import{c as p,a as _,i as g,b as S,d as h,e as y,u as w}from"./web.js";import{c as x}from"./CallStack.js";import{PropParser as v}from"./PropParser.js";import{n as N}from"./Reading.js";import"../web.js";class m{#t={};clear(){this.#t={}}static from(t){const s=new m;return s.#t={...t},s}val(){return{...this.#t}}search(t){return Object.entries(this.#t).some(([s,e])=>t>=parseInt(s)&&t<=e)}record(t){if(!this.search(t)){for(const[s,e]of Object.entries(this.#t))if(e+1===t){String(t+1)in this.#t?(this.#t[s]=this.#t[t+1],delete this.#t[t+1]):this.#t[s]=t;return}if(String(t+1)in this.#t){this.#t[t]=this.#t[t+1],delete this.#t[t+1];return}this.#t[t]=t}}erase(t){if(this.search(t)){if(String(t)in this.#t){this.#t[t]>t&&(this.#t[t+1]=this.#t[t]),delete this.#t[t];return}for(const[s,e]of Object.entries(this.#t))if(!(t<parseInt(s)||e<t)){if(this.#t[s]===t){this.#t[s]=t-1;return}this.#t[t+1]=e,this.#t[s]=t-1;return}}}get count(){return Object.keys(this.#t).length}toString(){let t="";for(const s of Object.keys(this.#t).map(e=>parseInt(e)).sort((e,i)=>e-i))t+=s===this.#t[s]?","+String(s):","+String(s)+"~"+String(this.#t[String(s)]);return t}}class u{constructor(t,s){this.cfg=t,s.let=e=>this.#n(e),s.let_abs=e=>this.#W(e),s.let_char_at=e=>this.#P(e),s.let_index_of=e=>this.#K(e),s.let_length=e=>this.#A(e),s.let_replace=e=>this.#L(e),s.let_round=e=>this.#F(e),s.let_search=e=>this.#D(e),s.let_substr=e=>this.#M(e),s.clearsysvar=()=>this.#f(),s.clearvar=()=>this.#R(),s.dump_val=()=>this.#I(),s.copybookmark=e=>this.#V(e),s.erasebookmark=e=>this.#j(e),this.defTmp("const.sn.bookmark.json",()=>{const e=[];for(const[i,n]of Object.entries(this.#s.mark)){const o={...n.json};o.place=w(i),e.push(o)}return JSON.stringify(e)}),this.#f(!0),this.#i["const.sn.config.window.width"]=t.oCfg.window.width,this.#i["const.sn.config.window.height"]=t.oCfg.window.height,this.#i["const.sn.config.book.title"]=t.oCfg.book.title,this.#i["const.sn.config.book.version"]=t.oCfg.book.version}#t=p();#i=_();#e={sys:{},save:this.#t,tmp:this.#i,mp:{},mark:{}};#r;#s={sys:{},mark:{},kidoku:{}};#o;#a={};#y;async setSys(t){this.#r=t,await t.initVal(this.#s,this.#i,s=>{this.updateData(s),this.cfg.oCfg.debug.variable?this.#C(t):this.#c=()=>t.flush(),this.#y=(i,n)=>t.callHook(i,n),t.addHook((i,n)=>this.#O[i]?.(i,n));const e=g(this.getVal("sys:sn.tagCh.msecWait",-1));(this.#i["const.sn.isFirstBoot"]||e===-1)&&this.#f(!0),this.#u=!!this.getVal("sys:sn.tagCh.doWait"),this.#k=!!this.getVal("sys:sn.tagCh.doWait_Kidoku"),this.#m=g(this.getVal("sys:sn.tagCh.msecWait")),this.#d=g(this.getVal("sys:sn.tagCh.msecWait_Kidoku")),this.#b()})}#C(t){sessionStorage.clear();const s=this.cfg.headNs;this.#c=()=>{const e=S();for(const[c,r]of Object.entries(this.#o))r instanceof Function||(e[c]=r);sessionStorage[s+"sys"]=JSON.stringify(e);const i=p();for(const[c,r]of Object.entries(this.#t))i[c]=r;sessionStorage[s+"save"]=JSON.stringify(i);const n=_();for(const[c,r]of Object.entries(this.#i))n[c]=r instanceof Function?r():r;sessionStorage[s+"tmp"]=JSON.stringify(n);const o=x();for(const[c,r]of Object.entries(this.#e.mp))o[c]=r;sessionStorage[s+"mp"]=JSON.stringify(o);const a={};for(const[c,r]of Object.entries(this.#s.mark))a[g(c)]=r instanceof Function?r():r;sessionStorage[s+"mark"]=JSON.stringify(a),sessionStorage[s+"kidoku"]=structuredClone(this.#s.kidoku),t.flush()}}#b(){N.playbackPage(String(this.getVal("sys:const.sn.aPageLog","[]")),String(this.getVal("save:const.sn.styPaging",N.INI_STYPAGE)))}#O={auth:(t,s)=>this.#_(s.hBreakpoint.aData),var:(t,s)=>this.#r.send2Dbg(s.ri,{v:this.#e[s.scope]??{}}),set_var:(t,s)=>{try{this.#w(s.nm,s.val),this.#r.send2Dbg(s.ri,{})}catch{}},set_data_break:(t,s)=>{this.#_(s.a),this.#r.send2Dbg(s.ri,{})},disconnect:t=>{u.#h={}}};#_(t){u.#h={};for(const s of t)u.#h[s.dataId]=1}updateData(t){this.#s=t,this.#o=this.#e.sys=this.#s.sys,this.#a={};for(const[s,e]of Object.entries(this.#s.kidoku))this.#a[s]=m.from(e)}#c=()=>{};flush(){this.#c()}setDoRecProc(t){this.#S=t}#S=t=>{};defTmp(t,s){this.#i[t]=s}cloneMp(){return{...this.#e.mp}}setMp(t){this.#e.mp=t}setMark(t,s){this.#s.mark[t]=s,this.flush()}getMark(t){const s=this.#s.mark[t];if(!s)throw`place【${String(t)}】は存在しません`;return s}cloneSave(){return{...this.#e.save}}mark2save(t){this.#t=this.#e.save={...t.hSave},this.#l=this.#t["sn.doRecLog"]}touchAreaKidoku(t){return this.#a[t]||(this.#s.kidoku[t]={},this.#a[t]=new m)}getAreaKidoku(t){const s=this.#a[t];if(!s)throw`hAreaKidoku${t}】は存在しません`;return s}saveKidoku(){for(const[t,s]of Object.entries(this.#a))this.#s.kidoku[t]=s.val();this.flush()}#V(t){const s=h(t,"from",NaN),e=h(t,"to",NaN);if(s===e)return!1;const i=this.#s.mark[s];if(!i)throw`from:${String(s)} のセーブデータは存在しません`;return this.setMark(e,{...i}),this.#r.copyBMFolder(s,e),!1}#j(t){const s=h(t,"place",NaN);return delete this.#s.mark[s],this.flush(),this.#r.eraseBMFolder(s),!1}#n(t){if(!t.name)throw"nameは必須です";let s=!0;if(t.cast)switch(t.cast){case"num":h(t,"text",NaN);break;case"int":t.text=String(g(h(t,"text",NaN)));break;case"uint":t.text=String(w(h(t,"text",NaN)));break;case"bool":y(t,"text",!1);break;case"str":s=!1;break;default:throw"cast【"+t.cast+"】は未定義です"}return this.#w(t.name,t.text,s),!1}#W(t){const s=h(t,"text",0);return t.text=String(s<0?-s:s),this.#n(t),!1}#P(t){return t.text=(t.text??"").charAt(h(t,"pos",0)),this.#n(t),!1}#K(t){const{val:s}=t;if(!s)throw"valは必須です";const e=h(t,"start",0);return t.text=String((t.text??"").indexOf(s,e)),this.#n(t),!1}#A(t){return t.text=String((t.text??"").length),this.#n(t),!1}#L(t){if(!t.reg)throw"regは必須です";const{flags:s}=t,e=s?new RegExp(t.reg,s):new RegExp(t.reg);return t.text=(t.text??"").replace(e,String(t.val)),this.#n(t),!1}#F(t){const s=h(t,"text",0);return t.text=String(Math.round(s)),this.#n(t),!1}#D(t){if(!t.reg)throw"regは必須です";const{flags:s}=t,e=s?new RegExp(t.reg,s):new RegExp(t.reg);return t.text=String((t.text??"").search(e)),this.#n(t),!1}#M(t){const s=h(t,"pos",0);return t.text=t.len!=="all"?(t.text??"").slice(s,s+g(h(t,"len",1))):(t.text??"").slice(s),this.#n(t),!1}#f(t=!1){const s=this.#o=this.#e.sys=this.#s.sys=S();typeof process<"u"||(this.setVal_Nochk("sys","const.sn.window.x",0),this.setVal_Nochk("sys","const.sn.window.y",0)),this.setVal_Nochk("sys","sn.tagCh.msecWait",this.cfg.oCfg.init.tagch_msecwait),this.setVal_Nochk("sys","sn.tagCh.msecWait_Kidoku",this.cfg.oCfg.init.tagch_msecwait),this.setVal_Nochk("sys","sn.auto.msecPageWait",h(s,"sn.auto.msecPageWait",this.cfg.oCfg.init.auto_msecpagewait)),this.setVal_Nochk("sys","sn.auto.msecPageWait_Kidoku",h(s,"sn.auto.msecPageWait",this.cfg.oCfg.init.auto_msecpagewait));for(const e of Object.values(this.#a))e.clear();return this.#e.mark=this.#s.mark={},t||this.#b(),this.flush(),!1}#R(){const t=this.#t["const.sn.mesLayer"],s=this.#t["sn.doRecLog"],e=this.#t["const.sn.sLog"],i=this.#t["const.sn.styPaging"];return this.#t=this.#e.save=p(),this.setVal_Nochk("save","const.sn.mesLayer",t),this.setVal_Nochk("save","sn.doRecLog",s),this.setVal_Nochk("save","const.sn.sLog",e),this.setVal_Nochk("save","const.sn.styPaging",i),!1}#w(t,s,e=!0){if(!t)throw"[変数に値セット] nameは必須です";if(s===void 0)throw"[変数に値セット] textは必須です（空文字はOK）";const i=v.getValName(t);if(!i)throw`[変数参照] name(${t})が変数名として異常です`;const n=this.#e[i.scope];if(!n)throw`[変数に値セット] scopeが異常【${String(i.scope)}】です`;const o=i.name;if(o.startsWith("const.")&&o in n)throw`[変数に値セット] 変数【${o}】は書き換え不可です`;this.setVal_Nochk(i.scope,o,s,e)}setVal_Nochk(t,s,e,i=!1){const n=this.#e[t],o=i?this.#g(e):e,a=t+":"+s;if(a in u.#h){const c=n[s],r=o;c!=r&&this.#y("data_break",{dataId:a,old_v:c,new_v:r})}n[s]=o,this.#v[a]?.(s,o??"")}static#h={};getVal(t,s,e=!1){if(!t)throw"[変数参照] nameは必須です";const i=v.getValName(t);if(!i)throw"[変数参照] name("+t+")が変数名として異常です";const n=this.#e[i.scope];if(!n)throw`[変数参照] scopeが異常【${String(i.scope)}】です`;const o=i.name;let a=n[o];if(!(o in n)){if(a=s,e)return n[o]=s,i.at==="@str"?a:this.#g(a);let c="";const r=o.split("."),k=r.length;for(let l=0;l<k;++l,c+="."){if(c+=r[l],!(c in n))continue;let f=JSON.parse(n[c]);if(Object.prototype.toString.call(f)!=="[object Object]"){if(l+1===k){a=f;break}continue}let d=l;for(;++d<k;){const b=r[d];if(!(b in f)){a=s;break}if(f=f[b],Object.prototype.toString.call(f)!=="[object Object]"||d+1===k){a=f;break}}a instanceof Object&&(a=JSON.stringify(a));break}}return a instanceof Function&&(a=a()),i.at==="@str"?a:this.#g(a)}#g(t){const s=t;if(s==="true")return!0;if(s==="false")return!1;if(s==="null")return null;if(s!=="undefined")return this.#T.test(s)?parseFloat(s):t}#T=/^-?[\d.]+$/;#I(){const t={tmp:{},sys:{},save:{},mp:{}};for(const s in t){const e=this.#e[s],i=t[s];for(const[n,o]of Object.entries(e))o instanceof Function||(i[n]=o)}return console.info("🥟 [dump_val]",t),!1}#l=!1;doRecLog(){return this.#l}#u=!1;get tagCh_doWait(){return this.#u}#k=!1;get tagCh_doWait_Kidoku(){return this.#k}#m=0;get tagCh_msecWait(){return this.#m}#d=0;get tagCh_msecWait_Kidoku(){return this.#d}#v={"sys:sn.tagCh.doWait":t=>{this.#u=this.#p(t)},"sys:sn.tagCh.doWait_Kidoku":t=>{this.#k=this.#p(t)},"sys:sn.tagCh.msecWait":t=>{this.#m=this.#J(t)},"sys:sn.tagCh.msecWait_Kidoku":t=>{this.#d=this.#$(t)},"sys:sn.tagCh.canskip":t=>this.#p(t),"sys:sn.auto.msecPageWait":t=>this.#N(t),"sys:sn.auto.msecPageWait_Kidoku":t=>this.#N(t),"sys:sn.auto.msecLineWait":t=>this.#x(t),"sys:sn.auto.msecLineWait_Kidoku":t=>this.#x(t),"save:sn.doRecLog":t=>{this.#S(this.#l=this.#E(t))},"save:sn.userFnTail":(t,s)=>{const e=String(s);if(e.includes("@"))throw"この変数では文字「@」は禁止です";this.cfg.userFnTail=e},"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode":()=>{}};defValTrg(t,s){this.#v[t]=s}#p=t=>y(this.#o,t,!0);#J=t=>h(this.#o,t,10);#$=t=>h(this.#o,t,this.cfg.oCfg.init.tagch_msecwait??10);#N=t=>h(this.#o,t,this.cfg.oCfg.init.auto_msecpagewait??3500);#x=t=>h(this.#o,t,500);#E(t){return y(this.#t,t,!0)}}export{u as Variable};
