"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel"],{

/***/ "./node_modules/@famibee/skynovel/dist/web.js":
/*!****************************************************!*\
  !*** ./node_modules/@famibee/skynovel/dist/web.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ CmnLib),\n/* harmony export */   \"Layer\": () => (/* binding */ Layer),\n/* harmony export */   \"SysWeb\": () => (/* binding */ SysWeb),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ argChk_Boolean),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ argChk_Num)\n/* harmony export */ });\nvar Ip = Object.defineProperty;\nvar Dp = (o, t, e) => t in o ? Ip(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;\nvar Rt = (o, t, e) => (Dp(o, typeof t != \"symbol\" ? t + \"\" : t, e), e), jc = (o, t, e) => {\n  if (!t.has(o))\n    throw TypeError(\"Cannot \" + e);\n};\nvar z = (o, t, e) => (jc(o, t, \"read from private field\"), e ? e.call(o) : t.get(o)), tt = (o, t, e) => {\n  if (t.has(o))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(o) : t.set(o, e);\n}, ot = (o, t, e, r) => (jc(o, t, \"write to private field\"), r ? r.call(o, e) : t.set(o, e), e), Me = (o, t, e, r) => ({\n  set _(S) {\n    ot(o, t, S, e);\n  },\n  get _() {\n    return z(o, t, r);\n  }\n}), lt = (o, t, e) => (jc(o, t, \"access private method\"), e);\nvar commonjsGlobal = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {}, platform$1 = { exports: {} };\n(function(o, t) {\n  (function() {\n    var e = {\n      function: !0,\n      object: !0\n    }, r = e[typeof window] && window || this, S = t, T = o && !o.nodeType && o, D = S && T && typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    D && (D.global === D || D.window === D || D.self === D) && (r = D);\n    var N = Math.pow(2, 53) - 1, B = /\\bOpera/, $ = Object.prototype, U = $.hasOwnProperty, V = $.toString;\n    function H(st) {\n      return st = String(st), st.charAt(0).toUpperCase() + st.slice(1);\n    }\n    function X(st, it, at) {\n      var ut = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      return it && at && /^Win/i.test(st) && !/^Windows Phone /i.test(st) && (ut = ut[/[\\d.]+$/.exec(st)]) && (st = \"Windows \" + ut), st = String(st), it && at && (st = st.replace(RegExp(it, \"i\"), at)), st = W(\n        st.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]\n      ), st;\n    }\n    function Y(st, it) {\n      var at = -1, ut = st ? st.length : 0;\n      if (typeof ut == \"number\" && ut > -1 && ut <= N)\n        for (; ++at < ut; )\n          it(st[at], at, st);\n      else\n        q(st, it);\n    }\n    function W(st) {\n      return st = rt(st), /^(?:webOS|i(?:OS|P))/.test(st) ? st : H(st);\n    }\n    function q(st, it) {\n      for (var at in st)\n        U.call(st, at) && it(st[at], at, st);\n    }\n    function K(st) {\n      return st == null ? H(st) : V.call(st).slice(8, -1);\n    }\n    function Z(st, it) {\n      var at = st != null ? typeof st[it] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(at) && (at == \"object\" ? !!st[it] : !0);\n    }\n    function J(st) {\n      return String(st).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function Q(st, it) {\n      var at = null;\n      return Y(st, function(ut, ct) {\n        at = it(at, ut, ct, st);\n      }), at;\n    }\n    function rt(st) {\n      return String(st).replace(/^ +| +$/g, \"\");\n    }\n    function et(st) {\n      var it = r, at = st && typeof st == \"object\" && K(st) != \"String\";\n      at && (it = st, st = null);\n      var ut = it.navigator || {}, ct = ut.userAgent || \"\";\n      st || (st = ct);\n      var gt = at ? !!ut.likeChrome : /\\bChrome\\b/.test(st) && !/internal|\\n/i.test(V.toString()), _t = \"Object\", vt = at ? _t : \"ScriptBridgingProxyObject\", mt = at ? _t : \"Environment\", bt = at && it.java ? \"JavaPackage\" : K(it.java), Ct = at ? _t : \"RuntimeObject\", St = /\\bJava/.test(bt) && it.java, pt = St && K(it.environment) == mt, yt = St ? \"a\" : \"α\", At = St ? \"b\" : \"β\", Dt = it.document || {}, Ot = it.operamini || it.opera, Pt = B.test(Pt = at && Ot ? Ot[\"[[Class]]\"] : K(Ot)) ? Pt : Ot = null, ft, Ft = st, It = [], zt = null, kt = st == ct, Tt = kt && Ot && typeof Ot.version == \"function\" && Ot.version(), jt, Nt = Wt([\n        { label: \"EdgeHTML\", pattern: \"Edge\" },\n        \"Trident\",\n        { label: \"WebKit\", pattern: \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]), Et = Jt([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { label: \"Microsoft Edge\", pattern: \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { label: \"Samsung Internet\", pattern: \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { label: \"Silk\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { label: \"SRWare Iron\", pattern: \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { label: \"Yandex Browser\", pattern: \"YaBrowser\" },\n        { label: \"UC Browser\", pattern: \"UCBrowser\" },\n        \"Opera Mini\",\n        { label: \"Opera Mini\", pattern: \"OPiOS\" },\n        \"Opera\",\n        { label: \"Opera\", pattern: \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { label: \"Chrome\", pattern: \"(?:HeadlessChrome)\" },\n        { label: \"Chrome Mobile\", pattern: \"(?:CriOS|CrMo)\" },\n        { label: \"Firefox\", pattern: \"(?:Firefox|Minefield)\" },\n        { label: \"Firefox for iOS\", pattern: \"FxiOS\" },\n        { label: \"IE\", pattern: \"IEMobile\" },\n        { label: \"IE\", pattern: \"MSIE\" },\n        \"Safari\"\n      ]), Lt = ke([\n        { label: \"BlackBerry\", pattern: \"BB10\" },\n        \"BlackBerry\",\n        { label: \"Galaxy S\", pattern: \"GT-I9000\" },\n        { label: \"Galaxy S2\", pattern: \"GT-I9100\" },\n        { label: \"Galaxy S3\", pattern: \"GT-I9300\" },\n        { label: \"Galaxy S4\", pattern: \"GT-I9500\" },\n        { label: \"Galaxy S5\", pattern: \"SM-G900\" },\n        { label: \"Galaxy S6\", pattern: \"SM-G920\" },\n        { label: \"Galaxy S6 Edge\", pattern: \"SM-G925\" },\n        { label: \"Galaxy S7\", pattern: \"SM-G930\" },\n        { label: \"Galaxy S7 Edge\", pattern: \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { label: \"Kindle Fire\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { label: \"Wii U\", pattern: \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { label: \"Xbox 360\", pattern: \"Xbox\" },\n        \"Xoom\"\n      ]), Ht = ee({\n        Apple: { iPad: 1, iPhone: 1, iPod: 1 },\n        Alcatel: {},\n        Archos: {},\n        Amazon: { Kindle: 1, \"Kindle Fire\": 1 },\n        Asus: { Transformer: 1 },\n        \"Barnes & Noble\": { Nook: 1 },\n        BlackBerry: { PlayBook: 1 },\n        Google: { \"Google TV\": 1, Nexus: 1 },\n        HP: { TouchPad: 1 },\n        HTC: {},\n        Huawei: {},\n        Lenovo: {},\n        LG: {},\n        Microsoft: { Xbox: 1, \"Xbox One\": 1 },\n        Motorola: { Xoom: 1 },\n        Nintendo: { \"Wii U\": 1, Wii: 1 },\n        Nokia: { Lumia: 1 },\n        Oppo: {},\n        Samsung: { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        Sony: { PlayStation: 1, \"PlayStation Vita\": 1 },\n        Xiaomi: { Mi: 1, Redmi: 1 }\n      }), wt = xe([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { label: \"Chrome OS\", pattern: \"CrOS\" },\n        \"Debian\",\n        { label: \"DragonFly BSD\", pattern: \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function Wt(fe) {\n        return Q(fe, function(ce, ie) {\n          return ce || RegExp(\"\\\\b\" + (ie.pattern || J(ie)) + \"\\\\b\", \"i\").exec(st) && (ie.label || ie);\n        });\n      }\n      function ee(fe) {\n        return Q(fe, function(ce, ie, ze) {\n          return ce || (ie[Lt] || ie[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(Lt)] || RegExp(\"\\\\b\" + J(ze) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(st)) && ze;\n        });\n      }\n      function Jt(fe) {\n        return Q(fe, function(ce, ie) {\n          return ce || RegExp(\"\\\\b\" + (ie.pattern || J(ie)) + \"\\\\b\", \"i\").exec(st) && (ie.label || ie);\n        });\n      }\n      function xe(fe) {\n        return Q(fe, function(ce, ie) {\n          var ze = ie.pattern || J(ie);\n          return !ce && (ce = RegExp(\"\\\\b\" + ze + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(st)) && (ce = X(ce, ze, ie.label || ie)), ce;\n        });\n      }\n      function ke(fe) {\n        return Q(fe, function(ce, ie) {\n          var ze = ie.pattern || J(ie);\n          return !ce && (ce = RegExp(\"\\\\b\" + ze + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(st) || RegExp(\"\\\\b\" + ze + \" *\\\\w+-[\\\\w]*\", \"i\").exec(st) || RegExp(\"\\\\b\" + ze + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(st)) && ((ce = String(ie.label && !RegExp(ze, \"i\").test(ie.label) ? ie.label : ce).split(\"/\"))[1] && !/[\\d.]+/.test(ce[0]) && (ce[0] += \" \" + ce[1]), ie = ie.label || ie, ce = W(ce[0].replace(RegExp(ze, \"i\"), ie).replace(RegExp(\"; *(?:\" + ie + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + ie + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"))), ce;\n        });\n      }\n      function ue(fe) {\n        return Q(fe, function(ce, ie) {\n          return ce || (RegExp(ie + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(st) || 0)[1] || null;\n        });\n      }\n      function me() {\n        return this.description || \"\";\n      }\n      if (Nt && (Nt = [Nt]), /\\bAndroid\\b/.test(wt) && !Lt && (ft = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(st)) && (Lt = rt(ft[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null), Ht && !Lt ? Lt = ke([Ht]) : Ht && Lt && (Lt = Lt.replace(RegExp(\"^(\" + J(Ht) + \")[-_.\\\\s]\", \"i\"), Ht + \" \").replace(RegExp(\"^(\" + J(Ht) + \")[-_.]?(\\\\w)\", \"i\"), Ht + \" $2\")), (ft = /\\bGoogle TV\\b/.exec(Lt)) && (Lt = ft[0]), /\\bSimulator\\b/i.test(st) && (Lt = (Lt ? Lt + \" \" : \"\") + \"Simulator\"), Et == \"Opera Mini\" && /\\bOPiOS\\b/.test(st) && It.push(\"running in Turbo/Uncompressed mode\"), Et == \"IE\" && /\\blike iPhone OS\\b/.test(st) ? (ft = et(st.replace(/like iPhone OS/, \"\")), Ht = ft.manufacturer, Lt = ft.product) : /^iP/.test(Lt) ? (Et || (Et = \"Safari\"), wt = \"iOS\" + ((ft = / OS ([\\d_]+)/i.exec(st)) ? \" \" + ft[1].replace(/_/g, \".\") : \"\")) : Et == \"Konqueror\" && /^Linux\\b/i.test(wt) ? wt = \"Kubuntu\" : Ht && Ht != \"Google\" && (/Chrome/.test(Et) && !/\\bMobile Safari\\b/i.test(st) || /\\bVita\\b/.test(Lt)) || /\\bAndroid\\b/.test(wt) && /^Chrome/.test(Et) && /\\bVersion\\//i.test(st) ? (Et = \"Android Browser\", wt = /\\bAndroid\\b/.test(wt) ? wt : \"Android\") : Et == \"Silk\" ? (/\\bMobi/i.test(st) || (wt = \"Android\", It.unshift(\"desktop mode\")), /Accelerated *= *true/i.test(st) && It.unshift(\"accelerated\")) : Et == \"UC Browser\" && /\\bUCWEB\\b/.test(st) ? It.push(\"speed mode\") : Et == \"PaleMoon\" && (ft = /\\bFirefox\\/([\\d.]+)\\b/.exec(st)) ? It.push(\"identifying as Firefox \" + ft[1]) : Et == \"Firefox\" && (ft = /\\b(Mobile|Tablet|TV)\\b/i.exec(st)) ? (wt || (wt = \"Firefox OS\"), Lt || (Lt = ft[1])) : !Et || (ft = !/\\bMinefield\\b/i.test(st) && /\\b(?:Firefox|Safari)\\b/.exec(Et)) ? (Et && !Lt && /[\\/,]|^[^(]+?\\)/.test(st.slice(st.indexOf(ft + \"/\") + 8)) && (Et = null), (ft = Lt || Ht || wt) && (Lt || Ht || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(wt)) && (Et = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(wt) ? wt : ft) + \" Browser\")) : Et == \"Electron\" && (ft = (/\\bChrome\\/([\\d.]+)\\b/.exec(st) || 0)[1]) && It.push(\"Chromium \" + ft), Tt || (Tt = ue([\n        \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n        \"Version\",\n        J(Et),\n        \"(?:Firefox|Minefield|NetFront)\"\n      ])), (ft = Nt == \"iCab\" && parseFloat(Tt) > 3 && \"WebKit\" || /\\bOpera\\b/.test(Et) && (/\\bOPR\\b/.test(st) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(st) && !/^(?:Trident|EdgeHTML)$/.test(Nt) && \"WebKit\" || !Nt && /\\bMSIE\\b/i.test(st) && (wt == \"Mac OS\" ? \"Tasman\" : \"Trident\") || Nt == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(Et) && \"NetFront\") && (Nt = [ft]), Et == \"IE\" && (ft = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(st) || 0)[1]) ? (Et += \" Mobile\", wt = \"Windows Phone \" + (/\\+$/.test(ft) ? ft : ft + \".x\"), It.unshift(\"desktop mode\")) : /\\bWPDesktop\\b/i.test(st) ? (Et = \"IE Mobile\", wt = \"Windows Phone 8.x\", It.unshift(\"desktop mode\"), Tt || (Tt = (/\\brv:([\\d.]+)/.exec(st) || 0)[1])) : Et != \"IE\" && Nt == \"Trident\" && (ft = /\\brv:([\\d.]+)/.exec(st)) && (Et && It.push(\"identifying as \" + Et + (Tt ? \" \" + Tt : \"\")), Et = \"IE\", Tt = ft[1]), kt) {\n        if (Z(it, \"global\"))\n          if (St && (ft = St.lang.System, Ft = ft.getProperty(\"os.arch\"), wt = wt || ft.getProperty(\"os.name\") + \" \" + ft.getProperty(\"os.version\")), pt) {\n            try {\n              Tt = it.require(\"ringo/engine\").version.join(\".\"), Et = \"RingoJS\";\n            } catch {\n              (ft = it.system) && ft.global.system == it.system && (Et = \"Narwhal\", wt || (wt = ft[0].os || null));\n            }\n            Et || (Et = \"Rhino\");\n          } else\n            typeof it.process == \"object\" && !it.process.browser && (ft = it.process) && (typeof ft.versions == \"object\" && (typeof ft.versions.electron == \"string\" ? (It.push(\"Node \" + ft.versions.node), Et = \"Electron\", Tt = ft.versions.electron) : typeof ft.versions.nw == \"string\" && (It.push(\"Chromium \" + Tt, \"Node \" + ft.versions.node), Et = \"NW.js\", Tt = ft.versions.nw)), Et || (Et = \"Node.js\", Ft = ft.arch, wt = ft.platform, Tt = /[\\d.]+/.exec(ft.version), Tt = Tt ? Tt[0] : null));\n        else\n          K(ft = it.runtime) == vt ? (Et = \"Adobe AIR\", wt = ft.flash.system.Capabilities.os) : K(ft = it.phantom) == Ct ? (Et = \"PhantomJS\", Tt = (ft = ft.version || null) && ft.major + \".\" + ft.minor + \".\" + ft.patch) : typeof Dt.documentMode == \"number\" && (ft = /\\bTrident\\/(\\d+)/i.exec(st)) ? (Tt = [Tt, Dt.documentMode], (ft = +ft[1] + 4) != Tt[1] && (It.push(\"IE \" + Tt[1] + \" mode\"), Nt && (Nt[1] = \"\"), Tt[1] = ft), Tt = Et == \"IE\" ? String(Tt[1].toFixed(1)) : Tt[0]) : typeof Dt.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(Et) && (It.push(\"masking as \" + Et + \" \" + Tt), Et = \"IE\", Tt = \"11.0\", Nt = [\"Trident\"], wt = \"Windows\");\n        wt = wt && W(wt);\n      }\n      if (Tt && (ft = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(Tt) || /(?:alpha|beta)(?: ?\\d)?/i.exec(st + \";\" + (kt && ut.appMinorVersion)) || /\\bMinefield\\b/i.test(st) && \"a\") && (zt = /b/i.test(ft) ? \"beta\" : \"alpha\", Tt = Tt.replace(RegExp(ft + \"\\\\+?$\"), \"\") + (zt == \"beta\" ? At : yt) + (/\\d+\\+?/.exec(ft) || \"\")), Et == \"Fennec\" || Et == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(wt))\n        Et = \"Firefox Mobile\";\n      else if (Et == \"Maxthon\" && Tt)\n        Tt = Tt.replace(/\\.[\\d.]+/, \".x\");\n      else if (/\\bXbox\\b/i.test(Lt))\n        Lt == \"Xbox 360\" && (wt = null), Lt == \"Xbox 360\" && /\\bIEMobile\\b/.test(st) && It.unshift(\"mobile mode\");\n      else if ((/^(?:Chrome|IE|Opera)$/.test(Et) || Et && !Lt && !/Browser|Mobi/.test(Et)) && (wt == \"Windows CE\" || /Mobi/i.test(st)))\n        Et += \" Mobile\";\n      else if (Et == \"IE\" && kt)\n        try {\n          it.external === null && It.unshift(\"platform preview\");\n        } catch {\n          It.unshift(\"embedded\");\n        }\n      else\n        (/\\bBlackBerry\\b/.test(Lt) || /\\bBB10\\b/.test(st)) && (ft = (RegExp(Lt.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(st) || 0)[1] || Tt) ? (ft = [ft, /BB10/.test(st)], wt = (ft[1] ? (Lt = null, Ht = \"BlackBerry\") : \"Device Software\") + \" \" + ft[0], Tt = null) : this != q && Lt != \"Wii\" && (kt && Ot || /Opera/.test(Et) && /\\b(?:MSIE|Firefox)\\b/i.test(st) || Et == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(wt) || Et == \"IE\" && (wt && !/^Win/.test(wt) && Tt > 5.5 || /\\bWindows XP\\b/.test(wt) && Tt > 8 || Tt == 8 && !/\\bTrident\\b/.test(st))) && !B.test(ft = et.call(q, st.replace(B, \"\") + \";\")) && ft.name && (ft = \"ing as \" + ft.name + ((ft = ft.version) ? \" \" + ft : \"\"), B.test(Et) ? (/\\bIE\\b/.test(ft) && wt == \"Mac OS\" && (wt = null), ft = \"identify\" + ft) : (ft = \"mask\" + ft, Pt ? Et = W(Pt.replace(/([a-z])([A-Z])/g, \"$1 $2\")) : Et = \"Opera\", /\\bIE\\b/.test(ft) && (wt = null), kt || (Tt = null)), Nt = [\"Presto\"], It.push(ft));\n      (ft = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(st) || 0)[1]) && (ft = [parseFloat(ft.replace(/\\.(\\d)$/, \".0$1\")), ft], Et == \"Safari\" && ft[1].slice(-1) == \"+\" ? (Et = \"WebKit Nightly\", zt = \"alpha\", Tt = ft[1].slice(0, -1)) : (Tt == ft[1] || Tt == (ft[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(st) || 0)[1])) && (Tt = null), ft[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(st) || 0)[1], ft[0] == 537.36 && ft[2] == 537.36 && parseFloat(ft[1]) >= 28 && Nt == \"WebKit\" && (Nt = [\"Blink\"]), !kt || !gt && !ft[1] ? (Nt && (Nt[1] = \"like Safari\"), ft = (ft = ft[0], ft < 400 ? 1 : ft < 500 ? 2 : ft < 526 ? 3 : ft < 533 ? 4 : ft < 534 ? \"4+\" : ft < 535 ? 5 : ft < 537 ? 6 : ft < 538 ? 7 : ft < 601 ? 8 : ft < 602 ? 9 : ft < 604 ? 10 : ft < 606 ? 11 : ft < 608 ? 12 : \"12\")) : (Nt && (Nt[1] = \"like Chrome\"), ft = ft[1] || (ft = ft[0], ft < 530 ? 1 : ft < 532 ? 2 : ft < 532.05 ? 3 : ft < 533 ? 4 : ft < 534.03 ? 5 : ft < 534.07 ? 6 : ft < 534.1 ? 7 : ft < 534.13 ? 8 : ft < 534.16 ? 9 : ft < 534.24 ? 10 : ft < 534.3 ? 11 : ft < 535.01 ? 12 : ft < 535.02 ? \"13+\" : ft < 535.07 ? 15 : ft < 535.11 ? 16 : ft < 535.19 ? 17 : ft < 536.05 ? 18 : ft < 536.1 ? 19 : ft < 537.01 ? 20 : ft < 537.11 ? \"21+\" : ft < 537.13 ? 23 : ft < 537.18 ? 24 : ft < 537.24 ? 25 : ft < 537.36 ? 26 : Nt != \"Blink\" ? \"27\" : \"28\")), Nt && (Nt[1] += \" \" + (ft += typeof ft == \"number\" ? \".x\" : /[.+]/.test(ft) ? \"\" : \"+\")), Et == \"Safari\" && (!Tt || parseInt(Tt) > 45) ? Tt = ft : Et == \"Chrome\" && /\\bHeadlessChrome/i.test(st) && It.unshift(\"headless\")), Et == \"Opera\" && (ft = /\\bzbov|zvav$/.exec(wt)) ? (Et += \" \", It.unshift(\"desktop mode\"), ft == \"zvav\" ? (Et += \"Mini\", Tt = null) : Et += \"Mobile\", wt = wt.replace(RegExp(\" *\" + ft + \"$\"), \"\")) : Et == \"Safari\" && /\\bChrome\\b/.exec(Nt && Nt[1]) ? (It.unshift(\"desktop mode\"), Et = \"Chrome Mobile\", Tt = null, /\\bOS X\\b/.test(wt) ? (Ht = \"Apple\", wt = \"iOS 4.3+\") : wt = null) : /\\bSRWare Iron\\b/.test(Et) && !Tt && (Tt = ue(\"Chrome\")), Tt && Tt.indexOf(ft = /[\\d.]+$/.exec(wt)) == 0 && st.indexOf(\"/\" + ft + \"-\") > -1 && (wt = rt(wt.replace(ft, \"\"))), wt && wt.indexOf(Et) != -1 && !RegExp(Et + \" OS\").test(wt) && (wt = wt.replace(RegExp(\" *\" + J(Et) + \" *\"), \"\")), Nt && !/\\b(?:Avant|Nook)\\b/.test(Et) && (/Browser|Lunascape|Maxthon/.test(Et) || Et != \"Safari\" && /^iOS/.test(wt) && /\\bSafari\\b/.test(Nt[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(Et) && Nt[1]) && (ft = Nt[Nt.length - 1]) && It.push(ft), It.length && (It = [\"(\" + It.join(\"; \") + \")\"]), Ht && Lt && Lt.indexOf(Ht) < 0 && It.push(\"on \" + Ht), Lt && It.push((/^on /.test(It[It.length - 1]) ? \"\" : \"on \") + Lt), wt && (ft = / ([\\d.+]+)$/.exec(wt), jt = ft && wt.charAt(wt.length - ft[0].length - 1) == \"/\", wt = {\n        architecture: 32,\n        family: ft && !jt ? wt.replace(ft[0], \"\") : wt,\n        version: ft ? ft[1] : null,\n        toString: function() {\n          var fe = this.version;\n          return this.family + (fe && !jt ? \" \" + fe : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n        }\n      }), (ft = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec(Ft)) && !/\\bi686\\b/i.test(Ft) ? (wt && (wt.architecture = 64, wt.family = wt.family.replace(RegExp(\" *\" + ft), \"\")), Et && (/\\bWOW64\\b/i.test(st) || kt && /\\w(?:86|32)$/.test(ut.cpuClass || ut.platform) && !/\\bWin64; x64\\b/i.test(st)) && It.unshift(\"32-bit\")) : wt && /^OS X/.test(wt.family) && Et == \"Chrome\" && parseFloat(Tt) >= 39 && (wt.architecture = 64), st || (st = null);\n      var pe = {};\n      return pe.description = st, pe.layout = Nt && Nt[0], pe.manufacturer = Ht, pe.name = Et, pe.prerelease = zt, pe.product = Lt, pe.ua = st, pe.version = Et && Tt, pe.os = wt || {\n        architecture: null,\n        family: null,\n        version: null,\n        toString: function() {\n          return \"null\";\n        }\n      }, pe.parse = et, pe.toString = me, pe.version && It.unshift(Tt), pe.name && It.unshift(Et), wt && Et && !(wt == String(wt).split(\" \")[0] && (wt == Et.split(\" \")[0] || Lt)) && It.push(Lt ? \"(\" + wt + \")\" : \"on \" + wt), It.length && (pe.description = It.join(\" \")), pe;\n    }\n    var nt = et();\n    S && T ? q(nt, function(st, it) {\n      S[it] = st;\n    }) : r.platform = nt;\n  }).call(commonjsGlobal);\n})(platform$1, platform$1.exports);\nconst platform = platform$1.exports;\nfunction int(o) {\n  return parseInt(String(o), 10);\n}\nfunction uint(o) {\n  const t = parseInt(String(o), 10);\n  return t < 0 ? -t : t;\n}\n\"toInt\" in String.prototype || (String.prototype.toInt = function() {\n  return int(this);\n});\n\"toUint\" in String.prototype || (String.prototype.toUint = function() {\n  const o = int(this);\n  return o < 0 ? -o : o;\n});\nfunction getDateStr(o = \"/\", t = \" \", e = \":\", r = \"\") {\n  const S = new Date();\n  return S.getFullYear() + o + String(100 + S.getMonth() + 1).slice(1, 3) + o + String(100 + S.getDate()).slice(1, 3) + t + String(100 + S.getHours()).slice(1, 3) + e + String(100 + S.getMinutes()).slice(1, 3) + (r === \"\" ? \"\" : r + String(S.getMilliseconds()));\n}\nconst hMemberCnt = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction cnvTweenArg(o, t) {\n  const e = {};\n  for (const r of Object.keys(hMemberCnt)) {\n    if (!(r in o))\n      continue;\n    const S = String(o[r]), T = (S.at(0) === \"=\" ? S.slice(1) : S).split(\",\"), D = e[r] = parseFloat(T[0]);\n    T.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(T[1]) - D + 1))), S.at(0) === \"=\" && (e[r] += parseFloat(t[r]));\n  }\n  return e;\n}\nconst css_key4del = \"/* SKYNovel */\";\nfunction initStyle() {\n  const o = document.getElementsByTagName(\"head\")[0], t = o.children.length;\n  for (let e = t - 1; e >= 0; --e) {\n    const r = o.children[e];\n    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === css_key4del && o.removeChild(r);\n  }\n}\nfunction addStyle(o) {\n  const t = document.createElement(\"style\");\n  t.innerHTML = css_key4del + o, document.getElementsByTagName(\"head\")[0].appendChild(t);\n}\nfunction argChk_Num(o, t, e) {\n  const r = o[t];\n  if (!(t in o)) {\n    if (isNaN(e))\n      throw `[${o[\":タグ名\"]}]属性 ${t} は必須です`;\n    return o[t] = e, e;\n  }\n  const S = String(r).slice(0, 2) === \"0x\" ? parseInt(r) : parseFloat(r);\n  if (isNaN(S))\n    throw `[${o[\":タグ名\"]}]属性 ${t} の値【${r}】が数値ではありません`;\n  return o[t] = S;\n}\nfunction argChk_Boolean(o, t, e) {\n  if (!(t in o))\n    return o[t] = e;\n  const r = o[t];\n  if (r === null)\n    return !1;\n  const S = String(r);\n  return o[t] = S === \"false\" ? !1 : Boolean(S);\n}\nfunction parseColor(o) {\n  if (o.at(0) === \"#\")\n    return parseInt(o.slice(1), 16);\n  const t = Number(o);\n  if (!isNaN(t))\n    return t;\n  if (o === \"black\")\n    return 0;\n  CmnLib.cc4ColorName.fillStyle = o;\n  const e = CmnLib.cc4ColorName.fillStyle;\n  if (e === \"#000000\")\n    throw `色名前 ${o} が異常です`;\n  return parseInt(e.slice(1), 16);\n}\nfunction argChk_Color(o, t, e) {\n  const r = o[t];\n  return r ? o[t] = parseColor(String(r)) : o[t] = e;\n}\nconst REG_ERRMES_JSON = /JSON at position (\\d+)$/;\nfunction mesErrJSON(o, t = \"\", e = \"\") {\n  const r = (e.match(REG_ERRMES_JSON) ?? [\"\", \"\"])[1];\n  return `[${o[\":タグ名\"]}] ${t} 属性の解析エラー : ${e}\n${o[t]}${r ? `\n${\"^\".padStart(Number(r))}` : \"\"}`;\n}\nconst REG_FN = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction getFn(o) {\n  return (o.match(REG_FN) ?? [\"\"])[0];\n}\nconst REG_EXT = /\\.([^\\.]+)$/;\nfunction getExt(o) {\n  return (o.match(REG_EXT) ?? [\"\", \"\"])[1];\n}\nvar Nf, Lf;\nclass CmnLib {\n}\nRt(CmnLib, \"stageW\", 0), Rt(CmnLib, \"stageH\", 0), Rt(CmnLib, \"debugLog\", !1), Rt(CmnLib, \"isSafari\", platform$1.exports.name === \"Safari\"), Rt(CmnLib, \"isFirefox\", platform$1.exports.name === \"Firefox\"), Rt(CmnLib, \"isMac\", new RegExp(\"OS X\").test(((Nf = platform$1.exports.os) == null ? void 0 : Nf.family) ?? \"\")), Rt(CmnLib, \"isMobile\", !new RegExp(\"(Windows|OS X)\").test(((Lf = platform$1.exports.os) == null ? void 0 : Lf.family) ?? \"\")), Rt(CmnLib, \"hDip\", {}), Rt(CmnLib, \"isDbg\", !1), Rt(CmnLib, \"isPackaged\", !1), Rt(CmnLib, \"isDarkMode\", !1), Rt(CmnLib, \"cc4ColorName\");\nfunction finallyConstructor(o) {\n  var t = this.constructor;\n  return this.then(\n    function(e) {\n      return t.resolve(o()).then(function() {\n        return e;\n      });\n    },\n    function(e) {\n      return t.resolve(o()).then(function() {\n        return t.reject(e);\n      });\n    }\n  );\n}\nfunction allSettled(o) {\n  var t = this;\n  return new t(function(e, r) {\n    if (!(o && typeof o.length < \"u\"))\n      return r(\n        new TypeError(\n          typeof o + \" \" + o + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"\n        )\n      );\n    var S = Array.prototype.slice.call(o);\n    if (S.length === 0)\n      return e([]);\n    var T = S.length;\n    function D(B, $) {\n      if ($ && (typeof $ == \"object\" || typeof $ == \"function\")) {\n        var U = $.then;\n        if (typeof U == \"function\") {\n          U.call(\n            $,\n            function(V) {\n              D(B, V);\n            },\n            function(V) {\n              S[B] = { status: \"rejected\", reason: V }, --T === 0 && e(S);\n            }\n          );\n          return;\n        }\n      }\n      S[B] = { status: \"fulfilled\", value: $ }, --T === 0 && e(S);\n    }\n    for (var N = 0; N < S.length; N++)\n      D(N, S[N]);\n  });\n}\nvar setTimeoutFunc = setTimeout;\nfunction isArray$1(o) {\n  return Boolean(o && typeof o.length < \"u\");\n}\nfunction noop() {\n}\nfunction bind$2(o, t) {\n  return function() {\n    o.apply(t, arguments);\n  };\n}\nfunction Promise$1(o) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof o != \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(o, this);\n}\nfunction handle(o, t) {\n  for (; o._state === 3; )\n    o = o._value;\n  if (o._state === 0) {\n    o._deferreds.push(t);\n    return;\n  }\n  o._handled = !0, Promise$1._immediateFn(function() {\n    var e = o._state === 1 ? t.onFulfilled : t.onRejected;\n    if (e === null) {\n      (o._state === 1 ? resolve$1 : reject)(t.promise, o._value);\n      return;\n    }\n    var r;\n    try {\n      r = e(o._value);\n    } catch (S) {\n      reject(t.promise, S);\n      return;\n    }\n    resolve$1(t.promise, r);\n  });\n}\nfunction resolve$1(o, t) {\n  try {\n    if (t === o)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (t && (typeof t == \"object\" || typeof t == \"function\")) {\n      var e = t.then;\n      if (t instanceof Promise$1) {\n        o._state = 3, o._value = t, finale(o);\n        return;\n      } else if (typeof e == \"function\") {\n        doResolve(bind$2(e, t), o);\n        return;\n      }\n    }\n    o._state = 1, o._value = t, finale(o);\n  } catch (r) {\n    reject(o, r);\n  }\n}\nfunction reject(o, t) {\n  o._state = 2, o._value = t, finale(o);\n}\nfunction finale(o) {\n  o._state === 2 && o._deferreds.length === 0 && Promise$1._immediateFn(function() {\n    o._handled || Promise$1._unhandledRejectionFn(o._value);\n  });\n  for (var t = 0, e = o._deferreds.length; t < e; t++)\n    handle(o, o._deferreds[t]);\n  o._deferreds = null;\n}\nfunction Handler(o, t, e) {\n  this.onFulfilled = typeof o == \"function\" ? o : null, this.onRejected = typeof t == \"function\" ? t : null, this.promise = e;\n}\nfunction doResolve(o, t) {\n  var e = !1;\n  try {\n    o(\n      function(r) {\n        e || (e = !0, resolve$1(t, r));\n      },\n      function(r) {\n        e || (e = !0, reject(t, r));\n      }\n    );\n  } catch (r) {\n    if (e)\n      return;\n    e = !0, reject(t, r);\n  }\n}\nPromise$1.prototype.catch = function(o) {\n  return this.then(null, o);\n};\nPromise$1.prototype.then = function(o, t) {\n  var e = new this.constructor(noop);\n  return handle(this, new Handler(o, t, e)), e;\n};\nPromise$1.prototype.finally = finallyConstructor;\nPromise$1.all = function(o) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(o))\n      return e(new TypeError(\"Promise.all accepts an array\"));\n    var r = Array.prototype.slice.call(o);\n    if (r.length === 0)\n      return t([]);\n    var S = r.length;\n    function T(N, B) {\n      try {\n        if (B && (typeof B == \"object\" || typeof B == \"function\")) {\n          var $ = B.then;\n          if (typeof $ == \"function\") {\n            $.call(\n              B,\n              function(U) {\n                T(N, U);\n              },\n              e\n            );\n            return;\n          }\n        }\n        r[N] = B, --S === 0 && t(r);\n      } catch (U) {\n        e(U);\n      }\n    }\n    for (var D = 0; D < r.length; D++)\n      T(D, r[D]);\n  });\n};\nPromise$1.allSettled = allSettled;\nPromise$1.resolve = function(o) {\n  return o && typeof o == \"object\" && o.constructor === Promise$1 ? o : new Promise$1(function(t) {\n    t(o);\n  });\n};\nPromise$1.reject = function(o) {\n  return new Promise$1(function(t, e) {\n    e(o);\n  });\n};\nPromise$1.race = function(o) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(o))\n      return e(new TypeError(\"Promise.race accepts an array\"));\n    for (var r = 0, S = o.length; r < S; r++)\n      Promise$1.resolve(o[r]).then(t, e);\n  });\n};\nPromise$1._immediateFn = typeof setImmediate == \"function\" && function(o) {\n  setImmediate(o);\n} || function(o) {\n  setTimeoutFunc(o, 0);\n};\nPromise$1._unhandledRejectionFn = function(t) {\n  typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", t);\n};\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(o) {\n  if (o == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(o);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var o = new String(\"abc\");\n    if (o[5] = \"de\", Object.getOwnPropertyNames(o)[0] === \"5\")\n      return !1;\n    for (var t = {}, e = 0; e < 10; e++)\n      t[\"_\" + String.fromCharCode(e)] = e;\n    var r = Object.getOwnPropertyNames(t).map(function(T) {\n      return t[T];\n    });\n    if (r.join(\"\") !== \"0123456789\")\n      return !1;\n    var S = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(T) {\n      S[T] = T;\n    }), Object.keys(Object.assign({}, S)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(o, t) {\n  for (var e, r = toObject(o), S, T = 1; T < arguments.length; T++) {\n    e = Object(arguments[T]);\n    for (var D in e)\n      hasOwnProperty$1.call(e, D) && (r[D] = e[D]);\n    if (getOwnPropertySymbols) {\n      S = getOwnPropertySymbols(e);\n      for (var N = 0; N < S.length; N++)\n        propIsEnumerable.call(e, S[N]) && (r[S[N]] = e[S[N]]);\n    }\n  }\n  return r;\n};\ntypeof globalThis > \"u\" && (typeof self < \"u\" ? self.globalThis = self : typeof __webpack_require__.g < \"u\" && (__webpack_require__.g.globalThis = __webpack_require__.g));\nglobalThis.Promise || (globalThis.Promise = Promise$1);\nObject.assign || (Object.assign = objectAssign);\nvar ONE_FRAME_TIME = 16;\nDate.now && Date.prototype.getTime || (Date.now = function() {\n  return new Date().getTime();\n});\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var startTime_1 = Date.now();\n  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {\n    return Date.now() - startTime_1;\n  };\n}\nvar lastTime = Date.now(), vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {\n  var p$1 = vendors[x$1];\n  globalThis.requestAnimationFrame = globalThis[p$1 + \"RequestAnimationFrame\"], globalThis.cancelAnimationFrame = globalThis[p$1 + \"CancelAnimationFrame\"] || globalThis[p$1 + \"CancelRequestAnimationFrame\"];\n}\nglobalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(o) {\n  if (typeof o != \"function\")\n    throw new TypeError(o + \"is not a function\");\n  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;\n  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {\n    lastTime = Date.now(), o(performance.now());\n  }, e);\n});\nglobalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(o) {\n  return clearTimeout(o);\n});\nMath.sign || (Math.sign = function(t) {\n  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;\n});\nNumber.isInteger || (Number.isInteger = function(t) {\n  return typeof t == \"number\" && isFinite(t) && Math.floor(t) === t;\n});\nglobalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);\nglobalThis.Float32Array || (globalThis.Float32Array = Array);\nglobalThis.Uint32Array || (globalThis.Uint32Array = Array);\nglobalThis.Uint16Array || (globalThis.Uint16Array = Array);\nglobalThis.Uint8Array || (globalThis.Uint8Array = Array);\nglobalThis.Int32Array || (globalThis.Int32Array = Array);\nvar ENV;\n(function(o) {\n  o[o.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", o[o.WEBGL = 1] = \"WEBGL\", o[o.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV || (ENV = {}));\nvar RENDERER_TYPE;\n(function(o) {\n  o[o.UNKNOWN = 0] = \"UNKNOWN\", o[o.WEBGL = 1] = \"WEBGL\", o[o.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE || (RENDERER_TYPE = {}));\nvar BUFFER_BITS;\n(function(o) {\n  o[o.COLOR = 16384] = \"COLOR\", o[o.DEPTH = 256] = \"DEPTH\", o[o.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS || (BUFFER_BITS = {}));\nvar BLEND_MODES;\n(function(o) {\n  o[o.NORMAL = 0] = \"NORMAL\", o[o.ADD = 1] = \"ADD\", o[o.MULTIPLY = 2] = \"MULTIPLY\", o[o.SCREEN = 3] = \"SCREEN\", o[o.OVERLAY = 4] = \"OVERLAY\", o[o.DARKEN = 5] = \"DARKEN\", o[o.LIGHTEN = 6] = \"LIGHTEN\", o[o.COLOR_DODGE = 7] = \"COLOR_DODGE\", o[o.COLOR_BURN = 8] = \"COLOR_BURN\", o[o.HARD_LIGHT = 9] = \"HARD_LIGHT\", o[o.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", o[o.DIFFERENCE = 11] = \"DIFFERENCE\", o[o.EXCLUSION = 12] = \"EXCLUSION\", o[o.HUE = 13] = \"HUE\", o[o.SATURATION = 14] = \"SATURATION\", o[o.COLOR = 15] = \"COLOR\", o[o.LUMINOSITY = 16] = \"LUMINOSITY\", o[o.NORMAL_NPM = 17] = \"NORMAL_NPM\", o[o.ADD_NPM = 18] = \"ADD_NPM\", o[o.SCREEN_NPM = 19] = \"SCREEN_NPM\", o[o.NONE = 20] = \"NONE\", o[o.SRC_OVER = 0] = \"SRC_OVER\", o[o.SRC_IN = 21] = \"SRC_IN\", o[o.SRC_OUT = 22] = \"SRC_OUT\", o[o.SRC_ATOP = 23] = \"SRC_ATOP\", o[o.DST_OVER = 24] = \"DST_OVER\", o[o.DST_IN = 25] = \"DST_IN\", o[o.DST_OUT = 26] = \"DST_OUT\", o[o.DST_ATOP = 27] = \"DST_ATOP\", o[o.ERASE = 26] = \"ERASE\", o[o.SUBTRACT = 28] = \"SUBTRACT\", o[o.XOR = 29] = \"XOR\";\n})(BLEND_MODES || (BLEND_MODES = {}));\nvar DRAW_MODES;\n(function(o) {\n  o[o.POINTS = 0] = \"POINTS\", o[o.LINES = 1] = \"LINES\", o[o.LINE_LOOP = 2] = \"LINE_LOOP\", o[o.LINE_STRIP = 3] = \"LINE_STRIP\", o[o.TRIANGLES = 4] = \"TRIANGLES\", o[o.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", o[o.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES || (DRAW_MODES = {}));\nvar FORMATS;\n(function(o) {\n  o[o.RGBA = 6408] = \"RGBA\", o[o.RGB = 6407] = \"RGB\", o[o.RG = 33319] = \"RG\", o[o.RED = 6403] = \"RED\", o[o.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", o[o.RGB_INTEGER = 36248] = \"RGB_INTEGER\", o[o.RG_INTEGER = 33320] = \"RG_INTEGER\", o[o.RED_INTEGER = 36244] = \"RED_INTEGER\", o[o.ALPHA = 6406] = \"ALPHA\", o[o.LUMINANCE = 6409] = \"LUMINANCE\", o[o.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", o[o.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", o[o.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS || (FORMATS = {}));\nvar TARGETS;\n(function(o) {\n  o[o.TEXTURE_2D = 3553] = \"TEXTURE_2D\", o[o.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", o[o.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS || (TARGETS = {}));\nvar TYPES;\n(function(o) {\n  o[o.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", o[o.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", o[o.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", o[o.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", o[o.BYTE = 5120] = \"BYTE\", o[o.SHORT = 5122] = \"SHORT\", o[o.INT = 5124] = \"INT\", o[o.FLOAT = 5126] = \"FLOAT\", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", o[o.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES || (TYPES = {}));\nvar SAMPLER_TYPES;\n(function(o) {\n  o[o.FLOAT = 0] = \"FLOAT\", o[o.INT = 1] = \"INT\", o[o.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));\nvar SCALE_MODES;\n(function(o) {\n  o[o.NEAREST = 0] = \"NEAREST\", o[o.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES || (SCALE_MODES = {}));\nvar WRAP_MODES;\n(function(o) {\n  o[o.CLAMP = 33071] = \"CLAMP\", o[o.REPEAT = 10497] = \"REPEAT\", o[o.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES || (WRAP_MODES = {}));\nvar MIPMAP_MODES;\n(function(o) {\n  o[o.OFF = 0] = \"OFF\", o[o.POW2 = 1] = \"POW2\", o[o.ON = 2] = \"ON\", o[o.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES || (MIPMAP_MODES = {}));\nvar ALPHA_MODES;\n(function(o) {\n  o[o.NPM = 0] = \"NPM\", o[o.UNPACK = 1] = \"UNPACK\", o[o.PMA = 2] = \"PMA\", o[o.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", o[o.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", o[o.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", o[o.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES || (ALPHA_MODES = {}));\nvar CLEAR_MODES;\n(function(o) {\n  o[o.NO = 0] = \"NO\", o[o.YES = 1] = \"YES\", o[o.AUTO = 2] = \"AUTO\", o[o.BLEND = 0] = \"BLEND\", o[o.CLEAR = 1] = \"CLEAR\", o[o.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES || (CLEAR_MODES = {}));\nvar GC_MODES;\n(function(o) {\n  o[o.AUTO = 0] = \"AUTO\", o[o.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES || (GC_MODES = {}));\nvar PRECISION;\n(function(o) {\n  o.LOW = \"lowp\", o.MEDIUM = \"mediump\", o.HIGH = \"highp\";\n})(PRECISION || (PRECISION = {}));\nvar MASK_TYPES;\n(function(o) {\n  o[o.NONE = 0] = \"NONE\", o[o.SCISSOR = 1] = \"SCISSOR\", o[o.STENCIL = 2] = \"STENCIL\", o[o.SPRITE = 3] = \"SPRITE\", o[o.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES || (MASK_TYPES = {}));\nvar COLOR_MASK_BITS;\n(function(o) {\n  o[o.RED = 1] = \"RED\", o[o.GREEN = 2] = \"GREEN\", o[o.BLUE = 4] = \"BLUE\", o[o.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));\nvar MSAA_QUALITY;\n(function(o) {\n  o[o.NONE = 0] = \"NONE\", o[o.LOW = 2] = \"LOW\", o[o.MEDIUM = 4] = \"MEDIUM\", o[o.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY || (MSAA_QUALITY = {}));\nvar BUFFER_TYPE;\n(function(o) {\n  o[o.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", o[o.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", o[o.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE || (BUFFER_TYPE = {}));\nvar BrowserAdapter = {\n  createCanvas: function(o, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = o, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var o;\n    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;\n  },\n  fetch: function(o, t) {\n    return fetch(o, t);\n  }\n}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13 = function(o) {\n  return typeof o < \"u\" && o.platform === \"MacIntel\" && typeof o.maxTouchPoints == \"number\" && o.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch(o) {\n  return function(t) {\n    return t.test(o);\n  };\n}\nfunction isMobile$1(o) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !o && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof o == \"string\" ? t.userAgent = o : o && o.userAgent && (t = {\n    userAgent: o.userAgent,\n    platform: o.platform,\n    maxTouchPoints: o.maxTouchPoints || 0\n  });\n  var e = t.userAgent, r = e.split(\"[FBAN\");\n  typeof r[1] < \"u\" && (e = r[0]), r = e.split(\"Twitter\"), typeof r[1] < \"u\" && (e = r[0]);\n  var S = createMatch(e), T = {\n    apple: {\n      phone: S(appleIphone) && !S(windowsPhone),\n      ipod: S(appleIpod),\n      tablet: !S(appleIphone) && (S(appleTablet) || isAppleTabletOnIos13(t)) && !S(windowsPhone),\n      universal: S(appleUniversal),\n      device: (S(appleIphone) || S(appleIpod) || S(appleTablet) || S(appleUniversal) || isAppleTabletOnIos13(t)) && !S(windowsPhone)\n    },\n    amazon: {\n      phone: S(amazonPhone),\n      tablet: !S(amazonPhone) && S(amazonTablet),\n      device: S(amazonPhone) || S(amazonTablet)\n    },\n    android: {\n      phone: !S(windowsPhone) && S(amazonPhone) || !S(windowsPhone) && S(androidPhone),\n      tablet: !S(windowsPhone) && !S(amazonPhone) && !S(androidPhone) && (S(amazonTablet) || S(androidTablet)),\n      device: !S(windowsPhone) && (S(amazonPhone) || S(amazonTablet) || S(androidPhone) || S(androidTablet)) || S(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: S(windowsPhone),\n      tablet: S(windowsTablet),\n      device: S(windowsPhone) || S(windowsTablet)\n    },\n    other: {\n      blackberry: S(otherBlackBerry),\n      blackberry10: S(otherBlackBerry10),\n      opera: S(otherOpera),\n      firefox: S(otherFirefox),\n      chrome: S(otherChrome),\n      device: S(otherBlackBerry) || S(otherBlackBerry10) || S(otherOpera) || S(otherFirefox) || S(otherChrome)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return T.any = T.apple.device || T.android.device || T.windows.device || T.other.device, T.phone = T.apple.phone || T.android.phone || T.windows.phone, T.tablet = T.apple.tablet || T.android.tablet || T.windows.tablet, T;\n}\nvar isMobile = isMobile$1(globalThis.navigator);\nfunction canUploadSameBuffer() {\n  return !isMobile.apple.device;\n}\nfunction maxRecommendedTextures(o) {\n  var t = !0;\n  if (isMobile.tablet || isMobile.phone) {\n    if (isMobile.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 11 && (t = !1);\n      }\n    }\n    if (isMobile.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? o : 4;\n}\nvar settings = {\n  ADAPTER: BrowserAdapter,\n  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  GC_MODE: GC_MODES.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES.CLAMP,\n  SCALE_MODE: SCALE_MODES.LINEAR,\n  PRECISION_VERTEX: PRECISION.HIGH,\n  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),\n  CREATE_IMAGE_BITMAP: !1,\n  ROUND_PIXELS: !1\n}, eventemitter3 = { exports: {} };\n(function(o) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function r() {\n  }\n  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));\n  function S(B, $, U) {\n    this.fn = B, this.context = $, this.once = U || !1;\n  }\n  function T(B, $, U, V, H) {\n    if (typeof U != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var X = new S(U, V || B, H), Y = e ? e + $ : $;\n    return B._events[Y] ? B._events[Y].fn ? B._events[Y] = [B._events[Y], X] : B._events[Y].push(X) : (B._events[Y] = X, B._eventsCount++), B;\n  }\n  function D(B, $) {\n    --B._eventsCount === 0 ? B._events = new r() : delete B._events[$];\n  }\n  function N() {\n    this._events = new r(), this._eventsCount = 0;\n  }\n  N.prototype.eventNames = function() {\n    var $ = [], U, V;\n    if (this._eventsCount === 0)\n      return $;\n    for (V in U = this._events)\n      t.call(U, V) && $.push(e ? V.slice(1) : V);\n    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;\n  }, N.prototype.listeners = function($) {\n    var U = e ? e + $ : $, V = this._events[U];\n    if (!V)\n      return [];\n    if (V.fn)\n      return [V.fn];\n    for (var H = 0, X = V.length, Y = new Array(X); H < X; H++)\n      Y[H] = V[H].fn;\n    return Y;\n  }, N.prototype.listenerCount = function($) {\n    var U = e ? e + $ : $, V = this._events[U];\n    return V ? V.fn ? 1 : V.length : 0;\n  }, N.prototype.emit = function($, U, V, H, X, Y) {\n    var W = e ? e + $ : $;\n    if (!this._events[W])\n      return !1;\n    var q = this._events[W], K = arguments.length, Z, J;\n    if (q.fn) {\n      switch (q.once && this.removeListener($, q.fn, void 0, !0), K) {\n        case 1:\n          return q.fn.call(q.context), !0;\n        case 2:\n          return q.fn.call(q.context, U), !0;\n        case 3:\n          return q.fn.call(q.context, U, V), !0;\n        case 4:\n          return q.fn.call(q.context, U, V, H), !0;\n        case 5:\n          return q.fn.call(q.context, U, V, H, X), !0;\n        case 6:\n          return q.fn.call(q.context, U, V, H, X, Y), !0;\n      }\n      for (J = 1, Z = new Array(K - 1); J < K; J++)\n        Z[J - 1] = arguments[J];\n      q.fn.apply(q.context, Z);\n    } else {\n      var Q = q.length, rt;\n      for (J = 0; J < Q; J++)\n        switch (q[J].once && this.removeListener($, q[J].fn, void 0, !0), K) {\n          case 1:\n            q[J].fn.call(q[J].context);\n            break;\n          case 2:\n            q[J].fn.call(q[J].context, U);\n            break;\n          case 3:\n            q[J].fn.call(q[J].context, U, V);\n            break;\n          case 4:\n            q[J].fn.call(q[J].context, U, V, H);\n            break;\n          default:\n            if (!Z)\n              for (rt = 1, Z = new Array(K - 1); rt < K; rt++)\n                Z[rt - 1] = arguments[rt];\n            q[J].fn.apply(q[J].context, Z);\n        }\n    }\n    return !0;\n  }, N.prototype.on = function($, U, V) {\n    return T(this, $, U, V, !1);\n  }, N.prototype.once = function($, U, V) {\n    return T(this, $, U, V, !0);\n  }, N.prototype.removeListener = function($, U, V, H) {\n    var X = e ? e + $ : $;\n    if (!this._events[X])\n      return this;\n    if (!U)\n      return D(this, X), this;\n    var Y = this._events[X];\n    if (Y.fn)\n      Y.fn === U && (!H || Y.once) && (!V || Y.context === V) && D(this, X);\n    else {\n      for (var W = 0, q = [], K = Y.length; W < K; W++)\n        (Y[W].fn !== U || H && !Y[W].once || V && Y[W].context !== V) && q.push(Y[W]);\n      q.length ? this._events[X] = q.length === 1 ? q[0] : q : D(this, X);\n    }\n    return this;\n  }, N.prototype.removeAllListeners = function($) {\n    var U;\n    return $ ? (U = e ? e + $ : $, this._events[U] && D(this, U)) : (this._events = new r(), this._eventsCount = 0), this;\n  }, N.prototype.off = N.prototype.removeListener, N.prototype.addListener = N.prototype.on, N.prefixed = e, N.EventEmitter = N, o.exports = N;\n})(eventemitter3);\nconst i$1 = eventemitter3.exports;\nvar earcut$1 = { exports: {} };\nearcut$1.exports = earcut;\nearcut$1.exports.default = earcut;\nfunction earcut(o, t, e) {\n  e = e || 2;\n  var r = t && t.length, S = r ? t[0] * e : o.length, T = linkedList(o, 0, S, e, !0), D = [];\n  if (!T || T.next === T.prev)\n    return D;\n  var N, B, $, U, V, H, X;\n  if (r && (T = eliminateHoles(o, t, T, e)), o.length > 80 * e) {\n    N = $ = o[0], B = U = o[1];\n    for (var Y = e; Y < S; Y += e)\n      V = o[Y], H = o[Y + 1], V < N && (N = V), H < B && (B = H), V > $ && ($ = V), H > U && (U = H);\n    X = Math.max($ - N, U - B), X = X !== 0 ? 32767 / X : 0;\n  }\n  return earcutLinked(T, D, e, N, B, X, 0), D;\n}\nfunction linkedList(o, t, e, r, S) {\n  var T, D;\n  if (S === signedArea(o, t, e, r) > 0)\n    for (T = t; T < e; T += r)\n      D = insertNode(T, o[T], o[T + 1], D);\n  else\n    for (T = e - r; T >= t; T -= r)\n      D = insertNode(T, o[T], o[T + 1], D);\n  return D && equals$1(D, D.next) && (removeNode(D), D = D.next), D;\n}\nfunction filterPoints(o, t) {\n  if (!o)\n    return o;\n  t || (t = o);\n  var e = o, r;\n  do\n    if (r = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {\n      if (removeNode(e), e = t = e.prev, e === e.next)\n        break;\n      r = !0;\n    } else\n      e = e.next;\n  while (r || e !== t);\n  return t;\n}\nfunction earcutLinked(o, t, e, r, S, T, D) {\n  if (!!o) {\n    !D && T && indexCurve(o, r, S, T);\n    for (var N = o, B, $; o.prev !== o.next; ) {\n      if (B = o.prev, $ = o.next, T ? isEarHashed(o, r, S, T) : isEar(o)) {\n        t.push(B.i / e | 0), t.push(o.i / e | 0), t.push($.i / e | 0), removeNode(o), o = $.next, N = $.next;\n        continue;\n      }\n      if (o = $, o === N) {\n        D ? D === 1 ? (o = cureLocalIntersections(filterPoints(o), t, e), earcutLinked(o, t, e, r, S, T, 2)) : D === 2 && splitEarcut(o, t, e, r, S, T) : earcutLinked(filterPoints(o), t, e, r, S, T, 1);\n        break;\n      }\n    }\n  }\n}\nfunction isEar(o) {\n  var t = o.prev, e = o, r = o.next;\n  if (area(t, e, r) >= 0)\n    return !1;\n  for (var S = t.x, T = e.x, D = r.x, N = t.y, B = e.y, $ = r.y, U = S < T ? S < D ? S : D : T < D ? T : D, V = N < B ? N < $ ? N : $ : B < $ ? B : $, H = S > T ? S > D ? S : D : T > D ? T : D, X = N > B ? N > $ ? N : $ : B > $ ? B : $, Y = r.next; Y !== t; ) {\n    if (Y.x >= U && Y.x <= H && Y.y >= V && Y.y <= X && pointInTriangle(S, N, T, B, D, $, Y.x, Y.y) && area(Y.prev, Y, Y.next) >= 0)\n      return !1;\n    Y = Y.next;\n  }\n  return !0;\n}\nfunction isEarHashed(o, t, e, r) {\n  var S = o.prev, T = o, D = o.next;\n  if (area(S, T, D) >= 0)\n    return !1;\n  for (var N = S.x, B = T.x, $ = D.x, U = S.y, V = T.y, H = D.y, X = N < B ? N < $ ? N : $ : B < $ ? B : $, Y = U < V ? U < H ? U : H : V < H ? V : H, W = N > B ? N > $ ? N : $ : B > $ ? B : $, q = U > V ? U > H ? U : H : V > H ? V : H, K = zOrder(X, Y, t, e, r), Z = zOrder(W, q, t, e, r), J = o.prevZ, Q = o.nextZ; J && J.z >= K && Q && Q.z <= Z; ) {\n    if (J.x >= X && J.x <= W && J.y >= Y && J.y <= q && J !== S && J !== D && pointInTriangle(N, U, B, V, $, H, J.x, J.y) && area(J.prev, J, J.next) >= 0 || (J = J.prevZ, Q.x >= X && Q.x <= W && Q.y >= Y && Q.y <= q && Q !== S && Q !== D && pointInTriangle(N, U, B, V, $, H, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0))\n      return !1;\n    Q = Q.nextZ;\n  }\n  for (; J && J.z >= K; ) {\n    if (J.x >= X && J.x <= W && J.y >= Y && J.y <= q && J !== S && J !== D && pointInTriangle(N, U, B, V, $, H, J.x, J.y) && area(J.prev, J, J.next) >= 0)\n      return !1;\n    J = J.prevZ;\n  }\n  for (; Q && Q.z <= Z; ) {\n    if (Q.x >= X && Q.x <= W && Q.y >= Y && Q.y <= q && Q !== S && Q !== D && pointInTriangle(N, U, B, V, $, H, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0)\n      return !1;\n    Q = Q.nextZ;\n  }\n  return !0;\n}\nfunction cureLocalIntersections(o, t, e) {\n  var r = o;\n  do {\n    var S = r.prev, T = r.next.next;\n    !equals$1(S, T) && intersects(S, r, r.next, T) && locallyInside(S, T) && locallyInside(T, S) && (t.push(S.i / e | 0), t.push(r.i / e | 0), t.push(T.i / e | 0), removeNode(r), removeNode(r.next), r = o = T), r = r.next;\n  } while (r !== o);\n  return filterPoints(r);\n}\nfunction splitEarcut(o, t, e, r, S, T) {\n  var D = o;\n  do {\n    for (var N = D.next.next; N !== D.prev; ) {\n      if (D.i !== N.i && isValidDiagonal(D, N)) {\n        var B = splitPolygon(D, N);\n        D = filterPoints(D, D.next), B = filterPoints(B, B.next), earcutLinked(D, t, e, r, S, T, 0), earcutLinked(B, t, e, r, S, T, 0);\n        return;\n      }\n      N = N.next;\n    }\n    D = D.next;\n  } while (D !== o);\n}\nfunction eliminateHoles(o, t, e, r) {\n  var S = [], T, D, N, B, $;\n  for (T = 0, D = t.length; T < D; T++)\n    N = t[T] * r, B = T < D - 1 ? t[T + 1] * r : o.length, $ = linkedList(o, N, B, r, !1), $ === $.next && ($.steiner = !0), S.push(getLeftmost($));\n  for (S.sort(compareX), T = 0; T < S.length; T++)\n    e = eliminateHole(S[T], e);\n  return e;\n}\nfunction compareX(o, t) {\n  return o.x - t.x;\n}\nfunction eliminateHole(o, t) {\n  var e = findHoleBridge(o, t);\n  if (!e)\n    return t;\n  var r = splitPolygon(e, o);\n  return filterPoints(r, r.next), filterPoints(e, e.next);\n}\nfunction findHoleBridge(o, t) {\n  var e = t, r = o.x, S = o.y, T = -1 / 0, D;\n  do {\n    if (S <= e.y && S >= e.next.y && e.next.y !== e.y) {\n      var N = e.x + (S - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if (N <= r && N > T && (T = N, D = e.x < e.next.x ? e : e.next, N === r))\n        return D;\n    }\n    e = e.next;\n  } while (e !== t);\n  if (!D)\n    return null;\n  var B = D, $ = D.x, U = D.y, V = 1 / 0, H;\n  e = D;\n  do\n    r >= e.x && e.x >= $ && r !== e.x && pointInTriangle(S < U ? r : T, S, $, U, S < U ? T : r, S, e.x, e.y) && (H = Math.abs(S - e.y) / (r - e.x), locallyInside(e, o) && (H < V || H === V && (e.x > D.x || e.x === D.x && sectorContainsSector(D, e))) && (D = e, V = H)), e = e.next;\n  while (e !== B);\n  return D;\n}\nfunction sectorContainsSector(o, t) {\n  return area(o.prev, o, t.prev) < 0 && area(t.next, o, o.next) < 0;\n}\nfunction indexCurve(o, t, e, r) {\n  var S = o;\n  do\n    S.z === 0 && (S.z = zOrder(S.x, S.y, t, e, r)), S.prevZ = S.prev, S.nextZ = S.next, S = S.next;\n  while (S !== o);\n  S.prevZ.nextZ = null, S.prevZ = null, sortLinked(S);\n}\nfunction sortLinked(o) {\n  var t, e, r, S, T, D, N, B, $ = 1;\n  do {\n    for (e = o, o = null, T = null, D = 0; e; ) {\n      for (D++, r = e, N = 0, t = 0; t < $ && (N++, r = r.nextZ, !!r); t++)\n        ;\n      for (B = $; N > 0 || B > 0 && r; )\n        N !== 0 && (B === 0 || !r || e.z <= r.z) ? (S = e, e = e.nextZ, N--) : (S = r, r = r.nextZ, B--), T ? T.nextZ = S : o = S, S.prevZ = T, T = S;\n      e = r;\n    }\n    T.nextZ = null, $ *= 2;\n  } while (D > 1);\n  return o;\n}\nfunction zOrder(o, t, e, r, S) {\n  return o = (o - e) * S | 0, t = (t - r) * S | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, o | t << 1;\n}\nfunction getLeftmost(o) {\n  var t = o, e = o;\n  do\n    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;\n  while (t !== o);\n  return e;\n}\nfunction pointInTriangle(o, t, e, r, S, T, D, N) {\n  return (S - D) * (t - N) >= (o - D) * (T - N) && (o - D) * (r - N) >= (e - D) * (t - N) && (e - D) * (T - N) >= (S - D) * (r - N);\n}\nfunction isValidDiagonal(o, t) {\n  return o.next.i !== t.i && o.prev.i !== t.i && !intersectsPolygon(o, t) && (locallyInside(o, t) && locallyInside(t, o) && middleInside(o, t) && (area(o.prev, o, t.prev) || area(o, t.prev, t)) || equals$1(o, t) && area(o.prev, o, o.next) > 0 && area(t.prev, t, t.next) > 0);\n}\nfunction area(o, t, e) {\n  return (t.y - o.y) * (e.x - t.x) - (t.x - o.x) * (e.y - t.y);\n}\nfunction equals$1(o, t) {\n  return o.x === t.x && o.y === t.y;\n}\nfunction intersects(o, t, e, r) {\n  var S = sign$1(area(o, t, e)), T = sign$1(area(o, t, r)), D = sign$1(area(e, r, o)), N = sign$1(area(e, r, t));\n  return !!(S !== T && D !== N || S === 0 && onSegment(o, e, t) || T === 0 && onSegment(o, r, t) || D === 0 && onSegment(e, o, r) || N === 0 && onSegment(e, t, r));\n}\nfunction onSegment(o, t, e) {\n  return t.x <= Math.max(o.x, e.x) && t.x >= Math.min(o.x, e.x) && t.y <= Math.max(o.y, e.y) && t.y >= Math.min(o.y, e.y);\n}\nfunction sign$1(o) {\n  return o > 0 ? 1 : o < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(o, t) {\n  var e = o;\n  do {\n    if (e.i !== o.i && e.next.i !== o.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, o, t))\n      return !0;\n    e = e.next;\n  } while (e !== o);\n  return !1;\n}\nfunction locallyInside(o, t) {\n  return area(o.prev, o, o.next) < 0 ? area(o, t, o.next) >= 0 && area(o, o.prev, t) >= 0 : area(o, t, o.prev) < 0 || area(o, o.next, t) < 0;\n}\nfunction middleInside(o, t) {\n  var e = o, r = !1, S = (o.x + t.x) / 2, T = (o.y + t.y) / 2;\n  do\n    e.y > T != e.next.y > T && e.next.y !== e.y && S < (e.next.x - e.x) * (T - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;\n  while (e !== o);\n  return r;\n}\nfunction splitPolygon(o, t) {\n  var e = new Node$1(o.i, o.x, o.y), r = new Node$1(t.i, t.x, t.y), S = o.next, T = t.prev;\n  return o.next = t, t.prev = o, e.next = S, S.prev = e, r.next = e, e.prev = r, T.next = r, r.prev = T, r;\n}\nfunction insertNode(o, t, e, r) {\n  var S = new Node$1(o, t, e);\n  return r ? (S.next = r.next, S.prev = r, r.next.prev = S, r.next = S) : (S.prev = S, S.next = S), S;\n}\nfunction removeNode(o) {\n  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);\n}\nfunction Node$1(o, t, e) {\n  this.i = o, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nearcut.deviation = function(o, t, e, r) {\n  var S = t && t.length, T = S ? t[0] * e : o.length, D = Math.abs(signedArea(o, 0, T, e));\n  if (S)\n    for (var N = 0, B = t.length; N < B; N++) {\n      var $ = t[N] * e, U = N < B - 1 ? t[N + 1] * e : o.length;\n      D -= Math.abs(signedArea(o, $, U, e));\n    }\n  var V = 0;\n  for (N = 0; N < r.length; N += 3) {\n    var H = r[N] * e, X = r[N + 1] * e, Y = r[N + 2] * e;\n    V += Math.abs(\n      (o[H] - o[Y]) * (o[X + 1] - o[H + 1]) - (o[H] - o[X]) * (o[Y + 1] - o[H + 1])\n    );\n  }\n  return D === 0 && V === 0 ? 0 : Math.abs((V - D) / D);\n};\nfunction signedArea(o, t, e, r) {\n  for (var S = 0, T = t, D = e - r; T < e; T += r)\n    S += (o[D] - o[T]) * (o[T + 1] + o[D + 1]), D = T;\n  return S;\n}\nearcut.flatten = function(o) {\n  for (var t = o[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, S = 0; S < o.length; S++) {\n    for (var T = 0; T < o[S].length; T++)\n      for (var D = 0; D < t; D++)\n        e.vertices.push(o[S][T][D]);\n    S > 0 && (r += o[S - 1].length, e.holes.push(r));\n  }\n  return e;\n};\nvar punycode$1 = { exports: {} };\n(function(o, t) {\n  (function(e) {\n    var r = t && !t.nodeType && t, S = o && !o.nodeType && o, T = typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    (T.global === T || T.window === T || T.self === T) && (e = T);\n    var D, N = 2147483647, B = 36, $ = 1, U = 26, V = 38, H = 700, X = 72, Y = 128, W = \"-\", q = /^xn--/, K = /[^\\x20-\\x7E]/, Z = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, J = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, Q = B - $, rt = Math.floor, et = String.fromCharCode, nt;\n    function st(pt) {\n      throw RangeError(J[pt]);\n    }\n    function it(pt, yt) {\n      for (var At = pt.length, Dt = []; At--; )\n        Dt[At] = yt(pt[At]);\n      return Dt;\n    }\n    function at(pt, yt) {\n      var At = pt.split(\"@\"), Dt = \"\";\n      At.length > 1 && (Dt = At[0] + \"@\", pt = At[1]), pt = pt.replace(Z, \".\");\n      var Ot = pt.split(\".\"), Pt = it(Ot, yt).join(\".\");\n      return Dt + Pt;\n    }\n    function ut(pt) {\n      for (var yt = [], At = 0, Dt = pt.length, Ot, Pt; At < Dt; )\n        Ot = pt.charCodeAt(At++), Ot >= 55296 && Ot <= 56319 && At < Dt ? (Pt = pt.charCodeAt(At++), (Pt & 64512) == 56320 ? yt.push(((Ot & 1023) << 10) + (Pt & 1023) + 65536) : (yt.push(Ot), At--)) : yt.push(Ot);\n      return yt;\n    }\n    function ct(pt) {\n      return it(pt, function(yt) {\n        var At = \"\";\n        return yt > 65535 && (yt -= 65536, At += et(yt >>> 10 & 1023 | 55296), yt = 56320 | yt & 1023), At += et(yt), At;\n      }).join(\"\");\n    }\n    function gt(pt) {\n      return pt - 48 < 10 ? pt - 22 : pt - 65 < 26 ? pt - 65 : pt - 97 < 26 ? pt - 97 : B;\n    }\n    function _t(pt, yt) {\n      return pt + 22 + 75 * (pt < 26) - ((yt != 0) << 5);\n    }\n    function vt(pt, yt, At) {\n      var Dt = 0;\n      for (pt = At ? rt(pt / H) : pt >> 1, pt += rt(pt / yt); pt > Q * U >> 1; Dt += B)\n        pt = rt(pt / Q);\n      return rt(Dt + (Q + 1) * pt / (pt + V));\n    }\n    function mt(pt) {\n      var yt = [], At = pt.length, Dt, Ot = 0, Pt = Y, ft = X, Ft, It, zt, kt, Tt, jt, Nt, Et, Lt;\n      for (Ft = pt.lastIndexOf(W), Ft < 0 && (Ft = 0), It = 0; It < Ft; ++It)\n        pt.charCodeAt(It) >= 128 && st(\"not-basic\"), yt.push(pt.charCodeAt(It));\n      for (zt = Ft > 0 ? Ft + 1 : 0; zt < At; ) {\n        for (kt = Ot, Tt = 1, jt = B; zt >= At && st(\"invalid-input\"), Nt = gt(pt.charCodeAt(zt++)), (Nt >= B || Nt > rt((N - Ot) / Tt)) && st(\"overflow\"), Ot += Nt * Tt, Et = jt <= ft ? $ : jt >= ft + U ? U : jt - ft, !(Nt < Et); jt += B)\n          Lt = B - Et, Tt > rt(N / Lt) && st(\"overflow\"), Tt *= Lt;\n        Dt = yt.length + 1, ft = vt(Ot - kt, Dt, kt == 0), rt(Ot / Dt) > N - Pt && st(\"overflow\"), Pt += rt(Ot / Dt), Ot %= Dt, yt.splice(Ot++, 0, Pt);\n      }\n      return ct(yt);\n    }\n    function bt(pt) {\n      var yt, At, Dt, Ot, Pt, ft, Ft, It, zt, kt, Tt, jt = [], Nt, Et, Lt, Ht;\n      for (pt = ut(pt), Nt = pt.length, yt = Y, At = 0, Pt = X, ft = 0; ft < Nt; ++ft)\n        Tt = pt[ft], Tt < 128 && jt.push(et(Tt));\n      for (Dt = Ot = jt.length, Ot && jt.push(W); Dt < Nt; ) {\n        for (Ft = N, ft = 0; ft < Nt; ++ft)\n          Tt = pt[ft], Tt >= yt && Tt < Ft && (Ft = Tt);\n        for (Et = Dt + 1, Ft - yt > rt((N - At) / Et) && st(\"overflow\"), At += (Ft - yt) * Et, yt = Ft, ft = 0; ft < Nt; ++ft)\n          if (Tt = pt[ft], Tt < yt && ++At > N && st(\"overflow\"), Tt == yt) {\n            for (It = At, zt = B; kt = zt <= Pt ? $ : zt >= Pt + U ? U : zt - Pt, !(It < kt); zt += B)\n              Ht = It - kt, Lt = B - kt, jt.push(\n                et(_t(kt + Ht % Lt, 0))\n              ), It = rt(Ht / Lt);\n            jt.push(et(_t(It, 0))), Pt = vt(At, Et, Dt == Ot), At = 0, ++Dt;\n          }\n        ++At, ++yt;\n      }\n      return jt.join(\"\");\n    }\n    function Ct(pt) {\n      return at(pt, function(yt) {\n        return q.test(yt) ? mt(yt.slice(4).toLowerCase()) : yt;\n      });\n    }\n    function St(pt) {\n      return at(pt, function(yt) {\n        return K.test(yt) ? \"xn--\" + bt(yt) : yt;\n      });\n    }\n    if (D = {\n      version: \"1.3.2\",\n      ucs2: {\n        decode: ut,\n        encode: ct\n      },\n      decode: mt,\n      encode: bt,\n      toASCII: St,\n      toUnicode: Ct\n    }, r && S)\n      if (o.exports == r)\n        S.exports = D;\n      else\n        for (nt in D)\n          D.hasOwnProperty(nt) && (r[nt] = D[nt]);\n    else\n      e.punycode = D;\n  })(commonjsGlobal);\n})(punycode$1, punycode$1.exports);\nvar util$8 = {\n  isString: function(o) {\n    return typeof o == \"string\";\n  },\n  isObject: function(o) {\n    return typeof o == \"object\" && o !== null;\n  },\n  isNull: function(o) {\n    return o === null;\n  },\n  isNullOrUndefined: function(o) {\n    return o == null;\n  }\n}, querystring$1 = {};\nfunction hasOwnProperty(o, t) {\n  return Object.prototype.hasOwnProperty.call(o, t);\n}\nvar decode$2 = function(o, t, e, r) {\n  t = t || \"&\", e = e || \"=\";\n  var S = {};\n  if (typeof o != \"string\" || o.length === 0)\n    return S;\n  var T = /\\+/g;\n  o = o.split(t);\n  var D = 1e3;\n  r && typeof r.maxKeys == \"number\" && (D = r.maxKeys);\n  var N = o.length;\n  D > 0 && N > D && (N = D);\n  for (var B = 0; B < N; ++B) {\n    var $ = o[B].replace(T, \"%20\"), U = $.indexOf(e), V, H, X, Y;\n    U >= 0 ? (V = $.substr(0, U), H = $.substr(U + 1)) : (V = $, H = \"\"), X = decodeURIComponent(V), Y = decodeURIComponent(H), hasOwnProperty(S, X) ? Array.isArray(S[X]) ? S[X].push(Y) : S[X] = [S[X], Y] : S[X] = Y;\n  }\n  return S;\n}, stringifyPrimitive = function(o) {\n  switch (typeof o) {\n    case \"string\":\n      return o;\n    case \"boolean\":\n      return o ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(o) ? o : \"\";\n    default:\n      return \"\";\n  }\n}, encode$2 = function(o, t, e, r) {\n  return t = t || \"&\", e = e || \"=\", o === null && (o = void 0), typeof o == \"object\" ? Object.keys(o).map(function(S) {\n    var T = encodeURIComponent(stringifyPrimitive(S)) + e;\n    return Array.isArray(o[S]) ? o[S].map(function(D) {\n      return T + encodeURIComponent(stringifyPrimitive(D));\n    }).join(t) : T + encodeURIComponent(stringifyPrimitive(o[S]));\n  }).join(t) : r ? encodeURIComponent(stringifyPrimitive(r)) + e + encodeURIComponent(stringifyPrimitive(o)) : \"\";\n};\nquerystring$1.decode = querystring$1.parse = decode$2;\nquerystring$1.encode = querystring$1.stringify = encode$2;\nvar punycode = punycode$1.exports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;\nfunction Url() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", `\n`, \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n}, querystring = querystring$1;\nfunction urlParse(o, t, e) {\n  if (o && util$7.isObject(o) && o instanceof Url)\n    return o;\n  var r = new Url();\n  return r.parse(o, t, e), r;\n}\nUrl.prototype.parse = function(o, t, e) {\n  if (!util$7.isString(o))\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof o);\n  var r = o.indexOf(\"?\"), S = r !== -1 && r < o.indexOf(\"#\") ? \"?\" : \"#\", T = o.split(S), D = /\\\\/g;\n  T[0] = T[0].replace(D, \"/\"), o = T.join(S);\n  var N = o;\n  if (N = N.trim(), !e && o.split(\"#\").length === 1) {\n    var B = simplePathPattern.exec(N);\n    if (B)\n      return this.path = N, this.href = N, this.pathname = B[1], B[2] ? (this.search = B[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = \"\", this.query = {}), this;\n  }\n  var $ = protocolPattern.exec(N);\n  if ($) {\n    $ = $[0];\n    var U = $.toLowerCase();\n    this.protocol = U, N = N.substr($.length);\n  }\n  if (e || $ || N.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var V = N.substr(0, 2) === \"//\";\n    V && !($ && hostlessProtocol[$]) && (N = N.substr(2), this.slashes = !0);\n  }\n  if (!hostlessProtocol[$] && (V || $ && !slashedProtocol[$])) {\n    for (var H = -1, X = 0; X < hostEndingChars.length; X++) {\n      var Y = N.indexOf(hostEndingChars[X]);\n      Y !== -1 && (H === -1 || Y < H) && (H = Y);\n    }\n    var W, q;\n    H === -1 ? q = N.lastIndexOf(\"@\") : q = N.lastIndexOf(\"@\", H), q !== -1 && (W = N.slice(0, q), N = N.slice(q + 1), this.auth = decodeURIComponent(W)), H = -1;\n    for (var X = 0; X < nonHostChars.length; X++) {\n      var Y = N.indexOf(nonHostChars[X]);\n      Y !== -1 && (H === -1 || Y < H) && (H = Y);\n    }\n    H === -1 && (H = N.length), this.host = N.slice(0, H), N = N.slice(H), this.parseHost(), this.hostname = this.hostname || \"\";\n    var K = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!K)\n      for (var Z = this.hostname.split(/\\./), X = 0, J = Z.length; X < J; X++) {\n        var Q = Z[X];\n        if (!!Q && !Q.match(hostnamePartPattern)) {\n          for (var rt = \"\", et = 0, nt = Q.length; et < nt; et++)\n            Q.charCodeAt(et) > 127 ? rt += \"x\" : rt += Q[et];\n          if (!rt.match(hostnamePartPattern)) {\n            var st = Z.slice(0, X), it = Z.slice(X + 1), at = Q.match(hostnamePartStart);\n            at && (st.push(at[1]), it.unshift(at[2])), it.length && (N = \"/\" + it.join(\".\") + N), this.hostname = st.join(\".\");\n            break;\n          }\n        }\n      }\n    this.hostname.length > hostnameMaxLen ? this.hostname = \"\" : this.hostname = this.hostname.toLowerCase(), K || (this.hostname = punycode.toASCII(this.hostname));\n    var ut = this.port ? \":\" + this.port : \"\", ct = this.hostname || \"\";\n    this.host = ct + ut, this.href += this.host, K && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), N[0] !== \"/\" && (N = \"/\" + N));\n  }\n  if (!unsafeProtocol[U])\n    for (var X = 0, J = autoEscape.length; X < J; X++) {\n      var gt = autoEscape[X];\n      if (N.indexOf(gt) !== -1) {\n        var _t = encodeURIComponent(gt);\n        _t === gt && (_t = escape(gt)), N = N.split(gt).join(_t);\n      }\n    }\n  var vt = N.indexOf(\"#\");\n  vt !== -1 && (this.hash = N.substr(vt), N = N.slice(0, vt));\n  var mt = N.indexOf(\"?\");\n  if (mt !== -1 ? (this.search = N.substr(mt), this.query = N.substr(mt + 1), t && (this.query = querystring.parse(this.query)), N = N.slice(0, mt)) : t && (this.search = \"\", this.query = {}), N && (this.pathname = N), slashedProtocol[U] && this.hostname && !this.pathname && (this.pathname = \"/\"), this.pathname || this.search) {\n    var ut = this.pathname || \"\", bt = this.search || \"\";\n    this.path = ut + bt;\n  }\n  return this.href = this.format(), this;\n};\nfunction urlFormat(o) {\n  return util$7.isString(o) && (o = urlParse(o)), o instanceof Url ? o.format() : Url.prototype.format.call(o);\n}\nUrl.prototype.format = function() {\n  var o = this.auth || \"\";\n  o && (o = encodeURIComponent(o), o = o.replace(/%3A/i, \":\"), o += \"@\");\n  var t = this.protocol || \"\", e = this.pathname || \"\", r = this.hash || \"\", S = !1, T = \"\";\n  this.host ? S = o + this.host : this.hostname && (S = o + (this.hostname.indexOf(\":\") === -1 ? this.hostname : \"[\" + this.hostname + \"]\"), this.port && (S += \":\" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (T = querystring.stringify(this.query));\n  var D = this.search || T && \"?\" + T || \"\";\n  return t && t.substr(-1) !== \":\" && (t += \":\"), this.slashes || (!t || slashedProtocol[t]) && S !== !1 ? (S = \"//\" + (S || \"\"), e && e.charAt(0) !== \"/\" && (e = \"/\" + e)) : S || (S = \"\"), r && r.charAt(0) !== \"#\" && (r = \"#\" + r), D && D.charAt(0) !== \"?\" && (D = \"?\" + D), e = e.replace(/[?#]/g, function(N) {\n    return encodeURIComponent(N);\n  }), D = D.replace(\"#\", \"%23\"), t + S + e + D + r;\n};\nfunction urlResolve(o, t) {\n  return urlParse(o, !1, !0).resolve(t);\n}\nUrl.prototype.resolve = function(o) {\n  return this.resolveObject(urlParse(o, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(o) {\n  if (util$7.isString(o)) {\n    var t = new Url();\n    t.parse(o, !1, !0), o = t;\n  }\n  for (var e = new Url(), r = Object.keys(this), S = 0; S < r.length; S++) {\n    var T = r[S];\n    e[T] = this[T];\n  }\n  if (e.hash = o.hash, o.href === \"\")\n    return e.href = e.format(), e;\n  if (o.slashes && !o.protocol) {\n    for (var D = Object.keys(o), N = 0; N < D.length; N++) {\n      var B = D[N];\n      B !== \"protocol\" && (e[B] = o[B]);\n    }\n    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = \"/\"), e.href = e.format(), e;\n  }\n  if (o.protocol && o.protocol !== e.protocol) {\n    if (!slashedProtocol[o.protocol]) {\n      for (var $ = Object.keys(o), U = 0; U < $.length; U++) {\n        var V = $[U];\n        e[V] = o[V];\n      }\n      return e.href = e.format(), e;\n    }\n    if (e.protocol = o.protocol, !o.host && !hostlessProtocol[o.protocol]) {\n      for (var J = (o.pathname || \"\").split(\"/\"); J.length && !(o.host = J.shift()); )\n        ;\n      o.host || (o.host = \"\"), o.hostname || (o.hostname = \"\"), J[0] !== \"\" && J.unshift(\"\"), J.length < 2 && J.unshift(\"\"), e.pathname = J.join(\"/\");\n    } else\n      e.pathname = o.pathname;\n    if (e.search = o.search, e.query = o.query, e.host = o.host || \"\", e.auth = o.auth, e.hostname = o.hostname || o.host, e.port = o.port, e.pathname || e.search) {\n      var H = e.pathname || \"\", X = e.search || \"\";\n      e.path = H + X;\n    }\n    return e.slashes = e.slashes || o.slashes, e.href = e.format(), e;\n  }\n  var Y = e.pathname && e.pathname.charAt(0) === \"/\", W = o.host || o.pathname && o.pathname.charAt(0) === \"/\", q = W || Y || e.host && o.pathname, K = q, Z = e.pathname && e.pathname.split(\"/\") || [], J = o.pathname && o.pathname.split(\"/\") || [], Q = e.protocol && !slashedProtocol[e.protocol];\n  if (Q && (e.hostname = \"\", e.port = null, e.host && (Z[0] === \"\" ? Z[0] = e.host : Z.unshift(e.host)), e.host = \"\", o.protocol && (o.hostname = null, o.port = null, o.host && (J[0] === \"\" ? J[0] = o.host : J.unshift(o.host)), o.host = null), q = q && (J[0] === \"\" || Z[0] === \"\")), W)\n    e.host = o.host || o.host === \"\" ? o.host : e.host, e.hostname = o.hostname || o.hostname === \"\" ? o.hostname : e.hostname, e.search = o.search, e.query = o.query, Z = J;\n  else if (J.length)\n    Z || (Z = []), Z.pop(), Z = Z.concat(J), e.search = o.search, e.query = o.query;\n  else if (!util$7.isNullOrUndefined(o.search)) {\n    if (Q) {\n      e.hostname = e.host = Z.shift();\n      var rt = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n      rt && (e.auth = rt.shift(), e.host = e.hostname = rt.shift());\n    }\n    return e.search = o.search, e.query = o.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.href = e.format(), e;\n  }\n  if (!Z.length)\n    return e.pathname = null, e.search ? e.path = \"/\" + e.search : e.path = null, e.href = e.format(), e;\n  for (var et = Z.slice(-1)[0], nt = (e.host || o.host || Z.length > 1) && (et === \".\" || et === \"..\") || et === \"\", st = 0, it = Z.length; it >= 0; it--)\n    et = Z[it], et === \".\" ? Z.splice(it, 1) : et === \"..\" ? (Z.splice(it, 1), st++) : st && (Z.splice(it, 1), st--);\n  if (!q && !K)\n    for (; st--; st)\n      Z.unshift(\"..\");\n  q && Z[0] !== \"\" && (!Z[0] || Z[0].charAt(0) !== \"/\") && Z.unshift(\"\"), nt && Z.join(\"/\").substr(-1) !== \"/\" && Z.push(\"\");\n  var at = Z[0] === \"\" || Z[0] && Z[0].charAt(0) === \"/\";\n  if (Q) {\n    e.hostname = e.host = at ? \"\" : Z.length ? Z.shift() : \"\";\n    var rt = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n    rt && (e.auth = rt.shift(), e.host = e.hostname = rt.shift());\n  }\n  return q = q || e.host && Z.length, q && !at && Z.unshift(\"\"), Z.length ? e.pathname = Z.join(\"/\") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.auth = o.auth || e.auth, e.slashes = e.slashes || o.slashes, e.href = e.format(), e;\n};\nUrl.prototype.parseHost = function() {\n  var o = this.host, t = portPattern.exec(o);\n  t && (t = t[0], t !== \":\" && (this.port = t.substr(1)), o = o.substr(0, o.length - t.length)), o && (this.hostname = o);\n};\nvar url$1 = {\n  parse: parse$2,\n  format: format$1,\n  resolve\n};\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nvar saidHello = !1, VERSION$1 = \"6.5.8\";\nfunction skipHello() {\n  saidHello = !0;\n}\nfunction sayHello(o) {\n  var t;\n  if (!saidHello) {\n    if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n      var e = [\n        `\n %c %c %c PixiJS ` + VERSION$1 + \" - ✰ \" + o + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n`,\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff66a5; background: #030307; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ffc3dc; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\"\n      ];\n      (t = globalThis.console).log.apply(t, e);\n    } else\n      globalThis.console && globalThis.console.log(\"PixiJS \" + VERSION$1 + \" - \" + o + \" - http://www.pixijs.com/\");\n    saidHello = !0;\n  }\n}\nvar supported;\nfunction isWebGLSupported() {\n  return typeof supported > \"u\" && (supported = function() {\n    var t = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      var e = settings.ADAPTER.createCanvas(), r = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t), S = !!(r && r.getContextAttributes().stencil);\n      if (r) {\n        var T = r.getExtension(\"WEBGL_lose_context\");\n        T && T.loseContext();\n      }\n      return r = null, S;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\nvar aliceblue = \"#f0f8ff\", antiquewhite = \"#faebd7\", aqua = \"#00ffff\", aquamarine = \"#7fffd4\", azure = \"#f0ffff\", beige = \"#f5f5dc\", bisque = \"#ffe4c4\", black = \"#000000\", blanchedalmond = \"#ffebcd\", blue = \"#0000ff\", blueviolet = \"#8a2be2\", brown = \"#a52a2a\", burlywood = \"#deb887\", cadetblue = \"#5f9ea0\", chartreuse = \"#7fff00\", chocolate = \"#d2691e\", coral = \"#ff7f50\", cornflowerblue = \"#6495ed\", cornsilk = \"#fff8dc\", crimson = \"#dc143c\", cyan = \"#00ffff\", darkblue = \"#00008b\", darkcyan = \"#008b8b\", darkgoldenrod = \"#b8860b\", darkgray = \"#a9a9a9\", darkgreen = \"#006400\", darkgrey = \"#a9a9a9\", darkkhaki = \"#bdb76b\", darkmagenta = \"#8b008b\", darkolivegreen = \"#556b2f\", darkorange = \"#ff8c00\", darkorchid = \"#9932cc\", darkred = \"#8b0000\", darksalmon = \"#e9967a\", darkseagreen = \"#8fbc8f\", darkslateblue = \"#483d8b\", darkslategray = \"#2f4f4f\", darkslategrey = \"#2f4f4f\", darkturquoise = \"#00ced1\", darkviolet = \"#9400d3\", deeppink = \"#ff1493\", deepskyblue = \"#00bfff\", dimgray = \"#696969\", dimgrey = \"#696969\", dodgerblue = \"#1e90ff\", firebrick = \"#b22222\", floralwhite = \"#fffaf0\", forestgreen = \"#228b22\", fuchsia = \"#ff00ff\", gainsboro = \"#dcdcdc\", ghostwhite = \"#f8f8ff\", goldenrod = \"#daa520\", gold = \"#ffd700\", gray = \"#808080\", green = \"#008000\", greenyellow = \"#adff2f\", grey = \"#808080\", honeydew = \"#f0fff0\", hotpink = \"#ff69b4\", indianred = \"#cd5c5c\", indigo = \"#4b0082\", ivory = \"#fffff0\", khaki = \"#f0e68c\", lavenderblush = \"#fff0f5\", lavender = \"#e6e6fa\", lawngreen = \"#7cfc00\", lemonchiffon = \"#fffacd\", lightblue = \"#add8e6\", lightcoral = \"#f08080\", lightcyan = \"#e0ffff\", lightgoldenrodyellow = \"#fafad2\", lightgray = \"#d3d3d3\", lightgreen = \"#90ee90\", lightgrey = \"#d3d3d3\", lightpink = \"#ffb6c1\", lightsalmon = \"#ffa07a\", lightseagreen = \"#20b2aa\", lightskyblue = \"#87cefa\", lightslategray = \"#778899\", lightslategrey = \"#778899\", lightsteelblue = \"#b0c4de\", lightyellow = \"#ffffe0\", lime = \"#00ff00\", limegreen = \"#32cd32\", linen = \"#faf0e6\", magenta = \"#ff00ff\", maroon = \"#800000\", mediumaquamarine = \"#66cdaa\", mediumblue = \"#0000cd\", mediumorchid = \"#ba55d3\", mediumpurple = \"#9370db\", mediumseagreen = \"#3cb371\", mediumslateblue = \"#7b68ee\", mediumspringgreen = \"#00fa9a\", mediumturquoise = \"#48d1cc\", mediumvioletred = \"#c71585\", midnightblue = \"#191970\", mintcream = \"#f5fffa\", mistyrose = \"#ffe4e1\", moccasin = \"#ffe4b5\", navajowhite = \"#ffdead\", navy = \"#000080\", oldlace = \"#fdf5e6\", olive = \"#808000\", olivedrab = \"#6b8e23\", orange = \"#ffa500\", orangered = \"#ff4500\", orchid = \"#da70d6\", palegoldenrod = \"#eee8aa\", palegreen = \"#98fb98\", paleturquoise = \"#afeeee\", palevioletred = \"#db7093\", papayawhip = \"#ffefd5\", peachpuff = \"#ffdab9\", peru = \"#cd853f\", pink = \"#ffc0cb\", plum = \"#dda0dd\", powderblue = \"#b0e0e6\", purple = \"#800080\", rebeccapurple = \"#663399\", red = \"#ff0000\", rosybrown = \"#bc8f8f\", royalblue = \"#4169e1\", saddlebrown = \"#8b4513\", salmon = \"#fa8072\", sandybrown = \"#f4a460\", seagreen = \"#2e8b57\", seashell = \"#fff5ee\", sienna = \"#a0522d\", silver = \"#c0c0c0\", skyblue = \"#87ceeb\", slateblue = \"#6a5acd\", slategray = \"#708090\", slategrey = \"#708090\", snow = \"#fffafa\", springgreen = \"#00ff7f\", steelblue = \"#4682b4\", tan = \"#d2b48c\", teal = \"#008080\", thistle = \"#d8bfd8\", tomato = \"#ff6347\", turquoise = \"#40e0d0\", violet = \"#ee82ee\", wheat = \"#f5deb3\", white = \"#ffffff\", whitesmoke = \"#f5f5f5\", yellow = \"#ffff00\", yellowgreen = \"#9acd32\", cssColorNames = {\n  aliceblue,\n  antiquewhite,\n  aqua,\n  aquamarine,\n  azure,\n  beige,\n  bisque,\n  black,\n  blanchedalmond,\n  blue,\n  blueviolet,\n  brown,\n  burlywood,\n  cadetblue,\n  chartreuse,\n  chocolate,\n  coral,\n  cornflowerblue,\n  cornsilk,\n  crimson,\n  cyan,\n  darkblue,\n  darkcyan,\n  darkgoldenrod,\n  darkgray,\n  darkgreen,\n  darkgrey,\n  darkkhaki,\n  darkmagenta,\n  darkolivegreen,\n  darkorange,\n  darkorchid,\n  darkred,\n  darksalmon,\n  darkseagreen,\n  darkslateblue,\n  darkslategray,\n  darkslategrey,\n  darkturquoise,\n  darkviolet,\n  deeppink,\n  deepskyblue,\n  dimgray,\n  dimgrey,\n  dodgerblue,\n  firebrick,\n  floralwhite,\n  forestgreen,\n  fuchsia,\n  gainsboro,\n  ghostwhite,\n  goldenrod,\n  gold,\n  gray,\n  green,\n  greenyellow,\n  grey,\n  honeydew,\n  hotpink,\n  indianred,\n  indigo,\n  ivory,\n  khaki,\n  lavenderblush,\n  lavender,\n  lawngreen,\n  lemonchiffon,\n  lightblue,\n  lightcoral,\n  lightcyan,\n  lightgoldenrodyellow,\n  lightgray,\n  lightgreen,\n  lightgrey,\n  lightpink,\n  lightsalmon,\n  lightseagreen,\n  lightskyblue,\n  lightslategray,\n  lightslategrey,\n  lightsteelblue,\n  lightyellow,\n  lime,\n  limegreen,\n  linen,\n  magenta,\n  maroon,\n  mediumaquamarine,\n  mediumblue,\n  mediumorchid,\n  mediumpurple,\n  mediumseagreen,\n  mediumslateblue,\n  mediumspringgreen,\n  mediumturquoise,\n  mediumvioletred,\n  midnightblue,\n  mintcream,\n  mistyrose,\n  moccasin,\n  navajowhite,\n  navy,\n  oldlace,\n  olive,\n  olivedrab,\n  orange,\n  orangered,\n  orchid,\n  palegoldenrod,\n  palegreen,\n  paleturquoise,\n  palevioletred,\n  papayawhip,\n  peachpuff,\n  peru,\n  pink,\n  plum,\n  powderblue,\n  purple,\n  rebeccapurple,\n  red,\n  rosybrown,\n  royalblue,\n  saddlebrown,\n  salmon,\n  sandybrown,\n  seagreen,\n  seashell,\n  sienna,\n  silver,\n  skyblue,\n  slateblue,\n  slategray,\n  slategrey,\n  snow,\n  springgreen,\n  steelblue,\n  tan,\n  teal,\n  thistle,\n  tomato,\n  turquoise,\n  violet,\n  wheat,\n  white,\n  whitesmoke,\n  yellow,\n  yellowgreen\n};\nfunction hex2rgb(o, t) {\n  return t === void 0 && (t = []), t[0] = (o >> 16 & 255) / 255, t[1] = (o >> 8 & 255) / 255, t[2] = (o & 255) / 255, t;\n}\nfunction hex2string(o) {\n  var t = o.toString(16);\n  return t = \"000000\".substring(0, 6 - t.length) + t, \"#\" + t;\n}\nfunction string2hex(o) {\n  return typeof o == \"string\" && (o = cssColorNames[o.toLowerCase()] || o, o[0] === \"#\" && (o = o.slice(1))), parseInt(o, 16);\n}\nfunction mapPremultipliedBlendModes() {\n  for (var o = [], t = [], e = 0; e < 32; e++)\n    o[e] = e, t[e] = e;\n  o[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, o[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, o[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  var r = [];\n  return r.push(t), r.push(o), r;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(o, t) {\n  return premultiplyBlendMode[t ? 1 : 0][o];\n}\nfunction premultiplyRgba(o, t, e, r) {\n  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = o[0] * t, e[1] = o[1] * t, e[2] = o[2] * t) : (e[0] = o[0], e[1] = o[1], e[2] = o[2]), e[3] = t, e;\n}\nfunction premultiplyTint(o, t) {\n  if (t === 1)\n    return (t * 255 << 24) + o;\n  if (t === 0)\n    return 0;\n  var e = o >> 16 & 255, r = o >> 8 & 255, S = o & 255;\n  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, S = S * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + S;\n}\nfunction premultiplyTintToRgba(o, t, e, r) {\n  return e = e || new Float32Array(4), e[0] = (o >> 16 & 255) / 255, e[1] = (o >> 8 & 255) / 255, e[2] = (o & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;\n}\nfunction createIndicesForQuads(o, t) {\n  t === void 0 && (t = null);\n  var e = o * 6;\n  if (t = t || new Uint16Array(e), t.length !== e)\n    throw new Error(\"Out buffer length is incorrect, got \" + t.length + \" and expected \" + e);\n  for (var r = 0, S = 0; r < e; r += 6, S += 4)\n    t[r + 0] = S + 0, t[r + 1] = S + 1, t[r + 2] = S + 2, t[r + 3] = S + 0, t[r + 4] = S + 2, t[r + 5] = S + 3;\n  return t;\n}\nfunction getBufferType(o) {\n  if (o.BYTES_PER_ELEMENT === 4)\n    return o instanceof Float32Array ? \"Float32Array\" : o instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (o.BYTES_PER_ELEMENT === 2) {\n    if (o instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (o.BYTES_PER_ELEMENT === 1 && o instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nfunction nextPow2(o) {\n  return o += o === 0 ? 1 : 0, --o, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o + 1;\n}\nfunction isPow2(o) {\n  return !(o & o - 1) && !!o;\n}\nfunction log2(o) {\n  var t = (o > 65535 ? 1 : 0) << 4;\n  o >>>= t;\n  var e = (o > 255 ? 1 : 0) << 3;\n  return o >>>= e, t |= e, e = (o > 15 ? 1 : 0) << 2, o >>>= e, t |= e, e = (o > 3 ? 1 : 0) << 1, o >>>= e, t |= e, t | o >> 1;\n}\nfunction removeItems(o, t, e) {\n  var r = o.length, S;\n  if (!(t >= r || e === 0)) {\n    e = t + e > r ? r - t : e;\n    var T = r - e;\n    for (S = t; S < T; ++S)\n      o[S] = o[S + e];\n    o.length = T;\n  }\n}\nfunction sign(o) {\n  return o === 0 ? 0 : o < 0 ? -1 : 1;\n}\nvar nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nvar warnings = {};\nfunction deprecation(o, t, e) {\n  if (e === void 0 && (e = 3), !warnings[t]) {\n    var r = new Error().stack;\n    typeof r > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + o) : (r = r.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + o), console.warn(r), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + o), console.warn(r))), warnings[t] = !0;\n  }\n}\nvar ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction clearTextureCache() {\n  var o;\n  for (o in TextureCache)\n    delete TextureCache[o];\n  for (o in BaseTextureCache)\n    delete BaseTextureCache[o];\n}\nvar CanvasRenderTarget = function() {\n  function o(t, e, r) {\n    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = r || settings.RESOLUTION, this.resize(t, e);\n  }\n  return o.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }, o.prototype.resize = function(t, e) {\n    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n  }, o.prototype.destroy = function() {\n    this.context = null, this.canvas = null;\n  }, Object.defineProperty(o.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(t) {\n      this.canvas.width = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(t) {\n      this.canvas.height = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}();\nfunction trimCanvas(o) {\n  var t = o.width, e = o.height, r = o.getContext(\"2d\", {\n    willReadFrequently: !0\n  }), S = r.getImageData(0, 0, t, e), T = S.data, D = T.length, N = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  }, B = null, $, U, V;\n  for ($ = 0; $ < D; $ += 4)\n    T[$ + 3] !== 0 && (U = $ / 4 % t, V = ~~($ / 4 / t), N.top === null && (N.top = V), (N.left === null || U < N.left) && (N.left = U), (N.right === null || N.right < U) && (N.right = U + 1), (N.bottom === null || N.bottom < V) && (N.bottom = V));\n  return N.top !== null && (t = N.right - N.left, e = N.bottom - N.top + 1, B = r.getImageData(N.left, N.top, t, e)), {\n    height: e,\n    width: t,\n    data: B\n  };\n}\nvar tempAnchor$1;\nfunction determineCrossOrigin(o, t) {\n  if (t === void 0 && (t = globalThis.location), o.indexOf(\"data:\") === 0)\n    return \"\";\n  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement(\"a\")), tempAnchor$1.href = o;\n  var e = url$1.parse(tempAnchor$1.href), r = !e.port && t.port === \"\" || e.port === t.port;\n  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? \"anonymous\" : \"\";\n}\nfunction getResolutionOfUrl(o, t) {\n  var e = settings.RETINA_PREFIX.exec(o);\n  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;\n}\nvar PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;\n(function(o) {\n  o[o.POLY = 0] = \"POLY\", o[o.RECT = 1] = \"RECT\", o[o.CIRC = 2] = \"CIRC\", o[o.ELIP = 3] = \"ELIP\", o[o.RREC = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\nvar Point = function() {\n  function o(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;\n  }\n  return o.prototype.clone = function() {\n    return new o(this.x, this.y);\n  }, o.prototype.copyFrom = function(t) {\n    return this.set(t.x, t.y), this;\n  }, o.prototype.copyTo = function(t) {\n    return t.set(this.x, this.y), t;\n  }, o.prototype.equals = function(t) {\n    return t.x === this.x && t.y === this.y;\n  }, o.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n  }, o;\n}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {\n  function o(t, e, r, S) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(S), this.type = SHAPES.RECT;\n  }\n  return Object.defineProperty(o.prototype, \"left\", {\n    get: function() {\n      return this.x;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"right\", {\n    get: function() {\n      return this.x + this.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"top\", {\n    get: function() {\n      return this.y;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"bottom\", {\n    get: function() {\n      return this.y + this.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"EMPTY\", {\n    get: function() {\n      return new o(0, 0, 0, 0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.clone = function() {\n    return new o(this.x, this.y, this.width, this.height);\n  }, o.prototype.copyFrom = function(t) {\n    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;\n  }, o.prototype.copyTo = function(t) {\n    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;\n  }, o.prototype.contains = function(t, e) {\n    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;\n  }, o.prototype.intersects = function(t, e) {\n    if (!e) {\n      var r = this.x < t.x ? t.x : this.x, S = this.right > t.right ? t.right : this.right;\n      if (S <= r)\n        return !1;\n      var T = this.y < t.y ? t.y : this.y, D = this.bottom > t.bottom ? t.bottom : this.bottom;\n      return D > T;\n    }\n    var N = this.left, B = this.right, $ = this.top, U = this.bottom;\n    if (B <= N || U <= $)\n      return !1;\n    var V = tempPoints$1[0].set(t.left, t.top), H = tempPoints$1[1].set(t.left, t.bottom), X = tempPoints$1[2].set(t.right, t.top), Y = tempPoints$1[3].set(t.right, t.bottom);\n    if (X.x <= V.x || H.y <= V.y)\n      return !1;\n    var W = Math.sign(e.a * e.d - e.b * e.c);\n    if (W === 0 || (e.apply(V, V), e.apply(H, H), e.apply(X, X), e.apply(Y, Y), Math.max(V.x, H.x, X.x, Y.x) <= N || Math.min(V.x, H.x, X.x, Y.x) >= B || Math.max(V.y, H.y, X.y, Y.y) <= $ || Math.min(V.y, H.y, X.y, Y.y) >= U))\n      return !1;\n    var q = W * (H.y - V.y), K = W * (V.x - H.x), Z = q * N + K * $, J = q * B + K * $, Q = q * N + K * U, rt = q * B + K * U;\n    if (Math.max(Z, J, Q, rt) <= q * V.x + K * V.y || Math.min(Z, J, Q, rt) >= q * Y.x + K * Y.y)\n      return !1;\n    var et = W * (V.y - X.y), nt = W * (X.x - V.x), st = et * N + nt * $, it = et * B + nt * $, at = et * N + nt * U, ut = et * B + nt * U;\n    return !(Math.max(st, it, at, ut) <= et * V.x + nt * V.y || Math.min(st, it, at, ut) >= et * Y.x + nt * Y.y);\n  }, o.prototype.pad = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;\n  }, o.prototype.fit = function(t) {\n    var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), S = Math.max(this.y, t.y), T = Math.min(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = Math.max(r - e, 0), this.y = S, this.height = Math.max(T - S, 0), this;\n  }, o.prototype.ceil = function(t, e) {\n    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);\n    var r = Math.ceil((this.x + this.width - e) * t) / t, S = Math.ceil((this.y + this.height - e) * t) / t;\n    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = S - this.y, this;\n  }, o.prototype.enlarge = function(t) {\n    var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), S = Math.min(this.y, t.y), T = Math.max(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = r - e, this.y = S, this.height = T - S, this;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, o;\n}(), Circle = function() {\n  function o(t, e, r) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = SHAPES.CIRC;\n  }\n  return o.prototype.clone = function() {\n    return new o(this.x, this.y, this.radius);\n  }, o.prototype.contains = function(t, e) {\n    if (this.radius <= 0)\n      return !1;\n    var r = this.radius * this.radius, S = this.x - t, T = this.y - e;\n    return S *= S, T *= T, S + T <= r;\n  }, o.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n  }, o;\n}(), Ellipse = function() {\n  function o(t, e, r, S) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), this.x = t, this.y = e, this.width = r, this.height = S, this.type = SHAPES.ELIP;\n  }\n  return o.prototype.clone = function() {\n    return new o(this.x, this.y, this.width, this.height);\n  }, o.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    var r = (t - this.x) / this.width, S = (e - this.y) / this.height;\n    return r *= r, S *= S, r + S <= 1;\n  }, o.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, o;\n}(), Polygon = function() {\n  function o() {\n    for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n      e[r] = t[r];\n    var S = Array.isArray(e[0]) ? e[0] : e;\n    if (typeof S[0] != \"number\") {\n      for (var T = [], D = 0, N = S.length; D < N; D++)\n        T.push(S[D].x, S[D].y);\n      S = T;\n    }\n    this.points = S, this.type = SHAPES.POLY, this.closeStroke = !0;\n  }\n  return o.prototype.clone = function() {\n    var t = this.points.slice(), e = new o(t);\n    return e.closeStroke = this.closeStroke, e;\n  }, o.prototype.contains = function(t, e) {\n    for (var r = !1, S = this.points.length / 2, T = 0, D = S - 1; T < S; D = T++) {\n      var N = this.points[T * 2], B = this.points[T * 2 + 1], $ = this.points[D * 2], U = this.points[D * 2 + 1], V = B > e != U > e && t < ($ - N) * ((e - B) / (U - B)) + N;\n      V && (r = !r);\n    }\n    return r;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(t, e) {\n      return t + \", \" + e;\n    }, \"\") + \"]\");\n  }, o;\n}(), RoundedRectangle = function() {\n  function o(t, e, r, S, T) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), T === void 0 && (T = 20), this.x = t, this.y = e, this.width = r, this.height = S, this.radius = T, this.type = SHAPES.RREC;\n  }\n  return o.prototype.clone = function() {\n    return new o(this.x, this.y, this.width, this.height, this.radius);\n  }, o.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {\n      var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n      if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)\n        return !0;\n      var S = t - (this.x + r), T = e - (this.y + r), D = r * r;\n      if (S * S + T * T <= D || (S = t - (this.x + this.width - r), S * S + T * T <= D) || (T = e - (this.y + this.height - r), S * S + T * T <= D) || (S = t - (this.x + r), S * S + T * T <= D))\n        return !0;\n    }\n    return !1;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n  }, o;\n}(), ObservablePoint = function() {\n  function o(t, e, r, S) {\n    r === void 0 && (r = 0), S === void 0 && (S = 0), this._x = r, this._y = S, this.cb = t, this.scope = e;\n  }\n  return o.prototype.clone = function(t, e) {\n    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new o(t, e, this._x, this._y);\n  }, o.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;\n  }, o.prototype.copyFrom = function(t) {\n    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;\n  }, o.prototype.copyTo = function(t) {\n    return t.set(this._x, this._y), t;\n  }, o.prototype.equals = function(t) {\n    return t.x === this._x && t.y === this._y;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:ObservablePoint x=\" + 0 + \" y=\" + 0 + \" scope=\" + this.scope + \"]\";\n  }, Object.defineProperty(o.prototype, \"x\", {\n    get: function() {\n      return this._x;\n    },\n    set: function(t) {\n      this._x !== t && (this._x = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"y\", {\n    get: function() {\n      return this._y;\n    },\n    set: function(t) {\n      this._y !== t && (this._y = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}(), Matrix = function() {\n  function o(t, e, r, S, T, D) {\n    t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 0), D === void 0 && (D = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = S, this.tx = T, this.ty = D;\n  }\n  return o.prototype.fromArray = function(t) {\n    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];\n  }, o.prototype.set = function(t, e, r, S, T, D) {\n    return this.a = t, this.b = e, this.c = r, this.d = S, this.tx = T, this.ty = D, this;\n  }, o.prototype.toArray = function(t, e) {\n    this.array || (this.array = new Float32Array(9));\n    var r = e || this.array;\n    return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;\n  }, o.prototype.apply = function(t, e) {\n    e = e || new Point();\n    var r = t.x, S = t.y;\n    return e.x = this.a * r + this.c * S + this.tx, e.y = this.b * r + this.d * S + this.ty, e;\n  }, o.prototype.applyInverse = function(t, e) {\n    e = e || new Point();\n    var r = 1 / (this.a * this.d + this.c * -this.b), S = t.x, T = t.y;\n    return e.x = this.d * r * S + -this.c * r * T + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * T + -this.b * r * S + (-this.ty * this.a + this.tx * this.b) * r, e;\n  }, o.prototype.translate = function(t, e) {\n    return this.tx += t, this.ty += e, this;\n  }, o.prototype.scale = function(t, e) {\n    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;\n  }, o.prototype.rotate = function(t) {\n    var e = Math.cos(t), r = Math.sin(t), S = this.a, T = this.c, D = this.tx;\n    return this.a = S * e - this.b * r, this.b = S * r + this.b * e, this.c = T * e - this.d * r, this.d = T * r + this.d * e, this.tx = D * e - this.ty * r, this.ty = D * r + this.ty * e, this;\n  }, o.prototype.append = function(t) {\n    var e = this.a, r = this.b, S = this.c, T = this.d;\n    return this.a = t.a * e + t.b * S, this.b = t.a * r + t.b * T, this.c = t.c * e + t.d * S, this.d = t.c * r + t.d * T, this.tx = t.tx * e + t.ty * S + this.tx, this.ty = t.tx * r + t.ty * T + this.ty, this;\n  }, o.prototype.setTransform = function(t, e, r, S, T, D, N, B, $) {\n    return this.a = Math.cos(N + $) * T, this.b = Math.sin(N + $) * T, this.c = -Math.sin(N - B) * D, this.d = Math.cos(N - B) * D, this.tx = t - (r * this.a + S * this.c), this.ty = e - (r * this.b + S * this.d), this;\n  }, o.prototype.prepend = function(t) {\n    var e = this.tx;\n    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {\n      var r = this.a, S = this.c;\n      this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = S * t.a + this.d * t.c, this.d = S * t.b + this.d * t.d;\n    }\n    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;\n  }, o.prototype.decompose = function(t) {\n    var e = this.a, r = this.b, S = this.c, T = this.d, D = t.pivot, N = -Math.atan2(-S, T), B = Math.atan2(r, e), $ = Math.abs(N + B);\n    return $ < 1e-5 || Math.abs(PI_2 - $) < 1e-5 ? (t.rotation = B, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = N, t.skew.y = B), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(S * S + T * T), t.position.x = this.tx + (D.x * e + D.y * S), t.position.y = this.ty + (D.x * r + D.y * T), t;\n  }, o.prototype.invert = function() {\n    var t = this.a, e = this.b, r = this.c, S = this.d, T = this.tx, D = t * S - e * r;\n    return this.a = S / D, this.b = -e / D, this.c = -r / D, this.d = t / D, this.tx = (r * this.ty - S * T) / D, this.ty = -(t * this.ty - e * T) / D, this;\n  }, o.prototype.identity = function() {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n  }, o.prototype.clone = function() {\n    var t = new o();\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, o.prototype.copyTo = function(t) {\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, o.prototype.copyFrom = function(t) {\n    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n  }, Object.defineProperty(o, \"IDENTITY\", {\n    get: function() {\n      return new o();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"TEMP_MATRIX\", {\n    get: function() {\n      return new o();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (var o = 0; o < 16; o++) {\n    var t = [];\n    rotationCayley.push(t);\n    for (var e = 0; e < 16; e++)\n      for (var r = signum(ux[o] * ux[e] + vx[o] * uy[e]), S = signum(uy[o] * ux[e] + vy[o] * uy[e]), T = signum(ux[o] * vx[e] + vx[o] * vy[e]), D = signum(uy[o] * vx[e] + vy[o] * vy[e]), N = 0; N < 16; N++)\n        if (ux[N] === r && uy[N] === S && vx[N] === T && vy[N] === D) {\n          t.push(N);\n          break;\n        }\n  }\n  for (var o = 0; o < 16; o++) {\n    var B = new Matrix();\n    B.set(ux[o], uy[o], vx[o], vy[o], 0, 0), rotationMatrices.push(B);\n  }\n}\ninit();\nvar groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: function(o) {\n    return ux[o];\n  },\n  uY: function(o) {\n    return uy[o];\n  },\n  vX: function(o) {\n    return vx[o];\n  },\n  vY: function(o) {\n    return vy[o];\n  },\n  inv: function(o) {\n    return o & 8 ? o & 15 : -o & 7;\n  },\n  add: function(o, t) {\n    return rotationCayley[o][t];\n  },\n  sub: function(o, t) {\n    return rotationCayley[o][groupD8.inv(t)];\n  },\n  rotate180: function(o) {\n    return o ^ 4;\n  },\n  isVertical: function(o) {\n    return (o & 3) === 2;\n  },\n  byDirection: function(o, t) {\n    return Math.abs(o) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(o) ? o > 0 ? groupD8.E : groupD8.W : t > 0 ? o > 0 ? groupD8.SE : groupD8.SW : o > 0 ? groupD8.NE : groupD8.NW;\n  },\n  matrixAppendRotationInv: function(o, t, e, r) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0);\n    var S = rotationMatrices[groupD8.inv(t)];\n    S.tx = e, S.ty = r, o.append(S);\n  }\n}, Transform = function() {\n  function o() {\n    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n  }\n  return o.prototype.onChange = function() {\n    this._localID++;\n  }, o.prototype.updateSkew = function() {\n    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n  }, o.prototype.updateLocalTransform = function() {\n    var t = this.localTransform;\n    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);\n  }, o.prototype.updateTransform = function(t) {\n    var e = this.localTransform;\n    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {\n      var r = t.worldTransform, S = this.worldTransform;\n      S.a = e.a * r.a + e.b * r.c, S.b = e.a * r.b + e.b * r.d, S.c = e.c * r.a + e.d * r.c, S.d = e.c * r.b + e.d * r.d, S.tx = e.tx * r.a + e.ty * r.c + r.tx, S.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;\n    }\n  }, o.prototype.setFromMatrix = function(t) {\n    t.decompose(this), this._localID++;\n  }, Object.defineProperty(o.prototype, \"rotation\", {\n    get: function() {\n      return this._rotation;\n    },\n    set: function(t) {\n      this._rotation !== t && (this._rotation = t, this.updateSkew());\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.IDENTITY = new o(), o;\n}();\nsettings.SORTABLE_CHILDREN = !1;\nvar Bounds = function() {\n  function o() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n  }\n  return o.prototype.isEmpty = function() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }, o.prototype.clear = function() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n  }, o.prototype.getRectangle = function(t) {\n    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);\n  }, o.prototype.addPoint = function(t) {\n    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);\n  }, o.prototype.addPointMatrix = function(t, e) {\n    var r = t.a, S = t.b, T = t.c, D = t.d, N = t.tx, B = t.ty, $ = r * e.x + T * e.y + N, U = S * e.x + D * e.y + B;\n    this.minX = Math.min(this.minX, $), this.maxX = Math.max(this.maxX, $), this.minY = Math.min(this.minY, U), this.maxY = Math.max(this.maxY, U);\n  }, o.prototype.addQuad = function(t) {\n    var e = this.minX, r = this.minY, S = this.maxX, T = this.maxY, D = t[0], N = t[1];\n    e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[2], N = t[3], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[4], N = t[5], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, D = t[6], N = t[7], e = D < e ? D : e, r = N < r ? N : r, S = D > S ? D : S, T = N > T ? N : T, this.minX = e, this.minY = r, this.maxX = S, this.maxY = T;\n  }, o.prototype.addFrame = function(t, e, r, S, T) {\n    this.addFrameMatrix(t.worldTransform, e, r, S, T);\n  }, o.prototype.addFrameMatrix = function(t, e, r, S, T) {\n    var D = t.a, N = t.b, B = t.c, $ = t.d, U = t.tx, V = t.ty, H = this.minX, X = this.minY, Y = this.maxX, W = this.maxY, q = D * e + B * r + U, K = N * e + $ * r + V;\n    H = q < H ? q : H, X = K < X ? K : X, Y = q > Y ? q : Y, W = K > W ? K : W, q = D * S + B * r + U, K = N * S + $ * r + V, H = q < H ? q : H, X = K < X ? K : X, Y = q > Y ? q : Y, W = K > W ? K : W, q = D * e + B * T + U, K = N * e + $ * T + V, H = q < H ? q : H, X = K < X ? K : X, Y = q > Y ? q : Y, W = K > W ? K : W, q = D * S + B * T + U, K = N * S + $ * T + V, H = q < H ? q : H, X = K < X ? K : X, Y = q > Y ? q : Y, W = K > W ? K : W, this.minX = H, this.minY = X, this.maxX = Y, this.maxY = W;\n  }, o.prototype.addVertexData = function(t, e, r) {\n    for (var S = this.minX, T = this.minY, D = this.maxX, N = this.maxY, B = e; B < r; B += 2) {\n      var $ = t[B], U = t[B + 1];\n      S = $ < S ? $ : S, T = U < T ? U : T, D = $ > D ? $ : D, N = U > N ? U : N;\n    }\n    this.minX = S, this.minY = T, this.maxX = D, this.maxY = N;\n  }, o.prototype.addVertices = function(t, e, r, S) {\n    this.addVerticesMatrix(t.worldTransform, e, r, S);\n  }, o.prototype.addVerticesMatrix = function(t, e, r, S, T, D) {\n    T === void 0 && (T = 0), D === void 0 && (D = T);\n    for (var N = t.a, B = t.b, $ = t.c, U = t.d, V = t.tx, H = t.ty, X = this.minX, Y = this.minY, W = this.maxX, q = this.maxY, K = r; K < S; K += 2) {\n      var Z = e[K], J = e[K + 1], Q = N * Z + $ * J + V, rt = U * J + B * Z + H;\n      X = Math.min(X, Q - T), W = Math.max(W, Q + T), Y = Math.min(Y, rt - D), q = Math.max(q, rt + D);\n    }\n    this.minX = X, this.minY = Y, this.maxX = W, this.maxY = q;\n  }, o.prototype.addBounds = function(t) {\n    var e = this.minX, r = this.minY, S = this.maxX, T = this.maxY;\n    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > S ? t.maxX : S, this.maxY = t.maxY > T ? t.maxY : T;\n  }, o.prototype.addBoundsMask = function(t, e) {\n    var r = t.minX > e.minX ? t.minX : e.minX, S = t.minY > e.minY ? t.minY : e.minY, T = t.maxX < e.maxX ? t.maxX : e.maxX, D = t.maxY < e.maxY ? t.maxY : e.maxY;\n    if (r <= T && S <= D) {\n      var N = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;\n      this.minX = r < N ? r : N, this.minY = S < B ? S : B, this.maxX = T > $ ? T : $, this.maxY = D > U ? D : U;\n    }\n  }, o.prototype.addBoundsMatrix = function(t, e) {\n    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);\n  }, o.prototype.addBoundsArea = function(t, e) {\n    var r = t.minX > e.x ? t.minX : e.x, S = t.minY > e.y ? t.minY : e.y, T = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, D = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;\n    if (r <= T && S <= D) {\n      var N = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;\n      this.minX = r < N ? r : N, this.minY = S < B ? S : B, this.maxX = T > $ ? T : $, this.maxY = D > U ? D : U;\n    }\n  }, o.prototype.pad = function(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);\n  }, o.prototype.addFramePad = function(t, e, r, S, T, D) {\n    t -= T, e -= D, r += T, S += D, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > S ? this.maxY : S;\n  }, o;\n}();\nvar extendStatics$q = function(o, t) {\n  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$q(o, t);\n};\nfunction __extends$q(o, t) {\n  extendStatics$q(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar DisplayObject = function(o) {\n  __extends$q(t, o);\n  function t() {\n    var e = o.call(this) || this;\n    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;\n  }\n  return t.mixin = function(e) {\n    for (var r = Object.keys(e), S = 0; S < r.length; ++S) {\n      var T = r[S];\n      Object.defineProperty(t.prototype, T, Object.getOwnPropertyDescriptor(e, T));\n    }\n  }, Object.defineProperty(t.prototype, \"destroyed\", {\n    get: function() {\n      return this._destroyed;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._recursivePostUpdateTransform = function() {\n    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n  }, t.prototype.updateTransform = function() {\n    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }, t.prototype.getBounds = function(e, r) {\n    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Rectangle()), r = this._boundsRect), this._bounds.getRectangle(r);\n  }, t.prototype.getLocalBounds = function(e) {\n    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());\n    var r = this.transform, S = this.parent;\n    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;\n    var T = this._bounds, D = this._boundsID;\n    this._bounds = this._localBounds;\n    var N = this.getBounds(!1, e);\n    return this.parent = S, this.transform = r, this._bounds = T, this._bounds.updateID += this._boundsID - D, N;\n  }, t.prototype.toGlobal = function(e, r, S) {\n    return S === void 0 && (S = !1), S || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);\n  }, t.prototype.toLocal = function(e, r, S, T) {\n    return r && (e = r.toGlobal(e, S, T)), T || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, S);\n  }, t.prototype.setParent = function(e) {\n    if (!e || !e.addChild)\n      throw new Error(\"setParent: Argument must be a Container\");\n    return e.addChild(this), e;\n  }, t.prototype.setTransform = function(e, r, S, T, D, N, B, $, U) {\n    return e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 1), D === void 0 && (D = 0), N === void 0 && (N = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), this.position.x = e, this.position.y = r, this.scale.x = S || 1, this.scale.y = T || 1, this.rotation = D, this.skew.x = N, this.skew.y = B, this.pivot.x = $, this.pivot.y = U, this;\n  }, t.prototype.destroy = function(e) {\n    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit(\"destroyed\"), this.removeAllListeners();\n  }, Object.defineProperty(t.prototype, \"_tempDisplayObjectParent\", {\n    get: function() {\n      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.enableTempParent = function() {\n    var e = this.parent;\n    return this.parent = this._tempDisplayObjectParent, e;\n  }, t.prototype.disableTempParent = function(e) {\n    this.parent = e;\n  }, Object.defineProperty(t.prototype, \"x\", {\n    get: function() {\n      return this.position.x;\n    },\n    set: function(e) {\n      this.transform.position.x = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"y\", {\n    get: function() {\n      return this.position.y;\n    },\n    set: function(e) {\n      this.transform.position.y = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldTransform\", {\n    get: function() {\n      return this.transform.worldTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"localTransform\", {\n    get: function() {\n      return this.transform.localTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"position\", {\n    get: function() {\n      return this.transform.position;\n    },\n    set: function(e) {\n      this.transform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scale\", {\n    get: function() {\n      return this.transform.scale;\n    },\n    set: function(e) {\n      this.transform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"pivot\", {\n    get: function() {\n      return this.transform.pivot;\n    },\n    set: function(e) {\n      this.transform.pivot.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"skew\", {\n    get: function() {\n      return this.transform.skew;\n    },\n    set: function(e) {\n      this.transform.skew.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotation\", {\n    get: function() {\n      return this.transform.rotation;\n    },\n    set: function(e) {\n      this.transform.rotation = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"angle\", {\n    get: function() {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function(e) {\n      this.transform.rotation = e * DEG_TO_RAD;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"zIndex\", {\n    get: function() {\n      return this._zIndex;\n    },\n    set: function(e) {\n      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldVisible\", {\n    get: function() {\n      var e = this;\n      do {\n        if (!e.visible)\n          return !1;\n        e = e.parent;\n      } while (e);\n      return !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mask\", {\n    get: function() {\n      return this._mask;\n    },\n    set: function(e) {\n      if (this._mask !== e) {\n        if (this._mask) {\n          var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));\n        }\n        if (this._mask = e, this._mask) {\n          var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);\n        }\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), TemporaryDisplayObject = function(o) {\n  __extends$q(t, o);\n  function t() {\n    var e = o !== null && o.apply(this, arguments) || this;\n    return e.sortDirty = null, e;\n  }\n  return t;\n}(DisplayObject);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\nfunction sortChildren(o, t) {\n  return o.zIndex === t.zIndex ? o._lastSortedIndex - t._lastSortedIndex : o.zIndex - t.zIndex;\n}\nvar Container = function(o) {\n  __extends$q(t, o);\n  function t() {\n    var e = o.call(this) || this;\n    return e.children = [], e.sortableChildren = settings.SORTABLE_CHILDREN, e.sortDirty = !1, e;\n  }\n  return t.prototype.onChildrenChange = function(e) {\n  }, t.prototype.addChild = function() {\n    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)\n      r[S] = e[S];\n    if (r.length > 1)\n      for (var T = 0; T < r.length; T++)\n        this.addChild(r[T]);\n    else {\n      var D = r[0];\n      D.parent && D.parent.removeChild(D), D.parent = this, this.sortDirty = !0, D.transform._parentID = -1, this.children.push(D), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit(\"childAdded\", D, this, this.children.length - 1), D.emit(\"added\", this);\n    }\n    return r[0];\n  }, t.prototype.addChildAt = function(e, r) {\n    if (r < 0 || r > this.children.length)\n      throw new Error(e + \"addChildAt: The index \" + r + \" supplied is out of bounds \" + this.children.length);\n    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit(\"added\", this), this.emit(\"childAdded\", e, this, r), e;\n  }, t.prototype.swapChildren = function(e, r) {\n    if (e !== r) {\n      var S = this.getChildIndex(e), T = this.getChildIndex(r);\n      this.children[S] = r, this.children[T] = e, this.onChildrenChange(S < T ? S : T);\n    }\n  }, t.prototype.getChildIndex = function(e) {\n    var r = this.children.indexOf(e);\n    if (r === -1)\n      throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n    return r;\n  }, t.prototype.setChildIndex = function(e, r) {\n    if (r < 0 || r >= this.children.length)\n      throw new Error(\"The index \" + r + \" supplied is out of bounds \" + this.children.length);\n    var S = this.getChildIndex(e);\n    removeItems(this.children, S, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);\n  }, t.prototype.getChildAt = function(e) {\n    if (e < 0 || e >= this.children.length)\n      throw new Error(\"getChildAt: Index (\" + e + \") does not exist.\");\n    return this.children[e];\n  }, t.prototype.removeChild = function() {\n    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)\n      r[S] = e[S];\n    if (r.length > 1)\n      for (var T = 0; T < r.length; T++)\n        this.removeChild(r[T]);\n    else {\n      var D = r[0], N = this.children.indexOf(D);\n      if (N === -1)\n        return null;\n      D.parent = null, D.transform._parentID = -1, removeItems(this.children, N, 1), this._boundsID++, this.onChildrenChange(N), D.emit(\"removed\", this), this.emit(\"childRemoved\", D, this, N);\n    }\n    return r[0];\n  }, t.prototype.removeChildAt = function(e) {\n    var r = this.getChildAt(e);\n    return r.parent = null, r.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit(\"removed\", this), this.emit(\"childRemoved\", r, this, e), r;\n  }, t.prototype.removeChildren = function(e, r) {\n    e === void 0 && (e = 0), r === void 0 && (r = this.children.length);\n    var S = e, T = r, D = T - S, N;\n    if (D > 0 && D <= T) {\n      N = this.children.splice(S, D);\n      for (var B = 0; B < N.length; ++B)\n        N[B].parent = null, N[B].transform && (N[B].transform._parentID = -1);\n      this._boundsID++, this.onChildrenChange(e);\n      for (var B = 0; B < N.length; ++B)\n        N[B].emit(\"removed\", this), this.emit(\"childRemoved\", N[B], this, B);\n      return N;\n    } else if (D === 0 && this.children.length === 0)\n      return [];\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  }, t.prototype.sortChildren = function() {\n    for (var e = !1, r = 0, S = this.children.length; r < S; ++r) {\n      var T = this.children[r];\n      T._lastSortedIndex = r, !e && T.zIndex !== 0 && (e = !0);\n    }\n    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var e = 0, r = this.children.length; e < r; ++e) {\n      var S = this.children[e];\n      S.visible && S.updateTransform();\n    }\n  }, t.prototype.calculateBounds = function() {\n    this._bounds.clear(), this._calculateBounds();\n    for (var e = 0; e < this.children.length; e++) {\n      var r = this.children[e];\n      if (!(!r.visible || !r.renderable))\n        if (r.calculateBounds(), r._mask) {\n          var S = r._mask.isMaskData ? r._mask.maskObject : r._mask;\n          S ? (S.calculateBounds(), this._bounds.addBoundsMask(r._bounds, S._bounds)) : this._bounds.addBounds(r._bounds);\n        } else\n          r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);\n    }\n    this._bounds.updateID = this._boundsID;\n  }, t.prototype.getLocalBounds = function(e, r) {\n    r === void 0 && (r = !1);\n    var S = o.prototype.getLocalBounds.call(this, e);\n    if (!r)\n      for (var T = 0, D = this.children.length; T < D; ++T) {\n        var N = this.children[T];\n        N.visible && N.updateTransform();\n      }\n    return S;\n  }, t.prototype._calculateBounds = function() {\n  }, t.prototype._renderWithCulling = function(e) {\n    var r = e.renderTexture.sourceFrame;\n    if (r.width > 0 && r.height > 0) {\n      var S, T;\n      if (this.cullArea ? (S = this.cullArea, T = this.worldTransform) : this._render !== t.prototype._render && (S = this.getBounds(!0)), S && r.intersects(S, T))\n        this._render(e);\n      else if (this.cullArea)\n        return;\n      for (var D = 0, N = this.children.length; D < N; ++D) {\n        var B = this.children[D], $ = B.cullable;\n        B.cullable = $ || !this.cullArea, B.render(e), B.cullable = $;\n      }\n    }\n  }, t.prototype.render = function(e) {\n    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n      if (this._mask || this.filters && this.filters.length)\n        this.renderAdvanced(e);\n      else if (this.cullable)\n        this._renderWithCulling(e);\n      else {\n        this._render(e);\n        for (var r = 0, S = this.children.length; r < S; ++r)\n          this.children[r].render(e);\n      }\n  }, t.prototype.renderAdvanced = function(e) {\n    var r = this.filters, S = this._mask;\n    if (r) {\n      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n      for (var T = 0; T < r.length; T++)\n        r[T].enabled && this._enabledFilters.push(r[T]);\n    }\n    var D = r && this._enabledFilters && this._enabledFilters.length || S && (!S.isMaskData || S.enabled && (S.autoDetect || S.type !== MASK_TYPES.NONE));\n    if (D && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), S && e.mask.push(this, this._mask), this.cullable)\n      this._renderWithCulling(e);\n    else {\n      this._render(e);\n      for (var T = 0, N = this.children.length; T < N; ++T)\n        this.children[T].render(e);\n    }\n    D && e.batch.flush(), S && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();\n  }, t.prototype._render = function(e) {\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this), this.sortDirty = !1;\n    var r = typeof e == \"boolean\" ? e : e && e.children, S = this.removeChildren(0, this.children.length);\n    if (r)\n      for (var T = 0; T < S.length; ++T)\n        S[T].destroy(e);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(e) {\n      var r = this.getLocalBounds().width;\n      r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(e) {\n      var r = this.getLocalBounds().height;\n      r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(DisplayObject);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\nvar __assign$8 = function() {\n  return __assign$8 = Object.assign || function(t) {\n    for (var e = arguments, r, S = 1, T = arguments.length; S < T; S++) {\n      r = e[S];\n      for (var D in r)\n        Object.prototype.hasOwnProperty.call(r, D) && (t[D] = r[D]);\n    }\n    return t;\n  }, __assign$8.apply(this, arguments);\n}, ExtensionType;\n(function(o) {\n  o.Application = \"application\", o.RendererPlugin = \"renderer-webgl-plugin\", o.CanvasRendererPlugin = \"renderer-canvas-plugin\", o.Loader = \"loader\", o.LoadParser = \"load-parser\", o.ResolveParser = \"resolve-parser\", o.CacheParser = \"cache-parser\", o.DetectionParser = \"detection-parser\";\n})(ExtensionType || (ExtensionType = {}));\nvar normalizeExtension = function(o) {\n  if (typeof o == \"function\" || typeof o == \"object\" && o.extension) {\n    if (!o.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    var t = typeof o.extension != \"object\" ? { type: o.extension } : o.extension;\n    o = __assign$8(__assign$8({}, t), { ref: o });\n  }\n  if (typeof o == \"object\")\n    o = __assign$8({}, o);\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof o.type == \"string\" && (o.type = [o.type]), o;\n}, extensions = {\n  _addHandlers: null,\n  _removeHandlers: null,\n  _queue: {},\n  remove: function() {\n    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = o[r];\n    return e.map(normalizeExtension).forEach(function(S) {\n      S.type.forEach(function(T) {\n        var D, N;\n        return (N = (D = t._removeHandlers)[T]) === null || N === void 0 ? void 0 : N.call(D, S);\n      });\n    }), this;\n  },\n  add: function() {\n    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = o[r];\n    return e.map(normalizeExtension).forEach(function(S) {\n      S.type.forEach(function(T) {\n        var D = t._addHandlers, N = t._queue;\n        D[T] ? D[T](S) : (N[T] = N[T] || [], N[T].push(S));\n      });\n    }), this;\n  },\n  handle: function(o, t, e) {\n    var r = this._addHandlers = this._addHandlers || {}, S = this._removeHandlers = this._removeHandlers || {};\n    if (r[o] || S[o])\n      throw new Error(\"Extension type \" + o + \" already has a handler\");\n    r[o] = t, S[o] = e;\n    var T = this._queue;\n    return T[o] && (T[o].forEach(function(D) {\n      return t(D);\n    }), delete T[o]), this;\n  },\n  handleByMap: function(o, t) {\n    return this.handle(o, function(e) {\n      t[e.name] = e.ref;\n    }, function(e) {\n      delete t[e.name];\n    });\n  },\n  handleByList: function(o, t) {\n    return this.handle(o, function(e) {\n      var r, S;\n      t.push(e.ref), o === ExtensionType.Loader && ((S = (r = e.ref).add) === null || S === void 0 || S.call(r));\n    }, function(e) {\n      var r = t.indexOf(e.ref);\n      r !== -1 && t.splice(r, 1);\n    });\n  }\n};\nvar Runner = function() {\n  function o(t) {\n    this.items = [], this._name = t, this._aliasCount = 0;\n  }\n  return o.prototype.emit = function(t, e, r, S, T, D, N, B) {\n    if (arguments.length > 8)\n      throw new Error(\"max arguments reached\");\n    var $ = this, U = $.name, V = $.items;\n    this._aliasCount++;\n    for (var H = 0, X = V.length; H < X; H++)\n      V[H][U](t, e, r, S, T, D, N, B);\n    return V === this.items && this._aliasCount--, this;\n  }, o.prototype.ensureNonAliasedItems = function() {\n    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n  }, o.prototype.add = function(t) {\n    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;\n  }, o.prototype.remove = function(t) {\n    var e = this.items.indexOf(t);\n    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;\n  }, o.prototype.contains = function(t) {\n    return this.items.indexOf(t) !== -1;\n  }, o.prototype.removeAll = function() {\n    return this.ensureNonAliasedItems(), this.items.length = 0, this;\n  }, o.prototype.destroy = function() {\n    this.removeAll(), this.items = null, this._name = null;\n  }, Object.defineProperty(o.prototype, \"empty\", {\n    get: function() {\n      return this.items.length === 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"name\", {\n    get: function() {\n      return this._name;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}();\nObject.defineProperties(Runner.prototype, {\n  dispatch: { value: Runner.prototype.emit },\n  run: { value: Runner.prototype.emit }\n});\nsettings.TARGET_FPMS = 0.06;\nvar UPDATE_PRIORITY;\n(function(o) {\n  o[o.INTERACTION = 50] = \"INTERACTION\", o[o.HIGH = 25] = \"HIGH\", o[o.NORMAL = 0] = \"NORMAL\", o[o.LOW = -25] = \"LOW\", o[o.UTILITY = -50] = \"UTILITY\";\n})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));\nvar TickerListener = function() {\n  function o(t, e, r, S) {\n    e === void 0 && (e = null), r === void 0 && (r = 0), S === void 0 && (S = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = S;\n  }\n  return o.prototype.match = function(t, e) {\n    return e === void 0 && (e = null), this.fn === t && this.context === e;\n  }, o.prototype.emit = function(t) {\n    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));\n    var e = this.next;\n    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;\n  }, o.prototype.connect = function(t) {\n    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;\n  }, o.prototype.destroy = function(t) {\n    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n    var e = this.next;\n    return this.next = t ? null : e, this.previous = null, e;\n  }, o;\n}(), Ticker = function() {\n  function o() {\n    var t = this;\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings.TARGET_FPMS, this.elapsedMS = 1 / settings.TARGET_FPMS, this._tick = function(e) {\n      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));\n    };\n  }\n  return o.prototype._requestIfNeeded = function() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }, o.prototype._cancelIfNeeded = function() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }, o.prototype._startIfPossible = function() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }, o.prototype.add = function(t, e, r) {\n    return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r));\n  }, o.prototype.addOnce = function(t, e, r) {\n    return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r, !0));\n  }, o.prototype._addListener = function(t) {\n    var e = this._head.next, r = this._head;\n    if (!e)\n      t.connect(r);\n    else {\n      for (; e; ) {\n        if (t.priority > e.priority) {\n          t.connect(r);\n          break;\n        }\n        r = e, e = e.next;\n      }\n      t.previous || t.connect(r);\n    }\n    return this._startIfPossible(), this;\n  }, o.prototype.remove = function(t, e) {\n    for (var r = this._head.next; r; )\n      r.match(t, e) ? r = r.destroy() : r = r.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }, Object.defineProperty(o.prototype, \"count\", {\n    get: function() {\n      if (!this._head)\n        return 0;\n      for (var t = 0, e = this._head; e = e.next; )\n        t++;\n      return t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.start = function() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }, o.prototype.stop = function() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }, o.prototype.destroy = function() {\n    if (!this._protected) {\n      this.stop();\n      for (var t = this._head.next; t; )\n        t = t.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }, o.prototype.update = function(t) {\n    t === void 0 && (t = performance.now());\n    var e;\n    if (t > this.lastTime) {\n      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {\n        var r = t - this._lastFrame | 0;\n        if (r < this._minElapsedMS)\n          return;\n        this._lastFrame = t - r % this._minElapsedMS;\n      }\n      this.deltaMS = e, this.deltaTime = this.deltaMS * settings.TARGET_FPMS;\n      for (var S = this._head, T = S.next; T; )\n        T = T.emit(this.deltaTime);\n      S.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = t;\n  }, Object.defineProperty(o.prototype, \"FPS\", {\n    get: function() {\n      return 1e3 / this.elapsedMS;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"minFPS\", {\n    get: function() {\n      return 1e3 / this._maxElapsedMS;\n    },\n    set: function(t) {\n      var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, settings.TARGET_FPMS);\n      this._maxElapsedMS = 1 / r;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"maxFPS\", {\n    get: function() {\n      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n    },\n    set: function(t) {\n      if (t === 0)\n        this._minElapsedMS = 0;\n      else {\n        var e = Math.max(this.minFPS, t);\n        this._minElapsedMS = 1 / (e / 1e3);\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"shared\", {\n    get: function() {\n      if (!o._shared) {\n        var t = o._shared = new o();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return o._shared;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"system\", {\n    get: function() {\n      if (!o._system) {\n        var t = o._system = new o();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return o._system;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}(), TickerPlugin = function() {\n  function o() {\n  }\n  return o.init = function(t) {\n    var e = this;\n    t = Object.assign({\n      autoStart: !0,\n      sharedTicker: !1\n    }, t), Object.defineProperty(this, \"ticker\", {\n      set: function(r) {\n        this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, UPDATE_PRIORITY.LOW);\n      },\n      get: function() {\n        return this._ticker;\n      }\n    }), this.stop = function() {\n      e._ticker.stop();\n    }, this.start = function() {\n      e._ticker.start();\n    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();\n  }, o.destroy = function() {\n    if (this._ticker) {\n      var t = this._ticker;\n      this.ticker = null, t.destroy();\n    }\n  }, o.extension = ExtensionType.Application, o;\n}();\nsettings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;\nsettings.STRICT_TEXTURE_CACHE = !1;\nvar INSTALLED = [];\nfunction autoDetectResource(o, t) {\n  if (!o)\n    return null;\n  var e = \"\";\n  if (typeof o == \"string\") {\n    var r = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(o);\n    r && (e = r[1].toLowerCase());\n  }\n  for (var S = INSTALLED.length - 1; S >= 0; --S) {\n    var T = INSTALLED[S];\n    if (T.test && T.test(o, e))\n      return new T(o, t);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\nvar extendStatics$p = function(o, t) {\n  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$p(o, t);\n};\nfunction __extends$p(o, t) {\n  extendStatics$p(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$7 = function() {\n  return __assign$7 = Object.assign || function(t) {\n    for (var e = arguments, r, S = 1, T = arguments.length; S < T; S++) {\n      r = e[S];\n      for (var D in r)\n        Object.prototype.hasOwnProperty.call(r, D) && (t[D] = r[D]);\n    }\n    return t;\n  }, __assign$7.apply(this, arguments);\n};\nfunction __rest$3(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)\n      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);\n  return e;\n}\nvar Resource = function() {\n  function o(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner(\"setRealSize\"), this.onUpdate = new Runner(\"update\"), this.onError = new Runner(\"onError\");\n  }\n  return o.prototype.bind = function(t) {\n    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n  }, o.prototype.unbind = function(t) {\n    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);\n  }, o.prototype.resize = function(t, e) {\n    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));\n  }, Object.defineProperty(o.prototype, \"valid\", {\n    get: function() {\n      return !!this._width && !!this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.update = function() {\n    this.destroyed || this.onUpdate.emit();\n  }, o.prototype.load = function() {\n    return Promise.resolve(this);\n  }, Object.defineProperty(o.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.style = function(t, e, r) {\n    return !1;\n  }, o.prototype.dispose = function() {\n  }, o.prototype.destroy = function() {\n    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n  }, o.test = function(t, e) {\n    return !1;\n  }, o;\n}(), BufferResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this, T = r || {}, D = T.width, N = T.height;\n    if (!D || !N)\n      throw new Error(\"BufferResource width or height invalid\");\n    return S = o.call(this, D, N) || this, S.data = e, S;\n  }\n  return t.prototype.upload = function(e, r, S) {\n    var T = e.gl;\n    T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);\n    var D = r.realWidth, N = r.realHeight;\n    return S.width === D && S.height === N ? T.texSubImage2D(r.target, 0, 0, 0, D, N, r.format, S.type, this.data) : (S.width = D, S.height = N, T.texImage2D(r.target, 0, S.internalFormat, D, N, 0, r.format, S.type, this.data)), !0;\n  }, t.prototype.dispose = function() {\n    this.data = null;\n  }, t.test = function(e) {\n    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;\n  }, t;\n}(Resource), defaultBufferOptions = {\n  scaleMode: SCALE_MODES.NEAREST,\n  format: FORMATS.RGBA,\n  alphaMode: ALPHA_MODES.NPM\n}, BaseTexture = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    e === void 0 && (e = null), r === void 0 && (r = null);\n    var S = o.call(this) || this;\n    r = r || {};\n    var T = r.alphaMode, D = r.mipmap, N = r.anisotropicLevel, B = r.scaleMode, $ = r.width, U = r.height, V = r.wrapMode, H = r.format, X = r.type, Y = r.target, W = r.resolution, q = r.resourceOptions;\n    return e && !(e instanceof Resource) && (e = autoDetectResource(e, q), e.internal = !0), S.resolution = W || settings.RESOLUTION, S.width = Math.round(($ || 0) * S.resolution) / S.resolution, S.height = Math.round((U || 0) * S.resolution) / S.resolution, S._mipmap = D !== void 0 ? D : settings.MIPMAP_TEXTURES, S.anisotropicLevel = N !== void 0 ? N : settings.ANISOTROPIC_LEVEL, S._wrapMode = V || settings.WRAP_MODE, S._scaleMode = B !== void 0 ? B : settings.SCALE_MODE, S.format = H || FORMATS.RGBA, S.type = X || TYPES.UNSIGNED_BYTE, S.target = Y || TARGETS.TEXTURE_2D, S.alphaMode = T !== void 0 ? T : ALPHA_MODES.UNPACK, S.uid = uid(), S.touched = 0, S.isPowerOfTwo = !1, S._refreshPOT(), S._glTextures = {}, S.dirtyId = 0, S.dirtyStyleId = 0, S.cacheId = null, S.valid = $ > 0 && U > 0, S.textureCacheIds = [], S.destroyed = !1, S.resource = null, S._batchEnabled = 0, S._batchLocation = 0, S.parentTextureArray = null, S.setResource(e), S;\n  }\n  return Object.defineProperty(t.prototype, \"realWidth\", {\n    get: function() {\n      return Math.round(this.width * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"realHeight\", {\n    get: function() {\n      return Math.round(this.height * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mipmap\", {\n    get: function() {\n      return this._mipmap;\n    },\n    set: function(e) {\n      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scaleMode\", {\n    get: function() {\n      return this._scaleMode;\n    },\n    set: function(e) {\n      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"wrapMode\", {\n    get: function() {\n      return this._wrapMode;\n    },\n    set: function(e) {\n      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.setStyle = function(e, r) {\n    var S;\n    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, S = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, S = !0), S && this.dirtyStyleId++, this;\n  }, t.prototype.setSize = function(e, r, S) {\n    return S = S || this.resolution, this.setRealSize(e * S, r * S, S);\n  }, t.prototype.setRealSize = function(e, r, S) {\n    return this.resolution = S || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;\n  }, t.prototype._refreshPOT = function() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  }, t.prototype.setResolution = function(e) {\n    var r = this.resolution;\n    return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit(\"update\", this)), this._refreshPOT(), this);\n  }, t.prototype.setResource = function(e) {\n    if (this.resource === e)\n      return this;\n    if (this.resource)\n      throw new Error(\"Resource can be set only once\");\n    return e.bind(this), this.resource = e, this;\n  }, t.prototype.update = function() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n  }, t.prototype.onError = function(e) {\n    this.emit(\"error\", this, e);\n  }, t.prototype.destroy = function() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;\n  }, t.prototype.dispose = function() {\n    this.emit(\"dispose\", this);\n  }, t.prototype.castToBaseTexture = function() {\n    return this;\n  }, t.from = function(e, r, S) {\n    S === void 0 && (S = settings.STRICT_TEXTURE_CACHE);\n    var T = typeof e == \"string\", D = null;\n    if (T)\n      D = e;\n    else {\n      if (!e._pixiId) {\n        var N = r && r.pixiIdPrefix || \"pixiid\";\n        e._pixiId = N + \"_\" + uid();\n      }\n      D = e._pixiId;\n    }\n    var B = BaseTextureCache[D];\n    if (T && S && !B)\n      throw new Error('The cacheId \"' + D + '\" does not exist in BaseTextureCache.');\n    return B || (B = new t(e, r), B.cacheId = D, t.addToCache(B, D)), B;\n  }, t.fromBuffer = function(e, r, S, T) {\n    e = e || new Float32Array(r * S * 4);\n    var D = new BufferResource(e, { width: r, height: S }), N = e instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;\n    return new t(D, Object.assign({}, defaultBufferOptions, T || { width: r, height: S, type: N }));\n  }, t.addToCache = function(e, r) {\n    r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), BaseTextureCache[r] && console.warn(\"BaseTexture added to the cache with an id [\" + r + \"] that already had an entry\"), BaseTextureCache[r] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var r = BaseTextureCache[e];\n      if (r) {\n        var S = r.textureCacheIds.indexOf(e);\n        return S > -1 && r.textureCacheIds.splice(S, 1), delete BaseTextureCache[e], r;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var T = 0; T < e.textureCacheIds.length; ++T)\n        delete BaseTextureCache[e.textureCacheIds[T]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, t._globalBatch = 0, t;\n}(i$1), AbstractMultiResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this, T = r || {}, D = T.width, N = T.height;\n    S = o.call(this, D, N) || this, S.items = [], S.itemDirtyIds = [];\n    for (var B = 0; B < e; B++) {\n      var $ = new BaseTexture();\n      S.items.push($), S.itemDirtyIds.push(-2);\n    }\n    return S.length = e, S._load = null, S.baseTexture = null, S;\n  }\n  return t.prototype.initFromArray = function(e, r) {\n    for (var S = 0; S < this.length; S++)\n      !e[S] || (e[S].castToBaseTexture ? this.addBaseTextureAt(e[S].castToBaseTexture(), S) : e[S] instanceof Resource ? this.addResourceAt(e[S], S) : this.addResourceAt(autoDetectResource(e[S], r), S));\n  }, t.prototype.dispose = function() {\n    for (var e = 0, r = this.length; e < r; e++)\n      this.items[e].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }, t.prototype.addResourceAt = function(e, r) {\n    if (!this.items[r])\n      throw new Error(\"Index \" + r + \" is out of bounds\");\n    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;\n  }, t.prototype.bind = function(e) {\n    if (this.baseTexture !== null)\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    o.prototype.bind.call(this, e);\n    for (var r = 0; r < this.length; r++)\n      this.items[r].parentTextureArray = e, this.items[r].on(\"update\", e.update, e);\n  }, t.prototype.unbind = function(e) {\n    o.prototype.unbind.call(this, e);\n    for (var r = 0; r < this.length; r++)\n      this.items[r].parentTextureArray = null, this.items[r].off(\"update\", e.update, e);\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var r = this.items.map(function(T) {\n      return T.resource;\n    }).filter(function(T) {\n      return T;\n    }), S = r.map(function(T) {\n      return T.load();\n    });\n    return this._load = Promise.all(S).then(function() {\n      var T = e.items[0], D = T.realWidth, N = T.realHeight;\n      return e.resize(D, N), Promise.resolve(e);\n    }), this._load;\n  }, t;\n}(Resource), ArrayResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this, T = r || {}, D = T.width, N = T.height, B, $;\n    return Array.isArray(e) ? (B = e, $ = e.length) : $ = e, S = o.call(this, $, { width: D, height: N }) || this, B && S.initFromArray(B, r), S;\n  }\n  return t.prototype.addBaseTextureAt = function(e, r) {\n    if (e.resource)\n      this.addResourceAt(e.resource, r);\n    else\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    return this;\n  }, t.prototype.bind = function(e) {\n    o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_2D_ARRAY;\n  }, t.prototype.upload = function(e, r, S) {\n    var T = this, D = T.length, N = T.itemDirtyIds, B = T.items, $ = e.gl;\n    S.dirtyId < 0 && $.texImage3D($.TEXTURE_2D_ARRAY, 0, S.internalFormat, this._width, this._height, D, 0, r.format, S.type, null);\n    for (var U = 0; U < D; U++) {\n      var V = B[U];\n      N[U] < V.dirtyId && (N[U] = V.dirtyId, V.valid && $.texSubImage3D(\n        $.TEXTURE_2D_ARRAY,\n        0,\n        0,\n        0,\n        U,\n        V.resource.width,\n        V.resource.height,\n        1,\n        r.format,\n        S.type,\n        V.resource.source\n      ));\n    }\n    return !0;\n  }, t;\n}(AbstractMultiResource), BaseImageResource = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    var r = this, S = e, T = S.naturalWidth || S.videoWidth || S.width, D = S.naturalHeight || S.videoHeight || S.height;\n    return r = o.call(this, T, D) || this, r.source = e, r.noSubImage = !1, r;\n  }\n  return t.crossOrigin = function(e, r, S) {\n    S === void 0 && r.indexOf(\"data:\") !== 0 ? e.crossOrigin = determineCrossOrigin(r) : S !== !1 && (e.crossOrigin = typeof S == \"string\" ? S : \"anonymous\");\n  }, t.prototype.upload = function(e, r, S, T) {\n    var D = e.gl, N = r.realWidth, B = r.realHeight;\n    if (T = T || this.source, T instanceof HTMLImageElement) {\n      if (!T.complete || T.naturalWidth === 0)\n        return !1;\n    } else if (T instanceof HTMLVideoElement && T.readyState <= 1)\n      return !1;\n    return D.pixelStorei(D.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && r.target === D.TEXTURE_2D && S.width === N && S.height === B ? D.texSubImage2D(D.TEXTURE_2D, 0, 0, 0, r.format, S.type, T) : (S.width = N, S.height = B, D.texImage2D(r.target, 0, S.internalFormat, r.format, S.type, T)), !0;\n  }, t.prototype.update = function() {\n    if (!this.destroyed) {\n      var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, S = e.naturalHeight || e.videoHeight || e.height;\n      this.resize(r, S), o.prototype.update.call(this);\n    }\n  }, t.prototype.dispose = function() {\n    this.source = null;\n  }, t;\n}(Resource), CanvasResource = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    return o.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    var r = globalThis.OffscreenCanvas;\n    return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;\n  }, t;\n}(BaseImageResource), CubeResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this, T = r || {}, D = T.width, N = T.height, B = T.autoLoad, $ = T.linkBaseTexture;\n    if (e && e.length !== t.SIDES)\n      throw new Error(\"Invalid length. Got \" + e.length + \", expected 6\");\n    S = o.call(this, 6, { width: D, height: N }) || this;\n    for (var U = 0; U < t.SIDES; U++)\n      S.items[U].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + U;\n    return S.linkBaseTexture = $ !== !1, e && S.initFromArray(e, r), B !== !1 && S.load(), S;\n  }\n  return t.prototype.bind = function(e) {\n    o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_CUBE_MAP;\n  }, t.prototype.addBaseTextureAt = function(e, r, S) {\n    if (!this.items[r])\n      throw new Error(\"Index \" + r + \" is out of bounds\");\n    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)\n      if (e.resource)\n        this.addResourceAt(e.resource, r);\n      else\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n    else\n      e.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;\n    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;\n  }, t.prototype.upload = function(e, r, S) {\n    for (var T = this.itemDirtyIds, D = 0; D < t.SIDES; D++) {\n      var N = this.items[D];\n      (T[D] < N.dirtyId || S.dirtyId < r.dirtyId) && (N.valid && N.resource ? (N.resource.upload(e, N, S), T[D] = N.dirtyId) : T[D] < -1 && (e.gl.texImage2D(N.target, 0, S.internalFormat, r.realWidth, r.realHeight, 0, r.format, S.type, null), T[D] = -1));\n    }\n    return !0;\n  }, t.test = function(e) {\n    return Array.isArray(e) && e.length === t.SIDES;\n  }, t.SIDES = 6, t;\n}(AbstractMultiResource), ImageResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this;\n    if (r = r || {}, !(e instanceof HTMLImageElement)) {\n      var T = new Image();\n      BaseImageResource.crossOrigin(T, e, r.crossorigin), T.src = e, e = T;\n    }\n    return S = o.call(this, e) || this, !e.complete && !!S._width && !!S._height && (S._width = 0, S._height = 0), S.url = e.src, S._process = null, S.preserveBitmap = !1, S.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, S.alphaMode = typeof r.alphaMode == \"number\" ? r.alphaMode : null, S.bitmap = null, S._load = null, r.autoLoad !== !1 && S.load(), S;\n  }\n  return t.prototype.load = function(e) {\n    var r = this;\n    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(S, T) {\n      var D = r.source;\n      r.url = D.src;\n      var N = function() {\n        r.destroyed || (D.onload = null, D.onerror = null, r.resize(D.width, D.height), r._load = null, r.createBitmap ? S(r.process()) : S(r));\n      };\n      D.complete && D.src ? N() : (D.onload = N, D.onerror = function(B) {\n        T(B), r.onError.emit(B);\n      });\n    }), this._load);\n  }, t.prototype.process = function() {\n    var e = this, r = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    var S = globalThis.createImageBitmap, T = !r.crossOrigin || r.crossOrigin === \"anonymous\";\n    return this._process = fetch(r.src, {\n      mode: T ? \"cors\" : \"no-cors\"\n    }).then(function(D) {\n      return D.blob();\n    }).then(function(D) {\n      return S(D, 0, 0, r.width, r.height, {\n        premultiplyAlpha: e.alphaMode === null || e.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n      });\n    }).then(function(D) {\n      return e.destroyed ? Promise.reject() : (e.bitmap = D, e.update(), e._process = null, Promise.resolve(e));\n    }), this._process;\n  }, t.prototype.upload = function(e, r, S) {\n    if (typeof this.alphaMode == \"number\" && (r.alphaMode = this.alphaMode), !this.createBitmap)\n      return o.prototype.upload.call(this, e, r, S);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (o.prototype.upload.call(this, e, r, S, this.bitmap), !this.preserveBitmap) {\n      var T = !0, D = r._glTextures;\n      for (var N in D) {\n        var B = D[N];\n        if (B !== S && B.dirtyId !== r.dirtyId) {\n          T = !1;\n          break;\n        }\n      }\n      T && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }, t.prototype.dispose = function() {\n    this.source.onload = null, this.source.onerror = null, o.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }, t.test = function(e) {\n    return typeof e == \"string\" || e instanceof HTMLImageElement;\n  }, t;\n}(BaseImageResource), SVGResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this;\n    return r = r || {}, S = o.call(this, settings.ADAPTER.createCanvas()) || this, S._width = 0, S._height = 0, S.svg = e, S.scale = r.scale || 1, S._overrideWidth = r.width, S._overrideHeight = r.height, S._resolve = null, S._crossorigin = r.crossorigin, S._load = null, r.autoLoad !== !1 && S.load(), S;\n  }\n  return t.prototype.load = function() {\n    var e = this;\n    return this._load ? this._load : (this._load = new Promise(function(r) {\n      if (e._resolve = function() {\n        e.resize(e.source.width, e.source.height), r(e);\n      }, t.SVG_XML.test(e.svg.trim())) {\n        if (!btoa)\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        e.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(e.svg)));\n      }\n      e._loadSvg();\n    }), this._load);\n  }, t.prototype._loadSvg = function() {\n    var e = this, r = new Image();\n    BaseImageResource.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(S) {\n      !e._resolve || (r.onerror = null, e.onError.emit(S));\n    }, r.onload = function() {\n      if (!!e._resolve) {\n        var S = r.width, T = r.height;\n        if (!S || !T)\n          throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n        var D = S * e.scale, N = T * e.scale;\n        (e._overrideWidth || e._overrideHeight) && (D = e._overrideWidth || e._overrideHeight / T * S, N = e._overrideHeight || e._overrideWidth / S * T), D = Math.round(D), N = Math.round(N);\n        var B = e.source;\n        B.width = D, B.height = N, B._pixiId = \"canvas_\" + uid(), B.getContext(\"2d\").drawImage(r, 0, 0, S, T, 0, 0, D, N), e._resolve(), e._resolve = null;\n      }\n    };\n  }, t.getSize = function(e) {\n    var r = t.SVG_SIZE.exec(e), S = {};\n    return r && (S[r[1]] = Math.round(parseFloat(r[3])), S[r[5]] = Math.round(parseFloat(r[7]))), S;\n  }, t.prototype.dispose = function() {\n    o.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;\n  }, t.test = function(e, r) {\n    return r === \"svg\" || typeof e == \"string\" && e.startsWith(\"data:image/svg+xml\") || typeof e == \"string\" && t.SVG_XML.test(e);\n  }, t.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i, t;\n}(BaseImageResource), VideoResource = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = this;\n    if (r = r || {}, !(e instanceof HTMLVideoElement)) {\n      var T = document.createElement(\"video\");\n      T.setAttribute(\"preload\", \"auto\"), T.setAttribute(\"webkit-playsinline\", \"\"), T.setAttribute(\"playsinline\", \"\"), typeof e == \"string\" && (e = [e]);\n      var D = e[0].src || e[0];\n      BaseImageResource.crossOrigin(T, D, r.crossorigin);\n      for (var N = 0; N < e.length; ++N) {\n        var B = document.createElement(\"source\"), $ = e[N], U = $.src, V = $.mime;\n        U = U || e[N];\n        var H = U.split(\"?\").shift().toLowerCase(), X = H.slice(H.lastIndexOf(\".\") + 1);\n        V = V || t.MIME_TYPES[X] || \"video/\" + X, B.src = U, B.type = V, T.appendChild(B);\n      }\n      e = T;\n    }\n    return S = o.call(this, e) || this, S.noSubImage = !0, S._autoUpdate = !0, S._isConnectedToTicker = !1, S._updateFPS = r.updateFPS || 0, S._msToNextUpdate = 0, S.autoPlay = r.autoPlay !== !1, S._load = null, S._resolve = null, S._onCanPlay = S._onCanPlay.bind(S), S._onError = S._onError.bind(S), r.autoLoad !== !1 && S.load(), S;\n  }\n  return t.prototype.update = function(e) {\n    if (!this.destroyed) {\n      var r = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (o.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var r = this.source;\n    return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener(\"play\", this._onPlayStart.bind(this)), r.addEventListener(\"pause\", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener(\"canplay\", this._onCanPlay), r.addEventListener(\"canplaythrough\", this._onCanPlay), r.addEventListener(\"error\", this._onError, !0)), this._load = new Promise(function(S) {\n      e.valid ? S(e) : (e._resolve = S, r.load());\n    }), this._load;\n  }, t.prototype._onError = function(e) {\n    this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(e);\n  }, t.prototype._isSourcePlaying = function() {\n    var e = this.source;\n    return !e.paused && !e.ended && this._isSourceReady();\n  }, t.prototype._isSourceReady = function() {\n    var e = this.source;\n    return e.readyState > 2;\n  }, t.prototype._onPlayStart = function() {\n    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);\n  }, t.prototype._onPlayStop = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n  }, t.prototype._onCanPlay = function() {\n    var e = this.source;\n    e.removeEventListener(\"canplay\", this._onCanPlay), e.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    var r = this.valid;\n    this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();\n  }, t.prototype.dispose = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n    var e = this.source;\n    e && (e.removeEventListener(\"error\", this._onError, !0), e.pause(), e.src = \"\", e.load()), o.prototype.dispose.call(this);\n  }, Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"updateFPS\", {\n    get: function() {\n      return this._updateFPS;\n    },\n    set: function(e) {\n      e !== this._updateFPS && (this._updateFPS = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.test = function(e, r) {\n    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;\n  }, t.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], t.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n  }, t;\n}(BaseImageResource), ImageBitmapResource = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    return o.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && e instanceof ImageBitmap;\n  }, t;\n}(BaseImageResource);\nINSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\nvar _resources = {\n  __proto__: null,\n  Resource,\n  BaseImageResource,\n  INSTALLED,\n  autoDetectResource,\n  AbstractMultiResource,\n  ArrayResource,\n  BufferResource,\n  CanvasResource,\n  CubeResource,\n  ImageResource,\n  SVGResource,\n  VideoResource,\n  ImageBitmapResource\n}, DepthResource = function(o) {\n  __extends$p(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return t.prototype.upload = function(e, r, S) {\n    var T = e.gl;\n    T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);\n    var D = r.realWidth, N = r.realHeight;\n    return S.width === D && S.height === N ? T.texSubImage2D(r.target, 0, 0, 0, D, N, r.format, S.type, this.data) : (S.width = D, S.height = N, T.texImage2D(r.target, 0, S.internalFormat, D, N, 0, r.format, S.type, this.data)), !0;\n  }, t;\n}(BufferResource), Framebuffer = function() {\n  function o(t, e) {\n    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner(\"disposeFramebuffer\"), this.multisample = MSAA_QUALITY.NONE;\n  }\n  return Object.defineProperty(o.prototype, \"colorTexture\", {\n    get: function() {\n      return this.colorTextures[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.addColorTexture = function(t, e) {\n    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES.OFF,\n      width: this.width,\n      height: this.height\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, o.prototype.addDepthTexture = function(t) {\n    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: SCALE_MODES.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES.OFF,\n      format: FORMATS.DEPTH_COMPONENT,\n      type: TYPES.UNSIGNED_SHORT\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, o.prototype.enableDepth = function() {\n    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, o.prototype.enableStencil = function() {\n    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, o.prototype.resize = function(t, e) {\n    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {\n      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;\n      for (var r = 0; r < this.colorTextures.length; r++) {\n        var S = this.colorTextures[r], T = S.resolution;\n        S.setSize(t / T, e / T);\n      }\n      if (this.depthTexture) {\n        var T = this.depthTexture.resolution;\n        this.depthTexture.setSize(t / T, e / T);\n      }\n    }\n  }, o.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, o.prototype.destroyDepthTexture = function() {\n    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n  }, o;\n}(), BaseRenderTexture = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    e === void 0 && (e = {});\n    var r = this;\n    if (typeof e == \"number\") {\n      var S = arguments[0], T = arguments[1], D = arguments[2], N = arguments[3];\n      e = { width: S, height: T, scaleMode: D, resolution: N };\n    }\n    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY.NONE, r = o.call(this, null, e) || this, r.mipmap = MIPMAP_MODES.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Framebuffer(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;\n  }\n  return t.prototype.resize = function(e, r) {\n    this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }, t.prototype.dispose = function() {\n    this.framebuffer.dispose(), o.prototype.dispose.call(this);\n  }, t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n  }, t;\n}(BaseTexture), TextureUvs = function() {\n  function o() {\n    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n  }\n  return o.prototype.set = function(t, e, r) {\n    var S = e.width, T = e.height;\n    if (r) {\n      var D = t.width / 2 / S, N = t.height / 2 / T, B = t.x / S + D, $ = t.y / T + N;\n      r = groupD8.add(r, groupD8.NW), this.x0 = B + D * groupD8.uX(r), this.y0 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x1 = B + D * groupD8.uX(r), this.y1 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x2 = B + D * groupD8.uX(r), this.y2 = $ + N * groupD8.uY(r), r = groupD8.add(r, 2), this.x3 = B + D * groupD8.uX(r), this.y3 = $ + N * groupD8.uY(r);\n    } else\n      this.x0 = t.x / S, this.y0 = t.y / T, this.x1 = (t.x + t.width) / S, this.y1 = t.y / T, this.x2 = (t.x + t.width) / S, this.y2 = (t.y + t.height) / T, this.x3 = t.x / S, this.y3 = (t.y + t.height) / T;\n    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n  }, o.prototype.toString = function() {\n    return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n  }, o;\n}(), DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(o) {\n  o.destroy = function() {\n  }, o.on = function() {\n  }, o.once = function() {\n  }, o.emit = function() {\n  };\n}\nvar Texture = function(o) {\n  __extends$p(t, o);\n  function t(e, r, S, T, D, N) {\n    var B = o.call(this) || this;\n    if (B.noFrame = !1, r || (B.noFrame = !0, r = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), B.baseTexture = e, B._frame = r, B.trim = T, B.valid = !1, B._uvs = DEFAULT_UVS, B.uvMatrix = null, B.orig = S || r, B._rotate = Number(D || 0), D === !0)\n      B._rotate = 2;\n    else if (B._rotate % 2 !== 0)\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    return B.defaultAnchor = N ? new Point(N.x, N.y) : new Point(0, 0), B._updateID = 0, B.textureCacheIds = [], e.valid ? B.noFrame ? e.valid && B.onBaseTextureUpdated(e) : B.frame = r : e.once(\"loaded\", B.onBaseTextureUpdated, B), B.noFrame && e.on(\"update\", B.onBaseTextureUpdated, B), B;\n  }\n  return t.prototype.update = function() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }, t.prototype.onBaseTextureUpdated = function(e) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit(\"update\", this);\n  }, t.prototype.destroy = function(e) {\n    if (this.baseTexture) {\n      if (e) {\n        var r = this.baseTexture.resource;\n        r && r.url && TextureCache[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;\n  }, t.prototype.clone = function() {\n    var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), S = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n    return this.noFrame && (S._frame = e), S;\n  }, t.prototype.updateUvs = function() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }, t.from = function(e, r, S) {\n    r === void 0 && (r = {}), S === void 0 && (S = settings.STRICT_TEXTURE_CACHE);\n    var T = typeof e == \"string\", D = null;\n    if (T)\n      D = e;\n    else if (e instanceof BaseTexture) {\n      if (!e.cacheId) {\n        var N = r && r.pixiIdPrefix || \"pixiid\";\n        e.cacheId = N + \"-\" + uid(), BaseTexture.addToCache(e, e.cacheId);\n      }\n      D = e.cacheId;\n    } else {\n      if (!e._pixiId) {\n        var N = r && r.pixiIdPrefix || \"pixiid\";\n        e._pixiId = N + \"_\" + uid();\n      }\n      D = e._pixiId;\n    }\n    var B = TextureCache[D];\n    if (T && S && !B)\n      throw new Error('The cacheId \"' + D + '\" does not exist in TextureCache.');\n    return !B && !(e instanceof BaseTexture) ? (r.resolution || (r.resolution = getResolutionOfUrl(e)), B = new t(new BaseTexture(e, r)), B.baseTexture.cacheId = D, BaseTexture.addToCache(B.baseTexture, D), t.addToCache(B, D)) : !B && e instanceof BaseTexture && (B = new t(e), t.addToCache(B, D)), B;\n  }, t.fromURL = function(e, r) {\n    var S = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), T = t.from(e, Object.assign({ resourceOptions: S }, r), !1), D = T.baseTexture.resource;\n    return T.baseTexture.valid ? Promise.resolve(T) : D.load().then(function() {\n      return Promise.resolve(T);\n    });\n  }, t.fromBuffer = function(e, r, S, T) {\n    return new t(BaseTexture.fromBuffer(e, r, S, T));\n  }, t.fromLoader = function(e, r, S, T) {\n    var D = new BaseTexture(e, Object.assign({\n      scaleMode: settings.SCALE_MODE,\n      resolution: getResolutionOfUrl(r)\n    }, T)), N = D.resource;\n    N instanceof ImageResource && (N.url = r);\n    var B = new t(D);\n    return S || (S = r), BaseTexture.addToCache(B.baseTexture, S), t.addToCache(B, S), S !== r && (BaseTexture.addToCache(B.baseTexture, r), t.addToCache(B, r)), B.baseTexture.valid ? Promise.resolve(B) : new Promise(function($) {\n      B.baseTexture.once(\"loaded\", function() {\n        return $(B);\n      });\n    });\n  }, t.addToCache = function(e, r) {\n    r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), TextureCache[r] && console.warn(\"Texture added to the cache with an id [\" + r + \"] that already had an entry\"), TextureCache[r] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var r = TextureCache[e];\n      if (r) {\n        var S = r.textureCacheIds.indexOf(e);\n        return S > -1 && r.textureCacheIds.splice(S, 1), delete TextureCache[e], r;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var T = 0; T < e.textureCacheIds.length; ++T)\n        TextureCache[e.textureCacheIds[T]] === e && delete TextureCache[e.textureCacheIds[T]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this.baseTexture.resolution;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"frame\", {\n    get: function() {\n      return this._frame;\n    },\n    set: function(e) {\n      this._frame = e, this.noFrame = !1;\n      var r = e.x, S = e.y, T = e.width, D = e.height, N = r + T > this.baseTexture.width, B = S + D > this.baseTexture.height;\n      if (N || B) {\n        var $ = N && B ? \"and\" : \"or\", U = \"X: \" + r + \" + \" + T + \" = \" + (r + T) + \" > \" + this.baseTexture.width, V = \"Y: \" + S + \" + \" + D + \" = \" + (S + D) + \" > \" + this.baseTexture.height;\n        throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + (U + \" \" + $ + \" \" + V));\n      }\n      this.valid = T && D && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotate\", {\n    get: function() {\n      return this._rotate;\n    },\n    set: function(e) {\n      this._rotate = e, this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.orig.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.orig.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.castToBaseTexture = function() {\n    return this.baseTexture;\n  }, Object.defineProperty(t, \"EMPTY\", {\n    get: function() {\n      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"WHITE\", {\n    get: function() {\n      if (!t._WHITE) {\n        var e = settings.ADAPTER.createCanvas(16, 16), r = e.getContext(\"2d\");\n        e.width = 16, e.height = 16, r.fillStyle = \"white\", r.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);\n      }\n      return t._WHITE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), RenderTexture = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    var S = o.call(this, e, r) || this;\n    return S.valid = !0, S.filterFrame = null, S.filterPoolKey = null, S.updateUvs(), S;\n  }\n  return Object.defineProperty(t.prototype, \"framebuffer\", {\n    get: function() {\n      return this.baseTexture.framebuffer;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"multisample\", {\n    get: function() {\n      return this.framebuffer.multisample;\n    },\n    set: function(e) {\n      this.framebuffer.multisample = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, r, S) {\n    S === void 0 && (S = !0);\n    var T = this.baseTexture.resolution, D = Math.round(e * T) / T, N = Math.round(r * T) / T;\n    this.valid = D > 0 && N > 0, this._frame.width = this.orig.width = D, this._frame.height = this.orig.height = N, S && this.baseTexture.resize(D, N), this.updateUvs();\n  }, t.prototype.setResolution = function(e) {\n    var r = this.baseTexture;\n    r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));\n  }, t.create = function(e) {\n    for (var r = arguments, S = [], T = 1; T < arguments.length; T++)\n      S[T - 1] = r[T];\n    return typeof e == \"number\" && (deprecation(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\"), e = {\n      width: e,\n      height: S[0],\n      scaleMode: S[1],\n      resolution: S[2]\n    }), new t(new BaseRenderTexture(e));\n  }, t;\n}(Texture), RenderTexturePool = function() {\n  function o(t) {\n    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n  }\n  return o.prototype.createTexture = function(t, e, r) {\n    r === void 0 && (r = MSAA_QUALITY.NONE);\n    var S = new BaseRenderTexture(Object.assign({\n      width: t,\n      height: e,\n      resolution: 1,\n      multisample: r\n    }, this.textureOptions));\n    return new RenderTexture(S);\n  }, o.prototype.getOptimalTexture = function(t, e, r, S) {\n    r === void 0 && (r = 1), S === void 0 && (S = MSAA_QUALITY.NONE);\n    var T;\n    t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), T = ((t & 65535) << 16 | e & 65535) >>> 0, S > 1 && (T += S * 4294967296)) : T = S > 1 ? -S : -1, this.texturePool[T] || (this.texturePool[T] = []);\n    var D = this.texturePool[T].pop();\n    return D || (D = this.createTexture(t, e, S)), D.filterPoolKey = T, D.setResolution(r), D;\n  }, o.prototype.getFilterTexture = function(t, e, r) {\n    var S = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);\n    return S.filterFrame = t.filterFrame, S;\n  }, o.prototype.returnTexture = function(t) {\n    var e = t.filterPoolKey;\n    t.filterFrame = null, this.texturePool[e].push(t);\n  }, o.prototype.returnFilterTexture = function(t) {\n    this.returnTexture(t);\n  }, o.prototype.clear = function(t) {\n    if (t = t !== !1, t)\n      for (var e in this.texturePool) {\n        var r = this.texturePool[e];\n        if (r)\n          for (var S = 0; S < r.length; S++)\n            r[S].destroy(!0);\n      }\n    this.texturePool = {};\n  }, o.prototype.setScreenSize = function(t) {\n    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {\n      this.enableFullScreen = t.width > 0 && t.height > 0;\n      for (var e in this.texturePool)\n        if (Number(e) < 0) {\n          var r = this.texturePool[e];\n          if (r)\n            for (var S = 0; S < r.length; S++)\n              r[S].destroy(!0);\n          this.texturePool[e] = [];\n        }\n      this._pixelsWidth = t.width, this._pixelsHeight = t.height;\n    }\n  }, o.SCREEN_KEY = -1, o;\n}(), Attribute = function() {\n  function o(t, e, r, S, T, D, N) {\n    e === void 0 && (e = 0), r === void 0 && (r = !1), S === void 0 && (S = TYPES.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = S, this.stride = T, this.start = D, this.instance = N;\n  }\n  return o.prototype.destroy = function() {\n    this.buffer = null;\n  }, o.from = function(t, e, r, S, T) {\n    return new o(t, e, r, S, T);\n  }, o;\n}(), UID$4 = 0, Buffer$1 = function() {\n  function o(t, e, r) {\n    e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner(\"disposeBuffer\");\n  }\n  return o.prototype.update = function(t) {\n    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;\n  }, o.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, o.prototype.destroy = function() {\n    this.dispose(), this.data = null;\n  }, Object.defineProperty(o.prototype, \"index\", {\n    get: function() {\n      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    },\n    set: function(t) {\n      this.type = t ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.from = function(t) {\n    return t instanceof Array && (t = new Float32Array(t)), new o(t);\n  }, o;\n}(), map$1$1 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(o, t) {\n  for (var e = 0, r = 0, S = {}, T = 0; T < o.length; T++)\n    r += t[T], e += o[T].length;\n  for (var D = new ArrayBuffer(e * 4), N = null, B = 0, T = 0; T < o.length; T++) {\n    var $ = t[T], U = o[T], V = getBufferType(U);\n    S[V] || (S[V] = new map$1$1[V](D)), N = S[V];\n    for (var H = 0; H < U.length; H++) {\n      var X = (H / $ | 0) * r + B, Y = H % $;\n      N[X + Y] = U[H];\n    }\n    B += $;\n  }\n  return new Float32Array(D);\n}\nvar byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n}, Geometry = function() {\n  function o(t, e) {\n    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner(\"disposeGeometry\"), this.refCount = 0;\n  }\n  return o.prototype.addAttribute = function(t, e, r, S, T, D, N, B) {\n    if (r === void 0 && (r = 0), S === void 0 && (S = !1), B === void 0 && (B = !1), !e)\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));\n    var $ = t.split(\"|\");\n    if ($.length > 1) {\n      for (var U = 0; U < $.length; U++)\n        this.addAttribute($[U], e, r, S, T);\n      return this;\n    }\n    var V = this.buffers.indexOf(e);\n    return V === -1 && (this.buffers.push(e), V = this.buffers.length - 1), this.attributes[t] = new Attribute(V, r, S, T, D, N, B), this.instanced = this.instanced || B, this;\n  }, o.prototype.getAttribute = function(t) {\n    return this.attributes[t];\n  }, o.prototype.getBuffer = function(t) {\n    return this.buffers[this.getAttribute(t).buffer];\n  }, o.prototype.addIndex = function(t) {\n    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;\n  }, o.prototype.getIndex = function() {\n    return this.indexBuffer;\n  }, o.prototype.interleave = function() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    var t = [], e = [], r = new Buffer$1(), S;\n    for (S in this.attributes) {\n      var T = this.attributes[S], D = this.buffers[T.buffer];\n      t.push(D.data), e.push(T.size * byteSizeMap$1[T.type] / 4), T.buffer = 0;\n    }\n    for (r.data = interleaveTypedArrays(t, e), S = 0; S < this.buffers.length; S++)\n      this.buffers[S] !== this.indexBuffer && this.buffers[S].destroy();\n    return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }, o.prototype.getSize = function() {\n    for (var t in this.attributes) {\n      var e = this.attributes[t], r = this.buffers[e.buffer];\n      return r.data.length / (e.stride / 4 || e.size);\n    }\n    return 0;\n  }, o.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, o.prototype.destroy = function() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }, o.prototype.clone = function() {\n    for (var t = new o(), e = 0; e < this.buffers.length; e++)\n      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));\n    for (var e in this.attributes) {\n      var r = this.attributes[e];\n      t.attributes[e] = new Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);\n    }\n    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), t;\n  }, o.merge = function(t) {\n    for (var e = new o(), r = [], S = [], T = [], D, N = 0; N < t.length; N++) {\n      D = t[N];\n      for (var B = 0; B < D.buffers.length; B++)\n        S[B] = S[B] || 0, S[B] += D.buffers[B].data.length, T[B] = 0;\n    }\n    for (var N = 0; N < D.buffers.length; N++)\n      r[N] = new map$2[getBufferType(D.buffers[N].data)](S[N]), e.buffers[N] = new Buffer$1(r[N]);\n    for (var N = 0; N < t.length; N++) {\n      D = t[N];\n      for (var B = 0; B < D.buffers.length; B++)\n        r[B].set(D.buffers[B].data, T[B]), T[B] += D.buffers[B].data.length;\n    }\n    if (e.attributes = D.attributes, D.indexBuffer) {\n      e.indexBuffer = e.buffers[D.buffers.indexOf(D.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      for (var $ = 0, U = 0, V = 0, H = 0, N = 0; N < D.buffers.length; N++)\n        if (D.buffers[N] !== D.indexBuffer) {\n          H = N;\n          break;\n        }\n      for (var N in D.attributes) {\n        var X = D.attributes[N];\n        (X.buffer | 0) === H && (U += X.size * byteSizeMap$1[X.type] / 4);\n      }\n      for (var N = 0; N < t.length; N++) {\n        for (var Y = t[N].indexBuffer.data, B = 0; B < Y.length; B++)\n          e.indexBuffer.data[B + V] += $;\n        $ += t[N].buffers[H].data.length / U, V += Y.length;\n      }\n    }\n    return e;\n  }, o;\n}(), Quad = function(o) {\n  __extends$p(t, o);\n  function t() {\n    var e = o.call(this) || this;\n    return e.addAttribute(\"aVertexPosition\", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]), e;\n  }\n  return t;\n}(Geometry), QuadUv = function(o) {\n  __extends$p(t, o);\n  function t() {\n    var e = o.call(this) || this;\n    return e.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]), e.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute(\"aVertexPosition\", e.vertexBuffer).addAttribute(\"aTextureCoord\", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;\n  }\n  return t.prototype.map = function(e, r) {\n    var S = 0, T = 0;\n    return this.uvs[0] = S, this.uvs[1] = T, this.uvs[2] = S + r.width / e.width, this.uvs[3] = T, this.uvs[4] = S + r.width / e.width, this.uvs[5] = T + r.height / e.height, this.uvs[6] = S, this.uvs[7] = T + r.height / e.height, S = r.x, T = r.y, this.vertices[0] = S, this.vertices[1] = T, this.vertices[2] = S + r.width, this.vertices[3] = T, this.vertices[4] = S + r.width, this.vertices[5] = T + r.height, this.vertices[6] = S, this.vertices[7] = T + r.height, this.invalidate(), this;\n  }, t.prototype.invalidate = function() {\n    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n  }, t;\n}(Geometry), UID$2 = 0, UniformGroup = function() {\n  function o(t, e, r) {\n    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!r, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));\n  }\n  return o.prototype.update = function() {\n    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n  }, o.prototype.add = function(t, e, r) {\n    if (!this.ubo)\n      this.uniforms[t] = new o(e, r);\n    else\n      throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n  }, o.from = function(t, e, r) {\n    return new o(t, e, r);\n  }, o.uboFrom = function(t, e) {\n    return new o(t, e ?? !0, !0);\n  }, o;\n}(), FilterState = function() {\n  function o() {\n    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;\n  }\n  return o.prototype.clear = function() {\n    this.target = null, this.filters = null, this.renderTexture = null;\n  }, o;\n}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {\n  function o(t) {\n    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  return o.prototype.push = function(t, e) {\n    for (var r, S, T = this.renderer, D = this.defaultFilterStack, N = this.statePool.pop() || new FilterState(), B = this.renderer.renderTexture, $ = e[0].resolution, U = e[0].multisample, V = e[0].padding, H = e[0].autoFit, X = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, Y = 1; Y < e.length; Y++) {\n      var W = e[Y];\n      $ = Math.min($, W.resolution), U = Math.min(U, W.multisample), V = this.useMaxPadding ? Math.max(V, W.padding) : V + W.padding, H = H && W.autoFit, X = X || ((S = W.legacy) !== null && S !== void 0 ? S : !0);\n    }\n    D.length === 1 && (this.defaultFilterStack[0].renderTexture = B.current), D.push(N), N.resolution = $, N.multisample = U, N.legacy = X, N.target = t, N.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), N.sourceFrame.pad(V);\n    var q = this.tempRect.copyFrom(B.sourceFrame);\n    T.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(T.projection.transform).invert(), q), H ? (N.sourceFrame.fit(q), (N.sourceFrame.width <= 0 || N.sourceFrame.height <= 0) && (N.sourceFrame.width = 0, N.sourceFrame.height = 0)) : N.sourceFrame.intersects(q) || (N.sourceFrame.width = 0, N.sourceFrame.height = 0), this.roundFrame(N.sourceFrame, B.current ? B.current.resolution : T.resolution, B.sourceFrame, B.destinationFrame, T.projection.transform), N.renderTexture = this.getOptimalFilterTexture(N.sourceFrame.width, N.sourceFrame.height, $, U), N.filters = e, N.destinationFrame.width = N.renderTexture.width, N.destinationFrame.height = N.renderTexture.height;\n    var K = this.tempRect;\n    K.x = 0, K.y = 0, K.width = N.sourceFrame.width, K.height = N.sourceFrame.height, N.renderTexture.filterFrame = N.sourceFrame, N.bindingSourceFrame.copyFrom(B.sourceFrame), N.bindingDestinationFrame.copyFrom(B.destinationFrame), N.transform = T.projection.transform, T.projection.transform = null, B.bind(N.renderTexture, N.sourceFrame, K), T.framebuffer.clear(0, 0, 0, 0);\n  }, o.prototype.pop = function() {\n    var t = this.defaultFilterStack, e = t.pop(), r = e.filters;\n    this.activeState = e;\n    var S = this.globalUniforms.uniforms;\n    S.outputFrame = e.sourceFrame, S.resolution = e.resolution;\n    var T = S.inputSize, D = S.inputPixel, N = S.inputClamp;\n    if (T[0] = e.destinationFrame.width, T[1] = e.destinationFrame.height, T[2] = 1 / T[0], T[3] = 1 / T[1], D[0] = Math.round(T[0] * e.resolution), D[1] = Math.round(T[1] * e.resolution), D[2] = 1 / D[0], D[3] = 1 / D[1], N[0] = 0.5 * D[2], N[1] = 0.5 * D[3], N[2] = e.sourceFrame.width * T[2] - 0.5 * D[2], N[3] = e.sourceFrame.height * T[3] - 0.5 * D[3], e.legacy) {\n      var B = S.filterArea;\n      B[0] = e.destinationFrame.width, B[1] = e.destinationFrame.height, B[2] = e.sourceFrame.x, B[3] = e.sourceFrame.y, S.filterClamp = S.inputClamp;\n    }\n    this.globalUniforms.update();\n    var $ = t[t.length - 1];\n    if (this.renderer.framebuffer.blit(), r.length === 1)\n      r[0].apply(this, e.renderTexture, $.renderTexture, CLEAR_MODES.BLEND, e), this.returnFilterTexture(e.renderTexture);\n    else {\n      var U = e.renderTexture, V = this.getOptimalFilterTexture(U.width, U.height, e.resolution);\n      V.filterFrame = U.filterFrame;\n      var H = 0;\n      for (H = 0; H < r.length - 1; ++H) {\n        H === 1 && e.multisample > 1 && (V = this.getOptimalFilterTexture(U.width, U.height, e.resolution), V.filterFrame = U.filterFrame), r[H].apply(this, U, V, CLEAR_MODES.CLEAR, e);\n        var X = U;\n        U = V, V = X;\n      }\n      r[H].apply(this, U, $.renderTexture, CLEAR_MODES.BLEND, e), H > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(U), this.returnFilterTexture(V);\n    }\n    e.clear(), this.statePool.push(e);\n  }, o.prototype.bindAndClear = function(t, e) {\n    e === void 0 && (e = CLEAR_MODES.CLEAR);\n    var r = this.renderer, S = r.renderTexture, T = r.state;\n    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {\n      var D = this.tempRect;\n      D.x = 0, D.y = 0, D.width = t.filterFrame.width, D.height = t.filterFrame.height, S.bind(t, t.filterFrame, D);\n    } else\n      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? S.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    var N = T.stateId & 1 || this.forceClear;\n    (e === CLEAR_MODES.CLEAR || e === CLEAR_MODES.BLIT && N) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }, o.prototype.applyFilter = function(t, e, r, S) {\n    var T = this.renderer;\n    T.state.set(t.state), this.bindAndClear(r, S), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, T.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), T.geometry.bind(this.quadUv), T.geometry.draw(DRAW_MODES.TRIANGLES)) : (T.geometry.bind(this.quad), T.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));\n  }, o.prototype.calculateSpriteMatrix = function(t, e) {\n    var r = this.activeState, S = r.sourceFrame, T = r.destinationFrame, D = e._texture.orig, N = t.set(T.width, 0, 0, T.height, S.x, S.y), B = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return B.invert(), N.prepend(B), N.scale(1 / D.width, 1 / D.height), N.translate(e.anchor.x, e.anchor.y), N;\n  }, o.prototype.destroy = function() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }, o.prototype.getOptimalFilterTexture = function(t, e, r, S) {\n    return r === void 0 && (r = 1), S === void 0 && (S = MSAA_QUALITY.NONE), this.texturePool.getOptimalTexture(t, e, r, S);\n  }, o.prototype.getFilterTexture = function(t, e, r) {\n    if (typeof t == \"number\") {\n      var S = t;\n      t = e, e = S;\n    }\n    t = t || this.activeState.renderTexture;\n    var T = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);\n    return T.filterFrame = t.filterFrame, T;\n  }, o.prototype.returnFilterTexture = function(t) {\n    this.texturePool.returnTexture(t);\n  }, o.prototype.emptyPool = function() {\n    this.texturePool.clear(!0);\n  }, o.prototype.resize = function() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }, o.prototype.transformAABB = function(t, e) {\n    var r = tempPoints[0], S = tempPoints[1], T = tempPoints[2], D = tempPoints[3];\n    r.set(e.left, e.top), S.set(e.left, e.bottom), T.set(e.right, e.top), D.set(e.right, e.bottom), t.apply(r, r), t.apply(S, S), t.apply(T, T), t.apply(D, D);\n    var N = Math.min(r.x, S.x, T.x, D.x), B = Math.min(r.y, S.y, T.y, D.y), $ = Math.max(r.x, S.x, T.x, D.x), U = Math.max(r.y, S.y, T.y, D.y);\n    e.x = N, e.y = B, e.width = $ - N, e.height = U - B;\n  }, o.prototype.roundFrame = function(t, e, r, S, T) {\n    if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {\n      if (T) {\n        var D = T.a, N = T.b, B = T.c, $ = T.d;\n        if ((Math.abs(N) > 1e-4 || Math.abs(B) > 1e-4) && (Math.abs(D) > 1e-4 || Math.abs($) > 1e-4))\n          return;\n      }\n      T = T ? tempMatrix$2.copyFrom(T) : tempMatrix$2.identity(), T.translate(-r.x, -r.y).scale(S.width / r.width, S.height / r.height).translate(S.x, S.y), this.transformAABB(T, t), t.ceil(e), this.transformAABB(T.invert(), t);\n    }\n  }, o;\n}(), ObjectRenderer = function() {\n  function o(t) {\n    this.renderer = t;\n  }\n  return o.prototype.flush = function() {\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o.prototype.start = function() {\n  }, o.prototype.stop = function() {\n    this.flush();\n  }, o.prototype.render = function(t) {\n  }, o;\n}(), BatchSystem = function() {\n  function o(t) {\n    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;\n  }\n  return o.prototype.setObjectRenderer = function(t) {\n    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());\n  }, o.prototype.flush = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, o.prototype.reset = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, o.prototype.copyBoundTextures = function(t, e) {\n    for (var r = this.renderer.texture.boundTextures, S = e - 1; S >= 0; --S)\n      t[S] = r[S] || null, t[S] && (t[S]._batchLocation = S);\n  }, o.prototype.boundArray = function(t, e, r, S) {\n    for (var T = t.elements, D = t.ids, N = t.count, B = 0, $ = 0; $ < N; $++) {\n      var U = T[$], V = U._batchLocation;\n      if (V >= 0 && V < S && e[V] === U) {\n        D[$] = V;\n        continue;\n      }\n      for (; B < S; ) {\n        var H = e[B];\n        if (H && H._batchEnabled === r && H._batchLocation === B) {\n          B++;\n          continue;\n        }\n        D[$] = B, U._batchLocation = B, e[B] = U;\n        break;\n      }\n    }\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {\n  function o(t) {\n    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n      uint32Indices: !1\n    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), t.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1);\n  }\n  return Object.defineProperty(o.prototype, \"isLost\", {\n    get: function() {\n      return !this.gl || this.gl.isContextLost();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.contextChange = function(t) {\n    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension(\"WEBGL_lose_context\") && t.getExtension(\"WEBGL_lose_context\").restoreContext();\n  }, o.prototype.initFromContext = function(t) {\n    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);\n  }, o.prototype.initFromOptions = function(t) {\n    var e = this.createContext(this.renderer.view, t);\n    this.initFromContext(e);\n  }, o.prototype.createContext = function(t, e) {\n    var r;\n    if (settings.PREFER_ENV >= ENV.WEBGL2 && (r = t.getContext(\"webgl2\", e)), r)\n      this.webGLVersion = 2;\n    else if (this.webGLVersion = 1, r = t.getContext(\"webgl\", e) || t.getContext(\"experimental-webgl\", e), !r)\n      throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n    return this.gl = r, this.getExtensions(), this.gl;\n  }, o.prototype.getExtensions = function() {\n    var t = this.gl, e = {\n      anisotropicFiltering: t.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      s3tc: t.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: t.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      etc: t.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: t.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: t.getExtension(\"WEBGL_compressed_texture_pvrtc\") || t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: t.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: t.getExtension(\"WEBGL_compressed_texture_astc\")\n    };\n    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {\n      drawBuffers: t.getExtension(\"WEBGL_draw_buffers\"),\n      depthTexture: t.getExtension(\"WEBGL_depth_texture\"),\n      loseContext: t.getExtension(\"WEBGL_lose_context\"),\n      vertexArrayObject: t.getExtension(\"OES_vertex_array_object\") || t.getExtension(\"MOZ_OES_vertex_array_object\") || t.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n      uint32ElementIndex: t.getExtension(\"OES_element_index_uint\"),\n      floatTexture: t.getExtension(\"OES_texture_float\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      textureHalfFloat: t.getExtension(\"OES_texture_half_float\"),\n      textureHalfFloatLinear: t.getExtension(\"OES_texture_half_float_linear\")\n    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {\n      colorBufferFloat: t.getExtension(\"EXT_color_buffer_float\")\n    });\n  }, o.prototype.handleContextLost = function(t) {\n    t.preventDefault();\n  }, o.prototype.handleContextRestored = function() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }, o.prototype.destroy = function() {\n    var t = this.renderer.view;\n    this.renderer = null, t.removeEventListener(\"webglcontextlost\", this.handleContextLost), t.removeEventListener(\"webglcontextrestored\", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n  }, o.prototype.postrender = function() {\n    this.renderer.renderingToScreen && this.gl.flush();\n  }, o.prototype.validateContext = function(t) {\n    var e = t.getContextAttributes(), r = \"WebGL2RenderingContext\" in globalThis && t instanceof globalThis.WebGL2RenderingContext;\n    r && (this.webGLVersion = 2), e && !e.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    var S = r || !!t.getExtension(\"OES_element_index_uint\");\n    this.supports.uint32Indices = S, S || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n  }, o;\n}(), GLFramebuffer = function() {\n  function o(t) {\n    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n  }\n  return o;\n}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {\n  function o(t) {\n    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;\n  }\n  return o.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {\n      var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;\n      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(S) {\n        return e.drawBuffersWEBGL(S);\n      } : (this.hasMRT = !1, t.drawBuffers = function() {\n      }), r || (this.writeDepthTexture = !1);\n    } else\n      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);\n  }, o.prototype.bind = function(t, e, r) {\n    r === void 0 && (r = 0);\n    var S = this.gl;\n    if (t) {\n      var T = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);\n      this.current !== t && (this.current = t, S.bindFramebuffer(S.FRAMEBUFFER, T.framebuffer)), T.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, T.mipLevel = r), T.dirtyId !== t.dirtyId && (T.dirtyId = t.dirtyId, T.dirtyFormat !== t.dirtyFormat ? (T.dirtyFormat = t.dirtyFormat, T.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : T.dirtySize !== t.dirtySize && (T.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));\n      for (var D = 0; D < t.colorTextures.length; D++) {\n        var N = t.colorTextures[D];\n        this.renderer.texture.unbind(N.parentTextureArray || N);\n      }\n      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {\n        var B = e.width >> r, $ = e.height >> r, U = B / e.width;\n        this.setViewport(e.x * U, e.y * U, B, $);\n      } else {\n        var B = t.width >> r, $ = t.height >> r;\n        this.setViewport(0, 0, B, $);\n      }\n    } else\n      this.current && (this.current = null, S.bindFramebuffer(S.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n  }, o.prototype.setViewport = function(t, e, r, S) {\n    var T = this.viewport;\n    t = Math.round(t), e = Math.round(e), r = Math.round(r), S = Math.round(S), (T.width !== r || T.height !== S || T.x !== t || T.y !== e) && (T.x = t, T.y = e, T.width = r, T.height = S, this.gl.viewport(t, e, r, S));\n  }, Object.defineProperty(o.prototype, \"size\", {\n    get: function() {\n      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.clear = function(t, e, r, S, T) {\n    T === void 0 && (T = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);\n    var D = this.gl;\n    D.clearColor(t, e, r, S), D.clear(T);\n  }, o.prototype.initFramebuffer = function(t) {\n    var e = this.gl, r = new GLFramebuffer(e.createFramebuffer());\n    return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;\n  }, o.prototype.resizeFramebuffer = function(t) {\n    var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];\n    r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));\n    var S = t.colorTextures, T = S.length;\n    e.drawBuffers || (T = Math.min(T, 1));\n    for (var D = 0; D < T; D++) {\n      var N = S[D], B = N.parentTextureArray || N;\n      this.renderer.texture.bind(B, 0);\n    }\n    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);\n  }, o.prototype.updateFramebuffer = function(t, e) {\n    var r = this.gl, S = t.glFramebuffers[this.CONTEXT_UID], T = t.colorTextures, D = T.length;\n    r.drawBuffers || (D = Math.min(D, 1)), S.multisample > 1 && this.canMultisampleFramebuffer(t) ? (S.msaaBuffer = S.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, S.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, S.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, S.msaaBuffer)) : S.msaaBuffer && (r.deleteRenderbuffer(S.msaaBuffer), S.msaaBuffer = null, S.blitFramebuffer && (S.blitFramebuffer.dispose(), S.blitFramebuffer = null));\n    for (var N = [], B = 0; B < D; B++) {\n      var $ = T[B], U = $.parentTextureArray || $;\n      this.renderer.texture.bind(U, 0), !(B === 0 && S.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + B, $.target, U._glTextures[this.CONTEXT_UID].texture, e), N.push(r.COLOR_ATTACHMENT0 + B));\n    }\n    if (N.length > 1 && r.drawBuffers(N), t.depthTexture) {\n      var V = this.writeDepthTexture;\n      if (V) {\n        var H = t.depthTexture;\n        this.renderer.texture.bind(H, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, H._glTextures[this.CONTEXT_UID].texture, e);\n      }\n    }\n    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (S.stencil = S.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, S.stencil), S.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, S.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, S.stencil)) : S.stencil && (r.deleteRenderbuffer(S.stencil), S.stencil = null);\n  }, o.prototype.canMultisampleFramebuffer = function(t) {\n    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;\n  }, o.prototype.detectSamples = function(t) {\n    var e = this.msaaSamples, r = MSAA_QUALITY.NONE;\n    if (t <= 1 || e === null)\n      return r;\n    for (var S = 0; S < e.length; S++)\n      if (e[S] <= t) {\n        r = e[S];\n        break;\n      }\n    return r === 1 && (r = MSAA_QUALITY.NONE), r;\n  }, o.prototype.blit = function(t, e, r) {\n    var S = this, T = S.current, D = S.renderer, N = S.gl, B = S.CONTEXT_UID;\n    if (D.context.webGLVersion === 2 && !!T) {\n      var $ = T.glFramebuffers[B];\n      if (!!$) {\n        if (!t) {\n          if (!$.msaaBuffer)\n            return;\n          var U = T.colorTextures[0];\n          if (!U)\n            return;\n          $.blitFramebuffer || ($.blitFramebuffer = new Framebuffer(T.width, T.height), $.blitFramebuffer.addColorTexture(0, U)), t = $.blitFramebuffer, t.colorTextures[0] !== U && (t.colorTextures[0] = U, t.dirtyId++, t.dirtyFormat++), (t.width !== T.width || t.height !== T.height) && (t.width = T.width, t.height = T.height, t.dirtyId++, t.dirtySize++);\n        }\n        e || (e = tempRectangle, e.width = T.width, e.height = T.height), r || (r = e);\n        var V = e.width === r.width && e.height === r.height;\n        this.bind(t), N.bindFramebuffer(N.READ_FRAMEBUFFER, $.framebuffer), N.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, N.COLOR_BUFFER_BIT, V ? N.NEAREST : N.LINEAR);\n      }\n    }\n  }, o.prototype.disposeFramebuffer = function(t, e) {\n    var r = t.glFramebuffers[this.CONTEXT_UID], S = this.gl;\n    if (!!r) {\n      delete t.glFramebuffers[this.CONTEXT_UID];\n      var T = this.managedFramebuffers.indexOf(t);\n      T >= 0 && this.managedFramebuffers.splice(T, 1), t.disposeRunner.remove(this), e || (S.deleteFramebuffer(r.framebuffer), r.msaaBuffer && S.deleteRenderbuffer(r.msaaBuffer), r.stencil && S.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();\n    }\n  }, o.prototype.disposeAll = function(t) {\n    var e = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (var r = 0; r < e.length; r++)\n      this.disposeFramebuffer(e[r], t);\n  }, o.prototype.forceStencil = function() {\n    var t = this.current;\n    if (!!t) {\n      var e = t.glFramebuffers[this.CONTEXT_UID];\n      if (!(!e || e.stencil)) {\n        t.stencil = !0;\n        var r = t.width, S = t.height, T = this.gl, D = T.createRenderbuffer();\n        T.bindRenderbuffer(T.RENDERBUFFER, D), e.msaaBuffer ? T.renderbufferStorageMultisample(T.RENDERBUFFER, e.multisample, T.DEPTH24_STENCIL8, r, S) : T.renderbufferStorage(T.RENDERBUFFER, T.DEPTH_STENCIL, r, S), e.stencil = D, T.framebufferRenderbuffer(T.FRAMEBUFFER, T.DEPTH_STENCIL_ATTACHMENT, T.RENDERBUFFER, D);\n      }\n    }\n  }, o.prototype.reset = function() {\n    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {\n  function o(t) {\n    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n  }\n  return o.prototype.contextChange = function() {\n    this.disposeAll(!0);\n    var t = this.gl = this.renderer.gl, e = this.renderer.context;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {\n      var r = this.renderer.context.extensions.vertexArrayObject;\n      settings.PREFER_ENV === ENV.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {\n        return r.createVertexArrayOES();\n      }, t.bindVertexArray = function(T) {\n        return r.bindVertexArrayOES(T);\n      }, t.deleteVertexArray = function(T) {\n        return r.deleteVertexArrayOES(T);\n      }) : (this.hasVao = !1, t.createVertexArray = function() {\n        return null;\n      }, t.bindVertexArray = function() {\n        return null;\n      }, t.deleteVertexArray = function() {\n        return null;\n      });\n    }\n    if (e.webGLVersion !== 2) {\n      var S = t.getExtension(\"ANGLE_instanced_arrays\");\n      S ? (t.vertexAttribDivisor = function(T, D) {\n        return S.vertexAttribDivisorANGLE(T, D);\n      }, t.drawElementsInstanced = function(T, D, N, B, $) {\n        return S.drawElementsInstancedANGLE(T, D, N, B, $);\n      }, t.drawArraysInstanced = function(T, D, N, B) {\n        return S.drawArraysInstancedANGLE(T, D, N, B);\n      }) : this.hasInstance = !1;\n    }\n    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;\n  }, o.prototype.bind = function(t, e) {\n    e = e || this.renderer.shader.shader;\n    var r = this.gl, S = t.glVertexArrayObjects[this.CONTEXT_UID], T = !1;\n    S || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = S = {}, T = !0);\n    var D = S[e.program.id] || this.initGeometryVao(t, e, T);\n    this._activeGeometry = t, this._activeVao !== D && (this._activeVao = D, this.hasVao ? r.bindVertexArray(D) : this.activateVao(t, e.program)), this.updateBuffers();\n  }, o.prototype.reset = function() {\n    this.unbind();\n  }, o.prototype.updateBuffers = function() {\n    for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {\n      var S = t.buffers[r];\n      e.update(S);\n    }\n  }, o.prototype.checkCompatibility = function(t, e) {\n    var r = t.attributes, S = e.attributeData;\n    for (var T in S)\n      if (!r[T])\n        throw new Error('shader and geometry incompatible, geometry missing the \"' + T + '\" attribute');\n  }, o.prototype.getSignature = function(t, e) {\n    var r = t.attributes, S = e.attributeData, T = [\"g\", t.id];\n    for (var D in r)\n      S[D] && T.push(D, S[D].location);\n    return T.join(\"-\");\n  }, o.prototype.initGeometryVao = function(t, e, r) {\n    r === void 0 && (r = !0);\n    var S = this.gl, T = this.CONTEXT_UID, D = this.renderer.buffer, N = e.program;\n    N.glPrograms[T] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, N);\n    var B = this.getSignature(t, N), $ = t.glVertexArrayObjects[this.CONTEXT_UID], U = $[B];\n    if (U)\n      return $[N.id] = U, U;\n    var V = t.buffers, H = t.attributes, X = {}, Y = {};\n    for (var W in V)\n      X[W] = 0, Y[W] = 0;\n    for (var W in H)\n      !H[W].size && N.attributeData[W] ? H[W].size = N.attributeData[W].size : H[W].size || console.warn(\"PIXI Geometry attribute '\" + W + \"' size cannot be determined (likely the bound shader does not have the attribute)\"), X[H[W].buffer] += H[W].size * byteSizeMap[H[W].type];\n    for (var W in H) {\n      var q = H[W], K = q.size;\n      q.stride === void 0 && (X[q.buffer] === K * byteSizeMap[q.type] ? q.stride = 0 : q.stride = X[q.buffer]), q.start === void 0 && (q.start = Y[q.buffer], Y[q.buffer] += K * byteSizeMap[q.type]);\n    }\n    U = S.createVertexArray(), S.bindVertexArray(U);\n    for (var Z = 0; Z < V.length; Z++) {\n      var J = V[Z];\n      D.bind(J), r && J._glBuffers[T].refCount++;\n    }\n    return this.activateVao(t, N), this._activeVao = U, $[N.id] = U, $[B] = U, U;\n  }, o.prototype.disposeGeometry = function(t, e) {\n    var r;\n    if (!!this.managedGeometries[t.id]) {\n      delete this.managedGeometries[t.id];\n      var S = t.glVertexArrayObjects[this.CONTEXT_UID], T = this.gl, D = t.buffers, N = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;\n      if (t.disposeRunner.remove(this), !!S) {\n        if (N)\n          for (var B = 0; B < D.length; B++) {\n            var $ = D[B]._glBuffers[this.CONTEXT_UID];\n            $ && ($.refCount--, $.refCount === 0 && !e && N.dispose(D[B], e));\n          }\n        if (!e) {\n          for (var U in S)\n            if (U[0] === \"g\") {\n              var V = S[U];\n              this._activeVao === V && this.unbind(), T.deleteVertexArray(V);\n            }\n        }\n        delete t.glVertexArrayObjects[this.CONTEXT_UID];\n      }\n    }\n  }, o.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)\n      this.disposeGeometry(this.managedGeometries[e[r]], t);\n  }, o.prototype.activateVao = function(t, e) {\n    var r = this.gl, S = this.CONTEXT_UID, T = this.renderer.buffer, D = t.buffers, N = t.attributes;\n    t.indexBuffer && T.bind(t.indexBuffer);\n    var B = null;\n    for (var $ in N) {\n      var U = N[$], V = D[U.buffer], H = V._glBuffers[S];\n      if (e.attributeData[$]) {\n        B !== H && (T.bind(V), B = H);\n        var X = e.attributeData[$].location;\n        if (r.enableVertexAttribArray(X), r.vertexAttribPointer(X, U.size, U.type || r.FLOAT, U.normalized, U.stride, U.start), U.instance)\n          if (this.hasInstance)\n            r.vertexAttribDivisor(X, 1);\n          else\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n      }\n    }\n  }, o.prototype.draw = function(t, e, r, S) {\n    var T = this.gl, D = this._activeGeometry;\n    if (D.indexBuffer) {\n      var N = D.indexBuffer.data.BYTES_PER_ELEMENT, B = N === 2 ? T.UNSIGNED_SHORT : T.UNSIGNED_INT;\n      N === 2 || N === 4 && this.canUseUInt32ElementIndex ? D.instanced ? T.drawElementsInstanced(t, e || D.indexBuffer.data.length, B, (r || 0) * N, S || 1) : T.drawElements(t, e || D.indexBuffer.data.length, B, (r || 0) * N) : console.warn(\"unsupported index buffer type: uint32\");\n    } else\n      D.instanced ? T.drawArraysInstanced(t, r, e || D.getSize(), S || 1) : T.drawArrays(t, r, e || D.getSize());\n    return this;\n  }, o.prototype.unbind = function() {\n    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), MaskData = function() {\n  function o(t) {\n    t === void 0 && (t = null), this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  return Object.defineProperty(o.prototype, \"filter\", {\n    get: function() {\n      return this._filters ? this._filters[0] : null;\n    },\n    set: function(t) {\n      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.reset = function() {\n    this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }, o.prototype.copyCountersOrReset = function(t) {\n    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }, o;\n}();\nfunction compileShader(o, t, e) {\n  var r = o.createShader(t);\n  return o.shaderSource(r, e), o.compileShader(r), r;\n}\nfunction logPrettyShaderError(o, t) {\n  var e = o.getShaderSource(t).split(`\n`).map(function($, U) {\n    return U + \": \" + $;\n  }), r = o.getShaderInfoLog(t), S = r.split(`\n`), T = {}, D = S.map(function($) {\n    return parseFloat($.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function($) {\n    return $ && !T[$] ? (T[$] = !0, !0) : !1;\n  }), N = [\"\"];\n  D.forEach(function($) {\n    e[$ - 1] = \"%c\" + e[$ - 1] + \"%c\", N.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var B = e.join(`\n`);\n  N[0] = B, console.error(r), console.groupCollapsed(\"click to view full shader code\"), console.warn.apply(console, N), console.groupEnd();\n}\nfunction logProgramError(o, t, e, r) {\n  o.getProgramParameter(t, o.LINK_STATUS) || (o.getShaderParameter(e, o.COMPILE_STATUS) || logPrettyShaderError(o, e), o.getShaderParameter(r, o.COMPILE_STATUS) || logPrettyShaderError(o, r), console.error(\"PixiJS Error: Could not initialize shader.\"), o.getProgramInfoLog(t) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", o.getProgramInfoLog(t)));\n}\nfunction booleanArray(o) {\n  for (var t = new Array(o), e = 0; e < t.length; e++)\n    t[e] = !1;\n  return t;\n}\nfunction defaultValue(o, t) {\n  switch (o) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * t);\n    case \"vec3\":\n      return new Float32Array(3 * t);\n    case \"vec4\":\n      return new Float32Array(4 * t);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * t);\n    case \"ivec3\":\n      return new Int32Array(3 * t);\n    case \"ivec4\":\n      return new Int32Array(4 * t);\n    case \"uvec2\":\n      return new Uint32Array(2 * t);\n    case \"uvec3\":\n      return new Uint32Array(3 * t);\n    case \"uvec4\":\n      return new Uint32Array(4 * t);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return booleanArray(2 * t);\n    case \"bvec3\":\n      return booleanArray(3 * t);\n    case \"bvec4\":\n      return booleanArray(4 * t);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar unknownContext = {}, context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context && context.isContextLost()) {\n    var o = settings.ADAPTER.createCanvas(), t = void 0;\n    settings.PREFER_ENV >= ENV.WEBGL2 && (t = o.getContext(\"webgl2\", {})), t || (t = o.getContext(\"webgl\", {}) || o.getContext(\"experimental-webgl\", {}), t ? t.getExtension(\"WEBGL_draw_buffers\") : t = null), context = t;\n  }\n  return context;\n}\nvar maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION.MEDIUM;\n    var o = getTestContext();\n    if (o && o.getShaderPrecisionFormat) {\n      var t = o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT);\n      maxFragmentPrecision = t.precision ? PRECISION.HIGH : PRECISION.MEDIUM;\n    }\n  }\n  return maxFragmentPrecision;\n}\nfunction setPrecision(o, t, e) {\n  if (o.substring(0, 9) !== \"precision\") {\n    var r = t;\n    return t === PRECISION.HIGH && e !== PRECISION.HIGH && (r = PRECISION.MEDIUM), \"precision \" + r + ` float;\n` + o;\n  } else if (e !== PRECISION.HIGH && o.substring(0, 15) === \"precision highp\")\n    return o.replace(\"precision highp\", \"precision mediump\");\n  return o;\n}\nvar GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(o) {\n  return GLSL_TO_SIZE[o];\n}\nvar GL_TABLE = null, GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(o, t) {\n  if (!GL_TABLE) {\n    var e = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (var r = 0; r < e.length; ++r) {\n      var S = e[r];\n      GL_TABLE[o[S]] = GL_TO_GLSL_TYPES[S];\n    }\n  }\n  return GL_TABLE[t];\n}\nvar uniformParsers = [\n  {\n    test: function(o) {\n      return o.type === \"float\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n            if(uv[\"` + o + '\"] !== ud[\"' + o + `\"].value)\n            {\n                ud[\"` + o + '\"].value = uv[\"' + o + `\"]\n                gl.uniform1f(ud[\"` + o + '\"].location, uv[\"' + o + `\"])\n            }\n            `;\n    }\n  },\n  {\n    test: function(o, t) {\n      return (o.type === \"sampler2D\" || o.type === \"samplerCube\" || o.type === \"sampler2DArray\") && o.size === 1 && !o.isArray && (t == null || t.castToBaseTexture !== void 0);\n    },\n    code: function(o) {\n      return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"` + o + `\"], t);\n\n            if(ud[\"` + o + `\"].value !== t)\n            {\n                ud[\"` + o + `\"].value = t;\n                gl.uniform1i(ud[\"` + o + `\"].location, t);\n; // eslint-disable-line max-len\n            }`;\n    }\n  },\n  {\n    test: function(o, t) {\n      return o.type === \"mat3\" && o.size === 1 && !o.isArray && t.a !== void 0;\n    },\n    code: function(o) {\n      return `\n            gl.uniformMatrix3fv(ud[\"` + o + '\"].location, false, uv[\"' + o + `\"].toArray(true));\n            `;\n    },\n    codeUbo: function(o) {\n      return `\n                var ` + o + \"_matrix = uv.\" + o + `.toArray(true);\n\n                data[offset] = ` + o + `_matrix[0];\n                data[offset+1] = ` + o + `_matrix[1];\n                data[offset+2] = ` + o + `_matrix[2];\n        \n                data[offset + 4] = ` + o + `_matrix[3];\n                data[offset + 5] = ` + o + `_matrix[4];\n                data[offset + 6] = ` + o + `_matrix[5];\n        \n                data[offset + 8] = ` + o + `_matrix[6];\n                data[offset + 9] = ` + o + `_matrix[7];\n                data[offset + 10] = ` + o + `_matrix[8];\n            `;\n    }\n  },\n  {\n    test: function(o, t) {\n      return o.type === \"vec2\" && o.size === 1 && !o.isArray && t.x !== void 0;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"` + o + `\"].location, v.x, v.y);\n                }`;\n    },\n    codeUbo: function(o) {\n      return `\n                v = uv.` + o + `;\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `;\n    }\n  },\n  {\n    test: function(o) {\n      return o.type === \"vec2\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"` + o + `\"].location, v[0], v[1]);\n                }\n            `;\n    }\n  },\n  {\n    test: function(o, t) {\n      return o.type === \"vec4\" && o.size === 1 && !o.isArray && t.width !== void 0;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"` + o + `\"].location, v.x, v.y, v.width, v.height)\n                }`;\n    },\n    codeUbo: function(o) {\n      return `\n                    v = uv.` + o + `;\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `;\n    }\n  },\n  {\n    test: function(o) {\n      return o.type === \"vec4\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"` + o + `\"].location, v[0], v[1], v[2], v[3])\n                }`;\n    }\n  }\n], GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(o, t) {\n  var e, r = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (var S in o.uniforms) {\n    var T = t[S];\n    if (!T) {\n      !((e = o.uniforms[S]) === null || e === void 0) && e.group && (o.uniforms[S].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.` + S + \", '\" + S + `');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.` + S + `, syncData);\n                    `));\n      continue;\n    }\n    for (var D = o.uniforms[S], N = !1, B = 0; B < uniformParsers.length; B++)\n      if (uniformParsers[B].test(T, D)) {\n        r.push(uniformParsers[B].code(S, D)), N = !0;\n        break;\n      }\n    if (!N) {\n      var $ = T.size === 1 && !T.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, U = $[T.type].replace(\"location\", 'ud[\"' + S + '\"].location');\n      r.push(`\n            cu = ud[\"` + S + `\"];\n            cv = cu.value;\n            v = uv[\"` + S + `\"];\n            ` + U + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", r.join(`\n`));\n}\nvar fragTemplate$1 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction generateIfTestSrc(o) {\n  for (var t = \"\", e = 0; e < o; ++e)\n    e > 0 && (t += `\nelse `), e < o - 1 && (t += \"if(test == \" + e + \".0){}\");\n  return t;\n}\nfunction checkMaxIfStatementsInShader(o, t) {\n  if (o === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {\n    var r = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(o));\n    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))\n      o = o / 2 | 0;\n    else\n      break;\n  }\n  return o;\n}\nvar unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == \"boolean\")\n    return unsafeEval;\n  try {\n    var o = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = o({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\nvar defaultFragment$2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`, defaultVertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`, UID$1 = 0, nameCache = {}, Program = function() {\n  function o(t, e, r) {\n    r === void 0 && (r = \"pixi-shader\"), this.id = UID$1++, this.vertexSrc = t || o.defaultVertexSrc, this.fragmentSrc = e || o.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== \"#version\" && (r = r.replace(/\\s+/g, \"-\"), nameCache[r] ? (nameCache[r]++, r += \"-\" + nameCache[r]) : nameCache[r] = 1, this.vertexSrc = \"#define SHADER_NAME \" + r + `\n` + this.vertexSrc, this.fragmentSrc = \"#define SHADER_NAME \" + r + `\n` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;\n  }\n  return Object.defineProperty(o, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$3;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.from = function(t, e, r) {\n    var S = t + e, T = ProgramCache[S];\n    return T || (ProgramCache[S] = T = new o(t, e, r)), T;\n  }, o;\n}(), Shader = function() {\n  function o(t, e) {\n    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner(\"disposeShader\");\n  }\n  return o.prototype.checkUniformExists = function(t, e) {\n    if (e.uniforms[t])\n      return !0;\n    for (var r in e.uniforms) {\n      var S = e.uniforms[r];\n      if (S.group && this.checkUniformExists(t, S))\n        return !0;\n    }\n    return !1;\n  }, o.prototype.destroy = function() {\n    this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();\n  }, Object.defineProperty(o.prototype, \"uniforms\", {\n    get: function() {\n      return this.uniformGroup.uniforms;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.from = function(t, e, r) {\n    var S = Program.from(t, e);\n    return new o(S, r);\n  }, o;\n}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {\n  function o() {\n    this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n  }\n  return Object.defineProperty(o.prototype, \"blend\", {\n    get: function() {\n      return !!(this.data & 1 << BLEND$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"offsets\", {\n    get: function() {\n      return !!(this.data & 1 << OFFSET$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"culling\", {\n    get: function() {\n      return !!(this.data & 1 << CULLING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"depthTest\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_TEST$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"depthMask\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_MASK$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"clockwiseFrontFace\", {\n    get: function() {\n      return !!(this.data & 1 << WINDING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"blendMode\", {\n    get: function() {\n      return this._blendMode;\n    },\n    set: function(t) {\n      this.blend = t !== BLEND_MODES.NONE, this._blendMode = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"polygonOffset\", {\n    get: function() {\n      return this._polygonOffset;\n    },\n    set: function(t) {\n      this.offsets = !!t, this._polygonOffset = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.toString = function() {\n    return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n  }, o.for2d = function() {\n    var t = new o();\n    return t.depthTest = !1, t.blend = !0, t;\n  }, o;\n}(), defaultFragment$1 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`, defaultVertex$2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, Filter = function(o) {\n  __extends$p(t, o);\n  function t(e, r, S) {\n    var T = this, D = Program.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);\n    return T = o.call(this, D, S) || this, T.padding = 0, T.resolution = settings.FILTER_RESOLUTION, T.multisample = settings.FILTER_MULTISAMPLE, T.enabled = !0, T.autoFit = !0, T.state = new State(), T;\n  }\n  return t.prototype.apply = function(e, r, S, T, D) {\n    e.applyFilter(this, r, S, T);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._resolution = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Shader), vertex$4 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`, fragment$7 = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`, tempMat$1 = new Matrix(), TextureMatrix = function() {\n  function o(t, e) {\n    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > \"u\" ? 0.5 : e, this.isSimple = !1;\n  }\n  return Object.defineProperty(o.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(t) {\n      this._texture = t, this._textureID = -1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.multiplyUvs = function(t, e) {\n    e === void 0 && (e = t);\n    for (var r = this.mapCoord, S = 0; S < t.length; S += 2) {\n      var T = t[S], D = t[S + 1];\n      e[S] = T * r.a + D * r.c + r.tx, e[S + 1] = T * r.b + D * r.d + r.ty;\n    }\n    return e;\n  }, o.prototype.update = function(t) {\n    var e = this._texture;\n    if (!e || !e.valid || !t && this._textureID === e._updateID)\n      return !1;\n    this._textureID = e._updateID, this._updateID++;\n    var r = e._uvs;\n    this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);\n    var S = e.orig, T = e.trim;\n    T && (tempMat$1.set(S.width / T.width, 0, 0, S.height / T.height, -T.x / T.width, -T.y / T.height), this.mapCoord.append(tempMat$1));\n    var D = e.baseTexture, N = this.uClampFrame, B = this.clampMargin / D.resolution, $ = this.clampOffset;\n    return N[0] = (e._frame.x + B + $) / D.width, N[1] = (e._frame.y + B + $) / D.height, N[2] = (e._frame.x + e._frame.width - B + $) / D.width, N[3] = (e._frame.y + e._frame.height - B + $) / D.height, this.uClampOffset[0] = $ / D.realWidth, this.uClampOffset[1] = $ / D.realHeight, this.isSimple = e._frame.width === D.width && e._frame.height === D.height && e.rotate === 0, !0;\n  }, o;\n}(), SpriteMaskFilter = function(o) {\n  __extends$p(t, o);\n  function t(e, r, S) {\n    var T = this, D = null;\n    return typeof e != \"string\" && r === void 0 && S === void 0 && (D = e, e = void 0, r = void 0, S = void 0), T = o.call(this, e || vertex$4, r || fragment$7, S) || this, T.maskSprite = D, T.maskMatrix = new Matrix(), T;\n  }\n  return Object.defineProperty(t.prototype, \"maskSprite\", {\n    get: function() {\n      return this._maskSprite;\n    },\n    set: function(e) {\n      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.apply = function(e, r, S, T) {\n    var D = this._maskSprite, N = D._texture;\n    !N.valid || (N.uvMatrix || (N.uvMatrix = new TextureMatrix(N, 0)), N.uvMatrix.update(), this.uniforms.npmAlpha = N.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = N, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, D).prepend(N.uvMatrix.mapCoord), this.uniforms.alpha = D.worldAlpha, this.uniforms.maskClamp = N.uvMatrix.uClampFrame, e.applyFilter(this, r, S, T));\n  }, t;\n}(Filter), MaskSystem = function() {\n  function o(t) {\n    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  return o.prototype.setMaskStack = function(t) {\n    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);\n  }, o.prototype.push = function(t, e) {\n    var r = e;\n    if (!r.isMaskData) {\n      var S = this.maskDataPool.pop() || new MaskData();\n      S.pooled = !0, S.maskObject = e, r = S;\n    }\n    var T = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (r.copyCountersOrReset(T), r._colorMask = T ? T._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled)\n      switch (r.type) {\n        case MASK_TYPES.SCISSOR:\n          this.renderer.scissor.push(r);\n          break;\n        case MASK_TYPES.STENCIL:\n          this.renderer.stencil.push(r);\n          break;\n        case MASK_TYPES.SPRITE:\n          r.copyCountersOrReset(null), this.pushSpriteMask(r);\n          break;\n        case MASK_TYPES.COLOR:\n          this.pushColorMask(r);\n          break;\n      }\n    r.type === MASK_TYPES.SPRITE && this.maskStack.push(r);\n  }, o.prototype.pop = function(t) {\n    var e = this.maskStack.pop();\n    if (!(!e || e._target !== t)) {\n      if (e.enabled)\n        switch (e.type) {\n          case MASK_TYPES.SCISSOR:\n            this.renderer.scissor.pop(e);\n            break;\n          case MASK_TYPES.STENCIL:\n            this.renderer.stencil.pop(e.maskObject);\n            break;\n          case MASK_TYPES.SPRITE:\n            this.popSpriteMask(e);\n            break;\n          case MASK_TYPES.COLOR:\n            this.popColorMask(e);\n            break;\n        }\n      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {\n        var r = this.maskStack[this.maskStack.length - 1];\n        r.type === MASK_TYPES.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);\n      }\n    }\n  }, o.prototype.detect = function(t) {\n    var e = t.maskObject;\n    e ? e.isSprite ? t.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES.SCISSOR : t.type = MASK_TYPES.STENCIL : t.type = MASK_TYPES.COLOR;\n  }, o.prototype.pushSpriteMask = function(t) {\n    var e, r, S = t.maskObject, T = t._target, D = t._filters;\n    D || (D = this.alphaMaskPool[this.alphaMaskIndex], D || (D = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));\n    var N = this.renderer, B = N.renderTexture, $, U;\n    if (B.current) {\n      var V = B.current;\n      $ = t.resolution || V.resolution, U = (e = t.multisample) !== null && e !== void 0 ? e : V.multisample;\n    } else\n      $ = t.resolution || N.resolution, U = (r = t.multisample) !== null && r !== void 0 ? r : N.multisample;\n    D[0].resolution = $, D[0].multisample = U, D[0].maskSprite = S;\n    var H = T.filterArea;\n    T.filterArea = S.getBounds(!0), N.filter.push(T, D), T.filterArea = H, t._filters || this.alphaMaskIndex++;\n  }, o.prototype.popSpriteMask = function(t) {\n    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }, o.prototype.pushColorMask = function(t) {\n    var e = t._colorMask, r = t._colorMask = e & t.colorMask;\n    r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n  }, o.prototype.popColorMask = function(t) {\n    var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), AbstractMaskSystem = function() {\n  function o(t) {\n    this.renderer = t, this.maskStack = [], this.glConst = 0;\n  }\n  return o.prototype.getStackLength = function() {\n    return this.maskStack.length;\n  }, o.prototype.setMaskStack = function(t) {\n    var e = this.renderer.gl, r = this.getStackLength();\n    this.maskStack = t;\n    var S = this.getStackLength();\n    S !== r && (S === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));\n  }, o.prototype._useCurrent = function() {\n  }, o.prototype.destroy = function() {\n    this.renderer = null, this.maskStack = null;\n  }, o;\n}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return r.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._scissorCounter : 0;\n  }, t.prototype.calcScissorRect = function(e) {\n    var r;\n    if (!e._scissorRectLocal) {\n      var S = e._scissorRect, T = e.maskObject, D = this.renderer, N = D.renderTexture, B = T.getBounds(!0, (r = rectPool.pop()) !== null && r !== void 0 ? r : new Rectangle());\n      this.roundFrameToPixels(B, N.current ? N.current.resolution : D.resolution, N.sourceFrame, N.destinationFrame, D.projection.transform), S && B.fit(S), e._scissorRectLocal = B;\n    }\n  }, t.isMatrixRotated = function(e) {\n    if (!e)\n      return !1;\n    var r = e.a, S = e.b, T = e.c, D = e.d;\n    return (Math.abs(S) > 1e-4 || Math.abs(T) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(D) > 1e-4);\n  }, t.prototype.testScissor = function(e) {\n    var r = e.maskObject;\n    if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))\n      return !1;\n    this.calcScissorRect(e);\n    var S = e._scissorRectLocal;\n    return S.width > 0 && S.height > 0;\n  }, t.prototype.roundFrameToPixels = function(e, r, S, T, D) {\n    t.isMatrixRotated(D) || (D = D ? tempMatrix$1.copyFrom(D) : tempMatrix$1.identity(), D.translate(-S.x, -S.y).scale(T.width / S.width, T.height / S.height).translate(T.x, T.y), this.renderer.filter.transformAABB(D, e), e.fit(T), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));\n  }, t.prototype.push = function(e) {\n    e._scissorRectLocal || this.calcScissorRect(e);\n    var r = this.renderer.gl;\n    e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var r = this.renderer.gl;\n    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);\n  }, t.prototype._useCurrent = function() {\n    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;\n    this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);\n  }, t;\n}(AbstractMaskSystem), StencilSystem = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return r.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._stencilCounter : 0;\n  }, t.prototype.push = function(e) {\n    var r = e.maskObject, S = this.renderer.gl, T = e._stencilCounter;\n    T === 0 && (this.renderer.framebuffer.forceStencil(), S.clearStencil(0), S.clear(S.STENCIL_BUFFER_BIT), S.enable(S.STENCIL_TEST)), e._stencilCounter++;\n    var D = e._colorMask;\n    D !== 0 && (e._colorMask = 0, S.colorMask(!1, !1, !1, !1)), S.stencilFunc(S.EQUAL, T, 4294967295), S.stencilOp(S.KEEP, S.KEEP, S.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, D !== 0 && (e._colorMask = D, S.colorMask((D & 1) !== 0, (D & 2) !== 0, (D & 4) !== 0, (D & 8) !== 0)), this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var r = this.renderer.gl;\n    if (this.getStackLength() === 0)\n      r.disable(r.STENCIL_TEST);\n    else {\n      var S = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, T = S ? S._colorMask : 15;\n      T !== 0 && (S._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, T !== 0 && (S._colorMask = T, r.colorMask((T & 1) !== 0, (T & 2) !== 0, (T & 4) !== 0, (T & 8) !== 0)), this._useCurrent();\n    }\n  }, t.prototype._useCurrent = function() {\n    var e = this.renderer.gl;\n    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);\n  }, t;\n}(AbstractMaskSystem), ProjectionSystem = function() {\n  function o(t) {\n    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;\n  }\n  return o.prototype.update = function(t, e, r, S) {\n    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, S), this.transform && this.projectionMatrix.append(this.transform);\n    var T = this.renderer;\n    T.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, T.globalUniforms.update(), T.shader.shader && T.shader.syncUniformGroup(T.shader.shader.uniforms.globals);\n  }, o.prototype.calculateProjection = function(t, e, r, S) {\n    var T = this.projectionMatrix, D = S ? -1 : 1;\n    T.identity(), T.a = 1 / e.width * 2, T.d = D * (1 / e.height * 2), T.tx = -1 - e.x * T.a, T.ty = -D - e.y * T.d;\n  }, o.prototype.setTransform = function(t) {\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {\n  function o(t) {\n    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();\n  }\n  return o.prototype.bind = function(t, e, r) {\n    t === void 0 && (t = null);\n    var S = this.renderer;\n    this.current = t;\n    var T, D, N;\n    t ? (T = t.baseTexture, N = T.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), r || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, r = tempRect2), D = T.framebuffer) : (N = S.resolution, e || (tempRect.width = S.screen.width, tempRect.height = S.screen.height, e = tempRect), r || (r = tempRect, r.width = e.width, r.height = e.height));\n    var B = this.viewportFrame;\n    B.x = r.x * N, B.y = r.y * N, B.width = r.width * N, B.height = r.height * N, t || (B.y = S.view.height - (B.y + B.height)), B.ceil(), this.renderer.framebuffer.bind(D, B), this.renderer.projection.update(r, e, N, !D), t ? this.renderer.mask.setMaskStack(T.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);\n  }, o.prototype.clear = function(t, e) {\n    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;\n    var r = this.destinationFrame, S = this.current ? this.current.baseTexture : this.renderer.screen, T = r.width !== S.width || r.height !== S.height;\n    if (T) {\n      var D = this.viewportFrame, N = D.x, B = D.y, $ = D.width, U = D.height;\n      N = Math.round(N), B = Math.round(B), $ = Math.round($), U = Math.round(U), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(N, B, $, U);\n    }\n    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), T && this.renderer.scissor.pop();\n  }, o.prototype.resize = function() {\n    this.bind(null);\n  }, o.prototype.reset = function() {\n    this.bind(null);\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}();\nfunction uboUpdate(o, t, e, r, S) {\n  e.buffer.update(S);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(o) {\n  for (var t = o.map(function(B) {\n    return {\n      data: B,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  }), e = 0, r = 0, S = 0, T = 0; T < t.length; T++) {\n    var D = t[T];\n    if (e = GLSL_TO_STD40_SIZE[D.data.type], D.data.size > 1 && (e = Math.max(e, 16) * D.data.size), D.dataLen = e, r % e !== 0 && r < 16) {\n      var N = r % e % 16;\n      r += N, S += N;\n    }\n    r + e > 16 ? (S = Math.ceil(S / 16) * 16, D.offset = S, S += e, r = e) : (D.offset = S, r += e, S += e);\n  }\n  return S = Math.ceil(S / 16) * 16, { uboElements: t, size: S };\n}\nfunction getUBOData(o, t) {\n  var e = [];\n  for (var r in o)\n    t[r] && e.push(t[r]);\n  return e.sort(function(S, T) {\n    return S.index - T.index;\n  }), e;\n}\nfunction generateUniformBufferSync(o, t) {\n  if (!o.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  for (var e = getUBOData(o.uniforms, t), r = createUBOElements(e), S = r.uboElements, T = r.size, D = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `], N = 0; N < S.length; N++) {\n    for (var B = S[N], $ = o.uniforms[B.data.name], U = B.data.name, V = !1, H = 0; H < uniformParsers.length; H++) {\n      var X = uniformParsers[H];\n      if (X.codeUbo && X.test(B.data, $)) {\n        D.push(\"offset = \" + B.offset / 4 + \";\", uniformParsers[H].codeUbo(B.data.name, $)), V = !0;\n        break;\n      }\n    }\n    if (!V)\n      if (B.data.size > 1) {\n        var Y = mapSize(B.data.type), W = Math.max(GLSL_TO_STD40_SIZE[B.data.type] / 16, 1), q = Y / W, K = (4 - q % 4) % 4;\n        D.push(`\n                cv = ud.` + U + `.value;\n                v = uv.` + U + `;\n                offset = ` + B.offset / 4 + `;\n\n                t = 0;\n\n                for(var i=0; i < ` + B.data.size * W + `; i++)\n                {\n                    for(var j = 0; j < ` + q + `; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ` + K + `;\n                }\n\n                `);\n      } else {\n        var Z = UBO_TO_SINGLE_SETTERS[B.data.type];\n        D.push(`\n                cv = ud.` + U + `.value;\n                v = uv.` + U + `;\n                offset = ` + B.offset / 4 + `;\n                ` + Z + `;\n                `);\n      }\n  }\n  return D.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size: T,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", D.join(`\n`))\n  };\n}\nvar IGLUniformData = function() {\n  function o() {\n  }\n  return o;\n}(), GLProgram = function() {\n  function o(t, e) {\n    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n  }\n  return o.prototype.destroy = function() {\n    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n  }, o;\n}();\nfunction getAttributeData(o, t) {\n  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_ATTRIBUTES), S = 0; S < r; S++) {\n    var T = t.getActiveAttrib(o, S);\n    if (T.name.indexOf(\"gl_\") !== 0) {\n      var D = mapType(t, T.type), N = {\n        type: D,\n        name: T.name,\n        size: mapSize(D),\n        location: t.getAttribLocation(o, T.name)\n      };\n      e[T.name] = N;\n    }\n  }\n  return e;\n}\nfunction getUniformData(o, t) {\n  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_UNIFORMS), S = 0; S < r; S++) {\n    var T = t.getActiveUniform(o, S), D = T.name.replace(/\\[.*?\\]$/, \"\"), N = !!T.name.match(/\\[.*?\\]$/), B = mapType(t, T.type);\n    e[D] = {\n      name: D,\n      index: S,\n      type: B,\n      size: T.size,\n      isArray: N,\n      value: defaultValue(B, T.size)\n    };\n  }\n  return e;\n}\nfunction generateProgram(o, t) {\n  var e = compileShader(o, o.VERTEX_SHADER, t.vertexSrc), r = compileShader(o, o.FRAGMENT_SHADER, t.fragmentSrc), S = o.createProgram();\n  if (o.attachShader(S, e), o.attachShader(S, r), o.linkProgram(S), o.getProgramParameter(S, o.LINK_STATUS) || logProgramError(o, S, e, r), t.attributeData = getAttributeData(S, o), t.uniformData = getUniformData(S, o), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(t.vertexSrc)) {\n    var T = Object.keys(t.attributeData);\n    T.sort(function(U, V) {\n      return U > V ? 1 : -1;\n    });\n    for (var D = 0; D < T.length; D++)\n      t.attributeData[T[D]].location = D, o.bindAttribLocation(S, D, T[D]);\n    o.linkProgram(S);\n  }\n  o.deleteShader(e), o.deleteShader(r);\n  var N = {};\n  for (var D in t.uniformData) {\n    var B = t.uniformData[D];\n    N[D] = {\n      location: o.getUniformLocation(S, D),\n      value: defaultValue(B.type, B.size)\n    };\n  }\n  var $ = new GLProgram(S, N);\n  return $;\n}\nvar UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {\n  function o(t) {\n    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;\n  }\n  return o.prototype.systemCheck = function() {\n    if (!unsafeEvalSupported())\n      throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n  }, o.prototype.contextChange = function(t) {\n    this.gl = t, this.reset();\n  }, o.prototype.bind = function(t, e) {\n    t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;\n    var r = t.program, S = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);\n    return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(S.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), S;\n  }, o.prototype.setUniforms = function(t) {\n    var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];\n    e.syncUniforms(r.uniformData, t, this.renderer);\n  }, o.prototype.syncUniformGroup = function(t, e) {\n    var r = this.getGlProgram();\n    (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));\n  }, o.prototype.syncUniforms = function(t, e, r) {\n    var S = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);\n    S(e.uniformData, t.uniforms, this.renderer, r);\n  }, o.prototype.createSyncGroups = function(t) {\n    var e = this.getSignature(t, this.shader.program.uniformData, \"u\");\n    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];\n  }, o.prototype.syncUniformBufferGroup = function(t, e) {\n    var r = this.getGlProgram();\n    if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {\n      t.dirtyId = 0;\n      var S = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);\n      t.buffer.update(), S(r.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);\n  }, o.prototype.createSyncBufferGroup = function(t, e, r) {\n    var S = this.renderer.gl;\n    this.renderer.buffer.bind(t.buffer);\n    var T = this.gl.getUniformBlockIndex(e.program, r);\n    e.uniformBufferBindings[r] = this.shader.uniformBindCount, S.uniformBlockBinding(e.program, T, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n    var D = this.getSignature(t, this.shader.program.uniformData, \"ubo\"), N = this._uboCache[D];\n    if (N || (N = this._uboCache[D] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {\n      var B = new Float32Array(N.size / 4);\n      t.buffer.update(B);\n    }\n    return e.uniformGroups[t.id] = N.syncFunc, e.uniformGroups[t.id];\n  }, o.prototype.getSignature = function(t, e, r) {\n    var S = t.uniforms, T = [r + \"-\"];\n    for (var D in S)\n      T.push(D), e[D] && T.push(e[D].type);\n    return T.join(\"-\");\n  }, o.prototype.getGlProgram = function() {\n    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n  }, o.prototype.generateProgram = function(t) {\n    var e = this.gl, r = t.program, S = generateProgram(e, r);\n    return r.glPrograms[this.renderer.CONTEXT_UID] = S, S;\n  }, o.prototype.reset = function() {\n    this.program = null, this.shader = null;\n  }, o.prototype.disposeShader = function(t) {\n    this.shader === t && (this.shader = null);\n  }, o.prototype.destroy = function() {\n    this.renderer = null, this.destroyed = !0;\n  }, o;\n}();\nfunction mapWebGLBlendModesToPixi(o, t) {\n  return t === void 0 && (t = []), t[BLEND_MODES.NORMAL] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD] = [o.ONE, o.ONE], t[BLEND_MODES.MULTIPLY] = [o.DST_COLOR, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SCREEN] = [o.ONE, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.OVERLAY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DARKEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LIGHTEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_DODGE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_BURN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HARD_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SOFT_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DIFFERENCE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.EXCLUSION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HUE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SATURATION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LUMINOSITY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.NONE] = [0, 0], t[BLEND_MODES.NORMAL_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD_NPM] = [o.SRC_ALPHA, o.ONE, o.ONE, o.ONE], t[BLEND_MODES.SCREEN_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SRC_IN] = [o.DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_OUT] = [o.ONE_MINUS_DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_ATOP] = [o.DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_OVER] = [o.ONE_MINUS_DST_ALPHA, o.ONE], t[BLEND_MODES.DST_IN] = [o.ZERO, o.SRC_ALPHA], t[BLEND_MODES.DST_OUT] = [o.ZERO, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_ATOP] = [o.ONE_MINUS_DST_ALPHA, o.SRC_ALPHA], t[BLEND_MODES.XOR] = [o.ONE_MINUS_DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SUBTRACT] = [o.ONE, o.ONE, o.ONE, o.ONE, o.FUNC_REVERSE_SUBTRACT, o.FUNC_ADD], t;\n}\nvar BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {\n  function o() {\n    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;\n  }\n  return o.prototype.contextChange = function(t) {\n    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();\n  }, o.prototype.set = function(t) {\n    if (t = t || this.defaultState, this.stateId !== t.data) {\n      for (var e = this.stateId ^ t.data, r = 0; e; )\n        e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;\n      this.stateId = t.data;\n    }\n    for (var r = 0; r < this.checks.length; r++)\n      this.checks[r](this, t);\n  }, o.prototype.forceState = function(t) {\n    t = t || this.defaultState;\n    for (var e = 0; e < this.map.length; e++)\n      this.map[e].call(this, !!(t.data & 1 << e));\n    for (var e = 0; e < this.checks.length; e++)\n      this.checks[e](this, t);\n    this.stateId = t.data;\n  }, o.prototype.setBlend = function(t) {\n    this.updateCheck(o.checkBlendMode, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }, o.prototype.setOffset = function(t) {\n    this.updateCheck(o.checkPolygonOffset, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }, o.prototype.setDepthTest = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }, o.prototype.setDepthMask = function(t) {\n    this.gl.depthMask(t);\n  }, o.prototype.setCullFace = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }, o.prototype.setFrontFace = function(t) {\n    this.gl.frontFace(this.gl[t ? \"CW\" : \"CCW\"]);\n  }, o.prototype.setBlendMode = function(t) {\n    if (t !== this.blendMode) {\n      this.blendMode = t;\n      var e = this.blendModes[t], r = this.gl;\n      e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));\n    }\n  }, o.prototype.setPolygonOffset = function(t, e) {\n    this.gl.polygonOffset(t, e);\n  }, o.prototype.reset = function() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n  }, o.prototype.updateCheck = function(t, e) {\n    var r = this.checks.indexOf(t);\n    e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);\n  }, o.checkBlendMode = function(t, e) {\n    t.setBlendMode(e.blendMode);\n  }, o.checkPolygonOffset = function(t, e) {\n    t.setPolygonOffset(1, e.polygonOffset);\n  }, o.prototype.destroy = function() {\n    this.gl = null;\n  }, o;\n}(), TextureGCSystem = function() {\n  function o(t) {\n    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings.GC_MAX_IDLE, this.checkCountMax = settings.GC_MAX_CHECK_COUNT, this.mode = settings.GC_MODE;\n  }\n  return o.prototype.postrender = function() {\n    !this.renderer.renderingToScreen || (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n  }, o.prototype.run = function() {\n    for (var t = this.renderer.texture, e = t.managedTextures, r = !1, S = 0; S < e.length; S++) {\n      var T = e[S];\n      !T.framebuffer && this.count - T.touched > this.maxIdle && (t.destroyTexture(T, !0), e[S] = null, r = !0);\n    }\n    if (r) {\n      for (var D = 0, S = 0; S < e.length; S++)\n        e[S] !== null && (e[D++] = e[S]);\n      e.length = D;\n    }\n  }, o.prototype.unload = function(t) {\n    var e = this.renderer.texture, r = t._texture;\n    r && !r.framebuffer && e.destroyTexture(r);\n    for (var S = t.children.length - 1; S >= 0; S--)\n      this.unload(t.children[S]);\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}();\nfunction mapTypeAndFormatToInternalFormat(o) {\n  var t, e, r, S, T, D, N, B, $, U, V, H, X, Y, W, q, K, Z, J, Q, rt, et, nt;\n  return \"WebGL2RenderingContext\" in globalThis && o instanceof globalThis.WebGL2RenderingContext ? nt = (t = {}, t[TYPES.UNSIGNED_BYTE] = (e = {}, e[FORMATS.RGBA] = o.RGBA8, e[FORMATS.RGB] = o.RGB8, e[FORMATS.RG] = o.RG8, e[FORMATS.RED] = o.R8, e[FORMATS.RGBA_INTEGER] = o.RGBA8UI, e[FORMATS.RGB_INTEGER] = o.RGB8UI, e[FORMATS.RG_INTEGER] = o.RG8UI, e[FORMATS.RED_INTEGER] = o.R8UI, e[FORMATS.ALPHA] = o.ALPHA, e[FORMATS.LUMINANCE] = o.LUMINANCE, e[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, e), t[TYPES.BYTE] = (r = {}, r[FORMATS.RGBA] = o.RGBA8_SNORM, r[FORMATS.RGB] = o.RGB8_SNORM, r[FORMATS.RG] = o.RG8_SNORM, r[FORMATS.RED] = o.R8_SNORM, r[FORMATS.RGBA_INTEGER] = o.RGBA8I, r[FORMATS.RGB_INTEGER] = o.RGB8I, r[FORMATS.RG_INTEGER] = o.RG8I, r[FORMATS.RED_INTEGER] = o.R8I, r), t[TYPES.UNSIGNED_SHORT] = (S = {}, S[FORMATS.RGBA_INTEGER] = o.RGBA16UI, S[FORMATS.RGB_INTEGER] = o.RGB16UI, S[FORMATS.RG_INTEGER] = o.RG16UI, S[FORMATS.RED_INTEGER] = o.R16UI, S[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT16, S), t[TYPES.SHORT] = (T = {}, T[FORMATS.RGBA_INTEGER] = o.RGBA16I, T[FORMATS.RGB_INTEGER] = o.RGB16I, T[FORMATS.RG_INTEGER] = o.RG16I, T[FORMATS.RED_INTEGER] = o.R16I, T), t[TYPES.UNSIGNED_INT] = (D = {}, D[FORMATS.RGBA_INTEGER] = o.RGBA32UI, D[FORMATS.RGB_INTEGER] = o.RGB32UI, D[FORMATS.RG_INTEGER] = o.RG32UI, D[FORMATS.RED_INTEGER] = o.R32UI, D[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT24, D), t[TYPES.INT] = (N = {}, N[FORMATS.RGBA_INTEGER] = o.RGBA32I, N[FORMATS.RGB_INTEGER] = o.RGB32I, N[FORMATS.RG_INTEGER] = o.RG32I, N[FORMATS.RED_INTEGER] = o.R32I, N), t[TYPES.FLOAT] = (B = {}, B[FORMATS.RGBA] = o.RGBA32F, B[FORMATS.RGB] = o.RGB32F, B[FORMATS.RG] = o.RG32F, B[FORMATS.RED] = o.R32F, B[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT32F, B), t[TYPES.HALF_FLOAT] = ($ = {}, $[FORMATS.RGBA] = o.RGBA16F, $[FORMATS.RGB] = o.RGB16F, $[FORMATS.RG] = o.RG16F, $[FORMATS.RED] = o.R16F, $), t[TYPES.UNSIGNED_SHORT_5_6_5] = (U = {}, U[FORMATS.RGB] = o.RGB565, U), t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (V = {}, V[FORMATS.RGBA] = o.RGBA4, V), t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (H = {}, H[FORMATS.RGBA] = o.RGB5_A1, H), t[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (X = {}, X[FORMATS.RGBA] = o.RGB10_A2, X[FORMATS.RGBA_INTEGER] = o.RGB10_A2UI, X), t[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (Y = {}, Y[FORMATS.RGB] = o.R11F_G11F_B10F, Y), t[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (W = {}, W[FORMATS.RGB] = o.RGB9_E5, W), t[TYPES.UNSIGNED_INT_24_8] = (q = {}, q[FORMATS.DEPTH_STENCIL] = o.DEPTH24_STENCIL8, q), t[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (K = {}, K[FORMATS.DEPTH_STENCIL] = o.DEPTH32F_STENCIL8, K), t) : nt = (Z = {}, Z[TYPES.UNSIGNED_BYTE] = (J = {}, J[FORMATS.RGBA] = o.RGBA, J[FORMATS.RGB] = o.RGB, J[FORMATS.ALPHA] = o.ALPHA, J[FORMATS.LUMINANCE] = o.LUMINANCE, J[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, J), Z[TYPES.UNSIGNED_SHORT_5_6_5] = (Q = {}, Q[FORMATS.RGB] = o.RGB, Q), Z[TYPES.UNSIGNED_SHORT_4_4_4_4] = (rt = {}, rt[FORMATS.RGBA] = o.RGBA, rt), Z[TYPES.UNSIGNED_SHORT_5_5_5_1] = (et = {}, et[FORMATS.RGBA] = o.RGBA, et), Z), nt;\n}\nvar GLTexture = function() {\n  function o(t) {\n    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;\n  }\n  return o;\n}(), TextureSystem = function() {\n  function o(t) {\n    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  return o.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);\n    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = e;\n    for (var r = 0; r < e; r++)\n      this.boundTextures[r] = null;\n    this.emptyTextures = {};\n    var S = new GLTexture(t.createTexture());\n    t.bindTexture(t.TEXTURE_2D, S.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = S, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);\n    for (var r = 0; r < 6; r++)\n      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);\n    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);\n    for (var r = 0; r < this.boundTextures.length; r++)\n      this.bind(null, r);\n  }, o.prototype.bind = function(t, e) {\n    e === void 0 && (e = 0);\n    var r = this.gl;\n    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {\n      t.touched = this.renderer.textureGC.count;\n      var S = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);\n      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, S.texture)), S.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : S.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;\n    } else\n      this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;\n  }, o.prototype.reset = function() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (var t = 0; t < this.boundTextures.length; t++)\n      this.boundTextures[t] = this.unknownTexture;\n  }, o.prototype.unbind = function(t) {\n    var e = this, r = e.gl, S = e.boundTextures;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (var T = 0; T < S.length; T++)\n        S[T] === this.unknownTexture && this.bind(null, T);\n    }\n    for (var T = 0; T < S.length; T++)\n      S[T] === t && (this.currentLocation !== T && (r.activeTexture(r.TEXTURE0 + T), this.currentLocation = T), r.bindTexture(t.target, this.emptyTextures[t.target].texture), S[T] = null);\n  }, o.prototype.ensureSamplerType = function(t) {\n    var e = this, r = e.boundTextures, S = e.hasIntegerTextures, T = e.CONTEXT_UID;\n    if (!!S)\n      for (var D = t - 1; D >= 0; --D) {\n        var N = r[D];\n        if (N) {\n          var B = N._glTextures[T];\n          B.samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(N);\n        }\n      }\n  }, o.prototype.initTexture = function(t) {\n    var e = new GLTexture(this.gl.createTexture());\n    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on(\"dispose\", this.destroyTexture, this), e;\n  }, o.prototype.initTextureType = function(t, e) {\n    var r, S;\n    e.internalFormat = (S = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && S !== void 0 ? S : t.format, this.webGLVersion === 2 && t.type === TYPES.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;\n  }, o.prototype.updateTexture = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    if (!!e) {\n      var r = this.renderer;\n      if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))\n        e.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);\n      else {\n        var S = t.realWidth, T = t.realHeight, D = r.gl;\n        (e.width !== S || e.height !== T || e.dirtyId < 0) && (e.width = S, e.height = T, D.texImage2D(t.target, 0, e.internalFormat, S, T, 0, t.format, e.type, null));\n      }\n      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;\n    }\n  }, o.prototype.destroyTexture = function(t, e) {\n    var r = this.gl;\n    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off(\"dispose\", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {\n      var S = this.managedTextures.indexOf(t);\n      S !== -1 && removeItems(this.managedTextures, S, 1);\n    }\n  }, o.prototype.updateTextureStyle = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    !e || ((t.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);\n  }, o.prototype.setStyle = function(t, e) {\n    var r = this.gl;\n    if (e.mipmap && t.mipmap !== MIPMAP_MODES.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {\n      r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);\n      var S = this.renderer.context.extensions.anisotropicFiltering;\n      if (S && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES.LINEAR) {\n        var T = Math.min(t.anisotropicLevel, r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        r.texParameterf(t.target, S.TEXTURE_MAX_ANISOTROPY_EXT, T);\n      }\n    } else\n      r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);\n    r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), _systems = {\n  __proto__: null,\n  FilterSystem,\n  BatchSystem,\n  ContextSystem,\n  FramebufferSystem,\n  GeometrySystem,\n  MaskSystem,\n  ScissorSystem,\n  StencilSystem,\n  ProjectionSystem,\n  RenderTextureSystem,\n  ShaderSystem,\n  StateSystem,\n  TextureGCSystem,\n  TextureSystem\n}, tempMatrix = new Matrix(), AbstractRenderer = function(o) {\n  __extends$p(t, o);\n  function t(e, r) {\n    e === void 0 && (e = RENDERER_TYPE.UNKNOWN);\n    var S = o.call(this) || this;\n    return r = Object.assign({}, settings.RENDER_OPTIONS, r), S.options = r, S.type = e, S.screen = new Rectangle(0, 0, r.width, r.height), S.view = r.view || settings.ADAPTER.createCanvas(), S.resolution = r.resolution || settings.RESOLUTION, S.useContextAlpha = r.useContextAlpha, S.autoDensity = !!r.autoDensity, S.preserveDrawingBuffer = r.preserveDrawingBuffer, S.clearBeforeRender = r.clearBeforeRender, S._backgroundColor = 0, S._backgroundColorRgba = [0, 0, 0, 1], S._backgroundColorString = \"#000000\", S.backgroundColor = r.backgroundColor || S._backgroundColor, S.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (deprecation(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\"), S.useContextAlpha = r.transparent, S.backgroundAlpha = r.transparent ? 0 : 1), S._lastObjectRendered = null, S.plugins = {}, S;\n  }\n  return t.prototype.initPlugins = function(e) {\n    for (var r in e)\n      this.plugins[r] = new e[r](this);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.view.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.view.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, r) {\n    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);\n    var S = this.view.width / this.resolution, T = this.view.height / this.resolution;\n    this.screen.width = S, this.screen.height = T, this.autoDensity && (this.view.style.width = S + \"px\", this.view.style.height = T + \"px\"), this.emit(\"resize\", S, T);\n  }, t.prototype.generateTexture = function(e, r, S, T) {\n    r === void 0 && (r = {}), typeof r == \"number\" && (deprecation(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\"), r = { scaleMode: r, resolution: S, region: T });\n    var D = r.region, N = __rest$3(r, [\"region\"]);\n    T = D || e.getLocalBounds(null, !0), T.width === 0 && (T.width = 1), T.height === 0 && (T.height = 1);\n    var B = RenderTexture.create(__assign$7({ width: T.width, height: T.height }, N));\n    return tempMatrix.tx = -T.x, tempMatrix.ty = -T.y, this.render(e, {\n      renderTexture: B,\n      clear: !1,\n      transform: tempMatrix,\n      skipUpdateTransform: !!e.parent\n    }), B;\n  }, t.prototype.destroy = function(e) {\n    for (var r in this.plugins)\n      this.plugins[r].destroy(), this.plugins[r] = null;\n    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);\n    var S = this;\n    S.plugins = null, S.type = RENDERER_TYPE.UNKNOWN, S.view = null, S.screen = null, S._tempDisplayObjectParent = null, S.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;\n  }, Object.defineProperty(t.prototype, \"backgroundColor\", {\n    get: function() {\n      return this._backgroundColor;\n    },\n    set: function(e) {\n      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"backgroundAlpha\", {\n    get: function() {\n      return this._backgroundColorRgba[3];\n    },\n    set: function(e) {\n      this._backgroundColorRgba[3] = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), GLBuffer = function() {\n  function o(t) {\n    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n  }\n  return o;\n}(), BufferSystem = function() {\n  function o(t) {\n    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};\n  }\n  return o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o.prototype.contextChange = function() {\n    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }, o.prototype.bind = function(t) {\n    var e = this, r = e.gl, S = e.CONTEXT_UID, T = t._glBuffers[S] || this.createGLBuffer(t);\n    r.bindBuffer(t.type, T.buffer);\n  }, o.prototype.bindBufferBase = function(t, e) {\n    var r = this, S = r.gl, T = r.CONTEXT_UID;\n    if (this.boundBufferBases[e] !== t) {\n      var D = t._glBuffers[T] || this.createGLBuffer(t);\n      this.boundBufferBases[e] = t, S.bindBufferBase(S.UNIFORM_BUFFER, e, D.buffer);\n    }\n  }, o.prototype.bindBufferRange = function(t, e, r) {\n    var S = this, T = S.gl, D = S.CONTEXT_UID;\n    r = r || 0;\n    var N = t._glBuffers[D] || this.createGLBuffer(t);\n    T.bindBufferRange(T.UNIFORM_BUFFER, e || 0, N.buffer, r * 256, 256);\n  }, o.prototype.update = function(t) {\n    var e = this, r = e.gl, S = e.CONTEXT_UID, T = t._glBuffers[S];\n    if (t._updateID !== T.updateID)\n      if (T.updateID = t._updateID, r.bindBuffer(t.type, T.buffer), T.byteLength >= t.data.byteLength)\n        r.bufferSubData(t.type, 0, t.data);\n      else {\n        var D = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;\n        T.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, D);\n      }\n  }, o.prototype.dispose = function(t, e) {\n    if (!!this.managedBuffers[t.id]) {\n      delete this.managedBuffers[t.id];\n      var r = t._glBuffers[this.CONTEXT_UID], S = this.gl;\n      t.disposeRunner.remove(this), r && (e || S.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);\n    }\n  }, o.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)\n      this.dispose(this.managedBuffers[e[r]], t);\n  }, o.prototype.createGLBuffer = function(t) {\n    var e = this, r = e.CONTEXT_UID, S = e.gl;\n    return t._glBuffers[r] = new GLBuffer(S.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];\n  }, o;\n}(), Renderer = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    var r = o.call(this, RENDERER_TYPE.WEBGL, e) || this;\n    return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {\n      destroy: new Runner(\"destroy\"),\n      contextChange: new Runner(\"contextChange\"),\n      reset: new Runner(\"reset\"),\n      update: new Runner(\"update\"),\n      postrender: new Runner(\"postrender\"),\n      prerender: new Runner(\"prerender\"),\n      resize: new Runner(\"resize\")\n    }, r.runners.contextChange.add(r), r.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, !0), r.addSystem(MaskSystem, \"mask\").addSystem(ContextSystem, \"context\").addSystem(StateSystem, \"state\").addSystem(ShaderSystem, \"shader\").addSystem(TextureSystem, \"texture\").addSystem(BufferSystem, \"buffer\").addSystem(GeometrySystem, \"geometry\").addSystem(FramebufferSystem, \"framebuffer\").addSystem(ScissorSystem, \"scissor\").addSystem(StencilSystem, \"stencil\").addSystem(ProjectionSystem, \"projection\").addSystem(TextureGCSystem, \"textureGC\").addSystem(FilterSystem, \"filter\").addSystem(RenderTextureSystem, \"renderTexture\").addSystem(BatchSystem, \"batch\"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({\n      alpha: !!r.useContextAlpha,\n      antialias: e.antialias,\n      premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== \"notMultiplied\",\n      stencil: !0,\n      preserveDrawingBuffer: e.preserveDrawingBuffer,\n      powerPreference: r.options.powerPreference\n    }), r.renderingToScreen = !0, sayHello(r.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\"), r.resize(r.options.width, r.options.height), r;\n  }\n  return t.create = function(e) {\n    if (isWebGLSupported())\n      return new t(e);\n    throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n  }, t.prototype.contextChange = function() {\n    var e = this.gl, r;\n    if (this.context.webGLVersion === 1) {\n      var S = e.getParameter(e.FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, S);\n    } else {\n      var S = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, S);\n    }\n    r >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : r >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : r >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;\n  }, t.prototype.addSystem = function(e, r) {\n    var S = new e(this);\n    if (this[r])\n      throw new Error('Whoops! The name \"' + r + '\" is already in use');\n    this[r] = S;\n    for (var T in this.runners)\n      this.runners[T].add(S);\n    return this;\n  }, t.prototype.render = function(e, r) {\n    var S, T, D, N;\n    if (r && (r instanceof RenderTexture ? (deprecation(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\"), S = r, T = arguments[2], D = arguments[3], N = arguments[4]) : (S = r.renderTexture, T = r.clear, D = r.transform, N = r.skipUpdateTransform)), this.renderingToScreen = !S, this.runners.prerender.emit(), this.emit(\"prerender\"), this.projection.transform = D, !this.context.isLost) {\n      if (S || (this._lastObjectRendered = e), !N) {\n        var B = e.enableTempParent();\n        e.updateTransform(), e.disableTempParent(B);\n      }\n      this.renderTexture.bind(S), this.batch.currentRenderer.start(), (T !== void 0 ? T : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), S && S.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit(\"postrender\");\n    }\n  }, t.prototype.generateTexture = function(e, r, S, T) {\n    r === void 0 && (r = {});\n    var D = o.prototype.generateTexture.call(this, e, r, S, T);\n    return this.framebuffer.blit(), D;\n  }, t.prototype.resize = function(e, r) {\n    o.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);\n  }, t.prototype.reset = function() {\n    return this.runners.reset.emit(), this;\n  }, t.prototype.clear = function() {\n    this.renderTexture.bind(), this.renderTexture.clear();\n  }, t.prototype.destroy = function(e) {\n    this.runners.destroy.emit();\n    for (var r in this.runners)\n      this.runners[r].destroy();\n    o.prototype.destroy.call(this, e), this.gl = null;\n  }, Object.defineProperty(t.prototype, \"extract\", {\n    get: function() {\n      return deprecation(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\"), this.plugins.extract;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.registerPlugin = function(e, r) {\n    deprecation(\"6.5.0\", \"Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.\"), extensions.add({\n      name: e,\n      type: ExtensionType.RendererPlugin,\n      ref: r\n    });\n  }, t.__plugins = {}, t;\n}(AbstractRenderer);\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nfunction autoDetectRenderer(o) {\n  return Renderer.create(o);\n}\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, System = function() {\n  function o(t) {\n    deprecation(\"6.1.0\", \"System class is deprecated, implemement ISystem interface instead.\"), this.renderer = t;\n  }\n  return o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o;\n}(), BatchDrawCall = function() {\n  function o() {\n    this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n  }\n  return o;\n}(), BatchTextureArray = function() {\n  function o() {\n    this.elements = [], this.ids = [], this.count = 0;\n  }\n  return o.prototype.clear = function() {\n    for (var t = 0; t < this.count; t++)\n      this.elements[t] = null;\n    this.count = 0;\n  }, o;\n}(), ViewableBuffer = function() {\n  function o(t) {\n    typeof t == \"number\" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  return Object.defineProperty(o.prototype, \"int8View\", {\n    get: function() {\n      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"uint8View\", {\n    get: function() {\n      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"int16View\", {\n    get: function() {\n      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"uint16View\", {\n    get: function() {\n      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"int32View\", {\n    get: function() {\n      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.view = function(t) {\n    return this[t + \"View\"];\n  }, o.prototype.destroy = function() {\n    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n  }, o.sizeOf = function(t) {\n    switch (t) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(t + \" isn't a valid view type\");\n    }\n  }, o;\n}(), AbstractBatchRenderer = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = State.for2d(), r.size = settings.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on(\"prerender\", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer.gl;\n    settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n    for (var r = 0; r < this._packedGeometryPoolSize; r++)\n      this._packedGeometries[r] = new this.geometryClass();\n    this.initFlushBuffers();\n  }, t.prototype.initFlushBuffers = function() {\n    for (var e = t._drawCallPool, r = t._textureArrayPool, S = this.size / 4, T = Math.floor(S / this.MAX_TEXTURES) + 1; e.length < S; )\n      e.push(new BatchDrawCall());\n    for (; r.length < T; )\n      r.push(new BatchTextureArray());\n    for (var D = 0; D < this.MAX_TEXTURES; D++)\n      this._tempBoundTextures[D] = null;\n  }, t.prototype.onPrerender = function() {\n    this._flushId = 0;\n  }, t.prototype.render = function(e) {\n    !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);\n  }, t.prototype.buildTexturesAndDrawCalls = function() {\n    var e = this, r = e._bufferedTextures, S = e.MAX_TEXTURES, T = t._textureArrayPool, D = this.renderer.batch, N = this._tempBoundTextures, B = this.renderer.textureGC.count, $ = ++BaseTexture._globalBatch, U = 0, V = T[0], H = 0;\n    D.copyBoundTextures(N, S);\n    for (var X = 0; X < this._bufferSize; ++X) {\n      var Y = r[X];\n      r[X] = null, Y._batchEnabled !== $ && (V.count >= S && (D.boundArray(V, N, $, S), this.buildDrawCalls(V, H, X), H = X, V = T[++U], ++$), Y._batchEnabled = $, Y.touched = B, V.elements[V.count++] = Y);\n    }\n    V.count > 0 && (D.boundArray(V, N, $, S), this.buildDrawCalls(V, H, this._bufferSize), ++U, ++$);\n    for (var X = 0; X < N.length; X++)\n      N[X] = null;\n    BaseTexture._globalBatch = $;\n  }, t.prototype.buildDrawCalls = function(e, r, S) {\n    var T = this, D = T._bufferedElements, N = T._attributeBuffer, B = T._indexBuffer, $ = T.vertexSize, U = t._drawCallPool, V = this._dcIndex, H = this._aIndex, X = this._iIndex, Y = U[V];\n    Y.start = this._iIndex, Y.texArray = e;\n    for (var W = r; W < S; ++W) {\n      var q = D[W], K = q._texture.baseTexture, Z = premultiplyBlendMode[K.alphaMode ? 1 : 0][q.blendMode];\n      D[W] = null, r < W && Y.blend !== Z && (Y.size = X - Y.start, r = W, Y = U[++V], Y.texArray = e, Y.start = X), this.packInterleavedGeometry(q, N, B, H, X), H += q.vertexData.length / 2 * $, X += q.indices.length, Y.blend = Z;\n    }\n    r < S && (Y.size = X - Y.start, ++V), this._dcIndex = V, this._aIndex = H, this._iIndex = X;\n  }, t.prototype.bindAndClearTexArray = function(e) {\n    for (var r = this.renderer.texture, S = 0; S < e.count; S++)\n      r.bind(e.elements[S], e.ids[S]), e.elements[S] = null;\n    e.count = 0;\n  }, t.prototype.updateGeometry = function() {\n    var e = this, r = e._packedGeometries, S = e._attributeBuffer, T = e._indexBuffer;\n    settings.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(S.rawBinaryData), r[this._flushId]._indexBuffer.update(T), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(S.rawBinaryData), r[this._flushId]._indexBuffer.update(T), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }, t.prototype.drawBatches = function() {\n    for (var e = this._dcIndex, r = this.renderer, S = r.gl, T = r.state, D = t._drawCallPool, N = null, B = 0; B < e; B++) {\n      var $ = D[B], U = $.texArray, V = $.type, H = $.size, X = $.start, Y = $.blend;\n      N !== U && (N = U, this.bindAndClearTexArray(U)), this.state.blendMode = Y, T.set(this.state), S.drawElements(V, H, S.UNSIGNED_SHORT, X * 2);\n    }\n  }, t.prototype.flush = function() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }, t.prototype.start = function() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }, t.prototype.stop = function() {\n    this.flush();\n  }, t.prototype.destroy = function() {\n    for (var e = 0; e < this._packedGeometryPoolSize; e++)\n      this._packedGeometries[e] && this._packedGeometries[e].destroy();\n    this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), o.prototype.destroy.call(this);\n  }, t.prototype.getAttributeBuffer = function(e) {\n    var r = nextPow2(Math.ceil(e / 8)), S = log2(r), T = r * 8;\n    this._aBuffers.length <= S && (this._iBuffers.length = S + 1);\n    var D = this._aBuffers[T];\n    return D || (this._aBuffers[T] = D = new ViewableBuffer(T * this.vertexSize * 4)), D;\n  }, t.prototype.getIndexBuffer = function(e) {\n    var r = nextPow2(Math.ceil(e / 12)), S = log2(r), T = r * 12;\n    this._iBuffers.length <= S && (this._iBuffers.length = S + 1);\n    var D = this._iBuffers[S];\n    return D || (this._iBuffers[S] = D = new Uint16Array(T)), D;\n  }, t.prototype.packInterleavedGeometry = function(e, r, S, T, D) {\n    for (var N = r.uint32View, B = r.float32View, $ = T / this.vertexSize, U = e.uvs, V = e.indices, H = e.vertexData, X = e._texture.baseTexture._batchLocation, Y = Math.min(e.worldAlpha, 1), W = Y < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, Y) : e._tintRGB + (Y * 255 << 24), q = 0; q < H.length; q += 2)\n      B[T++] = H[q], B[T++] = H[q + 1], B[T++] = U[q], B[T++] = U[q + 1], N[T++] = W, B[T++] = X;\n    for (var q = 0; q < V.length; q++)\n      S[D++] = $ + V[q];\n  }, t._drawCallPool = [], t._textureArrayPool = [], t;\n}(ObjectRenderer), BatchShaderGenerator = function() {\n  function o(t, e) {\n    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf(\"%count%\") < 0)\n      throw new Error('Fragment template must contain \"%count%\".');\n    if (e.indexOf(\"%forloop%\") < 0)\n      throw new Error('Fragment template must contain \"%forloop%\".');\n  }\n  return o.prototype.generateShader = function(t) {\n    if (!this.programCache[t]) {\n      for (var e = new Int32Array(t), r = 0; r < t; r++)\n        e[r] = r;\n      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);\n      var S = this.fragTemplate;\n      S = S.replace(/%count%/gi, \"\" + t), S = S.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, S);\n    }\n    var T = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[t]\n    };\n    return new Shader(this.programCache[t], T);\n  }, o.prototype.generateSampleSrc = function(t) {\n    var e = \"\";\n    e += `\n`, e += `\n`;\n    for (var r = 0; r < t; r++)\n      r > 0 && (e += `\nelse `), r < t - 1 && (e += \"if(vTextureId < \" + r + \".5)\"), e += `\n{`, e += `\n\tcolor = texture2D(uSamplers[` + r + \"], vTextureCoord);\", e += `\n}`;\n    return e += `\n`, e += `\n`, e;\n  }, o;\n}(), BatchGeometry = function(o) {\n  __extends$p(t, o);\n  function t(e) {\n    e === void 0 && (e = !1);\n    var r = o.call(this) || this;\n    return r._buffer = new Buffer$1(null, e, !1), r._indexBuffer = new Buffer$1(null, e, !0), r.addAttribute(\"aVertexPosition\", r._buffer, 2, !1, TYPES.FLOAT).addAttribute(\"aTextureCoord\", r._buffer, 2, !1, TYPES.FLOAT).addAttribute(\"aColor\", r._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute(\"aTextureId\", r._buffer, 1, !0, TYPES.FLOAT).addIndex(r._indexBuffer), r;\n  }\n  return t;\n}(Geometry), defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`, defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`, BatchPluginFactory = function() {\n  function o() {\n  }\n  return o.create = function(t) {\n    var e = Object.assign({\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      geometryClass: BatchGeometry,\n      vertexSize: 6\n    }, t), r = e.vertex, S = e.fragment, T = e.vertexSize, D = e.geometryClass;\n    return function(N) {\n      __extends$p(B, N);\n      function B($) {\n        var U = N.call(this, $) || this;\n        return U.shaderGenerator = new BatchShaderGenerator(r, S), U.geometryClass = D, U.vertexSize = T, U;\n      }\n      return B;\n    }(AbstractBatchRenderer);\n  }, Object.defineProperty(o, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"defaultFragmentTemplate\", {\n    get: function() {\n      return defaultFragment;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}(), BatchRenderer = BatchPluginFactory.create();\nObject.assign(BatchRenderer, {\n  extension: {\n    name: \"batch\",\n    type: ExtensionType.RendererPlugin\n  }\n});\nvar resources = {}, _loop_1 = function(o) {\n  Object.defineProperty(resources, o, {\n    get: function() {\n      return deprecation(\"6.0.0\", \"PIXI.systems.\" + o + \" has moved to PIXI.\" + o), _resources[o];\n    }\n  });\n};\nfor (var name in _resources)\n  _loop_1(name);\nvar systems = {}, _loop_2 = function(o) {\n  Object.defineProperty(systems, o, {\n    get: function() {\n      return deprecation(\"6.0.0\", \"PIXI.resources.\" + o + \" has moved to PIXI.\" + o), _systems[o];\n    }\n  });\n};\nfor (var name in _systems)\n  _loop_2(name);\nvar VERSION = \"6.5.8\";\nconst n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AbstractBatchRenderer,\n  AbstractMultiResource,\n  AbstractRenderer,\n  ArrayResource,\n  Attribute,\n  BaseImageResource,\n  BaseRenderTexture,\n  BaseTexture,\n  BatchDrawCall,\n  BatchGeometry,\n  BatchPluginFactory,\n  BatchRenderer,\n  BatchShaderGenerator,\n  BatchSystem,\n  BatchTextureArray,\n  Buffer: Buffer$1,\n  BufferResource,\n  CanvasResource,\n  ContextSystem,\n  CubeResource,\n  Filter,\n  FilterState,\n  FilterSystem,\n  Framebuffer,\n  FramebufferSystem,\n  GLFramebuffer,\n  GLProgram,\n  GLTexture,\n  Geometry,\n  GeometrySystem,\n  IGLUniformData,\n  INSTALLED,\n  ImageBitmapResource,\n  ImageResource,\n  MaskData,\n  MaskSystem,\n  ObjectRenderer,\n  Program,\n  ProjectionSystem,\n  Quad,\n  QuadUv,\n  RenderTexture,\n  RenderTexturePool,\n  RenderTextureSystem,\n  Renderer,\n  Resource,\n  SVGResource,\n  ScissorSystem,\n  Shader,\n  ShaderSystem,\n  SpriteMaskFilter,\n  State,\n  StateSystem,\n  StencilSystem,\n  System,\n  Texture,\n  TextureGCSystem,\n  TextureMatrix,\n  TextureSystem,\n  TextureUvs,\n  UniformGroup,\n  VERSION,\n  VideoResource,\n  ViewableBuffer,\n  autoDetectRenderer,\n  autoDetectResource,\n  checkMaxIfStatementsInShader,\n  createUBOElements,\n  defaultFilterVertex,\n  defaultVertex: defaultVertex$1,\n  generateProgram,\n  generateUniformBufferSync,\n  getTestContext,\n  getUBOData,\n  resources,\n  systems,\n  uniformParsers,\n  get ExtensionType() {\n    return ExtensionType;\n  },\n  extensions\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar accessibleTarget = {\n  accessible: !1,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: !1,\n  _accessibleDiv: null,\n  accessibleType: \"button\",\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: !0,\n  renderId: -1\n};\nDisplayObject.mixin(accessibleTarget);\nvar KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {\n  function o(t) {\n    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile.tablet || isMobile.phone) && this.createTouchHook();\n    var e = document.createElement(\"div\");\n    e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_TOUCH_POS_X + \"px\", e.style.left = DIV_TOUCH_POS_Y + \"px\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1);\n  }\n  return Object.defineProperty(o.prototype, \"isActive\", {\n    get: function() {\n      return this._isActive;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"isMobileAccessibility\", {\n    get: function() {\n      return this._isMobileAccessibility;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.createTouchHook = function() {\n    var t = this, e = document.createElement(\"button\");\n    e.style.width = DIV_HOOK_SIZE + \"px\", e.style.height = DIV_HOOK_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_HOOK_POS_X + \"px\", e.style.left = DIV_HOOK_POS_Y + \"px\", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = \"#FF0000\", e.title = \"select to enable accessibility for this content\", e.addEventListener(\"focus\", function() {\n      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();\n    }), document.body.appendChild(e), this._hookDiv = e;\n  }, o.prototype.destroyTouchHook = function() {\n    !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n  }, o.prototype.activate = function() {\n    var t;\n    this._isActive || (this._isActive = !0, globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.on(\"postrender\", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));\n  }, o.prototype.deactivate = function() {\n    var t;\n    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.off(\"postrender\", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));\n  }, o.prototype.updateAccessibleObjects = function(t) {\n    if (!(!t.visible || !t.accessibleChildren)) {\n      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);\n      var e = t.children;\n      if (e)\n        for (var r = 0; r < e.length; r++)\n          this.updateAccessibleObjects(e[r]);\n    }\n  }, o.prototype.update = function() {\n    var t = performance.now();\n    if (!(isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {\n      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n      var e = this.renderer.view.getBoundingClientRect(), r = e.left, S = e.top, T = e.width, D = e.height, N = this.renderer, B = N.width, $ = N.height, U = N.resolution, V = T / B * U, H = D / $ * U, X = this.div;\n      X.style.left = r + \"px\", X.style.top = S + \"px\", X.style.width = B + \"px\", X.style.height = $ + \"px\";\n      for (var Y = 0; Y < this.children.length; Y++) {\n        var W = this.children[Y];\n        if (W.renderId !== this.renderId)\n          W._accessibleActive = !1, removeItems(this.children, Y, 1), this.div.removeChild(W._accessibleDiv), this.pool.push(W._accessibleDiv), W._accessibleDiv = null, Y--;\n        else {\n          X = W._accessibleDiv;\n          var q = W.hitArea, K = W.worldTransform;\n          W.hitArea ? (X.style.left = (K.tx + q.x * K.a) * V + \"px\", X.style.top = (K.ty + q.y * K.d) * H + \"px\", X.style.width = q.width * K.a * V + \"px\", X.style.height = q.height * K.d * H + \"px\") : (q = W.getBounds(), this.capHitArea(q), X.style.left = q.x * V + \"px\", X.style.top = q.y * H + \"px\", X.style.width = q.width * V + \"px\", X.style.height = q.height * H + \"px\", X.title !== W.accessibleTitle && W.accessibleTitle !== null && (X.title = W.accessibleTitle), X.getAttribute(\"aria-label\") !== W.accessibleHint && W.accessibleHint !== null && X.setAttribute(\"aria-label\", W.accessibleHint)), (W.accessibleTitle !== X.title || W.tabIndex !== X.tabIndex) && (X.title = W.accessibleTitle, X.tabIndex = W.tabIndex, this.debug && this.updateDebugHTML(X));\n        }\n      }\n      this.renderId++;\n    }\n  }, o.prototype.updateDebugHTML = function(t) {\n    t.innerHTML = \"type: \" + t.type + \"</br> title : \" + t.title + \"</br> tabIndex: \" + t.tabIndex;\n  }, o.prototype.capHitArea = function(t) {\n    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);\n    var e = this.renderer, r = e.width, S = e.height;\n    t.x + t.width > r && (t.width = r - t.x), t.y + t.height > S && (t.height = S - t.y);\n  }, o.prototype.addChild = function(t) {\n    var e = this.pool.pop();\n    e || (e = document.createElement(\"button\"), e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\", e.style.position = \"absolute\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = \"none\", navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1 ? e.setAttribute(\"aria-live\", \"off\") : e.setAttribute(\"aria-live\", \"polite\"), navigator.userAgent.match(/rv:.*Gecko\\//) ? e.setAttribute(\"aria-relevant\", \"additions\") : e.setAttribute(\"aria-relevant\", \"text\"), e.addEventListener(\"click\", this._onClick.bind(this)), e.addEventListener(\"focus\", this._onFocus.bind(this)), e.addEventListener(\"focusout\", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = \"displayObject \" + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute(\"aria-label\", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;\n  }, o.prototype._onClick = function(t) {\n    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;\n    e.dispatchEvent(r, \"click\", S), e.dispatchEvent(r, \"pointertap\", S), e.dispatchEvent(r, \"tap\", S);\n  }, o.prototype._onFocus = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"assertive\");\n    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;\n    e.dispatchEvent(r, \"mouseover\", S);\n  }, o.prototype._onFocusOut = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"polite\");\n    var e = this.renderer.plugins.interaction, r = t.target.displayObject, S = e.eventData;\n    e.dispatchEvent(r, \"mouseout\", S);\n  }, o.prototype._onKeyDown = function(t) {\n    t.keyCode === KEY_CODE_TAB && this.activate();\n  }, o.prototype._onMouseMove = function(t) {\n    t.movementX === 0 && t.movementY === 0 || this.deactivate();\n  }, o.prototype.destroy = function() {\n    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n  }, o.extension = {\n    name: \"accessibility\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, o;\n}();\nvar InteractionData = function() {\n  function o() {\n    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;\n  }\n  return Object.defineProperty(o.prototype, \"pointerId\", {\n    get: function() {\n      return this.identifier;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.getLocalPosition = function(t, e, r) {\n    return t.worldTransform.applyInverse(r || this.global, e);\n  }, o.prototype.copyEvent = function(t) {\n    \"isPrimary\" in t && t.isPrimary && (this.isPrimary = !0), this.button = \"button\" in t && t.button;\n    var e = \"buttons\" in t && t.buttons;\n    this.buttons = Number.isInteger(e) ? e : \"which\" in t && t.which, this.width = \"width\" in t && t.width, this.height = \"height\" in t && t.height, this.tiltX = \"tiltX\" in t && t.tiltX, this.tiltY = \"tiltY\" in t && t.tiltY, this.pointerType = \"pointerType\" in t && t.pointerType, this.pressure = \"pressure\" in t && t.pressure, this.rotationAngle = \"rotationAngle\" in t && t.rotationAngle, this.twist = \"twist\" in t && t.twist || 0, this.tangentialPressure = \"tangentialPressure\" in t && t.tangentialPressure || 0;\n  }, o.prototype.reset = function() {\n    this.isPrimary = !1;\n  }, o;\n}();\nvar extendStatics$o = function(o, t) {\n  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$o(o, t);\n};\nfunction __extends$o(o, t) {\n  extendStatics$o(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar InteractionEvent = function() {\n  function o() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;\n  }\n  return o.prototype.stopPropagation = function() {\n    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;\n  }, o.prototype.reset = function() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;\n  }, o;\n}(), InteractionTrackingData = function() {\n  function o(t) {\n    this._pointerId = t, this._flags = o.FLAGS.NONE;\n  }\n  return o.prototype._doSet = function(t, e) {\n    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;\n  }, Object.defineProperty(o.prototype, \"pointerId\", {\n    get: function() {\n      return this._pointerId;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"flags\", {\n    get: function() {\n      return this._flags;\n    },\n    set: function(t) {\n      this._flags = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"none\", {\n    get: function() {\n      return this._flags === o.FLAGS.NONE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"over\", {\n    get: function() {\n      return (this._flags & o.FLAGS.OVER) !== 0;\n    },\n    set: function(t) {\n      this._doSet(o.FLAGS.OVER, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"rightDown\", {\n    get: function() {\n      return (this._flags & o.FLAGS.RIGHT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(o.FLAGS.RIGHT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"leftDown\", {\n    get: function() {\n      return (this._flags & o.FLAGS.LEFT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(o.FLAGS.LEFT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  }), o;\n}(), TreeSearch = function() {\n  function o() {\n    this._tempPoint = new Point();\n  }\n  return o.prototype.recursiveFindHit = function(t, e, r, S, T) {\n    var D;\n    if (!e || !e.visible)\n      return !1;\n    var N = t.data.global;\n    T = e.interactive || T;\n    var B = !1, $ = T, U = !0;\n    if (e.hitArea)\n      S && (e.worldTransform.applyInverse(N, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? B = !0 : (S = !1, U = !1)), $ = !1;\n    else if (e._mask && S) {\n      var V = e._mask.isMaskData ? e._mask.maskObject : e._mask;\n      V && !(!((D = V.containsPoint) === null || D === void 0) && D.call(V, N)) && (S = !1);\n    }\n    if (U && e.interactiveChildren && e.children)\n      for (var H = e.children, X = H.length - 1; X >= 0; X--) {\n        var Y = H[X], W = this.recursiveFindHit(t, Y, r, S, $);\n        if (W) {\n          if (!Y.parent)\n            continue;\n          $ = !1, W && (t.target && (S = !1), B = !0);\n        }\n      }\n    return T && (S && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(N) && (B = !0), e.interactive && (B && !t.target && (t.target = e), r && r(t, e, !!B))), B;\n  }, o.prototype.findHit = function(t, e, r, S) {\n    this.recursiveFindHit(t, e, r, S, !1);\n  }, o;\n}(), interactiveTarget = {\n  interactive: !1,\n  interactiveChildren: !0,\n  hitArea: null,\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(o) {\n    o ? this.cursor = \"pointer\" : this.cursor === \"pointer\" && (this.cursor = null);\n  },\n  cursor: null,\n  get trackedPointers() {\n    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;\n  },\n  _trackedPointers: void 0\n};\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1, hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n}, InteractionManager = function(o) {\n  __extends$o(t, o);\n  function t(e, r) {\n    var S = o.call(this) || this;\n    return r = r || {}, S.renderer = e, S.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, S.interactionFrequency = r.interactionFrequency || 10, S.mouse = new InteractionData(), S.mouse.identifier = MOUSE_POINTER_ID, S.mouse.global.set(-999999), S.activeInteractionData = {}, S.activeInteractionData[MOUSE_POINTER_ID] = S.mouse, S.interactionDataPool = [], S.eventData = new InteractionEvent(), S.interactionDOMElement = null, S.moveWhenInside = !1, S.eventsAdded = !1, S.tickerAdded = !1, S.mouseOverRenderer = !(\"PointerEvent\" in globalThis), S.supportsTouchEvents = \"ontouchstart\" in globalThis, S.supportsPointerEvents = !!globalThis.PointerEvent, S.onPointerUp = S.onPointerUp.bind(S), S.processPointerUp = S.processPointerUp.bind(S), S.onPointerCancel = S.onPointerCancel.bind(S), S.processPointerCancel = S.processPointerCancel.bind(S), S.onPointerDown = S.onPointerDown.bind(S), S.processPointerDown = S.processPointerDown.bind(S), S.onPointerMove = S.onPointerMove.bind(S), S.processPointerMove = S.processPointerMove.bind(S), S.onPointerOut = S.onPointerOut.bind(S), S.processPointerOverOut = S.processPointerOverOut.bind(S), S.onPointerOver = S.onPointerOver.bind(S), S.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    }, S.currentCursorMode = null, S.cursor = null, S.resolution = 1, S.delayedEvents = [], S.search = new TreeSearch(), S._tempDisplayObject = new TemporaryDisplayObject(), S._eventListenerOptions = { capture: !0, passive: !1 }, S._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, S.setTargetElement(S.renderer.view, S.renderer.resolution), S;\n  }\n  return Object.defineProperty(t.prototype, \"useSystemTicker\", {\n    get: function() {\n      return this._useSystemTicker;\n    },\n    set: function(e) {\n      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"lastObjectRendered\", {\n    get: function() {\n      return this.renderer._lastObjectRendered || this._tempDisplayObject;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.hitTest = function(e, r) {\n    return hitTestEvent.target = null, hitTestEvent.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(hitTestEvent, r, null, !0), hitTestEvent.target;\n  }, t.prototype.setTargetElement = function(e, r) {\n    r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();\n  }, t.prototype.addTickerListener = function() {\n    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);\n  }, t.prototype.removeTickerListener = function() {\n    !this.tickerAdded || (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n  }, t.prototype.addEvents = function() {\n    if (!(this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"none\", e.msTouchAction = \"none\") : this.supportsPointerEvents && (e.touchAction = \"none\"), this.supportsPointerEvents ? (globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;\n    }\n  }, t.prototype.removeEvents = function() {\n    if (!(!this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"\", e.msTouchAction = \"\") : this.supportsPointerEvents && (e.touchAction = \"\"), this.supportsPointerEvents ? (globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;\n    }\n  }, t.prototype.tickerUpdate = function(e) {\n    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n  }, t.prototype.update = function() {\n    if (!!this.interactionDOMElement) {\n      if (this._didMove) {\n        this._didMove = !1;\n        return;\n      }\n      this.cursor = null;\n      for (var e in this.activeInteractionData)\n        if (this.activeInteractionData.hasOwnProperty(e)) {\n          var r = this.activeInteractionData[e];\n          if (r.originalEvent && r.pointerType !== \"touch\") {\n            var S = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);\n            this.processInteractive(S, this.lastObjectRendered, this.processPointerOverOut, !0);\n          }\n        }\n      this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.setCursorMode = function(e) {\n    e = e || \"default\";\n    var r = !0;\n    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {\n      this.currentCursorMode = e;\n      var S = this.cursorStyles[e];\n      if (S)\n        switch (typeof S) {\n          case \"string\":\n            r && (this.interactionDOMElement.style.cursor = S);\n            break;\n          case \"function\":\n            S(e);\n            break;\n          case \"object\":\n            r && Object.assign(this.interactionDOMElement.style, S);\n            break;\n        }\n      else\n        r && typeof e == \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);\n    }\n  }, t.prototype.dispatchEvent = function(e, r, S) {\n    (!S.stopPropagationHint || e === S.stopsPropagatingAt) && (S.currentTarget = e, S.type = r, e.emit(r, S), e[r] && e[r](S));\n  }, t.prototype.delayDispatchEvent = function(e, r, S) {\n    this.delayedEvents.push({ displayObject: e, eventString: r, eventData: S });\n  }, t.prototype.mapPositionToPoint = function(e, r, S) {\n    var T;\n    this.interactionDOMElement.parentElement ? T = this.interactionDOMElement.getBoundingClientRect() : T = {\n      x: 0,\n      y: 0,\n      width: this.interactionDOMElement.width,\n      height: this.interactionDOMElement.height,\n      left: 0,\n      top: 0\n    };\n    var D = 1 / this.resolution;\n    e.x = (r - T.left) * (this.interactionDOMElement.width / T.width) * D, e.y = (S - T.top) * (this.interactionDOMElement.height / T.height) * D;\n  }, t.prototype.processInteractive = function(e, r, S, T) {\n    var D = this.search.findHit(e, r, S, T), N = this.delayedEvents;\n    if (!N.length)\n      return D;\n    e.stopPropagationHint = !1;\n    var B = N.length;\n    this.delayedEvents = [];\n    for (var $ = 0; $ < B; $++) {\n      var U = N[$], V = U.displayObject, H = U.eventString, X = U.eventData;\n      X.stopsPropagatingAt === V && (X.stopPropagationHint = !0), this.dispatchEvent(V, H, X);\n    }\n    return D;\n  }, t.prototype.onPointerDown = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var r = this.normalizeToPointerData(e);\n      if (this.autoPreventDefault && r[0].isNormalized) {\n        var S = e.cancelable || !(\"cancelable\" in e);\n        S && e.preventDefault();\n      }\n      for (var T = r.length, D = 0; D < T; D++) {\n        var N = r[D], B = this.getInteractionDataForPointerId(N), $ = this.configureInteractionEventForDOMEvent(this.eventData, N, B);\n        if ($.data.originalEvent = e, this.processInteractive($, this.lastObjectRendered, this.processPointerDown, !0), this.emit(\"pointerdown\", $), N.pointerType === \"touch\")\n          this.emit(\"touchstart\", $);\n        else if (N.pointerType === \"mouse\" || N.pointerType === \"pen\") {\n          var U = N.button === 2;\n          this.emit(U ? \"rightdown\" : \"mousedown\", this.eventData);\n        }\n      }\n    }\n  }, t.prototype.processPointerDown = function(e, r, S) {\n    var T = e.data, D = e.data.identifier;\n    if (S) {\n      if (r.trackedPointers[D] || (r.trackedPointers[D] = new InteractionTrackingData(D)), this.dispatchEvent(r, \"pointerdown\", e), T.pointerType === \"touch\")\n        this.dispatchEvent(r, \"touchstart\", e);\n      else if (T.pointerType === \"mouse\" || T.pointerType === \"pen\") {\n        var N = T.button === 2;\n        N ? r.trackedPointers[D].rightDown = !0 : r.trackedPointers[D].leftDown = !0, this.dispatchEvent(r, N ? \"rightdown\" : \"mousedown\", e);\n      }\n    }\n  }, t.prototype.onPointerComplete = function(e, r, S) {\n    var T = this.normalizeToPointerData(e), D = T.length, N = e.target;\n    e.composedPath && e.composedPath().length > 0 && (N = e.composedPath()[0]);\n    for (var B = N !== this.interactionDOMElement ? \"outside\" : \"\", $ = 0; $ < D; $++) {\n      var U = T[$], V = this.getInteractionDataForPointerId(U), H = this.configureInteractionEventForDOMEvent(this.eventData, U, V);\n      if (H.data.originalEvent = e, this.processInteractive(H, this.lastObjectRendered, S, r || !B), this.emit(r ? \"pointercancel\" : \"pointerup\" + B, H), U.pointerType === \"mouse\" || U.pointerType === \"pen\") {\n        var X = U.button === 2;\n        this.emit(X ? \"rightup\" + B : \"mouseup\" + B, H);\n      } else\n        U.pointerType === \"touch\" && (this.emit(r ? \"touchcancel\" : \"touchend\" + B, H), this.releaseInteractionDataForPointerId(U.pointerId));\n    }\n  }, t.prototype.onPointerCancel = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !0, this.processPointerCancel);\n  }, t.prototype.processPointerCancel = function(e, r) {\n    var S = e.data, T = e.data.identifier;\n    r.trackedPointers[T] !== void 0 && (delete r.trackedPointers[T], this.dispatchEvent(r, \"pointercancel\", e), S.pointerType === \"touch\" && this.dispatchEvent(r, \"touchcancel\", e));\n  }, t.prototype.onPointerUp = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !1, this.processPointerUp);\n  }, t.prototype.processPointerUp = function(e, r, S) {\n    var T = e.data, D = e.data.identifier, N = r.trackedPointers[D], B = T.pointerType === \"touch\", $ = T.pointerType === \"mouse\" || T.pointerType === \"pen\", U = !1;\n    if ($) {\n      var V = T.button === 2, H = InteractionTrackingData.FLAGS, X = V ? H.RIGHT_DOWN : H.LEFT_DOWN, Y = N !== void 0 && N.flags & X;\n      S ? (this.dispatchEvent(r, V ? \"rightup\" : \"mouseup\", e), Y && (this.dispatchEvent(r, V ? \"rightclick\" : \"click\", e), U = !0)) : Y && this.dispatchEvent(r, V ? \"rightupoutside\" : \"mouseupoutside\", e), N && (V ? N.rightDown = !1 : N.leftDown = !1);\n    }\n    S ? (this.dispatchEvent(r, \"pointerup\", e), B && this.dispatchEvent(r, \"touchend\", e), N && ((!$ || U) && this.dispatchEvent(r, \"pointertap\", e), B && (this.dispatchEvent(r, \"tap\", e), N.over = !1))) : N && (this.dispatchEvent(r, \"pointerupoutside\", e), B && this.dispatchEvent(r, \"touchendoutside\", e)), N && N.none && delete r.trackedPointers[D];\n  }, t.prototype.onPointerMove = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var r = this.normalizeToPointerData(e);\n      (r[0].pointerType === \"mouse\" || r[0].pointerType === \"pen\") && (this._didMove = !0, this.cursor = null);\n      for (var S = r.length, T = 0; T < S; T++) {\n        var D = r[T], N = this.getInteractionDataForPointerId(D), B = this.configureInteractionEventForDOMEvent(this.eventData, D, N);\n        B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerMove, !0), this.emit(\"pointermove\", B), D.pointerType === \"touch\" && this.emit(\"touchmove\", B), (D.pointerType === \"mouse\" || D.pointerType === \"pen\") && this.emit(\"mousemove\", B);\n      }\n      r[0].pointerType === \"mouse\" && this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.processPointerMove = function(e, r, S) {\n    var T = e.data, D = T.pointerType === \"touch\", N = T.pointerType === \"mouse\" || T.pointerType === \"pen\";\n    N && this.processPointerOverOut(e, r, S), (!this.moveWhenInside || S) && (this.dispatchEvent(r, \"pointermove\", e), D && this.dispatchEvent(r, \"touchmove\", e), N && this.dispatchEvent(r, \"mousemove\", e));\n  }, t.prototype.onPointerOut = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var r = this.normalizeToPointerData(e), S = r[0];\n      S.pointerType === \"mouse\" && (this.mouseOverRenderer = !1, this.setCursorMode(null));\n      var T = this.getInteractionDataForPointerId(S), D = this.configureInteractionEventForDOMEvent(this.eventData, S, T);\n      D.data.originalEvent = S, this.processInteractive(D, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit(\"pointerout\", D), S.pointerType === \"mouse\" || S.pointerType === \"pen\" ? this.emit(\"mouseout\", D) : this.releaseInteractionDataForPointerId(T.identifier);\n    }\n  }, t.prototype.processPointerOverOut = function(e, r, S) {\n    var T = e.data, D = e.data.identifier, N = T.pointerType === \"mouse\" || T.pointerType === \"pen\", B = r.trackedPointers[D];\n    S && !B && (B = r.trackedPointers[D] = new InteractionTrackingData(D)), B !== void 0 && (S && this.mouseOverRenderer ? (B.over || (B.over = !0, this.delayDispatchEvent(r, \"pointerover\", e), N && this.delayDispatchEvent(r, \"mouseover\", e)), N && this.cursor === null && (this.cursor = r.cursor)) : B.over && (B.over = !1, this.dispatchEvent(r, \"pointerout\", this.eventData), N && this.dispatchEvent(r, \"mouseout\", e), B.none && delete r.trackedPointers[D]));\n  }, t.prototype.onPointerOver = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var r = this.normalizeToPointerData(e), S = r[0], T = this.getInteractionDataForPointerId(S), D = this.configureInteractionEventForDOMEvent(this.eventData, S, T);\n      D.data.originalEvent = S, S.pointerType === \"mouse\" && (this.mouseOverRenderer = !0), this.emit(\"pointerover\", D), (S.pointerType === \"mouse\" || S.pointerType === \"pen\") && this.emit(\"mouseover\", D);\n    }\n  }, t.prototype.getInteractionDataForPointerId = function(e) {\n    var r = e.pointerId, S;\n    return r === MOUSE_POINTER_ID || e.pointerType === \"mouse\" ? S = this.mouse : this.activeInteractionData[r] ? S = this.activeInteractionData[r] : (S = this.interactionDataPool.pop() || new InteractionData(), S.identifier = r, this.activeInteractionData[r] = S), S.copyEvent(e), S;\n  }, t.prototype.releaseInteractionDataForPointerId = function(e) {\n    var r = this.activeInteractionData[e];\n    r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));\n  }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, S) {\n    return e.data = S, this.mapPositionToPoint(S.global, r.clientX, r.clientY), r.pointerType === \"touch\" && (r.globalX = S.global.x, r.globalY = S.global.y), S.originalEvent = r, e.reset(), e;\n  }, t.prototype.normalizeToPointerData = function(e) {\n    var r = [];\n    if (this.supportsTouchEvents && e instanceof TouchEvent)\n      for (var S = 0, T = e.changedTouches.length; S < T; S++) {\n        var D = e.changedTouches[S];\n        typeof D.button > \"u\" && (D.button = e.touches.length ? 1 : 0), typeof D.buttons > \"u\" && (D.buttons = e.touches.length ? 1 : 0), typeof D.isPrimary > \"u\" && (D.isPrimary = e.touches.length === 1 && e.type === \"touchstart\"), typeof D.width > \"u\" && (D.width = D.radiusX || 1), typeof D.height > \"u\" && (D.height = D.radiusY || 1), typeof D.tiltX > \"u\" && (D.tiltX = 0), typeof D.tiltY > \"u\" && (D.tiltY = 0), typeof D.pointerType > \"u\" && (D.pointerType = \"touch\"), typeof D.pointerId > \"u\" && (D.pointerId = D.identifier || 0), typeof D.pressure > \"u\" && (D.pressure = D.force || 0.5), typeof D.twist > \"u\" && (D.twist = 0), typeof D.tangentialPressure > \"u\" && (D.tangentialPressure = 0), typeof D.layerX > \"u\" && (D.layerX = D.offsetX = D.clientX), typeof D.layerY > \"u\" && (D.layerY = D.offsetY = D.clientY), D.isNormalized = !0, r.push(D);\n      }\n    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {\n      var N = e;\n      typeof N.isPrimary > \"u\" && (N.isPrimary = !0), typeof N.width > \"u\" && (N.width = 1), typeof N.height > \"u\" && (N.height = 1), typeof N.tiltX > \"u\" && (N.tiltX = 0), typeof N.tiltY > \"u\" && (N.tiltY = 0), typeof N.pointerType > \"u\" && (N.pointerType = \"mouse\"), typeof N.pointerId > \"u\" && (N.pointerId = MOUSE_POINTER_ID), typeof N.pressure > \"u\" && (N.pressure = 0.5), typeof N.twist > \"u\" && (N.twist = 0), typeof N.tangentialPressure > \"u\" && (N.tangentialPressure = 0), N.isNormalized = !0, r.push(N);\n    } else\n      r.push(e);\n    return r;\n  }, t.prototype.destroy = function() {\n    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;\n  }, t.extension = {\n    name: \"interaction\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, t;\n}(i$1);\nvar TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {\n  function o(t) {\n    this.renderer = t;\n  }\n  return o.prototype.image = function(t, e, r) {\n    var S = new Image();\n    return S.src = this.base64(t, e, r), S;\n  }, o.prototype.base64 = function(t, e, r) {\n    return this.canvas(t).toDataURL(e, r);\n  }, o.prototype.canvas = function(t, e) {\n    var r = this.renderer, S, T = !1, D, N = !1;\n    t && (t instanceof RenderTexture ? D = t : (D = this.renderer.generateTexture(t), N = !0)), D ? (S = D.baseTexture.resolution, e = e ?? D.frame, T = !1, r.renderTexture.bind(D)) : (S = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), T = !0, r.renderTexture.bind(null));\n    var B = Math.round(e.width * S), $ = Math.round(e.height * S), U = new CanvasRenderTarget(B, $, 1), V = new Uint8Array(BYTES_PER_PIXEL * B * $), H = r.gl;\n    H.readPixels(Math.round(e.x * S), Math.round(e.y * S), B, $, H.RGBA, H.UNSIGNED_BYTE, V);\n    var X = U.context.getImageData(0, 0, B, $);\n    if (o.arrayPostDivide(V, X.data), U.context.putImageData(X, 0, 0), T) {\n      var Y = new CanvasRenderTarget(U.width, U.height, 1);\n      Y.context.scale(1, -1), Y.context.drawImage(U.canvas, 0, -$), U.destroy(), U = Y;\n    }\n    return N && D.destroy(!0), U.canvas;\n  }, o.prototype.pixels = function(t, e) {\n    var r = this.renderer, S, T, D = !1;\n    t && (t instanceof RenderTexture ? T = t : (T = this.renderer.generateTexture(t), D = !0)), T ? (S = T.baseTexture.resolution, e = e ?? T.frame, r.renderTexture.bind(T)) : (S = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), r.renderTexture.bind(null));\n    var N = Math.round(e.width * S), B = Math.round(e.height * S), $ = new Uint8Array(BYTES_PER_PIXEL * N * B), U = r.gl;\n    return U.readPixels(Math.round(e.x * S), Math.round(e.y * S), N, B, U.RGBA, U.UNSIGNED_BYTE, $), D && T.destroy(!0), o.arrayPostDivide($, $), $;\n  }, o.prototype.destroy = function() {\n    this.renderer = null;\n  }, o.arrayPostDivide = function(t, e) {\n    for (var r = 0; r < t.length; r += 4) {\n      var S = e[r + 3] = t[r + 3];\n      S !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / S, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / S, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / S, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);\n    }\n  }, o.extension = {\n    name: \"extract\",\n    type: ExtensionType.RendererPlugin\n  }, o;\n}();\nvar SignalBinding = function() {\n  function o(t, e, r) {\n    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;\n  }\n  return o.prototype.detach = function() {\n    return this._owner === null ? !1 : (this._owner.detach(this), !0);\n  }, o;\n}();\nfunction _addSignalBinding(o, t) {\n  return o._head ? (o._tail._next = t, t._prev = o._tail, o._tail = t) : (o._head = t, o._tail = t), t._owner = o, t;\n}\nvar Signal = function() {\n  function o() {\n    this._head = this._tail = void 0;\n  }\n  return o.prototype.handlers = function(t) {\n    t === void 0 && (t = !1);\n    var e = this._head;\n    if (t)\n      return !!e;\n    for (var r = []; e; )\n      r.push(e), e = e._next;\n    return r;\n  }, o.prototype.has = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n    return t._owner === this;\n  }, o.prototype.dispatch = function() {\n    for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n      e[r] = t[r];\n    var S = this._head;\n    if (!S)\n      return !1;\n    for (; S; )\n      S._once && this.detach(S), S._fn.apply(S._thisArg, e), S = S._next;\n    return !0;\n  }, o.prototype.add = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !1, e));\n  }, o.prototype.once = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !0, e));\n  }, o.prototype.detach = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);\n  }, o.prototype.detachAll = function() {\n    var t = this._head;\n    if (!t)\n      return this;\n    for (this._head = this._tail = null; t; )\n      t._owner = null, t = t._next;\n    return this;\n  }, o;\n}();\nfunction parseUri(o, t) {\n  t = t || {};\n  for (var e = {\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, r = e.parser[t.strictMode ? \"strict\" : \"loose\"].exec(o), S = {}, T = 14; T--; )\n    S[e.key[T]] = r[T] || \"\";\n  return S[e.q.name] = {}, S[e.key[12]].replace(e.q.parser, function(D, N, B) {\n    N && (S[e.q.name][N] = B);\n  }), S;\n}\nvar useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;\nfunction _noop$1() {\n}\nfunction setExtMap(o, t, e) {\n  t && t.indexOf(\".\") === 0 && (t = t.substring(1)), t && (o[t] = e);\n}\nfunction reqType(o) {\n  return o.toString().replace(\"object \", \"\");\n}\nvar LoaderResource = function() {\n  function o(t, e, r) {\n    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != \"string\" || typeof e != \"string\")\n      throw new Error(\"Both name and url are required for constructing a resource.\");\n    r = r || {}, this._flags = 0, this._setFlag(o.STATUS_FLAGS.DATA_URL, e.indexOf(\"data:\") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? \"anonymous\" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = o.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();\n  }\n  return o.setExtensionLoadType = function(t, e) {\n    setExtMap(o._loadTypeMap, t, e);\n  }, o.setExtensionXhrType = function(t, e) {\n    setExtMap(o._xhrTypeMap, t, e);\n  }, Object.defineProperty(o.prototype, \"isDataUrl\", {\n    get: function() {\n      return this._hasFlag(o.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"isComplete\", {\n    get: function() {\n      return this._hasFlag(o.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"isLoading\", {\n    get: function() {\n      return this._hasFlag(o.STATUS_FLAGS.LOADING);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.complete = function() {\n    this._clearEvents(), this._finish();\n  }, o.prototype.abort = function(t) {\n    if (!this.error) {\n      if (this.error = new Error(t), this._clearEvents(), this.xhr)\n        this.xhr.abort();\n      else if (this.xdr)\n        this.xdr.abort();\n      else if (this.data)\n        if (this.data.src)\n          this.data.src = o.EMPTY_GIF;\n        else\n          for (; this.data.firstChild; )\n            this.data.removeChild(this.data.firstChild);\n      this._finish();\n    }\n  }, o.prototype.load = function(t) {\n    var e = this;\n    if (!this.isLoading) {\n      if (this.isComplete) {\n        t && setTimeout(function() {\n          return t(e);\n        }, 1);\n        return;\n      } else\n        t && this.onComplete.once(t);\n      switch (this._setFlag(o.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != \"string\") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {\n        case o.LOAD_TYPE.IMAGE:\n          this.type = o.TYPE.IMAGE, this._loadElement(\"image\");\n          break;\n        case o.LOAD_TYPE.AUDIO:\n          this.type = o.TYPE.AUDIO, this._loadSourceElement(\"audio\");\n          break;\n        case o.LOAD_TYPE.VIDEO:\n          this.type = o.TYPE.VIDEO, this._loadSourceElement(\"video\");\n          break;\n        case o.LOAD_TYPE.XHR:\n        default:\n          typeof useXdr > \"u\" && (useXdr = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();\n          break;\n      }\n    }\n  }, o.prototype._hasFlag = function(t) {\n    return (this._flags & t) !== 0;\n  }, o.prototype._setFlag = function(t, e) {\n    this._flags = e ? this._flags | t : this._flags & ~t;\n  }, o.prototype._clearEvents = function() {\n    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener(\"error\", this._boundOnError, !1), this.data.removeEventListener(\"load\", this._boundComplete, !1), this.data.removeEventListener(\"progress\", this._boundOnProgress, !1), this.data.removeEventListener(\"canplaythrough\", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener(\"error\", this._boundXhrOnError, !1), this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, !1), this.xhr.removeEventListener(\"progress\", this._boundOnProgress, !1), this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));\n  }, o.prototype._finish = function() {\n    if (this.isComplete)\n      throw new Error(\"Complete called again for an already completed resource.\");\n    this._setFlag(o.STATUS_FLAGS.COMPLETE, !0), this._setFlag(o.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);\n  }, o.prototype._loadElement = function(t) {\n    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"image\" && typeof globalThis.Image < \"u\" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, o.prototype._loadSourceElement = function(t) {\n    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"audio\" && typeof globalThis.Audio < \"u\" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {\n      this.abort(\"Unsupported element: \" + t);\n      return;\n    }\n    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)\n      if (navigator.isCocoonJS)\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      else if (Array.isArray(this.url))\n        for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)\n          this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));\n      else {\n        var e = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));\n      }\n    this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.data.addEventListener(\"canplaythrough\", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, o.prototype._loadXhr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new XMLHttpRequest();\n    this.crossOrigin === \"use-credentials\" && (t.withCredentials = !0), t.open(\"GET\", this.url, !0), t.timeout = this.timeout, this.xhrType === o.XHR_RESPONSE_TYPE.JSON || this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = o.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener(\"error\", this._boundXhrOnError, !1), t.addEventListener(\"timeout\", this._boundXhrOnTimeout, !1), t.addEventListener(\"abort\", this._boundXhrOnAbort, !1), t.addEventListener(\"progress\", this._boundOnProgress, !1), t.addEventListener(\"load\", this._boundXhrOnLoad, !1), t.send();\n  }, o.prototype._loadXdr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new globalThis.XDomainRequest();\n    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open(\"GET\", this.url, !0), setTimeout(function() {\n      return t.send();\n    }, 1);\n  }, o.prototype._createSource = function(t, e, r) {\n    r || (r = t + \"/\" + this._getExtension(e));\n    var S = document.createElement(\"source\");\n    return S.src = e, S.type = r, S;\n  }, o.prototype._onError = function(t) {\n    this.abort(\"Failed to load element using: \" + t.target.nodeName);\n  }, o.prototype._onProgress = function(t) {\n    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);\n  }, o.prototype._onTimeout = function() {\n    this.abort(\"Load timed out.\");\n  }, o.prototype._xhrOnError = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request failed. Status: \" + t.status + ', text: \"' + t.statusText + '\"');\n  }, o.prototype._xhrOnTimeout = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request timed out.\");\n  }, o.prototype._xhrOnAbort = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request was aborted by the user.\");\n  }, o.prototype._xhrOnLoad = function() {\n    var t = this.xhr, e = \"\", r = typeof t.status > \"u\" ? STATUS_OK : t.status;\n    (t.responseType === \"\" || t.responseType === \"text\" || typeof t.responseType > \"u\") && (e = t.responseText), r === STATUS_NONE && (e.length > 0 || t.responseType === o.XHR_RESPONSE_TYPE.BUFFER) ? r = STATUS_OK : r === STATUS_IE_BUG_EMPTY && (r = STATUS_EMPTY);\n    var S = r / 100 | 0;\n    if (S === STATUS_TYPE_OK)\n      if (this.xhrType === o.XHR_RESPONSE_TYPE.TEXT)\n        this.data = e, this.type = o.TYPE.TEXT;\n      else if (this.xhrType === o.XHR_RESPONSE_TYPE.JSON)\n        try {\n          this.data = JSON.parse(e), this.type = o.TYPE.JSON;\n        } catch (N) {\n          this.abort(\"Error trying to parse loaded json: \" + N);\n          return;\n        }\n      else if (this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT)\n        try {\n          if (globalThis.DOMParser) {\n            var T = new DOMParser();\n            this.data = T.parseFromString(e, \"text/xml\");\n          } else {\n            var D = document.createElement(\"div\");\n            D.innerHTML = e, this.data = D;\n          }\n          this.type = o.TYPE.XML;\n        } catch (N) {\n          this.abort(\"Error trying to parse loaded xml: \" + N);\n          return;\n        }\n      else\n        this.data = t.response || e;\n    else {\n      this.abort(\"[\" + t.status + \"] \" + t.statusText + \": \" + t.responseURL);\n      return;\n    }\n    this.complete();\n  }, o.prototype._determineCrossOrigin = function(t, e) {\n    if (t.indexOf(\"data:\") === 0)\n      return \"\";\n    if (globalThis.origin !== globalThis.location.origin)\n      return \"anonymous\";\n    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement(\"a\")), tempAnchor.href = t;\n    var r = parseUri(tempAnchor.href, { strictMode: !0 }), S = !r.port && e.port === \"\" || r.port === e.port, T = r.protocol ? r.protocol + \":\" : \"\";\n    return r.host !== e.hostname || !S || T !== e.protocol ? \"anonymous\" : \"\";\n  }, o.prototype._determineXhrType = function() {\n    return o._xhrTypeMap[this.extension] || o.XHR_RESPONSE_TYPE.TEXT;\n  }, o.prototype._determineLoadType = function() {\n    return o._loadTypeMap[this.extension] || o.LOAD_TYPE.XHR;\n  }, o.prototype._getExtension = function(t) {\n    t === void 0 && (t = this.url);\n    var e = \"\";\n    if (this.isDataUrl) {\n      var r = t.indexOf(\"/\");\n      e = t.substring(r + 1, t.indexOf(\";\", r));\n    } else {\n      var S = t.indexOf(\"?\"), T = t.indexOf(\"#\"), D = Math.min(S > -1 ? S : t.length, T > -1 ? T : t.length);\n      t = t.substring(0, D), e = t.substring(t.lastIndexOf(\".\") + 1);\n    }\n    return e.toLowerCase();\n  }, o.prototype._getMimeFromXhrType = function(t) {\n    switch (t) {\n      case o.XHR_RESPONSE_TYPE.BUFFER:\n        return \"application/octet-binary\";\n      case o.XHR_RESPONSE_TYPE.BLOB:\n        return \"application/blob\";\n      case o.XHR_RESPONSE_TYPE.DOCUMENT:\n        return \"application/xml\";\n      case o.XHR_RESPONSE_TYPE.JSON:\n        return \"application/json\";\n      case o.XHR_RESPONSE_TYPE.DEFAULT:\n      case o.XHR_RESPONSE_TYPE.TEXT:\n      default:\n        return \"text/plain\";\n    }\n  }, o;\n}();\n(function(o) {\n  (function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.DATA_URL = 1] = \"DATA_URL\", t[t.COMPLETE = 2] = \"COMPLETE\", t[t.LOADING = 4] = \"LOADING\";\n  })(o.STATUS_FLAGS || (o.STATUS_FLAGS = {})), function(t) {\n    t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.JSON = 1] = \"JSON\", t[t.XML = 2] = \"XML\", t[t.IMAGE = 3] = \"IMAGE\", t[t.AUDIO = 4] = \"AUDIO\", t[t.VIDEO = 5] = \"VIDEO\", t[t.TEXT = 6] = \"TEXT\";\n  }(o.TYPE || (o.TYPE = {})), function(t) {\n    t[t.XHR = 1] = \"XHR\", t[t.IMAGE = 2] = \"IMAGE\", t[t.AUDIO = 3] = \"AUDIO\", t[t.VIDEO = 4] = \"VIDEO\";\n  }(o.LOAD_TYPE || (o.LOAD_TYPE = {})), function(t) {\n    t.DEFAULT = \"text\", t.BUFFER = \"arraybuffer\", t.BLOB = \"blob\", t.DOCUMENT = \"document\", t.JSON = \"json\", t.TEXT = \"text\";\n  }(o.XHR_RESPONSE_TYPE || (o.XHR_RESPONSE_TYPE = {})), o._loadTypeMap = {\n    gif: o.LOAD_TYPE.IMAGE,\n    png: o.LOAD_TYPE.IMAGE,\n    bmp: o.LOAD_TYPE.IMAGE,\n    jpg: o.LOAD_TYPE.IMAGE,\n    jpeg: o.LOAD_TYPE.IMAGE,\n    tif: o.LOAD_TYPE.IMAGE,\n    tiff: o.LOAD_TYPE.IMAGE,\n    webp: o.LOAD_TYPE.IMAGE,\n    tga: o.LOAD_TYPE.IMAGE,\n    avif: o.LOAD_TYPE.IMAGE,\n    svg: o.LOAD_TYPE.IMAGE,\n    \"svg+xml\": o.LOAD_TYPE.IMAGE,\n    mp3: o.LOAD_TYPE.AUDIO,\n    ogg: o.LOAD_TYPE.AUDIO,\n    wav: o.LOAD_TYPE.AUDIO,\n    mp4: o.LOAD_TYPE.VIDEO,\n    webm: o.LOAD_TYPE.VIDEO\n  }, o._xhrTypeMap = {\n    xhtml: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    gif: o.XHR_RESPONSE_TYPE.BLOB,\n    png: o.XHR_RESPONSE_TYPE.BLOB,\n    bmp: o.XHR_RESPONSE_TYPE.BLOB,\n    jpg: o.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: o.XHR_RESPONSE_TYPE.BLOB,\n    tif: o.XHR_RESPONSE_TYPE.BLOB,\n    tiff: o.XHR_RESPONSE_TYPE.BLOB,\n    webp: o.XHR_RESPONSE_TYPE.BLOB,\n    tga: o.XHR_RESPONSE_TYPE.BLOB,\n    avif: o.XHR_RESPONSE_TYPE.BLOB,\n    json: o.XHR_RESPONSE_TYPE.JSON,\n    text: o.XHR_RESPONSE_TYPE.TEXT,\n    txt: o.XHR_RESPONSE_TYPE.TEXT,\n    ttf: o.XHR_RESPONSE_TYPE.BUFFER,\n    otf: o.XHR_RESPONSE_TYPE.BUFFER\n  }, o.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(LoaderResource || (LoaderResource = {}));\nfunction _noop() {\n}\nfunction onlyOnce(o) {\n  return function() {\n    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)\n      r[S] = e[S];\n    if (o === null)\n      throw new Error(\"Callback was already called.\");\n    var T = o;\n    o = null, T.apply(this, r);\n  };\n}\nvar AsyncQueueItem = function() {\n  function o(t, e) {\n    this.data = t, this.callback = e;\n  }\n  return o;\n}(), AsyncQueue = function() {\n  function o(t, e) {\n    var r = this;\n    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(S, T, D) {\n      if (D && typeof D != \"function\")\n        throw new Error(\"task callback must be a function\");\n      if (r.started = !0, S == null && r.idle()) {\n        setTimeout(function() {\n          return r.drain();\n        }, 1);\n        return;\n      }\n      var N = new AsyncQueueItem(S, typeof D == \"function\" ? D : _noop);\n      T ? r._tasks.unshift(N) : r._tasks.push(N), setTimeout(r.process, 1);\n    }, this.process = function() {\n      for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {\n        var S = r._tasks.shift();\n        r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(S.data, onlyOnce(r._next(S)));\n      }\n    }, this._worker = t, e === 0)\n      throw new Error(\"Concurrency must not be zero\");\n    this.concurrency = e, this.buffer = e / 4;\n  }\n  return o.prototype._next = function(t) {\n    var e = this;\n    return function() {\n      for (var r = arguments, S = [], T = 0; T < arguments.length; T++)\n        S[T] = r[T];\n      e.workers -= 1, t.callback.apply(t, S), S[0] != null && e.error(S[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();\n    };\n  }, o.prototype.push = function(t, e) {\n    this._insert(t, !1, e);\n  }, o.prototype.kill = function() {\n    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];\n  }, o.prototype.unshift = function(t, e) {\n    this._insert(t, !0, e);\n  }, o.prototype.length = function() {\n    return this._tasks.length;\n  }, o.prototype.running = function() {\n    return this.workers;\n  }, o.prototype.idle = function() {\n    return this._tasks.length + this.workers === 0;\n  }, o.prototype.pause = function() {\n    this.paused !== !0 && (this.paused = !0);\n  }, o.prototype.resume = function() {\n    if (this.paused !== !1) {\n      this.paused = !1;\n      for (var t = 1; t <= this.concurrency; t++)\n        this.process();\n    }\n  }, o.eachSeries = function(t, e, r, S) {\n    var T = 0, D = t.length;\n    function N(B) {\n      if (B || T === D) {\n        r && r(B);\n        return;\n      }\n      S ? setTimeout(function() {\n        e(t[T++], N);\n      }, 1) : e(t[T++], N);\n    }\n    N();\n  }, o.queue = function(t, e) {\n    return new o(t, e);\n  }, o;\n}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\\w-]+)?$/, Loader = function() {\n  function o(t, e) {\n    var r = this;\n    t === void 0 && (t = \"\"), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = \"\", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {\n      return r._loadResource(B, $);\n    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {\n      return r._loadResource(B, $);\n    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();\n    for (var S = 0; S < o._plugins.length; ++S) {\n      var T = o._plugins[S], D = T.pre, N = T.use;\n      D && this.pre(D), N && this.use(N);\n    }\n    this._protected = !1;\n  }\n  return o.prototype._add = function(t, e, r, S) {\n    if (this.loading && (!r || !r.parentResource))\n      throw new Error(\"Cannot add resources while the loader is running.\");\n    if (this.resources[t])\n      throw new Error('Resource named \"' + t + '\" already exists.');\n    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, r), typeof S == \"function\" && this.resources[t].onAfterMiddleware.once(S), this.loading) {\n      for (var T = r.parentResource, D = [], N = 0; N < T.children.length; ++N)\n        T.children[N].isComplete || D.push(T.children[N]);\n      var B = T.progressChunk * (D.length + 1), $ = B / (D.length + 2);\n      T.children.push(this.resources[t]), T.progressChunk = $;\n      for (var N = 0; N < D.length; ++N)\n        D[N].progressChunk = $;\n      this.resources[t].progressChunk = $;\n    }\n    return this._queue.push(this.resources[t]), this;\n  }, o.prototype.pre = function(t) {\n    return this._beforeMiddleware.push(t), this;\n  }, o.prototype.use = function(t) {\n    return this._afterMiddleware.push(t), this;\n  }, o.prototype.reset = function() {\n    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();\n    for (var t in this.resources) {\n      var e = this.resources[t];\n      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort(\"loader reset\");\n    }\n    return this.resources = {}, this;\n  }, o.prototype.load = function(t) {\n    if (deprecation(\"6.5.0\", \"@pixi/loaders is being replaced with @pixi/assets in the next major release.\"), typeof t == \"function\" && this.onComplete.once(t), this.loading)\n      return this;\n    if (this._queue.idle())\n      this._onStart(), this._onComplete();\n    else {\n      for (var e = this._queue._tasks.length, r = MAX_PROGRESS / e, S = 0; S < this._queue._tasks.length; ++S)\n        this._queue._tasks[S].data.progressChunk = r;\n      this._onStart(), this._queue.resume();\n    }\n    return this;\n  }, Object.defineProperty(o.prototype, \"concurrency\", {\n    get: function() {\n      return this._queue.concurrency;\n    },\n    set: function(t) {\n      this._queue.concurrency = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype._prepareUrl = function(t) {\n    var e = parseUri(t, { strictMode: !0 }), r;\n    if (e.protocol || !e.path || t.indexOf(\"//\") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && t.charAt(0) !== \"/\" ? r = this.baseUrl + \"/\" + t : r = this.baseUrl + t, this.defaultQueryString) {\n      var S = rgxExtractUrlHash.exec(r)[0];\n      r = r.slice(0, r.length - S.length), r.indexOf(\"?\") !== -1 ? r += \"&\" + this.defaultQueryString : r += \"?\" + this.defaultQueryString, r += S;\n    }\n    return r;\n  }, o.prototype._loadResource = function(t, e) {\n    var r = this;\n    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(S, T) {\n      S.call(r, t, function() {\n        T(t.isComplete ? {} : null);\n      });\n    }, function() {\n      t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());\n    }, !0);\n  }, o.prototype._onStart = function() {\n    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);\n  }, o.prototype._onComplete = function() {\n    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);\n  }, o.prototype._onLoad = function(t) {\n    var e = this;\n    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(r, S) {\n      r.call(e, t, S);\n    }, function() {\n      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();\n    }, !0);\n  }, o.prototype.destroy = function() {\n    this._protected || this.reset();\n  }, Object.defineProperty(o, \"shared\", {\n    get: function() {\n      var t = o._shared;\n      return t || (t = new o(), t._protected = !0, o._shared = t), t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.registerPlugin = function(t) {\n    return deprecation(\"6.5.0\", \"Loader.registerPlugin() is deprecated, use extensions.add() instead.\"), extensions.add({\n      type: ExtensionType.Loader,\n      ref: t\n    }), o;\n  }, o._plugins = [], o;\n}();\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\nLoader.prototype.add = function(t, e, r, S) {\n  if (Array.isArray(t)) {\n    for (var T = 0; T < t.length; ++T)\n      this.add(t[T]);\n    return this;\n  }\n  if (typeof t == \"object\" && (r = t, S = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != \"string\" && (S = r, r = e, e = t), typeof e != \"string\")\n    throw new Error(\"No url passed to add resource to loader.\");\n  return typeof r == \"function\" && (S = r, r = null), this._add(t, e, r, S);\n};\nvar AppLoaderPlugin = function() {\n  function o() {\n  }\n  return o.init = function(t) {\n    t = Object.assign({\n      sharedLoader: !1\n    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();\n  }, o.destroy = function() {\n    this.loader && (this.loader.destroy(), this.loader = null);\n  }, o.extension = ExtensionType.Application, o;\n}(), TextureLoader = function() {\n  function o() {\n  }\n  return o.add = function() {\n    LoaderResource.setExtensionLoadType(\"svg\", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType(\"svg\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, o.use = function(t, e) {\n    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === \"svg\")) {\n      var r = t.data, S = t.url, T = t.name, D = t.metadata;\n      Texture.fromLoader(r, S, T, D).then(function(N) {\n        t.texture = N, e();\n      }).catch(e);\n    } else\n      e();\n  }, o.extension = ExtensionType.Loader, o;\n}(), _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction encodeBinary(o) {\n  for (var t = \"\", e = 0; e < o.length; ) {\n    for (var r = [0, 0, 0], S = [0, 0, 0, 0], T = 0; T < r.length; ++T)\n      e < o.length ? r[T] = o.charCodeAt(e++) & 255 : r[T] = 0;\n    S[0] = r[0] >> 2, S[1] = (r[0] & 3) << 4 | r[1] >> 4, S[2] = (r[1] & 15) << 2 | r[2] >> 6, S[3] = r[2] & 63;\n    var D = e - (o.length - 1);\n    switch (D) {\n      case 2:\n        S[3] = 64, S[2] = 64;\n        break;\n      case 1:\n        S[3] = 64;\n        break;\n    }\n    for (var T = 0; T < S.length; ++T)\n      t += _keyStr.charAt(S[T]);\n  }\n  return t;\n}\nfunction parsing(o, t) {\n  if (!o.data) {\n    t();\n    return;\n  }\n  if (o.xhr && o.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof o.data == \"string\") {\n      var e = o.xhr.getResponseHeader(\"content-type\");\n      if (e && e.indexOf(\"image\") === 0) {\n        o.data = new Image(), o.data.src = \"data:\" + e + \";base64,\" + encodeBinary(o.xhr.responseText), o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {\n          o.data.onload = null, t();\n        };\n        return;\n      }\n    } else if (o.data.type.indexOf(\"image\") === 0) {\n      var r = globalThis.URL || globalThis.webkitURL, S = r.createObjectURL(o.data);\n      o.blob = o.data, o.data = new Image(), o.data.src = S, o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {\n        r.revokeObjectURL(S), o.data.onload = null, t();\n      };\n      return;\n    }\n  }\n  t();\n}\nvar ParsingLoader = function() {\n  function o() {\n  }\n  return o.extension = ExtensionType.Loader, o.use = parsing, o;\n}();\nextensions.add(TextureLoader, ParsingLoader);\nvar _a$2, INTERNAL_FORMATS;\n(function(o) {\n  o[o.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\", o[o.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\", o[o.COMPRESSED_R11_EAC = 37488] = \"COMPRESSED_R11_EAC\", o[o.COMPRESSED_SIGNED_R11_EAC = 37489] = \"COMPRESSED_SIGNED_R11_EAC\", o[o.COMPRESSED_RG11_EAC = 37490] = \"COMPRESSED_RG11_EAC\", o[o.COMPRESSED_SIGNED_RG11_EAC = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\", o[o.COMPRESSED_RGB8_ETC2 = 37492] = \"COMPRESSED_RGB8_ETC2\", o[o.COMPRESSED_RGBA8_ETC2_EAC = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\", o[o.COMPRESSED_SRGB8_ETC2 = 37493] = \"COMPRESSED_SRGB8_ETC2\", o[o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\", o[o.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\", o[o.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\", o[o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\", o[o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\", o[o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\", o[o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\", o[o.COMPRESSED_RGB_ETC1_WEBGL = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\", o[o.COMPRESSED_RGB_ATC_WEBGL = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\", o[o.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\", o[o.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\", o[o.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = \"COMPRESSED_RGBA_ASTC_4x4_KHR\";\n})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));\nvar INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);\nvar extendStatics$n = function(o, t) {\n  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$n(o, t);\n};\nfunction __extends$n(o, t) {\n  extendStatics$n(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction __awaiter(o, t, e, r) {\n  function S(T) {\n    return T instanceof e ? T : new e(function(D) {\n      D(T);\n    });\n  }\n  return new (e || (e = Promise))(function(T, D) {\n    function N(U) {\n      try {\n        $(r.next(U));\n      } catch (V) {\n        D(V);\n      }\n    }\n    function B(U) {\n      try {\n        $(r.throw(U));\n      } catch (V) {\n        D(V);\n      }\n    }\n    function $(U) {\n      U.done ? T(U.value) : S(U.value).then(N, B);\n    }\n    $((r = r.apply(o, t || [])).next());\n  });\n}\nfunction __generator(o, t) {\n  var e = { label: 0, sent: function() {\n    if (T[0] & 1)\n      throw T[1];\n    return T[1];\n  }, trys: [], ops: [] }, r, S, T, D;\n  return D = { next: N(0), throw: N(1), return: N(2) }, typeof Symbol == \"function\" && (D[Symbol.iterator] = function() {\n    return this;\n  }), D;\n  function N($) {\n    return function(U) {\n      return B([$, U]);\n    };\n  }\n  function B($) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; e; )\n      try {\n        if (r = 1, S && (T = $[0] & 2 ? S.return : $[0] ? S.throw || ((T = S.return) && T.call(S), 0) : S.next) && !(T = T.call(S, $[1])).done)\n          return T;\n        switch (S = 0, T && ($ = [$[0] & 2, T.value]), $[0]) {\n          case 0:\n          case 1:\n            T = $;\n            break;\n          case 4:\n            return e.label++, { value: $[1], done: !1 };\n          case 5:\n            e.label++, S = $[1], $ = [0];\n            continue;\n          case 7:\n            $ = e.ops.pop(), e.trys.pop();\n            continue;\n          default:\n            if (T = e.trys, !(T = T.length > 0 && T[T.length - 1]) && ($[0] === 6 || $[0] === 2)) {\n              e = 0;\n              continue;\n            }\n            if ($[0] === 3 && (!T || $[1] > T[0] && $[1] < T[3])) {\n              e.label = $[1];\n              break;\n            }\n            if ($[0] === 6 && e.label < T[1]) {\n              e.label = T[1], T = $;\n              break;\n            }\n            if (T && e.label < T[2]) {\n              e.label = T[2], e.ops.push($);\n              break;\n            }\n            T[2] && e.ops.pop(), e.trys.pop();\n            continue;\n        }\n        $ = t.call(o, e);\n      } catch (U) {\n        $ = [6, U], S = 0;\n      } finally {\n        r = T = 0;\n      }\n    if ($[0] & 5)\n      throw $[1];\n    return { value: $[0] ? $[1] : void 0, done: !0 };\n  }\n}\nvar BlobResource = function(o) {\n  __extends$n(t, o);\n  function t(e, r) {\n    r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });\n    var S = this, T, D;\n    return typeof e == \"string\" ? (T = e, D = new Uint8Array()) : (T = null, D = e), S = o.call(this, D, r) || this, S.origin = T, S.buffer = D ? new ViewableBuffer(D) : null, S.origin && r.autoLoad !== !1 && S.load(), D && D.length && (S.loaded = !0, S.onBlobLoaded(S.buffer.rawBinaryData)), S;\n  }\n  return t.prototype.onBlobLoaded = function(e) {\n  }, t.prototype.load = function() {\n    return __awaiter(this, void 0, Promise, function() {\n      var e, r, S;\n      return __generator(this, function(T) {\n        switch (T.label) {\n          case 0:\n            return [4, fetch(this.origin)];\n          case 1:\n            return e = T.sent(), [4, e.blob()];\n          case 2:\n            return r = T.sent(), [4, r.arrayBuffer()];\n          case 3:\n            return S = T.sent(), this.data = new Uint32Array(S), this.buffer = new ViewableBuffer(S), this.loaded = !0, this.onBlobLoaded(S), this.update(), [2, this];\n        }\n      });\n    });\n  }, t;\n}(BufferResource), CompressedTextureResource = function(o) {\n  __extends$n(t, o);\n  function t(e, r) {\n    var S = o.call(this, e, r) || this;\n    return S.format = r.format, S.levels = r.levels || 1, S._width = r.width, S._height = r.height, S._extension = t._formatToExtension(S.format), (r.levelBuffers || S.buffer) && (S._levelBuffers = r.levelBuffers || t._createLevelBuffers(\n      e instanceof Uint8Array ? e : S.buffer.uint8View,\n      S.format,\n      S.levels,\n      4,\n      4,\n      S.width,\n      S.height\n    )), S;\n  }\n  return t.prototype.upload = function(e, r, S) {\n    var T = e.gl, D = e.context.extensions[this._extension];\n    if (!D)\n      throw new Error(this._extension + \" textures are not supported on the current machine\");\n    if (!this._levelBuffers)\n      return !1;\n    for (var N = 0, B = this.levels; N < B; N++) {\n      var $ = this._levelBuffers[N], U = $.levelID, V = $.levelWidth, H = $.levelHeight, X = $.levelBuffer;\n      T.compressedTexImage2D(T.TEXTURE_2D, U, this.format, V, H, 0, X);\n    }\n    return !0;\n  }, t.prototype.onBlobLoaded = function() {\n    this._levelBuffers = t._createLevelBuffers(\n      this.buffer.uint8View,\n      this.format,\n      this.levels,\n      4,\n      4,\n      this.width,\n      this.height\n    );\n  }, t._formatToExtension = function(e) {\n    if (e >= 33776 && e <= 33779)\n      return \"s3tc\";\n    if (e >= 37488 && e <= 37497)\n      return \"etc\";\n    if (e >= 35840 && e <= 35843)\n      return \"pvrtc\";\n    if (e >= 36196)\n      return \"etc1\";\n    if (e >= 35986 && e <= 34798)\n      return \"atc\";\n    throw new Error(\"Invalid (compressed) texture format given!\");\n  }, t._createLevelBuffers = function(e, r, S, T, D, N, B) {\n    for (var $ = new Array(S), U = e.byteOffset, V = N, H = B, X = V + T - 1 & ~(T - 1), Y = H + D - 1 & ~(D - 1), W = X * Y * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r], q = 0; q < S; q++)\n      $[q] = {\n        levelID: q,\n        levelWidth: S > 1 ? V : X,\n        levelHeight: S > 1 ? H : Y,\n        levelBuffer: new Uint8Array(e.buffer, U, W)\n      }, U += W, V = V >> 1 || 1, H = H >> 1 || 1, X = V + T - 1 & ~(T - 1), Y = H + D - 1 & ~(D - 1), W = X * Y * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r];\n    return $;\n  }, t;\n}(BlobResource), CompressedTextureLoader = function() {\n  function o() {\n  }\n  return o.use = function(t, e) {\n    var r = t.data, S = this;\n    if (t.type === LoaderResource.TYPE.JSON && r && r.cacheID && r.textures) {\n      for (var T = r.textures, D = void 0, N = void 0, B = 0, $ = T.length; B < $; B++) {\n        var U = T[B], V = U.src, H = U.format;\n        if (H || (N = V), o.textureFormats[H]) {\n          D = V;\n          break;\n        }\n      }\n      if (D = D || N, !D) {\n        e(new Error(\"Cannot load compressed-textures in \" + t.url + \", make sure you provide a fallback\"));\n        return;\n      }\n      if (D === t.url) {\n        e(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n        return;\n      }\n      var X = {\n        crossOrigin: t.crossOrigin,\n        metadata: t.metadata.imageMetadata,\n        parentResource: t\n      }, Y = url$1.resolve(t.url.replace(S.baseUrl, \"\"), D), W = r.cacheID;\n      S.add(W, Y, X, function(q) {\n        if (q.error) {\n          e(q.error);\n          return;\n        }\n        var K = q.texture, Z = K === void 0 ? null : K, J = q.textures, Q = J === void 0 ? {} : J;\n        Object.assign(t, { texture: Z, textures: Q }), e();\n      });\n    } else\n      e();\n  }, Object.defineProperty(o, \"textureExtensions\", {\n    get: function() {\n      if (!o._textureExtensions) {\n        var t = settings.ADAPTER.createCanvas(), e = t.getContext(\"webgl\");\n        if (!e)\n          return console.warn(\"WebGL not available for compressed textures. Silently failing.\"), {};\n        var r = {\n          s3tc: e.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n          s3tc_sRGB: e.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n          etc: e.getExtension(\"WEBGL_compressed_texture_etc\"),\n          etc1: e.getExtension(\"WEBGL_compressed_texture_etc1\"),\n          pvrtc: e.getExtension(\"WEBGL_compressed_texture_pvrtc\") || e.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n          atc: e.getExtension(\"WEBGL_compressed_texture_atc\"),\n          astc: e.getExtension(\"WEBGL_compressed_texture_astc\")\n        };\n        o._textureExtensions = r;\n      }\n      return o._textureExtensions;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"textureFormats\", {\n    get: function() {\n      if (!o._textureFormats) {\n        var t = o.textureExtensions;\n        o._textureFormats = {};\n        for (var e in t) {\n          var r = t[e];\n          !r || Object.assign(o._textureFormats, Object.getPrototypeOf(r));\n        }\n      }\n      return o._textureFormats;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.extension = ExtensionType.Loader, o;\n}();\nfunction registerCompressedTextures(o, t, e) {\n  var r = {\n    textures: {},\n    texture: null\n  };\n  if (!t)\n    return r;\n  var S = t.map(function(T) {\n    return new Texture(new BaseTexture(T, Object.assign({\n      mipmap: MIPMAP_MODES.OFF,\n      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA\n    }, e)));\n  });\n  return S.forEach(function(T, D) {\n    var N = T.baseTexture, B = o + \"-\" + (D + 1);\n    BaseTexture.addToCache(N, B), Texture.addToCache(T, B), D === 0 && (BaseTexture.addToCache(N, o), Texture.addToCache(T, o), r.texture = T), r.textures[B] = T;\n  }), r;\n}\nvar _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, DXGI_FORMAT;\n(function(o) {\n  o[o.DXGI_FORMAT_UNKNOWN = 0] = \"DXGI_FORMAT_UNKNOWN\", o[o.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\", o[o.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\", o[o.DXGI_FORMAT_R32G32B32A32_UINT = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\", o[o.DXGI_FORMAT_R32G32B32A32_SINT = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\", o[o.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\", o[o.DXGI_FORMAT_R32G32B32_FLOAT = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\", o[o.DXGI_FORMAT_R32G32B32_UINT = 7] = \"DXGI_FORMAT_R32G32B32_UINT\", o[o.DXGI_FORMAT_R32G32B32_SINT = 8] = \"DXGI_FORMAT_R32G32B32_SINT\", o[o.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\", o[o.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\", o[o.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\", o[o.DXGI_FORMAT_R16G16B16A16_UINT = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\", o[o.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\", o[o.DXGI_FORMAT_R16G16B16A16_SINT = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\", o[o.DXGI_FORMAT_R32G32_TYPELESS = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\", o[o.DXGI_FORMAT_R32G32_FLOAT = 16] = \"DXGI_FORMAT_R32G32_FLOAT\", o[o.DXGI_FORMAT_R32G32_UINT = 17] = \"DXGI_FORMAT_R32G32_UINT\", o[o.DXGI_FORMAT_R32G32_SINT = 18] = \"DXGI_FORMAT_R32G32_SINT\", o[o.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\", o[o.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\", o[o.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\", o[o.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\", o[o.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\", o[o.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\", o[o.DXGI_FORMAT_R10G10B10A2_UINT = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\", o[o.DXGI_FORMAT_R11G11B10_FLOAT = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\", o[o.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\", o[o.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\", o[o.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\", o[o.DXGI_FORMAT_R8G8B8A8_UINT = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\", o[o.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\", o[o.DXGI_FORMAT_R8G8B8A8_SINT = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\", o[o.DXGI_FORMAT_R16G16_TYPELESS = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\", o[o.DXGI_FORMAT_R16G16_FLOAT = 34] = \"DXGI_FORMAT_R16G16_FLOAT\", o[o.DXGI_FORMAT_R16G16_UNORM = 35] = \"DXGI_FORMAT_R16G16_UNORM\", o[o.DXGI_FORMAT_R16G16_UINT = 36] = \"DXGI_FORMAT_R16G16_UINT\", o[o.DXGI_FORMAT_R16G16_SNORM = 37] = \"DXGI_FORMAT_R16G16_SNORM\", o[o.DXGI_FORMAT_R16G16_SINT = 38] = \"DXGI_FORMAT_R16G16_SINT\", o[o.DXGI_FORMAT_R32_TYPELESS = 39] = \"DXGI_FORMAT_R32_TYPELESS\", o[o.DXGI_FORMAT_D32_FLOAT = 40] = \"DXGI_FORMAT_D32_FLOAT\", o[o.DXGI_FORMAT_R32_FLOAT = 41] = \"DXGI_FORMAT_R32_FLOAT\", o[o.DXGI_FORMAT_R32_UINT = 42] = \"DXGI_FORMAT_R32_UINT\", o[o.DXGI_FORMAT_R32_SINT = 43] = \"DXGI_FORMAT_R32_SINT\", o[o.DXGI_FORMAT_R24G8_TYPELESS = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\", o[o.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\", o[o.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\", o[o.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\", o[o.DXGI_FORMAT_R8G8_TYPELESS = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\", o[o.DXGI_FORMAT_R8G8_UNORM = 49] = \"DXGI_FORMAT_R8G8_UNORM\", o[o.DXGI_FORMAT_R8G8_UINT = 50] = \"DXGI_FORMAT_R8G8_UINT\", o[o.DXGI_FORMAT_R8G8_SNORM = 51] = \"DXGI_FORMAT_R8G8_SNORM\", o[o.DXGI_FORMAT_R8G8_SINT = 52] = \"DXGI_FORMAT_R8G8_SINT\", o[o.DXGI_FORMAT_R16_TYPELESS = 53] = \"DXGI_FORMAT_R16_TYPELESS\", o[o.DXGI_FORMAT_R16_FLOAT = 54] = \"DXGI_FORMAT_R16_FLOAT\", o[o.DXGI_FORMAT_D16_UNORM = 55] = \"DXGI_FORMAT_D16_UNORM\", o[o.DXGI_FORMAT_R16_UNORM = 56] = \"DXGI_FORMAT_R16_UNORM\", o[o.DXGI_FORMAT_R16_UINT = 57] = \"DXGI_FORMAT_R16_UINT\", o[o.DXGI_FORMAT_R16_SNORM = 58] = \"DXGI_FORMAT_R16_SNORM\", o[o.DXGI_FORMAT_R16_SINT = 59] = \"DXGI_FORMAT_R16_SINT\", o[o.DXGI_FORMAT_R8_TYPELESS = 60] = \"DXGI_FORMAT_R8_TYPELESS\", o[o.DXGI_FORMAT_R8_UNORM = 61] = \"DXGI_FORMAT_R8_UNORM\", o[o.DXGI_FORMAT_R8_UINT = 62] = \"DXGI_FORMAT_R8_UINT\", o[o.DXGI_FORMAT_R8_SNORM = 63] = \"DXGI_FORMAT_R8_SNORM\", o[o.DXGI_FORMAT_R8_SINT = 64] = \"DXGI_FORMAT_R8_SINT\", o[o.DXGI_FORMAT_A8_UNORM = 65] = \"DXGI_FORMAT_A8_UNORM\", o[o.DXGI_FORMAT_R1_UNORM = 66] = \"DXGI_FORMAT_R1_UNORM\", o[o.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\", o[o.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\", o[o.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\", o[o.DXGI_FORMAT_BC1_TYPELESS = 70] = \"DXGI_FORMAT_BC1_TYPELESS\", o[o.DXGI_FORMAT_BC1_UNORM = 71] = \"DXGI_FORMAT_BC1_UNORM\", o[o.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\", o[o.DXGI_FORMAT_BC2_TYPELESS = 73] = \"DXGI_FORMAT_BC2_TYPELESS\", o[o.DXGI_FORMAT_BC2_UNORM = 74] = \"DXGI_FORMAT_BC2_UNORM\", o[o.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\", o[o.DXGI_FORMAT_BC3_TYPELESS = 76] = \"DXGI_FORMAT_BC3_TYPELESS\", o[o.DXGI_FORMAT_BC3_UNORM = 77] = \"DXGI_FORMAT_BC3_UNORM\", o[o.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\", o[o.DXGI_FORMAT_BC4_TYPELESS = 79] = \"DXGI_FORMAT_BC4_TYPELESS\", o[o.DXGI_FORMAT_BC4_UNORM = 80] = \"DXGI_FORMAT_BC4_UNORM\", o[o.DXGI_FORMAT_BC4_SNORM = 81] = \"DXGI_FORMAT_BC4_SNORM\", o[o.DXGI_FORMAT_BC5_TYPELESS = 82] = \"DXGI_FORMAT_BC5_TYPELESS\", o[o.DXGI_FORMAT_BC5_UNORM = 83] = \"DXGI_FORMAT_BC5_UNORM\", o[o.DXGI_FORMAT_BC5_SNORM = 84] = \"DXGI_FORMAT_BC5_SNORM\", o[o.DXGI_FORMAT_B5G6R5_UNORM = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\", o[o.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\", o[o.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\", o[o.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\", o[o.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\", o[o.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\", o[o.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\", o[o.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\", o[o.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\", o[o.DXGI_FORMAT_BC6H_TYPELESS = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\", o[o.DXGI_FORMAT_BC6H_UF16 = 95] = \"DXGI_FORMAT_BC6H_UF16\", o[o.DXGI_FORMAT_BC6H_SF16 = 96] = \"DXGI_FORMAT_BC6H_SF16\", o[o.DXGI_FORMAT_BC7_TYPELESS = 97] = \"DXGI_FORMAT_BC7_TYPELESS\", o[o.DXGI_FORMAT_BC7_UNORM = 98] = \"DXGI_FORMAT_BC7_UNORM\", o[o.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\", o[o.DXGI_FORMAT_AYUV = 100] = \"DXGI_FORMAT_AYUV\", o[o.DXGI_FORMAT_Y410 = 101] = \"DXGI_FORMAT_Y410\", o[o.DXGI_FORMAT_Y416 = 102] = \"DXGI_FORMAT_Y416\", o[o.DXGI_FORMAT_NV12 = 103] = \"DXGI_FORMAT_NV12\", o[o.DXGI_FORMAT_P010 = 104] = \"DXGI_FORMAT_P010\", o[o.DXGI_FORMAT_P016 = 105] = \"DXGI_FORMAT_P016\", o[o.DXGI_FORMAT_420_OPAQUE = 106] = \"DXGI_FORMAT_420_OPAQUE\", o[o.DXGI_FORMAT_YUY2 = 107] = \"DXGI_FORMAT_YUY2\", o[o.DXGI_FORMAT_Y210 = 108] = \"DXGI_FORMAT_Y210\", o[o.DXGI_FORMAT_Y216 = 109] = \"DXGI_FORMAT_Y216\", o[o.DXGI_FORMAT_NV11 = 110] = \"DXGI_FORMAT_NV11\", o[o.DXGI_FORMAT_AI44 = 111] = \"DXGI_FORMAT_AI44\", o[o.DXGI_FORMAT_IA44 = 112] = \"DXGI_FORMAT_IA44\", o[o.DXGI_FORMAT_P8 = 113] = \"DXGI_FORMAT_P8\", o[o.DXGI_FORMAT_A8P8 = 114] = \"DXGI_FORMAT_A8P8\", o[o.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\", o[o.DXGI_FORMAT_P208 = 116] = \"DXGI_FORMAT_P208\", o[o.DXGI_FORMAT_V208 = 117] = \"DXGI_FORMAT_V208\", o[o.DXGI_FORMAT_V408 = 118] = \"DXGI_FORMAT_V408\", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\", o[o.DXGI_FORMAT_FORCE_UINT = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(DXGI_FORMAT || (DXGI_FORMAT = {}));\nvar D3D10_RESOURCE_DIMENSION;\n(function(o) {\n  o[o.DDS_DIMENSION_TEXTURE1D = 2] = \"DDS_DIMENSION_TEXTURE1D\", o[o.DDS_DIMENSION_TEXTURE2D = 3] = \"DDS_DIMENSION_TEXTURE2D\", o[o.DDS_DIMENSION_TEXTURE3D = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));\nvar PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);\nfunction parseDDS(o) {\n  var t = new Uint32Array(o), e = t[0];\n  if (e !== DDS_MAGIC)\n    throw new Error(\"Invalid DDS file magic word\");\n  var r = new Uint32Array(o, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), S = r[DDS_FIELDS.HEIGHT], T = r[DDS_FIELDS.WIDTH], D = r[DDS_FIELDS.MIPMAP_COUNT], N = new Uint32Array(o, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), B = N[PF_FLAGS];\n  if (B & DDPF_FOURCC) {\n    var $ = N[DDS_PF_FIELDS.FOURCC];\n    if ($ !== FOURCC_DX10) {\n      var U = FOURCC_TO_FORMAT[$], V = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, H = new Uint8Array(o, V), X = new CompressedTextureResource(H, {\n        format: U,\n        width: T,\n        height: S,\n        levels: D\n      });\n      return [X];\n    }\n    var Y = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, W = new Uint32Array(t.buffer, Y, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), q = W[DDS_DX10_FIELDS.DXGI_FORMAT], K = W[DDS_DX10_FIELDS.RESOURCE_DIMENSION], Z = W[DDS_DX10_FIELDS.MISC_FLAG], J = W[DDS_DX10_FIELDS.ARRAY_SIZE], Q = DXGI_TO_FORMAT[q];\n    if (Q === void 0)\n      throw new Error(\"DDSParser cannot parse texture data with DXGI format \" + q);\n    if (Z === DDS_RESOURCE_MISC_TEXTURECUBE)\n      throw new Error(\"DDSParser does not support cubemap textures\");\n    if (K === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n      throw new Error(\"DDSParser does not supported 3D texture data\");\n    var rt = new Array(), et = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (J === 1)\n      rt.push(new Uint8Array(o, et));\n    else {\n      for (var nt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[Q], st = 0, it = T, at = S, ut = 0; ut < D; ut++) {\n        var ct = Math.max(1, it + 3 & -4), gt = Math.max(1, at + 3 & -4), _t = ct * gt * nt;\n        st += _t, it = it >>> 1, at = at >>> 1;\n      }\n      for (var vt = et, ut = 0; ut < J; ut++)\n        rt.push(new Uint8Array(o, vt, st)), vt += st;\n    }\n    return rt.map(function(mt) {\n      return new CompressedTextureResource(mt, {\n        format: Q,\n        width: T,\n        height: S,\n        levels: D\n      });\n    });\n  }\n  throw B & DDPF_RGB ? new Error(\"DDSParser does not support uncompressed texture data.\") : B & DDPF_YUV ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : B & DDPF_LUMINANCE ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : B & DDPF_ALPHA ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nvar _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);\nfunction parseKTX(o, t, e) {\n  e === void 0 && (e = !1);\n  var r = new DataView(t);\n  if (!validate(o, r))\n    return null;\n  var S = r.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, T = r.getUint32(KTX_FIELDS.GL_TYPE, S), D = r.getUint32(KTX_FIELDS.GL_FORMAT, S), N = r.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, S), B = r.getUint32(KTX_FIELDS.PIXEL_WIDTH, S), $ = r.getUint32(KTX_FIELDS.PIXEL_HEIGHT, S) || 1, U = r.getUint32(KTX_FIELDS.PIXEL_DEPTH, S) || 1, V = r.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, S) || 1, H = r.getUint32(KTX_FIELDS.NUMBER_OF_FACES, S), X = r.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, S), Y = r.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, S);\n  if ($ === 0 || U !== 1)\n    throw new Error(\"Only 2D textures are supported\");\n  if (H !== 1)\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  if (V !== 1)\n    throw new Error(\"WebGL does not support array textures\");\n  var W = 4, q = 4, K = B + 3 & -4, Z = $ + 3 & -4, J = new Array(V), Q = B * $;\n  T === 0 && (Q = K * Z);\n  var rt;\n  if (T !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[T] ? rt = TYPES_TO_BYTES_PER_COMPONENT[T] * FORMATS_TO_COMPONENTS[D] : rt = TYPES_TO_BYTES_PER_PIXEL[T] : rt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[N], rt === void 0)\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  for (var et = e ? parseKvData(r, Y, S) : null, nt = Q * rt, st = nt, it = B, at = $, ut = K, ct = Z, gt = FILE_HEADER_SIZE + Y, _t = 0; _t < X; _t++) {\n    for (var vt = r.getUint32(gt, S), mt = gt + 4, bt = 0; bt < V; bt++) {\n      var Ct = J[bt];\n      Ct || (Ct = J[bt] = new Array(X)), Ct[_t] = {\n        levelID: _t,\n        levelWidth: X > 1 || T !== 0 ? it : ut,\n        levelHeight: X > 1 || T !== 0 ? at : ct,\n        levelBuffer: new Uint8Array(t, mt, st)\n      }, mt += st;\n    }\n    gt += vt + 4, gt = gt % 4 !== 0 ? gt + 4 - gt % 4 : gt, it = it >> 1 || 1, at = at >> 1 || 1, ut = it + W - 1 & ~(W - 1), ct = at + q - 1 & ~(q - 1), st = ut * ct * rt;\n  }\n  return T !== 0 ? {\n    uncompressed: J.map(function(St) {\n      var pt = St[0].levelBuffer, yt = !1;\n      return T === TYPES.FLOAT ? pt = new Float32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4) : T === TYPES.UNSIGNED_INT ? (yt = !0, pt = new Uint32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)) : T === TYPES.INT && (yt = !0, pt = new Int32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)), {\n        resource: new BufferResource(pt, {\n          width: St[0].levelWidth,\n          height: St[0].levelHeight\n        }),\n        type: T,\n        format: yt ? convertFormatToInteger(D) : D\n      };\n    }),\n    kvData: et\n  } : {\n    compressed: J.map(function(St) {\n      return new CompressedTextureResource(null, {\n        format: N,\n        width: B,\n        height: $,\n        levels: X,\n        levelBuffers: St\n      });\n    }),\n    kvData: et\n  };\n}\nfunction validate(o, t) {\n  for (var e = 0; e < FILE_IDENTIFIER.length; e++)\n    if (t.getUint8(e) !== FILE_IDENTIFIER[e])\n      return console.error(o + \" is not a valid *.ktx file!\"), !1;\n  return !0;\n}\nfunction convertFormatToInteger(o) {\n  switch (o) {\n    case FORMATS.RGBA:\n      return FORMATS.RGBA_INTEGER;\n    case FORMATS.RGB:\n      return FORMATS.RGB_INTEGER;\n    case FORMATS.RG:\n      return FORMATS.RG_INTEGER;\n    case FORMATS.RED:\n      return FORMATS.RED_INTEGER;\n    default:\n      return o;\n  }\n}\nfunction parseKvData(o, t, e) {\n  for (var r = /* @__PURE__ */ new Map(), S = 0; S < t; ) {\n    var T = o.getUint32(FILE_HEADER_SIZE + S, e), D = FILE_HEADER_SIZE + S + 4, N = 3 - (T + 3) % 4;\n    if (T === 0 || T > t - S) {\n      console.error(\"KTXLoader: keyAndValueByteSize out of bounds\");\n      break;\n    }\n    for (var B = 0; B < T && o.getUint8(D + B) !== 0; B++)\n      ;\n    if (B === -1) {\n      console.error(\"KTXLoader: Failed to find null byte terminating kvData key\");\n      break;\n    }\n    var $ = new TextDecoder().decode(new Uint8Array(o.buffer, D, B)), U = new DataView(o.buffer, D + B + 1, T - B - 1);\n    r.set($, U), S += 4 + T + N;\n  }\n  return r;\n}\nLoaderResource.setExtensionXhrType(\"dds\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar DDSLoader = function() {\n  function o() {\n  }\n  return o.use = function(t, e) {\n    if (t.extension === \"dds\" && t.data)\n      try {\n        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));\n      } catch (r) {\n        e(r);\n        return;\n      }\n    e();\n  }, o.extension = ExtensionType.Loader, o;\n}();\nLoaderResource.setExtensionXhrType(\"ktx\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar KTXLoader = function() {\n  function o() {\n  }\n  return o.use = function(t, e) {\n    if (t.extension === \"ktx\" && t.data)\n      try {\n        var r = t.name || t.url, S = parseKTX(r, t.data, this.loadKeyValueData), T = S.compressed, D = S.uncompressed, N = S.kvData;\n        if (T) {\n          var B = registerCompressedTextures(r, T, t.metadata);\n          if (N && B.textures)\n            for (var $ in B.textures)\n              B.textures[$].baseTexture.ktxKeyValueData = N;\n          Object.assign(t, B);\n        } else if (D) {\n          var U = {};\n          D.forEach(function(V, H) {\n            var X = new Texture(new BaseTexture(V.resource, {\n              mipmap: MIPMAP_MODES.OFF,\n              alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n              type: V.type,\n              format: V.format\n            })), Y = r + \"-\" + (H + 1);\n            N && (X.baseTexture.ktxKeyValueData = N), BaseTexture.addToCache(X.baseTexture, Y), Texture.addToCache(X, Y), H === 0 && (U[r] = X, BaseTexture.addToCache(X.baseTexture, r), Texture.addToCache(X, r)), U[Y] = X;\n          }), Object.assign(t, { textures: U });\n        }\n      } catch (V) {\n        e(V);\n        return;\n      }\n    e();\n  }, o.extension = ExtensionType.Loader, o.loadKeyValueData = !1, o;\n}();\nvar extendStatics$m = function(o, t) {\n  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$m(o, t);\n};\nfunction __extends$m(o, t) {\n  extendStatics$m(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\n(function(o) {\n  __extends$m(t, o);\n  function t(e, r, S, T) {\n    e === void 0 && (e = 1500), S === void 0 && (S = 16384), T === void 0 && (T = !1);\n    var D = o.call(this) || this, N = 16384;\n    return S > N && (S = N), D._properties = [!1, !0, !1, !1, !1], D._maxSize = e, D._batchSize = S, D._buffers = null, D._bufferUpdateIDs = [], D._updateID = 0, D.interactiveChildren = !1, D.blendMode = BLEND_MODES.NORMAL, D.autoResize = T, D.roundPixels = !0, D.baseTexture = null, D.setProperties(r), D._tint = 0, D.tintRgb = new Float32Array(4), D.tint = 16777215, D;\n  }\n  return t.prototype.setProperties = function(e) {\n    e && (this._properties[0] = \"vertices\" in e || \"scale\" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = \"position\" in e ? !!e.position : this._properties[1], this._properties[2] = \"rotation\" in e ? !!e.rotation : this._properties[2], this._properties[3] = \"uvs\" in e ? !!e.uvs : this._properties[3], this._properties[4] = \"tint\" in e || \"alpha\" in e ? !!e.tint || !!e.alpha : this._properties[4]);\n  }, t.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, hex2rgb(e, this.tintRgb);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.render = function(e) {\n    var r = this;\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", function() {\n      return r.onChildrenChange(0);\n    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));\n  }, t.prototype.onChildrenChange = function(e) {\n    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[r] = ++this._updateID;\n  }, t.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var e = 0; e < this._buffers.length; ++e)\n        this._buffers[e].destroy();\n      this._buffers = null;\n    }\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }, t;\n})(Container);\nvar ParticleBuffer = function() {\n  function o(t, e, r) {\n    this.geometry = new Geometry(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];\n    for (var S = 0; S < t.length; ++S) {\n      var T = t[S];\n      T = {\n        attributeName: T.attributeName,\n        size: T.size,\n        uploadFunction: T.uploadFunction,\n        type: T.type || TYPES.FLOAT,\n        offset: T.offset\n      }, e[S] ? this.dynamicProperties.push(T) : this.staticProperties.push(T);\n    }\n    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n  }\n  return o.prototype.initBuffers = function() {\n    var t = this.geometry, e = 0;\n    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;\n    for (var r = 0; r < this.dynamicProperties.length; ++r) {\n      var S = this.dynamicProperties[r];\n      S.offset = e, e += S.size, this.dynamicStride += S.size;\n    }\n    var T = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(T), this.dynamicDataUint32 = new Uint32Array(T), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);\n    var D = 0;\n    this.staticStride = 0;\n    for (var r = 0; r < this.staticProperties.length; ++r) {\n      var S = this.staticProperties[r];\n      S.offset = D, D += S.size, this.staticStride += S.size;\n    }\n    var N = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(N), this.staticDataUint32 = new Uint32Array(N), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);\n    for (var r = 0; r < this.dynamicProperties.length; ++r) {\n      var S = this.dynamicProperties[r];\n      t.addAttribute(S.attributeName, this.dynamicBuffer, 0, S.type === TYPES.UNSIGNED_BYTE, S.type, this.dynamicStride * 4, S.offset * 4);\n    }\n    for (var r = 0; r < this.staticProperties.length; ++r) {\n      var S = this.staticProperties[r];\n      t.addAttribute(S.attributeName, this.staticBuffer, 0, S.type === TYPES.UNSIGNED_BYTE, S.type, this.staticStride * 4, S.offset * 4);\n    }\n  }, o.prototype.uploadDynamic = function(t, e, r) {\n    for (var S = 0; S < this.dynamicProperties.length; S++) {\n      var T = this.dynamicProperties[S];\n      T.uploadFunction(t, e, r, T.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, T.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  }, o.prototype.uploadStatic = function(t, e, r) {\n    for (var S = 0; S < this.staticProperties.length; S++) {\n      var T = this.staticProperties[S];\n      T.uploadFunction(t, e, r, T.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, T.offset);\n    }\n    this.staticBuffer._updateID++;\n  }, o.prototype.destroy = function() {\n    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n  }, o;\n}(), fragment$6 = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`, vertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`, ParticleRenderer = function(o) {\n  __extends$m(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return r.shader = null, r.properties = null, r.tempMatrix = new Matrix(), r.properties = [\n      {\n        attributeName: \"aVertexPosition\",\n        size: 2,\n        uploadFunction: r.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: \"aPositionCoord\",\n        size: 2,\n        uploadFunction: r.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: \"aRotation\",\n        size: 1,\n        uploadFunction: r.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: \"aTextureCoord\",\n        size: 2,\n        uploadFunction: r.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: \"aColor\",\n        size: 1,\n        type: TYPES.UNSIGNED_BYTE,\n        uploadFunction: r.uploadTint,\n        offset: 0\n      }\n    ], r.shader = Shader.from(vertex$3, fragment$6, {}), r.state = State.for2d(), r;\n  }\n  return t.prototype.render = function(e) {\n    var r = e.children, S = e._maxSize, T = e._batchSize, D = this.renderer, N = r.length;\n    if (N !== 0) {\n      N > S && !e.autoResize && (N = S);\n      var B = e._buffers;\n      B || (B = e._buffers = this.generateBuffers(e));\n      var $ = r[0]._texture.baseTexture, U = $.alphaMode > 0;\n      this.state.blendMode = correctBlendMode(e.blendMode, U), D.state.set(this.state);\n      var V = D.gl, H = e.worldTransform.copyTo(this.tempMatrix);\n      H.prepend(D.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = H.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, U), this.shader.uniforms.uSampler = $, this.renderer.shader.bind(this.shader);\n      for (var X = !1, Y = 0, W = 0; Y < N; Y += T, W += 1) {\n        var q = N - Y;\n        q > T && (q = T), W >= B.length && B.push(this._generateOneMoreBuffer(e));\n        var K = B[W];\n        K.uploadDynamic(r, Y, q);\n        var Z = e._bufferUpdateIDs[W] || 0;\n        X = X || K._updateID < Z, X && (K._updateID = e._updateID, K.uploadStatic(r, Y, q)), D.geometry.bind(K.geometry), V.drawElements(V.TRIANGLES, q * 6, V.UNSIGNED_SHORT, 0);\n      }\n    }\n  }, t.prototype.generateBuffers = function(e) {\n    for (var r = [], S = e._maxSize, T = e._batchSize, D = e._properties, N = 0; N < S; N += T)\n      r.push(new ParticleBuffer(this.properties, D, T));\n    return r;\n  }, t.prototype._generateOneMoreBuffer = function(e) {\n    var r = e._batchSize, S = e._properties;\n    return new ParticleBuffer(this.properties, S, r);\n  }, t.prototype.uploadVertices = function(e, r, S, T, D, N) {\n    for (var B = 0, $ = 0, U = 0, V = 0, H = 0; H < S; ++H) {\n      var X = e[r + H], Y = X._texture, W = X.scale.x, q = X.scale.y, K = Y.trim, Z = Y.orig;\n      K ? ($ = K.x - X.anchor.x * Z.width, B = $ + K.width, V = K.y - X.anchor.y * Z.height, U = V + K.height) : (B = Z.width * (1 - X.anchor.x), $ = Z.width * -X.anchor.x, U = Z.height * (1 - X.anchor.y), V = Z.height * -X.anchor.y), T[N] = $ * W, T[N + 1] = V * q, T[N + D] = B * W, T[N + D + 1] = V * q, T[N + D * 2] = B * W, T[N + D * 2 + 1] = U * q, T[N + D * 3] = $ * W, T[N + D * 3 + 1] = U * q, N += D * 4;\n    }\n  }, t.prototype.uploadPosition = function(e, r, S, T, D, N) {\n    for (var B = 0; B < S; B++) {\n      var $ = e[r + B].position;\n      T[N] = $.x, T[N + 1] = $.y, T[N + D] = $.x, T[N + D + 1] = $.y, T[N + D * 2] = $.x, T[N + D * 2 + 1] = $.y, T[N + D * 3] = $.x, T[N + D * 3 + 1] = $.y, N += D * 4;\n    }\n  }, t.prototype.uploadRotation = function(e, r, S, T, D, N) {\n    for (var B = 0; B < S; B++) {\n      var $ = e[r + B].rotation;\n      T[N] = $, T[N + D] = $, T[N + D * 2] = $, T[N + D * 3] = $, N += D * 4;\n    }\n  }, t.prototype.uploadUvs = function(e, r, S, T, D, N) {\n    for (var B = 0; B < S; ++B) {\n      var $ = e[r + B]._texture._uvs;\n      $ ? (T[N] = $.x0, T[N + 1] = $.y0, T[N + D] = $.x1, T[N + D + 1] = $.y1, T[N + D * 2] = $.x2, T[N + D * 2 + 1] = $.y2, T[N + D * 3] = $.x3, T[N + D * 3 + 1] = $.y3, N += D * 4) : (T[N] = 0, T[N + 1] = 0, T[N + D] = 0, T[N + D + 1] = 0, T[N + D * 2] = 0, T[N + D * 2 + 1] = 0, T[N + D * 3] = 0, T[N + D * 3 + 1] = 0, N += D * 4);\n    }\n  }, t.prototype.uploadTint = function(e, r, S, T, D, N) {\n    for (var B = 0; B < S; ++B) {\n      var $ = e[r + B], U = $._texture.baseTexture.alphaMode > 0, V = $.alpha, H = V < 1 && U ? premultiplyTint($._tintRGB, V) : $._tintRGB + (V * 255 << 24);\n      T[N] = H, T[N + D] = H, T[N + D * 2] = H, T[N + D * 3] = H, N += D * 4;\n    }\n  }, t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n  }, t.extension = {\n    name: \"particle\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\nvar LINE_JOIN;\n(function(o) {\n  o.MITER = \"miter\", o.BEVEL = \"bevel\", o.ROUND = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\nvar LINE_CAP;\n(function(o) {\n  o.BUTT = \"butt\", o.ROUND = \"round\", o.SQUARE = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\nvar GRAPHICS_CURVES = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(o, t) {\n    if (t === void 0 && (t = 20), !this.adaptive || !o || isNaN(o))\n      return t;\n    var e = Math.ceil(o / this.maxLength);\n    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;\n  }\n}, FillStyle = function() {\n  function o() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();\n  }\n  return o.prototype.clone = function() {\n    var t = new o();\n    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;\n  }, o.prototype.reset = function() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;\n  }, o.prototype.destroy = function() {\n    this.texture = null, this.matrix = null;\n  }, o;\n}();\nvar extendStatics$l = function(o, t) {\n  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$l(o, t);\n};\nfunction __extends$l(o, t) {\n  extendStatics$l(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction fixOrientation(o, t) {\n  var e, r;\n  t === void 0 && (t = !1);\n  var S = o.length;\n  if (!(S < 6)) {\n    for (var T = 0, D = 0, N = o[S - 2], B = o[S - 1]; D < S; D += 2) {\n      var $ = o[D], U = o[D + 1];\n      T += ($ - N) * (U + B), N = $, B = U;\n    }\n    if (!t && T > 0 || t && T <= 0)\n      for (var V = S / 2, D = V + V % 2; D < S; D += 2) {\n        var H = S - D - 2, X = S - D - 1, Y = D, W = D + 1;\n        e = [o[Y], o[H]], o[H] = e[0], o[Y] = e[1], r = [o[W], o[X]], o[X] = r[0], o[W] = r[1];\n      }\n  }\n}\nvar buildPoly = {\n  build: function(o) {\n    o.points = o.shape.points.slice();\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = o.holes, S = t.points, T = t.indices;\n    if (e.length >= 6) {\n      fixOrientation(e, !1);\n      for (var D = [], N = 0; N < r.length; N++) {\n        var B = r[N];\n        fixOrientation(B.points, !0), D.push(e.length / 2), e = e.concat(B.points);\n      }\n      var $ = earcut$1.exports(e, D, 2);\n      if (!$)\n        return;\n      for (var U = S.length / 2, N = 0; N < $.length; N += 3)\n        T.push($[N] + U), T.push($[N + 1] + U), T.push($[N + 2] + U);\n      for (var N = 0; N < e.length; N++)\n        S.push(e[N]);\n    }\n  }\n}, buildCircle = {\n  build: function(o) {\n    var t = o.points, e, r, S, T, D, N;\n    if (o.type === SHAPES.CIRC) {\n      var B = o.shape;\n      e = B.x, r = B.y, D = N = B.radius, S = T = 0;\n    } else if (o.type === SHAPES.ELIP) {\n      var $ = o.shape;\n      e = $.x, r = $.y, D = $.width, N = $.height, S = T = 0;\n    } else {\n      var U = o.shape, V = U.width / 2, H = U.height / 2;\n      e = U.x + V, r = U.y + H, D = N = Math.max(0, Math.min(U.radius, Math.min(V, H))), S = V - D, T = H - N;\n    }\n    if (!(D >= 0 && N >= 0 && S >= 0 && T >= 0)) {\n      t.length = 0;\n      return;\n    }\n    var X = Math.ceil(2.3 * Math.sqrt(D + N)), Y = X * 8 + (S ? 4 : 0) + (T ? 4 : 0);\n    if (t.length = Y, Y !== 0) {\n      if (X === 0) {\n        t.length = 8, t[0] = t[6] = e + S, t[1] = t[3] = r + T, t[2] = t[4] = e - S, t[5] = t[7] = r - T;\n        return;\n      }\n      var W = 0, q = X * 4 + (S ? 2 : 0) + 2, K = q, Z = Y;\n      {\n        var J = S + D, Q = T, rt = e + J, et = e - J, nt = r + Q;\n        if (t[W++] = rt, t[W++] = nt, t[--q] = nt, t[--q] = et, T) {\n          var st = r - Q;\n          t[K++] = et, t[K++] = st, t[--Z] = st, t[--Z] = rt;\n        }\n      }\n      for (var it = 1; it < X; it++) {\n        var at = Math.PI / 2 * (it / X), J = S + Math.cos(at) * D, Q = T + Math.sin(at) * N, rt = e + J, et = e - J, nt = r + Q, st = r - Q;\n        t[W++] = rt, t[W++] = nt, t[--q] = nt, t[--q] = et, t[K++] = et, t[K++] = st, t[--Z] = st, t[--Z] = rt;\n      }\n      {\n        var J = S, Q = T + N, rt = e + J, et = e - J, nt = r + Q, st = r - Q;\n        t[W++] = rt, t[W++] = nt, t[--Z] = st, t[--Z] = rt, S && (t[W++] = et, t[W++] = nt, t[--Z] = st, t[--Z] = et);\n      }\n    }\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = t.points, S = t.indices;\n    if (e.length !== 0) {\n      var T = r.length / 2, D = T, N, B;\n      if (o.type !== SHAPES.RREC) {\n        var $ = o.shape;\n        N = $.x, B = $.y;\n      } else {\n        var U = o.shape;\n        N = U.x + U.width / 2, B = U.y + U.height / 2;\n      }\n      var V = o.matrix;\n      r.push(o.matrix ? V.a * N + V.c * B + V.tx : N, o.matrix ? V.b * N + V.d * B + V.ty : B), T++, r.push(e[0], e[1]);\n      for (var H = 2; H < e.length; H += 2)\n        r.push(e[H], e[H + 1]), S.push(T++, D, T);\n      S.push(D + 1, D, T);\n    }\n  }\n}, buildRectangle = {\n  build: function(o) {\n    var t = o.shape, e = t.x, r = t.y, S = t.width, T = t.height, D = o.points;\n    D.length = 0, D.push(e, r, e + S, r, e + S, r + T, e, r + T);\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = t.points, S = r.length / 2;\n    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(S, S + 1, S + 2, S + 1, S + 2, S + 3);\n  }\n};\nfunction getPt(o, t, e) {\n  var r = t - o;\n  return o + r * e;\n}\nfunction quadraticBezierCurve(o, t, e, r, S, T, D) {\n  D === void 0 && (D = []);\n  for (var N = 20, B = D, $ = 0, U = 0, V = 0, H = 0, X = 0, Y = 0, W = 0, q = 0; W <= N; ++W)\n    q = W / N, $ = getPt(o, e, q), U = getPt(t, r, q), V = getPt(e, S, q), H = getPt(r, T, q), X = getPt($, V, q), Y = getPt(U, H, q), !(W === 0 && B[B.length - 2] === X && B[B.length - 1] === Y) && B.push(X, Y);\n  return B;\n}\nvar buildRoundedRectangle = {\n  build: function(o) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(o);\n      return;\n    }\n    var t = o.shape, e = o.points, r = t.x, S = t.y, T = t.width, D = t.height, N = Math.max(0, Math.min(t.radius, Math.min(T, D) / 2));\n    e.length = 0, N ? (quadraticBezierCurve(r, S + N, r, S, r + N, S, e), quadraticBezierCurve(r + T - N, S, r + T, S, r + T, S + N, e), quadraticBezierCurve(r + T, S + D - N, r + T, S + D, r + T - N, S + D, e), quadraticBezierCurve(r + N, S + D, r, S + D, r, S + D - N, e)) : e.push(r, S, r + T, S, r + T, S + D, r, S + D);\n  },\n  triangulate: function(o, t) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(o, t);\n      return;\n    }\n    for (var e = o.points, r = t.points, S = t.indices, T = r.length / 2, D = earcut$1.exports(e, null, 2), N = 0, B = D.length; N < B; N += 3)\n      S.push(D[N] + T), S.push(D[N + 1] + T), S.push(D[N + 2] + T);\n    for (var N = 0, B = e.length; N < B; N++)\n      r.push(e[N], e[++N]);\n  }\n};\nfunction square(o, t, e, r, S, T, D, N) {\n  var B = o - e * S, $ = t - r * S, U = o + e * T, V = t + r * T, H, X;\n  D ? (H = r, X = -e) : (H = -r, X = e);\n  var Y = B + H, W = $ + X, q = U + H, K = V + X;\n  return N.push(Y, W), N.push(q, K), 2;\n}\nfunction round$1(o, t, e, r, S, T, D, N) {\n  var B = e - o, $ = r - t, U = Math.atan2(B, $), V = Math.atan2(S - o, T - t);\n  N && U < V ? U += Math.PI * 2 : !N && U > V && (V += Math.PI * 2);\n  var H = U, X = V - U, Y = Math.abs(X), W = Math.sqrt(B * B + $ * $), q = (15 * Y * Math.sqrt(W) / Math.PI >> 0) + 1, K = X / q;\n  if (H += K, N) {\n    D.push(o, t), D.push(e, r);\n    for (var Z = 1, J = H; Z < q; Z++, J += K)\n      D.push(o, t), D.push(o + Math.sin(J) * W, t + Math.cos(J) * W);\n    D.push(o, t), D.push(S, T);\n  } else {\n    D.push(e, r), D.push(o, t);\n    for (var Z = 1, J = H; Z < q; Z++, J += K)\n      D.push(o + Math.sin(J) * W, t + Math.cos(J) * W), D.push(o, t);\n    D.push(S, T), D.push(o, t);\n  }\n  return q * 2;\n}\nfunction buildNonNativeLine(o, t) {\n  var e = o.shape, r = o.points || e.points.slice(), S = t.closePointEps;\n  if (r.length !== 0) {\n    var T = o.lineStyle, D = new Point(r[0], r[1]), N = new Point(r[r.length - 2], r[r.length - 1]), B = e.type !== SHAPES.POLY || e.closeStroke, $ = Math.abs(D.x - N.x) < S && Math.abs(D.y - N.y) < S;\n    if (B) {\n      r = r.slice(), $ && (r.pop(), r.pop(), N.set(r[r.length - 2], r[r.length - 1]));\n      var U = (D.x + N.x) * 0.5, V = (N.y + D.y) * 0.5;\n      r.unshift(U, V), r.push(U, V);\n    }\n    var H = t.points, X = r.length / 2, Y = r.length, W = H.length / 2, q = T.width / 2, K = q * q, Z = T.miterLimit * T.miterLimit, J = r[0], Q = r[1], rt = r[2], et = r[3], nt = 0, st = 0, it = -(Q - et), at = J - rt, ut = 0, ct = 0, gt = Math.sqrt(it * it + at * at);\n    it /= gt, at /= gt, it *= q, at *= q;\n    var _t = T.alignment, vt = (1 - _t) * 2, mt = _t * 2;\n    B || (T.cap === LINE_CAP.ROUND ? Y += round$1(J - it * (vt - mt) * 0.5, Q - at * (vt - mt) * 0.5, J - it * vt, Q - at * vt, J + it * mt, Q + at * mt, H, !0) + 2 : T.cap === LINE_CAP.SQUARE && (Y += square(J, Q, it, at, vt, mt, !0, H))), H.push(J - it * vt, Q - at * vt), H.push(J + it * mt, Q + at * mt);\n    for (var bt = 1; bt < X - 1; ++bt) {\n      J = r[(bt - 1) * 2], Q = r[(bt - 1) * 2 + 1], rt = r[bt * 2], et = r[bt * 2 + 1], nt = r[(bt + 1) * 2], st = r[(bt + 1) * 2 + 1], it = -(Q - et), at = J - rt, gt = Math.sqrt(it * it + at * at), it /= gt, at /= gt, it *= q, at *= q, ut = -(et - st), ct = rt - nt, gt = Math.sqrt(ut * ut + ct * ct), ut /= gt, ct /= gt, ut *= q, ct *= q;\n      var Ct = rt - J, St = Q - et, pt = rt - nt, yt = st - et, At = Ct * pt + St * yt, Dt = St * pt - yt * Ct, Ot = Dt < 0;\n      if (Math.abs(Dt) < 1e-3 * Math.abs(At)) {\n        H.push(rt - it * vt, et - at * vt), H.push(rt + it * mt, et + at * mt), At >= 0 && (T.join === LINE_JOIN.ROUND ? Y += round$1(rt, et, rt - it * vt, et - at * vt, rt - ut * vt, et - ct * vt, H, !1) + 4 : Y += 2, H.push(rt - ut * mt, et - ct * mt), H.push(rt + ut * vt, et + ct * vt));\n        continue;\n      }\n      var Pt = (-it + J) * (-at + et) - (-it + rt) * (-at + Q), ft = (-ut + nt) * (-ct + et) - (-ut + rt) * (-ct + st), Ft = (Ct * ft - pt * Pt) / Dt, It = (yt * Pt - St * ft) / Dt, zt = (Ft - rt) * (Ft - rt) + (It - et) * (It - et), kt = rt + (Ft - rt) * vt, Tt = et + (It - et) * vt, jt = rt - (Ft - rt) * mt, Nt = et - (It - et) * mt, Et = Math.min(Ct * Ct + St * St, pt * pt + yt * yt), Lt = Ot ? vt : mt, Ht = Et + Lt * Lt * K, wt = zt <= Ht;\n      wt ? T.join === LINE_JOIN.BEVEL || zt / K > Z ? (Ot ? (H.push(kt, Tt), H.push(rt + it * mt, et + at * mt), H.push(kt, Tt), H.push(rt + ut * mt, et + ct * mt)) : (H.push(rt - it * vt, et - at * vt), H.push(jt, Nt), H.push(rt - ut * vt, et - ct * vt), H.push(jt, Nt)), Y += 2) : T.join === LINE_JOIN.ROUND ? Ot ? (H.push(kt, Tt), H.push(rt + it * mt, et + at * mt), Y += round$1(rt, et, rt + it * mt, et + at * mt, rt + ut * mt, et + ct * mt, H, !0) + 4, H.push(kt, Tt), H.push(rt + ut * mt, et + ct * mt)) : (H.push(rt - it * vt, et - at * vt), H.push(jt, Nt), Y += round$1(rt, et, rt - it * vt, et - at * vt, rt - ut * vt, et - ct * vt, H, !1) + 4, H.push(rt - ut * vt, et - ct * vt), H.push(jt, Nt)) : (H.push(kt, Tt), H.push(jt, Nt)) : (H.push(rt - it * vt, et - at * vt), H.push(rt + it * mt, et + at * mt), T.join === LINE_JOIN.ROUND ? Ot ? Y += round$1(rt, et, rt + it * mt, et + at * mt, rt + ut * mt, et + ct * mt, H, !0) + 2 : Y += round$1(rt, et, rt - it * vt, et - at * vt, rt - ut * vt, et - ct * vt, H, !1) + 2 : T.join === LINE_JOIN.MITER && zt / K <= Z && (Ot ? (H.push(jt, Nt), H.push(jt, Nt)) : (H.push(kt, Tt), H.push(kt, Tt)), Y += 2), H.push(rt - ut * vt, et - ct * vt), H.push(rt + ut * mt, et + ct * mt), Y += 2);\n    }\n    J = r[(X - 2) * 2], Q = r[(X - 2) * 2 + 1], rt = r[(X - 1) * 2], et = r[(X - 1) * 2 + 1], it = -(Q - et), at = J - rt, gt = Math.sqrt(it * it + at * at), it /= gt, at /= gt, it *= q, at *= q, H.push(rt - it * vt, et - at * vt), H.push(rt + it * mt, et + at * mt), B || (T.cap === LINE_CAP.ROUND ? Y += round$1(rt - it * (vt - mt) * 0.5, et - at * (vt - mt) * 0.5, rt - it * vt, et - at * vt, rt + it * mt, et + at * mt, H, !1) + 2 : T.cap === LINE_CAP.SQUARE && (Y += square(rt, et, it, at, vt, mt, !1, H)));\n    for (var Wt = t.indices, ee = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, bt = W; bt < Y + W - 2; ++bt)\n      J = H[bt * 2], Q = H[bt * 2 + 1], rt = H[(bt + 1) * 2], et = H[(bt + 1) * 2 + 1], nt = H[(bt + 2) * 2], st = H[(bt + 2) * 2 + 1], !(Math.abs(J * (et - st) + rt * (st - Q) + nt * (Q - et)) < ee) && Wt.push(bt, bt + 1, bt + 2);\n  }\n}\nfunction buildNativeLine(o, t) {\n  var e = 0, r = o.shape, S = o.points || r.points, T = r.type !== SHAPES.POLY || r.closeStroke;\n  if (S.length !== 0) {\n    var D = t.points, N = t.indices, B = S.length / 2, $ = D.length / 2, U = $;\n    for (D.push(S[0], S[1]), e = 1; e < B; e++)\n      D.push(S[e * 2], S[e * 2 + 1]), N.push(U, U + 1), U++;\n    T && N.push(U, $);\n  }\n}\nfunction buildLine(o, t) {\n  o.lineStyle.native ? buildNativeLine(o, t) : buildNonNativeLine(o, t);\n}\nvar ArcUtils = function() {\n  function o() {\n  }\n  return o.curveTo = function(t, e, r, S, T, D) {\n    var N = D[D.length - 2], B = D[D.length - 1], $ = B - e, U = N - t, V = S - e, H = r - t, X = Math.abs($ * H - U * V);\n    if (X < 1e-8 || T === 0)\n      return (D[D.length - 2] !== t || D[D.length - 1] !== e) && D.push(t, e), null;\n    var Y = $ * $ + U * U, W = V * V + H * H, q = $ * V + U * H, K = T * Math.sqrt(Y) / X, Z = T * Math.sqrt(W) / X, J = K * q / Y, Q = Z * q / W, rt = K * H + Z * U, et = K * V + Z * $, nt = U * (Z + J), st = $ * (Z + J), it = H * (K + Q), at = V * (K + Q), ut = Math.atan2(st - et, nt - rt), ct = Math.atan2(at - et, it - rt);\n    return {\n      cx: rt + t,\n      cy: et + e,\n      radius: T,\n      startAngle: ut,\n      endAngle: ct,\n      anticlockwise: U * V > H * $\n    };\n  }, o.arc = function(t, e, r, S, T, D, N, B, $) {\n    for (var U = N - D, V = GRAPHICS_CURVES._segmentsCount(Math.abs(U) * T, Math.ceil(Math.abs(U) / PI_2) * 40), H = U / (V * 2), X = H * 2, Y = Math.cos(H), W = Math.sin(H), q = V - 1, K = q % 1 / q, Z = 0; Z <= q; ++Z) {\n      var J = Z + K * Z, Q = H + D + X * J, rt = Math.cos(Q), et = -Math.sin(Q);\n      $.push((Y * rt + W * et) * T + r, (Y * -et + W * rt) * T + S);\n    }\n  }, o;\n}(), BezierUtils = function() {\n  function o() {\n  }\n  return o.curveLength = function(t, e, r, S, T, D, N, B) {\n    for (var $ = 10, U = 0, V = 0, H = 0, X = 0, Y = 0, W = 0, q = 0, K = 0, Z = 0, J = 0, Q = 0, rt = t, et = e, nt = 1; nt <= $; ++nt)\n      V = nt / $, H = V * V, X = H * V, Y = 1 - V, W = Y * Y, q = W * Y, K = q * t + 3 * W * V * r + 3 * Y * H * T + X * N, Z = q * e + 3 * W * V * S + 3 * Y * H * D + X * B, J = rt - K, Q = et - Z, rt = K, et = Z, U += Math.sqrt(J * J + Q * Q);\n    return U;\n  }, o.curveTo = function(t, e, r, S, T, D, N) {\n    var B = N[N.length - 2], $ = N[N.length - 1];\n    N.length -= 2;\n    var U = GRAPHICS_CURVES._segmentsCount(o.curveLength(B, $, t, e, r, S, T, D)), V = 0, H = 0, X = 0, Y = 0, W = 0;\n    N.push(B, $);\n    for (var q = 1, K = 0; q <= U; ++q)\n      K = q / U, V = 1 - K, H = V * V, X = H * V, Y = K * K, W = Y * K, N.push(X * B + 3 * H * K * t + 3 * V * Y * r + W * T, X * $ + 3 * H * K * e + 3 * V * Y * S + W * D);\n  }, o;\n}(), QuadraticUtils = function() {\n  function o() {\n  }\n  return o.curveLength = function(t, e, r, S, T, D) {\n    var N = t - 2 * r + T, B = e - 2 * S + D, $ = 2 * r - 2 * t, U = 2 * S - 2 * e, V = 4 * (N * N + B * B), H = 4 * (N * $ + B * U), X = $ * $ + U * U, Y = 2 * Math.sqrt(V + H + X), W = Math.sqrt(V), q = 2 * V * W, K = 2 * Math.sqrt(X), Z = H / W;\n    return (q * Y + W * H * (Y - K) + (4 * X * V - H * H) * Math.log((2 * W + Z + Y) / (Z + K))) / (4 * q);\n  }, o.curveTo = function(t, e, r, S, T) {\n    for (var D = T[T.length - 2], N = T[T.length - 1], B = GRAPHICS_CURVES._segmentsCount(o.curveLength(D, N, t, e, r, S)), $ = 0, U = 0, V = 1; V <= B; ++V) {\n      var H = V / B;\n      $ = D + (t - D) * H, U = N + (e - N) * H, T.push($ + (t + (r - t) * H - $) * H, U + (e + (S - e) * H - U) * H);\n    }\n  }, o;\n}(), BatchPart = function() {\n  function o() {\n    this.reset();\n  }\n  return o.prototype.begin = function(t, e, r) {\n    this.reset(), this.style = t, this.start = e, this.attribStart = r;\n  }, o.prototype.end = function(t, e) {\n    this.attribSize = e - this.attribStart, this.size = t - this.start;\n  }, o.prototype.reset = function() {\n    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n  }, o;\n}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {\n  function o(t, e, r, S) {\n    e === void 0 && (e = null), r === void 0 && (r = null), S === void 0 && (S = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = S, this.type = t.type;\n  }\n  return o.prototype.clone = function() {\n    return new o(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  }, o.prototype.destroy = function() {\n    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n  }, o;\n}(), tmpPoint = new Point(), GraphicsGeometry = function(o) {\n  __extends$l(t, o);\n  function t() {\n    var e = o.call(this) || this;\n    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;\n  }\n  return Object.defineProperty(t.prototype, \"bounds\", {\n    get: function() {\n      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.invalidate = function() {\n    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n    for (var e = 0; e < this.drawCalls.length; e++)\n      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);\n    this.drawCalls.length = 0;\n    for (var e = 0; e < this.batches.length; e++) {\n      var r = this.batches[e];\n      r.reset(), BATCH_POOL.push(r);\n    }\n    this.batches.length = 0;\n  }, t.prototype.clear = function() {\n    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n  }, t.prototype.drawShape = function(e, r, S, T) {\n    r === void 0 && (r = null), S === void 0 && (S = null), T === void 0 && (T = null);\n    var D = new GraphicsData(e, r, S, T);\n    return this.graphicsData.push(D), this.dirty++, this;\n  }, t.prototype.drawHole = function(e, r) {\n    if (r === void 0 && (r = null), !this.graphicsData.length)\n      return null;\n    var S = new GraphicsData(e, null, null, r), T = this.graphicsData[this.graphicsData.length - 1];\n    return S.lineStyle = T.lineStyle, T.holes.push(S), this.dirty++, this;\n  }, t.prototype.destroy = function() {\n    o.prototype.destroy.call(this);\n    for (var e = 0; e < this.graphicsData.length; ++e)\n      this.graphicsData[e].destroy();\n    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n  }, t.prototype.containsPoint = function(e) {\n    for (var r = this.graphicsData, S = 0; S < r.length; ++S) {\n      var T = r[S];\n      if (!!T.fillStyle.visible && T.shape && (T.matrix ? T.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), T.shape.contains(tmpPoint.x, tmpPoint.y))) {\n        var D = !1;\n        if (T.holes)\n          for (var N = 0; N < T.holes.length; N++) {\n            var B = T.holes[N];\n            if (B.shape.contains(tmpPoint.x, tmpPoint.y)) {\n              D = !0;\n              break;\n            }\n          }\n        if (!D)\n          return !0;\n      }\n    }\n    return !1;\n  }, t.prototype.updateBatches = function() {\n    if (!this.graphicsData.length) {\n      this.batchable = !0;\n      return;\n    }\n    if (!!this.validateBatching()) {\n      this.cacheDirty = this.dirty;\n      var e = this.uvs, r = this.graphicsData, S = null, T = null;\n      this.batches.length > 0 && (S = this.batches[this.batches.length - 1], T = S.style);\n      for (var D = this.shapeIndex; D < r.length; D++) {\n        this.shapeIndex++;\n        var N = r[D], B = N.fillStyle, $ = N.lineStyle, U = FILL_COMMANDS[N.type];\n        U.build(N), N.matrix && this.transformPoints(N.points, N.matrix), (B.visible || $.visible) && this.processHoles(N.holes);\n        for (var V = 0; V < 2; V++) {\n          var H = V === 0 ? B : $;\n          if (!!H.visible) {\n            var X = H.texture.baseTexture, Y = this.indices.length, W = this.points.length / 2;\n            X.wrapMode = WRAP_MODES.REPEAT, V === 0 ? this.processFill(N) : this.processLine(N);\n            var q = this.points.length / 2 - W;\n            q !== 0 && (S && !this._compareStyles(T, H) && (S.end(Y, W), S = null), S || (S = BATCH_POOL.pop() || new BatchPart(), S.begin(H, Y, W), this.batches.push(S), T = H), this.addUvs(this.points, e, H.texture, W, q, H.matrix));\n          }\n        }\n      }\n      var K = this.indices.length, Z = this.points.length / 2;\n      if (S && S.end(K, Z), this.batches.length === 0) {\n        this.batchable = !0;\n        return;\n      }\n      var J = Z > 65535;\n      this.indicesUint16 && this.indices.length === this.indicesUint16.length && J === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = J ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n    }\n  }, t.prototype._compareStyles = function(e, r) {\n    return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);\n  }, t.prototype.validateBatching = function() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n      return !1;\n    for (var e = 0, r = this.graphicsData.length; e < r; e++) {\n      var S = this.graphicsData[e], T = S.fillStyle, D = S.lineStyle;\n      if (T && !T.texture.baseTexture.valid || D && !D.texture.baseTexture.valid)\n        return !1;\n    }\n    return !0;\n  }, t.prototype.packBatches = function() {\n    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n    for (var e = this.batches, r = 0, S = e.length; r < S; r++)\n      for (var T = e[r], D = 0; D < T.size; D++) {\n        var N = T.start + D;\n        this.indicesUint16[N] = this.indicesUint16[N] - T.attribStart;\n      }\n  }, t.prototype.isBatchable = function() {\n    if (this.points.length > 65535 * 2)\n      return !1;\n    for (var e = this.batches, r = 0; r < e.length; r++)\n      if (e[r].style.native)\n        return !1;\n    return this.points.length < t.BATCHABLE_SIZE * 2;\n  }, t.prototype.buildDrawCalls = function() {\n    for (var e = ++BaseTexture._globalBatch, r = 0; r < this.drawCalls.length; r++)\n      this.drawCalls[r].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[r]);\n    this.drawCalls.length = 0;\n    var S = this.colors, T = this.textureIds, D = DRAW_CALL_POOL.pop();\n    D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), D.texArray.count = 0, D.start = 0, D.size = 0, D.type = DRAW_MODES.TRIANGLES;\n    var N = 0, B = null, $ = 0, U = !1, V = DRAW_MODES.TRIANGLES, H = 0;\n    this.drawCalls.push(D);\n    for (var r = 0; r < this.batches.length; r++) {\n      var X = this.batches[r], Y = 8, W = X.style, q = W.texture.baseTexture;\n      U !== !!W.native && (U = !!W.native, V = U ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, B = null, N = Y, e++), B !== q && (B = q, q._batchEnabled !== e && (N === Y && (e++, N = 0, D.size > 0 && (D = DRAW_CALL_POOL.pop(), D || (D = new BatchDrawCall(), D.texArray = new BatchTextureArray()), this.drawCalls.push(D)), D.start = H, D.size = 0, D.texArray.count = 0, D.type = V), q.touched = 1, q._batchEnabled = e, q._batchLocation = N, q.wrapMode = WRAP_MODES.REPEAT, D.texArray.elements[D.texArray.count++] = q, N++)), D.size += X.size, H += X.size, $ = q._batchLocation, this.addColors(S, W.color, W.alpha, X.attribSize, X.attribStart), this.addTextureIds(T, $, X.attribSize, X.attribStart);\n    }\n    BaseTexture._globalBatch = e, this.packAttributes();\n  }, t.prototype.packAttributes = function() {\n    for (var e = this.points, r = this.uvs, S = this.colors, T = this.textureIds, D = new ArrayBuffer(e.length * 3 * 4), N = new Float32Array(D), B = new Uint32Array(D), $ = 0, U = 0; U < e.length / 2; U++)\n      N[$++] = e[U * 2], N[$++] = e[U * 2 + 1], N[$++] = r[U * 2], N[$++] = r[U * 2 + 1], B[$++] = S[U], N[$++] = T[U];\n    this._buffer.update(D), this._indexBuffer.update(this.indicesUint16);\n  }, t.prototype.processFill = function(e) {\n    if (e.holes.length)\n      buildPoly.triangulate(e, this);\n    else {\n      var r = FILL_COMMANDS[e.type];\n      r.triangulate(e, this);\n    }\n  }, t.prototype.processLine = function(e) {\n    buildLine(e, this);\n    for (var r = 0; r < e.holes.length; r++)\n      buildLine(e.holes[r], this);\n  }, t.prototype.processHoles = function(e) {\n    for (var r = 0; r < e.length; r++) {\n      var S = e[r], T = FILL_COMMANDS[S.type];\n      T.build(S), S.matrix && this.transformPoints(S.points, S.matrix);\n    }\n  }, t.prototype.calculateBounds = function() {\n    var e = this._bounds;\n    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);\n  }, t.prototype.transformPoints = function(e, r) {\n    for (var S = 0; S < e.length / 2; S++) {\n      var T = e[S * 2], D = e[S * 2 + 1];\n      e[S * 2] = r.a * T + r.c * D + r.tx, e[S * 2 + 1] = r.b * T + r.d * D + r.ty;\n    }\n  }, t.prototype.addColors = function(e, r, S, T, D) {\n    D === void 0 && (D = 0);\n    var N = (r >> 16) + (r & 65280) + ((r & 255) << 16), B = premultiplyTint(N, S);\n    e.length = Math.max(e.length, D + T);\n    for (var $ = 0; $ < T; $++)\n      e[D + $] = B;\n  }, t.prototype.addTextureIds = function(e, r, S, T) {\n    T === void 0 && (T = 0), e.length = Math.max(e.length, T + S);\n    for (var D = 0; D < S; D++)\n      e[T + D] = r;\n  }, t.prototype.addUvs = function(e, r, S, T, D, N) {\n    N === void 0 && (N = null);\n    for (var B = 0, $ = r.length, U = S.frame; B < D; ) {\n      var V = e[(T + B) * 2], H = e[(T + B) * 2 + 1];\n      if (N) {\n        var X = N.a * V + N.c * H + N.tx;\n        H = N.b * V + N.d * H + N.ty, V = X;\n      }\n      B++, r.push(V / U.width, H / U.height);\n    }\n    var Y = S.baseTexture;\n    (U.width < Y.width || U.height < Y.height) && this.adjustUvs(r, S, $, D);\n  }, t.prototype.adjustUvs = function(e, r, S, T) {\n    for (var D = r.baseTexture, N = 1e-6, B = S + T * 2, $ = r.frame, U = $.width / D.width, V = $.height / D.height, H = $.x / $.width, X = $.y / $.height, Y = Math.floor(e[S] + N), W = Math.floor(e[S + 1] + N), q = S + 2; q < B; q += 2)\n      Y = Math.min(Y, Math.floor(e[q] + N)), W = Math.min(W, Math.floor(e[q + 1] + N));\n    H -= Y, X -= W;\n    for (var q = S; q < B; q += 2)\n      e[q] = (e[q] + H) * U, e[q + 1] = (e[q + 1] + X) * V;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(BatchGeometry), LineStyle = function(o) {\n  __extends$l(t, o);\n  function t() {\n    var e = o !== null && o.apply(this, arguments) || this;\n    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;\n  }\n  return t.prototype.clone = function() {\n    var e = new t();\n    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;\n  }, t.prototype.reset = function() {\n    o.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;\n  }, t;\n}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(o) {\n  __extends$l(t, o);\n  function t(e) {\n    e === void 0 && (e = null);\n    var r = o.call(this) || this;\n    return r.shader = null, r.pluginName = \"batch\", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new FillStyle(), r._lineStyle = new LineStyle(), r._matrix = null, r._holeMode = !1, r.state = State.for2d(), r._geometry = e || new GraphicsGeometry(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.clone = function() {\n    return this.finishPoly(), new t(this._geometry);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fill\", {\n    get: function() {\n      return this._fillStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"line\", {\n    get: function() {\n      return this._lineStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.lineStyle = function(e, r, S, T, D) {\n    return e === void 0 && (e = null), r === void 0 && (r = 0), S === void 0 && (S = 1), T === void 0 && (T = 0.5), D === void 0 && (D = !1), typeof e == \"number\" && (e = { width: e, color: r, alpha: S, alignment: T, native: D }), this.lineTextureStyle(e);\n  }, t.prototype.lineTextureStyle = function(e) {\n    e = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: e && e.texture ? 16777215 : 0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: !1,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, e), this.currentPath && this.startPoly();\n    var r = e.width > 0 && e.alpha > 0;\n    return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;\n  }, t.prototype.startPoly = function() {\n    if (this.currentPath) {\n      var e = this.currentPath.points, r = this.currentPath.points.length;\n      r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));\n    } else\n      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n  }, t.prototype.finishPoly = function() {\n    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n  }, t.prototype.moveTo = function(e, r) {\n    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;\n  }, t.prototype.lineTo = function(e, r) {\n    this.currentPath || this.moveTo(0, 0);\n    var S = this.currentPath.points, T = S[S.length - 2], D = S[S.length - 1];\n    return (T !== e || D !== r) && S.push(e, r), this;\n  }, t.prototype._initCurve = function(e, r) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);\n  }, t.prototype.quadraticCurveTo = function(e, r, S, T) {\n    this._initCurve();\n    var D = this.currentPath.points;\n    return D.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, r, S, T, D), this;\n  }, t.prototype.bezierCurveTo = function(e, r, S, T, D, N) {\n    return this._initCurve(), BezierUtils.curveTo(e, r, S, T, D, N, this.currentPath.points), this;\n  }, t.prototype.arcTo = function(e, r, S, T, D) {\n    this._initCurve(e, r);\n    var N = this.currentPath.points, B = ArcUtils.curveTo(e, r, S, T, D, N);\n    if (B) {\n      var $ = B.cx, U = B.cy, V = B.radius, H = B.startAngle, X = B.endAngle, Y = B.anticlockwise;\n      this.arc($, U, V, H, X, Y);\n    }\n    return this;\n  }, t.prototype.arc = function(e, r, S, T, D, N) {\n    if (N === void 0 && (N = !1), T === D)\n      return this;\n    !N && D <= T ? D += PI_2 : N && T <= D && (T += PI_2);\n    var B = D - T;\n    if (B === 0)\n      return this;\n    var $ = e + Math.cos(T) * S, U = r + Math.sin(T) * S, V = this._geometry.closePointEps, H = this.currentPath ? this.currentPath.points : null;\n    if (H) {\n      var X = Math.abs(H[H.length - 2] - $), Y = Math.abs(H[H.length - 1] - U);\n      X < V && Y < V || H.push($, U);\n    } else\n      this.moveTo($, U), H = this.currentPath.points;\n    return ArcUtils.arc($, U, e, r, S, T, D, N, H), this;\n  }, t.prototype.beginFill = function(e, r) {\n    return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: r });\n  }, t.prototype.beginTextureFill = function(e) {\n    e = Object.assign({\n      texture: Texture.WHITE,\n      color: 16777215,\n      alpha: 1,\n      matrix: null\n    }, e), this.currentPath && this.startPoly();\n    var r = e.alpha > 0;\n    return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;\n  }, t.prototype.endFill = function() {\n    return this.finishPoly(), this._fillStyle.reset(), this;\n  }, t.prototype.drawRect = function(e, r, S, T) {\n    return this.drawShape(new Rectangle(e, r, S, T));\n  }, t.prototype.drawRoundedRect = function(e, r, S, T, D) {\n    return this.drawShape(new RoundedRectangle(e, r, S, T, D));\n  }, t.prototype.drawCircle = function(e, r, S) {\n    return this.drawShape(new Circle(e, r, S));\n  }, t.prototype.drawEllipse = function(e, r, S, T) {\n    return this.drawShape(new Ellipse(e, r, S, T));\n  }, t.prototype.drawPolygon = function() {\n    for (var e = arguments, r = [], S = 0; S < arguments.length; S++)\n      r[S] = e[S];\n    var T, D = !0, N = r[0];\n    N.points ? (D = N.closeStroke, T = N.points) : Array.isArray(r[0]) ? T = r[0] : T = r;\n    var B = new Polygon(T);\n    return B.closeStroke = D, this.drawShape(B), this;\n  }, t.prototype.drawShape = function(e) {\n    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;\n  }, t.prototype.clear = function() {\n    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n  }, t.prototype.isFastRect = function() {\n    var e = this._geometry.graphicsData;\n    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);\n  }, t.prototype._render = function(e) {\n    this.finishPoly();\n    var r = this._geometry;\n    r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));\n  }, t.prototype._populateBatches = function() {\n    var e = this._geometry, r = this.blendMode, S = e.batches.length;\n    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = S, this.vertexData = new Float32Array(e.points);\n    for (var T = 0; T < S; T++) {\n      var D = e.batches[T], N = D.style.color, B = new Float32Array(this.vertexData.buffer, D.attribStart * 4 * 2, D.attribSize * 2), $ = new Float32Array(e.uvsFloat32.buffer, D.attribStart * 4 * 2, D.attribSize * 2), U = new Uint16Array(e.indicesUint16.buffer, D.start * 2, D.size), V = {\n        vertexData: B,\n        blendMode: r,\n        indices: U,\n        uvs: $,\n        _batchRGB: hex2rgb(N),\n        _tintRGB: N,\n        _texture: D.style.texture,\n        alpha: D.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[T] = V;\n    }\n  }, t.prototype._renderBatched = function(e) {\n    if (!!this.batches.length) {\n      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n      for (var r = 0, S = this.batches.length; r < S; r++) {\n        var T = this.batches[r];\n        T.worldAlpha = this.worldAlpha * T.alpha, e.plugins[this.pluginName].render(T);\n      }\n    }\n  }, t.prototype._renderDirect = function(e) {\n    var r = this._resolveDirectShader(e), S = this._geometry, T = this.tint, D = this.worldAlpha, N = r.uniforms, B = S.drawCalls;\n    N.translationMatrix = this.transform.worldTransform, N.tint[0] = (T >> 16 & 255) / 255 * D, N.tint[1] = (T >> 8 & 255) / 255 * D, N.tint[2] = (T & 255) / 255 * D, N.tint[3] = D, e.shader.bind(r), e.geometry.bind(S, r), e.state.set(this.state);\n    for (var $ = 0, U = B.length; $ < U; $++)\n      this._renderDrawCallDirect(e, S.drawCalls[$]);\n  }, t.prototype._renderDrawCallDirect = function(e, r) {\n    for (var S = r.texArray, T = r.type, D = r.size, N = r.start, B = S.count, $ = 0; $ < B; $++)\n      e.texture.bind(S.elements[$], $);\n    e.geometry.draw(T, D, N);\n  }, t.prototype._resolveDirectShader = function(e) {\n    var r = this.shader, S = this.pluginName;\n    if (!r) {\n      if (!DEFAULT_SHADERS[S]) {\n        for (var T = e.plugins[S].MAX_TEXTURES, D = new Int32Array(T), N = 0; N < T; N++)\n          D[N] = N;\n        var B = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: D }, !0)\n        }, $ = e.plugins[S]._shader.program;\n        DEFAULT_SHADERS[S] = new Shader($, B);\n      }\n      r = DEFAULT_SHADERS[S];\n    }\n    return r;\n  }, t.prototype._calculateBounds = function() {\n    this.finishPoly();\n    var e = this._geometry;\n    if (!!e.graphicsData.length) {\n      var r = e.bounds, S = r.minX, T = r.minY, D = r.maxX, N = r.maxY;\n      this._bounds.addFrame(this.transform, S, T, D, N);\n    }\n  }, t.prototype.containsPoint = function(e) {\n    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);\n  }, t.prototype.calculateTints = function() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      for (var e = hex2rgb(this.tint, temp), r = 0; r < this.batches.length; r++) {\n        var S = this.batches[r], T = S._batchRGB, D = e[0] * T[0] * 255, N = e[1] * T[1] * 255, B = e[2] * T[2] * 255, $ = (D << 16) + (N << 8) + (B | 0);\n        S._tintRGB = ($ >> 16) + ($ & 65280) + (($ & 255) << 16);\n      }\n    }\n  }, t.prototype.calculateVertices = function() {\n    var e = this.transform._worldID;\n    if (this._transformID !== e) {\n      this._transformID = e;\n      for (var r = this.transform.worldTransform, S = r.a, T = r.b, D = r.c, N = r.d, B = r.tx, $ = r.ty, U = this._geometry.points, V = this.vertexData, H = 0, X = 0; X < U.length; X += 2) {\n        var Y = U[X], W = U[X + 1];\n        V[H++] = S * Y + D * W + B, V[H++] = N * W + T * Y + $;\n      }\n    }\n  }, t.prototype.closePath = function() {\n    var e = this.currentPath;\n    return e && (e.closeStroke = !0, this.finishPoly()), this;\n  }, t.prototype.setMatrix = function(e) {\n    return this._matrix = e, this;\n  }, t.prototype.beginHole = function() {\n    return this.finishPoly(), this._holeMode = !0, this;\n  }, t.prototype.endHole = function() {\n    return this.finishPoly(), this._holeMode = !1, this;\n  }, t.prototype.destroy = function(e) {\n    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, o.prototype.destroy.call(this, e);\n  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;\n}(Container);\nvar extendStatics$k = function(o, t) {\n  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$k(o, t);\n};\nfunction __extends$k(o, t) {\n  extendStatics$k(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(o) {\n  __extends$k(t, o);\n  function t(e) {\n    var r = o.call(this) || this;\n    return r._anchor = new ObservablePoint(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Texture.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = indices, r.pluginName = \"batch\", r.isSprite = !0, r._roundPixels = settings.ROUND_PIXELS, r;\n  }\n  return t.prototype._onTextureUpdate = function() {\n    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);\n  }, t.prototype._onAnchorUpdate = function() {\n    this._transformID = -1, this._transformTrimmedID = -1;\n  }, t.prototype.calculateVertices = function() {\n    var e = this._texture;\n    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {\n      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;\n      var r = this.transform.worldTransform, S = r.a, T = r.b, D = r.c, N = r.d, B = r.tx, $ = r.ty, U = this.vertexData, V = e.trim, H = e.orig, X = this._anchor, Y = 0, W = 0, q = 0, K = 0;\n      if (V ? (W = V.x - X._x * H.width, Y = W + V.width, K = V.y - X._y * H.height, q = K + V.height) : (W = -X._x * H.width, Y = W + H.width, K = -X._y * H.height, q = K + H.height), U[0] = S * W + D * K + B, U[1] = N * K + T * W + $, U[2] = S * Y + D * K + B, U[3] = N * K + T * Y + $, U[4] = S * Y + D * q + B, U[5] = N * q + T * Y + $, U[6] = S * W + D * q + B, U[7] = N * q + T * W + $, this._roundPixels)\n        for (var Z = settings.RESOLUTION, J = 0; J < U.length; ++J)\n          U[J] = Math.round((U[J] * Z | 0) / Z);\n    }\n  }, t.prototype.calculateTrimmedVertices = function() {\n    if (!this.vertexTrimmedData)\n      this.vertexTrimmedData = new Float32Array(8);\n    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n      return;\n    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n    var e = this._texture, r = this.vertexTrimmedData, S = e.orig, T = this._anchor, D = this.transform.worldTransform, N = D.a, B = D.b, $ = D.c, U = D.d, V = D.tx, H = D.ty, X = -T._x * S.width, Y = X + S.width, W = -T._y * S.height, q = W + S.height;\n    r[0] = N * X + $ * W + V, r[1] = U * W + B * X + H, r[2] = N * Y + $ * W + V, r[3] = U * W + B * Y + H, r[4] = N * Y + $ * q + V, r[5] = U * q + B * Y + H, r[6] = N * X + $ * q + V, r[7] = U * q + B * X + H;\n  }, t.prototype._render = function(e) {\n    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);\n  }, t.prototype._calculateBounds = function() {\n    var e = this._texture.trim, r = this._texture.orig;\n    !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$2);\n    var r = this._texture.orig.width, S = this._texture.orig.height, T = -r * this.anchor.x, D = 0;\n    return tempPoint$2.x >= T && tempPoint$2.x < T + r && (D = -S * this.anchor.y, tempPoint$2.y >= D && tempPoint$2.y < D + S);\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null;\n    var r = typeof e == \"boolean\" ? e : e && e.texture;\n    if (r) {\n      var S = typeof e == \"boolean\" ? e : e && e.baseTexture;\n      this._texture.destroy(!!S);\n    }\n    this._texture = null;\n  }, t.from = function(e, r) {\n    var S = e instanceof Texture ? e : Texture.from(e, r);\n    return new t(S);\n  }, Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      var r = sign(this.scale.x) || 1;\n      this.scale.x = r * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      var r = sign(this.scale.y) || 1;\n      this.scale.y = r * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(e) {\n      this._texture !== e && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once(\"update\", this._onTextureUpdate, this)));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Container);\nvar extendStatics$j = function(o, t) {\n  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$j(o, t);\n};\nfunction __extends$j(o, t) {\n  extendStatics$j(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar TEXT_GRADIENT;\n(function(o) {\n  o[o.LINEAR_VERTICAL = 0] = \"LINEAR_VERTICAL\", o[o.LINEAR_HORIZONTAL = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nvar defaultStyle = {\n  align: \"left\",\n  breakWords: !1,\n  dropShadow: !1,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: !1,\n  whiteSpace: \"pre\",\n  wordWrap: !1,\n  wordWrapWidth: 100,\n  leading: 0\n}, genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n], TextStyle = function() {\n  function o(t) {\n    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);\n  }\n  return o.prototype.clone = function() {\n    var t = {};\n    return deepCopyProperties(t, this, defaultStyle), new o(t);\n  }, o.prototype.reset = function() {\n    deepCopyProperties(this, defaultStyle, defaultStyle);\n  }, Object.defineProperty(o.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(t) {\n      this._align !== t && (this._align = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"breakWords\", {\n    get: function() {\n      return this._breakWords;\n    },\n    set: function(t) {\n      this._breakWords !== t && (this._breakWords = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadow\", {\n    get: function() {\n      return this._dropShadow;\n    },\n    set: function(t) {\n      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadowAlpha\", {\n    get: function() {\n      return this._dropShadowAlpha;\n    },\n    set: function(t) {\n      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadowAngle\", {\n    get: function() {\n      return this._dropShadowAngle;\n    },\n    set: function(t) {\n      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadowBlur\", {\n    get: function() {\n      return this._dropShadowBlur;\n    },\n    set: function(t) {\n      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadowColor\", {\n    get: function() {\n      return this._dropShadowColor;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"dropShadowDistance\", {\n    get: function() {\n      return this._dropShadowDistance;\n    },\n    set: function(t) {\n      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fill\", {\n    get: function() {\n      return this._fill;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._fill !== e && (this._fill = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fillGradientType\", {\n    get: function() {\n      return this._fillGradientType;\n    },\n    set: function(t) {\n      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fillGradientStops\", {\n    get: function() {\n      return this._fillGradientStops;\n    },\n    set: function(t) {\n      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fontFamily\", {\n    get: function() {\n      return this._fontFamily;\n    },\n    set: function(t) {\n      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(t) {\n      this._fontSize !== t && (this._fontSize = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fontStyle\", {\n    get: function() {\n      return this._fontStyle;\n    },\n    set: function(t) {\n      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fontVariant\", {\n    get: function() {\n      return this._fontVariant;\n    },\n    set: function(t) {\n      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"fontWeight\", {\n    get: function() {\n      return this._fontWeight;\n    },\n    set: function(t) {\n      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(t) {\n      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"lineHeight\", {\n    get: function() {\n      return this._lineHeight;\n    },\n    set: function(t) {\n      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"leading\", {\n    get: function() {\n      return this._leading;\n    },\n    set: function(t) {\n      this._leading !== t && (this._leading = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"lineJoin\", {\n    get: function() {\n      return this._lineJoin;\n    },\n    set: function(t) {\n      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"miterLimit\", {\n    get: function() {\n      return this._miterLimit;\n    },\n    set: function(t) {\n      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"padding\", {\n    get: function() {\n      return this._padding;\n    },\n    set: function(t) {\n      this._padding !== t && (this._padding = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"stroke\", {\n    get: function() {\n      return this._stroke;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._stroke !== e && (this._stroke = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"strokeThickness\", {\n    get: function() {\n      return this._strokeThickness;\n    },\n    set: function(t) {\n      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"textBaseline\", {\n    get: function() {\n      return this._textBaseline;\n    },\n    set: function(t) {\n      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"trim\", {\n    get: function() {\n      return this._trim;\n    },\n    set: function(t) {\n      this._trim !== t && (this._trim = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"whiteSpace\", {\n    get: function() {\n      return this._whiteSpace;\n    },\n    set: function(t) {\n      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"wordWrap\", {\n    get: function() {\n      return this._wordWrap;\n    },\n    set: function(t) {\n      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"wordWrapWidth\", {\n    get: function() {\n      return this._wordWrapWidth;\n    },\n    set: function(t) {\n      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.toFontString = function() {\n    var t = typeof this.fontSize == \"number\" ? this.fontSize + \"px\" : this.fontSize, e = this.fontFamily;\n    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(\",\"));\n    for (var r = e.length - 1; r >= 0; r--) {\n      var S = e[r].trim();\n      !/([\\\"\\'])[^\\'\\\"]+\\1/.test(S) && genericFontFamilies.indexOf(S) < 0 && (S = '\"' + S + '\"'), e[r] = S;\n    }\n    return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + t + \" \" + e.join(\",\");\n  }, o;\n}();\nfunction getSingleColor(o) {\n  return typeof o == \"number\" ? hex2string(o) : (typeof o == \"string\" && o.indexOf(\"0x\") === 0 && (o = o.replace(\"0x\", \"#\")), o);\n}\nfunction getColor(o) {\n  if (Array.isArray(o)) {\n    for (var t = 0; t < o.length; ++t)\n      o[t] = getSingleColor(o[t]);\n    return o;\n  } else\n    return getSingleColor(o);\n}\nfunction areArraysEqual(o, t) {\n  if (!Array.isArray(o) || !Array.isArray(t) || o.length !== t.length)\n    return !1;\n  for (var e = 0; e < o.length; ++e)\n    if (o[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction deepCopyProperties(o, t, e) {\n  for (var r in e)\n    Array.isArray(t[r]) ? o[r] = t[r].slice() : o[r] = t[r];\n}\nvar contextSettings = {\n  willReadFrequently: !0\n}, TextMetrics = function() {\n  function o(t, e, r, S, T, D, N, B, $) {\n    this.text = t, this.style = e, this.width = r, this.height = S, this.lines = T, this.lineWidths = D, this.lineHeight = N, this.maxLineWidth = B, this.fontProperties = $;\n  }\n  return o.measureText = function(t, e, r, S) {\n    S === void 0 && (S = o._canvas), r = r ?? e.wordWrap;\n    var T = e.toFontString(), D = o.measureFont(T);\n    D.fontSize === 0 && (D.fontSize = e.fontSize, D.ascent = e.fontSize);\n    var N = S.getContext(\"2d\", contextSettings);\n    N.font = T;\n    for (var B = r ? o.wordWrap(t, e, S) : t, $ = B.split(/(?:\\r\\n|\\r|\\n)/), U = new Array($.length), V = 0, H = 0; H < $.length; H++) {\n      var X = N.measureText($[H]).width + ($[H].length - 1) * e.letterSpacing;\n      U[H] = X, V = Math.max(V, X);\n    }\n    var Y = V + e.strokeThickness;\n    e.dropShadow && (Y += e.dropShadowDistance);\n    var W = e.lineHeight || D.fontSize + e.strokeThickness, q = Math.max(W, D.fontSize + e.strokeThickness) + ($.length - 1) * (W + e.leading);\n    return e.dropShadow && (q += e.dropShadowDistance), new o(t, e, Y, q, $, U, W + e.leading, V, D);\n  }, o.wordWrap = function(t, e, r) {\n    r === void 0 && (r = o._canvas);\n    for (var S = r.getContext(\"2d\", contextSettings), T = 0, D = \"\", N = \"\", B = /* @__PURE__ */ Object.create(null), $ = e.letterSpacing, U = e.whiteSpace, V = o.collapseSpaces(U), H = o.collapseNewlines(U), X = !V, Y = e.wordWrapWidth + $, W = o.tokenize(t), q = 0; q < W.length; q++) {\n      var K = W[q];\n      if (o.isNewline(K)) {\n        if (!H) {\n          N += o.addLine(D), X = !V, D = \"\", T = 0;\n          continue;\n        }\n        K = \" \";\n      }\n      if (V) {\n        var Z = o.isBreakingSpace(K), J = o.isBreakingSpace(D[D.length - 1]);\n        if (Z && J)\n          continue;\n      }\n      var Q = o.getFromCache(K, $, B, S);\n      if (Q > Y)\n        if (D !== \"\" && (N += o.addLine(D), D = \"\", T = 0), o.canBreakWords(K, e.breakWords))\n          for (var rt = o.wordWrapSplit(K), et = 0; et < rt.length; et++) {\n            for (var nt = rt[et], st = 1; rt[et + st]; ) {\n              var it = rt[et + st], at = nt[nt.length - 1];\n              if (!o.canBreakChars(at, it, K, et, e.breakWords))\n                nt += it;\n              else\n                break;\n              st++;\n            }\n            et += nt.length - 1;\n            var ut = o.getFromCache(nt, $, B, S);\n            ut + T > Y && (N += o.addLine(D), X = !1, D = \"\", T = 0), D += nt, T += ut;\n          }\n        else {\n          D.length > 0 && (N += o.addLine(D), D = \"\", T = 0);\n          var ct = q === W.length - 1;\n          N += o.addLine(K, !ct), X = !1, D = \"\", T = 0;\n        }\n      else\n        Q + T > Y && (X = !1, N += o.addLine(D), D = \"\", T = 0), (D.length > 0 || !o.isBreakingSpace(K) || X) && (D += K, T += Q);\n    }\n    return N += o.addLine(D, !1), N;\n  }, o.addLine = function(t, e) {\n    return e === void 0 && (e = !0), t = o.trimRight(t), t = e ? t + `\n` : t, t;\n  }, o.getFromCache = function(t, e, r, S) {\n    var T = r[t];\n    if (typeof T != \"number\") {\n      var D = t.length * e;\n      T = S.measureText(t).width + D, r[t] = T;\n    }\n    return T;\n  }, o.collapseSpaces = function(t) {\n    return t === \"normal\" || t === \"pre-line\";\n  }, o.collapseNewlines = function(t) {\n    return t === \"normal\";\n  }, o.trimRight = function(t) {\n    if (typeof t != \"string\")\n      return \"\";\n    for (var e = t.length - 1; e >= 0; e--) {\n      var r = t[e];\n      if (!o.isBreakingSpace(r))\n        break;\n      t = t.slice(0, -1);\n    }\n    return t;\n  }, o.isNewline = function(t) {\n    return typeof t != \"string\" ? !1 : o._newlines.indexOf(t.charCodeAt(0)) >= 0;\n  }, o.isBreakingSpace = function(t, e) {\n    return typeof t != \"string\" ? !1 : o._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;\n  }, o.tokenize = function(t) {\n    var e = [], r = \"\";\n    if (typeof t != \"string\")\n      return e;\n    for (var S = 0; S < t.length; S++) {\n      var T = t[S], D = t[S + 1];\n      if (o.isBreakingSpace(T, D) || o.isNewline(T)) {\n        r !== \"\" && (e.push(r), r = \"\"), e.push(T);\n        continue;\n      }\n      r += T;\n    }\n    return r !== \"\" && e.push(r), e;\n  }, o.canBreakWords = function(t, e) {\n    return e;\n  }, o.canBreakChars = function(t, e, r, S, T) {\n    return !0;\n  }, o.wordWrapSplit = function(t) {\n    return t.split(\"\");\n  }, o.measureFont = function(t) {\n    if (o._fonts[t])\n      return o._fonts[t];\n    var e = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, r = o._canvas, S = o._context;\n    S.font = t;\n    var T = o.METRICS_STRING + o.BASELINE_SYMBOL, D = Math.ceil(S.measureText(T).width), N = Math.ceil(S.measureText(o.BASELINE_SYMBOL).width), B = Math.ceil(o.HEIGHT_MULTIPLIER * N);\n    N = N * o.BASELINE_MULTIPLIER | 0, r.width = D, r.height = B, S.fillStyle = \"#f00\", S.fillRect(0, 0, D, B), S.font = t, S.textBaseline = \"alphabetic\", S.fillStyle = \"#000\", S.fillText(T, 0, N);\n    var $ = S.getImageData(0, 0, D, B).data, U = $.length, V = D * 4, H = 0, X = 0, Y = !1;\n    for (H = 0; H < N; ++H) {\n      for (var W = 0; W < V; W += 4)\n        if ($[X + W] !== 255) {\n          Y = !0;\n          break;\n        }\n      if (!Y)\n        X += V;\n      else\n        break;\n    }\n    for (e.ascent = N - H, X = U - V, Y = !1, H = B; H > N; --H) {\n      for (var W = 0; W < V; W += 4)\n        if ($[X + W] !== 255) {\n          Y = !0;\n          break;\n        }\n      if (!Y)\n        X -= V;\n      else\n        break;\n    }\n    return e.descent = H - N, e.fontSize = e.ascent + e.descent, o._fonts[t] = e, e;\n  }, o.clearMetrics = function(t) {\n    t === void 0 && (t = \"\"), t ? delete o._fonts[t] : o._fonts = {};\n  }, Object.defineProperty(o, \"_canvas\", {\n    get: function() {\n      if (!o.__canvas) {\n        var t = void 0;\n        try {\n          var e = new OffscreenCanvas(0, 0), r = e.getContext(\"2d\", contextSettings);\n          if (r && r.measureText)\n            return o.__canvas = e, e;\n          t = settings.ADAPTER.createCanvas();\n        } catch {\n          t = settings.ADAPTER.createCanvas();\n        }\n        t.width = t.height = 10, o.__canvas = t;\n      }\n      return o.__canvas;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o, \"_context\", {\n    get: function() {\n      return o.__context || (o.__context = o._canvas.getContext(\"2d\", contextSettings)), o.__context;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o;\n}();\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|ÉqÅ\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, Text = function(o) {\n  __extends$j(t, o);\n  function t(e, r, S) {\n    var T = this, D = !1;\n    S || (S = settings.ADAPTER.createCanvas(), D = !0), S.width = 3, S.height = 3;\n    var N = Texture.from(S);\n    return N.orig = new Rectangle(), N.trim = new Rectangle(), T = o.call(this, N) || this, T._ownCanvas = D, T.canvas = S, T.context = S.getContext(\"2d\", {\n      willReadFrequently: !0\n    }), T._resolution = settings.RESOLUTION, T._autoResolution = !0, T._text = null, T._style = null, T._styleListener = null, T._font = \"\", T.text = e, T.style = r, T.localStyleID = -1, T;\n  }\n  return t.prototype.updateText = function(e) {\n    var r = this._style;\n    if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {\n      this._font = this._style.toFontString();\n      var S = this.context, T = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), D = T.width, N = T.height, B = T.lines, $ = T.lineHeight, U = T.lineWidths, V = T.maxLineWidth, H = T.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, D) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, N) + r.padding * 2) * this._resolution), S.scale(this._resolution, this._resolution), S.clearRect(0, 0, this.canvas.width, this.canvas.height), S.font = this._font, S.lineWidth = r.strokeThickness, S.textBaseline = r.textBaseline, S.lineJoin = r.lineJoin, S.miterLimit = r.miterLimit;\n      for (var X, Y, W = r.dropShadow ? 2 : 1, q = 0; q < W; ++q) {\n        var K = r.dropShadow && q === 0, Z = K ? Math.ceil(Math.max(1, N) + r.padding * 2) : 0, J = Z * this._resolution;\n        if (K) {\n          S.fillStyle = \"black\", S.strokeStyle = \"black\";\n          var Q = r.dropShadowColor, rt = hex2rgb(typeof Q == \"number\" ? Q : string2hex(Q)), et = r.dropShadowBlur * this._resolution, nt = r.dropShadowDistance * this._resolution;\n          S.shadowColor = \"rgba(\" + rt[0] * 255 + \",\" + rt[1] * 255 + \",\" + rt[2] * 255 + \",\" + r.dropShadowAlpha + \")\", S.shadowBlur = et, S.shadowOffsetX = Math.cos(r.dropShadowAngle) * nt, S.shadowOffsetY = Math.sin(r.dropShadowAngle) * nt + J;\n        } else\n          S.fillStyle = this._generateFillStyle(r, B, T), S.strokeStyle = r.stroke, S.shadowColor = \"black\", S.shadowBlur = 0, S.shadowOffsetX = 0, S.shadowOffsetY = 0;\n        var st = ($ - H.fontSize) / 2;\n        (!t.nextLineHeightBehavior || $ - H.fontSize < 0) && (st = 0);\n        for (var it = 0; it < B.length; it++)\n          X = r.strokeThickness / 2, Y = r.strokeThickness / 2 + it * $ + H.ascent + st, r.align === \"right\" ? X += V - U[it] : r.align === \"center\" && (X += (V - U[it]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(B[it], X + r.padding, Y + r.padding - Z, !0), r.fill && this.drawLetterSpacing(B[it], X + r.padding, Y + r.padding - Z);\n      }\n      this.updateTexture();\n    }\n  }, t.prototype.drawLetterSpacing = function(e, r, S, T) {\n    T === void 0 && (T = !1);\n    var D = this._style, N = D.letterSpacing, B = t.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n    if (N === 0 || B) {\n      B && (this.context.letterSpacing = N, this.context.textLetterSpacing = N), T ? this.context.strokeText(e, r, S) : this.context.fillText(e, r, S);\n      return;\n    }\n    for (var $ = r, U = Array.from ? Array.from(e) : e.split(\"\"), V = this.context.measureText(e).width, H = 0, X = 0; X < U.length; ++X) {\n      var Y = U[X];\n      T ? this.context.strokeText(Y, $, S) : this.context.fillText(Y, $, S);\n      for (var W = \"\", q = X + 1; q < U.length; ++q)\n        W += U[q];\n      H = this.context.measureText(W).width, $ += V - H + N, V = H;\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.canvas;\n    if (this._style.trim) {\n      var r = trimCanvas(e);\n      r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));\n    }\n    var S = this._texture, T = this._style, D = T.trim ? 0 : T.padding, N = S.baseTexture;\n    S.trim.width = S._frame.width = e.width / this._resolution, S.trim.height = S._frame.height = e.height / this._resolution, S.trim.x = -D, S.trim.y = -D, S.orig.width = S._frame.width - D * 2, S.orig.height = S._frame.height - D * 2, this._onTextureUpdate(), N.setRealSize(e.width, e.height, this._resolution), S.updateUvs(), this.dirty = !1;\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), o.prototype._render.call(this, e);\n  }, t.prototype.updateTransform = function() {\n    this.updateText(!0), o.prototype.updateTransform.call(this);\n  }, t.prototype.getBounds = function(e, r) {\n    return this.updateText(!0), this._textureID === -1 && (e = !1), o.prototype.getBounds.call(this, e, r);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.updateText(!0), o.prototype.getLocalBounds.call(this, e);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }, t.prototype._generateFillStyle = function(e, r, S) {\n    var T = e.fill;\n    if (Array.isArray(T)) {\n      if (T.length === 1)\n        return T[0];\n    } else\n      return T;\n    var D, N = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = this.canvas.width / this._resolution - N - B * 2, U = this.canvas.height / this._resolution - N - B * 2, V = T.slice(), H = e.fillGradientStops.slice();\n    if (!H.length)\n      for (var X = V.length + 1, Y = 1; Y < X; ++Y)\n        H.push(Y / X);\n    if (V.unshift(T[0]), H.unshift(0), V.push(T[T.length - 1]), H.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      D = this.context.createLinearGradient($ / 2, B, $ / 2, U + B);\n      for (var W = S.fontProperties.fontSize + e.strokeThickness, Y = 0; Y < r.length; Y++) {\n        var q = S.lineHeight * (Y - 1) + W, K = S.lineHeight * Y, Z = K;\n        Y > 0 && q > K && (Z = (K + q) / 2);\n        var J = K + W, Q = S.lineHeight * (Y + 1), rt = J;\n        Y + 1 < r.length && Q < J && (rt = (J + Q) / 2);\n        for (var et = (rt - Z) / U, nt = 0; nt < V.length; nt++) {\n          var st = 0;\n          typeof H[nt] == \"number\" ? st = H[nt] : st = nt / V.length;\n          var it = Math.min(1, Math.max(0, Z / U + st * et));\n          it = Number(it.toFixed(5)), D.addColorStop(it, V[nt]);\n        }\n      }\n    } else {\n      D = this.context.createLinearGradient(B, U / 2, $ + B, U / 2);\n      for (var at = V.length + 1, ut = 1, Y = 0; Y < V.length; Y++) {\n        var ct = void 0;\n        typeof H[Y] == \"number\" ? ct = H[Y] : ct = ut / at, D.addColorStop(ct, V[Y]), ut++;\n      }\n    }\n    return D;\n  }, t.prototype.destroy = function(e) {\n    typeof e == \"boolean\" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), o.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var r = sign(this.scale.x) || 1;\n      this.scale.x = r * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var r = sign(this.scale.y) || 1;\n      this.scale.y = r * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"style\", {\n    get: function() {\n      return this._style;\n    },\n    set: function(e) {\n      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;\n}(Sprite);\nsettings.UPLOADS_PER_FRAME = 4;\nvar extendStatics$i = function(o, t) {\n  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$i(o, t);\n};\nfunction __extends$i(o, t) {\n  extendStatics$i(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar CountLimiter = function() {\n  function o(t) {\n    this.maxItemsPerFrame = t, this.itemsLeft = 0;\n  }\n  return o.prototype.beginFrame = function() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }, o.prototype.allowedToUpload = function() {\n    return this.itemsLeft-- > 0;\n  }, o;\n}();\nfunction findMultipleBaseTextures(o, t) {\n  var e = !1;\n  if (o && o._textures && o._textures.length) {\n    for (var r = 0; r < o._textures.length; r++)\n      if (o._textures[r] instanceof Texture) {\n        var S = o._textures[r].baseTexture;\n        t.indexOf(S) === -1 && (t.push(S), e = !0);\n      }\n  }\n  return e;\n}\nfunction findBaseTexture(o, t) {\n  if (o.baseTexture instanceof BaseTexture) {\n    var e = o.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTexture(o, t) {\n  if (o._texture && o._texture instanceof Texture) {\n    var e = o._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction drawText(o, t) {\n  return t instanceof Text ? (t.updateText(!0), !0) : !1;\n}\nfunction calculateTextStyle(o, t) {\n  if (t instanceof TextStyle) {\n    var e = t.toFontString();\n    return TextMetrics.measureFont(e), !0;\n  }\n  return !1;\n}\nfunction findText(o, t) {\n  if (o instanceof Text) {\n    t.indexOf(o.style) === -1 && t.push(o.style), t.indexOf(o) === -1 && t.push(o);\n    var e = o._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTextStyle(o, t) {\n  return o instanceof TextStyle ? (t.indexOf(o) === -1 && t.push(o), !0) : !1;\n}\nvar BasePrepare = function() {\n  function o(t) {\n    var e = this;\n    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {\n      !e.queue || e.prepareItems();\n    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);\n  }\n  return o.prototype.upload = function(t, e) {\n    var r = this;\n    return typeof t == \"function\" && (e = t, t = null), e && deprecation(\"6.5.0\", \"BasePrepare.upload callback is deprecated, use the return Promise instead.\"), new Promise(function(S) {\n      t && r.add(t);\n      var T = function() {\n        e == null || e(), S();\n      };\n      r.queue.length ? (r.completes.push(T), r.ticking || (r.ticking = !0, Ticker.system.addOnce(r.tick, r, UPDATE_PRIORITY.UTILITY))) : T();\n    });\n  }, o.prototype.tick = function() {\n    setTimeout(this.delayedTick, 0);\n  }, o.prototype.prepareItems = function() {\n    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n      var t = this.queue[0], e = !1;\n      if (t && !t._destroyed) {\n        for (var r = 0, S = this.uploadHooks.length; r < S; r++)\n          if (this.uploadHooks[r](this.uploadHookHelper, t)) {\n            this.queue.shift(), e = !0;\n            break;\n          }\n      }\n      e || this.queue.shift();\n    }\n    if (this.queue.length)\n      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n    else {\n      this.ticking = !1;\n      var T = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var r = 0, S = T.length; r < S; r++)\n        T[r]();\n    }\n  }, o.prototype.registerFindHook = function(t) {\n    return t && this.addHooks.push(t), this;\n  }, o.prototype.registerUploadHook = function(t) {\n    return t && this.uploadHooks.push(t), this;\n  }, o.prototype.add = function(t) {\n    for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)\n      ;\n    if (t instanceof Container)\n      for (var e = t.children.length - 1; e >= 0; e--)\n        this.add(t.children[e]);\n    return this;\n  }, o.prototype.destroy = function() {\n    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n  }, o;\n}();\nfunction uploadBaseTextures(o, t) {\n  return t instanceof BaseTexture ? (t._glTextures[o.CONTEXT_UID] || o.texture.bind(t), !0) : !1;\n}\nfunction uploadGraphics(o, t) {\n  if (!(t instanceof Graphics))\n    return !1;\n  var e = t.geometry;\n  t.finishPoly(), e.updateBatches();\n  for (var r = e.batches, S = 0; S < r.length; S++) {\n    var T = r[S].style.texture;\n    T && uploadBaseTextures(o, T.baseTexture);\n  }\n  return e.batchable || o.geometry.bind(e, t._resolveDirectShader(o)), !0;\n}\nfunction findGraphics(o, t) {\n  return o instanceof Graphics ? (t.push(o), !0) : !1;\n}\nvar Prepare = function(o) {\n  __extends$i(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return r.uploadHookHelper = r.renderer, r.registerFindHook(findGraphics), r.registerUploadHook(uploadBaseTextures), r.registerUploadHook(uploadGraphics), r;\n  }\n  return t.extension = {\n    name: \"prepare\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(BasePrepare);\nvar Spritesheet = function() {\n  function o(t, e, r) {\n    r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;\n    var S = this.baseTexture.resource;\n    this.resolution = this._updateResolution(r || (S ? S.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n  }\n  return o.prototype._updateResolution = function(t) {\n    t === void 0 && (t = null);\n    var e = this.data.meta.scale, r = getResolutionOfUrl(t, null);\n    return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;\n  }, o.prototype.parse = function(t) {\n    var e = this;\n    return t && deprecation(\"6.5.0\", \"Spritesheet.parse callback is deprecated, use the return Promise instead.\"), new Promise(function(r) {\n      e._callback = function(S) {\n        t == null || t(S), r(S);\n      }, e._batchIndex = 0, e._frameKeys.length <= o.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();\n    });\n  }, o.prototype._processFrames = function(t) {\n    for (var e = t, r = o.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {\n      var S = this._frameKeys[e], T = this._frames[S], D = T.frame;\n      if (D) {\n        var N = null, B = null, $ = T.trimmed !== !1 && T.sourceSize ? T.sourceSize : T.frame, U = new Rectangle(0, 0, Math.floor($.w) / this.resolution, Math.floor($.h) / this.resolution);\n        T.rotated ? N = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.h) / this.resolution, Math.floor(D.w) / this.resolution) : N = new Rectangle(Math.floor(D.x) / this.resolution, Math.floor(D.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution), T.trimmed !== !1 && T.spriteSourceSize && (B = new Rectangle(Math.floor(T.spriteSourceSize.x) / this.resolution, Math.floor(T.spriteSourceSize.y) / this.resolution, Math.floor(D.w) / this.resolution, Math.floor(D.h) / this.resolution)), this.textures[S] = new Texture(this.baseTexture, N, U, B, T.rotated ? 2 : 0, T.anchor), Texture.addToCache(this.textures[S], S);\n      }\n      e++;\n    }\n  }, o.prototype._processAnimations = function() {\n    var t = this.data.animations || {};\n    for (var e in t) {\n      this.animations[e] = [];\n      for (var r = 0; r < t[e].length; r++) {\n        var S = t[e][r];\n        this.animations[e].push(this.textures[S]);\n      }\n    }\n  }, o.prototype._parseComplete = function() {\n    var t = this._callback;\n    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);\n  }, o.prototype._nextBatch = function() {\n    var t = this;\n    this._processFrames(this._batchIndex * o.BATCH_SIZE), this._batchIndex++, setTimeout(function() {\n      t._batchIndex * o.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());\n    }, 0);\n  }, o.prototype.destroy = function(t) {\n    var e;\n    t === void 0 && (t = !1);\n    for (var r in this.textures)\n      this.textures[r].destroy();\n    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n  }, o.BATCH_SIZE = 1e3, o;\n}(), SpritesheetLoader = function() {\n  function o() {\n  }\n  return o.use = function(t, e) {\n    var r, S, T = this, D = t.name + \"_image\";\n    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || T.resources[D]) {\n      e();\n      return;\n    }\n    var N = (S = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || S === void 0 ? void 0 : S.related_multi_packs;\n    if (Array.isArray(N))\n      for (var B = function(Y) {\n        if (typeof Y != \"string\")\n          return \"continue\";\n        var W = Y.replace(\".json\", \"\"), q = url$1.resolve(t.url.replace(T.baseUrl, \"\"), Y);\n        if (T.resources[W] || Object.values(T.resources).some(function(Z) {\n          return url$1.format(url$1.parse(Z.url)) === q;\n        }))\n          return \"continue\";\n        var K = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: t,\n          metadata: t.metadata\n        };\n        T.add(W, q, K);\n      }, $ = 0, U = N; $ < U.length; $++) {\n        var V = U[$];\n        B(V);\n      }\n    var H = {\n      crossOrigin: t.crossOrigin,\n      metadata: t.metadata.imageMetadata,\n      parentResource: t\n    }, X = o.getResourcePath(t, T.baseUrl);\n    T.add(D, X, H, function(W) {\n      if (W.error) {\n        e(W.error);\n        return;\n      }\n      var q = new Spritesheet(W.texture, t.data, t.url);\n      q.parse().then(function() {\n        t.spritesheet = q, t.textures = q.textures, e();\n      });\n    });\n  }, o.getResourcePath = function(t, e) {\n    return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, \"\"), t.data.meta.image);\n  }, o.extension = ExtensionType.Loader, o;\n}();\nvar extendStatics$h = function(o, t) {\n  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$h(o, t);\n};\nfunction __extends$h(o, t) {\n  extendStatics$h(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$1 = new Point();\n(function(o) {\n  __extends$h(t, o);\n  function t(e, r, S) {\n    r === void 0 && (r = 100), S === void 0 && (S = 100);\n    var T = o.call(this, e) || this;\n    return T.tileTransform = new Transform(), T._width = r, T._height = S, T.uvMatrix = T.texture.uvMatrix || new TextureMatrix(e), T.pluginName = \"tilingSprite\", T.uvRespectAnchor = !1, T;\n  }\n  return Object.defineProperty(t.prototype, \"clampMargin\", {\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(e) {\n      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tileScale\", {\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(e) {\n      this.tileTransform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tilePosition\", {\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(e) {\n      this.tileTransform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._onTextureUpdate = function() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }, t.prototype._render = function(e) {\n    var r = this._texture;\n    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));\n  }, t.prototype._calculateBounds = function() {\n    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, S = this._width * (1 - this._anchor._x), T = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, e, r, S, T);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$1);\n    var r = this._width, S = this._height, T = -r * this.anchor._x;\n    if (tempPoint$1.x >= T && tempPoint$1.x < T + r) {\n      var D = -S * this.anchor._y;\n      if (tempPoint$1.y >= D && tempPoint$1.y < D + S)\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;\n  }, t.from = function(e, r) {\n    var S = e instanceof Texture ? e : Texture.from(e, r);\n    return new t(S, r.width, r.height);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Sprite);\nvar fragmentSimpleSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`, gl1VertexSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl1FragmentSrc = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`, gl2VertexSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl2FragmentSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`, tempMat = new Matrix(), TilingSpriteRenderer = function(o) {\n  __extends$h(t, o);\n  function t(e) {\n    var r = o.call(this, e) || this;\n    return e.runners.contextChange.add(r), r.quad = new QuadUv(), r.state = State.for2d(), r;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer, r = { globals: e.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, r), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, r) : Shader.from(gl1VertexSrc, gl1FragmentSrc, r);\n  }, t.prototype.render = function(e) {\n    var r = this.renderer, S = this.quad, T = S.vertices;\n    T[0] = T[6] = e._width * -e.anchor.x, T[1] = T[3] = e._height * -e.anchor.y, T[2] = T[4] = e._width * (1 - e.anchor.x), T[5] = T[7] = e._height * (1 - e.anchor.y);\n    var D = e.uvRespectAnchor ? e.anchor.x : 0, N = e.uvRespectAnchor ? e.anchor.y : 0;\n    T = S.uvs, T[0] = T[6] = -D, T[1] = T[3] = -N, T[2] = T[4] = 1 - D, T[5] = T[7] = 1 - N, S.invalidate();\n    var B = e._texture, $ = B.baseTexture, U = $.alphaMode > 0, V = e.tileTransform.localTransform, H = e.uvMatrix, X = $.isPowerOfTwo && B.frame.width === $.width && B.frame.height === $.height;\n    X && ($._glTextures[r.CONTEXT_UID] ? X = $.wrapMode !== WRAP_MODES.CLAMP : $.wrapMode === WRAP_MODES.CLAMP && ($.wrapMode = WRAP_MODES.REPEAT));\n    var Y = X ? this.simpleShader : this.shader, W = B.width, q = B.height, K = e._width, Z = e._height;\n    tempMat.set(V.a * W / K, V.b * W / Z, V.c * q / K, V.d * q / Z, V.tx / K, V.ty / Z), tempMat.invert(), X ? tempMat.prepend(H.mapCoord) : (Y.uniforms.uMapCoord = H.mapCoord.toArray(!0), Y.uniforms.uClampFrame = H.uClampFrame, Y.uniforms.uClampOffset = H.uClampOffset), Y.uniforms.uTransform = tempMat.toArray(!0), Y.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, Y.uniforms.uColor, U), Y.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), Y.uniforms.uSampler = B, r.shader.bind(Y), r.geometry.bind(S), this.state.blendMode = correctBlendMode(e.blendMode, U), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }, t.extension = {\n    name: \"tilingSprite\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\nvar extendStatics$g = function(o, t) {\n  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$g(o, t);\n};\nfunction __extends$g(o, t) {\n  extendStatics$g(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar MeshBatchUvs = function() {\n  function o(t, e) {\n    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n  }\n  return o.prototype.update = function(t) {\n    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {\n      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n      var e = this.uvBuffer.data;\n      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;\n    }\n  }, o;\n}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(o) {\n  __extends$g(t, o);\n  function t(e, r, S, T) {\n    T === void 0 && (T = DRAW_MODES.TRIANGLES);\n    var D = o.call(this) || this;\n    return D.geometry = e, D.shader = r, D.state = S || State.for2d(), D.drawMode = T, D.start = 0, D.size = 0, D.uvs = null, D.indices = null, D.vertexData = new Float32Array(1), D.vertexDirty = -1, D._transformID = -1, D._roundPixels = settings.ROUND_PIXELS, D.batchUvs = null, D;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    set: function(e) {\n      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"uvBuffer\", {\n    get: function() {\n      return this.geometry.buffers[1];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"verticesBuffer\", {\n    get: function() {\n      return this.geometry.buffers[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"material\", {\n    get: function() {\n      return this.shader;\n    },\n    set: function(e) {\n      this.shader = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function(e) {\n      this.shader.tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function(e) {\n      this.shader.texture = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    var r = this.geometry.buffers[0].data, S = this.shader;\n    S.batchable && this.drawMode === DRAW_MODES.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);\n  }, t.prototype._renderDefault = function(e) {\n    var r = this.shader;\n    r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }, t.prototype._renderToBatch = function(e) {\n    var r = this.geometry, S = this.shader;\n    S.uvMatrix && (S.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = S._tintRGB, this._texture = S.texture;\n    var T = this.material.pluginName;\n    e.batch.setObjectRenderer(e.plugins[T]), e.plugins[T].render(this);\n  }, t.prototype.calculateVertices = function() {\n    var e = this.geometry, r = e.buffers[0], S = r.data, T = r._updateID;\n    if (!(T === this.vertexDirty && this._transformID === this.transform._worldID)) {\n      this._transformID = this.transform._worldID, this.vertexData.length !== S.length && (this.vertexData = new Float32Array(S.length));\n      for (var D = this.transform.worldTransform, N = D.a, B = D.b, $ = D.c, U = D.d, V = D.tx, H = D.ty, X = this.vertexData, Y = 0; Y < X.length / 2; Y++) {\n        var W = S[Y * 2], q = S[Y * 2 + 1];\n        X[Y * 2] = N * W + $ * q + V, X[Y * 2 + 1] = B * W + U * q + H;\n      }\n      if (this._roundPixels)\n        for (var K = settings.RESOLUTION, Y = 0; Y < X.length; ++Y)\n          X[Y] = Math.round((X[Y] * K | 0) / K);\n      this.vertexDirty = T;\n    }\n  }, t.prototype.calculateUvs = function() {\n    var e = this.geometry.buffers[1], r = this.shader;\n    r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }, t.prototype.containsPoint = function(e) {\n    if (!this.getBounds().contains(e.x, e.y))\n      return !1;\n    this.worldTransform.applyInverse(e, tempPoint);\n    for (var r = this.geometry.getBuffer(\"aVertexPosition\").data, S = tempPolygon.points, T = this.geometry.getIndex().data, D = T.length, N = this.drawMode === 4 ? 3 : 1, B = 0; B + 2 < D; B += N) {\n      var $ = T[B] * 2, U = T[B + 1] * 2, V = T[B + 2] * 2;\n      if (S[0] = r[$], S[1] = r[$ + 1], S[2] = r[U], S[3] = r[U + 1], S[4] = r[V], S[5] = r[V + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(Container), fragment$5 = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`, vertex$2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`, MeshMaterial = function(o) {\n  __extends$g(t, o);\n  function t(e, r) {\n    var S = this, T = {\n      uSampler: e,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    return r = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: \"batch\"\n    }, r), r.uniforms && Object.assign(T, r.uniforms), S = o.call(this, r.program || Program.from(vertex$2, fragment$5), T) || this, S._colorDirty = !1, S.uvMatrix = new TextureMatrix(e), S.batchable = r.program === void 0, S.pluginName = r.pluginName, S.tint = r.tint, S.alpha = r.alpha, S;\n  }\n  return Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.uniforms.uSampler;\n    },\n    set: function(e) {\n      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this._alpha;\n    },\n    set: function(e) {\n      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.update = function() {\n    if (this._colorDirty) {\n      this._colorDirty = !1;\n      var e = this.texture.baseTexture;\n      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);\n    }\n    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n  }, t;\n}(Shader), MeshGeometry = function(o) {\n  __extends$g(t, o);\n  function t(e, r, S) {\n    var T = o.call(this) || this, D = new Buffer$1(e), N = new Buffer$1(r, !0), B = new Buffer$1(S, !0, !0);\n    return T.addAttribute(\"aVertexPosition\", D, 2, !1, TYPES.FLOAT).addAttribute(\"aTextureCoord\", N, 2, !1, TYPES.FLOAT).addIndex(B), T._updateId = -1, T;\n  }\n  return Object.defineProperty(t.prototype, \"vertexDirtyId\", {\n    get: function() {\n      return this.buffers[0]._updateID;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Geometry);\nvar extendStatics$f = function(o, t) {\n  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$f(o, t);\n};\nfunction __extends$f(o, t) {\n  extendStatics$f(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar BitmapFontData = function() {\n  function o() {\n    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n  }\n  return o;\n}(), TextFormat = function() {\n  function o() {\n  }\n  return o.test = function(t) {\n    return typeof t == \"string\" && t.indexOf(\"info face=\") === 0;\n  }, o.parse = function(t) {\n    var e = t.match(/^[a-z]+\\s+.+$/gm), r = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (var S in e) {\n      var T = e[S].match(/^[a-z]+/gm)[0], D = e[S].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm), N = {};\n      for (var B in D) {\n        var $ = D[B].split(\"=\"), U = $[0], V = $[1].replace(/\"/gm, \"\"), H = parseFloat(V), X = isNaN(H) ? V : H;\n        N[U] = X;\n      }\n      r[T].push(N);\n    }\n    var Y = new BitmapFontData();\n    return r.info.forEach(function(W) {\n      return Y.info.push({\n        face: W.face,\n        size: parseInt(W.size, 10)\n      });\n    }), r.common.forEach(function(W) {\n      return Y.common.push({\n        lineHeight: parseInt(W.lineHeight, 10)\n      });\n    }), r.page.forEach(function(W) {\n      return Y.page.push({\n        id: parseInt(W.id, 10),\n        file: W.file\n      });\n    }), r.char.forEach(function(W) {\n      return Y.char.push({\n        id: parseInt(W.id, 10),\n        page: parseInt(W.page, 10),\n        x: parseInt(W.x, 10),\n        y: parseInt(W.y, 10),\n        width: parseInt(W.width, 10),\n        height: parseInt(W.height, 10),\n        xoffset: parseInt(W.xoffset, 10),\n        yoffset: parseInt(W.yoffset, 10),\n        xadvance: parseInt(W.xadvance, 10)\n      });\n    }), r.kerning.forEach(function(W) {\n      return Y.kerning.push({\n        first: parseInt(W.first, 10),\n        second: parseInt(W.second, 10),\n        amount: parseInt(W.amount, 10)\n      });\n    }), r.distanceField.forEach(function(W) {\n      return Y.distanceField.push({\n        distanceRange: parseInt(W.distanceRange, 10),\n        fieldType: W.fieldType\n      });\n    }), Y;\n  }, o;\n}(), XMLFormat = function() {\n  function o() {\n  }\n  return o.test = function(t) {\n    return t instanceof XMLDocument && t.getElementsByTagName(\"page\").length && t.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  }, o.parse = function(t) {\n    for (var e = new BitmapFontData(), r = t.getElementsByTagName(\"info\"), S = t.getElementsByTagName(\"common\"), T = t.getElementsByTagName(\"page\"), D = t.getElementsByTagName(\"char\"), N = t.getElementsByTagName(\"kerning\"), B = t.getElementsByTagName(\"distanceField\"), $ = 0; $ < r.length; $++)\n      e.info.push({\n        face: r[$].getAttribute(\"face\"),\n        size: parseInt(r[$].getAttribute(\"size\"), 10)\n      });\n    for (var $ = 0; $ < S.length; $++)\n      e.common.push({\n        lineHeight: parseInt(S[$].getAttribute(\"lineHeight\"), 10)\n      });\n    for (var $ = 0; $ < T.length; $++)\n      e.page.push({\n        id: parseInt(T[$].getAttribute(\"id\"), 10) || 0,\n        file: T[$].getAttribute(\"file\")\n      });\n    for (var $ = 0; $ < D.length; $++) {\n      var U = D[$];\n      e.char.push({\n        id: parseInt(U.getAttribute(\"id\"), 10),\n        page: parseInt(U.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(U.getAttribute(\"x\"), 10),\n        y: parseInt(U.getAttribute(\"y\"), 10),\n        width: parseInt(U.getAttribute(\"width\"), 10),\n        height: parseInt(U.getAttribute(\"height\"), 10),\n        xoffset: parseInt(U.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt(U.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt(U.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (var $ = 0; $ < N.length; $++)\n      e.kerning.push({\n        first: parseInt(N[$].getAttribute(\"first\"), 10),\n        second: parseInt(N[$].getAttribute(\"second\"), 10),\n        amount: parseInt(N[$].getAttribute(\"amount\"), 10)\n      });\n    for (var $ = 0; $ < B.length; $++)\n      e.distanceField.push({\n        fieldType: B[$].getAttribute(\"fieldType\"),\n        distanceRange: parseInt(B[$].getAttribute(\"distanceRange\"), 10)\n      });\n    return e;\n  }, o;\n}(), XMLStringFormat = function() {\n  function o() {\n  }\n  return o.test = function(t) {\n    if (typeof t == \"string\" && t.indexOf(\"<font>\") > -1) {\n      var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n      return XMLFormat.test(e);\n    }\n    return !1;\n  }, o.parse = function(t) {\n    var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n    return XMLFormat.parse(e);\n  }, o;\n}(), formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(o) {\n  for (var t = 0; t < formats.length; t++)\n    if (formats[t].test(o))\n      return formats[t];\n  return null;\n}\nfunction generateFillStyle(o, t, e, r, S, T) {\n  var D = e.fill;\n  if (Array.isArray(D)) {\n    if (D.length === 1)\n      return D[0];\n  } else\n    return D;\n  var N, B = e.dropShadow ? e.dropShadowDistance : 0, $ = e.padding || 0, U = o.width / r - B - $ * 2, V = o.height / r - B - $ * 2, H = D.slice(), X = e.fillGradientStops.slice();\n  if (!X.length)\n    for (var Y = H.length + 1, W = 1; W < Y; ++W)\n      X.push(W / Y);\n  if (H.unshift(D[0]), X.unshift(0), H.push(D[D.length - 1]), X.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    N = t.createLinearGradient(U / 2, $, U / 2, V + $);\n    for (var q = 0, K = T.fontProperties.fontSize + e.strokeThickness, Z = K / V, W = 0; W < S.length; W++)\n      for (var J = T.lineHeight * W, Q = 0; Q < H.length; Q++) {\n        var rt = 0;\n        typeof X[Q] == \"number\" ? rt = X[Q] : rt = Q / H.length;\n        var et = J / V + rt * Z, nt = Math.max(q, et);\n        nt = Math.min(nt, 1), N.addColorStop(nt, H[Q]), q = nt;\n      }\n  } else {\n    N = t.createLinearGradient($, V / 2, U + $, V / 2);\n    for (var st = H.length + 1, it = 1, W = 0; W < H.length; W++) {\n      var at = void 0;\n      typeof X[W] == \"number\" ? at = X[W] : at = it / st, N.addColorStop(at, H[W]), it++;\n    }\n  }\n  return N;\n}\nfunction drawGlyph(o, t, e, r, S, T, D) {\n  var N = e.text, B = e.fontProperties;\n  t.translate(r, S), t.scale(T, T);\n  var $ = D.strokeThickness / 2, U = -(D.strokeThickness / 2);\n  if (t.font = D.toFontString(), t.lineWidth = D.strokeThickness, t.textBaseline = D.textBaseline, t.lineJoin = D.lineJoin, t.miterLimit = D.miterLimit, t.fillStyle = generateFillStyle(o, t, D, T, [N], e), t.strokeStyle = D.stroke, D.dropShadow) {\n    var V = D.dropShadowColor, H = hex2rgb(typeof V == \"number\" ? V : string2hex(V)), X = D.dropShadowBlur * T, Y = D.dropShadowDistance * T;\n    t.shadowColor = \"rgba(\" + H[0] * 255 + \",\" + H[1] * 255 + \",\" + H[2] * 255 + \",\" + D.dropShadowAlpha + \")\", t.shadowBlur = X, t.shadowOffsetX = Math.cos(D.dropShadowAngle) * Y, t.shadowOffsetY = Math.sin(D.dropShadowAngle) * Y;\n  } else\n    t.shadowColor = \"black\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;\n  D.stroke && D.strokeThickness && t.strokeText(N, $, U + e.lineHeight - B.descent), D.fill && t.fillText(N, $, U + e.lineHeight - B.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction splitTextToCharacters(o) {\n  return Array.from ? Array.from(o) : o.split(\"\");\n}\nfunction resolveCharacters(o) {\n  typeof o == \"string\" && (o = [o]);\n  for (var t = [], e = 0, r = o.length; e < r; e++) {\n    var S = o[e];\n    if (Array.isArray(S)) {\n      if (S.length !== 2)\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + S.length + \".\");\n      var T = S[0].charCodeAt(0), D = S[1].charCodeAt(0);\n      if (D < T)\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      for (var N = T, B = D; N <= B; N++)\n        t.push(String.fromCharCode(N));\n    } else\n      t.push.apply(t, splitTextToCharacters(S));\n  }\n  if (t.length === 0)\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  return t;\n}\nfunction extractCharCode(o) {\n  return o.codePointAt ? o.codePointAt(0) : o.charCodeAt(0);\n}\nvar BitmapFont = function() {\n  function o(t, e, r) {\n    var S, T, D = t.info[0], N = t.common[0], B = t.page[0], $ = t.distanceField[0], U = getResolutionOfUrl(B.file), V = {};\n    this._ownsTextures = r, this.font = D.face, this.size = D.size, this.lineHeight = N.lineHeight / U, this.chars = {}, this.pageTextures = V;\n    for (var H = 0; H < t.page.length; H++) {\n      var X = t.page[H], Y = X.id, W = X.file;\n      V[Y] = e instanceof Array ? e[H] : e[W], ($ == null ? void 0 : $.fieldType) && $.fieldType !== \"none\" && (V[Y].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, V[Y].baseTexture.mipmap = MIPMAP_MODES.OFF);\n    }\n    for (var H = 0; H < t.char.length; H++) {\n      var q = t.char[H], Y = q.id, K = q.page, Z = t.char[H], J = Z.x, Q = Z.y, rt = Z.width, et = Z.height, nt = Z.xoffset, st = Z.yoffset, it = Z.xadvance;\n      J /= U, Q /= U, rt /= U, et /= U, nt /= U, st /= U, it /= U;\n      var at = new Rectangle(J + V[K].frame.x / U, Q + V[K].frame.y / U, rt, et);\n      this.chars[Y] = {\n        xOffset: nt,\n        yOffset: st,\n        xAdvance: it,\n        kerning: {},\n        texture: new Texture(V[K].baseTexture, at),\n        page: K\n      };\n    }\n    for (var H = 0; H < t.kerning.length; H++) {\n      var ut = t.kerning[H], ct = ut.first, gt = ut.second, _t = ut.amount;\n      ct /= U, gt /= U, _t /= U, this.chars[gt] && (this.chars[gt].kerning[ct] = _t);\n    }\n    this.distanceFieldRange = $ == null ? void 0 : $.distanceRange, this.distanceFieldType = (T = (S = $ == null ? void 0 : $.fieldType) === null || S === void 0 ? void 0 : S.toLowerCase()) !== null && T !== void 0 ? T : \"none\";\n  }\n  return o.prototype.destroy = function() {\n    for (var t in this.chars)\n      this.chars[t].texture.destroy(), this.chars[t].texture = null;\n    for (var t in this.pageTextures)\n      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;\n    this.chars = null, this.pageTextures = null;\n  }, o.install = function(t, e, r) {\n    var S;\n    if (t instanceof BitmapFontData)\n      S = t;\n    else {\n      var T = autoDetectFormat(t);\n      if (!T)\n        throw new Error(\"Unrecognized data format for font.\");\n      S = T.parse(t);\n    }\n    e instanceof Texture && (e = [e]);\n    var D = new o(S, e, r);\n    return o.available[D.font] = D, D;\n  }, o.uninstall = function(t) {\n    var e = o.available[t];\n    if (!e)\n      throw new Error(\"No font found named '\" + t + \"'\");\n    e.destroy(), delete o.available[t];\n  }, o.from = function(t, e, r) {\n    if (!t)\n      throw new Error(\"[BitmapFont] Property `name` is required.\");\n    var S = Object.assign({}, o.defaultOptions, r), T = S.chars, D = S.padding, N = S.resolution, B = S.textureWidth, $ = S.textureHeight, U = resolveCharacters(T), V = e instanceof TextStyle ? e : new TextStyle(e), H = B, X = new BitmapFontData();\n    X.info[0] = {\n      face: V.fontFamily,\n      size: V.fontSize\n    }, X.common[0] = {\n      lineHeight: V.fontSize\n    };\n    for (var Y = 0, W = 0, q, K, Z, J = 0, Q = [], rt = 0; rt < U.length; rt++) {\n      q || (q = settings.ADAPTER.createCanvas(), q.width = B, q.height = $, K = q.getContext(\"2d\"), Z = new BaseTexture(q, { resolution: N }), Q.push(new Texture(Z)), X.page.push({\n        id: Q.length - 1,\n        file: \"\"\n      }));\n      var et = U[rt], nt = TextMetrics.measureText(et, V, !1, q), st = nt.width, it = Math.ceil(nt.height), at = Math.ceil((V.fontStyle === \"italic\" ? 2 : 1) * st);\n      if (W >= $ - it * N) {\n        if (W === 0)\n          throw new Error(\"[BitmapFont] textureHeight \" + $ + \"px is too small \" + (\"(fontFamily: '\" + V.fontFamily + \"', fontSize: \" + V.fontSize + \"px, char: '\" + et + \"')\"));\n        --rt, q = null, K = null, Z = null, W = 0, Y = 0, J = 0;\n        continue;\n      }\n      if (J = Math.max(it + nt.fontProperties.descent, J), at * N + Y >= H) {\n        if (Y === 0)\n          throw new Error(\"[BitmapFont] textureWidth \" + B + \"px is too small \" + (\"(fontFamily: '\" + V.fontFamily + \"', fontSize: \" + V.fontSize + \"px, char: '\" + et + \"')\"));\n        --rt, W += J * N, W = Math.ceil(W), Y = 0, J = 0;\n        continue;\n      }\n      drawGlyph(q, K, nt, Y, W, N, V);\n      var ut = extractCharCode(nt.text);\n      X.char.push({\n        id: ut,\n        page: Q.length - 1,\n        x: Y / N,\n        y: W / N,\n        width: at,\n        height: it,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: Math.ceil(st - (V.dropShadow ? V.dropShadowDistance : 0) - (V.stroke ? V.strokeThickness : 0))\n      }), Y += (at + 2 * D) * N, Y = Math.ceil(Y);\n    }\n    for (var rt = 0, ct = U.length; rt < ct; rt++)\n      for (var gt = U[rt], _t = 0; _t < ct; _t++) {\n        var vt = U[_t], mt = K.measureText(gt).width, bt = K.measureText(vt).width, Ct = K.measureText(gt + vt).width, St = Ct - (mt + bt);\n        St && X.kerning.push({\n          first: extractCharCode(gt),\n          second: extractCharCode(vt),\n          amount: St\n        });\n      }\n    var pt = new o(X, Q, !0);\n    return o.available[t] !== void 0 && o.uninstall(t), o.available[t] = pt, pt;\n  }, o.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"], o.NUMERIC = [[\"0\", \"9\"]], o.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"], o.ASCII = [[\" \", \"~\"]], o.defaultOptions = {\n    resolution: 1,\n    textureWidth: 512,\n    textureHeight: 512,\n    padding: 4,\n    chars: o.ALPHANUMERIC\n  }, o.available = {}, o;\n}(), msdfFrag = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n  if (median < 0.01) {\\r\n    alpha = 0.0;\\r\n  } else if (median > 0.99) {\\r\n    alpha = 1.0;\\r\n  }\\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\n\\r\n}\\r\n`, msdfVert = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];\n(function(o) {\n  __extends$f(t, o);\n  function t(e, r) {\n    r === void 0 && (r = {});\n    var S = o.call(this) || this;\n    S._tint = 16777215;\n    var T = Object.assign({}, t.styleDefaults, r), D = T.align, N = T.tint, B = T.maxWidth, $ = T.letterSpacing, U = T.fontName, V = T.fontSize;\n    if (!BitmapFont.available[U])\n      throw new Error('Missing BitmapFont \"' + U + '\"');\n    return S._activePagesMeshData = [], S._textWidth = 0, S._textHeight = 0, S._align = D, S._tint = N, S._font = void 0, S._fontName = U, S._fontSize = V, S.text = e, S._maxWidth = B, S._maxLineHeight = 0, S._letterSpacing = $, S._anchor = new ObservablePoint(function() {\n      S.dirty = !0;\n    }, S, 0, 0), S._roundPixels = settings.ROUND_PIXELS, S.dirty = !0, S._resolution = settings.RESOLUTION, S._autoResolution = !0, S._textureCache = {}, S;\n  }\n  return t.prototype.updateText = function() {\n    for (var e, r = BitmapFont.available[this._fontName], S = this.fontSize, T = S / r.size, D = new Point(), N = [], B = [], $ = [], U = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \", V = splitTextToCharacters(U), H = this._maxWidth * r.size / S, X = r.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, Y = null, W = 0, q = 0, K = 0, Z = -1, J = 0, Q = 0, rt = 0, et = 0, nt = 0; nt < V.length; nt++) {\n      var st = V[nt], it = extractCharCode(st);\n      if (/(?:\\s)/.test(st) && (Z = nt, J = W, et++), st === \"\\r\" || st === `\n`) {\n        B.push(W), $.push(-1), q = Math.max(q, W), ++K, ++Q, D.x = 0, D.y += r.lineHeight, Y = null, et = 0;\n        continue;\n      }\n      var at = r.chars[it];\n      if (!!at) {\n        Y && at.kerning[Y] && (D.x += at.kerning[Y]);\n        var ut = charRenderDataPool.pop() || {\n          texture: Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new Point()\n        };\n        ut.texture = at.texture, ut.line = K, ut.charCode = it, ut.position.x = D.x + at.xOffset + this._letterSpacing / 2, ut.position.y = D.y + at.yOffset, ut.prevSpaces = et, N.push(ut), W = ut.position.x + Math.max(at.xAdvance - at.xOffset, at.texture.orig.width), D.x += at.xAdvance + this._letterSpacing, rt = Math.max(rt, at.yOffset + at.texture.height), Y = it, Z !== -1 && H > 0 && D.x > H && (++Q, removeItems(N, 1 + Z - Q, 1 + nt - Z), nt = Z, Z = -1, B.push(J), $.push(N.length > 0 ? N[N.length - 1].prevSpaces : 0), q = Math.max(q, J), K++, D.x = 0, D.y += r.lineHeight, Y = null, et = 0);\n      }\n    }\n    var ct = V[V.length - 1];\n    ct !== \"\\r\" && ct !== `\n` && (/(?:\\s)/.test(ct) && (W = J), B.push(W), q = Math.max(q, W), $.push(-1));\n    for (var gt = [], nt = 0; nt <= K; nt++) {\n      var _t = 0;\n      this._align === \"right\" ? _t = q - B[nt] : this._align === \"center\" ? _t = (q - B[nt]) / 2 : this._align === \"justify\" && (_t = $[nt] < 0 ? 0 : (q - B[nt]) / $[nt]), gt.push(_t);\n    }\n    var vt = N.length, mt = {}, bt = [], Ct = this._activePagesMeshData;\n    X.push.apply(X, Ct);\n    for (var nt = 0; nt < vt; nt++) {\n      var St = N[nt].texture, pt = St.baseTexture.uid;\n      if (!mt[pt]) {\n        var yt = X.pop();\n        if (!yt) {\n          var At = new MeshGeometry(), Dt = void 0, Ot = void 0;\n          r.distanceFieldType === \"none\" ? (Dt = new MeshMaterial(Texture.EMPTY), Ot = BLEND_MODES.NORMAL) : (Dt = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), Ot = BLEND_MODES.NORMAL_NPM);\n          var Pt = new Mesh(At, Dt);\n          Pt.blendMode = Ot, yt = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh: Pt,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        yt.index = 0, yt.indexCount = 0, yt.vertexCount = 0, yt.uvsCount = 0, yt.total = 0;\n        var ft = this._textureCache;\n        ft[pt] = ft[pt] || new Texture(St.baseTexture), yt.mesh.texture = ft[pt], yt.mesh.tint = this._tint, bt.push(yt), mt[pt] = yt;\n      }\n      mt[pt].total++;\n    }\n    for (var nt = 0; nt < Ct.length; nt++)\n      bt.indexOf(Ct[nt]) === -1 && this.removeChild(Ct[nt].mesh);\n    for (var nt = 0; nt < bt.length; nt++)\n      bt[nt].mesh.parent !== this && this.addChild(bt[nt].mesh);\n    this._activePagesMeshData = bt;\n    for (var nt in mt) {\n      var yt = mt[nt], Ft = yt.total;\n      if (!(((e = yt.indices) === null || e === void 0 ? void 0 : e.length) > 6 * Ft) || yt.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n        yt.vertices = new Float32Array(4 * 2 * Ft), yt.uvs = new Float32Array(4 * 2 * Ft), yt.indices = new Uint16Array(6 * Ft);\n      else\n        for (var It = yt.total, zt = yt.vertices, kt = It * 4 * 2; kt < zt.length; kt++)\n          zt[kt] = 0;\n      yt.mesh.size = 6 * Ft;\n    }\n    for (var nt = 0; nt < vt; nt++) {\n      var st = N[nt], Tt = st.position.x + gt[st.line] * (this._align === \"justify\" ? st.prevSpaces : 1);\n      this._roundPixels && (Tt = Math.round(Tt));\n      var jt = Tt * T, Nt = st.position.y * T, St = st.texture, Et = mt[St.baseTexture.uid], Lt = St.frame, Ht = St._uvs, wt = Et.index++;\n      Et.indices[wt * 6 + 0] = 0 + wt * 4, Et.indices[wt * 6 + 1] = 1 + wt * 4, Et.indices[wt * 6 + 2] = 2 + wt * 4, Et.indices[wt * 6 + 3] = 0 + wt * 4, Et.indices[wt * 6 + 4] = 2 + wt * 4, Et.indices[wt * 6 + 5] = 3 + wt * 4, Et.vertices[wt * 8 + 0] = jt, Et.vertices[wt * 8 + 1] = Nt, Et.vertices[wt * 8 + 2] = jt + Lt.width * T, Et.vertices[wt * 8 + 3] = Nt, Et.vertices[wt * 8 + 4] = jt + Lt.width * T, Et.vertices[wt * 8 + 5] = Nt + Lt.height * T, Et.vertices[wt * 8 + 6] = jt, Et.vertices[wt * 8 + 7] = Nt + Lt.height * T, Et.uvs[wt * 8 + 0] = Ht.x0, Et.uvs[wt * 8 + 1] = Ht.y0, Et.uvs[wt * 8 + 2] = Ht.x1, Et.uvs[wt * 8 + 3] = Ht.y1, Et.uvs[wt * 8 + 4] = Ht.x2, Et.uvs[wt * 8 + 5] = Ht.y2, Et.uvs[wt * 8 + 6] = Ht.x3, Et.uvs[wt * 8 + 7] = Ht.y3;\n    }\n    this._textWidth = q * T, this._textHeight = (D.y + r.lineHeight) * T;\n    for (var nt in mt) {\n      var yt = mt[nt];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        for (var Wt = 0, ee = this._textWidth * this.anchor.x, Jt = this._textHeight * this.anchor.y, xe = 0; xe < yt.total; xe++)\n          yt.vertices[Wt++] -= ee, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= ee, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= ee, yt.vertices[Wt++] -= Jt, yt.vertices[Wt++] -= ee, yt.vertices[Wt++] -= Jt;\n      this._maxLineHeight = rt * T;\n      var ke = yt.mesh.geometry.getBuffer(\"aVertexPosition\"), ue = yt.mesh.geometry.getBuffer(\"aTextureCoord\"), me = yt.mesh.geometry.getIndex();\n      ke.data = yt.vertices, ue.data = yt.uvs, me.data = yt.indices, ke.update(), ue.update(), me.update();\n    }\n    for (var nt = 0; nt < N.length; nt++)\n      charRenderDataPool.push(N[nt]);\n    this._font = r, this.dirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.validate(), this.containerUpdateTransform();\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);\n    var r = BitmapFont.available[this._fontName], S = r.distanceFieldRange, T = r.distanceFieldType, D = r.size;\n    if (T !== \"none\")\n      for (var N = this.worldTransform, B = N.a, $ = N.b, U = N.c, V = N.d, H = Math.sqrt(B * B + $ * $), X = Math.sqrt(U * U + V * V), Y = (Math.abs(H) + Math.abs(X)) / 2, W = this.fontSize / D, q = 0, K = this._activePagesMeshData; q < K.length; q++) {\n        var Z = K[q];\n        Z.mesh.shader.uniforms.uFWidth = Y * S * W * this._resolution;\n      }\n    o.prototype._render.call(this, e);\n  }, t.prototype.getLocalBounds = function() {\n    return this.validate(), o.prototype.getLocalBounds.call(this);\n  }, t.prototype.validate = function() {\n    var e = BitmapFont.available[this._fontName];\n    if (!e)\n      throw new Error('Missing BitmapFont \"' + this._fontName + '\"');\n    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      if (this._tint !== e) {\n        this._tint = e;\n        for (var r = 0; r < this._activePagesMeshData.length; r++)\n          this._activePagesMeshData[r].mesh.tint = e;\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(e) {\n      this._align !== e && (this._align = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontName\", {\n    get: function() {\n      return this._fontName;\n    },\n    set: function(e) {\n      if (!BitmapFont.available[e])\n        throw new Error('Missing BitmapFont \"' + e + '\"');\n      this._fontName !== e && (this._fontName = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontSize\", {\n    get: function() {\n      var e;\n      return (e = this._fontSize) !== null && e !== void 0 ? e : BitmapFont.available[this._fontName].size;\n    },\n    set: function(e) {\n      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      typeof e == \"number\" ? this._anchor.set(e) : this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxWidth\", {\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(e) {\n      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxLineHeight\", {\n    get: function() {\n      return this.validate(), this._maxLineHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textWidth\", {\n    get: function() {\n      return this.validate(), this._textWidth;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(e) {\n      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textHeight\", {\n    get: function() {\n      return this.validate(), this._textHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.destroy = function(e) {\n    var r = this._textureCache, S = BitmapFont.available[this._fontName], T = S.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    T.push.apply(T, this._activePagesMeshData);\n    for (var D = 0, N = this._activePagesMeshData; D < N.length; D++) {\n      var B = N[D];\n      this.removeChild(B.mesh);\n    }\n    this._activePagesMeshData = [], T.filter(function(V) {\n      return r[V.mesh.texture.baseTexture.uid];\n    }).forEach(function(V) {\n      V.mesh.texture = Texture.EMPTY;\n    });\n    for (var $ in r) {\n      var U = r[$];\n      U.destroy(), delete r[$];\n    }\n    this._font = null, this._textureCache = null, o.prototype.destroy.call(this, e);\n  }, t.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  }, t;\n})(Container);\nvar BitmapFontLoader = function() {\n  function o() {\n  }\n  return o.add = function() {\n    LoaderResource.setExtensionXhrType(\"fnt\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, o.use = function(t, e) {\n    var r = autoDetectFormat(t.data);\n    if (!r) {\n      e();\n      return;\n    }\n    for (var S = o.getBaseUrl(this, t), T = r.parse(t.data), D = {}, N = function(W) {\n      D[W.metadata.pageFile] = W.texture, Object.keys(D).length === T.page.length && (t.bitmapFont = BitmapFont.install(T, D, !0), e());\n    }, B = 0; B < T.page.length; ++B) {\n      var $ = T.page[B].file, U = S + $, V = !1;\n      for (var H in this.resources) {\n        var X = this.resources[H];\n        if (X.url === U) {\n          X.metadata.pageFile = $, X.texture ? N(X) : X.onAfterMiddleware.add(N), V = !0;\n          break;\n        }\n      }\n      if (!V) {\n        var Y = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.IMAGE,\n          metadata: Object.assign({ pageFile: $ }, t.metadata.imageMetadata),\n          parentResource: t\n        };\n        this.add(U, Y, N);\n      }\n    }\n  }, o.getBaseUrl = function(t, e) {\n    var r = e.isDataUrl ? \"\" : o.dirname(e.url);\n    return e.isDataUrl && (r === \".\" && (r = \"\"), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === \"/\" && (r += \"/\")), r = r.replace(t.baseUrl, \"\"), r && r.charAt(r.length - 1) !== \"/\" && (r += \"/\"), r;\n  }, o.dirname = function(t) {\n    var e = t.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n    return e === t ? \".\" : e === \"\" ? \"/\" : e;\n  }, o.extension = ExtensionType.Loader, o;\n}();\nvar extendStatics$e = function(o, t) {\n  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$e(o, t);\n};\nfunction __extends$e(o, t) {\n  extendStatics$e(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$4 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n(function(o) {\n  __extends$e(t, o);\n  function t(e) {\n    e === void 0 && (e = 1);\n    var r = o.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;\n    return r.alpha = e, r;\n  }\n  return Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\nvar extendStatics$d = function(o, t) {\n  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$d(o, t);\n};\nfunction __extends$d(o, t) {\n  extendStatics$d(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(o, t) {\n  var e = Math.ceil(o / 2), r = vertTemplate, S = \"\", T;\n  t ? T = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\" : T = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  for (var D = 0; D < o; D++) {\n    var N = T.replace(\"%index%\", D.toString());\n    N = N.replace(\"%sampleIndex%\", D - (e - 1) + \".0\"), S += N, S += `\n`;\n  }\n  return r = r.replace(\"%blur%\", S), r = r.replace(\"%size%\", o.toString()), r;\n}\nvar GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, fragTemplate = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(`\n`);\nfunction generateBlurFragSource(o) {\n  for (var t = GAUSSIAN_VALUES[o], e = t.length, r = fragTemplate, S = \"\", T = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\", D, N = 0; N < o; N++) {\n    var B = T.replace(\"%index%\", N.toString());\n    D = N, N >= e && (D = o - N - 1), B = B.replace(\"%value%\", t[D].toString()), S += B, S += `\n`;\n  }\n  return r = r.replace(\"%blur%\", S), r = r.replace(\"%size%\", o.toString()), r;\n}\nvar BlurFilterPass = function(o) {\n  __extends$d(t, o);\n  function t(e, r, S, T, D) {\n    r === void 0 && (r = 8), S === void 0 && (S = 4), T === void 0 && (T = settings.FILTER_RESOLUTION), D === void 0 && (D = 5);\n    var N = this, B = generateBlurVertSource(D, e), $ = generateBlurFragSource(D);\n    return N = o.call(\n      this,\n      B,\n      $\n    ) || this, N.horizontal = e, N.resolution = T, N._quality = 0, N.quality = S, N.blur = r, N;\n  }\n  return t.prototype.apply = function(e, r, S, T) {\n    if (S ? this.horizontal ? this.uniforms.strength = 1 / S.width * (S.width / r.width) : this.uniforms.strength = 1 / S.height * (S.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n      e.applyFilter(this, r, S, T);\n    else {\n      var D = e.getFilterTexture(), N = e.renderer, B = r, $ = D;\n      this.state.blend = !1, e.applyFilter(this, B, $, CLEAR_MODES.CLEAR);\n      for (var U = 1; U < this.passes - 1; U++) {\n        e.bindAndClear(B, CLEAR_MODES.BLIT), this.uniforms.uSampler = $;\n        var V = $;\n        $ = B, B = V, N.shader.bind(this), N.geometry.draw(5);\n      }\n      this.state.blend = !0, e.applyFilter(this, $, S, T), e.returnFilterTexture(D);\n    }\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.strength;\n    },\n    set: function(e) {\n      this.padding = 1 + Math.abs(e) * 2, this.strength = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this._quality;\n    },\n    set: function(e) {\n      this._quality = e, this.passes = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\n(function(o) {\n  __extends$d(t, o);\n  function t(e, r, S, T) {\n    e === void 0 && (e = 8), r === void 0 && (r = 4), S === void 0 && (S = settings.FILTER_RESOLUTION), T === void 0 && (T = 5);\n    var D = o.call(this) || this;\n    return D.blurXFilter = new BlurFilterPass(!0, e, r, S, T), D.blurYFilter = new BlurFilterPass(!1, e, r, S, T), D.resolution = S, D.quality = r, D.blur = e, D.repeatEdgePixels = !1, D;\n  }\n  return t.prototype.apply = function(e, r, S, T) {\n    var D = Math.abs(this.blurXFilter.strength), N = Math.abs(this.blurYFilter.strength);\n    if (D && N) {\n      var B = e.getFilterTexture();\n      this.blurXFilter.apply(e, r, B, CLEAR_MODES.CLEAR), this.blurYFilter.apply(e, B, S, T), e.returnFilterTexture(B);\n    } else\n      N ? this.blurYFilter.apply(e, r, S, T) : this.blurXFilter.apply(e, r, S, T);\n  }, t.prototype.updatePadding = function() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(e) {\n      this.blurXFilter.quality = this.blurYFilter.quality = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurX\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurY\", {\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(e) {\n      this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(e) {\n      this.blurYFilter.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"repeatEdgePixels\", {\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(e) {\n      this._repeatEdgePixels = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\nvar extendStatics$c = function(o, t) {\n  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$c(o, t);\n};\nfunction __extends$c(o, t) {\n  extendStatics$c(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$3 = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`, ColorMatrixFilter = function(o) {\n  __extends$c(t, o);\n  function t() {\n    var e = this, r = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    return e = o.call(this, defaultFilterVertex, fragment$3, r) || this, e.alpha = 1, e;\n  }\n  return t.prototype._loadMatrix = function(e, r) {\n    r === void 0 && (r = !1);\n    var S = e;\n    r && (this._multiply(S, this.uniforms.m, e), S = this._colorMatrix(S)), this.uniforms.m = S;\n  }, t.prototype._multiply = function(e, r, S) {\n    return e[0] = r[0] * S[0] + r[1] * S[5] + r[2] * S[10] + r[3] * S[15], e[1] = r[0] * S[1] + r[1] * S[6] + r[2] * S[11] + r[3] * S[16], e[2] = r[0] * S[2] + r[1] * S[7] + r[2] * S[12] + r[3] * S[17], e[3] = r[0] * S[3] + r[1] * S[8] + r[2] * S[13] + r[3] * S[18], e[4] = r[0] * S[4] + r[1] * S[9] + r[2] * S[14] + r[3] * S[19] + r[4], e[5] = r[5] * S[0] + r[6] * S[5] + r[7] * S[10] + r[8] * S[15], e[6] = r[5] * S[1] + r[6] * S[6] + r[7] * S[11] + r[8] * S[16], e[7] = r[5] * S[2] + r[6] * S[7] + r[7] * S[12] + r[8] * S[17], e[8] = r[5] * S[3] + r[6] * S[8] + r[7] * S[13] + r[8] * S[18], e[9] = r[5] * S[4] + r[6] * S[9] + r[7] * S[14] + r[8] * S[19] + r[9], e[10] = r[10] * S[0] + r[11] * S[5] + r[12] * S[10] + r[13] * S[15], e[11] = r[10] * S[1] + r[11] * S[6] + r[12] * S[11] + r[13] * S[16], e[12] = r[10] * S[2] + r[11] * S[7] + r[12] * S[12] + r[13] * S[17], e[13] = r[10] * S[3] + r[11] * S[8] + r[12] * S[13] + r[13] * S[18], e[14] = r[10] * S[4] + r[11] * S[9] + r[12] * S[14] + r[13] * S[19] + r[14], e[15] = r[15] * S[0] + r[16] * S[5] + r[17] * S[10] + r[18] * S[15], e[16] = r[15] * S[1] + r[16] * S[6] + r[17] * S[11] + r[18] * S[16], e[17] = r[15] * S[2] + r[16] * S[7] + r[17] * S[12] + r[18] * S[17], e[18] = r[15] * S[3] + r[16] * S[8] + r[17] * S[13] + r[18] * S[18], e[19] = r[15] * S[4] + r[16] * S[9] + r[17] * S[14] + r[18] * S[19] + r[19], e;\n  }, t.prototype._colorMatrix = function(e) {\n    var r = new Float32Array(e);\n    return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;\n  }, t.prototype.brightness = function(e, r) {\n    var S = [\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(S, r);\n  }, t.prototype.tint = function(e, r) {\n    var S = e >> 16 & 255, T = e >> 8 & 255, D = e & 255, N = [\n      S / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      T / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      D / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(N, r);\n  }, t.prototype.greyscale = function(e, r) {\n    var S = [\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(S, r);\n  }, t.prototype.blackAndWhite = function(e) {\n    var r = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.hue = function(e, r) {\n    e = (e || 0) / 180 * Math.PI;\n    var S = Math.cos(e), T = Math.sin(e), D = Math.sqrt, N = 1 / 3, B = D(N), $ = S + (1 - S) * N, U = N * (1 - S) - B * T, V = N * (1 - S) + B * T, H = N * (1 - S) + B * T, X = S + N * (1 - S), Y = N * (1 - S) - B * T, W = N * (1 - S) - B * T, q = N * (1 - S) + B * T, K = S + N * (1 - S), Z = [\n      $,\n      U,\n      V,\n      0,\n      0,\n      H,\n      X,\n      Y,\n      0,\n      0,\n      W,\n      q,\n      K,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(Z, r);\n  }, t.prototype.contrast = function(e, r) {\n    var S = (e || 0) + 1, T = -0.5 * (S - 1), D = [\n      S,\n      0,\n      0,\n      0,\n      T,\n      0,\n      S,\n      0,\n      0,\n      T,\n      0,\n      0,\n      S,\n      0,\n      T,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(D, r);\n  }, t.prototype.saturate = function(e, r) {\n    e === void 0 && (e = 0);\n    var S = e * 2 / 3 + 1, T = (S - 1) * -0.5, D = [\n      S,\n      T,\n      T,\n      0,\n      0,\n      T,\n      S,\n      T,\n      0,\n      0,\n      T,\n      T,\n      S,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(D, r);\n  }, t.prototype.desaturate = function() {\n    this.saturate(-1);\n  }, t.prototype.negative = function(e) {\n    var r = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.sepia = function(e) {\n    var r = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.technicolor = function(e) {\n    var r = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.polaroid = function(e) {\n    var r = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.toBGR = function(e) {\n    var r = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.kodachrome = function(e) {\n    var r = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.browni = function(e) {\n    var r = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.vintage = function(e) {\n    var r = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.colorTone = function(e, r, S, T, D) {\n    e = e || 0.2, r = r || 0.15, S = S || 16770432, T = T || 3375104;\n    var N = (S >> 16 & 255) / 255, B = (S >> 8 & 255) / 255, $ = (S & 255) / 255, U = (T >> 16 & 255) / 255, V = (T >> 8 & 255) / 255, H = (T & 255) / 255, X = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      N,\n      B,\n      $,\n      e,\n      0,\n      U,\n      V,\n      H,\n      r,\n      0,\n      N - U,\n      B - V,\n      $ - H,\n      0,\n      0\n    ];\n    this._loadMatrix(X, D);\n  }, t.prototype.night = function(e, r) {\n    e = e || 0.1;\n    var S = [\n      e * -2,\n      -e,\n      0,\n      0,\n      0,\n      -e,\n      0,\n      e,\n      0,\n      0,\n      0,\n      e,\n      e * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(S, r);\n  }, t.prototype.predator = function(e, r) {\n    var S = [\n      11.224130630493164 * e,\n      -4.794486999511719 * e,\n      -2.8746118545532227 * e,\n      0 * e,\n      0.40342438220977783 * e,\n      -3.6330697536468506 * e,\n      9.193157196044922 * e,\n      -2.951810836791992 * e,\n      0 * e,\n      -1.316135048866272 * e,\n      -3.2184197902679443 * e,\n      -4.2375030517578125 * e,\n      7.476448059082031 * e,\n      0 * e,\n      0.8044459223747253 * e,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(S, r);\n  }, t.prototype.lsd = function(e) {\n    var r = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(r, e);\n  }, t.prototype.reset = function() {\n    var e = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(e, !1);\n  }, Object.defineProperty(t.prototype, \"matrix\", {\n    get: function() {\n      return this.uniforms.m;\n    },\n    set: function(e) {\n      this.uniforms.m = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\nvar extendStatics$b = function(o, t) {\n  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$b(o, t);\n};\nfunction __extends$b(o, t) {\n  extendStatics$b(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$2 = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`, vertex$1 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n(function(o) {\n  __extends$b(t, o);\n  function t(e, r) {\n    var S = this, T = new Matrix();\n    return e.renderable = !1, S = o.call(this, vertex$1, fragment$2, {\n      mapSampler: e._texture,\n      filterMatrix: T,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this, S.maskSprite = e, S.maskMatrix = T, r == null && (r = 20), S.scale = new Point(r, r), S;\n  }\n  return t.prototype.apply = function(e, r, S, T) {\n    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    var D = this.maskSprite.worldTransform, N = Math.sqrt(D.a * D.a + D.b * D.b), B = Math.sqrt(D.c * D.c + D.d * D.d);\n    N !== 0 && B !== 0 && (this.uniforms.rotation[0] = D.a / N, this.uniforms.rotation[1] = D.b / N, this.uniforms.rotation[2] = D.c / B, this.uniforms.rotation[3] = D.d / B), e.applyFilter(this, r, S, T);\n  }, Object.defineProperty(t.prototype, \"map\", {\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(e) {\n      this.uniforms.mapSampler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\nvar extendStatics$a = function(o, t) {\n  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$a(o, t);\n};\nfunction __extends$a(o, t) {\n  extendStatics$a(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertex = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`, fragment$1 = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(o) {\n  __extends$a(t, o);\n  function t() {\n    return o.call(this, vertex, fragment$1) || this;\n  }\n  return t;\n})(Filter);\nvar extendStatics$9 = function(o, t) {\n  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$9(o, t);\n};\nfunction __extends$9(o, t) {\n  extendStatics$9(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n(function(o) {\n  __extends$9(t, o);\n  function t(e, r) {\n    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());\n    var S = o.call(this, defaultFilterVertex, fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    return S.noise = e, S.seed = r, S;\n  }\n  return Object.defineProperty(t.prototype, \"noise\", {\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(e) {\n      this.uniforms.uNoise = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"seed\", {\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(e) {\n      this.uniforms.uSeed = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\nvar _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;\nvar CacheData = function() {\n  function o() {\n    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n  }\n  return o;\n}();\nObject.defineProperties(DisplayObject.prototype, {\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(o) {\n      o !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(o) {\n      o !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(o) {\n      if (this._cacheAsBitmap !== o) {\n        this._cacheAsBitmap = o;\n        var t;\n        o ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));\n};\nDisplayObject.prototype._initCachedDisplayObject = function(t) {\n  var e;\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var r = this.alpha;\n    this.alpha = 1, t.batch.flush();\n    var S = this.getLocalBounds(null, !0).clone();\n    if (this.filters && this.filters.length) {\n      var T = this.filters[0].padding;\n      S.pad(T);\n    }\n    S.ceil(settings.RESOLUTION);\n    var D = t.renderTexture.current, N = t.renderTexture.sourceFrame.clone(), B = t.renderTexture.destinationFrame.clone(), $ = t.projection.transform, U = RenderTexture.create({\n      width: S.width,\n      height: S.height,\n      resolution: this.cacheAsBitmapResolution || t.resolution,\n      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample\n    }), V = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = V, BaseTexture.addToCache(U.baseTexture, V), Texture.addToCache(U, V);\n    var H = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-S.x, -S.y);\n    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: U, clear: !0, transform: H, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = $, t.renderTexture.bind(D, N, B), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var X = new Sprite(U);\n    X.transform.worldTransform = this.transform.worldTransform, X.anchor.x = -(S.x / S.width), X.anchor.y = -(S.y / S.height), X.alpha = r, X._bounds = this._bounds, this._cacheData.sprite = X, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = X.containsPoint.bind(X);\n  }\n};\nDisplayObject.prototype._renderCachedCanvas = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var e = this.getLocalBounds(null, !0), r = this.alpha;\n    this.alpha = 1;\n    var S = t.context, T = t._projTransform;\n    e.ceil(settings.RESOLUTION);\n    var D = RenderTexture.create({ width: e.width, height: e.height }), N = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = N, BaseTexture.addToCache(D.baseTexture, N), Texture.addToCache(D, N);\n    var B = _tempMatrix;\n    this.transform.localTransform.copyTo(B), B.invert(), B.tx -= e.x, B.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: D, clear: !0, transform: B, skipUpdateTransform: !1 }), t.context = S, t._projTransform = T, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var $ = new Sprite(D);\n    $.transform.worldTransform = this.transform.worldTransform, $.anchor.x = -(e.x / e.width), $.anchor.y = -(e.y / e.height), $.alpha = r, $._bounds = this._bounds, this._cacheData.sprite = $, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = $.containsPoint.bind($);\n  }\n};\nDisplayObject.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function(t) {\n  this.cacheAsBitmap = !1, this.destroy(t);\n};\nDisplayObject.prototype.name = null;\nContainer.prototype.getChildByName = function(t, e) {\n  for (var r = 0, S = this.children.length; r < S; r++)\n    if (this.children[r].name === t)\n      return this.children[r];\n  if (e)\n    for (var r = 0, S = this.children.length; r < S; r++) {\n      var T = this.children[r];\n      if (!!T.getChildByName) {\n        var D = T.getChildByName(t, !0);\n        if (D)\n          return D;\n      }\n    }\n  return null;\n};\nDisplayObject.prototype.getGlobalPosition = function(t, e) {\n  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;\n};\nvar ResizePlugin = function() {\n  function o() {\n  }\n  return o.init = function(t) {\n    var e = this;\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set: function(r) {\n          globalThis.removeEventListener(\"resize\", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener(\"resize\", this.queueResize), this.resize());\n        },\n        get: function() {\n          return this._resizeTo;\n        }\n      }\n    ), this.queueResize = function() {\n      !e._resizeTo || (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {\n        return e.resize();\n      }));\n    }, this.cancelResize = function() {\n      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);\n    }, this.resize = function() {\n      if (!!e._resizeTo) {\n        e.cancelResize();\n        var r, S;\n        if (e._resizeTo === globalThis.window)\n          r = globalThis.innerWidth, S = globalThis.innerHeight;\n        else {\n          var T = e._resizeTo, D = T.clientWidth, N = T.clientHeight;\n          r = D, S = N;\n        }\n        e.renderer.resize(r, S);\n      }\n    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;\n  }, o.destroy = function() {\n    globalThis.removeEventListener(\"resize\", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n  }, o.extension = ExtensionType.Application, o;\n}(), Application = function() {\n  function o(t) {\n    var e = this;\n    this.stage = new Container(), t = Object.assign({\n      forceCanvas: !1\n    }, t), this.renderer = autoDetectRenderer(t), o._plugins.forEach(function(r) {\n      r.init.call(e, t);\n    });\n  }\n  return o.registerPlugin = function(t) {\n    deprecation(\"6.5.0\", \"Application.registerPlugin() is deprecated, use extensions.add()\"), extensions.add({\n      type: ExtensionType.Application,\n      ref: t\n    });\n  }, o.prototype.render = function() {\n    this.renderer.render(this.stage);\n  }, Object.defineProperty(o.prototype, \"view\", {\n    get: function() {\n      return this.renderer.view;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"screen\", {\n    get: function() {\n      return this.renderer.screen;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), o.prototype.destroy = function(t, e) {\n    var r = this, S = o._plugins.slice(0);\n    S.reverse(), S.forEach(function(T) {\n      T.destroy.call(r);\n    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;\n  }, o._plugins = [], o;\n}();\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ResizePlugin);\nvar extendStatics$8 = function(o, t) {\n  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$8(o, t);\n};\nfunction __extends$8(o, t) {\n  extendStatics$8(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar PlaneGeometry = function(o) {\n  __extends$8(t, o);\n  function t(e, r, S, T) {\n    e === void 0 && (e = 100), r === void 0 && (r = 100), S === void 0 && (S = 10), T === void 0 && (T = 10);\n    var D = o.call(this) || this;\n    return D.segWidth = S, D.segHeight = T, D.width = e, D.height = r, D.build(), D;\n  }\n  return t.prototype.build = function() {\n    for (var e = this.segWidth * this.segHeight, r = [], S = [], T = [], D = this.segWidth - 1, N = this.segHeight - 1, B = this.width / D, $ = this.height / N, U = 0; U < e; U++) {\n      var V = U % this.segWidth, H = U / this.segWidth | 0;\n      r.push(V * B, H * $), S.push(V / D, H / N);\n    }\n    for (var X = D * N, U = 0; U < X; U++) {\n      var Y = U % D, W = U / D | 0, q = W * this.segWidth + Y, K = W * this.segWidth + Y + 1, Z = (W + 1) * this.segWidth + Y, J = (W + 1) * this.segWidth + Y + 1;\n      T.push(q, K, Z, K, J, Z);\n    }\n    this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(S), this.indexBuffer.data = new Uint16Array(T), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n  }, t;\n}(MeshGeometry), RopeGeometry = function(o) {\n  __extends$8(t, o);\n  function t(e, r, S) {\n    e === void 0 && (e = 200), S === void 0 && (S = 0);\n    var T = o.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;\n    return T.points = r, T._width = e, T.textureScale = S, T.build(), T;\n  }\n  return Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.build = function() {\n    var e = this.points;\n    if (!!e) {\n      var r = this.getBuffer(\"aVertexPosition\"), S = this.getBuffer(\"aTextureCoord\"), T = this.getIndex();\n      if (!(e.length < 1)) {\n        r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), S.data = new Float32Array(e.length * 4), T.data = new Uint16Array((e.length - 1) * 6));\n        var D = S.data, N = T.data;\n        D[0] = 0, D[1] = 0, D[2] = 0, D[3] = 1;\n        for (var B = 0, $ = e[0], U = this._width * this.textureScale, V = e.length, H = 0; H < V; H++) {\n          var X = H * 4;\n          if (this.textureScale > 0) {\n            var Y = $.x - e[H].x, W = $.y - e[H].y, q = Math.sqrt(Y * Y + W * W);\n            $ = e[H], B += q / U;\n          } else\n            B = H / (V - 1);\n          D[X] = B, D[X + 1] = 0, D[X + 2] = B, D[X + 3] = 1;\n        }\n        for (var K = 0, H = 0; H < V - 1; H++) {\n          var X = H * 2;\n          N[K++] = X, N[K++] = X + 1, N[K++] = X + 2, N[K++] = X + 2, N[K++] = X + 1, N[K++] = X + 3;\n        }\n        S.update(), T.update(), this.updateVertices();\n      }\n    }\n  }, t.prototype.updateVertices = function() {\n    var e = this.points;\n    if (!(e.length < 1)) {\n      for (var r = e[0], S, T = 0, D = 0, N = this.buffers[0].data, B = e.length, $ = 0; $ < B; $++) {\n        var U = e[$], V = $ * 4;\n        $ < e.length - 1 ? S = e[$ + 1] : S = U, D = -(S.x - r.x), T = S.y - r.y;\n        var H = Math.sqrt(T * T + D * D), X = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n        T /= H, D /= H, T *= X, D *= X, N[V] = U.x + T, N[V + 1] = U.y + D, N[V + 2] = U.x - T, N[V + 3] = U.y - D, r = U;\n      }\n      this.buffers[0].update();\n    }\n  }, t.prototype.update = function() {\n    this.textureScale > 0 ? this.build() : this.updateVertices();\n  }, t;\n}(MeshGeometry);\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, S) {\n    S === void 0 && (S = 0);\n    var T = this, D = new RopeGeometry(e.height, r, S), N = new MeshMaterial(e);\n    return S > 0 && (e.baseTexture.wrapMode = WRAP_MODES.REPEAT), T = o.call(this, D, N) || this, T.autoUpdate = !0, T;\n  }\n  return t.prototype._render = function(e) {\n    var r = this.geometry;\n    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), o.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar SimplePlane = function(o) {\n  __extends$8(t, o);\n  function t(e, r, S) {\n    var T = this, D = new PlaneGeometry(e.width, e.height, r, S), N = new MeshMaterial(Texture.WHITE);\n    return T = o.call(this, D, N) || this, T.texture = e, T.autoResize = !0, T;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID;\n    var e = this.geometry, r = this.shader.texture, S = r.width, T = r.height;\n    this.autoResize && (e.width !== S || e.height !== T) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());\n  }, Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.shader.texture;\n    },\n    set: function(e) {\n      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once(\"update\", this.textureUpdated, this));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), o.prototype._render.call(this, e);\n  }, t.prototype.destroy = function(e) {\n    this.shader.texture.off(\"update\", this.textureUpdated, this), o.prototype.destroy.call(this, e);\n  }, t;\n}(Mesh);\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, S, T, D) {\n    e === void 0 && (e = Texture.EMPTY);\n    var N = this, B = new MeshGeometry(r, S, T);\n    B.getBuffer(\"aVertexPosition\").static = !1;\n    var $ = new MeshMaterial(e);\n    return N = o.call(this, B, $, null, D) || this, N.autoUpdate = !0, N;\n  }\n  return Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this.autoUpdate && this.geometry.getBuffer(\"aVertexPosition\").update(), o.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, S, T, D) {\n    r === void 0 && (r = DEFAULT_BORDER_SIZE), S === void 0 && (S = DEFAULT_BORDER_SIZE), T === void 0 && (T = DEFAULT_BORDER_SIZE), D === void 0 && (D = DEFAULT_BORDER_SIZE);\n    var N = o.call(this, Texture.WHITE, 4, 4) || this;\n    return N._origWidth = e.orig.width, N._origHeight = e.orig.height, N._width = N._origWidth, N._height = N._origHeight, N._leftWidth = r, N._rightWidth = T, N._topHeight = S, N._bottomHeight = D, N.texture = e, N;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }, Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.updateHorizontalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;\n  }, t.prototype.updateVerticalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;\n  }, t.prototype._getMinScale = function() {\n    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, S = this._topHeight + this._bottomHeight, T = this._height > S ? 1 : this._height / S, D = Math.min(r, T);\n    return D;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"leftWidth\", {\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(e) {\n      this._leftWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rightWidth\", {\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(e) {\n      this._rightWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"topHeight\", {\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(e) {\n      this._topHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"bottomHeight\", {\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(e) {\n      this._bottomHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._refresh = function() {\n    var e = this.texture, r = this.geometry.buffers[1].data;\n    this._origWidth = e.orig.width, this._origHeight = e.orig.height;\n    var S = 1 / this._origWidth, T = 1 / this._origHeight;\n    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = S * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - S * this._rightWidth, r[9] = r[11] = r[13] = r[15] = T * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - T * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }, t;\n})(SimplePlane);\nvar extendStatics$7 = function(o, t) {\n  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$7(o, t);\n};\nfunction __extends$7(o, t) {\n  extendStatics$7(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar AnimatedSprite = function(o) {\n  __extends$7(t, o);\n  function t(e, r) {\n    r === void 0 && (r = !0);\n    var S = o.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;\n    return S._textures = null, S._durations = null, S._autoUpdate = r, S._isConnectedToTicker = !1, S.animationSpeed = 1, S.loop = !0, S.updateAnchor = !1, S.onComplete = null, S.onFrameChange = null, S.onLoop = null, S._currentTime = 0, S._playing = !1, S._previousFrame = null, S.textures = e, S;\n  }\n  return t.prototype.stop = function() {\n    !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n  }, t.prototype.play = function() {\n    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));\n  }, t.prototype.gotoAndStop = function(e) {\n    this.stop();\n    var r = this.currentFrame;\n    this._currentTime = e, r !== this.currentFrame && this.updateTexture();\n  }, t.prototype.gotoAndPlay = function(e) {\n    var r = this.currentFrame;\n    this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();\n  }, t.prototype.update = function(e) {\n    if (!!this._playing) {\n      var r = this.animationSpeed * e, S = this.currentFrame;\n      if (this._durations !== null) {\n        var T = this._currentTime % 1 * this._durations[this.currentFrame];\n        for (T += r / 60 * 1e3; T < 0; )\n          this._currentTime--, T += this._durations[this.currentFrame];\n        var D = Math.sign(this.animationSpeed * e);\n        for (this._currentTime = Math.floor(this._currentTime); T >= this._durations[this.currentFrame]; )\n          T -= this._durations[this.currentFrame] * D, this._currentTime += D;\n        this._currentTime += T / this._durations[this.currentFrame];\n      } else\n        this._currentTime += r;\n      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : S !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < S ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > S && this.onLoop()), this.updateTexture());\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.currentFrame;\n    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n  }, t.prototype.destroy = function(e) {\n    this.stop(), o.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n  }, t.fromFrames = function(e) {\n    for (var r = [], S = 0; S < e.length; ++S)\n      r.push(Texture.from(e[S]));\n    return new t(r);\n  }, t.fromImages = function(e) {\n    for (var r = [], S = 0; S < e.length; ++S)\n      r.push(Texture.from(e[S]));\n    return new t(r);\n  }, Object.defineProperty(t.prototype, \"totalFrames\", {\n    get: function() {\n      return this._textures.length;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textures\", {\n    get: function() {\n      return this._textures;\n    },\n    set: function(e) {\n      if (e[0] instanceof Texture)\n        this._textures = e, this._durations = null;\n      else {\n        this._textures = [], this._durations = [];\n        for (var r = 0; r < e.length; r++)\n          this._textures.push(e[r].texture), this._durations.push(e[r].time);\n      }\n      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"currentFrame\", {\n    get: function() {\n      var e = Math.floor(this._currentTime) % this._textures.length;\n      return e < 0 && (e += this._textures.length), e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"playing\", {\n    get: function() {\n      return this._playing;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Sprite);\nextensions.add(\n  AccessibilityManager,\n  Extract,\n  InteractionManager,\n  ParticleRenderer,\n  Prepare,\n  BatchRenderer,\n  TilingSpriteRenderer,\n  BitmapFontLoader,\n  CompressedTextureLoader,\n  DDSLoader,\n  KTXLoader,\n  SpritesheetLoader,\n  TickerPlugin,\n  AppLoaderPlugin\n);\nvar Ai;\nclass EventListenerCtn {\n  constructor() {\n    tt(this, Ai, []);\n  }\n  add(t, e, r, S = {}) {\n    if (t instanceof BaseTexture) {\n      switch (e) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          t.on(e, r, S), z(this, Ai).push(() => t.off(e, r, S));\n          break;\n      }\n      return;\n    }\n    if (t instanceof i$1) {\n      t.on(e, r, S), z(this, Ai).push(() => t.off(e, r, S));\n      return;\n    }\n    t.addEventListener(e, r, S), z(this, Ai).push(() => t.removeEventListener(e, r, { capture: S.capture ?? !1 }));\n  }\n  clear() {\n    for (const t of z(this, Ai))\n      t();\n    ot(this, Ai, []);\n  }\n}\nAi = new WeakMap();\nvar SEARCH_PATH_ARG_EXT = /* @__PURE__ */ ((o) => (o.DEFAULT = \"\", o.SP_GSM = \"png|jpg|jpeg|json|svg|webp|mp4|webm\", o.SCRIPT = \"sn|ssn\", o.FONT = \"woff2|woff|otf|ttf\", o.SOUND = \"mp3|m4a|ogg|aac|flac|wav\", o.HTML = \"htm|html\", o.CSS = \"css\", o.SN = \"sn\", o.PSD = \"psd\", o.TST_PNGPNG_ = \"png|png_\", o.TST_HH = \"hh\", o.TST_EEE = \"eee\", o.TST_GGG = \"ggg\", o.TST_PNGXML = \"png|xml\", o))(SEARCH_PATH_ARG_EXT || {}), Qa, to, bu;\nclass ConfigBase {\n  constructor(t) {\n    Rt(this, \"oCfg\", {\n      save_ns: \"\",\n      window: {\n        width: 300,\n        height: 300\n      },\n      book: {\n        title: \"\",\n        creator: \"\",\n        cre_url: \"\",\n        publisher: \"\",\n        pub_url: \"\",\n        detail: \"\",\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      init: {\n        bg_color: \"#000000\",\n        tagch_msecwait: 10,\n        auto_msecpagewait: 3500,\n        escape: \"\"\n      },\n      debug: {\n        devtool: !1,\n        token: !1,\n        tag: !1,\n        putCh: !1,\n        debugLog: !1,\n        baseTx: !1,\n        masume: !1,\n        variable: !1\n      },\n      code: {},\n      debuger_token: \"\"\n    });\n    Rt(this, \"userFnTail\", \"\");\n    Rt(this, \"hPathFn2Exts\", {});\n    tt(this, Qa, !1);\n    tt(this, to, !1);\n    tt(this, bu, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n    this.sys = t;\n  }\n  async load(t) {\n    var e, r, S, T;\n    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((T = (S = t.log) == null ? void 0 : S.max_len) == null ? void 0 : T.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), ot(this, Qa, this.matchPath(\"^breakline$\", \"png|jpg|jpeg|json|svg|webp|mp4|webm\").length > 0), ot(this, to, this.matchPath(\"^breakpage$\", \"png|jpg|jpeg|json|svg|webp|mp4|webm\").length > 0), !!this.sys.crypto)\n      for (const D of Object.values(this.hPathFn2Exts))\n        for (const [N, B] of Object.entries(D)) {\n          if (N.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const $ = B.slice(B.lastIndexOf(\"/\") + 1), U = D[N.slice(0, -10)], H = await (await this.sys.fetch(U)).text(), X = this.sys.hash(H);\n          if ($ !== X)\n            throw `ファイル改竄エラーです fn:${U}`;\n        }\n  }\n  get existsBreakline() {\n    return z(this, Qa);\n  }\n  get existsBreakpage() {\n    return z(this, to);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  searchPath(t, e = \"\") {\n    if (!t)\n      throw \"[searchPath] fnが空です\";\n    if (t.slice(0, 7) === \"http://\")\n      return t;\n    const r = t.match(z(this, bu));\n    let S = r ? r[1] : t;\n    const T = r ? r[2] : \"\";\n    if (this.userFnTail) {\n      const B = S + \"@@\" + this.userFnTail;\n      if (B in this.hPathFn2Exts) {\n        if (e === \"\")\n          S = B;\n        else\n          for (const $ of Object.keys(this.hPathFn2Exts[B]))\n            if (`|${e}|`.indexOf(`|${$}|`) !== -1) {\n              S = B;\n              break;\n            }\n      }\n    }\n    const D = this.hPathFn2Exts[S];\n    if (!D)\n      throw `サーチパスに存在しないファイル【${t}】です`;\n    let N = \"\";\n    if (!T) {\n      const B = int(D[\":cnt\"]);\n      if (e === \"\") {\n        if (B > 1)\n          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n        return t;\n      }\n      const $ = `|${e}|`;\n      if (B > 1) {\n        let U = 0;\n        for (const V of Object.keys(D))\n          if ($.indexOf(`|${V}|`) !== -1 && ++U > 1)\n            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n      }\n      for (let U of Object.keys(D))\n        if ($.indexOf(`|${U}|`) > -1)\n          return D[U];\n      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;\n    }\n    if (e !== \"\" && `|${e}|`.indexOf(`|${T}|`) === -1)\n      throw `指定ファイルの拡張子【${T}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;\n    if (N = D[T], !N)\n      throw `サーチパスに存在しない拡張子【${T}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;\n    return N;\n  }\n  matchPath(t, e = \"\") {\n    const r = [], S = new RegExp(t), T = new RegExp(e);\n    for (const [D, N] of Object.entries(this.hPathFn2Exts)) {\n      if (D.search(S) === -1)\n        continue;\n      if (e === \"\") {\n        r.push(N);\n        continue;\n      }\n      const B = {};\n      let $ = !1;\n      for (const U of Object.keys(N))\n        U.search(T) !== -1 && (B[U] = D, $ = !0);\n      $ && r.push(B);\n    }\n    return r;\n  }\n  addPath(t, e) {\n    const r = {};\n    for (const [S, T] of Object.entries(e))\n      r[S] = (S.at(0) === \":\" ? \"\" : this.sys.cur) + T;\n    this.hPathFn2Exts[t] = r;\n  }\n}\nQa = new WeakMap(), to = new WeakMap(), bu = new WeakMap();\nclass Config extends ConfigBase {\n  constructor(t) {\n    super(t), this.sys = t;\n  }\n  static async generate(t) {\n    const e = new Config(t), r = t.cur + \"prj.json\", S = await (await t.fetch(r)).text(), T = JSON.parse(t.decStr(r, S));\n    return await e.load(T), e;\n  }\n  async load(t) {\n    await super.load(t), CmnLib.stageW = this.oCfg.window.width, CmnLib.stageH = this.oCfg.window.height, CmnLib.debugLog = this.oCfg.debug.debugLog;\n  }\n  searchPath(t, e = SEARCH_PATH_ARG_EXT.DEFAULT) {\n    return t.slice(0, 11) === \"downloads:/\" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === \"userdata:/\" ? this.sys.path_userdata + \"storage/\" + t.slice(10) : super.searchPath(t, e);\n  }\n}\nconst REG_TAG = /(?<name>[^\\s;\\]]+)/;\nfunction tagToken2Name_Args(o) {\n  const t = REG_TAG.exec(o.slice(1, -1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${o}】異常です(タグ解析)`;\n  const r = e.name;\n  return [r, o.slice(1 + r.length, -1)];\n}\nfunction tagToken2Name(o) {\n  const t = REG_TAG.exec(o.slice(1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${o}】異常です(タグ解析)`;\n  return e.name;\n}\nfunction splitAmpersand(o) {\n  const t = o.replaceAll(\"==\", \"＝\").replaceAll(\"!=\", \"≠\").split(\"=\"), e = t.length;\n  if (e < 2 || e > 3)\n    throw \"「&計算」書式では「=」指定が一つか二つ必要です\";\n  if (t[1].at(0) === \"&\")\n    throw \"「&計算」書式では「&」指定が不要です\";\n  return {\n    name: t[0].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    text: t[1].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    cast: e === 3 ? t[2].trim() : void 0\n  };\n}\nvar ln, un, eo, ro, io, Ve, no, Cs, eu;\nclass Grammar {\n  constructor() {\n    tt(this, Cs);\n    tt(this, ln, void 0);\n    tt(this, un, void 0);\n    tt(this, eo, new RegExp(\"\"));\n    tt(this, ro, \"\");\n    tt(this, io, \"\");\n    tt(this, Ve, void 0);\n    tt(this, no, void 0);\n    this.setEscape(\"\");\n  }\n  setEscape(t) {\n    if (z(this, Ve) && t in z(this, Ve))\n      throw \"[エスケープ文字] char【\" + t + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    ot(this, ln, new RegExp(\n      (t ? `\\\\${t}\\\\S|` : \"\") + `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:(?=([^\"'#;\\\\]]+))\\\\1|([\"'#]).*?\\\\2|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^&;\\\\n\\\\t]+|^\\\\*[^\\\\s\\\\[&;\\\\\\\\]+|[^\\\\n\\\\t\\\\[;${t ? `\\\\${t}` : \"\"}]+`,\n      \"gs\"\n    )), ot(this, un, new RegExp(`[\\\\w\\\\s;[\\\\]*=&｜《》${t ? `\\\\${t}` : \"\"}]`)), ot(this, no, new RegExp(`[\\\\n\\\\t;\\\\[*&${t ? `\\\\${t}` : \"\"}]`));\n  }\n  bracket2macro(t, e, r, S) {\n    const { name: T, text: D } = t;\n    if (!T)\n      throw \"[bracket2macro] nameは必須です\";\n    if (!D)\n      throw \"[bracket2macro] textは必須です\";\n    const N = D.at(0);\n    if (!N)\n      throw \"[bracket2macro] textは必須です\";\n    if (D.length !== 2)\n      throw \"[bracket2macro] textは括弧の前後を示す二文字を指定してください\";\n    if (!(T in e))\n      throw `[bracket2macro] 未定義のタグ又はマクロ[${T}]です`;\n    z(this, Ve) ?? ot(this, Ve, {});\n    const B = D.charAt(1);\n    if (N in z(this, Ve))\n      throw \"[bracket2macro] text【\" + N + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (B in z(this, Ve))\n      throw \"[bracket2macro] text【\" + B + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (z(this, un).test(N))\n      throw \"[bracket2macro] text【\" + N + \"】は括弧マクロに使用できない文字です\";\n    if (z(this, un).test(B))\n      throw \"[bracket2macro] text【\" + B + \"】は括弧マクロに使用できない文字です\";\n    z(this, Ve)[B] = \"0\", z(this, Ve)[N] = `[${T} text=`, this.addC2M(`\\\\${N}[^\\\\${B}]*\\\\${B}`, `\\\\${N}\\\\${B}`), lt(this, Cs, eu).call(this, r, S);\n  }\n  char2macro(t, e, r, S) {\n    const { char: T, name: D } = t;\n    if (!T)\n      throw \"[char2macro] charは必須です\";\n    if (z(this, Ve) ?? ot(this, Ve, {}), T in z(this, Ve))\n      throw \"[char2macro] char【\" + T + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (z(this, un).test(T))\n      throw \"[char2macro] char【\" + T + \"】は一文字マクロに使用できない文字です\";\n    if (!D)\n      throw \"[char2macro] nameは必須です\";\n    if (!(D in e))\n      throw `[char2macro] 未定義のタグ又はマクロ[${D}]です`;\n    z(this, Ve)[T] = `[${D}]`, this.addC2M(`\\\\${T}`, `\\\\${T}`), lt(this, Cs, eu).call(this, r, S);\n  }\n  addC2M(t, e) {\n    ot(this, ro, z(this, ro) + `${t}|`), ot(this, io, z(this, io) + `${e}`), ot(this, eo, new RegExp(\n      `(${z(this, ro)}[^${z(this, io)}]+)`,\n      \"g\"\n    ));\n  }\n  resolveScript(t) {\n    var S;\n    const e = ((S = t.replaceAll(/(\\r\\n|\\r)/g, `\n`).match(z(this, ln))) == null ? void 0 : S.flatMap((T) => {\n      if (!this.testTagLetml(T))\n        return T;\n      const D = /^([^\\]]+?])(.*)$/s.exec(T);\n      if (!D)\n        return T;\n      const [, N, B] = D;\n      return [N, B];\n    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };\n    return lt(this, Cs, eu).call(this, r), r;\n  }\n  testTagLetml(t) {\n    return /^\\[let_ml\\s/.test(t);\n  }\n  testTagEndLetml(t) {\n    return /^\\[endlet_ml\\s*]/.test(t);\n  }\n  analyzToken(t) {\n    return z(this, ln).lastIndex = 0, z(this, ln).exec(t);\n  }\n  testNoTxt(t) {\n    return z(this, no).test(t);\n  }\n}\nln = new WeakMap(), un = new WeakMap(), eo = new WeakMap(), ro = new WeakMap(), io = new WeakMap(), Ve = new WeakMap(), no = new WeakMap(), Cs = new WeakSet(), eu = function(t, e = 0) {\n  if (!!z(this, Ve)) {\n    for (let r = t.len - 1; r >= e; --r) {\n      const S = t.aToken[r];\n      if (this.testNoTxt(S.at(0) ?? `\n`))\n        continue;\n      const T = t.aLNum[r], D = S.match(z(this, eo));\n      if (!D)\n        continue;\n      let N = 1;\n      for (let B = D.length - 1; B >= 0; --B) {\n        let $ = D[B];\n        const U = z(this, Ve)[$.at(0) ?? \" \"];\n        U && ($ = U + (U.slice(-1) === \"]\" ? \"\" : `'${$.slice(1, -1)}']`)), t.aToken.splice(r, N, $), t.aLNum.splice(r, N, T), N = 0;\n      }\n    }\n    t.len = t.aToken.length;\n  }\n};\nvar so, Ps, ru, hn, Rs;\nclass AnalyzeTagArg {\n  constructor() {\n    tt(this, Ps);\n    tt(this, so, /;[^\\n]*|(?<key>[^\\s=\"'#|;]+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    tt(this, hn, {});\n    tt(this, Rs, !1);\n  }\n  parse(t) {\n    ot(this, hn, {}), ot(this, Rs, !1);\n    for (const { groups: e } of t.matchAll(z(this, so))) {\n      const { key: r, val: S, val2: T, def: D, def2: N, literal: B } = e;\n      r ? z(this, hn)[r] = {\n        val: S ?? T,\n        def: D ?? N\n      } : B && (B === \"*\" ? ot(this, Rs, !0) : z(this, hn)[B] = { val: \"1\" });\n    }\n  }\n  parseinDetail(t, e, r, S) {\n    const T = {}, D = t.slice(1 + e, -1);\n    for (const { groups: N, index: B, 0: $ } of D.matchAll(z(this, so))) {\n      if (B === void 0)\n        continue;\n      const { key: U, val: V, val2: H, literal: X } = N;\n      if (X) {\n        if (X.slice(-1) === \"=\") {\n          const Z = X.length - 1, { ch: J } = lt(this, Ps, ru).call(this, e, r, S, D, B + Z);\n          T[X.slice(0, -1)] = {\n            k_ln: r,\n            k_ch: J - Z,\n            v_ln: r,\n            v_ch: J + 1,\n            v_len: 0\n          };\n        }\n        continue;\n      }\n      if (!U)\n        continue;\n      const { ln: Y, ch: W } = lt(this, Ps, ru).call(this, e, r, S, D, B), { ln: q, ch: K } = lt(this, Ps, ru).call(this, e, r, S, D, B + $.lastIndexOf(V ?? H) - (V ? 0 : 1));\n      T[U] = { k_ln: Y, k_ch: W, v_ln: q, v_ch: K, v_len: V ? V.length : H.length + 2 };\n    }\n    return T;\n  }\n  get hPrm() {\n    return z(this, hn);\n  }\n  get isKomeParam() {\n    return z(this, Rs);\n  }\n}\nso = new WeakMap(), Ps = new WeakSet(), ru = function(t, e, r, S, T) {\n  const N = S.slice(0, T).split(`\n`), B = N.length;\n  return {\n    ln: e + B - 1,\n    ch: B < 2 ? r + 1 + t + T : N.at(-1).length\n  };\n}, hn = new WeakMap(), Rs = new WeakMap();\nvar parsimmon_umd_min = { exports: {} };\n(function(o, t) {\n  (function(e, r) {\n    o.exports = r();\n  })(typeof self < \"u\" ? self : commonjsGlobal, function() {\n    return function(e) {\n      var r = {};\n      function S(T) {\n        if (r[T])\n          return r[T].exports;\n        var D = r[T] = { i: T, l: !1, exports: {} };\n        return e[T].call(D.exports, D, D.exports, S), D.l = !0, D.exports;\n      }\n      return S.m = e, S.c = r, S.d = function(T, D, N) {\n        S.o(T, D) || Object.defineProperty(T, D, { configurable: !1, enumerable: !0, get: N });\n      }, S.r = function(T) {\n        Object.defineProperty(T, \"__esModule\", { value: !0 });\n      }, S.n = function(T) {\n        var D = T && T.__esModule ? function() {\n          return T.default;\n        } : function() {\n          return T;\n        };\n        return S.d(D, \"a\", D), D;\n      }, S.o = function(T, D) {\n        return Object.prototype.hasOwnProperty.call(T, D);\n      }, S.p = \"\", S(S.s = 0);\n    }([function(e, r, S) {\n      function T(ht) {\n        if (!(this instanceof T))\n          return new T(ht);\n        this._ = ht;\n      }\n      var D = T.prototype;\n      function N(ht, dt) {\n        for (var xt = 0; xt < ht; xt++)\n          dt(xt);\n      }\n      function B(ht, dt, xt) {\n        return function(Mt, Bt) {\n          N(Bt.length, function($t) {\n            Mt(Bt[$t], $t, Bt);\n          });\n        }(function(Mt, Bt, $t) {\n          dt = ht(dt, Mt, Bt, $t);\n        }, xt), dt;\n      }\n      function $(ht, dt) {\n        return B(function(xt, Mt, Bt, $t) {\n          return xt.concat([ht(Mt, Bt, $t)]);\n        }, [], dt);\n      }\n      function U(ht, dt) {\n        var xt = { v: 0, buf: dt };\n        return N(ht, function() {\n          var Mt;\n          xt = { v: xt.v << 1 | (Mt = xt.buf, Mt[0] >> 7), buf: function(Bt) {\n            var $t = B(function(Gt, Qt, Se, He) {\n              return Gt.concat(Se === He.length - 1 ? Buffer.from([Qt, 0]).readUInt16BE(0) : He.readUInt16BE(Se));\n            }, [], Bt);\n            return Buffer.from($(function(Gt) {\n              return (Gt << 1 & 65535) >> 8;\n            }, $t));\n          }(xt.buf) };\n        }), xt;\n      }\n      function V() {\n        return typeof Buffer < \"u\";\n      }\n      function H() {\n        if (!V())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function X(ht) {\n        H();\n        var dt = B(function($t, Gt) {\n          return $t + Gt;\n        }, 0, ht);\n        if (dt % 8 != 0)\n          throw new Error(\"The bits [\" + ht.join(\", \") + \"] add up to \" + dt + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var xt, Mt = dt / 8, Bt = (xt = function($t) {\n          return $t > 48;\n        }, B(function($t, Gt) {\n          return $t || (xt(Gt) ? Gt : $t);\n        }, null, ht));\n        if (Bt)\n          throw new Error(Bt + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new T(function($t, Gt) {\n          var Qt = Mt + Gt;\n          return Qt > $t.length ? st(Gt, Mt.toString() + \" bytes\") : nt(Qt, B(function(Se, He) {\n            var Be = U(He, Se.buf);\n            return { coll: Se.coll.concat(Be.v), buf: Be.buf };\n          }, { coll: [], buf: $t.slice(Gt, Qt) }, ht).coll);\n        });\n      }\n      function Y(ht, dt) {\n        return new T(function(xt, Mt) {\n          return H(), Mt + dt > xt.length ? st(Mt, dt + \" bytes for \" + ht) : nt(Mt + dt, xt.slice(Mt, Mt + dt));\n        });\n      }\n      function W(ht, dt) {\n        if (typeof (xt = dt) != \"number\" || Math.floor(xt) !== xt || dt < 0 || dt > 6)\n          throw new Error(ht + \" requires integer length in range [0, 6].\");\n        var xt;\n      }\n      function q(ht) {\n        return W(\"uintBE\", ht), Y(\"uintBE(\" + ht + \")\", ht).map(function(dt) {\n          return dt.readUIntBE(0, ht);\n        });\n      }\n      function K(ht) {\n        return W(\"uintLE\", ht), Y(\"uintLE(\" + ht + \")\", ht).map(function(dt) {\n          return dt.readUIntLE(0, ht);\n        });\n      }\n      function Z(ht) {\n        return W(\"intBE\", ht), Y(\"intBE(\" + ht + \")\", ht).map(function(dt) {\n          return dt.readIntBE(0, ht);\n        });\n      }\n      function J(ht) {\n        return W(\"intLE\", ht), Y(\"intLE(\" + ht + \")\", ht).map(function(dt) {\n          return dt.readIntLE(0, ht);\n        });\n      }\n      function Q(ht) {\n        return ht instanceof T;\n      }\n      function rt(ht) {\n        return {}.toString.call(ht) === \"[object Array]\";\n      }\n      function et(ht) {\n        return V() && Buffer.isBuffer(ht);\n      }\n      function nt(ht, dt) {\n        return { status: !0, index: ht, value: dt, furthest: -1, expected: [] };\n      }\n      function st(ht, dt) {\n        return rt(dt) || (dt = [dt]), { status: !1, index: -1, value: null, furthest: ht, expected: dt };\n      }\n      function it(ht, dt) {\n        if (!dt || ht.furthest > dt.furthest)\n          return ht;\n        var xt = ht.furthest === dt.furthest ? function(Mt, Bt) {\n          if (function() {\n            if (T._supportsSet !== void 0)\n              return T._supportsSet;\n            var ei = typeof Set < \"u\";\n            return T._supportsSet = ei, ei;\n          }() && Array.from) {\n            for (var $t = new Set(Mt), Gt = 0; Gt < Bt.length; Gt++)\n              $t.add(Bt[Gt]);\n            var Qt = Array.from($t);\n            return Qt.sort(), Qt;\n          }\n          for (var Se = {}, He = 0; He < Mt.length; He++)\n            Se[Mt[He]] = !0;\n          for (var Be = 0; Be < Bt.length; Be++)\n            Se[Bt[Be]] = !0;\n          var ti = [];\n          for (var er in Se)\n            ({}).hasOwnProperty.call(Se, er) && ti.push(er);\n          return ti.sort(), ti;\n        }(ht.expected, dt.expected) : dt.expected;\n        return { status: ht.status, index: ht.index, value: ht.value, furthest: dt.furthest, expected: xt };\n      }\n      var at = {};\n      function ut(ht, dt) {\n        if (et(ht))\n          return { offset: dt, line: -1, column: -1 };\n        ht in at || (at[ht] = {});\n        for (var xt = at[ht], Mt = 0, Bt = 0, $t = 0, Gt = dt; Gt >= 0; ) {\n          if (Gt in xt) {\n            Mt = xt[Gt].line, $t === 0 && ($t = xt[Gt].lineStart);\n            break;\n          }\n          (ht.charAt(Gt) === `\n` || ht.charAt(Gt) === \"\\r\" && ht.charAt(Gt + 1) !== `\n`) && (Bt++, $t === 0 && ($t = Gt + 1)), Gt--;\n        }\n        var Qt = Mt + Bt, Se = dt - $t;\n        return xt[dt] = { line: Qt, lineStart: $t }, { offset: dt, line: Qt + 1, column: Se + 1 };\n      }\n      function ct(ht) {\n        if (!Q(ht))\n          throw new Error(\"not a parser: \" + ht);\n      }\n      function gt(ht, dt) {\n        return typeof ht == \"string\" ? ht.charAt(dt) : ht[dt];\n      }\n      function _t(ht) {\n        if (typeof ht != \"number\")\n          throw new Error(\"not a number: \" + ht);\n      }\n      function vt(ht) {\n        if (typeof ht != \"function\")\n          throw new Error(\"not a function: \" + ht);\n      }\n      function mt(ht) {\n        if (typeof ht != \"string\")\n          throw new Error(\"not a string: \" + ht);\n      }\n      var bt = 2, Ct = 3, St = 8, pt = 5 * St, yt = 4 * St, At = \"  \";\n      function Dt(ht, dt) {\n        return new Array(dt + 1).join(ht);\n      }\n      function Ot(ht, dt, xt) {\n        var Mt = dt - ht.length;\n        return Mt <= 0 ? ht : Dt(xt, Mt) + ht;\n      }\n      function Pt(ht, dt, xt, Mt) {\n        return { from: ht - dt > 0 ? ht - dt : 0, to: ht + xt > Mt ? Mt : ht + xt };\n      }\n      function ft(ht, dt) {\n        var xt, Mt, Bt, $t, Gt, Qt = dt.index, Se = Qt.offset, He = 1;\n        if (Se === ht.length)\n          return \"Got the end of the input\";\n        if (et(ht)) {\n          var Be = Se - Se % St, ti = Se - Be, er = Pt(Be, pt, yt + St, ht.length), ei = $(function(Ae) {\n            return $(function(gs) {\n              return Ot(gs.toString(16), 2, \"0\");\n            }, Ae);\n          }, function(Ae, gs) {\n            var ms = Ae.length, en = [], _s = 0;\n            if (ms <= gs)\n              return [Ae.slice()];\n            for (var ys = 0; ys < ms; ys++)\n              en[_s] || en.push([]), en[_s].push(Ae[ys]), (ys + 1) % gs == 0 && _s++;\n            return en;\n          }(ht.slice(er.from, er.to).toJSON().data, St));\n          $t = function(Ae) {\n            return Ae.from === 0 && Ae.to === 1 ? { from: Ae.from, to: Ae.to } : { from: Ae.from / St, to: Math.floor(Ae.to / St) };\n          }(er), Mt = Be / St, xt = 3 * ti, ti >= 4 && (xt += 1), He = 2, Bt = $(function(Ae) {\n            return Ae.length <= 4 ? Ae.join(\" \") : Ae.slice(0, 4).join(\" \") + \"  \" + Ae.slice(4).join(\" \");\n          }, ei), (Gt = (8 * ($t.to > 0 ? $t.to - 1 : $t.to)).toString(16).length) < 2 && (Gt = 2);\n        } else {\n          var vs = ht.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          xt = Qt.column - 1, Mt = Qt.line - 1, $t = Pt(Mt, bt, Ct, vs.length), Bt = vs.slice($t.from, $t.to), Gt = $t.to.toString().length;\n        }\n        var Op = Mt - $t.from;\n        return et(ht) && (Gt = (8 * ($t.to > 0 ? $t.to - 1 : $t.to)).toString(16).length) < 2 && (Gt = 2), B(function(Ae, gs, ms) {\n          var en, _s = ms === Op, ys = _s ? \"> \" : At;\n          return en = et(ht) ? Ot((8 * ($t.from + ms)).toString(16), Gt, \"0\") : Ot(($t.from + ms + 1).toString(), Gt, \" \"), [].concat(Ae, [ys + en + \" | \" + gs], _s ? [At + Dt(\" \", Gt) + \" | \" + Ot(\"\", xt, \" \") + Dt(\"^\", He)] : []);\n        }, [], Bt).join(`\n`);\n      }\n      function Ft(ht, dt) {\n        return [`\n`, \"-- PARSING FAILED \" + Dt(\"-\", 50), `\n\n`, ft(ht, dt), `\n\n`, (xt = dt.expected, xt.length === 1 ? `Expected:\n\n` + xt[0] : `Expected one of the following: \n\n` + xt.join(\", \")), `\n`].join(\"\");\n        var xt;\n      }\n      function It(ht) {\n        return ht.flags !== void 0 ? ht.flags : [ht.global ? \"g\" : \"\", ht.ignoreCase ? \"i\" : \"\", ht.multiline ? \"m\" : \"\", ht.unicode ? \"u\" : \"\", ht.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function zt() {\n        for (var ht = [].slice.call(arguments), dt = ht.length, xt = 0; xt < dt; xt += 1)\n          ct(ht[xt]);\n        return T(function(Mt, Bt) {\n          for (var $t, Gt = new Array(dt), Qt = 0; Qt < dt; Qt += 1) {\n            if (!($t = it(ht[Qt]._(Mt, Bt), $t)).status)\n              return $t;\n            Gt[Qt] = $t.value, Bt = $t.index;\n          }\n          return it(nt(Bt, Gt), $t);\n        });\n      }\n      function kt() {\n        var ht = [].slice.call(arguments);\n        if (ht.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var dt = ht.pop();\n        return vt(dt), zt.apply(null, ht).map(function(xt) {\n          return dt.apply(null, xt);\n        });\n      }\n      function Tt() {\n        var ht = [].slice.call(arguments), dt = ht.length;\n        if (dt === 0)\n          return wt(\"zero alternates\");\n        for (var xt = 0; xt < dt; xt += 1)\n          ct(ht[xt]);\n        return T(function(Mt, Bt) {\n          for (var $t, Gt = 0; Gt < ht.length; Gt += 1)\n            if (($t = it(ht[Gt]._(Mt, Bt), $t)).status)\n              return $t;\n          return $t;\n        });\n      }\n      function jt(ht, dt) {\n        return Nt(ht, dt).or(Ht([]));\n      }\n      function Nt(ht, dt) {\n        return ct(ht), ct(dt), kt(ht, dt.then(ht).many(), function(xt, Mt) {\n          return [xt].concat(Mt);\n        });\n      }\n      function Et(ht) {\n        mt(ht);\n        var dt = \"'\" + ht + \"'\";\n        return T(function(xt, Mt) {\n          var Bt = Mt + ht.length, $t = xt.slice(Mt, Bt);\n          return $t === ht ? nt(Bt, $t) : st(Mt, dt);\n        });\n      }\n      function Lt(ht, dt) {\n        (function(Bt) {\n          if (!(Bt instanceof RegExp))\n            throw new Error(\"not a regexp: \" + Bt);\n          for (var $t = It(Bt), Gt = 0; Gt < $t.length; Gt++) {\n            var Qt = $t.charAt(Gt);\n            if (Qt !== \"i\" && Qt !== \"m\" && Qt !== \"u\" && Qt !== \"s\")\n              throw new Error('unsupported regexp flag \"' + Qt + '\": ' + Bt);\n          }\n        })(ht), arguments.length >= 2 ? _t(dt) : dt = 0;\n        var xt = function(Bt) {\n          return RegExp(\"^(?:\" + Bt.source + \")\", It(Bt));\n        }(ht), Mt = \"\" + ht;\n        return T(function(Bt, $t) {\n          var Gt = xt.exec(Bt.slice($t));\n          if (Gt) {\n            if (0 <= dt && dt <= Gt.length) {\n              var Qt = Gt[0], Se = Gt[dt];\n              return nt($t + Qt.length, Se);\n            }\n            return st($t, \"valid match group (0 to \" + Gt.length + \") in \" + Mt);\n          }\n          return st($t, Mt);\n        });\n      }\n      function Ht(ht) {\n        return T(function(dt, xt) {\n          return nt(xt, ht);\n        });\n      }\n      function wt(ht) {\n        return T(function(dt, xt) {\n          return st(xt, ht);\n        });\n      }\n      function Wt(ht) {\n        if (Q(ht))\n          return T(function(dt, xt) {\n            var Mt = ht._(dt, xt);\n            return Mt.index = xt, Mt.value = \"\", Mt;\n          });\n        if (typeof ht == \"string\")\n          return Wt(Et(ht));\n        if (ht instanceof RegExp)\n          return Wt(Lt(ht));\n        throw new Error(\"not a string, regexp, or parser: \" + ht);\n      }\n      function ee(ht) {\n        return ct(ht), T(function(dt, xt) {\n          var Mt = ht._(dt, xt), Bt = dt.slice(xt, Mt.index);\n          return Mt.status ? st(xt, 'not \"' + Bt + '\"') : nt(xt, null);\n        });\n      }\n      function Jt(ht) {\n        return vt(ht), T(function(dt, xt) {\n          var Mt = gt(dt, xt);\n          return xt < dt.length && ht(Mt) ? nt(xt + 1, Mt) : st(xt, \"a character/byte matching \" + ht);\n        });\n      }\n      function xe(ht, dt) {\n        arguments.length < 2 && (dt = ht, ht = void 0);\n        var xt = T(function(Mt, Bt) {\n          return xt._ = dt()._, xt._(Mt, Bt);\n        });\n        return ht ? xt.desc(ht) : xt;\n      }\n      function ke() {\n        return wt(\"fantasy-land/empty\");\n      }\n      D.parse = function(ht) {\n        if (typeof ht != \"string\" && !et(ht))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var dt, xt = this.skip(fe)._(ht, 0);\n        return dt = xt.status ? { status: !0, value: xt.value } : { status: !1, index: ut(ht, xt.furthest), expected: xt.expected }, delete at[ht], dt;\n      }, D.tryParse = function(ht) {\n        var dt = this.parse(ht);\n        if (dt.status)\n          return dt.value;\n        var xt = Ft(ht, dt), Mt = new Error(xt);\n        throw Mt.type = \"ParsimmonError\", Mt.result = dt, Mt;\n      }, D.assert = function(ht, dt) {\n        return this.chain(function(xt) {\n          return ht(xt) ? Ht(xt) : wt(dt);\n        });\n      }, D.or = function(ht) {\n        return Tt(this, ht);\n      }, D.trim = function(ht) {\n        return this.wrap(ht, ht);\n      }, D.wrap = function(ht, dt) {\n        return kt(ht, this, dt, function(xt, Mt) {\n          return Mt;\n        });\n      }, D.thru = function(ht) {\n        return ht(this);\n      }, D.then = function(ht) {\n        return ct(ht), zt(this, ht).map(function(dt) {\n          return dt[1];\n        });\n      }, D.many = function() {\n        var ht = this;\n        return T(function(dt, xt) {\n          for (var Mt = [], Bt = void 0; ; ) {\n            if (!(Bt = it(ht._(dt, xt), Bt)).status)\n              return it(nt(xt, Mt), Bt);\n            if (xt === Bt.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            xt = Bt.index, Mt.push(Bt.value);\n          }\n        });\n      }, D.tieWith = function(ht) {\n        return mt(ht), this.map(function(dt) {\n          if (function(Bt) {\n            if (!rt(Bt))\n              throw new Error(\"not an array: \" + Bt);\n          }(dt), dt.length) {\n            mt(dt[0]);\n            for (var xt = dt[0], Mt = 1; Mt < dt.length; Mt++)\n              mt(dt[Mt]), xt += ht + dt[Mt];\n            return xt;\n          }\n          return \"\";\n        });\n      }, D.tie = function() {\n        return this.tieWith(\"\");\n      }, D.times = function(ht, dt) {\n        var xt = this;\n        return arguments.length < 2 && (dt = ht), _t(ht), _t(dt), T(function(Mt, Bt) {\n          for (var $t = [], Gt = void 0, Qt = void 0, Se = 0; Se < ht; Se += 1) {\n            if (Qt = it(Gt = xt._(Mt, Bt), Qt), !Gt.status)\n              return Qt;\n            Bt = Gt.index, $t.push(Gt.value);\n          }\n          for (; Se < dt && (Qt = it(Gt = xt._(Mt, Bt), Qt), Gt.status); Se += 1)\n            Bt = Gt.index, $t.push(Gt.value);\n          return it(nt(Bt, $t), Qt);\n        });\n      }, D.result = function(ht) {\n        return this.map(function() {\n          return ht;\n        });\n      }, D.atMost = function(ht) {\n        return this.times(0, ht);\n      }, D.atLeast = function(ht) {\n        return kt(this.times(ht), this.many(), function(dt, xt) {\n          return dt.concat(xt);\n        });\n      }, D.map = function(ht) {\n        vt(ht);\n        var dt = this;\n        return T(function(xt, Mt) {\n          var Bt = dt._(xt, Mt);\n          return Bt.status ? it(nt(Bt.index, ht(Bt.value)), Bt) : Bt;\n        });\n      }, D.contramap = function(ht) {\n        vt(ht);\n        var dt = this;\n        return T(function(xt, Mt) {\n          var Bt = dt.parse(ht(xt.slice(Mt)));\n          return Bt.status ? nt(Mt + xt.length, Bt.value) : Bt;\n        });\n      }, D.promap = function(ht, dt) {\n        return vt(ht), vt(dt), this.contramap(ht).map(dt);\n      }, D.skip = function(ht) {\n        return zt(this, ht).map(function(dt) {\n          return dt[0];\n        });\n      }, D.mark = function() {\n        return kt(ue, this, ue, function(ht, dt, xt) {\n          return { start: ht, value: dt, end: xt };\n        });\n      }, D.node = function(ht) {\n        return kt(ue, this, ue, function(dt, xt, Mt) {\n          return { name: ht, value: xt, start: dt, end: Mt };\n        });\n      }, D.sepBy = function(ht) {\n        return jt(this, ht);\n      }, D.sepBy1 = function(ht) {\n        return Nt(this, ht);\n      }, D.lookahead = function(ht) {\n        return this.skip(Wt(ht));\n      }, D.notFollowedBy = function(ht) {\n        return this.skip(ee(ht));\n      }, D.desc = function(ht) {\n        rt(ht) || (ht = [ht]);\n        var dt = this;\n        return T(function(xt, Mt) {\n          var Bt = dt._(xt, Mt);\n          return Bt.status || (Bt.expected = ht), Bt;\n        });\n      }, D.fallback = function(ht) {\n        return this.or(Ht(ht));\n      }, D.ap = function(ht) {\n        return kt(ht, this, function(dt, xt) {\n          return dt(xt);\n        });\n      }, D.chain = function(ht) {\n        var dt = this;\n        return T(function(xt, Mt) {\n          var Bt = dt._(xt, Mt);\n          return Bt.status ? it(ht(Bt.value)._(xt, Bt.index), Bt) : Bt;\n        });\n      }, D.concat = D.or, D.empty = ke, D.of = Ht, D[\"fantasy-land/ap\"] = D.ap, D[\"fantasy-land/chain\"] = D.chain, D[\"fantasy-land/concat\"] = D.concat, D[\"fantasy-land/empty\"] = D.empty, D[\"fantasy-land/of\"] = D.of, D[\"fantasy-land/map\"] = D.map;\n      var ue = T(function(ht, dt) {\n        return nt(dt, ut(ht, dt));\n      }), me = T(function(ht, dt) {\n        return dt >= ht.length ? st(dt, \"any character/byte\") : nt(dt + 1, gt(ht, dt));\n      }), pe = T(function(ht, dt) {\n        return nt(ht.length, ht.slice(dt));\n      }), fe = T(function(ht, dt) {\n        return dt < ht.length ? st(dt, \"EOF\") : nt(dt, null);\n      }), ce = Lt(/[0-9]/).desc(\"a digit\"), ie = Lt(/[0-9]*/).desc(\"optional digits\"), ze = Lt(/[a-z]/i).desc(\"a letter\"), ds = Lt(/[a-z]*/i).desc(\"optional letters\"), $a = Lt(/\\s*/).desc(\"optional whitespace\"), Gc = Lt(/\\s+/).desc(\"whitespace\"), Ga = Et(\"\\r\"), ps = Et(`\n`), Ql = Et(`\\r\n`), tu = Tt(Ql, ps, Ga).desc(\"newline\"), Uc = Tt(tu, fe);\n      T.all = pe, T.alt = Tt, T.any = me, T.cr = Ga, T.createLanguage = function(ht) {\n        var dt = {};\n        for (var xt in ht)\n          ({}).hasOwnProperty.call(ht, xt) && function(Mt) {\n            dt[Mt] = xe(function() {\n              return ht[Mt](dt);\n            });\n          }(xt);\n        return dt;\n      }, T.crlf = Ql, T.custom = function(ht) {\n        return T(ht(nt, st));\n      }, T.digit = ce, T.digits = ie, T.empty = ke, T.end = Uc, T.eof = fe, T.fail = wt, T.formatError = Ft, T.index = ue, T.isParser = Q, T.lazy = xe, T.letter = ze, T.letters = ds, T.lf = ps, T.lookahead = Wt, T.makeFailure = st, T.makeSuccess = nt, T.newline = tu, T.noneOf = function(ht) {\n        return Jt(function(dt) {\n          return ht.indexOf(dt) < 0;\n        }).desc(\"none of '\" + ht + \"'\");\n      }, T.notFollowedBy = ee, T.of = Ht, T.oneOf = function(ht) {\n        for (var dt = ht.split(\"\"), xt = 0; xt < dt.length; xt++)\n          dt[xt] = \"'\" + dt[xt] + \"'\";\n        return Jt(function(Mt) {\n          return ht.indexOf(Mt) >= 0;\n        }).desc(dt);\n      }, T.optWhitespace = $a, T.Parser = T, T.range = function(ht, dt) {\n        return Jt(function(xt) {\n          return ht <= xt && xt <= dt;\n        }).desc(ht + \"-\" + dt);\n      }, T.regex = Lt, T.regexp = Lt, T.sepBy = jt, T.sepBy1 = Nt, T.seq = zt, T.seqMap = kt, T.seqObj = function() {\n        for (var ht, dt = {}, xt = 0, Mt = (ht = arguments, Array.prototype.slice.call(ht)), Bt = Mt.length, $t = 0; $t < Bt; $t += 1) {\n          var Gt = Mt[$t];\n          if (!Q(Gt)) {\n            if (rt(Gt) && Gt.length === 2 && typeof Gt[0] == \"string\" && Q(Gt[1])) {\n              var Qt = Gt[0];\n              if (Object.prototype.hasOwnProperty.call(dt, Qt))\n                throw new Error(\"seqObj: duplicate key \" + Qt);\n              dt[Qt] = !0, xt++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (xt === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return T(function(Se, He) {\n          for (var Be, ti = {}, er = 0; er < Bt; er += 1) {\n            var ei, vs;\n            if (rt(Mt[er]) ? (ei = Mt[er][0], vs = Mt[er][1]) : (ei = null, vs = Mt[er]), !(Be = it(vs._(Se, He), Be)).status)\n              return Be;\n            ei && (ti[ei] = Be.value), He = Be.index;\n          }\n          return it(nt(He, ti), Be);\n        });\n      }, T.string = Et, T.succeed = Ht, T.takeWhile = function(ht) {\n        return vt(ht), T(function(dt, xt) {\n          for (var Mt = xt; Mt < dt.length && ht(gt(dt, Mt)); )\n            Mt++;\n          return nt(Mt, dt.slice(xt, Mt));\n        });\n      }, T.test = Jt, T.whitespace = Gc, T[\"fantasy-land/empty\"] = ke, T[\"fantasy-land/of\"] = Ht, T.Binary = { bitSeq: X, bitSeqObj: function(ht) {\n        H();\n        var dt = {}, xt = 0, Mt = $(function($t) {\n          if (rt($t)) {\n            var Gt = $t;\n            if (Gt.length !== 2)\n              throw new Error(\"[\" + Gt.join(\", \") + \"] should be length 2, got length \" + Gt.length);\n            if (mt(Gt[0]), _t(Gt[1]), Object.prototype.hasOwnProperty.call(dt, Gt[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + Gt[0]);\n            return dt[Gt[0]] = !0, xt++, Gt;\n          }\n          return _t($t), [null, $t];\n        }, ht);\n        if (xt < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + ht.join(\", \") + \"]\");\n        var Bt = $(function($t) {\n          return $t[0];\n        }, Mt);\n        return X($(function($t) {\n          return $t[1];\n        }, Mt)).map(function($t) {\n          return B(function(Gt, Qt) {\n            return Qt[0] !== null && (Gt[Qt[0]] = Qt[1]), Gt;\n          }, {}, $(function(Gt, Qt) {\n            return [Gt, $t[Qt]];\n          }, Bt));\n        });\n      }, byte: function(ht) {\n        if (H(), _t(ht), ht > 255)\n          throw new Error(\"Value specified to byte constructor (\" + ht + \"=0x\" + ht.toString(16) + \") is larger in value than a single byte.\");\n        var dt = (ht > 15 ? \"0x\" : \"0x0\") + ht.toString(16);\n        return T(function(xt, Mt) {\n          var Bt = gt(xt, Mt);\n          return Bt === ht ? nt(Mt + 1, Bt) : st(Mt, dt);\n        });\n      }, buffer: function(ht) {\n        return Y(\"buffer\", ht).map(function(dt) {\n          return Buffer.from(dt);\n        });\n      }, encodedString: function(ht, dt) {\n        return Y(\"string\", dt).map(function(xt) {\n          return xt.toString(ht);\n        });\n      }, uintBE: q, uint8BE: q(1), uint16BE: q(2), uint32BE: q(4), uintLE: K, uint8LE: K(1), uint16LE: K(2), uint32LE: K(4), intBE: Z, int8BE: Z(1), int16BE: Z(2), int32BE: Z(4), intLE: J, int8LE: J(1), int16LE: J(2), int32LE: J(4), floatBE: Y(\"floatBE\", 4).map(function(ht) {\n        return ht.readFloatBE(0);\n      }), floatLE: Y(\"floatLE\", 4).map(function(ht) {\n        return ht.readFloatLE(0);\n      }), doubleBE: Y(\"doubleBE\", 8).map(function(ht) {\n        return ht.readDoubleBE(0);\n      }), doubleLE: Y(\"doubleLE\", 8).map(function(ht) {\n        return ht.readDoubleLE(0);\n      }) }, e.exports = T;\n    }]);\n  });\n})(parsimmon_umd_min);\nvar cn, qt, Kt, Ni, Li, bs, xu, ao, zc, Su, Eu, kf;\nconst Df = class {\n  constructor(t, e = \"\\\\\") {\n    tt(this, qt);\n    tt(this, Li);\n    tt(this, ao);\n    tt(this, cn, null);\n    tt(this, Ni, {\n      \"!num!\": (t) => t.shift(),\n      \"!str!\": (t) => lt(this, ao, zc).call(this, t.shift()),\n      \"!bool!\": (t) => t.shift(),\n      \"!\": (t) => {\n        const e = t.shift();\n        return e[0] === \"!bool!\" ? !Boolean(e[1]) : String(lt(this, qt, Kt).call(this, e)) !== \"true\";\n      },\n      \"~\": (t) => ~Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"**\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) ** Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"*\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) * Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"/\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) / Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"¥\": (t) => Math.floor(z(this, Ni)[\"/\"](t)),\n      \"%\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) % Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"+\": (t) => {\n        const e = lt(this, qt, Kt).call(this, t.shift()), r = lt(this, qt, Kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) === \"[object String]\" || Object.prototype.toString.call(r) === \"[object String]\" ? String(e) + String(r) : Number(e) + Number(r);\n      },\n      \"-\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) - Number(lt(this, qt, Kt).call(this, t.shift())),\n      int: (t) => int(lt(this, Li, bs).call(this, t.shift())),\n      parseInt: (t) => int(z(this, Ni).Number(t)),\n      Number: (t) => {\n        const e = lt(this, qt, Kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) !== \"[object String]\" ? Number(e) : lt(this, Li, bs).call(this, z(this, cn).parse(String(e)).value);\n      },\n      ceil: (t) => Math.ceil(lt(this, Li, bs).call(this, t.shift())),\n      floor: (t) => Math.floor(lt(this, Li, bs).call(this, t.shift())),\n      round: (t) => Math.round(lt(this, Li, bs).call(this, t.shift())),\n      isNaN: (t) => isNaN(Number(lt(this, qt, Kt).call(this, t.shift()))),\n      \"<<\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) << Number(lt(this, qt, Kt).call(this, t.shift())),\n      \">>\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) >> Number(lt(this, qt, Kt).call(this, t.shift())),\n      \">>>\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) >>> Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"<\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) < Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"<=\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) <= Number(lt(this, qt, Kt).call(this, t.shift())),\n      \">\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) > Number(lt(this, qt, Kt).call(this, t.shift())),\n      \">=\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) >= Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"==\": (t) => {\n        const e = lt(this, qt, Kt).call(this, t.shift()), r = lt(this, qt, Kt).call(this, t.shift());\n        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);\n      },\n      \"!=\": (t) => !z(this, Ni)[\"==\"](t),\n      \"===\": (t) => {\n        const e = lt(this, qt, Kt).call(this, t.shift()), r = lt(this, qt, Kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);\n      },\n      \"!==\": (t) => !z(this, Ni)[\"===\"](t),\n      \"&\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) & Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"^\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) ^ Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"|\": (t) => Number(lt(this, qt, Kt).call(this, t.shift())) | Number(lt(this, qt, Kt).call(this, t.shift())),\n      \"&&\": (t) => String(lt(this, qt, Kt).call(this, t.shift())) === \"true\" && String(lt(this, qt, Kt).call(this, t.shift())) === \"true\",\n      \"||\": (t) => String(lt(this, qt, Kt).call(this, t.shift())) === \"true\" || String(lt(this, qt, Kt).call(this, t.shift())) === \"true\",\n      \"?\": (t) => {\n        const e = t.shift();\n        let r = !1;\n        if (e[0] === \"!bool!\")\n          r = Boolean(e[1]);\n        else {\n          const T = String(lt(this, qt, Kt).call(this, e));\n          r = T !== \"true\" && T !== \"false\" ? int(T) !== 0 : T === \"true\";\n        }\n        const S = t.shift();\n        if (S[0] !== \":\")\n          throw Error(\"(PropParser)三項演算子の文法エラーです。: が見つかりません\");\n        return lt(this, qt, Kt).call(this, S[r ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)三項演算子の文法エラーです。? が見つかりません\");\n      }\n    });\n    tt(this, xu, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g);\n    Rt(this, \"getValAmpersand\", (t) => t.at(0) === \"&\" ? String(this.parse(t.slice(1))) : t);\n    this.val = t;\n    function r(q) {\n      const K = [];\n      for (const Z of q)\n        K.push(\n          (Z instanceof RegExp ? parsimmon_umd_min.exports.regex(Z) : parsimmon_umd_min.exports.string(Z)).trim(parsimmon_umd_min.exports.optWhitespace)\n        );\n      return parsimmon_umd_min.exports.alt.apply(null, K);\n    }\n    function S(q, K) {\n      const Z = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(q, Z).or(K));\n      return Z;\n    }\n    function T(q, K) {\n      let Z = parsimmon_umd_min.exports.lazy(\n        () => K.chain(\n          (J) => parsimmon_umd_min.exports.seq(\n            q,\n            parsimmon_umd_min.exports.of(J),\n            Z\n          ).or(parsimmon_umd_min.exports.of(J))\n        )\n      );\n      return Z;\n    }\n    function D(q, K) {\n      return parsimmon_umd_min.exports.seqMap(\n        K,\n        parsimmon_umd_min.exports.seq(q, K).many(),\n        (Z, J) => J.reduce((Q, rt) => [rt[0], Q, rt[1]], Z)\n      );\n    }\n    const N = parsimmon_umd_min.exports.alt(\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((q) => int(q))\n    ).map((q) => [\"!num!\", q]).desc(\"number\"), B = parsimmon_umd_min.exports.string(\"null\").map(() => [\"!str!\", null]), $ = parsimmon_umd_min.exports.regex(/(true|false)/).map((q) => [\"!bool!\", q === \"true\"]).desc(\"boolean\"), U = parsimmon_umd_min.exports.regex(new RegExp(`(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)`)).map((q) => [\"!str!\", q.slice(1, -1).replaceAll(e, \"\")]).desc(\"string\"), V = /\\[[^\\]]+\\]/g, H = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((q) => {\n      const K = String(q).replaceAll(\n        V,\n        (J) => \".\" + this.parse(J.slice(1, -1))\n      );\n      if (K.at(0) === \"-\") {\n        const J = this.val.getVal(K.slice(1));\n        if (J == null || String(J) === \"null\")\n          throw Error(\"(PropParser)数値以外に-符号がついています\");\n        return [\"!num!\", -Number(J)];\n      }\n      const Z = this.val.getVal(K);\n      return Z == null ? [\"!str!\", Z] : typeof Z == \"boolean\" ? [\"!bool!\", Z] : Object.prototype.toString.call(Z) === \"[object String]\" ? [\"!str!\", String(Z)] : [\"!num!\", Number(Z)];\n    }).desc(\"string\"), X = parsimmon_umd_min.exports.lazy(\n      () => parsimmon_umd_min.exports.string(\"(\").then(z(this, cn)).skip(parsimmon_umd_min.exports.string(\")\")).or(N).or(B).or($).or(U).or(H)\n    ), W = [\n      { type: S, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      { type: S, ops: r([/(!(?!=)|~)/]) },\n      { type: T, ops: r([\"**\"]) },\n      { type: D, ops: r([\"*\", \"/\", \"¥\", \"%\"]) },\n      { type: D, ops: r([\"+\", \"-\"]) },\n      { type: D, ops: r([/(>>>|<<|>>)/]) },\n      { type: D, ops: r([/(<=|<|>=|>)/]) },\n      { type: D, ops: r([/(===|!==|==|!=)/]) },\n      { type: D, ops: r([/&(?!&)/]) },\n      { type: D, ops: r([\"^\"]) },\n      { type: D, ops: r([/\\|(?!\\|)/]) },\n      { type: D, ops: r([\"&&\"]) },\n      { type: D, ops: r([\"||\"]) },\n      { type: T, ops: r([\":\"]) },\n      { type: T, ops: r([\"?\"]) }\n    ].reduce(\n      (q, K) => K.type(K.ops, q),\n      X\n    );\n    ot(this, cn, W.trim(parsimmon_umd_min.exports.optWhitespace));\n  }\n  parse(t) {\n    const e = z(this, cn).parse(t);\n    if (!e.status)\n      throw Error(\"(PropParser)文法エラー【\" + t + \"】\");\n    const r = e.value;\n    return r[0] === \"!str!\" ? lt(this, ao, zc).call(this, r[1]) : lt(this, qt, Kt).call(this, r);\n  }\n  static getValName(t) {\n    var N;\n    const e = z(this, Su).exec(t.trim()), r = e == null ? void 0 : e.groups;\n    if (!r)\n      return null;\n    const { scope: S = \"tmp\", name: T, at: D = \"\" } = r;\n    return {\n      scope: S,\n      name: lt(N = Df, Eu, kf).call(N, T),\n      at: D\n    };\n  }\n};\nlet PropParser = Df;\ncn = new WeakMap(), qt = new WeakSet(), Kt = function(t) {\n  const e = t.shift();\n  if (e instanceof Array)\n    return lt(this, qt, Kt).call(this, e);\n  const r = z(this, Ni)[e];\n  return r ? r(t) : Object(null);\n}, Ni = new WeakMap(), Li = new WeakSet(), bs = function(t) {\n  const e = lt(this, qt, Kt).call(this, t);\n  if (Object.prototype.toString.call(e) !== \"[object Number]\")\n    throw Error(\"(PropParser)引数【\" + e + \"】が数値ではありません\");\n  return Number(e);\n}, xu = new WeakMap(), ao = new WeakSet(), zc = function(t) {\n  return t == null ? t : String(t).replaceAll(z(this, xu), (e) => e.at(0) === \"$\" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));\n}, Su = new WeakMap(), Eu = new WeakSet(), kf = function(t) {\n  let e = 0, r = 0;\n  for (; ; ) {\n    if (e = t.indexOf('[\"'), e < 0) {\n      if (e = t.indexOf(\"['\"), e < 0)\n        break;\n      r = t.indexOf(\"']\", e + 2);\n    } else\n      r = t.indexOf('\"]', e + 2);\n    if (r < 0)\n      break;\n    t = t.slice(0, e) + \".\" + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;\n  }\n  return t;\n}, tt(PropParser, Eu), tt(PropParser, Su, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar Er, fn, Ms, Tr, oo, Tu, Bf, wu, Ff, Cu, $f, Pu, Gf;\nconst de = class {\n  constructor(t, e, r) {\n    tt(this, Tu);\n    tt(this, wu);\n    tt(this, oo, !0);\n    this.sys = t, ot(de, Er, r), ot(de, fn, e), ot(de, Ms, e.title), de.myTrace = lt(de, Cu, $f), e.log = (S) => lt(this, Tu, Bf).call(this, S), e.trace = (S) => lt(this, wu, Ff).call(this, S), ot(de, Tr, document.createElement(\"span\")), z(de, Tr).hidden = !0, z(de, Tr).textContent = \"\", z(de, Tr).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(z(de, Tr));\n  }\n  destroy() {\n    ot(de, Ms, () => !1), document.body.removeChild(z(de, Tr)), de.myTrace = de.trace_beforeNew;\n  }\n  static trace_beforeNew(t, e = \"E\") {\n    let r = `{${e}} ` + t, S = \"\";\n    switch (e) {\n      case \"D\":\n        S = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        S = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        S = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw r;\n      case \"E\":\n        console.error(\"%c\" + r, \"color:#FF3300;\");\n        return;\n      default:\n        S = \"color:black;\", r = \" \" + r;\n    }\n    console.info(\"%c\" + r, S);\n  }\n};\nlet DebugMng = de;\nEr = new WeakMap(), fn = new WeakMap(), Ms = new WeakMap(), Tr = new WeakMap(), oo = new WeakMap(), Tu = new WeakSet(), Bf = function(t) {\n  let e = \"\";\n  return z(this, oo) && (ot(this, oo, !1), e = `== ${platform.description} ==\n`), this.sys.appendFile(\n    this.sys.path_downloads + \"log.txt\",\n    `${e}--- ${getDateStr(\"-\", \"_\", \"\")} [fn:${z(de, Er).scriptFn} line:${z(de, Er).lineNum}] prj:${this.sys.cur}\n${t.text || `(text is ${t.text})`}\n`,\n    (r) => {\n      r && console.log(r);\n    }\n  ), !1;\n}, wu = new WeakSet(), Ff = function(t) {\n  return de.myTrace(t.text || `(text is ${t.text})`, \"I\"), !1;\n}, Cu = new WeakSet(), $f = function(t, e = \"E\") {\n  var T, D;\n  let r = `{${e}} ` + de.strPos() + t;\n  lt(T = de, Pu, Gf).call(T, r, e);\n  let S = \"\";\n  switch (e) {\n    case \"D\":\n      S = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      S = \"color:#F80;\";\n      break;\n    case \"F\":\n      S = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      if (z(D = de, Ms).call(D, { text: t }), z(this, fn).dump_lay({}), z(this, fn).dump_val({}), z(de, Er).dumpErrForeLine(), z(this, fn).dump_stack({}), e === \"ET\")\n        throw r;\n      console.error(\"%c\" + r, \"color:#F30;\");\n      return;\n    default:\n      S = \"\", r = \" \" + r;\n  }\n  console.info(\"%c\" + r, S);\n}, Pu = new WeakSet(), Gf = function(t, e) {\n  let r = \"\";\n  switch (e) {\n    case \"D\":\n      r = \"color:#05A;\";\n      break;\n    case \"W\":\n      r = \"color:#F80;\";\n      break;\n    case \"F\":\n      r = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      r = \"color:#F30;\";\n      break;\n    default:\n      r = \"\";\n  }\n  z(de, Tr).innerHTML += `<span style='${r}'>${t}</span><br/>`, z(de, Tr).hidden = !1;\n}, tt(DebugMng, Cu), tt(DebugMng, Pu), tt(DebugMng, Er, void 0), tt(DebugMng, fn, void 0), tt(DebugMng, Ms, void 0), tt(DebugMng, Tr, void 0), Rt(DebugMng, \"myTrace\", de.trace_beforeNew), Rt(DebugMng, \"strPos\", () => z(de, Er) && z(de, Er).lineNum > 0 ? `(fn:${z(de, Er).scriptFn} line:${z(de, Er).lineNum}) ` : \"\");\nclass Areas {\n  constructor() {\n    Rt(this, \"hAreas\", /* @__PURE__ */ Object.create(null));\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(t) {\n    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);\n  }\n  record(t) {\n    if (!this.search(t)) {\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (r + 1 === t) {\n          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;\n          return;\n        }\n      if (String(t + 1) in this.hAreas) {\n        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];\n        return;\n      }\n      this.hAreas[t] = t;\n    }\n  }\n  erase(t) {\n    if (!!this.search(t)) {\n      if (String(t) in this.hAreas) {\n        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];\n        return;\n      }\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (!(t < parseInt(e) || r < t)) {\n          if (this.hAreas[e] === t) {\n            this.hAreas[e] = t - 1;\n            return;\n          }\n          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;\n          return;\n        }\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  toString() {\n    let t = \",\";\n    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, S) => r - S))\n      t += e === this.hAreas[e] ? \",\" + e : \",\" + e + \"~\" + this.hAreas[e];\n    return t.slice(1);\n  }\n}\nvar Ne, dr, Te, ri, Oe, nr, Br, lo, Ru, uo, Hc, ho, co, Mu, Uf, Ou, jf, pr, kr, Iu, zf, Du, Hf, Au, Vf, Nu, Xf, Lu, Yf, ku, Wf, Bu, qf, Fu, Kf, Os, iu, fo, Vc, po, dn, vo, Xc, $u, Gu, Is, go, Ds, nu, Uu, Zf, ju, Jf, mo, Yc, _o, Wc, zu, Qf, Hu, td, As, su;\nconst Ts = class {\n  constructor(t, e) {\n    tt(this, uo);\n    tt(this, Mu);\n    tt(this, Ou);\n    tt(this, pr);\n    tt(this, Iu);\n    tt(this, Du);\n    tt(this, Au);\n    tt(this, Nu);\n    tt(this, Lu);\n    tt(this, ku);\n    tt(this, Bu);\n    tt(this, Fu);\n    tt(this, Os);\n    tt(this, fo);\n    tt(this, vo);\n    tt(this, Ds);\n    tt(this, Uu);\n    tt(this, ju);\n    tt(this, mo);\n    tt(this, _o);\n    tt(this, zu);\n    tt(this, Hu);\n    tt(this, As);\n    tt(this, Ne, { sys: {}, save: {}, tmp: {}, mp: {} });\n    tt(this, dr, z(this, Ne).save);\n    tt(this, Te, z(this, Ne).tmp);\n    tt(this, ri, void 0);\n    tt(this, Oe, { sys: {}, mark: {}, kidoku: {} });\n    tt(this, nr, void 0);\n    tt(this, Br, {});\n    tt(this, lo, void 0);\n    tt(this, Ru, {\n      auth: (t, e) => lt(this, uo, Hc).call(this, e.hBreakpoint.aData),\n      var: (t, e) => z(this, ri).send2Dbg(e.ri, { v: z(this, Ne)[e.scope] ?? {} }),\n      set_var: (t, e) => {\n        try {\n          z(this, po).call(this, e.nm, e.val), z(this, ri).send2Dbg(e.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (t, e) => {\n        lt(this, uo, Hc).call(this, e.a), z(this, ri).send2Dbg(e.ri, {});\n      },\n      disconnect: (t) => ot(Ts, dn, {})\n    });\n    tt(this, ho, () => {\n    });\n    tt(this, co, (t) => {\n    });\n    Rt(this, \"getMark\", (t) => z(this, Oe).mark[t]);\n    Rt(this, \"getAreaKidoku\", (t) => z(this, Br)[t]);\n    tt(this, po, (t, e, r = !0) => {\n      if (!t)\n        throw \"[変数に値セット] nameは必須です\";\n      if (e == null)\n        throw \"[変数に値セット] textは必須です（空文字はOK）\";\n      const S = PropParser.getValName(t);\n      if (S === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const T = z(this, Ne)[S.scope];\n      if (!T)\n        throw \"[変数に値セット] scopeが異常【\" + S.scope + \"】です\";\n      const D = S.name;\n      if (D.slice(0, 6) === \"const.\" && D in T)\n        throw \"[変数に値セット] 変数【\" + D + \"】は書き換え不可です\";\n      this.setVal_Nochk(S.scope, D, e, r);\n    });\n    Rt(this, \"getVal\", (t, e) => {\n      if (!t)\n        throw \"[変数参照] nameは必須です\";\n      const r = PropParser.getValName(t);\n      if (r === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const S = z(this, Ne)[r.scope];\n      if (!S)\n        throw \"[変数参照] scopeが異常【\" + r.scope + \"】です\";\n      const T = r.name;\n      let D = S[T];\n      if (!(T in S)) {\n        D = e;\n        let N = \"\";\n        const B = T.split(\".\"), $ = B.length;\n        for (let U = 0; U < $; ++U, N += \".\") {\n          if (N += B[U], !(N in S))\n            continue;\n          let V = JSON.parse(S[N]);\n          if (Object.prototype.toString.call(V) !== \"[object Object]\") {\n            if (U + 1 === $) {\n              D = V;\n              break;\n            }\n            continue;\n          }\n          let H = U;\n          for (; ++H < $; ) {\n            if (!(B[H] in V)) {\n              D = e;\n              break;\n            }\n            if (V = V[B[H]], Object.prototype.toString.call(V) !== \"[object Object]\" || H + 1 === $) {\n              D = V;\n              break;\n            }\n          }\n          D instanceof Object && (D = JSON.stringify(D));\n          break;\n        }\n      }\n      return D instanceof Function && (D = D()), r.at === \"@str\" ? D : lt(this, vo, Xc).call(this, D);\n    });\n    tt(this, $u, /^-?[\\d\\.]+$/);\n    tt(this, Gu, () => {\n      const t = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let e in t) {\n        const r = z(this, Ne)[e], S = t[e];\n        for (let [T, D] of Object.entries(r))\n          S[T] = Object.prototype.toString.call(D) === \"[object Function]\" ? D() : D;\n      }\n      return console.info(\"🥟 [dump_val]\", t), !1;\n    });\n    tt(this, Is, !1);\n    tt(this, go, {\n      \"sys:sn.tagCh.doWait\": (t) => lt(this, Ds, nu).call(this, t),\n      \"sys:sn.tagCh.doWait_Kidoku\": (t) => lt(this, Ds, nu).call(this, t),\n      \"sys:sn.tagCh.msecWait\": (t) => lt(this, Uu, Zf).call(this, t),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (t) => lt(this, ju, Jf).call(this, t),\n      \"sys:sn.tagCh.canskip\": (t) => lt(this, Ds, nu).call(this, t),\n      \"sys:sn.auto.msecPageWait\": (t) => lt(this, mo, Yc).call(this, t),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (t) => lt(this, mo, Yc).call(this, t),\n      \"sys:sn.auto.msecLineWait\": (t) => lt(this, _o, Wc).call(this, t),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (t) => lt(this, _o, Wc).call(this, t),\n      \"save:sn.doRecLog\": (t) => {\n        z(this, co).call(this, ot(this, Is, lt(this, zu, Qf).call(this, t)));\n      },\n      \"save:sn.userFnTail\": (t, e) => this.cfg.userFnTail = e,\n      \"tmp:sn.tagL.enabled\": (t) => lt(this, Hu, td).call(this, t),\n      \"tmp:sn.skip.all\": (t) => lt(this, As, su).call(this, t),\n      \"tmp:sn.skip.enabled\": (t) => lt(this, As, su).call(this, t),\n      \"tmp:sn.auto.enabled\": (t) => lt(this, As, su).call(this, t),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    });\n    if (this.cfg = t, e.let = (T) => lt(this, pr, kr).call(this, T), e.let_abs = (T) => lt(this, Iu, zf).call(this, T), e.let_char_at = (T) => lt(this, Du, Hf).call(this, T), e.let_index_of = (T) => lt(this, Au, Vf).call(this, T), e.let_length = (T) => lt(this, Nu, Xf).call(this, T), e.let_replace = (T) => lt(this, Lu, Yf).call(this, T), e.let_round = (T) => lt(this, ku, Wf).call(this, T), e.let_search = (T) => lt(this, Bu, qf).call(this, T), e.let_substr = (T) => lt(this, Fu, Kf).call(this, T), e.clearsysvar = () => lt(this, Os, iu).call(this), e.clearvar = () => lt(this, fo, Vc).call(this), e.dump_val = () => z(this, Gu).call(this), e.copybookmark = (T) => lt(this, Mu, Uf).call(this, T), e.erasebookmark = (T) => lt(this, Ou, jf).call(this, T), z(this, dr)[\"sn.userFnTail\"] = \"\", this.defTmp(\"const.sn.bookmark.json\", () => {\n      const T = [];\n      for (const D of Object.keys(z(this, Oe).mark).sort()) {\n        const N = { ...z(this, Oe).mark[D].json };\n        N.place = D, T.push(N);\n      }\n      return JSON.stringify(T);\n    }), z(this, Te)[\"const.sn.isFirstBoot\"] = !0, z(this, Te)[\"sn.tagL.enabled\"] = !0, z(this, Te)[\"sn.skip.all\"] = !1, z(this, Te)[\"sn.skip.enabled\"] = !1, z(this, Te)[\"sn.auto.enabled\"] = !1, z(this, Te)[\"const.sn.last_page_text\"] = \"\", z(this, Te)[\"const.sn.displayState\"] = !1, z(this, Te)[\"const.Date.getTime\"] = () => new Date().getTime(), z(this, Te)[\"const.Date.getDateStr\"] = () => getDateStr(), z(this, Te)[\"const.sn.platform\"] = JSON.stringify(platform), lt(this, Os, iu).call(this), lt(this, fo, Vc).call(this), z(this, Te)[\"const.sn.config.window.width\"] = t.oCfg.window.width, z(this, Te)[\"const.sn.config.window.height\"] = t.oCfg.window.height, z(this, Te)[\"const.sn.config.book.title\"] = t.oCfg.book.title, z(this, Te)[\"const.sn.config.book.version\"] = t.oCfg.book.version, z(this, Te)[\"const.sn.Math.PI\"] = Math.PI, typeof window > \"u\")\n      return;\n    const r = window, S = r.AudioContext ?? r.webkitAudioContext;\n    z(this, Te)[\"const.sn.needClick2Play\"] = () => new S().state === \"suspended\";\n  }\n  setSys(t) {\n    ot(this, ri, t), t.initVal(z(this, Oe), z(this, Te), (e) => {\n      this.updateData(e), sessionStorage.clear();\n      const r = this.cfg.getNs();\n      ot(this, ho, this.cfg.oCfg.debug.variable ? () => {\n        const T = {};\n        for (const [V, H] of Object.entries(z(this, nr)))\n          T[\"sys:\" + V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"sys\"] = JSON.stringify(T);\n        const D = {};\n        for (const [V, H] of Object.entries(z(this, dr)))\n          D[\"save:\" + V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"save\"] = JSON.stringify(D);\n        const N = {};\n        for (const [V, H] of Object.entries(z(this, Te)))\n          N[V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"tmp\"] = JSON.stringify(N);\n        const B = {};\n        for (const [V, H] of Object.entries(z(this, Ne).mp))\n          B[V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"mp\"] = JSON.stringify(B);\n        const $ = {};\n        for (const [V, H] of Object.entries(z(this, Oe).mark))\n          $[V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"mark\"] = JSON.stringify($);\n        const U = {};\n        for (const [V, H] of Object.entries(z(this, Oe).kidoku))\n          U[V] = H instanceof Function ? H() : H;\n        sessionStorage[r + \"kidoku\"] = JSON.stringify(U), t.flush();\n      } : () => t.flush()), ot(this, lo, (T, D) => t.callHook(T, D)), t.addHook((T, D) => {\n        var N, B;\n        return (B = (N = z(this, Ru))[T]) == null ? void 0 : B.call(N, T, D);\n      });\n      const S = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      (z(this, Te)[\"const.sn.isFirstBoot\"] || S === -1) && lt(this, Os, iu).call(this);\n    });\n  }\n  updateData(t) {\n    ot(this, Oe, t), ot(this, nr, z(this, Ne).sys = z(this, Oe).sys), ot(this, Br, {});\n    for (const [e, r] of Object.entries(z(this, Oe).kidoku)) {\n      const S = new Areas();\n      S.hAreas = { ...r }, z(this, Br)[e] = S;\n    }\n  }\n  flush() {\n    z(this, ho).call(this);\n  }\n  setDoRecProc(t) {\n    ot(this, co, t);\n  }\n  defTmp(t, e) {\n    z(this, Te)[t] = e;\n  }\n  cloneMp() {\n    return { ...z(this, Ne).mp };\n  }\n  setMp(t) {\n    z(this, Ne).mp = t;\n  }\n  setMark(t, e) {\n    z(this, Oe).mark[t] = e, this.flush();\n  }\n  cloneSave() {\n    return { ...z(this, Ne).save };\n  }\n  mark2save(t) {\n    ot(this, dr, z(this, Ne).save = { ...t.hSave }), ot(this, Is, z(this, dr)[\"sn.doRecLog\"] ?? !1);\n  }\n  loadScrWork(t) {\n    t in z(this, Br) || (z(this, Br)[t] = new Areas());\n  }\n  saveKidoku() {\n    for (const [t, { hAreas: e }] of Object.entries(z(this, Br)))\n      z(this, Oe).kidoku[t] = { ...e };\n    this.flush();\n  }\n  setVal_Nochk(t, e, r, S = !1) {\n    var N, B;\n    const T = z(this, Ne)[t];\n    S && (r = lt(this, vo, Xc).call(this, r));\n    const D = t + \":\" + e;\n    if (D in z(Ts, dn)) {\n      const $ = T[e], U = r;\n      $ != U && z(this, lo).call(this, \"data_break\", {\n        dataId: D,\n        old_v: $,\n        new_v: U\n      });\n    }\n    T[e] = r, (B = (N = z(this, go))[D]) == null || B.call(N, e, r);\n  }\n  doRecLog() {\n    return z(this, Is);\n  }\n  defValTrg(t, e) {\n    z(this, go)[t] = e;\n  }\n};\nlet Variable = Ts;\nNe = new WeakMap(), dr = new WeakMap(), Te = new WeakMap(), ri = new WeakMap(), Oe = new WeakMap(), nr = new WeakMap(), Br = new WeakMap(), lo = new WeakMap(), Ru = new WeakMap(), uo = new WeakSet(), Hc = function(t) {\n  ot(Ts, dn, {});\n  for (const e of t)\n    z(Ts, dn)[e.dataId] = 1;\n}, ho = new WeakMap(), co = new WeakMap(), Mu = new WeakSet(), Uf = function(t) {\n  if (!(\"from\" in t))\n    throw \"fromは必須です\";\n  if (!(\"to\" in t))\n    throw \"toは必須です\";\n  const e = Number(t.from), r = Number(t.to);\n  if (e === r)\n    return !1;\n  if (!(e in z(this, Oe).mark))\n    throw `from:${e} のセーブデータは存在しません`;\n  return this.setMark(r, { ...z(this, Oe).mark[e] }), z(this, ri).copyBMFolder(e, r), !1;\n}, Ou = new WeakSet(), jf = function(t) {\n  const { place: e } = t;\n  if (!e)\n    throw \"placeは必須です\";\n  return delete z(this, Oe).mark[e], this.flush(), z(this, ri).eraseBMFolder(e), !1;\n}, pr = new WeakSet(), kr = function(t) {\n  if (!t.name)\n    throw \"nameは必須です\";\n  let e = !0;\n  if (t.cast)\n    switch (t.cast) {\n      case \"num\":\n        argChk_Num(t, \"text\", NaN);\n        break;\n      case \"int\":\n        t.text = String(int(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"uint\":\n        t.text = String(uint(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"bool\":\n        argChk_Boolean(t, \"text\", !1);\n        break;\n      case \"str\":\n        e = !1;\n        break;\n      default:\n        throw \"cast【\" + t.cast + \"】は未定義です\";\n    }\n  return z(this, po).call(this, t.name, t.text, e), !1;\n}, Iu = new WeakSet(), zf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(e < 0 ? -e : e), lt(this, pr, kr).call(this, t), !1;\n}, Du = new WeakSet(), Hf = function(t) {\n  return t.text = (t.text ?? \"\").charAt(argChk_Num(t, \"pos\", 0)), lt(this, pr, kr).call(this, t), !1;\n}, Au = new WeakSet(), Vf = function(t) {\n  const { val: e } = t;\n  if (!e)\n    throw \"valは必須です\";\n  const r = argChk_Num(t, \"start\", 0);\n  return t.text = String((t.text ?? \"\").indexOf(e, r)), lt(this, pr, kr).call(this, t), !1;\n}, Nu = new WeakSet(), Xf = function(t) {\n  return t.text = String((t.text ?? \"\").length), lt(this, pr, kr).call(this, t), !1;\n}, Lu = new WeakSet(), Yf = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String(t.text ?? \"\").replace(r, String(t.val)), lt(this, pr, kr).call(this, t), !1;\n}, ku = new WeakSet(), Wf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(Math.round(e)), lt(this, pr, kr).call(this, t), !1;\n}, Bu = new WeakSet(), qf = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String((t.text ?? \"\").search(r)), lt(this, pr, kr).call(this, t), !1;\n}, Fu = new WeakSet(), Kf = function(t) {\n  const e = argChk_Num(t, \"pos\", 0);\n  return t.text = t.len !== \"all\" ? (t.text ?? \"\").slice(e, e + int(argChk_Num(t, \"len\", 1))) : (t.text ?? \"\").slice(e), lt(this, pr, kr).call(this, t), !1;\n}, Os = new WeakSet(), iu = function() {\n  const t = ot(this, nr, z(this, Ne).sys = z(this, Oe).sys = {});\n  typeof process < \"u\" || (this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0), this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0)), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", !0), this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\"), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", argChk_Num(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", argChk_Num(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500), this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const [r, S] of Object.entries(z(this, Oe).kidoku))\n    S.hAreas = {}, z(this, Br)[r].clear();\n  return this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5), z(this, Ne).mark = z(this, Oe).mark = {}, this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1), this.flush(), !1;\n}, fo = new WeakSet(), Vc = function() {\n  const t = z(this, dr)[\"const.sn.mesLayer\"] ?? \"\", e = z(this, dr)[\"sn.doRecLog\"] ?? !1, r = z(this, dr)[\"const.sn.sLog\"] ?? \"[]\";\n  return ot(this, dr, z(this, Ne).save = {}), this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", t), this.setVal_Nochk(\"save\", \"sn.doRecLog\", e), this.setVal_Nochk(\"save\", \"const.sn.sLog\", r), !1;\n}, po = new WeakMap(), dn = new WeakMap(), vo = new WeakSet(), Xc = function(t) {\n  const e = t;\n  if (e === \"true\")\n    return !0;\n  if (e === \"false\")\n    return !1;\n  if (e === \"null\")\n    return null;\n  if (e !== \"undefined\")\n    return z(this, $u).test(e) ? parseFloat(e) : t;\n}, $u = new WeakMap(), Gu = new WeakMap(), Is = new WeakMap(), go = new WeakMap(), Ds = new WeakSet(), nu = function(t) {\n  argChk_Boolean(z(this, nr), t, !0);\n}, Uu = new WeakSet(), Zf = function(t) {\n  argChk_Num(z(this, nr), t, 10), z(this, nr)[\"sn.tagCh.doWait\"];\n}, ju = new WeakSet(), Jf = function(t) {\n  argChk_Num(\n    z(this, nr),\n    t,\n    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait\n  ), z(this, nr)[\"sn.tagCh.doWait_Kidoku\"];\n}, mo = new WeakSet(), Yc = function(t) {\n  argChk_Num(\n    z(this, nr),\n    t,\n    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait\n  );\n}, _o = new WeakSet(), Wc = function(t) {\n  argChk_Num(z(this, nr), t, 500);\n}, zu = new WeakSet(), Qf = function(t) {\n  return argChk_Boolean(z(this, dr), t, !0);\n}, Hu = new WeakSet(), td = function(t) {\n  argChk_Boolean(z(this, Te), t, !0);\n}, As = new WeakSet(), su = function(t) {\n  argChk_Boolean(z(this, Te), t, !1);\n}, tt(Variable, dn, {});\nvar Easing = {\n  Linear: {\n    None: function(o) {\n      return o;\n    }\n  },\n  Quadratic: {\n    In: function(o) {\n      return o * o;\n    },\n    Out: function(o) {\n      return o * (2 - o);\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);\n    }\n  },\n  Cubic: {\n    In: function(o) {\n      return o * o * o;\n    },\n    Out: function(o) {\n      return --o * o * o + 1;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);\n    }\n  },\n  Quartic: {\n    In: function(o) {\n      return o * o * o * o;\n    },\n    Out: function(o) {\n      return 1 - --o * o * o * o;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);\n    }\n  },\n  Quintic: {\n    In: function(o) {\n      return o * o * o * o * o;\n    },\n    Out: function(o) {\n      return --o * o * o * o * o + 1;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);\n    }\n  },\n  Sinusoidal: {\n    In: function(o) {\n      return 1 - Math.cos(o * Math.PI / 2);\n    },\n    Out: function(o) {\n      return Math.sin(o * Math.PI / 2);\n    },\n    InOut: function(o) {\n      return 0.5 * (1 - Math.cos(Math.PI * o));\n    }\n  },\n  Exponential: {\n    In: function(o) {\n      return o === 0 ? 0 : Math.pow(1024, o - 1);\n    },\n    Out: function(o) {\n      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);\n    },\n    InOut: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);\n    }\n  },\n  Circular: {\n    In: function(o) {\n      return 1 - Math.sqrt(1 - o * o);\n    },\n    Out: function(o) {\n      return Math.sqrt(1 - --o * o);\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);\n    }\n  },\n  Elastic: {\n    In: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);\n    },\n    Out: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);\n    }\n  },\n  Back: {\n    In: function(o) {\n      var t = 1.70158;\n      return o * o * ((t + 1) * o - t);\n    },\n    Out: function(o) {\n      var t = 1.70158;\n      return --o * o * ((t + 1) * o + t) + 1;\n    },\n    InOut: function(o) {\n      var t = 2.5949095;\n      return (o *= 2) < 1 ? 0.5 * (o * o * ((t + 1) * o - t)) : 0.5 * ((o -= 2) * o * ((t + 1) * o + t) + 2);\n    }\n  },\n  Bounce: {\n    In: function(o) {\n      return 1 - Easing.Bounce.Out(1 - o);\n    },\n    Out: function(o) {\n      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;\n    },\n    InOut: function(o) {\n      return o < 0.5 ? Easing.Bounce.In(o * 2) * 0.5 : Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;\n    }\n  }\n}, now$2;\ntypeof self > \"u\" && typeof process < \"u\" && process.hrtime ? now$2 = function() {\n  var o = process.hrtime();\n  return o[0] * 1e3 + o[1] / 1e6;\n} : typeof self < \"u\" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {\n  return new Date().getTime();\n};\nvar now$1$1 = now$2, Group = function() {\n  function o() {\n    this._tweens = {}, this._tweensAddedDuringUpdate = {};\n  }\n  return o.prototype.getAll = function() {\n    var t = this;\n    return Object.keys(this._tweens).map(function(e) {\n      return t._tweens[e];\n    });\n  }, o.prototype.removeAll = function() {\n    this._tweens = {};\n  }, o.prototype.add = function(t) {\n    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;\n  }, o.prototype.remove = function(t) {\n    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];\n  }, o.prototype.update = function(t, e) {\n    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);\n    var r = Object.keys(this._tweens);\n    if (r.length === 0)\n      return !1;\n    for (; r.length > 0; ) {\n      this._tweensAddedDuringUpdate = {};\n      for (var S = 0; S < r.length; S++) {\n        var T = this._tweens[r[S]], D = !e;\n        T && T.update(t, D) === !1 && !e && delete this._tweens[r[S]];\n      }\n      r = Object.keys(this._tweensAddedDuringUpdate);\n    }\n    return !0;\n  }, o;\n}(), Interpolation = {\n  Linear: function(o, t) {\n    var e = o.length - 1, r = e * t, S = Math.floor(r), T = Interpolation.Utils.Linear;\n    return t < 0 ? T(o[0], o[1], r) : t > 1 ? T(o[e], o[e - 1], e - r) : T(o[S], o[S + 1 > e ? e : S + 1], r - S);\n  },\n  Bezier: function(o, t) {\n    for (var e = 0, r = o.length - 1, S = Math.pow, T = Interpolation.Utils.Bernstein, D = 0; D <= r; D++)\n      e += S(1 - t, r - D) * S(t, D) * o[D] * T(r, D);\n    return e;\n  },\n  CatmullRom: function(o, t) {\n    var e = o.length - 1, r = e * t, S = Math.floor(r), T = Interpolation.Utils.CatmullRom;\n    return o[0] === o[e] ? (t < 0 && (S = Math.floor(r = e * (1 + t))), T(o[(S - 1 + e) % e], o[S], o[(S + 1) % e], o[(S + 2) % e], r - S)) : t < 0 ? o[0] - (T(o[0], o[0], o[1], o[1], -r) - o[0]) : t > 1 ? o[e] - (T(o[e], o[e], o[e - 1], o[e - 1], r - e) - o[e]) : T(o[S ? S - 1 : 0], o[S], o[e < S + 1 ? e : S + 1], o[e < S + 2 ? e : S + 2], r - S);\n  },\n  Utils: {\n    Linear: function(o, t, e) {\n      return (t - o) * e + o;\n    },\n    Bernstein: function(o, t) {\n      var e = Interpolation.Utils.Factorial;\n      return e(o) / e(t) / e(o - t);\n    },\n    Factorial: function() {\n      var o = [1];\n      return function(t) {\n        var e = 1;\n        if (o[t])\n          return o[t];\n        for (var r = t; r > 1; r--)\n          e *= r;\n        return o[t] = e, e;\n      };\n    }(),\n    CatmullRom: function(o, t, e, r, S) {\n      var T = (e - o) * 0.5, D = (r - t) * 0.5, N = S * S, B = S * N;\n      return (2 * t - 2 * e + T + D) * B + (-3 * t + 3 * e - 2 * T - D) * N + T * S + t;\n    }\n  }\n}, Sequence = function() {\n  function o() {\n  }\n  return o.nextId = function() {\n    return o._nextId++;\n  }, o._nextId = 0, o;\n}(), mainGroup = new Group(), Tween = function() {\n  function o(t, e) {\n    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;\n  }\n  return o.prototype.getId = function() {\n    return this._id;\n  }, o.prototype.isPlaying = function() {\n    return this._isPlaying;\n  }, o.prototype.isPaused = function() {\n    return this._isPaused;\n  }, o.prototype.to = function(t, e) {\n    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;\n  }, o.prototype.duration = function(t) {\n    return this._duration = t, this;\n  }, o.prototype.start = function(t) {\n    if (this._isPlaying)\n      return this;\n    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {\n      this._reversed = !1;\n      for (var e in this._valuesStartRepeat)\n        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];\n    }\n    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == \"string\" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;\n  }, o.prototype._setupProperties = function(t, e, r, S) {\n    for (var T in r) {\n      var D = t[T], N = Array.isArray(D), B = N ? \"array\" : typeof D, $ = !N && Array.isArray(r[T]);\n      if (!(B === \"undefined\" || B === \"function\")) {\n        if ($) {\n          var U = r[T];\n          if (U.length === 0)\n            continue;\n          U = U.map(this._handleRelativeValue.bind(this, D)), r[T] = [D].concat(U);\n        }\n        if ((B === \"object\" || N) && D && !$) {\n          e[T] = N ? [] : {};\n          for (var V in D)\n            e[T][V] = D[V];\n          S[T] = N ? [] : {}, this._setupProperties(D, e[T], r[T], S[T]);\n        } else\n          typeof e[T] > \"u\" && (e[T] = D), N || (e[T] *= 1), $ ? S[T] = r[T].slice().reverse() : S[T] = e[T] || 0;\n      }\n    }\n  }, o.prototype.stop = function() {\n    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;\n  }, o.prototype.end = function() {\n    return this._goToEnd = !0, this.update(1 / 0), this;\n  }, o.prototype.pause = function(t) {\n    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);\n  }, o.prototype.resume = function(t) {\n    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);\n  }, o.prototype.stopChainedTweens = function() {\n    for (var t = 0, e = this._chainedTweens.length; t < e; t++)\n      this._chainedTweens[t].stop();\n    return this;\n  }, o.prototype.group = function(t) {\n    return this._group = t, this;\n  }, o.prototype.delay = function(t) {\n    return this._delayTime = t, this;\n  }, o.prototype.repeat = function(t) {\n    return this._initialRepeat = t, this._repeat = t, this;\n  }, o.prototype.repeatDelay = function(t) {\n    return this._repeatDelayTime = t, this;\n  }, o.prototype.yoyo = function(t) {\n    return this._yoyo = t, this;\n  }, o.prototype.easing = function(t) {\n    return this._easingFunction = t, this;\n  }, o.prototype.interpolation = function(t) {\n    return this._interpolationFunction = t, this;\n  }, o.prototype.chain = function() {\n    for (var t = [], e = 0; e < arguments.length; e++)\n      t[e] = arguments[e];\n    return this._chainedTweens = t, this;\n  }, o.prototype.onStart = function(t) {\n    return this._onStartCallback = t, this;\n  }, o.prototype.onUpdate = function(t) {\n    return this._onUpdateCallback = t, this;\n  }, o.prototype.onRepeat = function(t) {\n    return this._onRepeatCallback = t, this;\n  }, o.prototype.onComplete = function(t) {\n    return this._onCompleteCallback = t, this;\n  }, o.prototype.onStop = function(t) {\n    return this._onStopCallback = t, this;\n  }, o.prototype.update = function(t, e) {\n    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)\n      return !0;\n    var r, S, T = this._startTime + this._duration;\n    if (!this._goToEnd && !this._isPlaying) {\n      if (t > T)\n        return !1;\n      e && this.start(t);\n    }\n    if (this._goToEnd = !1, t < this._startTime)\n      return !0;\n    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), S = (t - this._startTime) / this._duration, S = this._duration === 0 || S > 1 ? 1 : S;\n    var D = this._easingFunction(S);\n    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, D), this._onUpdateCallback && this._onUpdateCallback(this._object, S), S === 1)\n      if (this._repeat > 0) {\n        isFinite(this._repeat) && this._repeat--;\n        for (r in this._valuesStartRepeat)\n          !this._yoyo && typeof this._valuesEnd[r] == \"string\" && (this._valuesStartRepeat[r] = this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];\n        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;\n      } else {\n        this._onCompleteCallback && this._onCompleteCallback(this._object);\n        for (var N = 0, B = this._chainedTweens.length; N < B; N++)\n          this._chainedTweens[N].start(this._startTime + this._duration);\n        return this._isPlaying = !1, !1;\n      }\n    return !0;\n  }, o.prototype._updateProperties = function(t, e, r, S) {\n    for (var T in r)\n      if (e[T] !== void 0) {\n        var D = e[T] || 0, N = r[T], B = Array.isArray(t[T]), $ = Array.isArray(N), U = !B && $;\n        U ? t[T] = this._interpolationFunction(N, S) : typeof N == \"object\" && N ? this._updateProperties(t[T], D, N, S) : (N = this._handleRelativeValue(D, N), typeof N == \"number\" && (t[T] = D + (N - D) * S));\n      }\n  }, o.prototype._handleRelativeValue = function(t, e) {\n    return typeof e != \"string\" ? e : e.charAt(0) === \"+\" || e.charAt(0) === \"-\" ? t + parseFloat(e) : parseFloat(e);\n  }, o.prototype._swapEndStartRepeatValues = function(t) {\n    var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];\n    typeof r == \"string\" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;\n  }, o;\n}();\nSequence.nextId;\nvar TWEEN = mainGroup;\nTWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nTWEEN.add.bind(TWEEN);\nvar remove$6 = TWEEN.remove.bind(TWEEN), update = TWEEN.update.bind(TWEEN), yo;\nconst Vu = class {\n  static ease(t) {\n    if (!t)\n      return (e) => Easing.Linear.None(e);\n    if (!(t in z(Vu, yo)))\n      throw \"異常なease指定です\";\n    return z(Vu, yo)[t];\n  }\n};\nlet CmnTween = Vu;\nyo = new WeakMap(), tt(CmnTween, yo, {\n  \"Back.In\": (t) => Easing.Back.In(t),\n  \"Back.InOut\": (t) => Easing.Back.InOut(t),\n  \"Back.Out\": (t) => Easing.Back.Out(t),\n  \"Bounce.In\": (t) => Easing.Bounce.In(t),\n  \"Bounce.InOut\": (t) => Easing.Bounce.InOut(t),\n  \"Bounce.Out\": (t) => Easing.Bounce.Out(t),\n  \"Circular.In\": (t) => Easing.Circular.In(t),\n  \"Circular.InOut\": (t) => Easing.Circular.InOut(t),\n  \"Circular.Out\": (t) => Easing.Circular.Out(t),\n  \"Cubic.In\": (t) => Easing.Cubic.In(t),\n  \"Cubic.InOut\": (t) => Easing.Cubic.InOut(t),\n  \"Cubic.Out\": (t) => Easing.Cubic.Out(t),\n  \"Elastic.In\": (t) => Easing.Elastic.In(t),\n  \"Elastic.InOut\": (t) => Easing.Elastic.InOut(t),\n  \"Elastic.Out\": (t) => Easing.Elastic.Out(t),\n  \"Exponential.In\": (t) => Easing.Exponential.In(t),\n  \"Exponential.InOut\": (t) => Easing.Exponential.InOut(t),\n  \"Exponential.Out\": (t) => Easing.Exponential.Out(t),\n  \"Linear.None\": (t) => Easing.Linear.None(t),\n  \"Quadratic.In\": (t) => Easing.Quadratic.In(t),\n  \"Quadratic.InOut\": (t) => Easing.Quadratic.InOut(t),\n  \"Quadratic.Out\": (t) => Easing.Quadratic.Out(t),\n  \"Quartic.In\": (t) => Easing.Quartic.In(t),\n  \"Quartic.InOut\": (t) => Easing.Quartic.InOut(t),\n  \"Quartic.Out\": (t) => Easing.Quartic.Out(t),\n  \"Quintic.In\": (t) => Easing.Quintic.In(t),\n  \"Quintic.InOut\": (t) => Easing.Quintic.InOut(t),\n  \"Quintic.Out\": (t) => Easing.Quintic.Out(t),\n  \"Sinusoidal.In\": (t) => Easing.Sinusoidal.In(t),\n  \"Sinusoidal.InOut\": (t) => Easing.Sinusoidal.InOut(t),\n  \"Sinusoidal.Out\": (t) => Easing.Sinusoidal.Out(t)\n});\nvar s;\nfunction u() {\n  return s;\n}\nvar a = function(o, t) {\n  return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      Object.prototype.hasOwnProperty.call(r, S) && (e[S] = r[S]);\n  })(o, t);\n};\nfunction c(o, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  function e() {\n    this.constructor = o;\n  }\n  a(o, t), o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar l = function() {\n  return (l = Object.assign || function(o) {\n    for (var t, e = 1, r = arguments.length; e < r; e++)\n      for (var S in t = arguments[e])\n        Object.prototype.hasOwnProperty.call(t, S) && (o[S] = t[S]);\n    return o;\n  }).apply(this, arguments);\n}, p = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], h = {};\nfunction f(o) {\n  var t = l({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, o || {}), e = document.createElement(\"audio\"), r = {}, S = /^no$/;\n  p.forEach(function(T) {\n    var D = e.canPlayType(\"audio/\".concat(T)).replace(S, \"\"), N = t[T] ? e.canPlayType(t[T]).replace(S, \"\") : \"\";\n    r[T] = !!D || !!N;\n  }), Object.assign(h, r);\n}\nf();\nvar d = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction _(o) {\n  var t = d, e = typeof o == \"string\" ? o : o.url;\n  if (!t.test(e))\n    return e;\n  for (var r = t.exec(e), S = r[2].split(\",\"), T = S[S.length - 1], D = 0, N = S.length; D < N; D++) {\n    var B = S[D];\n    if (h[B]) {\n      T = B;\n      break;\n    }\n  }\n  var $ = e.replace(r[1], T);\n  if (typeof o != \"string\") {\n    var U = o;\n    U.extension = T, U.url = $;\n  }\n  return $;\n}\nvar y = function() {\n  function o() {\n  }\n  return o.add = function() {\n    o.setLegacy(u().useLegacy);\n  }, o.setLegacy = function(t) {\n    var e = p;\n    t ? e.forEach(function(r) {\n      LoaderResource.setExtensionXhrType(r, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(r, LoaderResource.LOAD_TYPE.AUDIO);\n    }) : e.forEach(function(r) {\n      LoaderResource.setExtensionXhrType(r, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(r, LoaderResource.LOAD_TYPE.XHR);\n    });\n  }, o.pre = function(t, e) {\n    _(t), e();\n  }, o.use = function(t, e) {\n    t.data && p.indexOf(t.extension) > -1 ? t.sound = u().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();\n  }, o.extension = \"loader\", o;\n}(), m = 0, g = function(o) {\n  function t(e) {\n    var r = o.call(this) || this;\n    return r.id = m++, r.init(e), r;\n  }\n  return c(t, o), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n    }\n    return this;\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {\n    this._playing = !0;\n  }, t.prototype._onPause = function() {\n    this._playing = !1;\n  }, t.prototype.init = function(e) {\n    this._playing = !1, this._duration = e.source.duration;\n    var r = this._source = e.source.cloneNode(!1);\n    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on(\"refresh\", this.refresh, this), e.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = e;\n  }, t.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, t.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    var e = this._media.context, r = this._media.parent;\n    this._source.loop = this._loop || r.loop;\n    var S = e.volume * (e.muted ? 0 : 1), T = r.volume * (r.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = D * S * T, this._source.playbackRate = this._speed * e.speed * r.speed;\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, S = this._paused || r.paused || e.paused;\n    S !== this._pausedReal && (this._pausedReal = S, S ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", S));\n  }, t.prototype.play = function(e) {\n    var r = this, S = e.start, T = e.end, D = e.speed, N = e.loop, B = e.volume, $ = e.muted;\n    this._speed = D, this._volume = B, this._loop = !!N, this._muted = $, this.refresh(), this.loop && T !== null && (this.loop = !1), this._start = S, this._end = T || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      r._source && (r._source.currentTime = S, r._source.onloadedmetadata = null, r.emit(\"progress\", S, r._duration), Ticker.shared.add(r._onUpdate, r));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, t.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, t.prototype._onComplete = function() {\n    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t.prototype.destroy = function() {\n    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var e = this._source;\n    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, t.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, t.PADDING = 0.1, t;\n}(i$1), b = function(o) {\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return c(t, o), t.prototype.init = function(e) {\n    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);\n  }, t.prototype.create = function() {\n    return new g(this);\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(t.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {\n    var r = this._source, S = this.parent;\n    if (r.readyState !== 4)\n      if (S.url) {\n        r.src = S.url;\n        var T = function() {\n          B(), S.isLoaded = !0;\n          var U = S.autoPlayStart();\n          e && e(null, S, U);\n        }, D = function() {\n          B(), e && e(new Error(\"Sound loading has been aborted\"));\n        }, N = function() {\n          B();\n          var U = \"Failed to load audio element (code: \".concat(r.error.code, \")\");\n          e && e(new Error(U));\n        }, B = function() {\n          r.removeEventListener(\"canplaythrough\", T), r.removeEventListener(\"load\", T), r.removeEventListener(\"abort\", D), r.removeEventListener(\"error\", N);\n        };\n        r.addEventListener(\"canplaythrough\", T, !1), r.addEventListener(\"load\", T, !1), r.addEventListener(\"abort\", D, !1), r.addEventListener(\"error\", N, !1), r.load();\n      } else\n        e(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      S.isLoaded = !0;\n      var $ = S.autoPlayStart();\n      e && setTimeout(function() {\n        e(null, S, $);\n      }, 0);\n    }\n  }, t;\n}(i$1), v = function() {\n  function o(t, e) {\n    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return o.prototype.play = function(t) {\n    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, o.prototype.destroy = function() {\n    this.parent = null;\n  }, o;\n}(), P = function() {\n  function o() {\n  }\n  return o.setParamValue = function(t, e) {\n    if (t.setValueAtTime) {\n      var r = u().context;\n      t.setValueAtTime(e, r.audioContext.currentTime);\n    } else\n      t.value = e;\n    return e;\n  }, o;\n}(), x = 0, O = function(o) {\n  function t(e) {\n    var r = o.call(this) || this;\n    return r.id = x++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;\n  }\n  return c(t, o), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n    }\n    return this;\n  }, t.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh(), this._update(!0);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(e) {\n    var r;\n    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(S) {\n      return S;\n    }).forEach(function(S) {\n      return S.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    if (this._source) {\n      var e = this._media.context, r = this._media.parent;\n      this._source.loop = this._loop || r.loop;\n      var S = e.volume * (e.muted ? 0 : 1), T = r.volume * (r.muted ? 0 : 1), D = this._volume * (this._muted ? 0 : 1);\n      P.setParamValue(this._gain.gain, D * T * S), P.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();\n    }\n  }, t.prototype.applyFilters = function() {\n    var e;\n    if (!((e = this._filters) === null || e === void 0) && e.length) {\n      this._source.disconnect();\n      var r = this._source;\n      this._filters.forEach(function(S) {\n        r.connect(S.destination), r = S;\n      }), r.connect(this._gain);\n    }\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, S = this._paused || r.paused || e.paused;\n    S !== this._pausedReal && (this._pausedReal = S, S ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", S));\n  }, t.prototype.play = function(e) {\n    var r = e.start, S = e.end, T = e.speed, D = e.loop, N = e.volume, B = e.muted, $ = e.filters;\n    this._paused = !1;\n    var U = this._media.nodes.cloneBufferSource(), V = U.source, H = U.gain;\n    this._source = V, this._gain = H, this._speed = T, this._volume = N, this._loop = !!D, this._muted = B, this._filters = $, this.refresh();\n    var X = this._source.buffer.duration;\n    this._duration = X, this._end = S, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = S, this._source.loopStart = r, this._source.start(0, r)) : S ? this._source.start(0, r, S - r) : this._source.start(0, r), this.emit(\"start\"), this._update(!0), this.enableTicker(!0);\n  }, t.prototype.enableTicker = function(e) {\n    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    var e;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {\n      return r.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;\n  }, t.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, t.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, t.prototype._updateListener = function() {\n    this._update();\n  }, t.prototype._update = function(e) {\n    if (e === void 0 && (e = !1), this._source) {\n      var r = this._now(), S = r - this._lastUpdate;\n      if (S > 0 || e) {\n        var T = this._source.playbackRate.value;\n        this._elapsed += S * T, this._lastUpdate = r;\n        var D = this._duration, N = void 0;\n        if (this._source.loopStart) {\n          var B = this._source.loopEnd - this._source.loopStart;\n          N = (this._source.loopStart + this._elapsed % B) / D;\n        } else\n          N = this._elapsed % D / D;\n        this._progress = N, this.emit(\"progress\", this._progress, D);\n      }\n    }\n  }, t.prototype.init = function(e) {\n    this._media = e, e.context.events.on(\"refresh\", this.refresh, this), e.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, t.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n      this._source = null;\n    }\n  }, t.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t;\n}(i$1), j = function() {\n  function o(t, e) {\n    this._output = e, this._input = t;\n  }\n  return Object.defineProperty(o.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(S) {\n      S && S.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t && t.length) {\n      this._filters = t.slice(0), this._input.disconnect();\n      var r = null;\n      t.forEach(function(S) {\n        r === null ? e._input.connect(S.destination) : r.connect(S.destination), r = S;\n      }), r.connect(this._output);\n    }\n  }, enumerable: !1, configurable: !0 }), o.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, o;\n}(), w = function(o) {\n  function t(e) {\n    var r = this, S = e.audioContext, T = S.createBufferSource(), D = S.createGain(), N = S.createAnalyser();\n    return T.connect(N), N.connect(D), D.connect(e.destination), (r = o.call(this, N, D) || this).context = e, r.bufferSource = T, r.gain = D, r.analyser = N, r;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, t.prototype.cloneBufferSource = function() {\n    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();\n    r.buffer = e.buffer, P.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;\n    var S = this.context.audioContext.createGain();\n    return r.connect(S), S.connect(this.destination), { source: r, gain: S };\n  }, Object.defineProperty(t.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;\n}(j), A = function() {\n  function o() {\n  }\n  return o.prototype.init = function(t) {\n    this.parent = t, this._nodes = new w(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;\n  }, o.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch {\n    }\n    this._source = null, this.source = null;\n  }, o.prototype.create = function() {\n    return new O(this);\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t) {\n    this._nodes.filters = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t) {\n    this._source.buffer = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: !1, configurable: !0 }), o.prototype.load = function(t) {\n    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error(\"sound.url or sound.source must be set\"));\n  }, o.prototype._loadUrl = function(t) {\n    var e = this, r = new XMLHttpRequest(), S = this.parent.url;\n    r.open(\"GET\", S, !0), r.responseType = \"arraybuffer\", r.onload = function() {\n      e.source = r.response, e._decode(r.response, t);\n    }, r.send();\n  }, o.prototype._decode = function(t, e) {\n    var r = this, S = function(T, D) {\n      if (T)\n        e && e(T);\n      else {\n        r.parent.isLoaded = !0, r.buffer = D;\n        var N = r.parent.autoPlayStart();\n        e && e(null, r.parent, N);\n      }\n    };\n    t instanceof AudioBuffer ? S(null, t) : this.parent.context.decode(t, S);\n  }, o;\n}(), F = function() {\n  function o(t, e) {\n    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var r = e.complete;\n    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return o.from = function(t) {\n    var e = {};\n    return typeof t == \"string\" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = l({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = _(e.url)), Object.freeze(e), new o(u().useLegacy ? new b() : new A(), e);\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return u().context;\n  }, enumerable: !1, configurable: !0 }), o.prototype.pause = function() {\n    return this.isPlaying = !1, this.paused = !0, this;\n  }, o.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;\n  }, Object.defineProperty(o.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t) {\n    this._paused = t, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t) {\n    this._speed = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t) {\n    this.media.filters = t;\n  }, enumerable: !1, configurable: !0 }), o.prototype.addSprites = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var S in t)\n        r[S] = this.addSprites(S, t[S]);\n      return r;\n    }\n    var T = new v(this, e);\n    return this._sprites[t] = T, T;\n  }, o.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, o.prototype.removeSprites = function(t) {\n    if (t) {\n      var e = this._sprites[t];\n      e !== void 0 && (e.destroy(), delete this._sprites[t]);\n    } else\n      for (var r in this._sprites)\n        this.removeSprites(r);\n    return this;\n  }, Object.defineProperty(o.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: !1, configurable: !0 }), o.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = !1, this._autoPlayOptions = null, this;\n    this.isPlaying = !1;\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._instances[t].stop();\n    return this;\n  }, o.prototype.play = function(t, e) {\n    var r, S = this;\n    if (typeof t == \"string\" ? r = { sprite: D = t, loop: this.loop, complete: e } : typeof t == \"function\" ? (r = {}).complete = t : r = t, (r = l({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {\n      var T = r.sprite, D = this._sprites[T];\n      r.start = D.start + (r.start || 0), r.end = D.end, r.speed = D.speed || 1, r.loop = D.loop || r.loop, delete r.sprite;\n    }\n    if (r.offset && (r.start = r.offset), !this.isLoaded)\n      return new Promise(function(B, $) {\n        S.autoPlay = !0, S._autoPlayOptions = r, S._preload(function(U, V, H) {\n          U ? $(U) : (r.loaded && r.loaded(U, V, H), B(H));\n        });\n      });\n    (this.singleInstance || r.singleInstance) && this._removeInstances();\n    var N = this._createInstance();\n    return this._instances.push(N), this.isPlaying = !0, N.once(\"end\", function() {\n      r.complete && r.complete(S), S._onComplete(N);\n    }), N.once(\"stop\", function() {\n      S._onComplete(N);\n    }), N.play(r), N;\n  }, o.prototype.refresh = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refresh();\n  }, o.prototype.refreshPaused = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(o.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t) {\n    this._volume = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t) {\n    this._muted = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t) {\n    this._loop = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), o.prototype._preload = function(t) {\n    this.media.load(t);\n  }, Object.defineProperty(o.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: !1, configurable: !0 }), o.prototype.autoPlayStart = function() {\n    var t;\n    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;\n  }, o.prototype._removeInstances = function() {\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._poolInstance(this._instances[t]);\n    this._instances.length = 0;\n  }, o.prototype._onComplete = function(t) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t);\n  }, o.prototype._createInstance = function() {\n    if (o._pool.length > 0) {\n      var t = o._pool.pop();\n      return t.init(this.media), t;\n    }\n    return this.media.create();\n  }, o.prototype._poolInstance = function(t) {\n    t.destroy(), o._pool.indexOf(t) < 0 && o._pool.push(t);\n  }, o._pool = [], o;\n}(), C = function(o) {\n  function t() {\n    var e = o !== null && o.apply(this, arguments) || this;\n    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;\n  }\n  return c(t, o), t.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, t.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, t;\n}(i$1), E = function(o) {\n  function t() {\n    var e = this, r = window, S = new t.AudioContext(), T = S.createDynamicsCompressor(), D = S.createAnalyser();\n    return D.connect(T), T.connect(S.destination), (e = o.call(this, D, T) || this)._ctx = S, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, S.sampleRate)) : 44100), e._unlocked = !1, e.compressor = T, e.analyser = D, e.events = new i$1(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, S.state !== \"running\" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener(\"mousedown\", e._unlock, !0), document.addEventListener(\"touchstart\", e._unlock, !0), document.addEventListener(\"touchend\", e._unlock, !0)), e;\n  }\n  return c(t, o), t.prototype._unlock = function() {\n    this._unlocked || (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, !0), document.removeEventListener(\"touchend\", this._unlock, !0), document.removeEventListener(\"touchstart\", this._unlock, !0), this._unlocked = !0));\n  }, t.prototype.playEmptySound = function() {\n    var e = this._ctx.createBufferSource();\n    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === \"suspended\" && e.context.resume();\n  }, Object.defineProperty(t, \"AudioContext\", { get: function() {\n    var e = window;\n    return e.AudioContext || e.webkitAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, \"OfflineAudioContext\", { get: function() {\n    var e = window;\n    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this);\n    var e = this._ctx;\n    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    e && this._ctx.state === \"running\" ? this._ctx.suspend() : e || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = e;\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, t.prototype.decode = function(e, r) {\n    var S = function(D) {\n      r(new Error((D == null ? void 0 : D.message) || \"Unable to decode file\"));\n    }, T = this._offlineCtx.decodeAudioData(e, function(D) {\n      r(null, D);\n    }, S);\n    T && T.catch(S);\n  }, t;\n}(j), L = function() {\n  function o() {\n    this.init();\n  }\n  return o.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new E()), this._htmlAudioContext = new C(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t) {\n    this.useLegacy || (this._context.filters = t);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"supported\", { get: function() {\n    return E.AudioContext !== null;\n  }, enumerable: !1, configurable: !0 }), o.prototype.add = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var S in t) {\n        var T = this._getOptions(t[S], e);\n        r[S] = this.add(S, T);\n      }\n      return r;\n    }\n    if (e instanceof F)\n      return this._sounds[t] = e, e;\n    var D = this._getOptions(e), N = F.from(D);\n    return this._sounds[t] = N, N;\n  }, o.prototype._getOptions = function(t, e) {\n    var r;\n    return r = typeof t == \"string\" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = l(l({}, r), e || {});\n  }, Object.defineProperty(o.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t) {\n    y.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: !1, configurable: !0 }), o.prototype.remove = function(t) {\n    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;\n  }, Object.defineProperty(o.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t) {\n    this._context.volume = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t) {\n    this._context.speed = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), o.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, o.prototype.pauseAll = function() {\n    return this._context.paused = !0, this._context.refreshPaused(), this;\n  }, o.prototype.resumeAll = function() {\n    return this._context.paused = !1, this._context.refreshPaused(), this;\n  }, o.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, o.prototype.muteAll = function() {\n    return this._context.muted = !0, this._context.refresh(), this;\n  }, o.prototype.unmuteAll = function() {\n    return this._context.muted = !1, this._context.refresh(), this;\n  }, o.prototype.removeAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].destroy(), delete this._sounds[t];\n    return this;\n  }, o.prototype.stopAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].stop();\n    return this;\n  }, o.prototype.exists = function(t, e) {\n    return !!this._sounds[t];\n  }, o.prototype.find = function(t) {\n    return this.exists(t, !0), this._sounds[t];\n  }, o.prototype.play = function(t, e) {\n    return this.find(t).play(e);\n  }, o.prototype.stop = function(t) {\n    return this.find(t).stop();\n  }, o.prototype.pause = function(t) {\n    return this.find(t).pause();\n  }, o.prototype.resume = function(t) {\n    return this.find(t).resume();\n  }, o.prototype.volume = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.volume = e), r.volume;\n  }, o.prototype.speed = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.speed = e), r.speed;\n  }, o.prototype.duration = function(t) {\n    return this.find(t).duration;\n  }, o.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, o;\n}(), k = function() {\n  function o(t, e) {\n    this.init(t, e);\n  }\n  return o.prototype.init = function(t, e) {\n    this.destination = t, this.source = e || t;\n  }, o.prototype.connect = function(t) {\n    this.source.connect(t);\n  }, o.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, o.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, o;\n}(), M = { __proto__: null, Filter: k, EqualizerFilter: function(o) {\n  function t(e, r, S, T, D, N, B, $, U, V) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0), S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = 0), N === void 0 && (N = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), V === void 0 && (V = 0);\n    var H = this;\n    if (!u().useLegacy) {\n      var X = [{ f: t.F32, type: \"lowshelf\", gain: e }, { f: t.F64, type: \"peaking\", gain: r }, { f: t.F125, type: \"peaking\", gain: S }, { f: t.F250, type: \"peaking\", gain: T }, { f: t.F500, type: \"peaking\", gain: D }, { f: t.F1K, type: \"peaking\", gain: N }, { f: t.F2K, type: \"peaking\", gain: B }, { f: t.F4K, type: \"peaking\", gain: $ }, { f: t.F8K, type: \"peaking\", gain: U }, { f: t.F16K, type: \"highshelf\", gain: V }].map(function(q) {\n        var K = u().context.audioContext.createBiquadFilter();\n        return K.type = q.type, P.setParamValue(K.Q, 1), K.frequency.value = q.f, P.setParamValue(K.gain, q.gain), K;\n      });\n      (H = o.call(this, X[0], X[X.length - 1]) || this).bands = X, H.bandsMap = {};\n      for (var Y = 0; Y < H.bands.length; Y++) {\n        var W = H.bands[Y];\n        Y > 0 && H.bands[Y - 1].connect(W), H.bandsMap[W.frequency.value] = W;\n      }\n      return H;\n    }\n    H = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype.setGain = function(e, r) {\n    if (r === void 0 && (r = 0), !this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    P.setParamValue(this.bandsMap[e].gain, r);\n  }, t.prototype.getGain = function(e) {\n    if (!this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    return this.bandsMap[e].gain.value;\n  }, Object.defineProperty(t.prototype, \"f32\", { get: function() {\n    return this.getGain(t.F32);\n  }, set: function(e) {\n    this.setGain(t.F32, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f64\", { get: function() {\n    return this.getGain(t.F64);\n  }, set: function(e) {\n    this.setGain(t.F64, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f125\", { get: function() {\n    return this.getGain(t.F125);\n  }, set: function(e) {\n    this.setGain(t.F125, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f250\", { get: function() {\n    return this.getGain(t.F250);\n  }, set: function(e) {\n    this.setGain(t.F250, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f500\", { get: function() {\n    return this.getGain(t.F500);\n  }, set: function(e) {\n    this.setGain(t.F500, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f1k\", { get: function() {\n    return this.getGain(t.F1K);\n  }, set: function(e) {\n    this.setGain(t.F1K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f2k\", { get: function() {\n    return this.getGain(t.F2K);\n  }, set: function(e) {\n    this.setGain(t.F2K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f4k\", { get: function() {\n    return this.getGain(t.F4K);\n  }, set: function(e) {\n    this.setGain(t.F4K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f8k\", { get: function() {\n    return this.getGain(t.F8K);\n  }, set: function(e) {\n    this.setGain(t.F8K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f16k\", { get: function() {\n    return this.getGain(t.F16K);\n  }, set: function(e) {\n    this.setGain(t.F16K, e);\n  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {\n    this.bands.forEach(function(e) {\n      P.setParamValue(e.gain, 0);\n    });\n  }, t.prototype.destroy = function() {\n    this.bands.forEach(function(e) {\n      e.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;\n}(k), DistortionFilter: function(o) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!u().useLegacy) {\n      var S = u().context.audioContext.createWaveShaper();\n      return (r = o.call(this, S) || this)._distortion = S, r.amount = e, r;\n    }\n    r = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(e) {\n    this._amount = e;\n    for (var r, S = 1e3 * e, T = 44100, D = new Float32Array(T), N = Math.PI / 180, B = 0; B < T; ++B)\n      r = 2 * B / T - 1, D[B] = (3 + S) * r * 20 * N / (Math.PI + S * Math.abs(r));\n    this._distortion.curve = D, this._distortion.oversample = \"4x\";\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._distortion = null, o.prototype.destroy.call(this);\n  }, t;\n}(k), StereoFilter: function(o) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!u().useLegacy) {\n      var S, T, D, N = u().context.audioContext;\n      return N.createStereoPanner ? D = S = N.createStereoPanner() : ((T = N.createPanner()).panningModel = \"equalpower\", D = T), (r = o.call(this, D) || this)._stereo = S, r._panner = T, r.pan = e, r;\n    }\n    r = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(e) {\n    this._pan = e, this._stereo ? P.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, t;\n}(k), ReverbFilter: function(o) {\n  function t(e, r, S) {\n    e === void 0 && (e = 3), r === void 0 && (r = 2), S === void 0 && (S = !1);\n    var T = this;\n    if (!u().useLegacy)\n      return (T = o.call(this, null) || this)._seconds = T._clamp(e, 1, 50), T._decay = T._clamp(r, 0, 100), T._reverse = S, T._rebuild(), T;\n    T = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype._clamp = function(e, r, S) {\n    return Math.min(S, Math.max(r, e));\n  }, Object.defineProperty(t.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(e) {\n    this._seconds = this._clamp(e, 1, 50), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(e) {\n    this._decay = this._clamp(e, 0, 100), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(e) {\n    this._reverse = e, this._rebuild();\n  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {\n    for (var e, r = u().context.audioContext, S = r.sampleRate, T = S * this._seconds, D = r.createBuffer(2, T, S), N = D.getChannelData(0), B = D.getChannelData(1), $ = 0; $ < T; $++)\n      e = this._reverse ? T - $ : $, N[$] = (2 * Math.random() - 1) * Math.pow(1 - e / T, this._decay), B[$] = (2 * Math.random() - 1) * Math.pow(1 - e / T, this._decay);\n    var U = u().context.audioContext.createConvolver();\n    U.buffer = D, this.init(U);\n  }, t;\n}(k), MonoFilter: function(o) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var r = u().context.audioContext, S = r.createChannelSplitter(), T = r.createChannelMerger();\n      return T.connect(S), (e = o.call(this, T, S) || this)._merger = T, e;\n    }\n    e = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, o.prototype.destroy.call(this);\n  }, t;\n}(k), StreamFilter: function(o) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var r = u().context.audioContext, S = r.createMediaStreamDestination(), T = r.createMediaStreamSource(S.stream);\n      return (e = o.call(this, S, T) || this)._stream = S.stream, e;\n    }\n    e = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._stream = null, o.prototype.destroy.call(this);\n  }, t;\n}(k), TelephoneFilter: function(o) {\n  function t() {\n    if (!u().useLegacy) {\n      var e = u().context.audioContext, r = e.createBiquadFilter(), S = e.createBiquadFilter(), T = e.createBiquadFilter(), D = e.createBiquadFilter();\n      return r.type = \"lowpass\", P.setParamValue(r.frequency, 2e3), S.type = \"lowpass\", P.setParamValue(S.frequency, 2e3), T.type = \"highpass\", P.setParamValue(T.frequency, 500), D.type = \"highpass\", P.setParamValue(D.frequency, 500), r.connect(S), S.connect(T), T.connect(D), o.call(this, r, D) || this;\n    }\n    o.call(this, null);\n  }\n  return c(t, o), t;\n}(k) }, G = 0, I = { __proto__: null, playOnce: function(o, t) {\n  var e = \"alias\".concat(G++);\n  return u().add(e, { url: o, preload: !0, autoPlay: !0, loaded: function(r) {\n    r && (u().remove(e), t && t(r));\n  }, complete: function() {\n    u().remove(e), t && t(null);\n  } }), e;\n}, get PLAY_ID() {\n  return G;\n}, render: function(o, t) {\n  var e = document.createElement(\"canvas\");\n  t = l({ width: 512, height: 128, fill: \"black\" }, t || {}), e.width = t.width, e.height = t.height;\n  var r = BaseTexture.from(e);\n  if (!(o.media instanceof A))\n    return r;\n  var S = o.media, T = e.getContext(\"2d\");\n  T.fillStyle = t.fill;\n  for (var D = S.buffer.getChannelData(0), N = Math.ceil(D.length / t.width), B = t.height / 2, $ = 0; $ < t.width; $++) {\n    for (var U = 1, V = -1, H = 0; H < N; H++) {\n      var X = D[$ * N + H];\n      X < U && (U = X), X > V && (V = X);\n    }\n    T.fillRect($, (1 + U) * B, 1, Math.max(1, (V - U) * B));\n  }\n  return r;\n}, resolveUrl: _, sineTone: function(o, t) {\n  o === void 0 && (o = 200), t === void 0 && (t = 1);\n  var e = F.from({ singleInstance: !0 });\n  if (!(e.media instanceof A))\n    return e;\n  for (var r = e.media, S = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), T = S.getChannelData(0), D = 0; D < T.length; D++) {\n    var N = o * (D / S.sampleRate) * Math.PI;\n    T[D] = 2 * Math.sin(N);\n  }\n  return r.buffer = S, e.isLoaded = !0, e;\n}, validateFormats: f, supported: h, extensions: p }, R = function(o) {\n  return s = o, o;\n}(new L());\n\"extensions\" in n ? extensions.add(y) : Loader.registerPlugin(y);\nvar Ce, Fe, ki, Xu, ed, Ns, au, Yu, rd, Wu, id, bo, qc, pn, Ua, xo, Kc, Ls, ks, ou, So, Zc, Eo, Bs, lu, qu, nd, Fr, Mi, Ku, sd, To, Jc, vn, ja, Zu, ad, wo, Qc, Ju, od, Qu, ld, Fs, uu;\nconst Ja = class {\n  constructor(t, e, r, S, T) {\n    tt(this, Xu);\n    tt(this, Ns);\n    tt(this, Yu);\n    tt(this, Wu);\n    tt(this, bo);\n    tt(this, pn);\n    tt(this, xo);\n    tt(this, ks);\n    tt(this, So);\n    tt(this, Bs);\n    tt(this, qu);\n    tt(this, Fr);\n    tt(this, Ku);\n    tt(this, To);\n    tt(this, vn);\n    tt(this, Zu);\n    tt(this, wo);\n    tt(this, Ju);\n    tt(this, Qu);\n    tt(this, Fs);\n    tt(this, Ce, {});\n    tt(this, Fe, {});\n    tt(this, ki, void 0);\n    tt(this, Eo, () => {\n      R.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1)), ot(this, Eo, () => {\n      });\n    });\n    this.cfg = t, this.val = r, this.main = S, this.sys = T, e.volume = (D) => lt(this, Xu, ed).call(this, D), e.fadebgm = (D) => lt(this, bo, qc).call(this, D), e.fadeoutbgm = (D) => lt(this, Yu, rd).call(this, D), e.fadeoutse = (D) => lt(this, Wu, id).call(this, D), e.fadese = (D) => lt(this, pn, Ua).call(this, D), e.playbgm = (D) => lt(this, xo, Kc).call(this, D), e.playse = (D) => lt(this, ks, ou).call(this, D), e.stop_allse = () => lt(this, Bs, lu).call(this), e.stopbgm = (D) => lt(this, qu, nd).call(this, D), e.stopse = (D) => lt(this, Fr, Mi).call(this, D), e.wb = (D) => lt(this, Ku, sd).call(this, D), e.wf = (D) => lt(this, To, Jc).call(this, D), e.stopfadese = (D) => lt(this, vn, ja).call(this, D), e.wl = (D) => lt(this, Zu, ad).call(this, D), e.ws = (D) => lt(this, wo, Qc).call(this, D), e.xchgbuf = (D) => lt(this, Ju, od).call(this, D), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\"), r.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(I.supported));\n  }\n  setEvtMng(t) {\n    ot(this, ki, t);\n  }\n  setNoticeChgVolume(t, e) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (r, S) => t(R.volumeAll = Number(S))), this.val.defValTrg(\"sys:sn.sound.movie_volume\", (r, S) => e(Number(S))), this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1)), this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    R.removeAll();\n  }\n  playLoopFromSaveObj() {\n    const t = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    if (this.val.flush(), t === \"{}\") {\n      lt(this, Bs, lu).call(this);\n      return;\n    }\n    ot(this, Fe, JSON.parse(t));\n    const e = Object.keys(z(this, Fe)).map((r) => () => {\n      const S = \"save:const.sn.sound.\" + r + \".\", T = {\n        fn: String(this.val.getVal(S + \"fn\")),\n        buf: r,\n        join: !1,\n        loop: !0,\n        volume: Number(this.val.getVal(S + \"volume\")),\n        start_ms: Number(this.val.getVal(S + \"start_ms\")),\n        end_ms: Number(this.val.getVal(S + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(S + \"ret_ms\"))\n      };\n      T.buf === \"BGM\" ? lt(this, xo, Kc).call(this, T) : lt(this, ks, ou).call(this, T);\n    });\n    lt(this, Bs, lu).call(this);\n    for (const r of e)\n      r();\n  }\n};\nlet SoundMng = Ja;\nCe = new WeakMap(), Fe = new WeakMap(), ki = new WeakMap(), Xu = new WeakSet(), ed = function(t) {\n  const { buf: e = \"SE\" } = t, r = \"const.sn.sound.\" + e + \".volume\", S = lt(this, Ns, au).call(this, t, 1);\n  return Number(this.val.getVal(\"sys:\" + r)) === S ? !1 : (this.val.setVal_Nochk(\"sys\", r, S), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal(\"save:\" + r)), lt(this, pn, Ua).call(this, t));\n}, Ns = new WeakSet(), au = function(t, e) {\n  const r = argChk_Num(t, \"volume\", e);\n  return r < 0 ? 0 : r > 1 ? 1 : r;\n}, Yu = new WeakSet(), rd = function(t) {\n  return t.volume = 0, lt(this, bo, qc).call(this, t);\n}, Wu = new WeakSet(), id = function(t) {\n  return t.volume = 0, lt(this, pn, Ua).call(this, t);\n}, bo = new WeakSet(), qc = function(t) {\n  return t.buf = \"BGM\", lt(this, pn, Ua).call(this, t);\n}, pn = new WeakSet(), Ua = function(t) {\n  lt(this, vn, ja).call(this, t);\n  const { buf: e = \"SE\" } = t, r = z(this, Ce)[e];\n  if (!(r != null && r.playing()) || !r.snd)\n    return !1;\n  const S = \"const.sn.sound.\" + e + \".\", T = S + \"volume\", D = lt(this, Ns, au).call(this, t, NaN);\n  this.val.setVal_Nochk(\"save\", T, D);\n  const N = D * Number(this.val.getVal(\"sys:\" + T, 1)), B = argChk_Boolean(t, \"stop\", D === 0);\n  B && (lt(this, Fs, uu).call(this, e), this.val.setVal_Nochk(\"save\", S + \"fn\", \"\")), this.val.flush();\n  const $ = argChk_Num(t, \"time\", NaN), U = argChk_Num(t, \"delay\", 0);\n  if ($ === 0 && U === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || z(this, ki).isSkippingByKeyDown())\n    return r.snd.volume = N, B && lt(this, Fr, Mi).call(this, t), !1;\n  const V = argChk_Num(t, \"repeat\", 1);\n  return r.updFade = (H) => r.snd.volume = H, r.twFade = new Tween({ v: r.snd.volume }).to({ v: N }, $).delay(U).easing(CmnTween.ease(t.ease)).repeat(V === 0 ? 1 / 0 : V - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onUpdate(({ v: H }) => r.updFade(H)).onComplete(() => {\n    const H = z(this, Ce)[r.now_buf];\n    (H == null ? void 0 : H.twFade) !== void 0 && (H.updFade = () => {\n    }, remove$6(H.twFade), delete H.twFade, B && (t.buf = r.now_buf, lt(this, Fr, Mi).call(this, t)), H.resumeFade && this.main.resume());\n  }).start(), !1;\n}, xo = new WeakSet(), Kc = function(t) {\n  return t.buf = \"BGM\", t.canskip = !1, argChk_Boolean(t, \"loop\", !0), lt(this, ks, ou).call(this, t);\n}, Ls = new WeakMap(), ks = new WeakSet(), ou = function(t) {\n  const { buf: e = \"SE\", fn: r } = t;\n  if (lt(this, Fr, Mi).call(this, { buf: e }), !r)\n    throw `[playse] fnは必須です buf:${e}`;\n  if (argChk_Boolean(t, \"canskip\", !0) && z(this, ki).isSkippingByKeyDown())\n    return !1;\n  const S = argChk_Boolean(t, \"loop\", !1);\n  lt(this, Qu, ld).call(this, e, S);\n  const T = \"const.sn.sound.\" + e + \".\";\n  this.val.setVal_Nochk(\"save\", T + \"fn\", r);\n  const D = lt(this, Ns, au).call(this, t, 1);\n  this.val.setVal_Nochk(\"save\", T + \"volume\", D);\n  const N = D * Number(this.val.getVal(\"sys:\" + T + \"volume\", 1)), B = argChk_Num(t, \"start_ms\", 0), $ = argChk_Num(t, \"end_ms\", z(Ja, Ls)), U = argChk_Num(t, \"ret_ms\", 0), V = argChk_Num(t, \"pan\", 0), H = argChk_Num(t, \"speed\", 1);\n  if (B < 0)\n    throw `[playse] start_ms:${B} が負の値です`;\n  if (U < 0)\n    throw `[playse] ret_ms:${U} が負の値です`;\n  if ($ > 0) {\n    if (B >= $)\n      throw `[playse] start_ms:${B} >= end_ms:${$} は異常値です`;\n    if (U >= $)\n      throw `[playse] ret_ms:${U} >= end_ms:${$} は異常値です`;\n  }\n  this.val.setVal_Nochk(\"save\", T + \"start_ms\", B), this.val.setVal_Nochk(\"save\", T + \"end_ms\", $), this.val.setVal_Nochk(\"save\", T + \"ret_ms\", U), this.val.flush();\n  const X = R.find(r), Y = z(this, Ce)[e] = {\n    now_buf: e,\n    snd: X,\n    loop: S,\n    start_ms: B,\n    end_ms: $,\n    ret_ms: U,\n    resume: !1,\n    pan: V,\n    playing: () => !0,\n    updFade: () => {\n    },\n    onend: () => {\n      const Z = Y.now_buf, J = z(this, Ce)[Z];\n      if (!J)\n        return;\n      delete z(this, Ce)[Z], J.playing = () => !1;\n      const Q = \"const.sn.sound.\" + Z + \".\";\n      this.val.setVal_Nochk(\"tmp\", Q + \"playing\", !1), t.buf = Z, lt(this, vn, ja).call(this, t), J.resume && this.main.resume();\n    }\n  };\n  this.val.setVal_Nochk(\"tmp\", T + \"playing\", !0);\n  const W = {\n    loop: S,\n    speed: H,\n    volume: N,\n    loaded: (Z, J) => {\n      if (Z) {\n        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${Z}`, !1);\n        return;\n      }\n      if (!J)\n        return;\n      const Q = z(this, Ce)[Y.now_buf];\n      Q && (Q.snd = J);\n    }\n  };\n  let q = \"\";\n  if (B > 0 || $ < z(Ja, Ls)) {\n    q = `${r};${B};${$};${U}`;\n    const Z = (W.sprites ?? (W.sprites = {}))[q] = {\n      start: B / 1e3,\n      end: $ / 1e3\n    };\n    W.preload = !0;\n    const J = W.loaded;\n    W.loaded = (Q, rt) => {\n      J(Q, rt);\n      const et = rt, nt = et.duration;\n      if (Z.end < 0) {\n        if (Z.end += nt, et.removeSprites(q), et.addSprites(q, Z), Z.start >= Z.end)\n          throw `[playse] start_ms:${B} >= end_ms:${$}(${Z.end * 1e3}) は異常値です`;\n        if (U >= Z.end * 1e3)\n          throw `[playse] ret_ms:${U} >= end_ms:${$}(${Z.end * 1e3}) は異常値です`;\n      }\n      if (Z.start >= nt)\n        throw `[playse] start_ms:${B} >= 音声ファイル再生時間:${nt} は異常値です`;\n      if ($ !== z(Ja, Ls) && Z.end >= nt)\n        throw `[playse] end_ms:${$} >= 音声ファイル再生時間:${nt} は異常値です`;\n      et.play(q, W.complete);\n    };\n  } else\n    W.autoPlay = !0;\n  if (S ? U !== 0 && (W.loop = !1, W.complete = async (Z) => {\n    const J = Z.duration, Q = U / 1e3, rt = $ / 1e3;\n    if (Q >= J)\n      throw `[playse] ret_ms:${U} >= 音声ファイル再生時間:${J} は異常値です`;\n    await R.play(r, {\n      start: Q,\n      end: rt < 0 ? rt + J : rt,\n      speed: H,\n      loop: !0,\n      volume: N,\n      filters: Y.pan !== 0 ? [new M.StereoFilter(Y.pan)] : []\n    });\n    const et = z(this, Ce)[Y.now_buf];\n    et && (et.snd = R.find(r));\n  }) : W.complete = () => {\n    var Z;\n    return (Z = z(this, Ce)[Y.now_buf]) == null ? void 0 : Z.onend();\n  }, z(this, Eo).call(this), X) {\n    if (X.volume = N, q)\n      lt(this, So, Zc).call(this, e, r, W);\n    else if (X.isPlayable) {\n      const Z = X.options.source;\n      !(Z instanceof ArrayBuffer) || Z.byteLength === 0 ? X.play(W) : Y.snd = F.from({\n        ...W,\n        url: X.options.url,\n        source: Z\n      }), X.filters = [new M.StereoFilter(V)];\n    }\n    return !1;\n  }\n  const K = argChk_Boolean(t, \"join\", !0);\n  if (K) {\n    const Z = W.loaded;\n    W.loaded = (J, Q) => {\n      Z == null || Z(J, Q), this.main.resume();\n    };\n  }\n  return lt(this, So, Zc).call(this, e, r, W), K;\n}, So = new WeakSet(), Zc = function(t, e, r) {\n  const S = this.cfg.searchPath(e, SEARCH_PATH_ARG_EXT.SOUND);\n  if (S.slice(-4) !== \".bin\") {\n    r.url = S;\n    const T = F.from(r);\n    if (t) {\n      const D = z(this, Ce)[t];\n      if (!D)\n        return;\n      D.snd = T, D.pan !== 0 && (T.filters = [new M.StereoFilter(D.pan)]);\n    }\n    r.loop || R.add(e, T);\n    return;\n  }\n  new Loader().add({ name: e, url: S, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((T, D) => {\n    this.sys.dec(T.extension, T.data).then((N) => {\n      T.data = N, D == null || D();\n    }).catch((N) => this.main.errScript(`Sound ロード失敗ですc fn:${T.name} ${N}`, !1));\n  }).load((T, D) => {\n    var B;\n    r.source = (B = D[e]) == null ? void 0 : B.data;\n    const N = F.from(r);\n    if (t) {\n      const $ = z(this, Ce)[t];\n      if (!$)\n        return;\n      $.snd = N, $.pan !== 0 && (N.filters = [new M.StereoFilter($.pan)]);\n    }\n    r.loop || R.add(e, N);\n  });\n}, Eo = new WeakMap(), Bs = new WeakSet(), lu = function() {\n  for (const t of Object.keys(z(this, Ce)))\n    lt(this, Fr, Mi).call(this, { buf: t });\n  return ot(this, Ce, {}), R.stopAll(), !1;\n}, qu = new WeakSet(), nd = function(t) {\n  return t.buf = \"BGM\", lt(this, Fr, Mi).call(this, t);\n}, Fr = new WeakSet(), Mi = function(t) {\n  var S;\n  const { buf: e = \"SE\" } = t;\n  lt(this, Fs, uu).call(this, e);\n  const r = z(this, Ce)[e];\n  return r && ((S = r.snd) == null || S.stop(), r.onend()), !1;\n}, Ku = new WeakSet(), sd = function(t) {\n  return t.buf = \"BGM\", lt(this, To, Jc).call(this, t);\n}, To = new WeakSet(), Jc = function(t) {\n  const { buf: e = \"SE\" } = t, r = z(this, Ce)[e];\n  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = z(this, ki).waitEvent(\n    () => lt(this, vn, ja).call(this, t),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, vn = new WeakSet(), ja = function(t) {\n  var r, S;\n  const { buf: e = \"SE\" } = t;\n  return (S = (r = z(this, Ce)[e]) == null ? void 0 : r.twFade) == null || S.stop().end(), !1;\n}, Zu = new WeakSet(), ad = function(t) {\n  return t.buf = \"BGM\", lt(this, wo, Qc).call(this, t);\n}, wo = new WeakSet(), Qc = function(t) {\n  const { buf: e = \"SE\" } = t, r = z(this, Ce)[e];\n  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = z(this, ki).waitEvent(\n    () => {\n      t.buf = r.now_buf, lt(this, Fr, Mi).call(this, t);\n      const S = z(this, Ce)[t.buf];\n      !(S != null && S.playing()) || S.loop || S.onend();\n    },\n    argChk_Boolean(t, \"canskip\", !1),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, Ju = new WeakSet(), od = function(t) {\n  const { buf: e = \"SE\", buf2: r = \"SE\" } = t;\n  if (e === r)\n    return !1;\n  const S = z(this, Ce)[e];\n  S && (S.now_buf = r);\n  const T = z(this, Ce)[r];\n  T && (T.now_buf = e), [z(this, Ce)[e], z(this, Ce)[r]] = [T, S];\n  const D = \"const.sn.sound.\" + e + \".\", N = Number(this.val.getVal(\"save:\" + D + \"volume\")), B = Number(this.val.getVal(\"save:\" + D + \"fn\")), $ = String(this.val.getVal(\"tmp:\" + D + \"playing\")) === \"true\", U = \"const.sn.sound.\" + r + \".\", V = Number(this.val.getVal(\"save:\" + U + \"volume\")), H = Number(this.val.getVal(\"save:\" + U + \"fn\")), X = String(this.val.getVal(\"tmp:\" + U + \"playing\")) === \"true\";\n  return this.val.setVal_Nochk(\"save\", D + \"volume\", V), this.val.setVal_Nochk(\"save\", U + \"volume\", N), this.val.setVal_Nochk(\"save\", D + \"fn\", H), this.val.setVal_Nochk(\"save\", U + \"fn\", B), this.val.setVal_Nochk(\"tmp\", D + \"playing\", X), this.val.setVal_Nochk(\"tmp\", U + \"playing\", $), e in z(this, Fe) == r in z(this, Fe) && (e in z(this, Fe) ? (delete z(this, Fe)[e], z(this, Fe)[r] = 0) : (delete z(this, Fe)[r], z(this, Fe)[e] = 0), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(z(this, Fe)))), this.val.flush(), !1;\n}, Qu = new WeakSet(), ld = function(t, e) {\n  if (!e) {\n    lt(this, Fs, uu).call(this, t);\n    return;\n  }\n  z(this, Fe)[t] = 0, this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(z(this, Fe))), this.val.flush();\n}, Fs = new WeakSet(), uu = function(t) {\n  delete z(this, Fe)[t], this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(z(this, Fe))), this.val.flush();\n}, tt(SoundMng, Ls, 999e3);\nvar _e;\nconst Af = class {\n  constructor(t, e, r, S, T, D, N, B) {\n    tt(this, _e, void 0);\n    Rt(this, \"lay\", (t) => this.getPage(t).lay(t));\n    Rt(this, \"getPage\", (t) => Af.argChk_page(t, \"fore\") !== \"back\" ? z(this, _e).fore : z(this, _e).back);\n    this.cls = e, this.hArg = T, this.sys = D, this.val = N, this.ret = B;\n    const $ = D.hFactoryCls[e];\n    if (!$)\n      throw `属性 class【${e}】が不正です`;\n    const U = $(), V = $();\n    U.layname = V.layname = t;\n    const H = T[\":id_tag\"] = `layer:${t} cls:${e} page:`;\n    U.spLay.name = U.name = H + \"A\", U.spLay.name = V.name = H + \"B\", r.addChild(U.spLay), S.addChild(V.spLay), argChk_Boolean(T, \"visible\", !0), argChk_Boolean(T, \"visible\", !0), B.isWait = U.lay(T) || V.lay(T), ot(this, _e, { fore: U, back: V });\n    const X = `const.sn.lay.${t}`;\n    N.setVal_Nochk(\"tmp\", X, !0), N.defTmp(X + \".fore.alpha\", () => z(this, _e).fore.alpha), N.defTmp(X + \".back.alpha\", () => z(this, _e).back.alpha), N.defTmp(X + \".fore.height\", () => z(this, _e).fore.height), N.defTmp(X + \".back.height\", () => z(this, _e).back.height), N.defTmp(X + \".fore.visible\", () => z(this, _e).fore.spLay.visible), N.defTmp(X + \".back.visible\", () => z(this, _e).back.spLay.visible), N.defTmp(X + \".fore.width\", () => z(this, _e).fore.width), N.defTmp(X + \".back.width\", () => z(this, _e).back.width), N.defTmp(X + \".fore.x\", () => z(this, _e).fore.x), N.defTmp(X + \".back.x\", () => z(this, _e).back.x), N.defTmp(X + \".fore.y\", () => z(this, _e).fore.y), N.defTmp(X + \".back.y\", () => z(this, _e).back.y);\n  }\n  destroy() {\n    z(this, _e).fore.destroy(), z(this, _e).back.destroy();\n  }\n  static argChk_page(t, e) {\n    const r = t.page ?? e;\n    if (r === \"fore\" || r === \"back\")\n      return t.page = r;\n    throw Error(\"属性 page【\" + r + \"】が不正です\");\n  }\n  get fore() {\n    return z(this, _e).fore;\n  }\n  get back() {\n    return z(this, _e).back;\n  }\n  transPage(t) {\n    [z(this, _e).back, z(this, _e).fore] = [z(this, _e).fore, z(this, _e).back], z(this, _e).back.copy(z(this, _e).fore, t);\n  }\n};\nlet Pages = Af;\n_e = new WeakMap();\nvar th, eh;\nconst Oi = class {\n  constructor() {\n    Rt(this, \"layname\", \"\");\n    Rt(this, \"name_\", \"\");\n    Rt(this, \"spLay\", new Sprite(Texture.EMPTY));\n  }\n  set name(t) {\n    this.name_ = t;\n  }\n  get name() {\n    return this.name_;\n  }\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(t) {\n    this.spLay.alpha = t;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(t) {\n    this.spLay.angle = t;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(t) {\n    this.spLay.scale.x = t;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(t) {\n    this.spLay.scale.y = t;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(t) {\n    this.spLay.x = t;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(t) {\n    this.spLay.y = t;\n  }\n  destroy() {\n  }\n  lay(t) {\n    return \"alpha\" in t && (this.spLay.alpha = argChk_Num(t, \"alpha\", 1)), Oi.setBlendmode(this.spLay, t), (\"pivot_x\" in t || \"pivot_y\" in t) && this.spLay.pivot.set(\n      argChk_Num(t, \"pivot_x\", this.spLay.pivot.x),\n      argChk_Num(t, \"pivot_y\", this.spLay.pivot.y)\n    ), \"rotation\" in t && (this.spLay.angle = argChk_Num(t, \"rotation\", 0)), (\"scale_x\" in t || \"scale_y\" in t) && this.spLay.scale.set(\n      argChk_Num(t, \"scale_x\", this.spLay.scale.x),\n      argChk_Num(t, \"scale_y\", this.spLay.scale.y)\n    ), \"visible\" in t && (this.spLay.visible = argChk_Boolean(t, \"visible\", !0)), !1;\n  }\n  static setBlendmode(t, e) {\n    const { blendmode: r } = e;\n    if (!r)\n      return;\n    const S = Oi.getBlendmodeNum(r);\n    t instanceof Sprite && (t.blendMode = S);\n    for (const T of t.children)\n      T instanceof Sprite && (T.blendMode = S);\n  }\n  static getBlendmodeNum(t) {\n    if (!t)\n      return BLEND_MODES.NORMAL;\n    const e = z(Oi, th)[t];\n    if (e !== void 0)\n      return e;\n    throw `${t} はサポートされない blendmode です`;\n  }\n  static getNum2Blendmode(t) {\n    return z(Oi, eh)[t] ?? \"normal\";\n  }\n  get containMovement() {\n    return !1;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(t) {\n    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, \"filter\", !1) && (this.spLay.filters = []);\n  }\n  copy(t, e) {\n    const r = this.name_;\n    this.playback(t.record(), e), this.name = r;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(t, e) {\n    this.name = t.name, this.clearLay({ filter: \"true\" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;\n  }\n  snapshot(t, e) {\n    t.render(this.spLay, { clear: !1 }), e();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(t) {\n  }\n  makeDesignCastChildren(t) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(t, e, r, S = !1, T = !1) {\n    if (e.pos) {\n      Oi.setXYByPos(t, e.pos, r);\n      return;\n    }\n    const D = t.getBounds(), N = r.scale.x < 0 ? -r.scale.x : r.scale.x, B = N === 1 ? D.width : D.width * N, $ = r.scale.y < 0 ? -r.scale.y : r.scale.y, U = $ === 1 ? D.height : D.height * $;\n    let V = r.x;\n    \"left\" in e ? (V = argChk_Num(e, \"left\", 0), V > -1 && V < 1 && (V *= CmnLib.stageW)) : \"center\" in e ? (V = argChk_Num(e, \"center\", 0), V > -1 && V < 1 && (V *= CmnLib.stageW), V = V - (T ? B / 3 : B) / 2) : \"right\" in e ? (V = argChk_Num(e, \"right\", 0), V > -1 && V < 1 && (V *= CmnLib.stageW), V = V - (T ? B / 3 : B)) : \"s_right\" in e && (V = argChk_Num(e, \"s_right\", 0), V > -1 && V < 1 && (V *= CmnLib.stageW), V = CmnLib.stageW - V - (T ? B / 3 : B)), r.x = int(r.scale.x < 0 ? V + (T ? B / 3 : B) : V);\n    let H = r.y;\n    \"top\" in e ? (H = argChk_Num(e, \"top\", 0), H > -1 && H < 1 && (H *= CmnLib.stageH)) : \"middle\" in e ? (H = argChk_Num(e, \"middle\", 0), H > -1 && H < 1 && (H *= CmnLib.stageH), H = H - U / 2) : \"bottom\" in e ? (H = argChk_Num(e, \"bottom\", 0), H > -1 && H < 1 && (H *= CmnLib.stageH), H = H - U) : \"s_bottom\" in e && (H = argChk_Num(e, \"s_bottom\", 0), H > -1 && H < 1 && (H *= CmnLib.stageH), H = CmnLib.stageH - H - U), r.y = int(r.scale.y < 0 ? H + U : H), S && !(\"left\" in e) && !(\"center\" in e) && !(\"right\" in e) && !(\"s_right\" in e) && !(\"top\" in e) && !(\"middle\" in e) && !(\"bottom\" in e) && !(\"s_bottom\" in e) && Oi.setXYByPos(t, \"c\", r);\n  }\n  static setXYByPos(t, e, r) {\n    if (e === \"stay\")\n      return;\n    if (t === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (r === void 0)\n      throw \"setXYByPos result === undefined\";\n    const S = t.getBounds(), T = r.scale.x < 0 ? -r.scale.x : r.scale.x, D = T === 1 ? S.width : S.width * T, N = r.scale.y < 0 ? -r.scale.y : r.scale.y, B = N === 1 ? S.height : S.height * N;\n    let $ = 0;\n    !e || e === \"c\" ? $ = CmnLib.stageW * 0.5 : e === \"r\" ? $ = CmnLib.stageW - D * 0.5 : e === \"l\" ? $ = D * 0.5 : $ = int(e), r.x = int($ - D * 0.5), r.y = CmnLib.stageH - B, r.scale.x < 0 && (r.x += D), r.scale.y < 0 && (r.y += B);\n  }\n  static setXYCenter(t) {\n    const e = t.getBounds();\n    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;\n  }\n};\nlet Layer = Oi;\nth = new WeakMap(), eh = new WeakMap(), tt(Layer, th, {\n  normal: BLEND_MODES.NORMAL,\n  add: BLEND_MODES.ADD,\n  multiply: BLEND_MODES.MULTIPLY,\n  screen: BLEND_MODES.SCREEN\n}), tt(Layer, eh, {\n  0: \"normal\",\n  1: \"add\",\n  2: \"multiply\",\n  3: \"screen\"\n});\nfunction prefixNames(o) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  return t.map(function(r) {\n    return r.split(\" \").map(function(S) {\n      return S ? \"\" + o + S : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction prefixCSS(o, t) {\n  return t.replace(/([^}{]*){/gm, function(e, r) {\n    return r.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + o + \"$1\") + \"{\";\n  });\n}\nfunction ref(o, t) {\n  return function(e) {\n    e && (o[t] = e);\n  };\n}\nfunction refs(o, t, e) {\n  return function(r) {\n    r && (o[t][e] = r);\n  };\n}\nfunction Properties(o, t) {\n  return function(e) {\n    var r = e.prototype;\n    o.forEach(function(S) {\n      t(r, S);\n    });\n  };\n}\nfunction withMethods(o, t) {\n  return t === void 0 && (t = {}), function(e, r) {\n    o.forEach(function(S) {\n      var T = t[S] || S;\n      T in e || (e[T] = function() {\n        for (var D, N = [], B = 0; B < arguments.length; B++)\n          N[B] = arguments[B];\n        var $ = (D = this[r])[S].apply(D, N);\n        return $ === this[r] ? this : $;\n      });\n    });\n  };\n}\nvar PolyMap = /* @__PURE__ */ function() {\n  function o() {\n    this.keys = [], this.values = [];\n  }\n  var t = o.prototype;\n  return t.get = function(e) {\n    return this.values[this.keys.indexOf(e)];\n  }, t.set = function(e, r) {\n    var S = this.keys, T = this.values, D = S.indexOf(e), N = D === -1 ? S.length : D;\n    S[N] = e, T[N] = r;\n  }, o;\n}(), HashMap = /* @__PURE__ */ function() {\n  function o() {\n    this.object = {};\n  }\n  var t = o.prototype;\n  return t.get = function(e) {\n    return this.object[e];\n  }, t.set = function(e, r) {\n    this.object[e] = r;\n  }, o;\n}(), SUPPORT_MAP = typeof Map == \"function\", Link = /* @__PURE__ */ function() {\n  function o() {\n  }\n  var t = o.prototype;\n  return t.connect = function(e, r) {\n    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);\n  }, t.disconnect = function() {\n    var e = this.prev, r = this.next;\n    e && (e.next = r), r && (r.prev = e);\n  }, t.getIndex = function() {\n    for (var e = this, r = -1; e; )\n      e = e.prev, ++r;\n    return r;\n  }, o;\n}();\nfunction orderChanged(o, t) {\n  var e = [], r = [];\n  return o.forEach(function(S) {\n    var T = S[0], D = S[1], N = new Link();\n    e[T] = N, r[D] = N;\n  }), e.forEach(function(S, T) {\n    S.connect(e[T - 1]);\n  }), o.filter(function(S, T) {\n    return !t[T];\n  }).map(function(S, T) {\n    var D = S[0], N = S[1];\n    if (D === N)\n      return [0, 0];\n    var B = e[D], $ = r[N - 1], U = B.getIndex();\n    B.disconnect(), $ ? B.connect($, $.next) : B.connect(void 0, e[0]);\n    var V = B.getIndex();\n    return [U, V];\n  });\n}\nvar Result = /* @__PURE__ */ function() {\n  function o(e, r, S, T, D, N, B, $) {\n    this.prevList = e, this.list = r, this.added = S, this.removed = T, this.changed = D, this.maintained = N, this.changedBeforeAdded = B, this.fixed = $;\n  }\n  var t = o.prototype;\n  return Object.defineProperty(t, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(t, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), t.caculateOrdered = function() {\n    var e = orderChanged(this.changedBeforeAdded, this.fixed), r = this.changed, S = [];\n    this.cacheOrdered = e.filter(function(T, D) {\n      var N = T[0], B = T[1], $ = r[D], U = $[0], V = $[1];\n      if (N !== B)\n        return S.push([U, V]), !0;\n    }), this.cachePureChanged = S;\n  }, o;\n}();\nfunction diff$1(o, t, e) {\n  var r = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, S = e || function(Z) {\n    return Z;\n  }, T = [], D = [], N = [], B = o.map(S), $ = t.map(S), U = new r(), V = new r(), H = [], X = [], Y = {}, W = [], q = 0, K = 0;\n  return B.forEach(function(Z, J) {\n    U.set(Z, J);\n  }), $.forEach(function(Z, J) {\n    V.set(Z, J);\n  }), B.forEach(function(Z, J) {\n    var Q = V.get(Z);\n    typeof Q > \"u\" ? (++K, D.push(J)) : Y[Q] = K;\n  }), $.forEach(function(Z, J) {\n    var Q = U.get(Z);\n    typeof Q > \"u\" ? (T.push(J), ++q) : (N.push([Q, J]), K = Y[J] || 0, H.push([Q - K, J - q]), X.push(J === Q), Q !== J && W.push([Q, J]));\n  }), D.reverse(), new Result(o, t, T, D, W, N, H, X);\n}\nvar ListDiffer = /* @__PURE__ */ function() {\n  function o(e, r) {\n    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);\n  }\n  var t = o.prototype;\n  return t.update = function(e) {\n    var r = [].slice.call(e), S = diff$1(this.list, r, this.findKeyCallback);\n    return this.list = r, S;\n  }, o;\n}(), FUNCTION$1 = \"function\", OBJECT = \"object\", STRING$1 = \"string\", NUMBER = \"number\", UNDEFINED = \"undefined\", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {\n  cm: function(o) {\n    return o * 96 / 2.54;\n  },\n  mm: function(o) {\n    return o * 96 / 254;\n  },\n  in: function(o) {\n    return o * 96;\n  },\n  pt: function(o) {\n    return o * 96 / 72;\n  },\n  pc: function(o) {\n    return o * 96 / 6;\n  },\n  \"%\": function(o, t) {\n    return o * t / 100;\n  },\n  vw: function(o, t) {\n    return t === void 0 && (t = window.innerWidth), o / 100 * t;\n  },\n  vh: function(o, t) {\n    return t === void 0 && (t = window.innerHeight), o / 100 * t;\n  },\n  vmax: function(o, t) {\n    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), o / 100 * t;\n  },\n  vmin: function(o, t) {\n    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), o / 100 * t;\n  }\n};\nfunction __spreadArrays$3() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), S = 0, t = 0; t < e; t++)\n    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)\n      r[S] = T[D];\n  return r;\n}\nfunction dot(o, t, e, r) {\n  return (o * r + t * e) / (e + r);\n}\nfunction isUndefined(o) {\n  return typeof o === UNDEFINED;\n}\nfunction isObject$2(o) {\n  return o && typeof o === OBJECT;\n}\nfunction isArray(o) {\n  return Array.isArray(o);\n}\nfunction isString$1(o) {\n  return typeof o === STRING$1;\n}\nfunction isNumber(o) {\n  return typeof o === NUMBER;\n}\nfunction isFunction$3(o) {\n  return typeof o === FUNCTION$1;\n}\nfunction isEqualSeparator(o, t) {\n  var e = o === \"\" || o == \" \", r = t === \"\" || t == \" \";\n  return r && e || o === t;\n}\nfunction findOpen(o, t, e, r, S) {\n  var T = findIgnore(o, t, e);\n  return T ? e : findClose(o, t, e + 1, r, S);\n}\nfunction findIgnore(o, t, e) {\n  if (!o.ignore)\n    return null;\n  var r = t.slice(Math.max(e - 3, 0), e + 3).join(\"\");\n  return new RegExp(o.ignore).exec(r);\n}\nfunction findClose(o, t, e, r, S) {\n  for (var T = function($) {\n    var U = t[$].trim();\n    if (U === o.close && !findIgnore(o, t, $))\n      return {\n        value: $\n      };\n    var V = $, H = find$1(S, function(X) {\n      var Y = X.open;\n      return Y === U;\n    });\n    if (H && (V = findOpen(H, t, $, r, S)), V === -1)\n      return D = $, \"break\";\n    $ = V, D = $;\n  }, D, N = e; N < r; ++N) {\n    var B = T(N);\n    if (N = D, typeof B == \"object\")\n      return B.value;\n    if (B === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction splitText(o, t) {\n  var e = isString$1(t) ? {\n    separator: t\n  } : t, r = e.separator, S = r === void 0 ? \",\" : r, T = e.isSeparateFirst, D = e.isSeparateOnlyOpenClose, N = e.isSeparateOpenClose, B = N === void 0 ? D : N, $ = e.openCloseCharacters, U = $ === void 0 ? OPEN_CLOSED_CHARACTERS : $, V = U.map(function(nt) {\n    var st = nt.open, it = nt.close;\n    return st === it ? st : st + \"|\" + it;\n  }).join(\"|\"), H = \"(\\\\s*\" + S + \"\\\\s*|\" + V + \"|\\\\s+)\", X = new RegExp(H, \"g\"), Y = o.split(X).filter(Boolean), W = Y.length, q = [], K = [];\n  function Z() {\n    return K.length ? (q.push(K.join(\"\")), K = [], !0) : !1;\n  }\n  for (var J = function(nt) {\n    var st = Y[nt].trim(), it = nt, at = find$1(U, function(gt) {\n      var _t = gt.open;\n      return _t === st;\n    }), ut = find$1(U, function(gt) {\n      var _t = gt.close;\n      return _t === st;\n    });\n    if (at) {\n      if (it = findOpen(at, Y, nt, W, U), it !== -1 && B)\n        return Z() && T || (q.push(Y.slice(nt, it + 1).join(\"\")), nt = it, T) ? (Q = nt, \"break\") : (Q = nt, \"continue\");\n    } else if (ut && !findIgnore(ut, Y, nt)) {\n      var ct = __spreadArrays$3(U);\n      return ct.splice(U.indexOf(ut), 1), {\n        value: splitText(o, {\n          separator: S,\n          isSeparateFirst: T,\n          isSeparateOnlyOpenClose: D,\n          isSeparateOpenClose: B,\n          openCloseCharacters: ct\n        })\n      };\n    } else if (isEqualSeparator(st, S) && !D)\n      return Z(), T ? (Q = nt, \"break\") : (Q = nt, \"continue\");\n    it === -1 && (it = W - 1), K.push(Y.slice(nt, it + 1).join(\"\")), nt = it, Q = nt;\n  }, Q, rt = 0; rt < W; ++rt) {\n    var et = J(rt);\n    if (rt = Q, typeof et == \"object\")\n      return et.value;\n    if (et === \"break\")\n      break;\n  }\n  return K.length && q.push(K.join(\"\")), q;\n}\nfunction splitSpace(o) {\n  return splitText(o, \"\");\n}\nfunction splitComma(o) {\n  return splitText(o, \",\");\n}\nfunction splitBracket(o) {\n  var t = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(o);\n  return !t || t.length < 4 ? {} : {\n    prefix: t[1],\n    value: t[2],\n    suffix: t[3]\n  };\n}\nfunction splitUnit(o) {\n  var t = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(o);\n  if (!t)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var e = t[1], r = t[2], S = t[3];\n  return {\n    prefix: e,\n    unit: S,\n    value: parseFloat(r)\n  };\n}\nfunction camelize(o) {\n  return o.replace(/[\\s-_]([a-z])/g, function(t, e) {\n    return e.toUpperCase();\n  });\n}\nfunction decamelize(o, t) {\n  return t === void 0 && (t = \"-\"), o.replace(/([a-z])([A-Z])/g, function(e, r, S) {\n    return \"\" + r + t + S.toLowerCase();\n  });\n}\nfunction now$1() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\nfunction findIndex(o, t, e) {\n  e === void 0 && (e = -1);\n  for (var r = o.length, S = 0; S < r; ++S)\n    if (t(o[S], S, o))\n      return S;\n  return e;\n}\nfunction find$1(o, t, e) {\n  var r = findIndex(o, t);\n  return r > -1 ? o[r] : e;\n}\nvar requestAnimationFrame$1 = /* @__PURE__ */ function() {\n  var o = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    var r = now$1(), S = window.setTimeout(function() {\n      e(r - o);\n    }, 1e3 / 60);\n    return S;\n  };\n}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {\n  var o = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return o ? o.bind(window) : function(t) {\n    clearTimeout(t);\n  };\n}();\nfunction getKeys(o) {\n  return Object.keys(o);\n}\nfunction convertUnitSize(o, t) {\n  var e = splitUnit(o), r = e.value, S = e.unit;\n  if (isObject$2(t)) {\n    var T = t[S];\n    if (T) {\n      if (isFunction$3(T))\n        return T(r);\n      if (DEFAULT_UNIT_PRESETS[S])\n        return DEFAULT_UNIT_PRESETS[S](r, T);\n    }\n  } else if (S === \"%\")\n    return r * t / 100;\n  return DEFAULT_UNIT_PRESETS[S] ? DEFAULT_UNIT_PRESETS[S](r) : r;\n}\nfunction between(o, t, e) {\n  return Math.max(t, Math.min(o, e));\n}\nfunction checkBoundSize(o, t, e, r) {\n  return r === void 0 && (r = o[0] / o[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / r, TINY_NUM$1)], [throttle(t[1] * r, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(S) {\n    return S.every(function(T, D) {\n      var N = t[D], B = throttle(N, TINY_NUM$1);\n      return e ? T <= N || T <= B : T >= N || T >= B;\n    });\n  })[0] || o;\n}\nfunction calculateBoundSize(o, t, e, r) {\n  if (!r)\n    return o.map(function(X, Y) {\n      return between(X, t[Y], e[Y]);\n    });\n  var S = o[0], T = o[1], D = r === !0 ? S / T : r, N = checkBoundSize(o, t, !1, D), B = N[0], $ = N[1], U = checkBoundSize(o, e, !0, D), V = U[0], H = U[1];\n  return S < B || T < $ ? (S = B, T = $) : (S > V || T > H) && (S = V, T = H), [S, T];\n}\nfunction sum(o) {\n  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)\n    e += o[r];\n  return e;\n}\nfunction average(o) {\n  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)\n    e += o[r];\n  return t ? e / t : 0;\n}\nfunction getRad$1(o, t) {\n  var e = t[0] - o[0], r = t[1] - o[1], S = Math.atan2(r, e);\n  return S >= 0 ? S : S + Math.PI * 2;\n}\nfunction getCenterPoint(o) {\n  return [0, 1].map(function(t) {\n    return average(o.map(function(e) {\n      return e[t];\n    }));\n  });\n}\nfunction getShapeDirection(o) {\n  var t = getCenterPoint(o), e = getRad$1(t, o[0]), r = getRad$1(t, o[1]);\n  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;\n}\nfunction getDist$2(o, t) {\n  return Math.sqrt(Math.pow((t ? t[0] : 0) - o[0], 2) + Math.pow((t ? t[1] : 0) - o[1], 2));\n}\nfunction throttle(o, t) {\n  if (!t)\n    return o;\n  var e = 1 / t;\n  return Math.round(o / t) / e;\n}\nfunction throttleArray(o, t) {\n  return o.forEach(function(e, r) {\n    o[r] = throttle(o[r], t);\n  }), o;\n}\nfunction hasClass(o, t) {\n  return o.classList ? o.classList.contains(t) : !!o.className.match(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\"));\n}\nfunction addClass(o, t) {\n  o.classList ? o.classList.add(t) : o.className += \" \" + t;\n}\nfunction removeClass(o, t) {\n  if (o.classList)\n    o.classList.remove(t);\n  else {\n    var e = new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\");\n    o.className = o.className.replace(e, \" \");\n  }\n}\nfunction addEvent(o, t, e, r) {\n  o.addEventListener(t, e, r);\n}\nfunction removeEvent(o, t, e, r) {\n  o.removeEventListener(t, e, r);\n}\nvar extendStatics$6 = function(o, t) {\n  return extendStatics$6 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$6(o, t);\n};\nfunction __extends$6(o, t) {\n  extendStatics$6(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$6 = function() {\n  return __assign$6 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$6.apply(this, arguments);\n};\nfunction __rest$2(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)\n      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);\n  return e;\n}\nfunction __spreadArrays$2() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), S = 0, t = 0; t < e; t++)\n    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)\n      r[S] = T[D];\n  return r;\n}\nfunction isDiff(o, t) {\n  if (o === t)\n    return !1;\n  for (var e in o)\n    if (!(e in t))\n      return !0;\n  for (var e in t)\n    if (o[e] !== t[e])\n      return !0;\n  return !1;\n}\nfunction diffObject(o, t) {\n  var e = Object.keys(o), r = Object.keys(t), S = diff$1(e, r, function(B) {\n    return B;\n  }), T = {}, D = {}, N = {};\n  return S.added.forEach(function(B) {\n    var $ = r[B];\n    T[$] = t[$];\n  }), S.removed.forEach(function(B) {\n    var $ = e[B];\n    D[$] = o[$];\n  }), S.maintained.forEach(function(B) {\n    var $ = B[0], U = e[$], V = [o[U], t[U]];\n    o[U] !== t[U] && (N[U] = V);\n  }), {\n    added: T,\n    removed: D,\n    changed: N\n  };\n}\nfunction executeHooks(o) {\n  o.forEach(function(t) {\n    t();\n  });\n}\nfunction fillKeys(o) {\n  var t = 0;\n  return o.map(function(e) {\n    return e == null ? \"$compat\" + ++t : \"\" + e;\n  });\n}\nfunction createProvider(o, t, e, r) {\n  if (isString$1(o) || isNumber(o))\n    return new TextProvider(\"text_\" + o, t, e, r, null, {});\n  var S = typeof o.type == \"string\" ? ElementProvider : o.type.prototype.render ? ComponentProvider : FunctionProvider;\n  return new S(o.type, t, e, r, o.ref, o.props);\n}\nfunction flat$1(o) {\n  var t = [];\n  return o.forEach(function(e) {\n    t = t.concat(isArray(e) ? flat$1(e) : e);\n  }), t;\n}\nfunction getAttributes(o) {\n  var t = o.className, e = __rest$2(o, [\"className\"]);\n  return t != null && (e.class = t), delete e.style, delete e.children, e;\n}\nfunction fillProps(o, t) {\n  if (!t)\n    return o;\n  for (var e in t)\n    isUndefined(o[e]) && (o[e] = t[e]);\n  return o;\n}\nfunction createElement(o, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var S = t || {}, T = S.key, D = S.ref, N = __rest$2(S, [\"key\", \"ref\"]);\n  return {\n    type: o,\n    key: T,\n    ref: D,\n    props: __assign$6(__assign$6({}, N), {\n      children: flat$1(e).filter(function(B) {\n        return B != null && B !== !1;\n      })\n    })\n  };\n}\nvar Provider = /* @__PURE__ */ function() {\n  function o(e, r, S, T, D, N) {\n    N === void 0 && (N = {}), this.type = e, this.key = r, this.index = S, this.container = T, this.ref = D, this.props = N, this._providers = [];\n  }\n  var t = o.prototype;\n  return t._should = function(e, r) {\n    return !0;\n  }, t._update = function(e, r, S, T) {\n    if (this.base && !isString$1(r) && !T && !this._should(r.props, S))\n      return !1;\n    this.original = r, this._setState(S);\n    var D = this.props;\n    return isString$1(r) || (this.props = r.props, this.ref = r.ref), this._render(e, this.base ? D : {}, S), !0;\n  }, t._mounted = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._setState = function(e) {\n  }, t._updated = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._destroy = function() {\n    var e = this.ref;\n    e && e(null);\n  }, o;\n}();\nfunction diffAttributes(o, t, e) {\n  var r = diffObject(o, t), S = r.added, T = r.removed, D = r.changed;\n  for (var N in S)\n    e.setAttribute(N, S[N]);\n  for (var N in D)\n    e.setAttribute(N, D[N][1]);\n  for (var N in T)\n    e.removeAttribute(N);\n}\nfunction diffEvents(o, t, e) {\n  var r = diffObject(o, t), S = r.added, T = r.removed, D = r.changed;\n  for (var N in T)\n    e.removeEventListener(N);\n  for (var N in S)\n    e.addEventListener(N, S[N]);\n  for (var N in D)\n    e.removeEventListener(N), e.addEventListener(N, D[N][1]);\n  for (var N in T)\n    e.removeEventListener(N);\n}\nfunction diffStyle(o, t, e) {\n  var r = e.style, S = diffObject(o, t), T = S.added, D = S.removed, N = S.changed;\n  for (var B in T) {\n    var $ = decamelize(B, \"-\");\n    r.setProperty ? r.setProperty($, T[B]) : r[$] = T[B];\n  }\n  for (var B in N) {\n    var $ = decamelize(B, \"-\");\n    r.setProperty ? r.setProperty($, N[B][1]) : r[$] = N[B][1];\n  }\n  for (var B in D) {\n    var $ = decamelize(B, \"-\");\n    r.removeProperty ? r.removeProperty($) : r[$] = \"\";\n  }\n}\nfunction splitProps(o) {\n  var t = {}, e = {};\n  for (var r in o)\n    r.indexOf(\"on\") === 0 ? e[r.replace(\"on\", \"\").toLowerCase()] = o[r] : t[r] = o[r];\n  return {\n    attributes: t,\n    events: e\n  };\n}\nvar TextProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(r) {\n    var S = this, T = !this.base;\n    return T && (this.base = document.createTextNode(this.type.replace(\"text_\", \"\"))), r.push(function() {\n      T ? S._mounted() : S._updated();\n    }), !0;\n  }, e._unmount = function() {\n    this.base.parentNode.removeChild(this.base);\n  }, t;\n}(Provider), ElementProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.events = {}, r._isSVG = !1, r;\n  }\n  var e = t.prototype;\n  return e.addEventListener = function(r, S) {\n    var T = this.events;\n    T[r] = function(D) {\n      D.nativeEvent = D, S(D);\n    }, this.base.addEventListener(r, T[r]);\n  }, e.removeEventListener = function(r) {\n    var S = this.events;\n    this.base.removeEventListener(r, S[r]), delete S[r];\n  }, e._should = function(r) {\n    return isDiff(this.props, r);\n  }, e._render = function(r, S) {\n    var T = this, D = !this.base;\n    if (D) {\n      var N = this._hasSVG();\n      this._isSVG = N;\n      var B = this.props.portalContainer;\n      if (!B) {\n        var $ = this.type;\n        N ? B = document.createElementNS(\"http://www.w3.org/2000/svg\", $) : B = document.createElement($);\n      }\n      this.base = B;\n    }\n    renderProviders(this, this._providers, this.props.children, r, null);\n    var U = this.base, V = splitProps(S), H = V.attributes, X = V.events, Y = splitProps(this.props), W = Y.attributes, q = Y.events;\n    return diffAttributes(getAttributes(H), getAttributes(W), U), diffEvents(X, q, this), diffStyle(S.style || {}, this.props.style || {}, U), r.push(function() {\n      D ? T._mounted() : T._updated();\n    }), !0;\n  }, e._unmount = function() {\n    var r = this.events, S = this.base;\n    for (var T in r)\n      S.removeEventListener(T, r[T]);\n    this._providers.forEach(function(D) {\n      D._unmount();\n    }), this.events = {}, this.props.portalContainer || S.parentNode.removeChild(S);\n  }, e._hasSVG = function() {\n    if (this._isSVG || this.type === \"svg\")\n      return !0;\n    var r = findContainerNode(this.container);\n    return r && \"ownerSVGElement\" in r;\n  }, t;\n}(Provider);\nfunction findContainerNode(o) {\n  if (!o)\n    return null;\n  var t = o.base;\n  return t instanceof Node ? t : findContainerNode(o.container);\n}\nfunction findDOMNode(o) {\n  if (!o)\n    return null;\n  if (o instanceof Node)\n    return o;\n  var t = o.$_provider._providers;\n  return t.length ? findDOMNode(t[0].base) : null;\n}\nvar FunctionProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(r) {\n    var S = this.type(this.props);\n    return renderProviders(this, this._providers, S ? [S] : [], r), !0;\n  }, e._unmount = function() {\n    this._providers.forEach(function(r) {\n      r._unmount();\n    });\n  }, t;\n}(Provider), ContainerProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t(r) {\n    var S = o.call(this, \"container\", \"container\", 0, null) || this;\n    return S.base = r, S;\n  }\n  var e = t.prototype;\n  return e._render = function() {\n    return !0;\n  }, e._unmount = function() {\n  }, t;\n}(Provider), ComponentProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t(r, S, T, D, N, B) {\n    return B === void 0 && (B = {}), o.call(this, r, S, T, D, N, fillProps(B, r.defaultProps)) || this;\n  }\n  var e = t.prototype;\n  return e._should = function(r, S) {\n    return this.base.shouldComponentUpdate(fillProps(r, this.type.defaultProps), S || this.base.state);\n  }, e._render = function(r, S) {\n    var T = this;\n    this.props = fillProps(this.props, this.type.defaultProps);\n    var D = !this.base;\n    D ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;\n    var N = this.base, B = N.state, $ = N.render();\n    $ && $.props && !$.props.children.length && ($.props.children = this.props.children), renderProviders(this, this._providers, $ ? [$] : [], r), r.push(function() {\n      D ? (T._mounted(), N.componentDidMount()) : (T._updated(), N.componentDidUpdate(S, B));\n    });\n  }, e._setState = function(r) {\n    var S = this.base;\n    !S || !r || (S.state = r);\n  }, e._unmount = function() {\n    this._providers.forEach(function(r) {\n      r._unmount();\n    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();\n  }, t;\n}(Provider), Component = /* @__PURE__ */ function() {\n  function o(e) {\n    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};\n  }\n  var t = o.prototype;\n  return t.shouldComponentUpdate = function(e, r) {\n    return !0;\n  }, t.render = function() {\n    return null;\n  }, t.setState = function(e, r, S) {\n    var T = this;\n    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$6(__assign$6({}, this.$_state), e), S ? this.$_setState(r, S) : this.$_timer = setTimeout(function() {\n      T.$_timer = 0, T.$_setState(r, S);\n    });\n  }, t.forceUpdate = function(e) {\n    this.setState({}, e, !0);\n  }, t.componentDidMount = function() {\n  }, t.componentDidUpdate = function(e, r) {\n  }, t.componentWillUnmount = function() {\n  }, t.$_setState = function(e, r) {\n    var S = [], T = this.$_provider, D = renderProviders(T.container, [T], [T.original], S, __assign$6(__assign$6({}, this.state), this.$_state), r);\n    D && (e && S.push(e), executeHooks(S));\n  }, o;\n}(), PureComponent = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.shouldComponentUpdate = function(r, S) {\n    return isDiff(this.props, r) || isDiff(this.state, S);\n  }, t;\n}(Component), _Portal = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    var r = this.props, S = r.element, T = r.container;\n    this._portalProvider = new ContainerProvider(T), renderProvider(S, T, this._portalProvider);\n  }, e.componentDidUpdate = function() {\n    var r = this.props, S = r.element, T = r.container;\n    renderProvider(S, T, this._portalProvider);\n  }, e.componentWillUnmount = function() {\n    var r = this.props.container;\n    renderProvider(null, r, this._portalProvider), this._portalProvider = null;\n  }, t;\n}(PureComponent);\nfunction updateProvider(o, t, e) {\n  var r = [];\n  renderProviders(o, o._providers, t, r, e), executeHooks(r);\n}\nfunction getNextSibiling(o, t) {\n  for (var e = o._providers, r = e.length, S = t.index + 1; S < r; ++S) {\n    var T = findDOMNode(e[S].base);\n    if (T)\n      return T;\n  }\n  return null;\n}\nfunction diffProviders(o, t, e) {\n  var r = e.map(function(B) {\n    return isString$1(B) ? null : B.key;\n  }), S = fillKeys(t.map(function(B) {\n    return B.key;\n  })), T = fillKeys(r), D = diff$1(S, T, function(B) {\n    return B;\n  });\n  D.removed.forEach(function(B) {\n    t.splice(B, 1)[0]._unmount();\n  }), D.ordered.forEach(function(B) {\n    var $ = B[0], U = B[1], V = t.splice($, 1)[0];\n    t.splice(U, 0, V);\n    var H = findDOMNode(V.base), X = findDOMNode(t[U + 1] && t[U + 1].base);\n    H && H.parentNode.insertBefore(H, X);\n  }), D.added.forEach(function(B) {\n    t.splice(B, 0, createProvider(e[B], r[B], B, o));\n  });\n  var N = D.maintained.filter(function(B) {\n    B[0];\n    var $ = B[1], U = e[$], V = t[$], H = isString$1(U) ? \"text_\" + U : U.type;\n    return H !== V.type ? (V._unmount(), t.splice($, 1, createProvider(U, r[$], $, o)), !0) : (V.index = $, !1);\n  });\n  return __spreadArrays$2(D.added, N.map(function(B) {\n    B[0];\n    var $ = B[1];\n    return $;\n  }));\n}\nfunction renderProviders(o, t, e, r, S, T) {\n  var D = diffProviders(o, t, e), N = t.filter(function($, U) {\n    return $._update(r, e[U], S, T);\n  }), B = findContainerNode(o);\n  return B && D.reverse().forEach(function($) {\n    var U = t[$], V = findDOMNode(U.base);\n    if (!!V && B !== V && !V.parentNode) {\n      var H = getNextSibiling(o, U);\n      B.insertBefore(V, H);\n    }\n  }), N.length > 0;\n}\nfunction renderProvider(o, t, e) {\n  e === void 0 && (e = t.__REACT_COMPAT__);\n  var r = !!e;\n  return e || (e = new ContainerProvider(t)), updateProvider(e, o ? [o] : []), r || (t.__REACT_COMPAT__ = e), e;\n}\nfunction render(o, t, e) {\n  var r = t.__REACT_COMPAT__;\n  o && !r && (t.innerHTML = \"\"), renderProvider(o, t, r), e && e();\n}\nfunction createPortal(o, t) {\n  return createElement(_Portal, {\n    element: o,\n    container: t\n  });\n}\nvar version = \"simple-1.1.0\";\nfunction some(o, t) {\n  for (var e = o.length, r = 0; r < e; ++r)\n    if (t(o[r], r))\n      return !0;\n  return !1;\n}\nfunction find(o, t) {\n  for (var e = o.length, r = 0; r < e; ++r)\n    if (t(o[r], r))\n      return o[r];\n  return null;\n}\nfunction getUserAgentString(o) {\n  var t = o;\n  if (typeof t > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    t = navigator.userAgent || \"\";\n  }\n  return t.toLowerCase();\n}\nfunction execRegExp(o, t) {\n  try {\n    return new RegExp(o, \"g\").exec(t);\n  } catch {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var o = navigator.userAgentData, t = o.brands || o.uaList;\n  return !!(t && t.length);\n}\nfunction findVersion(o, t) {\n  var e = execRegExp(\"(\" + o + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", t);\n  return e ? e[3] : \"\";\n}\nfunction convertVersion(o) {\n  return o.replace(/_/g, \".\");\n}\nfunction findPreset(o, t) {\n  var e = null, r = \"-1\";\n  return some(o, function(S) {\n    var T = execRegExp(\"(\" + S.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", t);\n    return !T || S.brand ? !1 : (e = S, r = T[3] || \"-1\", S.versionAlias ? r = S.versionAlias : S.versionTest && (r = findVersion(S.versionTest.toLowerCase(), t) || r), r = convertVersion(r), !0);\n  }), {\n    preset: e,\n    version: r\n  };\n}\nfunction findPresetBrand(o, t) {\n  var e = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return some(o, function(r) {\n    var S = findBrand(t, r);\n    return S ? (e.brand = r.id, e.version = r.versionAlias || S.version, e.version !== \"-1\") : !1;\n  }), e;\n}\nfunction findBrand(o, t) {\n  return find(o, function(e) {\n    var r = e.brand;\n    return execRegExp(\"\" + t.test, r.toLowerCase());\n  });\n}\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  test: \"webview\",\n  id: \"webview\"\n}], OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction isWebView(o) {\n  return !!findPreset(WEBVIEW_PRESETS, o).preset;\n}\nfunction getLegacyAgent(o) {\n  var t = getUserAgentString(o), e = !!/mobi/g.exec(t), r = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(t),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, S = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, T = findPreset(BROWSER_PRESETS, t), D = T.preset, N = T.version, B = findPreset(OS_PRESETS, t), $ = B.preset, U = B.version, V = findPreset(CHROMIUM_PRESETS, t);\n  if (r.chromium = !!V.preset, r.chromiumVersion = V.version, !r.chromium) {\n    var H = findPreset(WEBKIT_PRESETS, t);\n    r.webkit = !!H.preset, r.webkitVersion = H.version;\n  }\n  return $ && (S.name = $.id, S.version = U, S.majorVersion = parseInt(U, 10)), D && (r.name = D.id, r.version = N, r.webview && S.name === \"ios\" && r.name !== \"safari\" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {\n    browser: r,\n    os: S,\n    isMobile: e,\n    isHints: !1\n  };\n}\nfunction getClientHintsAgent(o) {\n  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = o && o.fullVersionList, S = t.mobile || !1, T = e[0], D = (o && o.platform || t.platform || navigator.platform).toLowerCase(), N = {\n    name: T.brand,\n    version: T.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())\n  }, B = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  N.webkit = !N.chromium && some(WEBKIT_PRESETS, function(Y) {\n    return findBrand(e, Y);\n  });\n  var $ = findPresetBrand(CHROMIUM_PRESETS, e);\n  if (N.chromium = !!$.brand, N.chromiumVersion = $.version, !N.chromium) {\n    var U = findPresetBrand(WEBKIT_PRESETS, e);\n    N.webkit = !!U.brand, N.webkitVersion = U.version;\n  }\n  var V = find(OS_PRESETS, function(Y) {\n    return new RegExp(\"\" + Y.test, \"g\").exec(D);\n  });\n  if (B.name = V ? V.id : \"\", o && (B.version = o.platformVersion), r && r.length) {\n    var H = findPresetBrand(BROWSER_PRESETS, r);\n    N.name = H.brand || N.name, N.version = H.version || N.version;\n  } else {\n    var X = findPresetBrand(BROWSER_PRESETS, e);\n    N.name = X.brand || N.name, N.version = X.brand && o ? o.uaFullVersion : X.version;\n  }\n  return N.webkit && (B.name = S ? \"ios\" : \"mac\"), B.name === \"ios\" && N.webview && (N.version = \"-1\"), B.version = convertVersion(B.version), N.version = convertVersion(N.version), B.majorVersion = parseInt(B.version, 10), N.majorVersion = parseInt(N.version, 10), {\n    browser: N,\n    os: B,\n    isMobile: S,\n    isHints: !0\n  };\n}\nfunction agent$1(o) {\n  return typeof o > \"u\" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(o);\n}\nfunction add(o, t, e, r, S, T) {\n  for (var D = 0; D < S; ++D) {\n    var N = e + D * S, B = r + D * S;\n    o[N] += o[B] * T, t[N] += t[B] * T;\n  }\n}\nfunction swap(o, t, e, r, S) {\n  for (var T = 0; T < S; ++T) {\n    var D = e + T * S, N = r + T * S, B = o[D], $ = t[D];\n    o[D] = o[N], o[N] = B, t[D] = t[N], t[N] = $;\n  }\n}\nfunction divide(o, t, e, r, S) {\n  for (var T = 0; T < r; ++T) {\n    var D = e + T * r;\n    o[D] /= S, t[D] /= S;\n  }\n}\nfunction ignoreDimension(o, t, e) {\n  e === void 0 && (e = Math.sqrt(o.length));\n  for (var r = o.slice(), S = 0; S < e; ++S)\n    r[S * e + t - 1] = 0, r[(t - 1) * e + S] = 0;\n  return r[(t - 1) * (e + 1)] = 1, r;\n}\nfunction invert(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = o.slice(), r = createIdentityMatrix(t), S = 0; S < t; ++S) {\n    var T = t * S + S;\n    if (!throttle(e[T], TINY_NUM$1)) {\n      for (var D = S + 1; D < t; ++D)\n        if (e[t * S + D]) {\n          swap(e, r, S, D, t);\n          break;\n        }\n    }\n    if (!throttle(e[T], TINY_NUM$1))\n      return [];\n    divide(e, r, S, t, e[T]);\n    for (var D = 0; D < t; ++D) {\n      var N = D, B = D + S * t, $ = e[B];\n      !throttle($, TINY_NUM$1) || S === D || add(e, r, N, S, t, -$);\n    }\n  }\n  return r;\n}\nfunction transpose(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = [], r = 0; r < t; ++r)\n    for (var S = 0; S < t; ++S)\n      e[S * t + r] = o[t * r + S];\n  return e;\n}\nfunction getOrigin(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = [], r = o[t * t - 1], S = 0; S < t - 1; ++S)\n    e[S] = o[t * (t - 1) + S] / r;\n  return e[t - 1] = 0, e;\n}\nfunction fromTranslation(o, t) {\n  for (var e = createIdentityMatrix(t), r = 0; r < t - 1; ++r)\n    e[t * (t - 1) + r] = o[r] || 0;\n  return e;\n}\nfunction convertPositionMatrix(o, t) {\n  for (var e = o.slice(), r = o.length; r < t - 1; ++r)\n    e[r] = 0;\n  return e[t - 1] = 1, e;\n}\nfunction convertDimension(o, t, e) {\n  if (t === void 0 && (t = Math.sqrt(o.length)), t === e)\n    return o;\n  for (var r = createIdentityMatrix(e), S = Math.min(t, e), T = 0; T < S - 1; ++T) {\n    for (var D = 0; D < S - 1; ++D)\n      r[T * e + D] = o[T * t + D];\n    r[(T + 1) * e - 1] = o[(T + 1) * t - 1], r[(e - 1) * e + T] = o[(t - 1) * t + T];\n  }\n  return r[e * e - 1] = o[t * t - 1], r;\n}\nfunction multiplies(o) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  var r = createIdentityMatrix(o);\n  return t.forEach(function(S) {\n    r = multiply(r, S, o);\n  }), r;\n}\nfunction multiply(o, t, e) {\n  e === void 0 && (e = Math.sqrt(o.length));\n  var r = [], S = o.length / e, T = t.length / S;\n  if (S) {\n    if (!T)\n      return o;\n  } else\n    return t;\n  for (var D = 0; D < e; ++D)\n    for (var N = 0; N < T; ++N) {\n      r[N * e + D] = 0;\n      for (var B = 0; B < S; ++B)\n        r[N * e + D] += o[B * e + D] * t[N * S + B];\n    }\n  return r;\n}\nfunction plus(o, t) {\n  for (var e = Math.min(o.length, t.length), r = o.slice(), S = 0; S < e; ++S)\n    r[S] = r[S] + t[S];\n  return r;\n}\nfunction minus(o, t) {\n  for (var e = Math.min(o.length, t.length), r = o.slice(), S = 0; S < e; ++S)\n    r[S] = r[S] - t[S];\n  return r;\n}\nfunction convertCSStoMatrix(o, t) {\n  return t === void 0 && (t = o.length === 6), t ? [o[0], o[1], 0, o[2], o[3], 0, o[4], o[5], 1] : o;\n}\nfunction convertMatrixtoCSS(o, t) {\n  return t === void 0 && (t = o.length === 9), t ? [o[0], o[1], o[3], o[4], o[6], o[7]] : o;\n}\nfunction calculate(o, t, e) {\n  e === void 0 && (e = t.length);\n  var r = multiply(o, t, e), S = r[e - 1];\n  return r.map(function(T) {\n    return T / S;\n  });\n}\nfunction rotateX3d(o, t) {\n  return multiply(o, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateY3d(o, t) {\n  return multiply(o, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateZ3d(o, t) {\n  return multiply(o, createRotateMatrix(t, 4));\n}\nfunction scale3d(o, t) {\n  var e = t[0], r = e === void 0 ? 1 : e, S = t[1], T = S === void 0 ? 1 : S, D = t[2], N = D === void 0 ? 1 : D;\n  return multiply(o, [r, 0, 0, 0, 0, T, 0, 0, 0, 0, N, 0, 0, 0, 0, 1], 4);\n}\nfunction rotate(o, t) {\n  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(o, 3));\n}\nfunction translate3d(o, t) {\n  var e = t[0], r = e === void 0 ? 0 : e, S = t[1], T = S === void 0 ? 0 : S, D = t[2], N = D === void 0 ? 0 : D;\n  return multiply(o, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, T, N, 1], 4);\n}\nfunction matrix3d(o, t) {\n  return multiply(o, t, 4);\n}\nfunction createRotateMatrix(o, t) {\n  var e = Math.cos(o), r = Math.sin(o), S = createIdentityMatrix(t);\n  return S[0] = e, S[1] = r, S[t] = -r, S[t + 1] = e, S;\n}\nfunction createIdentityMatrix(o) {\n  for (var t = o * o, e = [], r = 0; r < t; ++r)\n    e[r] = r % (o + 1) ? 0 : 1;\n  return e;\n}\nfunction createScaleMatrix(o, t) {\n  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), S = 0; S < r; ++S)\n    e[(t + 1) * S] = o[S];\n  return e;\n}\nfunction createOriginMatrix(o, t) {\n  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), S = 0; S < r; ++S)\n    e[t * (t - 1) + S] = o[S];\n  return e;\n}\nfunction createWarpMatrix(o, t, e, r, S, T, D, N) {\n  var B = o[0], $ = o[1], U = t[0], V = t[1], H = e[0], X = e[1], Y = r[0], W = r[1], q = S[0], K = S[1], Z = T[0], J = T[1], Q = D[0], rt = D[1], et = N[0], nt = N[1], st = [B, 0, U, 0, H, 0, Y, 0, $, 0, V, 0, X, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, B, 0, U, 0, H, 0, Y, 0, $, 0, V, 0, X, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, -q * B, -K * B, -Z * U, -J * U, -Q * H, -rt * H, -et * Y, -nt * Y, -q * $, -K * $, -Z * V, -J * V, -Q * X, -rt * X, -et * W, -nt * W], it = invert(st, 8);\n  if (!it.length)\n    return [];\n  var at = multiply(it, [q, K, Z, J, Q, rt, et, nt], 8);\n  return at[8] = 1, convertDimension(transpose(at), 3, 4);\n}\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction parseMat(o) {\n  return toMat(parse$1(o));\n}\nfunction calculateMatrixDist(o, t) {\n  var e = calculate(o, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;\n  return [e[0] / r, e[1] / r, e[2] / r];\n}\nfunction toMat(o) {\n  var t = createMatrix();\n  return o.forEach(function(e) {\n    var r = e.matrixFunction, S = e.functionValue;\n    !r || (t = r(t, S));\n  }), t;\n}\nfunction parse$1(o) {\n  var t = isArray(o) ? o : splitSpace(o);\n  return t.map(function(e) {\n    var r = splitBracket(e), S = r.prefix, T = r.value, D = null, N = S, B = \"\";\n    if (S === \"translate\" || S === \"translateX\" || S === \"translate3d\") {\n      var $ = splitComma(T).map(function(at) {\n        return parseFloat(at);\n      }), U = $[0], V = $[1], H = V === void 0 ? 0 : V, X = $[2], Y = X === void 0 ? 0 : X;\n      D = translate3d, B = [U, H, Y];\n    } else if (S === \"translateY\") {\n      var H = parseFloat(T);\n      D = translate3d, B = [0, H, 0];\n    } else if (S === \"translateZ\") {\n      var Y = parseFloat(T);\n      D = translate3d, B = [0, 0, Y];\n    } else if (S === \"scale\" || S === \"scale3d\") {\n      var W = splitComma(T).map(function(at) {\n        return parseFloat(at);\n      }), q = W[0], K = W[1], Z = K === void 0 ? q : K, J = W[2], Q = J === void 0 ? 1 : J;\n      D = scale3d, B = [q, Z, Q];\n    } else if (S === \"scaleX\") {\n      var q = parseFloat(T);\n      D = scale3d, B = [q, 1, 1];\n    } else if (S === \"scaleY\") {\n      var Z = parseFloat(T);\n      D = scale3d, B = [1, Z, 1];\n    } else if (S === \"scaleZ\") {\n      var Q = parseFloat(T);\n      D = scale3d, B = [1, 1, Q];\n    } else if (S === \"rotate\" || S === \"rotateZ\" || S === \"rotateX\" || S === \"rotateY\") {\n      var rt = splitUnit(T), et = rt.unit, nt = rt.value, st = et === \"rad\" ? nt : nt * Math.PI / 180;\n      S === \"rotate\" || S === \"rotateZ\" ? (N = \"rotateZ\", D = rotateZ3d) : S === \"rotateX\" ? D = rotateX3d : S === \"rotateY\" && (D = rotateY3d), B = st;\n    } else if (S === \"matrix3d\")\n      D = matrix3d, B = splitComma(T).map(function(at) {\n        return parseFloat(at);\n      });\n    else if (S === \"matrix\") {\n      var it = splitComma(T).map(function(at) {\n        return parseFloat(at);\n      });\n      D = matrix3d, B = [it[0], it[1], 0, 0, it[2], it[3], 0, 0, 0, 0, 1, 0, it[4], it[5], 0, 1];\n    } else\n      N = \"\";\n    return {\n      name: S,\n      functionName: N,\n      value: T,\n      matrixFunction: D,\n      functionValue: B\n    };\n  });\n}\nvar extendStatics$5 = function(o, t) {\n  return extendStatics$5 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$5(o, t);\n};\nfunction __extends$5(o, t) {\n  extendStatics$5(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar findKeyCallback = typeof Map == \"function\" ? void 0 : function() {\n  var o = 0;\n  return function(t) {\n    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++o);\n  };\n}(), ChildrenDiffer = /* @__PURE__ */ function(o) {\n  __extends$5(t, o);\n  function t(e) {\n    return e === void 0 && (e = []), o.call(this, e, findKeyCallback) || this;\n  }\n  return t;\n}(ListDiffer);\nfunction diff(o, t) {\n  return diff$1(o, t, findKeyCallback);\n}\nconst ChildrenDiffer$1 = ChildrenDiffer;\nfunction __spreadArrays$1() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), S = 0, t = 0; t < e; t++)\n    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)\n      r[S] = T[D];\n  return r;\n}\nfunction tinyThrottle(o) {\n  return throttle(o, TINY_NUM$1);\n}\nfunction isSameConstants(o, t) {\n  return o.every(function(e, r) {\n    return tinyThrottle(e - t[r]) === 0;\n  });\n}\nfunction isSamePoint(o, t) {\n  return !tinyThrottle(o[0] - t[0]) && !tinyThrottle(o[1] - t[1]);\n}\nfunction getAreaSize(o) {\n  return o.length < 3 ? 0 : Math.abs(sum(o.map(function(t, e) {\n    var r = o[e + 1] || o[0];\n    return t[0] * r[1] - r[0] * t[1];\n  }))) / 2;\n}\nfunction fitPoints(o, t) {\n  var e = t.width, r = t.height, S = t.left, T = t.top, D = getMinMaxs(o), N = D.minX, B = D.minY, $ = D.maxX, U = D.maxY, V = e / ($ - N), H = r / (U - B);\n  return o.map(function(X) {\n    return [S + (X[0] - N) * V, T + (X[1] - B) * H];\n  });\n}\nfunction getMinMaxs(o) {\n  var t = o.map(function(r) {\n    return r[0];\n  }), e = o.map(function(r) {\n    return r[1];\n  });\n  return {\n    minX: Math.min.apply(Math, t),\n    minY: Math.min.apply(Math, e),\n    maxX: Math.max.apply(Math, t),\n    maxY: Math.max.apply(Math, e)\n  };\n}\nfunction isInside(o, t, e) {\n  var r = o[0], S = o[1], T = getMinMaxs(t), D = T.minX, N = T.maxX, B = [[D, S], [N, S]], $ = getLinearConstants(B[0], B[1]), U = convertLines(t), V = [];\n  if (U.forEach(function(Y) {\n    var W = getLinearConstants(Y[0], Y[1]), q = Y[0];\n    if (isSameConstants($, W))\n      V.push({\n        pos: o,\n        line: Y,\n        type: \"line\"\n      });\n    else {\n      var K = getPointsOnLines(getIntersectionPointsByConstants($, W), [B, Y]);\n      K.forEach(function(Z) {\n        Y.some(function(J) {\n          return isSamePoint(J, Z);\n        }) ? V.push({\n          pos: Z,\n          line: Y,\n          type: \"point\"\n        }) : tinyThrottle(q[1] - S) !== 0 && V.push({\n          pos: Z,\n          line: Y,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), !e && find$1(V, function(Y) {\n    return Y[0] === r;\n  }))\n    return !0;\n  var H = 0, X = {};\n  return V.forEach(function(Y) {\n    var W = Y.pos, q = Y.type, K = Y.line;\n    if (!(W[0] > r))\n      if (q === \"intersection\")\n        ++H;\n      else {\n        if (q === \"line\")\n          return;\n        if (q === \"point\") {\n          var Z = find$1(K, function(rt) {\n            return rt[1] !== S;\n          }), J = X[W[0]], Q = Z[1] > S ? 1 : -1;\n          J ? J !== Q && ++H : X[W[0]] = Q;\n        }\n      }\n  }), H % 2 === 1;\n}\nfunction getLinearConstants(o, t) {\n  var e = o[0], r = o[1], S = t[0], T = t[1], D = S - e, N = T - r;\n  Math.abs(D) < TINY_NUM$1 && (D = 0), Math.abs(N) < TINY_NUM$1 && (N = 0);\n  var B = 0, $ = 0, U = 0;\n  return D ? N ? (B = -N / D, $ = 1, U = -B * e - r) : ($ = 1, U = -r) : N && (B = -1, U = e), [B, $, U];\n}\nfunction getIntersectionPointsByConstants(o, t) {\n  var e = o[0], r = o[1], S = o[2], T = t[0], D = t[1], N = t[2], B = e === 0 && T === 0, $ = r === 0 && D === 0, U = [];\n  if (B && $)\n    return [];\n  if (B) {\n    var V = -S / r, H = -N / D;\n    return V !== H ? [] : [[-1 / 0, V], [1 / 0, V]];\n  } else if ($) {\n    var X = -S / e, Y = -N / T;\n    return X !== Y ? [] : [[X, -1 / 0], [X, 1 / 0]];\n  } else if (e === 0) {\n    var W = -S / r, q = -(D * W + N) / T;\n    U = [[q, W]];\n  } else if (T === 0) {\n    var W = -N / D, q = -(r * W + S) / e;\n    U = [[q, W]];\n  } else if (r === 0) {\n    var q = -S / e, W = -(T * q + N) / D;\n    U = [[q, W]];\n  } else if (D === 0) {\n    var q = -N / T, W = -(e * q + S) / r;\n    U = [[q, W]];\n  } else {\n    var q = (r * N - D * S) / (D * e - r * T), W = -(e * q + S) / r;\n    U = [[q, W]];\n  }\n  return U.map(function(K) {\n    return [K[0], K[1]];\n  });\n}\nfunction getPointsOnLines(o, t) {\n  var e = t.map(function(V) {\n    return [0, 1].map(function(H) {\n      return [Math.min(V[0][H], V[1][H]), Math.max(V[0][H], V[1][H])];\n    });\n  }), r = [];\n  if (o.length === 2) {\n    var S = o[0], T = S[0], D = S[1];\n    if (tinyThrottle(T - o[1][0])) {\n      if (!tinyThrottle(D - o[1][1])) {\n        var $ = Math.max.apply(Math, e.map(function(V) {\n          return V[0][0];\n        })), U = Math.min.apply(Math, e.map(function(V) {\n          return V[0][1];\n        }));\n        if (tinyThrottle($ - U) > 0)\n          return [];\n        r = [[$, D], [U, D]];\n      }\n    } else {\n      var N = Math.max.apply(Math, e.map(function(V) {\n        return V[1][0];\n      })), B = Math.min.apply(Math, e.map(function(V) {\n        return V[1][1];\n      }));\n      if (tinyThrottle(N - B) > 0)\n        return [];\n      r = [[T, N], [T, B]];\n    }\n  }\n  return r.length || (r = o.filter(function(V) {\n    var H = V[0], X = V[1];\n    return e.every(function(Y) {\n      return 0 <= tinyThrottle(H - Y[0][0]) && 0 <= tinyThrottle(Y[0][1] - H) && 0 <= tinyThrottle(X - Y[1][0]) && 0 <= tinyThrottle(Y[1][1] - X);\n    });\n  })), r.map(function(V) {\n    return [tinyThrottle(V[0]), tinyThrottle(V[1])];\n  });\n}\nfunction convertLines(o) {\n  return __spreadArrays$1(o.slice(1), [o[0]]).map(function(t, e) {\n    return [o[e], t];\n  });\n}\nfunction getOverlapPointInfos(o, t) {\n  var e = o.slice(), r = t.slice();\n  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(r) === -1 && r.reverse();\n  var S = convertLines(e), T = convertLines(r), D = S.map(function(U) {\n    return getLinearConstants(U[0], U[1]);\n  }), N = T.map(function(U) {\n    return getLinearConstants(U[0], U[1]);\n  }), B = [];\n  D.forEach(function(U, V) {\n    var H = S[V], X = [];\n    N.forEach(function(Y, W) {\n      var q = getIntersectionPointsByConstants(U, Y), K = getPointsOnLines(q, [H, T[W]]);\n      X.push.apply(X, K.map(function(Z) {\n        return {\n          index1: V,\n          index2: W,\n          pos: Z,\n          type: \"intersection\"\n        };\n      }));\n    }), X.sort(function(Y, W) {\n      return getDist$2(H[0], Y.pos) - getDist$2(H[0], W.pos);\n    }), B.push.apply(B, X), isInside(H[1], r) && B.push({\n      index1: V,\n      index2: -1,\n      pos: H[1],\n      type: \"inside\"\n    });\n  }), T.forEach(function(U, V) {\n    if (!!isInside(U[1], e)) {\n      var H = !1, X = findIndex(B, function(Y) {\n        var W = Y.index2;\n        return W === V ? (H = !0, !1) : !!H;\n      });\n      X === -1 && (H = !1, X = findIndex(B, function(Y) {\n        var W = Y.index1, q = Y.index2;\n        return W === -1 && q + 1 === V ? (H = !0, !1) : !!H;\n      })), X === -1 ? B.push({\n        index1: -1,\n        index2: V,\n        pos: U[1],\n        type: \"inside\"\n      }) : B.splice(X, 0, {\n        index1: -1,\n        index2: V,\n        pos: U[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var $ = {};\n  return B.filter(function(U) {\n    var V = U.pos, H = V[0] + \"x\" + V[1];\n    return $[H] ? !1 : ($[H] = !0, !0);\n  });\n}\nfunction getOverlapPoints(o, t) {\n  var e = getOverlapPointInfos(o, t);\n  return e.map(function(r) {\n    var S = r.pos;\n    return S;\n  });\n}\nfunction getOverlapSize(o, t) {\n  var e = getOverlapPoints(o, t);\n  return getAreaSize(e);\n}\nvar __assign$5 = function() {\n  return __assign$5 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$5.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), S = 0, t = 0; t < e; t++)\n    for (var T = arguments[t], D = 0, N = T.length; D < N; D++, S++)\n      r[S] = T[D];\n  return r;\n}\nvar EventEmitter = /* @__PURE__ */ function() {\n  function o() {\n    this._events = {};\n  }\n  var t = o.prototype;\n  return t.on = function(e, r) {\n    if (isObject$2(e))\n      for (var S in e)\n        this.on(S, e[S]);\n    else\n      this._addEvent(e, r, {});\n    return this;\n  }, t.off = function(e, r) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var S in e)\n        this.off(S);\n    else if (!r)\n      this._events[e] = [];\n    else {\n      var T = this._events[e];\n      if (T) {\n        var D = findIndex(T, function(N) {\n          return N.listener === r;\n        });\n        D > -1 && T.splice(D, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, r) {\n    var S = this;\n    return r && this._addEvent(e, r, {\n      once: !0\n    }), new Promise(function(T) {\n      S._addEvent(e, T, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, r) {\n    var S = this;\n    r === void 0 && (r = {});\n    var T = this._events[e];\n    if (!e || !T)\n      return !0;\n    var D = !1;\n    return r.eventType = e, r.stop = function() {\n      D = !0;\n    }, r.currentTarget = this, __spreadArrays(T).forEach(function(N) {\n      N.listener(r), N.once && S.off(e, N.listener);\n    }), !D;\n  }, t.trigger = function(e, r) {\n    return r === void 0 && (r = {}), this.emit(e, r);\n  }, t._addEvent = function(e, r, S) {\n    var T = this._events;\n    T[e] = T[e] || [];\n    var D = T[e];\n    D.push(__assign$5({\n      listener: r\n    }, S));\n  }, o;\n}();\nconst EventEmitter$1 = EventEmitter;\nvar FUNCTION = \"function\", STRING = \"string\";\nfunction isString(o) {\n  return typeof o === STRING;\n}\nfunction isFunction$2(o) {\n  return typeof o === FUNCTION;\n}\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\nvar extendStatics$4 = function(o, t) {\n  return extendStatics$4 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$4(o, t);\n};\nfunction __extends$4(o, t) {\n  extendStatics$4(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$4 = function() {\n  return __assign$4 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$4.apply(this, arguments);\n};\nfunction getDefaultScrollPosition$1(o) {\n  var t = o.container;\n  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];\n}\nfunction getContainerElement(o) {\n  if (o) {\n    if (isString(o))\n      return document.querySelector(o);\n  } else\n    return null;\n  if (isFunction$2(o))\n    return o();\n  if (o instanceof Element)\n    return o;\n  if (\"current\" in o)\n    return o.current;\n  if (\"value\" in o)\n    return o.value;\n}\nvar DragScroll = /* @__PURE__ */ function(o) {\n  __extends$4(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r;\n  }\n  var e = t.prototype;\n  return e.dragStart = function(r, S) {\n    var T = getContainerElement(S.container);\n    if (!T) {\n      this._flag = !1;\n      return;\n    }\n    var D = 0, N = 0, B = 0, $ = 0;\n    if (T === document.body)\n      B = window.innerWidth, $ = window.innerHeight;\n    else {\n      var U = T.getBoundingClientRect();\n      D = U.top, N = U.left, B = U.width, $ = U.height;\n    }\n    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {\n      top: D,\n      left: N,\n      width: B,\n      height: $\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], S);\n  }, e.drag = function(r, S) {\n    if (clearTimeout(this._timer), !!this._flag) {\n      var T = r.clientX, D = r.clientY, N = S.threshold, B = N === void 0 ? 0 : N, $ = this, U = $._startRect, V = $._startPos, H = [0, 0];\n      return U.top > D - B ? (V[1] > U.top || D < V[1]) && (H[1] = -1) : U.top + U.height < D + B && (V[1] < U.top + U.height || D > V[1]) && (H[1] = 1), U.left > T - B ? (V[0] > U.left || T < V[0]) && (H[0] = -1) : U.left + U.width < T + B && (V[0] < U.left + U.width || T > V[0]) && (H[0] = 1), !H[0] && !H[1] ? !1 : this._continueDrag(__assign$4(__assign$4({}, S), {\n        direction: H,\n        inputEvent: r,\n        isDrag: !0\n      }));\n    }\n  }, e.checkScroll = function(r) {\n    var S = this;\n    if (this._isWait)\n      return !1;\n    var T = r.prevScrollPos, D = T === void 0 ? this._prevScrollPos : T, N = r.direction, B = r.throttleTime, $ = B === void 0 ? 0 : B, U = r.inputEvent, V = r.isDrag, H = this._getScrollPosition(N || [0, 0], r), X = H[0] - D[0], Y = H[1] - D[1], W = N || [X ? Math.abs(X) / X : 0, Y ? Math.abs(Y) / Y : 0];\n    return this._prevScrollPos = H, !X && !Y ? !1 : (this.trigger(\"move\", {\n      offsetX: W[0] ? X : 0,\n      offsetY: W[1] ? Y : 0,\n      inputEvent: U\n    }), $ && V && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n      S._continueDrag(r);\n    }, $)), !0);\n  }, e.dragEnd = function() {\n    this._flag = !1, clearTimeout(this._timer);\n  }, e._getScrollPosition = function(r, S) {\n    var T = S.container, D = S.getScrollPosition, N = D === void 0 ? getDefaultScrollPosition$1 : D;\n    return N({\n      container: getContainerElement(T),\n      direction: r\n    });\n  }, e._continueDrag = function(r) {\n    var S = this, T, D, N = r.container, B = r.direction, $ = r.throttleTime, U = r.useScroll, V = r.isDrag, H = r.inputEvent;\n    if (!(!this._flag || V && this._isWait)) {\n      var X = now(), Y = Math.max($ + this._prevTime - X, 0);\n      if (Y > 0)\n        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n          S._continueDrag(r);\n        }, Y), !1;\n      this._prevTime = X;\n      var W = this._getScrollPosition(B, r);\n      this._prevScrollPos = W, V && (this._isWait = !0);\n      var q = {\n        container: getContainerElement(N),\n        direction: B,\n        inputEvent: H\n      };\n      return (D = (T = r).requestScroll) === null || D === void 0 || D.call(T, q), this.trigger(\"scroll\", q), this._isWait = !1, U || this.checkScroll(__assign$4(__assign$4({}, r), {\n        prevScrollPos: W,\n        direction: B,\n        inputEvent: H\n      }));\n    }\n  }, t;\n}(EventEmitter$1);\nconst DragScroll$1 = DragScroll;\nvar extendStatics$3 = function(o, t) {\n  return extendStatics$3 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$3(o, t);\n};\nfunction __extends$3(o, t) {\n  extendStatics$3(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$3 = function() {\n  return __assign$3 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$3.apply(this, arguments);\n};\nfunction getRad(o, t) {\n  var e = t[0] - o[0], r = t[1] - o[1], S = Math.atan2(r, e);\n  return S >= 0 ? S : S + Math.PI * 2;\n}\nfunction getRotatiion(o) {\n  return getRad([o[0].clientX, o[0].clientY], [o[1].clientX, o[1].clientY]) / Math.PI * 180;\n}\nfunction isMultiTouch(o) {\n  return o.touches && o.touches.length >= 2;\n}\nfunction getEventClients(o) {\n  return o ? o.touches ? getClients(o.touches) : [getClient(o)] : [];\n}\nfunction isMouseEvent(o) {\n  return o && (o.type.indexOf(\"mouse\") > -1 || \"button\" in o);\n}\nfunction getPosition(o, t, e) {\n  var r = e.length, S = getAverageClient(o, r), T = S.clientX, D = S.clientY, N = S.originalClientX, B = S.originalClientY, $ = getAverageClient(t, r), U = $.clientX, V = $.clientY, H = getAverageClient(e, r), X = H.clientX, Y = H.clientY, W = T - U, q = D - V, K = T - X, Z = D - Y;\n  return {\n    clientX: N,\n    clientY: B,\n    deltaX: W,\n    deltaY: q,\n    distX: K,\n    distY: Z\n  };\n}\nfunction getDist$1(o) {\n  return Math.sqrt(Math.pow(o[0].clientX - o[1].clientX, 2) + Math.pow(o[0].clientY - o[1].clientY, 2));\n}\nfunction getClients(o) {\n  for (var t = Math.min(o.length, 2), e = [], r = 0; r < t; ++r)\n    e.push(getClient(o[r]));\n  return e;\n}\nfunction getClient(o) {\n  return {\n    clientX: o.clientX,\n    clientY: o.clientY\n  };\n}\nfunction getAverageClient(o, t) {\n  t === void 0 && (t = o.length);\n  for (var e = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, r = 0; r < t; ++r) {\n    var S = o[r];\n    e.originalClientX += \"originalClientX\" in S ? S.originalClientX : S.clientX, e.originalClientY += \"originalClientY\" in S ? S.originalClientY : S.clientY, e.clientX += S.clientX, e.clientY += S.clientY;\n  }\n  return t ? {\n    clientX: e.clientX / t,\n    clientY: e.clientY / t,\n    originalClientX: e.originalClientX / t,\n    originalClientY: e.originalClientY / t\n  } : e;\n}\nvar ClientStore = /* @__PURE__ */ function() {\n  function o(e) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;\n  }\n  var t = o.prototype;\n  return t.getAngle = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e);\n  }, t.getRotation = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e) - getRotatiion(this.startClients);\n  }, t.getPosition = function(e, r) {\n    e === void 0 && (e = this.prevClients);\n    var S = getPosition(e || this.prevClients, this.prevClients, this.startClients), T = S.deltaX, D = S.deltaY;\n    return this.movement += Math.sqrt(T * T + D * D), this.prevClients = e, S;\n  }, t.getPositions = function(e) {\n    e === void 0 && (e = this.prevClients);\n    var r = this.prevClients;\n    return this.startClients.map(function(S, T) {\n      return getPosition([e[T]], [r[T]], [S]);\n    });\n  }, t.getMovement = function(e) {\n    var r = this.movement;\n    if (!e)\n      return r;\n    var S = getAverageClient(e, this.length), T = getAverageClient(this.prevClients, this.length), D = S.clientX - T.clientX, N = S.clientY - T.clientY;\n    return Math.sqrt(D * D + N * N) + r;\n  }, t.getDistance = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e);\n  }, t.getScale = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e) / getDist$1(this.startClients);\n  }, t.move = function(e, r) {\n    this.startClients.forEach(function(S) {\n      S.clientX -= e, S.clientY -= r;\n    }), this.prevClients.forEach(function(S) {\n      S.clientX -= e, S.clientY -= r;\n    });\n  }, o;\n}(), INPUT_TAGNAMES = [\"textarea\", \"input\"], Gesto = /* @__PURE__ */ function(o) {\n  __extends$3(t, o);\n  function t(r, S) {\n    S === void 0 && (S = {});\n    var T = o.call(this) || this;\n    T.options = {}, T.flag = !1, T.pinchFlag = !1, T.data = {}, T.isDrag = !1, T.isPinch = !1, T.isMouse = !1, T.isTouch = !1, T.clientStores = [], T.targets = [], T.prevTime = 0, T.doubleFlag = !1, T._dragFlag = !1, T._isMouseEvent = !1, T._isSecondaryButton = !1, T._preventMouseEvent = !1, T.onDragStart = function(H, X) {\n      if (X === void 0 && (X = !0), !(!T.flag && H.cancelable === !1)) {\n        var Y = T.options, W = Y.container, q = Y.pinchOutside, K = Y.preventWheelClick, Z = Y.preventRightClick, J = Y.preventDefault, Q = Y.checkInput, rt = Y.preventClickEventOnDragStart, et = Y.preventClickEventOnDrag, nt = Y.preventClickEventByCondition, st = T.isTouch, it = !T.flag;\n        if (T._isSecondaryButton = H.which === 3 || H.button === 2, K && (H.which === 2 || H.button === 1) || Z && (H.which === 3 || H.button === 2))\n          return T.stop(), !1;\n        if (it) {\n          var at = document.activeElement, ut = H.target;\n          if (ut) {\n            var ct = ut.tagName.toLowerCase(), gt = INPUT_TAGNAMES.indexOf(ct) > -1, _t = ut.isContentEditable;\n            if (gt || _t) {\n              if (Q || at === ut || at && _t && at.isContentEditable && at.contains(ut))\n                return !1;\n            } else if ((J || H.type === \"touchstart\") && at) {\n              var vt = at.tagName.toLowerCase();\n              (at.isContentEditable || INPUT_TAGNAMES.indexOf(vt) > -1) && at.blur();\n            }\n            (rt || et || nt) && addEvent(window, \"click\", T._onClick, !0);\n          }\n          T.clientStores = [new ClientStore(getEventClients(H))], T.flag = !0, T.isDrag = !1, T._dragFlag = !0, T.data = {}, T.doubleFlag = now$1() - T.prevTime < 200, T._isMouseEvent = isMouseEvent(H), !T._isMouseEvent && T._preventMouseEvent && (T._preventMouseEvent = !1);\n          var mt = T._preventMouseEvent || T.emit(\"dragStart\", __assign$3(__assign$3({\n            data: T.data,\n            datas: T.data,\n            inputEvent: H,\n            isMouseEvent: T._isMouseEvent,\n            isSecondaryButton: T._isSecondaryButton,\n            isTrusted: X,\n            isDouble: T.doubleFlag\n          }, T.getCurrentStore().getPosition()), {\n            preventDefault: function() {\n              H.preventDefault();\n            },\n            preventDrag: function() {\n              T._dragFlag = !1;\n            }\n          }));\n          mt === !1 && T.stop(), T._isMouseEvent && T.flag && J && H.preventDefault();\n        }\n        if (!T.flag)\n          return !1;\n        var bt = 0;\n        if (it ? (T._attchDragEvent(), st && q && (bt = setTimeout(function() {\n          addEvent(W, \"touchstart\", T.onDragStart, {\n            passive: !1\n          });\n        }))) : st && q && removeEvent(W, \"touchstart\", T.onDragStart), T.flag && isMultiTouch(H)) {\n          if (clearTimeout(bt), it && H.touches.length !== H.changedTouches.length)\n            return;\n          T.pinchFlag || T.onPinchStart(H);\n        }\n      }\n    }, T.onDrag = function(H, X) {\n      if (!!T.flag) {\n        var Y = T.options.preventDefault;\n        !T._isMouseEvent && Y && H.preventDefault();\n        var W = getEventClients(H), q = T.moveClients(W, H, !1);\n        if (T._dragFlag) {\n          if (T.pinchFlag || q.deltaX || q.deltaY) {\n            var K = T._preventMouseEvent || T.emit(\"drag\", __assign$3(__assign$3({}, q), {\n              isScroll: !!X,\n              inputEvent: H\n            }));\n            if (K === !1) {\n              T.stop();\n              return;\n            }\n          }\n          T.pinchFlag && T.onPinch(H, W);\n        }\n        T.getCurrentStore().getPosition(W, !0);\n      }\n    }, T.onDragEnd = function(H) {\n      if (!!T.flag) {\n        var X = T.options, Y = X.pinchOutside, W = X.container, q = X.preventClickEventOnDrag, K = X.preventClickEventOnDragStart, Z = X.preventClickEventByCondition, J = T.isDrag;\n        (q || K || Z) && requestAnimationFrame(function() {\n          T._allowClickEvent();\n        }), !Z && !K && q && !J && T._allowClickEvent(), T.isTouch && Y && removeEvent(W, \"touchstart\", T.onDragStart), T.pinchFlag && T.onPinchEnd(H);\n        var Q = H != null && H.touches ? getEventClients(H) : [], rt = Q.length;\n        rt === 0 || !T.options.keepDragging ? T.flag = !1 : T._addStore(new ClientStore(Q));\n        var et = T._getPosition(), nt = now$1(), st = !J && T.doubleFlag;\n        T.prevTime = J || st ? 0 : nt, T.flag || (T._dettachDragEvent(), T._preventMouseEvent || T.emit(\"dragEnd\", __assign$3({\n          data: T.data,\n          datas: T.data,\n          isDouble: st,\n          isDrag: J,\n          isClick: !J,\n          isMouseEvent: T._isMouseEvent,\n          isSecondaryButton: T._isSecondaryButton,\n          inputEvent: H\n        }, et)), T.clientStores = [], T._isMouseEvent || (T._preventMouseEvent = !0, requestAnimationFrame(function() {\n          requestAnimationFrame(function() {\n            T._preventMouseEvent = !1;\n          });\n        })));\n      }\n    }, T.onBlur = function() {\n      T.onDragEnd();\n    }, T._allowClickEvent = function() {\n      removeEvent(window, \"click\", T._onClick, !0);\n    }, T._onClick = function(H) {\n      T._allowClickEvent(), T._preventMouseEvent = !1;\n      var X = T.options.preventClickEventByCondition;\n      X != null && X(H) || (H.stopPropagation(), H.preventDefault());\n    }, T._onContextMenu = function(H) {\n      var X = T.options;\n      X.preventRightClick ? T.onDragEnd(H) : H.preventDefault();\n    }, T._passCallback = function() {\n    };\n    var D = [].concat(r);\n    T.options = __assign$3({\n      checkInput: !1,\n      container: D.length > 1 ? window : D[0],\n      preventRightClick: !0,\n      preventWheelClick: !0,\n      preventClickEventOnDragStart: !1,\n      preventClickEventOnDrag: !1,\n      preventClickEventByCondition: null,\n      preventDefault: !0,\n      checkWindowBlur: !1,\n      keepDragging: !1,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, S);\n    var N = T.options, B = N.container, $ = N.events, U = N.checkWindowBlur;\n    if (T.isTouch = $.indexOf(\"touch\") > -1, T.isMouse = $.indexOf(\"mouse\") > -1, T.targets = D, T.isMouse && (D.forEach(function(H) {\n      addEvent(H, \"mousedown\", T.onDragStart), addEvent(H, \"mousemove\", T._passCallback);\n    }), addEvent(B, \"contextmenu\", T._onContextMenu)), U && addEvent(window, \"blur\", T.onBlur), T.isTouch) {\n      var V = {\n        passive: !1\n      };\n      D.forEach(function(H) {\n        addEvent(H, \"touchstart\", T.onDragStart, V), addEvent(H, \"touchmove\", T._passCallback, V);\n      });\n    }\n    return T;\n  }\n  var e = t.prototype;\n  return e.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();\n  }, e.getMovement = function(r) {\n    return this.getCurrentStore().getMovement(r) + this.clientStores.slice(1).reduce(function(S, T) {\n      return S + T.movement;\n    }, 0);\n  }, e.isDragging = function() {\n    return this.isDrag;\n  }, e.isFlag = function() {\n    return this.flag;\n  }, e.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, e.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, e.isPinching = function() {\n    return this.isPinch;\n  }, e.scrollBy = function(r, S, T, D) {\n    D === void 0 && (D = !0), this.flag && (this.clientStores[0].move(r, S), D && this.onDrag(T, !0));\n  }, e.move = function(r, S) {\n    var T = r[0], D = r[1], N = this.getCurrentStore(), B = N.prevClients;\n    return this.moveClients(B.map(function($) {\n      var U = $.clientX, V = $.clientY;\n      return {\n        clientX: U + T,\n        clientY: V + D,\n        originalClientX: U,\n        originalClientY: V\n      };\n    }), S, !0);\n  }, e.triggerDragStart = function(r) {\n    this.onDragStart(r, !1);\n  }, e.setEventData = function(r) {\n    var S = this.data;\n    for (var T in r)\n      S[T] = r[T];\n    return this;\n  }, e.setEventDatas = function(r) {\n    return this.setEventData(r);\n  }, e.getCurrentEvent = function(r) {\n    return __assign$3(__assign$3({\n      data: this.data,\n      datas: this.data\n    }, this._getPosition()), {\n      movement: this.getMovement(),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      inputEvent: r\n    });\n  }, e.getEventData = function() {\n    return this.data;\n  }, e.getEventDatas = function() {\n    return this.data;\n  }, e.unset = function() {\n    var r = this, S = this.targets, T = this.options.container;\n    this.off(), removeEvent(window, \"blur\", this.onBlur), this.isMouse && (S.forEach(function(D) {\n      removeEvent(D, \"mousedown\", r.onDragStart);\n    }), removeEvent(T, \"contextmenu\", this._onContextMenu)), this.isTouch && (S.forEach(function(D) {\n      removeEvent(D, \"touchstart\", r.onDragStart);\n    }), removeEvent(T, \"touchstart\", this.onDragStart)), this._allowClickEvent(), this._dettachDragEvent();\n  }, e.onPinchStart = function(r) {\n    var S = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > S)) {\n      var T = new ClientStore(getEventClients(r));\n      this.pinchFlag = !0, this._addStore(T);\n      var D = this.emit(\"pinchStart\", __assign$3(__assign$3({\n        data: this.data,\n        datas: this.data,\n        angle: T.getAngle(),\n        touches: this.getCurrentStore().getPositions()\n      }, T.getPosition()), {\n        inputEvent: r\n      }));\n      D === !1 && (this.pinchFlag = !1);\n    }\n  }, e.onPinch = function(r, S) {\n    if (!(!this.flag || !this.pinchFlag || S.length < 2)) {\n      var T = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", __assign$3(__assign$3({\n        data: this.data,\n        datas: this.data,\n        movement: this.getMovement(S),\n        angle: T.getAngle(S),\n        rotation: T.getRotation(S),\n        touches: T.getPositions(S),\n        scale: T.getScale(S),\n        distance: T.getDistance(S)\n      }, T.getPosition(S)), {\n        inputEvent: r\n      }));\n    }\n  }, e.onPinchEnd = function(r) {\n    if (!!this.pinchFlag) {\n      var S = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var T = this.getCurrentStore();\n      this.emit(\"pinchEnd\", __assign$3(__assign$3({\n        data: this.data,\n        datas: this.data,\n        isPinch: S,\n        touches: T.getPositions()\n      }, T.getPosition()), {\n        inputEvent: r\n      }));\n    }\n  }, e.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, e.moveClients = function(r, S, T) {\n    var D = this._getPosition(r, T), N = this.isDrag;\n    (D.deltaX || D.deltaY) && (this.isDrag = !0);\n    var B = !1;\n    return !N && this.isDrag && (B = !0), __assign$3(__assign$3({\n      data: this.data,\n      datas: this.data\n    }, D), {\n      movement: this.getMovement(r),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      isMouseEvent: this._isMouseEvent,\n      isSecondaryButton: this._isSecondaryButton,\n      inputEvent: S,\n      isFirstDrag: B\n    });\n  }, e._addStore = function(r) {\n    this.clientStores.splice(0, 0, r);\n  }, e._getPosition = function(r, S) {\n    var T = this.getCurrentStore(), D = T.getPosition(r, S), N = this.clientStores.slice(1).reduce(function(U, V) {\n      var H = V.getPosition();\n      return U.distX += H.distX, U.distY += H.distY, U;\n    }, D), B = N.distX, $ = N.distY;\n    return __assign$3(__assign$3({}, D), {\n      distX: B,\n      distY: $\n    });\n  }, e._attchDragEvent = function() {\n    var r = this.options.container, S = {\n      passive: !1\n    };\n    this.isMouse && (addEvent(r, \"mousemove\", this.onDrag), addEvent(r, \"mouseup\", this.onDragEnd)), this.isTouch && (addEvent(r, \"touchmove\", this.onDrag, S), addEvent(r, \"touchend\", this.onDragEnd, S), addEvent(r, \"touchcancel\", this.onDragEnd, S));\n  }, e._dettachDragEvent = function() {\n    var r = this.options.container;\n    this.isMouse && (removeEvent(r, \"mousemove\", this.onDrag), removeEvent(r, \"mouseup\", this.onDragEnd)), this.isTouch && (removeEvent(r, \"touchstart\", this.onDragStart), removeEvent(r, \"touchmove\", this.onDrag), removeEvent(r, \"touchend\", this.onDragEnd), removeEvent(r, \"touchcancel\", this.onDragEnd));\n  }, t;\n}(EventEmitter$1);\nconst Gesto$1 = Gesto;\nfunction hash$2(o) {\n  for (var t = 5381, e = o.length; e; )\n    t = t * 33 ^ o.charCodeAt(--e);\n  return t >>> 0;\n}\nvar stringHash = hash$2;\nfunction getHash(o) {\n  return stringHash(o).toString(36);\n}\nfunction getShadowRoot$1(o) {\n  if (o && o.getRootNode) {\n    var t = o.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction replaceStyle(o, t, e) {\n  return e.original ? t : t.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(r, S) {\n    var T = S.trim();\n    return (T ? splitComma(T) : [\"\"]).map(function(D) {\n      var N = D.trim();\n      return N.indexOf(\"@\") === 0 ? N : N.indexOf(\":global\") > -1 ? N.replace(/\\:global/g, \"\") : N.indexOf(\":host\") > -1 ? \"\" + N.replace(/\\:host/g, \".\" + o) : N ? \".\" + o + \" \" + N : \".\" + o;\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(o, t, e, r) {\n  var S = document.createElement(\"style\");\n  return S.setAttribute(\"type\", \"text/css\"), S.setAttribute(\"data-styled-id\", o), e.nonce && S.setAttribute(\"nonce\", e.nonce), S.innerHTML = replaceStyle(o, t, e), (r || document.head || document.body).appendChild(S), S;\n}\nfunction styled$1(o) {\n  var t = \"rCS\" + getHash(o), e = 0, r;\n  return {\n    className: t,\n    inject: function(S, T) {\n      T === void 0 && (T = {});\n      var D = getShadowRoot$1(S), N = e === 0, B;\n      return (D || N) && (B = injectStyle(t, o, T, D)), N && (r = B), D || ++e, {\n        destroy: function() {\n          D ? (D.removeChild(B), B = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));\n        }\n      };\n    }\n  };\n}\nvar extendStatics$2 = function(o, t) {\n  return extendStatics$2 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics$2(o, t);\n};\nfunction __extends$2(o, t) {\n  extendStatics$2(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$2 = function() {\n  return __assign$2 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$2.apply(this, arguments);\n};\nfunction __rest$1(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)\n      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);\n  return e;\n}\nvar StyledElement = /* @__PURE__ */ function(o) {\n  __extends$2(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.injectResult = null, r.tag = \"div\", r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this.props, S = r.className, T = S === void 0 ? \"\" : S;\n    r.cspNonce;\n    var D = r.portalContainer, N = __rest$1(r, [\"className\", \"cspNonce\", \"portalContainer\"]), B = this.injector.className, $ = this.tag, U = {};\n    return version.indexOf(\"simple\") > -1 && D && (U = {\n      portalContainer: D\n    }), createElement($, __assign$2({\n      ref: ref(this, \"element\"),\n      \"data-styled-id\": B,\n      className: T + \" \" + B\n    }, U, N));\n  }, e.componentDidMount = function() {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  }, e.componentWillUnmount = function() {\n    this.injectResult.destroy(), this.injectResult = null;\n  }, e.getElement = function() {\n    return this.element;\n  }, t;\n}(Component);\nfunction styled(o, t) {\n  var e = styled$1(t);\n  return /* @__PURE__ */ function(r) {\n    __extends$2(S, r);\n    function S() {\n      var T = r !== null && r.apply(this, arguments) || this;\n      return T.injector = e, T.tag = o, T;\n    }\n    return S;\n  }(StyledElement);\n}\nvar extendStatics$1 = function(o, t) {\n  return extendStatics$1 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      Object.prototype.hasOwnProperty.call(r, S) && (e[S] = r[S]);\n  }, extendStatics$1(o, t);\n};\nfunction __extends$1(o, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  extendStatics$1(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$1 = function() {\n  return __assign$1 = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign$1.apply(this, arguments);\n};\nfunction __rest(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var S = 0, r = Object.getOwnPropertySymbols(o); S < r.length; S++)\n      t.indexOf(r[S]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[S]) && (e[r[S]] = o[r[S]]);\n  return e;\n}\nfunction __decorate$1(o, t, e, r) {\n  var S = arguments.length, T = S < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, D;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    T = Reflect.decorate(o, t, e, r);\n  else\n    for (var N = o.length - 1; N >= 0; N--)\n      (D = o[N]) && (T = (S < 3 ? D(T) : S > 3 ? D(t, e, T) : D(t, e)) || T);\n  return S > 3 && T && Object.defineProperty(t, e, T), T;\n}\nfunction __spreadArray(o, t, e) {\n  if (e || arguments.length === 2)\n    for (var r = 0, S = t.length, T; r < S; r++)\n      (T || !(r in t)) && (T || (T = Array.prototype.slice.call(t, 0, r)), T[r] = t[r]);\n  return o.concat(T || Array.prototype.slice.call(t));\n}\nfunction makeAble(o, t) {\n  var e;\n  return __assign$1({\n    events: {},\n    props: (e = {}, e[o] = Boolean, e),\n    name: o\n  }, t);\n}\nfunction getSVGCursor(o, t) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * o, 'px\" height=\"').concat(32 * o, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(o) {\n  var t = getSVGCursor(1, o), e = Math.round(o / 45) * 45 % 180, r = \"ns-resize\";\n  return e === 135 ? r = \"nwse-resize\" : e === 45 ? r = \"nesw-resize\" : e === 90 && (r = \"ew-resize\"), \"cursor:\".concat(r, \";cursor: url('\").concat(t, \"') 16 16, \").concat(r, \";\");\n}\nvar agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {\n  var o = typeof window > \"u\" ? {\n    userAgent: \"\"\n  } : window.navigator, t = /applewebkit\\/([^\\s]+)/g.exec(o.userAgent.toLowerCase());\n  return t ? parseFloat(t[1]) < 605 : !1;\n}(), IS_FIREFOX = agent.browser.name === \"firefox\", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = \"moveable-\", MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n    outline: 1px solid transparent;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(o) {\n  return `\n.direction[data-rotation=\"`.concat(o, '\"], :global .view-control-rotation').concat(o, ` {\n\t`).concat(getCursorCSS(o), `\n}\n`);\n}).join(`\n`), `\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n`).concat(IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\", `\n`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"], DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"], DIRECTION_REGION_TO_DIRECTION = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, DIRECTION_INDEXES = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\", \"waitToChangeTarget\", \"updateSelectors\", \"getTargets\", \"stopDrag\"];\nfunction setCustomDrag(o, t, e, r, S, T) {\n  var D, N;\n  T === void 0 && (T = \"draggable\");\n  var B = (N = (D = t.gestos[T]) === null || D === void 0 ? void 0 : D.move(e, o.inputEvent)) !== null && N !== void 0 ? N : {}, $ = B.originalDatas || B.datas, U = $[T] || ($[T] = {});\n  return __assign$1(__assign$1({}, S ? convertDragDist(t, B) : B), {\n    isPinch: !!r,\n    parentEvent: !0,\n    datas: U,\n    originalDatas: o.originalDatas\n  });\n}\nvar CustomGesto = /* @__PURE__ */ function() {\n  function o(e) {\n    var r;\n    e === void 0 && (e = \"draggable\"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {\n      draggable: {}\n    }, this.datas = (r = {}, r[e] = {}, r);\n  }\n  var t = o.prototype;\n  return t.dragStart = function(e, r) {\n    this.isDrag = !1, this.isFlag = !1;\n    var S = r.originalDatas;\n    return this.datas = S, S[this.ableName] || (S[this.ableName] = {}), __assign$1(__assign$1({}, this.move(e, r.inputEvent)), {\n      type: \"dragstart\"\n    });\n  }, t.drag = function(e, r) {\n    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);\n  }, t.move = function(e, r) {\n    var S, T, D = !1;\n    if (!this.isFlag)\n      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], S = e[0], T = e[1], this.isFlag = !0;\n    else {\n      var N = this.isDrag;\n      S = this.prevX + e[0], T = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !N && this.isDrag && (D = !0);\n    }\n    return this.prevX = S, this.prevY = T, {\n      type: \"drag\",\n      clientX: S,\n      clientY: T,\n      inputEvent: r,\n      isFirstDrag: D,\n      isDrag: this.isDrag,\n      distX: S - this.startX,\n      distY: T - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }, o;\n}();\nfunction calculatePointerDist(o, t) {\n  var e = t.clientX, r = t.clientY, S = t.datas, T = o.state, D = T.moveableClientRect, N = T.rootMatrix, B = T.is3d, $ = T.pos1, U = D.left, V = D.top, H = B ? 4 : 3, X = minus(calculateInversePosition(N, [e - U, r - V], H), $), Y = X[0], W = X[1], q = getDragDist({\n    datas: S,\n    distX: Y,\n    distY: W\n  }), K = q[0], Z = q[1];\n  return [K, Z];\n}\nfunction setDragStart(o, t) {\n  var e = t.datas, r = o.state, S = r.allMatrix, T = r.beforeMatrix, D = r.is3d, N = r.left, B = r.top, $ = r.origin, U = r.offsetMatrix, V = r.targetMatrix, H = r.transformOrigin, X = D ? 4 : 3;\n  e.is3d = D, e.matrix = S, e.targetMatrix = V, e.beforeMatrix = T, e.offsetMatrix = U, e.transformOrigin = H, e.inverseMatrix = invert(S, X), e.inverseBeforeMatrix = invert(T, X), e.absoluteOrigin = convertPositionMatrix(plus([N, B], $), X), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, X), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, X);\n}\nfunction getTransformDirection(o) {\n  return calculateMoveablePosition(o.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction resolveTransformEvent(o, t) {\n  var e = o.datas, r = o.originalDatas.beforeRenderable, S = e.transformIndex, T = r.nextTransforms, D = T.length, N = r.nextTransformAppendedIndexes, B = 0;\n  S === -1 ? (t === \"translate\" ? B = 0 : t === \"rotate\" && (B = findIndex(T, function(H) {\n    return H.match(/scale\\(/g);\n  })), B === -1 && (B = T.length), e.transformIndex = B) : find$1(N, function(H) {\n    return H.index === S && H.functionName === t;\n  }) ? B = S : B = S + N.filter(function(H) {\n    return H.index < S;\n  }).length;\n  var $ = convertTransformInfo(T, B), U = $.targetFunction, V = t === \"rotate\" ? \"rotateZ\" : t;\n  e.beforeFunctionTexts = $.beforeFunctionTexts, e.afterFunctionTexts = $.afterFunctionTexts, e.beforeTransform = $.beforeFunctionMatrix, e.beforeTransform2 = $.beforeFunctionMatrix2, e.targetTansform = $.targetFunctionMatrix, e.afterTransform = $.afterFunctionMatrix, e.afterTransform2 = $.afterFunctionMatrix2, e.targetAllTransform = $.allFunctionMatrix, U.functionName === V ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : D > B && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], N, !0), [{\n    functionName: t,\n    index: B,\n    isAppend: !0\n  }], !1));\n}\nfunction convertTransformFormat(o, t, e) {\n  return \"\".concat(o.beforeFunctionTexts.join(\" \"), \" \").concat(o.isAppendTransform ? e : t, \" \").concat(o.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(o) {\n  var t = o.datas, e = o.distX, r = o.distY, S = getBeforeDragDist({\n    datas: t,\n    distX: e,\n    distY: r\n  }), T = S[0], D = S[1], N = getTransfromMatrix(t, fromTranslation([T, D], 4));\n  return calculate(N, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nfunction getTransfromMatrix(o, t, e) {\n  var r = o.beforeTransform, S = o.afterTransform, T = o.beforeTransform2, D = o.afterTransform2, N = o.targetAllTransform, B = e ? multiply(N, t, 4) : multiply(t, N, 4), $ = multiply(invert(e ? T : r, 4), B, 4), U = multiply($, invert(e ? D : S, 4), 4);\n  return U;\n}\nfunction getBeforeDragDist(o) {\n  var t = o.datas, e = o.distX, r = o.distY, S = t.inverseBeforeMatrix, T = t.is3d, D = t.startDragBeforeDist, N = t.absoluteOrigin, B = T ? 4 : 3;\n  return minus(calculate(S, plus(N, [e, r]), B), D);\n}\nfunction getDragDist(o, t) {\n  var e = o.datas, r = o.distX, S = o.distY, T = e.inverseBeforeMatrix, D = e.inverseMatrix, N = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, V = N ? 4 : 3;\n  return minus(calculate(t ? T : D, plus(U, [r, S]), V), t ? B : $);\n}\nfunction getInverseDragDist(o, t) {\n  var e = o.datas, r = o.distX, S = o.distY, T = e.beforeMatrix, D = e.matrix, N = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, V = N ? 4 : 3;\n  return minus(calculate(t ? T : D, plus(t ? B : $, [r, S]), V), U);\n}\nfunction calculateTransformOrigin(o, t, e, r, S, T) {\n  return r === void 0 && (r = t), S === void 0 && (S = e), T === void 0 && (T = [0, 0]), o ? o.map(function(D, N) {\n    var B = splitUnit(D), $ = B.value, U = B.unit, V = N ? S : r, H = N ? e : t;\n    if (D === \"%\" || isNaN($)) {\n      var X = V ? T[N] / V : 0;\n      return H * X;\n    } else if (U !== \"%\")\n      return $;\n    return H * $ / 100;\n  }) : T;\n}\nfunction getPosIndexesByDirection(o) {\n  var t = [];\n  return o[1] >= 0 && (o[0] >= 0 && t.push(3), o[0] <= 0 && t.push(2)), o[1] <= 0 && (o[0] >= 0 && t.push(1), o[0] <= 0 && t.push(0)), t;\n}\nfunction getPosesByDirection(o, t) {\n  return getPosIndexesByDirection(t).map(function(e) {\n    return o[e];\n  });\n}\nfunction getPosByDirection(o, t) {\n  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, S = [dot(o[0][0], o[1][0], e, 1 - e), dot(o[0][1], o[1][1], e, 1 - e)], T = [dot(o[2][0], o[3][0], e, 1 - e), dot(o[2][1], o[3][1], e, 1 - e)];\n  return [dot(S[0], T[0], r, 1 - r), dot(S[1], T[1], r, 1 - r)];\n}\nfunction getDist(o, t, e, r, S, T) {\n  var D = calculatePoses(t, e, r, S), N = getPosByDirection(D, T), B = o[0] - N[0], $ = o[1] - N[1];\n  return [B, $];\n}\nfunction getNextMatrix(o, t, e, r) {\n  return multiply(o, getAbsoluteMatrix(t, r, e), r);\n}\nfunction getNextTransformMatrix(o, t, e) {\n  var r = o.transformOrigin, S = o.offsetMatrix, T = o.is3d, D = t.beforeTransform, N = t.afterTransform, B = T ? 4 : 3, $ = parseMat([e]);\n  return getNextMatrix(S, convertDimension(multiply(multiply(D, $, 4), N, 4), 4, B), r, B);\n}\nfunction scaleMatrix(o, t) {\n  var e = o.transformOrigin, r = o.offsetMatrix, S = o.is3d, T = o.targetMatrix, D = S ? 4 : 3;\n  return getNextMatrix(r, multiply(T, createScaleMatrix(t, D), D), e, D);\n}\nfunction fillTransformStartEvent(o) {\n  var t = getBeforeRenderableDatas(o);\n  return {\n    setTransform: function(e, r) {\n      r === void 0 && (r = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(o, r);\n    },\n    setTransformIndex: function(e) {\n      setTransformIndex(o, e);\n    }\n  };\n}\nfunction setDefaultTransformIndex(o, t) {\n  var e = getBeforeRenderableDatas(o), r = e.startTransforms;\n  setTransformIndex(o, findIndex(r, function(S) {\n    return S.indexOf(\"\".concat(t, \"(\")) === 0;\n  }));\n}\nfunction setTransformIndex(o, t) {\n  var e = getBeforeRenderableDatas(o), r = o.datas;\n  if (r.transformIndex = t, t !== -1) {\n    var S = e.startTransforms[t];\n    if (!!S) {\n      var T = parse$1([S]);\n      r.startValue = T[0].functionValue;\n    }\n  }\n}\nfunction fillOriginalTransform(o, t) {\n  var e = getBeforeRenderableDatas(o);\n  e.nextTransforms = splitSpace(t);\n}\nfunction getBeforeRenderableDatas(o) {\n  return o.originalDatas.beforeRenderable;\n}\nfunction getNextTransforms(o) {\n  var t = o.originalDatas.beforeRenderable;\n  return t.nextTransforms;\n}\nfunction getNextTransformText(o) {\n  return getNextTransforms(o).join(\" \");\n}\nfunction getNextStyle(o) {\n  return getBeforeRenderableDatas(o).nextStyle;\n}\nfunction fillTransformEvent(o, t, e, r, S) {\n  fillOriginalTransform(S, t);\n  var T = Draggable.drag(o, setCustomDrag(S, o.state, e, r, !1)), D = T ? T.transform : t;\n  return __assign$1(__assign$1({\n    transform: t,\n    drag: T\n  }, fillCSSObject({\n    transform: D\n  }, S)), {\n    afterTransform: D\n  });\n}\nfunction getTranslateDist(o, t, e, r, S) {\n  var T = o.state, D = T.left, N = T.top, B = o.props.groupable, $ = getNextTransformMatrix(o.state, S, t), U = B ? D : 0, V = B ? N : 0, H = getDirectionOffset(o, e, $), X = minus(r, H);\n  return minus(X, [U, V]);\n}\nfunction getScaleDist(o, t, e, r, S) {\n  var T = getTranslateDist(o, \"scale(\".concat(t.join(\", \"), \")\"), e, r, S);\n  return T;\n}\nfunction getDirectionByPos(o, t, e) {\n  return [-1 + o[0] / (t / 2), -1 + o[1] / (e / 2)];\n}\nfunction getDirectionOffset(o, t, e) {\n  e === void 0 && (e = o.state.allMatrix);\n  var r = o.state, S = r.width, T = r.height, D = r.is3d, N = D ? 4 : 3, B = [S / 2 * (1 + t[0]), T / 2 * (1 + t[1])];\n  return calculatePosition(e, B, N);\n}\nfunction getRotateDist(o, t, e) {\n  var r = e.fixedDirection, S = e.fixedPosition;\n  return getTranslateDist(o, \"rotate(\".concat(t, \"deg)\"), r, S, e);\n}\nfunction getResizeDist(o, t, e, r, S, T) {\n  var D = o.props.groupable, N = o.state, B = N.transformOrigin, $ = N.offsetMatrix, U = N.is3d, V = N.width, H = N.height, X = N.left, Y = N.top, W = T.fixedDirection, q = T.nextTargetMatrix || N.targetMatrix, K = U ? 4 : 3, Z = calculateTransformOrigin(S, t, e, V, H, B), J = D ? X : 0, Q = D ? Y : 0, rt = getNextMatrix($, q, Z, K), et = getDist(r, rt, t, e, K, W);\n  return minus(et, [J, Q]);\n}\nfunction getAbsolutePosition(o, t) {\n  return getPosByDirection(getAbsolutePosesByState(o.state), t);\n}\nfunction getGestoData(o, t) {\n  var e = o.targetGesto, r = o.controlGesto, S;\n  return e != null && e.isFlag() && (S = e.getEventData()[t]), !S && (r == null ? void 0 : r.isFlag()) && (S = r.getEventData()[t]), S || {};\n}\nfunction multiply2(o, t) {\n  return [o[0] * t[0], o[1] * t[1]];\n}\nfunction prefix() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  return prefixNames.apply(void 0, __spreadArray([PREFIX], o, !1));\n}\nfunction defaultSync(o) {\n  o();\n}\nfunction getTransformMatrix(o) {\n  return !o || o === \"none\" ? [1, 0, 0, 1, 0, 0] : isObject$2(o) ? o : parseMat(o);\n}\nfunction getAbsoluteMatrix(o, t, e) {\n  return multiplies(t, createOriginMatrix(e, t), o, createOriginMatrix(e.map(function(r) {\n    return -r;\n  }), t));\n}\nfunction measureSVGSize(o, t, e) {\n  if (t === \"%\") {\n    var r = getSVGViewBox(o.ownerSVGElement);\n    return r[e ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction getBeforeTransformOrigin(o) {\n  var t = getTransformOrigin(getComputedStyle$1$1(o, \":before\"));\n  return t.map(function(e, r) {\n    var S = splitUnit(e), T = S.value, D = S.unit;\n    return T * measureSVGSize(o, D, r === 0);\n  });\n}\nfunction getTransformOrigin(o) {\n  var t = o.transformOrigin;\n  return t ? t.split(\" \") : [\"0\", \"0\"];\n}\nfunction getElementTransform(o, t) {\n  t === void 0 && (t = getComputedStyle$1$1(o));\n  var e = t.transform;\n  if (e && e !== \"none\")\n    return t.transform;\n  if (\"transform\" in o) {\n    var r = o.transform, S = r.baseVal;\n    if (!S)\n      return \"\";\n    var T = S.length;\n    if (!T)\n      return \"\";\n    for (var D = [], N = function($) {\n      var U = S[$].matrix;\n      D.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(V) {\n        return U[V];\n      }).join(\", \"), \")\"));\n    }, B = 0; B < T; ++B)\n      N(B);\n    return D.join(\" \");\n  }\n  return \"\";\n}\nfunction getOffsetInfo(o, t, e, r, S) {\n  var T, D, N, B = document.documentElement || document.body, $ = !1, U, V;\n  if (!o || e)\n    U = o;\n  else {\n    var H = (T = o == null ? void 0 : o.assignedSlot) === null || T === void 0 ? void 0 : T.parentElement, X = o.parentElement;\n    H ? ($ = !0, V = X, U = H) : U = X;\n  }\n  for (var Y = !1, W = o === t || U === t, q = \"relative\", K = 1, Z = parseFloat((D = S) === null || D === void 0 ? void 0 : D.zoom) || 1, J = S == null ? void 0 : S.position; U && U !== B; ) {\n    t === U && (W = !0);\n    var Q = getComputedStyle$1$1(U), rt = U.tagName.toLowerCase(), et = getElementTransform(U, Q), nt = Q.willChange, st = parseFloat(Q.zoom) || 1;\n    if (q = Q.position, r && st !== 1) {\n      K = st;\n      break;\n    }\n    if (!e && r && Z !== 1 && J && J !== \"absolute\" || rt === \"svg\" || q !== \"static\" || et && et !== \"none\" || nt === \"transform\")\n      break;\n    var it = (N = o == null ? void 0 : o.assignedSlot) === null || N === void 0 ? void 0 : N.parentNode, at = U.parentNode;\n    it && ($ = !0, V = at);\n    var ut = it || at;\n    if (ut && ut.nodeType === 11) {\n      U = ut.host, Y = !0;\n      break;\n    }\n    U = ut, q = \"relative\";\n  }\n  return {\n    offsetZoom: K,\n    hasSlot: $,\n    parentSlotElement: V,\n    isCustomElement: Y,\n    isStatic: q === \"static\",\n    isEnd: W || !U || U === B,\n    offsetParent: U || B\n  };\n}\nfunction getOffsetPosInfo(o, t, e) {\n  var r, S = o.tagName.toLowerCase(), T = o.offsetLeft, D = o.offsetTop, N = isUndefined(T), B = !N, $, U;\n  return !B && S !== \"svg\" ? ($ = IS_WEBKIT605 ? getBeforeTransformOrigin(o) : getTransformOrigin(e).map(function(V) {\n    return parseFloat(V);\n  }), U = $.slice(), B = !0, r = getSVGGraphicsOffset(o, $, o === t && t.tagName.toLowerCase() === \"g\"), T = r[0], D = r[1], $[0] = r[2], $[1] = r[3]) : ($ = getTransformOrigin(e).map(function(V) {\n    return parseFloat(V);\n  }), U = $.slice()), {\n    tagName: S,\n    isSVG: N,\n    hasOffset: B,\n    offset: [T || 0, D || 0],\n    origin: $,\n    targetOrigin: U\n  };\n}\nfunction getBodyOffset(o, t, e) {\n  e === void 0 && (e = getComputedStyle$1$1(o));\n  var r = getComputedStyle$1$1(document.body), S = r.position;\n  if (!t && (!S || S === \"static\"))\n    return [0, 0];\n  var T = parseInt(r.marginLeft, 10), D = parseInt(r.marginTop, 10);\n  return e.position === \"absolute\" && ((e.top !== \"auto\" || e.bottom !== \"auto\") && (D = 0), (e.left !== \"auto\" || e.right !== \"auto\") && (T = 0)), [T, D];\n}\nfunction convert3DMatrixes(o) {\n  o.forEach(function(t) {\n    var e = t.matrix;\n    e && (t.matrix = convertDimension(e, 3, 4));\n  });\n}\nfunction getPositionFixedInfo(o) {\n  for (var t = o.parentElement, e = !1; t; ) {\n    var r = getComputedStyle$1$1(t).transform;\n    if (r && r !== \"none\") {\n      e = !0;\n      break;\n    }\n    if (t === document.body)\n      break;\n    t = t.parentElement;\n  }\n  return {\n    fixedContainer: t || document.body,\n    hasTransform: e\n  };\n}\nfunction makeMatrixCSS(o, t) {\n  return t === void 0 && (t = o.length > 9), \"\".concat(t ? \"matrix3d\" : \"matrix\", \"(\").concat(convertMatrixtoCSS(o, !t).join(\",\"), \")\");\n}\nfunction getSVGViewBox(o) {\n  var t = o.clientWidth, e = o.clientHeight;\n  if (!o)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: t,\n      clientHeight: e\n    };\n  var r = o.viewBox, S = r && r.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: S.x,\n    y: S.y,\n    width: S.width || t,\n    height: S.height || e,\n    clientWidth: t,\n    clientHeight: e\n  };\n}\nfunction getSVGMatrix(o, t) {\n  var e = getSVGViewBox(o), r = e.width, S = e.height, T = e.clientWidth, D = e.clientHeight, N = T / r, B = D / S, $ = o.preserveAspectRatio.baseVal, U = $.align, V = $.meetOrSlice, H = [0, 0], X = [N, B], Y = [0, 0];\n  if (U !== 1) {\n    var W = (U - 2) % 3, q = Math.floor((U - 2) / 3);\n    H[0] = r * W / 2, H[1] = S * q / 2;\n    var K = V === 2 ? Math.max(B, N) : Math.min(N, B);\n    X[0] = K, X[1] = K, Y[0] = (T - r) / 2 * W, Y[1] = (D - S) / 2 * q;\n  }\n  var Z = createScaleMatrix(X, t);\n  return Z[t * (t - 1)] = Y[0], Z[t * (t - 1) + 1] = Y[1], getAbsoluteMatrix(Z, t, H);\n}\nfunction getSVGGraphicsOffset(o, t, e) {\n  if (!o.getBBox || !e && o.tagName.toLowerCase() === \"g\")\n    return [0, 0, 0, 0];\n  var r = o.getBBox(), S = getSVGViewBox(o.ownerSVGElement), T = r.x - S.x, D = r.y - S.y;\n  return [T, D, t[0] - T, t[1] - D];\n}\nfunction calculatePosition(o, t, e) {\n  return calculate(o, convertPositionMatrix(t, e), e);\n}\nfunction calculatePoses(o, t, e, r) {\n  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(S) {\n    return calculatePosition(o, S, r);\n  });\n}\nfunction getRect(o) {\n  var t = o.map(function($) {\n    return $[0];\n  }), e = o.map(function($) {\n    return $[1];\n  }), r = Math.min.apply(Math, t), S = Math.min.apply(Math, e), T = Math.max.apply(Math, t), D = Math.max.apply(Math, e), N = T - r, B = D - S;\n  return {\n    left: r,\n    top: S,\n    right: T,\n    bottom: D,\n    width: N,\n    height: B\n  };\n}\nfunction calculateRect(o, t, e, r) {\n  var S = calculatePoses(o, t, e, r);\n  return getRect(S);\n}\nfunction getSVGOffset(o, t, e, r, S) {\n  var T, D = o.target, N = o.origin, B = t.matrix, $ = getSize(D), U = $.offsetWidth, V = $.offsetHeight, H = e.getBoundingClientRect(), X = [0, 0];\n  e === document.body && (X = getBodyOffset(D, !0));\n  for (var Y = D.getBoundingClientRect(), W = Y.left - H.left + e.scrollLeft - (e.clientLeft || 0) + X[0], q = Y.top - H.top + e.scrollTop - (e.clientTop || 0) + X[1], K = Y.width, Z = Y.height, J = multiplies(r, S, B), Q = calculateRect(J, U, V, r), rt = Q.left, et = Q.top, nt = Q.width, st = Q.height, it = calculatePosition(J, N, r), at = minus(it, [rt, et]), ut = [W + at[0] * K / nt, q + at[1] * Z / st], ct = [0, 0], gt = 0; ++gt < 10; ) {\n    var _t = invert(S, r);\n    T = minus(calculatePosition(_t, ut, r), calculatePosition(_t, it, r)), ct[0] = T[0], ct[1] = T[1];\n    var vt = multiplies(r, S, createOriginMatrix(ct, r), B), mt = calculateRect(vt, U, V, r), bt = mt.left, Ct = mt.top, St = bt - W, pt = Ct - q;\n    if (Math.abs(St) < 2 && Math.abs(pt) < 2)\n      break;\n    ut[0] -= St, ut[1] -= pt;\n  }\n  return ct.map(function(yt) {\n    return Math.round(yt);\n  });\n}\nfunction calculateMoveableClientPositions(o, t, e) {\n  var r = o.length === 16, S = r ? 4 : 3, T = t.map(function(B) {\n    return calculatePosition(o, B, S);\n  }), D = e.left, N = e.top;\n  return T.map(function(B) {\n    return [B[0] + D, B[1] + N];\n  });\n}\nfunction calculateMoveablePosition(o, t, e, r) {\n  var S = o.length === 16, T = S ? 4 : 3, D = calculatePoses(o, e, r, T), N = D[0], B = N[0], $ = N[1], U = D[1], V = U[0], H = U[1], X = D[2], Y = X[0], W = X[1], q = D[3], K = q[0], Z = q[1], J = calculatePosition(o, t, T), Q = J[0], rt = J[1], et = Math.min(B, V, Y, K), nt = Math.min($, H, W, Z), st = Math.max(B, V, Y, K), it = Math.max($, H, W, Z);\n  B = B - et || 0, V = V - et || 0, Y = Y - et || 0, K = K - et || 0, $ = $ - nt || 0, H = H - nt || 0, W = W - nt || 0, Z = Z - nt || 0, Q = Q - et || 0, rt = rt - nt || 0;\n  var at = getShapeDirection(calculatePoses(o, 100, 100, T));\n  return {\n    left: et,\n    top: nt,\n    right: st,\n    bottom: it,\n    origin: [Q, rt],\n    pos1: [B, $],\n    pos2: [V, H],\n    pos3: [Y, W],\n    pos4: [K, Z],\n    direction: at\n  };\n}\nfunction getDistSize(o) {\n  return Math.sqrt(o[0] * o[0] + o[1] * o[1]);\n}\nfunction getDiagonalSize(o, t) {\n  return getDistSize([t[0] - o[0], t[1] - o[1]]);\n}\nfunction getLineStyle(o, t, e, r) {\n  e === void 0 && (e = 1), r === void 0 && (r = getRad$1(o, t));\n  var S = getDiagonalSize(o, t);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(o[0], \"px, \").concat(o[1], \"px) rotate(\").concat(r, \"rad) scaleY(\").concat(e, \")\"),\n    width: \"\".concat(S, \"px\")\n  };\n}\nfunction getControlTransform(o, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var S = e.length, T = e.reduce(function(N, B) {\n    return N + B[0];\n  }, 0) / S, D = e.reduce(function(N, B) {\n    return N + B[1];\n  }, 0) / S;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(T, \"px, \").concat(D, \"px) rotate(\").concat(o, \"rad) scale(\").concat(t, \")\")\n  };\n}\nfunction getProps(o, t) {\n  var e = o[t];\n  return isObject$2(e) ? __assign$1(__assign$1({}, o), e) : o;\n}\nfunction getSize(o, t) {\n  t === void 0 && (t = o ? getComputedStyle$1$1(o) : null);\n  var e = o && !isUndefined(o.offsetWidth), r = 0, S = 0, T = 0, D = 0, N = 0, B = 0, $ = 0, U = 0, V = 0, H = 0, X = 0, Y = 0, W = 1 / 0, q = 1 / 0, K = 1 / 0, Z = 1 / 0, J = 0, Q = 0, rt = !1;\n  if (o)\n    if (!e && o.tagName.toLowerCase() !== \"svg\") {\n      var et = o.getBBox();\n      rt = !0, r = et.width, S = et.height, N = r, B = S, $ = r, U = S, T = r, D = S;\n    } else {\n      var nt = o.style, st = t.boxSizing === \"border-box\", it = parseFloat(t.borderLeftWidth) || 0, at = parseFloat(t.borderRightWidth) || 0, ut = parseFloat(t.borderTopWidth) || 0, ct = parseFloat(t.borderBottomWidth) || 0, gt = parseFloat(t.paddingLeft) || 0, _t = parseFloat(t.paddingRight) || 0, vt = parseFloat(t.paddingTop) || 0, mt = parseFloat(t.paddingBottom) || 0, bt = gt + _t, Ct = vt + mt, St = it + at, pt = ut + ct, yt = bt + St, At = Ct + pt, Dt = t.position, Ot = 0, Pt = 0;\n      if (\"clientLeft\" in o) {\n        var ft = null;\n        if (Dt === \"absolute\") {\n          var Ft = getOffsetInfo(o, document.body);\n          ft = Ft.offsetParent;\n        } else\n          ft = o.parentElement;\n        if (ft) {\n          var It = getComputedStyle$1$1(ft);\n          Ot = parseFloat(It.width), Pt = parseFloat(It.height);\n        }\n      }\n      V = Math.max(bt, convertUnitSize(t.minWidth, Ot) || 0), H = Math.max(Ct, convertUnitSize(t.minHeight, Pt) || 0), W = convertUnitSize(t.maxWidth, Ot), q = convertUnitSize(t.maxHeight, Pt), isNaN(W) && (W = 1 / 0), isNaN(q) && (q = 1 / 0), J = convertUnitSize(nt.width, 0) || 0, Q = convertUnitSize(nt.height, 0) || 0, N = parseFloat(t.width) || 0, B = parseFloat(t.height) || 0, $ = Math.abs(N - J) < 1 ? between(V, J || N, W) : N, U = Math.abs(B - Q) < 1 ? between(H, Q || B, q) : B, r = $, S = U, T = $, D = U, st ? (K = W, Z = q, X = V, Y = H, $ = r - yt, U = S - At) : (K = W + yt, Z = q + At, X = V + yt, Y = H + At, r = $ + yt, S = U + At), T = $ + bt, D = U + Ct;\n    }\n  return {\n    svg: rt,\n    offsetWidth: r,\n    offsetHeight: S,\n    clientWidth: T,\n    clientHeight: D,\n    contentWidth: $,\n    contentHeight: U,\n    inlineCSSWidth: J,\n    inlineCSSHeight: Q,\n    cssWidth: N,\n    cssHeight: B,\n    minWidth: V,\n    minHeight: H,\n    maxWidth: W,\n    maxHeight: q,\n    minOffsetWidth: X,\n    minOffsetHeight: Y,\n    maxOffsetWidth: K,\n    maxOffsetHeight: Z\n  };\n}\nfunction getRotationRad(o, t) {\n  return getRad$1(t > 0 ? o[0] : o[1], t > 0 ? o[1] : o[0]);\n}\nfunction resetClientRect() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction getExtendsRect(o, t) {\n  var e = o === document.body || o === document.documentElement, r = {\n    clientLeft: o.clientLeft,\n    clientTop: o.clientTop,\n    clientWidth: o.clientWidth,\n    clientHeight: o.clientHeight,\n    scrollWidth: o.scrollWidth,\n    scrollHeight: o.scrollHeight,\n    overflow: !1\n  };\n  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = getComputedStyle$1$1(o).overflow !== \"visible\", __assign$1(__assign$1({}, t), r);\n}\nfunction getClientRectByPosition(o, t, e, r) {\n  var S = o.left, T = o.right, D = o.top, N = o.bottom, B = t.top, $ = t.left, U = {\n    left: $ + S,\n    top: B + D,\n    right: $ + T,\n    bottom: B + N,\n    width: T - S,\n    height: N - D\n  };\n  return e && r ? getExtendsRect(e, U) : U;\n}\nfunction getClientRect(o, t) {\n  var e = 0, r = 0, S = 0, T = 0;\n  if (o) {\n    var D = o.getBoundingClientRect();\n    e = D.left, r = D.top, S = D.width, T = D.height;\n  }\n  var N = {\n    left: e,\n    top: r,\n    width: S,\n    height: T,\n    right: e + S,\n    bottom: r + T\n  };\n  return o && t ? getExtendsRect(o, N) : N;\n}\nfunction getTotalDirection(o, t, e, r) {\n  var S;\n  if (o)\n    S = o;\n  else if (t)\n    S = [0, 0];\n  else {\n    var T = e.target;\n    S = getDirection(T, r);\n  }\n  return S;\n}\nfunction getDirection(o, t) {\n  if (!!o) {\n    var e = o.getAttribute(\"data-rotation\") || \"\", r = o.getAttribute(\"data-direction\");\n    if (t.deg = e, !!r) {\n      var S = [0, 0];\n      return r.indexOf(\"w\") > -1 && (S[0] = -1), r.indexOf(\"e\") > -1 && (S[0] = 1), r.indexOf(\"n\") > -1 && (S[1] = -1), r.indexOf(\"s\") > -1 && (S[1] = 1), S;\n    }\n  }\n}\nfunction getAbsolutePoses(o, t) {\n  return [plus(t, o[0]), plus(t, o[1]), plus(t, o[2]), plus(t, o[3])];\n}\nfunction getAbsolutePosesByState(o) {\n  var t = o.left, e = o.top, r = o.pos1, S = o.pos2, T = o.pos3, D = o.pos4;\n  return getAbsolutePoses([r, S, T, D], [t, e]);\n}\nfunction roundSign(o) {\n  return Math.round(o % 1 === -0.5 ? o - 1 : o);\n}\nfunction unset(o, t) {\n  var e;\n  (e = o[t]) === null || e === void 0 || e.unset(), o[t] = null;\n}\nfunction fillCSSObject(o, t) {\n  if (t) {\n    var e = getBeforeRenderableDatas(t);\n    e.nextStyle = __assign$1(__assign$1({}, e.nextStyle), o);\n  }\n  return {\n    style: o,\n    cssText: getKeys(o).map(function(r) {\n      return \"\".concat(decamelize(r, \"-\"), \": \").concat(o[r], \";\");\n    }).join(\"\")\n  };\n}\nfunction fillAfterTransform(o, t, e) {\n  var r = t.afterTransform || t.transform;\n  return __assign$1(__assign$1({}, fillCSSObject(__assign$1(__assign$1(__assign$1({}, o.style), t.style), {\n    transform: r\n  }), e)), {\n    afterTransform: r,\n    transform: o.transform\n  });\n}\nfunction fillParams(o, t, e, r) {\n  var S = t.datas;\n  S.datas || (S.datas = {});\n  var T = __assign$1(__assign$1({}, e), {\n    target: o.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: o,\n    moveable: o,\n    datas: S.datas,\n    isFirstDrag: !!t.isFirstDrag,\n    stopAble: function() {\n      S.isEventStart = !1;\n    },\n    stopDrag: function() {\n      var D;\n      (D = t.stop) === null || D === void 0 || D.call(t);\n    }\n  });\n  return S.isStartEvent ? r || (S.lastEvent = T) : S.isStartEvent = !0, T;\n}\nfunction fillEndParams(o, t, e) {\n  var r = t.datas, S = \"isDrag\" in e ? e.isDrag : t.isDrag;\n  return r.datas || (r.datas = {}), __assign$1(__assign$1({\n    isDrag: S\n  }, e), {\n    moveable: o,\n    target: o.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: o,\n    lastEvent: r.lastEvent,\n    isDouble: t.isDouble,\n    datas: r.datas,\n    isFirstDrag: !!t.isFirstDrag\n  });\n}\nfunction catchEvent(o, t, e) {\n  o._emitter.on(t, e);\n}\nfunction triggerEvent(o, t, e, r) {\n  return o.triggerEvent(t, e, r);\n}\nfunction getComputedStyle$1$1(o, t) {\n  return window.getComputedStyle(o, t);\n}\nfunction filterAbles(o, t, e) {\n  var r = {}, S = {};\n  return o.filter(function(T) {\n    var D = T.name;\n    if (r[D] || !t.some(function(N) {\n      return T[N];\n    }))\n      return !1;\n    if (!e && T.ableGroup) {\n      if (S[T.ableGroup])\n        return !1;\n      S[T.ableGroup] = !0;\n    }\n    return r[D] = !0, !0;\n  });\n}\nfunction equals(o, t) {\n  return o === t || o == null && t == null;\n}\nfunction selectValue() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  for (var e = o.length - 1, r = 0; r < e; ++r) {\n    var S = o[r];\n    if (!isUndefined(S))\n      return S;\n  }\n  return o[e];\n}\nfunction groupBy(o, t) {\n  var e = [], r = [];\n  return o.forEach(function(S, T) {\n    var D = t(S, T, o), N = r.indexOf(D), B = e[N] || [];\n    N === -1 && (r.push(D), e.push(B)), B.push(S);\n  }), e;\n}\nfunction groupByMap(o, t) {\n  var e = [], r = {};\n  return o.forEach(function(S, T) {\n    var D = t(S, T, o), N = r[D];\n    N || (N = [], r[D] = N, e.push(N)), N.push(S);\n  }), e;\n}\nfunction flat(o) {\n  return o.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction maxOffset() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  return o.sort(function(e, r) {\n    return Math.abs(r) - Math.abs(e);\n  }), o[0];\n}\nfunction calculateInversePosition(o, t, e) {\n  return calculate(invert(o, e), convertPositionMatrix(t, e), e);\n}\nfunction convertDragDist(o, t) {\n  var e, r = o.is3d, S = o.rootMatrix, T = r ? 4 : 3;\n  return e = calculateInversePosition(S, [t.distX, t.distY], T), t.distX = e[0], t.distY = e[1], t;\n}\nfunction calculatePadding(o, t, e, r, S) {\n  return minus(calculatePosition(o, plus(e, t), S), r);\n}\nfunction convertCSSSize(o, t, e) {\n  return e ? \"\".concat(o / t * 100, \"%\") : \"\".concat(o, \"px\");\n}\nfunction getTinyDist(o) {\n  return Math.abs(o) <= TINY_NUM ? 0 : o;\n}\nfunction getDirectionViewClassName(o) {\n  return function(t) {\n    if (!t.isDragging(o))\n      return \"\";\n    var e = getGestoData(t, o), r = e.deg;\n    return r ? prefix(\"view-control-rotation\".concat(r)) : \"\";\n  };\n}\nfunction getDirectionCondition(o, t) {\n  return t === void 0 && (t = [o]), function(e, r) {\n    if (r.isRequest)\n      return t.some(function(T) {\n        return r.requestAble === T;\n      }) ? r.parentDirection : !1;\n    var S = r.inputEvent.target;\n    return hasClass(S, prefix(\"direction\")) && (!o || hasClass(S, prefix(o)));\n  };\n}\nfunction invertObject(o) {\n  var t = {};\n  for (var e in o)\n    t[o[e]] = e;\n  return t;\n}\nfunction convertTransformInfo(o, t) {\n  var e = o.slice(0, t < 0 ? void 0 : t), r = o.slice(0, t < 0 ? void 0 : t + 1), S = o[t] || \"\", T = t < 0 ? [] : o.slice(t), D = t < 0 ? [] : o.slice(t + 1), N = parse$1(e), B = parse$1(r), $ = parse$1([S]), U = parse$1(T), V = parse$1(D), H = toMat(N), X = toMat(B), Y = toMat(U), W = toMat(V), q = multiply(H, Y, 4);\n  return {\n    transforms: o,\n    beforeFunctionMatrix: H,\n    beforeFunctionMatrix2: X,\n    targetFunctionMatrix: toMat($),\n    afterFunctionMatrix: Y,\n    afterFunctionMatrix2: W,\n    allFunctionMatrix: q,\n    beforeFunctions: N,\n    beforeFunctions2: B,\n    targetFunction: $[0],\n    afterFunctions: U,\n    afterFunctions2: V,\n    beforeFunctionTexts: e,\n    beforeFunctionTexts2: r,\n    targetFunctionText: S,\n    afterFunctionTexts: T,\n    afterFunctionTexts2: D\n  };\n}\nfunction isArrayFormat(o) {\n  return !o || !isObject$2(o) || o instanceof Element ? !1 : isArray(o) || \"length\" in o;\n}\nfunction getRefTarget(o, t) {\n  return o ? o instanceof Element ? o : isString$1(o) ? t ? document.querySelector(o) : o : isFunction$3(o) ? o() : \"current\" in o ? o.current : o : null;\n}\nfunction getRefTargets(o, t) {\n  if (!o)\n    return [];\n  var e = isArrayFormat(o) ? [].slice.call(o) : [o];\n  return e.reduce(function(r, S) {\n    return isString$1(S) && t ? __spreadArray(__spreadArray([], r, !0), [].slice.call(document.querySelectorAll(S)), !0) : (isArray(S) ? r.push(getRefTargets(S, t)) : r.push(getRefTarget(S, t)), r);\n  }, []);\n}\nfunction getAbsoluteRotation(o, t, e) {\n  var r = getRad$1(o, t) / Math.PI * 180;\n  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;\n}\nfunction getDragDistByState(o, t) {\n  var e = o.rootMatrix, r = o.is3d, S = r ? 4 : 3, T = invert(e, S);\n  return r || (T = convertDimension(T, 3, 4)), T[12] = 0, T[13] = 0, T[14] = 0, calculateMatrixDist(T, t);\n}\nfunction getSizeDistByDist(o, t, e, r, S) {\n  var T = o[0], D = o[1], N = 0, B = 0;\n  if (S && T && D) {\n    var $ = getRad$1([0, 0], t), U = getRad$1([0, 0], r), V = getDistSize(t), H = Math.cos($ - U) * V;\n    if (!r[0])\n      B = H, N = B * e;\n    else if (!r[1])\n      N = H, B = N / e;\n    else {\n      var X = r[0] * 2 * T, Y = r[1] * 2 * D, W = getDistSize([X + t[0], Y + t[1]]) - getDistSize([X, Y]), q = getRad$1([0, 0], [e, 1]);\n      N = Math.cos(q) * W, B = Math.sin(q) * W;\n    }\n  } else\n    N = r[0] * t[0], B = r[1] * t[1];\n  return [N, B];\n}\nfunction getOffsetSizeDist(o, t, e, r) {\n  var S, T = e.ratio, D = e.startOffsetWidth, N = e.startOffsetHeight, B = 0, $ = 0, U = r.distX, V = r.distY, H = r.parentDistance, X = r.parentDist, Y = r.parentScale, W = e.fixedDirection, q = [0, 1].map(function(et) {\n    return Math.abs(o[et] - W[et]);\n  }), K = [0, 1].map(function(et) {\n    var nt = q[et];\n    return nt !== 0 && (nt = 2 / nt), nt;\n  });\n  if (X)\n    B = X[0], $ = X[1], t && (B ? $ || ($ = B / T) : B = $ * T);\n  else if (Y)\n    B = (Y[0] - 1) * D, $ = (Y[1] - 1) * N;\n  else if (H) {\n    var Z = D * q[0], J = N * q[1], Q = getDistSize([Z, J]);\n    B = H / Q * Z * K[0], $ = H / Q * J * K[1];\n  } else {\n    var rt = getDragDist({\n      datas: e,\n      distX: U,\n      distY: V\n    });\n    rt = K.map(function(et, nt) {\n      return rt[nt] * et;\n    }), S = getSizeDistByDist([D, N], rt, T, o, t), B = S[0], $ = S[1];\n  }\n  return {\n    distWidth: B,\n    distHeight: $\n  };\n}\nfunction convertTransformUnit(o, t) {\n  if (t) {\n    if (o === \"left\")\n      return {\n        x: \"0%\",\n        y: \"50%\"\n      };\n    if (o === \"top\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (o === \"center\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (o === \"right\")\n      return {\n        x: \"100%\",\n        y: \"50%\"\n      };\n    if (o === \"bottom\")\n      return {\n        x: \"50%\",\n        y: \"100%\"\n      };\n    var e = o.split(\" \"), r = e[0], S = e[1], T = convertTransformUnit(r || \"\"), D = convertTransformUnit(S || \"\"), N = __assign$1(__assign$1({}, T), D), B = {\n      x: \"50%\",\n      y: \"50%\"\n    };\n    return N.x && (B.x = N.x), N.y && (B.y = N.y), N.value && (N.x && !N.y && (B.y = N.value), !N.x && N.y && (B.x = N.value)), B;\n  }\n  return o === \"left\" ? {\n    x: \"0%\"\n  } : o === \"right\" ? {\n    x: \"100%\"\n  } : o === \"top\" ? {\n    y: \"0%\"\n  } : o === \"bottom\" ? {\n    y: \"100%\"\n  } : o ? o === \"center\" ? {\n    value: \"50%\"\n  } : {\n    value: o\n  } : {};\n}\nfunction convertTransformOriginArray(o, t, e) {\n  var r = convertTransformUnit(o, !0), S = r.x, T = r.y;\n  return [convertUnitSize(S, t) || 0, convertUnitSize(T, e) || 0];\n}\nfunction rotatePosesInfo(o, t, e) {\n  var r = o.map(function(T) {\n    return minus(T, t);\n  }), S = r.map(function(T) {\n    return rotate(T, e);\n  });\n  return {\n    prev: r,\n    next: S,\n    result: S.map(function(T) {\n      return plus(T, t);\n    })\n  };\n}\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function() {\n    return !0;\n  },\n  pinchStart: function(o, t) {\n    var e = t.datas, r = t.targets, S = t.angle, T = t.originalDatas, D = o.props, N = D.pinchable, B = D.ables;\n    if (!N)\n      return !1;\n    var $ = \"onPinch\".concat(r ? \"Group\" : \"\", \"Start\"), U = \"drag\".concat(r ? \"Group\" : \"\", \"ControlStart\"), V = (N === !0 ? o.controlAbles : B.filter(function(W) {\n      return N.indexOf(W.name) > -1;\n    })).filter(function(W) {\n      return W.canPinch && W[U];\n    }), H = fillParams(o, t, {});\n    r && (H.targets = r);\n    var X = triggerEvent(o, $, H);\n    e.isPinch = X !== !1, e.ables = V;\n    var Y = e.isPinch;\n    return Y ? (V.forEach(function(W) {\n      if (T[W.name] = T[W.name] || {}, !!W[U]) {\n        var q = __assign$1(__assign$1({}, t), {\n          datas: T[W.name],\n          parentRotate: S,\n          isPinch: !0\n        });\n        W[U](o, q);\n      }\n    }), o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: [0, 0]\n    }, Y) : !1;\n  },\n  pinch: function(o, t) {\n    var e = t.datas, r = t.scale, S = t.distance, T = t.originalDatas, D = t.inputEvent, N = t.targets, B = t.angle;\n    if (!!e.isPinch) {\n      var $ = S * (1 - 1 / r), U = fillParams(o, t, {});\n      N && (U.targets = N);\n      var V = \"onPinch\".concat(N ? \"Group\" : \"\");\n      triggerEvent(o, V, U);\n      var H = e.ables, X = \"drag\".concat(N ? \"Group\" : \"\", \"Control\");\n      return H.forEach(function(Y) {\n        !Y[X] || Y[X](o, __assign$1(__assign$1({}, t), {\n          datas: T[Y.name],\n          inputEvent: D,\n          parentDistance: $,\n          parentRotate: B,\n          isPinch: !0\n        }));\n      }), U;\n    }\n  },\n  pinchEnd: function(o, t) {\n    var e = t.datas, r = t.isPinch, S = t.inputEvent, T = t.targets, D = t.originalDatas;\n    if (!!e.isPinch) {\n      var N = \"onPinch\".concat(T ? \"Group\" : \"\", \"End\"), B = fillEndParams(o, t, {\n        isDrag: r\n      });\n      T && (B.targets = T), triggerEvent(o, N, B);\n      var $ = e.ables, U = \"drag\".concat(T ? \"Group\" : \"\", \"ControlEnd\");\n      return $.forEach(function(V) {\n        !V[U] || V[U](o, __assign$1(__assign$1({}, t), {\n          isDrag: r,\n          datas: D[V.name],\n          inputEvent: S,\n          isPinch: !0\n        }));\n      }), r;\n    }\n  },\n  pinchGroupStart: function(o, t) {\n    return this.pinchStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  pinchGroup: function(o, t) {\n    return this.pinch(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  pinchGroupEnd: function(o, t) {\n    return this.pinchEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  }\n});\nfunction fillChildEvents(o, t, e) {\n  var r = e.originalDatas;\n  r.groupable = r.groupable || {};\n  var S = r.groupable;\n  S.childDatas = S.childDatas || [];\n  var T = S.childDatas;\n  return o.moveables.map(function(D, N) {\n    return T[N] = T[N] || {}, T[N][t] = T[N][t] || {}, __assign$1(__assign$1({}, e), {\n      datas: T[N][t],\n      originalDatas: T[N]\n    });\n  });\n}\nfunction triggerChildGesto(o, t, e, r, S, T, D) {\n  var N = !!e.match(/Start$/g), B = !!e.match(/End$/g), $ = S.isPinch, U = S.datas, V = fillChildEvents(o, t.name, S), H = o.moveables, X = V.map(function(Y, W) {\n    var q = H[W], K = q.state, Z = K.gestos, J = Y;\n    if (N)\n      J = new CustomGesto(D).dragStart(r, Y);\n    else {\n      if (Z[D] || (Z[D] = U.childGestos[W]), !Z[D])\n        return;\n      J = setCustomDrag(Y, K, r, $, T, D);\n    }\n    var Q = t[e](q, __assign$1(__assign$1({}, J), {\n      parentFlag: !0\n    }));\n    return B && (Z[D] = null), Q;\n  });\n  return N && (U.childGestos = H.map(function(Y) {\n    return Y.state.gestos[D];\n  })), X;\n}\nfunction triggerChildAbles(o, t, e, r, S, T) {\n  S === void 0 && (S = function(U, V) {\n    return V;\n  });\n  var D = !!e.match(/End$/g), N = fillChildEvents(o, t.name, r), B = o.moveables, $ = N.map(function(U, V) {\n    var H = B[V], X = U;\n    X = S(H, U);\n    var Y = t[e](H, __assign$1(__assign$1({}, X), {\n      parentFlag: !0\n    }));\n    return Y && T && T(H, U, Y, V), D && (H.state.gestos = {}), Y;\n  });\n  return $;\n}\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"], HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"], VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction hasGuidelines(o, t) {\n  var e = o.props, r = e.snappable, S = e.bounds, T = e.innerBounds, D = e.verticalGuidelines, N = e.horizontalGuidelines, B = e.snapGridWidth, $ = e.snapGridHeight, U = o.state, V = U.guidelines, H = U.enableSnap;\n  return !r || !H || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(B || $ || S || T || V && V.length || D && D.length || N && N.length);\n}\nfunction getSnapDirections(o) {\n  return o === !1 ? {} : o === !0 || !o ? {\n    left: !0,\n    right: !0,\n    top: !0,\n    bottom: !0\n  } : o;\n}\nfunction mapSnapDirectionPoses(o, t) {\n  var e = getSnapDirections(o), r = {};\n  for (var S in e)\n    S in t && e[S] && (r[S] = t[S]);\n  return r;\n}\nfunction splitSnapDirectionPoses(o, t) {\n  var e = mapSnapDirectionPoses(o, t), r = HORIZONTAL_NAMES.filter(function(T) {\n    return T in e;\n  }), S = VERTICAL_NAMES.filter(function(T) {\n    return T in e;\n  });\n  return {\n    horizontal: r.map(function(T) {\n      return e[T];\n    }),\n    vertical: S.map(function(T) {\n      return e[T];\n    })\n  };\n}\nfunction calculateContainerPos(o, t, e) {\n  var r = calculatePosition(o, [t.clientLeft, t.clientTop], e);\n  return [t.left + r[0], t.top + r[1]];\n}\nfunction solveLineConstants(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];\n  Math.abs(r) < TINY_NUM$1 && (r = 0), Math.abs(S) < TINY_NUM$1 && (S = 0);\n  var T = 0, D = 0, N = 0;\n  return r ? S ? (T = -S / r, D = 1, N = T * t[0] - t[1]) : (D = 1, N = -t[1]) : (T = -1, N = t[0]), [T, D, N].map(function(B) {\n    return throttle(B, TINY_NUM$1);\n  });\n}\nfunction checkMoveableSnapPoses(o, t, e, r) {\n  var S = o.props, T = selectValue(r, S.snapThreshold, 5);\n  return checkSnapPoses(o.state.guidelines, t, e, T);\n}\nfunction checkSnapPoses(o, t, e, r) {\n  return {\n    vertical: checkSnap(o, \"vertical\", t, r),\n    horizontal: checkSnap(o, \"horizontal\", e, r)\n  };\n}\nfunction checkSnapKeepRatio(o, t, e) {\n  var r = e[0], S = e[1], T = t[0], D = t[1], N = minus(e, t), B = N[0], $ = N[1], U = $ > 0, V = B > 0;\n  B = getTinyDist(B), $ = getTinyDist($);\n  var H = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, X = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (B === 0 && $ === 0)\n    return {\n      vertical: H,\n      horizontal: X\n    };\n  var Y = checkMoveableSnapPoses(o, B ? [r] : [], $ ? [S] : []), W = Y.vertical, q = Y.horizontal;\n  W.posInfos.filter(function(_t) {\n    var vt = _t.pos;\n    return V ? vt >= T : vt <= T;\n  }), q.posInfos.filter(function(_t) {\n    var vt = _t.pos;\n    return U ? vt >= D : vt <= D;\n  }), W.isSnap = W.posInfos.length > 0, q.isSnap = q.posInfos.length > 0;\n  var K = getNearestSnapGuidelineInfo(W), Z = K.isSnap, J = K.guideline, Q = getNearestSnapGuidelineInfo(q), rt = Q.isSnap, et = Q.guideline, nt = rt ? et.pos[1] : 0, st = Z ? J.pos[0] : 0;\n  if (B === 0)\n    rt && (X.isSnap = !0, X.pos = et.pos[1], X.offset = S - X.pos);\n  else if ($ === 0)\n    Z && (H.isSnap = !0, H.pos = st, H.offset = r - st);\n  else {\n    var it = $ / B, at = e[1] - it * r, ut = 0, ct = 0, gt = !1;\n    Z ? (ct = st, ut = it * ct + at, gt = !0) : rt && (ut = nt, ct = (ut - at) / it, gt = !0), gt && (H.isSnap = !0, H.pos = ct, H.offset = r - ct, X.isSnap = !0, X.pos = ut, X.offset = S - ut);\n  }\n  return {\n    vertical: H,\n    horizontal: X\n  };\n}\nfunction checkSnaps(o, t, e) {\n  var r = splitSnapDirectionPoses(o.props.snapDirections, t);\n  return checkMoveableSnapPoses(o, r.vertical, r.horizontal, e);\n}\nfunction getNearestSnapGuidelineInfo(o) {\n  var t = o.isSnap;\n  if (!t)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  var e = o.posInfos[0], r = e.guidelineInfos[0], S = r.offset, T = r.dist, D = r.guideline;\n  return {\n    isSnap: t,\n    offset: S,\n    dist: T,\n    pos: e.pos,\n    guideline: D\n  };\n}\nfunction checkSnap(o, t, e, r) {\n  if (!o || !o.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      posInfos: []\n    };\n  var S = t === \"vertical\", T = S ? 0 : 1, D = e.map(function(B, $) {\n    var U = o.map(function(V) {\n      var H = V.pos, X = B - H[T];\n      return {\n        offset: X,\n        dist: Math.abs(X),\n        guideline: V\n      };\n    }).filter(function(V) {\n      var H = V.guideline, X = V.dist, Y = H.type;\n      return !(Y !== t || X > r);\n    }).sort(function(V, H) {\n      return V.dist - H.dist;\n    });\n    return {\n      pos: B,\n      index: $,\n      guidelineInfos: U\n    };\n  }).filter(function(B) {\n    return B.guidelineInfos.length > 0;\n  }).sort(function(B, $) {\n    return B.guidelineInfos[0].dist - $.guidelineInfos[0].dist;\n  }), N = D.length > 0;\n  return {\n    isSnap: N,\n    index: N ? D[0].index : -1,\n    posInfos: D\n  };\n}\nfunction getSnapInfosByDirection(o, t, e, r) {\n  r === void 0 && (r = 1);\n  var S = [];\n  if (e[0] && e[1])\n    S = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(N) {\n      return getPosByDirection(t, N);\n    });\n  else if (!e[0] && !e[1])\n    for (var T = [t[0], t[1], t[3], t[2], t[0]], D = 0; D < 4; ++D)\n      S.push(T[D]), S.push([(T[D][0] + T[D + 1][0]) / 2, (T[D][1] + T[D + 1][1]) / 2]);\n  else\n    o.props.keepRatio ? S = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(N) {\n      return getPosByDirection(t, N);\n    }) : (S = getPosesByDirection(t, e), S.length > 1 && S.push([(S[0][0] + S[1][0]) / 2, (S[0][1] + S[1][1]) / 2]));\n  return checkMoveableSnapPoses(o, S.map(function(N) {\n    return N[0];\n  }), S.map(function(N) {\n    return N[1];\n  }), r);\n}\nfunction checkSnapBoundPriority(o, t) {\n  var e = Math.abs(o.offset), r = Math.abs(t.offset);\n  return o.isBound && t.isBound ? r - e : o.isBound ? -1 : t.isBound ? 1 : o.isSnap && t.isSnap ? r - e : o.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : r < TINY_NUM ? -1 : e - r;\n}\nfunction getNearOffsetInfo(o, t) {\n  return o.slice().sort(function(e, r) {\n    var S = e.sign[t], T = r.sign[t], D = e.offset[t], N = r.offset[t];\n    if (S) {\n      if (!T)\n        return -1;\n    } else\n      return 1;\n    return checkSnapBoundPriority({\n      isBound: e.isBound,\n      isSnap: e.isSnap,\n      offset: D\n    }, {\n      isBound: r.isBound,\n      isSnap: r.isSnap,\n      offset: N\n    });\n  })[0];\n}\nfunction getCheckSnapDirections(o, t, e) {\n  var r = [];\n  if (e)\n    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [o[0], -o[1]]], [t, [-o[0], o[1]]]), r.push([t, o]);\n  else if (o[0] && o[1] || !o[0] && !o[1]) {\n    var S = o[0] ? o : [1, 1];\n    [1, -1].forEach(function(D) {\n      [1, -1].forEach(function(N) {\n        var B = [D * S[0], N * S[1]];\n        t[0] === B[0] && t[1] === B[1] || r.push([t, B]);\n      });\n    });\n  } else if (o[0]) {\n    var T = Math.abs(t[0]) === 1 ? [1] : [1, -1];\n    T.forEach(function(D) {\n      r.push([[t[0], -1], [D * o[0], -1]], [[t[0], 0], [D * o[0], 0]], [[t[0], 1], [D * o[0], 1]]);\n    });\n  } else if (o[1]) {\n    var T = Math.abs(t[1]) === 1 ? [1] : [1, -1];\n    T.forEach(function(N) {\n      r.push([[-1, t[1]], [-1, N * o[1]]], [[0, t[1]], [0, N * o[1]]], [[1, t[1]], [1, N * o[1]]]);\n    });\n  }\n  return r;\n}\nfunction isStartLine(o, t) {\n  var e = average([t[0][0], t[1][0]]), r = average([t[0][1], t[1][1]]);\n  return {\n    vertical: e <= o[0],\n    horizontal: r <= o[1]\n  };\n}\nfunction hitTestLine(o, t) {\n  var e = t[0], r = t[1], S = r[0] - e[0], T = r[1] - e[1];\n  Math.abs(S) < TINY_NUM && (S = 0), Math.abs(T) < TINY_NUM && (T = 0);\n  var D, N;\n  if (!S)\n    D = e[0], N = o[0];\n  else if (!T)\n    D = e[1], N = o[1];\n  else {\n    var B = T / S;\n    D = B * (o[0] - e[0]) + e[1], N = o[1];\n  }\n  return D - N;\n}\nfunction isSameStartLine(o, t, e, r) {\n  return r === void 0 && (r = TINY_NUM), o.every(function(S) {\n    var T = hitTestLine(S, t), D = T <= 0;\n    return D === e || Math.abs(T) <= r;\n  });\n}\nfunction checkInnerBoundDot(o, t, e, r, S) {\n  return S === void 0 && (S = 0), r && t - S <= o || !r && o <= e + S ? {\n    isBound: !0,\n    offset: r ? t - o : e - o\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction checkInnerBound(o, t) {\n  var e = t.line, r = t.centerSign, S = t.verticalSign, T = t.horizontalSign, D = t.lineConstants, N = o.props.innerBounds;\n  if (!N)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var B = N.left, $ = N.top, U = N.width, V = N.height, H = [[B, $], [B, $ + V]], X = [[B, $], [B + U, $]], Y = [[B + U, $], [B + U, $ + V]], W = [[B, $ + V], [B + U, $ + V]];\n  if (isSameStartLine([[B, $], [B + U, $], [B, $ + V], [B + U, $ + V]], e, r))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var q = checkLineBoundCollision(e, D, X, S), K = checkLineBoundCollision(e, D, W, S), Z = checkLineBoundCollision(e, D, H, T), J = checkLineBoundCollision(e, D, Y, T), Q = q.isBound && K.isBound, rt = q.isBound || K.isBound, et = Z.isBound && J.isBound, nt = Z.isBound || J.isBound, st = maxOffset(q.offset, K.offset), it = maxOffset(Z.offset, J.offset), at = [0, 0], ut = !1, ct = !1;\n  return Math.abs(it) < Math.abs(st) ? (at = [st, 0], ut = rt, ct = Q) : (at = [0, it], ut = nt, ct = et), {\n    isAllBound: ct,\n    isVerticalBound: rt,\n    isHorizontalBound: nt,\n    isBound: ut,\n    offset: at\n  };\n}\nfunction checkLineBoundCollision(o, t, e, r, S, T) {\n  var D = t[0], N = t[1], B = o[0], $ = e[0], U = e[1], V = getTinyDist(U[1] - $[1]), H = getTinyDist(U[0] - $[0]), X = N, Y = D, W = -D / N;\n  if (H) {\n    if (!V) {\n      if (T && !X)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (Y) {\n        var J = ($[1] - B[1]) / W + B[0];\n        return checkInnerBoundDot(J, $[0], U[0], r, S);\n      } else {\n        var K = $[1] - B[1], Z = Math.abs(K) <= (S || 0);\n        return {\n          isBound: Z,\n          offset: Z ? K : 0\n        };\n      }\n    }\n  } else {\n    if (T && !Y)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (X) {\n      var q = W * ($[0] - B[0]) + B[1];\n      return checkInnerBoundDot(q, $[1], U[1], r, S);\n    } else {\n      var K = $[0] - B[0], Z = Math.abs(K) <= (S || 0);\n      return {\n        isBound: Z,\n        offset: Z ? K : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction getInnerBoundInfo(o, t, e) {\n  return t.map(function(r) {\n    var S = checkInnerBound(o, r), T = S.isBound, D = S.offset, N = S.isVerticalBound, B = S.isHorizontalBound, $ = r.multiple, U = getDragDist({\n      datas: e,\n      distX: D[0],\n      distY: D[1]\n    }).map(function(V, H) {\n      return V * ($[H] ? 2 / $[H] : 0);\n    });\n    return {\n      sign: $,\n      isBound: T,\n      isVerticalBound: N,\n      isHorizontalBound: B,\n      isSnap: !1,\n      offset: U\n    };\n  });\n}\nfunction getInnerBoundDragInfo(o, t, e) {\n  var r, S = getCheckInnerBoundLineInfos(o, t, [0, 0], !1).map(function(H) {\n    return __assign$1(__assign$1({}, H), {\n      multiple: H.multiple.map(function(X) {\n        return Math.abs(X) * 2;\n      })\n    });\n  }), T = getInnerBoundInfo(o, S, e), D = getNearOffsetInfo(T, 0), N = getNearOffsetInfo(T, 1), B = 0, $ = 0, U = D.isVerticalBound || N.isVerticalBound, V = D.isHorizontalBound || N.isHorizontalBound;\n  return (U || V) && (r = getInverseDragDist({\n    datas: e,\n    distX: -D.offset[0],\n    distY: -N.offset[1]\n  }), B = r[0], $ = r[1]), {\n    vertical: {\n      isBound: U,\n      offset: B\n    },\n    horizontal: {\n      isBound: V,\n      offset: $\n    }\n  };\n}\nfunction getCheckSnapLineDirections(o, t) {\n  var e = [], r = o[0], S = o[1];\n  return r && S ? e.push([[0, S * 2], o, [-r, S]], [[r * 2, 0], o, [r, -S]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : S ? (e.push([[0, S * 2], [1, S], [-1, S]]), t && e.push([[-1, 0], [-1, S], [-1, -S]], [[1, 0], [1, S], [1, -S]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;\n}\nfunction getCheckInnerBoundLineInfos(o, t, e, r) {\n  var S = o.state, T = S.allMatrix, D = S.is3d, N = calculatePoses(T, 100, 100, D ? 4 : 3), B = getPosByDirection(N, [0, 0]);\n  return getCheckSnapLineDirections(e, r).map(function($) {\n    var U = $[0], V = $[1], H = $[2], X = [getPosByDirection(N, V), getPosByDirection(N, H)], Y = solveLineConstants(X), W = isStartLine(B, X), q = W.vertical, K = W.horizontal, Z = hitTestLine(B, X) <= 0;\n    return {\n      multiple: U,\n      centerSign: Z,\n      verticalSign: q,\n      horizontalSign: K,\n      lineConstants: Y,\n      line: [getPosByDirection(t, V), getPosByDirection(t, H)]\n    };\n  });\n}\nfunction isBoundRotate$1(o, t, e, r) {\n  var S = r ? o.map(function(T) {\n    return rotate(T, r);\n  }) : o;\n  return [[S[0], S[1]], [S[1], S[3]], [S[3], S[2]], [S[2], S[0]]].some(function(T) {\n    var D = hitTestLine(e, T) <= 0;\n    return !isSameStartLine(t, T, D);\n  });\n}\nfunction getDistPointLine(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];\n  if (!r)\n    return Math.abs(t[0]);\n  if (!S)\n    return Math.abs(t[1]);\n  var T = S / r;\n  return Math.abs((-T * t[0] + t[1]) / Math.sqrt(Math.pow(T, 2) + 1));\n}\nfunction solveReverseLine(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], S = e[1] - t[1];\n  if (!r)\n    return [t[0], 0];\n  if (!S)\n    return [0, t[1]];\n  var T = S / r, D = -T * t[0] + t[1];\n  return [-D / (T + 1 / T), D / (T * T + 1)];\n}\nfunction checkRotateInnerBounds(o, t, e, r, S) {\n  var T = o.props.innerBounds, D = S * Math.PI / 180;\n  if (!T)\n    return [];\n  var N = T.left, B = T.top, $ = T.width, U = T.height, V = N - r[0], H = N + $ - r[0], X = B - r[1], Y = B + U - r[1], W = [[V, X], [H, X], [V, Y], [H, Y]], q = getPosByDirection(e, [0, 0]);\n  if (!isBoundRotate$1(e, W, q, 0))\n    return [];\n  var K = [], Z = W.map(function(J) {\n    return [getDistSize(J), getRad$1([0, 0], J)];\n  });\n  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(J) {\n    var Q = getRad$1([0, 0], solveReverseLine(J)), rt = getDistPointLine(J);\n    K.push.apply(K, Z.filter(function(et) {\n      var nt = et[0];\n      return nt && rt <= nt;\n    }).map(function(et) {\n      var nt = et[0], st = et[1], it = Math.acos(nt ? rt / nt : 0), at = st + it, ut = st - it;\n      return [D + at - Q, D + ut - Q];\n    }).reduce(function(et, nt) {\n      return et.push.apply(et, nt), et;\n    }, []).filter(function(et) {\n      return !isBoundRotate$1(t, W, q, et);\n    }).map(function(et) {\n      return throttle(et * 180 / Math.PI, TINY_NUM);\n    }));\n  }), K;\n}\nfunction checkInnerBoundPoses(o) {\n  var t = o.props.innerBounds;\n  if (!t)\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  var e = o.getRect(), r = e.pos1, S = e.pos2, T = e.pos3, D = e.pos4, N = [r, S, T, D], B = getPosByDirection(N, [0, 0]), $ = t.left, U = t.top, V = t.width, H = t.height, X = [[$, U], [$, U + H]], Y = [[$, U], [$ + V, U]], W = [[$ + V, U], [$ + V, U + H]], q = [[$, U + H], [$ + V, U + H]], K = getCheckInnerBoundLineInfos(o, N, [0, 0], !1), Z = [], J = [], Q = {\n    top: !1,\n    bottom: !1,\n    left: !1,\n    right: !1\n  };\n  return K.forEach(function(rt) {\n    var et = rt.line, nt = rt.lineConstants, st = isStartLine(B, et), it = st.horizontal, at = st.vertical, ut = checkLineBoundCollision(et, nt, Y, at, 1, !0), ct = checkLineBoundCollision(et, nt, q, at, 1, !0), gt = checkLineBoundCollision(et, nt, X, it, 1, !0), _t = checkLineBoundCollision(et, nt, W, it, 1, !0);\n    ut.isBound && !Q.top && (Z.push(U), Q.top = !0), ct.isBound && !Q.bottom && (Z.push(U + H), Q.bottom = !0), gt.isBound && !Q.left && (J.push($), Q.left = !0), _t.isBound && !Q.right && (J.push($ + V), Q.right = !0);\n  }), {\n    horizontal: Z,\n    vertical: J\n  };\n}\nfunction checkBoundPoses(o, t, e) {\n  var r = o || {}, S = r.position, T = S === void 0 ? \"client\" : S, D = r.left, N = D === void 0 ? -1 / 0 : D, B = r.top, $ = B === void 0 ? -1 / 0 : B, U = r.right, V = U === void 0 ? 1 / 0 : U, H = r.bottom, X = H === void 0 ? 1 / 0 : H, Y = {\n    position: T,\n    left: N,\n    top: $,\n    right: V,\n    bottom: X\n  };\n  return {\n    vertical: checkBounds(Y, t, !0),\n    horizontal: checkBounds(Y, e, !1)\n  };\n}\nfunction getBounds(o, t) {\n  var e = o.state, r = e.containerClientRect, S = r.clientHeight, T = r.clientWidth, D = r.clientLeft, N = r.clientTop, B = e.snapOffset, $ = B.left, U = B.top, V = B.right, H = B.bottom, X = t || o.props.bounds || {}, Y = X.position || \"client\", W = Y === \"css\", q = X.left, K = q === void 0 ? -1 / 0 : q, Z = X.top, J = Z === void 0 ? -1 / 0 : Z, Q = X.right, rt = Q === void 0 ? W ? -1 / 0 : 1 / 0 : Q, et = X.bottom, nt = et === void 0 ? W ? -1 / 0 : 1 / 0 : et;\n  return W && (rt = T + V - $ - rt, nt = S + H - U - nt), {\n    left: K + $ - D,\n    right: rt + $ - D,\n    top: J + U - N,\n    bottom: nt + U - N\n  };\n}\nfunction checkBoundKeepRatio(o, t, e) {\n  var r = getBounds(o), S = r.left, T = r.top, D = r.right, N = r.bottom, B = e[0], $ = e[1], U = minus(e, t), V = U[0], H = U[1];\n  Math.abs(V) < TINY_NUM && (V = 0), Math.abs(H) < TINY_NUM && (H = 0);\n  var X = H > 0, Y = V > 0, W = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, q = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (V === 0 && H === 0)\n    return {\n      vertical: W,\n      horizontal: q\n    };\n  if (V === 0)\n    X ? N < $ && (q.pos = N, q.offset = $ - N) : T > $ && (q.pos = T, q.offset = $ - T);\n  else if (H === 0)\n    Y ? D < B && (W.pos = D, W.offset = B - D) : S > B && (W.pos = S, W.offset = B - S);\n  else {\n    var K = H / V, Z = e[1] - K * B, J = 0, Q = 0, rt = !1;\n    Y && D <= B ? (J = K * D + Z, Q = D, rt = !0) : !Y && B <= S && (J = K * S + Z, Q = S, rt = !0), rt && (J < T || J > N) && (rt = !1), rt || (X && N <= $ ? (J = N, Q = (J - Z) / K, rt = !0) : !X && $ <= T && (J = T, Q = (J - Z) / K, rt = !0)), rt && (W.isBound = !0, W.pos = Q, W.offset = B - Q, q.isBound = !0, q.pos = J, q.offset = $ - J);\n  }\n  return {\n    vertical: W,\n    horizontal: q\n  };\n}\nfunction checkBounds(o, t, e) {\n  var r = o[e ? \"left\" : \"top\"], S = o[e ? \"right\" : \"bottom\"], T = Math.min.apply(Math, t), D = Math.max.apply(Math, t), N = [];\n  return r + 1 > T && N.push({\n    isBound: !0,\n    offset: T - r,\n    pos: r\n  }), S - 1 < D && N.push({\n    isBound: !0,\n    offset: D - S,\n    pos: S\n  }), N.length || N.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), N.sort(function(B, $) {\n    return Math.abs($.offset) - Math.abs(B.offset);\n  });\n}\nfunction isBoundRotate(o, t, e) {\n  var r = e ? o.map(function(S) {\n    return rotate(S, e);\n  }) : o;\n  return r.some(function(S) {\n    return S[0] < t.left && Math.abs(S[0] - t.left) > 0.1 || S[0] > t.right && Math.abs(S[0] - t.right) > 0.1 || S[1] < t.top && Math.abs(S[1] - t.top) > 0.1 || S[1] > t.bottom && Math.abs(S[1] - t.bottom) > 0.1;\n  });\n}\nfunction boundRotate(o, t, e) {\n  var r = getDistSize(o), S = Math.sqrt(r * r - t * t) || 0;\n  return [S, -S].sort(function(T, D) {\n    return Math.abs(T - o[e ? 0 : 1]) - Math.abs(D - o[e ? 0 : 1]);\n  }).map(function(T) {\n    return getRad$1([0, 0], e ? [T, t] : [t, T]);\n  });\n}\nfunction checkRotateBounds(o, t, e, r, S) {\n  if (!o.props.bounds)\n    return [];\n  var T = S * Math.PI / 180, D = getBounds(o), N = D.left, B = D.top, $ = D.right, U = D.bottom, V = N - r[0], H = $ - r[0], X = B - r[1], Y = U - r[1], W = {\n    left: V,\n    top: X,\n    right: H,\n    bottom: Y\n  };\n  if (!isBoundRotate(e, W, 0))\n    return [];\n  var q = [];\n  return [[V, 0], [H, 0], [X, 1], [Y, 1]].forEach(function(K) {\n    var Z = K[0], J = K[1];\n    e.forEach(function(Q) {\n      var rt = getRad$1([0, 0], Q);\n      q.push.apply(q, boundRotate(Q, Z, J).map(function(et) {\n        return T + et - rt;\n      }).filter(function(et) {\n        return !isBoundRotate(t, W, et);\n      }).map(function(et) {\n        return throttle(et * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  }), q;\n}\nfunction renderGuideline(o, t) {\n  var e, r = o.direction, S = o.classNames, T = o.size, D = o.pos, N = o.zoom, B = o.key, $ = r === \"horizontal\", U = $ ? \"Y\" : \"X\";\n  return t.createElement(\"div\", {\n    key: B,\n    className: S.join(\" \"),\n    style: (e = {}, e[$ ? \"width\" : \"height\"] = \"\".concat(T), e.transform = \"translate(\".concat(D[0], \", \").concat(D[1], \") translate\").concat(U, \"(-50%) scale\").concat(U, \"(\").concat(N, \")\"), e)\n  });\n}\nfunction renderInnerGuideline(o, t) {\n  return renderGuideline(__assign$1(__assign$1({}, o), {\n    classNames: __spreadArray([prefix(\"line\", \"guideline\", o.direction)], o.classNames, !0).filter(function(e) {\n      return e;\n    }),\n    size: o.size || \"\".concat(o.sizeValue, \"px\"),\n    pos: o.pos || o.posValue.map(function(e) {\n      return \"\".concat(throttle(e, 0.1), \"px\");\n    })\n  }), t);\n}\nfunction renderSnapPoses(o, t, e, r, S, T, D, N) {\n  var B = o.props.zoom;\n  return e.map(function($, U) {\n    var V = $.type, H = $.pos, X = [0, 0];\n    return X[D] = r, X[D ? 0 : 1] = -S + H, renderInnerGuideline({\n      key: \"\".concat(t, \"TargetGuideline\").concat(U),\n      classNames: [prefix(\"target\", \"bold\", V)],\n      posValue: X,\n      sizeValue: T,\n      zoom: B,\n      direction: t\n    }, N);\n  });\n}\nfunction renderGuidelines(o, t, e, r, S, T) {\n  var D = o.props, N = D.zoom, B = D.isDisplayInnerSnapDigit, $ = t === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = S[$.start], V = S[$.end];\n  return e.filter(function(H) {\n    var X = H.hide, Y = H.elementRect;\n    if (X)\n      return !1;\n    if (B && Y) {\n      var W = Y.rect;\n      if (W[$.start] <= U && V <= W[$.end])\n        return !1;\n    }\n    return !0;\n  }).map(function(H, X) {\n    var Y = H.pos, W = H.size, q = H.element, K = H.className, Z = [-r[0] + Y[0], -r[1] + Y[1]];\n    return renderInnerGuideline({\n      key: \"\".concat(t, \"-default-guideline-\").concat(X),\n      classNames: q ? [prefix(\"bold\"), K] : [prefix(\"normal\"), K],\n      direction: t,\n      posValue: Z,\n      sizeValue: W,\n      zoom: N\n    }, T);\n  });\n}\nfunction renderDigitLine(o, t, e, r, S, T, D, N) {\n  var B, $ = o.props, U = $.snapDigit, V = U === void 0 ? 0 : U, H = $.isDisplaySnapDigit, X = H === void 0 ? !0 : H, Y = $.snapDistFormat, W = Y === void 0 ? function(rt, et) {\n    return rt;\n  } : Y, q = $.zoom, K = t === \"horizontal\" ? \"X\" : \"Y\", Z = t === \"vertical\" ? \"height\" : \"width\", J = Math.abs(S), Q = X ? parseFloat(J.toFixed(V)) : 0;\n  return N.createElement(\"div\", {\n    key: \"\".concat(t, \"-\").concat(e, \"-guideline-\").concat(r),\n    className: prefix(\"guideline-group\", t),\n    style: (B = {\n      left: \"\".concat(T[0], \"px\"),\n      top: \"\".concat(T[1], \"px\")\n    }, B[Z] = \"\".concat(J, \"px\"), B)\n  }, renderInnerGuideline({\n    direction: t,\n    classNames: [prefix(e), D],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: J,\n    zoom: q\n  }, N), N.createElement(\"div\", {\n    className: prefix(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(K, \"(-50%) scale(\").concat(q, \")\")\n    }\n  }, Q > 0 ? W(Q, t) : \"\"));\n}\nfunction groupByElementGuidelines(o, t, e, r) {\n  var S = o === \"vertical\" ? 0 : 1, T = o === \"vertical\" ? 1 : 0, D = S ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, N = e[D.start], B = e[D.end];\n  return groupBy(t, function($) {\n    return $.pos[S];\n  }).map(function($) {\n    var U = [], V = [], H = [];\n    return $.forEach(function(X) {\n      var Y, W, q = X.element, K = X.elementRect.rect;\n      if (K[D.end] < N)\n        U.push(X);\n      else if (B < K[D.start])\n        V.push(X);\n      else if (K[D.start] <= N && B <= K[D.end] && r) {\n        var Z = X.pos, J = {\n          element: q,\n          rect: __assign$1(__assign$1({}, K), (Y = {}, Y[D.end] = K[D.start], Y))\n        }, Q = {\n          element: q,\n          rect: __assign$1(__assign$1({}, K), (W = {}, W[D.start] = K[D.end], W))\n        }, rt = [0, 0], et = [0, 0];\n        rt[S] = Z[S], rt[T] = Z[T], et[S] = Z[S], et[T] = Z[T] + X.size, U.push({\n          type: o,\n          pos: rt,\n          size: 0,\n          elementRect: J\n        }), V.push({\n          type: o,\n          pos: et,\n          size: 0,\n          elementRect: Q\n        });\n      }\n    }), U.sort(function(X, Y) {\n      return Y.pos[T] - X.pos[T];\n    }), V.sort(function(X, Y) {\n      return X.pos[T] - Y.pos[T];\n    }), {\n      total: $,\n      start: U,\n      end: V,\n      inner: H\n    };\n  });\n}\nfunction renderDashedGuidelines(o, t, e, r, S) {\n  var T = o.props.isDisplayInnerSnapDigit, D = [];\n  return [\"vertical\", \"horizontal\"].forEach(function(N) {\n    var B = t.filter(function(q) {\n      return q.type === N;\n    }), $ = N === \"vertical\" ? 1 : 0, U = $ ? 0 : 1, V = groupByElementGuidelines(N, B, r, T), H = $ ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = $ ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, Y = r[H.start], W = r[H.end];\n    V.forEach(function(q) {\n      var K = q.total, Z = q.start, J = q.end, Q = q.inner, rt = e[U] + K[0].pos[U] - r[X.start], et = r;\n      Z.forEach(function(nt) {\n        var st = nt.elementRect.rect, it = et[H.start] - st[H.end];\n        if (it > 0) {\n          var at = [0, 0];\n          at[$] = e[$] + et[H.start] - Y - it, at[U] = rt, D.push(renderDigitLine(o, N, \"dashed\", D.length, it, at, nt.className, S));\n        }\n        et = st;\n      }), et = r, J.forEach(function(nt) {\n        var st = nt.elementRect.rect, it = st[H.start] - et[H.end];\n        if (it > 0) {\n          var at = [0, 0];\n          at[$] = e[$] + et[H.end] - Y, at[U] = rt, D.push(renderDigitLine(o, N, \"dashed\", D.length, it, at, nt.className, S));\n        }\n        et = st;\n      }), Q.forEach(function(nt) {\n        var st = nt.elementRect.rect, it = Y - st[H.start], at = st[H.end] - W, ut = [0, 0], ct = [0, 0];\n        ut[$] = e[$] - it, ut[U] = rt, ct[$] = e[$] + W - Y, ct[U] = rt, D.push(renderDigitLine(o, N, \"dashed\", D.length, it, ut, nt.className, S)), D.push(renderDigitLine(o, N, \"dashed\", D.length, at, ct, nt.className, S));\n      });\n    });\n  }), D;\n}\nfunction renderGapGuidelines(o, t, e, r, S) {\n  var T = [];\n  return [\"horizontal\", \"vertical\"].forEach(function(D) {\n    var N = t.filter(function(q) {\n      return q.type === D;\n    }).slice(0, 1), B = D === \"vertical\" ? 0 : 1, $ = B ? 0 : 1, U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, V = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, H = r[U.start], X = r[U.end], Y = r[V.start], W = r[V.end];\n    N.forEach(function(q) {\n      var K = q.gap, Z = q.gapRects, J = Math.max.apply(Math, __spreadArray([Y], Z.map(function(et) {\n        var nt = et.rect;\n        return nt[V.start];\n      }), !1)), Q = Math.min.apply(Math, __spreadArray([W], Z.map(function(et) {\n        var nt = et.rect;\n        return nt[V.end];\n      }), !1)), rt = (J + Q) / 2;\n      J === Q || rt === (Y + W) / 2 || Z.forEach(function(et) {\n        var nt = et.rect, st = et.className, it = [e[0], e[1]];\n        if (nt[U.end] < H)\n          it[B] += nt[U.end] - H;\n        else if (X < nt[U.start])\n          it[B] += nt[U.start] - H - K;\n        else\n          return;\n        it[$] += rt - Y, T.push(renderDigitLine(o, B ? \"vertical\" : \"horizontal\", \"gap\", T.length, K, it, st, S));\n      });\n    });\n  }), T;\n}\nfunction solveEquation(o, t, e, r) {\n  var S = t[0] - o[0], T = t[1] - o[1];\n  if (Math.abs(S) < TINY_NUM$1 && (S = 0), Math.abs(T) < TINY_NUM$1 && (T = 0), !S)\n    return r ? [0, 0] : [0, e];\n  if (!T)\n    return r ? [e, 0] : [0, 0];\n  var D = T / S, N = o[1] - D * o[0];\n  if (r) {\n    var B = D * (t[0] + e) + N;\n    return [e, B - t[1]];\n  } else {\n    var $ = (t[1] + e - N) / D;\n    return [$ - t[0], e];\n  }\n}\nfunction solveNextOffset(o, t, e, r, S) {\n  var T = solveEquation(o, t, e, r);\n  if (!T)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  var D = getDist$2(o, t), N = getDist$2(T, o), B = getDist$2(T, t), $ = N > D || B > D, U = getDragDist({\n    datas: S,\n    distX: T[0],\n    distY: T[1]\n  }), V = U[0], H = U[1];\n  return {\n    offset: [V, H],\n    isOutside: $\n  };\n}\nfunction getSnapBound(o, t) {\n  return o.isBound ? o.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;\n}\nfunction checkThrottleDragRotate(o, t, e, r, S) {\n  var T = t[0], D = t[1], N = e[0], B = e[1], $ = r[0], U = r[1], V = S[0], H = S[1], X = -V, Y = -H;\n  if (o && T && D) {\n    X = 0, Y = 0;\n    var W = [];\n    if (N && B ? W.push([0, H], [V, 0]) : N ? W.push([V, 0]) : B ? W.push([0, H]) : $ && U ? W.push([0, H], [V, 0]) : $ ? W.push([V, 0]) : U && W.push([0, H]), W.length) {\n      W.sort(function(J, Q) {\n        return getDistSize(minus([T, D], J)) - getDistSize(minus([T, D], Q));\n      });\n      var q = W[0];\n      if (q[0] && Math.abs(T) > TINY_NUM$1)\n        X = -q[0], Y = D * Math.abs(T + X) / Math.abs(T) - D;\n      else if (q[1] && Math.abs(D) > TINY_NUM$1) {\n        var K = D;\n        Y = -q[1], X = T * Math.abs(D + Y) / Math.abs(K) - T;\n      }\n      if (o && B && N)\n        if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(V)) {\n          var Z = Math.abs(V) / Math.abs(X);\n          X *= Z, Y *= Z;\n        } else if (Math.abs(Y) > TINY_NUM$1 && Math.abs(Y) < Math.abs(H)) {\n          var Z = Math.abs(H) / Math.abs(Y);\n          X *= Z, Y *= Z;\n        } else\n          X = maxOffset(-V, X), Y = maxOffset(-H, Y);\n    }\n  } else\n    X = T || N ? -V : 0, Y = D || B ? -H : 0;\n  return [X, Y];\n}\nfunction checkSnapBoundsDrag(o, t, e, r, S, T) {\n  if (!hasGuidelines(o, \"draggable\"))\n    return [{\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }, {\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }];\n  var D = getAbsolutePoses(T.absolutePoses, [t, e]), N = getRect(D), B = N.left, $ = N.right, U = N.top, V = N.bottom, H = {\n    horizontal: D.map(function(_t) {\n      return _t[1];\n    }),\n    vertical: D.map(function(_t) {\n      return _t[0];\n    })\n  }, X = getSnapDirections(o.props.snapDirections), Y = splitSnapDirectionPoses(X, {\n    left: B,\n    right: $,\n    top: U,\n    bottom: V,\n    center: (B + $) / 2,\n    middle: (U + V) / 2\n  }), W = checkMoveableSnapBounds(o, S, Y, H), q = W.vertical, K = W.horizontal, Z = getInnerBoundDragInfo(o, D, T), J = Z.vertical, Q = Z.horizontal, rt = q.isSnap, et = K.isSnap, nt = q.isBound || J.isBound, st = K.isBound || Q.isBound, it = maxOffset(q.offset, J.offset), at = maxOffset(K.offset, Q.offset), ut = checkThrottleDragRotate(r, [t, e], [nt, st], [rt, et], [it, at]), ct = ut[0], gt = ut[1];\n  return [{\n    isBound: nt,\n    isSnap: rt,\n    offset: ct\n  }, {\n    isBound: st,\n    isSnap: et,\n    offset: gt\n  }];\n}\nfunction checkMoveableSnapBounds(o, t, e, r) {\n  r === void 0 && (r = e);\n  var S = checkBoundPoses(getBounds(o), r.vertical, r.horizontal), T = S.horizontal, D = S.vertical, N = t ? {\n    horizontal: {\n      isSnap: !1,\n      index: -1\n    },\n    vertical: {\n      isSnap: !1,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(o, e.vertical, e.horizontal), B = N.horizontal, $ = N.vertical, U = getSnapBound(T[0], B), V = getSnapBound(D[0], $), H = Math.abs(U), X = Math.abs(V);\n  return {\n    horizontal: {\n      isBound: T[0].isBound,\n      isSnap: B.isSnap,\n      snapIndex: B.index,\n      offset: U,\n      dist: H,\n      bounds: T,\n      snap: B\n    },\n    vertical: {\n      isBound: D[0].isBound,\n      isSnap: $.isSnap,\n      snapIndex: $.index,\n      offset: V,\n      dist: X,\n      bounds: D,\n      snap: $\n    }\n  };\n}\nfunction checkSnapBounds(o, t, e, r, S) {\n  var T = checkBoundPoses(t, e, r), D = T.horizontal, N = T.vertical, B = checkSnapPoses(o, e, r, S), $ = B.horizontal, U = B.vertical, V = getSnapBound(D[0], $), H = getSnapBound(N[0], U), X = Math.abs(V), Y = Math.abs(H);\n  return {\n    horizontal: {\n      isBound: D[0].isBound,\n      isSnap: $.isSnap,\n      snapIndex: $.index,\n      offset: V,\n      dist: X,\n      bounds: D,\n      snap: $\n    },\n    vertical: {\n      isBound: N[0].isBound,\n      isSnap: U.isSnap,\n      snapIndex: U.index,\n      offset: H,\n      dist: Y,\n      bounds: N,\n      snap: U\n    }\n  };\n}\nfunction checkSnapRightLine(o, t, e, r) {\n  var S = getRad$1(o, t) / Math.PI * 180, T = e.vertical, D = T.isBound, N = T.isSnap, B = T.dist, $ = e.horizontal, U = $.isBound, V = $.isSnap, H = $.dist, X = S % 180, Y = X < 3 || X > 177, W = X > 87 && X < 93;\n  return H < B && (D || N && !W && (!r || !Y)) ? \"vertical\" : U || V && !Y && (!r || !W) ? \"horizontal\" : \"\";\n}\nfunction getSnapBoundInfo(o, t, e, r, S, T) {\n  return e.map(function(D) {\n    var N = D[0], B = D[1], $ = getPosByDirection(t, N), U = getPosByDirection(t, B), V = r ? checkSnapBoundsKeepRatio(o, $, U, S) : checkMoveableSnapBounds(o, S, {\n      vertical: [U[0]],\n      horizontal: [U[1]]\n    }), H = V.horizontal, X = H.offset, Y = H.isBound, W = H.isSnap, q = V.vertical, K = q.offset, Z = q.isBound, J = q.isSnap, Q = minus(B, N);\n    if (!K && !X)\n      return {\n        isBound: Z || Y,\n        isSnap: J || W,\n        sign: Q,\n        offset: [0, 0]\n      };\n    var rt = checkSnapRightLine($, U, V, r);\n    if (!rt)\n      return {\n        sign: Q,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    var et = rt === \"vertical\", nt = [0, 0];\n    return !r && Math.abs(B[0]) === 1 && Math.abs(B[1]) === 1 && N[0] !== B[0] && N[1] !== B[1] ? nt = getDragDist({\n      datas: T,\n      distX: -K,\n      distY: -X\n    }) : nt = solveNextOffset($, U, -(et ? K : X), et, T).offset, nt = nt.map(function(st, it) {\n      return st * (Q[it] ? 2 / Q[it] : 0);\n    }), {\n      sign: Q,\n      isBound: et ? Z : Y,\n      isSnap: et ? J : W,\n      offset: nt\n    };\n  });\n}\nfunction getSnapBoundOffset(o, t) {\n  return o.isBound ? o.offset : t.isSnap ? t.offset : 0;\n}\nfunction checkSnapBoundsKeepRatio(o, t, e, r) {\n  var S = checkBoundKeepRatio(o, t, e), T = S.horizontal, D = S.vertical, N = r ? {\n    horizontal: {\n      isSnap: !1\n    },\n    vertical: {\n      isSnap: !1\n    }\n  } : checkSnapKeepRatio(o, t, e), B = N.horizontal, $ = N.vertical, U = getSnapBoundOffset(T, B), V = getSnapBoundOffset(D, $), H = Math.abs(U), X = Math.abs(V);\n  return {\n    horizontal: {\n      isBound: T.isBound,\n      isSnap: B.isSnap,\n      offset: U,\n      dist: H\n    },\n    vertical: {\n      isBound: D.isBound,\n      isSnap: $.isSnap,\n      offset: V,\n      dist: X\n    }\n  };\n}\nfunction checkMaxBounds(o, t, e, r, S) {\n  var T = [-e[0], -e[1]], D = o.state, N = D.width, B = D.height, $ = o.props.bounds, U = 1 / 0, V = 1 / 0;\n  if ($) {\n    var H = [[e[0], -e[1]], [-e[0], e[1]]], X = $.left, Y = X === void 0 ? -1 / 0 : X, W = $.top, q = W === void 0 ? -1 / 0 : W, K = $.right, Z = K === void 0 ? 1 / 0 : K, J = $.bottom, Q = J === void 0 ? 1 / 0 : J;\n    H.forEach(function(rt) {\n      var et = rt[0] !== T[0], nt = rt[1] !== T[1], st = getPosByDirection(t, rt), it = getRad$1(r, st) * 360 / Math.PI;\n      if (nt) {\n        var at = st.slice();\n        (Math.abs(it - 360) < 2 || Math.abs(it - 180) < 2) && (at[1] = r[1]);\n        var ut = solveNextOffset(r, at, (r[1] < st[1] ? Q : q) - st[1], !1, S), ct = ut.offset, gt = ct[1], _t = ut.isOutside;\n        isNaN(gt) || (V = B + (_t ? 1 : -1) * Math.abs(gt));\n      }\n      if (et) {\n        var at = st.slice();\n        (Math.abs(it - 90) < 2 || Math.abs(it - 270) < 2) && (at[0] = r[0]);\n        var vt = solveNextOffset(r, at, (r[0] < st[0] ? Z : Y) - st[0], !0, S), mt = vt.offset[0], bt = vt.isOutside;\n        isNaN(mt) || (U = N + (bt ? 1 : -1) * Math.abs(mt));\n      }\n    });\n  }\n  return {\n    maxWidth: U,\n    maxHeight: V\n  };\n}\nfunction getTotalGuidelines(o) {\n  var t = o.state, e = t.containerClientRect, r = t.hasFixed, S = e.overflow, T = e.scrollHeight, D = e.scrollWidth, N = e.clientHeight, B = e.clientWidth, $ = e.clientLeft, U = e.clientTop, V = o.props, H = V.snapGap, X = H === void 0 ? !0 : H, Y = V.verticalGuidelines, W = V.horizontalGuidelines, q = V.snapThreshold, K = q === void 0 ? 5 : q, Z = V.snapGridWidth, J = Z === void 0 ? 0 : Z, Q = V.snapGridHeight, rt = Q === void 0 ? 0 : Q, et = V.maxSnapElementGuidelineDistance, nt = et === void 0 ? 1 / 0 : et, st = getRect(getAbsolutePosesByState(o.state)), it = st.top, at = st.left, ut = st.bottom, ct = st.right, gt = {\n    top: it,\n    left: at,\n    bottom: ut,\n    right: ct,\n    center: (at + ct) / 2,\n    middle: (it + ut) / 2\n  }, _t = getElementGuidelines(o), vt = __spreadArray([], _t, !0);\n  X && vt.push.apply(vt, getGapGuidelines(o, gt, K)), vt.push.apply(vt, getGridGuidelines(J, rt, S ? D : B, S ? T : N, $, U));\n  var mt = __assign$1({}, t.snapOffset || {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  });\n  if (r) {\n    var bt = e.left, Ct = e.top;\n    mt.left += bt, mt.top += Ct, mt.right += bt, mt.bottom += Ct;\n  }\n  return vt.push.apply(vt, getDefaultGuidelines(W || !1, Y || !1, S ? D : B, S ? T : N, $, U, mt)), vt = vt.filter(function(St) {\n    var pt = St.element, yt = St.elementRect, At = St.type;\n    if (!pt || !yt)\n      return !0;\n    var Dt = yt.rect;\n    return checkBetweenRects(gt, Dt, At, nt);\n  }), vt;\n}\nfunction getGapGuidelines(o, t, e) {\n  var r = o.props, S = r.maxSnapElementGuidelineDistance, T = S === void 0 ? 1 / 0 : S, D = r.maxSnapElementGapDistance, N = D === void 0 ? 1 / 0 : D, B = o.state.elementRects, $ = [];\n  return [[\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(U) {\n    var V = U[0], H = U[1], X = U[2], Y = t[H.start], W = t[H.end], q = t[H.center], K = t[X.start], Z = t[X.end];\n    function J(et) {\n      var nt = et.rect;\n      return nt[H.end] < Y + e ? Y - nt[H.end] : W - e < nt[H.start] ? nt[H.start] - W : -1;\n    }\n    var Q = B.filter(function(et) {\n      var nt = et.rect;\n      return nt[X.start] > Z || nt[X.end] < K ? !1 : J(et) > 0;\n    }).sort(function(et, nt) {\n      return J(et) - J(nt);\n    }), rt = [];\n    Q.forEach(function(et) {\n      Q.forEach(function(nt) {\n        if (et !== nt) {\n          var st = et.rect, it = nt.rect, at = st[X.start], ut = st[X.end], ct = it[X.start], gt = it[X.end];\n          at > gt || ct > ut || rt.push([et, nt]);\n        }\n      });\n    }), rt.forEach(function(et) {\n      var nt = et[0], st = et[1], it = nt.rect, at = st.rect, ut = it[H.start], ct = it[H.end], gt = at[H.start], _t = at[H.end], vt = 0, mt = 0, bt = !1, Ct = !1, St = !1;\n      if (ct <= Y && W <= gt) {\n        if (Ct = !0, vt = (gt - ct - (W - Y)) / 2, mt = ct + vt + (W - Y) / 2, Math.abs(mt - q) > e)\n          return;\n      } else if (ct < gt && _t < Y + e) {\n        if (bt = !0, vt = gt - ct, mt = _t + vt, Math.abs(mt - Y) > e)\n          return;\n      } else if (ct < gt && W - e < ut) {\n        if (St = !0, vt = gt - ct, mt = ut - vt, Math.abs(mt - W) > e)\n          return;\n      } else\n        return;\n      !vt || !checkBetweenRects(t, at, V, T) || vt > N || $.push({\n        type: V,\n        pos: V === \"vertical\" ? [mt, 0] : [0, mt],\n        element: st.element,\n        size: 0,\n        className: st.className,\n        isStart: bt,\n        isCenter: Ct,\n        isEnd: St,\n        gap: vt,\n        hide: !0,\n        gapRects: [nt, st]\n      });\n    });\n  }), $;\n}\nfunction getGridGuidelines(o, t, e, r, S, T) {\n  S === void 0 && (S = 0), T === void 0 && (T = 0);\n  var D = [];\n  if (t)\n    for (var N = 0; N <= r; N += t)\n      D.push({\n        type: \"horizontal\",\n        pos: [0, throttle(N - T, 0.1)],\n        size: e,\n        hide: !0\n      });\n  if (o)\n    for (var N = 0; N <= e; N += o)\n      D.push({\n        type: \"vertical\",\n        pos: [throttle(N - S, 0.1), 0],\n        size: r,\n        hide: !0\n      });\n  return D;\n}\nfunction checkBetweenRects(o, t, e, r) {\n  return e === \"horizontal\" ? Math.abs(o.right - t.left) <= r || Math.abs(o.left - t.right) <= r || o.left <= t.right && t.left <= o.right : e === \"vertical\" ? Math.abs(o.bottom - t.top) <= r || Math.abs(o.top - t.bottom) <= r || o.top <= t.bottom && t.top <= o.bottom : !0;\n}\nfunction getElementGuidelines(o) {\n  var t = o.state, e = o.props.elementGuidelines, r = e === void 0 ? [] : e;\n  if (!r.length)\n    return t.elementRects = [], [];\n  var S = (t.elementRects || []).filter(function(H) {\n    return !H.refresh;\n  }), T = r.map(function(H) {\n    return isObject$2(H) && \"element\" in H ? __assign$1(__assign$1({}, H), {\n      element: getRefTarget(H.element, !0)\n    }) : {\n      element: getRefTarget(H, !0)\n    };\n  }).filter(function(H) {\n    return H.element;\n  }), D = diff(S.map(function(H) {\n    return H.element;\n  }), T.map(function(H) {\n    return H.element;\n  })), N = D.maintained, B = D.added, $ = [];\n  N.forEach(function(H) {\n    var X = H[0], Y = H[1];\n    $[Y] = S[X];\n  }), getSnapElementRects(o, B.map(function(H) {\n    return T[H];\n  })).map(function(H, X) {\n    $[B[X]] = H;\n  }), t.elementRects = $;\n  var U = getSnapDirections(o.props.elementSnapDirections), V = [];\n  return $.forEach(function(H) {\n    var X = H.element, Y = H.top, W = Y === void 0 ? U.top : Y, q = H.left, K = q === void 0 ? U.left : q, Z = H.right, J = Z === void 0 ? U.right : Z, Q = H.bottom, rt = Q === void 0 ? U.bottom : Q, et = H.center, nt = et === void 0 ? U.center : et, st = H.middle, it = st === void 0 ? U.middle : st, at = H.className, ut = H.rect, ct = splitSnapDirectionPoses({\n      top: W,\n      right: J,\n      left: K,\n      bottom: rt,\n      center: nt,\n      middle: it\n    }, ut), gt = ct.horizontal, _t = ct.vertical, vt = ut.top, mt = ut.left, bt = ut.right - mt, Ct = ut.bottom - vt, St = [bt, Ct];\n    _t.forEach(function(pt) {\n      V.push({\n        type: \"vertical\",\n        element: X,\n        pos: [throttle(pt, 0.1), vt],\n        size: Ct,\n        sizes: St,\n        className: at,\n        elementRect: H\n      });\n    }), gt.forEach(function(pt) {\n      V.push({\n        type: \"horizontal\",\n        element: X,\n        pos: [mt, throttle(pt, 0.1)],\n        size: bt,\n        sizes: St,\n        className: at,\n        elementRect: H\n      });\n    });\n  }), V;\n}\nfunction getDefaultGuidelines(o, t, e, r, S, T, D) {\n  S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  });\n  var N = [], B = D.left, $ = D.top, U = D.bottom, V = D.right, H = e + V - B, X = r + U - $;\n  return o && o.forEach(function(Y) {\n    var W = isObject$2(Y) ? Y : {\n      pos: Y\n    };\n    N.push({\n      type: \"horizontal\",\n      pos: [B, throttle(W.pos - T + $, 0.1)],\n      size: H,\n      className: W.className\n    });\n  }), t && t.forEach(function(Y) {\n    var W = isObject$2(Y) ? Y : {\n      pos: Y\n    };\n    N.push({\n      type: \"vertical\",\n      pos: [throttle(W.pos - S + B, 0.1), $],\n      size: X,\n      className: W.className\n    });\n  }), N;\n}\nfunction getSnapElementRects(o, t) {\n  if (!t.length)\n    return [];\n  var e = o.state, r = e.containerClientRect, S = e.targetClientRect, T = S.top, D = S.left, N = e.rootMatrix, B = e.is3d, $ = B ? 4 : 3, U = calculateContainerPos(N, r, $), V = U[0], H = U[1], X = getAbsolutePosesByState(e), Y = getMinMaxs(X), W = Y.minX, q = Y.minY, K = minus([W, q], calculateInversePosition(N, [D - V, T - H], $)).map(function(Q) {\n    return roundSign(Q);\n  }), Z = K[0], J = K[1];\n  return t.map(function(Q) {\n    var rt = Q.element.getBoundingClientRect(), et = rt.left - V, nt = rt.top - H, st = nt + rt.height, it = et + rt.width, at = calculateInversePosition(N, [et, nt], $), ut = at[0], ct = at[1], gt = calculateInversePosition(N, [it, st], $), _t = gt[0], vt = gt[1];\n    return __assign$1(__assign$1({}, Q), {\n      rect: {\n        left: ut + Z,\n        right: _t + Z,\n        top: ct + J,\n        bottom: vt + J,\n        center: (ut + _t) / 2 + Z,\n        middle: (ct + vt) / 2 + J\n      }\n    });\n  });\n}\nfunction checkSnapInfo(o) {\n  var t = o.state, e = t.container, r = o.props.snapContainer || e;\n  if (t.snapContainer === r && t.guidelines && t.guidelines.length)\n    return !1;\n  var S = t.containerClientRect, T = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n  if (e !== r) {\n    var D = getRefTarget(r, !0);\n    if (D) {\n      var N = getClientRect(D), B = getDragDistByState(t, [N.left - S.left, N.top - S.top]), $ = getDragDistByState(t, [N.right - S.right, N.bottom - S.bottom]);\n      T.left = throttle(B[0], 1e-5), T.top = throttle(B[1], 1e-5), T.right = throttle($[0], 1e-5), T.bottom = throttle($[1], 1e-5);\n    }\n  }\n  return t.snapContainer = r, t.snapOffset = T, t.guidelines = getTotalGuidelines(o), t.enableSnap = !0, !0;\n}\nfunction getNextFixedPoses(o, t, e, r, S, T) {\n  var D = calculatePoses(o, t, e, T ? 4 : 3), N = getPosByDirection(D, r);\n  return getAbsolutePoses(D, minus(S, N));\n}\nfunction getSizeOffsetInfo(o, t, e, r, S, T) {\n  var D = T.fixedDirection, N = getCheckSnapDirections(e, D, r), B = getCheckInnerBoundLineInfos(o, t, e, r), $ = __spreadArray(__spreadArray([], getSnapBoundInfo(o, t, N, r, S, T), !0), getInnerBoundInfo(o, B, T), !0), U = getNearOffsetInfo($, 0), V = getNearOffsetInfo($, 1);\n  return {\n    width: {\n      isBound: U.isBound,\n      offset: U.offset[0]\n    },\n    height: {\n      isBound: V.isBound,\n      offset: V.offset[1]\n    }\n  };\n}\nfunction recheckSizeByTwoDirection(o, t, e, r, S, T, D, N, B) {\n  var $ = getPosByDirection(t, D), U = checkMoveableSnapBounds(o, N, {\n    vertical: [$[0]],\n    horizontal: [$[1]]\n  }), V = U.horizontal.offset, H = U.vertical.offset;\n  if (throttle(H, FLOAT_POINT_NUM) || throttle(V, FLOAT_POINT_NUM)) {\n    var X = getDragDist({\n      datas: B,\n      distX: -H,\n      distY: -V\n    }), Y = X[0], W = X[1], q = Math.min(S || 1 / 0, e + D[0] * Y), K = Math.min(T || 1 / 0, r + D[1] * W);\n    return [q - e, K - r];\n  }\n  return [0, 0];\n}\nfunction checkSizeDist(o, t, e, r, S, T, D, N) {\n  for (var B = getAbsolutePosesByState(o.state), $ = o.props.keepRatio, U = 0, V = 0, H = 0; H < 2; ++H) {\n    var X = t(U, V), Y = getSizeOffsetInfo(o, X, S, $, D, N), W = Y.width, q = Y.height, K = W.isBound, Z = q.isBound, J = W.offset, Q = q.offset;\n    if (H === 1 && (K || (J = 0), Z || (Q = 0)), H === 0 && D && !K && !Z)\n      return [0, 0];\n    if ($) {\n      var rt = Math.abs(J) * (e ? 1 / e : 1), et = Math.abs(Q) * (r ? 1 / r : 1), nt = K && Z ? rt < et : Z || !K && rt < et;\n      nt ? J = e * Q / r : Q = r * J / e;\n    }\n    U += J, V += Q;\n  }\n  if (S[0] && S[1]) {\n    var st = checkMaxBounds(o, B, S, T, N), it = st.maxWidth, at = st.maxHeight, ut = recheckSizeByTwoDirection(o, t(U, V).map(function(_t) {\n      return _t.map(function(vt) {\n        return throttle(vt, FLOAT_POINT_NUM);\n      });\n    }), e + U, r + V, it, at, S, D, N), J = ut[0], Q = ut[1];\n    U += J, V += Q;\n  }\n  return [U, V];\n}\nfunction checkSnapRotate(o, t, e) {\n  if (!hasGuidelines(o, \"rotatable\"))\n    return {\n      isSnap: !1,\n      rotation: e\n    };\n  var r = t.pos1, S = t.pos2, T = t.pos3, D = t.pos4, N = t.origin, B = e * Math.PI / 180, $ = [r, S, T, D].map(function(X) {\n    return minus(X, N);\n  }), U = $.map(function(X) {\n    return rotate(X, B);\n  }), V = __spreadArray(__spreadArray([], checkRotateBounds(o, $, U, N, e), !0), checkRotateInnerBounds(o, $, U, N, e), !0);\n  V.sort(function(X, Y) {\n    return Math.abs(X - e) - Math.abs(Y - e);\n  });\n  var H = V.length > 0;\n  return {\n    isSnap: H,\n    rotation: H ? V[0] : e\n  };\n}\nfunction checkSnapResize(o, t, e, r, S, T, D) {\n  if (!hasGuidelines(o, \"resizable\"))\n    return [0, 0];\n  var N = D.fixedDirection, B = D.nextAllMatrix, $ = o.state, U = $.allMatrix, V = $.is3d;\n  return checkSizeDist(o, function(H, X) {\n    return getNextFixedPoses(B || U, t + H, e + X, N, S, V);\n  }, t, e, r, S, T, D);\n}\nfunction checkSnapScale(o, t, e, r, S) {\n  if (!hasGuidelines(o, \"scalable\"))\n    return [0, 0];\n  var T = S.startOffsetWidth, D = S.startOffsetHeight, N = S.fixedPosition, B = S.fixedDirection, $ = S.is3d, U = checkSizeDist(o, function(V, H) {\n    return getNextFixedPoses(scaleMatrix(S, plus(t, [V / T, H / D])), T, D, B, N, $);\n  }, T, D, e, N, r, S);\n  return [U[0] / T, U[1] / D];\n}\nfunction startCheckSnapDrag(o, t) {\n  t.absolutePoses = getAbsolutePosesByState(o.state);\n}\nfunction getSnapGuidelines(o) {\n  var t = [];\n  return o.forEach(function(e) {\n    e.guidelineInfos.forEach(function(r) {\n      var S = r.guideline;\n      t.indexOf(S) > -1 || t.push(S);\n    });\n  }), t;\n}\nfunction addBoundGuidelines(o, t, e, r, S, T) {\n  var D = checkBoundPoses(getBounds(o, T), t, e), N = D.vertical, B = D.horizontal;\n  N.forEach(function(H) {\n    H.isBound && r.push({\n      type: \"bounds\",\n      pos: H.pos\n    });\n  }), B.forEach(function(H) {\n    H.isBound && S.push({\n      type: \"bounds\",\n      pos: H.pos\n    });\n  });\n  var $ = checkInnerBoundPoses(o), U = $.vertical, V = $.horizontal;\n  U.forEach(function(H) {\n    findIndex(r, function(X) {\n      var Y = X.type, W = X.pos;\n      return Y === \"bounds\" && W === H;\n    }) >= 0 || r.push({\n      type: \"bounds\",\n      pos: H\n    });\n  }), V.forEach(function(H) {\n    findIndex(S, function(X) {\n      var Y = X.type, W = X.pos;\n      return Y === \"bounds\" && W === H;\n    }) >= 0 || S.push({\n      type: \"bounds\",\n      pos: H\n    });\n  });\n}\nvar directionCondition$2 = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]), Snappable = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapDirections: [Boolean, Object],\n    elementSnapDirections: [Boolean, Object],\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    snapRenderThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function,\n    maxSnapElementGuidelineDistance: Number,\n    maxSnapElementGapDistance: Number\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [`:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`],\n  render: function(o, t) {\n    var e = o.state, r = e.top, S = e.left, T = e.pos1, D = e.pos2, N = e.pos3, B = e.pos4, $ = e.snapRenderInfo, U = o.props.snapRenderThreshold, V = U === void 0 ? 1 : U;\n    if (!$ || !hasGuidelines(o, \"\"))\n      return [];\n    e.guidelines = getTotalGuidelines(o);\n    var H = Math.min(T[0], D[0], N[0], B[0]), X = Math.min(T[1], D[1], N[1], B[1]), Y = $.externalPoses || [], W = getAbsolutePosesByState(o.state), q = [], K = [], Z = [], J = [], Q = [], rt = getRect(W), et = rt.width, nt = rt.height, st = rt.top, it = rt.left, at = rt.bottom, ut = rt.right, ct = {\n      left: it,\n      right: ut,\n      top: st,\n      bottom: at,\n      center: (it + ut) / 2,\n      middle: (st + at) / 2\n    }, gt = Y.length > 0, _t = gt ? getRect(Y) : {};\n    if (!$.request) {\n      if ($.direction && Q.push(getSnapInfosByDirection(o, W, $.direction, V)), $.snap) {\n        var vt = getRect(W);\n        $.center && (vt.middle = (vt.top + vt.bottom) / 2, vt.center = (vt.left + vt.right) / 2), Q.push(checkSnaps(o, vt, V));\n      }\n      gt && ($.center && (_t.middle = (_t.top + _t.bottom) / 2, _t.center = (_t.left + _t.right) / 2), Q.push(checkSnaps(o, _t, V))), Q.forEach(function(St) {\n        var pt = St.vertical.posInfos, yt = St.horizontal.posInfos;\n        q.push.apply(q, pt.filter(function(At) {\n          var Dt = At.guidelineInfos;\n          return Dt.some(function(Ot) {\n            var Pt = Ot.guideline;\n            return !Pt.hide;\n          });\n        }).map(function(At) {\n          return {\n            type: \"snap\",\n            pos: At.pos\n          };\n        })), K.push.apply(K, yt.filter(function(At) {\n          var Dt = At.guidelineInfos;\n          return Dt.some(function(Ot) {\n            var Pt = Ot.guideline;\n            return !Pt.hide;\n          });\n        }).map(function(At) {\n          return {\n            type: \"snap\",\n            pos: At.pos\n          };\n        })), Z.push.apply(Z, getSnapGuidelines(pt)), J.push.apply(J, getSnapGuidelines(yt));\n      });\n    }\n    addBoundGuidelines(o, [it, ut], [st, at], q, K), gt && addBoundGuidelines(o, [_t.left, _t.right], [_t.top, _t.bottom], q, K, $.externalBounds);\n    var mt = __spreadArray(__spreadArray([], Z, !0), J, !0), bt = mt.filter(function(St) {\n      return St.element && !St.gapRects;\n    }), Ct = mt.filter(function(St) {\n      return St.gapRects;\n    }).sort(function(St, pt) {\n      return St.gap - pt.gap;\n    });\n    return triggerEvent(o, \"onSnap\", {\n      guidelines: mt.filter(function(St) {\n        var pt = St.element;\n        return !pt;\n      }),\n      elements: bt,\n      gaps: Ct\n    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(o, bt, [H, X], ct, t), !0), renderGapGuidelines(o, Ct, [H, X], ct, t), !0), renderGuidelines(o, \"horizontal\", J, [S, r], ct, t), !0), renderGuidelines(o, \"vertical\", Z, [S, r], ct, t), !0), renderSnapPoses(o, \"horizontal\", K, H, r, et, 0, t), !0), renderSnapPoses(o, \"vertical\", q, X, S, nt, 1, t), !0);\n  },\n  dragStart: function(o, t) {\n    o.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, checkSnapInfo(o);\n  },\n  drag: function(o) {\n    var t = o.state;\n    checkSnapInfo(o) || (t.guidelines = getTotalGuidelines(o));\n  },\n  pinchStart: function(o) {\n    this.unset(o);\n  },\n  dragEnd: function(o) {\n    this.unset(o);\n  },\n  dragControlCondition: function(o, t) {\n    if (directionCondition$2(o, t) || dragControlCondition(o, t))\n      return !0;\n    if (!t.isRequest && t.inputEvent)\n      return hasClass(t.inputEvent.target, prefix(\"snap-control\"));\n  },\n  dragControlStart: function(o) {\n    o.state.snapRenderInfo = null, checkSnapInfo(o);\n  },\n  dragControl: function(o) {\n    this.drag(o);\n  },\n  dragControlEnd: function(o) {\n    this.unset(o);\n  },\n  dragGroupStart: function(o, t) {\n    this.dragStart(o, t);\n  },\n  dragGroup: function(o) {\n    this.drag(o);\n  },\n  dragGroupEnd: function(o) {\n    this.unset(o);\n  },\n  dragGroupControlStart: function(o) {\n    o.state.snapRenderInfo = null, checkSnapInfo(o);\n  },\n  dragGroupControl: function(o) {\n    this.drag(o);\n  },\n  dragGroupControlEnd: function(o) {\n    this.unset(o);\n  },\n  unset: function(o) {\n    var t = o.state;\n    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];\n  }\n};\nfunction renderDirectionControlsByInfos(o, t, e, r) {\n  var S = o.getState(), T = S.renderPoses, D = S.rotation, N = S.direction, B = getProps(o.props, t).zoom, $ = N > 0 ? 1 : -1, U = D / Math.PI * 180, V = {}, H = o.renderState;\n  H.renderDirectionMap || (H.renderDirectionMap = {});\n  var X = H.renderDirectionMap;\n  return e.forEach(function(Y) {\n    var W = Y.dir;\n    V[W] = !0;\n  }), e.map(function(Y) {\n    var W = Y.data, q = Y.classNames, K = Y.dir, Z = DIRECTION_INDEXES[K];\n    if (!Z || !V[K])\n      return null;\n    X[K] = !0;\n    var J = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[K] + 720) % 180, Q = {};\n    return getKeys(W).forEach(function(rt) {\n      Q[\"data-\".concat(rt)] = W[rt];\n    }), r.createElement(\"div\", __assign$1({\n      className: prefix.apply(void 0, __spreadArray([\"control\", \"direction\", K, t], q, !1)),\n      \"data-rotation\": J,\n      \"data-direction\": K\n    }, Q, {\n      key: \"direction-\".concat(K),\n      style: getControlTransform.apply(void 0, __spreadArray([D, B], Z.map(function(rt) {\n        return T[rt];\n      }), !1))\n    }));\n  });\n}\nfunction renderDirectionControls(o, t, e, r) {\n  var S = getProps(o.props, e).renderDirections, T = S === void 0 ? t : S;\n  if (!T)\n    return [];\n  var D = T === !0 ? DIRECTIONS : T;\n  return renderDirectionControlsByInfos(o, e, D.map(function(N) {\n    return {\n      data: {},\n      classNames: [],\n      dir: N\n    };\n  }), r);\n}\nfunction renderAroundControls(o, t) {\n  var e = o.renderState;\n  e.renderDirectionMap || (e.renderDirectionMap = {});\n  var r = o.getState(), S = r.renderPoses, T = r.rotation, D = r.direction, N = e.renderDirectionMap, B = o.props.zoom, $ = D > 0 ? 1 : -1, U = T / Math.PI * 180;\n  return getKeys(N).map(function(V) {\n    var H = DIRECTION_INDEXES[V];\n    if (!H)\n      return null;\n    var X = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[V] + 720) % 180;\n    return t.createElement(\"div\", {\n      className: prefix(\"around-control\"),\n      \"data-rotation\": X,\n      \"data-direction\": V,\n      key: \"direction-around-\".concat(V),\n      style: getControlTransform.apply(void 0, __spreadArray([T, B], H.map(function(Y) {\n        return S[Y];\n      }), !1))\n    });\n  });\n}\nfunction renderLine(o, t, e, r, S, T) {\n  for (var D = [], N = 6; N < arguments.length; N++)\n    D[N - 6] = arguments[N];\n  var B = getRad$1(e, r), $ = t ? throttle(B / Math.PI * 180, 15) % 180 : -1;\n  return o.createElement(\"div\", {\n    key: \"line-\".concat(T),\n    className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", t ? \"edge\" : \"\", t], D, !1)),\n    \"data-rotation\": $,\n    \"data-line-key\": T,\n    \"data-direction\": t,\n    style: getLineStyle(e, r, S, B)\n  });\n}\nfunction renderEdgeLines(o, t, e, r, S) {\n  var T = e === !0 ? DIRECTIONS4 : e;\n  return T.map(function(D, N) {\n    var B = DIRECTION_INDEXES[D], $ = B[0], U = B[1];\n    if (U != null)\n      return renderLine(o, D, r[$], r[U], S, \"\".concat(t, \"Edge\").concat(N), t);\n  }).filter(Boolean);\n}\nfunction getRenderDirections(o) {\n  return function(t, e) {\n    var r = getProps(t.props, o).edge;\n    return r && (r === !0 || r.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, o, r, t.getState().renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, o, e), !0) : renderAllDirections(t, o, e);\n  };\n}\nfunction renderAllDirections(o, t, e) {\n  return renderDirectionControls(o, DIRECTIONS, t, e);\n}\nfunction renderDiagonalDirections(o, t, e) {\n  return renderDirectionControls(o, [\"nw\", \"ne\", \"sw\", \"se\"], t, e);\n}\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  requestStyle: function() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  render: function(o, t) {\n    var e = o.props, r = e.throttleDragRotate, S = e.zoom, T = o.getState(), D = T.dragInfo, N = T.beforeOrigin;\n    if (!r || !D)\n      return [];\n    var B = D.dist;\n    if (!B[0] && !B[1])\n      return [];\n    var $ = getDistSize(B), U = getRad$1(B, [0, 0]);\n    return [t.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat($, \"px\"),\n        transform: \"translate(\".concat(N[0], \"px, \").concat(N[1], \"px) rotate(\").concat(U, \"rad) scaleY(\").concat(S, \")\")\n      }\n    })];\n  },\n  dragStart: function(o, t) {\n    var e = t.datas, r = t.parentEvent, S = t.parentGesto, T = o.state, D = T.gestos, N = T.style;\n    if (D.draggable)\n      return !1;\n    D.draggable = S || o.targetGesto, e.datas = {}, e.left = parseFloat(N.left || \"\") || 0, e.top = parseFloat(N.top || \"\") || 0, e.bottom = parseFloat(N.bottom || \"\") || 0, e.right = parseFloat(N.right || \"\") || 0, e.startValue = [0, 0], setDragStart(o, t), setDefaultTransformIndex(t, \"translate\"), startCheckSnapDrag(o, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];\n    var B = fillParams(o, t, __assign$1({\n      set: function(U) {\n        e.startValue = U;\n      }\n    }, fillTransformStartEvent(t))), $ = r || triggerEvent(o, \"onDragStart\", B);\n    return $ !== !1 ? (e.isDrag = !0, o.state.dragInfo = {\n      startRect: o.getRect(),\n      dist: [0, 0]\n    }) : (D.draggable = null, e.isPinch = !1), e.isDrag ? B : !1;\n  },\n  drag: function(o, t) {\n    if (!!t) {\n      resolveTransformEvent(t, \"translate\");\n      var e = t.datas, r = t.parentEvent, S = t.parentFlag, T = t.isPinch, D = t.isRequest, N = t.deltaOffset, B = t.distX, $ = t.distY, U = e.isDrag, V = e.prevDist, H = e.prevBeforeDist, X = e.startValue;\n      if (!!U) {\n        N && (B += N[0], $ += N[1]);\n        var Y = o.props, W = Y.parentMoveable, q = r ? 0 : Y.throttleDrag || 0, K = r ? 0 : Y.throttleDragRotate || 0, Z = 0, J = !1, Q = !1, rt = !1, et = !1;\n        if (!r && K > 0 && (B || $)) {\n          var nt = Y.startDragRotate || 0, st = throttle(nt + getRad$1([0, 0], [B, $]) * 180 / Math.PI, K) - nt, it = $ * Math.abs(Math.cos((st - 90) / 180 * Math.PI)), at = B * Math.abs(Math.cos(st / 180 * Math.PI)), ut = getDistSize([at, it]);\n          Z = st * Math.PI / 180, B = ut * Math.cos(Z), $ = ut * Math.sin(Z);\n        }\n        if (!T && !r && !S) {\n          var ct = checkSnapBoundsDrag(o, B, $, K, D || N, e), gt = ct[0], _t = ct[1];\n          J = gt.isSnap, Q = gt.isBound, rt = _t.isSnap, et = _t.isBound;\n          var vt = gt.offset, mt = _t.offset;\n          B += vt, $ += mt;\n        }\n        var bt = plus(getBeforeDragDist({\n          datas: e,\n          distX: B,\n          distY: $\n        }), X), Ct = plus(getTransformDist({\n          datas: e,\n          distX: B,\n          distY: $\n        }), X);\n        throttleArray(Ct, TINY_NUM), throttleArray(bt, TINY_NUM), K || (!J && !Q && (Ct[0] = throttle(Ct[0], q), bt[0] = throttle(bt[0], q)), !rt && !et && (Ct[1] = throttle(Ct[1], q), bt[1] = throttle(bt[1], q)));\n        var St = minus(bt, X), pt = minus(Ct, X), yt = minus(pt, V), At = minus(St, H);\n        e.prevDist = pt, e.prevBeforeDist = St, e.passDelta = yt, e.passDist = pt;\n        var Dt = e.left + St[0], Ot = e.top + St[1], Pt = e.right - St[0], ft = e.bottom - St[1], Ft = convertTransformFormat(e, \"translate(\".concat(Ct[0], \"px, \").concat(Ct[1], \"px)\"), \"translate(\".concat(pt[0], \"px, \").concat(pt[1], \"px)\"));\n        if (fillOriginalTransform(t, Ft), o.state.dragInfo.dist = r ? [0, 0] : pt, !(!r && !W && yt.every(function(jt) {\n          return !jt;\n        }) && At.some(function(jt) {\n          return !jt;\n        }))) {\n          var It = o.state, zt = It.width, kt = It.height, Tt = fillParams(o, t, __assign$1({\n            transform: Ft,\n            dist: pt,\n            delta: yt,\n            translate: Ct,\n            beforeDist: St,\n            beforeDelta: At,\n            beforeTranslate: bt,\n            left: Dt,\n            top: Ot,\n            right: Pt,\n            bottom: ft,\n            width: zt,\n            height: kt,\n            isPinch: T\n          }, fillCSSObject({\n            transform: Ft\n          }, t)));\n          return !r && triggerEvent(o, \"onDrag\", Tt), Tt;\n        }\n      }\n    }\n  },\n  dragAfter: function(o, t) {\n    var e = t.datas, r = e.deltaOffset;\n    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(o, __assign$1(__assign$1({}, t), {\n      deltaOffset: r\n    }))) : !1;\n  },\n  dragEnd: function(o, t) {\n    var e = t.parentEvent, r = t.datas;\n    if (o.state.dragInfo = null, !!r.isDrag) {\n      r.isDrag = !1;\n      var S = fillEndParams(o, t, {});\n      return !e && triggerEvent(o, \"onDragEnd\", S), S;\n    }\n  },\n  dragGroupStart: function(o, t) {\n    var e = t.datas, r = t.clientX, S = t.clientY, T = this.dragStart(o, t);\n    if (!T)\n      return !1;\n    var D = triggerChildGesto(o, this, \"dragStart\", [r || 0, S || 0], t, !1, \"draggable\"), N = __assign$1(__assign$1({}, T), {\n      targets: o.props.targets,\n      events: D\n    }), B = triggerEvent(o, \"onDragGroupStart\", N);\n    return e.isDrag = B !== !1, e.isDrag ? T : !1;\n  },\n  dragGroup: function(o, t) {\n    var e = t.datas;\n    if (!!e.isDrag) {\n      var r = this.drag(o, t), S = t.datas.passDelta, T = triggerChildGesto(o, this, \"drag\", S, t, !1, \"draggable\");\n      if (!!r) {\n        var D = __assign$1({\n          targets: o.props.targets,\n          events: T\n        }, r);\n        return triggerEvent(o, \"onDragGroup\", D), D;\n      }\n    }\n  },\n  dragGroupEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (!!r.isDrag) {\n      this.dragEnd(o, t);\n      var S = triggerChildGesto(o, this, \"dragEnd\", [0, 0], t, !1, \"draggable\");\n      return triggerEvent(o, \"onDragGroupEnd\", fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: S\n      })), e;\n    }\n  },\n  request: function(o) {\n    var t = {}, e = o.getRect(), r = 0, S = 0;\n    return {\n      isControl: !1,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(T) {\n        return \"x\" in T ? r = T.x - e.left : \"deltaX\" in T && (r += T.deltaX), \"y\" in T ? S = T.y - e.top : \"deltaY\" in T && (S += T.deltaY), {\n          datas: t,\n          distX: r,\n          distY: S\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(o) {\n    o.state.gestos.draggable = null, o.state.dragInfo = null;\n  }\n}, directionCondition$1 = getDirectionCondition(\"resizable\"), Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean,\n    resizeFormat: Function,\n    keepRatioFinally: Boolean,\n    edge: Boolean,\n    checkResizableError: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onBeforeResize: \"beforeResize\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onBeforeResizeGroup: \"beforeResizeGroup\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: getRenderDirections(\"resizable\"),\n  dragControlCondition: directionCondition$1,\n  viewClassName: getDirectionViewClassName(\"resizable\"),\n  dragControlStart: function(o, t) {\n    var e, r = t.inputEvent, S = t.isPinch, T = t.isGroup, D = t.parentDirection, N = t.parentGesto, B = t.datas, $ = t.parentFixedDirection, U = t.parentEvent, V = getTotalDirection(D, S, r, B), H = o.state, X = H.target, Y = H.width, W = H.height, q = H.gestos;\n    if (!V || !X || q.resizable)\n      return !1;\n    q.resizable = N || o.controlGesto, !S && setDragStart(o, t), B.datas = {}, B.direction = V, B.startOffsetWidth = Y, B.startOffsetHeight = W, B.prevWidth = 0, B.prevHeight = 0, B.minSize = [0, 0], B.startWidth = H.inlineCSSWidth || H.cssWidth, B.startHeight = H.inlineCSSHeight || H.cssHeight, B.maxSize = [1 / 0, 1 / 0], T || (B.minSize = [H.minOffsetWidth, H.minOffsetHeight], B.maxSize = [H.maxOffsetWidth, H.maxOffsetHeight]);\n    var K = o.props.transformOrigin || \"% %\";\n    B.transformOrigin = K && isString$1(K) ? K.split(\" \") : K, B.startOffsetMatrix = H.offsetMatrix, B.startTransformOrigin = H.transformOrigin, B.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !V[0] && !V[1] || V[0] || !V[1];\n    function Z(it) {\n      B.ratio = it && isFinite(it) ? it : 0;\n    }\n    B.startPositions = getAbsolutePosesByState(o.state);\n    function J(it) {\n      B.fixedDirection = it, B.fixedPosition = getPosByDirection(B.startPositions, it);\n    }\n    function Q(it) {\n      var at = o.state, ut = at.width, ct = at.height;\n      B.fixedPosition = it, B.fixedDirection = getDirectionByPos(it, ut, ct);\n    }\n    function rt(it) {\n      B.minSize = [convertUnitSize(\"\".concat(it[0]), 0) || 0, convertUnitSize(\"\".concat(it[1]), 0) || 0];\n    }\n    function et(it) {\n      var at = [it[0] || 1 / 0, it[1] || 1 / 0];\n      (!isNumber(at[0]) || isFinite(at[0])) && (at[0] = convertUnitSize(\"\".concat(at[0]), 0) || 1 / 0), (!isNumber(at[1]) || isFinite(at[1])) && (at[1] = convertUnitSize(\"\".concat(at[1]), 0) || 1 / 0), B.maxSize = at;\n    }\n    Z(Y / W), J($ || [-V[0], -V[1]]), B.setFixedDirection = J, B.setFixedPosition = Q, B.setMin = rt, B.setMax = et;\n    var nt = fillParams(o, t, {\n      direction: V,\n      startRatio: B.ratio,\n      set: function(it) {\n        var at = it[0], ut = it[1];\n        B.startWidth = at, B.startHeight = ut;\n      },\n      setMin: rt,\n      setMax: et,\n      setRatio: Z,\n      setFixedDirection: J,\n      setFixedPosition: Q,\n      setOrigin: function(it) {\n        B.transformOrigin = it;\n      },\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    }), st = U || triggerEvent(o, \"onResizeStart\", nt);\n    return B.startFixedDirection = B.fixedDirection, B.startFixedPosition = B.fixedPosition, st !== !1 && (B.isResize = !0, o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: V\n    }), B.isResize ? nt : !1;\n  },\n  dragControl: function(o, t) {\n    var e, r = t.datas, S = t.parentFlag, T = t.isPinch, D = t.parentKeepRatio, N = t.dragClient, B = t.parentDist, $ = t.isRequest, U = t.isGroup, V = t.parentEvent, H = t.resolveMatrix, X = r.isResize, Y = r.transformOrigin, W = r.startWidth, q = r.startHeight, K = r.prevWidth, Z = r.prevHeight, J = r.minSize, Q = r.maxSize, rt = r.ratio, et = r.startOffsetWidth, nt = r.startOffsetHeight, st = r.isWidth;\n    if (!X)\n      return;\n    if (H) {\n      var it = o.state.is3d, at = r.startOffsetMatrix, ut = r.startTransformOrigin, ct = it ? 4 : 3, gt = parseMat(getNextTransforms(t)), _t = Math.sqrt(gt.length);\n      ct !== _t && (gt = convertDimension(gt, _t, ct));\n      var vt = getNextMatrix(at, gt, ut, ct), mt = calculatePoses(vt, et, nt, ct);\n      r.startPositions = mt, r.nextTargetMatrix = gt, r.nextAllMatrix = vt;\n    }\n    var bt = getProps(o.props, \"resizable\"), Ct = bt.resizeFormat, St = bt.throttleResize, pt = St === void 0 ? S ? 0 : 1 : St, yt = bt.parentMoveable, At = bt.keepRatioFinally, Dt = r.direction, Ot = Dt, Pt = 0, ft = 0;\n    !Dt[0] && !Dt[1] && (Ot = [1, 1]);\n    var Ft = rt && (D ?? bt.keepRatio) || !1;\n    function It() {\n      var ue = r.fixedDirection, me = getOffsetSizeDist(Ot, Ft, r, t);\n      Pt = me.distWidth, ft = me.distHeight;\n      var pe = Ot[0] - ue[0] || Ft ? Math.max(et + Pt, TINY_NUM) : et, fe = Ot[1] - ue[1] || Ft ? Math.max(nt + ft, TINY_NUM) : nt;\n      return Ft && et && nt && (st ? fe = pe / rt : pe = fe * rt), [pe, fe];\n    }\n    var zt = It(), kt = zt[0], Tt = zt[1];\n    V || (r.setFixedDirection(r.fixedDirection), triggerEvent(o, \"onBeforeResize\", fillParams(o, t, {\n      startFixedDirection: r.startFixedDirection,\n      startFixedPosition: r.startFixedPosition,\n      setFixedDirection: function(ue) {\n        var me;\n        return r.setFixedDirection(ue), me = It(), kt = me[0], Tt = me[1], [kt, Tt];\n      },\n      setFixedPosition: function(ue) {\n        var me;\n        return r.setFixedPosition(ue), me = It(), kt = me[0], Tt = me[1], [kt, Tt];\n      },\n      boundingWidth: kt,\n      boundingHeight: Tt,\n      setSize: function(ue) {\n        kt = ue[0], Tt = ue[1];\n      }\n    }, !0)));\n    var jt = N;\n    N || (!S && T ? jt = getAbsolutePosition(o, [0, 0]) : jt = r.fixedPosition);\n    var Nt = [0, 0];\n    T || (Nt = checkSnapResize(o, kt, Tt, Dt, jt, $, r)), B && (!B[0] && (Nt[0] = 0), !B[1] && (Nt[1] = 0));\n    function Et() {\n      var ue;\n      Ct && (ue = Ct([kt, Tt]), kt = ue[0], Tt = ue[1]), kt = throttle(kt, pt), Tt = throttle(Tt, pt);\n    }\n    if (Ft) {\n      Ot[0] && Ot[1] && Nt[0] && Nt[1] && (Math.abs(Nt[0]) > Math.abs(Nt[1]) ? Nt[1] = 0 : Nt[0] = 0);\n      var Lt = !Nt[0] && !Nt[1];\n      Lt && Et(), Ot[0] && !Ot[1] || Nt[0] && !Nt[1] || Lt && st ? (kt += Nt[0], Tt = kt / rt) : (!Ot[0] && Ot[1] || !Nt[0] && Nt[1] || Lt && !st) && (Tt += Nt[1], kt = Tt * rt);\n    } else\n      kt += Nt[0], Tt += Nt[1], kt = Math.max(0, kt), Tt = Math.max(0, Tt);\n    e = calculateBoundSize([kt, Tt], J, Q, Ft ? rt : !1), kt = e[0], Tt = e[1], Et(), Ft && (U || At) && (st ? Tt = kt / rt : kt = Tt * rt), Pt = kt - et, ft = Tt - nt;\n    var Ht = [Pt - K, ft - Z];\n    r.prevWidth = Pt, r.prevHeight = ft;\n    var wt = getResizeDist(o, kt, Tt, jt, Y, r);\n    if (!(!yt && Ht.every(function(ue) {\n      return !ue;\n    }) && wt.every(function(ue) {\n      return !ue;\n    }))) {\n      var Wt = Draggable.drag(o, setCustomDrag(t, o.state, wt, !!T, !1, \"draggable\")), ee = Wt.transform, Jt = W + Pt, xe = q + ft, ke = fillParams(o, t, __assign$1({\n        width: Jt,\n        height: xe,\n        offsetWidth: Math.round(kt),\n        offsetHeight: Math.round(Tt),\n        startRatio: rt,\n        boundingWidth: kt,\n        boundingHeight: Tt,\n        direction: Dt,\n        dist: [Pt, ft],\n        delta: Ht,\n        isPinch: !!T,\n        drag: Wt\n      }, fillAfterTransform({\n        style: {\n          width: \"\".concat(Jt, \"px\"),\n          height: \"\".concat(xe, \"px\")\n        },\n        transform: ee\n      }, Wt, t)));\n      return !V && triggerEvent(o, \"onResize\", ke), ke;\n    }\n  },\n  dragControlAfter: function(o, t) {\n    var e = t.datas, r = e.isResize, S = e.startOffsetWidth, T = e.startOffsetHeight, D = e.prevWidth, N = e.prevHeight;\n    if (!(!r || o.props.checkResizableError === !1)) {\n      var B = o.state, $ = B.width, U = B.height, V = $ - (S + D), H = U - (T + N), X = Math.abs(V) > 3, Y = Math.abs(H) > 3;\n      if (X && (e.startWidth += V, e.startOffsetWidth += V, e.prevWidth += V), Y && (e.startHeight += H, e.startOffsetHeight += H, e.prevHeight += H), X || Y)\n        return this.dragControl(o, t);\n    }\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas, r = t.parentEvent;\n    if (!!e.isResize) {\n      e.isResize = !1;\n      var S = fillEndParams(o, t, {});\n      return !r && triggerEvent(o, \"onResizeEnd\", S), S;\n    }\n  },\n  dragGroupControlCondition: directionCondition$1,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = this.dragControlStart(o, __assign$1(__assign$1({}, t), {\n      isGroup: !0\n    }));\n    if (!r)\n      return !1;\n    var S = fillChildEvents(o, \"resizable\", t);\n    function T(Y, W) {\n      var q = e.fixedDirection, K = e.fixedPosition, Z = W.datas.startPositions || getAbsolutePosesByState(Y.state), J = getPosByDirection(Z, q), Q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [J[0] - K[0], J[1] - K[1], 1], 3), rt = Q[0], et = Q[1];\n      return W.datas.originalX = rt, W.datas.originalY = et, W;\n    }\n    var D = e.startOffsetWidth, N = e.startOffsetHeight;\n    function B() {\n      var Y = e.minSize;\n      S.forEach(function(W) {\n        var q = W.datas, K = q.minSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (Z ? K[0] / Z : 0), rt = N * (J ? K[1] / J : 0);\n        Y[0] = Math.max(Y[0], Q), Y[1] = Math.max(Y[1], rt);\n      });\n    }\n    function $() {\n      var Y = e.maxSize;\n      S.forEach(function(W) {\n        var q = W.datas, K = q.maxSize, Z = q.startOffsetWidth, J = q.startOffsetHeight, Q = D * (Z ? K[0] / Z : 0), rt = N * (J ? K[1] / J : 0);\n        Y[0] = Math.min(Y[0], Q), Y[1] = Math.min(Y[1], rt);\n      });\n    }\n    var U = triggerChildAbles(o, this, \"dragControlStart\", t, function(Y, W) {\n      return T(Y, W);\n    });\n    B(), $();\n    var V = function(Y) {\n      r.setFixedDirection(Y), U.forEach(function(W, q) {\n        W.setFixedDirection(Y), T(W.moveable, S[q]);\n      });\n    };\n    e.setFixedDirection = V;\n    var H = __assign$1(__assign$1({}, r), {\n      targets: o.props.targets,\n      events: U.map(function(Y) {\n        return __assign$1(__assign$1({}, Y), {\n          setMin: function(W) {\n            Y.setMin(W), B();\n          },\n          setMax: function(W) {\n            Y.setMax(W), $();\n          }\n        });\n      }),\n      setFixedDirection: V,\n      setMin: function(Y) {\n        r.setMin(Y), B();\n      },\n      setMax: function(Y) {\n        r.setMax(Y), $();\n      }\n    }), X = triggerEvent(o, \"onResizeGroupStart\", H);\n    return e.isResize = X !== !1, e.isResize ? r : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (!!e.isResize) {\n      var r = getProps(o.props, \"resizable\");\n      catchEvent(o, \"onBeforeResize\", function(X) {\n        triggerEvent(o, \"onBeforeResizeGroup\", fillParams(o, t, __assign$1(__assign$1({}, X), {\n          targets: r.targets\n        }), !0));\n      });\n      var S = this.dragControl(o, __assign$1(__assign$1({}, t), {\n        isGroup: !0\n      }));\n      if (!!S) {\n        var T = S.boundingWidth, D = S.boundingHeight, N = S.dist, B = r.keepRatio, $ = [T / (T - N[0]), D / (D - N[1])], U = e.fixedPosition, V = triggerChildAbles(o, this, \"dragControl\", t, function(X, Y) {\n          var W = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [Y.datas.originalX * $[0], Y.datas.originalY * $[1], 1], 3), q = W[0], K = W[1];\n          return __assign$1(__assign$1({}, Y), {\n            parentDist: null,\n            parentScale: $,\n            dragClient: plus(U, [q, K]),\n            parentKeepRatio: B\n          });\n        }), H = __assign$1({\n          targets: r.targets,\n          events: V\n        }, S);\n        return triggerEvent(o, \"onResizeGroup\", H), H;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (!!r.isResize) {\n      this.dragControlEnd(o, t);\n      var S = triggerChildAbles(o, this, \"dragControlEnd\", t), T = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: S\n      });\n      return triggerEvent(o, \"onResizeGroupEnd\", T), e;\n    }\n  },\n  request: function(o) {\n    var t = {}, e = 0, r = 0, S = o.getRect();\n    return {\n      isControl: !0,\n      requestStart: function(T) {\n        var D;\n        return {\n          datas: t,\n          parentDirection: T.direction || [1, 1],\n          parentIsWidth: (D = T == null ? void 0 : T.horizontal) !== null && D !== void 0 ? D : !0\n        };\n      },\n      request: function(T) {\n        return \"offsetWidth\" in T ? e = T.offsetWidth - S.offsetWidth : \"deltaWidth\" in T && (e += T.deltaWidth), \"offsetHeight\" in T ? r = T.offsetHeight - S.offsetHeight : \"deltaHeight\" in T && (r += T.deltaHeight), {\n          datas: t,\n          parentDist: [e, r],\n          parentKeepRatio: T.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(o) {\n    o.state.gestos.resizable = null;\n  }\n};\nfunction setRotateStartInfo(o, t, e, r, S) {\n  var T = o.props.groupable, D = o.state, N = D.is3d ? 4 : 3, B = t.origin, $ = calculatePosition(\n    o.state.rootMatrix,\n    minus([B[0], B[1]], T ? [0, 0] : [D.left, D.top]),\n    N\n  ), U = plus([S.left, S.top], $);\n  t.startAbsoluteOrigin = U, t.prevDeg = getRad$1(U, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(U, [e, r]);\n}\nfunction getAbsoluteDist(o, t, e) {\n  var r = e.defaultDeg, S = e.prevDeg, T = S % 360, D = Math.floor(S / 360);\n  T < 0 && (T += 360), T > o && T > 270 && o < 90 ? ++D : T < o && T < 90 && o > 270 && --D;\n  var N = t * (D * 360 + o - r);\n  return e.prevDeg = r + N, N;\n}\nfunction getAbsoluteDistByClient(o, t, e, r) {\n  return getAbsoluteDist(getRad$1(r.startAbsoluteOrigin, [o, t]) / Math.PI * 180, e, r);\n}\nfunction getRotateInfo(o, t, e, r, S, T) {\n  var D = o.props.throttleRotate, N = D === void 0 ? 0 : D, B = e.prevSnapDeg, $ = 0, U = !1;\n  if (T) {\n    var V = checkSnapRotate(o, t, r);\n    U = V.isSnap, $ = S + V.rotation;\n  }\n  U || ($ = throttle(S + r, N));\n  var H = $ - S;\n  return e.prevSnapDeg = H, [H - B, H, $];\n}\nfunction getRotationPositions(o, t, e) {\n  var r = t[0], S = t[1], T = t[2], D = t[3];\n  if (o === \"none\")\n    return [];\n  if (isArray(o))\n    return o.map(function(W) {\n      return getRotationPositions(W, [r, S, T, D], e)[0];\n    });\n  var N = (o || \"top\").split(\"-\"), B = N[0], $ = N[1], U = [r, S];\n  B === \"left\" ? U = [T, r] : B === \"right\" ? U = [S, D] : B === \"bottom\" && (U = [D, T]);\n  var V = [(U[0][0] + U[1][0]) / 2, (U[0][1] + U[1][1]) / 2], H = getRotationRad(U, e);\n  if ($) {\n    var X = $ === \"top\" || $ === \"left\", Y = B === \"bottom\" || B === \"left\";\n    V = U[X && !Y || !X && Y ? 0 : 1];\n  }\n  return [[V, H]];\n}\nfunction dragControlCondition(o, t) {\n  if (t.isRequest)\n    return t.requestAble === \"rotatable\";\n  var e = t.inputEvent.target;\n  if (hasClass(e, prefix(\"rotation-control\")) || hasClass(e, prefix(\"around-control\")) || hasClass(e, prefix(\"control\")) && hasClass(e, prefix(\"rotatable\")))\n    return !0;\n  var r = o.props.rotationTarget;\n  return r ? getRefTargets(r, !0).some(function(S) {\n    return S ? e === S || e.contains(S) : !1;\n  }) : !1;\n}\nvar directionCSS = DIRECTIONS.map(function(o) {\n  var t = \"\", e = \"\", r = \"center\", S = \"center\";\n  return o.indexOf(\"n\") > -1 && (t = \"top: -20px;\", S = \"bottom\"), o.indexOf(\"s\") > -1 && (t = \"top: 0px;\", S = \"top\"), o.indexOf(\"w\") > -1 && (e = \"left: -20px;\", r = \"right\"), o.indexOf(\"e\") > -1 && (e = \"left: 0px;\", r = \"left\"), '.around-control[data-direction*=\"'.concat(o, `\"] {\n        `).concat(e).concat(t, `\n        transform-origin: `).concat(r, \" \").concat(S, `;\n    }`);\n}).join(`\n`), css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n`.concat(directionCSS, `\n`), Rotatable = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object,\n    rotateAroundControls: Boolean,\n    edge: Boolean,\n    resolveAblesWithRotatable: Object\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onBeforeRotate: \"beforeRotate\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onBeforeRotateGroup: \"beforeRotateGroup\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [css],\n  viewClassName: function(o) {\n    return o.isDragging(\"rotatable\") ? prefix(\"view-rotation-dragging\") : \"\";\n  },\n  render: function(o, t) {\n    var e = getProps(o.props, \"rotatable\"), r = e.rotatable, S = e.rotationPosition, T = e.zoom, D = e.renderDirections, N = e.rotateAroundControls, B = e.resolveAblesWithRotatable, $ = o.getState(), U = $.renderPoses, V = $.direction;\n    if (!r)\n      return null;\n    var H = getRotationPositions(S, U, V), X = [];\n    if (H.forEach(function(K, Z) {\n      var J = K[0], Q = K[1];\n      X.push(t.createElement(\"div\", {\n        key: \"rotation\".concat(Z),\n        className: prefix(\"rotation\"),\n        style: {\n          transform: \"translate(-50%) translate(\".concat(J[0], \"px, \").concat(J[1], \"px) rotate(\").concat(Q, \"rad)\")\n        }\n      }, t.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(T, \")\")\n        }\n      }), t.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(T, \")\")\n        }\n      })));\n    }), D) {\n      var Y = getKeys(B || {}), W = {};\n      Y.forEach(function(K) {\n        B[K].forEach(function(Z) {\n          W[Z] = K;\n        });\n      });\n      var q = [];\n      isArray(D) && (q = D.map(function(K) {\n        var Z = W[K];\n        return {\n          data: Z ? {\n            resolve: Z\n          } : {},\n          classNames: Z ? [\"move\"] : [],\n          dir: K\n        };\n      })), X.push.apply(X, renderDirectionControlsByInfos(o, \"rotatable\", q, t));\n    }\n    return N && X.push.apply(X, renderAroundControls(o, t)), X;\n  },\n  dragControlCondition,\n  dragControlStart: function(o, t) {\n    var e, r, S = t.datas, T = t.clientX, D = t.clientY, N = t.parentRotate, B = t.parentFlag, $ = t.isPinch, U = t.isRequest, V = o.state, H = V.target, X = V.left, Y = V.top, W = V.direction, q = V.beforeDirection, K = V.targetTransform, Z = V.moveableClientRect, J = V.offsetMatrix, Q = V.targetMatrix, rt = V.allMatrix, et = V.width, nt = V.height;\n    if (!U && !H)\n      return !1;\n    var st = o.getRect();\n    S.rect = st, S.transform = K, S.left = X, S.top = Y;\n    var it = function(Pt) {\n      var ft = o.state, Ft = ft.allMatrix, It = ft.is3d, zt = ft.width, kt = ft.height, Tt = getDirectionByPos(Pt, zt, kt);\n      S.fixedDirection = Tt, S.fixedPosition = calculatePosition(Ft, Pt, It ? 4 : 3), yt && yt.setFixedPosition(Pt);\n    }, at = function(Pt) {\n      S.fixedDirection = Pt, S.fixedPosition = getDirectionOffset(o, Pt), yt && yt.setFixedDirection(Pt);\n    }, ut = T, ct = D;\n    if (U || $ || B) {\n      var gt = N || 0;\n      S.beforeInfo = {\n        origin: st.beforeOrigin,\n        prevDeg: gt,\n        defaultDeg: gt,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, S.afterInfo = __assign$1(__assign$1({}, S.beforeInfo), {\n        origin: st.origin\n      }), S.absoluteInfo = __assign$1(__assign$1({}, S.beforeInfo), {\n        origin: st.origin,\n        startValue: gt\n      });\n    } else {\n      var _t = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;\n      if (_t) {\n        var vt = _t.getAttribute(\"data-direction\") || \"\", mt = DIRECTION_REGION_TO_DIRECTION[vt];\n        if (mt) {\n          S.isControl = !0, S.isAroundControl = hasClass(_t, prefix(\"around-control\")), S.controlDirection = mt;\n          var bt = _t.getAttribute(\"data-resolve\");\n          bt && (S.resolveAble = bt);\n          var Ct = calculateMoveableClientPositions(V.rootMatrix, V.renderPoses, Z);\n          e = getPosByDirection(Ct, mt), ut = e[0], ct = e[1];\n        }\n      }\n      S.beforeInfo = {\n        origin: st.beforeOrigin\n      }, S.afterInfo = {\n        origin: st.origin\n      }, S.absoluteInfo = {\n        origin: st.origin,\n        startValue: st.rotation\n      };\n      var St = it;\n      it = function(Pt) {\n        var ft = V.is3d ? 4 : 3, Ft = plus(getOrigin(Q, ft), Pt), It = Ft[0], zt = Ft[1], kt = calculate(J, convertPositionMatrix([It, zt], ft)), Tt = calculate(rt, convertPositionMatrix([Pt[0], Pt[1]], ft));\n        St(Pt);\n        var jt = V.posDelta;\n        S.beforeInfo.origin = minus(kt, jt), S.afterInfo.origin = minus(Tt, jt), S.absoluteInfo.origin = minus(Tt, jt), setRotateStartInfo(o, S.beforeInfo, ut, ct, Z), setRotateStartInfo(o, S.afterInfo, ut, ct, Z), setRotateStartInfo(o, S.absoluteInfo, ut, ct, Z);\n      }, at = function(Pt) {\n        var ft = getPosByDirection([[0, 0], [et, 0], [0, nt], [et, nt]], Pt);\n        it(ft);\n      };\n    }\n    S.startClientX = ut, S.startClientY = ct, S.direction = W, S.beforeDirection = q, S.startValue = 0, S.datas = {}, setDefaultTransformIndex(t, \"rotate\");\n    var pt = !1, yt = !1;\n    if (S.isControl && S.resolveAble) {\n      var At = S.resolveAble;\n      At === \"resizable\" && (yt = Resizable.dragControlStart(o, __assign$1(__assign$1({}, new CustomGesto(\"resizable\").dragStart([0, 0], t)), {\n        parentPosition: S.controlPosition,\n        parentFixedPosition: S.fixedPosition\n      })));\n    }\n    yt || (pt = Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))), it(V.transformOrigin);\n    var Dt = fillParams(o, t, __assign$1(__assign$1({\n      set: function(Pt) {\n        S.startValue = Pt * Math.PI / 180;\n      },\n      setFixedDirection: at,\n      setFixedPosition: it\n    }, fillTransformStartEvent(t)), {\n      dragStart: pt,\n      resizeStart: yt\n    })), Ot = triggerEvent(o, \"onRotateStart\", Dt);\n    return S.isRotate = Ot !== !1, V.snapRenderInfo = {\n      request: t.isRequest\n    }, S.isRotate ? Dt : !1;\n  },\n  dragControl: function(o, t) {\n    var e, r, S, T = t.datas, D = t.clientDistX, N = t.clientDistY, B = t.parentRotate, $ = t.parentFlag, U = t.isPinch, V = t.groupDelta, H = T.beforeDirection, X = T.beforeInfo, Y = T.afterInfo, W = T.absoluteInfo, q = T.isRotate, K = T.startValue, Z = T.rect, J = T.startClientX, Q = T.startClientY;\n    if (!!q) {\n      resolveTransformEvent(t, \"rotate\");\n      var rt = getTransformDirection(t), et = H * rt, nt = o.props.parentMoveable, st = 0, it, at, ut = 0, ct, gt, _t = 0, vt, mt, bt = 180 / Math.PI * K, Ct = W.startValue, St = !1, pt = J + D, yt = Q + N;\n      if (!$ && \"parentDist\" in t) {\n        var At = t.parentDist;\n        it = At, ct = At, vt = At;\n      } else\n        U || $ ? (it = getAbsoluteDist(B, H, X), ct = getAbsoluteDist(B, et, Y), vt = getAbsoluteDist(B, et, W)) : (it = getAbsoluteDistByClient(pt, yt, H, X), ct = getAbsoluteDistByClient(pt, yt, et, Y), vt = getAbsoluteDistByClient(pt, yt, et, W), St = !0);\n      if (at = bt + it, gt = bt + ct, mt = Ct + vt, triggerEvent(o, \"onBeforeRotate\", fillParams(o, t, {\n        beforeRotation: at,\n        rotation: gt,\n        absoluteRotation: mt,\n        setRotation: function(jt) {\n          ct = jt - bt, it = ct, vt = ct;\n        }\n      }, !0)), e = getRotateInfo(o, Z, X, it, bt, St), st = e[0], it = e[1], at = e[2], r = getRotateInfo(o, Z, Y, ct, bt, St), ut = r[0], ct = r[1], gt = r[2], S = getRotateInfo(o, Z, W, vt, Ct, St), _t = S[0], vt = S[1], mt = S[2], !(!_t && !ut && !st && !nt)) {\n        var Dt = convertTransformFormat(T, \"rotate(\".concat(gt, \"deg)\"), \"rotate(\".concat(ct, \"deg)\")), Ot = getRotateDist(o, ct, T), Pt = minus(plus(V || [0, 0], Ot), T.prevInverseDist || [0, 0]);\n        T.prevInverseDist = Ot, T.requestValue = null;\n        var ft = fillTransformEvent(o, Dt, Pt, U, t), Ft = ft, It = getDist$2([pt, yt], W.startAbsoluteOrigin) - W.startDist, zt = void 0;\n        if (T.resolveAble === \"resizable\") {\n          var kt = Resizable.dragControl(o, __assign$1(__assign$1({}, setCustomDrag(t, o.state, [t.deltaX, t.deltaY], !!U, !1, \"resizable\")), {\n            resolveMatrix: !0,\n            parentDistance: It\n          }));\n          kt && (zt = kt, Ft = fillAfterTransform(Ft, kt, t));\n        }\n        var Tt = fillParams(o, t, __assign$1(__assign$1({\n          delta: ut,\n          dist: ct,\n          rotate: gt,\n          rotation: gt,\n          beforeDist: it,\n          beforeDelta: st,\n          beforeRotate: at,\n          beforeRotation: at,\n          absoluteDist: vt,\n          absoluteDelta: _t,\n          absoluteRotate: mt,\n          absoluteRotation: mt,\n          isPinch: !!U,\n          resize: zt\n        }, ft), Ft));\n        return triggerEvent(o, \"onRotate\", Tt), Tt;\n      }\n    }\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      e.isRotate = !1;\n      var r = fillEndParams(o, t, {});\n      return triggerEvent(o, \"onRotateEnd\", r), r;\n    }\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = o.state, S = r.left, T = r.top, D = r.beforeOrigin, N = this.dragControlStart(o, t);\n    if (!N)\n      return !1;\n    N.set(e.beforeDirection * o.rotation);\n    var B = triggerChildAbles(o, this, \"dragControlStart\", t, function(V, H) {\n      var X = V.state, Y = X.left, W = X.top, q = X.beforeOrigin, K = plus(minus([Y, W], [S, T]), minus(q, D));\n      return H.datas.startGroupClient = K, H.datas.groupClient = K, __assign$1(__assign$1({}, H), {\n        parentRotate: 0\n      });\n    }), $ = __assign$1(__assign$1({}, N), {\n      targets: o.props.targets,\n      events: B\n    }), U = triggerEvent(o, \"onRotateGroupStart\", $);\n    return e.isRotate = U !== !1, e.isRotate ? N : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      catchEvent(o, \"onBeforeRotate\", function($) {\n        triggerEvent(o, \"onBeforeRotateGroup\", fillParams(o, t, __assign$1(__assign$1({}, $), {\n          targets: o.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(o, t);\n      if (!!r) {\n        var S = e.beforeDirection, T = r.beforeDist, D = T / 180 * Math.PI, N = triggerChildAbles(o, this, \"dragControl\", t, function($, U) {\n          var V = U.datas.startGroupClient, H = U.datas.groupClient, X = H[0], Y = H[1], W = rotate(V, D * S), q = W[0], K = W[1], Z = [q - X, K - Y];\n          return U.datas.groupClient = [q, K], __assign$1(__assign$1({}, U), {\n            parentRotate: T,\n            groupDelta: Z\n          });\n        });\n        o.rotation = S * r.beforeRotation;\n        var B = __assign$1({\n          targets: o.props.targets,\n          events: N,\n          set: function($) {\n            o.rotation = $;\n          },\n          setGroupRotation: function($) {\n            o.rotation = $;\n          }\n        }, r);\n        return triggerEvent(o, \"onRotateGroup\", B), B;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (!!r.isRotate) {\n      this.dragControlEnd(o, t);\n      var S = triggerChildAbles(o, this, \"dragControlEnd\", t), T = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: S\n      });\n      return triggerEvent(o, \"onRotateGroupEnd\", T), e;\n    }\n  },\n  request: function(o) {\n    var t = {}, e = 0, r = o.getRotation();\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(S) {\n        return \"deltaRotate\" in S ? e += S.deltaRotate : \"rotate\" in S && (e = S.rotate - r), {\n          datas: t,\n          parentDist: e\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, directionCondition = getDirectionCondition(\"scalable\"), Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean,\n    edge: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onBeforeScale: \"beforeScale\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onBeforeScaleGroup: \"beforeScaleGroup\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: getRenderDirections(\"scalable\"),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName(\"scalable\"),\n  dragControlStart: function(o, t) {\n    var e = t.datas, r = t.isPinch, S = t.inputEvent, T = t.parentDirection, D = getTotalDirection(T, r, S, e), N = o.state, B = N.width, $ = N.height, U = N.targetTransform, V = N.target, H = N.pos1, X = N.pos2, Y = N.pos4;\n    if (!D || !V)\n      return !1;\n    r || setDragStart(o, t), e.datas = {}, e.transform = U, e.prevDist = [1, 1], e.direction = D, e.startOffsetWidth = B, e.startOffsetHeight = $, e.startValue = [1, 1];\n    var W = getDist$2(H, X), q = getDist$2(X, Y), K = !D[0] && !D[1] || D[0] || !D[1];\n    e.scaleWidth = W, e.scaleHeight = q, e.scaleXRatio = W / B, e.scaleYRatio = q / $, setDefaultTransformIndex(t, \"scale\"), e.isWidth = K;\n    function Z(et) {\n      e.ratio = et && isFinite(et) ? et : 0;\n    }\n    e.startPositions = getAbsolutePosesByState(o.state);\n    function J(et) {\n      e.fixedDirection = et, e.fixedPosition = getPosByDirection(e.startPositions, et);\n    }\n    e.setFixedDirection = J, Z(getDist$2(H, X) / getDist$2(X, Y)), J([-D[0], -D[1]]);\n    var Q = fillParams(o, t, __assign$1(__assign$1({\n      direction: D,\n      set: function(et) {\n        e.startValue = et;\n      },\n      setRatio: Z,\n      setFixedDirection: J\n    }, fillTransformStartEvent(t)), {\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    })), rt = triggerEvent(o, \"onScaleStart\", Q);\n    return e.startFixedDirection = e.fixedDirection, rt !== !1 && (e.isScale = !0, o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: D\n    }), e.isScale ? Q : !1;\n  },\n  dragControl: function(o, t) {\n    resolveTransformEvent(t, \"scale\");\n    var e = t.datas, r = t.parentKeepRatio, S = t.parentFlag, T = t.isPinch, D = t.dragClient, N = t.isRequest, B = e.prevDist, $ = e.direction, U = e.startOffsetWidth, V = e.startOffsetHeight, H = e.isScale, X = e.startValue, Y = e.isWidth, W = e.ratio;\n    if (!H)\n      return !1;\n    var q = o.props, K = q.throttleScale, Z = q.parentMoveable, J = $;\n    !$[0] && !$[1] && (J = [1, 1]);\n    var Q = W && (r ?? q.keepRatio) || !1, rt = o.state;\n    function et() {\n      var yt = getOffsetSizeDist(J, Q, e, t), At = yt.distWidth, Dt = yt.distHeight, Ot = U ? (U + At) / U : 1, Pt = V ? (V + Dt) / V : 1;\n      return Ot = J[0] || Q ? Ot * X[0] : X[0], Pt = J[1] || Q ? Pt * X[1] : X[1], Ot === 0 && (Ot = (B[0] > 0 ? 1 : -1) * MIN_SCALE), Pt === 0 && (Pt = (B[1] > 0 ? 1 : -1) * MIN_SCALE), [Ot, Pt];\n    }\n    var nt = et();\n    if (!T && o.props.groupable) {\n      var st = rt.snapRenderInfo || {}, it = st.direction;\n      isArray(it) && (it[0] || it[1]) && (rt.snapRenderInfo = {\n        direction: $,\n        request: t.isRequest\n      });\n    }\n    triggerEvent(o, \"onBeforeScale\", fillParams(o, t, {\n      scale: nt,\n      setFixedDirection: function(yt) {\n        return e.setFixedDirection(yt), nt = et(), nt;\n      },\n      startFixedDirection: e.startFixedDirection,\n      setScale: function(yt) {\n        nt = yt;\n      }\n    }, !0));\n    var at = [nt[0] / X[0], nt[1] / X[1]], ut = D, ct = [0, 0];\n    if (D || (!S && T ? ut = getAbsolutePosition(o, [0, 0]) : ut = e.fixedPosition), T || (ct = checkSnapScale(o, at, $, N, e)), Q) {\n      J[0] && J[1] && ct[0] && ct[1] && (Math.abs(ct[0] * U) > Math.abs(ct[1] * V) ? ct[1] = 0 : ct[0] = 0);\n      var gt = !ct[0] && !ct[1];\n      if (gt && (Y ? at[0] = throttle(at[0] * X[0], K) / X[0] : at[1] = throttle(at[1] * X[1], K) / X[1]), J[0] && !J[1] || ct[0] && !ct[1] || gt && Y) {\n        at[0] += ct[0];\n        var _t = U * at[0] * X[0] / W;\n        at[1] = _t / V / X[1];\n      } else if (!J[0] && J[1] || !ct[0] && ct[1] || gt && !Y) {\n        at[1] += ct[1];\n        var vt = V * at[1] * X[1] * W;\n        at[0] = vt / U / X[0];\n      }\n    } else\n      at[0] += ct[0], at[1] += ct[1], ct[0] || (at[0] = throttle(at[0] * X[0], K) / X[0]), ct[1] || (at[1] = throttle(at[1] * X[1], K) / X[1]);\n    at[0] === 0 && (at[0] = (B[0] > 0 ? 1 : -1) * MIN_SCALE), at[1] === 0 && (at[1] = (B[1] > 0 ? 1 : -1) * MIN_SCALE);\n    var mt = [at[0] / B[0], at[1] / B[1]];\n    nt = multiply2(at, X);\n    var bt = getScaleDist(o, at, e.fixedDirection, ut, e), Ct = minus(bt, e.prevInverseDist || [0, 0]);\n    if (e.prevDist = at, e.prevInverseDist = bt, nt[0] === B[0] && nt[1] === B[1] && Ct.every(function(yt) {\n      return !yt;\n    }) && !Z)\n      return !1;\n    var St = convertTransformFormat(e, \"scale(\".concat(nt.join(\", \"), \")\"), \"scale(\".concat(at.join(\", \"), \")\")), pt = fillParams(o, t, __assign$1({\n      offsetWidth: U,\n      offsetHeight: V,\n      direction: $,\n      scale: nt,\n      dist: at,\n      delta: mt,\n      isPinch: !!T\n    }, fillTransformEvent(o, St, Ct, T, t)));\n    return triggerEvent(o, \"onScale\", pt), pt;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    if (!e.isScale)\n      return !1;\n    e.isScale = !1;\n    var r = fillEndParams(o, t, {});\n    return triggerEvent(o, \"onScaleEnd\", r), r;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = this.dragControlStart(o, t);\n    if (!r)\n      return !1;\n    var S = fillChildEvents(o, \"resizable\", t);\n    function T(U, V) {\n      var H = e.fixedDirection, X = e.fixedPosition, Y = V.datas.startPositions || getAbsolutePosesByState(U.state), W = getPosByDirection(Y, H), q = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [W[0] - X[0], W[1] - X[1], 1], 3), K = q[0], Z = q[1];\n      return V.datas.originalX = K, V.datas.originalY = Z, V;\n    }\n    e.moveableScale = o.scale;\n    var D = triggerChildAbles(o, this, \"dragControlStart\", t, function(U, V) {\n      return T(U, V);\n    }), N = function(U) {\n      r.setFixedDirection(U), D.forEach(function(V, H) {\n        V.setFixedDirection(U), T(V.moveable, S[H]);\n      });\n    };\n    e.setFixedDirection = N;\n    var B = __assign$1(__assign$1({}, r), {\n      targets: o.props.targets,\n      events: D,\n      setFixedDirection: N\n    }), $ = triggerEvent(o, \"onScaleGroupStart\", B);\n    return e.isScale = $ !== !1, e.isScale ? B : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (!!e.isScale) {\n      catchEvent(o, \"onBeforeScale\", function(V) {\n        triggerEvent(o, \"onBeforeScaleGroup\", fillParams(o, t, __assign$1(__assign$1({}, V), {\n          targets: o.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(o, t);\n      if (!!r) {\n        var S = e.moveableScale;\n        o.scale = [r.scale[0] * S[0], r.scale[1] * S[1]];\n        var T = o.props.keepRatio, D = r.dist, N = r.scale, B = e.fixedPosition, $ = triggerChildAbles(o, this, \"dragControl\", t, function(V, H) {\n          var X = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [H.datas.originalX * D[0], H.datas.originalY * D[1], 1], 3), Y = X[0], W = X[1];\n          return __assign$1(__assign$1({}, H), {\n            parentDist: null,\n            parentScale: N,\n            parentKeepRatio: T,\n            dragClient: plus(B, [Y, W])\n          });\n        }), U = __assign$1({\n          targets: o.props.targets,\n          events: $\n        }, r);\n        return triggerEvent(o, \"onScaleGroup\", U), U;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (!!r.isScale) {\n      this.dragControlEnd(o, t);\n      var S = triggerChildAbles(o, this, \"dragControlEnd\", t), T = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: S\n      });\n      return triggerEvent(o, \"onScaleGroupEnd\", T), e;\n    }\n  },\n  request: function() {\n    var o = {}, t = 0, e = 0;\n    return {\n      isControl: !0,\n      requestStart: function(r) {\n        return {\n          datas: o,\n          parentDirection: r.direction || [1, 1]\n        };\n      },\n      request: function(r) {\n        return t += r.deltaWidth, e += r.deltaHeight, {\n          datas: o,\n          parentDist: [t, e],\n          parentKeepRatio: r.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: o,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction getMiddleLinePos(o, t) {\n  return o.map(function(e, r) {\n    return dot(e, t[r], 1, 2);\n  });\n}\nfunction getTriangleRad(o, t, e) {\n  var r = getRad$1(o, t), S = getRad$1(o, e), T = S - r;\n  return T >= 0 ? T : T + 2 * Math.PI;\n}\nfunction isValidPos(o, t) {\n  var e = getTriangleRad(o[0], o[1], o[2]), r = getTriangleRad(t[0], t[1], t[2]), S = Math.PI;\n  return !(e >= S && r <= S || e <= S && r >= S);\n}\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array,\n    edge: Boolean\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  viewClassName: getDirectionViewClassName(\"warpable\"),\n  render: function(o, t) {\n    var e = o.props, r = e.resizable, S = e.scalable, T = e.warpable, D = e.zoom;\n    if (r || S || !T)\n      return [];\n    var N = o.state, B = N.pos1, $ = N.pos2, U = N.pos3, V = N.pos4, H = getMiddleLinePos(B, $), X = getMiddleLinePos($, B), Y = getMiddleLinePos(B, U), W = getMiddleLinePos(U, B), q = getMiddleLinePos(U, V), K = getMiddleLinePos(V, U), Z = getMiddleLinePos($, V), J = getMiddleLinePos(V, $);\n    return __spreadArray([t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(H, q, D)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(X, K, D)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(Y, Z, D)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(W, J, D)\n    })], renderAllDirections(o, \"warpable\", t), !0);\n  },\n  dragControlCondition: function(o, t) {\n    if (t.isRequest)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"warpable\"));\n  },\n  dragControlStart: function(o, t) {\n    var e = t.datas, r = t.inputEvent, S = o.props.target, T = r.target, D = getDirection(T, e);\n    if (!D || !S)\n      return !1;\n    var N = o.state, B = N.transformOrigin, $ = N.is3d, U = N.targetTransform, V = N.targetMatrix, H = N.width, X = N.height, Y = N.left, W = N.top;\n    e.datas = {}, e.targetTransform = U, e.warpTargetMatrix = $ ? V : convertDimension(V, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = D, e.left = Y, e.top = W, e.poses = [[0, 0], [H, 0], [0, X], [H, X]].map(function(Z) {\n      return minus(Z, B);\n    }), e.nextPoses = e.poses.map(function(Z) {\n      var J = Z[0], Q = Z[1];\n      return calculate(e.warpTargetMatrix, [J, Q, 0, 1], 4);\n    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(N), e.posIndexes = getPosIndexesByDirection(D), setDragStart(o, t), setDefaultTransformIndex(t, \"matrix3d\"), N.snapRenderInfo = {\n      request: t.isRequest,\n      direction: D\n    };\n    var q = fillParams(o, t, __assign$1({\n      set: function(Z) {\n        e.startValue = Z;\n      }\n    }, fillTransformStartEvent(t))), K = triggerEvent(o, \"onWarpStart\", q);\n    return K !== !1 && (e.isWarp = !0), e.isWarp;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = t.isRequest, S = t.distX, T = t.distY, D = e.targetInverseMatrix, N = e.prevMatrix, B = e.isWarp, $ = e.startValue, U = e.poses, V = e.posIndexes, H = e.absolutePoses;\n    if (!B)\n      return !1;\n    if (resolveTransformEvent(t, \"matrix3d\"), hasGuidelines(o, \"warpable\")) {\n      var X = V.map(function(it) {\n        return H[it];\n      });\n      X.length > 1 && X.push([(X[0][0] + X[1][0]) / 2, (X[0][1] + X[1][1]) / 2]);\n      var Y = checkMoveableSnapBounds(o, r, {\n        horizontal: X.map(function(it) {\n          return it[1] + T;\n        }),\n        vertical: X.map(function(it) {\n          return it[0] + S;\n        })\n      }), W = Y.horizontal, q = Y.vertical;\n      T -= W.offset, S -= q.offset;\n    }\n    var K = getDragDist({\n      datas: e,\n      distX: S,\n      distY: T\n    }, !0), Z = e.nextPoses.slice();\n    if (V.forEach(function(it) {\n      Z[it] = plus(Z[it], K);\n    }), !NEARBY_POS.every(function(it) {\n      return isValidPos(it.map(function(at) {\n        return U[at];\n      }), it.map(function(at) {\n        return Z[at];\n      }));\n    }))\n      return !1;\n    var J = createWarpMatrix(U[0], U[2], U[1], U[3], Z[0], Z[2], Z[1], Z[3]);\n    if (!J.length)\n      return !1;\n    var Q = multiply(D, J, 4), rt = getTransfromMatrix(e, Q, !0), et = multiply(invert(N, 4), rt, 4);\n    e.prevMatrix = rt;\n    var nt = multiply($, rt, 4), st = convertTransformFormat(e, \"matrix3d(\".concat(nt.join(\", \"), \")\"), \"matrix3d(\".concat(rt.join(\", \"), \")\"));\n    return fillOriginalTransform(t, st), triggerEvent(o, \"onWarp\", fillParams(o, t, __assign$1({\n      delta: et,\n      matrix: nt,\n      dist: rt,\n      multiply,\n      transform: st\n    }, fillCSSObject({\n      transform: st\n    }, t)))), !0;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas, r = t.isDrag;\n    return e.isWarp ? (e.isWarp = !1, triggerEvent(o, \"onWarpEnd\", fillEndParams(o, t, {})), r) : !1;\n  }\n}, AREA_PIECES = /* @__PURE__ */ prefix(\"area-pieces\"), AREA_PIECE = /* @__PURE__ */ prefix(\"area-piece\"), AVOID = /* @__PURE__ */ prefix(\"avoid\"), VIEW_DRAGGING = prefix(\"view-dragging\");\nfunction restoreStyle(o) {\n  var t = o.areaElement;\n  if (!!t) {\n    var e = o.state, r = e.width, S = e.height;\n    removeClass(t, AVOID), t.style.cssText += \"left: 0px; top: 0px; width: \".concat(r, \"px; height: \").concat(S, \"px\");\n  }\n}\nfunction renderPieces(o) {\n  return o.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function(o, t) {\n    var e = o.props, r = e.target, S = e.dragArea, T = e.groupable, D = e.passDragArea, N = o.getState(), B = N.width, $ = N.height, U = N.renderPoses, V = D ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (T)\n      return [t.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(o, \"areaElement\"),\n        className: V\n      }), renderPieces(t)];\n    if (!r || !S)\n      return [];\n    var H = createWarpMatrix([0, 0], [B, 0], [0, $], [B, $], U[0], U[1], U[2], U[3]), X = H.length ? makeMatrixCSS(H, !0) : \"none\";\n    return [t.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(o, \"areaElement\"),\n      className: V,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(B, \"px\"),\n        height: \"\".concat($, \"px\"),\n        transformOrigin: \"0 0\",\n        transform: X\n      }\n    }), renderPieces(t)];\n  },\n  dragStart: function(o, t) {\n    var e = t.datas, r = t.clientX, S = t.clientY, T = t.inputEvent;\n    if (!T)\n      return !1;\n    e.isDragArea = !1;\n    var D = o.areaElement, N = o.state, B = N.moveableClientRect, $ = N.renderPoses, U = N.rootMatrix, V = N.is3d, H = B.left, X = B.top, Y = getRect($), W = Y.left, q = Y.top, K = Y.width, Z = Y.height, J = V ? 4 : 3, Q = calculateInversePosition(U, [r - H, S - X], J), rt = Q[0], et = Q[1];\n    rt -= W, et -= q;\n    var nt = [{\n      left: W,\n      top: q,\n      width: K,\n      height: et - 10\n    }, {\n      left: W,\n      top: q,\n      width: rt - 10,\n      height: Z\n    }, {\n      left: W,\n      top: q + et + 10,\n      width: K,\n      height: Z - et - 10\n    }, {\n      left: W + rt + 10,\n      top: q,\n      width: K - rt - 10,\n      height: Z\n    }], st = [].slice.call(D.nextElementSibling.children);\n    nt.forEach(function(it, at) {\n      st[at].style.cssText = \"left: \".concat(it.left, \"px;top: \").concat(it.top, \"px; width: \").concat(it.width, \"px; height: \").concat(it.height, \"px;\");\n    }), addClass(D, AVOID), N.disableNativeEvent = !0;\n  },\n  drag: function(o, t) {\n    var e = t.datas, r = t.inputEvent;\n    if (this.enableNativeEvent(o), !r)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, restoreStyle(o));\n  },\n  dragEnd: function(o, t) {\n    this.enableNativeEvent(o);\n    var e = t.inputEvent, r = t.datas;\n    if (!e)\n      return !1;\n    r.isDragArea || restoreStyle(o);\n  },\n  dragGroupStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragGroup: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragGroupEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  unset: function(o) {\n    restoreStyle(o), o.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent: function(o) {\n    var t = o.state;\n    t.disableNativeEvent && requestAnimationFrame$1(function() {\n      t.disableNativeEvent = !1;\n    });\n  }\n}, Origin = makeAble(\"origin\", {\n  render: function(o, t) {\n    var e = o.props.zoom, r = o.getState(), S = r.beforeOrigin, T = r.rotation;\n    return [t.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(T, e, S),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction getDefaultScrollPosition(o) {\n  var t = o.scrollContainer;\n  return [t.scrollLeft, t.scrollTop];\n}\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    scrollThrottleTime: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragRelation: \"strong\",\n  dragStart: function(o, t) {\n    var e = o.props, r = e.scrollContainer, S = r === void 0 ? o.getContainer() : r, T = new DragScroll$1(), D = getRefTarget(S, !0);\n    t.datas.dragScroll = T;\n    var N = t.isControl ? \"controlGesto\" : \"targetGesto\", B = t.targets;\n    T.on(\"scroll\", function($) {\n      var U = $.container, V = $.direction, H = fillParams(o, t, {\n        scrollContainer: U,\n        direction: V\n      }), X = B ? \"onScrollGroup\" : \"onScroll\";\n      B && (H.targets = B), triggerEvent(o, X, H);\n    }).on(\"move\", function($) {\n      var U = $.offsetX, V = $.offsetY, H = $.inputEvent;\n      o[N].scrollBy(U, V, H.inputEvent, !1);\n    }), T.dragStart(t, {\n      container: D\n    });\n  },\n  checkScroll: function(o, t) {\n    var e = t.datas.dragScroll;\n    if (!!e) {\n      var r = o.props, S = r.scrollContainer, T = S === void 0 ? o.getContainer() : S, D = r.scrollThreshold, N = D === void 0 ? 0 : D, B = r.scrollThrottleTime, $ = B === void 0 ? 0 : B, U = r.getScrollPosition, V = U === void 0 ? getDefaultScrollPosition : U;\n      return e.drag(t, {\n        container: T,\n        threshold: N,\n        throttleTime: $,\n        getScrollPosition: function(H) {\n          return V({\n            scrollContainer: H.container,\n            direction: H.direction\n          });\n        }\n      }), !0;\n    }\n  },\n  drag: function(o, t) {\n    return this.checkScroll(o, t);\n  },\n  dragEnd: function(o, t) {\n    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      isControl: !0\n    }));\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroup: function(o, t) {\n    return this.drag(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupEnd: function(o, t) {\n    return this.dragEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets,\n      isControl: !0\n    }));\n  },\n  dragGroupContro: function(o, t) {\n    return this.drag(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupControEnd: function(o, t) {\n    return this.dragEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  }\n}, Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    useResizeObserver: Boolean,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Object,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    hideDefaultLines: Boolean,\n    props: Object,\n    flushSync: Function,\n    stopPropagation: Boolean,\n    preventClickEventOnDrag: Boolean,\n    preventClickDefault: Boolean,\n    viewContainer: Object,\n    persistData: Object,\n    useAccuratePosition: Boolean,\n    firstRenderState: Object\n  },\n  events: {\n    onChangeTargets: \"changeTargets\"\n  }\n}, Padding = makeAble(\"padding\", {\n  render: function(o, t) {\n    var e = o.props;\n    if (e.dragArea)\n      return [];\n    var r = e.padding || {}, S = r.left, T = S === void 0 ? 0 : S, D = r.top, N = D === void 0 ? 0 : D, B = r.right, $ = B === void 0 ? 0 : B, U = r.bottom, V = U === void 0 ? 0 : U, H = o.getState(), X = H.renderPoses, Y = H.pos1, W = H.pos2, q = H.pos3, K = H.pos4, Z = [Y, W, q, K], J = [];\n    return T > 0 && J.push([0, 2]), N > 0 && J.push([0, 1]), $ > 0 && J.push([1, 3]), V > 0 && J.push([2, 3]), J.map(function(Q, rt) {\n      var et = Q[0], nt = Q[1], st = Z[et], it = Z[nt], at = X[et], ut = X[nt], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], st, it, at, ut);\n      if (!!ct.length)\n        return t.createElement(\"div\", {\n          key: \"padding\".concat(rt),\n          className: prefix(\"padding\"),\n          style: {\n            transform: makeMatrixCSS(ct, !0)\n          }\n        });\n    });\n  }\n}), RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction calculateRatio(o, t) {\n  var e = o[0] + o[1], r = e > t ? t / e : 1;\n  return o[0] *= r, o[1] = t - o[1] * r, o;\n}\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\nfunction getRadiusStyles(o, t, e, r, S, T, D, N) {\n  S === void 0 && (S = 0), T === void 0 && (T = 0), D === void 0 && (D = e), N === void 0 && (N = r);\n  var B = [], $ = !1, U = o.filter(function(H) {\n    return !H.virtual;\n  }), V = U.map(function(H) {\n    var X = H.horizontal, Y = H.vertical, W = H.pos;\n    if (Y && !$ && ($ = !0, B.push(\"/\")), $) {\n      var q = Math.max(0, Y === 1 ? W[1] - T : N - W[1]);\n      return B.push(convertCSSSize(q, r, t)), q;\n    } else {\n      var q = Math.max(0, X === 1 ? W[0] - S : D - W[0]);\n      return B.push(convertCSSSize(q, e, t)), q;\n    }\n  });\n  return {\n    radiusPoses: U,\n    styles: B,\n    raws: V\n  };\n}\nfunction getRadiusRange(o) {\n  for (var t = [0, 0], e = [0, 0], r = o.length, S = 0; S < r; ++S) {\n    var T = o[S];\n    !T.sub || (T.horizontal && (t[1] === 0 && (t[0] = S), t[1] = S - t[0] + 1, e[0] = S + 1), T.vertical && (e[1] === 0 && (e[0] = S), e[1] = S - e[0] + 1));\n  }\n  return {\n    horizontalRange: t,\n    verticalRange: e\n  };\n}\nfunction getRadiusValues(o, t, e, r, S, T, D) {\n  var N, B, $, U;\n  T === void 0 && (T = [0, 0]), D === void 0 && (D = !1);\n  var V = o.indexOf(\"/\"), H = (V > -1 ? o.slice(0, V) : o).length, X = o.slice(0, H), Y = o.slice(H + 1), W = X.length, q = Y.length, K = q > 0, Z = X[0], J = Z === void 0 ? \"0px\" : Z, Q = X[1], rt = Q === void 0 ? J : Q, et = X[2], nt = et === void 0 ? J : et, st = X[3], it = st === void 0 ? rt : st, at = Y[0], ut = at === void 0 ? J : at, ct = Y[1], gt = ct === void 0 ? K ? ut : rt : ct, _t = Y[2], vt = _t === void 0 ? K ? ut : nt : _t, mt = Y[3], bt = mt === void 0 ? K ? gt : it : mt, Ct = [J, rt, nt, it].map(function(Ot) {\n    return convertUnitSize(Ot, t);\n  }), St = [ut, gt, vt, bt].map(function(Ot) {\n    return convertUnitSize(Ot, e);\n  }), pt = Ct.slice(), yt = St.slice();\n  N = calculateRatio([pt[0], pt[1]], t), pt[0] = N[0], pt[1] = N[1], B = calculateRatio([pt[3], pt[2]], t), pt[3] = B[0], pt[2] = B[1], $ = calculateRatio([yt[0], yt[3]], e), yt[0] = $[0], yt[3] = $[1], U = calculateRatio([yt[1], yt[2]], e), yt[1] = U[0], yt[2] = U[1];\n  var At = D ? pt : pt.slice(0, Math.max(T[0], W)), Dt = D ? yt : yt.slice(0, Math.max(T[1], q));\n  return __spreadArray(__spreadArray([], At.map(function(Ot, Pt) {\n    var ft = RADIUS_DIRECTIONS[Pt];\n    return {\n      virtual: Pt >= W,\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Pt],\n      vertical: 0,\n      pos: [r + Ot, S + (VERTICAL_RADIUS_DIRECTIONS[Pt] === -1 ? e : 0)],\n      sub: !0,\n      raw: Ct[Pt],\n      direction: ft\n    };\n  }), !0), Dt.map(function(Ot, Pt) {\n    var ft = RADIUS_DIRECTIONS[Pt];\n    return {\n      virtual: Pt >= q,\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[Pt],\n      pos: [r + (HORIZONTAL_RADIUS_DIRECTIONS[Pt] === -1 ? t : 0), S + Ot],\n      sub: !0,\n      raw: St[Pt],\n      direction: ft\n    };\n  }), !0);\n}\nfunction removeRadiusPos(o, t, e, r, S) {\n  S === void 0 && (S = t.length);\n  var T = getRadiusRange(o.slice(r)), D = T.horizontalRange, N = T.verticalRange, B = e - r, $ = 0;\n  if (B === 0)\n    $ = S;\n  else if (B > 0 && B < D[1])\n    $ = D[1] - B;\n  else if (B >= N[0])\n    $ = N[0] + N[1] - B;\n  else\n    return;\n  o.splice(e, $), t.splice(e, $);\n}\nfunction addRadiusPos(o, t, e, r, S, T, D, N, B, $, U) {\n  $ === void 0 && ($ = 0), U === void 0 && (U = 0);\n  var V = getRadiusRange(o.slice(e)), H = V.horizontalRange, X = V.verticalRange;\n  if (r > -1)\n    for (var Y = HORIZONTAL_RADIUS_DIRECTIONS[r] === 1 ? T - $ : N - T, W = H[1]; W <= r; ++W) {\n      var q = VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? U : B, K = 0;\n      if (r === W ? K = T : W === 0 ? K = $ + Y : HORIZONTAL_RADIUS_DIRECTIONS[W] === -1 && (K = N - (t[e][0] - $)), o.splice(e + W, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[W],\n        vertical: 0,\n        pos: [K, q]\n      }), t.splice(e + W, 0, [K, q]), W === 0)\n        break;\n    }\n  else if (S > -1) {\n    var Z = VERTICAL_RADIUS_DIRECTIONS[S] === 1 ? D - U : B - D;\n    if (H[1] === 0 && X[1] === 0) {\n      var J = [$ + Z, U];\n      o.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: J\n      }), t.push(J);\n    }\n    for (var Q = X[0], W = X[1]; W <= S; ++W) {\n      var K = HORIZONTAL_RADIUS_DIRECTIONS[W] === 1 ? $ : N, q = 0;\n      if (S === W ? q = D : W === 0 ? q = U + Z : VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? q = t[e + Q][1] : VERTICAL_RADIUS_DIRECTIONS[W] === -1 && (q = B - (t[e + Q][1] - U)), o.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[W],\n        pos: [K, q]\n      }), t.push([K, q]), W === 0)\n        break;\n    }\n  }\n}\nfunction splitRadiusPoses(o, t) {\n  t === void 0 && (t = o.map(function(S) {\n    return S.raw;\n  }));\n  var e = o.map(function(S, T) {\n    return S.horizontal ? t[T] : null;\n  }).filter(function(S) {\n    return S != null;\n  }), r = o.map(function(S, T) {\n    return S.vertical ? t[T] : null;\n  }).filter(function(S) {\n    return S != null;\n  });\n  return {\n    horizontals: e,\n    verticals: r\n  };\n}\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]], CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction getClipStyles(o, t, e) {\n  var r = o.props.clipRelative, S = o.state, T = S.width, D = S.height, N = t, B = N.type, $ = N.poses, U = B === \"rect\", V = B === \"circle\";\n  if (B === \"polygon\")\n    return e.map(function(et) {\n      return \"\".concat(convertCSSSize(et[0], T, r), \" \").concat(convertCSSSize(et[1], D, r));\n    });\n  if (U || B === \"inset\") {\n    var H = e[1][1], X = e[3][0], Y = e[7][0], W = e[5][1];\n    if (U)\n      return [H, X, W, Y].map(function(et) {\n        return \"\".concat(et, \"px\");\n      });\n    var q = [H, T - X, D - W, Y].map(function(et, nt) {\n      return convertCSSSize(et, nt % 2 ? T : D, r);\n    });\n    if (e.length > 8) {\n      var K = minus(e[4], e[0]), Z = K[0], J = K[1];\n      q.push.apply(q, __spreadArray([\"round\"], getRadiusStyles($.slice(8).map(function(et, nt) {\n        return __assign$1(__assign$1({}, et), {\n          pos: e[nt]\n        });\n      }), r, Z, J, Y, H, X, W).styles, !1));\n    }\n    return q;\n  } else if (V || B === \"ellipse\") {\n    var Q = e[0], rt = convertCSSSize(Math.abs(e[1][1] - Q[1]), V ? Math.sqrt((T * T + D * D) / 2) : D, r), q = V ? [rt] : [convertCSSSize(Math.abs(e[2][0] - Q[0]), T, r), rt];\n    return q.push(\"at\", convertCSSSize(Q[0], T, r), convertCSSSize(Q[1], D, r)), q;\n  }\n}\nfunction getRectPoses(o, t, e, r) {\n  var S = [r, (r + t) / 2, t], T = [o, (o + e) / 2, e];\n  return CLIP_RECT_DIRECTIONS.map(function(D) {\n    var N = D[0], B = D[1], $ = D[2], U = S[N + 1], V = T[B + 1];\n    return {\n      vertical: Math.abs(B),\n      horizontal: Math.abs(N),\n      direction: $,\n      pos: [U, V]\n    };\n  });\n}\nfunction getControlSize(o) {\n  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];\n  return o.forEach(function(r) {\n    var S = r.pos;\n    t[0] = Math.min(t[0], S[0]), t[1] = Math.max(t[1], S[0]), e[0] = Math.min(e[0], S[1]), e[1] = Math.max(e[1], S[1]);\n  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];\n}\nfunction getClipPath(o, t, e, r, S) {\n  var T, D, N, B, $, U, V;\n  if (!!o) {\n    var H = S;\n    if (!H) {\n      var X = getComputedStyle(o), Y = X.clipPath;\n      H = Y !== \"none\" ? Y : X.clip;\n    }\n    if (!((!H || H === \"none\" || H === \"auto\") && (H = r, !H))) {\n      var W = splitBracket(H), q = W.prefix, K = q === void 0 ? H : q, Z = W.value, J = Z === void 0 ? \"\" : Z, Q = K === \"circle\", rt = \" \";\n      if (K === \"polygon\") {\n        var et = splitComma(J || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n        rt = \",\";\n        var nt = et.map(function(Wt) {\n          var ee = Wt.split(\" \"), Jt = ee[0], xe = ee[1];\n          return {\n            vertical: 1,\n            horizontal: 1,\n            pos: [convertUnitSize(Jt, t), convertUnitSize(xe, e)]\n          };\n        }), st = getMinMaxs(nt.map(function(Wt) {\n          return Wt.pos;\n        }));\n        return {\n          type: K,\n          clipText: H,\n          poses: nt,\n          splitter: rt,\n          left: st.minX,\n          right: st.maxX,\n          top: st.minY,\n          bottom: st.maxY\n        };\n      } else if (Q || K === \"ellipse\") {\n        var it = \"\", at = \"\", ut = 0, ct = 0, et = splitSpace(J);\n        if (Q) {\n          var gt = \"\";\n          T = et[0], gt = T === void 0 ? \"50%\" : T, D = et[2], it = D === void 0 ? \"50%\" : D, N = et[3], at = N === void 0 ? \"50%\" : N, ut = convertUnitSize(gt, Math.sqrt((t * t + e * e) / 2)), ct = ut;\n        } else {\n          var _t = \"\", vt = \"\";\n          B = et[0], _t = B === void 0 ? \"50%\" : B, $ = et[1], vt = $ === void 0 ? \"50%\" : $, U = et[3], it = U === void 0 ? \"50%\" : U, V = et[4], at = V === void 0 ? \"50%\" : V, ut = convertUnitSize(_t, t), ct = convertUnitSize(vt, e);\n        }\n        var mt = [convertUnitSize(it, t), convertUnitSize(at, e)], nt = __spreadArray([{\n          vertical: 1,\n          horizontal: 1,\n          pos: mt,\n          direction: \"nesw\"\n        }], CLIP_DIRECTIONS.slice(0, Q ? 1 : 2).map(function(Jt) {\n          return {\n            vertical: Math.abs(Jt[1]),\n            horizontal: Jt[0],\n            direction: Jt[2],\n            sub: !0,\n            pos: [mt[0] + Jt[0] * ut, mt[1] + Jt[1] * ct]\n          };\n        }), !0);\n        return {\n          type: K,\n          clipText: H,\n          radiusX: ut,\n          radiusY: ct,\n          left: mt[0] - ut,\n          top: mt[1] - ct,\n          right: mt[0] + ut,\n          bottom: mt[1] + ct,\n          poses: nt,\n          splitter: rt\n        };\n      } else if (K === \"inset\") {\n        var et = splitSpace(J || \"0 0 0 0\"), bt = et.indexOf(\"round\"), Ct = (bt > -1 ? et.slice(0, bt) : et).length, St = et.slice(Ct + 1), pt = et.slice(0, Ct), yt = pt[0], At = pt[1], Dt = At === void 0 ? yt : At, Ot = pt[2], Pt = Ot === void 0 ? yt : Ot, ft = pt[3], Ft = ft === void 0 ? Dt : ft, It = [yt, Pt].map(function(Jt) {\n          return convertUnitSize(Jt, e);\n        }), zt = It[0], kt = It[1], Tt = [Ft, Dt].map(function(Jt) {\n          return convertUnitSize(Jt, t);\n        }), jt = Tt[0], Nt = Tt[1], Et = t - Nt, Lt = e - kt, Ht = getRadiusValues(St, Et - jt, Lt - zt, jt, zt), nt = __spreadArray(__spreadArray([], getRectPoses(zt, Et, Lt, jt), !0), Ht, !0);\n        return {\n          type: \"inset\",\n          clipText: H,\n          poses: nt,\n          top: zt,\n          left: jt,\n          right: Et,\n          bottom: Lt,\n          radius: St,\n          splitter: rt\n        };\n      } else if (K === \"rect\") {\n        var et = splitComma(J || \"0px, \".concat(t, \"px, \").concat(e, \"px, 0px\"));\n        rt = \",\";\n        var wt = et.map(function(me) {\n          var pe = splitUnit(me).value;\n          return pe;\n        }), zt = wt[0], Nt = wt[1], kt = wt[2], jt = wt[3], nt = getRectPoses(zt, Nt, kt, jt);\n        return {\n          type: \"rect\",\n          clipText: H,\n          poses: nt,\n          top: zt,\n          right: Nt,\n          bottom: kt,\n          left: jt,\n          values: et,\n          splitter: rt\n        };\n      }\n    }\n  }\n}\nfunction moveControlPos(o, t, e, r, S) {\n  var T = o[t], D = T.direction, N = T.sub, B = o.map(function() {\n    return [0, 0];\n  }), $ = D ? D.split(\"\") : [];\n  if (r && t < 8) {\n    var U = $.filter(function(gt) {\n      return gt === \"w\" || gt === \"e\";\n    }), V = $.filter(function(gt) {\n      return gt === \"n\" || gt === \"s\";\n    }), H = U[0], X = V[0];\n    B[t] = e;\n    var Y = getControlSize(o), W = Y[0], q = Y[1], K = W && q ? W / q : 0;\n    if (K && S) {\n      var Z = (t + 4) % 8, J = o[Z].pos, Q = [0, 0];\n      D.indexOf(\"w\") > -1 ? Q[0] = -1 : D.indexOf(\"e\") > -1 && (Q[0] = 1), D.indexOf(\"n\") > -1 ? Q[1] = -1 : D.indexOf(\"s\") > -1 && (Q[1] = 1);\n      var rt = getSizeDistByDist([W, q], e, K, Q, !0), et = W + rt[0], nt = q + rt[1], st = J[1], it = J[1], at = J[0], ut = J[0];\n      Q[0] === -1 ? at = ut - et : Q[0] === 1 ? ut = at + et : (at = at - et / 2, ut = ut + et / 2), Q[1] === -1 ? st = it - nt : (Q[1] === 1 || (st = it - nt / 2), it = st + nt);\n      var ct = getRectPoses(st, ut, it, at);\n      o.forEach(function(gt, _t) {\n        B[_t][0] = ct[_t].pos[0] - gt.pos[0], B[_t][1] = ct[_t].pos[1] - gt.pos[1];\n      });\n    } else\n      o.forEach(function(gt, _t) {\n        var vt = gt.direction;\n        !vt || (vt.indexOf(H) > -1 && (B[_t][0] = e[0]), vt.indexOf(X) > -1 && (B[_t][1] = e[1]));\n      }), H && (B[1][0] = e[0] / 2, B[5][0] = e[0] / 2), X && (B[3][1] = e[1] / 2, B[7][1] = e[1] / 2);\n  } else\n    D && !N ? $.forEach(function(gt) {\n      var _t = gt === \"n\" || gt === \"s\";\n      o.forEach(function(vt, mt) {\n        var bt = vt.direction, Ct = vt.horizontal, St = vt.vertical;\n        !bt || bt.indexOf(gt) === -1 || (B[mt] = [_t || !Ct ? 0 : e[0], !_t || !St ? 0 : e[1]]);\n      });\n    }) : B[t] = e;\n  return B;\n}\nfunction addClipPath(o, t) {\n  var e = calculatePointerDist(o, t), r = e[0], S = e[1], T = t.datas, D = T.clipPath, N = T.clipIndex, B = D, $ = B.type, U = B.poses, V = B.splitter, H = U.map(function(Z) {\n    return Z.pos;\n  });\n  if ($ === \"polygon\")\n    H.splice(N, 0, [r, S]);\n  else if ($ === \"inset\") {\n    var X = HORIZONTAL_RADIUS_ORDER.indexOf(N), Y = VERTICAL_RADIUS_ORDER.indexOf(N), W = U.length;\n    if (addRadiusPos(U, H, 8, X, Y, r, S, H[4][0], H[4][1], H[0][0], H[0][1]), W === U.length)\n      return;\n  } else\n    return;\n  var q = getClipStyles(o, D, H), K = \"\".concat($, \"(\").concat(q.join(V), \")\");\n  triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n    clipEventType: \"added\",\n    clipType: $,\n    poses: H,\n    clipStyles: q,\n    clipStyle: K,\n    distX: 0,\n    distY: 0\n  }, fillCSSObject({\n    clipPath: K\n  }, t))));\n}\nfunction removeClipPath(o, t) {\n  var e = t.datas, r = e.clipPath, S = e.clipIndex, T = r, D = T.type, N = T.poses, B = T.splitter, $ = N.map(function(X) {\n    return X.pos;\n  }), U = $.length;\n  if (D === \"polygon\")\n    N.splice(S, 1), $.splice(S, 1);\n  else if (D === \"inset\") {\n    if (S < 8 || (removeRadiusPos(N, $, S, 8, U), U === N.length))\n      return;\n  } else\n    return;\n  var V = getClipStyles(o, r, $), H = \"\".concat(D, \"(\").concat(V.join(B), \")\");\n  triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n    clipEventType: \"removed\",\n    clipType: D,\n    poses: $,\n    clipStyles: V,\n    clipStyle: H,\n    distX: 0,\n    distY: 0\n  }, fillCSSObject({\n    clipPath: H\n  }, t))));\n}\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    keepRatio: Boolean,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [`.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`, `:host {\n    --bounds-color: #d66;\n}`, `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`, `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`],\n  render: function(o, t) {\n    var e = o.props, r = e.customClipPath, S = e.defaultClipPath, T = e.clipArea, D = e.zoom, N = o.getState(), B = N.target, $ = N.width, U = N.height, V = N.allMatrix, H = N.is3d, X = N.left, Y = N.top, W = N.pos1, q = N.pos2, K = N.pos3, Z = N.pos4, J = N.clipPathState, Q = N.snapBoundInfos, rt = N.rotation;\n    if (!B)\n      return [];\n    var et = getClipPath(B, $, U, S || \"inset\", J || r);\n    if (!et)\n      return [];\n    var nt = H ? 4 : 3, st = et.type, it = et.poses, at = it.map(function(Et) {\n      var Lt = calculatePosition(V, Et.pos, nt);\n      return [Lt[0] - X, Lt[1] - Y];\n    }), ut = [], ct = [], gt = st === \"rect\", _t = st === \"inset\", vt = st === \"polygon\";\n    if (gt || _t || vt) {\n      var mt = _t ? at.slice(0, 8) : at;\n      ct = mt.map(function(Et, Lt) {\n        var Ht = Lt === 0 ? mt[mt.length - 1] : mt[Lt - 1], wt = getRad$1(Ht, Et), Wt = getDiagonalSize(Ht, Et);\n        return t.createElement(\"div\", {\n          key: \"clipLine\".concat(Lt),\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": Lt,\n          style: {\n            width: \"\".concat(Wt, \"px\"),\n            transform: \"translate(\".concat(Ht[0], \"px, \").concat(Ht[1], \"px) rotate(\").concat(wt, \"rad) scaleY(\").concat(D, \")\")\n          }\n        });\n      });\n    }\n    if (ut = at.map(function(Et, Lt) {\n      return t.createElement(\"div\", {\n        key: \"clipControl\".concat(Lt),\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": Lt,\n        style: {\n          transform: \"translate(\".concat(Et[0], \"px, \").concat(Et[1], \"px) rotate(\").concat(rt, \"rad) scale(\").concat(D, \")\")\n        }\n      });\n    }), _t && ut.push.apply(ut, at.slice(8).map(function(Et, Lt) {\n      return t.createElement(\"div\", {\n        key: \"clipRadiusControl\".concat(Lt),\n        className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n        \"data-clip-index\": 8 + Lt,\n        style: {\n          transform: \"translate(\".concat(Et[0], \"px, \").concat(Et[1], \"px) rotate(\").concat(rt, \"rad) scale(\").concat(D, \")\")\n        }\n      });\n    })), st === \"circle\" || st === \"ellipse\") {\n      var bt = et.left, Ct = et.top, St = et.radiusX, pt = et.radiusY, yt = minus(calculatePosition(V, [bt, Ct], nt), calculatePosition(V, [0, 0], nt)), At = yt[0], Dt = yt[1], Ot = \"none\";\n      if (!T) {\n        for (var Pt = Math.max(10, St / 5, pt / 5), ft = [], Ft = 0; Ft <= Pt; ++Ft) {\n          var It = Math.PI * 2 / Pt * Ft;\n          ft.push([St + (St - D) * Math.cos(It), pt + (pt - D) * Math.sin(It)]);\n        }\n        ft.push([St, -2]), ft.push([-2, -2]), ft.push([-2, pt * 2 + 2]), ft.push([St * 2 + 2, pt * 2 + 2]), ft.push([St * 2 + 2, -2]), ft.push([St, -2]), Ot = \"polygon(\".concat(ft.map(function(Et) {\n          return \"\".concat(Et[0], \"px \").concat(Et[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      ut.push(t.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(St * 2, \"px\"),\n          height: \"\".concat(pt * 2, \"px\"),\n          clipPath: Ot,\n          transform: \"translate(\".concat(-X + At, \"px, \").concat(-Y + Dt, \"px) \").concat(makeMatrixCSS(V))\n        }\n      }));\n    }\n    if (T) {\n      var zt = getRect(__spreadArray([W, q, K, Z], at, !0)), kt = zt.width, Tt = zt.height, jt = zt.left, Nt = zt.top;\n      if (vt || gt || _t) {\n        var ft = _t ? at.slice(0, 8) : at;\n        ut.push(t.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(kt, \"px\"),\n            height: \"\".concat(Tt, \"px\"),\n            transform: \"translate(\".concat(jt, \"px, \").concat(Nt, \"px)\"),\n            clipPath: \"polygon(\".concat(ft.map(function(Lt) {\n              return \"\".concat(Lt[0] - jt, \"px \").concat(Lt[1] - Nt, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    return Q && [\"vertical\", \"horizontal\"].forEach(function(Et) {\n      var Lt = Q[Et], Ht = Et === \"horizontal\";\n      Lt.isSnap && ct.push.apply(ct, Lt.snap.posInfos.map(function(wt, Wt) {\n        var ee = wt.pos, Jt = minus(calculatePosition(V, Ht ? [0, ee] : [ee, 0], nt), [X, Y]), xe = minus(calculatePosition(V, Ht ? [$, ee] : [ee, U], nt), [X, Y]);\n        return renderLine(t, \"\", Jt, xe, D, \"clip\".concat(Et, \"snap\").concat(Wt), \"guideline\");\n      })), Lt.isBound && ct.push.apply(ct, Lt.bounds.map(function(wt, Wt) {\n        var ee = wt.pos, Jt = minus(calculatePosition(V, Ht ? [0, ee] : [ee, 0], nt), [X, Y]), xe = minus(calculatePosition(V, Ht ? [$, ee] : [ee, U], nt), [X, Y]);\n        return renderLine(t, \"\", Jt, xe, D, \"clip\".concat(Et, \"bounds\").concat(Wt), \"guideline\", \"bounds\", \"bold\");\n      }));\n    }), __spreadArray(__spreadArray([], ut, !0), ct, !0);\n  },\n  dragControlCondition: function(o, t) {\n    return t.inputEvent && (t.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(o, t) {\n    var e = o.props, r = e.dragWithClip, S = r === void 0 ? !0 : r;\n    return S ? !1 : this.dragControlStart(o, t);\n  },\n  drag: function(o, t) {\n    return this.dragControl(o, __assign$1(__assign$1({}, t), {\n      isDragTarget: !0\n    }));\n  },\n  dragEnd: function(o, t) {\n    return this.dragControlEnd(o, t);\n  },\n  dragControlStart: function(o, t) {\n    var e = o.state, r = o.props, S = r.defaultClipPath, T = r.customClipPath, D = e.target, N = e.width, B = e.height, $ = t.inputEvent ? t.inputEvent.target : null, U = $ && $.getAttribute(\"class\") || \"\", V = t.datas, H = getClipPath(D, N, B, S || \"inset\", T);\n    if (!H)\n      return !1;\n    var X = H.clipText, Y = H.type, W = H.poses, q = triggerEvent(o, \"onClipStart\", fillParams(o, t, {\n      clipType: Y,\n      clipStyle: X,\n      poses: W.map(function(K) {\n        return K.pos;\n      })\n    }));\n    return q === !1 ? (V.isClipStart = !1, !1) : (V.isControl = U && U.indexOf(\"clip-control\") > -1, V.isLine = U.indexOf(\"clip-line\") > -1, V.isArea = U.indexOf(\"clip-area\") > -1 || U.indexOf(\"clip-ellipse\") > -1, V.clipIndex = $ ? parseInt($.getAttribute(\"data-clip-index\"), 10) : -1, V.clipPath = H, V.isClipStart = !0, e.clipPathState = X, setDragStart(o, t), !0);\n  },\n  dragControl: function(o, t) {\n    var e, r, S = t.datas, T = t.originalDatas, D = t.isDragTarget;\n    if (!S.isClipStart)\n      return !1;\n    var N = S, B = N.isControl, $ = N.isLine, U = N.isArea, V = N.clipIndex, H = N.clipPath;\n    if (!H)\n      return !1;\n    var X = getProps(o.props, \"clippable\"), Y = X.keepRatio, W = 0, q = 0, K = T.draggable, Z = getDragDist(t);\n    D && K ? (e = K.prevBeforeDist, W = e[0], q = e[1]) : (W = Z[0], q = Z[1]);\n    var J = [W, q], Q = o.state, rt = Q.width, et = Q.height, nt = !U && !B && !$, st = H.type, it = H.poses, at = H.splitter, ut = it.map(function(dt) {\n      return dt.pos;\n    });\n    nt && (W = -W, q = -q);\n    var ct = !B || it[V].direction === \"nesw\", gt = st === \"inset\" || st === \"rect\", _t = it.map(function() {\n      return [0, 0];\n    });\n    if (B && !ct) {\n      var vt = it[V], mt = vt.horizontal, bt = vt.vertical, Ct = [W * Math.abs(mt), q * Math.abs(bt)];\n      _t = moveControlPos(it, V, Ct, gt, Y);\n    } else\n      ct && (_t = ut.map(function() {\n        return [W, q];\n      }));\n    var St = ut.map(function(dt, xt) {\n      return plus(dt, _t[xt]);\n    }), pt = __spreadArray([], St, !0);\n    Q.snapBoundInfos = null;\n    var yt = H.type === \"circle\", At = H.type === \"ellipse\";\n    if (yt || At) {\n      var Dt = getRect(St), Ot = Math.abs(Dt.bottom - Dt.top), Pt = Math.abs(At ? Dt.right - Dt.left : Ot), ft = St[0][1] + Ot, Ft = St[0][0] - Pt, It = St[0][0] + Pt;\n      yt && (pt.push([It, Dt.bottom]), _t.push([1, 0])), pt.push([Dt.left, ft]), _t.push([0, 1]), pt.push([Ft, Dt.bottom]), _t.push([1, 0]);\n    }\n    var zt = getDefaultGuidelines((X.clipHorizontalGuidelines || []).map(function(dt) {\n      return convertUnitSize(\"\".concat(dt), et);\n    }), (X.clipVerticalGuidelines || []).map(function(dt) {\n      return convertUnitSize(\"\".concat(dt), rt);\n    }), rt, et), kt = [], Tt = [];\n    if (yt || At)\n      kt = [pt[4][0], pt[2][0]], Tt = [pt[1][1], pt[3][1]];\n    else if (gt) {\n      var jt = [pt[0], pt[2], pt[4], pt[6]], Nt = [_t[0], _t[2], _t[4], _t[6]];\n      kt = jt.filter(function(dt, xt) {\n        return Nt[xt][0];\n      }).map(function(dt) {\n        return dt[0];\n      }), Tt = jt.filter(function(dt, xt) {\n        return Nt[xt][1];\n      }).map(function(dt) {\n        return dt[1];\n      });\n    } else\n      kt = pt.filter(function(dt, xt) {\n        return _t[xt][0];\n      }).map(function(dt) {\n        return dt[0];\n      }), Tt = pt.filter(function(dt, xt) {\n        return _t[xt][1];\n      }).map(function(dt) {\n        return dt[1];\n      });\n    var Et = [0, 0], Lt = checkSnapBounds(zt, X.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: rt,\n      bottom: et\n    }, kt, Tt, 5), Ht = Lt.horizontal, wt = Lt.vertical, Wt = Ht.offset, ee = wt.offset;\n    if (Ht.isBound && (Et[1] += Wt), wt.isBound && (Et[0] += ee), (At || yt) && _t[0][0] === 0 && _t[0][1] === 0) {\n      var Dt = getRect(St), Jt = Dt.bottom - Dt.top, xe = At ? Dt.right - Dt.left : Jt, ke = wt.isBound ? Math.abs(ee) : wt.snapIndex === 0 ? -ee : ee, ue = Ht.isBound ? Math.abs(Wt) : Ht.snapIndex === 0 ? -Wt : Wt;\n      xe -= ke, Jt -= ue, yt && (Jt = checkSnapBoundPriority(wt, Ht) > 0 ? Jt : xe, xe = Jt);\n      var me = pt[0];\n      pt[1][1] = me[1] - Jt, pt[2][0] = me[0] + xe, pt[3][1] = me[1] + Jt, pt[4][0] = me[0] - xe;\n    } else if (gt && Y && B) {\n      var pe = getControlSize(it), fe = pe[0], ce = pe[1], ie = fe && ce ? fe / ce : 0, ze = it[V], ds = ze.direction || \"\", $a = pt[1][1], ft = pt[5][1], Ft = pt[7][0], It = pt[3][0];\n      Wt <= ee ? Wt = ee / ie : ee = Wt * ie, ds.indexOf(\"w\") > -1 ? Ft -= ee : ds.indexOf(\"e\") > -1 ? It -= ee : (Ft += ee / 2, It -= ee / 2), ds.indexOf(\"n\") > -1 ? $a -= Wt : ds.indexOf(\"s\") > -1 ? ft -= Wt : ($a += Wt / 2, ft -= Wt / 2);\n      var Gc = getRectPoses($a, It, ft, Ft);\n      pt.forEach(function(Bt, $t) {\n        var Gt;\n        Gt = Gc[$t].pos, Bt[0] = Gt[0], Bt[1] = Gt[1];\n      });\n    } else\n      pt.forEach(function(dt, xt) {\n        var Mt = _t[xt];\n        Mt[0] && (dt[0] -= ee), Mt[1] && (dt[1] -= Wt);\n      });\n    var Ga = getClipStyles(o, H, St), ps = \"\".concat(st, \"(\").concat(Ga.join(at), \")\");\n    if (Q.clipPathState = ps, yt || At)\n      kt = [pt[4][0], pt[2][0]], Tt = [pt[1][1], pt[3][1]];\n    else if (gt) {\n      var jt = [pt[0], pt[2], pt[4], pt[6]];\n      kt = jt.map(function(xt) {\n        return xt[0];\n      }), Tt = jt.map(function(xt) {\n        return xt[1];\n      });\n    } else\n      kt = pt.map(function(dt) {\n        return dt[0];\n      }), Tt = pt.map(function(dt) {\n        return dt[1];\n      });\n    if (Q.snapBoundInfos = checkSnapBounds(zt, X.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: rt,\n      bottom: et\n    }, kt, Tt, 1), K) {\n      var Ql = Q.is3d, tu = Q.allMatrix, Uc = Ql ? 4 : 3, ht = Et;\n      D && (ht = [J[0] + Et[0] - Z[0], J[1] + Et[1] - Z[1]]), K.deltaOffset = multiply(tu, [ht[0], ht[1], 0, 0], Uc);\n    }\n    return triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n      clipEventType: \"changed\",\n      clipType: st,\n      poses: St,\n      clipStyle: ps,\n      clipStyles: Ga,\n      distX: W,\n      distY: q\n    }, fillCSSObject((r = {}, r[st === \"rect\" ? \"clip\" : \"clipPath\"] = ps, r), t)))), !0;\n  },\n  dragControlEnd: function(o, t) {\n    this.unset(o);\n    var e = t.isDrag, r = t.datas, S = t.isDouble, T = r.isLine, D = r.isClipStart, N = r.isControl;\n    return D ? (triggerEvent(o, \"onClipEnd\", fillEndParams(o, t, {})), S && (N ? removeClipPath(o, t) : T && addClipPath(o, t)), S || e) : !1;\n  },\n  unset: function(o) {\n    o.state.clipPathState = \"\", o.state.snapBoundInfos = null;\n  }\n}, OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [`:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`],\n  dragControlCondition: function(o, t) {\n    return t.isRequest ? t.requestAble === \"originDraggable\" : hasClass(t.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function(o, t) {\n    var e = t.datas;\n    setDragStart(o, t);\n    var r = fillParams(o, t, {\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    }), S = triggerEvent(o, \"onDragOriginStart\", r);\n    return e.startOrigin = o.state.transformOrigin, e.startTargetOrigin = o.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, S === !1 ? (e.isDragOrigin = !1, !1) : r;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = t.isPinch, S = t.isRequest;\n    if (!e.isDragOrigin)\n      return !1;\n    var T = getDragDist(t), D = T[0], N = T[1], B = o.state, $ = B.width, U = B.height, V = B.offsetMatrix, H = B.targetMatrix, X = B.is3d, Y = o.props.originRelative, W = Y === void 0 ? !0 : Y, q = X ? 4 : 3, K = [D, N];\n    if (S) {\n      var Z = t.distOrigin;\n      (Z[0] || Z[1]) && (K = Z);\n    }\n    var J = plus(e.startOrigin, K), Q = plus(e.startTargetOrigin, K), rt = minus(K, e.prevOrigin), et = getNextMatrix(V, H, J, q), nt = o.getRect(), st = getRect(calculatePoses(et, $, U, q)), it = [nt.left - st.left, nt.top - st.top];\n    e.prevOrigin = K;\n    var at = [convertCSSSize(Q[0], $, W), convertCSSSize(Q[1], U, W)].join(\" \"), ut = Draggable.drag(o, setCustomDrag(t, o.state, it, !!r, !1)), ct = fillParams(o, t, __assign$1(__assign$1({\n      width: $,\n      height: U,\n      origin: J,\n      dist: K,\n      delta: rt,\n      transformOrigin: at,\n      drag: ut\n    }, fillCSSObject({\n      transformOrigin: at,\n      transform: ut.transform\n    }, t)), {\n      afterTransform: ut.transform\n    }));\n    return triggerEvent(o, \"onDragOrigin\", ct), ct;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    return e.isDragOrigin ? (triggerEvent(o, \"onDragOriginEnd\", fillEndParams(o, t, {})), !0) : !1;\n  },\n  dragGroupControlCondition: function(o, t) {\n    return this.dragControlCondition(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    var e = this.dragControlStart(o, t);\n    return !!e;\n  },\n  dragGroupControl: function(o, t) {\n    var e = this.dragControl(o, t);\n    return e ? (o.transformOrigin = e.transformOrigin, !0) : !1;\n  },\n  request: function(o) {\n    var t = {}, e = o.getRect(), r = 0, S = 0, T = e.transformOrigin, D = [0, 0];\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(N) {\n        return \"deltaOrigin\" in N ? (D[0] += N.deltaOrigin[0], D[1] += N.deltaOrigin[1]) : \"origin\" in N ? (D[0] = N.origin[0] - T[0], D[1] = N.origin[1] - T[1]) : (\"x\" in N ? r = N.x - e.left : \"deltaX\" in N && (r += N.deltaX), \"y\" in N ? S = N.y - e.top : \"deltaY\" in N && (S += N.deltaY)), {\n          datas: t,\n          distX: r,\n          distY: S,\n          distOrigin: D\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction addBorderRadiusByLine(o, t, e, r) {\n  var S = o.filter(function(B) {\n    var $ = B.virtual, U = B.horizontal;\n    return U && !$;\n  }).length, T = o.filter(function(B) {\n    var $ = B.virtual, U = B.vertical;\n    return U && !$;\n  }).length, D = -1;\n  if (t === 0 && (S === 0 ? D = 0 : S === 1 && (D = 1)), t === 2 && (S <= 2 ? D = 2 : S <= 3 && (D = 3)), t === 3 && (T === 0 ? D = 4 : T < 4 && (D = 7)), t === 1 && (T <= 1 ? D = 5 : T <= 2 && (D = 6)), !(D === -1 || !o[D].virtual)) {\n    var N = o[D];\n    addBorderRadius(o, D), D < 4 ? N.pos[0] = e : N.pos[1] = r;\n  }\n}\nfunction addBorderRadius(o, t) {\n  t < 4 ? o.slice(0, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }) : (o[0].virtual && (o[0].virtual = !1), o.slice(4, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }));\n}\nfunction removeBorderRadius(o, t) {\n  t < 4 ? o.slice(t, 4).forEach(function(e) {\n    e.virtual = !0;\n  }) : o.slice(t).forEach(function(e) {\n    e.virtual = !0;\n  });\n}\nfunction getBorderRadius(o, t, e, r, S) {\n  r === void 0 && (r = [0, 0]);\n  var T = [];\n  return !o || o === \"0px\" ? T = [] : T = splitSpace(o), getRadiusValues(T, t, e, 0, 0, r, S);\n}\nfunction triggerRoundEvent(o, t, e, r, S) {\n  var T = o.state, D = T.width, N = T.height, B = getRadiusStyles(S, o.props.roundRelative, D, N), $ = B.raws, U = B.styles, V = B.radiusPoses, H = splitRadiusPoses(V, $), X = H.horizontals, Y = H.verticals, W = U.join(\" \");\n  T.borderRadiusState = W;\n  var q = fillParams(o, t, __assign$1({\n    horizontals: X,\n    verticals: Y,\n    borderRadius: W,\n    width: D,\n    height: N,\n    delta: r,\n    dist: e\n  }, fillCSSObject({\n    borderRadius: W\n  }, t)));\n  return triggerEvent(o, \"onRound\", q), q;\n}\nfunction getStyleBorderRadius(o) {\n  var t = o.getState().style, e = t.borderRadius || \"\";\n  if (!e && o.props.groupable) {\n    var r = o.getTargets()[0];\n    r && (e = getComputedStyle(r).borderRadius, t.borderRadius = e);\n  }\n  return e;\n}\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean,\n    roundPadding: Number,\n    isDisplayShadowRoundControls: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\",\n    onRoundGroupStart: \"roundGroupStart\",\n    onRoundGroup: \"roundGroup\",\n    onRoundGroupEnd: \"roundGroupEnd\"\n  },\n  css: [`.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n    z-index: 3;\n}`, `.control.border-radius.vertical {\n    background: #d6d;\n    z-index: 2;\n}`, `.control.border-radius.virtual {\n    opacity: 0.5;\n    z-index: 1;\n}`, `:host.round-line-clickable .line.direction {\n    cursor: pointer;\n}`],\n  className: function(o) {\n    var t = o.props.roundClickable;\n    return t === !0 || t === \"line\" ? prefix(\"round-line-clickable\") : \"\";\n  },\n  requestStyle: function() {\n    return [\"borderRadius\"];\n  },\n  render: function(o, t) {\n    var e = o.getState(), r = e.target, S = e.width, T = e.height, D = e.allMatrix, N = e.is3d, B = e.left, $ = e.top, U = e.borderRadiusState, V = o.props, H = V.minRoundControls, X = H === void 0 ? [0, 0] : H, Y = V.maxRoundControls, W = Y === void 0 ? [4, 4] : Y, q = V.zoom, K = V.roundPadding, Z = K === void 0 ? 0 : K, J = V.isDisplayShadowRoundControls, Q = V.groupable;\n    if (!r)\n      return null;\n    var rt = U || getStyleBorderRadius(o), et = N ? 4 : 3, nt = getBorderRadius(rt, S, T, X, !0);\n    if (!nt)\n      return null;\n    var st = 0, it = 0, at = Q ? [0, 0] : [B, $];\n    return nt.map(function(ut, ct) {\n      var gt = ut.horizontal, _t = ut.vertical, vt = ut.direction || \"\", mt = __spreadArray([], ut.pos, !0);\n      it += Math.abs(gt), st += Math.abs(_t), gt && vt.indexOf(\"n\") > -1 && (mt[1] -= Z), _t && vt.indexOf(\"w\") > -1 && (mt[0] -= Z), gt && vt.indexOf(\"s\") > -1 && (mt[1] += Z), _t && vt.indexOf(\"e\") > -1 && (mt[0] += Z);\n      var bt = minus(calculatePosition(D, mt, et), at), Ct = ut.vertical ? st <= W[1] && (J || !ut.virtual) : it <= W[0] && (J || !ut.virtual);\n      return t.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(ct),\n        className: prefix(\"control\", \"border-radius\", ut.vertical ? \"vertical\" : \"\", ut.virtual ? \"virtual\" : \"\"),\n        \"data-radius-index\": ct,\n        style: {\n          display: Ct ? \"block\" : \"none\",\n          transform: \"translate(\".concat(bt[0], \"px, \").concat(bt[1], \"px) scale(\").concat(q, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(o, t) {\n    if (!t.inputEvent || t.isRequest)\n      return !1;\n    var e = t.inputEvent.target.getAttribute(\"class\") || \"\";\n    return e.indexOf(\"border-radius\") > -1 || e.indexOf(\"moveable-line\") > -1 && e.indexOf(\"moveable-direction\") > -1;\n  },\n  dragGroupControlCondition: function(o, t) {\n    return this.dragControlCondition(o, t);\n  },\n  dragControlStart: function(o, t) {\n    var e = t.inputEvent, r = t.datas, S = e.target, T = S.getAttribute(\"class\") || \"\", D = T.indexOf(\"border-radius\") > -1, N = T.indexOf(\"moveable-line\") > -1 && T.indexOf(\"moveable-direction\") > -1, B = D ? parseInt(S.getAttribute(\"data-radius-index\"), 10) : -1, $ = -1;\n    if (N) {\n      var U = S.getAttribute(\"data-line-key\") || \"\";\n      U && ($ = parseInt(U.replace(/render-line-/g, \"\"), 10), isNaN($) && ($ = -1));\n    }\n    if (!D && !N)\n      return !1;\n    var V = fillParams(o, t, {}), H = triggerEvent(o, \"onRoundStart\", V);\n    if (H === !1)\n      return !1;\n    r.lineIndex = $, r.controlIndex = B, r.isControl = D, r.isLine = N, setDragStart(o, t);\n    var X = o.props, Y = X.roundRelative, W = X.minRoundControls, q = W === void 0 ? [0, 0] : W, K = o.state, Z = K.width, J = K.height;\n    r.isRound = !0, r.prevDist = [0, 0];\n    var Q = getStyleBorderRadius(o), rt = getBorderRadius(Q || \"\", Z, J, q, !0) || [];\n    return r.controlPoses = rt, K.borderRadiusState = getRadiusStyles(rt, Y, Z, J).styles.join(\" \"), V;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = e.controlPoses;\n    if (!e.isRound || !e.isControl || !r.length)\n      return !1;\n    var S = e.controlIndex, T = getDragDist(t), D = T[0], N = T[1], B = [D, N], $ = minus(B, e.prevDist), U = o.props.maxRoundControls, V = U === void 0 ? [4, 4] : U, H = o.state, X = H.width, Y = H.height, W = r[S], q = W.vertical, K = W.horizontal, Z = r.map(function(Q) {\n      var rt = Q.horizontal, et = Q.vertical, nt = [rt * K * B[0], et * q * B[1]];\n      if (rt) {\n        if (V[0] === 1)\n          return nt;\n        if (V[0] < 4 && rt !== K)\n          return nt;\n      } else {\n        if (V[1] === 0)\n          return nt[1] = et * K * B[0] / X * Y, nt;\n        if (q) {\n          if (V[1] === 1)\n            return nt;\n          if (V[1] < 4 && et !== q)\n            return nt;\n        }\n      }\n      return [0, 0];\n    });\n    Z[S] = B;\n    var J = r.map(function(Q, rt) {\n      return __assign$1(__assign$1({}, Q), {\n        pos: plus(Q.pos, Z[rt])\n      });\n    });\n    return S < 4 ? J.slice(0, S + 1).forEach(function(Q) {\n      Q.virtual = !1;\n    }) : J.slice(4, S + 1).forEach(function(Q) {\n      Q.virtual = !1;\n    }), e.prevDist = [D, N], triggerRoundEvent(o, t, B, $, J);\n  },\n  dragControlEnd: function(o, t) {\n    var e = o.state;\n    e.borderRadiusState = \"\";\n    var r = t.datas, S = t.isDouble;\n    if (!r.isRound)\n      return !1;\n    var T = r.isControl, D = r.controlIndex, N = r.isLine, B = r.lineIndex, $ = r.controlPoses, U = $.filter(function(K) {\n      var Z = K.virtual;\n      return Z;\n    }).length, V = o.props.roundClickable, H = V === void 0 ? !0 : V;\n    if (S && H) {\n      if (T && (H === !0 || H === \"control\"))\n        removeBorderRadius($, D);\n      else if (N && (H === !0 || H === \"line\")) {\n        var X = calculatePointerDist(o, t), Y = X[0], W = X[1];\n        addBorderRadiusByLine($, B, Y, W);\n      }\n      U !== $.filter(function(K) {\n        var Z = K.virtual;\n        return Z;\n      }).length && triggerRoundEvent(o, t, [0, 0], [0, 0], $);\n    }\n    var q = fillEndParams(o, t, {});\n    return triggerEvent(o, \"onRoundEnd\", q), e.borderRadiusState = \"\", q;\n  },\n  dragGroupControlStart: function(o, t) {\n    var e = this.dragControlStart(o, t);\n    if (!e)\n      return !1;\n    var r = o.moveables, S = o.props.targets, T = fillChildEvents(o, \"roundable\", t), D = __assign$1({\n      targets: o.props.targets,\n      events: T.map(function(N, B) {\n        return __assign$1(__assign$1({}, N), {\n          target: S[B],\n          moveable: r[B],\n          currentTarget: r[B]\n        });\n      })\n    }, e);\n    return triggerEvent(o, \"onRoundGroupStart\", D), e;\n  },\n  dragGroupControl: function(o, t) {\n    var e = this.dragControl(o, t);\n    if (!e)\n      return !1;\n    var r = o.moveables, S = o.props.targets, T = fillChildEvents(o, \"roundable\", t), D = __assign$1({\n      targets: o.props.targets,\n      events: T.map(function(N, B) {\n        return __assign$1(__assign$1(__assign$1({}, N), {\n          target: S[B],\n          moveable: r[B],\n          currentTarget: r[B]\n        }), fillCSSObject({\n          borderRadius: e.borderRadius\n        }, N));\n      })\n    }, e);\n    return triggerEvent(o, \"onRoundGroup\", D), D;\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = o.moveables, r = o.props.targets, S = fillChildEvents(o, \"roundable\", t);\n    catchEvent(o, \"onRound\", function(N) {\n      var B = __assign$1({\n        targets: o.props.targets,\n        events: S.map(function($, U) {\n          return __assign$1(__assign$1(__assign$1({}, $), {\n            target: r[U],\n            moveable: e[U],\n            currentTarget: e[U]\n          }), fillCSSObject({\n            borderRadius: N.borderRadius\n          }, $));\n        })\n      }, N);\n      triggerEvent(o, \"onRoundGroup\", B);\n    });\n    var T = this.dragControlEnd(o, t);\n    if (!T)\n      return !1;\n    var D = __assign$1({\n      targets: o.props.targets,\n      events: S.map(function(N, B) {\n        var $;\n        return __assign$1(__assign$1({}, N), {\n          target: r[B],\n          moveable: e[B],\n          currentTarget: e[B],\n          lastEvent: ($ = N.datas) === null || $ === void 0 ? void 0 : $.lastEvent\n        });\n      })\n    }, T);\n    return triggerEvent(o, \"onRoundGroupEnd\", D), D;\n  },\n  unset: function(o) {\n    o.state.borderRadiusState = \"\";\n  }\n};\nfunction isIdentityMatrix(o, t) {\n  var e = t ? 4 : 3, r = createIdentityMatrix(e), S = \"matrix\".concat(t ? \"3d\" : \"\", \"(\").concat(r.join(\",\"), \")\");\n  return o === S || o === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  setTransform: function(o, t) {\n    var e = o.state, r = e.is3d, S = e.target, T = e.targetMatrix, D = S == null ? void 0 : S.style.transform, N = r ? \"matrix3d(\".concat(T.join(\",\"), \")\") : \"matrix(\".concat(convertMatrixtoCSS(T, !0), \")\"), B = !D || D === \"none\" ? N : D;\n    t.datas.startTransforms = isIdentityMatrix(B, r) ? [] : splitSpace(B);\n  },\n  resetStyle: function(o) {\n    var t = o.datas;\n    t.nextStyle = {}, t.nextTransforms = o.datas.startTransforms, t.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(o, t) {\n    return fillParams(o, t, {\n      setTransform: function(e) {\n        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);\n      },\n      isPinch: !!t.isPinch\n    });\n  },\n  fillDragParams: function(o, t) {\n    return fillParams(o, t, {\n      isPinch: !!t.isPinch\n    });\n  },\n  dragStart: function(o, t) {\n    this.setTransform(o, t), this.resetStyle(t), triggerEvent(o, \"onBeforeRenderStart\", this.fillDragStartParams(o, t));\n  },\n  drag: function(o, t) {\n    this.resetStyle(t), triggerEvent(o, \"onBeforeRender\", fillParams(o, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  dragEnd: function(o, t) {\n    triggerEvent(o, \"onBeforeRenderEnd\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    }));\n  },\n  dragGroupStart: function(o, t) {\n    var e = this;\n    this.dragStart(o, t);\n    var r = fillChildEvents(o, \"beforeRenderable\", t), S = o.moveables, T = r.map(function(D, N) {\n      var B = S[N];\n      return e.setTransform(B, D), e.resetStyle(D), e.fillDragStartParams(B, D);\n    });\n    triggerEvent(o, \"onBeforeRenderGroupStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      setTransform: function() {\n      },\n      events: T\n    }));\n  },\n  dragGroup: function(o, t) {\n    var e = this;\n    this.drag(o, t);\n    var r = fillChildEvents(o, \"beforeRenderable\", t), S = o.moveables, T = r.map(function(D, N) {\n      var B = S[N];\n      return e.resetStyle(D), e.fillDragParams(B, D);\n    });\n    triggerEvent(o, \"onBeforeRenderGroup\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      events: T\n    }));\n  },\n  dragGroupEnd: function(o, t) {\n    this.dragEnd(o, t), triggerEvent(o, \"onBeforeRenderGroupEnd\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: o.props.targets\n    }));\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragGroupStart(o, t);\n  },\n  dragGroupControl: function(o, t) {\n    return this.dragGroup(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    return this.dragGroupEnd(o, t);\n  }\n}, Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  dragStart: function(o, t) {\n    triggerEvent(o, \"onRenderStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  drag: function(o, t) {\n    triggerEvent(o, \"onRender\", this.fillDragParams(o, t));\n  },\n  dragAfter: function(o, t) {\n    if (t.resultCount)\n      return this.drag(o, t);\n  },\n  dragEnd: function(o, t) {\n    triggerEvent(o, \"onRenderEnd\", this.fillDragEndParams(o, t));\n  },\n  dragGroupStart: function(o, t) {\n    triggerEvent(o, \"onRenderGroupStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets\n    }));\n  },\n  dragGroup: function(o, t) {\n    var e = this, r = fillChildEvents(o, \"beforeRenderable\", t), S = o.moveables, T = r.map(function(D, N) {\n      var B = S[N];\n      return e.fillDragParams(B, D);\n    });\n    triggerEvent(o, \"onRenderGroup\", fillParams(o, t, __assign$1(__assign$1({\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))), {\n      events: T\n    })));\n  },\n  dragGroupEnd: function(o, t) {\n    var e = this, r = fillChildEvents(o, \"beforeRenderable\", t), S = o.moveables, T = r.map(function(D, N) {\n      var B = S[N];\n      return e.fillDragEndParams(B, D);\n    });\n    triggerEvent(o, \"onRenderGroupEnd\", fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: o.props.targets,\n      events: T,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t)))));\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlAfter: function(o, t) {\n    return this.dragAfter(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragGroupStart(o, t);\n  },\n  dragGroupControl: function(o, t) {\n    return this.dragGroup(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    return this.dragGroupEnd(o, t);\n  },\n  fillDragParams: function(o, t) {\n    return fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))));\n  },\n  fillDragEndParams: function(o, t) {\n    return fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))));\n  }\n};\nfunction triggerAble(o, t, e, r, S, T, D) {\n  var N = S === \"Start\", B = o.state.target, $ = T.isRequest;\n  if (!B || N && r.indexOf(\"Control\") > -1 && !$ && o.areaElement === T.inputEvent.target)\n    return !1;\n  var U = \"\".concat(e).concat(r).concat(S), V = \"\".concat(e).concat(r, \"Condition\"), H = S === \"End\", X = S === \"After\", Y = N && (!o.targetGesto || !o.controlGesto || !o.targetGesto.isFlag() || !o.controlGesto.isFlag());\n  Y && o.updateRect(S, !0, !1), T.clientDistX = T.distX, T.clientDistY = T.distY, S === \"\" && !$ && convertDragDist(o.state, T);\n  var W = __spreadArray([], o[t], !0);\n  if ($) {\n    var q = T.requestAble;\n    W.some(function(ct) {\n      return ct.name === q;\n    }) || W.push.apply(W, o.props.ables.filter(function(ct) {\n      return ct.name === q;\n    }));\n  }\n  if (!W.length || W.every(function(ct) {\n    return ct.dragRelation;\n  }))\n    return !1;\n  var K = __spreadArray(__spreadArray([BeforeRenderable], W, !0), [Renderable], !1).filter(function(ct) {\n    return ct[U];\n  }), Z = T.datas;\n  Y && K.forEach(function(ct) {\n    ct.unset && ct.unset(o);\n  });\n  var J = T.inputEvent, Q;\n  H && J && (Q = document.elementFromPoint(T.clientX, T.clientY) || J.target);\n  var rt = 0, et = !1, nt = function() {\n    var ct;\n    et = !0, (ct = T.stop) === null || ct === void 0 || ct.call(T);\n  }, st = K.filter(function(ct) {\n    var gt = ct.name, _t = Z[gt] || (Z[gt] = {});\n    if (N && (_t.isEventStart = !ct[V] || ct[V](o, T)), _t.isEventStart) {\n      var vt = ct[U](o, __assign$1(__assign$1({}, T), {\n        stop: nt,\n        resultCount: rt,\n        datas: _t,\n        originalDatas: Z,\n        inputTarget: Q\n      }));\n      return o._emitter.off(), N && vt === !1 && (_t.isEventStart = !1), rt += vt || _t.isEventStart ? 1 : 0, vt;\n    }\n    return !1;\n  }), it = st.length, at = !1;\n  if (et && (at = !0), !at && N && K.length && !it && (at = K.filter(function(ct) {\n    var gt = ct.name, _t = Z[gt];\n    return _t.isEventStart ? ct.dragRelation !== \"strong\" : !1;\n  }).length), (H || at) && (o.state.gestos = {}, o.moveables && o.moveables.forEach(function(ct) {\n    ct.state.gestos = {};\n  }), K.forEach(function(ct) {\n    ct.unset && ct.unset(o);\n  })), N && !at && !$ && it && (T == null || T.preventDefault()), o.isUnmounted || at)\n    return !1;\n  if (!N && it && !D || H) {\n    var ut = o.props.flushSync || defaultSync;\n    ut(function() {\n      o.updateRect(H ? S : \"\", !0, !1), o.forceUpdate();\n    });\n  }\n  return !N && !H && !X && it && !D && triggerAble(o, t, e, r, S + \"After\", T), !0;\n}\nfunction checkMoveableTarget(o) {\n  return function(t) {\n    var e = o.props.dragTarget, r = t.inputEvent.target, S = o.areaElement;\n    return e && (r === e || e.contains(r)) || r === S || !o.isMoveableElement(r) && !o.controlBox.getElement().contains(r) || hasClass(r, \"moveable-area\") || hasClass(r, \"moveable-padding\") || hasClass(r, \"moveable-edgeDraggable\");\n  };\n}\nfunction getTargetAbleGesto(o, t, e) {\n  var r = o.controlBox.getElement(), S = [], T = o.props.dragTarget;\n  return S.push(r), (!o.props.dragArea || T) && S.push(t), getAbleGesto(o, S, \"targetAbles\", e, {\n    dragStart: checkMoveableTarget(o),\n    pinchStart: checkMoveableTarget(o)\n  });\n}\nfunction getAbleGesto(o, t, e, r, S) {\n  S === void 0 && (S = {});\n  var T = e === \"targetAbles\", D = o.props, N = D.pinchOutside, B = D.pinchThreshold, $ = D.preventClickEventOnDrag, U = D.preventClickDefault, V = D.checkInput, H = {\n    preventDefault: !0,\n    preventRightClick: !0,\n    preventWheelClick: !0,\n    container: window,\n    pinchThreshold: B,\n    pinchOutside: N,\n    preventClickEventOnDrag: T ? $ : !1,\n    preventClickEventOnDragStart: T ? U : !1,\n    preventClickEventByCondition: T ? null : function(W) {\n      return o.controlBox.getElement().contains(W.target);\n    },\n    checkInput: T ? V : !1\n  }, X = new Gesto$1(t, H), Y = r === \"Control\";\n  return [\"drag\", \"pinch\"].forEach(function(W) {\n    [\"Start\", \"\", \"End\"].forEach(function(q) {\n      X.on(\"\".concat(W).concat(q), function(K) {\n        var Z, J = K.eventType;\n        if (S[J] && !S[J](K)) {\n          K.stop();\n          return;\n        }\n        var Q = triggerAble(o, e, W, r, q, K);\n        Q ? (o.props.stopPropagation || q === \"Start\" && Y) && ((Z = K == null ? void 0 : K.inputEvent) === null || Z === void 0 || Z.stopPropagation()) : K.stop();\n      });\n    });\n  }), X;\n}\nvar EventManager = /* @__PURE__ */ function() {\n  function o(e, r, S) {\n    var T = this;\n    this.target = e, this.moveable = r, this.eventName = S, this.ables = [], this._onEvent = function(D) {\n      var N = T.eventName, B = T.moveable;\n      B.state.disableNativeEvent || T.ables.forEach(function($) {\n        $[N](B, {\n          inputEvent: D\n        });\n      });\n    }, e.addEventListener(S.toLowerCase(), this._onEvent);\n  }\n  var t = o.prototype;\n  return t.setAbles = function(e) {\n    this.ables = e;\n  }, t.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;\n  }, o;\n}();\nfunction getShadowRoot(o) {\n  if (o && o.getRootNode) {\n    var t = o.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction getMatrixStackInfo(o, t, e) {\n  for (var r = o, S = [], T = document.documentElement || document.body, D = !e && o === t || o === T, N = D, B = !1, $ = 3, U, V, H, X = !1, Y = getOffsetInfo(t, t, !0).offsetParent, W = 1; r && !N; ) {\n    N = D;\n    var q = getComputedStyle(r), K = q.position, Z = getElementTransform(r, q), J = convertCSStoMatrix(getTransformMatrix(Z)), Q = K === \"fixed\", rt = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    Q && (X = !0, rt = getPositionFixedInfo(r), Y = rt.fixedContainer);\n    var et = J.length;\n    !B && et === 16 && (B = !0, $ = 4, convert3DMatrixes(S), H && (H = convertDimension(H, 3, 4))), B && et === 9 && (J = convertDimension(J, 3, 4));\n    var nt = getOffsetPosInfo(r, o, q), st = nt.tagName, it = nt.hasOffset, at = nt.isSVG, ut = nt.origin, ct = nt.targetOrigin, gt = nt.offset, _t = gt[0], vt = gt[1];\n    st === \"svg\" && H && (S.push({\n      type: \"target\",\n      target: r,\n      matrix: getSVGMatrix(r, $)\n    }), S.push({\n      type: \"offset\",\n      target: r,\n      matrix: createIdentityMatrix($)\n    }));\n    var mt = void 0, bt = !1, Ct = !1, St = parseFloat(q.zoom) || 1;\n    if (Q)\n      mt = rt.fixedContainer, bt = !0;\n    else {\n      var pt = getOffsetInfo(r, t, !1, !0, q), yt = pt.offsetZoom;\n      if (mt = pt.offsetParent, bt = pt.isEnd, Ct = pt.isStatic, W *= yt, yt !== 1 && Ct)\n        _t -= mt.offsetLeft, vt -= mt.offsetTop;\n      else if (IS_FIREFOX) {\n        var At = pt.parentSlotElement;\n        if (At) {\n          for (var Dt = mt, Ot = 0, Pt = 0; Dt && getShadowRoot(Dt); )\n            Ot += Dt.offsetLeft, Pt += Dt.offsetTop, Dt = Dt.offsetParent;\n          _t -= Ot, vt -= Pt;\n        }\n      }\n    }\n    IS_WEBKIT && !IS_SAFARI_ABOVE15 && it && !at && Ct && (K === \"relative\" || K === \"static\") && (_t -= mt.offsetLeft, vt -= mt.offsetTop, D = D || bt);\n    var ft = 0, Ft = 0, It = 0, zt = 0;\n    if (Q)\n      it && rt.hasTransform && (It = mt.clientLeft, zt = mt.clientTop);\n    else if (it && Y !== mt && (ft = mt.clientLeft, Ft = mt.clientTop), it && mt === T) {\n      var kt = getBodyOffset(r, !1, q);\n      _t += kt[0], vt += kt[1];\n    }\n    if (S.push({\n      type: \"target\",\n      target: r,\n      matrix: getAbsoluteMatrix(J, $, ut)\n    }), it) {\n      var Tt = r === o, jt = Tt ? 0 : r.scrollLeft, Nt = Tt ? 0 : r.scrollTop;\n      S.push({\n        type: \"offset\",\n        target: r,\n        matrix: createOriginMatrix([_t - jt + ft - It, vt - Nt + Ft - zt], $)\n      });\n    } else\n      S.push({\n        type: \"offset\",\n        target: r,\n        origin: ut\n      });\n    if (St !== 1 && S.push({\n      type: \"zoom\",\n      target: r,\n      matrix: getAbsoluteMatrix(createScaleMatrix([St, St], $), $, [0, 0])\n    }), H || (H = J), U || (U = ut), V || (V = ct), N || Q)\n      break;\n    r = mt, D = bt, (!e || r === T) && (N = D);\n  }\n  return H || (H = createIdentityMatrix($)), U || (U = [0, 0]), V || (V = [0, 0]), {\n    zoom: W,\n    offsetContainer: Y,\n    matrixes: S,\n    targetMatrix: H,\n    transformOrigin: U,\n    targetOrigin: V,\n    is3d: B,\n    hasFixed: X\n  };\n}\nfunction calculateMatrixStack(o, t, e, r) {\n  var S;\n  e === void 0 && (e = t);\n  var T = getMatrixStackInfo(o, t), D = T.matrixes, N = T.is3d, B = T.targetMatrix, $ = T.transformOrigin, U = T.targetOrigin, V = T.offsetContainer, H = T.hasFixed, X = T.zoom, Y = getMatrixStackInfo(V, e, !0), W = Y.matrixes, q = Y.is3d, K = Y.offsetContainer, Z = Y.zoom, J = r || q || N, Q = J ? 4 : 3, rt = o.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in o, et = B, nt = createIdentityMatrix(Q), st = createIdentityMatrix(Q), it = createIdentityMatrix(Q), at = createIdentityMatrix(Q), ut = D.length;\n  W.reverse(), D.reverse(), !N && J && (et = convertDimension(et, 3, 4), convert3DMatrixes(D)), !q && J && convert3DMatrixes(W), W.forEach(function(Ct) {\n    st = multiply(st, Ct.matrix, Q);\n  });\n  var ct = e || document.body, gt = ((S = W[0]) === null || S === void 0 ? void 0 : S.target) || getOffsetInfo(ct, ct, !0).offsetParent, _t = W.slice(1).reduce(function(Ct, St) {\n    return multiply(Ct, St.matrix, Q);\n  }, createIdentityMatrix(Q));\n  D.forEach(function(Ct, St) {\n    if (ut - 2 === St && (it = nt.slice()), ut - 1 === St && (at = nt.slice()), !Ct.matrix) {\n      var pt = D[St + 1], yt = getSVGOffset(Ct, pt, gt, Q, multiply(_t, nt, Q));\n      Ct.matrix = createOriginMatrix(yt, Q);\n    }\n    nt = multiply(nt, Ct.matrix, Q);\n  });\n  var vt = !rt && N;\n  et || (et = createIdentityMatrix(vt ? 4 : 3));\n  var mt = makeMatrixCSS(rt && et.length === 16 ? convertDimension(et, 4, 3) : et, vt), bt = st;\n  return st = ignoreDimension(st, Q, Q), {\n    hasZoom: X !== 1 || Z !== 1,\n    hasFixed: H,\n    rootMatrix: st,\n    originalRootMatrix: bt,\n    beforeMatrix: it,\n    offsetMatrix: at,\n    allMatrix: nt,\n    targetMatrix: et,\n    targetTransform: mt,\n    transformOrigin: $,\n    targetOrigin: U,\n    is3d: J,\n    offsetContainer: V,\n    offsetRootContainer: K\n  };\n}\nfunction calculateElementInfo(o, t, e, r) {\n  e === void 0 && (e = t);\n  var S = 0, T = 0, D = 0, N = {}, B = getSize(o);\n  if (o && (S = B.offsetWidth, T = B.offsetHeight), o) {\n    var $ = calculateMatrixStack(o, t, e, r), U = calculateMoveablePosition($.allMatrix, $.transformOrigin, S, T);\n    N = __assign$1(__assign$1({}, $), U);\n    var V = calculateMoveablePosition($.allMatrix, [50, 50], 100, 100);\n    D = getRotationRad([V.pos1, V.pos2], V.direction);\n  }\n  var H = r ? 4 : 3;\n  return __assign$1(__assign$1(__assign$1({\n    hasZoom: !1,\n    width: S,\n    height: T,\n    rotation: D\n  }, B), {\n    originalRootMatrix: createIdentityMatrix(H),\n    rootMatrix: createIdentityMatrix(H),\n    beforeMatrix: createIdentityMatrix(H),\n    offsetMatrix: createIdentityMatrix(H),\n    allMatrix: createIdentityMatrix(H),\n    targetMatrix: createIdentityMatrix(H),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!r,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null\n  }), N);\n}\nfunction getMoveableTargetInfo(o, t, e, r, S, T) {\n  T === void 0 && (T = []);\n  var D = 1, N = [0, 0], B = resetClientRect(), $ = resetClientRect(), U = resetClientRect(), V = resetClientRect(), H = [0, 0], X = {}, Y = calculateElementInfo(t, e, S, !0);\n  if (t) {\n    var W = getComputedStyle(t);\n    T.forEach(function(ct) {\n      X[ct] = W[ct];\n    });\n    var q = Y.is3d ? 4 : 3, K = calculateMoveablePosition(Y.offsetMatrix, plus(Y.transformOrigin, getOrigin(Y.targetMatrix, q)), Y.width, Y.height);\n    D = K.direction, N = plus(K.origin, [K.left - Y.left, K.top - Y.top]), V = getClientRect(Y.offsetRootContainer);\n    var Z = getOffsetInfo(r, r, !0).offsetParent || Y.offsetRootContainer;\n    if (Y.hasZoom) {\n      var J = calculateMoveablePosition(multiply(Y.originalRootMatrix, Y.allMatrix), Y.transformOrigin, Y.width, Y.height), Q = calculateMoveablePosition(Y.originalRootMatrix, getTransformOrigin(getComputedStyle(Z)).map(function(ct) {\n        return parseFloat(ct);\n      }), Z.offsetWidth, Z.offsetHeight);\n      if (B = getClientRectByPosition(J, V), U = getClientRectByPosition(Q, V, Z, !0), o) {\n        var rt = J.left, et = J.top;\n        $ = getClientRectByPosition({\n          left: rt,\n          top: et,\n          bottom: et,\n          right: et\n        }, V);\n      }\n    } else {\n      B = getClientRect(t), U = getClientRect(Z, !0), o && ($ = getClientRect(o));\n      var nt = U.left, st = U.top, it = U.clientLeft, at = U.clientTop, ut = [B.left - nt, B.top - st];\n      H = minus(calculateInversePosition(Y.rootMatrix, ut, 4), [it + Y.left, at + Y.top]);\n    }\n  }\n  return __assign$1({\n    targetClientRect: B,\n    containerClientRect: U,\n    moveableClientRect: $,\n    rootContainerClientRect: V,\n    beforeDirection: D,\n    beforeOrigin: N,\n    originalBeforeOrigin: N,\n    target: t,\n    style: X,\n    offsetDelta: H\n  }, Y);\n}\nfunction getPersistState(o) {\n  var t = o.pos1, e = o.pos2, r = o.pos3, S = o.pos4;\n  if (!t || !e || !r || !S)\n    return null;\n  var T = getMinMaxs([t, e, r, S]), D = [T.minX, T.minY], N = minus(o.origin, D);\n  return t = minus(t, D), e = minus(e, D), r = minus(r, D), S = minus(S, D), __assign$1(__assign$1({}, o), {\n    left: o.left,\n    top: o.top,\n    posDelta: D,\n    pos1: t,\n    pos2: e,\n    pos3: r,\n    pos4: S,\n    origin: N,\n    beforeOrigin: N,\n    isPersisted: !0\n  });\n}\nvar MoveableManager$1 = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.state = __assign$1({\n      container: null,\n      gestos: {},\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: !1,\n      posDelta: [0, 0]\n    }, getMoveableTargetInfo(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {\n      mouseEnter: null,\n      mouseLeave: null\n    }, r._emitter = new EventEmitter$1(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._observer = null, r._observerId = 0, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r.checkUpdateRect = function() {\n      if (!r.isDragging()) {\n        var S = r.props.parentMoveable;\n        if (S) {\n          S.checkUpdateRect();\n          return;\n        }\n        cancelAnimationFrame$1(r._observerId), r._observerId = requestAnimationFrame$1(function() {\n          r.isDragging() || r.updateRect();\n        });\n      }\n    }, r._onPreventClick = function(S) {\n      S.stopPropagation(), S.preventDefault();\n    }, r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this.props, S = this.getState(), T = r.parentPosition, D = r.className, N = r.target, B = r.zoom, $ = r.cspNonce, U = r.translateZ, V = r.cssStyled, H = r.portalContainer, X = r.groupable;\n    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();\n    var Y = T || [0, 0], W = Y[0], q = Y[1], K = S.left, Z = S.top, J = S.target, Q = S.direction, rt = S.hasFixed, et = S.offsetDelta, nt = r.targets, st = this.isDragging(), it = {};\n    this.getEnabledAbles().forEach(function(_t) {\n      it[\"data-able-\".concat(_t.name.toLowerCase())] = !0;\n    });\n    var at = this._getAbleClassName(), ut = nt && nt.length && (J || X) || N || !this._hasFirstTarget && this.state.isPersisted, ct = this.controlBox || this.props.firstRenderState || this.props.persistData, gt = [K - W, Z - q];\n    return !X && r.useAccuratePosition && (gt[0] += et[0], gt[1] += et[1]), createElement(V, __assign$1({\n      cspNonce: $,\n      ref: ref(this, \"controlBox\"),\n      className: \"\".concat(prefix(\"control-box\", Q === -1 ? \"reverse\" : \"\", st ? \"dragging\" : \"\"), \" \").concat(at, \" \").concat(D)\n    }, it, {\n      onClick: this._onPreventClick,\n      portalContainer: H,\n      style: {\n        position: rt ? \"fixed\" : \"absolute\",\n        display: ut ? \"block\" : \"none\",\n        visibility: ct ? \"visible\" : \"hidden\",\n        transform: \"translate3d(\".concat(gt[0], \"px, \").concat(gt[1], \"px, \").concat(U, \")\"),\n        \"--zoom\": B,\n        \"--zoompx\": \"\".concat(B, \"px\")\n      }\n    }), this.renderAbles(), this._renderLines());\n  }, e.componentDidMount = function() {\n    this.isMoveableMounted = !0, this.isUnmounted = !1, this.controlBox.getElement();\n    var r = this.props, S = r.parentMoveable, T = r.container, D = r.wrapperMoveable;\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !T && !S && !D && !this.state.isPersisted && (this.updateRect(\"\", !1, !1), this.forceUpdate());\n  }, e.componentDidUpdate = function(r) {\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);\n  }, e.componentWillUnmount = function() {\n    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off();\n    var r = this._viewContainer;\n    r && this._changeAbleViewClassNames([]), unset(this, \"targetGesto\"), unset(this, \"controlGesto\");\n    var S = this.events;\n    for (var T in S) {\n      var D = S[T];\n      D && D.destroy();\n    }\n  }, e.getTargets = function() {\n    var r = this.props.target;\n    return r ? [r] : [];\n  }, e.getAble = function(r) {\n    var S = this.props.ables || [];\n    return find$1(S, function(T) {\n      return T.name === r;\n    });\n  }, e.getContainer = function() {\n    var r = this.props, S = r.parentMoveable, T = r.wrapperMoveable, D = r.container;\n    return D || T && T.getContainer() || S && S.getContainer() || this.controlBox.getElement().parentElement;\n  }, e.isMoveableElement = function(r) {\n    var S;\n    return r && (((S = r.getAttribute) === null || S === void 0 ? void 0 : S.call(r, \"class\")) || \"\").indexOf(PREFIX) > -1;\n  }, e.dragStart = function(r) {\n    var S = this.targetGesto, T = this.controlGesto;\n    return S && checkMoveableTarget(this)({\n      inputEvent: r\n    }) ? S.isFlag() || S.triggerDragStart(r) : T && this.isMoveableElement(r.target) && (T.isFlag() || T.triggerDragStart(r)), this;\n  }, e.hitTest = function(r) {\n    var S = this.state, T = S.target, D = S.pos1, N = S.pos2, B = S.pos3, $ = S.pos4, U = S.targetClientRect;\n    if (!T)\n      return 0;\n    var V;\n    if (r instanceof Element) {\n      var H = r.getBoundingClientRect();\n      V = {\n        left: H.left,\n        top: H.top,\n        width: H.width,\n        height: H.height\n      };\n    } else\n      V = __assign$1({\n        width: 0,\n        height: 0\n      }, r);\n    var X = V.left, Y = V.top, W = V.width, q = V.height, K = fitPoints([D, N, $, B], U), Z = getOverlapSize(K, [[X, Y], [X + W, Y], [X + W, Y + q], [X, Y + q]]), J = getAreaSize(K);\n    return !Z || !J ? 0 : Math.min(100, Z / J * 100);\n  }, e.isInside = function(r, S) {\n    var T = this.state, D = T.target, N = T.pos1, B = T.pos2, $ = T.pos3, U = T.pos4, V = T.targetClientRect;\n    return D ? isInside([r, S], fitPoints([N, B, U, $], V)) : !1;\n  }, e.updateRect = function(r, S, T) {\n    T === void 0 && (T = !0);\n    var D = this.props, N = D.parentMoveable, B = this.state, $ = B.target || this.props.target, U = this.getContainer(), V = N ? N._rootContainer : this._rootContainer, H = getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), $, U, U, V || U, this._getRequestStyles());\n    if (!$ && this._hasFirstTarget && D.persistData) {\n      var X = getPersistState(D.persistData);\n      for (var Y in X)\n        H[Y] = X[Y];\n    }\n    this.updateState(H, N ? !1 : T);\n  }, e.isDragging = function(r) {\n    var S, T, D = this.targetGesto, N = this.controlGesto;\n    if (D != null && D.isFlag()) {\n      if (!r)\n        return !0;\n      var B = D.getEventData();\n      return !!(!((S = B[r]) === null || S === void 0) && S.isEventStart);\n    }\n    if (N != null && N.isFlag()) {\n      if (!r)\n        return !0;\n      var B = N.getEventData();\n      return !!(!((T = B[r]) === null || T === void 0) && T.isEventStart);\n    }\n    return !1;\n  }, e.updateTarget = function(r) {\n    this.updateRect(r, !0);\n  }, e.getRect = function() {\n    var r = this.state, S = getAbsolutePosesByState(this.state), T = S[0], D = S[1], N = S[2], B = S[3], $ = getRect(S), U = r.width, V = r.height, H = $.width, X = $.height, Y = $.left, W = $.top, q = [r.left, r.top], K = plus(q, r.origin), Z = plus(q, r.beforeOrigin), J = r.transformOrigin;\n    return {\n      width: H,\n      height: X,\n      left: Y,\n      top: W,\n      pos1: T,\n      pos2: D,\n      pos3: N,\n      pos4: B,\n      offsetWidth: U,\n      offsetHeight: V,\n      beforeOrigin: Z,\n      origin: K,\n      transformOrigin: J,\n      rotation: this.getRotation()\n    };\n  }, e.getManager = function() {\n    return this;\n  }, e.stopDrag = function(r) {\n    var S, T;\n    (!r || r === \"target\") && ((S = this.targetGesto) === null || S === void 0 || S.stop()), (!r || r === \"control\") && ((T = this.controlGesto) === null || T === void 0 || T.stop());\n  }, e.getRotation = function() {\n    var r = this.state, S = r.pos1, T = r.pos2, D = r.direction;\n    return getAbsoluteRotation(S, T, D);\n  }, e.request = function(r, S, T) {\n    S === void 0 && (S = {});\n    var D = this.props, N = D.ables, B = D.groupable, $ = N.filter(function(q) {\n      return q.name === r;\n    })[0];\n    if (this.isDragging() || !$ || !$.request)\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    var U = this, V = $.request(this), H = T || S.isInstant, X = V.isControl ? \"controlAbles\" : \"targetAbles\", Y = \"\".concat(B ? \"Group\" : \"\").concat(V.isControl ? \"Control\" : \"\"), W = {\n      request: function(q) {\n        return triggerAble(U, X, \"drag\", Y, \"\", __assign$1(__assign$1({}, V.request(q)), {\n          requestAble: r,\n          isRequest: !0\n        }), H), this;\n      },\n      requestEnd: function() {\n        return triggerAble(U, X, \"drag\", Y, \"End\", __assign$1(__assign$1({}, V.requestEnd()), {\n          requestAble: r,\n          isRequest: !0\n        }), H), this;\n      }\n    };\n    return triggerAble(U, X, \"drag\", Y, \"Start\", __assign$1(__assign$1({}, V.requestStart(S)), {\n      requestAble: r,\n      isRequest: !0\n    }), H), H ? W.request(S).requestEnd() : W;\n  }, e.destroy = function() {\n    this.componentWillUnmount();\n  }, e.updateRenderPoses = function() {\n    var r = this.getState(), S = this.props, T = r.originalBeforeOrigin, D = r.transformOrigin, N = r.allMatrix, B = r.is3d, $ = r.pos1, U = r.pos2, V = r.pos3, H = r.pos4, X = r.left, Y = r.top, W = r.isPersisted, q = S.padding || {}, K = q.left, Z = K === void 0 ? 0 : K, J = q.top, Q = J === void 0 ? 0 : J, rt = q.bottom, et = rt === void 0 ? 0 : rt, nt = q.right, st = nt === void 0 ? 0 : nt, it = B ? 4 : 3, at = [];\n    W ? at = D : this.controlBox && S.groupable ? at = T : at = plus(T, [X, Y]), r.renderPoses = [plus($, calculatePadding(N, [-Z, -Q], D, at, it)), plus(U, calculatePadding(N, [st, -Q], D, at, it)), plus(V, calculatePadding(N, [-Z, et], D, at, it)), plus(H, calculatePadding(N, [st, et], D, at, it))];\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1;\n    var r = this.props, S = r.target, T = r.container, D = r.parentMoveable, N = this.state, B = N.target, $ = N.container;\n    if (!(!B && !S)) {\n      this.updateAbles();\n      var U = !equals(B, S), V = U || !equals($, T);\n      if (!!V) {\n        var H = T || this.controlBox;\n        H && this.unsetAbles(), this.updateState({\n          target: S,\n          container: T\n        }), !D && H && this.updateRect(\"End\", !1, !1), this._isPropTargetChanged = U;\n      }\n    }\n  }, e.waitToChangeTarget = function() {\n    return new Promise(function() {\n    });\n  }, e.triggerEvent = function(r, S) {\n    this._emitter.trigger(r, S);\n    var T = this.props[r];\n    return T && T(S);\n  }, e.useCSS = function(r, S) {\n    var T = this.props.customStyledMap, D = r + S;\n    return T[D] || (T[D] = styled(r, S)), T[D];\n  }, e.getState = function() {\n    var r, S = this.props;\n    (S.target || ((r = S.targets) === null || r === void 0 ? void 0 : r.length)) && (this._hasFirstTarget = !0);\n    var T = this.controlBox, D = S.persistData, N = S.firstRenderState;\n    if (N && !T)\n      return N;\n    if (!this._hasFirstTarget && D) {\n      var B = getPersistState(D);\n      if (B)\n        return this.updateState(B, !1), this.state;\n    }\n    return this.state.isPersisted = !1, this.state;\n  }, e.updateSelectors = function() {\n  }, e.unsetAbles = function() {\n    var r = this;\n    this.targetAbles.forEach(function(S) {\n      S.unset && S.unset(r);\n    });\n  }, e.updateAbles = function(r, S) {\n    r === void 0 && (r = this.props.ables), S === void 0 && (S = \"\");\n    var T = this.props, D = T.triggerAblesSimultaneously, N = this.getEnabledAbles(r), B = \"drag\".concat(S, \"Start\"), $ = \"pinch\".concat(S, \"Start\"), U = \"drag\".concat(S, \"ControlStart\"), V = filterAbles(N, [B, $], D), H = filterAbles(N, [U], D);\n    this.enabledAbles = N, this.targetAbles = V, this.controlAbles = H;\n  }, e.updateState = function(r, S) {\n    if (S) {\n      if (this.isUnmounted)\n        return;\n      this.setState(r);\n    } else {\n      var T = this.state;\n      for (var D in r)\n        T[D] = r[D];\n    }\n  }, e.getEnabledAbles = function(r) {\n    r === void 0 && (r = this.props.ables);\n    var S = this.props;\n    return r.filter(function(T) {\n      return T && (T.always && S[T.name] !== !1 || S[T.name]);\n    });\n  }, e.renderAbles = function() {\n    var r = this, S = this.props, T = S.triggerAblesSimultaneously, D = {\n      createElement\n    };\n    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], T).map(function(N) {\n      var B = N.render;\n      return B(r, D) || [];\n    })).filter(function(N) {\n      return N;\n    }), function(N) {\n      var B = N.key;\n      return B;\n    }).map(function(N) {\n      return N[0];\n    });\n  }, e.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }, e._getRequestStyles = function() {\n    var r = this.getEnabledAbles().reduce(function(S, T) {\n      var D, N, B = (N = (D = T.requestStyle) === null || D === void 0 ? void 0 : D.call(T)) !== null && N !== void 0 ? N : [];\n      return __spreadArray(__spreadArray([], S, !0), B, !0);\n    }, []);\n    return r;\n  }, e._updateObserver = function(r) {\n    var S, T = this.props, D = T.target;\n    if (!window.ResizeObserver || !D || !T.useResizeObserver) {\n      (S = this._observer) === null || S === void 0 || S.disconnect();\n      return;\n    }\n    if (!(r.target === D && this._observer)) {\n      var N = new ResizeObserver(this.checkUpdateRect);\n      N.observe(D, {\n        box: \"border-box\"\n      }), this._observer = N;\n    }\n  }, e._updateEvents = function() {\n    var r = this.controlBox.getElement(), S = this.targetAbles.length, T = this.controlAbles.length, D = this.props, N = D.dragTarget || D.target, B = !S && this.targetGesto || this._isTargetChanged(!0);\n    B && (unset(this, \"targetGesto\"), this.updateState({\n      gesto: null\n    })), T || unset(this, \"controlGesto\"), N && S && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, N, \"\")), !this.controlGesto && T && (this.controlGesto = getAbleGesto(this, r, \"controlAbles\", \"Control\"));\n  }, e._updateTargets = function() {\n    var r = this.props;\n    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;\n  }, e._renderLines = function() {\n    var r = this.props, S = r, T = S.zoom, D = S.hideDefaultLines, N = S.hideChildMoveableDefaultLines, B = S.parentMoveable;\n    if (D || B && N)\n      return [];\n    var $ = this.getState().renderPoses, U = {\n      createElement\n    };\n    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(V, H) {\n      var X = V[0], Y = V[1];\n      return renderLine(U, \"\", $[X], $[Y], T, \"render-line-\".concat(H));\n    });\n  }, e._isTargetChanged = function(r) {\n    var S = this.props, T = S.dragTarget || S.target, D = this._prevTarget, N = this._prevDragArea, B = S.dragArea, $ = !B && D !== T, U = (r || B) && N !== B;\n    return $ || U;\n  }, e._updateNativeEvents = function() {\n    var r = this, S = this.props, T = S.dragArea ? this.areaElement : this.state.target, D = this.events, N = getKeys(D);\n    if (this._isTargetChanged())\n      for (var B in D) {\n        var $ = D[B];\n        $ && $.destroy(), D[B] = null;\n      }\n    if (!!T) {\n      var U = this.enabledAbles;\n      N.forEach(function(V) {\n        var H = filterAbles(U, [V]), X = H.length > 0, Y = D[V];\n        if (!X) {\n          Y && (Y.destroy(), D[V] = null);\n          return;\n        }\n        Y || (Y = new EventManager(T, r, V), D[V] = Y), Y.setAbles(H);\n      });\n    }\n  }, e._checkUpdateRootContainer = function() {\n    var r = this.props.rootContainer;\n    !this._rootContainer && r && (this._rootContainer = getRefTarget(r, !0));\n  }, e._checkUpdateViewContainer = function() {\n    var r = this.props.viewContainer;\n    !this._viewContainer && r && (this._viewContainer = getRefTarget(r, !0));\n    var S = this._viewContainer;\n    S && this._changeAbleViewClassNames(__spreadArray(__spreadArray([], this._getAbleViewClassNames(), !0), [this.isDragging() ? VIEW_DRAGGING : \"\"], !1));\n  }, e._changeAbleViewClassNames = function(r) {\n    var S = this._viewContainer, T = groupBy(r.filter(Boolean), function(U) {\n      return U;\n    }).map(function(U) {\n      var V = U[0];\n      return V;\n    }), D = this._viewClassNames, N = diff$1(D, T), B = N.removed, $ = N.added;\n    B.forEach(function(U) {\n      removeClass(S, D[U]);\n    }), $.forEach(function(U) {\n      addClass(S, T[U]);\n    }), this._viewClassNames = T;\n  }, e._getAbleViewClassNames = function() {\n    var r = this;\n    return (this.getEnabledAbles().map(function(S) {\n      var T;\n      return ((T = S.viewClassName) === null || T === void 0 ? void 0 : T.call(S, r)) || \"\";\n    }).join(\" \") + \" \".concat(this._getAbleClassName(\"-view\"))).split(/\\s+/g);\n  }, e._getAbleClassName = function(r) {\n    var S = this;\n    r === void 0 && (r = \"\");\n    var T = this.getEnabledAbles(), D = this.targetGesto, N = this.controlGesto, B = D != null && D.isFlag() ? D.getEventData() : {}, $ = N != null && N.isFlag() ? N.getEventData() : {};\n    return T.map(function(U) {\n      var V, H, X, Y = U.name, W = ((V = U.className) === null || V === void 0 ? void 0 : V.call(U, S)) || \"\";\n      return (((H = B[Y]) === null || H === void 0 ? void 0 : H.isEventStart) || ((X = $[Y]) === null || X === void 0 ? void 0 : X.isEventStart)) && (W += \" \".concat(prefix(\"\".concat(Y).concat(r, \"-dragging\")))), W.trim();\n    }).filter(Boolean).join(\" \");\n  }, t.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: !0,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    isWrapperMounted: !1,\n    parentPosition: null,\n    portalContainer: null,\n    useResizeObserver: !1,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: !1,\n    passDragArea: !1,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: !1,\n    padding: {},\n    pinchOutside: !0,\n    checkInput: !1,\n    groupable: !1,\n    hideDefaultLines: !1,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: !1,\n    preventClickDefault: !1,\n    preventClickEventOnDrag: !0,\n    flushSync: defaultSync,\n    firstRenderState: null,\n    persistData: null,\n    viewContainer: null,\n    useAccuratePosition: !1\n  }, t;\n}(PureComponent), Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean,\n    groupableProps: Object,\n    targetGroups: Object,\n    hideChildMoveableDefaultLines: Boolean\n  },\n  events: {},\n  render: function(o, t) {\n    var e, r = o.props, S = r.targets || [];\n    o.moveables = [];\n    var T = o.getState(), D = T.left, N = T.top, B = T.isPersisted, $ = [D, N], U = r.zoom || 1, V = o.renderGroupRects, H = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];\n    return B ? S = H.map(function() {\n      return null;\n    }) : H = [], __spreadArray(__spreadArray([], S.map(function(X, Y) {\n      return t.createElement(MoveableManager$1, {\n        key: \"moveable\" + Y,\n        ref: refs(o, \"moveables\", Y),\n        target: X,\n        origin: !1,\n        cssStyled: r.cssStyled,\n        customStyledMap: r.customStyledMap,\n        useResizeObserver: r.useResizeObserver,\n        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,\n        parentMoveable: o,\n        parentPosition: $,\n        persistData: H[Y],\n        zoom: U\n      });\n    }), !0), flat(V.map(function(X, Y) {\n      var W = X.pos1, q = X.pos2, K = X.pos3, Z = X.pos4, J = [W, q, K, Z];\n      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(Q, rt) {\n        var et = Q[0], nt = Q[1];\n        return renderLine(t, \"\", minus(J[et], $), minus(J[nt], $), U, \"group-rect-\".concat(Y, \"-\").concat(rt));\n      });\n    })), !0);\n  }\n}, Clickable = makeAble(\"clickable\", {\n  props: {\n    clickable: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: !0,\n  dragRelation: \"weak\",\n  dragStart: function() {\n  },\n  dragControlStart: function() {\n  },\n  dragGroupStart: function(o, t) {\n    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;\n  },\n  dragEnd: function(o, t) {\n    var e = o.props.target, r = t.inputEvent, S = t.inputTarget, T = o.isMoveableElement(S), D = !T && o.controlBox.getElement().contains(S);\n    if (!(!r || !S || t.isDrag || o.isMoveableElement(S) || D)) {\n      var N = e.contains(S);\n      triggerEvent(o, \"onClick\", fillParams(o, t, {\n        isDouble: t.isDouble,\n        inputTarget: S,\n        isTarget: e === S,\n        moveableTarget: o.props.target,\n        containsTarget: N\n      }));\n    }\n  },\n  dragGroupEnd: function(o, t) {\n    var e = t.inputEvent, r = t.inputTarget;\n    if (!(!e || !r || t.isDrag || o.isMoveableElement(r) || t.datas.inputTarget === r)) {\n      var S = o.props.targets, T = S.indexOf(r), D = T > -1, N = !1;\n      T === -1 && (T = findIndex(S, function(B) {\n        return B.contains(r);\n      }), N = T > -1), triggerEvent(o, \"onClickGroup\", fillParams(o, t, {\n        isDouble: t.isDouble,\n        targets: S,\n        inputTarget: r,\n        targetIndex: T,\n        isTarget: D,\n        containsTarget: N,\n        moveableTarget: S[T]\n      }));\n    }\n  },\n  dragControlEnd: function(o, t) {\n    this.dragEnd(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    this.dragEnd(o, t);\n  }\n});\nfunction getDraggableEvent(o) {\n  var t = o.originalDatas.draggable;\n  return t || (o.originalDatas.draggable = {}, t = o.originalDatas.draggable), __assign$1(__assign$1({}, o), {\n    datas: t\n  });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  css: [`.edge.edgeDraggable.line {\n    cursor: move;\n}`],\n  render: function(o, t) {\n    var e = o.props, r = e.edgeDraggable;\n    return r ? renderEdgeLines(t, \"edgeDraggable\", r, o.getState().renderPoses, e.zoom) : [];\n  },\n  dragCondition: function(o, t) {\n    var e, r = o.props, S = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !S ? !1 : !r.draggable && hasClass(S, prefix(\"direction\")) && hasClass(S, prefix(\"edge\")) && hasClass(S, prefix(\"edgeDraggable\"));\n  },\n  dragStart: function(o, t) {\n    return Draggable.dragStart(o, getDraggableEvent(t));\n  },\n  drag: function(o, t) {\n    return Draggable.drag(o, getDraggableEvent(t));\n  },\n  dragEnd: function(o, t) {\n    return Draggable.dragEnd(o, getDraggableEvent(t));\n  },\n  dragGroupCondition: function(o, t) {\n    var e, r = o.props, S = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !S ? !1 : !r.draggable && hasClass(S, prefix(\"direction\")) && hasClass(S, prefix(\"line\"));\n  },\n  dragGroupStart: function(o, t) {\n    return Draggable.dragGroupStart(o, getDraggableEvent(t));\n  },\n  dragGroup: function(o, t) {\n    return Draggable.dragGroup(o, getDraggableEvent(t));\n  },\n  dragGroupEnd: function(o, t) {\n    return Draggable.dragGroupEnd(o, getDraggableEvent(t));\n  },\n  unset: function(o) {\n    return Draggable.unset(o);\n  }\n}), IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean\n  },\n  events: {}\n}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {\n  return __assign$1(__assign$1({}, o), \"events\" in t ? t.events : {});\n}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {\n  return __assign$1(__assign$1({}, o), t.props);\n}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nfunction solveConstantsDistance(o, t) {\n  var e = o[0], r = o[1], S = o[2];\n  return (e * t[0] + r * t[1] + S) / Math.sqrt(e * e + r * r);\n}\nfunction solveC(o, t) {\n  var e = o[0], r = o[1];\n  return -e * t[0] - r * t[1];\n}\nfunction getMaxPos(o, t) {\n  return Math.max.apply(Math, o.map(function(e) {\n    var r = e[0], S = e[1], T = e[2], D = e[3];\n    return Math.max(r[t], S[t], T[t], D[t]);\n  }));\n}\nfunction getMinPos(o, t) {\n  return Math.min.apply(Math, o.map(function(e) {\n    var r = e[0], S = e[1], T = e[2], D = e[3];\n    return Math.min(r[t], S[t], T[t], D[t]);\n  }));\n}\nfunction getGroupRect(o, t) {\n  var e, r = [0, 0], S = [0, 0], T = [0, 0], D = [0, 0], N = 0, B = 0;\n  if (!o.length)\n    return {\n      pos1: r,\n      pos2: S,\n      pos3: T,\n      pos4: D,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: N,\n      height: B,\n      rotation: t\n    };\n  var $ = throttle(t, TINY_NUM);\n  if ($ % 90) {\n    var U = $ / 180 * Math.PI, V = Math.tan(U), H = -1 / V, X = [MAX_NUM, MIN_NUM], Y = [[0, 0], [0, 0]], W = [MAX_NUM, MIN_NUM], q = [[0, 0], [0, 0]];\n    o.forEach(function(St) {\n      St.forEach(function(pt) {\n        var yt = solveConstantsDistance([-V, 1, 0], pt), At = solveConstantsDistance([-H, 1, 0], pt);\n        X[0] > yt && (Y[0] = pt, X[0] = yt), X[1] < yt && (Y[1] = pt, X[1] = yt), W[0] > At && (q[0] = pt, W[0] = At), W[1] < At && (q[1] = pt, W[1] = At);\n      });\n    });\n    var K = Y[0], Z = Y[1], J = q[0], Q = q[1], rt = [-V, 1, solveC([-V, 1], K)], et = [-V, 1, solveC([-V, 1], Z)], nt = [-H, 1, solveC([-H, 1], J)], st = [-H, 1, solveC([-H, 1], Q)];\n    e = [[rt, nt], [rt, st], [et, nt], [et, st]].map(function(St) {\n      var pt = St[0], yt = St[1];\n      return getIntersectionPointsByConstants(pt, yt)[0];\n    }), r = e[0], S = e[1], T = e[2], D = e[3], N = W[1] - W[0], B = X[1] - X[0];\n  } else {\n    var it = getMinPos(o, 0), at = getMinPos(o, 1), ut = getMaxPos(o, 0), ct = getMaxPos(o, 1);\n    if (r = [it, at], S = [ut, at], T = [it, ct], D = [ut, ct], N = ut - it, B = ct - at, $ % 180) {\n      var gt = [T, r, D, S];\n      r = gt[0], S = gt[1], T = gt[2], D = gt[3], N = ct - at, B = ut - it;\n    }\n  }\n  if ($ % 360 > 180) {\n    var gt = [D, T, S, r];\n    r = gt[0], S = gt[1], T = gt[2], D = gt[3];\n  }\n  var _t = getMinMaxs([r, S, T, D]), vt = _t.minX, mt = _t.minY, bt = _t.maxX, Ct = _t.maxY;\n  return {\n    pos1: r,\n    pos2: S,\n    pos3: T,\n    pos4: D,\n    width: N,\n    height: B,\n    minX: vt,\n    minY: mt,\n    maxX: bt,\n    maxY: Ct,\n    rotation: t\n  };\n}\nfunction findMoveableGroups(o, t) {\n  var e = t.map(function(r) {\n    if (isArray(r)) {\n      var S = findMoveableGroups(o, r), T = S.length;\n      return T > 1 ? S : T === 1 ? S[0] : null;\n    } else {\n      var D = find$1(o, function(N) {\n        var B = N.manager;\n        return B.props.target === r;\n      });\n      return D ? (D.finded = !0, D.manager) : null;\n    }\n  }).filter(Boolean);\n  return e.length === 1 && isArray(e[0]) ? e[0] : e;\n}\nvar MoveableGroup = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.differ = new ChildrenDiffer$1(), r.moveables = [], r.transformOrigin = \"50% 50%\", r.renderGroupRects = [], r._hasFirstTargets = !1, r;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    o.prototype.componentDidMount.call(this);\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1, this.updateAbles();\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, S, T) {\n    var D;\n    T === void 0 && (T = !0);\n    var N = this.state;\n    if (!this.controlBox || N.isPersisted)\n      return;\n    this.moveables.forEach(function(Ft) {\n      Ft.updateRect(r, !1, !1);\n    });\n    var B = this.props, $ = this.moveables, U = N.target || B.target, V = $.map(function(Ft) {\n      return {\n        finded: !1,\n        manager: Ft\n      };\n    }), H = findMoveableGroups(V, this.props.targetGroups || []);\n    H.push.apply(H, V.filter(function(Ft) {\n      var It = Ft.finded;\n      return !It;\n    }).map(function(Ft) {\n      var It = Ft.manager;\n      return It;\n    }));\n    var X = [], Y = !S || r !== \"\" && B.updateGroup, W = B.defaultGroupRotate || 0;\n    if (!this._hasFirstTargets) {\n      var q = (D = this.props.persistData) === null || D === void 0 ? void 0 : D.rotation;\n      q != null && (W = q);\n    }\n    function K(Ft, It, zt) {\n      var kt = Ft.map(function(wt) {\n        if (isArray(wt)) {\n          var Wt = K(wt, It), ee = [Wt.pos1, Wt.pos2, Wt.pos3, Wt.pos4];\n          return X.push(Wt), {\n            poses: ee,\n            rotation: Wt.rotation\n          };\n        } else\n          return {\n            poses: getAbsolutePosesByState(wt.state),\n            rotation: wt.getRotation()\n          };\n      }), Tt = kt.map(function(wt) {\n        var Wt = wt.rotation;\n        return Wt;\n      }), jt = 0, Nt = Tt[0], Et = Tt.every(function(wt) {\n        return Math.abs(Nt - wt) < 0.1;\n      });\n      Y ? jt = Et ? Nt : W : jt = !zt && Et ? Nt : It;\n      var Lt = kt.map(function(wt) {\n        var Wt = wt.poses;\n        return Wt;\n      }), Ht = getGroupRect(Lt, jt);\n      return Ht;\n    }\n    var Z = K(H, this.rotation, !0);\n    Y && (this.rotation = Z.rotation, this.transformOrigin = B.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]), this.renderGroupRects = X;\n    var J = this.transformOrigin, Q = this.rotation, rt = this.scale, et = Z.width, nt = Z.height, st = Z.minX, it = Z.minY, at = rotatePosesInfo([[0, 0], [et, 0], [0, nt], [et, nt]], convertTransformOriginArray(J, et, nt), this.rotation / 180 * Math.PI), ut = getMinMaxs(at.result), ct = ut.minX, gt = ut.minY, _t = \" rotate(\".concat(Q, \"deg)\") + \" scale(\".concat(rt[0] >= 0 ? 1 : -1, \", \").concat(rt[1] >= 0 ? 1 : -1, \")\"), vt = \"translate(\".concat(-ct, \"px, \").concat(-gt, \"px)\").concat(_t);\n    this.controlBox.getElement().style.transform = \"translate3d(\".concat(st, \"px, \").concat(it, \"px, \").concat(this.props.translateZ || 0, \")\"), U.style.cssText += \"left:0px;top:0px;\" + \"transform-origin:\".concat(J, \";\") + \"width:\".concat(et, \"px;height:\").concat(nt, \"px;\") + \"transform: \".concat(vt), N.width = et, N.height = nt;\n    var mt = this.getContainer(), bt = getMoveableTargetInfo(this.controlBox.getElement(), U, this.controlBox.getElement(), this.getContainer(), this._rootContainer || mt, []), Ct = [bt.left, bt.top], St = getAbsolutePosesByState(bt), pt = St[0], yt = St[1], At = St[2], Dt = St[3], Ot = getMinMaxs([pt, yt, At, Dt]), Pt = [Ot.minX, Ot.minY], ft = rt[0] * rt[1] > 0 ? 1 : -1;\n    bt.pos1 = minus(pt, Pt), bt.pos2 = minus(yt, Pt), bt.pos3 = minus(At, Pt), bt.pos4 = minus(Dt, Pt), bt.left = st - bt.left + Pt[0], bt.top = it - bt.top + Pt[1], bt.origin = minus(plus(Ct, bt.origin), Pt), bt.beforeOrigin = minus(plus(Ct, bt.beforeOrigin), Pt), bt.originalBeforeOrigin = plus(Ct, bt.originalBeforeOrigin), bt.transformOrigin = minus(plus(Ct, bt.transformOrigin), Pt), U.style.transform = \"translate(\".concat(-ct - Pt[0], \"px, \").concat(-gt - Pt[1], \"px)\") + _t, this.updateState(__assign$1(__assign$1({}, bt), {\n      posDelta: Pt,\n      direction: ft,\n      beforeDirection: ft\n    }), T);\n  }, e.getRect = function() {\n    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.triggerEvent = function(r, S, T) {\n    if (T || r.indexOf(\"Group\") > -1)\n      return o.prototype.triggerEvent.call(this, r, S);\n    this._emitter.trigger(r, S);\n  }, e.updateAbles = function() {\n    o.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), \"Group\");\n  }, e._updateTargets = function() {\n    o.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;\n  }, e._updateEvents = function() {\n    var r = this.state, S = this.props, T = this._prevTarget, D = S.dragTarget || this.areaElement;\n    T !== D && (unset(this, \"targetGesto\"), unset(this, \"controlGesto\"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.getElement().style.display = \"block\"), r.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, D, \"Group\")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\")));\n    var N = !equals(r.container, S.container);\n    N && (r.container = S.container);\n    var B = this.differ.update(S.targets), $ = B.added, U = B.changed, V = B.removed, H = $.length || V.length;\n    (N || H || U.length) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!H;\n  }, e._updateObserver = function() {\n  }, t.defaultProps = __assign$1(__assign$1({}, MoveableManager$1.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: !0,\n    dragArea: !0,\n    keepRatio: !0,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  }), t;\n}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.moveables = [], r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this, S, T = this.props, D = T.cspNonce, N = T.cssStyled, B = T.persistData, $ = T.targets || [], U = $.length, V = this.isUnmounted || !U, H = (S = B == null ? void 0 : B.children) !== null && S !== void 0 ? S : [];\n    return V && !U && H.length ? $ = H.map(function() {\n      return null;\n    }) : V || (H = []), createElement(N, {\n      cspNonce: D,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, $.map(function(X, Y) {\n      return createElement(MoveableManager$1, __assign$1({\n        key: \"moveable\" + Y,\n        ref: refs(r, \"moveables\", Y)\n      }, r.props, {\n        target: X,\n        wrapperMoveable: r,\n        isWrapperMounted: r.isMoveableMounted,\n        persistData: H[Y]\n      }));\n    }));\n  }, e.componentDidUpdate = function() {\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, S, T) {\n    T === void 0 && (T = !0), this.moveables.forEach(function(D) {\n      D.updateRect(r, S, T);\n    });\n  }, e.getRect = function() {\n    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  }, e.dragStart = function() {\n    return this;\n  }, e.hitTest = function() {\n    return 0;\n  }, e.isInside = function() {\n    return !1;\n  }, e.isDragging = function() {\n    return !1;\n  }, e.updateRenderPoses = function() {\n  }, e.checkUpdate = function() {\n  }, e.triggerEvent = function() {\n  }, e.updateAbles = function() {\n  }, e._updateEvents = function() {\n  }, e._updateObserver = function() {\n  }, t;\n}(MoveableManager$1);\nfunction getElementTargets(o, t) {\n  var e = [];\n  return o.forEach(function(r) {\n    if (!!r) {\n      if (isString$1(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      isArray(r) ? e.push.apply(e, getElementTargets(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction getTargetGroups(o, t) {\n  var e = [];\n  return o.forEach(function(r) {\n    if (!!r) {\n      if (isString$1(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      isArray(r) ? e.push(getTargetGroups(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction compareRefTargets(o, t) {\n  return o.length !== t.length || o.some(function(e, r) {\n    var S = t[r];\n    return !e && !S ? !1 : e != S ? isArray(e) && isArray(S) ? compareRefTargets(e, S) : !0 : !1;\n  });\n}\nvar InitialMoveable = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.refTargets = [], r.selectorMap = {}, r._differ = new ChildrenDiffer$1(), r._elementTargets = [], r._onChangeTargets = null, r;\n  }\n  var e = t.prototype;\n  return t.makeStyled = function() {\n    var r = {}, S = this.getTotalAbles();\n    S.forEach(function(D) {\n      var N = D.css;\n      !N || N.forEach(function(B) {\n        r[B] = !0;\n      });\n    });\n    var T = getKeys(r).join(`\n`);\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + T));\n  }, t.getTotalAbles = function() {\n    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);\n  }, e.render = function() {\n    var r, S = this.constructor;\n    S.defaultStyled || S.makeStyled();\n    var T = this.props, D = T.ables, N = T.props, B = __rest(T, [\"ables\", \"props\"]), $ = this._updateRefs(!0), U = getElementTargets($, this.selectorMap), V = U.length > 1, H = S.getTotalAbles(), X = __spreadArray(__spreadArray([], H, !0), D || [], !0), Y = __assign$1(__assign$1(__assign$1({}, B), N || {}), {\n      ables: X,\n      cssStyled: S.defaultStyled,\n      customStyledMap: S.customStyledMap\n    });\n    this._elementTargets = U;\n    var W = null, q = this.moveable, K = B.persistData;\n    if (K != null && K.children && (V = !0), V) {\n      if (B.individualGroupable)\n        return createElement(MoveableIndividualGroup, __assign$1({\n          key: \"individual-group\",\n          ref: ref(this, \"moveable\")\n        }, Y, {\n          target: null,\n          targets: U\n        }));\n      var Z = getTargetGroups($, this.selectorMap);\n      if (q && !q.props.groupable && !q.props.individualGroupable) {\n        var J = q.props.target;\n        J && U.indexOf(J) > -1 && (W = __assign$1({}, q.state));\n      }\n      return createElement(MoveableGroup, __assign$1({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, Y, (r = B.groupableProps) !== null && r !== void 0 ? r : {}, {\n        target: null,\n        targets: U,\n        targetGroups: Z,\n        firstRenderState: W\n      }));\n    } else {\n      var Q = U[0];\n      if (q && (q.props.groupable || q.props.individualGroupable)) {\n        var rt = q.moveables || [], et = find$1(rt, function(nt) {\n          return nt.props.target === Q;\n        });\n        et && (W = __assign$1({}, et.state));\n      }\n      return createElement(MoveableManager$1, __assign$1({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, Y, {\n        target: Q,\n        firstRenderState: W\n      }));\n    }\n  }, e.componentDidMount = function() {\n    this._checkChangeTargets(), this._updateRefs();\n  }, e.componentDidUpdate = function() {\n    this._checkChangeTargets();\n  }, e.componentWillUnmount = function() {\n    this.selectorMap = {}, this.refTargets = [];\n  }, e.getTargets = function() {\n    var r, S;\n    return (S = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && S !== void 0 ? S : [];\n  }, e.updateSelectors = function() {\n    this.selectorMap = {}, this._updateRefs();\n  }, e.waitToChangeTarget = function() {\n    var r = this, S;\n    return this._onChangeTargets = function() {\n      r._onChangeTargets = null, S();\n    }, new Promise(function(T) {\n      S = T;\n    });\n  }, e.waitToChangeTargets = function() {\n    return this.waitToChangeTarget();\n  }, e.getManager = function() {\n    return this.moveable;\n  }, e._updateRefs = function(r) {\n    var S = this.refTargets, T = getRefTargets(this.props.target || this.props.targets), D = typeof document < \"u\", N = compareRefTargets(S, T), B = this.selectorMap, $ = {};\n    return this.refTargets.forEach(function U(V) {\n      if (isString$1(V)) {\n        var H = B[V];\n        H ? $[V] = B[V] : D && (N = !0, $[V] = [].slice.call(document.querySelectorAll(V)));\n      } else\n        isArray(V) && V.forEach(U);\n    }), this.refTargets = T, this.selectorMap = $, !r && N && this.forceUpdate(), T;\n  }, e._checkChangeTargets = function() {\n    var r, S, T, D = this._differ.update(this._elementTargets), N = D.added, B = D.removed, $ = N.length || B.length;\n    $ && ((S = (r = this.props).onChangeTargets) === null || S === void 0 || S.call(r, {\n      moveable: this.moveable,\n      targets: this._elementTargets\n    }), (T = this._onChangeTargets) === null || T === void 0 || T.call(this)), this._updateRefs();\n  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, \"moveable\", void 0), t;\n}(PureComponent), Moveable$1 = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return t.defaultAbles = MOVEABLE_ABLES, t;\n}(InitialMoveable), Moveable$2 = Moveable$1;\nvar extendStatics = function(o, t) {\n  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var S in r)\n      r.hasOwnProperty(S) && (e[S] = r[S]);\n  }, extendStatics(o, t);\n};\nfunction __extends(o, t) {\n  extendStatics(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign = function() {\n  return __assign = Object.assign || function(t) {\n    for (var e, r = 1, S = arguments.length; r < S; r++) {\n      e = arguments[r];\n      for (var T in e)\n        Object.prototype.hasOwnProperty.call(e, T) && (t[T] = e[T]);\n    }\n    return t;\n  }, __assign.apply(this, arguments);\n};\nfunction __decorate(o, t, e, r) {\n  var S = arguments.length, T = S < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, D;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    T = Reflect.decorate(o, t, e, r);\n  else\n    for (var N = o.length - 1; N >= 0; N--)\n      (D = o[N]) && (T = (S < 3 ? D(T) : S > 3 ? D(t, e, T) : D(t, e)) || T);\n  return S > 3 && T && Object.defineProperty(t, e, T), T;\n}\nvar InnerMoveable = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t(r) {\n    var S = o.call(this, r) || this;\n    return S.state = {}, S.state = S.props, S;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    return createPortal(createElement(Moveable$2, __assign({\n      ref: ref(this, \"moveable\")\n    }, this.state)), this.state.parentElement);\n  }, t;\n}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS, MoveableManager = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t(r, S) {\n    S === void 0 && (S = {});\n    var T = o.call(this) || this;\n    T.tempElement = document.createElement(\"div\");\n    var D = __assign({}, S), N = {};\n    EVENTS.forEach(function($) {\n      N[camelize(\"on \".concat($))] = function(U) {\n        return T.trigger($, U);\n      };\n    }), render(createElement(InnerMoveable, __assign({\n      ref: ref(T, \"innerMoveable\"),\n      parentElement: r\n    }, D, N)), T.tempElement);\n    var B = D.target;\n    return isArray(B) && B.length > 1 && T.updateRect(), T;\n  }\n  var e = t.prototype;\n  return e.setState = function(r, S) {\n    this.innerMoveable.setState(r, S);\n  }, e.forceUpdate = function(r) {\n    this.innerMoveable.forceUpdate(r);\n  }, e.dragStart = function(r) {\n    var S = this.innerMoveable;\n    S.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);\n  }, e.destroy = function() {\n    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;\n  }, e.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  }, t = __decorate([Properties(METHODS, function(r, S) {\n    r[S] || (r[S] = function() {\n      for (var T = [], D = 0; D < arguments.length; D++)\n        T[D] = arguments[D];\n      var N = this.getMoveable();\n      if (!(!N || !N[S]))\n        return N[S].apply(N, T);\n    });\n  }), Properties(PROPERTIES, function(r, S) {\n    Object.defineProperty(r, S, {\n      get: function() {\n        return this.getMoveable().props[S];\n      },\n      set: function(T) {\n        var D;\n        this.setState((D = {}, D[S] = T, D));\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  })], t), t;\n}(EventEmitter$1), Moveable = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return t;\n}(MoveableManager), $r, $s, Gs, Us, js, Co, gn, mn, Po, tf;\nconst Ut = class {\n  constructor(t, e = !1) {\n    tt(this, Po);\n    Rt(this, \"hArg\", {});\n    Rt(this, \"id_tag\", \"\");\n    Rt(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0\n    });\n    Rt(this, \"child\");\n    Rt(this, \"parent\");\n    Rt(this, \"fncLay\", () => {\n    });\n    Rt(this, \"mov\");\n    Rt(this, \"div\");\n    Rt(this, \"lx\", 0);\n    Rt(this, \"ly\", 0);\n    Rt(this, \"rect\", Rectangle.EMPTY);\n    Rt(this, \"pivot\", new Point(0, 0));\n    Rt(this, \"scale\", new Point(1, 1));\n    Rt(this, \"rotation\", 0);\n    Rt(this, \"oldFn\", () => \"\");\n    Rt(this, \"rotatable\", !0);\n    this.bg_col = t, this.isLay = e;\n  }\n  static init(t, e, r, S, T, D, N) {\n    Ut.sys = e, ot(Ut, $s, r), Ut.prpPrs = S, ot(Ut, Gs, T), ot(Ut, Us, D), Ut.hPages = N, Main.cvs.insertAdjacentHTML(\"beforebegin\", `<div id=\"${z(Ut, js)}\" style=\"width: ${CmnLib.stageW * e.cvsScale}px; height: ${CmnLib.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`), ot(Ut, $r, document.getElementById(z(Ut, js))), Ut.divHint.classList.add(\"sn_design_hint\"), t.view.parentElement.appendChild(Ut.divHint), addStyle(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(t, e, r, S) {\n    Ut.divHint.innerHTML = t;\n    const T = window.getComputedStyle(Ut.divHint), D = parseFloat(T.width), N = parseFloat(T.height);\n    Ut.divHint.style.cssText = `display: block; left: ${Math.max(10, S.lx + e - D)}px;\n\t\ttop: ${Math.max(10, S.ly + r - N - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const t = z(Ut, $r).style;\n    t.width = `${CmnLib.stageW * Ut.sys.cvsScale}px`, t.height = `${CmnLib.stageH * Ut.sys.cvsScale}px`;\n  }\n  destroy() {\n    var t;\n    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(t) {\n    if (!this.includeDesignArg(t))\n      return;\n    this.id_tag || (this.id_tag = t[\":id_tag\"] ?? \"\"), this.hArg = t;\n    const e = t[\":id_dc\"] ?? this.id_tag;\n    z(Ut, gn)[e] = this;\n  }\n  includeDesignArg(t) {\n    return Object.keys(t).some((e) => e in this.hDesignArg);\n  }\n  getRect() {\n    return Rectangle.EMPTY;\n  }\n  cnvPosArg(t, e) {\n    return {};\n  }\n  cnvSizeArg(t, e) {\n    return {};\n  }\n  setPos(t, e) {\n  }\n  setSize(t, e) {\n  }\n  setOther(t) {\n  }\n  adopt(t) {\n    this.child = t, t.parent = this;\n  }\n  static enterMode() {\n    Ut.leaveMode(), z(Ut, $r).style.display = \"inline\", ot(Ut, Co, 0), ot(Ut, gn, {});\n  }\n  static allHide() {\n    z(Ut, mn).forEach((t) => t.visible = !1);\n  }\n  set visible(t) {\n    !this.div || !this.mov || (this.div.style.display = t ? \"inline\" : \"none\", this.mov.updateTarget());\n  }\n  static leaveMode() {\n    z(Ut, $r).textContent = \"\", z(Ut, $r).style.display = \"none\", z(Ut, mn).forEach((t) => t.destroy()), ot(Ut, mn, []);\n  }\n  cvsResize() {\n    var t;\n    lt(this, Po, tf).call(this), (t = this.mov) == null || t.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    const t = this.hArg[\":id_dc\"] ?? this.id_tag;\n    z(Ut, gn)[t] = this;\n    const e = this.div = document.createElement(\"div\");\n    e.id = z(Ut, js) + \"_\" + ++Me(Ut, Co)._, e.classList.add(\"sn_design_cast\"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = \"none\", this.rect = this.getRect(), lt(this, Po, tf).call(this), (this.parent ? document.querySelector(\n      `[data-id_dc=\"${this.parent.id_tag}\"]`\n    ) ?? z(Ut, $r) : z(Ut, $r)).appendChild(e);\n    const r = {\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    }, S = () => {\n      r.aPos = [NaN, NaN], r.roDeg = this.rotation;\n      const B = this.pivot.x * Ut.sys.cvsScale, $ = this.pivot.y * Ut.sys.cvsScale;\n      r.trOrg = `${B}px ${$}px`, r.origin = [B, $];\n    }, T = (B) => {\n      Ut.sys.send2Dbg(\"_changeCast\", {\n        ...B,\n        \":id_tag\": this.id_tag\n      }), Ut.divHint.style.display = \"none\";\n    }, D = () => {\n      const [B, $] = r.aPos;\n      if (isNaN(B)) {\n        Ut.divHint.style.display = \"none\";\n        return;\n      }\n      const U = int(this.rect.x += B / Ut.sys.cvsScale + this.pivot.x), V = int(this.rect.y += $ / Ut.sys.cvsScale + this.pivot.y);\n      this.setPos(U, V);\n      const H = uint(this.rect.width), X = uint(this.rect.height);\n      this.setSize(H, X), T({\n        ...this.cnvPosArg(U, V),\n        ...this.cnvSizeArg(H, X)\n      });\n    };\n    let N;\n    this.mov = new Moveable(document.body, {\n      target: e,\n      draggable: !0,\n      resizable: !0,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: !0\n    }).on(\"dragStart\", (B) => {\n      var U;\n      S(), this.onDragStart();\n      const $ = (U = this.child) == null ? void 0 : U.mov;\n      $ && (N = $.target, $.isInside(B.clientX, B.clientY) && ($.target = void 0));\n    }).on(\"drag\", (B) => {\n      r.aPos = B.beforeTranslate, this.procDragHint(B, B.left, B.top);\n    }).on(\"dragEnd\", () => {\n      var B, $;\n      D(), (B = this.child) != null && B.mov && (this.child.mov.target = N), ($ = this.parent) != null && $.mov && (this.parent.mov.target = this.parent.div);\n    }).on(\"resizeStart\", S).on(\"resize\", (B) => {\n      e.style.width = `${B.width}px`, e.style.height = `${B.height}px`, r.aPos = B.drag.beforeTranslate, this.rect.width = B.width / Ut.sys.cvsScale, this.rect.height = B.height / Ut.sys.cvsScale, this.procResizeHint(B, B.drag.left, B.drag.top);\n    }).on(\"resizeEnd\", D).on(\"rotateStart\", (B) => {\n      S(), B.set(r.roDeg);\n    }).on(\"rotate\", (B) => {\n      r.roDeg = B.beforeRotate, Ut.setHint(int(r.roDeg) + \"度\", B.drag.left, B.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = r.roDeg, this.setOther({}), T({ rotation: int(r.roDeg) });\n    }).on(\"dragOriginStart\", () => S).on(\"dragOrigin\", (B) => {\n      r.trOrg = B.transformOrigin, r.origin = B.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [B, $] = r.origin;\n      r.trOrg = `${B}px ${$}px`;\n      const U = this.pivot.x = B / Ut.sys.cvsScale, V = this.pivot.y = $ / Ut.sys.cvsScale;\n      this.setOther({});\n      const H = int(this.rect.x + U), X = int(this.rect.y + V);\n      this.setPos(H, X), T({\n        ...this.cnvPosArg(H, X),\n        pivot_x: int(U),\n        pivot_y: int(V)\n      });\n    }).on(\"render\", () => {\n      const { aPos: B, roDeg: $, trOrg: U } = r;\n      e.style.transformOrigin = U, e.style.transform = `translate(${B[0]}px, ${B[1]}px) rotate(${$}deg)`;\n    }), z(Ut, mn).push(this), e.addEventListener(\"dragenter\", () => e.classList.add(\"drag_border\")), e.addEventListener(\"dragover\", (B) => {\n      B.stopPropagation(), B.preventDefault(), B.dataTransfer && (B.dataTransfer.dropEffect = \"copy\");\n    }), e.addEventListener(\"dragleave\", () => e.classList.remove(\"drag_border\")), e.addEventListener(\"drop\", (B) => {\n      B.stopPropagation(), B.preventDefault(), e.classList.remove(\"drag_border\");\n      const $ = B.dataTransfer;\n      if (!$ || $.files.length === 0)\n        return;\n      const U = $.files[0], V = {\n        \":id_tag\": this.id_tag,\n        fn: getFn(U.name),\n        ext: getExt(U.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: z(Ut, Us).searchPath(this.oldFn(), SEARCH_PATH_ARG_EXT.SP_GSM)\n      };\n      U.arrayBuffer().then((H) => {\n        V.buf = H;\n        try {\n          V.url = z(Ut, $s).cnvPath4Dbg(\n            z(Ut, Us).searchPath(U.name, SEARCH_PATH_ARG_EXT.SP_GSM)\n          );\n        } catch {\n        }\n        Ut.sys.send2Dbg(\"_dropFile\", V);\n      }).catch((H) => console.error(\"drop2dc %o\", H));\n    }), e.addEventListener(\"dblclick\", (B) => {\n      B.preventDefault(), Ut.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(t, e, r) {\n    const [S, T] = t.beforeTranslate;\n    Ut.setHint(\n      `(${int(this.rect.x + S / Ut.sys.cvsScale)}, ${int(this.rect.y + T / Ut.sys.cvsScale)})`,\n      e,\n      r,\n      this\n    );\n  }\n  procResizeHint(t, e, r) {\n    Ut.setHint(\n      `(${int(t.drag.left)}, ${int(t.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,\n      e,\n      r,\n      this\n    );\n  }\n  static replaceToken(t) {\n    var U, V, H, X, Y, W, q, K;\n    const r = t[\":id_tag\"], S = z(Ut, gn)[r];\n    if (!document.querySelector(`div[data-id_dc='${r}']`) || !S)\n      return;\n    const D = t[\":token\"];\n    z(Ut, $s).replace(t[\":idx_tkn\"], D);\n    const [N, B] = tagToken2Name_Args(D);\n    S.child && (S.child.hArg[\":token\"] = S.hArg[\":token\"]), z(Ut, Gs).parse(B);\n    const $ = z(Ut, Gs).hPrm;\n    if (\"pivot_x\" in $ || \"pivot_y\" in $) {\n      const Z = Number(Ut.prpPrs.getValAmpersand($.pivot_x.val)), J = Number(Ut.prpPrs.getValAmpersand($.pivot_y.val));\n      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`pivot_xかpivot_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${D}`, \"F\"), S.pivot.set(Z, J);\n    }\n    if (\"left\" in $ || \"top\" in $ || \"x\" in $ || \"y\" in $) {\n      const Z = int(Ut.prpPrs.getValAmpersand(((U = $.left) == null ? void 0 : U.val) ?? ((V = $.x) == null ? void 0 : V.val) ?? \"0\")), J = int(Ut.prpPrs.getValAmpersand(((H = $.top) == null ? void 0 : H.val) ?? ((X = $.y) == null ? void 0 : X.val) ?? \"0\"));\n      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${D}`, \"F\"), S.rect.x = Z - S.pivot.x, S.rect.y = J - S.pivot.y, S.setPos(Z, J);\n    }\n    if (\"width\" in $ || \"height\" in $) {\n      const Z = int(Ut.prpPrs.getValAmpersand(((Y = $.width) == null ? void 0 : Y.val) ?? \"0\")), J = int(Ut.prpPrs.getValAmpersand(((W = $.height) == null ? void 0 : W.val) ?? \"0\"));\n      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${D}`, \"F\"), S.rect.width = Z, S.rect.height = J, S.setSize(Z, J);\n    }\n    if (\"scale_x\" in $ || \"scale_y\" in $) {\n      const Z = Number(Ut.prpPrs.getValAmpersand(((q = $.scale_x) == null ? void 0 : q.val) ?? \"0\")), J = Number(Ut.prpPrs.getValAmpersand(((K = $.scale_y) == null ? void 0 : K.val) ?? \"0\"));\n      (isNaN(Z) || isNaN(J)) && DebugMng.myTrace(`scale_xかscale_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${D}`, \"F\"), S.scale.set(Z, J);\n    }\n    if (\"rotation\" in $) {\n      const Z = Number(Ut.prpPrs.getValAmpersand($.rotation.val));\n      isNaN(Z) && DebugMng.myTrace(`rotationが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${D}`, \"F\"), S.rotation = Z;\n    }\n    S.setOther($), S.cvsResize();\n  }\n};\nlet DesignCast = Ut;\n$r = new WeakMap(), $s = new WeakMap(), Gs = new WeakMap(), Us = new WeakMap(), js = new WeakMap(), Co = new WeakMap(), gn = new WeakMap(), mn = new WeakMap(), Po = new WeakSet(), tf = function() {\n  this.fncLay(), this.div && Object.assign(this.div.style, {\n    left: `${this.lx + this.rect.x * Ut.sys.cvsScale}px`,\n    top: `${this.ly + this.rect.y * Ut.sys.cvsScale}px`,\n    width: `${this.rect.width * Ut.sys.cvsScale}px`,\n    height: `${this.rect.height * Ut.sys.cvsScale}px`,\n    transformOrigin: `${this.pivot.x * Ut.sys.cvsScale}px ${this.pivot.y * Ut.sys.cvsScale}px`,\n    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n  });\n}, tt(DesignCast, $r, void 0), Rt(DesignCast, \"sys\"), tt(DesignCast, $s, void 0), Rt(DesignCast, \"prpPrs\"), tt(DesignCast, Gs, void 0), tt(DesignCast, Us, void 0), Rt(DesignCast, \"hPages\"), Rt(DesignCast, \"divHint\", document.createElement(\"div\")), tt(DesignCast, js, \"DesignMode\"), tt(DesignCast, Co, 0), tt(DesignCast, gn, {}), tt(DesignCast, mn, []);\nvar Bi;\nclass GrpLayDesignCast extends DesignCast {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    tt(this, Bi, void 0);\n    Rt(this, \"oldFn\", () => this.hArg.fn ?? \"\");\n    this.spLay = e, this.gl = r;\n  }\n  setSp(e) {\n    ot(this, Bi, e);\n  }\n  getRect() {\n    var e, r;\n    return new Rectangle(this.spLay.x, this.spLay.y, ((e = z(this, Bi)) == null ? void 0 : e.width) ?? 0, ((r = z(this, Bi)) == null ? void 0 : r.height) ?? 0);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.x = e, this.spLay.y = r;\n  }\n  setSize(e, r) {\n    z(this, Bi).width = e, z(this, Bi).height = r;\n  }\n  setOther(e) {\n    if (\"fn\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.fn.val);\n      this.gl.lay({ fn: r });\n    }\n    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nBi = new WeakMap();\nclass TxtLayDesignCast extends DesignCast {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    Rt(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0,\n      pl: 0,\n      pr: 0,\n      pt: 0,\n      pb: 0\n    });\n    this.spLay = e, this.ts = r;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(this.spLay.x, this.spLay.y, e.$width, e.$height);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay(this.cnvSizeArg(e, r));\n  }\n  setOther(e) {\n    var r;\n    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nvar Ro, ef;\nclass TxtLayPadDesignCast extends DesignCast {\n  constructor(e) {\n    super(\"#9e2\");\n    tt(this, Ro);\n    Rt(this, \"rotatable\", !1);\n    this.ts = e;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(\n      e.pad_left,\n      e.pad_top,\n      e.$width - e.pad_left - e.pad_right,\n      e.$height - e.pad_top - e.pad_bottom\n    );\n  }\n  cnvPosArg(e, r) {\n    return { pl: e, pt: r };\n  }\n  cnvSizeArg(e, r) {\n    const S = this.ts.infTL;\n    return {\n      pr: S.$width - S.pad_left - e,\n      pb: S.$height - S.pad_top - r\n    };\n  }\n  setPos(e, r) {\n    this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay({ ...this.cnvSizeArg(e, r), \":redraw\": !0 });\n  }\n  setOther(e) {\n    var S, T, D, N;\n    const r = this.ts.infTL;\n    if ((\"pl\" in e || \"pt\" in e) && (this.setPos(\n      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        ((S = e.pl) == null ? void 0 : S.val) ?? `${r.pad_left}`\n      )),\n      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        ((T = e.pt) == null ? void 0 : T.val) ?? `${r.pad_top}`\n      ))\n    ), this.cvsResize()), \"pr\" in e || \"pb\" in e) {\n      this.ts.lay({\n        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          ((D = e.pr) == null ? void 0 : D.val) ?? `${r.pad_right}`\n        )),\n        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          ((N = e.pb) == null ? void 0 : N.val) ?? `${r.pad_bottom}`\n        ))\n      });\n      const B = this.getRect();\n      this.setSize(\n        this.rect.width = B.width,\n        this.rect.height = B.height\n      ), this.cvsResize();\n    }\n  }\n  procDragHint(e, r, S) {\n    const [T, D] = e.beforeTranslate;\n    lt(this, Ro, ef).call(this, r, S, T, D);\n  }\n  procResizeHint(e, r, S) {\n    const [T, D] = e.drag.beforeTranslate;\n    lt(this, Ro, ef).call(this, r, S, T, D);\n  }\n}\nRo = new WeakSet(), ef = function(e, r, S, T) {\n  const D = this.rect.x, N = this.rect.y, B = this.rect.width, $ = this.rect.height, U = this.ts.infTL, V = int(D + S / DesignCast.sys.cvsScale), H = int(N + T / DesignCast.sys.cvsScale), X = int(U.$width - V - B), Y = int(U.$height - H - $), W = (q) => \"&nbsp;\".repeat(q);\n  DesignCast.setHint(\n    W(5 + 5 + 1) + `上幅=${H}<br/>\n\t\t\t左幅=${V + W(1 + 3 + 5 + 1)}右幅=${X}<br/>` + W(5) + `内側 ${int(B)} x ${int($)}<br/>` + W(5 + 5) + `下幅=${Y}`,\n    e,\n    r,\n    this\n  );\n};\nclass BtnDesignCast extends DesignCast {\n  constructor(t, e) {\n    super(\"#e92\"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x), this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y), this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x), this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y), this.rotation = argChk_Num(e, \"rotation\", this.rotation), this.sethArg(e);\n  }\n  sethArg(t) {\n    super.sethArg(t);\n    const e = this.hArg.layer ?? \"\";\n    this.fncLay = !this.parent && !this.child && e ? () => {\n      const r = DesignCast.hPages[e].fore;\n      this.lx = r.x * DesignCast.sys.cvsScale, this.ly = r.y * DesignCast.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.btn.x = t, this.btn.y = e;\n  }\n  setOther(t) {\n    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n  }\n}\nclass TxtBtnDesignCast extends BtnDesignCast {\n  constructor(e, r, S) {\n    super(e, r);\n    Rt(this, \"oldFn\", () => this.hArg.b_pic ?? \"\");\n    this.txt = S, argChk_Boolean(r, \"design\", !0) || (this.setPos = () => {\n    }, this.setSize = () => {\n    });\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(e, r) {\n    this.txt.width = e, this.txt.height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"b_pic\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.b_pic.val ?? \"\");\n      this.btn.update_b_pic(r, this.txt);\n    }\n  }\n}\nvar ii;\nclass PicBtnDesignCast extends BtnDesignCast {\n  constructor(e, r) {\n    super(e, r);\n    tt(this, ii, void 0);\n    Rt(this, \"oldFn\", () => this.hArg.pic ?? \"\");\n  }\n  setSp(e) {\n    ot(this, ii, e);\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, z(this, ii).width, z(this, ii).height);\n  }\n  setSize(e, r) {\n    z(this, ii).width = e, z(this, ii).height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"pic\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.pic.val);\n      this.btn.update_pic(r, z(this, ii));\n    }\n  }\n}\nii = new WeakMap();\nvar rh, Fi, ni, _n, yn, Gr, zs, bn, Mo, Hs, Ur, si, ai, $i, Oo, Io, Do, ih, ud, nh, hd, Ao, rf, sh, cd, Vs, hu, Xs, wr, Ys, xn, No;\nconst Xt = class extends Layer {\n  constructor() {\n    super();\n    tt(this, Ur, new GrpLayDesignCast(this.spLay, this));\n    tt(this, si, \"\");\n    tt(this, ai, \"\");\n    tt(this, $i, \"\");\n    Rt(this, \"lay\", (e) => this.laySub(e, (r) => {\n      r && z(Xt, ni).resume();\n    }));\n    tt(this, Oo, 0);\n    tt(this, Io, 0);\n    tt(this, Xs, void 0);\n    tt(this, wr, void 0);\n    tt(this, Ys, () => {\n    });\n    Rt(this, \"record\", () => ({\n      ...super.record(),\n      sBkFn: z(this, ai),\n      sBkFace: z(this, $i),\n      idc_hArg: z(this, Ur).gethArg()\n    }));\n    Rt(this, \"dump\", () => super.dump() + `, \"pic\":\"${z(this, si)}\"`);\n    CmnLib.isDbg && (this.setSp = (e) => z(this, Ur).setSp(e), this.cvsResize = () => {\n      super.cvsResize(), z(this, Ur).cvsResize();\n    });\n  }\n  static init(e, r, S, T, D, N) {\n    ot(Xt, ni, e), ot(Xt, _n, r), ot(Xt, yn, S), ot(Xt, Gr, T), ot(Xt, zs, N);\n    const B = () => {\n      const $ = z(Xt, bn) * z(Xt, Mo);\n      for (const U of Object.values(Xt.hFn2VElm))\n        U.volume = $;\n    };\n    D.setNoticeChgVolume(\n      ($) => {\n        ot(Xt, bn, $), B();\n      },\n      ($) => {\n        ot(Xt, Mo, $), B();\n      }\n    ), z(Xt, Gr).crypto && ot(Xt, Do, lt(Xt, nh, hd));\n  }\n  static setEvtMng(e) {\n    ot(Xt, Hs, e);\n  }\n  static destroy() {\n    z(Xt, rh).clear(), ot(Xt, Fi, {}), Xt.hFn2ResAniSpr = {}, Xt.hFn2VElm = {};\n  }\n  setSp(e) {\n  }\n  laySub(e, r) {\n    var B;\n    lt(B = Xt, Vs, hu).call(B, z(this, ai));\n    const { fn: S, face: T = \"\" } = e;\n    if (z(this, Ur).sethArg(e), !S)\n      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), ot(this, ai, \"\"), ot(this, si, ot(this, $i, T)), r(!1), !1;\n    const D = \"fn\" in e, N = \"face\" in e;\n    return this.clearLay({ filter: \"true\" }), D && ot(this, ai, S), N && ot(this, $i, T), super.lay(e), e.dx = 0, e.dy = 0, Xt.csv2Sprites(\n      ot(this, si, S + (T ? \",\" + T : \"\")),\n      this.spLay,\n      ($) => {\n        (\"width\" in e || \"height\" in e) && ($.width = argChk_Num(e, \"width\", 0), $.height = argChk_Num(e, \"height\", 0)), ot(this, Oo, $.width), ot(this, Io, $.height), Layer.setXY($, e, this.spLay, !0), this.setSp($);\n      },\n      ($) => {\n        Layer.setBlendmode(this.spLay, e), r($);\n      }\n    );\n  }\n  get width() {\n    return z(this, Oo);\n  }\n  get height() {\n    return z(this, Io);\n  }\n  static csv2Sprites(e, r, S, T = () => {\n  }) {\n    let D = !1;\n    if (e.slice(0, 5) === \"data:\") {\n      const U = () => {\n        const V = Sprite.from(e);\n        r == null || r.addChild(V), S(V), T(D);\n      };\n      return e in TextureCache ? U() : (D = !0, new Loader().add(e, e).load(U)), D;\n    }\n    const N = [], B = new Loader();\n    e.split(\",\").forEach((U, V) => {\n      if (!U)\n        throw \"face属性に空要素が含まれます\";\n      const { dx: H, dy: X, blendmode: Y, fn: W } = z(Xt, Fi)[U] || {\n        fn: U,\n        dx: 0,\n        dy: 0,\n        blendmode: BLEND_MODES.NORMAL\n      }, q = V === 0 ? S : (J) => {\n        J.x = H, J.y = X, J.blendMode = Y;\n      };\n      if (N.push({ fn: W, fnc: q }), W in Xt.hFn2ResAniSpr || W in TextureCache || W in Loader.shared.resources)\n        return;\n      D = !0;\n      const K = z(Xt, _n).searchPath(W, SEARCH_PATH_ARG_EXT.SP_GSM), Z = z(this, Gr).crypto ? { xhrType: K.slice(-5) === \".json\" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};\n      B.add({ ...Z, name: W, url: K });\n    });\n    const $ = (U) => {\n      var V;\n      for (const { fn: H, fnc: X } of N) {\n        const Y = lt(V = Xt, sh, cd).call(V, H, U);\n        Y.name = H, r == null || r.addChild(Y), X(Y);\n      }\n      T(D);\n    };\n    return D ? B.use((U, V) => {\n      z(this, Gr).dec(U.extension, U.data).then((H) => {\n        var X;\n        return z(X = Xt, Do).call(X, H, U, () => V == null ? void 0 : V());\n      }).catch((H) => z(this, ni).errScript(`Graphic ロード失敗です fn:${U.name} ${H}`, !1));\n    }).load((U, V) => $(V)) : $({}), D;\n  }\n  static wv(e) {\n    var D;\n    const { fn: r } = e;\n    if (!r)\n      throw \"fnは必須です\";\n    const S = Xt.hFn2VElm[r];\n    if (!S || S.loop)\n      return !1;\n    if (z(this, zs).getVal(\"tmp:sn.skip.enabled\") || z(this, Hs).isSkippingByKeyDown() || S.ended)\n      return lt(D = Xt, Vs, hu).call(D, r), !1;\n    const T = () => {\n      var N;\n      lt(N = Xt, Vs, hu).call(N, r), z(this, ni).resume();\n    };\n    return S.addEventListener(\"ended\", T, { once: !0, passive: !0 }), z(Xt, Hs).waitEvent(\n      () => {\n        S.removeEventListener(\"ended\", T), T();\n      },\n      argChk_Boolean(e, \"canskip\", !0),\n      argChk_Boolean(e, \"global\", !1)\n    );\n  }\n  renderStart() {\n    ot(this, Xs, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), ot(this, wr, new Sprite(z(this, Xs))), z(this, wr).visible = !1, this.spLay.addChildAt(z(this, wr), 0), z(this, wr).position.set(-this.spLay.x, -this.spLay.y);\n    let e = () => {\n      const r = this.spLay.alpha;\n      this.spLay.alpha = 1;\n      for (const S of this.spLay.children)\n        S.visible = !0;\n      z(this, wr).visible = !1, z(Xt, yn).renderer.render(this.spLay, { renderTexture: z(this, Xs) }), this.spLay.alpha = r;\n      for (const S of this.spLay.children)\n        S.visible = !1;\n    };\n    if (!this.containMovement) {\n      let r = e;\n      e = () => {\n        e = () => {\n        }, r();\n      };\n    }\n    ot(this, Ys, () => {\n      e(), z(this, wr).visible = !0;\n    }), z(Xt, yn).ticker.add(z(this, Ys));\n  }\n  renderEnd() {\n    z(Xt, yn).ticker.remove(z(this, Ys)), this.spLay.removeChild(z(this, wr));\n    for (const e of this.spLay.children)\n      e.visible = !0;\n    z(this, wr).destroy(!0);\n  }\n  static loadPic2Img(e, r, S) {\n    const T = z(this, No)[e];\n    if (T) {\n      r.src = T;\n      return;\n    }\n    const D = z(this, xn)[e];\n    if (D) {\n      D.push(r);\n      return;\n    }\n    z(this, xn)[e] = [r];\n    const N = z(Xt, _n).searchPath(e, SEARCH_PATH_ARG_EXT.SP_GSM), B = new Loader().add({ name: e, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });\n    z(Xt, Gr).crypto && getExt(N) === \"bin\" && B.use(($, U) => {\n      z(Xt, Gr).dec($.extension, $.data).then((V) => {\n        if ($.extension !== \"bin\") {\n          U == null || U();\n          return;\n        }\n        $.data = V, V instanceof HTMLImageElement && ($.type = LoaderResource.TYPE.IMAGE), U == null || U();\n      }).catch((V) => z(Xt, ni).errScript(`GrpLayer loadPic ロード失敗です fn:${$.name} ${V}`, !1));\n    }), B.load(($, U) => {\n      for (const [V, { data: { src: H } }] of Object.entries(U)) {\n        const X = z(this, No)[V] = H;\n        for (const Y of z(this, xn)[V])\n          Y.src = X, S && (Y.onload = () => S(Y));\n        delete z(this, xn)[V];\n      }\n    });\n  }\n  setPos(e) {\n    Layer.setXY(\n      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],\n      e,\n      this.spLay,\n      !0\n    );\n  }\n  static add_face(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (r in z(Xt, Fi))\n      throw \"一つのname（\" + r + \"）に対して同じ画像を複数割り当てられません\";\n    const { fn: S = r } = e;\n    return z(Xt, Fi)[r] = {\n      fn: S,\n      dx: argChk_Num(e, \"dx\", 0),\n      dy: argChk_Num(e, \"dy\", 0),\n      blendmode: Layer.getBlendmodeNum(e.blendmode || \"\")\n    }, !1;\n  }\n  static clearFace2Name() {\n    ot(Xt, Fi, {});\n  }\n  get containMovement() {\n    if (z(this, si) === \"\")\n      return !1;\n    const e = this.spLay.children;\n    return z(this, si).split(\",\").some(\n      (r, S) => e[S] instanceof AnimatedSprite || Xt.hFn2VElm[r]\n    );\n  }\n  clearLay(e) {\n    super.clearLay(e);\n    for (const r of this.spLay.removeChildren())\n      r.destroy();\n    ot(this, ai, \"\"), ot(this, $i, \"\"), ot(this, si, \"\");\n  }\n  playback(e, r) {\n    if (super.playback(e, r), e.sBkFn === \"\" && e.sBkFace === \"\") {\n      ot(this, ai, e.sBkFn), ot(this, $i, e.sBkFace), z(this, Ur).sethArg(e.idc_hArg);\n      return;\n    }\n    r.push(new Promise((S) => this.laySub(\n      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: Layer.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },\n      (T) => {\n        this.spLay.position.set(e.x, e.y), S();\n      }\n    )));\n  }\n  makeDesignCast(e) {\n    !this.spLay.visible || e(z(this, Ur));\n  }\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    z(this, Ur).visible = !0;\n  }\n};\nlet GrpLayer = Xt;\nrh = new WeakMap(), Fi = new WeakMap(), ni = new WeakMap(), _n = new WeakMap(), yn = new WeakMap(), Gr = new WeakMap(), zs = new WeakMap(), bn = new WeakMap(), Mo = new WeakMap(), Hs = new WeakMap(), Ur = new WeakMap(), si = new WeakMap(), ai = new WeakMap(), $i = new WeakMap(), Oo = new WeakMap(), Io = new WeakMap(), Do = new WeakMap(), ih = new WeakSet(), ud = function(e) {\n  const r = /([^\\d]+)\\d+\\.(\\w+)/.exec(e[0]);\n  if (!r)\n    return [];\n  const S = r[1].length, T = -r[2].length - 1;\n  return e.sort(\n    (D, N) => int(D.slice(S, T)) > int(N.slice(S, T)) ? 1 : -1\n  );\n}, nh = new WeakSet(), hd = function(e, r, S) {\n  var $;\n  if (r.data = e, r.extension === \"bin\" && (e instanceof HTMLImageElement ? (r.texture = Texture.fromLoader(e, r.url, r.name), r.type = LoaderResource.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = z(Xt, bn), Xt.hFn2VElm[r.name] = lt($ = Xt, Ao, rf).call($, e), r.type = LoaderResource.TYPE.VIDEO)), r.extension !== \"json\") {\n    S();\n    return;\n  }\n  if (typeof e != \"string\") {\n    S();\n    return;\n  }\n  const { meta: T, frames: D } = r.data = JSON.parse(e);\n  if (r.type = LoaderResource.TYPE.JSON, !(T != null && T.image)) {\n    S();\n    return;\n  }\n  const N = getFn(T.image), B = z(Xt, _n).searchPath(N, SEARCH_PATH_ARG_EXT.SP_GSM);\n  new Loader().use((U, V) => {\n    z(this, Gr).dec(U.extension, U.data).then((H) => {\n      U.data = H, H instanceof HTMLImageElement && (U.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(H.src)), V == null || V();\n    }).catch((H) => z(this, ni).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${U.name} ${H}`, !1));\n  }).add({ name: N, url: B, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((U, V) => {\n    for (const { data: H } of Object.values(U.resources)) {\n      const { baseTexture: X } = Texture.from(H), Y = Object.values(D);\n      Xt.hFn2ResAniSpr[r.name] = {\n        aTex: Y.map(({ frame: { x: W, y: q, w: K, h: Z } }) => new Texture(\n          X,\n          new Rectangle(W, q, K, Z)\n        )),\n        meta: T\n      };\n    }\n    S();\n  });\n}, Ao = new WeakSet(), rf = function(e) {\n  return z(Xt, zs).getVal(\"const.sn.needClick2Play\") && (DebugMng.trace_beforeNew(`[lay系] ${DebugMng.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, \"W\"), e.muted = !0), e.setAttribute(\"playsinline\", \"\"), e;\n}, sh = new WeakSet(), cd = function(e, r) {\n  const S = Xt.hFn2ResAniSpr[e];\n  if (S) {\n    const T = new AnimatedSprite(S.aTex);\n    return T.animationSpeed = S.meta.animationSpeed ?? 1, T.play(), T;\n  }\n  return e in TextureCache ? Sprite.from(e) : e in Xt.hFn2VElm ? Sprite.from(Xt.hFn2VElm[e]) : e in r ? new Sprite(r[e].texture) : new Sprite();\n}, Vs = new WeakSet(), hu = function(e) {\n  const r = Xt.hFn2VElm[e];\n  !r || (delete Xt.hFn2VElm[e], r.pause(), r.currentTime = r.duration);\n}, Xs = new WeakMap(), wr = new WeakMap(), Ys = new WeakMap(), xn = new WeakMap(), No = new WeakMap(), tt(GrpLayer, ih), tt(GrpLayer, nh), tt(GrpLayer, Ao), tt(GrpLayer, sh), tt(GrpLayer, Vs), tt(GrpLayer, rh, new EventListenerCtn()), tt(GrpLayer, Fi, {}), tt(GrpLayer, ni, void 0), tt(GrpLayer, _n, void 0), tt(GrpLayer, yn, void 0), tt(GrpLayer, Gr, void 0), tt(GrpLayer, zs, void 0), tt(GrpLayer, bn, 1), tt(GrpLayer, Mo, 1), tt(GrpLayer, Hs, void 0), Rt(GrpLayer, \"hFn2ResAniSpr\", {}), tt(GrpLayer, Do, (e, r, S) => {\n  var T, D;\n  switch (r.type) {\n    case LoaderResource.TYPE.JSON:\n      const N = r.spritesheet._frameKeys;\n      lt(T = Xt, ih, ud).call(T, N), Xt.hFn2ResAniSpr[r.name] = {\n        aTex: N.map(($) => Texture.from($)),\n        meta: r.data.meta\n      };\n      break;\n    case LoaderResource.TYPE.VIDEO:\n      const B = r.data;\n      B.volume = z(Xt, bn), Xt.hFn2VElm[r.name] = lt(D = Xt, Ao, rf).call(D, B);\n  }\n  S();\n}), Rt(GrpLayer, \"hFn2VElm\", {}), tt(GrpLayer, xn, {}), tt(GrpLayer, No, {});\nvar Ws, Lo, Sn, ne, jr, oi, ah, sr, Gi, Yt, li, ar, or, qs, cu, Cr, Ui, ko, Ks, oh, fd, En, Zs, ui, Tn, wn, Cn, Js, Bo, hi, Fo, nf, ci, $o, fi, zr, Qs, Go, sf, ji, Pn, Uo, af, We;\nconst Zt = class extends Container {\n  constructor(e, r, S) {\n    super();\n    tt(this, qs);\n    tt(this, oh);\n    tt(this, Fo);\n    tt(this, Go);\n    tt(this, Uo);\n    tt(this, ne, document.createElement(\"span\"));\n    tt(this, jr, new Container());\n    tt(this, oi, new Graphics());\n    tt(this, sr, new TxtLayDesignCast(this.spLay, this));\n    tt(this, Gi, new TxtLayPadDesignCast(this));\n    tt(this, Yt, {\n      fontsize: 24,\n      $width: 0,\n      $height: 0,\n      pad_left: 0,\n      pad_right: 0,\n      pad_top: 0,\n      pad_bottom: 0\n    });\n    tt(this, li, !1);\n    tt(this, ar, 0);\n    tt(this, or, 0);\n    tt(this, Cr, 0);\n    tt(this, Ui, !1);\n    tt(this, ko, 0);\n    tt(this, Ks, 0);\n    tt(this, En, void 0);\n    tt(this, Zs, []);\n    tt(this, ui, []);\n    tt(this, Tn, 0);\n    tt(this, hi, () => !1);\n    tt(this, Qs, 0);\n    tt(this, ji, \"Quadratic.Out\");\n    tt(this, Pn, \"Quadratic.Out\");\n    tt(this, We, void 0);\n    this.spLay = e, this.canFocus = r, this.sys = S, z(this, ne).classList.add(\"sn_tx\"), z(this, ne).style.position = \"absolute\", z(Zt, Lo).view.parentElement.appendChild(z(this, ne)), this.addChild(z(this, jr)), this.addChild(z(this, oi)), z(this, oi).name = \"grpDbgMasume\", z(this, sr).adopt(z(this, Gi));\n  }\n  static init(e, r) {\n    ot(Zt, Ws, e), ot(Zt, Lo, r), ot(Zt, wn, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), ot(Zt, Cn, /[［（｛〈「『【〔“〝]/), ot(Zt, Js, /[─‥…]/);\n  }\n  static setEvtMng(e) {\n    ot(Zt, Sn, e);\n  }\n  static destroy() {\n    ot(Zt, ci, /* @__PURE__ */ Object.create(null)), ot(Zt, fi, /* @__PURE__ */ Object.create(null)), ot(Zt, zr, new Container());\n  }\n  lay(e) {\n    const r = z(this, ne).style;\n    if (\"style\" in e)\n      if (e.style) {\n        const S = document.createElement(\"span\");\n        S.style.cssText = e.style;\n        const T = S.style.length;\n        for (let D = 0; D < T; ++D) {\n          const N = S.style[D];\n          if (N in z(Zt, ah)) {\n            DebugMng.myTrace(`${N}は指定できません`, \"W\");\n            continue;\n          }\n          r[N] = S.style[N];\n        }\n        !S.style.opacity && \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n      } else\n        z(this, ne).style.cssText = \"\";\n    else\n      \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n    if (\"width\" in e && (r.width = (e.width ?? \"0\") + \"px\"), \"height\" in e && (r.height = (e.height ?? \"0\") + \"px\"), \"pl\" in e && (r.paddingLeft = (e.pl ?? \"0\") + \"px\"), \"pr\" in e && (r.paddingRight = (e.pr ?? \"0\") + \"px\"), \"pt\" in e && (r.paddingTop = (e.pt ?? \"0\") + \"px\"), \"pb\" in e && (r.paddingBottom = (e.pb ?? \"0\") + \"px\"), \"kinsoku_sol\" in e && ot(Zt, wn, new RegExp(`[${e.kinsoku_sol}]`)), \"kinsoku_eol\" in e && ot(Zt, Cn, new RegExp(`[${e.kinsoku_eol}]`)), \"kinsoku_dns\" in e && ot(Zt, Js, new RegExp(`[${e.kinsoku_dns}]`)), lt(this, qs, cu).call(this), z(this, sr).sethArg(e), ot(this, Cr, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? \"inline\" : \"none\", r.textShadow = e.filter ?? r.textShadow ?? \"\", ot(this, li, argChk_Boolean(e, \"break_fixed\", z(this, li))), ot(this, ar, argChk_Num(e, \"break_fixed_left\", z(this, ar))), ot(this, or, argChk_Num(e, \"break_fixed_top\", z(this, or))), \":redraw\" in e && z(this, Tn) > 0) {\n      const S = [\n        z(this, ne).innerHTML.replaceAll(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>　</span>`\n      ];\n      lt(this, Uo, af).call(this), this.goTxt(S, !0);\n    }\n  }\n  cvsResize() {\n    const e = z(this, ne).style, r = this.sys.cvsScale;\n    e.left = `${this.sys.ofsLeft4elm + z(this, Cr) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, z(this, sr).cvsResize(), z(this, Gi).cvsResize();\n  }\n  get tategaki() {\n    return z(this, Ui);\n  }\n  get infTL() {\n    return z(this, Yt);\n  }\n  get getWidth() {\n    return z(this, Yt).$width;\n  }\n  get getHeight() {\n    return z(this, Yt).$height;\n  }\n  setSize(e, r) {\n    z(this, Yt).$width = e, z(this, Yt).$height = r, z(this, ne).style.width = z(this, Yt).$width + \"px\", z(this, ne).style.height = z(this, Yt).$height + \"px\";\n  }\n  goTxt(e, r) {\n    var et, nt, st;\n    z(Zt, zr).visible = !1;\n    let S = z(this, ui).length, T = \"\";\n    S === 0 ? (z(Zt, Ws).oCfg.debug.masume && (CmnLib.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${z(this, Yt).pad_left} pr:${z(this, Yt).pad_right} pt:${z(this, Yt).pad_top} pb:${z(this, Yt).pad_bottom} w:${z(this, Yt).$width} h:${z(this, Yt).$height}`), z(this, oi).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-z(this, Yt).pad_left, -z(this, Yt).pad_top, z(this, Yt).$width, z(this, Yt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(\n      0,\n      0,\n      z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right,\n      z(this, Yt).$height - z(this, Yt).pad_top - z(this, Yt).pad_bottom\n    ).endFill()), z(this, ne).innerHTML = [...e].join(\"\").replaceAll(/[\\n\\t]/g, \"\") + z(Zt, Bo)) : (T = z(this, ne).innerHTML, z(this, ne).querySelectorAll(\":scope > br\").forEach((it) => z(this, ne).removeChild(it)), z(this, ne).insertAdjacentHTML(\n      \"beforeend\",\n      e.slice(z(this, Tn)).join(\"\").replaceAll(/[\\n\\t]/g, \"\") + z(Zt, Bo)\n    ), --S, (et = z(this, ne).querySelector(\".sn_ch_last\")) == null || et.remove()), ot(this, Tn, e.length);\n    const D = this.sys.cvsScale, N = z(this, ne).getBoundingClientRect(), B = N.left + z(this, Yt).pad_left, $ = N.top + z(this, Yt).pad_top;\n    let U;\n    if (D === 1)\n      U = (it, at) => new Rectangle(\n        it.left - B,\n        it.top - $,\n        it.width,\n        it.height + (\"gjqy\".includes(at) ? z(this, Qs) : 0)\n      );\n    else {\n      const it = this.sys.ofsPadLeft_Dom2PIXI + N.left * (1 - D), at = this.sys.ofsPadTop_Dom2PIXI + N.top * (1 - D);\n      U = (ut, ct) => new Rectangle(\n        (ut.left - it) / D - B,\n        (ut.top - at) / D - $,\n        ut.width / D,\n        (ut.height + (\"gjqy\".includes(ct) ? z(this, Qs) : 0)) / D\n      );\n    }\n    let V = 0, H = 2, X = !1;\n    do {\n      const it = ot(this, ui, lt(this, Go, sf).call(this, z(this, ne), U));\n      if (V = it.length, !X && (V < 2 || S === V)) {\n        S > 0 && S === V && (z(this, ne).innerHTML = T.replaceAll('class=\"sn_ch\"', 'class=\"sn_ch sn_ch_in_default\"'));\n        break;\n      }\n      X = !0;\n      let at = -1 / 0;\n      for (; H < V; ++H) {\n        const ut = it[H];\n        if (ut.elm.tagName === \"RT\")\n          continue;\n        const ct = this.tategaki ? ut.rect.y : ut.rect.x;\n        if (at <= ct || ((st = (nt = ut.elm.previousElementSibling) == null ? void 0 : nt.children[0]) == null ? void 0 : st.tagName) === \"BR\") {\n          at = ct;\n          continue;\n        }\n        let gt = H - 1;\n        for (; it[gt].elm.tagName === \"RT\"; )\n          --gt;\n        const _t = it[gt].ch;\n        at = -1 / 0;\n        const vt = H;\n        if (z(Zt, Js).test(_t) && _t === ut.ch)\n          H = gt;\n        else {\n          if (z(Zt, Cn).test(_t))\n            H = gt;\n          else if (z(Zt, wn).test(ut.ch))\n            for (H = gt + 1; H > 0 && z(Zt, wn).test(it[--H].ch); )\n              ;\n          else {\n            ++H;\n            continue;\n          }\n          for (H = gt + 1; H > 0 && z(Zt, Cn).test(it[--H].ch); )\n            ;\n        }\n        const mt = it[H].elm.parentElement, bt = document.createElement(\"br\");\n        if (mt.classList.contains(\"sn_tx\"))\n          mt.insertBefore(bt, it[H].elm);\n        else {\n          const Ct = mt.parentElement;\n          Ct.classList.contains(\"sn_ch\") ? Ct.parentElement.insertBefore(bt, Ct) : Ct.insertBefore(bt, mt);\n        }\n        H += 2, H < vt && (H = vt), V = -1;\n        break;\n      }\n    } while (V < 0);\n    const Y = CmnLib.debugLog ? (it, at) => console.log(`🍌 masume ch:${it.ch} x:${at.x} y:${at.y} w:${at.width} h:${at.height}`) : () => {\n    }, W = z(Zt, Ws).oCfg.debug.masume ? (it, at) => {\n      Y(it, at), z(this, oi).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(at.x, at.y, at.width, at.height).endFill();\n    } : () => {\n    }, q = CmnTween.ease(z(this, ji));\n    for (let it = S; it < V; ++it) {\n      const at = z(this, ui)[it], ut = at.rect, ct = JSON.parse(at.elm.dataset.arg ?? '{\"delay\": 0}'), gt = JSON.parse(at.elm.dataset.add ?? \"{}\"), _t = z(Zt, ci)[gt.ch_in_style];\n      if (W(at, ut), at.elm.dataset.cmd === \"grp\") {\n        const vt = new Container();\n        z(this, jr).addChild(vt), GrpLayer.csv2Sprites(ct.pic, vt, (mt) => {\n          lt(this, Fo, nf).call(this, vt, ct, gt, ut, q, _t ?? {}), vt.parent || vt.removeChild(mt);\n        });\n      }\n      if (at.elm.dataset.lnk) {\n        const vt = at.elm.parentElement.closest(\"[data-arg]\"), mt = JSON.parse(vt.dataset.arg ?? \"{}\");\n        mt.key = `lnk=[${it}] ` + this.name;\n        const bt = new Sprite();\n        lt(this, Fo, nf).call(this, bt, mt, gt, ut, q, _t ?? {});\n        const Ct = mt.style ?? \"\", St = Ct + (mt.style_hover ?? \"\"), pt = Ct + (mt.style_clicked ?? \"\"), yt = mt.r_style ?? \"\", At = yt + (mt.r_style_hover ?? \"\"), Dt = yt + (mt.r_style_clicked ?? \"\"), Ot = vt.querySelectorAll(\"rt\");\n        Ot.forEach((Ft) => Ft.dataset.st_r_bk = Ft.style.cssText);\n        const Pt = vt.style.cssText, ft = (Ft, It) => {\n          vt.style.cssText = Pt + Ft, Ot.forEach((zt) => zt.style.cssText = zt.dataset.st_r_bk + It);\n        };\n        z(Zt, Sn).button(\n          mt,\n          bt,\n          () => ft(Ct, yt),\n          () => this.canFocus() ? (ft(St, At), !0) : !1,\n          () => ft(pt, Dt)\n        ), z(this, jr).addChild(bt);\n      }\n    }\n    const K = z(this, ne).querySelectorAll(\"span.sn_ch\");\n    if (ot(this, hi, () => (ot(this, hi, () => !1), K.forEach((it) => it.className = it.className.replaceAll(/ go_ch_in_[^\\s\"]+/g, \"\")), z(Zt, zr).position.set(\n      z(this, ar),\n      z(this, or)\n    ), z(Zt, zr).visible = !0, z(Zt, Sn).noticeCompTxt(), !0)), K.length === 0) {\n      const it = globalThis.getComputedStyle(z(this, ne)), at = parseFloat(it.fontSize);\n      z(this, Ui) ? (ot(this, ar, (z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right - at * 1.5) * this.sys.cvsScale), ot(this, or, 0)) : (ot(this, ar, 0), ot(this, or, at / 2 * this.sys.cvsScale)), z(this, hi).call(this);\n      return;\n    }\n    K.forEach((it) => it.className = it.className.replaceAll(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\"));\n    const { x: J, y: Q } = z(this, ui)[V - 1].rect;\n    ot(this, ar, J), ot(this, or, Q), S > 0 && ++S;\n    let rt;\n    for (let it = V - 2; it >= 0; --it) {\n      const at = z(this, ui)[it];\n      if (at.elm.tagName === \"SPAN\") {\n        rt = at.elm;\n        break;\n      }\n    }\n    if (!rt || r || S === V) {\n      z(this, hi).call(this);\n      return;\n    }\n    rt.addEventListener(\"animationend\", z(this, hi), { once: !0, passive: !0 });\n  }\n  skipChIn() {\n    let e = z(this, hi).call(this);\n    for (const r of z(this, Zs))\n      r.tw && (r.tw.stop().end(), e = !0);\n    return ot(this, Zs, []), e;\n  }\n  static initChStyle() {\n    ot(Zt, ci, /* @__PURE__ */ Object.create(null)), ot(Zt, fi, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(e) {\n    return z(Zt, ci)[e];\n  }\n  static ch_in_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (z(Zt, $o).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in z(Zt, ci))\n      throw `name【${r}】はすでにあります`;\n    const S = String(e.x ?? \"=0\"), T = String(e.y ?? \"=0\");\n    return z(Zt, ci)[r] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: S,\n      y: T,\n      nx: parseFloat(S.at(0) === \"=\" ? S.slice(1) : S),\n      ny: parseFloat(T.at(0) === \"=\" ? T.slice(1) : T),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !0),\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  static getChOutStyle(e) {\n    return z(Zt, fi)[e];\n  }\n  static ch_out_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (z(Zt, $o).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in z(Zt, fi))\n      throw `name【${r}】はすでにあります`;\n    const S = String(e.x ?? \"=0\"), T = String(e.y ?? \"=0\");\n    return z(Zt, fi)[r] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: S,\n      y: T,\n      nx: parseFloat(S.at(0) === \"=\" ? S.slice(1) : S),\n      ny: parseFloat(T.at(0) === \"=\" ? T.slice(1) : T),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !1),\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  dispBreak(e) {\n    const r = z(Zt, zr);\n    r.visible = !1, this.addChild(r), GrpLayer.csv2Sprites(e, r, (S) => {\n      r.parent || r.removeChild(S);\n    });\n  }\n  static delBreak() {\n    const e = z(Zt, zr);\n    e.parent && (e.parent.removeChild(e), e.removeChildren()), ot(Zt, zr, new Container());\n  }\n  reNew() {\n    var r;\n    lt(this, Uo, af).call(this);\n    const e = new Zt(this.spLay, () => this.canFocus(), this.sys);\n    return ot(e, Yt, z(this, Yt)), z(e, ne).style.cssText = z(this, ne).style.cssText, ot(e, Cr, z(this, Cr)), e.name = this.name, lt(r = e, qs, cu).call(r), z(e, sr).sethArg(z(this, sr).gethArg()), ot(e, En, z(this, En)), ot(e, ji, z(this, ji)), ot(e, Pn, z(this, Pn)), ot(e, li, z(this, li)), ot(e, ar, z(this, ar)), ot(e, or, z(this, or)), this.destroy(), e;\n  }\n  record() {\n    return {\n      infTL: z(this, Yt),\n      cssText: z(this, ne).style.cssText,\n      left: z(this, Cr),\n      idc_hArg: z(this, sr).gethArg(),\n      ch_filter: z(this, En),\n      fi_easing: z(this, ji),\n      fo_easing: z(this, Pn),\n      break_fixed: z(this, li),\n      break_fixed_left: z(this, ar),\n      break_fixed_top: z(this, or)\n    };\n  }\n  playback(e) {\n    ot(this, Yt, e.infTL), this.position.set(z(this, Yt).pad_left, z(this, Yt).pad_top), z(this, ne).style.cssText = e.cssText, ot(this, Cr, e.left), lt(this, qs, cu).call(this), z(this, sr).sethArg(e.idc_hArg), ot(this, En, e.ch_filter), ot(this, ji, e.fi_easing), ot(this, Pn, e.fo_easing), ot(this, li, e.break_fixed ?? !1), ot(this, ar, e.break_fixed_left ?? 0), ot(this, or, e.break_fixed_top ?? 0);\n  }\n  snapshot(e, r) {\n    lt(this, oh, fd).call(this, (S) => {\n      ot(this, We, new Sprite(S)), z(this, Ui) && (z(this, We).x += CmnLib.stageW - (z(this, Cr) + z(this, Yt).$width)), z(this, We).y -= z(this, Ks), z(this, We).texture.frame = new Rectangle(\n        0,\n        0,\n        Math.min(z(this, We).width, z(this, Yt).$width - z(this, Cr)),\n        Math.min(z(this, We).height, z(this, Yt).$height)\n      ), z(this, jr).addChild(z(this, We)), e.render(z(this, We), { clear: !1 }), r();\n    }, !1);\n  }\n  snapshot_end() {\n    z(this, We) && (z(this, jr).removeChild(z(this, We)), ot(this, We, void 0));\n  }\n  makeDesignCast(e) {\n    e(z(this, sr));\n    const r = z(this, sr).gethArg();\n    z(this, Gi).sethArg({ ...r, \":id_dc\": r[\":id_tag\"] + \"_pad\" }), e(z(this, Gi));\n  }\n  showDesignCast() {\n    z(this, sr).visible = !0, z(this, Gi).visible = !0;\n  }\n  dump() {\n    const e = [], r = z(this, ne).style, S = r.length;\n    for (let T = 0; T < S; ++T) {\n      const D = r[T];\n      e.push(`\"${D}\":\"${r[D].replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${z(this, ne).textContent.replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${e.join(\",\")}}`;\n  }\n  destroy() {\n    Zt.delBreak(), z(this, ne).parentElement.removeChild(z(this, ne)), this.removeChild(z(this, jr)), this.removeChild(z(this, oi)), super.destroy();\n  }\n};\nlet TxtStage = Zt;\nWs = new WeakMap(), Lo = new WeakMap(), Sn = new WeakMap(), ne = new WeakMap(), jr = new WeakMap(), oi = new WeakMap(), ah = new WeakMap(), sr = new WeakMap(), Gi = new WeakMap(), Yt = new WeakMap(), li = new WeakMap(), ar = new WeakMap(), or = new WeakMap(), qs = new WeakSet(), cu = function() {\n  const e = z(this, ne).style, r = parseFloat(e.fontSize || \"0\");\n  z(this, Yt).fontsize = r, z(this, Yt).pad_left = parseFloat(e.paddingLeft || \"0\"), z(this, Yt).pad_right = parseFloat(e.paddingRight || \"0\"), z(this, Yt).pad_top = parseFloat(e.paddingTop || \"0\"), z(this, Yt).pad_bottom = parseFloat(e.paddingBottom || \"0\"), z(this, Yt).$width = parseFloat(e.width || \"0\"), z(this, Yt).$height = parseFloat(e.height || \"0\"), this.position.set(z(this, Yt).pad_left, z(this, Yt).pad_top), ot(this, Ui, e.writingMode === \"vertical-rl\"), ot(this, ko, 0), ot(this, Ks, 0);\n  const S = e.lineHeight ?? \"0\";\n  ot(this, Qs, z(this, Ui) ? 0 : (S.slice(-2) === \"px\" ? parseFloat(S) : r * parseFloat(S) - r) / 2);\n}, Cr = new WeakMap(), Ui = new WeakMap(), ko = new WeakMap(), Ks = new WeakMap(), oh = new WeakSet(), fd = function(e, r = !0) {\n  const S = {\n    escape: (q) => q.replaceAll(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (q) => {\n      const K = $(q).toLowerCase();\n      return T()[K] || \"\";\n    },\n    dataAsUrl: X,\n    isDataUrl: U,\n    resolveUrl: V,\n    getAndEncode: H,\n    asArray: (q) => {\n      const K = [], Z = q.length;\n      for (let J = 0; J < Z; ++J)\n        K.push(q[J]);\n      return K;\n    }\n  };\n  function T() {\n    const q = \"application/font-woff\", K = \"image/jpeg\";\n    return {\n      woff: q,\n      woff2: q,\n      ttf: \"application/font-truetype\",\n      eot: \"application/vnd.ms-fontobject\",\n      png: \"image/png\",\n      jpg: K,\n      jpeg: K,\n      gif: \"image/gif\",\n      tiff: \"image/tiff\",\n      svg: \"image/svg+xml\"\n    };\n  }\n  const D = Y(), N = W();\n  function B(q) {\n    return N.resolveAll().then((K) => {\n      const Z = document.createElement(\"style\");\n      return q.appendChild(Z), Z.appendChild(document.createTextNode(K)), q;\n    });\n  }\n  function $(q) {\n    const K = /\\.([^\\.\\/]*?)$/g.exec(q);\n    return (K == null ? void 0 : K[1]) ?? \"\";\n  }\n  function U(q) {\n    return q.search(/^(data:)/) !== -1;\n  }\n  function V(q, K) {\n    const Z = document.implementation.createHTMLDocument(), J = Z.createElement(\"base\");\n    Z.head.appendChild(J);\n    const Q = Z.createElement(\"a\");\n    return Z.body.appendChild(Q), J.href = K, Q.href = q, Q.href;\n  }\n  function H(q) {\n    let K = 3e4;\n    return new Promise(function(Z) {\n      const J = new XMLHttpRequest();\n      J.onreadystatechange = Q, J.ontimeout = rt, J.responseType = \"blob\", J.timeout = K, J.open(\"GET\", q, !0), J.send();\n      function Q() {\n        if (J.readyState !== 4)\n          return;\n        if (J.status !== 200) {\n          et(\"cannot fetch resource: \" + q + \", status: \" + J.status);\n          return;\n        }\n        const nt = new FileReader();\n        nt.onloadend = function() {\n          const st = nt.result.toString().split(/,/)[1];\n          Z(st);\n        }, nt.readAsDataURL(J.response);\n      }\n      function rt() {\n        et(\"timeout of \" + K + \"ms occured while fetching resource: \" + q);\n      }\n      function et(nt) {\n        console.error(nt), Z(\"\");\n      }\n    });\n  }\n  function X(q, K) {\n    return \"data:\" + K + \";base64,\" + q;\n  }\n  function Y() {\n    const q = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll: Q,\n      shouldProcess: K\n    };\n    function K(rt) {\n      return rt.search(q) !== -1;\n    }\n    function Z(rt) {\n      const et = [];\n      let nt;\n      for (; nt = q.exec(rt); )\n        et.push(nt[1]);\n      return et.filter(function(st) {\n        return !S.isDataUrl(st);\n      });\n    }\n    function J(rt, et, nt, st) {\n      return Promise.resolve(et).then((at) => nt ? S.resolveUrl(at, nt) : at).then(st || S.getAndEncode).then((at) => S.dataAsUrl(at, S.mimeType(et))).then((at) => rt.replace(it(et), \"$1\" + at + \"$3\"));\n      function it(at) {\n        return new RegExp(`(url\\\\(['\"]?)(` + S.escape(at) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function Q(rt, et, nt) {\n      if (st())\n        return Promise.resolve(rt);\n      return Promise.resolve(rt).then(Z).then((it) => {\n        let at = Promise.resolve(rt);\n        for (const ut of it)\n          at = at.then((ct) => J(ct, ut, et, nt));\n        return at;\n      });\n      function st() {\n        return !K(rt);\n      }\n    }\n  }\n  function W() {\n    return {\n      resolveAll: q,\n      impl: { readAll: K }\n    };\n    function q() {\n      return K().then((Z) => Promise.allSettled(\n        Z.map((J) => J.resolve())\n      )).then((Z) => Z.join(`\n`));\n    }\n    function K() {\n      return Promise.resolve(S.asArray(document.styleSheets)).then(J).then(Z).then((rt) => rt.map(Q));\n      function Z(rt) {\n        return rt.filter((et) => et.type === CSSRule.FONT_FACE_RULE).filter((et) => D.shouldProcess(et.style.getPropertyValue(\"src\")));\n      }\n      function J(rt) {\n        const et = [];\n        for (const nt of rt)\n          try {\n            if (nt.href)\n              continue;\n            S.asArray(nt.cssRules || []).forEach(et.push.bind(et));\n          } catch (st) {\n            console.error(\"Error while reading CSS rules from \" + nt.href, st.toString());\n          }\n        return et;\n      }\n      function Q(rt) {\n        return {\n          resolve: function() {\n            const nt = (rt.parentStyleSheet || {}).href;\n            return D.inlineAll(rt.cssText, nt);\n          },\n          src: function() {\n            return rt.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(z(this, ne)).then((q) => {\n    const K = q.cloneNode(!0);\n    return K.style.padding = \"0px\", K.style.paddingRight = z(this, ko) + \"px\", K.style.paddingTop = z(this, Ks) + \"px\", K.style.left = \"0px\", K.style.top = \"0px\", K.style.width = z(this, Yt).$width - z(this, Yt).pad_left - z(this, Yt).pad_right + \"px\", K.style.height = z(this, Yt).$height - z(this, Yt).pad_top - z(this, Yt).pad_bottom + \"px\", z(this, ne).hidden = r, K;\n  }).then(B).then((q) => {\n    q.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const K = new Image();\n    return K.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${z(this, Yt).$width}px\" height=\"${z(this, Yt).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(q).replaceAll(\"#\", \"%23\").replaceAll(`\n`, \"%0A\")}</foreignObject></svg>`, new Promise((Z) => K.onload = () => Z(K));\n  }).then((q) => new Promise((K) => setTimeout(() => K(q), 100))).then((q) => {\n    const K = document.createElement(\"canvas\");\n    K.width = z(this, Yt).$width, K.height = z(this, Yt).$height, K.getContext(\"2d\").drawImage(q, 0, 0), K.toBlob((Z) => {\n      if (!Z)\n        return;\n      const J = URL.createObjectURL(Z);\n      Texture.from(J).once(\"update\", (Q) => {\n        e(Q), URL.revokeObjectURL(J);\n      });\n    });\n  }).catch((q) => DebugMng.myTrace(`goTxt() = ${q}`));\n}, En = new WeakMap(), Zs = new WeakMap(), ui = new WeakMap(), Tn = new WeakMap(), wn = new WeakMap(), Cn = new WeakMap(), Js = new WeakMap(), Bo = new WeakMap(), hi = new WeakMap(), Fo = new WeakSet(), nf = function(e, r, S, T, D, N) {\n  e.alpha = 0, r.x && (T.x = r.x.at(0) === \"=\" ? T.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (T.y = r.y.at(0) === \"=\" ? T.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (T.width = parseInt(r.width)), r.height && (T.height = parseInt(r.height)), r.wait && (N.wait = parseInt(r.wait)), e.width = T.width, e.height = T.height, N.x ? e.position.set(\n    N.x.at(0) === \"=\" ? T.x + e.width * N.nx : N.nx,\n    N.y.at(0) === \"=\" ? T.y + e.height * N.ny : N.ny\n  ) : e.position.set(T.x, T.y);\n  const B = {\n    sp: e,\n    tw: new Tween(e).to({ alpha: 1, x: T.x, y: T.y, width: T.width, height: T.height, angle: 0 }, N.wait ?? 0).easing(D).delay((S.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {\n      B.tw = void 0;\n    }).start()\n  };\n  z(this, Zs).push(B);\n}, ci = new WeakMap(), $o = new WeakMap(), fi = new WeakMap(), zr = new WeakMap(), Qs = new WeakMap(), Go = new WeakSet(), sf = function(e, r) {\n  const S = [];\n  if (e.nodeType !== e.TEXT_NODE)\n    return Array.from(e.childNodes).map((B) => lt(this, Go, sf).call(this, B, r)).flat();\n  const T = e.ownerDocument.createRange();\n  T.selectNodeContents(e);\n  let D = 0;\n  const N = T.endOffset;\n  for (; D < N; ) {\n    T.setStart(e, D), T.setEnd(e, ++D);\n    const B = T.toString();\n    S.push({\n      ch: B,\n      rect: r(T.getBoundingClientRect(), B),\n      elm: T.startContainer.parentElement\n    });\n  }\n  return T.detach(), S;\n}, ji = new WeakMap(), Pn = new WeakMap(), Uo = new WeakSet(), af = function() {\n  var D;\n  z(this, oi).clear(), ot(this, ui, []), ot(this, Tn, 0), this.skipChIn();\n  const e = z(this, ne).cloneNode(!0);\n  e.textContent = \"\";\n  const r = z(this, ne);\n  r.parentElement.insertBefore(e, r);\n  let S = 0;\n  r.querySelectorAll(\"span.sn_ch\").forEach((N) => {\n    var U, V, H;\n    const B = JSON.parse(\n      (N == null ? void 0 : N.dataset.add) ?? ((U = N == null ? void 0 : N.children[0]) == null ? void 0 : U.getAttribute(\"data-add\")) ?? ((H = (V = N == null ? void 0 : N.children[0]) == null ? void 0 : V.children[0]) == null ? void 0 : H.getAttribute(\"data-add\")) ?? \"{}\"\n    );\n    if (!B.ch_out_style)\n      return;\n    const $ = z(Zt, fi)[B.ch_out_style];\n    if (!!$) {\n      if ($.wait === 0) {\n        N.style.display = \"none\";\n        return;\n      }\n      S += $.wait, $.join || (N.style.animationDelay = \"0ms\"), N.classList.add(`go_ch_out_${B.ch_out_style}`);\n    }\n  });\n  const T = () => {\n    r.parentElement.removeChild(r);\n    for (const N of z(this, jr).removeChildren())\n      N instanceof Container && z(Zt, Sn).unButton(N), N.destroy();\n  };\n  S === 0 ? (z(this, ne).textContent = \"\", T()) : (D = r.lastElementChild) == null || D.addEventListener(\"animationend\", T, { once: !0, passive: !0 }), ot(this, ne, e);\n}, We = new WeakMap(), tt(TxtStage, Ws, void 0), tt(TxtStage, Lo, void 0), tt(TxtStage, Sn, void 0), tt(TxtStage, ah, {\n  \"background-color\": 0,\n  \"border-bottom-width\": 0,\n  \"border-left-width\": 0,\n  \"border-right-width\": 0,\n  \"border-top-width\": 0,\n  \"margin-bottom\": 0,\n  \"margin-left\": 0,\n  \"margin-right\": 0,\n  \"margin-top\": 0\n}), tt(TxtStage, wn, void 0), tt(TxtStage, Cn, void 0), tt(TxtStage, Js, void 0), tt(TxtStage, Bo, \"<span class='sn_ch sn_ch_last'>　</span>\"), tt(TxtStage, ci, /* @__PURE__ */ Object.create(null)), tt(TxtStage, $o, /[\\s\\.,]/), tt(TxtStage, fi, /* @__PURE__ */ Object.create(null)), tt(TxtStage, zr, new Container());\nvar Rn, Hr, jo;\nconst Ii = class {\n  constructor() {\n    tt(this, Hr, () => {\n    });\n  }\n  static setting(t) {\n    t.sesame && ot(Ii, Rn, t.sesame);\n  }\n  static getSesame() {\n    return z(Ii, Rn);\n  }\n  static destroy() {\n    ot(Ii, Rn, \"ヽ\");\n  }\n  init(t) {\n    ot(this, Hr, t);\n  }\n  static setEscape(t) {\n    ot(Ii, jo, new RegExp(\n      `${t ? `(?<ce>\\\\${t}\\\\S)|` : \"\"}｜(?<str>[^《\\\\n]+)《(?<ruby>[^》\\\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\\\n])《(?<kan_ruby>[^》\\\\n]+)》)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^｜《》]+?|.)`,\n      \"gs\"\n    ));\n  }\n  putTxt(t) {\n    for (const { groups: e } of t.matchAll(z(Ii, jo))) {\n      const { ruby: r, kan_ruby: S, kan: T, ce: D, txt: N = \"\", str: B } = e;\n      if (r) {\n        this.putTxtRb(decodeURIComponent(B), r);\n        continue;\n      }\n      if (S) {\n        this.putTxtRb(T, S);\n        continue;\n      }\n      if (D) {\n        z(this, Hr).call(this, D.slice(1), \"\");\n        continue;\n      }\n      for (const $ of Array.from(N))\n        z(this, Hr).call(this, $, \"\");\n    }\n  }\n  putTxtRb(t, e) {\n    if (/^\\w+｜{\"/.test(e)) {\n      z(this, Hr).call(this, t, e);\n      return;\n    }\n    const r = Array.from(t), S = r.length;\n    if (/^\\*.?$/.test(e)) {\n      const B = \"center｜\" + (e === \"*\" ? z(Ii, Rn) : e.charAt(1));\n      for (let $ = 0; $ < S; ++$)\n        z(this, Hr).call(this, r[$], B);\n      return;\n    }\n    if (S === 1 || e.indexOf(\" \") === -1) {\n      z(this, Hr).call(this, t, decodeURIComponent(e));\n      return;\n    }\n    const T = e.split(\" \"), D = T.length, N = D > S ? D : S;\n    for (let B = 0; B < N; ++B)\n      z(this, Hr).call(this, B < S ? r[B] : \"\", B < D ? decodeURIComponent(T[B]) : \"\");\n  }\n};\nlet RubySpliter = Ii;\nRn = new WeakMap(), Hr = new WeakMap(), jo = new WeakMap(), tt(RubySpliter, Rn, \"ヽ\"), tt(RubySpliter, jo, void 0);\nvar zo, Ho, Pr, di, ta, ea, Vo, of, ra, ia, Xo, lf;\nconst an = class extends Container {\n  constructor(e, r, S, T) {\n    var Y;\n    super();\n    tt(this, Vo);\n    tt(this, Xo);\n    Rt(this, \"getBtnBounds\", () => z(this, Pr));\n    tt(this, Pr, new Rectangle());\n    tt(this, di, void 0);\n    tt(this, ta, void 0);\n    tt(this, ea, void 0);\n    Rt(this, \"normal\", () => {\n    });\n    tt(this, ra, () => !1);\n    tt(this, ia, () => {\n    });\n    this.hArg = e, this.evtMng = r, this.resolve = S, this.canFocus = T, CmnLib.isDbg && (this.makeDesignCast = (W) => W(z(this, di)), this.cvsResize = () => z(this, di).cvsResize());\n    let D = {\n      x: this.x = uint(e.left ?? 0),\n      y: this.y = uint(e.top ?? 0),\n      rotation: this.angle = argChk_Num(e, \"rotation\", this.angle),\n      pivot_x: this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    this.getBtnBounds = () => (z(this, Pr).x = D.x, z(this, Pr).y = D.y, z(this, Pr));\n    const N = D.enabled = argChk_Boolean(e, \"enabled\", !0);\n    if (N && r.button(this.hArg, this, () => this.normal(), () => z(this, ra).call(this), () => z(this, ia).call(this)), e.pic) {\n      D.type = \"pic\", ot(this, di, new PicBtnDesignCast(this, e)), GrpLayer.csv2Sprites(\n        e.pic,\n        this,\n        (W) => {\n          lt(this, Xo, lf).call(this, W, D), z(this, Pr).width = W.width * D.scale_x, z(this, Pr).height = W.height * D.scale_y;\n        },\n        (W) => S\n      );\n      return;\n    }\n    if (!e.text)\n      throw \"textまたはpic属性は必須です\";\n    const B = argChk_Num(e, \"height\", 30), $ = new TextStyle({\n      align: \"center\",\n      dropShadow: !0,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: N ? \"black\" : \"gray\",\n      fontFamily: an.fontFamily,\n      fontSize: B,\n      padding: 5\n    });\n    if (e.style)\n      try {\n        const W = JSON.parse(e.style);\n        for (const [q, K] of Object.entries(W))\n          $[q] = K;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style\", W.message));\n      }\n    const U = new Text(e.text ?? \"\", $);\n    U.alpha = argChk_Num(e, \"alpha\", U.alpha), U.width = argChk_Num(e, \"width\", 100), U.height = e.height = B, this.setText = (W) => U.text = W, D.type = \"text\", D = { ...D, ...$ }, D.alpha = U.alpha, D.text = U.text, D.width = U.width, D.height = U.height, ot(this, di, new TxtBtnDesignCast(this, e, U));\n    let V = !1;\n    if (D.width = this.width, D.height = this.height, e.b_pic && (D.b_pic = e.b_pic, V = GrpLayer.csv2Sprites(\n      e.b_pic,\n      this,\n      (W) => {\n        lt(this, Vo, of).call(this, W, U), D.width = this.width, D.height = this.height;\n      },\n      (W) => {\n        Layer.setBlendmode(this, e), W && S();\n      }\n    )), U.name = JSON.stringify(D), this.addChild(U), z(this, Pr).width = U.width, z(this, Pr).height = U.height, e.b_pic || Layer.setBlendmode(this, e), z(Y = an, zo).call(Y, this, U), !N) {\n      V || S();\n      return;\n    }\n    const H = $.clone();\n    if (e.style_hover)\n      try {\n        const W = JSON.parse(e.style_hover);\n        for (const [q, K] of Object.entries(W))\n          H[q] = K;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style_hover\", W.message));\n      }\n    else\n      H.fill = \"white\";\n    const X = H.clone();\n    if (e.style_clicked)\n      try {\n        const W = JSON.parse(e.style_clicked);\n        for (const [q, K] of Object.entries(W))\n          X[q] = K;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style_clicked\", W.message));\n      }\n    else\n      X.dropShadow = !1;\n    this.normal = () => U.style = $, ot(this, ra, () => T() ? (U.style = H, !0) : !1), ot(this, ia, () => U.style = X), V || S();\n  }\n  static init(e) {\n    !e.oCfg.debug.masume || (ot(an, zo, (r, S) => r.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(S.x, S.y, S.width, S.height).endFill()\n    )), ot(an, Ho, (r, S, T, D) => r.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(S.x, S.y, T, D).endFill()\n    )));\n  }\n  setText(e) {\n  }\n  destroy(e) {\n    this.evtMng.unButton(this), super.destroy();\n  }\n  makeDesignCast(e) {\n  }\n  showDesignCast() {\n    z(this, di).visible = !0;\n  }\n  cvsResize() {\n  }\n  update_b_pic(e, r) {\n    const S = JSON.parse(r.name ?? \"{}\");\n    z(this, ta) && this.removeChild(z(this, ta)), this.hArg.b_pic = S.b_pic = e, r.name = JSON.stringify(S), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (T) => lt(this, Vo, of).call(this, T, r),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n  update_pic(e, r) {\n    const S = JSON.parse(r.name ?? \"{}\");\n    z(this, ea) && this.removeChild(z(this, ea)), this.hArg.pic = S.pic = e, r.name = JSON.stringify(S), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (T) => lt(this, Xo, lf).call(this, T, S),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n};\nlet Button = an;\nzo = new WeakMap(), Ho = new WeakMap(), Pr = new WeakMap(), di = new WeakMap(), ta = new WeakMap(), ea = new WeakMap(), Vo = new WeakSet(), of = function(e, r) {\n  ot(this, ta, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(\n    r.x,\n    r.y,\n    1,\n    1,\n    r.rotation,\n    0,\n    0,\n    (e.width - r.width) / 2,\n    (e.height - r.height) / 2\n  ), e.name = r.name;\n}, ra = new WeakMap(), ia = new WeakMap(), Xo = new WeakSet(), lf = function(e, r) {\n  var V;\n  ot(this, ea, e), r.alpha = e.alpha = argChk_Num(this.hArg, \"alpha\", e.alpha), z(this, di).setSp(e);\n  const S = e.width / 3, T = e.height, D = e.texture.baseTexture, N = new Texture(D, new Rectangle(0, 0, S, T)), B = new Texture(D, new Rectangle(S, 0, S, T)), $ = new Texture(D, new Rectangle(S * 2, 0, S, T)), U = () => e.texture = N;\n  U(), this.normal = U, ot(this, ra, () => this.canFocus() ? (e.texture = $, !0) : !1), ot(this, ia, () => e.texture = B), \"width\" in this.hArg ? (r.width = uint(this.hArg.width), this.scale.x *= r.width / S) : r.width = S, \"height\" in this.hArg ? (r.height = uint(this.hArg.height), this.scale.y *= r.height / T) : r.height = T, e.name = JSON.stringify(r), z(V = an, Ho).call(V, this, e, S, T);\n}, Rt(Button, \"fontFamily\", \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif\"), tt(Button, zo, (e, r) => {\n}), tt(Button, Ho, (e, r, S, T) => {\n});\nvar na, Rr, Yo, sa, Wo, uf, qo, hf, Ko, Mn, Zo, pi, On, lh, dd, vi, vr, Mr, ve, Vr, he, Jo, Xr, uh, qe, In, za, Dn, aa, An, Ha, oa, Qo, cf, tl, ff, Nn, Ln, la, el, ua, zi, Ke, hh, pd, lr, rl, ha, fu, gi, rn, Yr, Or, gr, mr, il, df, ca, du, nl, pf, kn;\nconst te = class extends Layer {\n  constructor() {\n    super();\n    tt(this, In);\n    tt(this, An);\n    tt(this, Qo);\n    tt(this, tl);\n    tt(this, hh);\n    tt(this, ha);\n    tt(this, gi);\n    tt(this, il);\n    tt(this, ca);\n    tt(this, nl);\n    tt(this, vi, 0);\n    tt(this, vr, 0);\n    tt(this, Mr, !1);\n    tt(this, ve, void 0);\n    tt(this, Vr, \"\");\n    tt(this, he, new TxtStage(this.spLay, () => this.canFocus(), z(te, Zo)));\n    tt(this, Jo, new RubySpliter());\n    tt(this, Xr, document.createElement(\"span\"));\n    tt(this, qe, new Container());\n    tt(this, Dn, \"\");\n    tt(this, aa, !0);\n    tt(this, oa, \"\");\n    tt(this, Nn, \"\");\n    tt(this, Ln, (e) => \"\");\n    tt(this, la, \"\");\n    tt(this, el, new RegExp(\"[　]\"));\n    Rt(this, \"isCur\", !1);\n    tt(this, zi, () => \"\");\n    tt(this, Ke, \"\");\n    tt(this, lr, !1);\n    tt(this, rl, (e, r) => {\n      var $, U, V;\n      z(te, na).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\\`${e}\\` ruby:\\`${r}\\` name:\\`${this.name_}\\``);\n      const S = r.split(\"｜\");\n      let T = \"\";\n      const [D, ...N] = S, B = N.join(\"｜\");\n      switch (S.length) {\n        case 1:\n          if (ot(this, lr, !0), e === `\n`) {\n            z(this, Or) ? (ot(this, Or, !1), T = \"<ruby>　<rt>　</rt></ruby><br/>\") : T = \"<br/>\";\n            break;\n          }\n          z(this, Or) && (ot(this, Or, !1), r === \"\" && (r = \"　\")), T = lt(this, ha, fu).call(this, e, r, z(this, Ke));\n          break;\n        default:\n          switch (D) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              ot(this, Or, !1), ot(this, lr, !0), T = lt(this, ha, fu).call(this, e, B, D);\n              break;\n            case \"gotxt\":\n              lt(this, ca, du).call(this), z(this, lr) ? (this.isCur && z(te, sa).recText(\n                z(this, gr).join(\"\").replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, \"\").replaceAll(/style='(anim\\S+ \\S+?;\\s*)+/g, \"style='\").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replaceAll(/class='sn_ch .+?'/g, \"class='sn_ch'\").replaceAll(\"display: none;\", \"\").replaceAll(\"class='offrec'\", \"style='display: none;'\")\n              ), z(this, he).goTxt(z(this, gr), z(this, Yr) === 0), ot(this, lr, !1), ot(this, Yr, 0)) : this.isCur && z(te, Mn).noticeCompTxt();\n              return;\n            case \"add\":\n              {\n                const H = JSON.parse(B), { style: X = \"\", wait: Y = null } = H, { cl: W, sty: q } = lt(this, gi, rn).call(this, !0, Y);\n                z(this, gr).push(`<span${W} style='${q} display: inline; ${X}'>`), delete H.style, lt(this, il, df).call(this, H);\n              }\n              return;\n            case \"add_close\":\n              z(this, gr).push(\"</span>\"), lt(this, ca, du).call(this);\n              return;\n            case \"grp\":\n              ot(this, lr, !0);\n              {\n                const H = JSON.parse(B);\n                if (H.id ?? (H.id = z(this, gr).length), H.id === \"break\") {\n                  z(this, he).dispBreak(H.pic);\n                  return;\n                }\n                ot(this, Or, !1), H.delay = z(this, Yr), H.r ?? (H.r = \"\"), H.style ?? (H.style = \"\"), H.r_style ?? (H.r_style = \"\");\n                const { cl: X, sty: Y, lnk: W } = lt(this, gi, rn).call(this, !0, H.wait);\n                T = `<span${X} style='${Y} ${H.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(H)}'${W} style='${Y} display: inline;'>　</span><rt${W}${this.mkStyle_r_align(\n                  \"　\",\n                  H.r,\n                  z(this, Ke),\n                  z(this, Xr).style.cssText + ((($ = z(this, mr).at(-1)) == null ? void 0 : $.o.r_style) ?? \"\") + H.r_style\n                )}>${H.r}</rt></ruby></span>`;\n              }\n              break;\n            case \"tcy\":\n              ot(this, Or, !1), ot(this, lr, !0);\n              {\n                z(te, Rr).doRecLog() && ot(this, kn, z(this, kn) + (e + (r ? `《${r}》` : \"\")));\n                const { t: H, r: X = \"\", wait: Y = null, style: W = \"\", r_style: q = \"\" } = JSON.parse(B), K = CmnLib.isSafari ? X.replaceAll(/[A-Za-z0-9]/g, (rt) => String.fromCharCode(rt.charCodeAt(0) + 65248)) : X, { cl: Z, sty: J, lnk: Q } = lt(this, gi, rn).call(this, !0, Y);\n                T = `<span${Z} style='${J}${z(this, Ln).call(this, H)} ${W}'><ruby><span${Q} style='${J} display: inline;\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;'>${H}</span><rt${Q}${this.mkStyle_r_align(\n                  H,\n                  K,\n                  z(this, Ke),\n                  z(this, Xr).style.cssText + (((U = z(this, mr).at(-1)) == null ? void 0 : U.o.r_style) ?? \"\") + q\n                )}>${K}</rt></ruby></span>`;\n              }\n              break;\n            case \"del\":\n              TxtStage.delBreak();\n              return;\n            case \"span\":\n              ot(this, lr, !0), lt(this, nl, pf).call(this, JSON.parse(B));\n              return;\n            case \"link\":\n              ot(this, lr, !0);\n              {\n                const H = JSON.parse(B);\n                H[\":link\"] = \" data-lnk='@'\";\n                const { cl: X, sty: Y, curpos: W } = lt(this, gi, rn).call(this, !1, H.wait);\n                z(this, gr).push(`<span${X} style='${Y} display: inline; ${H.style ?? \"\"}' ${W} data-arg='${B}'>`), delete H.style, lt(this, nl, pf).call(this, H);\n              }\n              return;\n            case \"endlink\":\n              ot(this, lr, !0), z(this, gr).push(\"</span>\"), lt(this, ca, du).call(this);\n              return;\n            default:\n              ot(this, lr, !0), T = lt(this, ha, fu).call(this, e, r, z(this, Ke));\n          }\n          break;\n      }\n      z(this, gr).push(z(V = te, ua).call(V, T));\n    });\n    tt(this, Yr, 0);\n    tt(this, Or, !0);\n    tt(this, gr, []);\n    tt(this, mr, []);\n    Rt(this, \"click\", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : z(this, he).skipChIn());\n    tt(this, kn, \"\");\n    Rt(this, \"addButton\", (e) => new Promise((r) => {\n      e.key = `btn=[${z(this, qe).children.length}] ` + this.name_, e[\":id_tag\"] = e.key.slice(0, -7), argChk_Boolean(e, \"hint_tate\", z(this, he).tategaki);\n      const S = new Button(e, z(te, Mn), () => r(), () => this.canFocus());\n      S.name = JSON.stringify(e).replaceAll('\"', \"'\"), z(this, qe).addChild(S);\n    }));\n    Rt(this, \"record\", () => ({\n      ...super.record(),\n      enabled: this.enabled,\n      r_cssText: z(this, Xr).style.cssText,\n      r_align: z(this, Ke),\n      b_do: z(this, ve) === void 0 ? void 0 : z(this, ve) instanceof Sprite ? \"Sprite\" : \"Graphics\",\n      b_pic: z(this, Vr),\n      b_color: z(this, vi),\n      b_alpha: z(this, vr),\n      b_alpha_isfixed: z(this, Mr),\n      ffs: z(this, Nn),\n      txs: z(this, he).record(),\n      strNoFFS: z(this, la),\n      btns: z(this, qe).children.map((e) => e.name)\n    }));\n    this.spLay.addChild(z(this, he)), z(this, Jo).init(z(this, rl)), this.spLay.addChild(z(this, qe)), z(this, qe).name = \"cntBtn\";\n    const e = 16;\n    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(e, r, S, T, D, N) {\n    var B, $;\n    ot(te, na, e), TxtStage.init(e, N), ot(te, Rr, S), ot(te, sa, T), ot(te, Yo, D), S.setDoRecProc(te.chgDoRec), r.autowc = (U) => {\n      var V;\n      return lt(V = te, lh, dd).call(V, U);\n    }, r.autowc({ enabled: !1, text: \"\", time: 0 }), r.ch_in_style = (U) => {\n      var V;\n      return lt(V = te, Wo, uf).call(V, U);\n    }, r.ch_out_style = (U) => {\n      var V;\n      return lt(V = te, qo, hf).call(V, U);\n    }, TxtStage.initChStyle(), initStyle(), addStyle(\n      e.matchPath(\".+\", SEARCH_PATH_ARG_EXT.FONT).flatMap((U) => Object.values(U).map((V) => `\n@font-face {\n\tfont-family: '${V}';\n\tsrc: url('${z(this, na).searchPath(V, SEARCH_PATH_ARG_EXT.FONT)}');\n}\n`)).join(\"\") + `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`\n    ), lt(B = te, Wo, uf).call(B, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !0,\n      ease: \"ease-out\"\n    }), lt($ = te, qo, hf).call($, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !1,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(e, r, S) {\n    ot(te, Ko, e), ot(te, Mn, r), ot(te, Zo, S), TxtStage.setEvtMng(r);\n  }\n  destroy() {\n    z(this, ve) && (this.spLay.removeChild(z(this, ve)).destroy(), ot(this, ve, void 0)), this.clearText(), z(this, he).destroy();\n  }\n  static destroy() {\n    ot(te, pi, !1), ot(te, On, {}), ot(te, ua, (e) => e);\n  }\n  set name(e) {\n    this.name_ = e, z(this, he).name = e;\n  }\n  get name() {\n    return this.name_;\n  }\n  cvsResize() {\n    z(this, he).cvsResize();\n  }\n  cvsResizeChildren() {\n    for (const e of z(this, qe).children)\n      e.cvsResize();\n  }\n  lay(e) {\n    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[\":id_tag\"] = this.name_.slice(0, -7), RubySpliter.setting(e), lt(this, tl, ff).call(this, e), z(this, he).lay(e), \"r_align\" in e && ot(this, Ke, e.r_align ?? \"\"), ot(this, zi, CmnLib.isSafari ? z(this, he).tategaki ? (r, S) => `text-align: start; height: ${S}em; padding-top: ${r}; padding-bottom: ${r};` : (r, S) => `text-align: start; width: ${S}em; padding-left: ${r}; padding-right: ${r};` : z(this, he).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), CmnLib.isFirefox && (this.mkStyle_r_align = lt(this, hh, pd)), \"r_style\" in e)\n      if (e.r_style) {\n        const r = document.createElement(\"span\");\n        r.style.cssText = e.r_style;\n        const S = r.style.length, T = z(this, Xr).style;\n        for (let D = 0; D < S; ++D) {\n          const N = r.style[D];\n          if (N in z(te, uh)) {\n            DebugMng.myTrace(`${N}は指定できません`, \"W\");\n            continue;\n          }\n          T[N] = r.style[N];\n        }\n      } else\n        z(this, Xr).style.cssText = \"\";\n    if (\"alpha\" in e)\n      for (const r of z(this, qe).children)\n        r.alpha = this.spLay.alpha;\n    return lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e), lt(this, Qo, cf).call(this, e, (r) => {\n      r && z(te, Ko).resume();\n    });\n  }\n  get width() {\n    return z(this, he).getWidth;\n  }\n  get height() {\n    return z(this, he).getHeight;\n  }\n  chgBackAlpha(e) {\n    const r = z(this, Mr) ? z(this, vr) : e * z(this, vr);\n    z(this, ve) instanceof Graphics && (z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), this.spLay.addChildAt(\n      ot(this, ve, new Graphics()).beginFill(z(this, vi)).lineStyle(void 0).drawRect(0, 0, z(this, he).getWidth, z(this, he).getHeight).endFill(),\n      0\n    ), z(this, ve).name = \"back(color)\"), z(this, ve) && (z(this, ve).visible = r > 0, z(this, ve).alpha = r);\n  }\n  static chgDoRec(e) {\n    ot(te, ua, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);\n  }\n  mkStyle_r_align(e, r, S, T = \"\") {\n    if (!S)\n      return ` style='${T}'`;\n    const D = e.length * 2;\n    if (D - r.length < 0)\n      return ` style='text-align: ${S}; ${T}'`;\n    let N = \"\";\n    switch (S) {\n      case \"justify\":\n        N = z(this, zi).call(this, \"0\", D);\n        break;\n      case \"121\":\n        N = z(this, zi).call(this, `calc(${(D - r.length) / (r.length * 2)}em)`, D);\n        break;\n      case \"even\":\n        N = z(this, zi).call(this, `calc(${(D - r.length) / (r.length + 1)}em)`, D);\n        break;\n      case \"1ruby\":\n        N = z(this, zi).call(this, \"1em\", D);\n        break;\n      default:\n        N = `text-align: ${S};`;\n    }\n    return ` style='${N} ${T}'`;\n  }\n  tagCh(e) {\n    z(this, Jo).putTxt(e);\n  }\n  clearText() {\n    this.spLay.addChild(ot(this, he, z(this, he).reNew())), ot(this, Yr, 0), ot(this, Or, !0), ot(this, gr, []), ot(this, kn, \"\"), z(te, sa).recPagebreak();\n  }\n  get pageText() {\n    return z(this, kn).replace(\"《　》\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var e;\n    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && z(e = te, Yo).call(e, this);\n  }\n  clearLay(e) {\n    super.clearLay(e), this.clearText();\n    for (const r of z(this, qe).removeChildren())\n      r.destroy();\n  }\n  playback(e, r) {\n    super.playback(e, r), this.enabled = e.enabled, z(this, Xr).style.cssText = e.r_cssText, ot(this, Ke, e.r_align), this.cvsResize(), lt(this, tl, ff).call(this, e), z(this, he).playback(e.txs), ot(this, vr, e.b_alpha), ot(this, Mr, e.b_alpha_isfixed), r.push(new Promise((T) => {\n      const D = e.b_do ? e.b_do === \"Sprite\" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: \"\" };\n      D.b_alpha = e.b_alpha, D.b_alpha_isfixed = e.b_alpha_isfixed, lt(this, Qo, cf).call(this, D, (N) => {\n        N && T();\n      }) || T();\n    }));\n    const S = e.btns;\n    r = r.concat(S.map((T) => this.addButton(JSON.parse(T.replaceAll(\"'\", '\"')))));\n  }\n  snapshot(e, r) {\n    e.render(this.spLay, { clear: !1 }), z(this, he).snapshot(e, r);\n  }\n  snapshot_end() {\n    z(this, he).snapshot_end();\n  }\n  makeDesignCast(e) {\n    !this.spLay.visible || z(this, he).makeDesignCast(e);\n  }\n  makeDesignCastChildren(e) {\n    if (!!this.spLay.visible)\n      for (const r of z(this, qe).children)\n        r.makeDesignCast(e);\n  }\n  showDesignCast() {\n    z(this, he).showDesignCast();\n  }\n  showDesignCastChildren() {\n    for (const e of z(this, qe).children)\n      e.showDesignCast();\n  }\n  dump() {\n    return z(this, rl).call(this, \"\", \"gotxt｜\"), super.dump() + `, \"enabled\":\"${this.enabled}\", ${z(this, he).dump()}, \"b_pic\":\"${z(this, Vr)}\", \"b_color\":\"${z(this, vi)}\", \"b_alpha\":${z(this, vr)}, \"b_alpha_isfixed\":\"${z(this, Mr)}\", \"width\":${z(this, he).getWidth}, \"height\":${z(this, he).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Sprite ? \"Sprite\" : e instanceof Graphics ? \"Graphics\" : e instanceof Container ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${z(this, qe).children.map((e) => e.children[0].name ?? \"{}\").join(\",\")}]`;\n  }\n};\nlet TxtLayer = te;\nna = new WeakMap(), Rr = new WeakMap(), Yo = new WeakMap(), sa = new WeakMap(), Wo = new WeakSet(), uf = function(e) {\n  const r = TxtStage.ch_in_style(e), S = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, T = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: D } = e;\n  return addStyle(`\n.sn_ch_in_${D} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${D} {\n\topacity: ${r.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${D} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes sn_ch_in_${D} {\n\tfrom {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${S}, ${T});}\n\tto {opacity: 1; transform: none;}\n}\n`), !1;\n}, qo = new WeakSet(), hf = function(e) {\n  const r = TxtStage.ch_out_style(e), S = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, T = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: D } = e;\n  return addStyle(`\n.go_ch_out_${D} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${D} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes go_ch_out_${D} {\n\tto {\n\t\topacity: ${r.alpha};\n\t\ttransform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${S}, ${T});\n\t}\n`), !1;\n}, Ko = new WeakMap(), Mn = new WeakMap(), Zo = new WeakMap(), pi = new WeakMap(), On = new WeakMap(), lh = new WeakSet(), dd = function(e) {\n  ot(te, pi, argChk_Boolean(e, \"enabled\", z(te, pi))), z(te, Rr).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", z(te, pi));\n  const { text: r } = e;\n  if (\"text\" in e != \"time\" in e)\n    throw \"[autowc] textとtimeは同時指定必須です\";\n  if (z(te, Rr).setVal_Nochk(\"save\", \"const.sn.autowc.text\", r), !r)\n    return z(te, Rr).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\"), !1;\n  const S = r.length;\n  if (z(te, pi) && S === 0)\n    throw '[autowc] enabled === false かつ text === \"\" は許されません';\n  const T = String(e.time).split(\",\");\n  if (T.length !== S)\n    throw \"[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい\";\n  return ot(te, On, {}), T.forEach((D, N) => z(te, On)[r[N]] = uint(D)), z(te, Rr).setVal_Nochk(\"save\", \"const.sn.autowc.time\", e.time), !1;\n}, vi = new WeakMap(), vr = new WeakMap(), Mr = new WeakMap(), ve = new WeakMap(), Vr = new WeakMap(), he = new WeakMap(), Jo = new WeakMap(), Xr = new WeakMap(), uh = new WeakMap(), qe = new WeakMap(), In = new WeakSet(), za = function(e) {\n  const { in_style: r } = e;\n  if (!r)\n    return;\n  const S = TxtStage.getChInStyle(r);\n  if (!S)\n    throw `存在しないin_style【${r}】です`;\n  ot(this, Dn, r), ot(this, aa, S.join);\n}, Dn = new WeakMap(), aa = new WeakMap(), An = new WeakSet(), Ha = function(e) {\n  const { out_style: r } = e;\n  if (!r)\n    return;\n  if (!TxtStage.getChOutStyle(r))\n    throw `存在しないout_style【${r}】です`;\n  ot(this, oa, r);\n}, oa = new WeakMap(), Qo = new WeakSet(), cf = function(e, r) {\n  if (\"back_clear\" in e)\n    return argChk_Boolean(e, \"back_clear\", !1) && (ot(this, vi, 0), ot(this, vr, 0), ot(this, Mr, !1), ot(this, Vr, \"\")), r(!1), !1;\n  ot(this, vr, argChk_Num(e, \"b_alpha\", z(this, vr))), ot(this, Mr, argChk_Boolean(e, \"b_alpha_isfixed\", z(this, Mr)));\n  const S = (z(this, Mr) ? 1 : Number(z(te, Rr).getVal(\"sys:TextLayer.Back.Alpha\"))) * z(this, vr);\n  if (e.b_pic) {\n    if (z(this, Vr) !== e.b_pic)\n      return ot(this, Vr, e.b_pic), z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), GrpLayer.csv2Sprites(z(this, Vr), this.spLay, (T) => {\n        ot(this, ve, T), T.name = \"back(pic)\", T.visible = S > 0, T.alpha = S, z(this, he).setSize(T.width, T.height), this.spLay.setChildIndex(T, 0), r(!0);\n      });\n  } else\n    \"b_color\" in e && (ot(this, vi, argChk_Color(e, \"b_color\", 0)), z(this, ve) && (this.spLay.removeChild(z(this, ve)), z(this, ve).destroy()), ot(this, Vr, \"\"), this.spLay.addChildAt(\n      ot(this, ve, new Graphics()).beginFill(z(this, vi)).lineStyle(void 0).drawRect(0, 0, z(this, he).getWidth, z(this, he).getHeight).endFill(),\n      0\n    ), z(this, ve).name = \"back(color)\");\n  return z(this, ve) && (z(this, ve).visible = S > 0, z(this, ve).alpha = S), r(!1), !1;\n}, tl = new WeakSet(), ff = function(e) {\n  \"noffs\" in e && (ot(this, la, e.noffs ?? \"\"), ot(this, el, new RegExp(`[　${z(this, la)}]`))), \"ffs\" in e && (z(this, Nn) ?? ot(this, Nn, \"\"), ot(this, Ln, z(this, Nn) === \"\" ? () => \"\" : (r) => z(this, el).test(r) ? \"\" : ` font-feature-settings: ${z(this, Nn)};`));\n}, Nn = new WeakMap(), Ln = new WeakMap(), la = new WeakMap(), el = new WeakMap(), ua = new WeakMap(), zi = new WeakMap(), Ke = new WeakMap(), hh = new WeakSet(), pd = function(e, r, S, T = \"\") {\n  if (!S)\n    return ` style='${T}'`;\n  const D = e.length * 2;\n  if (D - r.length < 0)\n    return ` style='text-align: ${S}; ${T}'`;\n  let N = \"\";\n  switch (S) {\n    case \"left\":\n      N = \"ruby-align: start;\";\n      break;\n    case \"center\":\n      N = \"ruby-align: center;\";\n      break;\n    case \"right\":\n      N = \"ruby-align: start;\";\n      break;\n    case \"justify\":\n      N = \"ruby-align: space-between;\";\n      break;\n    case \"121\":\n      N = \"ruby-align: space-around;\";\n      break;\n    case \"even\":\n      const B = (D - r.length) / (r.length + 1);\n      N = \"ruby-align: space-between; \" + (z(this, he).tategaki ? `padding-top: ${B}em; padding-bottom: ${B}em;` : `padding-left: ${B}em; padding-right: ${B}em;`);\n      break;\n    case \"1ruby\":\n      N = \"ruby-align: space-between; \" + (z(this, he).tategaki ? \"padding-top: 1em; padding-bottom: 1em;\" : \"padding-left: 1em; padding-right: 1em;\");\n      break;\n    default:\n      N = `text-align: ${S};`;\n  }\n  return ` style='${N} ${T}'`;\n}, lr = new WeakMap(), rl = new WeakMap(), ha = new WeakSet(), fu = function(e, r, S) {\n  var $;\n  const T = e === \" \" ? \"&nbsp;\" : e;\n  z(te, Rr).doRecLog() && ot(this, kn, z(this, kn) + (T + (r ? `《${r}》` : \"\")));\n  const { cl: D, sty: N, lnk: B } = lt(this, gi, rn).call(this, !0, null, e);\n  return r ? `<span${D} style='${N} ${z(this, Ln).call(this, e)}'><ruby>${Array.from(e).map((U, V) => `<span${D}${B} style='${V > 0 ? lt(this, gi, rn).call(this, !0, null, e).sty : N} display: inline;'>${U === \" \" ? \"&nbsp;\" : U}</span>`).join(\"\")}<rt${B}${this.mkStyle_r_align(\n    e,\n    r,\n    S,\n    z(this, Xr).style.cssText + ((($ = z(this, mr).at(-1)) == null ? void 0 : $.o.r_style) ?? \"\")\n  )}>${r}</rt></ruby></span>` : `<span${D} style='${N} ${z(this, Ln).call(this, e)}'${B}>${T}</span>`;\n}, gi = new WeakSet(), rn = function(e, r, S = `\n`) {\n  var N, B, $;\n  const T = z(this, aa) ? r ?? ((N = z(this, mr).at(0)) == null ? void 0 : N.o.wait) ?? (z(te, pi) ? z(te, On)[S.at(0) ?? \"\"] ?? 0 : LayerMng.msecChWait) : 0;\n  z(te, Mn).isSkippingByKeyDown() ? ot(this, Yr, 0) : e && z(this, aa) && ot(this, Yr, z(this, Yr) + Number(T));\n  const D = `data-add='{\"ch_in_style\":\"${z(this, Dn)}\", \"ch_out_style\":\"${z(this, oa)}\"}'`;\n  return {\n    cl: ` class='sn_ch${T > 0 ? ` sn_ch_in_${z(this, Dn)}` : \"\"}'`,\n    sty: `animation-delay: ${z(this, Yr)}ms;${((B = z(this, mr).at(-1)) == null ? void 0 : B.o.style) ?? \"\"}`,\n    lnk: ((($ = z(this, mr).at(0)) == null ? void 0 : $.o[\":link\"]) ?? \"\") + \" \" + D,\n    curpos: D\n  };\n}, Yr = new WeakMap(), Or = new WeakMap(), gr = new WeakMap(), mr = new WeakMap(), il = new WeakSet(), df = function(e) {\n  z(this, mr).push({\n    o: e,\n    r_align: z(this, Ke),\n    ch_in_style: z(this, Dn),\n    ch_out_style: z(this, oa)\n  }), \"r_align\" in e && ot(this, Ke, e.r_align), lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e);\n}, ca = new WeakSet(), du = function() {\n  const e = z(this, mr).pop();\n  !e || (ot(this, Ke, e.r_align), lt(this, In, za).call(this, { in_style: e.ch_in_style }), lt(this, An, Ha).call(this, { out_style: e.ch_out_style }));\n}, nl = new WeakSet(), pf = function(e) {\n  const r = z(this, mr).at(-1);\n  if (!r) {\n    lt(this, il, df).call(this, e);\n    return;\n  }\n  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = \"\", r.o.r_style = \"\"), \"r_align\" in e && ot(this, Ke, e.r_align), lt(this, In, za).call(this, e), lt(this, An, Ha).call(this, e);\n}, kn = new WeakMap(), tt(TxtLayer, Wo), tt(TxtLayer, qo), tt(TxtLayer, lh), tt(TxtLayer, na, void 0), tt(TxtLayer, Rr, void 0), tt(TxtLayer, Yo, void 0), tt(TxtLayer, sa, void 0), tt(TxtLayer, Ko, void 0), tt(TxtLayer, Mn, void 0), tt(TxtLayer, Zo, void 0), tt(TxtLayer, pi, !1), tt(TxtLayer, On, {}), tt(TxtLayer, uh, {\n  \"text-align\": 0,\n  \"text-align-last\": 0,\n  height: 0,\n  width: 0,\n  \"padding-left\": 0,\n  \"padding-right\": 0,\n  \"padding-top\": 0,\n  \"padding-bottom\": 0\n}), tt(TxtLayer, ua, (e) => e);\nvar fa, Bn, ch, vd, da, pa, pu, fh, gd, dh, md, sl, ph, _d, vh, yd;\nclass FrameMng {\n  constructor(t, e, r, S, T, D, N) {\n    tt(this, ch);\n    tt(this, pa);\n    tt(this, fh);\n    tt(this, dh);\n    tt(this, ph);\n    tt(this, vh);\n    tt(this, fa, void 0);\n    tt(this, Bn, /* @__PURE__ */ Object.create(null));\n    tt(this, da, {});\n    tt(this, sl, 1);\n    this.cfg = t, this.appPixi = r, this.val = S, this.main = T, this.sys = D, this.hTwInf = N, e.add_frame = (B) => lt(this, ch, vd).call(this, B), e.let_frame = (B) => lt(this, fh, gd).call(this, B), e.set_frame = (B) => lt(this, dh, md).call(this, B), e.frame = (B) => lt(this, ph, _d).call(this, B), e.tsy_frame = (B) => lt(this, vh, yd).call(this, B);\n  }\n  setEvtMng(t) {\n    ot(this, fa, t);\n  }\n  destroy() {\n    for (const t of Object.values(z(this, Bn)))\n      t.parentElement.removeChild(t);\n    ot(this, Bn, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(t) {\n    return z(this, da)[t];\n  }\n  cvsResize() {\n    for (const [t, e] of Object.entries(z(this, Bn))) {\n      const r = \"const.sn.frm.\" + t, S = Number(this.val.getVal(r + \".x\")), T = Number(this.val.getVal(r + \".y\")), D = Number(this.val.getVal(r + \".width\")), N = Number(this.val.getVal(r + \".height\"));\n      e.style.left = `${this.sys.ofsLeft4elm + S * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + T * this.sys.cvsScale}px`, e.width = String(D * this.sys.cvsScale), e.height = String(N * this.sys.cvsScale);\n    }\n  }\n}\nfa = new WeakMap(), Bn = new WeakMap(), ch = new WeakSet(), vd = function(t) {\n  const { id: e, src: r, alpha: S = 1, scale_x: T = 1, scale_y: D = 1, rotate: N = 0 } = t;\n  if (!e)\n    throw \"idは必須です\";\n  if (!r)\n    throw \"srcは必須です\";\n  const B = \"const.sn.frm.\" + e;\n  if (this.val.getVal(`tmp:${B}`))\n    throw `frame【${e}】はすでにあります`;\n  const $ = argChk_Boolean(t, \"visible\", !0), U = t.b_color ? ` background-color: ${t.b_color};` : \"\", V = lt(this, pa, pu).call(this, t);\n  Main.cvs.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${e}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${S}; position: absolute; left:${this.sys.ofsLeft4elm + V.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + V.y * this.sys.cvsScale}px; z-index: 1; ${U} border: 0px; overflow: hidden; display: ${$ ? \"inline\" : \"none\"}; transform: scale(${T}, ${D}) rotate(${N}deg);\" width=\"${V.width * this.sys.cvsScale}\" height=\"${V.height * this.sys.cvsScale}\"></iframe>`);\n  const H = this.cfg.searchPath(r, SEARCH_PATH_ARG_EXT.HTML), X = new Loader().add({ name: r, url: H, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });\n  return this.sys.crypto && X.use((Y, W) => {\n    try {\n      Y.data = this.sys.decStr(Y.extension, Y.data);\n    } catch (q) {\n      this.main.errScript(`[add_frame]Html ロード失敗です src:${Y.name} ${q}`, !1);\n    }\n    W == null || W();\n  }), X.load((Y, W) => {\n    var K;\n    const q = document.getElementById(e);\n    z(this, Bn)[e] = q, z(this, da)[e] = !1, q.srcdoc = String((K = W[r]) == null ? void 0 : K.data).replace(\"sn_repRes();\", \"\").replaceAll(\n      /\\s(?:src|href)=([\"'])(\\S+)\\1/g,\n      (Z, J, Q) => Q.slice(0, 3) === \"../\" ? this.sys.cur + Q.slice(4) : Z.replace(J, J + H.slice(0, H.lastIndexOf(\"/\") + 1))\n    ), q.onload = () => {\n      var J;\n      this.val.setVal_Nochk(\"tmp\", B, !0), this.val.setVal_Nochk(\"tmp\", B + \".alpha\", S), this.val.setVal_Nochk(\"tmp\", B + \".x\", V.x), this.val.setVal_Nochk(\"tmp\", B + \".y\", V.y), this.val.setVal_Nochk(\"tmp\", B + \".scale_x\", T), this.val.setVal_Nochk(\"tmp\", B + \".scale_y\", D), this.val.setVal_Nochk(\"tmp\", B + \".rotate\", N), this.val.setVal_Nochk(\"tmp\", B + \".width\", V.width), this.val.setVal_Nochk(\"tmp\", B + \".height\", V.height), this.val.setVal_Nochk(\"tmp\", B + \".visible\", $);\n      const Z = q.contentWindow;\n      z(this, fa).resvFlameEvent(Z), (J = Z.sn_repRes) == null || J.call(Z, (Q) => GrpLayer.loadPic2Img(Q.dataset.src ?? \"\", Q)), this.main.resume();\n    };\n  }), !0;\n}, da = new WeakMap(), pa = new WeakSet(), pu = function(t) {\n  const e = { ...t }, r = this.sys.resolution;\n  return new DOMRect(\n    argChk_Num(e, \"x\", 0) * r,\n    argChk_Num(e, \"y\", 0) * r,\n    argChk_Num(e, \"width\", CmnLib.stageW) * r,\n    argChk_Num(e, \"height\", CmnLib.stageH) * r\n  );\n}, fh = new WeakSet(), gd = function(t) {\n  const { id: e, var_name: r } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const S = document.getElementById(e);\n  if (!S)\n    throw `id【${e}】はフレームではありません`;\n  const T = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${T}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  const D = S.contentWindow;\n  if (!D.hasOwnProperty(r))\n    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;\n  const N = D[r];\n  return this.val.setVal_Nochk(\n    \"tmp\",\n    T + \".\" + r,\n    argChk_Boolean(t, \"function\", !1) ? N() : N\n  ), !1;\n}, dh = new WeakSet(), md = function(t) {\n  const { id: e, var_name: r, text: S } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const T = document.getElementById(e);\n  if (!T)\n    throw `id【${e}】はフレームではありません`;\n  const D = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${D}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  if (!S)\n    throw \"textは必須です\";\n  this.val.setVal_Nochk(\"tmp\", D + \".\" + r, S);\n  const N = T.contentWindow;\n  return N[r] = S, !1;\n}, sl = new WeakMap(), ph = new WeakSet(), _d = function(t) {\n  const { id: e } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const r = document.getElementById(e);\n  if (!r)\n    throw `id【${e}】はフレームではありません`;\n  const S = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(\"tmp:\" + S))\n    throw `frame【${e}】が読み込まれていません`;\n  const T = r.style;\n  if (argChk_Boolean(t, \"float\", !1) ? T.zIndex = `${++Me(this, sl)._}` : \"index\" in t ? T.zIndex = `${argChk_Num(t, \"index\", 0)}` : t.dive && (T.zIndex = `-${++Me(this, sl)._}`), \"alpha\" in t) {\n    const N = T.opacity = String(t.alpha);\n    this.val.setVal_Nochk(\"tmp\", S + \".alpha\", N);\n  }\n  const D = lt(this, pa, pu).call(this, t);\n  if ((\"x\" in t || \"y\" in t) && (T.left = `${this.sys.ofsLeft4elm + D.x * this.sys.cvsScale}px`, T.top = `${this.sys.ofsTop4elm + D.y * this.sys.cvsScale}px`, this.val.setVal_Nochk(\"tmp\", S + \".x\", D.x), this.val.setVal_Nochk(\"tmp\", S + \".y\", D.y)), \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) {\n    const N = argChk_Num(t, \"scale_x\", 1), B = argChk_Num(t, \"scale_y\", 1), $ = argChk_Num(t, \"rotate\", 0);\n    T.transform = `scale(${N}, ${B}) rotate(${$}deg)`, this.val.setVal_Nochk(\"tmp\", S + \".scale_x\", N), this.val.setVal_Nochk(\"tmp\", S + \".scale_y\", B), this.val.setVal_Nochk(\"tmp\", S + \".rotate\", $);\n  }\n  if (\"width\" in t && (r.width = String(D.width * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", S + \".width\", D.width)), \"height\" in t && (r.height = String(D.height * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", S + \".height\", D.height)), \"visible\" in t) {\n    const N = argChk_Boolean(t, \"visible\", !0);\n    T.display = N ? \"inline\" : \"none\", this.val.setVal_Nochk(\"tmp\", S + \".visible\", N);\n  }\n  if (\"b_color\" in t && (T.backgroundColor = t.b_color), \"disabled\" in t) {\n    const N = z(this, da)[e] = argChk_Boolean(t, \"disabled\", !0);\n    r.contentDocument.body.querySelectorAll(\"input,select\").forEach(($) => $.disabled = N);\n  }\n  return !1;\n}, vh = new WeakSet(), yd = function(t) {\n  const { id: e, alpha: r, x: S, y: T, scale_x: D, scale_y: N, rotate: B, width: $, height: U, ease: V, path: H, chain: X } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const Y = document.getElementById(e);\n  if (!Y)\n    throw `id【${e}】はフレームではありません`;\n  const W = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${W}`, 0))\n    throw `frame【${e}】が読み込まれていません`;\n  const q = {};\n  r && (q.a = Y.style.opacity), (S || T || D || N || B) && (q.x = Number(this.val.getVal(`tmp:${W}.x`)), q.y = Number(this.val.getVal(`tmp:${W}.y`)), q.sx = Number(this.val.getVal(`tmp:${W}.scale_x`)), q.sy = Number(this.val.getVal(`tmp:${W}.scale_y`)), q.r = Number(this.val.getVal(`tmp:${W}.rotate`))), $ && (q.w = this.val.getVal(`tmp:${W}.width`)), U && (q.h = this.val.getVal(`tmp:${W}.height`));\n  const K = cnvTweenArg(t, q), Z = {};\n  let J = () => {\n  };\n  r && (Z.a = argChk_Num(K, \"alpha\", 0), J = () => {\n    Y.style.opacity = q.a, this.val.setVal_Nochk(\"tmp\", \"alpha\", q.a);\n  });\n  let Q = () => {\n  };\n  const rt = lt(this, pa, pu).call(this, K);\n  (S || T || D || N || B) && (Z.x = rt.x, Z.y = rt.y, Z.sx = argChk_Num(K, \"scale_x\", 1), Z.sy = argChk_Num(K, \"scale_y\", 1), Z.r = argChk_Num(K, \"rotate\", 0), Q = () => {\n    Y.style.left = this.sys.ofsLeft4elm + q.x * this.sys.cvsScale + \"px\", Y.style.top = this.sys.ofsTop4elm + q.y * this.sys.cvsScale + \"px\", Y.style.transform = `scale(${q.sx}, ${q.sy}) rotate(${q.r}deg)`, this.val.setVal_Nochk(\"tmp\", W + \".x\", q.x), this.val.setVal_Nochk(\"tmp\", W + \".y\", q.y), this.val.setVal_Nochk(\"tmp\", W + \".scale_x\", q.sx), this.val.setVal_Nochk(\"tmp\", W + \".scale_y\", q.sy), this.val.setVal_Nochk(\"tmp\", W + \".rotate\", q.r);\n  });\n  let et = () => {\n  };\n  $ && (Z.w = rt.width, et = () => {\n    Y.width = q.w * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", W + \".width\", q.w);\n  });\n  let nt = () => {\n  };\n  U && (Z.h = rt.height, nt = () => {\n    Y.height = q.h * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", W + \".height\", q.h);\n  }), this.appPixi.stage.interactive = !1;\n  const st = `frm\n${e}`, it = () => {\n    var St, pt;\n    this.appPixi.stage.interactive = !0;\n    const Ct = this.hTwInf[st];\n    !Ct || (delete this.hTwInf[st], (St = Ct.tw) == null || St.stop(), Ct.resume && this.main.resume(), (pt = Ct.onEnd) == null || pt.call(Ct));\n  }, at = argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || z(this, fa).isSkippingByKeyDown()) ? 0 : 1), ut = CmnTween.ease(V), ct = argChk_Num(t, \"repeat\", 1), gt = ct === 0 ? 1 / 0 : ct - 1, _t = argChk_Boolean(t, \"yoyo\", !1), vt = argChk_Num(t, \"delay\", 0), mt = new Tween(q).to(Z, at).easing(ut).repeat(gt).yoyo(_t).delay(vt).onUpdate(() => {\n    J(), Q(), et(), nt();\n  });\n  let bt = mt;\n  if (H) {\n    CmnLib.debugLog && console.group(`🍝 [tsy_frame] path=${H}= start(${q.x},${q.y},${q.alpha})`);\n    for (const { groups: Ct } of H.matchAll(LayerMng.REG_TSY_PATH)) {\n      const { x: St, x2: pt, y: yt, y2: At, o: Dt, o2: Ot, json: Pt } = Ct;\n      let ft = {};\n      if (Pt)\n        try {\n          ft = JSON.parse(Pt);\n        } catch (zt) {\n          console.error(`🍝 json=${Pt} ` + zt);\n          continue;\n        }\n      else\n        (St ?? pt) && (ft.x = St ?? pt), (yt ?? At) && (ft.y = yt ?? At), (Dt ?? Ot) && (ft.alpha = Dt ?? Ot);\n      const Ft = cnvTweenArg(ft, q);\n      CmnLib.debugLog && console.info(`🍝 {x:${St} y:${yt} o:${Dt}} => hTo:${JSON.stringify(Ft)}`);\n      const It = new Tween(q).to(Ft, at).easing(ut).repeat(gt).yoyo(_t);\n      bt.chain(It), bt = It;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (bt.onComplete(it), X) {\n    const Ct = this.hTwInf[X ?? \"\"];\n    if (!Ct || !Ct.tw)\n      throw `${X}は存在しない・または終了したトゥイーンです`;\n    delete Ct.onEnd, Ct.tw.chain(mt);\n  } else\n    mt.start();\n  return this.hTwInf[st] = { tw: bt, resume: !1 }, !1;\n};\nvar _r, le, Ee, Hi, Fn, va, al, ol, ll, ga, ul, vf, Vi, Ir, gh, bd, Ze, mh, xd, _h, Sd, yh, Ed, se, Wr, qr, hl, bh, Td, ma, vu, xh, wd, Sh, cl, Eh, $n, Gn, mi, Ie, Un, Th, Cd, De, Xe, rr, wh, Pd, Ch, Rd, Ph, Md, jn, Va, Rh, Od, ur, Mh, Id, Oh, Dd, Ih, Ad, Dh, Nd, Ah, Ld, Xi, zn, Xa, hr, Nh, kd, fl, Lh, Bd, Kr, Hn, Yi, xs, Dr, Zr, kh, Fd, Bh, $d, Fh, Gd, $h, Ud, Gh, jd, Uh, zd, jh, Hd, dl, gf, zh, Vd, Hh, Xd, Vh, Yd, Xh, Wd, Yh, qd, Wh, Kd, qh, Zd;\nconst Di = class {\n  constructor(t, e, r, S, T, D, N, B, $, U) {\n    tt(this, ul);\n    tt(this, gh);\n    tt(this, mh);\n    tt(this, _h);\n    tt(this, yh);\n    tt(this, bh);\n    tt(this, ma);\n    tt(this, xh);\n    tt(this, Th);\n    tt(this, Xe);\n    tt(this, wh);\n    tt(this, Ch);\n    tt(this, Ph);\n    tt(this, jn);\n    tt(this, Rh);\n    tt(this, Mh);\n    tt(this, Oh);\n    tt(this, Ih);\n    tt(this, Dh);\n    tt(this, Ah);\n    tt(this, zn);\n    tt(this, Nh);\n    tt(this, Lh);\n    tt(this, Yi);\n    tt(this, kh);\n    tt(this, Bh);\n    tt(this, Fh);\n    tt(this, $h);\n    tt(this, Gh);\n    tt(this, Uh);\n    tt(this, jh);\n    tt(this, dl);\n    tt(this, zh);\n    tt(this, Hh);\n    tt(this, Vh);\n    tt(this, Xh);\n    tt(this, Yh);\n    tt(this, Wh);\n    tt(this, qh);\n    tt(this, _r, void 0);\n    tt(this, le, new Container());\n    tt(this, Ee, new Container());\n    tt(this, Hi, void 0);\n    tt(this, Fn, void 0);\n    tt(this, va, new EventListenerCtn());\n    tt(this, al, () => update());\n    tt(this, ol, {\n      attach: (t) => (DesignCast.leaveMode(), !1),\n      continue: (t) => (DesignCast.leaveMode(), !1),\n      disconnect: (t) => (DesignCast.leaveMode(), !1),\n      _enterDesign: (t) => {\n        DesignCast.enterMode();\n        for (const e of z(this, Wr)) {\n          const r = z(this, se)[e].fore;\n          r.makeDesignCastChildren((S) => S.make()), r.makeDesignCast((S) => S.make());\n        }\n        return lt(this, ul, vf).call(this, z(this, qr)), !1;\n      },\n      _replaceToken: (t, e) => (DesignCast.replaceToken(e), !1),\n      _selectNode: (t, e) => (lt(this, ul, vf).call(this, e.node), !1)\n    });\n    tt(this, ll, \"\");\n    tt(this, ga, \"\");\n    Rt(this, \"getFrmDisabled\", (t) => z(this, Hi).getFrmDisabled(t));\n    tt(this, Vi, void 0);\n    tt(this, Ir, void 0);\n    tt(this, Ze, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh(\"｜　《\" + t + \"》\"));\n    Rt(this, \"goTxt\", () => {\n    });\n    Rt(this, \"breakLine\", () => {\n    });\n    Rt(this, \"breakPage\", () => {\n    });\n    tt(this, se, {});\n    tt(this, Wr, []);\n    tt(this, qr, \"\");\n    tt(this, hl, \"\");\n    tt(this, Sh, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`);\n    tt(this, cl, {\n      rule: Texture.EMPTY,\n      vague: 0,\n      tick: 0\n    });\n    tt(this, Eh, new Filter(void 0, z(this, Sh), z(this, cl)));\n    tt(this, $n, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    tt(this, Gn, new Sprite(z(this, $n)));\n    tt(this, mi, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    tt(this, Ie, new Sprite(z(this, mi)));\n    tt(this, Un, []);\n    tt(this, De, { tw: void 0, resume: !1 });\n    tt(this, ur, {});\n    tt(this, hr, (t) => {\n      throw z(this, Hn).call(this), 0;\n    });\n    tt(this, fl, (t) => {\n      throw z(this, Hn).call(this), 0;\n    });\n    tt(this, Kr, void 0);\n    tt(this, Hn, () => {\n      throw \"文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい\";\n    });\n    tt(this, Dr, \"\");\n    tt(this, Zr, []);\n    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = S, this.main = T, this.scrItr = D, this.sys = N, this.sndMng = B, this.alzTagArg = $, this.prpPrs = U;\n    const V = () => {\n      if (N.cvsResize(), this.cvsResizeDesign(), z(this, ga))\n        for (const W of z(this, Wr))\n          z(this, se)[W].fore.cvsResizeChildren();\n      else\n        for (const W of z(this, Wr))\n          z(this, se)[W].fore.cvsResize();\n      z(this, Hi).cvsResize(), z(this, Ir).cvsResize();\n    };\n    if (CmnLib.isMobile)\n      z(this, va).add(globalThis, \"orientationchange\", V, { passive: !0 });\n    else {\n      let W;\n      z(this, va).add(globalThis, \"resize\", () => {\n        W || (W = setTimeout(() => {\n          W = void 0, V();\n        }, 1e3 / 60 * 10));\n      }, { passive: !0 });\n    }\n    N.cvsResize(), TxtLayer.init(t, e, S, this, (W) => z(this, se)[W.layname].fore === W, r), GrpLayer.init(T, t, r, N, B, S), Button.init(t), ot(this, Hi, new FrameMng(t, e, r, S, T, N, z(this, ur))), N.hFactoryCls.grp = () => new GrpLayer(), N.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (W) => lt(this, _h, Sd).call(this, W), e.snapshot = (W) => lt(this, mh, xd).call(this, W), e.add_lay = (W) => lt(this, yh, Ed).call(this, W), e.clear_lay = (W) => lt(this, xh, wd).call(this, W), e.finish_trans = () => lt(this, jn, Va).call(this), e.lay = (W) => lt(this, bh, Td).call(this, W), e.trans = (W) => lt(this, Th, Cd).call(this, W), e.wt = (W) => lt(this, Ph, Md).call(this, W), e.quake = (W) => lt(this, Rh, Od).call(this, W), e.stop_quake = (W) => e.finish_trans(W), e.wq = (W) => e.wt(W), e.pause_tsy = (W) => lt(this, Dh, Nd).call(this, W), e.resume_tsy = (W) => lt(this, Ah, Ld).call(this, W), e.stop_tsy = (W) => lt(this, Ih, Ad).call(this, W), e.tsy = (W) => lt(this, Mh, Id).call(this, W), e.wait_tsy = (W) => lt(this, Oh, Dd).call(this, W), e.ch = (W) => lt(this, zn, Xa).call(this, W), e.clear_text = (W) => lt(this, kh, Fd).call(this, W), e.current = (W) => z(this, fl).call(this, W), e.endlink = (W) => lt(this, Bh, $d).call(this, W), e.er = (W) => lt(this, Fh, Gd).call(this, W), e.graph = (W) => lt(this, $h, Ud).call(this, W), e.link = (W) => lt(this, Gh, jd).call(this, W), e.r = (W) => lt(this, Uh, zd).call(this, W), e.rec_ch = (W) => lt(this, dl, gf).call(this, W), e.rec_r = (W) => lt(this, jh, Hd).call(this, W), e.reset_rec = (W) => lt(this, zh, Vd).call(this, W), e.ruby2 = (W) => lt(this, Hh, Xd).call(this, W), e.span = (W) => lt(this, Vh, Yd).call(this, W), e.tcy = (W) => lt(this, Xh, Wd).call(this, W), e.add_face = (W) => GrpLayer.add_face(W), e.wv = (W) => GrpLayer.wv(W), e.dump_lay = (W) => lt(this, Yh, qd).call(this, W), e.enable_event = (W) => lt(this, Wh, Kd).call(this, W), e.button = (W) => lt(this, qh, Zd).call(this, W), t.existsBreakline && (this.breakLine = () => z(this, Ze).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakline\"}')), t.existsBreakpage && (this.breakPage = () => z(this, Ze).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakpage\"}')), ot(this, Fn, parseColor(String(t.oCfg.init.bg_color)));\n    const H = new Graphics();\n    H.beginFill(z(this, Fn), 1).lineStyle(0, z(this, Fn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), z(this, le).addChild(H.clone()), z(this, Ee).addChild(H), z(this, Ee).visible = !1, z(this, le).name = \"page:A\", z(this, Ee).name = \"page:B\", ot(this, _r, r.stage), z(this, _r).addChild(z(this, Ee)), z(this, _r).addChild(z(this, le)), z(this, _r).addChild(z(this, Gn)), z(this, _r).addChild(z(this, Ie)), z(this, _r).name = \"stage\", r.ticker.add(z(this, al));\n    const X = (W, q) => {\n      lt(this, gh, bd).call(this, Number(q));\n    };\n    X(\"\", S.getVal(\"sys:TextLayer.Back.Alpha\", 1)), S.defValTrg(\"sys:TextLayer.Back.Alpha\", X);\n    const Y = (W, q) => Button.fontFamily = q;\n    Y(\"\", S.getVal(\"tmp:sn.button.fontFamily\", Button.fontFamily)), S.defValTrg(\"tmp:sn.button.fontFamily\", Y), S.defTmp(\"const.sn.log.json\", () => JSON.stringify(\n      z(this, Dr) ? [...z(this, Zr), { text: z(this, Dr).replaceAll(\"</span><span class='sn_ch'>\", \"\") }] : z(this, Zr)\n    )), S.defTmp(\"const.sn.last_page_text\", () => {\n      var W;\n      return ((W = this.currentTxtlayFore) == null ? void 0 : W.pageText) ?? \"\";\n    }), CmnLib.isDbg && (DesignCast.init(r, N, D, U, $, t, z(this, se)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), N.addHook((W, q) => {\n      var K, Z;\n      !((Z = (K = z(this, ol))[W]) != null && Z.call(K, W, q)) || delete z(this, ol)[W];\n    }));\n  }\n  cvsResizeDesign() {\n  }\n  cover(t, e = 0) {\n    z(this, Vi) && (z(this, _r).removeChild(z(this, Vi)), z(this, Vi).destroy(), ot(this, Vi, void 0)), t && z(this, _r).addChild(\n      ot(this, Vi, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()\n    );\n  }\n  setEvtMng(t) {\n    ot(this, Ir, t), z(this, Hi).setEvtMng(t), GrpLayer.setEvtMng(t);\n  }\n  before_destroy() {\n    for (const t of Object.values(z(this, se)))\n      t.destroy();\n  }\n  destroy() {\n    z(this, va).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), z(this, Hi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(z(this, al)), ot(Di, Xi, 10);\n  }\n  stopAllTw() {\n    ot(this, ur, {}), removeAll();\n  }\n  clearBreak() {\n    !this.currentTxtlayFore || (this.clearBreak = () => z(this, Ze).call(this, \"del｜break\"), this.clearBreak());\n  }\n  clickTxtLay() {\n    return this.currentTxtlayFore ? lt(this, Xe, rr).call(this).some((t) => {\n      const e = z(this, se)[t].fore;\n      return e instanceof TxtLayer && e.click();\n    }) : !1;\n  }\n  static get msecChWait() {\n    return z(Di, Xi);\n  }\n  static set msecChWait(t) {\n    ot(Di, Xi, t);\n  }\n  setNormalChWait() {\n    ot(Di, Xi, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    return z(this, Hn).call(this), this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    return z(this, Kr) ? z(this, Kr).fore : null;\n  }\n  recText(t) {\n    ot(this, Dr, t), this.val.setVal_Nochk(\n      \"save\",\n      \"const.sn.sLog\",\n      String(this.val.getVal(\"const.sn.log.json\"))\n    );\n  }\n  recPagebreak() {\n    if (!z(this, Dr))\n      return;\n    const t = z(this, Dr).replaceAll(\"</span><span class='sn_ch'>\", \"\");\n    z(this, Zr).push({ text: t }) > this.cfg.oCfg.log.max_len && ot(this, Zr, z(this, Zr).slice(-this.cfg.oCfg.log.max_len)), ot(this, Dr, \"\");\n  }\n  record() {\n    const t = {};\n    for (const e of z(this, Wr)) {\n      const r = z(this, se)[e];\n      t[e] = {\n        cls: r.cls,\n        fore: r.fore.record(),\n        back: r.back.record()\n      };\n    }\n    return t;\n  }\n  playback(t, e) {\n    var D;\n    ot(this, Zr, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\")))), ot(this, Dr, \"\");\n    const r = [], S = [];\n    for (const [N, { fore: B, fore: { idx: $ }, back: U, cls: V }] of Object.entries(t)) {\n      S.push({ layer: N, idx: $ });\n      const H = (D = z(this, se))[N] ?? (D[N] = new Pages(N, V, z(this, le), z(this, Ee), {}, this.sys, this.val, { isWait: !1 }));\n      H.fore.playback(B, r), H.back.playback(U, r);\n    }\n    const T = z(this, le).children.length;\n    Promise.allSettled(r).then(() => {\n      for (const { layer: N, idx: B } of S.sort(({ idx: $ }, { idx: U }) => $ === U ? 0 : $ < U ? -1 : 1)) {\n        const { fore: $, back: U } = z(this, se)[N];\n        if (!$)\n          return;\n        const V = T > B ? B : T - 1;\n        z(this, le).setChildIndex($.spLay, V), z(this, Ee).setChildIndex(U.spLay, V);\n      }\n      e();\n    }).catch((N) => console.error(\"fn:LayerMng.ts playback e:%o\", N));\n  }\n};\nlet LayerMng = Di;\n_r = new WeakMap(), le = new WeakMap(), Ee = new WeakMap(), Hi = new WeakMap(), Fn = new WeakMap(), va = new WeakMap(), al = new WeakMap(), ol = new WeakMap(), ll = new WeakMap(), ga = new WeakMap(), ul = new WeakSet(), vf = function(t) {\n  [Me(this, ll)._, this.ga = \"\"] = t.split(\"/\");\n  const e = z(this, se)[z(this, ll)];\n  !e || (DesignCast.allHide(), z(this, ga) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());\n}, Vi = new WeakMap(), Ir = new WeakMap(), gh = new WeakSet(), bd = function(t) {\n  for (const e of lt(this, Xe, rr).call(this)) {\n    const r = z(this, se)[e];\n    r.fore instanceof TxtLayer && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));\n  }\n}, Ze = new WeakMap(), mh = new WeakSet(), xd = function(t) {\n  const e = t.fn ? t.fn.slice(0, 10) === \"userdata:/\" ? t.fn : `downloads:/${t.fn + getDateStr(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${getDateStr(\"-\", \"_\", \"\", \"_\")}.png`, r = this.cfg.searchPath(e);\n  if (this.sys.canCapturePage(r))\n    return !1;\n  const S = getExt(r), T = argChk_Color(t, \"b_color\", z(this, Fn)), D = autoDetectRenderer({\n    width: argChk_Num(t, \"width\", CmnLib.stageW),\n    height: argChk_Num(t, \"height\", CmnLib.stageH),\n    backgroundAlpha: T > 16777216 && S === \"png\" ? 0 : 1,\n    antialias: argChk_Boolean(t, \"smoothing\", !1),\n    preserveDrawingBuffer: !0,\n    backgroundColor: T & 16777215,\n    autoDensity: !0\n  }), N = [], B = t.page !== \"back\" ? \"fore\" : \"back\";\n  if (z(this, De).tw)\n    N.push(new Promise(($) => {\n      z(this, Ee).visible = !0;\n      for (const U of z(this, Un))\n        D.render(U, { clear: !1 });\n      z(this, Ee).visible = !1, z(this, Gn).visible = !0, z(this, le).filters = z(this, Ie).filters, z(this, le).visible = !0, D.render(z(this, le), { clear: !1 }), z(this, le).visible = !1, z(this, le).filters = [], $();\n    }));\n  else\n    for (const $ of lt(this, Xe, rr).call(this, t.layer))\n      N.push(\n        new Promise((U) => z(this, se)[$][B].snapshot(D, () => U()))\n      );\n  return Promise.allSettled(N).then(async () => {\n    const $ = RenderTexture.create({ width: D.width, height: D.height, transform: !0 });\n    if (D.render(z(this, _r), { renderTexture: $ }), await this.sys.savePic(\n      r,\n      D.plugins.extract.base64(Sprite.from($))\n    ), !z(this, De).tw)\n      for (const U of lt(this, Xe, rr).call(this, t.layer))\n        z(this, se)[U][B].snapshot_end();\n    D.destroy(!0);\n  }), !1;\n}, _h = new WeakSet(), Sd = function(t) {\n  const { fn: e } = t;\n  if (!e)\n    throw \"fnは必須です\";\n  const r = argChk_Boolean(t, \"join\", !0);\n  switch (getExt(e)) {\n    case \"css\":\n      (async () => {\n        const S = await fetch(e);\n        if (!S.ok)\n          throw new Error(\"Network response was not ok.\");\n        addStyle(await S.text()), r && this.main.resume();\n      })();\n      break;\n    default:\n      throw \"サポートされない拡張子です\";\n  }\n  return r;\n}, yh = new WeakSet(), Ed = function(t) {\n  const { layer: e, class: r } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  if (e.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (e in z(this, se))\n    throw `layer【${e}】はすでにあります`;\n  if (!r)\n    throw \"clsは必須です\";\n  const S = { isWait: !1 };\n  switch (z(this, se)[e] = new Pages(e, r, z(this, le), z(this, Ee), t, this.sys, this.val, S), z(this, Wr).push(e), r) {\n    case \"txt\":\n      z(this, qr) || (ot(this, Hn, () => {\n      }), ot(this, hr, lt(this, Nh, kd)), ot(this, fl, lt(this, Lh, Bd)), this.hTag.current({ layer: e }), this.goTxt = () => {\n        this.val.getVal(\"sn.skip.enabled\") ? ot(Di, Xi, 0) : this.setNormalChWait();\n        for (const T of lt(this, Xe, rr).call(this)) {\n          const D = z(this, se)[T].fore;\n          D instanceof TxtLayer && z(this, Ze).call(this, \"gotxt｜\", D, !1);\n        }\n      }), this.val.setVal_Nochk(\n        \"save\",\n        \"const.sn.layer.\" + (e ?? z(this, qr)) + \".enabled\",\n        !0\n      );\n      break;\n    case \"grp\":\n      if (z(this, hl))\n        break;\n      ot(this, hl, e);\n      break;\n  }\n  return this.scrItr.recodeDesign(t), S.isWait;\n}, se = new WeakMap(), Wr = new WeakMap(), qr = new WeakMap(), hl = new WeakMap(), bh = new WeakSet(), Td = function(t) {\n  const e = lt(this, Yi, xs).call(this, t), r = z(this, se)[e], S = r.back.spLay, T = r.fore.spLay;\n  if (argChk_Boolean(t, \"float\", !1))\n    z(this, Ee).setChildIndex(S, z(this, Ee).children.length - 1), z(this, le).setChildIndex(T, z(this, le).children.length - 1), lt(this, ma, vu).call(this);\n  else if (t.index)\n    argChk_Num(t, \"index\", 0) && (z(this, Ee).setChildIndex(S, t.index), z(this, le).setChildIndex(T, t.index), lt(this, ma, vu).call(this));\n  else if (t.dive) {\n    const { dive: D } = t;\n    let N = 0;\n    if (e === D)\n      throw \"[lay] 属性 layerとdiveが同じ【\" + D + \"】です\";\n    const B = z(this, se)[D];\n    if (!B)\n      throw \"[lay] 属性 dive【\" + D + \"】が不正です。レイヤーがありません\";\n    const $ = B.back, U = B.fore, V = z(this, Ee).getChildIndex($.spLay), H = z(this, le).getChildIndex(U.spLay);\n    N = V < H ? V : H, N > z(this, Ee).getChildIndex(S) && --N, z(this, le).setChildIndex(T, N), z(this, Ee).setChildIndex(S, N), lt(this, ma, vu).call(this);\n  }\n  return t[\":id_tag\"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);\n}, ma = new WeakSet(), vu = function() {\n  ot(this, Wr, lt(this, Ch, Rd).call(this));\n}, xh = new WeakSet(), wd = function(t) {\n  return lt(this, wh, Pd).call(this, t, (e) => {\n    const r = z(this, se)[lt(this, Yi, xs).call(this, { layer: e })];\n    t.page === \"both\" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);\n  }), !1;\n}, Sh = new WeakMap(), cl = new WeakMap(), Eh = new WeakMap(), $n = new WeakMap(), Gn = new WeakMap(), mi = new WeakMap(), Ie = new WeakMap(), Un = new WeakMap(), Th = new WeakSet(), Cd = function(t) {\n  lt(this, jn, Va).call(this), z(this, Ir).hideHint();\n  const { layer: e } = t;\n  ot(this, Un, []);\n  const r = {}, S = [];\n  for (const q of lt(this, Xe, rr).call(this, e))\n    r[q] = !0, S.push(z(this, se)[q].fore);\n  const T = [];\n  for (const q of lt(this, Xe, rr).call(this)) {\n    const K = z(this, se)[q][r[q] ? \"back\" : \"fore\"];\n    z(this, Un).push(K.spLay), T.push(K);\n  }\n  z(this, $n).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(z(this, Ee), { renderTexture: z(this, $n) });\n  let D = () => {\n    z(this, Ee).visible = !0;\n    for (const q of z(this, Un))\n      this.appPixi.renderer.render(q, { renderTexture: z(this, $n), clear: !1 });\n    z(this, Ee).visible = !1;\n  };\n  if (!T.some((q) => q.containMovement)) {\n    let q = D;\n    D = () => {\n      D = () => {\n      }, q();\n    };\n  }\n  z(this, mi).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(z(this, le), { renderTexture: z(this, mi) });\n  let N = () => {\n    z(this, le).visible = !0, this.appPixi.renderer.render(z(this, le), { renderTexture: z(this, mi) }), z(this, le).visible = !1;\n  };\n  if (!S.some((q) => q.containMovement)) {\n    let q = N;\n    N = () => {\n      N = () => {\n      }, q();\n    };\n  }\n  const B = () => {\n    D(), z(this, Gn).visible = !0, N(), z(this, Ie).visible = !0;\n  };\n  z(this, Ie).alpha = 1;\n  const $ = () => {\n    var K;\n    this.appPixi.ticker && this.appPixi.ticker.remove(B), [Me(this, le)._, Me(this, Ee)._] = [z(this, Ee), z(this, le)];\n    const q = [];\n    for (const [Z, J] of Object.entries(z(this, se))) {\n      if (r[Z]) {\n        J.transPage(q);\n        continue;\n      }\n      const { fore: { spLay: Q }, back: { spLay: rt } } = J, et = z(this, le).getChildIndex(rt);\n      z(this, le).removeChild(rt), z(this, Ee).removeChild(Q), z(this, le).addChildAt(Q, et), z(this, Ee).addChildAt(rt, et);\n    }\n    Promise.allSettled(q), z(this, le).visible = !0, z(this, Ee).visible = !1, z(this, Gn).visible = !1, z(this, Ie).visible = !1, (K = z(this, De).tw) == null || K.stop(), z(this, De).resume && this.main.resume(), ot(this, De, { tw: void 0, resume: !1 });\n  };\n  ot(this, De, { tw: void 0, resume: !1 });\n  const U = argChk_Num(t, \"time\", 0);\n  if (U === 0 || z(this, Ir).isSkippingByKeyDown())\n    return $(), !1;\n  const { ease: V, glsl: H, rule: X } = t, Y = CmnTween.ease(V);\n  if (!H && !X)\n    return z(this, Ie).filters = [], z(this, De).tw = new Tween(z(this, Ie)).to({ alpha: 0 }, U).delay(argChk_Num(t, \"delay\", 0)).easing(Y).onComplete($).start(), this.appPixi.ticker.add(B), !1;\n  const W = H ? new Filter(void 0, H, z(this, cl)) : z(this, Eh);\n  if (W.uniforms.vague = argChk_Num(t, \"vague\", 0.04), W.uniforms.tick = 0, z(this, De).tw = new Tween(W.uniforms).to({ tick: 1 }, U).delay(argChk_Num(t, \"delay\", 0)).easing(Y).onComplete($), z(this, Ie).filters = [W], H)\n    return z(this, De).tw.start(), this.appPixi.ticker.add(B), !1;\n  if (!X)\n    throw \"ruleが指定されていません\";\n  return GrpLayer.csv2Sprites(X, void 0, (q) => {\n    var K;\n    W.uniforms.rule = q.texture, q.destroy(), (K = z(this, De).tw) == null || K.start(), this.appPixi.ticker.add(B);\n  }), !1;\n}, De = new WeakMap(), Xe = new WeakSet(), rr = function(t = \"\") {\n  return t ? t.split(\",\") : z(this, Wr);\n}, wh = new WeakSet(), Pd = function(t, e) {\n  const r = lt(this, Xe, rr).call(this, t.layer);\n  for (const S of r) {\n    if (!S)\n      continue;\n    const T = z(this, se)[S];\n    if (!T)\n      throw \"存在しないlayer【\" + S + \"】です\";\n    e(S, T);\n  }\n  return r;\n}, Ch = new WeakSet(), Rd = function(t = \"\") {\n  return lt(this, Xe, rr).call(this, t).sort((e, r) => {\n    const S = z(this, le).getChildIndex(z(this, se)[e].fore.spLay), T = z(this, le).getChildIndex(z(this, se)[r].fore.spLay);\n    return S < T ? -1 : S > T ? 1 : 0;\n  });\n}, Ph = new WeakSet(), Md = function(t) {\n  return z(this, De).tw ? (z(this, De).resume = !0, z(this, Ir).waitLimitedEvent(t, () => lt(this, jn, Va).call(this))) : !1;\n}, jn = new WeakSet(), Va = function() {\n  var t;\n  return (t = z(this, De).tw) == null || t.end(), !1;\n}, Rh = new WeakSet(), Od = function(t) {\n  lt(this, jn, Va).call(this);\n  const e = argChk_Num(t, \"time\", NaN);\n  if (e === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || z(this, Ir).isSkippingByKeyDown())\n    return !1;\n  const { layer: r, ease: S } = t, T = [];\n  for (const X of lt(this, Xe, rr).call(this, r))\n    T.push(z(this, se)[X].fore.spLay);\n  z(this, mi).resize(CmnLib.stageW, CmnLib.stageH);\n  const D = () => {\n    z(this, le).visible = !0;\n    for (const X of T)\n      this.appPixi.renderer.render(\n        X,\n        { renderTexture: z(this, mi), clear: !1 }\n      );\n    z(this, le).visible = !1;\n  };\n  z(this, Ie).visible = !0, z(this, Ie).alpha = 1;\n  const N = uint(argChk_Num(t, \"hmax\", 10)), B = uint(argChk_Num(t, \"vmax\", 10)), $ = N === 0 ? () => {\n  } : () => z(this, Ie).x = Math.round(Math.random() * N * 2) - N, U = B === 0 ? () => {\n  } : () => z(this, Ie).y = Math.round(Math.random() * B * 2) - B;\n  z(this, Ie).filters = [];\n  const V = argChk_Num(t, \"repeat\", 1), H = new Tween(z(this, Ie)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(S)).onUpdate(() => {\n    $(), U();\n  }).repeat(V === 0 ? 1 / 0 : V - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onComplete(() => {\n    var X, Y;\n    (X = this.appPixi.ticker) == null || X.remove(D), z(this, le).visible = !0, z(this, Ie).visible = !1, z(this, Ie).x = 0, z(this, Ie).y = 0, (Y = z(this, De).tw) == null || Y.stop(), z(this, De).resume && this.main.resume(), ot(this, De, { tw: void 0, resume: !1 });\n  }).start();\n  return ot(this, De, { tw: H, resume: !1 }), this.appPixi.ticker.add(D), !1;\n}, ur = new WeakMap(), Mh = new WeakSet(), Id = function(t) {\n  const { layer: e, render: r, path: S, name: T, ease: D, chain: N } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  const B = lt(this, Yi, xs).call(this, t);\n  let $ = z(this, se)[B].fore, U = () => {\n  };\n  const V = z(this, Ir).isSkippingByKeyDown();\n  !V && r && ($.renderStart(), U = () => $.renderEnd());\n  const H = T ?? e, X = () => {\n    var at, ut;\n    const it = z(this, ur)[H];\n    !it || (U(), delete z(this, ur)[H], (at = it.tw) == null || at.stop(), it.resume && this.main.resume(), (ut = it.onEnd) == null || ut.call(it));\n  }, Y = cnvTweenArg(t, $), W = argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || V) ? 0 : 1), q = CmnTween.ease(D), K = argChk_Num(t, \"repeat\", 1), Z = K === 0 ? 1 / 0 : K - 1, J = argChk_Boolean(t, \"yoyo\", !1), Q = argChk_Num(t, \"delay\", 0), rt = new Tween($).to(Y, W).easing(q).repeat(Z).yoyo(J).delay(Q);\n  let et = rt;\n  if (S) {\n    CmnLib.debugLog && console.group(`🍝 [tsy] path=${S}= start(${$.x},${$.y},${$.alpha})`);\n    for (const { groups: it } of S.matchAll(Di.REG_TSY_PATH)) {\n      const { x: at, x2: ut, y: ct, y2: gt, o: _t, o2: vt, json: mt } = it;\n      let bt = {};\n      if (mt)\n        try {\n          bt = JSON.parse(mt);\n        } catch (pt) {\n          console.error(`🍝 json=${mt} ` + pt);\n          continue;\n        }\n      else\n        (at ?? ut) && (bt.x = at ?? ut), (ct ?? gt) && (bt.y = ct ?? gt), (_t ?? vt) && (bt.alpha = _t ?? vt);\n      const Ct = cnvTweenArg(bt, $);\n      CmnLib.debugLog && console.info(`🍝 ${mt ?? `{x:${at} y:${ct} o:${_t}}`} => hTo:${JSON.stringify(Ct)}`);\n      const St = new Tween($).to(Ct, W).easing(q).repeat(Z).yoyo(J);\n      et.chain(St), et = St;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (et.onComplete(X), N) {\n    const it = z(this, ur)[N ?? \"\"];\n    if (!(it != null && it.tw))\n      throw `${N}は存在しない・または終了したトゥイーンです`;\n    delete it.onEnd, it.tw.chain(rt);\n  } else\n    rt.start();\n  const nt = argChk_Boolean(t, \"arrive\", !1), st = argChk_Boolean(t, \"backlay\", !1);\n  return z(this, ur)[H] = { tw: et, resume: !1, onEnd: () => {\n    if (nt && Object.assign($, Y), st) {\n      const it = z(this, se)[B].back.spLay;\n      for (const at of Object.keys(hMemberCnt))\n        it[at] = $[at];\n    }\n  } }, !1;\n}, Oh = new WeakSet(), Dd = function(t) {\n  const { layer: e = \"\", id: r, name: S } = t, T = r ? `frm\n${r}` : S ?? e;\n  if (!T)\n    throw \"トゥイーンが指定されていません\";\n  const D = z(this, ur)[T];\n  return D != null && D.tw ? D.resume = z(this, Ir).waitEvent(\n    () => {\n      var N;\n      return (N = D.tw) == null ? void 0 : N.end();\n    },\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ) : !1;\n}, Ih = new WeakSet(), Ad = function(t) {\n  var D, N;\n  const { layer: e = \"\", id: r, name: S } = t, T = r ? `frm\n${r}` : S ?? e;\n  if (!T)\n    throw \"トゥイーンが指定されていません\";\n  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.end(), !1;\n}, Dh = new WeakSet(), Nd = function(t) {\n  var D, N;\n  const { layer: e = \"\", id: r, name: S } = t, T = r ? `frm\n${r}` : S ?? e;\n  if (!T)\n    throw \"トゥイーンが指定されていません\";\n  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.pause(), !1;\n}, Ah = new WeakSet(), Ld = function(t) {\n  var D, N;\n  const { layer: e = \"\", id: r, name: S } = t, T = r ? `frm\n${r}` : S ?? e;\n  if (!T)\n    throw \"トゥイーンが指定されていません\";\n  return (N = (D = z(this, ur)[T]) == null ? void 0 : D.tw) == null || N.resume(), !1;\n}, Xi = new WeakMap(), zn = new WeakSet(), Xa = function(t) {\n  const { text: e } = t;\n  if (!e)\n    throw \"textは必須です\";\n  const r = z(this, hr).call(this, t);\n  delete t.text, this.val.getVal(\"tmp:sn.skip.enabled\") ? t.wait = 0 : \"wait\" in t && argChk_Num(t, \"wait\", NaN);\n  const S = encodeURIComponent(JSON.stringify(t));\n  z(this, Ze).call(this, \"add｜\" + S, r);\n  const T = argChk_Boolean(t, \"record\", !0), D = this.val.doRecLog();\n  return T || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", T), r.tagCh(e.replaceAll(\"[r]\", `\n`)), this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", D), z(this, Ze).call(this, \"add_close｜\", r), !1;\n}, hr = new WeakMap(), Nh = new WeakSet(), kd = function(t) {\n  const e = lt(this, Yi, xs).call(this, t, z(this, qr)), S = z(this, se)[e].getPage(t);\n  if (!(S instanceof TxtLayer))\n    throw e + \"はTxtLayerではありません\";\n  return S;\n}, fl = new WeakMap(), Lh = new WeakSet(), Bd = function(t) {\n  const { layer: e } = t;\n  if (!e)\n    throw \"[current] layerは必須です\";\n  if (ot(this, Kr, z(this, se)[e]), !(z(this, Kr).getPage(t) instanceof TxtLayer))\n    throw `${e}はTxtLayerではありません`;\n  this.recPagebreak(), ot(this, qr, e), this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", e);\n  for (const r of lt(this, Xe, rr).call(this)) {\n    const S = z(this, se)[r];\n    S.fore instanceof TxtLayer && (S.fore.isCur = S.back.isCur = r === e);\n  }\n  return !1;\n}, Kr = new WeakMap(), Hn = new WeakMap(), Yi = new WeakSet(), xs = function(t, e = \"\") {\n  const r = t.layer ?? e;\n  if (r.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (!(r in z(this, se)))\n    throw \"属性 layer【\" + r + \"】が不正です。レイヤーがありません\";\n  return t.layer = r;\n}, Dr = new WeakMap(), Zr = new WeakMap(), kh = new WeakSet(), Fd = function(t) {\n  const e = z(this, hr).call(this, t);\n  return t.layer === z(this, qr) && t.page === \"fore\" && this.recPagebreak(), e.clearText(), !1;\n}, Bh = new WeakSet(), $d = function(t) {\n  return z(this, Ze).call(this, \"endlink｜\", z(this, hr).call(this, t)), !1;\n}, Fh = new WeakSet(), Gd = function(t) {\n  return argChk_Boolean(t, \"rec_page_break\", !0) && this.recPagebreak(), z(this, Kr) && (z(this, Kr).fore.clearLay(t), z(this, Kr).back.clearLay(t)), !1;\n}, $h = new WeakSet(), Ud = function(t) {\n  if (!t.pic)\n    throw \"[graph] picは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return z(this, Ze).call(this, \"grp｜\" + e, z(this, hr).call(this, t)), !1;\n}, Gh = new WeakSet(), jd = function(t) {\n  t.style ?? (t.style = \"background-color: rgba(255,0,0,0.5);\"), t.style_hover ?? (t.style_hover = \"background-color: rgba(255,0,0,0.9);\"), t.style_clicked ?? (t.style_clicked = t.style);\n  const e = encodeURIComponent(JSON.stringify(t));\n  return z(this, Ze).call(this, \"link｜\" + e, z(this, hr).call(this, t)), !1;\n}, Uh = new WeakSet(), zd = function(t) {\n  return t.text = `\n`, lt(this, zn, Xa).call(this, t);\n}, jh = new WeakSet(), Hd = function(t) {\n  return lt(this, dl, gf).call(this, { ...t, text: \"[r]\" });\n}, dl = new WeakSet(), gf = function(t) {\n  return t.text ? (t.record = !0, t.style ?? (t.style = \"\"), t.style += \"display: none;\", t.wait = 0, lt(this, zn, Xa).call(this, t)) : !1;\n}, zh = new WeakSet(), Vd = function(t) {\n  return ot(this, Zr, []), ot(this, Dr, t.text ?? \"\"), this.val.setVal_Nochk(\n    \"save\",\n    \"const.sn.sLog\",\n    t.text ? `[{text:\"${t.text}\"}]` : \"[]\"\n  ), !1;\n}, Hh = new WeakSet(), Xd = function(t) {\n  const { t: e, r } = t;\n  if (!e)\n    throw \"[ruby2] tは必須です\";\n  if (!r)\n    throw \"[ruby2] rは必須です\";\n  return t.text = \"｜\" + encodeURIComponent(e) + \"《\" + encodeURIComponent(r) + \"》\", delete t.t, delete t.r, lt(this, zn, Xa).call(this, t);\n}, Vh = new WeakSet(), Yd = function(t) {\n  const e = encodeURIComponent(JSON.stringify(t));\n  return z(this, Ze).call(this, \"span｜\" + e, z(this, hr).call(this, t)), !1;\n}, Xh = new WeakSet(), Wd = function(t) {\n  if (!t.t)\n    throw \"[tcy] tは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return z(this, Ze).call(this, \"tcy｜\" + e, z(this, hr).call(this, t)), !1;\n}, Yh = new WeakSet(), qd = function(t) {\n  console.group(\"🥟 [dump_lay]\");\n  for (const e of lt(this, Xe, rr).call(this, t.layer)) {\n    const r = z(this, se)[e];\n    try {\n      console.info(\n        `%c${r.fore.name.slice(0, -7)} %o`,\n        `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`,\n        JSON.parse(`{\"back\":{${r.back.dump()}}, \"fore\":{${r.fore.dump()}}}`)\n      );\n    } catch (S) {\n      console.error(\"dump_lay err:%o\", S), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);\n    }\n  }\n  return console.groupEnd(), !1;\n}, Wh = new WeakSet(), Kd = function(t) {\n  const e = lt(this, Yi, xs).call(this, t, z(this, qr)), r = argChk_Boolean(t, \"enabled\", !0);\n  return z(this, hr).call(this, t).enabled = r, this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + e + \".enabled\", r), !1;\n}, qh = new WeakSet(), Zd = function(t) {\n  return Pages.argChk_page(t, \"back\"), t.clicksebuf ?? (t.clicksebuf = \"SYS\"), t.entersebuf ?? (t.entersebuf = \"SYS\"), t.leavesebuf ?? (t.leavesebuf = \"SYS\"), t.fn || (t.fn = this.scrItr.scriptFn), z(this, hr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;\n}, Rt(LayerMng, \"REG_TSY_PATH\", /\\(\\s*(?:(?<x>[-=\\d\\.]+)|(['\"])(?<x2>.*?)\\2)?(?:\\s*,\\s*(?:(?<y>[-=\\d\\.]+)|(['\"])(?<y2>.*?)\\5)?(?:\\s*,\\s*(?:(?<o>[-=\\d\\.]+)|(['\"])(?<o2>.*?)\\8))?)?|(?<json>\\{[^{}]*})/g), tt(LayerMng, Xi, 10);\nvar we, ye, ya, Kh, Jd, pl, Vn, Ya;\nclass FocusMng {\n  constructor() {\n    tt(this, Kh);\n    tt(this, Vn);\n    tt(this, we, []);\n    tt(this, ye, -1);\n    tt(this, ya, new EventListenerCtn());\n    tt(this, pl, CmnLib.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, z(this, we)[t].btn) : () => {\n    });\n  }\n  destroy() {\n    ot(this, we, []), ot(this, ye, -1), z(this, ya).clear();\n  }\n  add(t, e, r) {\n    if (z(this, we).findIndex((N) => N.btn === t) >= 0)\n      return;\n    if (t instanceof Container) {\n      t.on(\"pointerdown\", () => {\n        for (let N = z(this, we).length - 1; N >= 0; --N)\n          if (z(this, we)[N].btn === t) {\n            ot(this, ye, N);\n            return;\n          }\n        ot(this, ye, -1);\n      }), z(this, we).push({ btn: t, on: e, off: r });\n      return;\n    }\n    z(this, ya).add(t, \"focus\", () => {\n      for (let N = z(this, we).length - 1; N >= 0; --N)\n        if (z(this, we)[N].btn === t) {\n          ot(this, ye, N);\n          return;\n        }\n      ot(this, ye, -1);\n    });\n    let S = (N) => {\n    }, T = t.localName === \"button\" || t.localName === \"a\" ? (N) => !N.isTrusted && N.key === \"Enter\" : (N) => N.key === \"Enter\";\n    const D = t;\n    switch (D.type ?? \"\") {\n      case \"checkbox\":\n        S = () => D.checked = !D.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (S = (N) => lt(this, Kh, Jd).call(this, t, N.key), T = () => !1);\n        break;\n      case \"range\":\n        S = (N) => {\n          N.isTrusted || (N.key === \"ArrowUp\" ? D.stepUp() : D.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        S = (N) => {\n          if (N.isTrusted)\n            return;\n          let B = (D.selectionStart ?? 0) + (N.key === \"ArrowUp\" ? -1 : 1);\n          B < 0 && (B = 0), D.setSelectionRange(B, B);\n        };\n        break;\n    }\n    z(this, ya).add(t, \"keydown\", (N) => {\n      if (!(N.key !== \"ArrowUp\" && N.key !== \"ArrowDown\" && N.key !== \"Enter\")) {\n        if (N.stopPropagation(), N.stopImmediatePropagation(), T(N)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        S(N);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), z(this, we).push({ btn: t, on: e, off: r });\n  }\n  remove(t) {\n    const e = z(this, we).findIndex((r) => r.btn === t);\n    e < 0 || (z(this, we).splice(e, 1), z(this, we).length === 0 ? ot(this, ye, -1) : e <= z(this, ye) && --Me(this, ye)._);\n  }\n  isFocus(t) {\n    return z(this, ye) < 0 ? !1 : z(this, we)[z(this, ye)].btn === t;\n  }\n  prev() {\n    lt(this, Vn, Ya).call(this);\n    const t = z(this, we).length;\n    if (t !== 0) {\n      --Me(this, ye)._ < 0 && ot(this, ye, t - 1);\n      for (let e = t; e >= 1; --e) {\n        const r = (z(this, ye) + e) % t;\n        if (z(this, we)[r].on()) {\n          ot(this, ye, r), z(this, pl).call(this, r);\n          return;\n        }\n      }\n      ot(this, ye, -1);\n    }\n  }\n  next() {\n    lt(this, Vn, Ya).call(this);\n    const t = z(this, we).length;\n    if (t !== 0) {\n      ++Me(this, ye)._ >= t && ot(this, ye, 0);\n      for (let e = 0; e < t; ++e) {\n        const r = (z(this, ye) + e) % t;\n        if (z(this, we)[r].on()) {\n          ot(this, ye, r), z(this, pl).call(this, r);\n          return;\n        }\n      }\n      ot(this, ye, -1);\n    }\n  }\n  getFocus() {\n    if (z(this, ye) < 0)\n      return null;\n    lt(this, Vn, Ya).call(this), z(this, ye) >= z(this, we).length && ot(this, ye, 0);\n    const t = z(this, we)[z(this, ye)];\n    return t.on() ? t.btn : null;\n  }\n  blur() {\n    lt(this, Vn, Ya).call(this), ot(this, ye, -1), globalThis.focus();\n  }\n}\nwe = new WeakMap(), ye = new WeakMap(), ya = new WeakMap(), Kh = new WeakSet(), Jd = function(t, e) {\n  const r = t.querySelectorAll(\"input[type]\"), S = r.length;\n  for (let T = 0; T < S; ++T)\n    if (!!r[T].checked) {\n      r[(T + S + (e === \"ArrowUp\" ? -1 : 1)) % S].checked = !0;\n      break;\n    }\n}, pl = new WeakMap(), Vn = new WeakSet(), Ya = function() {\n  for (let t = z(this, we).length - 1; t >= 0; --t) {\n    const e = z(this, we)[t];\n    !(e.btn instanceof Container) || e.btn.parent ? e.off() : z(this, we).splice(t, 1);\n  }\n};\nvar top = \"top\", bottom = \"bottom\", right = \"right\", left = \"left\", auto = \"auto\", basePlacements = [top, bottom, right, left], start = \"start\", end = \"end\", clippingParents = \"clippingParents\", viewport = \"viewport\", popper = \"popper\", reference = \"reference\", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(o, t) {\n  return o.concat([t + \"-\" + start, t + \"-\" + end]);\n}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(o, t) {\n  return o.concat([t, t + \"-\" + start, t + \"-\" + end]);\n}, []), beforeRead = \"beforeRead\", read$6 = \"read\", afterRead = \"afterRead\", beforeMain = \"beforeMain\", main$1 = \"main\", afterMain = \"afterMain\", beforeWrite = \"beforeWrite\", write$6 = \"write\", afterWrite = \"afterWrite\", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];\nfunction getNodeName(o) {\n  return o ? (o.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(o) {\n  if (o == null)\n    return window;\n  if (o.toString() !== \"[object Window]\") {\n    var t = o.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return o;\n}\nfunction isElement(o) {\n  var t = getWindow(o).Element;\n  return o instanceof t || o instanceof Element;\n}\nfunction isHTMLElement(o) {\n  var t = getWindow(o).HTMLElement;\n  return o instanceof t || o instanceof HTMLElement;\n}\nfunction isShadowRoot(o) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = getWindow(o).ShadowRoot;\n  return o instanceof t || o instanceof ShadowRoot;\n}\nfunction applyStyles(o) {\n  var t = o.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var r = t.styles[e] || {}, S = t.attributes[e] || {}, T = t.elements[e];\n    !isHTMLElement(T) || !getNodeName(T) || (Object.assign(T.style, r), Object.keys(S).forEach(function(D) {\n      var N = S[D];\n      N === !1 ? T.removeAttribute(D) : T.setAttribute(D, N === !0 ? \"\" : N);\n    }));\n  });\n}\nfunction effect$2(o) {\n  var t = o.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(r) {\n      var S = t.elements[r], T = t.attributes[r] || {}, D = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), N = D.reduce(function(B, $) {\n        return B[$] = \"\", B;\n      }, {});\n      !isHTMLElement(S) || !getNodeName(S) || (Object.assign(S.style, N), Object.keys(T).forEach(function(B) {\n        S.removeAttribute(B);\n      }));\n    });\n  };\n}\nconst applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(o) {\n  return o.split(\"-\")[0];\n}\nvar max = Math.max, min = Math.min, round = Math.round;\nfunction getUAString() {\n  var o = navigator.userAgentData;\n  return o != null && o.brands ? o.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(o, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var r = o.getBoundingClientRect(), S = 1, T = 1;\n  t && isHTMLElement(o) && (S = o.offsetWidth > 0 && round(r.width) / o.offsetWidth || 1, T = o.offsetHeight > 0 && round(r.height) / o.offsetHeight || 1);\n  var D = isElement(o) ? getWindow(o) : window, N = D.visualViewport, B = !isLayoutViewport() && e, $ = (r.left + (B && N ? N.offsetLeft : 0)) / S, U = (r.top + (B && N ? N.offsetTop : 0)) / T, V = r.width / S, H = r.height / T;\n  return {\n    width: V,\n    height: H,\n    top: U,\n    right: $ + V,\n    bottom: U + H,\n    left: $,\n    x: $,\n    y: U\n  };\n}\nfunction getLayoutRect(o) {\n  var t = getBoundingClientRect(o), e = o.offsetWidth, r = o.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {\n    x: o.offsetLeft,\n    y: o.offsetTop,\n    width: e,\n    height: r\n  };\n}\nfunction contains(o, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (o.contains(t))\n    return !0;\n  if (e && isShadowRoot(e)) {\n    var r = t;\n    do {\n      if (r && o.isSameNode(r))\n        return !0;\n      r = r.parentNode || r.host;\n    } while (r);\n  }\n  return !1;\n}\nfunction getComputedStyle$1(o) {\n  return getWindow(o).getComputedStyle(o);\n}\nfunction isTableElement(o) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(o)) >= 0;\n}\nfunction getDocumentElement(o) {\n  return ((isElement(o) ? o.ownerDocument : o.document) || window.document).documentElement;\n}\nfunction getParentNode(o) {\n  return getNodeName(o) === \"html\" ? o : o.assignedSlot || o.parentNode || (isShadowRoot(o) ? o.host : null) || getDocumentElement(o);\n}\nfunction getTrueOffsetParent(o) {\n  return !isHTMLElement(o) || getComputedStyle$1(o).position === \"fixed\" ? null : o.offsetParent;\n}\nfunction getContainingBlock(o) {\n  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());\n  if (e && isHTMLElement(o)) {\n    var r = getComputedStyle$1(o);\n    if (r.position === \"fixed\")\n      return null;\n  }\n  var S = getParentNode(o);\n  for (isShadowRoot(S) && (S = S.host); isHTMLElement(S) && [\"html\", \"body\"].indexOf(getNodeName(S)) < 0; ) {\n    var T = getComputedStyle$1(S);\n    if (T.transform !== \"none\" || T.perspective !== \"none\" || T.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(T.willChange) !== -1 || t && T.willChange === \"filter\" || t && T.filter && T.filter !== \"none\")\n      return S;\n    S = S.parentNode;\n  }\n  return null;\n}\nfunction getOffsetParent(o) {\n  for (var t = getWindow(o), e = getTrueOffsetParent(o); e && isTableElement(e) && getComputedStyle$1(e).position === \"static\"; )\n    e = getTrueOffsetParent(e);\n  return e && (getNodeName(e) === \"html\" || getNodeName(e) === \"body\" && getComputedStyle$1(e).position === \"static\") ? t : e || getContainingBlock(o) || t;\n}\nfunction getMainAxisFromPlacement(o) {\n  return [\"top\", \"bottom\"].indexOf(o) >= 0 ? \"x\" : \"y\";\n}\nfunction within(o, t, e) {\n  return max(o, min(t, e));\n}\nfunction withinMaxClamp(o, t, e) {\n  var r = within(o, t, e);\n  return r > e ? e : r;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(o) {\n  return Object.assign({}, getFreshSideObject(), o);\n}\nfunction expandToHashMap(o, t) {\n  return t.reduce(function(e, r) {\n    return e[r] = o, e;\n  }, {});\n}\nvar toPaddingObject = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, mergePaddingObject(typeof t != \"number\" ? t : expandToHashMap(t, basePlacements));\n};\nfunction arrow(o) {\n  var t, e = o.state, r = o.name, S = o.options, T = e.elements.arrow, D = e.modifiersData.popperOffsets, N = getBasePlacement(e.placement), B = getMainAxisFromPlacement(N), $ = [left, right].indexOf(N) >= 0, U = $ ? \"height\" : \"width\";\n  if (!(!T || !D)) {\n    var V = toPaddingObject(S.padding, e), H = getLayoutRect(T), X = B === \"y\" ? top : left, Y = B === \"y\" ? bottom : right, W = e.rects.reference[U] + e.rects.reference[B] - D[B] - e.rects.popper[U], q = D[B] - e.rects.reference[B], K = getOffsetParent(T), Z = K ? B === \"y\" ? K.clientHeight || 0 : K.clientWidth || 0 : 0, J = W / 2 - q / 2, Q = V[X], rt = Z - H[U] - V[Y], et = Z / 2 - H[U] / 2 + J, nt = within(Q, et, rt), st = B;\n    e.modifiersData[r] = (t = {}, t[st] = nt, t.centerOffset = nt - et, t);\n  }\n}\nfunction effect$1(o) {\n  var t = o.state, e = o.options, r = e.element, S = r === void 0 ? \"[data-popper-arrow]\" : r;\n  if (S != null && !(typeof S == \"string\" && (S = t.elements.popper.querySelector(S), !S))) {\n    if ( true && (isHTMLElement(S) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !contains(t.elements.popper, S)) {\n       true && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = S;\n  }\n}\nconst arrow$1 = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(o) {\n  return o.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(o) {\n  var t = o.x, e = o.y, r = window, S = r.devicePixelRatio || 1;\n  return {\n    x: round(t * S) / S || 0,\n    y: round(e * S) / S || 0\n  };\n}\nfunction mapToStyles(o) {\n  var t, e = o.popper, r = o.popperRect, S = o.placement, T = o.variation, D = o.offsets, N = o.position, B = o.gpuAcceleration, $ = o.adaptive, U = o.roundOffsets, V = o.isFixed, H = D.x, X = H === void 0 ? 0 : H, Y = D.y, W = Y === void 0 ? 0 : Y, q = typeof U == \"function\" ? U({\n    x: X,\n    y: W\n  }) : {\n    x: X,\n    y: W\n  };\n  X = q.x, W = q.y;\n  var K = D.hasOwnProperty(\"x\"), Z = D.hasOwnProperty(\"y\"), J = left, Q = top, rt = window;\n  if ($) {\n    var et = getOffsetParent(e), nt = \"clientHeight\", st = \"clientWidth\";\n    if (et === getWindow(e) && (et = getDocumentElement(e), getComputedStyle$1(et).position !== \"static\" && N === \"absolute\" && (nt = \"scrollHeight\", st = \"scrollWidth\")), et = et, S === top || (S === left || S === right) && T === end) {\n      Q = bottom;\n      var it = V && et === rt && rt.visualViewport ? rt.visualViewport.height : et[nt];\n      W -= it - r.height, W *= B ? 1 : -1;\n    }\n    if (S === left || (S === top || S === bottom) && T === end) {\n      J = right;\n      var at = V && et === rt && rt.visualViewport ? rt.visualViewport.width : et[st];\n      X -= at - r.width, X *= B ? 1 : -1;\n    }\n  }\n  var ut = Object.assign({\n    position: N\n  }, $ && unsetSides), ct = U === !0 ? roundOffsetsByDPR({\n    x: X,\n    y: W\n  }) : {\n    x: X,\n    y: W\n  };\n  if (X = ct.x, W = ct.y, B) {\n    var gt;\n    return Object.assign({}, ut, (gt = {}, gt[Q] = Z ? \"0\" : \"\", gt[J] = K ? \"0\" : \"\", gt.transform = (rt.devicePixelRatio || 1) <= 1 ? \"translate(\" + X + \"px, \" + W + \"px)\" : \"translate3d(\" + X + \"px, \" + W + \"px, 0)\", gt));\n  }\n  return Object.assign({}, ut, (t = {}, t[Q] = Z ? W + \"px\" : \"\", t[J] = K ? X + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction computeStyles(o) {\n  var t = o.state, e = o.options, r = e.gpuAcceleration, S = r === void 0 ? !0 : r, T = e.adaptive, D = T === void 0 ? !0 : T, N = e.roundOffsets, B = N === void 0 ? !0 : N;\n  if (true) {\n    var $ = getComputedStyle$1(t.elements.popper).transitionProperty || \"\";\n    D && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(V) {\n      return $.indexOf(V) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var U = {\n    placement: getBasePlacement(t.placement),\n    variation: getVariation(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: S,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, U, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: D,\n    roundOffsets: B\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, U, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: B\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: !0\n};\nfunction effect(o) {\n  var t = o.state, e = o.instance, r = o.options, S = r.scroll, T = S === void 0 ? !0 : S, D = r.resize, N = D === void 0 ? !0 : D, B = getWindow(t.elements.popper), $ = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return T && $.forEach(function(U) {\n    U.addEventListener(\"scroll\", e.update, passive);\n  }), N && B.addEventListener(\"resize\", e.update, passive), function() {\n    T && $.forEach(function(U) {\n      U.removeEventListener(\"scroll\", e.update, passive);\n    }), N && B.removeEventListener(\"resize\", e.update, passive);\n  };\n}\nconst eventListeners = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(o) {\n  return o.replace(/left|right|bottom|top/g, function(t) {\n    return hash$1[t];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(o) {\n  return o.replace(/start|end/g, function(t) {\n    return hash[t];\n  });\n}\nfunction getWindowScroll(o) {\n  var t = getWindow(o), e = t.pageXOffset, r = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: r\n  };\n}\nfunction getWindowScrollBarX(o) {\n  return getBoundingClientRect(getDocumentElement(o)).left + getWindowScroll(o).scrollLeft;\n}\nfunction getViewportRect(o, t) {\n  var e = getWindow(o), r = getDocumentElement(o), S = e.visualViewport, T = r.clientWidth, D = r.clientHeight, N = 0, B = 0;\n  if (S) {\n    T = S.width, D = S.height;\n    var $ = isLayoutViewport();\n    ($ || !$ && t === \"fixed\") && (N = S.offsetLeft, B = S.offsetTop);\n  }\n  return {\n    width: T,\n    height: D,\n    x: N + getWindowScrollBarX(o),\n    y: B\n  };\n}\nfunction getDocumentRect(o) {\n  var t, e = getDocumentElement(o), r = getWindowScroll(o), S = (t = o.ownerDocument) == null ? void 0 : t.body, T = max(e.scrollWidth, e.clientWidth, S ? S.scrollWidth : 0, S ? S.clientWidth : 0), D = max(e.scrollHeight, e.clientHeight, S ? S.scrollHeight : 0, S ? S.clientHeight : 0), N = -r.scrollLeft + getWindowScrollBarX(o), B = -r.scrollTop;\n  return getComputedStyle$1(S || e).direction === \"rtl\" && (N += max(e.clientWidth, S ? S.clientWidth : 0) - T), {\n    width: T,\n    height: D,\n    x: N,\n    y: B\n  };\n}\nfunction isScrollParent(o) {\n  var t = getComputedStyle$1(o), e = t.overflow, r = t.overflowX, S = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + S + r);\n}\nfunction getScrollParent(o) {\n  return [\"html\", \"body\", \"#document\"].indexOf(getNodeName(o)) >= 0 ? o.ownerDocument.body : isHTMLElement(o) && isScrollParent(o) ? o : getScrollParent(getParentNode(o));\n}\nfunction listScrollParents(o, t) {\n  var e;\n  t === void 0 && (t = []);\n  var r = getScrollParent(o), S = r === ((e = o.ownerDocument) == null ? void 0 : e.body), T = getWindow(r), D = S ? [T].concat(T.visualViewport || [], isScrollParent(r) ? r : []) : r, N = t.concat(D);\n  return S ? N : N.concat(listScrollParents(getParentNode(D)));\n}\nfunction rectToClientRect(o) {\n  return Object.assign({}, o, {\n    left: o.x,\n    top: o.y,\n    right: o.x + o.width,\n    bottom: o.y + o.height\n  });\n}\nfunction getInnerBoundingClientRect(o, t) {\n  var e = getBoundingClientRect(o, !1, t === \"fixed\");\n  return e.top = e.top + o.clientTop, e.left = e.left + o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction getClientRectFromMixedType(o, t, e) {\n  return t === viewport ? rectToClientRect(getViewportRect(o, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(o)));\n}\nfunction getClippingParents(o) {\n  var t = listScrollParents(getParentNode(o)), e = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(o).position) >= 0, r = e && isHTMLElement(o) ? getOffsetParent(o) : o;\n  return isElement(r) ? t.filter(function(S) {\n    return isElement(S) && contains(S, r) && getNodeName(S) !== \"body\";\n  }) : [];\n}\nfunction getClippingRect(o, t, e, r) {\n  var S = t === \"clippingParents\" ? getClippingParents(o) : [].concat(t), T = [].concat(S, [e]), D = T[0], N = T.reduce(function(B, $) {\n    var U = getClientRectFromMixedType(o, $, r);\n    return B.top = max(U.top, B.top), B.right = min(U.right, B.right), B.bottom = min(U.bottom, B.bottom), B.left = max(U.left, B.left), B;\n  }, getClientRectFromMixedType(o, D, r));\n  return N.width = N.right - N.left, N.height = N.bottom - N.top, N.x = N.left, N.y = N.top, N;\n}\nfunction computeOffsets(o) {\n  var t = o.reference, e = o.element, r = o.placement, S = r ? getBasePlacement(r) : null, T = r ? getVariation(r) : null, D = t.x + t.width / 2 - e.width / 2, N = t.y + t.height / 2 - e.height / 2, B;\n  switch (S) {\n    case top:\n      B = {\n        x: D,\n        y: t.y - e.height\n      };\n      break;\n    case bottom:\n      B = {\n        x: D,\n        y: t.y + t.height\n      };\n      break;\n    case right:\n      B = {\n        x: t.x + t.width,\n        y: N\n      };\n      break;\n    case left:\n      B = {\n        x: t.x - e.width,\n        y: N\n      };\n      break;\n    default:\n      B = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var $ = S ? getMainAxisFromPlacement(S) : null;\n  if ($ != null) {\n    var U = $ === \"y\" ? \"height\" : \"width\";\n    switch (T) {\n      case start:\n        B[$] = B[$] - (t[U] / 2 - e[U] / 2);\n        break;\n      case end:\n        B[$] = B[$] + (t[U] / 2 - e[U] / 2);\n        break;\n    }\n  }\n  return B;\n}\nfunction detectOverflow(o, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, S = r === void 0 ? o.placement : r, T = e.strategy, D = T === void 0 ? o.strategy : T, N = e.boundary, B = N === void 0 ? clippingParents : N, $ = e.rootBoundary, U = $ === void 0 ? viewport : $, V = e.elementContext, H = V === void 0 ? popper : V, X = e.altBoundary, Y = X === void 0 ? !1 : X, W = e.padding, q = W === void 0 ? 0 : W, K = mergePaddingObject(typeof q != \"number\" ? q : expandToHashMap(q, basePlacements)), Z = H === popper ? reference : popper, J = o.rects.popper, Q = o.elements[Y ? Z : H], rt = getClippingRect(isElement(Q) ? Q : Q.contextElement || getDocumentElement(o.elements.popper), B, U, D), et = getBoundingClientRect(o.elements.reference), nt = computeOffsets({\n    reference: et,\n    element: J,\n    strategy: \"absolute\",\n    placement: S\n  }), st = rectToClientRect(Object.assign({}, J, nt)), it = H === popper ? st : et, at = {\n    top: rt.top - it.top + K.top,\n    bottom: it.bottom - rt.bottom + K.bottom,\n    left: rt.left - it.left + K.left,\n    right: it.right - rt.right + K.right\n  }, ut = o.modifiersData.offset;\n  if (H === popper && ut) {\n    var ct = ut[S];\n    Object.keys(at).forEach(function(gt) {\n      var _t = [right, bottom].indexOf(gt) >= 0 ? 1 : -1, vt = [top, bottom].indexOf(gt) >= 0 ? \"y\" : \"x\";\n      at[gt] += ct[vt] * _t;\n    });\n  }\n  return at;\n}\nfunction computeAutoPlacement(o, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, S = e.boundary, T = e.rootBoundary, D = e.padding, N = e.flipVariations, B = e.allowedAutoPlacements, $ = B === void 0 ? placements : B, U = getVariation(r), V = U ? N ? variationPlacements : variationPlacements.filter(function(Y) {\n    return getVariation(Y) === U;\n  }) : basePlacements, H = V.filter(function(Y) {\n    return $.indexOf(Y) >= 0;\n  });\n  H.length === 0 && (H = V,  true && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var X = H.reduce(function(Y, W) {\n    return Y[W] = detectOverflow(o, {\n      placement: W,\n      boundary: S,\n      rootBoundary: T,\n      padding: D\n    })[getBasePlacement(W)], Y;\n  }, {});\n  return Object.keys(X).sort(function(Y, W) {\n    return X[Y] - X[W];\n  });\n}\nfunction getExpandedFallbackPlacements(o) {\n  if (getBasePlacement(o) === auto)\n    return [];\n  var t = getOppositePlacement(o);\n  return [getOppositeVariationPlacement(o), t, getOppositeVariationPlacement(t)];\n}\nfunction flip(o) {\n  var t = o.state, e = o.options, r = o.name;\n  if (!t.modifiersData[r]._skip) {\n    for (var S = e.mainAxis, T = S === void 0 ? !0 : S, D = e.altAxis, N = D === void 0 ? !0 : D, B = e.fallbackPlacements, $ = e.padding, U = e.boundary, V = e.rootBoundary, H = e.altBoundary, X = e.flipVariations, Y = X === void 0 ? !0 : X, W = e.allowedAutoPlacements, q = t.options.placement, K = getBasePlacement(q), Z = K === q, J = B || (Z || !Y ? [getOppositePlacement(q)] : getExpandedFallbackPlacements(q)), Q = [q].concat(J).reduce(function(Ot, Pt) {\n      return Ot.concat(getBasePlacement(Pt) === auto ? computeAutoPlacement(t, {\n        placement: Pt,\n        boundary: U,\n        rootBoundary: V,\n        padding: $,\n        flipVariations: Y,\n        allowedAutoPlacements: W\n      }) : Pt);\n    }, []), rt = t.rects.reference, et = t.rects.popper, nt = /* @__PURE__ */ new Map(), st = !0, it = Q[0], at = 0; at < Q.length; at++) {\n      var ut = Q[at], ct = getBasePlacement(ut), gt = getVariation(ut) === start, _t = [top, bottom].indexOf(ct) >= 0, vt = _t ? \"width\" : \"height\", mt = detectOverflow(t, {\n        placement: ut,\n        boundary: U,\n        rootBoundary: V,\n        altBoundary: H,\n        padding: $\n      }), bt = _t ? gt ? right : left : gt ? bottom : top;\n      rt[vt] > et[vt] && (bt = getOppositePlacement(bt));\n      var Ct = getOppositePlacement(bt), St = [];\n      if (T && St.push(mt[ct] <= 0), N && St.push(mt[bt] <= 0, mt[Ct] <= 0), St.every(function(Ot) {\n        return Ot;\n      })) {\n        it = ut, st = !1;\n        break;\n      }\n      nt.set(ut, St);\n    }\n    if (st)\n      for (var pt = Y ? 3 : 1, yt = function(Pt) {\n        var ft = Q.find(function(Ft) {\n          var It = nt.get(Ft);\n          if (It)\n            return It.slice(0, Pt).every(function(zt) {\n              return zt;\n            });\n        });\n        if (ft)\n          return it = ft, \"break\";\n      }, At = pt; At > 0; At--) {\n        var Dt = yt(At);\n        if (Dt === \"break\")\n          break;\n      }\n    t.placement !== it && (t.modifiersData[r]._skip = !0, t.placement = it, t.reset = !0);\n  }\n}\nconst flip$1 = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction getSideOffsets(o, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: o.top - t.height - e.y,\n    right: o.right - t.width + e.x,\n    bottom: o.bottom - t.height + e.y,\n    left: o.left - t.width - e.x\n  };\n}\nfunction isAnySideFullyClipped(o) {\n  return [top, right, bottom, left].some(function(t) {\n    return o[t] >= 0;\n  });\n}\nfunction hide(o) {\n  var t = o.state, e = o.name, r = t.rects.reference, S = t.rects.popper, T = t.modifiersData.preventOverflow, D = detectOverflow(t, {\n    elementContext: \"reference\"\n  }), N = detectOverflow(t, {\n    altBoundary: !0\n  }), B = getSideOffsets(D, r), $ = getSideOffsets(N, S, T), U = isAnySideFullyClipped(B), V = isAnySideFullyClipped($);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: B,\n    popperEscapeOffsets: $,\n    isReferenceHidden: U,\n    hasPopperEscaped: V\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": U,\n    \"data-popper-escaped\": V\n  });\n}\nconst hide$1 = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(o, t, e) {\n  var r = getBasePlacement(o), S = [left, top].indexOf(r) >= 0 ? -1 : 1, T = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: o\n  })) : e, D = T[0], N = T[1];\n  return D = D || 0, N = (N || 0) * S, [left, right].indexOf(r) >= 0 ? {\n    x: N,\n    y: D\n  } : {\n    x: D,\n    y: N\n  };\n}\nfunction offset(o) {\n  var t = o.state, e = o.options, r = o.name, S = e.offset, T = S === void 0 ? [0, 0] : S, D = placements.reduce(function(U, V) {\n    return U[V] = distanceAndSkiddingToXY(V, t.rects, T), U;\n  }, {}), N = D[t.placement], B = N.x, $ = N.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += B, t.modifiersData.popperOffsets.y += $), t.modifiersData[r] = D;\n}\nconst offset$1 = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(o) {\n  var t = o.state, e = o.name;\n  t.modifiersData[e] = computeOffsets({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(o) {\n  return o === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(o) {\n  var t = o.state, e = o.options, r = o.name, S = e.mainAxis, T = S === void 0 ? !0 : S, D = e.altAxis, N = D === void 0 ? !1 : D, B = e.boundary, $ = e.rootBoundary, U = e.altBoundary, V = e.padding, H = e.tether, X = H === void 0 ? !0 : H, Y = e.tetherOffset, W = Y === void 0 ? 0 : Y, q = detectOverflow(t, {\n    boundary: B,\n    rootBoundary: $,\n    padding: V,\n    altBoundary: U\n  }), K = getBasePlacement(t.placement), Z = getVariation(t.placement), J = !Z, Q = getMainAxisFromPlacement(K), rt = getAltAxis(Q), et = t.modifiersData.popperOffsets, nt = t.rects.reference, st = t.rects.popper, it = typeof W == \"function\" ? W(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : W, at = typeof it == \"number\" ? {\n    mainAxis: it,\n    altAxis: it\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, it), ut = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {\n    x: 0,\n    y: 0\n  };\n  if (!!et) {\n    if (T) {\n      var gt, _t = Q === \"y\" ? top : left, vt = Q === \"y\" ? bottom : right, mt = Q === \"y\" ? \"height\" : \"width\", bt = et[Q], Ct = bt + q[_t], St = bt - q[vt], pt = X ? -st[mt] / 2 : 0, yt = Z === start ? nt[mt] : st[mt], At = Z === start ? -st[mt] : -nt[mt], Dt = t.elements.arrow, Ot = X && Dt ? getLayoutRect(Dt) : {\n        width: 0,\n        height: 0\n      }, Pt = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject(), ft = Pt[_t], Ft = Pt[vt], It = within(0, nt[mt], Ot[mt]), zt = J ? nt[mt] / 2 - pt - It - ft - at.mainAxis : yt - It - ft - at.mainAxis, kt = J ? -nt[mt] / 2 + pt + It + Ft + at.mainAxis : At + It + Ft + at.mainAxis, Tt = t.elements.arrow && getOffsetParent(t.elements.arrow), jt = Tt ? Q === \"y\" ? Tt.clientTop || 0 : Tt.clientLeft || 0 : 0, Nt = (gt = ut == null ? void 0 : ut[Q]) != null ? gt : 0, Et = bt + zt - Nt - jt, Lt = bt + kt - Nt, Ht = within(X ? min(Ct, Et) : Ct, bt, X ? max(St, Lt) : St);\n      et[Q] = Ht, ct[Q] = Ht - bt;\n    }\n    if (N) {\n      var wt, Wt = Q === \"x\" ? top : left, ee = Q === \"x\" ? bottom : right, Jt = et[rt], xe = rt === \"y\" ? \"height\" : \"width\", ke = Jt + q[Wt], ue = Jt - q[ee], me = [top, left].indexOf(K) !== -1, pe = (wt = ut == null ? void 0 : ut[rt]) != null ? wt : 0, fe = me ? ke : Jt - nt[xe] - st[xe] - pe + at.altAxis, ce = me ? Jt + nt[xe] + st[xe] - pe - at.altAxis : ue, ie = X && me ? withinMaxClamp(fe, Jt, ce) : within(X ? fe : ke, Jt, X ? ce : ue);\n      et[rt] = ie, ct[rt] = ie - Jt;\n    }\n    t.modifiersData[r] = ct;\n  }\n}\nconst preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(o) {\n  return {\n    scrollLeft: o.scrollLeft,\n    scrollTop: o.scrollTop\n  };\n}\nfunction getNodeScroll(o) {\n  return o === getWindow(o) || !isHTMLElement(o) ? getWindowScroll(o) : getHTMLElementScroll(o);\n}\nfunction isElementScaled(o) {\n  var t = o.getBoundingClientRect(), e = round(t.width) / o.offsetWidth || 1, r = round(t.height) / o.offsetHeight || 1;\n  return e !== 1 || r !== 1;\n}\nfunction getCompositeRect(o, t, e) {\n  e === void 0 && (e = !1);\n  var r = isHTMLElement(t), S = isHTMLElement(t) && isElementScaled(t), T = getDocumentElement(t), D = getBoundingClientRect(o, S, e), N = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, B = {\n    x: 0,\n    y: 0\n  };\n  return (r || !r && !e) && ((getNodeName(t) !== \"body\" || isScrollParent(T)) && (N = getNodeScroll(t)), isHTMLElement(t) ? (B = getBoundingClientRect(t, !0), B.x += t.clientLeft, B.y += t.clientTop) : T && (B.x = getWindowScrollBarX(T))), {\n    x: D.left + N.scrollLeft - B.x,\n    y: D.top + N.scrollTop - B.y,\n    width: D.width,\n    height: D.height\n  };\n}\nfunction order(o) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];\n  o.forEach(function(T) {\n    t.set(T.name, T);\n  });\n  function S(T) {\n    e.add(T.name);\n    var D = [].concat(T.requires || [], T.requiresIfExists || []);\n    D.forEach(function(N) {\n      if (!e.has(N)) {\n        var B = t.get(N);\n        B && S(B);\n      }\n    }), r.push(T);\n  }\n  return o.forEach(function(T) {\n    e.has(T.name) || S(T);\n  }), r;\n}\nfunction orderModifiers(o) {\n  var t = order(o);\n  return modifierPhases.reduce(function(e, r) {\n    return e.concat(t.filter(function(S) {\n      return S.phase === r;\n    }));\n  }, []);\n}\nfunction debounce(o) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(o());\n      });\n    })), t;\n  };\n}\nfunction format(o) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)\n    e[r - 1] = arguments[r];\n  return [].concat(e).reduce(function(S, T) {\n    return S.replace(/%s/, T);\n  }, o);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction validateModifiers(o) {\n  o.forEach(function(t) {\n    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, r, S) {\n      return S.indexOf(e) === r;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(r) {\n            return '\"' + r + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(r) {\n        o.find(function(S) {\n          return S.name === r;\n        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), r, r));\n      });\n    });\n  });\n}\nfunction uniqueBy(o, t) {\n  var e = /* @__PURE__ */ new Set();\n  return o.filter(function(r) {\n    var S = t(r);\n    if (!e.has(S))\n      return e.add(S), !0;\n  });\n}\nfunction mergeByName(o) {\n  var t = o.reduce(function(e, r) {\n    var S = e[r.name];\n    return e[r.name] = S ? Object.assign({}, S, r, {\n      options: Object.assign({}, S.options, r.options),\n      data: Object.assign({}, S.data, r.data)\n    }) : r, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var o = arguments.length, t = new Array(o), e = 0; e < o; e++)\n    t[e] = arguments[e];\n  return !t.some(function(r) {\n    return !(r && typeof r.getBoundingClientRect == \"function\");\n  });\n}\nfunction popperGenerator(o) {\n  o === void 0 && (o = {});\n  var t = o, e = t.defaultModifiers, r = e === void 0 ? [] : e, S = t.defaultOptions, T = S === void 0 ? DEFAULT_OPTIONS : S;\n  return function(N, B, $) {\n    $ === void 0 && ($ = T);\n    var U = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, T),\n      modifiersData: {},\n      elements: {\n        reference: N,\n        popper: B\n      },\n      attributes: {},\n      styles: {}\n    }, V = [], H = !1, X = {\n      state: U,\n      setOptions: function(K) {\n        var Z = typeof K == \"function\" ? K(U.options) : K;\n        W(), U.options = Object.assign({}, T, U.options, Z), U.scrollParents = {\n          reference: isElement(N) ? listScrollParents(N) : N.contextElement ? listScrollParents(N.contextElement) : [],\n          popper: listScrollParents(B)\n        };\n        var J = orderModifiers(mergeByName([].concat(r, U.options.modifiers)));\n        if (U.orderedModifiers = J.filter(function(ut) {\n          return ut.enabled;\n        }), \"development\" !== \"production\") {\n          var Q = uniqueBy([].concat(J, U.options.modifiers), function(ut) {\n            var ct = ut.name;\n            return ct;\n          });\n          if (validateModifiers(Q), getBasePlacement(U.options.placement) === auto) {\n            var rt = U.orderedModifiers.find(function(ut) {\n              var ct = ut.name;\n              return ct === \"flip\";\n            });\n            rt || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var et = getComputedStyle$1(B), nt = et.marginTop, st = et.marginRight, it = et.marginBottom, at = et.marginLeft;\n          [nt, st, it, at].some(function(ut) {\n            return parseFloat(ut);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return Y(), X.update();\n      },\n      forceUpdate: function() {\n        if (!H) {\n          var K = U.elements, Z = K.reference, J = K.popper;\n          if (!areValidElements(Z, J)) {\n             true && console.error(INVALID_ELEMENT_ERROR);\n            return;\n          }\n          U.rects = {\n            reference: getCompositeRect(Z, getOffsetParent(J), U.options.strategy === \"fixed\"),\n            popper: getLayoutRect(J)\n          }, U.reset = !1, U.placement = U.options.placement, U.orderedModifiers.forEach(function(ut) {\n            return U.modifiersData[ut.name] = Object.assign({}, ut.data);\n          });\n          for (var Q = 0, rt = 0; rt < U.orderedModifiers.length; rt++) {\n            if ( true && (Q += 1, Q > 100)) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n            if (U.reset === !0) {\n              U.reset = !1, rt = -1;\n              continue;\n            }\n            var et = U.orderedModifiers[rt], nt = et.fn, st = et.options, it = st === void 0 ? {} : st, at = et.name;\n            typeof nt == \"function\" && (U = nt({\n              state: U,\n              options: it,\n              name: at,\n              instance: X\n            }) || U);\n          }\n        }\n      },\n      update: debounce(function() {\n        return new Promise(function(q) {\n          X.forceUpdate(), q(U);\n        });\n      }),\n      destroy: function() {\n        W(), H = !0;\n      }\n    };\n    if (!areValidElements(N, B))\n      return  true && console.error(INVALID_ELEMENT_ERROR), X;\n    X.setOptions($).then(function(q) {\n      !H && $.onFirstUpdate && $.onFirstUpdate(q);\n    });\n    function Y() {\n      U.orderedModifiers.forEach(function(q) {\n        var K = q.name, Z = q.options, J = Z === void 0 ? {} : Z, Q = q.effect;\n        if (typeof Q == \"function\") {\n          var rt = Q({\n            state: U,\n            name: K,\n            instance: X,\n            options: J\n          }), et = function() {\n          };\n          V.push(rt || et);\n        }\n      });\n    }\n    function W() {\n      V.forEach(function(q) {\n        return q();\n      }), V = [];\n    }\n    return X;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\");\nvar Je, Wi, Le, vl, gl, mf, ml, _f, _l, yf, ba, xa, yl, bf, Pe, yr, _i, yi, bl, qi, Ss, xl, Sl, Ue, Sa, Ea, El, Zh, Qd, Tl, Xn, Jh, tp, wl, xf, Qh, ep, Cl, Sf, Yn, Wa, Wn, tc, rp, ec, ip, br, rc, np, ic, sp, Ta, gu, bi, qn, Kn, nc, ap, Ye;\nclass EventMng {\n  constructor(t, e, r, S, T, D, N, B, $) {\n    tt(this, gl);\n    tt(this, ml);\n    tt(this, _l);\n    tt(this, yl);\n    tt(this, qi);\n    tt(this, Zh);\n    tt(this, Jh);\n    tt(this, wl);\n    tt(this, Qh);\n    tt(this, Cl);\n    tt(this, Yn);\n    tt(this, tc);\n    tt(this, ec);\n    tt(this, rc);\n    tt(this, ic);\n    tt(this, Ta);\n    tt(this, nc);\n    tt(this, Je, new EventListenerCtn());\n    tt(this, Wi, new GamepadListener({\n      analog: !1,\n      deadZone: 0.3\n    }));\n    tt(this, Le, new FocusMng());\n    tt(this, vl, (t) => {\n    });\n    tt(this, ba, !1);\n    tt(this, xa, !1);\n    tt(this, Pe, {});\n    tt(this, yr, {});\n    tt(this, _i, !1);\n    tt(this, yi, !1);\n    tt(this, bl, (t) => z(this, Pe)[t] ?? z(this, yr)[t]);\n    tt(this, xl, () => {\n      ot(this, xl, () => {\n      }), this.scrItr.firstWait();\n    });\n    tt(this, Sl, {\n      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n    });\n    tt(this, Ue, void 0);\n    tt(this, Sa, void 0);\n    tt(this, Ea, void 0);\n    tt(this, El, {\n      placement: \"bottom\",\n      fallbackPlacements: [\"top\", \"bottom\"]\n    });\n    tt(this, Tl, (t, e) => {\n    });\n    tt(this, Xn, new EventListenerCtn());\n    tt(this, Wn, () => this.layMng.goTxt());\n    tt(this, br, () => !1);\n    tt(this, bi, () => {\n    });\n    tt(this, qn, new i$1());\n    tt(this, Kn, \"sn:notice_comp_txt\");\n    tt(this, Ye, {\n      Alt: 0,\n      Meta: 0,\n      Control: 0,\n      ArrowDown: 0,\n      End: 0,\n      Enter: 0,\n      Escape: 0,\n      \" \": 0,\n      GoBack: 0\n    });\n    var Y, W;\n    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = S, this.layMng = T, this.val = D, this.sndMng = N, this.scrItr = B, this.sys = $, e.clear_event = (q) => lt(this, Jh, tp).call(this, q), e.event = (q) => lt(this, Qh, ep).call(this, q), e.l = (q) => lt(this, tc, rp).call(this, q), e.p = (q) => lt(this, ec, ip).call(this, q), e.s = () => (this.scrItr.recodePage(), lt(this, qi, Ss).call(this, () => {\n    }, !1, !0)), e.set_cancel_skip = () => lt(this, rc, np).call(this), e.set_focus = (q) => lt(this, ic, sp).call(this, q), e.wait = (q) => lt(this, Ta, gu).call(this, q), e.waitclick = () => lt(this, nc, ap).call(this), N.setEvtMng(this), B.setOtherObj(this, T), TxtLayer.setEvtMng(S, this, $), T.setEvtMng(this), $.setFire((q, K) => this.fire(q, K)), CmnLib.isDbg) {\n      const q = {\n        pause: () => {\n          if (ot(this, _i, !0), !z(this, yi))\n            return;\n          const K = {};\n          this.scrItr.recodeDesign(K), this.sys.callHook(\"_enterDesign\", K), this.sys.send2Dbg(\"_enterDesign\", K);\n        },\n        stopOnBreakpoint: () => ot(this, _i, !0),\n        stopOnDataBreakpoint: () => ot(this, _i, !0),\n        continue: () => ot(this, _i, !1),\n        disconnect: () => ot(this, _i, !1)\n      };\n      q.attach = q.stopOnEntry = q.stopOnStep = q.stopOnStepIn = q.stopOnStepOut = q.stopOnBackstep = q.pause, $.addHook((K) => {\n        var Z;\n        return (Z = q[K]) == null ? void 0 : Z.call(q);\n      });\n    }\n    addStyle(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`);\n    for (const q of Array.from(document.getElementsByClassName(\"sn_hint\")))\n      (Y = q.parentElement) == null || Y.removeChild(q);\n    (W = Main.cvs.parentElement) == null || W.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), ot(this, Ue, document.querySelector(\".sn_hint\")), ot(this, Sa, z(this, Ue).querySelector(\"span\")), ot(this, Ea, createPopper(z(this, Sl), z(this, Ue))), z(this, Ue).hidden = !0, r.stage.interactive = !0, CmnLib.isMobile ? r.stage.on(\"pointerdown\", (q) => this.fire(\"click\", q)) : z(this, Je).add(r.stage, \"pointerdown\", (q) => {\n      switch (q.data.button) {\n        case 0:\n          this.fire(\"click\", q);\n          break;\n        case 1:\n          this.fire(\"middleclick\", q);\n          break;\n      }\n    }), z(this, Je).add(window, \"keydown\", (q) => lt(this, gl, mf).call(this, q)), z(this, Je).add(Main.cvs, \"contextmenu\", (q) => lt(this, ml, _f).call(this, q));\n    const U = (q) => {\n      CmnLib.isDarkMode = q.matches, D.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", CmnLib.isDarkMode);\n    }, V = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    U(V), z(this, Je).add(V, \"change\", (q) => {\n      U(q), this.fire(\"sn:chgDarkMode\", q);\n    }), \"WheelEvent\" in window && (z(this, Je).add(Main.cvs, \"wheel\", (q) => lt(this, _l, yf).call(this, q), { passive: !0 }), ot(this, vl, (q) => z(this, Je).add(q, \"wheel\", (K) => lt(this, _l, yf).call(this, K), { passive: !0 })), ot(this, Tl, (q, K) => q.add(Main.cvs, \"wheel\", (Z) => {\n      Z.isComposing || Z.deltaY <= 0 || (Z.stopPropagation(), K());\n    }))), CmnLib.debugLog && (z(this, Wi).on(\"gamepad:connected\", (q) => console.log(`👺<'gamepad:connected' index:${q.detail.index} id:${q.detail.gamepad.id}`)), z(this, Wi).on(\"gamepad:disconnected\", (q) => console.log(`👺<'gamepad:disconnected' index:${q.detail.index} id:${q.detail.gamepad.id}`)));\n    const H = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      \"\",\n      \"ArrowDown\",\n      \"\"\n    ], X = [0, 0];\n    z(this, Wi).on(\"gamepad:axis\", (q) => {\n      if (!document.hasFocus() || q.detail.stick !== 0)\n        return;\n      X[q.detail.axis] = q.detail.value;\n      const K = (X[1] + 1) * 3 + (X[0] + 1), Z = H[K];\n      if (!Z)\n        return;\n      const J = z(this, Le).getFocus();\n      (!J || J instanceof Container ? globalThis : J).dispatchEvent(new KeyboardEvent(\"keydown\", { key: Z, bubbles: !0 })), !(!J || J instanceof Container) && J.getAttribute(\"type\") === \"range\" && J.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n    }), z(this, Wi).on(\"gamepad:button\", (q) => {\n      if (!(!document.hasFocus() || q.detail.value === 0))\n        if (q.detail.button % 2 === 0) {\n          const K = z(this, Le).getFocus();\n          (!K || K instanceof Container ? globalThis : K).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n        } else\n          Main.cvs.dispatchEvent(new Event(\"contextmenu\"));\n    }), z(this, Wi).start(), z(this, Je).add(window, \"keyup\", (q) => {\n      q.isComposing || q.key in z(this, Ye) && (z(this, Ye)[q.key] = 0);\n    }), D.defTmp(\"const.sn.key.alternate\", () => z(this, Ye).Alt > 0), D.defTmp(\"const.sn.key.command\", () => z(this, Ye).Meta > 0), D.defTmp(\"const.sn.key.control\", () => z(this, Ye).Control > 0), D.defTmp(\"const.sn.key.end\", () => z(this, Ye).End > 0), D.defTmp(\"const.sn.key.escape\", () => z(this, Ye).Escape > 0), D.defTmp(\"const.sn.key.back\", () => z(this, Ye).GoBack > 0);\n  }\n  resvFlameEvent(t) {\n    z(this, Je).add(t, \"keydown\", (e) => lt(this, gl, mf).call(this, e)), z(this, Je).add(t, \"contextmenu\", (e) => lt(this, ml, _f).call(this, e)), z(this, vl).call(this, t);\n  }\n  destroy() {\n    z(this, Le).destroy(), z(this, Je).clear();\n  }\n  fire(t, e) {\n    var T;\n    if (z(this, br).call(this) || !z(this, yi) || z(this, _i))\n      return;\n    const r = t.toLowerCase();\n    if (CmnLib.debugLog && console.log(`👺 fire<(key:\\`${r}\\` type:${e.type} e:%o)`, { ...e }), r === \"enter\") {\n      const D = z(this, Le).getFocus();\n      if (D instanceof Container) {\n        D.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const S = z(this, bl).call(this, r);\n    if (!S) {\n      r.slice(0, 5) === \"swipe\" && globalThis.scrollBy(\n        -e.deltaX,\n        -e.deltaY\n      );\n      return;\n    }\n    r.slice(-5) !== \"wheel\" && ((T = e.preventDefault) == null || T.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== \"dom=\" && this.layMng.clickTxtLay()) && (ot(this, yi, !1), S(e));\n  }\n  popLocalEvts() {\n    const t = z(this, Pe);\n    return ot(this, Pe, {}), t;\n  }\n  pushLocalEvts(t) {\n    ot(this, Pe, t);\n  }\n  waitEvent(t, e = !0, r = !1) {\n    if (e && r)\n      throw \"canskipとglobalを同時にtrue指定できません\";\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku)\n        return t(), !1;\n      z(this, br).call(this);\n    }\n    return lt(this, qi, Ss).call(this, t, e, r);\n  }\n  unButton(t) {\n    z(this, Le).remove(t);\n  }\n  button(t, e, r, S, T) {\n    var V;\n    !t.fn && !t.label && this.main.errScript(\"fnまたはlabelは必須です\"), e.interactive = e.buttonMode = !0;\n    const D = ((V = t.key) == null ? void 0 : V.toLowerCase()) ?? \" \";\n    t.fn || (t.fn = this.scrItr.scriptFn);\n    const N = argChk_Boolean(t, \"global\", !1);\n    N ? z(this, yr)[D] = () => this.main.resumeByJumpOrCall(t) : z(this, Pe)[D] = () => this.main.resumeByJumpOrCall(t), e.on(\"pointerdown\", (H) => this.fire(D, H));\n    const B = t.hint ? () => lt(this, Zh, Qd).call(this, t, e) : () => {\n    }, $ = () => {\n      r(), z(this, Ue).hidden = !0;\n    }, U = () => (B(), S());\n    if (e.on(\"pointerover\", U), e.on(\"pointerout\", () => {\n      z(this, Le).isFocus(e) ? U() : $();\n    }), e.on(\"pointerdown\", () => {\n      z(this, Ue).hidden = !0;\n      const H = z(this, Le).getFocus();\n      T(), H instanceof Button && H.normal();\n    }), e.on(\n      \"pointerup\",\n      CmnLib.isMobile ? $ : () => {\n        z(this, Le).isFocus(e) ? U() : $();\n      }\n    ), z(this, Le).add(e, U, $), t.clickse && (this.cfg.searchPath(t.clickse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerdown\", () => {\n      const H = { fn: t.clickse, join: !1 };\n      t.clicksebuf && (H.buf = t.clicksebuf), this.hTag.playse(H);\n    })), t.enterse && (this.cfg.searchPath(t.enterse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerover\", () => {\n      const H = { fn: t.enterse, join: !1 };\n      t.entersebuf && (H.buf = t.entersebuf), this.hTag.playse(H);\n    })), t.leavese && (this.cfg.searchPath(t.leavese, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerout\", () => {\n      const H = { fn: t.leavese, join: !1 };\n      t.leavesebuf && (H.buf = t.leavesebuf), this.hTag.playse(H);\n    })), t.onenter) {\n      const H = D + t.onenter.toLowerCase(), X = { fn: t.fn, label: t.onenter, call: !0, key: H };\n      N ? z(this, yr)[H] = () => this.main.resumeByJumpOrCall(X) : z(this, Pe)[H] = () => this.main.resumeByJumpOrCall(X), e.on(\"pointerover\", (Y) => this.fire(H, Y));\n    }\n    if (t.onleave) {\n      const H = D + t.onleave.toLowerCase(), X = { fn: t.fn, label: t.onleave, call: !0, key: H };\n      N ? z(this, yr)[H] = () => this.main.resumeByJumpOrCall(X) : z(this, Pe)[H] = () => this.main.resumeByJumpOrCall(X), e.on(\"pointerout\", (Y) => this.fire(H, Y));\n    }\n  }\n  hideHint() {\n    z(this, Ue).hidden = !0;\n  }\n  cvsResize() {\n    z(this, Ue).hidden = !0;\n  }\n  waitLimitedEvent(t, e) {\n    z(this, Wn).call(this), this.val.saveKidoku();\n    const r = () => {\n      z(this, Xn).clear(), e();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n        z(this, br).call(this);\n      else\n        return r(), !1;\n    return argChk_Boolean(t, \"canskip\", !0) && (z(this, Xn).add(window, \"pointerdown\", (S) => {\n      S.stopPropagation(), r();\n    }), z(this, Xn).add(window, \"keydown\", (S) => {\n      S.isComposing || (S.stopPropagation(), r());\n    }), z(this, Tl).call(this, z(this, Xn), r)), !0;\n  }\n  noticeCompTxt() {\n    z(this, qn).emit(z(this, Kn));\n  }\n  isSkippingByKeyDown() {\n    return this.scrItr.skip4page ? !0 : Object.keys(z(this, Ye)).some((t) => z(this, Ye)[t] === 2);\n  }\n}\nJe = new WeakMap(), Wi = new WeakMap(), Le = new WeakMap(), vl = new WeakMap(), gl = new WeakSet(), mf = function(t) {\n  if (t.isComposing)\n    return;\n  t.key in z(this, Ye) && (z(this, Ye)[t.key] = t.repeat ? 2 : 1);\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + t.key;\n  this.fire(e, t);\n}, ml = new WeakSet(), _f = function(t) {\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(e, t), t.preventDefault();\n}, _l = new WeakSet(), yf = function(t) {\n  if (t.isComposing)\n    return;\n  if (z(this, ba)) {\n    ot(this, xa, !0);\n    return;\n  }\n  ot(this, ba, !0), lt(this, yl, bf).call(this);\n  const e = (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\") + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(e, t);\n}, ba = new WeakMap(), xa = new WeakMap(), yl = new WeakSet(), bf = function() {\n  setTimeout(() => {\n    if (z(this, xa)) {\n      ot(this, xa, !1), lt(this, yl, bf).call(this);\n      return;\n    }\n    ot(this, ba, !1);\n  }, 250);\n}, Pe = new WeakMap(), yr = new WeakMap(), _i = new WeakMap(), yi = new WeakMap(), bl = new WeakMap(), qi = new WeakSet(), Ss = function(t, e = !0, r = !0) {\n  if (z(this, Wn).call(this), this.val.saveKidoku(), e ? z(this, Pe).click = z(this, Pe).enter = z(this, Pe).arrowdown = z(this, Pe)[\"wheel.y>0\"] = t : (delete z(this, Pe).click, delete z(this, Pe).enter, delete z(this, Pe).arrowdown, delete z(this, Pe)[\"wheel.y>0\"]), ot(this, bl, r ? (S) => z(this, Pe)[S] ?? z(this, yr)[S] : (S) => z(this, Pe)[S]), ot(this, yi, !0), z(this, xl).call(this), CmnLib.debugLog) {\n    const S = /* @__PURE__ */ Object.create(null);\n    S.local = Object.keys(z(this, Pe)), S.global = Object.keys(z(this, yr)), console.log(\"🎍 wait event... %o\", S);\n  }\n  return !0;\n}, xl = new WeakMap(), Sl = new WeakMap(), Ue = new WeakMap(), Sa = new WeakMap(), Ea = new WeakMap(), El = new WeakMap(), Zh = new WeakSet(), Qd = function(t, e) {\n  const r = e instanceof Button ? e.getBtnBounds() : e.getBounds();\n  if (!(t[\":タグ名\"] === \"link\")) {\n    const T = e.parent.parent;\n    r.x += T.x, r.y += T.y;\n  }\n  if (!t.hint) {\n    z(this, Ue).hidden = !0;\n    return;\n  }\n  z(this, Ue).style.cssText = `position:${z(this, Ue).style.position}; transform:${z(this, Ue).style.transform};` + (t.hint_style ?? \"\"), z(this, Sa).style.cssText = \"\", z(this, Sa).textContent = t.hint ?? \"\";\n  try {\n    const T = t.hint_opt ? { ...z(this, El), ...JSON.parse(t.hint_opt) } : z(this, El);\n    z(this, Ea).setOptions(T);\n  } catch (T) {\n    console.error(mesErrJSON(t, \"hint_opt\", T.message));\n  }\n  z(this, Sl).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,\n    width: r.width,\n    height: r.height\n  }), z(this, Ea).update(), z(this, Ue).hidden = !1;\n}, Tl = new WeakMap(), Xn = new WeakMap(), Jh = new WeakSet(), tp = function(t) {\n  const e = argChk_Boolean(t, \"global\", !1), r = e ? z(this, yr) : z(this, Pe);\n  for (const [S, T] of Object.entries(r))\n    lt(this, wl, xf).call(this, S, T);\n  return e ? ot(this, yr, {}) : ot(this, Pe, {}), ot(this, yi, !1), !1;\n}, wl = new WeakSet(), xf = function(t, e) {\n  t.slice(0, 4) === \"dom=\" && lt(this, Yn, Wa).call(this, t).el.forEach((r) => r.removeEventListener(\"click\", e));\n}, Qh = new WeakSet(), ep = function(t) {\n  const e = t.key;\n  if (!e)\n    throw \"keyは必須です\";\n  const r = e.toLowerCase(), S = argChk_Boolean(t, \"call\", !1), T = argChk_Boolean(t, \"global\", !1) ? z(this, yr) : z(this, Pe);\n  if (argChk_Boolean(t, \"del\", !1)) {\n    if (t.fn || t.label || S)\n      throw \"fn/label/callとdelは同時指定できません\";\n    return lt(this, wl, xf).call(this, e, T[r]), delete T[r], !1;\n  }\n  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === \"dom=\") {\n    const D = lt(this, Yn, Wa).call(this, e);\n    if (D.el.length === 0) {\n      if (argChk_Boolean(t, \"need_err\", !0))\n        throw `HTML内にセレクタ（${D.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n      return !1;\n    }\n    let N = [\"click\", \"keydown\"];\n    switch (D.el[0].type ?? \"\") {\n      case \"checkbox\":\n        N = [\"input\"];\n        break;\n      case \"range\":\n        N = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        N = [\"input\", \"change\"];\n        break;\n    }\n    N.forEach(($, U) => D.el.forEach((V) => {\n      z(this, Je).add(V, $, (H) => {\n        if (!z(this, yi) || this.layMng.getFrmDisabled(D.id) || $ === \"keydown\" && H.key !== \"Enter\")\n          return;\n        const X = V.dataset;\n        for (const [Y, W] of Object.entries(X))\n          this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${Y}`, W);\n        this.fire(e, H);\n      }), U === 0 && z(this, Le).add(\n        V,\n        () => lt(this, Cl, Sf).call(this, V) ? (V.focus(), !0) : !1,\n        () => {\n        }\n      );\n    }));\n  }\n  return T[r] = () => this.main.resumeByJumpOrCall(t), !1;\n}, Cl = new WeakSet(), Sf = function(t) {\n  if (t.offsetParent === null)\n    return !1;\n  let e = t;\n  do {\n    if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || (e == null ? void 0 : e.disabled))\n      return !1;\n    e = e.parentElement;\n  } while (e !== null);\n  return !0;\n}, Yn = new WeakSet(), Wa = function(t) {\n  const e = t.indexOf(\":\");\n  let r = \"\";\n  if (e >= 0) {\n    const S = t.slice(4, e), T = `const.sn.frm.${S}`;\n    if (!this.val.getVal(`tmp:${T}`, 0))\n      throw `HTML【${S}】が読み込まれていません`;\n    const N = document.getElementById(S).contentWindow;\n    return r = t.slice(e + 1), { el: N.document.querySelectorAll(r), id: S, sel: r };\n  }\n  return r = t.slice(4), { el: document.querySelectorAll(r), id: \"\", sel: r };\n}, Wn = new WeakMap(), tc = new WeakSet(), rp = function(t) {\n  if (this.scrItr.skip4page)\n    return !1;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\"))\n    return z(this, Wn).call(this), !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      z(this, br).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return !1;\n  }\n  return this.val.getVal(\"tmp:sn.auto.enabled\") ? lt(this, Ta, gu).call(this, {\n    time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n  }) : (argChk_Boolean(t, \"visible\", !0) && this.layMng.breakLine(), lt(this, qi, Ss).call(this, () => this.main.resume()));\n}, ec = new WeakSet(), ip = function(t) {\n  if (this.scrItr.recodePage(), this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      z(this, br).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\")\n      return z(this, Wn).call(this), !1;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return lt(this, Ta, gu).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  argChk_Boolean(t, \"visible\", !0) && this.layMng.breakPage();\n  const e = () => {\n    this.sndMng.clearCache(), this.main.resume();\n  };\n  return lt(this, qi, Ss).call(this, argChk_Boolean(t, \"er\", !1) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(t), e();\n  } : e);\n}, br = new WeakMap(), rc = new WeakSet(), np = function() {\n  return ot(this, br, () => (ot(this, br, () => !1), this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", !0), this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", !1), this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", !1), this.layMng.setNormalChWait(), z(this, bi).call(this), !0)), !1;\n}, ic = new WeakSet(), sp = function(t) {\n  const { add: e, del: r, to: S } = t;\n  if ((e == null ? void 0 : e.slice(0, 4)) === \"dom=\") {\n    const T = lt(this, Yn, Wa).call(this, e);\n    if (T.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${T.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return T.el.forEach((D) => z(this, Le).add(\n      D,\n      () => lt(this, Cl, Sf).call(this, D) ? (D.focus(), !0) : !1,\n      () => {\n      }\n    )), !1;\n  }\n  if ((r == null ? void 0 : r.slice(0, 4)) === \"dom=\") {\n    const T = lt(this, Yn, Wa).call(this, r);\n    if (T.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${T.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return T.el.forEach((D) => z(this, Le).remove(D)), !1;\n  }\n  if (!S)\n    throw \"[set_focus] add か to は必須です\";\n  switch (S) {\n    case \"null\":\n      z(this, Le).blur();\n      break;\n    case \"next\":\n      z(this, Le).next();\n      break;\n    case \"prev\":\n      z(this, Le).prev();\n      break;\n  }\n  return !1;\n}, Ta = new WeakSet(), gu = function(t) {\n  const e = argChk_Num(t, \"time\", NaN);\n  return this.scrItr.skip4page ? !1 : this.val.getVal(\"tmp:sn.skip.enabled\") ? (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku && z(this, br).call(this), !1) : (z(this, qn).once(z(this, Kn), () => {\n    z(this, qn).off(z(this, Kn));\n    const r = new Tween({}).to({}, e).onComplete(() => {\n      ot(this, bi, () => {\n      }), r.stop(), this.main.resume();\n    }).start();\n    ot(this, bi, () => r.end());\n  }), ot(this, bi, () => {\n    ot(this, bi, () => {\n    }), z(this, qn).off(z(this, Kn));\n  }), this.waitEvent(\n    () => z(this, bi).call(this),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ));\n}, bi = new WeakMap(), qn = new WeakMap(), Kn = new WeakMap(), nc = new WeakSet(), ap = function() {\n  return this.scrItr.skip4page ? !1 : ((this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\")) && z(this, br).call(this), lt(this, qi, Ss).call(this, () => this.main.resume()));\n}, Ye = new WeakMap();\nclass CallStack {\n  constructor(t = \"\", e = 0, r = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    Rt(this, \"toString\", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);\n    this.fn = t, this.idx = e, this.csArg = r;\n  }\n}\nvar ae, oe, Vt, be, ge, xi, Pl, Ef, Zn, wa, sc, Ki, Rl, Tf, Ml, wf, Ol, Zi, Es, Jn, qa, Qn, Si, Re, ac, op, ts, Ka, oc, lp, Il, Ca, cr, lc, up, uc, hp, Ei, nn, hc, cp, es, rs, Dl, Al, Nl, fr, cc, fp, fc, dp, dc, pp, Ll, Cf, pc, vp, vc, gp, gc, mp, kl, Pf, Bl, is, Za, ns, Ti, sn, Fl, Rf, $l, Gl, Mf, mc, yc, Ul, bc, _p, Qe, xc, yp, jl, Of, Sc, Ec, Tc, bp, wc, xp, wi, zl, If, Cc, Sp, Pc, Ep, Rc, Mc, Tp, Hl, Pa, Oc, wp, Ra, mu, Ma, Ic, Cp, Ar, Dc, Pp, Oa, _u, Ac, Rp, Nr, $e;\nconst ir = class {\n  constructor(t, e, r, S, T, D, N, B, $) {\n    tt(this, Pl);\n    tt(this, Rl);\n    tt(this, Ml);\n    tt(this, Zi);\n    tt(this, Jn);\n    tt(this, ac);\n    tt(this, ts);\n    tt(this, oc);\n    tt(this, lc);\n    tt(this, uc);\n    tt(this, Ei);\n    tt(this, hc);\n    tt(this, cc);\n    tt(this, fc);\n    tt(this, dc);\n    tt(this, Ll);\n    tt(this, pc);\n    tt(this, vc);\n    tt(this, gc);\n    tt(this, kl);\n    tt(this, is);\n    tt(this, Ti);\n    tt(this, Fl);\n    tt(this, Gl);\n    tt(this, bc);\n    tt(this, xc);\n    tt(this, jl);\n    tt(this, Tc);\n    tt(this, wc);\n    tt(this, zl);\n    tt(this, Cc);\n    tt(this, Pc);\n    tt(this, Mc);\n    tt(this, Oc);\n    tt(this, Ra);\n    tt(this, Ic);\n    tt(this, Dc);\n    tt(this, Oa);\n    tt(this, Ac);\n    tt(this, ae, { aToken: [\"\"], len: 1, aLNum: [1] });\n    tt(this, oe, \"\");\n    tt(this, Vt, 0);\n    tt(this, be, 0);\n    Rt(this, \"addLineNum\", (t) => ot(this, be, z(this, be) + t));\n    tt(this, ge, []);\n    tt(this, xi, new Grammar());\n    Rt(this, \"firstWait\", () => {\n    });\n    tt(this, Zn, {\n      disconnect: () => {\n        ot(ir, Qn, {}), ot(ir, Si, {}), this.isBreak = () => !1, z(this, Zn).continue({}), ot(this, Re, 0);\n      },\n      restart: () => this.isBreak = () => !1,\n      add_break: (t) => lt(this, Pl, Ef).call(this, t.fn, t.o),\n      data_break: (t) => {\n        z(this, Re) === 0 && (ot(this, Re, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook(\"stopOnDataBreakpoint\", {}), this.sys.send2Dbg(\"stopOnDataBreakpoint\", {}));\n      },\n      set_func_break: (t) => {\n        ot(ir, Si, {});\n        for (const e of t.a)\n          z(ir, Si)[e.name] = 1;\n        this.sys.send2Dbg(t.ri, {});\n      },\n      stack: (t) => this.sys.send2Dbg(t.ri, { a: lt(this, oc, lp).call(this) }),\n      eval: (t) => {\n        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });\n      },\n      continue: () => {\n        lt(this, Jn, qa).call(this) || (ot(this, Vt, z(this, Vt) - z(this, Zi, Es)), ot(this, Re, 3), this.main.setLoop(!0), this.main.resume());\n      },\n      stepover: (t) => lt(this, Rl, Tf).call(this, t),\n      stepin: () => {\n        if (lt(this, Jn, qa).call(this))\n          return;\n        const t = z(this, ae).aToken[z(this, Vt) - z(this, Zi, Es)];\n        this.sys.callHook(`stopOnStep${z(this, Pa).test(t) ? \"In\" : \"\"}`, {}), ot(this, Vt, z(this, Vt) - z(this, Zi, Es)), ot(this, Re, z(this, Re) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();\n      },\n      stepout: (t) => {\n        lt(this, Jn, qa).call(this) || (z(this, ge).length > 0 ? lt(this, Ml, wf).call(this, !0) : lt(this, Rl, Tf).call(this, t));\n      },\n      pause: () => {\n        ot(this, Re, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        ot(this, Re, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    });\n    tt(this, wa, (t) => this.cfg.searchPath(t, SEARCH_PATH_ARG_EXT.SCRIPT));\n    tt(this, Ki, (t) => (this.sys.pathBaseCnvSnPath4Dbg + z(this, wa).call(this, t)).replace(z(ir, sc), `$1/prj/$2/${z(this, oe)}$3`));\n    Rt(this, \"cnvPath4Dbg\", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace(\"/crypto_prj/\", \"/prj/\"));\n    tt(this, Ol, 0);\n    tt(this, Re, 0);\n    Rt(this, \"isBreak\", (t) => !1);\n    tt(this, Il, (t) => {\n    });\n    tt(this, Ca, void 0);\n    tt(this, cr, void 0);\n    tt(this, es, () => {\n    });\n    tt(this, rs, () => {\n    });\n    tt(this, Dl, \"\");\n    tt(this, Al, {});\n    Rt(this, \"noticeBreak\", (t) => {\n    });\n    tt(this, Nl, 5);\n    tt(this, fr, [-1]);\n    tt(this, Bl, \"\");\n    tt(this, ns, \"\");\n    Rt(this, \"nextToken\", () => \"\");\n    tt(this, $l, (t) => {\n    });\n    tt(this, mc, /(\\*{2,})([^\\|]*)/);\n    tt(this, yc, /\\[macro\\s/);\n    tt(this, Ul, /\\[endmacro[\\s\\]]/);\n    tt(this, Qe, /* @__PURE__ */ Object.create(null));\n    tt(this, Sc, /^\\[(call|loadplugin)\\s/);\n    tt(this, Ec, /\\bfn\\s*=\\s*[^\\s\\]]+/);\n    tt(this, wi, !1);\n    tt(this, Rc, new RegExp(`[\"'#;\\\\]　]+`));\n    tt(this, Hl, \"call\");\n    tt(this, Pa, /\\[(call)\\b/);\n    tt(this, Ma, !1);\n    tt(this, Ar, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    });\n    tt(this, Nr, []);\n    tt(this, $e, -1);\n    this.cfg = t, this.hTag = e, this.main = r, this.val = S, this.alzTagArg = T, this.runAnalyze = D, this.prpPrs = N, this.sndMng = B, this.sys = $, e.let_ml = (V) => lt(this, lc, up).call(this, V), e.dump_stack = () => lt(this, uc, hp).call(this), e.dump_script = (V) => lt(this, hc, cp).call(this, V), e.else = e.elsif = e.endif = () => lt(this, cc, fp).call(this), e.if = (V) => lt(this, fc, dp).call(this, V), e.call = (V) => lt(this, dc, pp).call(this, V), e.jump = (V) => lt(this, pc, vp).call(this, V), e.page = (V) => lt(this, vc, gp).call(this, V), e.pop_stack = (V) => lt(this, gc, mp).call(this, V), e.return = (V) => lt(this, kl, Pf).call(this, V), e.bracket2macro = (V) => lt(this, Cc, Sp).call(this, V), e.char2macro = (V) => lt(this, Pc, Ep).call(this, V), e.endmacro = (V) => lt(this, kl, Pf).call(this, V), e.macro = (V) => lt(this, Mc, Tp).call(this, V), e.load = (V) => lt(this, Oc, wp).call(this, V), e.reload_script = (V) => lt(this, Ic, Cp).call(this, V), e.record_place = () => lt(this, Dc, Pp).call(this), e.save = (V) => lt(this, Ac, Rp).call(this, V), t.oCfg.debug.token && ot(this, $l, (V) => console.log(`🌱 トークン fn:${z(this, oe)} idx:${z(this, Vt)} ln:${z(this, be)} token【${V}】`)), S.defTmp(\"const.sn.vctCallStk.length\", () => z(this, ge).length);\n    const U = t.oCfg.init.escape;\n    if (z(this, xi).setEscape(U), RubySpliter.setEscape(U), CmnLib.isDbg) {\n      $.addHook((H, X) => {\n        var Y, W;\n        return (W = (Y = z(this, Zn))[H]) == null ? void 0 : W.call(Y, X);\n      }), this.isBreak = lt(this, ac, op);\n      const V = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        }, this.sys.send2Dbg(\"hi\", {});\n      }, z(this, Zn).auth = (H) => {\n        const X = H.hBreakpoint.hFn2hLineBP;\n        for (const [Y, W] of Object.entries(X))\n          lt(this, Pl, Ef).call(this, Y, W);\n        ot(ir, Si, {});\n        for (const Y of H.hBreakpoint.aFunc)\n          z(ir, Si)[Y.name] = 1;\n        if (H.stopOnEntry) {\n          for (; ; ) {\n            let Y = this.nextToken();\n            if (!Y)\n              break;\n            const W = Y.charCodeAt(0);\n            if (W === 91 || W === 38 || W === 42 && Y.length === 1)\n              break;\n            W === 10 && ot(this, be, z(this, be) + Y.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {}), this.analyzeInit = V, this.analyzeInit();\n        } else\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          }, this.analyzeInit = V, this.analyzeInit();\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    t.oCfg.debug.tag && ot(this, Il, (V) => console.log(`🌲 タグ解析 fn:${z(this, oe)} idx:${z(this, Vt)} ln:${z(this, be)} [${V} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return z(this, oe);\n  }\n  subIdxToken() {\n    --Me(this, Vt)._;\n  }\n  get lineNum() {\n    return z(this, be);\n  }\n  destroy() {\n    this.isBreak = () => !1;\n  }\n  タグ解析(t) {\n    const [e, r] = tagToken2Name_Args(t), S = this.hTag[e];\n    if (!S)\n      throw `未定義のタグ【${e}】です`;\n    this.alzTagArg.parse(r), z(this, Il).call(this, e);\n    const T = this.alzTagArg.hPrm;\n    if (T.cond) {\n      const B = T.cond.val;\n      if (!B || B.at(0) === \"&\")\n        throw \"属性condは「&」が不要です\";\n      const $ = this.prpPrs.parse(B), U = String($);\n      if (U === \"null\" || U === \"undefined\" || !$)\n        return !1;\n    }\n    let D = {};\n    const N = z(this, ge).length;\n    if (this.alzTagArg.isKomeParam) {\n      if (N === 0)\n        throw \"属性「*」はマクロのみ有効です\";\n      D = { ...z(this, ge)[z(this, ge).length - 1].csArg };\n    }\n    D[\":タグ名\"] = e;\n    for (const [B, { val: $, def: U }] of Object.entries(T)) {\n      let V = $;\n      if ((V == null ? void 0 : V.at(0)) === \"%\") {\n        if (N === 0)\n          throw \"属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）\";\n        const H = z(this, ge)[z(this, ge).length - 1].csArg[V.slice(1)];\n        if (H) {\n          D[B] = H;\n          continue;\n        }\n        if (U === void 0 || U === \"null\")\n          continue;\n        V = U;\n      }\n      if (V = this.prpPrs.getValAmpersand(V ?? \"\"), V !== \"undefined\") {\n        D[B] = V;\n        continue;\n      }\n      U !== void 0 && (V = this.prpPrs.getValAmpersand(U), V !== \"undefined\" && (D[B] = V));\n    }\n    return S(D);\n  }\n  setOtherObj(t, e) {\n    ot(this, Ca, t), ot(this, cr, e);\n  }\n  dumpErrForeLine() {\n    if (z(this, Vt) === 0) {\n      console.group(`🥟 Error line (from 0 rows before) fn:${z(this, oe)}`), console.groupEnd();\n      return;\n    }\n    let t = \"\";\n    for (let D = z(this, Vt) - 1; D >= 0 && (t = z(this, ae).aToken[D] + t, !((t.match(/\\n/g) ?? []).length >= z(this, Nl))); --D)\n      ;\n    const e = t.split(`\n`).slice(-z(this, Nl)), r = e.length;\n    console.group(`🥟 Error line (from ${r} rows before) fn:${z(this, oe)}`);\n    const S = String(z(this, be)).length, T = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt));\n    for (let D = 0; D < r; ++D) {\n      const N = z(this, be) - r + D + 1, B = `${String(N).padStart(S, \" \")}: %c`, $ = e[D], U = $.length > 75 ? $.slice(0, 75) + \"…\" : $;\n      D === r - 1 ? console.info(\n        B + U.slice(0, T.col_s) + \"%c\" + U.slice(T.col_s),\n        \"color: black; background-color: skyblue;\",\n        \"color: black; background-color: pink;\"\n      ) : console.info(B + U, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const t = lt(this, bc, _p).call(this, z(this, ae), Boolean(this.val.getVal(\"mp:const.sn.macro.name\")), z(this, be), z(this, ns), z(this, Vt));\n    ot(this, Vt, t.idx), ot(this, be, t.ln), this.runAnalyze();\n  }\n  get isKidoku() {\n    return z(this, wi);\n  }\n  get isNextKidoku() {\n    let t = z(this, oe), e = z(this, Vt), r = z(this, ae).len;\n    if (z(this, ge).length > 0) {\n      const T = z(this, ge)[0];\n      t = T.fn, e = T.idx;\n      const D = z(this, Qe)[t];\n      D && (r = D.len);\n    }\n    const S = this.val.getAreaKidoku(t);\n    return !S || e === r ? !1 : S.search(e);\n  }\n  get normalWait() {\n    return z(this, wi) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return z(this, Ma);\n  }\n  recodePage() {\n    if (ot(this, Ma, !1), !this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: t, idx: e } = lt(this, Oa, _u).call(this), r = e - 1, S = r + \":\" + t, T = z(this, Nr).findIndex((N) => N.key === S);\n    if (T > -1) {\n      ot(this, $e, T);\n      return;\n    }\n    const D = {\n      key: S,\n      fn: t,\n      idx: r,\n      retFn: t,\n      retIdx: 0,\n      retMark: { ...z(this, Ar) }\n    };\n    if (z(this, $e) >= 0) {\n      const N = z(this, Nr)[z(this, $e)];\n      D.retFn = N.fn, D.retIdx = N.idx + 1;\n    }\n    ++Me(this, $e)._ === z(this, Nr).length ? z(this, Nr).push(D) : z(this, Nr)[z(this, $e)] = D;\n  }\n  recodeDesign(t) {\n    let e = \"\", r = 0;\n    const S = z(this, ge).length;\n    if (t.design_unit && S > 0) {\n      const N = z(this, ge)[0];\n      e = N.fn, r = N.idx;\n    } else\n      e = z(this, oe), r = z(this, Vt);\n    t[\":path\"] = z(this, Ki).call(this, e);\n    const T = lt(this, Ei, nn).call(this, z(this, Qe)[e], r);\n    t[\":ln\"] = T.ln, t[\":col_s\"] = T.col_s, t[\":col_e\"] = T.col_e;\n    const D = r - 1;\n    t[\":idx_tkn\"] = D, t[\":token\"] = z(this, Qe)[e].aToken[D], this.sys.send2Dbg(\"_recodeDesign\", t);\n  }\n  replace(t, e) {\n    z(this, ae).aToken[t] = e;\n  }\n};\nlet ScriptIterator = ir;\nae = new WeakMap(), oe = new WeakMap(), Vt = new WeakMap(), be = new WeakMap(), ge = new WeakMap(), xi = new WeakMap(), Pl = new WeakSet(), Ef = function(t, e) {\n  z(ir, Qn)[z(this, Ki).call(this, t)] = e;\n}, Zn = new WeakMap(), wa = new WeakMap(), sc = new WeakMap(), Ki = new WeakMap(), Rl = new WeakSet(), Tf = function(t) {\n  if (lt(this, Jn, qa).call(this))\n    return;\n  const e = z(this, ae).aToken[z(this, Vt) - z(this, Zi, Es)];\n  z(this, Pa).test(e) ? lt(this, Ml, wf).call(this, !1) : (this.sys.callHook(\"stopOnStep\", {}), z(this, Zn).stepin(t));\n}, Ml = new WeakSet(), wf = function(t) {\n  this.sys.callHook(`stopOnStep${t ? \"Out\" : \"\"}`, {}), ot(this, Ol, z(this, ge).length - (t ? 1 : 0)), ot(this, Vt, z(this, Vt) - z(this, Zi, Es)), ot(this, Re, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();\n}, Ol = new WeakMap(), Zi = new WeakSet(), Es = function() {\n  return z(this, Re) === 2 || z(this, Re) === 4 ? 1 : 0;\n}, Jn = new WeakSet(), qa = function() {\n  return z(this, Vt) < z(this, ae).len ? !1 : (this.sys.callHook(\"stopOnEntry\", {}), this.main.setLoop(!1, \"スクリプト終端です\"), !0);\n}, Qn = new WeakMap(), Si = new WeakMap(), Re = new WeakMap(), ac = new WeakSet(), op = function(t) {\n  switch (z(this, Re)) {\n    case 6:\n      lt(this, ts, Ka).call(this), ot(this, Re, 7);\n      break;\n    case 7:\n      if (z(this, ge).length !== z(this, Ol))\n        break;\n      return ot(this, Re, 4), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 5:\n      lt(this, ts, Ka).call(this), ot(this, Re, 4);\n      break;\n    case 4:\n      return lt(this, ts, Ka).call(this), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 3:\n      lt(this, ts, Ka).call(this), ot(this, Re, 0);\n      break;\n    default:\n      if (tagToken2Name(t) in z(ir, Si))\n        return ot(this, Re, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook(\"stopOnBreakpoint\", {}), this.sys.send2Dbg(\"stopOnBreakpoint\", {}), !0;\n      {\n        const e = z(ir, Qn)[z(this, Ki).call(this, z(this, oe))];\n        if (!e)\n          break;\n        const r = e[z(this, be)];\n        if (!r)\n          break;\n        if (r.condition) {\n          if (!this.prpPrs.parse(r.condition))\n            break;\n        } else if (\"hitCondition\" in r && --r.hitCondition > 0)\n          break;\n        const S = z(this, Re) === 0;\n        ot(this, Re, 2), this.main.setLoop(!1, S ? (r.condition ? \"条件\" : \"ヒットカウント\") + \"ブレーク\" : \"ステップ実行\");\n        const T = S ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(T, {}), this.sys.send2Dbg(T, {});\n      }\n      return !0;\n  }\n  return !1;\n}, ts = new WeakSet(), Ka = function() {\n  var e;\n  const t = (e = z(ir, Qn)[getFn(z(this, oe))]) == null ? void 0 : e[z(this, be)];\n  t != null && t.hitCondition && --t.hitCondition;\n}, oc = new WeakSet(), lp = function() {\n  const t = z(this, Re) === 3 ? 1 : 0, e = z(this, ae).aToken[z(this, Vt) - 1 + t], r = z(this, Ki).call(this, z(this, oe)), S = tagToken2Name(e), T = S ? `[${S}]` : e, D = this.val.getVal(\"mp:const.sn.macro\") ?? \"{}\";\n  if (z(this, Vt) === 0)\n    return [{ fn: r, ln: 1, col: 1, nm: T, ma: D }];\n  const N = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt)), B = [{ fn: r, ln: N.ln, col: N.col_s + 1, nm: T, ma: D }], $ = z(this, ge).length;\n  if ($ === 0)\n    return B;\n  for (let U = $ - 1; U >= 0; --U) {\n    const V = z(this, ge)[U], H = z(this, Qe)[V.fn], X = H.aToken[V.idx - 1], Y = lt(this, Ei, nn).call(this, H, V.idx), W = tagToken2Name(X);\n    B.push({\n      fn: z(this, Ki).call(this, V.fn),\n      ln: Y.ln,\n      col: Y.col_s + 1,\n      nm: W ? `[${W}]` : X,\n      ma: V.csArg[\":hMp\"][\"const.sn.macro\"] ?? \"{}\"\n    });\n  }\n  return B;\n}, Il = new WeakMap(), Ca = new WeakMap(), cr = new WeakMap(), lc = new WeakSet(), up = function(t) {\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  let r = \"\";\n  const S = z(this, ae).len;\n  for (; z(this, Vt) < S && (r = z(this, ae).aToken[z(this, Vt)], r === \"\"); ++Me(this, Vt)._)\n    ;\n  return t.text = r, t.cast = \"str\", this.hTag.let(t), ot(this, Vt, z(this, Vt) + 2), ot(this, be, z(this, be) + (r.match(/\\n/g) ?? []).length), !1;\n}, uc = new WeakSet(), hp = function() {\n  if (z(this, Vt) === 0)\n    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${z(this, oe)} line:${1} col:${0}`), console.groupEnd(), !1;\n  const t = lt(this, Ei, nn).call(this, z(this, ae), z(this, Vt)), e = `スクリプト現在地 fn:${z(this, oe)} line:${t.ln} col:${t.col_s + 1}`;\n  console.group(`🥟 [dump_stack] ${e}`);\n  const r = z(this, ge).length;\n  if (r > 0) {\n    console.info(e);\n    for (let S = r - 1; S >= 0; --S) {\n      const T = z(this, ge)[S], D = T.csArg[\":hMp\"], N = D ? D[\":タグ名\"] : void 0, B = T.csArg[\":タグ名\"] ?? \"\", $ = lt(this, Ei, nn).call(this, z(this, Qe)[T.fn], T.idx);\n      console.info(\n        `${r - S}つ前のコール元 fn:${T.fn} line:${$.ln} col:${$.col_s + 1}` + (N ? \"（[\" + N + \"]マクロ内）\" : \" \") + `で [${B} ...]をコール`\n      );\n    }\n  }\n  return console.groupEnd(), !1;\n}, Ei = new WeakSet(), nn = function(t, e) {\n  const r = { ln: 1, col_s: 0, col_e: 0 };\n  if (!t)\n    return r;\n  let S = e - 1;\n  const T = r.ln = t.aLNum[S];\n  for (; t.aLNum[S] === T; ) {\n    if (t.aToken[S].at(0) !== `\n`) {\n      const D = t.aToken[S].length;\n      r.col_e > 0 && (r.col_s += D), r.col_e += D;\n    }\n    if (--S < 0)\n      break;\n  }\n  return r;\n}, hc = new WeakSet(), cp = function(t) {\n  const { set_fnc: e, break_fnc: r } = t;\n  if (!e)\n    throw \"set_fncは必須です\";\n  if (ot(this, es, globalThis[e]), !z(this, es)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内に関数${e}が見つかりません`;\n    return ot(this, es, () => {\n    }), !1;\n  }\n  if (this.noticeBreak = (S) => {\n    z(this, Dl) !== z(this, oe) && (ot(this, Dl, z(this, oe)), z(this, es).call(this, z(this, Al)[z(this, oe)] = z(this, Al)[z(this, oe)] ?? z(this, ae).aToken.join(\"\"))), z(this, rs).call(this, z(this, be), S);\n  }, this.noticeBreak(!0), !r)\n    return !1;\n  if (ot(this, rs, globalThis[r]), !z(this, rs)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内に関数${r}が見つかりません`;\n    ot(this, rs, () => {\n    });\n  }\n  return !1;\n}, es = new WeakMap(), rs = new WeakMap(), Dl = new WeakMap(), Al = new WeakMap(), Nl = new WeakMap(), fr = new WeakMap(), cc = new WeakSet(), fp = function() {\n  if (z(this, fr)[0] === -1)\n    throw \"ifブロック内ではありません\";\n  return ot(this, Vt, z(this, fr)[0]), z(this, fr).shift(), !1;\n}, fc = new WeakSet(), dp = function(t) {\n  const { exp: e } = t;\n  if (!e)\n    throw \"expは必須です\";\n  if (e.at(0) === \"&\")\n    throw \"属性expは「&」が不要です\";\n  let r = 0, S = this.prpPrs.parse(e) ? z(this, Vt) : -1;\n  const T = z(this, ae).aLNum[z(this, Vt)];\n  let D = z(this, be) - (T || 0);\n  const N = z(this, ae).len;\n  for (; z(this, Vt) < N; ++Me(this, Vt)._) {\n    const B = z(this, ae).aLNum[z(this, Vt)];\n    z(this, ae).aLNum[z(this, Vt)] = (B || 0) + D;\n    const $ = z(this, ae).aToken[z(this, Vt)];\n    if (!$)\n      continue;\n    const U = $.charCodeAt(0);\n    if (U === 10) {\n      ot(this, be, z(this, be) + $.length);\n      continue;\n    }\n    if (U !== 91)\n      continue;\n    const [V, H] = tagToken2Name_Args($);\n    if (!(V in this.hTag))\n      throw `未定義のタグ[${V}]です`;\n    switch (this.alzTagArg.parse(H), V) {\n      case \"if\":\n        ++r;\n        break;\n      case \"elsif\":\n        if (r > 0 || S > -1)\n          break;\n        const X = this.alzTagArg.hPrm.exp.val;\n        if (X.at(0) === \"&\")\n          throw \"属性expは「&」が不要です\";\n        this.prpPrs.parse(X) && (S = z(this, Vt) + 1);\n        break;\n      case \"else\":\n        if (r > 0)\n          break;\n        S === -1 && (S = z(this, Vt) + 1);\n        break;\n      case \"endif\":\n        if (r > 0) {\n          --r;\n          break;\n        }\n        return S === -1 ? (++Me(this, Vt)._, z(this, ae).aLNum[z(this, Vt)] += D) : (z(this, fr).unshift(z(this, Vt) + 1), ot(this, Vt, S), ot(this, be, z(this, ae).aLNum[z(this, Vt)])), !1;\n    }\n  }\n  throw \"[endif]がないままスクリプト終端です\";\n}, dc = new WeakSet(), pp = function(t) {\n  argChk_Boolean(t, \"count\", !1) || lt(this, zl, If).call(this);\n  const { fn: e } = t;\n  return e && z(this, wa).call(this, e), lt(this, Ll, Cf).call(this, { \":hEvt1Time\": z(this, Ca).popLocalEvts(), \":hMp\": this.val.cloneMp() }), argChk_Boolean(t, \"clear_local_event\", !1) && this.hTag.clear_event({}), lt(this, Ti, sn).call(this, e, t.label), !0;\n}, Ll = new WeakSet(), Cf = function(t) {\n  z(this, ae).aLNum[z(this, Vt)] = z(this, be), z(this, Bl) || (t[\":resvToken\"] = \"\", lt(this, is, Za).call(this)), z(this, ge).push(new CallStack(z(this, oe), z(this, Vt), t)), z(this, fr).unshift(-1);\n}, pc = new WeakSet(), vp = function(t) {\n  return argChk_Boolean(t, \"count\", !0) || lt(this, zl, If).call(this), z(this, fr)[0] = -1, lt(this, Ti, sn).call(this, t.fn, t.label), !0;\n}, vc = new WeakSet(), gp = function(t) {\n  if (z(this, $e) === -1)\n    return !1;\n  if (argChk_Boolean(t, \"clear\", !1))\n    return ot(this, Nr, []), ot(this, $e, -1), !1;\n  const { to: e } = t;\n  if (!e)\n    throw \"clearかtoは必須です\";\n  const r = z(this, $e);\n  switch (e) {\n    case \"prev\":\n      z(this, $e) > 0 && --Me(this, $e)._;\n      break;\n    case \"next\":\n      const N = z(this, Nr).length;\n      z(this, $e) < N - 1 && ++Me(this, $e)._;\n      break;\n    default:\n      throw `属性to「${e}」は異常です`;\n  }\n  if (r === z(this, $e))\n    return !1;\n  const S = z(this, Nr)[z(this, $e)], { fn: T, idx: D } = lt(this, Oa, _u).call(this);\n  return S.key === D + \":\" + T ? !1 : lt(this, Ra, mu).call(this, { fn: S.retFn, index: S.retIdx }, S.retMark);\n}, gc = new WeakSet(), mp = function(t) {\n  if (argChk_Boolean(t, \"clear\", !1))\n    ot(this, ge, []);\n  else if (!z(this, ge).pop())\n    throw \"[pop_stack] スタックが空です\";\n  return lt(this, is, Za).call(this), ot(this, fr, [-1]), this.val.setMp({}), !1;\n}, kl = new WeakSet(), Pf = function(t) {\n  const e = z(this, ge).pop();\n  if (!e)\n    throw \"[return] スタックが空です\";\n  const r = e.csArg;\n  z(this, fr).shift();\n  const S = r[\":hMp\"];\n  S && this.val.setMp(S);\n  const T = r[\":resvToken\"];\n  T ? this.nextToken = () => (lt(this, is, Za).call(this), T) : lt(this, is, Za).call(this), r[\":hEvt1Time\"] && z(this, Ca).pushLocalEvts(r[\":hEvt1Time\"]);\n  const { fn: D, label: N } = t;\n  return D || N ? (lt(this, Ti, sn).call(this, D, N), !0) : e.fn in z(this, Qe) ? (lt(this, jl, Of).call(this, e), !1) : (lt(this, Ti, sn).call(this, e.fn, \"\", e.idx), !0);\n}, Bl = new WeakMap(), is = new WeakSet(), Za = function() {\n  ot(this, Bl, \"\"), this.nextToken = lt(this, Fl, Rf);\n}, ns = new WeakMap(), Ti = new WeakSet(), sn = function(t = \"\", e = \"\", r = 0) {\n  if (!t && !e && this.main.errScript(\"[jump系] fnまたはlabelは必須です\"), e ? (e.at(0) !== \"*\" && this.main.errScript(\"[jump系] labelは*で始まります\"), ot(this, ns, e), z(this, ns).slice(0, 2) !== \"**\" && ot(this, Vt, r)) : (ot(this, ns, \"\"), ot(this, Vt, r)), !t) {\n    this.analyzeInit();\n    return;\n  }\n  const S = z(this, wa).call(this, t);\n  if (t === z(this, oe)) {\n    this.analyzeInit();\n    return;\n  }\n  ot(this, oe, t);\n  const T = z(this, Qe)[z(this, oe)];\n  if (T) {\n    ot(this, ae, T), this.analyzeInit();\n    return;\n  }\n  new Loader().add({ name: z(this, oe), url: S }).use((D, N) => {\n    try {\n      D.data = this.sys.decStr(D.extension, D.data);\n    } catch (B) {\n      this.main.errScript(`[jump系]snロード失敗です fn:${D.name} ${B}`, !1);\n    }\n    N == null || N();\n  }).load((D, N) => {\n    this.nextToken = lt(this, Fl, Rf), ot(this, be, 1), lt(this, xc, yp).call(this, N[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());\n  }), this.main.stop();\n}, Fl = new WeakSet(), Rf = function() {\n  var e, r;\n  if (lt(this, Gl, Mf).call(this))\n    return \"\";\n  lt(this, wc, xp).call(this), (e = z(this, ae).aLNum)[r = z(this, Vt)] || (e[r] = z(this, be));\n  const t = z(this, ae).aToken[z(this, Vt)];\n  return z(this, $l).call(this, t), ++Me(this, Vt)._, t;\n}, $l = new WeakMap(), Gl = new WeakSet(), Mf = function() {\n  return z(this, Vt) < z(this, ae).len ? !1 : (this.main.errScript(\"スクリプト終端です\"), !0);\n}, mc = new WeakMap(), yc = new WeakMap(), Ul = new WeakMap(), bc = new WeakSet(), _p = function(t, e, r, S, T) {\n  var U, V;\n  const D = t.aToken.length;\n  if (!S) {\n    if (lt(this, Gl, Mf).call(this))\n      return { idx: T, ln: r };\n    if (t.aLNum[T])\n      r = t.aLNum[T];\n    else {\n      r = 1;\n      for (let H = 0; H < T; ++H) {\n        (U = t.aLNum)[H] || (U[H] = r);\n        const X = t.aToken[H];\n        X.charCodeAt(0) === 10 ? r += X.length : r += (X.match(/\\n/g) ?? []).length;\n      }\n      t.aLNum[T] = r;\n    }\n    return { idx: T, ln: r };\n  }\n  t.aLNum[0] = 1;\n  const N = S.match(z(this, mc));\n  if (N) {\n    S = N[1];\n    let H = T;\n    switch (N[2]) {\n      case \"before\":\n        for (; t.aToken[--H] !== S; )\n          H === 0 && DebugMng.myTrace(\"[jump系 無名ラベルbefore] \" + r + \"行目以前で\" + (e ? \"マクロ内に\" : \"\") + \"ラベル【\" + S + \"】がありません\", \"ET\"), e && t.aToken[H].search(z(this, yc)) > -1 && DebugMng.myTrace(\"[jump系 無名ラベルbefore] マクロ内にラベル【\" + S + \"】がありません\", \"ET\");\n        return { idx: H + 1, ln: t.aLNum[H] };\n      case \"after\":\n        for (; t.aToken[++H] !== S; )\n          H === D && DebugMng.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + S + \"】がありません\", \"ET\"), t.aToken[H].search(z(this, Ul)) > -1 && DebugMng.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + S + \"】がありません\", \"ET\");\n        return { idx: H + 1, ln: t.aLNum[H] };\n      default:\n        DebugMng.myTrace(\"[jump系] 無名ラベル指定【label=\" + S + \"】が間違っています\", \"ET\");\n    }\n  }\n  r = 1;\n  const B = new RegExp(\n    \"^\" + S.replaceAll(\"*\", \"\\\\*\") + \"(?=\\\\s|;|\\\\[|\\\\||$)\"\n  );\n  let $ = !1;\n  for (let H = 0; H < D; ++H) {\n    (V = t.aLNum)[H] || (V[H] = r);\n    const X = t.aToken[H];\n    if ($) {\n      z(this, xi).testTagEndLetml(X) ? $ = !1 : r += (X.match(/\\n/g) ?? []).length;\n      continue;\n    }\n    const Y = X.charCodeAt(0);\n    if (Y === 10) {\n      r += X.length;\n      continue;\n    }\n    if (Y === 42) {\n      if (X.search(B) > -1)\n        return { idx: H + 1, ln: r };\n      continue;\n    }\n    Y === 91 && (r += (X.match(/\\n/g) ?? []).length, z(this, xi).testTagLetml(X) && ($ = !0));\n  }\n  throw $ ? \"[let_ml]の終端・[endlet_ml]がありません\" : (DebugMng.myTrace(`[jump系] ラベル【${S}】がありません`, \"ET\"), \"Dummy\");\n}, Qe = new WeakMap(), xc = new WeakSet(), yp = function(t) {\n  let e = \"\";\n  try {\n    e = \"ScriptIterator.resolveScript\";\n    const r = z(this, xi).resolveScript(t);\n    e = \"ScriptIterator.replaceScript_Wildcard\", lt(this, Tc, bp).call(this, r), z(this, Qe)[z(this, oe)] = ot(this, ae, r);\n  } catch (r) {\n    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);\n  }\n  this.val.loadScrWork(z(this, oe));\n}, jl = new WeakSet(), Of = function(t) {\n  ot(this, oe, t.fn), ot(this, Vt, t.idx);\n  const e = z(this, Qe)[z(this, oe)];\n  e && ot(this, ae, e), ot(this, be, z(this, ae).aLNum[t.idx]);\n}, Sc = new WeakMap(), Ec = new WeakMap(), Tc = new WeakSet(), bp = function(t) {\n  for (let e = t.len - 1; e >= 0; --e) {\n    const r = t.aToken[e];\n    if (!z(this, Sc).test(r))\n      continue;\n    const [S, T] = tagToken2Name_Args(r);\n    this.alzTagArg.parse(T);\n    const D = this.alzTagArg.hPrm.fn;\n    if (!D)\n      continue;\n    const { val: N } = D;\n    if (!N || N.slice(-1) !== \"*\")\n      continue;\n    t.aToken.splice(e, 1, \"\t\", \"; \" + r), t.aLNum.splice(e, 1, NaN, NaN);\n    const B = S === \"loadplugin\" ? SEARCH_PATH_ARG_EXT.CSS : SEARCH_PATH_ARG_EXT.SN, $ = this.cfg.matchPath(\"^\" + N.slice(0, -1) + \".*\", B);\n    for (const U of $) {\n      const V = r.replace(\n        z(this, Ec),\n        \"fn=\" + decodeURIComponent(getFn(U[B]))\n      );\n      t.aToken.splice(e, 0, V), t.aLNum.splice(e, 0, NaN);\n    }\n  }\n  t.len = t.aToken.length;\n}, wc = new WeakSet(), xp = function() {\n  const t = this.val.getAreaKidoku(z(this, oe));\n  if (!t)\n    throw `recordKidoku fn:'${z(this, oe)}' (areas === null)`;\n  if (z(this, ge).length > 0) {\n    t.record(z(this, Vt));\n    return;\n  }\n  ot(this, wi, t.search(z(this, Vt))), this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", z(this, wi)), !z(this, wi) && t.record(z(this, Vt));\n}, wi = new WeakMap(), zl = new WeakSet(), If = function() {\n  var t;\n  (t = this.val.getAreaKidoku(z(this, oe))) == null || t.erase(z(this, Vt)), ot(this, wi, !1);\n}, Cc = new WeakSet(), Sp = function(t) {\n  return z(this, xi).bracket2macro(t, this.hTag, z(this, ae), z(this, Vt)), !1;\n}, Pc = new WeakSet(), Ep = function(t) {\n  return z(this, xi).char2macro(t, this.hTag, z(this, ae), z(this, Vt)), !1;\n}, Rc = new WeakMap(), Mc = new WeakSet(), Tp = function(t) {\n  var T, D;\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  if (e in this.hTag)\n    throw `[${e}]はタグかすでに定義済みのマクロです`;\n  if (z(this, Rc).test(e))\n    throw `[${e}]はマクロ名として異常です`;\n  const r = z(this, be), S = new CallStack(z(this, oe), z(this, Vt));\n  for (ot(this, Hl, z(this, Hl) + (\"|\" + e)), ot(this, Pa, new RegExp(`\\\\[(${z(this, Hl)})\\\\b`)), this.hTag[e] = (N) => (N.design_unit = t.design_unit, lt(this, Ll, Cf).call(this, { ...N, \":hMp\": this.val.cloneMp() }), this.val.setMp(N), this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(t)), this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", z(this, oe)), ot(this, be, r), lt(this, jl, Of).call(this, S), !1); z(this, Vt) < z(this, ae).len; ++Me(this, Vt)._) {\n    (T = z(this, ae).aLNum)[D = z(this, Vt)] || (T[D] = z(this, be));\n    const N = z(this, ae).aToken[z(this, Vt)];\n    if (N.search(z(this, Ul)) > -1)\n      return ++Me(this, Vt)._, !1;\n    const B = N.charCodeAt(0);\n    B === 10 ? ot(this, be, z(this, be) + N.length) : B === 91 && ot(this, be, z(this, be) + (N.match(/\\n/g) ?? []).length);\n  }\n  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;\n}, Hl = new WeakMap(), Pa = new WeakMap(), Oc = new WeakSet(), wp = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  if (\"fn\" in t != \"label\" in t)\n    throw \"fnとlabelはセットで指定して下さい\";\n  const r = this.val.getMark(e);\n  if (!r)\n    throw `place【${e}】は存在しません`;\n  return lt(this, Ra, mu).call(this, t, r);\n}, Ra = new WeakSet(), mu = function(t, e, r = !0) {\n  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), z(this, cr).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, \"do_rec\", !0) && ot(this, Ar, {\n    hSave: this.val.cloneSave(),\n    hPages: { ...e.hPages },\n    aIfStk: [...e.aIfStk]\n  });\n  const S = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(S);\n  const T = String(this.val.getVal(\"save:const.sn.scriptFn\")), D = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  return ot(this, fr, [...z(this, Ar).aIfStk]), ot(this, ge, []), z(this, cr).cover(!0), z(this, cr).stopAllTw(), \"index\" in t ? (z(this, cr).playback(z(this, Ar).hPages, () => {\n    z(this, cr).cover(!1), ot(this, Ma, !0), lt(this, Ti, sn).call(this, t.fn ?? T, \"\", t.index ?? D);\n  }), !0) : (delete z(this, Qe)[T], z(this, cr).playback(\n    z(this, Ar).hPages,\n    \"label\" in t ? () => {\n      z(this, cr).cover(!1), ot(this, oe, T), ot(this, Vt, D), this.hTag.call({ fn: t.fn, label: t.label });\n    } : () => {\n      z(this, cr).cover(!1), lt(this, Ti, sn).call(this, T, \"\", D);\n    }\n  ), !0);\n}, Ma = new WeakMap(), Ic = new WeakSet(), Cp = function(t) {\n  const e = this.val.getMark(0);\n  return delete z(this, Qe)[getFn(e.hSave[\"const.sn.scriptFn\"])], t.do_rec = !1, lt(this, Ra, mu).call(this, t, e, !1);\n}, Ar = new WeakMap(), Dc = new WeakSet(), Pp = function() {\n  if (this.main.isDestroyed())\n    return !1;\n  const { fn: t, idx: e } = lt(this, Oa, _u).call(this);\n  return this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", t), this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", e), ot(this, Ar, {\n    hSave: this.val.cloneSave(),\n    hPages: z(this, cr).record(),\n    aIfStk: z(this, fr).slice(z(this, ge).length)\n  }), !1;\n}, Oa = new WeakSet(), _u = function() {\n  if (z(this, ge).length === 0)\n    return {\n      fn: z(this, oe),\n      idx: z(this, Vt)\n    };\n  const e = z(this, ge)[0];\n  return {\n    fn: e.fn,\n    idx: e.idx\n  };\n}, Ac = new WeakSet(), Rp = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  delete t[\":タグ名\"], delete t.place, t.text = (t.text ?? \"\").replace(/^(<br\\/>)+/, \"\"), z(this, Ar).json = t, this.val.setMark(e, z(this, Ar));\n  const r = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  return e === r && this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", r + 1), !1;\n}, Nr = new WeakMap(), $e = new WeakMap(), tt(ScriptIterator, sc, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/), tt(ScriptIterator, Qn, {}), tt(ScriptIterator, Si, {});\nvar tr, xr, je, Sr, Ci, ss, Ge, Vl, Pi, Ia, as, Xl, Yl, Da, Nc, Mp, Wl, ql, Aa, Na, yu, os, ls;\nconst ws = class {\n  constructor(t) {\n    tt(this, Nc);\n    tt(this, Na);\n    tt(this, tr, void 0);\n    tt(this, xr, void 0);\n    tt(this, je, /* @__PURE__ */ Object.create(null));\n    tt(this, Sr, void 0);\n    tt(this, Ci, void 0);\n    tt(this, ss, void 0);\n    tt(this, Ge, void 0);\n    tt(this, Vl, void 0);\n    tt(this, Pi, void 0);\n    tt(this, Ia, void 0);\n    tt(this, as, () => {\n    });\n    tt(this, Xl, new AnalyzeTagArg());\n    tt(this, Yl, !1);\n    tt(this, Da, \"skynovel\");\n    tt(this, Wl, () => z(this, as).call(this));\n    tt(this, ql, (t = lt(this, Na, yu)) => {\n      z(this, os) || (z(this, Pi).clearBreak(), ot(this, as, t), this.resume = (e = lt(this, Na, yu)) => {\n        ot(this, as, e);\n      }, z(this, Ge).noticeBreak(!1));\n    });\n    Rt(this, \"resume\", z(this, ql));\n    Rt(this, \"stop\", () => {\n      ot(this, as, () => {\n      }), this.resume = z(this, ql), z(this, Ge).noticeBreak(!0);\n    });\n    tt(this, Aa, !0);\n    tt(this, os, !1);\n    Rt(this, \"isDestroyed\", () => z(this, os));\n    tt(this, ls, void 0);\n    this.sys = t, skipHello(), Config.generate(t).then((e) => ot(this, tr, e)).then(() => lt(this, Nc, Mp).call(this)).catch((e) => console.error(\"load err fn:prj.json e:%o\", e));\n  }\n  errScript(t, e = !0) {\n    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log(\"🍜 SKYNovel err!\"), e)\n      throw t;\n  }\n  resumeByJumpOrCall(t) {\n    if (t.url) {\n      globalThis.open(t.url);\n      return;\n    }\n    z(this, Sr).setVal_Nochk(\"tmp\", \"sn.eventArg\", t.arg ?? \"\"), z(this, Sr).setVal_Nochk(\"tmp\", \"sn.eventLabel\", t.label ?? \"\"), argChk_Boolean(t, \"call\", !1) ? (z(this, Ge).subIdxToken(), this.resume(() => z(this, je).call(t))) : (z(this, je).clear_event({}), this.resume(() => z(this, je).jump(t)));\n  }\n  setLoop(t, e = \"\") {\n    ot(this, Aa, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : \"\");\n  }\n  fire(t, e) {\n    z(this, Ia).fire(t, e);\n  }\n  async destroy(t = 0) {\n    z(this, os) || (ot(this, os, !0), z(this, Yl) && (this.stop(), ot(this, Aa, !1), z(this, Pi).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), ot(this, je, {}), z(this, Ia).destroy(), z(this, Ge).destroy(), z(this, Pi).destroy(), z(this, Vl).destroy(), z(this, xr).ticker.remove(z(this, Wl)), z(this, ls) && z(this, xr) && ws.cvs.parentNode.appendChild(z(this, ls)), clearTextureCache(), z(this, xr).destroy(!0), this.sys.destroy()));\n  }\n};\nlet Main = ws;\ntr = new WeakMap(), xr = new WeakMap(), je = new WeakMap(), Sr = new WeakMap(), Ci = new WeakMap(), ss = new WeakMap(), Ge = new WeakMap(), Vl = new WeakMap(), Pi = new WeakMap(), Ia = new WeakMap(), as = new WeakMap(), Xl = new WeakMap(), Yl = new WeakMap(), Da = new WeakMap(), Nc = new WeakSet(), Mp = async function() {\n  var S;\n  const t = (S = document.createElement(\"canvas\")) == null ? void 0 : S.getContext(\"2d\");\n  if (!t)\n    throw \"argChk_Color err\";\n  CmnLib.cc4ColorName = t;\n  const e = {\n    width: z(this, tr).oCfg.window.width,\n    height: z(this, tr).oCfg.window.height,\n    backgroundColor: parseColor(String(z(this, tr).oCfg.init.bg_color)),\n    resolution: globalThis.devicePixelRatio ?? 1,\n    autoResize: !0\n  }, r = document.getElementById(z(this, Da));\n  r && (ot(this, ls, r.cloneNode(!0)), z(this, ls).id = z(this, Da), e.view = r), ot(this, xr, new Application(e)), ws.cvs = z(this, xr).view, r || (document.body.appendChild(ws.cvs), ws.cvs.id = z(this, Da)), ot(this, Sr, new Variable(z(this, tr), z(this, je))), ot(this, Ci, new PropParser(z(this, Sr), z(this, tr).oCfg.init.escape ?? \"\\\\\")), await Promise.allSettled(this.sys.init(z(this, je), z(this, xr), z(this, Sr), this)), z(this, je).title({ text: z(this, tr).oCfg.book.title || \"SKYNovel\" }), ot(this, ss, new SoundMng(z(this, tr), z(this, je), z(this, Sr), this, this.sys)), ot(this, Ge, new ScriptIterator(z(this, tr), z(this, je), this, z(this, Sr), z(this, Xl), () => lt(this, Na, yu).call(this), z(this, Ci), z(this, ss), this.sys)), ot(this, Vl, new DebugMng(this.sys, z(this, je), z(this, Ge))), ot(this, Pi, new LayerMng(z(this, tr), z(this, je), z(this, xr), z(this, Sr), this, z(this, Ge), this.sys, z(this, ss), z(this, Xl), z(this, Ci))), ot(this, Ia, new EventMng(z(this, tr), z(this, je), z(this, xr), this, z(this, Pi), z(this, Sr), z(this, ss), z(this, Ge), this.sys)), z(this, xr).ticker.add(z(this, Wl)), this.resumeByJumpOrCall({ fn: \"main\" }), ot(this, Yl, !0);\n}, Wl = new WeakMap(), ql = new WeakMap(), Aa = new WeakMap(), Na = new WeakSet(), yu = function() {\n  for (; z(this, Aa); ) {\n    let t = z(this, Ge).nextToken();\n    if (!t)\n      break;\n    const e = t.charCodeAt(0);\n    if (e !== 9) {\n      if (e === 10) {\n        z(this, Ge).addLineNum(t.length);\n        continue;\n      }\n      if (e === 91) {\n        if (z(this, Ge).isBreak(t))\n          return;\n        try {\n          const r = (t.match(/\\n/g) ?? []).length;\n          if (r > 0 && z(this, Ge).addLineNum(r), z(this, Ge).タグ解析(t)) {\n            this.stop();\n            break;\n          }\n          continue;\n        } catch (r) {\n          r instanceof Error ? this.errScript(`[${tagToken2Name(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);\n          return;\n        }\n      }\n      if (e === 38)\n        try {\n          if (t.slice(-1) !== \"&\") {\n            if (z(this, Ge).isBreak(t))\n              return;\n            const r = splitAmpersand(t.slice(1));\n            r.name = z(this, Ci).getValAmpersand(r.name), r.text = String(z(this, Ci).parse(r.text)), z(this, je).let(r);\n            continue;\n          }\n          if (t.charAt(1) === \"&\")\n            throw new Error(\"「&表示&」書式では「&」指定が不要です\");\n          t = String(z(this, Ci).parse(t.slice(1, -1)));\n        } catch (r) {\n          this.errScript(\n            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,\n            !1\n          );\n          return;\n        }\n      else {\n        if (e === 59)\n          continue;\n        if (e === 42 && t.length > 1)\n          continue;\n      }\n      try {\n        z(this, Pi).currentTxtlayForeNeedErr.tagCh(t);\n      } catch (r) {\n        this.errScript(\n          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,\n          !1\n        );\n        return;\n      }\n    }\n  }\n}, os = new WeakMap(), ls = new WeakMap(), Rt(Main, \"cvs\");\nconst PACKET_TYPES = /* @__PURE__ */ Object.create(null);\nPACKET_TYPES.open = \"0\";\nPACKET_TYPES.close = \"1\";\nPACKET_TYPES.ping = \"2\";\nPACKET_TYPES.pong = \"3\";\nPACKET_TYPES.message = \"4\";\nPACKET_TYPES.upgrade = \"5\";\nPACKET_TYPES.noop = \"6\";\nconst PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\nObject.keys(PACKET_TYPES).forEach((o) => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[o]] = o;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" }, withNativeBlob$1 = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", withNativeArrayBuffer$2 = typeof ArrayBuffer == \"function\", isView$1 = (o) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(o) : o && o.buffer instanceof ArrayBuffer, encodePacket = ({ type: o, data: t }, e, r) => withNativeBlob$1 && t instanceof Blob ? e ? r(t) : encodeBlobAsBase64(t, r) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? r(t) : encodeBlobAsBase64(new Blob([t]), r) : r(PACKET_TYPES[o] + (t || \"\")), encodeBlobAsBase64 = (o, t) => {\n  const e = new FileReader();\n  return e.onload = function() {\n    const r = e.result.split(\",\")[1];\n    t(\"b\" + r);\n  }, e.readAsDataURL(o);\n}, chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", lookup$1 = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let o = 0; o < chars.length; o++)\n  lookup$1[chars.charCodeAt(o)] = o;\nconst decode$1 = (o) => {\n  let t = o.length * 0.75, e = o.length, r, S = 0, T, D, N, B;\n  o[o.length - 1] === \"=\" && (t--, o[o.length - 2] === \"=\" && t--);\n  const $ = new ArrayBuffer(t), U = new Uint8Array($);\n  for (r = 0; r < e; r += 4)\n    T = lookup$1[o.charCodeAt(r)], D = lookup$1[o.charCodeAt(r + 1)], N = lookup$1[o.charCodeAt(r + 2)], B = lookup$1[o.charCodeAt(r + 3)], U[S++] = T << 2 | D >> 4, U[S++] = (D & 15) << 4 | N >> 2, U[S++] = (N & 3) << 6 | B & 63;\n  return $;\n}, withNativeArrayBuffer$1 = typeof ArrayBuffer == \"function\", decodePacket = (o, t) => {\n  if (typeof o != \"string\")\n    return {\n      type: \"message\",\n      data: mapBinary(o, t)\n    };\n  const e = o.charAt(0);\n  return e === \"b\" ? {\n    type: \"message\",\n    data: decodeBase64Packet(o.substring(1), t)\n  } : PACKET_TYPES_REVERSE[e] ? o.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[e],\n    data: o.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[e]\n  } : ERROR_PACKET;\n}, decodeBase64Packet = (o, t) => {\n  if (withNativeArrayBuffer$1) {\n    const e = decode$1(o);\n    return mapBinary(e, t);\n  } else\n    return { base64: !0, data: o };\n}, mapBinary = (o, t) => {\n  switch (t) {\n    case \"blob\":\n      return o instanceof ArrayBuffer ? new Blob([o]) : o;\n    case \"arraybuffer\":\n    default:\n      return o;\n  }\n}, SEPARATOR = String.fromCharCode(30), encodePayload = (o, t) => {\n  const e = o.length, r = new Array(e);\n  let S = 0;\n  o.forEach((T, D) => {\n    encodePacket(T, !1, (N) => {\n      r[D] = N, ++S === e && t(r.join(SEPARATOR));\n    });\n  });\n}, decodePayload = (o, t) => {\n  const e = o.split(SEPARATOR), r = [];\n  for (let S = 0; S < e.length; S++) {\n    const T = decodePacket(e[S], t);\n    if (r.push(T), T.type === \"error\")\n      break;\n  }\n  return r;\n}, protocol$1 = 4;\nfunction Emitter(o) {\n  if (o)\n    return mixin(o);\n}\nfunction mixin(o) {\n  for (var t in Emitter.prototype)\n    o[t] = Emitter.prototype[t];\n  return o;\n}\nEmitter.prototype.on = Emitter.prototype.addEventListener = function(o, t) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + o] = this._callbacks[\"$\" + o] || []).push(t), this;\n};\nEmitter.prototype.once = function(o, t) {\n  function e() {\n    this.off(o, e), t.apply(this, arguments);\n  }\n  return e.fn = t, this.on(o, e), this;\n};\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(o, t) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var e = this._callbacks[\"$\" + o];\n  if (!e)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + o], this;\n  for (var r, S = 0; S < e.length; S++)\n    if (r = e[S], r === t || r.fn === t) {\n      e.splice(S, 1);\n      break;\n    }\n  return e.length === 0 && delete this._callbacks[\"$\" + o], this;\n};\nEmitter.prototype.emit = function(o) {\n  this._callbacks = this._callbacks || {};\n  for (var t = new Array(arguments.length - 1), e = this._callbacks[\"$\" + o], r = 1; r < arguments.length; r++)\n    t[r - 1] = arguments[r];\n  if (e) {\n    e = e.slice(0);\n    for (var r = 0, S = e.length; r < S; ++r)\n      e[r].apply(this, t);\n  }\n  return this;\n};\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\nEmitter.prototype.listeners = function(o) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + o] || [];\n};\nEmitter.prototype.hasListeners = function(o) {\n  return !!this.listeners(o).length;\n};\nconst globalThisShim = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction pick(o, ...t) {\n  return t.reduce((e, r) => (o.hasOwnProperty(r) && (e[r] = o[r]), e), {});\n}\nconst NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(o, t) {\n  t.useNativeTimers ? (o.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), o.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (o.setTimeoutFn = setTimeout.bind(globalThisShim), o.clearTimeoutFn = clearTimeout.bind(globalThisShim));\n}\nconst BASE64_OVERHEAD = 1.33;\nfunction byteLength(o) {\n  return typeof o == \"string\" ? utf8Length(o) : Math.ceil((o.byteLength || o.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(o) {\n  let t = 0, e = 0;\n  for (let r = 0, S = o.length; r < S; r++)\n    t = o.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);\n  return e;\n}\nclass TransportError extends Error {\n  constructor(t, e, r) {\n    super(t), this.description = e, this.context = r, this.type = \"TransportError\";\n  }\n}\nclass Transport extends Emitter {\n  constructor(t) {\n    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = \"\", this.socket = t.socket;\n  }\n  onError(t, e, r) {\n    return super.emitReserved(\"error\", new TransportError(t, e, r)), this;\n  }\n  open() {\n    return (this.readyState === \"closed\" || this.readyState === \"\") && (this.readyState = \"opening\", this.doOpen()), this;\n  }\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  send(t) {\n    this.readyState === \"open\" && this.write(t);\n  }\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  onData(t) {\n    const e = decodePacket(t, this.socket.binaryType);\n    this.onPacket(e);\n  }\n  onPacket(t) {\n    super.emitReserved(\"packet\", t);\n  }\n  onClose(t) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", t);\n  }\n}\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map$1 = {};\nlet seed = 0, i = 0, prev;\nfunction encode$1(o) {\n  let t = \"\";\n  do\n    t = alphabet[o % length] + t, o = Math.floor(o / length);\n  while (o > 0);\n  return t;\n}\nfunction yeast() {\n  const o = encode$1(+new Date());\n  return o !== prev ? (seed = 0, prev = o) : o + \".\" + encode$1(seed++);\n}\nfor (; i < length; i++)\n  map$1[alphabet[i]] = i;\nfunction encode(o) {\n  let t = \"\";\n  for (let e in o)\n    o.hasOwnProperty(e) && (t.length && (t += \"&\"), t += encodeURIComponent(e) + \"=\" + encodeURIComponent(o[e]));\n  return t;\n}\nfunction decode(o) {\n  let t = {}, e = o.split(\"&\");\n  for (let r = 0, S = e.length; r < S; r++) {\n    let T = e[r].split(\"=\");\n    t[decodeURIComponent(T[0])] = decodeURIComponent(T[1]);\n  }\n  return t;\n}\nlet value = !1;\ntry {\n  value = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst hasCORS = value;\nfunction XHR(o) {\n  const t = o.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!t || hasCORS))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!t)\n    try {\n      return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction empty() {\n}\nconst hasXHR2 = function() {\n  return new XHR({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass Polling extends Transport {\n  constructor(t) {\n    if (super(t), this.polling = !1, typeof location < \"u\") {\n      const r = location.protocol === \"https:\";\n      let S = location.port;\n      S || (S = r ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && t.hostname !== location.hostname || S !== t.port, this.xs = t.secure !== r;\n    }\n    const e = t && t.forceBase64;\n    this.supportsBinary = hasXHR2 && !e;\n  }\n  get name() {\n    return \"polling\";\n  }\n  doOpen() {\n    this.poll();\n  }\n  pause(t) {\n    this.readyState = \"pausing\";\n    const e = () => {\n      this.readyState = \"paused\", t();\n    };\n    if (this.polling || !this.writable) {\n      let r = 0;\n      this.polling && (r++, this.once(\"pollComplete\", function() {\n        --r || e();\n      })), this.writable || (r++, this.once(\"drain\", function() {\n        --r || e();\n      }));\n    } else\n      e();\n  }\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  onData(t) {\n    const e = (r) => {\n      if (this.readyState === \"opening\" && r.type === \"open\" && this.onOpen(), r.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(r);\n    };\n    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  doClose() {\n    const t = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? t() : this.once(\"open\", t);\n  }\n  write(t) {\n    this.writable = !1, encodePayload(t, (e) => {\n      this.doWrite(e, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"https\" : \"http\";\n    let r = \"\";\n    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === \"https\" && Number(this.opts.port) !== 443 || e === \"http\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port);\n    const S = encode(t), T = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (T ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (S.length ? \"?\" + S : \"\");\n  }\n  request(t = {}) {\n    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);\n  }\n  doWrite(t, e) {\n    const r = this.request({\n      method: \"POST\",\n      data: t\n    });\n    r.on(\"success\", e), r.on(\"error\", (S, T) => {\n      this.onError(\"xhr post error\", S, T);\n    });\n  }\n  doPoll() {\n    const t = this.request();\n    t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (e, r) => {\n      this.onError(\"xhr poll error\", e, r);\n    }), this.pollXhr = t;\n  }\n}\nclass Request extends Emitter {\n  constructor(t, e) {\n    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();\n  }\n  create() {\n    const t = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n    const e = this.xhr = new XHR(t);\n    try {\n      e.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n          for (let r in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        e.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof e.status == \"number\" ? e.status : 0);\n        }, 0));\n      }, e.send(this.data);\n    } catch (r) {\n      this.setTimeoutFn(() => {\n        this.onError(r);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);\n  }\n  onError(t) {\n    this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n  }\n  cleanup(t) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = empty, t)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete Request.requests[this.index], this.xhr = null;\n    }\n  }\n  onLoad() {\n    const t = this.xhr.responseText;\n    t !== null && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n  }\n  abort() {\n    this.cleanup();\n  }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", unloadHandler);\n  else if (typeof addEventListener == \"function\") {\n    const o = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(o, unloadHandler, !1);\n  }\n}\nfunction unloadHandler() {\n  for (let o in Request.requests)\n    Request.requests.hasOwnProperty(o) && Request.requests[o].abort();\n}\nconst nextTick = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = \"arraybuffer\", isReactNative = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n  constructor(t) {\n    super(t), this.supportsBinary = !t.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const t = this.uri(), e = this.opts.protocols, r = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, r);\n    } catch (S) {\n      return this.emitReserved(\"error\", S);\n    }\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();\n  }\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (t) => this.onClose({\n      description: \"websocket connection closed\",\n      context: t\n    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError(\"websocket error\", t);\n  }\n  write(t) {\n    this.writable = !1;\n    for (let e = 0; e < t.length; e++) {\n      const r = t[e], S = e === t.length - 1;\n      encodePacket(r, this.supportsBinary, (T) => {\n        const D = {};\n        try {\n          usingBrowserWebSocket && this.ws.send(T);\n        } catch {\n        }\n        S && nextTick(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"wss\" : \"ws\";\n    let r = \"\";\n    this.opts.port && (e === \"wss\" && Number(this.opts.port) !== 443 || e === \"ws\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);\n    const S = encode(t), T = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (T ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (S.length ? \"?\" + S : \"\");\n  }\n  check() {\n    return !!WebSocket;\n  }\n}\nconst transports = {\n  websocket: WS,\n  polling: Polling\n}, re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, parts = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction parse(o) {\n  const t = o, e = o.indexOf(\"[\"), r = o.indexOf(\"]\");\n  e != -1 && r != -1 && (o = o.substring(0, e) + o.substring(e, r).replace(/:/g, \";\") + o.substring(r, o.length));\n  let S = re.exec(o || \"\"), T = {}, D = 14;\n  for (; D--; )\n    T[parts[D]] = S[D] || \"\";\n  return e != -1 && r != -1 && (T.source = t, T.host = T.host.substring(1, T.host.length - 1).replace(/;/g, \":\"), T.authority = T.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), T.ipv6uri = !0), T.pathNames = pathNames(T, T.path), T.queryKey = queryKey(T, T.query), T;\n}\nfunction pathNames(o, t) {\n  const e = /\\/{2,9}/g, r = t.replace(e, \"/\").split(\"/\");\n  return (t.slice(0, 1) == \"/\" || t.length === 0) && r.splice(0, 1), t.slice(-1) == \"/\" && r.splice(r.length - 1, 1), r;\n}\nfunction queryKey(o, t) {\n  const e = {};\n  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, S, T) {\n    S && (e[S] = T);\n  }), e;\n}\nlet Socket$1 = class extends Emitter {\n  constructor(t, e = {}) {\n    super(), t && typeof t == \"object\" && (e = t, t = null), t ? (t = parse(t), e.hostname = t.host, e.secure = t.protocol === \"https\" || t.protocol === \"wss\", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < \"u\" && location.protocol === \"https:\", e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = e.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.readyState = \"\", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !0\n    }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\", typeof this.opts.query == \"string\" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, addEventListener(\"beforeunload\", this.beforeunloadEventListener, !1)), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  createTransport(t) {\n    const e = Object.assign({}, this.opts.query);\n    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);\n    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n      query: e,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new transports[t](r);\n  }\n  open() {\n    let t;\n    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      t = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      t = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      t = this.createTransport(t);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    t.open(), this.setTransport(t);\n  }\n  setTransport(t) {\n    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (e) => this.onClose(\"transport close\", e));\n  }\n  probe(t) {\n    let e = this.createTransport(t), r = !1;\n    Socket$1.priorWebsocketSuccess = !1;\n    const S = () => {\n      r || (e.send([{ type: \"ping\", data: \"probe\" }]), e.once(\"packet\", (V) => {\n        if (!r)\n          if (V.type === \"pong\" && V.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e)\n              return;\n            Socket$1.priorWebsocketSuccess = e.name === \"websocket\", this.transport.pause(() => {\n              r || this.readyState !== \"closed\" && (U(), this.setTransport(e), e.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const H = new Error(\"probe error\");\n            H.transport = e.name, this.emitReserved(\"upgradeError\", H);\n          }\n      }));\n    };\n    function T() {\n      r || (r = !0, U(), e.close(), e = null);\n    }\n    const D = (V) => {\n      const H = new Error(\"probe error: \" + V);\n      H.transport = e.name, T(), this.emitReserved(\"upgradeError\", H);\n    };\n    function N() {\n      D(\"transport closed\");\n    }\n    function B() {\n      D(\"socket closed\");\n    }\n    function $(V) {\n      e && V.name !== e.name && T();\n    }\n    const U = () => {\n      e.removeListener(\"open\", S), e.removeListener(\"error\", D), e.removeListener(\"close\", N), this.off(\"close\", B), this.off(\"upgrading\", $);\n    };\n    e.once(\"open\", S), e.once(\"error\", D), e.once(\"close\", N), this.once(\"close\", B), this.once(\"upgrading\", $), e.open();\n  }\n  onOpen() {\n    if (this.readyState = \"open\", Socket$1.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade && this.transport.pause) {\n      let t = 0;\n      const e = this.upgrades.length;\n      for (; t < e; t++)\n        this.probe(this.upgrades[t]);\n    }\n  }\n  onPacket(t) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(t.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const e = new Error(\"server error\");\n          e.code = t.data, this.onError(e);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n          break;\n      }\n  }\n  onHandshake(t) {\n    this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const t = this.getWritablePackets();\n      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n    }\n  }\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let e = 1;\n    for (let r = 0; r < this.writeBuffer.length; r++) {\n      const S = this.writeBuffer[r].data;\n      if (S && (e += byteLength(S)), r > 0 && e > this.maxPayload)\n        return this.writeBuffer.slice(0, r);\n      e += 2;\n    }\n    return this.writeBuffer;\n  }\n  write(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  send(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  sendPacket(t, e, r, S) {\n    if (typeof e == \"function\" && (S = e, e = void 0), typeof r == \"function\" && (S = r, r = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    r = r || {}, r.compress = r.compress !== !1;\n    const T = {\n      type: t,\n      data: e,\n      options: r\n    };\n    this.emitReserved(\"packetCreate\", T), this.writeBuffer.push(T), S && this.once(\"flush\", S), this.flush();\n  }\n  close() {\n    const t = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, e = () => {\n      this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n    }, r = () => {\n      this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? r() : t();\n    }) : this.upgrading ? r() : t()), this;\n  }\n  onError(t) {\n    Socket$1.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n  }\n  onClose(t, e) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && (removeEventListener(\"beforeunload\", this.beforeunloadEventListener, !1), removeEventListener(\"offline\", this.offlineEventListener, !1)), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  filterUpgrades(t) {\n    const e = [];\n    let r = 0;\n    const S = t.length;\n    for (; r < S; r++)\n      ~this.transports.indexOf(t[r]) && e.push(t[r]);\n    return e;\n  }\n};\nSocket$1.protocol = protocol$1;\nfunction url(o, t = \"\", e) {\n  let r = o;\n  e = e || typeof location < \"u\" && location, o == null && (o = e.protocol + \"//\" + e.host), typeof o == \"string\" && (o.charAt(0) === \"/\" && (o.charAt(1) === \"/\" ? o = e.protocol + o : o = e.host + o), /^(https?|wss?):\\/\\//.test(o) || (typeof e < \"u\" ? o = e.protocol + \"//\" + o : o = \"https://\" + o), r = parse(o)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = \"80\" : /^(http|ws)s$/.test(r.protocol) && (r.port = \"443\")), r.path = r.path || \"/\";\n  const T = r.host.indexOf(\":\") !== -1 ? \"[\" + r.host + \"]\" : r.host;\n  return r.id = r.protocol + \"://\" + T + \":\" + r.port + t, r.href = r.protocol + \"://\" + T + (e && e.port === r.port ? \"\" : \":\" + r.port), r;\n}\nconst withNativeArrayBuffer = typeof ArrayBuffer == \"function\", isView = (o) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(o) : o.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == \"function\" || typeof Blob < \"u\" && toString.call(Blob) === \"[object BlobConstructor]\", withNativeFile = typeof File == \"function\" || typeof File < \"u\" && toString.call(File) === \"[object FileConstructor]\";\nfunction isBinary(o) {\n  return withNativeArrayBuffer && (o instanceof ArrayBuffer || isView(o)) || withNativeBlob && o instanceof Blob || withNativeFile && o instanceof File;\n}\nfunction hasBinary(o, t) {\n  if (!o || typeof o != \"object\")\n    return !1;\n  if (Array.isArray(o)) {\n    for (let e = 0, r = o.length; e < r; e++)\n      if (hasBinary(o[e]))\n        return !0;\n    return !1;\n  }\n  if (isBinary(o))\n    return !0;\n  if (o.toJSON && typeof o.toJSON == \"function\" && arguments.length === 1)\n    return hasBinary(o.toJSON(), !0);\n  for (const e in o)\n    if (Object.prototype.hasOwnProperty.call(o, e) && hasBinary(o[e]))\n      return !0;\n  return !1;\n}\nfunction deconstructPacket(o) {\n  const t = [], e = o.data, r = o;\n  return r.data = _deconstructPacket(e, t), r.attachments = t.length, { packet: r, buffers: t };\n}\nfunction _deconstructPacket(o, t) {\n  if (!o)\n    return o;\n  if (isBinary(o)) {\n    const e = { _placeholder: !0, num: t.length };\n    return t.push(o), e;\n  } else if (Array.isArray(o)) {\n    const e = new Array(o.length);\n    for (let r = 0; r < o.length; r++)\n      e[r] = _deconstructPacket(o[r], t);\n    return e;\n  } else if (typeof o == \"object\" && !(o instanceof Date)) {\n    const e = {};\n    for (const r in o)\n      Object.prototype.hasOwnProperty.call(o, r) && (e[r] = _deconstructPacket(o[r], t));\n    return e;\n  }\n  return o;\n}\nfunction reconstructPacket(o, t) {\n  return o.data = _reconstructPacket(o.data, t), o.attachments = void 0, o;\n}\nfunction _reconstructPacket(o, t) {\n  if (!o)\n    return o;\n  if (o && o._placeholder === !0) {\n    if (typeof o.num == \"number\" && o.num >= 0 && o.num < t.length)\n      return t[o.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(o))\n    for (let e = 0; e < o.length; e++)\n      o[e] = _reconstructPacket(o[e], t);\n  else if (typeof o == \"object\")\n    for (const e in o)\n      Object.prototype.hasOwnProperty.call(o, e) && (o[e] = _reconstructPacket(o[e], t));\n  return o;\n}\nconst protocol = 5;\nvar PacketType;\n(function(o) {\n  o[o.CONNECT = 0] = \"CONNECT\", o[o.DISCONNECT = 1] = \"DISCONNECT\", o[o.EVENT = 2] = \"EVENT\", o[o.ACK = 3] = \"ACK\", o[o.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", o[o.BINARY_EVENT = 5] = \"BINARY_EVENT\", o[o.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\nclass Encoder {\n  constructor(t) {\n    this.replacer = t;\n  }\n  encode(t) {\n    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];\n  }\n  encodeAsString(t) {\n    let e = \"\" + t.type;\n    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + \"-\"), t.nsp && t.nsp !== \"/\" && (e += t.nsp + \",\"), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;\n  }\n  encodeAsBinary(t) {\n    const e = deconstructPacket(t), r = this.encodeAsString(e.packet), S = e.buffers;\n    return S.unshift(r), S;\n  }\n}\nclass Decoder extends Emitter {\n  constructor(t) {\n    super(), this.reviver = t;\n  }\n  add(t) {\n    let e;\n    if (typeof t == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n    } else if (isBinary(t) || t.base64)\n      if (this.reconstructor)\n        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + t);\n  }\n  decodeString(t) {\n    let e = 0;\n    const r = {\n      type: Number(t.charAt(0))\n    };\n    if (PacketType[r.type] === void 0)\n      throw new Error(\"unknown packet type \" + r.type);\n    if (r.type === PacketType.BINARY_EVENT || r.type === PacketType.BINARY_ACK) {\n      const T = e + 1;\n      for (; t.charAt(++e) !== \"-\" && e != t.length; )\n        ;\n      const D = t.substring(T, e);\n      if (D != Number(D) || t.charAt(e) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      r.attachments = Number(D);\n    }\n    if (t.charAt(e + 1) === \"/\") {\n      const T = e + 1;\n      for (; ++e && !(t.charAt(e) === \",\" || e === t.length); )\n        ;\n      r.nsp = t.substring(T, e);\n    } else\n      r.nsp = \"/\";\n    const S = t.charAt(e + 1);\n    if (S !== \"\" && Number(S) == S) {\n      const T = e + 1;\n      for (; ++e; ) {\n        const D = t.charAt(e);\n        if (D == null || Number(D) != D) {\n          --e;\n          break;\n        }\n        if (e === t.length)\n          break;\n      }\n      r.id = Number(t.substring(T, e + 1));\n    }\n    if (t.charAt(++e)) {\n      const T = this.tryParse(t.substr(e));\n      if (Decoder.isPayloadValid(r.type, T))\n        r.data = T;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return r;\n  }\n  tryParse(t) {\n    try {\n      return JSON.parse(t, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(t, e) {\n    switch (t) {\n      case PacketType.CONNECT:\n        return typeof e == \"object\";\n      case PacketType.DISCONNECT:\n        return e === void 0;\n      case PacketType.CONNECT_ERROR:\n        return typeof e == \"string\" || typeof e == \"object\";\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(e) && e.length > 0;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(e);\n    }\n  }\n  destroy() {\n    this.reconstructor && this.reconstructor.finishedReconstruction();\n  }\n}\nclass BinaryReconstructor {\n  constructor(t) {\n    this.packet = t, this.buffers = [], this.reconPack = t;\n  }\n  takeBinaryData(t) {\n    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n      const e = reconstructPacket(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), e;\n    }\n    return null;\n  }\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  protocol,\n  get PacketType() {\n    return PacketType;\n  },\n  Encoder,\n  Decoder\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction on(o, t, e) {\n  return o.on(t, e), function() {\n    o.off(t, e);\n  };\n}\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nclass Socket extends Emitter {\n  constructor(t, e, r) {\n    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs)\n      return;\n    const t = this.io;\n    this.subs = [\n      on(t, \"open\", this.onopen.bind(this)),\n      on(t, \"packet\", this.onpacket.bind(this)),\n      on(t, \"error\", this.onerror.bind(this)),\n      on(t, \"close\", this.onclose.bind(this))\n    ];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  open() {\n    return this.connect();\n  }\n  send(...t) {\n    return t.unshift(\"message\"), this.emit.apply(this, t), this;\n  }\n  emit(t, ...e) {\n    if (RESERVED_EVENTS.hasOwnProperty(t))\n      throw new Error('\"' + t.toString() + '\" is a reserved event name');\n    e.unshift(t);\n    const r = {\n      type: PacketType.EVENT,\n      data: e\n    };\n    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == \"function\") {\n      const D = this.ids++, N = e.pop();\n      this._registerAckCallback(D, N), r.id = D;\n    }\n    const S = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!S || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;\n  }\n  _registerAckCallback(t, e) {\n    const r = this.flags.timeout;\n    if (r === void 0) {\n      this.acks[t] = e;\n      return;\n    }\n    const S = this.io.setTimeoutFn(() => {\n      delete this.acks[t];\n      for (let T = 0; T < this.sendBuffer.length; T++)\n        this.sendBuffer[T].id === t && this.sendBuffer.splice(T, 1);\n      e.call(this, new Error(\"operation has timed out\"));\n    }, r);\n    this.acks[t] = (...T) => {\n      this.io.clearTimeoutFn(S), e.apply(this, [null, ...T]);\n    };\n  }\n  packet(t) {\n    t.nsp = this.nsp, this.io._packet(t);\n  }\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((t) => {\n      this.packet({ type: PacketType.CONNECT, data: t });\n    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });\n  }\n  onerror(t) {\n    this.connected || this.emitReserved(\"connect_error\", t);\n  }\n  onclose(t, e) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n  }\n  onpacket(t) {\n    if (t.nsp === this.nsp)\n      switch (t.type) {\n        case PacketType.CONNECT:\n          if (t.data && t.data.sid) {\n            const S = t.data.sid;\n            this.onconnect(S);\n          } else\n            this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case PacketType.EVENT:\n        case PacketType.BINARY_EVENT:\n          this.onevent(t);\n          break;\n        case PacketType.ACK:\n        case PacketType.BINARY_ACK:\n          this.onack(t);\n          break;\n        case PacketType.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case PacketType.CONNECT_ERROR:\n          this.destroy();\n          const r = new Error(t.data.message);\n          r.data = t.data.data, this.emitReserved(\"connect_error\", r);\n          break;\n      }\n  }\n  onevent(t) {\n    const e = t.data || [];\n    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n  }\n  emitEvent(t) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const e = this._anyListeners.slice();\n      for (const r of e)\n        r.apply(this, t);\n    }\n    super.emit.apply(this, t);\n  }\n  ack(t) {\n    const e = this;\n    let r = !1;\n    return function(...S) {\n      r || (r = !0, e.packet({\n        type: PacketType.ACK,\n        id: t,\n        data: S\n      }));\n    };\n  }\n  onack(t) {\n    const e = this.acks[t.id];\n    typeof e == \"function\" && (e.apply(this, t.data), delete this.acks[t.id]);\n  }\n  onconnect(t) {\n    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\");\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {\n      this.notifyOutgoingListeners(t), this.packet(t);\n    }), this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);\n  }\n  disconnect() {\n    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(t) {\n    return this.flags.compress = t, this;\n  }\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  timeout(t) {\n    return this.flags.timeout = t, this;\n  }\n  onAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n  }\n  prependAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n  }\n  offAny(t) {\n    if (!this._anyListeners)\n      return this;\n    if (t) {\n      const e = this._anyListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n  }\n  prependAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n  }\n  offAnyOutgoing(t) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (t) {\n      const e = this._anyOutgoingListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(t) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const e = this._anyOutgoingListeners.slice();\n      for (const r of e)\n        r.apply(this, t.data);\n    }\n  }\n}\nfunction Backoff(o) {\n  o = o || {}, this.ms = o.min || 100, this.max = o.max || 1e4, this.factor = o.factor || 2, this.jitter = o.jitter > 0 && o.jitter <= 1 ? o.jitter : 0, this.attempts = 0;\n}\nBackoff.prototype.duration = function() {\n  var o = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var t = Math.random(), e = Math.floor(t * this.jitter * o);\n    o = (Math.floor(t * 10) & 1) == 0 ? o - e : o + e;\n  }\n  return Math.min(o, this.max) | 0;\n};\nBackoff.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function(o) {\n  this.ms = o;\n};\nBackoff.prototype.setMax = function(o) {\n  this.max = o;\n};\nBackoff.prototype.setJitter = function(o) {\n  this.jitter = o;\n};\nclass Manager extends Emitter {\n  constructor(t, e) {\n    var r;\n    super(), this.nsps = {}, this.subs = [], t && typeof t == \"object\" && (e = t, t = void 0), e = e || {}, e.path = e.path || \"/socket.io\", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n    const S = e.parser || parser;\n    this.encoder = new S.Encoder(), this.decoder = new S.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(t) {\n    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n  }\n  reconnectionAttempts(t) {\n    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n  }\n  reconnectionDelay(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);\n  }\n  randomizationFactor(t) {\n    var e;\n    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);\n  }\n  reconnectionDelayMax(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);\n  }\n  timeout(t) {\n    return arguments.length ? (this._timeout = t, this) : this._timeout;\n  }\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  open(t) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Socket$1(this.uri, this.opts);\n    const e = this.engine, r = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const S = on(e, \"open\", function() {\n      r.onopen(), t && t();\n    }), T = on(e, \"error\", (D) => {\n      r.cleanup(), r._readyState = \"closed\", this.emitReserved(\"error\", D), t ? t(D) : r.maybeReconnectOnOpen();\n    });\n    if (this._timeout !== !1) {\n      const D = this._timeout;\n      D === 0 && S();\n      const N = this.setTimeoutFn(() => {\n        S(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n      }, D);\n      this.opts.autoUnref && N.unref(), this.subs.push(function() {\n        clearTimeout(N);\n      });\n    }\n    return this.subs.push(S), this.subs.push(T), this;\n  }\n  connect(t) {\n    return this.open(t);\n  }\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const t = this.engine;\n    this.subs.push(on(t, \"ping\", this.onping.bind(this)), on(t, \"data\", this.ondata.bind(this)), on(t, \"error\", this.onerror.bind(this)), on(t, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(t) {\n    try {\n      this.decoder.add(t);\n    } catch (e) {\n      this.onclose(\"parse error\", e);\n    }\n  }\n  ondecoded(t) {\n    nextTick(() => {\n      this.emitReserved(\"packet\", t);\n    }, this.setTimeoutFn);\n  }\n  onerror(t) {\n    this.emitReserved(\"error\", t);\n  }\n  socket(t, e) {\n    let r = this.nsps[t];\n    return r || (r = new Socket(this, t, e), this.nsps[t] = r), r;\n  }\n  _destroy(t) {\n    const e = Object.keys(this.nsps);\n    for (const r of e)\n      if (this.nsps[r].active)\n        return;\n    this._close();\n  }\n  _packet(t) {\n    const e = this.encoder.encode(t);\n    for (let r = 0; r < e.length; r++)\n      this.engine.write(e[r], t.options);\n  }\n  cleanup() {\n    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(t, e) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const t = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const e = this.backoff.duration();\n      this._reconnecting = !0;\n      const r = this.setTimeoutFn(() => {\n        t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), !t.skipReconnect && t.open((S) => {\n          S ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", S)) : t.onreconnect();\n        }));\n      }, e);\n      this.opts.autoUnref && r.unref(), this.subs.push(function() {\n        clearTimeout(r);\n      });\n    }\n  }\n  onreconnect() {\n    const t = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n  }\n}\nconst cache = {};\nfunction lookup(o, t) {\n  typeof o == \"object\" && (t = o, o = void 0), t = t || {};\n  const e = url(o, t.path || \"/socket.io\"), r = e.source, S = e.id, T = e.path, D = cache[S] && T in cache[S].nsps, N = t.forceNew || t[\"force new connection\"] || t.multiplex === !1 || D;\n  let B;\n  return N ? B = new Manager(r, t) : (cache[S] || (cache[S] = new Manager(r, t)), B = cache[S]), e.query && !t.query && (t.query = e.queryKey), B.socket(e.path, t);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\nvar Lr, Jr, Qr, us, hs, Ji, Qi, tn, Lc, kc, Kl, La, Bc, ka, cs, Fc, fs, Ba;\nconst $c = class {\n  constructor(t = {}, e) {\n    Rt(this, \"hFactoryCls\", {});\n    Rt(this, \"elc\", new EventListenerCtn());\n    Rt(this, \"fetch\", (t) => fetch(t));\n    Rt(this, \"resolution\", 1);\n    Rt(this, \"cfg\");\n    Rt(this, \"data\", { sys: {}, mark: {}, kidoku: {} });\n    Rt(this, \"val\");\n    Rt(this, \"appPixi\");\n    tt(this, Lr, 0);\n    tt(this, Jr, 0);\n    tt(this, Qr, 1);\n    tt(this, us, 0);\n    tt(this, hs, 0);\n    tt(this, Ji, 0);\n    tt(this, Qi, 0);\n    Rt(this, \"isFullScr\", !1);\n    Rt(this, \"extPort\", 3776);\n    tt(this, tn, void 0);\n    tt(this, Lc, {\n      auth: (t) => {\n        if (t.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"接続\");\n      },\n      continue: () => this.toast(\"再生\"),\n      disconnect: () => this.toast(\"切断\"),\n      restart: (t) => {\n        this.send2Dbg((t == null ? void 0 : t.ri) ?? \"\", {}), this.end(), this.run();\n      },\n      pause: () => this.toast(\"一時停止\"),\n      stopOnEntry: () => this.toast(\"一時停止\"),\n      stopOnDataBreakpoint: () => this.toast(\"注意\"),\n      stopOnBreakpoint: () => this.toast(\"注意\"),\n      stopOnStep: () => this.toast(\"一歩進む\"),\n      stopOnStepIn: () => this.toast(\"ステップイン\"),\n      stopOnStepOut: () => this.toast(\"ステップアウト\"),\n      stopOnBackstep: () => this.toast(\"一歩戻る\"),\n      _addPath: (t) => this.cfg.addPath(t.fn, t.o)\n    });\n    Rt(this, \"pathBaseCnvSnPath4Dbg\", \"\");\n    Rt(this, \"fire\");\n    tt(this, Kl, []);\n    Rt(this, \"callHook\", (t, e) => {\n    });\n    Rt(this, \"send2Dbg\", (t, e) => {\n      var r;\n      (r = z(this, tn)) == null || r.emit(\"data\", t, e);\n    });\n    Rt(this, \"copyBMFolder\", (t, e) => {\n    });\n    Rt(this, \"eraseBMFolder\", (t) => {\n    });\n    Rt(this, \"close\", () => !1);\n    Rt(this, \"_export\", () => !1);\n    Rt(this, \"_import\", () => !1);\n    Rt(this, \"navigate_to\", () => !1);\n    Rt(this, \"title\", (t) => {\n      const { text: e } = t;\n      if (!e)\n        throw \"[title] textは必須です\";\n      return ot(this, La, e), this.titleSub(z(this, La) + z(this, ka)), !1;\n    });\n    tt(this, La, \"\");\n    tt(this, Bc, (t) => {\n      if (!t.key)\n        return this.tglFlscr_sub(), !1;\n      const e = t.key.toLowerCase();\n      return this.elc.add(document, \"keydown\", (r) => {\n        (r.altKey ? r.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (r.ctrlKey ? r.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (r.shiftKey ? r.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());\n      }, { passive: !0 }), !1;\n    });\n    Rt(this, \"update_check\", () => !1);\n    Rt(this, \"window\", () => !1);\n    tt(this, ka, \"\");\n    tt(this, cs, (t, e) => ({ ret: e.toString(), ext_num: 0 }));\n    tt(this, Fc, {\n      1: { ext: \"jpeg\", fnc: (t) => z(this, fs).call(this, t), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (t) => z(this, fs).call(this, t), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (t) => z(this, fs).call(this, t), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (t) => z(this, fs).call(this, t), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (t) => t.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (t) => t.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (t) => t.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (t) => z(this, Ba).call(this, t), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (t) => z(this, Ba).call(this, t), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (t) => z(this, Ba).call(this, t), mime: \"video/ogv\" }\n    });\n    tt(this, fs, (t) => new Promise((e, r) => {\n      const S = new Image();\n      S.onload = () => e(S), S.onerror = (T) => r(T), S.src = URL.createObjectURL(t);\n    }));\n    tt(this, Ba, (t) => new Promise((e, r) => {\n      const S = document.createElement(\"video\");\n      this.elc.add(S, \"error\", () => {\n        var T;\n        return r(((T = S == null ? void 0 : S.error) == null ? void 0 : T.message) ?? \"\");\n      }), this.elc.add(S, \"canplay\", () => e(S)), S.src = URL.createObjectURL(t);\n    }));\n    Rt(this, \"enc\", (t) => t);\n    Rt(this, \"stk\", () => \"\");\n    Rt(this, \"hash\", (t) => \"\");\n    Rt(this, \"isApp\", !1);\n    Rt(this, \"$path_downloads\", \"\");\n    Rt(this, \"$path_userdata\", \"\");\n    Rt(this, \"canCapturePage\", (t) => !1);\n    this.hPlg = t, this.arg = e;\n  }\n  async loaded(t, e) {\n    const r = t.snsys_pre;\n    return delete t.snsys_pre, r == null ? void 0 : r.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (S) => ot(this, cs, S),\n      setEnc: (S) => this.enc = S,\n      getStK: (S) => this.stk = S,\n      getHash: (S) => this.hash = S\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  destroy() {\n    this.elc.clear();\n  }\n  async loadPath(t, e) {\n    this.cfg = e;\n  }\n  initVal(t, e, r) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(t, e, r, S) {\n    this.val = r, this.appPixi = e;\n    let T = \"\";\n    try {\n      this.val.setSys(this), T = \"sys\", T += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), T = \"kidoku\", this.val.saveKidoku();\n    } catch (D) {\n      console.error(`セーブデータ（${T}）が壊れています。一度クリアする必要があります %o`, D);\n    }\n    return t.close = (D) => this.close(D), t.export = (D) => this._export(D), t.import = (D) => this._import(D), t.navigate_to = (D) => this.navigate_to(D), t.title = (D) => this.title(D), t.toggle_full_screen = (D) => z(this, Bc).call(this, D), t.update_check = (D) => this.update_check(D), t.window = (D) => this.window(D), r.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp), r.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => CmnLib.isDbg), r.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => CmnLib.isPackaged), this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr), r.setVal_Nochk(\"sys\", $c.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), CmnLib.isDbg && this.attach_debug(S), this.hFactoryCls = {}, Object.values(this.hPlg).map((D) => D.init({\n      addTag: (N, B) => {\n        if (t[N])\n          throw `すでに定義済みのタグ[${N}]です`;\n        t[N] = B;\n      },\n      addLayCls: (N, B) => {\n        if (this.hFactoryCls[N])\n          throw `すでに定義済みのレイヤcls【${N}】です`;\n        this.hFactoryCls[N] = B;\n      },\n      searchPath: (N, B = \"\") => this.cfg.searchPath(N, B),\n      getVal: r.getVal,\n      resume: () => S.resume(),\n      render: (N, B, $ = !1) => this.appPixi.renderer.render(N, { renderTexture: B, clear: $ }),\n      setDec: (N) => ot(this, cs, N),\n      setEnc: (N) => this.enc = N,\n      getStK: (N) => this.stk = N,\n      getHash: (N) => this.hash = N\n    }));\n  }\n  get cvsWidth() {\n    return z(this, Lr);\n  }\n  get cvsHeight() {\n    return z(this, Jr);\n  }\n  get cvsScale() {\n    return z(this, Qr);\n  }\n  get ofsLeft4elm() {\n    return z(this, us);\n  }\n  get ofsTop4elm() {\n    return z(this, hs);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return z(this, Ji);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return z(this, Qi);\n  }\n  cvsResize() {\n    var B;\n    let t = globalThis.innerWidth, e = globalThis.innerHeight;\n    const r = Main.cvs, S = r.parentElement !== document.body;\n    if (S) {\n      const $ = globalThis.getComputedStyle(r);\n      t = parseFloat($.width), e = parseFloat($.height);\n    }\n    if (CmnLib.isMobile) {\n      const U = (((B = screen.orientation) == null ? void 0 : B.angle) ?? 0) % 180 === 0;\n      (U && t > e || !U && t < e) && ([t, e] = [e, t]);\n    }\n    const T = r.getBoundingClientRect();\n    if (argChk_Boolean(CmnLib.hDip, \"expanding\", !0) || S || CmnLib.stageW > t || CmnLib.stageH > e)\n      if (CmnLib.stageW / CmnLib.stageH <= t / e ? (ot(this, Jr, e), ot(this, Lr, CmnLib.stageW / CmnLib.stageH * e)) : (ot(this, Lr, t), ot(this, Jr, CmnLib.stageH / CmnLib.stageW * t)), ot(this, Qr, z(this, Lr) / CmnLib.stageW), S)\n        ot(this, Ji, 0), ot(this, Qi, 0);\n      else {\n        const $ = 1 - z(this, Qr);\n        CmnLib.isMobile ? (ot(this, Ji, (t - z(this, Lr)) / 2 * $), ot(this, Qi, (e - z(this, Jr)) / 2 * $)) : (ot(this, Ji, T.left * $), ot(this, Qi, T.top * $));\n      }\n    else\n      ot(this, Lr, CmnLib.stageW), ot(this, Jr, CmnLib.stageH), ot(this, Qr, 1), ot(this, Ji, 0), ot(this, Qi, 0);\n    const D = r.parentElement.style;\n    S || (D.position = \"relative\", D.width = `${z(this, Lr)}px`, D.height = `${z(this, Jr)}px`);\n    const N = r.style;\n    N.width = D.width, N.height = D.height, S ? (ot(this, us, T.left), ot(this, hs, T.top)) : (ot(this, us, 0), ot(this, hs, 0)), this.isFullScr && (ot(this, us, z(this, us) + (t - z(this, Lr)) / 2), ot(this, hs, z(this, hs) + (e - z(this, Jr)) / 2));\n  }\n  attach_debug(t) {\n    this.attach_debug = () => {\n    };\n    const e = document.createElement(\"style\");\n    e.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`, document.getElementsByTagName(\"head\")[0].appendChild(e), this.addHook((r, S) => {\n      var T, D;\n      return (D = (T = z(this, Lc))[r]) == null ? void 0 : D.call(T, S);\n    }), ot(this, tn, lookup(`http://localhost:${this.extPort}`)), z(this, tn).on(\"data\", (r, S) => {\n      this.callHook(r, S);\n    }).on(\"disconnect\", () => t.setLoop(!0)), this.callHook = (r, S) => {\n      for (const T of z(this, Kl))\n        T(r, S);\n    };\n  }\n  end() {\n    var t;\n    (t = z(this, tn)) == null || t.disconnect(), ot(this, tn, void 0);\n  }\n  toast(t) {\n    const e = document.body;\n    e.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach((D) => e.removeChild(D));\n    const r = document.createElement(\"img\"), S = z($c, kc)[t];\n    r.src = `data:image/svg+xml;base64,${S.dat}`;\n    const T = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * z(this, Qr);\n    r.width = r.height = T, r.style.cssText = `position: absolute;\nleft: ${(CmnLib.stageW - T) / 2 * z(this, Qr) + T * (S.dx ?? 0)}px;\ntop: ${(CmnLib.stageH - T) / 2 * z(this, Qr) + T * (S.dy ?? 0)}px;`, r.classList.add(\"sn_toast\", S.ease ?? \"sn_BounceInOut\"), S.ease || r.addEventListener(\"animationend\", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Main.cvs);\n  }\n  setFire(t) {\n    this.fire = t;\n  }\n  addHook(t) {\n    z(this, Kl).push(t);\n  }\n  titleSub(t) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(t) {\n    ot(this, ka, t), this.titleSub(z(this, La) + z(this, ka));\n  }\n  decStr(t, e) {\n    return z(this, cs).call(this, t, e).ret;\n  }\n  async dec(t, e) {\n    const { ret: r, ext_num: S } = z(this, cs).call(this, t, e), T = z(this, Fc)[S];\n    return T != null && T.fnc ? await T.fnc(new Blob([r], { type: T.mime })) : r;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  async savePic(t, e) {\n  }\n  async appendFile(t, e, r) {\n  }\n  async ensureFileSync(t) {\n  }\n};\nlet SysBase = $c;\nLr = new WeakMap(), Jr = new WeakMap(), Qr = new WeakMap(), us = new WeakMap(), hs = new WeakMap(), Ji = new WeakMap(), Qi = new WeakMap(), tn = new WeakMap(), Lc = new WeakMap(), kc = new WeakMap(), Kl = new WeakMap(), La = new WeakMap(), Bc = new WeakMap(), ka = new WeakMap(), cs = new WeakMap(), Fc = new WeakMap(), fs = new WeakMap(), Ba = new WeakMap(), Rt(SysBase, \"VALNM_CFG_NS\", \"const.sn.cfg.ns\"), tt(SysBase, kc, {\n  接続: { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  切断: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  再生: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一時停止: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  注意: { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  一歩進む: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一歩戻る: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  ステップイン: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  ステップアウト: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nvar assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < \"u\" ? window : commonjsGlobal, util$6 = {\n  assign,\n  create: create$1,\n  trim: trim$1,\n  bind: bind$1,\n  slice: slice$1,\n  each: each$7,\n  map,\n  pluck: pluck$1,\n  isList: isList$1,\n  isFunction: isFunction$1,\n  isObject: isObject$1,\n  Global: Global$5\n};\nfunction make_assign() {\n  return Object.assign ? Object.assign : function(t, e, r, S) {\n    for (var T = 1; T < arguments.length; T++)\n      each$7(Object(arguments[T]), function(D, N) {\n        t[N] = D;\n      });\n    return t;\n  };\n}\nfunction make_create() {\n  if (Object.create)\n    return function(t, e, r, S) {\n      var T = slice$1(arguments, 1);\n      return assign.apply(this, [Object.create(t)].concat(T));\n    };\n  {\n    let o = function() {\n    };\n    return function(e, r, S, T) {\n      var D = slice$1(arguments, 1);\n      return o.prototype = e, assign.apply(this, [new o()].concat(D));\n    };\n  }\n}\nfunction make_trim() {\n  return String.prototype.trim ? function(t) {\n    return String.prototype.trim.call(t);\n  } : function(t) {\n    return t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n}\nfunction bind$1(o, t) {\n  return function() {\n    return t.apply(o, Array.prototype.slice.call(arguments, 0));\n  };\n}\nfunction slice$1(o, t) {\n  return Array.prototype.slice.call(o, t || 0);\n}\nfunction each$7(o, t) {\n  pluck$1(o, function(e, r) {\n    return t(e, r), !1;\n  });\n}\nfunction map(o, t) {\n  var e = isList$1(o) ? [] : {};\n  return pluck$1(o, function(r, S) {\n    return e[S] = t(r, S), !1;\n  }), e;\n}\nfunction pluck$1(o, t) {\n  if (isList$1(o)) {\n    for (var e = 0; e < o.length; e++)\n      if (t(o[e], e))\n        return o[e];\n  } else\n    for (var r in o)\n      if (o.hasOwnProperty(r) && t(o[r], r))\n        return o[r];\n}\nfunction isList$1(o) {\n  return o != null && typeof o != \"function\" && typeof o.length == \"number\";\n}\nfunction isFunction$1(o) {\n  return o && {}.toString.call(o) === \"[object Function]\";\n}\nfunction isObject$1(o) {\n  return o && {}.toString.call(o) === \"[object Object]\";\n}\nvar util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {\n  createStore\n}, storeAPI = {\n  version: \"2.0.12\",\n  enabled: !1,\n  get: function(o, t) {\n    var e = this.storage.read(this._namespacePrefix + o);\n    return this._deserialize(e, t);\n  },\n  set: function(o, t) {\n    return t === void 0 ? this.remove(o) : (this.storage.write(this._namespacePrefix + o, this._serialize(t)), t);\n  },\n  remove: function(o) {\n    this.storage.remove(this._namespacePrefix + o);\n  },\n  each: function(o) {\n    var t = this;\n    this.storage.each(function(e, r) {\n      o.call(t, t._deserialize(e), (r || \"\").replace(t._namespaceRegexp, \"\"));\n    });\n  },\n  clearAll: function() {\n    this.storage.clearAll();\n  },\n  hasNamespace: function(o) {\n    return this._namespacePrefix == \"__storejs_\" + o + \"_\";\n  },\n  createStore: function() {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function(o) {\n    this._addPlugin(o);\n  },\n  namespace: function(o) {\n    return createStore(this.storage, this.plugins, o);\n  }\n};\nfunction _warn() {\n  var o = typeof console > \"u\" ? null : console;\n  if (!!o) {\n    var t = o.warn ? o.warn : o.log;\n    t.apply(o, arguments);\n  }\n}\nfunction createStore(o, t, e) {\n  e || (e = \"\"), o && !isList(o) && (o = [o]), t && !isList(t) && (t = [t]);\n  var r = e ? \"__storejs_\" + e + \"_\" : \"\", S = e ? new RegExp(\"^\" + r) : null, T = /^[a-zA-Z0-9_\\-]*$/;\n  if (!T.test(e))\n    throw new Error(\"store.js namespaces can only have alphanumerics + underscores and dashes\");\n  var D = {\n    _namespacePrefix: r,\n    _namespaceRegexp: S,\n    _testStorage: function(B) {\n      try {\n        var $ = \"__storejs__test__\";\n        B.write($, $);\n        var U = B.read($) === $;\n        return B.remove($), U;\n      } catch {\n        return !1;\n      }\n    },\n    _assignPluginFnProp: function(B, $) {\n      var U = this[$];\n      this[$] = function() {\n        var H = slice(arguments, 0), X = this;\n        function Y() {\n          if (!!U)\n            return each$6(arguments, function(q, K) {\n              H[K] = q;\n            }), U.apply(X, H);\n        }\n        var W = [Y].concat(H);\n        return B.apply(X, W);\n      };\n    },\n    _serialize: function(B) {\n      return JSON.stringify(B);\n    },\n    _deserialize: function(B, $) {\n      if (!B)\n        return $;\n      var U = \"\";\n      try {\n        U = JSON.parse(B);\n      } catch {\n        U = B;\n      }\n      return U !== void 0 ? U : $;\n    },\n    _addStorage: function(B) {\n      this.enabled || this._testStorage(B) && (this.storage = B, this.enabled = !0);\n    },\n    _addPlugin: function(B) {\n      var $ = this;\n      if (isList(B)) {\n        each$6(B, function(H) {\n          $._addPlugin(H);\n        });\n        return;\n      }\n      var U = pluck(this.plugins, function(H) {\n        return B === H;\n      });\n      if (!U) {\n        if (this.plugins.push(B), !isFunction(B))\n          throw new Error(\"Plugins must be function values that return objects\");\n        var V = B.call(this);\n        if (!isObject(V))\n          throw new Error(\"Plugins must return an object of function properties\");\n        each$6(V, function(H, X) {\n          if (!isFunction(H))\n            throw new Error(\"Bad plugin property: \" + X + \" from plugin \" + B.name + \". Plugins should only return functions.\");\n          $._assignPluginFnProp(H, X);\n        });\n      }\n    },\n    addStorage: function(B) {\n      _warn(\"store.addStorage(storage) is deprecated. Use createStore([storages])\"), this._addStorage(B);\n    }\n  }, N = create(D, storeAPI, {\n    plugins: []\n  });\n  return N.raw = {}, each$6(N, function(B, $) {\n    isFunction(B) && (N.raw[$] = bind(N, B));\n  }), each$6(o, function(B) {\n    N._addStorage(B);\n  }), each$6(t, function(B) {\n    N._addPlugin(B);\n  }), N;\n}\nvar util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {\n  name: \"localStorage\",\n  read: read$5,\n  write: write$5,\n  each: each$5,\n  remove: remove$5,\n  clearAll: clearAll$5\n};\nfunction localStorage() {\n  return Global$4.localStorage;\n}\nfunction read$5(o) {\n  return localStorage().getItem(o);\n}\nfunction write$5(o, t) {\n  return localStorage().setItem(o, t);\n}\nfunction each$5(o) {\n  for (var t = localStorage().length - 1; t >= 0; t--) {\n    var e = localStorage().key(t);\n    o(read$5(e), e);\n  }\n}\nfunction remove$5(o) {\n  return localStorage().removeItem(o);\n}\nfunction clearAll$5() {\n  return localStorage().clear();\n}\nvar util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {\n  name: \"oldFF-globalStorage\",\n  read: read$4,\n  write: write$4,\n  each: each$4,\n  remove: remove$4,\n  clearAll: clearAll$4\n}, globalStorage = Global$3.globalStorage;\nfunction read$4(o) {\n  return globalStorage[o];\n}\nfunction write$4(o, t) {\n  globalStorage[o] = t;\n}\nfunction each$4(o) {\n  for (var t = globalStorage.length - 1; t >= 0; t--) {\n    var e = globalStorage.key(t);\n    o(globalStorage[e], e);\n  }\n}\nfunction remove$4(o) {\n  return globalStorage.removeItem(o);\n}\nfunction clearAll$4() {\n  each$4(function(o, t) {\n    delete globalStorage[o];\n  });\n}\nvar util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {\n  name: \"oldIE-userDataStorage\",\n  write: write$3,\n  read: read$3,\n  each: each$3,\n  remove: remove$3,\n  clearAll: clearAll$3\n}, storageName = \"storejs\", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : \"\").match(/ (MSIE 8|MSIE 9|MSIE 10)\\./);\nfunction write$3(o, t) {\n  if (!disable) {\n    var e = fixKey(o);\n    _withStorageEl(function(r) {\n      r.setAttribute(e, t), r.save(storageName);\n    });\n  }\n}\nfunction read$3(o) {\n  if (!disable) {\n    var t = fixKey(o), e = null;\n    return _withStorageEl(function(r) {\n      e = r.getAttribute(t);\n    }), e;\n  }\n}\nfunction each$3(o) {\n  _withStorageEl(function(t) {\n    for (var e = t.XMLDocument.documentElement.attributes, r = e.length - 1; r >= 0; r--) {\n      var S = e[r];\n      o(t.getAttribute(S.name), S.name);\n    }\n  });\n}\nfunction remove$3(o) {\n  var t = fixKey(o);\n  _withStorageEl(function(e) {\n    e.removeAttribute(t), e.save(storageName);\n  });\n}\nfunction clearAll$3() {\n  _withStorageEl(function(o) {\n    var t = o.XMLDocument.documentElement.attributes;\n    o.load(storageName);\n    for (var e = t.length - 1; e >= 0; e--)\n      o.removeAttribute(t[e].name);\n    o.save(storageName);\n  });\n}\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\");\nfunction fixKey(o) {\n  return o.replace(/^\\d/, \"___$&\").replace(forbiddenCharsRegex, \"___\");\n}\nfunction _makeIEStorageElFunction() {\n  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)\n    return null;\n  var o = \"script\", t, e, r;\n  try {\n    e = new ActiveXObject(\"htmlfile\"), e.open(), e.write(\"<\" + o + \">document.w=window</\" + o + '><iframe src=\"/favicon.ico\"></iframe>'), e.close(), t = e.w.frames[0].document, r = t.createElement(\"div\");\n  } catch {\n    r = doc$1.createElement(\"div\"), t = doc$1.body;\n  }\n  return function(S) {\n    var T = [].slice.call(arguments, 0);\n    T.unshift(r), t.appendChild(r), r.addBehavior(\"#default#userData\"), r.load(storageName), S.apply(this, T), t.removeChild(r);\n  };\n}\nvar util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {\n  name: \"cookieStorage\",\n  read: read$2,\n  write: write$2,\n  each: each$2,\n  remove: remove$2,\n  clearAll: clearAll$2\n}, doc = Global$1.document;\nfunction read$2(o) {\n  if (!o || !_has(o))\n    return null;\n  var t = \"(?:^|.*;\\\\s*)\" + escape(o).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\";\n  return unescape(doc.cookie.replace(new RegExp(t), \"$1\"));\n}\nfunction each$2(o) {\n  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)\n    if (!!trim(t[e])) {\n      var r = t[e].split(\"=\"), S = unescape(r[0]), T = unescape(r[1]);\n      o(T, S);\n    }\n}\nfunction write$2(o, t) {\n  !o || (doc.cookie = escape(o) + \"=\" + escape(t) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\");\n}\nfunction remove$2(o) {\n  !o || !_has(o) || (doc.cookie = escape(o) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\");\n}\nfunction clearAll$2() {\n  each$2(function(o, t) {\n    remove$2(t);\n  });\n}\nfunction _has(o) {\n  return new RegExp(\"(?:^|;\\\\s*)\" + escape(o).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\").test(doc.cookie);\n}\nvar util = util$6, Global = util.Global, sessionStorage_1 = {\n  name: \"sessionStorage\",\n  read: read$1,\n  write: write$1,\n  each: each$1,\n  remove: remove$1,\n  clearAll: clearAll$1\n};\nfunction sessionStorage$1() {\n  return Global.sessionStorage;\n}\nfunction read$1(o) {\n  return sessionStorage$1().getItem(o);\n}\nfunction write$1(o, t) {\n  return sessionStorage$1().setItem(o, t);\n}\nfunction each$1(o) {\n  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {\n    var e = sessionStorage$1().key(t);\n    o(read$1(e), e);\n  }\n}\nfunction remove$1(o) {\n  return sessionStorage$1().removeItem(o);\n}\nfunction clearAll$1() {\n  return sessionStorage$1().clear();\n}\nvar memoryStorage_1 = {\n  name: \"memoryStorage\",\n  read,\n  write,\n  each,\n  remove,\n  clearAll\n}, memoryStorage = {};\nfunction read(o) {\n  return memoryStorage[o];\n}\nfunction write(o, t) {\n  memoryStorage[o] = t;\n}\nfunction each(o) {\n  for (var t in memoryStorage)\n    memoryStorage.hasOwnProperty(t) && o(memoryStorage[t], t);\n}\nfunction remove(o) {\n  delete memoryStorage[o];\n}\nfunction clearAll(o) {\n  memoryStorage = {};\n}\nvar all = [\n  localStorage_1,\n  oldFFGlobalStorage,\n  oldIEUserDataStorage,\n  cookieStorage,\n  sessionStorage_1,\n  memoryStorage_1\n], json2$1 = {}, hasRequiredJson2;\nfunction requireJson2() {\n  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != \"object\" && (JSON = {}), function() {\n    var rx_one = /^[\\],:{}\\s]*$/, rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, rx_four = /(?:^|:|,)(?:\\s*\\[)+/g, rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g, rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    function f(o) {\n      return o < 10 ? \"0\" + o : o;\n    }\n    function this_value() {\n      return this.valueOf();\n    }\n    typeof Date.prototype.toJSON != \"function\" && (Date.prototype.toJSON = function() {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);\n    var gap, indent, meta, rep;\n    function quote(o) {\n      return rx_escapable.lastIndex = 0, rx_escapable.test(o) ? '\"' + o.replace(rx_escapable, function(t) {\n        var e = meta[t];\n        return typeof e == \"string\" ? e : \"\\\\u\" + (\"0000\" + t.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + o + '\"';\n    }\n    function str(o, t) {\n      var e, r, S, T, D = gap, N, B = t[o];\n      switch (B && typeof B == \"object\" && typeof B.toJSON == \"function\" && (B = B.toJSON(o)), typeof rep == \"function\" && (B = rep.call(t, o, B)), typeof B) {\n        case \"string\":\n          return quote(B);\n        case \"number\":\n          return isFinite(B) ? String(B) : \"null\";\n        case \"boolean\":\n        case \"null\":\n          return String(B);\n        case \"object\":\n          if (!B)\n            return \"null\";\n          if (gap += indent, N = [], Object.prototype.toString.apply(B) === \"[object Array]\") {\n            for (T = B.length, e = 0; e < T; e += 1)\n              N[e] = str(e, B) || \"null\";\n            return S = N.length === 0 ? \"[]\" : gap ? `[\n` + gap + N.join(`,\n` + gap) + `\n` + D + \"]\" : \"[\" + N.join(\",\") + \"]\", gap = D, S;\n          }\n          if (rep && typeof rep == \"object\")\n            for (T = rep.length, e = 0; e < T; e += 1)\n              typeof rep[e] == \"string\" && (r = rep[e], S = str(r, B), S && N.push(quote(r) + (gap ? \": \" : \":\") + S));\n          else\n            for (r in B)\n              Object.prototype.hasOwnProperty.call(B, r) && (S = str(r, B), S && N.push(quote(r) + (gap ? \": \" : \":\") + S));\n          return S = N.length === 0 ? \"{}\" : gap ? `{\n` + gap + N.join(`,\n` + gap) + `\n` + D + \"}\" : \"{\" + N.join(\",\") + \"}\", gap = D, S;\n      }\n    }\n    typeof JSON.stringify != \"function\" && (meta = {\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    }, JSON.stringify = function(o, t, e) {\n      var r;\n      if (gap = \"\", indent = \"\", typeof e == \"number\")\n        for (r = 0; r < e; r += 1)\n          indent += \" \";\n      else\n        typeof e == \"string\" && (indent = e);\n      if (rep = t, t && typeof t != \"function\" && (typeof t != \"object\" || typeof t.length != \"number\"))\n        throw new Error(\"JSON.stringify\");\n      return str(\"\", { \"\": o });\n    }), typeof JSON.parse != \"function\" && (JSON.parse = function(text, reviver) {\n      var j;\n      function walk(o, t) {\n        var e, r, S = o[t];\n        if (S && typeof S == \"object\")\n          for (e in S)\n            Object.prototype.hasOwnProperty.call(S, e) && (r = walk(S, e), r !== void 0 ? S[e] = r : delete S[e]);\n        return reviver.call(o, t, S);\n      }\n      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(o) {\n        return \"\\\\u\" + (\"0000\" + o.charCodeAt(0).toString(16)).slice(-4);\n      })), rx_one.test(\n        text.replace(rx_two, \"@\").replace(rx_three, \"]\").replace(rx_four, \"\")\n      ))\n        return j = eval(\"(\" + text + \")\"), typeof reviver == \"function\" ? walk({ \"\": j }, \"\") : j;\n      throw new SyntaxError(\"JSON.parse\");\n    });\n  }()), json2$1;\n}\nvar json2 = json2Plugin;\nfunction json2Plugin() {\n  return requireJson2(), {};\n}\nvar engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);\nconst devtools = {\n  isOpen: !1,\n  orientation: void 0\n}, threshold = 170, emitEvent = (o, t) => {\n  globalThis.dispatchEvent(new globalThis.CustomEvent(\"devtoolschange\", {\n    detail: {\n      isOpen: o,\n      orientation: t\n    }\n  }));\n}, main = ({ emitEvents: o = !0 } = {}) => {\n  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, r = t ? \"vertical\" : \"horizontal\";\n  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== r) && o && emitEvent(!0, r), devtools.isOpen = !0, devtools.orientation = r) : (devtools.isOpen && o && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);\n};\nmain({ emitEvents: !1 });\nsetInterval(main, 500);\nvar Fa, Zl, Ri, Jl;\nclass SysWeb extends SysBase {\n  constructor(e = {}, r = { cur: \"prj/\", crypto: !1, dip: \"\" }) {\n    super(e, r);\n    tt(this, Fa, \"\");\n    tt(this, Zl, \":\");\n    Rt(this, \"run\", async () => {\n      z(this, Ri) && (z(this, Ri).destroy(10), await new Promise((r) => setTimeout(r, 10))), ot(this, Ri, new Main(this));\n    });\n    tt(this, Ri, void 0);\n    Rt(this, \"pathBaseCnvSnPath4Dbg\", \"${pathbase}/\");\n    Rt(this, \"_export\", () => ((async () => {\n      const e = JSON.stringify({\n        sys: this.data.sys,\n        mark: this.data.mark,\n        kidoku: this.data.kidoku\n      }), r = this.crypto ? await this.enc(e) : e, S = new Blob([r], { type: \"text/json\" }), T = document.createElement(\"a\");\n      T.href = URL.createObjectURL(S), T.download = (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + getDateStr(\"-\", \"_\", \"\") + \".swpd\", T.click(), CmnLib.debugLog && console.log(\"プレイデータをエクスポートしました\"), setTimeout(() => this.fire(\"sn:exported\", new Event(\"click\")), 10);\n    })(), !1));\n    Rt(this, \"_import\", () => (new Promise((e, r) => {\n      const S = document.createElement(\"input\");\n      S.type = \"file\", S.accept = \".swpd, text/plain\", S.onchange = () => {\n        S.files ? e(S.files[0]) : r();\n      }, S.click();\n    }).then((e) => new Promise((r) => {\n      const S = new FileReader();\n      S.readAsText(e), S.onload = () => r(S.result);\n    })).then(async (e) => {\n      const r = JSON.parse(this.crypto ? this.decStr(\"json\", e) : e);\n      if (!r.sys || !r.mark || !r.kidoku)\n        throw new Error(\"異常なプレイデータです\");\n      if (r.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {\n        console.error(`別のゲーム【プロジェクト名=${r.sys[SysBase.VALNM_CFG_NS]}】のプレイデータです`);\n        return;\n      }\n      this.data.sys = r.sys, this.data.mark = r.mark, this.data.kidoku = r.kidoku, this.flush(), this.val.updateData(r), CmnLib.debugLog && console.log(\"プレイデータをインポートしました\"), this.fire(\"sn:imported\", new Event(\"click\"));\n    }).catch((e) => console.error(`異常なプレイデータです ${e.message}`)), !1));\n    Rt(this, \"navigate_to\", (e) => {\n      const { url: r } = e;\n      if (!r)\n        throw \"[navigate_to] urlは必須です\";\n      return globalThis.open(r, \"_blank\"), !1;\n    });\n    tt(this, Jl, {});\n    const S = r.cur.split(\"/\");\n    ot(this, Fa, S.length > 2 ? S.slice(0, -2).join(\"/\") + \"/\" : \"\"), globalThis.onload = async () => this.loaded(e, r);\n  }\n  async loaded(e, r) {\n    await super.loaded(e, r), document.querySelectorAll(\"[data-prj]\").forEach((N) => {\n      const B = N.attributes.getNamedItem(\"data-prj\");\n      B && N.addEventListener(\"click\", () => this.runSN(B.value), { passive: !0 });\n    }), document.querySelectorAll(\"[data-reload]\").forEach(\n      (N) => N.addEventListener(\"click\", () => this.run(), { passive: !0 })\n    ), r.dip && (CmnLib.hDip = JSON.parse(r.dip));\n    const S = new URLSearchParams(location.search), T = S.get(\"dip\");\n    if (T && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(T.replaceAll(\"%2C\", \",\")) }), !argChk_Boolean(CmnLib.hDip, \"oninit_run\", !0))\n      return;\n    argChk_Boolean(CmnLib.hDip, \"dbg\", !1) && (CmnLib.isDbg = !0, this.fetch = (N) => fetch(N, { mode: \"cors\" })), this.extPort = argChk_Num(CmnLib.hDip, \"port\", this.extPort);\n    const D = S.get(\"cur\");\n    D && (r.cur = z(this, Fa) + D + \"/\"), this.run();\n  }\n  runSN(e) {\n    this.arg.cur = z(this, Fa) + e + \"/\", z(this, Zl) !== this.arg.cur && (ot(this, Zl, this.arg.cur), this.run());\n  }\n  stop() {\n    !z(this, Ri) || (z(this, Ri).destroy(), ot(this, Ri, void 0));\n  }\n  async loadPath(e, r) {\n    await super.loadPath(e, r);\n    const S = this.arg.cur + \"path.json\", T = await fetch(S);\n    if (!T.ok)\n      throw Error(T.statusText);\n    const D = await T.text(), N = JSON.parse(this.decStr(S, D));\n    for (const [B, $] of Object.entries(N)) {\n      const U = e[B] = $;\n      for (const [V, H] of Object.entries(U))\n        V !== \":cnt\" && (U[V] = this.arg.cur + H);\n    }\n  }\n  initVal(e, r, S) {\n    const T = encodeURIComponent(document.location.hostname);\n    r[\"const.sn.isDebugger\"] = T === \"localhost\" || T === \"127.0.0.1\";\n    const D = this.cfg.getNs();\n    this.flush = this.crypto ? async () => {\n      store_legacy.set(D + \"sys_\", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(D + \"mark_\", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(D + \"kidoku_\", this.enc(JSON.stringify(this.data.kidoku)));\n    } : () => {\n      store_legacy.set(D + \"sys\", this.data.sys), store_legacy.set(D + \"mark\", this.data.mark), store_legacy.set(D + \"kidoku\", this.data.kidoku);\n    };\n    const N = D + (this.arg.crypto ? \"sys_\" : \"sys\");\n    if (r[\"const.sn.isFirstBoot\"] = store_legacy.get(N) === void 0) {\n      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), S(this.data);\n      return;\n    }\n    if (!this.crypto) {\n      this.data.sys = store_legacy.get(D + \"sys\"), this.data.mark = store_legacy.get(D + \"mark\"), this.data.kidoku = store_legacy.get(D + \"kidoku\"), S(this.data);\n      return;\n    }\n    let B = \"\";\n    try {\n      B = \"sys\", this.data.sys = JSON.parse(this.decStr(\"json\", store_legacy.get(D + \"sys_\"))), B += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), B = \"mark\", this.data.mark = JSON.parse(this.decStr(\"json\", store_legacy.get(D + \"mark_\"))), B = \"kidoku\", this.data.kidoku = JSON.parse(this.decStr(\"json\", store_legacy.get(D + \"kidoku_\")));\n    } catch ($) {\n      console.error(`セーブデータ（${B}）が壊れています。一度クリアする必要があります %o`, $);\n    }\n    S(this.data);\n  }\n  init(e, r, S, T) {\n    super.init(e, r, S, T);\n    const D = r.view.parentElement;\n    if (\"requestFullscreen\" in document.body)\n      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : D.requestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = Boolean(document.fullscreenElement));\n    else {\n      const N = document;\n      this.tglFlscr_sub = () => this.isFullScr ? N.webkitCancelFullScreen() : D.webkitRequestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = Boolean(N.webkitFullscreenElement));\n    }\n    return this.cfg.oCfg.debug.devtool || this.elc.add(window, \"devtoolschange\", (N) => {\n      !N.detail.isOpen || (console.error(\"DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。\"), T.destroy());\n    }, { once: !0, passive: !0 }), [];\n  }\n  cvsResize() {\n    if (super.cvsResize(), this.isFullScr) {\n      const e = Main.cvs.style;\n      e.width = e.height = \"\";\n    }\n  }\n  titleSub(e) {\n    document.title = e, document.querySelectorAll(\"[data-title]\").forEach((r) => r.textContent = e);\n  }\n  async savePic(e, r) {\n    const S = document.createElement(\"a\");\n    S.href = r, S.download = e, S.click(), CmnLib.debugLog && console.log(\"画像ファイルをダウンロードします\");\n  }\n  async appendFile(e, r, S) {\n    const T = (z(this, Jl)[e] ?? \"\") + r;\n    z(this, Jl)[e] = T;\n    const D = new Blob([T], { type: \"text/json\" }), N = document.createElement(\"a\");\n    N.href = URL.createObjectURL(D), N.download = e, N.click();\n  }\n}\nFa = new WeakMap(), Zl = new WeakMap(), Ri = new WeakMap(), Jl = new WeakMap();\n\n//# sourceMappingURL=web.js.map\n\n\n//# sourceURL=webpack://gallery/./node_modules/@famibee/skynovel/dist/web.js?");

/***/ })

}]);