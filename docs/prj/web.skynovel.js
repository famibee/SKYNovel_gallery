"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel"],{

/***/ "./node_modules/@famibee/skynovel/dist/web.js":
/*!****************************************************!*\
  !*** ./node_modules/@famibee/skynovel/dist/web.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ CmnLib),\n/* harmony export */   \"Layer\": () => (/* binding */ Layer),\n/* harmony export */   \"SysWeb\": () => (/* binding */ SysWeb),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ argChk_Boolean),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ argChk_Num)\n/* harmony export */ });\nvar Np = Object.defineProperty;\nvar Lp = (o, t, e) => t in o ? Np(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;\nvar Ot = (o, t, e) => (Lp(o, typeof t != \"symbol\" ? t + \"\" : t, e), e), Vc = (o, t, e) => {\n  if (!t.has(o))\n    throw TypeError(\"Cannot \" + e);\n};\nvar H = (o, t, e) => (Vc(o, t, \"read from private field\"), e ? e.call(o) : t.get(o)), rt = (o, t, e) => {\n  if (t.has(o))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(o) : t.set(o, e);\n}, ot = (o, t, e, r) => (Vc(o, t, \"write to private field\"), r ? r.call(o, e) : t.set(o, e), e), Ie = (o, t, e, r) => ({\n  set _(D) {\n    ot(o, t, D, e);\n  },\n  get _() {\n    return H(o, t, r);\n  }\n}), lt = (o, t, e) => (Vc(o, t, \"access private method\"), e);\nvar commonjsGlobal = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {}, platformExports = {}, platform = {\n  get exports() {\n    return platformExports;\n  },\n  set exports(o) {\n    platformExports = o;\n  }\n};\n/*!\n * Platform.js v1.3.6\n * Copyright 2014-2020 Benjamin Tan\n * Copyright 2011-2013 John-David Dalton\n * Available under MIT license\n */\n(function(o, t) {\n  (function() {\n    var e = {\n      function: !0,\n      object: !0\n    }, r = e[typeof window] && window || this, D = t, N = o && !o.nodeType && o, k = D && N && typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    k && (k.global === k || k.window === k || k.self === k) && (r = k);\n    var $ = Math.pow(2, 53) - 1, G = /\\bOpera/, U = Object.prototype, z = U.hasOwnProperty, X = U.toString;\n    function V(st) {\n      return st = String(st), st.charAt(0).toUpperCase() + st.slice(1);\n    }\n    function Y(st, at, ut) {\n      var ft = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      return at && ut && /^Win/i.test(st) && !/^Windows Phone /i.test(st) && (ft = ft[/[\\d.]+$/.exec(st)]) && (st = \"Windows \" + ft), st = String(st), at && ut && (st = st.replace(RegExp(at, \"i\"), ut)), st = W(\n        st.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]\n      ), st;\n    }\n    function q(st, at) {\n      var ut = -1, ft = st ? st.length : 0;\n      if (typeof ft == \"number\" && ft > -1 && ft <= $)\n        for (; ++ut < ft; )\n          at(st[ut], ut, st);\n      else\n        K(st, at);\n    }\n    function W(st) {\n      return st = nt(st), /^(?:webOS|i(?:OS|P))/.test(st) ? st : V(st);\n    }\n    function K(st, at) {\n      for (var ut in st)\n        z.call(st, ut) && at(st[ut], ut, st);\n    }\n    function Z(st) {\n      return st == null ? V(st) : X.call(st).slice(8, -1);\n    }\n    function J(st, at) {\n      var ut = st != null ? typeof st[at] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(ut) && (ut == \"object\" ? !!st[at] : !0);\n    }\n    function Q(st) {\n      return String(st).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function et(st, at) {\n      var ut = null;\n      return q(st, function(ft, ct) {\n        ut = at(ut, ft, ct, st);\n      }), ut;\n    }\n    function nt(st) {\n      return String(st).replace(/^ +| +$/g, \"\");\n    }\n    function tt(st) {\n      var at = r, ut = st && typeof st == \"object\" && Z(st) != \"String\";\n      ut && (at = st, st = null);\n      var ft = at.navigator || {}, ct = ft.userAgent || \"\";\n      st || (st = ct);\n      var vt = ut ? !!ft.likeChrome : /\\bChrome\\b/.test(st) && !/internal|\\n/i.test(X.toString()), yt = \"Object\", mt = ut ? yt : \"ScriptBridgingProxyObject\", _t = ut ? yt : \"Environment\", Tt = ut && at.java ? \"JavaPackage\" : Z(at.java), Pt = ut ? yt : \"RuntimeObject\", St = /\\bJava/.test(Tt) && at.java, gt = St && Z(at.environment) == _t, bt = St ? \"a\" : \"α\", Nt = St ? \"b\" : \"β\", At = at.document || {}, It = at.operamini || at.opera, Mt = G.test(Mt = ut && It ? It[\"[[Class]]\"] : Z(It)) ? Mt : It = null, dt, $t = st, Dt = [], Vt = null, Lt = st == ct, Et = Lt && It && typeof It.version == \"function\" && It.version(), Ht, kt = qt([\n        { label: \"EdgeHTML\", pattern: \"Edge\" },\n        \"Trident\",\n        { label: \"WebKit\", pattern: \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]), wt = Kt([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { label: \"Microsoft Edge\", pattern: \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { label: \"Samsung Internet\", pattern: \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { label: \"Silk\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { label: \"SRWare Iron\", pattern: \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { label: \"Yandex Browser\", pattern: \"YaBrowser\" },\n        { label: \"UC Browser\", pattern: \"UCBrowser\" },\n        \"Opera Mini\",\n        { label: \"Opera Mini\", pattern: \"OPiOS\" },\n        \"Opera\",\n        { label: \"Opera\", pattern: \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { label: \"Chrome\", pattern: \"(?:HeadlessChrome)\" },\n        { label: \"Chrome Mobile\", pattern: \"(?:CriOS|CrMo)\" },\n        { label: \"Firefox\", pattern: \"(?:Firefox|Minefield)\" },\n        { label: \"Firefox for iOS\", pattern: \"FxiOS\" },\n        { label: \"IE\", pattern: \"IEMobile\" },\n        { label: \"IE\", pattern: \"MSIE\" },\n        \"Safari\"\n      ]), Bt = Oe([\n        { label: \"BlackBerry\", pattern: \"BB10\" },\n        \"BlackBerry\",\n        { label: \"Galaxy S\", pattern: \"GT-I9000\" },\n        { label: \"Galaxy S2\", pattern: \"GT-I9100\" },\n        { label: \"Galaxy S3\", pattern: \"GT-I9300\" },\n        { label: \"Galaxy S4\", pattern: \"GT-I9500\" },\n        { label: \"Galaxy S5\", pattern: \"SM-G900\" },\n        { label: \"Galaxy S6\", pattern: \"SM-G920\" },\n        { label: \"Galaxy S6 Edge\", pattern: \"SM-G925\" },\n        { label: \"Galaxy S7\", pattern: \"SM-G930\" },\n        { label: \"Galaxy S7 Edge\", pattern: \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { label: \"Kindle Fire\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { label: \"Wii U\", pattern: \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { label: \"Xbox 360\", pattern: \"Xbox\" },\n        \"Xoom\"\n      ]), jt = Qt({\n        Apple: { iPad: 1, iPhone: 1, iPod: 1 },\n        Alcatel: {},\n        Archos: {},\n        Amazon: { Kindle: 1, \"Kindle Fire\": 1 },\n        Asus: { Transformer: 1 },\n        \"Barnes & Noble\": { Nook: 1 },\n        BlackBerry: { PlayBook: 1 },\n        Google: { \"Google TV\": 1, Nexus: 1 },\n        HP: { TouchPad: 1 },\n        HTC: {},\n        Huawei: {},\n        Lenovo: {},\n        LG: {},\n        Microsoft: { Xbox: 1, \"Xbox One\": 1 },\n        Motorola: { Xoom: 1 },\n        Nintendo: { \"Wii U\": 1, Wii: 1 },\n        Nokia: { Lumia: 1 },\n        Oppo: {},\n        Samsung: { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        Sony: { PlayStation: 1, \"PlayStation Vita\": 1 },\n        Xiaomi: { Mi: 1, Redmi: 1 }\n      }), Ct = Se([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { label: \"Chrome OS\", pattern: \"CrOS\" },\n        \"Debian\",\n        { label: \"DragonFly BSD\", pattern: \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function qt(de) {\n        return et(de, function(fe, ne) {\n          return fe || RegExp(\"\\\\b\" + (ne.pattern || Q(ne)) + \"\\\\b\", \"i\").exec(st) && (ne.label || ne);\n        });\n      }\n      function Qt(de) {\n        return et(de, function(fe, ne, Ve) {\n          return fe || (ne[Bt] || ne[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(Bt)] || RegExp(\"\\\\b\" + Q(Ve) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(st)) && Ve;\n        });\n      }\n      function Kt(de) {\n        return et(de, function(fe, ne) {\n          return fe || RegExp(\"\\\\b\" + (ne.pattern || Q(ne)) + \"\\\\b\", \"i\").exec(st) && (ne.label || ne);\n        });\n      }\n      function Se(de) {\n        return et(de, function(fe, ne) {\n          var Ve = ne.pattern || Q(ne);\n          return !fe && (fe = RegExp(\"\\\\b\" + Ve + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(st)) && (fe = Y(fe, Ve, ne.label || ne)), fe;\n        });\n      }\n      function Oe(de) {\n        return et(de, function(fe, ne) {\n          var Ve = ne.pattern || Q(ne);\n          return !fe && (fe = RegExp(\"\\\\b\" + Ve + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(st) || RegExp(\"\\\\b\" + Ve + \" *\\\\w+-[\\\\w]*\", \"i\").exec(st) || RegExp(\"\\\\b\" + Ve + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(st)) && ((fe = String(ne.label && !RegExp(Ve, \"i\").test(ne.label) ? ne.label : fe).split(\"/\"))[1] && !/[\\d.]+/.test(fe[0]) && (fe[0] += \" \" + fe[1]), ne = ne.label || ne, fe = W(fe[0].replace(RegExp(Ve, \"i\"), ne).replace(RegExp(\"; *(?:\" + ne + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + ne + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"))), fe;\n        });\n      }\n      function ue(de) {\n        return et(de, function(fe, ne) {\n          return fe || (RegExp(ne + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(st) || 0)[1] || null;\n        });\n      }\n      function _e() {\n        return this.description || \"\";\n      }\n      if (kt && (kt = [kt]), /\\bAndroid\\b/.test(Ct) && !Bt && (dt = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(st)) && (Bt = nt(dt[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null), jt && !Bt ? Bt = Oe([jt]) : jt && Bt && (Bt = Bt.replace(RegExp(\"^(\" + Q(jt) + \")[-_.\\\\s]\", \"i\"), jt + \" \").replace(RegExp(\"^(\" + Q(jt) + \")[-_.]?(\\\\w)\", \"i\"), jt + \" $2\")), (dt = /\\bGoogle TV\\b/.exec(Bt)) && (Bt = dt[0]), /\\bSimulator\\b/i.test(st) && (Bt = (Bt ? Bt + \" \" : \"\") + \"Simulator\"), wt == \"Opera Mini\" && /\\bOPiOS\\b/.test(st) && Dt.push(\"running in Turbo/Uncompressed mode\"), wt == \"IE\" && /\\blike iPhone OS\\b/.test(st) ? (dt = tt(st.replace(/like iPhone OS/, \"\")), jt = dt.manufacturer, Bt = dt.product) : /^iP/.test(Bt) ? (wt || (wt = \"Safari\"), Ct = \"iOS\" + ((dt = / OS ([\\d_]+)/i.exec(st)) ? \" \" + dt[1].replace(/_/g, \".\") : \"\")) : wt == \"Konqueror\" && /^Linux\\b/i.test(Ct) ? Ct = \"Kubuntu\" : jt && jt != \"Google\" && (/Chrome/.test(wt) && !/\\bMobile Safari\\b/i.test(st) || /\\bVita\\b/.test(Bt)) || /\\bAndroid\\b/.test(Ct) && /^Chrome/.test(wt) && /\\bVersion\\//i.test(st) ? (wt = \"Android Browser\", Ct = /\\bAndroid\\b/.test(Ct) ? Ct : \"Android\") : wt == \"Silk\" ? (/\\bMobi/i.test(st) || (Ct = \"Android\", Dt.unshift(\"desktop mode\")), /Accelerated *= *true/i.test(st) && Dt.unshift(\"accelerated\")) : wt == \"UC Browser\" && /\\bUCWEB\\b/.test(st) ? Dt.push(\"speed mode\") : wt == \"PaleMoon\" && (dt = /\\bFirefox\\/([\\d.]+)\\b/.exec(st)) ? Dt.push(\"identifying as Firefox \" + dt[1]) : wt == \"Firefox\" && (dt = /\\b(Mobile|Tablet|TV)\\b/i.exec(st)) ? (Ct || (Ct = \"Firefox OS\"), Bt || (Bt = dt[1])) : !wt || (dt = !/\\bMinefield\\b/i.test(st) && /\\b(?:Firefox|Safari)\\b/.exec(wt)) ? (wt && !Bt && /[\\/,]|^[^(]+?\\)/.test(st.slice(st.indexOf(dt + \"/\") + 8)) && (wt = null), (dt = Bt || jt || Ct) && (Bt || jt || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(Ct)) && (wt = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(Ct) ? Ct : dt) + \" Browser\")) : wt == \"Electron\" && (dt = (/\\bChrome\\/([\\d.]+)\\b/.exec(st) || 0)[1]) && Dt.push(\"Chromium \" + dt), Et || (Et = ue([\n        \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n        \"Version\",\n        Q(wt),\n        \"(?:Firefox|Minefield|NetFront)\"\n      ])), (dt = kt == \"iCab\" && parseFloat(Et) > 3 && \"WebKit\" || /\\bOpera\\b/.test(wt) && (/\\bOPR\\b/.test(st) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(st) && !/^(?:Trident|EdgeHTML)$/.test(kt) && \"WebKit\" || !kt && /\\bMSIE\\b/i.test(st) && (Ct == \"Mac OS\" ? \"Tasman\" : \"Trident\") || kt == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(wt) && \"NetFront\") && (kt = [dt]), wt == \"IE\" && (dt = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(st) || 0)[1]) ? (wt += \" Mobile\", Ct = \"Windows Phone \" + (/\\+$/.test(dt) ? dt : dt + \".x\"), Dt.unshift(\"desktop mode\")) : /\\bWPDesktop\\b/i.test(st) ? (wt = \"IE Mobile\", Ct = \"Windows Phone 8.x\", Dt.unshift(\"desktop mode\"), Et || (Et = (/\\brv:([\\d.]+)/.exec(st) || 0)[1])) : wt != \"IE\" && kt == \"Trident\" && (dt = /\\brv:([\\d.]+)/.exec(st)) && (wt && Dt.push(\"identifying as \" + wt + (Et ? \" \" + Et : \"\")), wt = \"IE\", Et = dt[1]), Lt) {\n        if (J(at, \"global\"))\n          if (St && (dt = St.lang.System, $t = dt.getProperty(\"os.arch\"), Ct = Ct || dt.getProperty(\"os.name\") + \" \" + dt.getProperty(\"os.version\")), gt) {\n            try {\n              Et = at.require(\"ringo/engine\").version.join(\".\"), wt = \"RingoJS\";\n            } catch {\n              (dt = at.system) && dt.global.system == at.system && (wt = \"Narwhal\", Ct || (Ct = dt[0].os || null));\n            }\n            wt || (wt = \"Rhino\");\n          } else\n            typeof at.process == \"object\" && !at.process.browser && (dt = at.process) && (typeof dt.versions == \"object\" && (typeof dt.versions.electron == \"string\" ? (Dt.push(\"Node \" + dt.versions.node), wt = \"Electron\", Et = dt.versions.electron) : typeof dt.versions.nw == \"string\" && (Dt.push(\"Chromium \" + Et, \"Node \" + dt.versions.node), wt = \"NW.js\", Et = dt.versions.nw)), wt || (wt = \"Node.js\", $t = dt.arch, Ct = dt.platform, Et = /[\\d.]+/.exec(dt.version), Et = Et ? Et[0] : null));\n        else\n          Z(dt = at.runtime) == mt ? (wt = \"Adobe AIR\", Ct = dt.flash.system.Capabilities.os) : Z(dt = at.phantom) == Pt ? (wt = \"PhantomJS\", Et = (dt = dt.version || null) && dt.major + \".\" + dt.minor + \".\" + dt.patch) : typeof At.documentMode == \"number\" && (dt = /\\bTrident\\/(\\d+)/i.exec(st)) ? (Et = [Et, At.documentMode], (dt = +dt[1] + 4) != Et[1] && (Dt.push(\"IE \" + Et[1] + \" mode\"), kt && (kt[1] = \"\"), Et[1] = dt), Et = wt == \"IE\" ? String(Et[1].toFixed(1)) : Et[0]) : typeof At.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(wt) && (Dt.push(\"masking as \" + wt + \" \" + Et), wt = \"IE\", Et = \"11.0\", kt = [\"Trident\"], Ct = \"Windows\");\n        Ct = Ct && W(Ct);\n      }\n      if (Et && (dt = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(Et) || /(?:alpha|beta)(?: ?\\d)?/i.exec(st + \";\" + (Lt && ft.appMinorVersion)) || /\\bMinefield\\b/i.test(st) && \"a\") && (Vt = /b/i.test(dt) ? \"beta\" : \"alpha\", Et = Et.replace(RegExp(dt + \"\\\\+?$\"), \"\") + (Vt == \"beta\" ? Nt : bt) + (/\\d+\\+?/.exec(dt) || \"\")), wt == \"Fennec\" || wt == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(Ct))\n        wt = \"Firefox Mobile\";\n      else if (wt == \"Maxthon\" && Et)\n        Et = Et.replace(/\\.[\\d.]+/, \".x\");\n      else if (/\\bXbox\\b/i.test(Bt))\n        Bt == \"Xbox 360\" && (Ct = null), Bt == \"Xbox 360\" && /\\bIEMobile\\b/.test(st) && Dt.unshift(\"mobile mode\");\n      else if ((/^(?:Chrome|IE|Opera)$/.test(wt) || wt && !Bt && !/Browser|Mobi/.test(wt)) && (Ct == \"Windows CE\" || /Mobi/i.test(st)))\n        wt += \" Mobile\";\n      else if (wt == \"IE\" && Lt)\n        try {\n          at.external === null && Dt.unshift(\"platform preview\");\n        } catch {\n          Dt.unshift(\"embedded\");\n        }\n      else\n        (/\\bBlackBerry\\b/.test(Bt) || /\\bBB10\\b/.test(st)) && (dt = (RegExp(Bt.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(st) || 0)[1] || Et) ? (dt = [dt, /BB10/.test(st)], Ct = (dt[1] ? (Bt = null, jt = \"BlackBerry\") : \"Device Software\") + \" \" + dt[0], Et = null) : this != K && Bt != \"Wii\" && (Lt && It || /Opera/.test(wt) && /\\b(?:MSIE|Firefox)\\b/i.test(st) || wt == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(Ct) || wt == \"IE\" && (Ct && !/^Win/.test(Ct) && Et > 5.5 || /\\bWindows XP\\b/.test(Ct) && Et > 8 || Et == 8 && !/\\bTrident\\b/.test(st))) && !G.test(dt = tt.call(K, st.replace(G, \"\") + \";\")) && dt.name && (dt = \"ing as \" + dt.name + ((dt = dt.version) ? \" \" + dt : \"\"), G.test(wt) ? (/\\bIE\\b/.test(dt) && Ct == \"Mac OS\" && (Ct = null), dt = \"identify\" + dt) : (dt = \"mask\" + dt, Mt ? wt = W(Mt.replace(/([a-z])([A-Z])/g, \"$1 $2\")) : wt = \"Opera\", /\\bIE\\b/.test(dt) && (Ct = null), Lt || (Et = null)), kt = [\"Presto\"], Dt.push(dt));\n      (dt = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(st) || 0)[1]) && (dt = [parseFloat(dt.replace(/\\.(\\d)$/, \".0$1\")), dt], wt == \"Safari\" && dt[1].slice(-1) == \"+\" ? (wt = \"WebKit Nightly\", Vt = \"alpha\", Et = dt[1].slice(0, -1)) : (Et == dt[1] || Et == (dt[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(st) || 0)[1])) && (Et = null), dt[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(st) || 0)[1], dt[0] == 537.36 && dt[2] == 537.36 && parseFloat(dt[1]) >= 28 && kt == \"WebKit\" && (kt = [\"Blink\"]), !Lt || !vt && !dt[1] ? (kt && (kt[1] = \"like Safari\"), dt = (dt = dt[0], dt < 400 ? 1 : dt < 500 ? 2 : dt < 526 ? 3 : dt < 533 ? 4 : dt < 534 ? \"4+\" : dt < 535 ? 5 : dt < 537 ? 6 : dt < 538 ? 7 : dt < 601 ? 8 : dt < 602 ? 9 : dt < 604 ? 10 : dt < 606 ? 11 : dt < 608 ? 12 : \"12\")) : (kt && (kt[1] = \"like Chrome\"), dt = dt[1] || (dt = dt[0], dt < 530 ? 1 : dt < 532 ? 2 : dt < 532.05 ? 3 : dt < 533 ? 4 : dt < 534.03 ? 5 : dt < 534.07 ? 6 : dt < 534.1 ? 7 : dt < 534.13 ? 8 : dt < 534.16 ? 9 : dt < 534.24 ? 10 : dt < 534.3 ? 11 : dt < 535.01 ? 12 : dt < 535.02 ? \"13+\" : dt < 535.07 ? 15 : dt < 535.11 ? 16 : dt < 535.19 ? 17 : dt < 536.05 ? 18 : dt < 536.1 ? 19 : dt < 537.01 ? 20 : dt < 537.11 ? \"21+\" : dt < 537.13 ? 23 : dt < 537.18 ? 24 : dt < 537.24 ? 25 : dt < 537.36 ? 26 : kt != \"Blink\" ? \"27\" : \"28\")), kt && (kt[1] += \" \" + (dt += typeof dt == \"number\" ? \".x\" : /[.+]/.test(dt) ? \"\" : \"+\")), wt == \"Safari\" && (!Et || parseInt(Et) > 45) ? Et = dt : wt == \"Chrome\" && /\\bHeadlessChrome/i.test(st) && Dt.unshift(\"headless\")), wt == \"Opera\" && (dt = /\\bzbov|zvav$/.exec(Ct)) ? (wt += \" \", Dt.unshift(\"desktop mode\"), dt == \"zvav\" ? (wt += \"Mini\", Et = null) : wt += \"Mobile\", Ct = Ct.replace(RegExp(\" *\" + dt + \"$\"), \"\")) : wt == \"Safari\" && /\\bChrome\\b/.exec(kt && kt[1]) ? (Dt.unshift(\"desktop mode\"), wt = \"Chrome Mobile\", Et = null, /\\bOS X\\b/.test(Ct) ? (jt = \"Apple\", Ct = \"iOS 4.3+\") : Ct = null) : /\\bSRWare Iron\\b/.test(wt) && !Et && (Et = ue(\"Chrome\")), Et && Et.indexOf(dt = /[\\d.]+$/.exec(Ct)) == 0 && st.indexOf(\"/\" + dt + \"-\") > -1 && (Ct = nt(Ct.replace(dt, \"\"))), Ct && Ct.indexOf(wt) != -1 && !RegExp(wt + \" OS\").test(Ct) && (Ct = Ct.replace(RegExp(\" *\" + Q(wt) + \" *\"), \"\")), kt && !/\\b(?:Avant|Nook)\\b/.test(wt) && (/Browser|Lunascape|Maxthon/.test(wt) || wt != \"Safari\" && /^iOS/.test(Ct) && /\\bSafari\\b/.test(kt[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(wt) && kt[1]) && (dt = kt[kt.length - 1]) && Dt.push(dt), Dt.length && (Dt = [\"(\" + Dt.join(\"; \") + \")\"]), jt && Bt && Bt.indexOf(jt) < 0 && Dt.push(\"on \" + jt), Bt && Dt.push((/^on /.test(Dt[Dt.length - 1]) ? \"\" : \"on \") + Bt), Ct && (dt = / ([\\d.+]+)$/.exec(Ct), Ht = dt && Ct.charAt(Ct.length - dt[0].length - 1) == \"/\", Ct = {\n        architecture: 32,\n        family: dt && !Ht ? Ct.replace(dt[0], \"\") : Ct,\n        version: dt ? dt[1] : null,\n        toString: function() {\n          var de = this.version;\n          return this.family + (de && !Ht ? \" \" + de : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n        }\n      }), (dt = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec($t)) && !/\\bi686\\b/i.test($t) ? (Ct && (Ct.architecture = 64, Ct.family = Ct.family.replace(RegExp(\" *\" + dt), \"\")), wt && (/\\bWOW64\\b/i.test(st) || Lt && /\\w(?:86|32)$/.test(ft.cpuClass || ft.platform) && !/\\bWin64; x64\\b/i.test(st)) && Dt.unshift(\"32-bit\")) : Ct && /^OS X/.test(Ct.family) && wt == \"Chrome\" && parseFloat(Et) >= 39 && (Ct.architecture = 64), st || (st = null);\n      var ve = {};\n      return ve.description = st, ve.layout = kt && kt[0], ve.manufacturer = jt, ve.name = wt, ve.prerelease = Vt, ve.product = Bt, ve.ua = st, ve.version = wt && Et, ve.os = Ct || {\n        /**\n         * The CPU architecture the OS is built for.\n         *\n         * @memberOf platform.os\n         * @type number|null\n         */\n        architecture: null,\n        /**\n         * The family of the OS.\n         *\n         * Common values include:\n         * \"Windows\", \"Windows Server 2008 R2 / 7\", \"Windows Server 2008 / Vista\",\n         * \"Windows XP\", \"OS X\", \"Linux\", \"Ubuntu\", \"Debian\", \"Fedora\", \"Red Hat\",\n         * \"SuSE\", \"Android\", \"iOS\" and \"Windows Phone\"\n         *\n         * @memberOf platform.os\n         * @type string|null\n         */\n        family: null,\n        /**\n         * The version of the OS.\n         *\n         * @memberOf platform.os\n         * @type string|null\n         */\n        version: null,\n        /**\n         * Returns the OS string.\n         *\n         * @memberOf platform.os\n         * @returns {string} The OS string.\n         */\n        toString: function() {\n          return \"null\";\n        }\n      }, ve.parse = tt, ve.toString = _e, ve.version && Dt.unshift(Et), ve.name && Dt.unshift(wt), Ct && wt && !(Ct == String(Ct).split(\" \")[0] && (Ct == wt.split(\" \")[0] || Bt)) && Dt.push(Bt ? \"(\" + Ct + \")\" : \"on \" + Ct), Dt.length && (ve.description = Dt.join(\" \")), ve;\n    }\n    var it = tt();\n    D && N ? K(it, function(st, at) {\n      D[at] = st;\n    }) : r.platform = it;\n  }).call(commonjsGlobal);\n})(platform, platformExports);\nfunction int(o) {\n  return parseInt(String(o), 10);\n}\nfunction uint(o) {\n  const t = parseInt(String(o), 10);\n  return t < 0 ? -t : t;\n}\n\"toInt\" in String.prototype || (String.prototype.toInt = function() {\n  return int(this);\n});\n\"toUint\" in String.prototype || (String.prototype.toUint = function() {\n  const o = int(this);\n  return o < 0 ? -o : o;\n});\nfunction getDateStr(o = \"/\", t = \" \", e = \":\", r = \"\") {\n  const D = /* @__PURE__ */ new Date();\n  return D.getFullYear() + o + String(100 + D.getMonth() + 1).slice(1, 3) + o + String(100 + D.getDate()).slice(1, 3) + t + String(100 + D.getHours()).slice(1, 3) + e + String(100 + D.getMinutes()).slice(1, 3) + (r === \"\" ? \"\" : r + String(D.getMilliseconds()));\n}\nconst hMemberCnt = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction cnvTweenArg(o, t) {\n  const e = {};\n  for (const r of Object.keys(hMemberCnt)) {\n    if (!(r in o))\n      continue;\n    const D = String(o[r]), N = (D.at(0) === \"=\" ? D.slice(1) : D).split(\",\"), k = e[r] = parseFloat(N[0]);\n    N.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(N[1]) - k + 1))), D.at(0) === \"=\" && (e[r] += parseFloat(t[r]));\n  }\n  return e;\n}\nconst css_key4del = \"/* SKYNovel */\";\nfunction initStyle() {\n  const o = document.getElementsByTagName(\"head\")[0], t = o.children.length;\n  for (let e = t - 1; e >= 0; --e) {\n    const r = o.children[e];\n    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === css_key4del && o.removeChild(r);\n  }\n}\nfunction addStyle(o) {\n  const t = document.createElement(\"style\");\n  t.innerHTML = css_key4del + o, document.getElementsByTagName(\"head\")[0].appendChild(t);\n}\nfunction argChk_Num(o, t, e) {\n  const r = o[t];\n  if (!(t in o)) {\n    if (isNaN(e))\n      throw `[${o[\":タグ名\"]}]属性 ${t} は必須です`;\n    return o[t] = e, e;\n  }\n  const D = String(r).slice(0, 2) === \"0x\" ? parseInt(r) : parseFloat(r);\n  if (isNaN(D))\n    throw `[${o[\":タグ名\"]}]属性 ${t} の値【${r}】が数値ではありません`;\n  return o[t] = D;\n}\nfunction argChk_Boolean(o, t, e) {\n  if (!(t in o))\n    return o[t] = e;\n  const r = o[t];\n  if (r === null)\n    return !1;\n  const D = String(r);\n  return o[t] = D === \"false\" ? !1 : !!D;\n}\nfunction parseColor(o) {\n  if (o.at(0) === \"#\")\n    return parseInt(o.slice(1), 16);\n  const t = Number(o);\n  if (!isNaN(t))\n    return t;\n  if (o === \"black\")\n    return 0;\n  CmnLib.cc4ColorName.fillStyle = o;\n  const e = CmnLib.cc4ColorName.fillStyle;\n  if (e === \"#000000\")\n    throw `色名前 ${o} が異常です`;\n  return parseInt(e.slice(1), 16);\n}\nfunction argChk_Color(o, t, e) {\n  const r = o[t];\n  return r ? o[t] = parseColor(String(r)) : o[t] = e;\n}\nconst REG_ERRMES_JSON = /JSON at position (\\d+)$/;\nfunction mesErrJSON(o, t = \"\", e = \"\") {\n  const r = (e.match(REG_ERRMES_JSON) ?? [\"\", \"\"])[1];\n  return `[${o[\":タグ名\"]}] ${t} 属性の解析エラー : ${e}\n${o[t]}${r ? `\n${\"^\".padStart(Number(r))}` : \"\"}`;\n}\nconst REG_FN = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction getFn(o) {\n  return (o.match(REG_FN) ?? [\"\"])[0];\n}\nconst REG_EXT = /\\.([^\\.]+)$/;\nfunction getExt(o) {\n  return (o.match(REG_EXT) ?? [\"\", \"\"])[1];\n}\nvar Bf, Ff;\nclass CmnLib {\n}\nOt(CmnLib, \"stageW\", 0), Ot(CmnLib, \"stageH\", 0), Ot(CmnLib, \"debugLog\", !1), Ot(CmnLib, \"isSafari\", platformExports.name === \"Safari\"), Ot(CmnLib, \"isFirefox\", platformExports.name === \"Firefox\"), Ot(CmnLib, \"isMac\", new RegExp(\"OS X\").test(((Bf = platformExports.os) == null ? void 0 : Bf.family) ?? \"\")), Ot(CmnLib, \"isMobile\", !new RegExp(\"(Windows|OS X)\").test(((Ff = platformExports.os) == null ? void 0 : Ff.family) ?? \"\")), Ot(CmnLib, \"hDip\", {}), Ot(CmnLib, \"isDbg\", !1), Ot(CmnLib, \"isPackaged\", !1), Ot(CmnLib, \"isDarkMode\", !1), Ot(CmnLib, \"cc4ColorName\");\nfunction finallyConstructor(o) {\n  var t = this.constructor;\n  return this.then(\n    function(e) {\n      return t.resolve(o()).then(function() {\n        return e;\n      });\n    },\n    function(e) {\n      return t.resolve(o()).then(function() {\n        return t.reject(e);\n      });\n    }\n  );\n}\nfunction allSettled(o) {\n  var t = this;\n  return new t(function(e, r) {\n    if (!(o && typeof o.length < \"u\"))\n      return r(\n        new TypeError(\n          typeof o + \" \" + o + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"\n        )\n      );\n    var D = Array.prototype.slice.call(o);\n    if (D.length === 0)\n      return e([]);\n    var N = D.length;\n    function k(G, U) {\n      if (U && (typeof U == \"object\" || typeof U == \"function\")) {\n        var z = U.then;\n        if (typeof z == \"function\") {\n          z.call(\n            U,\n            function(X) {\n              k(G, X);\n            },\n            function(X) {\n              D[G] = { status: \"rejected\", reason: X }, --N === 0 && e(D);\n            }\n          );\n          return;\n        }\n      }\n      D[G] = { status: \"fulfilled\", value: U }, --N === 0 && e(D);\n    }\n    for (var $ = 0; $ < D.length; $++)\n      k($, D[$]);\n  });\n}\nfunction AggregateError(o, t) {\n  this.name = \"AggregateError\", this.errors = o, this.message = t || \"\";\n}\nAggregateError.prototype = Error.prototype;\nfunction any(o) {\n  var t = this;\n  return new t(function(e, r) {\n    if (!(o && typeof o.length < \"u\"))\n      return r(new TypeError(\"Promise.any accepts an array\"));\n    var D = Array.prototype.slice.call(o);\n    if (D.length === 0)\n      return r();\n    for (var N = [], k = 0; k < D.length; k++)\n      try {\n        t.resolve(D[k]).then(e).catch(function($) {\n          N.push($), N.length === D.length && r(\n            new AggregateError(\n              N,\n              \"All promises were rejected\"\n            )\n          );\n        });\n      } catch ($) {\n        r($);\n      }\n  });\n}\nvar setTimeoutFunc = setTimeout;\nfunction isArray$1(o) {\n  return !!(o && typeof o.length < \"u\");\n}\nfunction noop() {\n}\nfunction bind$2(o, t) {\n  return function() {\n    o.apply(t, arguments);\n  };\n}\nfunction Promise$1(o) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof o != \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(o, this);\n}\nfunction handle(o, t) {\n  for (; o._state === 3; )\n    o = o._value;\n  if (o._state === 0) {\n    o._deferreds.push(t);\n    return;\n  }\n  o._handled = !0, Promise$1._immediateFn(function() {\n    var e = o._state === 1 ? t.onFulfilled : t.onRejected;\n    if (e === null) {\n      (o._state === 1 ? resolve$1 : reject)(t.promise, o._value);\n      return;\n    }\n    var r;\n    try {\n      r = e(o._value);\n    } catch (D) {\n      reject(t.promise, D);\n      return;\n    }\n    resolve$1(t.promise, r);\n  });\n}\nfunction resolve$1(o, t) {\n  try {\n    if (t === o)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (t && (typeof t == \"object\" || typeof t == \"function\")) {\n      var e = t.then;\n      if (t instanceof Promise$1) {\n        o._state = 3, o._value = t, finale(o);\n        return;\n      } else if (typeof e == \"function\") {\n        doResolve(bind$2(e, t), o);\n        return;\n      }\n    }\n    o._state = 1, o._value = t, finale(o);\n  } catch (r) {\n    reject(o, r);\n  }\n}\nfunction reject(o, t) {\n  o._state = 2, o._value = t, finale(o);\n}\nfunction finale(o) {\n  o._state === 2 && o._deferreds.length === 0 && Promise$1._immediateFn(function() {\n    o._handled || Promise$1._unhandledRejectionFn(o._value);\n  });\n  for (var t = 0, e = o._deferreds.length; t < e; t++)\n    handle(o, o._deferreds[t]);\n  o._deferreds = null;\n}\nfunction Handler(o, t, e) {\n  this.onFulfilled = typeof o == \"function\" ? o : null, this.onRejected = typeof t == \"function\" ? t : null, this.promise = e;\n}\nfunction doResolve(o, t) {\n  var e = !1;\n  try {\n    o(\n      function(r) {\n        e || (e = !0, resolve$1(t, r));\n      },\n      function(r) {\n        e || (e = !0, reject(t, r));\n      }\n    );\n  } catch (r) {\n    if (e)\n      return;\n    e = !0, reject(t, r);\n  }\n}\nPromise$1.prototype.catch = function(o) {\n  return this.then(null, o);\n};\nPromise$1.prototype.then = function(o, t) {\n  var e = new this.constructor(noop);\n  return handle(this, new Handler(o, t, e)), e;\n};\nPromise$1.prototype.finally = finallyConstructor;\nPromise$1.all = function(o) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(o))\n      return e(new TypeError(\"Promise.all accepts an array\"));\n    var r = Array.prototype.slice.call(o);\n    if (r.length === 0)\n      return t([]);\n    var D = r.length;\n    function N($, G) {\n      try {\n        if (G && (typeof G == \"object\" || typeof G == \"function\")) {\n          var U = G.then;\n          if (typeof U == \"function\") {\n            U.call(\n              G,\n              function(z) {\n                N($, z);\n              },\n              e\n            );\n            return;\n          }\n        }\n        r[$] = G, --D === 0 && t(r);\n      } catch (z) {\n        e(z);\n      }\n    }\n    for (var k = 0; k < r.length; k++)\n      N(k, r[k]);\n  });\n};\nPromise$1.any = any;\nPromise$1.allSettled = allSettled;\nPromise$1.resolve = function(o) {\n  return o && typeof o == \"object\" && o.constructor === Promise$1 ? o : new Promise$1(function(t) {\n    t(o);\n  });\n};\nPromise$1.reject = function(o) {\n  return new Promise$1(function(t, e) {\n    e(o);\n  });\n};\nPromise$1.race = function(o) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(o))\n      return e(new TypeError(\"Promise.race accepts an array\"));\n    for (var r = 0, D = o.length; r < D; r++)\n      Promise$1.resolve(o[r]).then(t, e);\n  });\n};\nPromise$1._immediateFn = // @ts-ignore\ntypeof setImmediate == \"function\" && function(o) {\n  setImmediate(o);\n} || function(o) {\n  setTimeoutFunc(o, 0);\n};\nPromise$1._unhandledRejectionFn = function(t) {\n  typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", t);\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(o) {\n  if (o == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(o);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var o = new String(\"abc\");\n    if (o[5] = \"de\", Object.getOwnPropertyNames(o)[0] === \"5\")\n      return !1;\n    for (var t = {}, e = 0; e < 10; e++)\n      t[\"_\" + String.fromCharCode(e)] = e;\n    var r = Object.getOwnPropertyNames(t).map(function(N) {\n      return t[N];\n    });\n    if (r.join(\"\") !== \"0123456789\")\n      return !1;\n    var D = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(N) {\n      D[N] = N;\n    }), Object.keys(Object.assign({}, D)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(o, t) {\n  for (var e, r = toObject(o), D, N = 1; N < arguments.length; N++) {\n    e = Object(arguments[N]);\n    for (var k in e)\n      hasOwnProperty$1.call(e, k) && (r[k] = e[k]);\n    if (getOwnPropertySymbols) {\n      D = getOwnPropertySymbols(e);\n      for (var $ = 0; $ < D.length; $++)\n        propIsEnumerable.call(e, D[$]) && (r[D[$]] = e[D[$]]);\n    }\n  }\n  return r;\n};\n/*!\n * @pixi/polyfill - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/polyfill is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ntypeof globalThis > \"u\" && (typeof self < \"u\" ? self.globalThis = self : typeof __webpack_require__.g < \"u\" && (__webpack_require__.g.globalThis = __webpack_require__.g));\nglobalThis.Promise || (globalThis.Promise = Promise$1);\nObject.assign || (Object.assign = objectAssign);\nvar ONE_FRAME_TIME = 16;\nDate.now && Date.prototype.getTime || (Date.now = function() {\n  return (/* @__PURE__ */ new Date()).getTime();\n});\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var startTime_1 = Date.now();\n  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {\n    return Date.now() - startTime_1;\n  };\n}\nvar lastTime = Date.now(), vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {\n  var p$1 = vendors[x$1];\n  globalThis.requestAnimationFrame = globalThis[p$1 + \"RequestAnimationFrame\"], globalThis.cancelAnimationFrame = globalThis[p$1 + \"CancelAnimationFrame\"] || globalThis[p$1 + \"CancelRequestAnimationFrame\"];\n}\nglobalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(o) {\n  if (typeof o != \"function\")\n    throw new TypeError(o + \"is not a function\");\n  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;\n  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {\n    lastTime = Date.now(), o(performance.now());\n  }, e);\n});\nglobalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(o) {\n  return clearTimeout(o);\n});\nMath.sign || (Math.sign = function(t) {\n  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;\n});\nNumber.isInteger || (Number.isInteger = function(t) {\n  return typeof t == \"number\" && isFinite(t) && Math.floor(t) === t;\n});\nglobalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);\nglobalThis.Float32Array || (globalThis.Float32Array = Array);\nglobalThis.Uint32Array || (globalThis.Uint32Array = Array);\nglobalThis.Uint16Array || (globalThis.Uint16Array = Array);\nglobalThis.Uint8Array || (globalThis.Uint8Array = Array);\nglobalThis.Int32Array || (globalThis.Int32Array = Array);\n/*!\n * @pixi/constants - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV;\n(function(o) {\n  o[o.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", o[o.WEBGL = 1] = \"WEBGL\", o[o.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV || (ENV = {}));\nvar RENDERER_TYPE;\n(function(o) {\n  o[o.UNKNOWN = 0] = \"UNKNOWN\", o[o.WEBGL = 1] = \"WEBGL\", o[o.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE || (RENDERER_TYPE = {}));\nvar BUFFER_BITS;\n(function(o) {\n  o[o.COLOR = 16384] = \"COLOR\", o[o.DEPTH = 256] = \"DEPTH\", o[o.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS || (BUFFER_BITS = {}));\nvar BLEND_MODES;\n(function(o) {\n  o[o.NORMAL = 0] = \"NORMAL\", o[o.ADD = 1] = \"ADD\", o[o.MULTIPLY = 2] = \"MULTIPLY\", o[o.SCREEN = 3] = \"SCREEN\", o[o.OVERLAY = 4] = \"OVERLAY\", o[o.DARKEN = 5] = \"DARKEN\", o[o.LIGHTEN = 6] = \"LIGHTEN\", o[o.COLOR_DODGE = 7] = \"COLOR_DODGE\", o[o.COLOR_BURN = 8] = \"COLOR_BURN\", o[o.HARD_LIGHT = 9] = \"HARD_LIGHT\", o[o.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", o[o.DIFFERENCE = 11] = \"DIFFERENCE\", o[o.EXCLUSION = 12] = \"EXCLUSION\", o[o.HUE = 13] = \"HUE\", o[o.SATURATION = 14] = \"SATURATION\", o[o.COLOR = 15] = \"COLOR\", o[o.LUMINOSITY = 16] = \"LUMINOSITY\", o[o.NORMAL_NPM = 17] = \"NORMAL_NPM\", o[o.ADD_NPM = 18] = \"ADD_NPM\", o[o.SCREEN_NPM = 19] = \"SCREEN_NPM\", o[o.NONE = 20] = \"NONE\", o[o.SRC_OVER = 0] = \"SRC_OVER\", o[o.SRC_IN = 21] = \"SRC_IN\", o[o.SRC_OUT = 22] = \"SRC_OUT\", o[o.SRC_ATOP = 23] = \"SRC_ATOP\", o[o.DST_OVER = 24] = \"DST_OVER\", o[o.DST_IN = 25] = \"DST_IN\", o[o.DST_OUT = 26] = \"DST_OUT\", o[o.DST_ATOP = 27] = \"DST_ATOP\", o[o.ERASE = 26] = \"ERASE\", o[o.SUBTRACT = 28] = \"SUBTRACT\", o[o.XOR = 29] = \"XOR\";\n})(BLEND_MODES || (BLEND_MODES = {}));\nvar DRAW_MODES;\n(function(o) {\n  o[o.POINTS = 0] = \"POINTS\", o[o.LINES = 1] = \"LINES\", o[o.LINE_LOOP = 2] = \"LINE_LOOP\", o[o.LINE_STRIP = 3] = \"LINE_STRIP\", o[o.TRIANGLES = 4] = \"TRIANGLES\", o[o.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", o[o.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES || (DRAW_MODES = {}));\nvar FORMATS;\n(function(o) {\n  o[o.RGBA = 6408] = \"RGBA\", o[o.RGB = 6407] = \"RGB\", o[o.RG = 33319] = \"RG\", o[o.RED = 6403] = \"RED\", o[o.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", o[o.RGB_INTEGER = 36248] = \"RGB_INTEGER\", o[o.RG_INTEGER = 33320] = \"RG_INTEGER\", o[o.RED_INTEGER = 36244] = \"RED_INTEGER\", o[o.ALPHA = 6406] = \"ALPHA\", o[o.LUMINANCE = 6409] = \"LUMINANCE\", o[o.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", o[o.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", o[o.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS || (FORMATS = {}));\nvar TARGETS;\n(function(o) {\n  o[o.TEXTURE_2D = 3553] = \"TEXTURE_2D\", o[o.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", o[o.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", o[o.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", o[o.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", o[o.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", o[o.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS || (TARGETS = {}));\nvar TYPES;\n(function(o) {\n  o[o.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", o[o.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", o[o.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", o[o.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", o[o.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", o[o.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", o[o.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", o[o.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", o[o.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", o[o.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", o[o.BYTE = 5120] = \"BYTE\", o[o.SHORT = 5122] = \"SHORT\", o[o.INT = 5124] = \"INT\", o[o.FLOAT = 5126] = \"FLOAT\", o[o.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", o[o.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES || (TYPES = {}));\nvar SAMPLER_TYPES;\n(function(o) {\n  o[o.FLOAT = 0] = \"FLOAT\", o[o.INT = 1] = \"INT\", o[o.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));\nvar SCALE_MODES;\n(function(o) {\n  o[o.NEAREST = 0] = \"NEAREST\", o[o.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES || (SCALE_MODES = {}));\nvar WRAP_MODES;\n(function(o) {\n  o[o.CLAMP = 33071] = \"CLAMP\", o[o.REPEAT = 10497] = \"REPEAT\", o[o.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES || (WRAP_MODES = {}));\nvar MIPMAP_MODES;\n(function(o) {\n  o[o.OFF = 0] = \"OFF\", o[o.POW2 = 1] = \"POW2\", o[o.ON = 2] = \"ON\", o[o.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES || (MIPMAP_MODES = {}));\nvar ALPHA_MODES;\n(function(o) {\n  o[o.NPM = 0] = \"NPM\", o[o.UNPACK = 1] = \"UNPACK\", o[o.PMA = 2] = \"PMA\", o[o.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", o[o.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", o[o.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", o[o.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES || (ALPHA_MODES = {}));\nvar CLEAR_MODES;\n(function(o) {\n  o[o.NO = 0] = \"NO\", o[o.YES = 1] = \"YES\", o[o.AUTO = 2] = \"AUTO\", o[o.BLEND = 0] = \"BLEND\", o[o.CLEAR = 1] = \"CLEAR\", o[o.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES || (CLEAR_MODES = {}));\nvar GC_MODES;\n(function(o) {\n  o[o.AUTO = 0] = \"AUTO\", o[o.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES || (GC_MODES = {}));\nvar PRECISION;\n(function(o) {\n  o.LOW = \"lowp\", o.MEDIUM = \"mediump\", o.HIGH = \"highp\";\n})(PRECISION || (PRECISION = {}));\nvar MASK_TYPES;\n(function(o) {\n  o[o.NONE = 0] = \"NONE\", o[o.SCISSOR = 1] = \"SCISSOR\", o[o.STENCIL = 2] = \"STENCIL\", o[o.SPRITE = 3] = \"SPRITE\", o[o.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES || (MASK_TYPES = {}));\nvar COLOR_MASK_BITS;\n(function(o) {\n  o[o.RED = 1] = \"RED\", o[o.GREEN = 2] = \"GREEN\", o[o.BLUE = 4] = \"BLUE\", o[o.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));\nvar MSAA_QUALITY;\n(function(o) {\n  o[o.NONE = 0] = \"NONE\", o[o.LOW = 2] = \"LOW\", o[o.MEDIUM = 4] = \"MEDIUM\", o[o.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY || (MSAA_QUALITY = {}));\nvar BUFFER_TYPE;\n(function(o) {\n  o[o.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", o[o.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", o[o.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE || (BUFFER_TYPE = {}));\n/*!\n * @pixi/settings - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar BrowserAdapter = {\n  /**\n   * Creates a canvas element of the given size.\n   * This canvas is created using the browser's native canvas element.\n   * @param width - width of the canvas\n   * @param height - height of the canvas\n   */\n  createCanvas: function(o, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = o, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var o;\n    return (o = document.baseURI) !== null && o !== void 0 ? o : window.location.href;\n  },\n  fetch: function(o, t) {\n    return fetch(o, t);\n  }\n}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13 = function(o) {\n  return typeof o < \"u\" && o.platform === \"MacIntel\" && typeof o.maxTouchPoints == \"number\" && o.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch(o) {\n  return function(t) {\n    return t.test(o);\n  };\n}\nfunction isMobile$1(o) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !o && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof o == \"string\" ? t.userAgent = o : o && o.userAgent && (t = {\n    userAgent: o.userAgent,\n    platform: o.platform,\n    maxTouchPoints: o.maxTouchPoints || 0\n  });\n  var e = t.userAgent, r = e.split(\"[FBAN\");\n  typeof r[1] < \"u\" && (e = r[0]), r = e.split(\"Twitter\"), typeof r[1] < \"u\" && (e = r[0]);\n  var D = createMatch(e), N = {\n    apple: {\n      phone: D(appleIphone) && !D(windowsPhone),\n      ipod: D(appleIpod),\n      tablet: !D(appleIphone) && (D(appleTablet) || isAppleTabletOnIos13(t)) && !D(windowsPhone),\n      universal: D(appleUniversal),\n      device: (D(appleIphone) || D(appleIpod) || D(appleTablet) || D(appleUniversal) || isAppleTabletOnIos13(t)) && !D(windowsPhone)\n    },\n    amazon: {\n      phone: D(amazonPhone),\n      tablet: !D(amazonPhone) && D(amazonTablet),\n      device: D(amazonPhone) || D(amazonTablet)\n    },\n    android: {\n      phone: !D(windowsPhone) && D(amazonPhone) || !D(windowsPhone) && D(androidPhone),\n      tablet: !D(windowsPhone) && !D(amazonPhone) && !D(androidPhone) && (D(amazonTablet) || D(androidTablet)),\n      device: !D(windowsPhone) && (D(amazonPhone) || D(amazonTablet) || D(androidPhone) || D(androidTablet)) || D(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: D(windowsPhone),\n      tablet: D(windowsTablet),\n      device: D(windowsPhone) || D(windowsTablet)\n    },\n    other: {\n      blackberry: D(otherBlackBerry),\n      blackberry10: D(otherBlackBerry10),\n      opera: D(otherOpera),\n      firefox: D(otherFirefox),\n      chrome: D(otherChrome),\n      device: D(otherBlackBerry) || D(otherBlackBerry10) || D(otherOpera) || D(otherFirefox) || D(otherChrome)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;\n}\nvar isMobile = isMobile$1(globalThis.navigator);\nfunction canUploadSameBuffer() {\n  return !isMobile.apple.device;\n}\nfunction maxRecommendedTextures(o) {\n  var t = !0;\n  if (isMobile.tablet || isMobile.phone) {\n    if (isMobile.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 11 && (t = !1);\n      }\n    }\n    if (isMobile.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? o : 4;\n}\nvar settings = {\n  /**\n   * This adapter is used to call methods that are platform dependent.\n   * For example `document.createElement` only runs on the web but fails in node environments.\n   * This allows us to support more platforms by abstracting away specific implementations per platform.\n   *\n   * By default the adapter is set to work in the browser. However you can create your own\n   * by implementing the `IAdapter` interface. See `IAdapter` for more information.\n   * @name ADAPTER\n   * @memberof PIXI.settings\n   * @type {PIXI.IAdapter}\n   * @default PIXI.BrowserAdapter\n   */\n  ADAPTER: BrowserAdapter,\n  /**\n   * If set to true WebGL will attempt make textures mimpaped by default.\n   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.\n   * @static\n   * @name MIPMAP_TEXTURES\n   * @memberof PIXI.settings\n   * @type {PIXI.MIPMAP_MODES}\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,\n  /**\n   * Default anisotropic filtering level of textures.\n   * Usually from 0 to 16\n   * @static\n   * @name ANISOTROPIC_LEVEL\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 0\n   */\n  ANISOTROPIC_LEVEL: 0,\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @static\n   * @name RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  RESOLUTION: 1,\n  /**\n   * Default filter resolution.\n   * @static\n   * @name FILTER_RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  FILTER_RESOLUTION: 1,\n  /**\n   * Default filter samples.\n   * @static\n   * @name FILTER_MULTISAMPLE\n   * @memberof PIXI.settings\n   * @type {PIXI.MSAA_QUALITY}\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @name SPRITE_MAX_TEXTURES\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 32\n   */\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),\n  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000\n  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000\n  /**\n   * The default sprite batch size.\n   *\n   * The default aims to balance desktop and mobile devices.\n   * @static\n   * @name SPRITE_BATCH_SIZE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 4096\n   */\n  SPRITE_BATCH_SIZE: 4096,\n  /**\n   * The default render options if none are supplied to {@link PIXI.Renderer}\n   * or {@link PIXI.CanvasRenderer}.\n   * @static\n   * @name RENDER_OPTIONS\n   * @memberof PIXI.settings\n   * @type {object}\n   * @property {HTMLCanvasElement} [view=null] -\n   * @property {boolean} [antialias=false] -\n   * @property {boolean} [autoDensity=false] -\n   * @property {boolean} [useContextAlpha=true]  -\n   * @property {number} [backgroundColor=0x000000] -\n   * @property {number} [backgroundAlpha=1] -\n   * @property {boolean} [clearBeforeRender=true] -\n   * @property {boolean} [preserveDrawingBuffer=false] -\n   * @property {number} [width=800] -\n   * @property {number} [height=600] -\n   * @property {boolean} [legacy=false] -\n   */\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  /**\n   * Default Garbage Collection mode.\n   * @static\n   * @name GC_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.GC_MODES}\n   * @default PIXI.GC_MODES.AUTO\n   */\n  GC_MODE: GC_MODES.AUTO,\n  /**\n   * Default Garbage Collection max idle.\n   * @static\n   * @name GC_MAX_IDLE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 3600\n   */\n  GC_MAX_IDLE: 60 * 60,\n  /**\n   * Default Garbage Collection maximum check count.\n   * @static\n   * @name GC_MAX_CHECK_COUNT\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 600\n   */\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  /**\n   * Default wrap modes that are supported by pixi.\n   * @static\n   * @name WRAP_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.WRAP_MODES}\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  WRAP_MODE: WRAP_MODES.CLAMP,\n  /**\n   * Default scale mode for textures.\n   * @static\n   * @name SCALE_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.SCALE_MODES}\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  SCALE_MODE: SCALE_MODES.LINEAR,\n  /**\n   * Default specify float precision in vertex shader.\n   * @static\n   * @name PRECISION_VERTEX\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @default PIXI.PRECISION.HIGH\n   */\n  PRECISION_VERTEX: PRECISION.HIGH,\n  /**\n   * Default specify float precision in fragment shader.\n   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742\n   * @static\n   * @name PRECISION_FRAGMENT\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @default PIXI.PRECISION.MEDIUM\n   */\n  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   * @name CAN_UPLOAD_SAME_BUFFER\n   * @memberof PIXI.settings\n   * @type {boolean}\n   */\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),\n  /**\n   * Enables bitmap creation before image load. This feature is experimental.\n   * @static\n   * @name CREATE_IMAGE_BITMAP\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  CREATE_IMAGE_BITMAP: !1,\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * @static\n   * @constant\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  ROUND_PIXELS: !1\n}, eventemitter3Exports = {}, eventemitter3 = {\n  get exports() {\n    return eventemitter3Exports;\n  },\n  set exports(o) {\n    eventemitter3Exports = o;\n  }\n};\n(function(o) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function r() {\n  }\n  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));\n  function D(G, U, z) {\n    this.fn = G, this.context = U, this.once = z || !1;\n  }\n  function N(G, U, z, X, V) {\n    if (typeof z != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var Y = new D(z, X || G, V), q = e ? e + U : U;\n    return G._events[q] ? G._events[q].fn ? G._events[q] = [G._events[q], Y] : G._events[q].push(Y) : (G._events[q] = Y, G._eventsCount++), G;\n  }\n  function k(G, U) {\n    --G._eventsCount === 0 ? G._events = new r() : delete G._events[U];\n  }\n  function $() {\n    this._events = new r(), this._eventsCount = 0;\n  }\n  $.prototype.eventNames = function() {\n    var U = [], z, X;\n    if (this._eventsCount === 0)\n      return U;\n    for (X in z = this._events)\n      t.call(z, X) && U.push(e ? X.slice(1) : X);\n    return Object.getOwnPropertySymbols ? U.concat(Object.getOwnPropertySymbols(z)) : U;\n  }, $.prototype.listeners = function(U) {\n    var z = e ? e + U : U, X = this._events[z];\n    if (!X)\n      return [];\n    if (X.fn)\n      return [X.fn];\n    for (var V = 0, Y = X.length, q = new Array(Y); V < Y; V++)\n      q[V] = X[V].fn;\n    return q;\n  }, $.prototype.listenerCount = function(U) {\n    var z = e ? e + U : U, X = this._events[z];\n    return X ? X.fn ? 1 : X.length : 0;\n  }, $.prototype.emit = function(U, z, X, V, Y, q) {\n    var W = e ? e + U : U;\n    if (!this._events[W])\n      return !1;\n    var K = this._events[W], Z = arguments.length, J, Q;\n    if (K.fn) {\n      switch (K.once && this.removeListener(U, K.fn, void 0, !0), Z) {\n        case 1:\n          return K.fn.call(K.context), !0;\n        case 2:\n          return K.fn.call(K.context, z), !0;\n        case 3:\n          return K.fn.call(K.context, z, X), !0;\n        case 4:\n          return K.fn.call(K.context, z, X, V), !0;\n        case 5:\n          return K.fn.call(K.context, z, X, V, Y), !0;\n        case 6:\n          return K.fn.call(K.context, z, X, V, Y, q), !0;\n      }\n      for (Q = 1, J = new Array(Z - 1); Q < Z; Q++)\n        J[Q - 1] = arguments[Q];\n      K.fn.apply(K.context, J);\n    } else {\n      var et = K.length, nt;\n      for (Q = 0; Q < et; Q++)\n        switch (K[Q].once && this.removeListener(U, K[Q].fn, void 0, !0), Z) {\n          case 1:\n            K[Q].fn.call(K[Q].context);\n            break;\n          case 2:\n            K[Q].fn.call(K[Q].context, z);\n            break;\n          case 3:\n            K[Q].fn.call(K[Q].context, z, X);\n            break;\n          case 4:\n            K[Q].fn.call(K[Q].context, z, X, V);\n            break;\n          default:\n            if (!J)\n              for (nt = 1, J = new Array(Z - 1); nt < Z; nt++)\n                J[nt - 1] = arguments[nt];\n            K[Q].fn.apply(K[Q].context, J);\n        }\n    }\n    return !0;\n  }, $.prototype.on = function(U, z, X) {\n    return N(this, U, z, X, !1);\n  }, $.prototype.once = function(U, z, X) {\n    return N(this, U, z, X, !0);\n  }, $.prototype.removeListener = function(U, z, X, V) {\n    var Y = e ? e + U : U;\n    if (!this._events[Y])\n      return this;\n    if (!z)\n      return k(this, Y), this;\n    var q = this._events[Y];\n    if (q.fn)\n      q.fn === z && (!V || q.once) && (!X || q.context === X) && k(this, Y);\n    else {\n      for (var W = 0, K = [], Z = q.length; W < Z; W++)\n        (q[W].fn !== z || V && !q[W].once || X && q[W].context !== X) && K.push(q[W]);\n      K.length ? this._events[Y] = K.length === 1 ? K[0] : K : k(this, Y);\n    }\n    return this;\n  }, $.prototype.removeAllListeners = function(U) {\n    var z;\n    return U ? (z = e ? e + U : U, this._events[z] && k(this, z)) : (this._events = new r(), this._eventsCount = 0), this;\n  }, $.prototype.off = $.prototype.removeListener, $.prototype.addListener = $.prototype.on, $.prefixed = e, $.EventEmitter = $, o.exports = $;\n})(eventemitter3);\nvar earcutExports = {}, earcut$1 = {\n  get exports() {\n    return earcutExports;\n  },\n  set exports(o) {\n    earcutExports = o;\n  }\n};\nearcut$1.exports = earcut;\nearcutExports.default = earcut;\nfunction earcut(o, t, e) {\n  e = e || 2;\n  var r = t && t.length, D = r ? t[0] * e : o.length, N = linkedList(o, 0, D, e, !0), k = [];\n  if (!N || N.next === N.prev)\n    return k;\n  var $, G, U, z, X, V, Y;\n  if (r && (N = eliminateHoles(o, t, N, e)), o.length > 80 * e) {\n    $ = U = o[0], G = z = o[1];\n    for (var q = e; q < D; q += e)\n      X = o[q], V = o[q + 1], X < $ && ($ = X), V < G && (G = V), X > U && (U = X), V > z && (z = V);\n    Y = Math.max(U - $, z - G), Y = Y !== 0 ? 32767 / Y : 0;\n  }\n  return earcutLinked(N, k, e, $, G, Y, 0), k;\n}\nfunction linkedList(o, t, e, r, D) {\n  var N, k;\n  if (D === signedArea(o, t, e, r) > 0)\n    for (N = t; N < e; N += r)\n      k = insertNode(N, o[N], o[N + 1], k);\n  else\n    for (N = e - r; N >= t; N -= r)\n      k = insertNode(N, o[N], o[N + 1], k);\n  return k && equals$1(k, k.next) && (removeNode(k), k = k.next), k;\n}\nfunction filterPoints(o, t) {\n  if (!o)\n    return o;\n  t || (t = o);\n  var e = o, r;\n  do\n    if (r = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {\n      if (removeNode(e), e = t = e.prev, e === e.next)\n        break;\n      r = !0;\n    } else\n      e = e.next;\n  while (r || e !== t);\n  return t;\n}\nfunction earcutLinked(o, t, e, r, D, N, k) {\n  if (o) {\n    !k && N && indexCurve(o, r, D, N);\n    for (var $ = o, G, U; o.prev !== o.next; ) {\n      if (G = o.prev, U = o.next, N ? isEarHashed(o, r, D, N) : isEar(o)) {\n        t.push(G.i / e | 0), t.push(o.i / e | 0), t.push(U.i / e | 0), removeNode(o), o = U.next, $ = U.next;\n        continue;\n      }\n      if (o = U, o === $) {\n        k ? k === 1 ? (o = cureLocalIntersections(filterPoints(o), t, e), earcutLinked(o, t, e, r, D, N, 2)) : k === 2 && splitEarcut(o, t, e, r, D, N) : earcutLinked(filterPoints(o), t, e, r, D, N, 1);\n        break;\n      }\n    }\n  }\n}\nfunction isEar(o) {\n  var t = o.prev, e = o, r = o.next;\n  if (area(t, e, r) >= 0)\n    return !1;\n  for (var D = t.x, N = e.x, k = r.x, $ = t.y, G = e.y, U = r.y, z = D < N ? D < k ? D : k : N < k ? N : k, X = $ < G ? $ < U ? $ : U : G < U ? G : U, V = D > N ? D > k ? D : k : N > k ? N : k, Y = $ > G ? $ > U ? $ : U : G > U ? G : U, q = r.next; q !== t; ) {\n    if (q.x >= z && q.x <= V && q.y >= X && q.y <= Y && pointInTriangle(D, $, N, G, k, U, q.x, q.y) && area(q.prev, q, q.next) >= 0)\n      return !1;\n    q = q.next;\n  }\n  return !0;\n}\nfunction isEarHashed(o, t, e, r) {\n  var D = o.prev, N = o, k = o.next;\n  if (area(D, N, k) >= 0)\n    return !1;\n  for (var $ = D.x, G = N.x, U = k.x, z = D.y, X = N.y, V = k.y, Y = $ < G ? $ < U ? $ : U : G < U ? G : U, q = z < X ? z < V ? z : V : X < V ? X : V, W = $ > G ? $ > U ? $ : U : G > U ? G : U, K = z > X ? z > V ? z : V : X > V ? X : V, Z = zOrder(Y, q, t, e, r), J = zOrder(W, K, t, e, r), Q = o.prevZ, et = o.nextZ; Q && Q.z >= Z && et && et.z <= J; ) {\n    if (Q.x >= Y && Q.x <= W && Q.y >= q && Q.y <= K && Q !== D && Q !== k && pointInTriangle($, z, G, X, U, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0 || (Q = Q.prevZ, et.x >= Y && et.x <= W && et.y >= q && et.y <= K && et !== D && et !== k && pointInTriangle($, z, G, X, U, V, et.x, et.y) && area(et.prev, et, et.next) >= 0))\n      return !1;\n    et = et.nextZ;\n  }\n  for (; Q && Q.z >= Z; ) {\n    if (Q.x >= Y && Q.x <= W && Q.y >= q && Q.y <= K && Q !== D && Q !== k && pointInTriangle($, z, G, X, U, V, Q.x, Q.y) && area(Q.prev, Q, Q.next) >= 0)\n      return !1;\n    Q = Q.prevZ;\n  }\n  for (; et && et.z <= J; ) {\n    if (et.x >= Y && et.x <= W && et.y >= q && et.y <= K && et !== D && et !== k && pointInTriangle($, z, G, X, U, V, et.x, et.y) && area(et.prev, et, et.next) >= 0)\n      return !1;\n    et = et.nextZ;\n  }\n  return !0;\n}\nfunction cureLocalIntersections(o, t, e) {\n  var r = o;\n  do {\n    var D = r.prev, N = r.next.next;\n    !equals$1(D, N) && intersects(D, r, r.next, N) && locallyInside(D, N) && locallyInside(N, D) && (t.push(D.i / e | 0), t.push(r.i / e | 0), t.push(N.i / e | 0), removeNode(r), removeNode(r.next), r = o = N), r = r.next;\n  } while (r !== o);\n  return filterPoints(r);\n}\nfunction splitEarcut(o, t, e, r, D, N) {\n  var k = o;\n  do {\n    for (var $ = k.next.next; $ !== k.prev; ) {\n      if (k.i !== $.i && isValidDiagonal(k, $)) {\n        var G = splitPolygon(k, $);\n        k = filterPoints(k, k.next), G = filterPoints(G, G.next), earcutLinked(k, t, e, r, D, N, 0), earcutLinked(G, t, e, r, D, N, 0);\n        return;\n      }\n      $ = $.next;\n    }\n    k = k.next;\n  } while (k !== o);\n}\nfunction eliminateHoles(o, t, e, r) {\n  var D = [], N, k, $, G, U;\n  for (N = 0, k = t.length; N < k; N++)\n    $ = t[N] * r, G = N < k - 1 ? t[N + 1] * r : o.length, U = linkedList(o, $, G, r, !1), U === U.next && (U.steiner = !0), D.push(getLeftmost(U));\n  for (D.sort(compareX), N = 0; N < D.length; N++)\n    e = eliminateHole(D[N], e);\n  return e;\n}\nfunction compareX(o, t) {\n  return o.x - t.x;\n}\nfunction eliminateHole(o, t) {\n  var e = findHoleBridge(o, t);\n  if (!e)\n    return t;\n  var r = splitPolygon(e, o);\n  return filterPoints(r, r.next), filterPoints(e, e.next);\n}\nfunction findHoleBridge(o, t) {\n  var e = t, r = o.x, D = o.y, N = -1 / 0, k;\n  do {\n    if (D <= e.y && D >= e.next.y && e.next.y !== e.y) {\n      var $ = e.x + (D - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if ($ <= r && $ > N && (N = $, k = e.x < e.next.x ? e : e.next, $ === r))\n        return k;\n    }\n    e = e.next;\n  } while (e !== t);\n  if (!k)\n    return null;\n  var G = k, U = k.x, z = k.y, X = 1 / 0, V;\n  e = k;\n  do\n    r >= e.x && e.x >= U && r !== e.x && pointInTriangle(D < z ? r : N, D, U, z, D < z ? N : r, D, e.x, e.y) && (V = Math.abs(D - e.y) / (r - e.x), locallyInside(e, o) && (V < X || V === X && (e.x > k.x || e.x === k.x && sectorContainsSector(k, e))) && (k = e, X = V)), e = e.next;\n  while (e !== G);\n  return k;\n}\nfunction sectorContainsSector(o, t) {\n  return area(o.prev, o, t.prev) < 0 && area(t.next, o, o.next) < 0;\n}\nfunction indexCurve(o, t, e, r) {\n  var D = o;\n  do\n    D.z === 0 && (D.z = zOrder(D.x, D.y, t, e, r)), D.prevZ = D.prev, D.nextZ = D.next, D = D.next;\n  while (D !== o);\n  D.prevZ.nextZ = null, D.prevZ = null, sortLinked(D);\n}\nfunction sortLinked(o) {\n  var t, e, r, D, N, k, $, G, U = 1;\n  do {\n    for (e = o, o = null, N = null, k = 0; e; ) {\n      for (k++, r = e, $ = 0, t = 0; t < U && ($++, r = r.nextZ, !!r); t++)\n        ;\n      for (G = U; $ > 0 || G > 0 && r; )\n        $ !== 0 && (G === 0 || !r || e.z <= r.z) ? (D = e, e = e.nextZ, $--) : (D = r, r = r.nextZ, G--), N ? N.nextZ = D : o = D, D.prevZ = N, N = D;\n      e = r;\n    }\n    N.nextZ = null, U *= 2;\n  } while (k > 1);\n  return o;\n}\nfunction zOrder(o, t, e, r, D) {\n  return o = (o - e) * D | 0, t = (t - r) * D | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, o | t << 1;\n}\nfunction getLeftmost(o) {\n  var t = o, e = o;\n  do\n    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;\n  while (t !== o);\n  return e;\n}\nfunction pointInTriangle(o, t, e, r, D, N, k, $) {\n  return (D - k) * (t - $) >= (o - k) * (N - $) && (o - k) * (r - $) >= (e - k) * (t - $) && (e - k) * (N - $) >= (D - k) * (r - $);\n}\nfunction isValidDiagonal(o, t) {\n  return o.next.i !== t.i && o.prev.i !== t.i && !intersectsPolygon(o, t) && // dones't intersect other edges\n  (locallyInside(o, t) && locallyInside(t, o) && middleInside(o, t) && // locally visible\n  (area(o.prev, o, t.prev) || area(o, t.prev, t)) || // does not create opposite-facing sectors\n  equals$1(o, t) && area(o.prev, o, o.next) > 0 && area(t.prev, t, t.next) > 0);\n}\nfunction area(o, t, e) {\n  return (t.y - o.y) * (e.x - t.x) - (t.x - o.x) * (e.y - t.y);\n}\nfunction equals$1(o, t) {\n  return o.x === t.x && o.y === t.y;\n}\nfunction intersects(o, t, e, r) {\n  var D = sign$1(area(o, t, e)), N = sign$1(area(o, t, r)), k = sign$1(area(e, r, o)), $ = sign$1(area(e, r, t));\n  return !!(D !== N && k !== $ || D === 0 && onSegment(o, e, t) || N === 0 && onSegment(o, r, t) || k === 0 && onSegment(e, o, r) || $ === 0 && onSegment(e, t, r));\n}\nfunction onSegment(o, t, e) {\n  return t.x <= Math.max(o.x, e.x) && t.x >= Math.min(o.x, e.x) && t.y <= Math.max(o.y, e.y) && t.y >= Math.min(o.y, e.y);\n}\nfunction sign$1(o) {\n  return o > 0 ? 1 : o < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(o, t) {\n  var e = o;\n  do {\n    if (e.i !== o.i && e.next.i !== o.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, o, t))\n      return !0;\n    e = e.next;\n  } while (e !== o);\n  return !1;\n}\nfunction locallyInside(o, t) {\n  return area(o.prev, o, o.next) < 0 ? area(o, t, o.next) >= 0 && area(o, o.prev, t) >= 0 : area(o, t, o.prev) < 0 || area(o, o.next, t) < 0;\n}\nfunction middleInside(o, t) {\n  var e = o, r = !1, D = (o.x + t.x) / 2, N = (o.y + t.y) / 2;\n  do\n    e.y > N != e.next.y > N && e.next.y !== e.y && D < (e.next.x - e.x) * (N - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;\n  while (e !== o);\n  return r;\n}\nfunction splitPolygon(o, t) {\n  var e = new Node$1(o.i, o.x, o.y), r = new Node$1(t.i, t.x, t.y), D = o.next, N = t.prev;\n  return o.next = t, t.prev = o, e.next = D, D.prev = e, r.next = e, e.prev = r, N.next = r, r.prev = N, r;\n}\nfunction insertNode(o, t, e, r) {\n  var D = new Node$1(o, t, e);\n  return r ? (D.next = r.next, D.prev = r, r.next.prev = D, r.next = D) : (D.prev = D, D.next = D), D;\n}\nfunction removeNode(o) {\n  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);\n}\nfunction Node$1(o, t, e) {\n  this.i = o, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nearcut.deviation = function(o, t, e, r) {\n  var D = t && t.length, N = D ? t[0] * e : o.length, k = Math.abs(signedArea(o, 0, N, e));\n  if (D)\n    for (var $ = 0, G = t.length; $ < G; $++) {\n      var U = t[$] * e, z = $ < G - 1 ? t[$ + 1] * e : o.length;\n      k -= Math.abs(signedArea(o, U, z, e));\n    }\n  var X = 0;\n  for ($ = 0; $ < r.length; $ += 3) {\n    var V = r[$] * e, Y = r[$ + 1] * e, q = r[$ + 2] * e;\n    X += Math.abs(\n      (o[V] - o[q]) * (o[Y + 1] - o[V + 1]) - (o[V] - o[Y]) * (o[q + 1] - o[V + 1])\n    );\n  }\n  return k === 0 && X === 0 ? 0 : Math.abs((X - k) / k);\n};\nfunction signedArea(o, t, e, r) {\n  for (var D = 0, N = t, k = e - r; N < e; N += r)\n    D += (o[k] - o[N]) * (o[N + 1] + o[k + 1]), k = N;\n  return D;\n}\nearcut.flatten = function(o) {\n  for (var t = o[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, D = 0; D < o.length; D++) {\n    for (var N = 0; N < o[D].length; N++)\n      for (var k = 0; k < t; k++)\n        e.vertices.push(o[D][N][k]);\n    D > 0 && (r += o[D - 1].length, e.holes.push(r));\n  }\n  return e;\n};\nvar punycodeExports = {}, punycode$1 = {\n  get exports() {\n    return punycodeExports;\n  },\n  set exports(o) {\n    punycodeExports = o;\n  }\n};\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n(function(o, t) {\n  (function(e) {\n    var r = t && !t.nodeType && t, D = o && !o.nodeType && o, N = typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    (N.global === N || N.window === N || N.self === N) && (e = N);\n    var k, $ = 2147483647, G = 36, U = 1, z = 26, X = 38, V = 700, Y = 72, q = 128, W = \"-\", K = /^xn--/, Z = /[^\\x20-\\x7E]/, J = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, Q = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, et = G - U, nt = Math.floor, tt = String.fromCharCode, it;\n    function st(gt) {\n      throw RangeError(Q[gt]);\n    }\n    function at(gt, bt) {\n      for (var Nt = gt.length, At = []; Nt--; )\n        At[Nt] = bt(gt[Nt]);\n      return At;\n    }\n    function ut(gt, bt) {\n      var Nt = gt.split(\"@\"), At = \"\";\n      Nt.length > 1 && (At = Nt[0] + \"@\", gt = Nt[1]), gt = gt.replace(J, \".\");\n      var It = gt.split(\".\"), Mt = at(It, bt).join(\".\");\n      return At + Mt;\n    }\n    function ft(gt) {\n      for (var bt = [], Nt = 0, At = gt.length, It, Mt; Nt < At; )\n        It = gt.charCodeAt(Nt++), It >= 55296 && It <= 56319 && Nt < At ? (Mt = gt.charCodeAt(Nt++), (Mt & 64512) == 56320 ? bt.push(((It & 1023) << 10) + (Mt & 1023) + 65536) : (bt.push(It), Nt--)) : bt.push(It);\n      return bt;\n    }\n    function ct(gt) {\n      return at(gt, function(bt) {\n        var Nt = \"\";\n        return bt > 65535 && (bt -= 65536, Nt += tt(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), Nt += tt(bt), Nt;\n      }).join(\"\");\n    }\n    function vt(gt) {\n      return gt - 48 < 10 ? gt - 22 : gt - 65 < 26 ? gt - 65 : gt - 97 < 26 ? gt - 97 : G;\n    }\n    function yt(gt, bt) {\n      return gt + 22 + 75 * (gt < 26) - ((bt != 0) << 5);\n    }\n    function mt(gt, bt, Nt) {\n      var At = 0;\n      for (gt = Nt ? nt(gt / V) : gt >> 1, gt += nt(gt / bt); gt > et * z >> 1; At += G)\n        gt = nt(gt / et);\n      return nt(At + (et + 1) * gt / (gt + X));\n    }\n    function _t(gt) {\n      var bt = [], Nt = gt.length, At, It = 0, Mt = q, dt = Y, $t, Dt, Vt, Lt, Et, Ht, kt, wt, Bt;\n      for ($t = gt.lastIndexOf(W), $t < 0 && ($t = 0), Dt = 0; Dt < $t; ++Dt)\n        gt.charCodeAt(Dt) >= 128 && st(\"not-basic\"), bt.push(gt.charCodeAt(Dt));\n      for (Vt = $t > 0 ? $t + 1 : 0; Vt < Nt; ) {\n        for (Lt = It, Et = 1, Ht = G; Vt >= Nt && st(\"invalid-input\"), kt = vt(gt.charCodeAt(Vt++)), (kt >= G || kt > nt(($ - It) / Et)) && st(\"overflow\"), It += kt * Et, wt = Ht <= dt ? U : Ht >= dt + z ? z : Ht - dt, !(kt < wt); Ht += G)\n          Bt = G - wt, Et > nt($ / Bt) && st(\"overflow\"), Et *= Bt;\n        At = bt.length + 1, dt = mt(It - Lt, At, Lt == 0), nt(It / At) > $ - Mt && st(\"overflow\"), Mt += nt(It / At), It %= At, bt.splice(It++, 0, Mt);\n      }\n      return ct(bt);\n    }\n    function Tt(gt) {\n      var bt, Nt, At, It, Mt, dt, $t, Dt, Vt, Lt, Et, Ht = [], kt, wt, Bt, jt;\n      for (gt = ft(gt), kt = gt.length, bt = q, Nt = 0, Mt = Y, dt = 0; dt < kt; ++dt)\n        Et = gt[dt], Et < 128 && Ht.push(tt(Et));\n      for (At = It = Ht.length, It && Ht.push(W); At < kt; ) {\n        for ($t = $, dt = 0; dt < kt; ++dt)\n          Et = gt[dt], Et >= bt && Et < $t && ($t = Et);\n        for (wt = At + 1, $t - bt > nt(($ - Nt) / wt) && st(\"overflow\"), Nt += ($t - bt) * wt, bt = $t, dt = 0; dt < kt; ++dt)\n          if (Et = gt[dt], Et < bt && ++Nt > $ && st(\"overflow\"), Et == bt) {\n            for (Dt = Nt, Vt = G; Lt = Vt <= Mt ? U : Vt >= Mt + z ? z : Vt - Mt, !(Dt < Lt); Vt += G)\n              jt = Dt - Lt, Bt = G - Lt, Ht.push(\n                tt(yt(Lt + jt % Bt, 0))\n              ), Dt = nt(jt / Bt);\n            Ht.push(tt(yt(Dt, 0))), Mt = mt(Nt, wt, At == It), Nt = 0, ++At;\n          }\n        ++Nt, ++bt;\n      }\n      return Ht.join(\"\");\n    }\n    function Pt(gt) {\n      return ut(gt, function(bt) {\n        return K.test(bt) ? _t(bt.slice(4).toLowerCase()) : bt;\n      });\n    }\n    function St(gt) {\n      return ut(gt, function(bt) {\n        return Z.test(bt) ? \"xn--\" + Tt(bt) : bt;\n      });\n    }\n    if (k = {\n      /**\n       * A string representing the current Punycode.js version number.\n       * @memberOf punycode\n       * @type String\n       */\n      version: \"1.3.2\",\n      /**\n       * An object of methods to convert from JavaScript's internal character\n       * representation (UCS-2) to Unicode code points, and back.\n       * @see <https://mathiasbynens.be/notes/javascript-encoding>\n       * @memberOf punycode\n       * @type Object\n       */\n      ucs2: {\n        decode: ft,\n        encode: ct\n      },\n      decode: _t,\n      encode: Tt,\n      toASCII: St,\n      toUnicode: Pt\n    }, r && D)\n      if (o.exports == r)\n        D.exports = k;\n      else\n        for (it in k)\n          k.hasOwnProperty(it) && (r[it] = k[it]);\n    else\n      e.punycode = k;\n  })(commonjsGlobal);\n})(punycode$1, punycodeExports);\nvar util$8 = {\n  isString: function(o) {\n    return typeof o == \"string\";\n  },\n  isObject: function(o) {\n    return typeof o == \"object\" && o !== null;\n  },\n  isNull: function(o) {\n    return o === null;\n  },\n  isNullOrUndefined: function(o) {\n    return o == null;\n  }\n}, querystring$1 = {};\nfunction hasOwnProperty(o, t) {\n  return Object.prototype.hasOwnProperty.call(o, t);\n}\nvar decode$2 = function(o, t, e, r) {\n  t = t || \"&\", e = e || \"=\";\n  var D = {};\n  if (typeof o != \"string\" || o.length === 0)\n    return D;\n  var N = /\\+/g;\n  o = o.split(t);\n  var k = 1e3;\n  r && typeof r.maxKeys == \"number\" && (k = r.maxKeys);\n  var $ = o.length;\n  k > 0 && $ > k && ($ = k);\n  for (var G = 0; G < $; ++G) {\n    var U = o[G].replace(N, \"%20\"), z = U.indexOf(e), X, V, Y, q;\n    z >= 0 ? (X = U.substr(0, z), V = U.substr(z + 1)) : (X = U, V = \"\"), Y = decodeURIComponent(X), q = decodeURIComponent(V), hasOwnProperty(D, Y) ? Array.isArray(D[Y]) ? D[Y].push(q) : D[Y] = [D[Y], q] : D[Y] = q;\n  }\n  return D;\n}, stringifyPrimitive = function(o) {\n  switch (typeof o) {\n    case \"string\":\n      return o;\n    case \"boolean\":\n      return o ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(o) ? o : \"\";\n    default:\n      return \"\";\n  }\n}, encode$2 = function(o, t, e, r) {\n  return t = t || \"&\", e = e || \"=\", o === null && (o = void 0), typeof o == \"object\" ? Object.keys(o).map(function(D) {\n    var N = encodeURIComponent(stringifyPrimitive(D)) + e;\n    return Array.isArray(o[D]) ? o[D].map(function(k) {\n      return N + encodeURIComponent(stringifyPrimitive(k));\n    }).join(t) : N + encodeURIComponent(stringifyPrimitive(o[D]));\n  }).join(t) : r ? encodeURIComponent(stringifyPrimitive(r)) + e + encodeURIComponent(stringifyPrimitive(o)) : \"\";\n};\nquerystring$1.decode = querystring$1.parse = decode$2;\nquerystring$1.encode = querystring$1.stringify = encode$2;\nvar punycode = punycodeExports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;\nfunction Url() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", `\n`, \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n}, querystring = querystring$1;\nfunction urlParse(o, t, e) {\n  if (o && util$7.isObject(o) && o instanceof Url)\n    return o;\n  var r = new Url();\n  return r.parse(o, t, e), r;\n}\nUrl.prototype.parse = function(o, t, e) {\n  if (!util$7.isString(o))\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof o);\n  var r = o.indexOf(\"?\"), D = r !== -1 && r < o.indexOf(\"#\") ? \"?\" : \"#\", N = o.split(D), k = /\\\\/g;\n  N[0] = N[0].replace(k, \"/\"), o = N.join(D);\n  var $ = o;\n  if ($ = $.trim(), !e && o.split(\"#\").length === 1) {\n    var G = simplePathPattern.exec($);\n    if (G)\n      return this.path = $, this.href = $, this.pathname = G[1], G[2] ? (this.search = G[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = \"\", this.query = {}), this;\n  }\n  var U = protocolPattern.exec($);\n  if (U) {\n    U = U[0];\n    var z = U.toLowerCase();\n    this.protocol = z, $ = $.substr(U.length);\n  }\n  if (e || U || $.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var X = $.substr(0, 2) === \"//\";\n    X && !(U && hostlessProtocol[U]) && ($ = $.substr(2), this.slashes = !0);\n  }\n  if (!hostlessProtocol[U] && (X || U && !slashedProtocol[U])) {\n    for (var V = -1, Y = 0; Y < hostEndingChars.length; Y++) {\n      var q = $.indexOf(hostEndingChars[Y]);\n      q !== -1 && (V === -1 || q < V) && (V = q);\n    }\n    var W, K;\n    V === -1 ? K = $.lastIndexOf(\"@\") : K = $.lastIndexOf(\"@\", V), K !== -1 && (W = $.slice(0, K), $ = $.slice(K + 1), this.auth = decodeURIComponent(W)), V = -1;\n    for (var Y = 0; Y < nonHostChars.length; Y++) {\n      var q = $.indexOf(nonHostChars[Y]);\n      q !== -1 && (V === -1 || q < V) && (V = q);\n    }\n    V === -1 && (V = $.length), this.host = $.slice(0, V), $ = $.slice(V), this.parseHost(), this.hostname = this.hostname || \"\";\n    var Z = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!Z)\n      for (var J = this.hostname.split(/\\./), Y = 0, Q = J.length; Y < Q; Y++) {\n        var et = J[Y];\n        if (et && !et.match(hostnamePartPattern)) {\n          for (var nt = \"\", tt = 0, it = et.length; tt < it; tt++)\n            et.charCodeAt(tt) > 127 ? nt += \"x\" : nt += et[tt];\n          if (!nt.match(hostnamePartPattern)) {\n            var st = J.slice(0, Y), at = J.slice(Y + 1), ut = et.match(hostnamePartStart);\n            ut && (st.push(ut[1]), at.unshift(ut[2])), at.length && ($ = \"/\" + at.join(\".\") + $), this.hostname = st.join(\".\");\n            break;\n          }\n        }\n      }\n    this.hostname.length > hostnameMaxLen ? this.hostname = \"\" : this.hostname = this.hostname.toLowerCase(), Z || (this.hostname = punycode.toASCII(this.hostname));\n    var ft = this.port ? \":\" + this.port : \"\", ct = this.hostname || \"\";\n    this.host = ct + ft, this.href += this.host, Z && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), $[0] !== \"/\" && ($ = \"/\" + $));\n  }\n  if (!unsafeProtocol[z])\n    for (var Y = 0, Q = autoEscape.length; Y < Q; Y++) {\n      var vt = autoEscape[Y];\n      if ($.indexOf(vt) !== -1) {\n        var yt = encodeURIComponent(vt);\n        yt === vt && (yt = escape(vt)), $ = $.split(vt).join(yt);\n      }\n    }\n  var mt = $.indexOf(\"#\");\n  mt !== -1 && (this.hash = $.substr(mt), $ = $.slice(0, mt));\n  var _t = $.indexOf(\"?\");\n  if (_t !== -1 ? (this.search = $.substr(_t), this.query = $.substr(_t + 1), t && (this.query = querystring.parse(this.query)), $ = $.slice(0, _t)) : t && (this.search = \"\", this.query = {}), $ && (this.pathname = $), slashedProtocol[z] && this.hostname && !this.pathname && (this.pathname = \"/\"), this.pathname || this.search) {\n    var ft = this.pathname || \"\", Tt = this.search || \"\";\n    this.path = ft + Tt;\n  }\n  return this.href = this.format(), this;\n};\nfunction urlFormat(o) {\n  return util$7.isString(o) && (o = urlParse(o)), o instanceof Url ? o.format() : Url.prototype.format.call(o);\n}\nUrl.prototype.format = function() {\n  var o = this.auth || \"\";\n  o && (o = encodeURIComponent(o), o = o.replace(/%3A/i, \":\"), o += \"@\");\n  var t = this.protocol || \"\", e = this.pathname || \"\", r = this.hash || \"\", D = !1, N = \"\";\n  this.host ? D = o + this.host : this.hostname && (D = o + (this.hostname.indexOf(\":\") === -1 ? this.hostname : \"[\" + this.hostname + \"]\"), this.port && (D += \":\" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (N = querystring.stringify(this.query));\n  var k = this.search || N && \"?\" + N || \"\";\n  return t && t.substr(-1) !== \":\" && (t += \":\"), this.slashes || (!t || slashedProtocol[t]) && D !== !1 ? (D = \"//\" + (D || \"\"), e && e.charAt(0) !== \"/\" && (e = \"/\" + e)) : D || (D = \"\"), r && r.charAt(0) !== \"#\" && (r = \"#\" + r), k && k.charAt(0) !== \"?\" && (k = \"?\" + k), e = e.replace(/[?#]/g, function($) {\n    return encodeURIComponent($);\n  }), k = k.replace(\"#\", \"%23\"), t + D + e + k + r;\n};\nfunction urlResolve(o, t) {\n  return urlParse(o, !1, !0).resolve(t);\n}\nUrl.prototype.resolve = function(o) {\n  return this.resolveObject(urlParse(o, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(o) {\n  if (util$7.isString(o)) {\n    var t = new Url();\n    t.parse(o, !1, !0), o = t;\n  }\n  for (var e = new Url(), r = Object.keys(this), D = 0; D < r.length; D++) {\n    var N = r[D];\n    e[N] = this[N];\n  }\n  if (e.hash = o.hash, o.href === \"\")\n    return e.href = e.format(), e;\n  if (o.slashes && !o.protocol) {\n    for (var k = Object.keys(o), $ = 0; $ < k.length; $++) {\n      var G = k[$];\n      G !== \"protocol\" && (e[G] = o[G]);\n    }\n    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = \"/\"), e.href = e.format(), e;\n  }\n  if (o.protocol && o.protocol !== e.protocol) {\n    if (!slashedProtocol[o.protocol]) {\n      for (var U = Object.keys(o), z = 0; z < U.length; z++) {\n        var X = U[z];\n        e[X] = o[X];\n      }\n      return e.href = e.format(), e;\n    }\n    if (e.protocol = o.protocol, !o.host && !hostlessProtocol[o.protocol]) {\n      for (var Q = (o.pathname || \"\").split(\"/\"); Q.length && !(o.host = Q.shift()); )\n        ;\n      o.host || (o.host = \"\"), o.hostname || (o.hostname = \"\"), Q[0] !== \"\" && Q.unshift(\"\"), Q.length < 2 && Q.unshift(\"\"), e.pathname = Q.join(\"/\");\n    } else\n      e.pathname = o.pathname;\n    if (e.search = o.search, e.query = o.query, e.host = o.host || \"\", e.auth = o.auth, e.hostname = o.hostname || o.host, e.port = o.port, e.pathname || e.search) {\n      var V = e.pathname || \"\", Y = e.search || \"\";\n      e.path = V + Y;\n    }\n    return e.slashes = e.slashes || o.slashes, e.href = e.format(), e;\n  }\n  var q = e.pathname && e.pathname.charAt(0) === \"/\", W = o.host || o.pathname && o.pathname.charAt(0) === \"/\", K = W || q || e.host && o.pathname, Z = K, J = e.pathname && e.pathname.split(\"/\") || [], Q = o.pathname && o.pathname.split(\"/\") || [], et = e.protocol && !slashedProtocol[e.protocol];\n  if (et && (e.hostname = \"\", e.port = null, e.host && (J[0] === \"\" ? J[0] = e.host : J.unshift(e.host)), e.host = \"\", o.protocol && (o.hostname = null, o.port = null, o.host && (Q[0] === \"\" ? Q[0] = o.host : Q.unshift(o.host)), o.host = null), K = K && (Q[0] === \"\" || J[0] === \"\")), W)\n    e.host = o.host || o.host === \"\" ? o.host : e.host, e.hostname = o.hostname || o.hostname === \"\" ? o.hostname : e.hostname, e.search = o.search, e.query = o.query, J = Q;\n  else if (Q.length)\n    J || (J = []), J.pop(), J = J.concat(Q), e.search = o.search, e.query = o.query;\n  else if (!util$7.isNullOrUndefined(o.search)) {\n    if (et) {\n      e.hostname = e.host = J.shift();\n      var nt = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n      nt && (e.auth = nt.shift(), e.host = e.hostname = nt.shift());\n    }\n    return e.search = o.search, e.query = o.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.href = e.format(), e;\n  }\n  if (!J.length)\n    return e.pathname = null, e.search ? e.path = \"/\" + e.search : e.path = null, e.href = e.format(), e;\n  for (var tt = J.slice(-1)[0], it = (e.host || o.host || J.length > 1) && (tt === \".\" || tt === \"..\") || tt === \"\", st = 0, at = J.length; at >= 0; at--)\n    tt = J[at], tt === \".\" ? J.splice(at, 1) : tt === \"..\" ? (J.splice(at, 1), st++) : st && (J.splice(at, 1), st--);\n  if (!K && !Z)\n    for (; st--; st)\n      J.unshift(\"..\");\n  K && J[0] !== \"\" && (!J[0] || J[0].charAt(0) !== \"/\") && J.unshift(\"\"), it && J.join(\"/\").substr(-1) !== \"/\" && J.push(\"\");\n  var ut = J[0] === \"\" || J[0] && J[0].charAt(0) === \"/\";\n  if (et) {\n    e.hostname = e.host = ut ? \"\" : J.length ? J.shift() : \"\";\n    var nt = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n    nt && (e.auth = nt.shift(), e.host = e.hostname = nt.shift());\n  }\n  return K = K || e.host && J.length, K && !ut && J.unshift(\"\"), J.length ? e.pathname = J.join(\"/\") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.auth = o.auth || e.auth, e.slashes = e.slashes || o.slashes, e.href = e.format(), e;\n};\nUrl.prototype.parseHost = function() {\n  var o = this.host, t = portPattern.exec(o);\n  t && (t = t[0], t !== \":\" && (this.port = t.substr(1)), o = o.substr(0, o.length - t.length)), o && (this.hostname = o);\n};\n/*!\n * @pixi/utils - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar url$1 = {\n  parse: parse$2,\n  format: format$1,\n  resolve\n};\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nvar saidHello = !1, VERSION$1 = \"6.5.9\";\nfunction skipHello() {\n  saidHello = !0;\n}\nfunction sayHello(o) {\n  var t;\n  if (!saidHello) {\n    if (settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n      var e = [\n        `\n %c %c %c PixiJS ` + VERSION$1 + \" - ✰ \" + o + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n`,\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff66a5; background: #030307; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ffc3dc; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\"\n      ];\n      (t = globalThis.console).log.apply(t, e);\n    } else\n      globalThis.console && globalThis.console.log(\"PixiJS \" + VERSION$1 + \" - \" + o + \" - http://www.pixijs.com/\");\n    saidHello = !0;\n  }\n}\nvar supported;\nfunction isWebGLSupported() {\n  return typeof supported > \"u\" && (supported = function() {\n    var t = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      var e = settings.ADAPTER.createCanvas(), r = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t), D = !!(r && r.getContextAttributes().stencil);\n      if (r) {\n        var N = r.getExtension(\"WEBGL_lose_context\");\n        N && N.loseContext();\n      }\n      return r = null, D;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\nvar aliceblue = \"#f0f8ff\", antiquewhite = \"#faebd7\", aqua = \"#00ffff\", aquamarine = \"#7fffd4\", azure = \"#f0ffff\", beige = \"#f5f5dc\", bisque = \"#ffe4c4\", black = \"#000000\", blanchedalmond = \"#ffebcd\", blue = \"#0000ff\", blueviolet = \"#8a2be2\", brown = \"#a52a2a\", burlywood = \"#deb887\", cadetblue = \"#5f9ea0\", chartreuse = \"#7fff00\", chocolate = \"#d2691e\", coral = \"#ff7f50\", cornflowerblue = \"#6495ed\", cornsilk = \"#fff8dc\", crimson = \"#dc143c\", cyan = \"#00ffff\", darkblue = \"#00008b\", darkcyan = \"#008b8b\", darkgoldenrod = \"#b8860b\", darkgray = \"#a9a9a9\", darkgreen = \"#006400\", darkgrey = \"#a9a9a9\", darkkhaki = \"#bdb76b\", darkmagenta = \"#8b008b\", darkolivegreen = \"#556b2f\", darkorange = \"#ff8c00\", darkorchid = \"#9932cc\", darkred = \"#8b0000\", darksalmon = \"#e9967a\", darkseagreen = \"#8fbc8f\", darkslateblue = \"#483d8b\", darkslategray = \"#2f4f4f\", darkslategrey = \"#2f4f4f\", darkturquoise = \"#00ced1\", darkviolet = \"#9400d3\", deeppink = \"#ff1493\", deepskyblue = \"#00bfff\", dimgray = \"#696969\", dimgrey = \"#696969\", dodgerblue = \"#1e90ff\", firebrick = \"#b22222\", floralwhite = \"#fffaf0\", forestgreen = \"#228b22\", fuchsia = \"#ff00ff\", gainsboro = \"#dcdcdc\", ghostwhite = \"#f8f8ff\", goldenrod = \"#daa520\", gold = \"#ffd700\", gray = \"#808080\", green = \"#008000\", greenyellow = \"#adff2f\", grey = \"#808080\", honeydew = \"#f0fff0\", hotpink = \"#ff69b4\", indianred = \"#cd5c5c\", indigo = \"#4b0082\", ivory = \"#fffff0\", khaki = \"#f0e68c\", lavenderblush = \"#fff0f5\", lavender = \"#e6e6fa\", lawngreen = \"#7cfc00\", lemonchiffon = \"#fffacd\", lightblue = \"#add8e6\", lightcoral = \"#f08080\", lightcyan = \"#e0ffff\", lightgoldenrodyellow = \"#fafad2\", lightgray = \"#d3d3d3\", lightgreen = \"#90ee90\", lightgrey = \"#d3d3d3\", lightpink = \"#ffb6c1\", lightsalmon = \"#ffa07a\", lightseagreen = \"#20b2aa\", lightskyblue = \"#87cefa\", lightslategray = \"#778899\", lightslategrey = \"#778899\", lightsteelblue = \"#b0c4de\", lightyellow = \"#ffffe0\", lime = \"#00ff00\", limegreen = \"#32cd32\", linen = \"#faf0e6\", magenta = \"#ff00ff\", maroon = \"#800000\", mediumaquamarine = \"#66cdaa\", mediumblue = \"#0000cd\", mediumorchid = \"#ba55d3\", mediumpurple = \"#9370db\", mediumseagreen = \"#3cb371\", mediumslateblue = \"#7b68ee\", mediumspringgreen = \"#00fa9a\", mediumturquoise = \"#48d1cc\", mediumvioletred = \"#c71585\", midnightblue = \"#191970\", mintcream = \"#f5fffa\", mistyrose = \"#ffe4e1\", moccasin = \"#ffe4b5\", navajowhite = \"#ffdead\", navy = \"#000080\", oldlace = \"#fdf5e6\", olive = \"#808000\", olivedrab = \"#6b8e23\", orange = \"#ffa500\", orangered = \"#ff4500\", orchid = \"#da70d6\", palegoldenrod = \"#eee8aa\", palegreen = \"#98fb98\", paleturquoise = \"#afeeee\", palevioletred = \"#db7093\", papayawhip = \"#ffefd5\", peachpuff = \"#ffdab9\", peru = \"#cd853f\", pink = \"#ffc0cb\", plum = \"#dda0dd\", powderblue = \"#b0e0e6\", purple = \"#800080\", rebeccapurple = \"#663399\", red = \"#ff0000\", rosybrown = \"#bc8f8f\", royalblue = \"#4169e1\", saddlebrown = \"#8b4513\", salmon = \"#fa8072\", sandybrown = \"#f4a460\", seagreen = \"#2e8b57\", seashell = \"#fff5ee\", sienna = \"#a0522d\", silver = \"#c0c0c0\", skyblue = \"#87ceeb\", slateblue = \"#6a5acd\", slategray = \"#708090\", slategrey = \"#708090\", snow = \"#fffafa\", springgreen = \"#00ff7f\", steelblue = \"#4682b4\", tan = \"#d2b48c\", teal = \"#008080\", thistle = \"#d8bfd8\", tomato = \"#ff6347\", turquoise = \"#40e0d0\", violet = \"#ee82ee\", wheat = \"#f5deb3\", white = \"#ffffff\", whitesmoke = \"#f5f5f5\", yellow = \"#ffff00\", yellowgreen = \"#9acd32\", cssColorNames = {\n  aliceblue,\n  antiquewhite,\n  aqua,\n  aquamarine,\n  azure,\n  beige,\n  bisque,\n  black,\n  blanchedalmond,\n  blue,\n  blueviolet,\n  brown,\n  burlywood,\n  cadetblue,\n  chartreuse,\n  chocolate,\n  coral,\n  cornflowerblue,\n  cornsilk,\n  crimson,\n  cyan,\n  darkblue,\n  darkcyan,\n  darkgoldenrod,\n  darkgray,\n  darkgreen,\n  darkgrey,\n  darkkhaki,\n  darkmagenta,\n  darkolivegreen,\n  darkorange,\n  darkorchid,\n  darkred,\n  darksalmon,\n  darkseagreen,\n  darkslateblue,\n  darkslategray,\n  darkslategrey,\n  darkturquoise,\n  darkviolet,\n  deeppink,\n  deepskyblue,\n  dimgray,\n  dimgrey,\n  dodgerblue,\n  firebrick,\n  floralwhite,\n  forestgreen,\n  fuchsia,\n  gainsboro,\n  ghostwhite,\n  goldenrod,\n  gold,\n  gray,\n  green,\n  greenyellow,\n  grey,\n  honeydew,\n  hotpink,\n  indianred,\n  indigo,\n  ivory,\n  khaki,\n  lavenderblush,\n  lavender,\n  lawngreen,\n  lemonchiffon,\n  lightblue,\n  lightcoral,\n  lightcyan,\n  lightgoldenrodyellow,\n  lightgray,\n  lightgreen,\n  lightgrey,\n  lightpink,\n  lightsalmon,\n  lightseagreen,\n  lightskyblue,\n  lightslategray,\n  lightslategrey,\n  lightsteelblue,\n  lightyellow,\n  lime,\n  limegreen,\n  linen,\n  magenta,\n  maroon,\n  mediumaquamarine,\n  mediumblue,\n  mediumorchid,\n  mediumpurple,\n  mediumseagreen,\n  mediumslateblue,\n  mediumspringgreen,\n  mediumturquoise,\n  mediumvioletred,\n  midnightblue,\n  mintcream,\n  mistyrose,\n  moccasin,\n  navajowhite,\n  navy,\n  oldlace,\n  olive,\n  olivedrab,\n  orange,\n  orangered,\n  orchid,\n  palegoldenrod,\n  palegreen,\n  paleturquoise,\n  palevioletred,\n  papayawhip,\n  peachpuff,\n  peru,\n  pink,\n  plum,\n  powderblue,\n  purple,\n  rebeccapurple,\n  red,\n  rosybrown,\n  royalblue,\n  saddlebrown,\n  salmon,\n  sandybrown,\n  seagreen,\n  seashell,\n  sienna,\n  silver,\n  skyblue,\n  slateblue,\n  slategray,\n  slategrey,\n  snow,\n  springgreen,\n  steelblue,\n  tan,\n  teal,\n  thistle,\n  tomato,\n  turquoise,\n  violet,\n  wheat,\n  white,\n  whitesmoke,\n  yellow,\n  yellowgreen\n};\nfunction hex2rgb(o, t) {\n  return t === void 0 && (t = []), t[0] = (o >> 16 & 255) / 255, t[1] = (o >> 8 & 255) / 255, t[2] = (o & 255) / 255, t;\n}\nfunction hex2string(o) {\n  var t = o.toString(16);\n  return t = \"000000\".substring(0, 6 - t.length) + t, \"#\" + t;\n}\nfunction string2hex(o) {\n  return typeof o == \"string\" && (o = cssColorNames[o.toLowerCase()] || o, o[0] === \"#\" && (o = o.slice(1))), parseInt(o, 16);\n}\nfunction mapPremultipliedBlendModes() {\n  for (var o = [], t = [], e = 0; e < 32; e++)\n    o[e] = e, t[e] = e;\n  o[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, o[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, o[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  var r = [];\n  return r.push(t), r.push(o), r;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(o, t) {\n  return premultiplyBlendMode[t ? 1 : 0][o];\n}\nfunction premultiplyRgba(o, t, e, r) {\n  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = o[0] * t, e[1] = o[1] * t, e[2] = o[2] * t) : (e[0] = o[0], e[1] = o[1], e[2] = o[2]), e[3] = t, e;\n}\nfunction premultiplyTint(o, t) {\n  if (t === 1)\n    return (t * 255 << 24) + o;\n  if (t === 0)\n    return 0;\n  var e = o >> 16 & 255, r = o >> 8 & 255, D = o & 255;\n  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, D = D * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + D;\n}\nfunction premultiplyTintToRgba(o, t, e, r) {\n  return e = e || new Float32Array(4), e[0] = (o >> 16 & 255) / 255, e[1] = (o >> 8 & 255) / 255, e[2] = (o & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;\n}\nfunction createIndicesForQuads(o, t) {\n  t === void 0 && (t = null);\n  var e = o * 6;\n  if (t = t || new Uint16Array(e), t.length !== e)\n    throw new Error(\"Out buffer length is incorrect, got \" + t.length + \" and expected \" + e);\n  for (var r = 0, D = 0; r < e; r += 6, D += 4)\n    t[r + 0] = D + 0, t[r + 1] = D + 1, t[r + 2] = D + 2, t[r + 3] = D + 0, t[r + 4] = D + 2, t[r + 5] = D + 3;\n  return t;\n}\nfunction getBufferType(o) {\n  if (o.BYTES_PER_ELEMENT === 4)\n    return o instanceof Float32Array ? \"Float32Array\" : o instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (o.BYTES_PER_ELEMENT === 2) {\n    if (o instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (o.BYTES_PER_ELEMENT === 1 && o instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nfunction nextPow2(o) {\n  return o += o === 0 ? 1 : 0, --o, o |= o >>> 1, o |= o >>> 2, o |= o >>> 4, o |= o >>> 8, o |= o >>> 16, o + 1;\n}\nfunction isPow2(o) {\n  return !(o & o - 1) && !!o;\n}\nfunction log2(o) {\n  var t = (o > 65535 ? 1 : 0) << 4;\n  o >>>= t;\n  var e = (o > 255 ? 1 : 0) << 3;\n  return o >>>= e, t |= e, e = (o > 15 ? 1 : 0) << 2, o >>>= e, t |= e, e = (o > 3 ? 1 : 0) << 1, o >>>= e, t |= e, t | o >> 1;\n}\nfunction removeItems(o, t, e) {\n  var r = o.length, D;\n  if (!(t >= r || e === 0)) {\n    e = t + e > r ? r - t : e;\n    var N = r - e;\n    for (D = t; D < N; ++D)\n      o[D] = o[D + e];\n    o.length = N;\n  }\n}\nfunction sign(o) {\n  return o === 0 ? 0 : o < 0 ? -1 : 1;\n}\nvar nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nvar warnings = {};\nfunction deprecation(o, t, e) {\n  if (e === void 0 && (e = 3), !warnings[t]) {\n    var r = new Error().stack;\n    typeof r > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + o) : (r = r.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + o), console.warn(r), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + o), console.warn(r))), warnings[t] = !0;\n  }\n}\nvar ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction clearTextureCache() {\n  var o;\n  for (o in TextureCache)\n    delete TextureCache[o];\n  for (o in BaseTextureCache)\n    delete BaseTextureCache[o];\n}\nvar CanvasRenderTarget = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = r || settings.RESOLUTION, this.resize(t, e);\n    }\n    return o.prototype.clear = function() {\n      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }, o.prototype.resize = function(t, e) {\n      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n    }, o.prototype.destroy = function() {\n      this.context = null, this.canvas = null;\n    }, Object.defineProperty(o.prototype, \"width\", {\n      /**\n       * The width of the canvas buffer in pixels.\n       * @member {number}\n       */\n      get: function() {\n        return this.canvas.width;\n      },\n      set: function(t) {\n        this.canvas.width = Math.round(t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"height\", {\n      /**\n       * The height of the canvas buffer in pixels.\n       * @member {number}\n       */\n      get: function() {\n        return this.canvas.height;\n      },\n      set: function(t) {\n        this.canvas.height = Math.round(t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n);\nfunction trimCanvas(o) {\n  var t = o.width, e = o.height, r = o.getContext(\"2d\", {\n    willReadFrequently: !0\n  }), D = r.getImageData(0, 0, t, e), N = D.data, k = N.length, $ = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  }, G = null, U, z, X;\n  for (U = 0; U < k; U += 4)\n    N[U + 3] !== 0 && (z = U / 4 % t, X = ~~(U / 4 / t), $.top === null && ($.top = X), ($.left === null || z < $.left) && ($.left = z), ($.right === null || $.right < z) && ($.right = z + 1), ($.bottom === null || $.bottom < X) && ($.bottom = X));\n  return $.top !== null && (t = $.right - $.left, e = $.bottom - $.top + 1, G = r.getImageData($.left, $.top, t, e)), {\n    height: e,\n    width: t,\n    data: G\n  };\n}\nvar tempAnchor$1;\nfunction determineCrossOrigin(o, t) {\n  if (t === void 0 && (t = globalThis.location), o.indexOf(\"data:\") === 0)\n    return \"\";\n  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement(\"a\")), tempAnchor$1.href = o;\n  var e = url$1.parse(tempAnchor$1.href), r = !e.port && t.port === \"\" || e.port === t.port;\n  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? \"anonymous\" : \"\";\n}\nfunction getResolutionOfUrl(o, t) {\n  var e = settings.RETINA_PREFIX.exec(o);\n  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;\n}\n/*!\n * @pixi/math - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;\n(function(o) {\n  o[o.POLY = 0] = \"POLY\", o[o.RECT = 1] = \"RECT\", o[o.CIRC = 2] = \"CIRC\", o[o.ELIP = 3] = \"ELIP\", o[o.RREC = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\nvar Point = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;\n    }\n    return o.prototype.clone = function() {\n      return new o(this.x, this.y);\n    }, o.prototype.copyFrom = function(t) {\n      return this.set(t.x, t.y), this;\n    }, o.prototype.copyTo = function(t) {\n      return t.set(this.x, this.y), t;\n    }, o.prototype.equals = function(t) {\n      return t.x === this.x && t.y === this.y;\n    }, o.prototype.set = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n    }, o;\n  }()\n), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = (\n  /** @class */\n  function() {\n    function o(t, e, r, D) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(D), this.type = SHAPES.RECT;\n    }\n    return Object.defineProperty(o.prototype, \"left\", {\n      /** Returns the left edge of the rectangle. */\n      get: function() {\n        return this.x;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"right\", {\n      /** Returns the right edge of the rectangle. */\n      get: function() {\n        return this.x + this.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"top\", {\n      /** Returns the top edge of the rectangle. */\n      get: function() {\n        return this.y;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"bottom\", {\n      /** Returns the bottom edge of the rectangle. */\n      get: function() {\n        return this.y + this.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"EMPTY\", {\n      /** A constant empty rectangle. */\n      get: function() {\n        return new o(0, 0, 0, 0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.clone = function() {\n      return new o(this.x, this.y, this.width, this.height);\n    }, o.prototype.copyFrom = function(t) {\n      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;\n    }, o.prototype.copyTo = function(t) {\n      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;\n    }, o.prototype.contains = function(t, e) {\n      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;\n    }, o.prototype.intersects = function(t, e) {\n      if (!e) {\n        var r = this.x < t.x ? t.x : this.x, D = this.right > t.right ? t.right : this.right;\n        if (D <= r)\n          return !1;\n        var N = this.y < t.y ? t.y : this.y, k = this.bottom > t.bottom ? t.bottom : this.bottom;\n        return k > N;\n      }\n      var $ = this.left, G = this.right, U = this.top, z = this.bottom;\n      if (G <= $ || z <= U)\n        return !1;\n      var X = tempPoints$1[0].set(t.left, t.top), V = tempPoints$1[1].set(t.left, t.bottom), Y = tempPoints$1[2].set(t.right, t.top), q = tempPoints$1[3].set(t.right, t.bottom);\n      if (Y.x <= X.x || V.y <= X.y)\n        return !1;\n      var W = Math.sign(e.a * e.d - e.b * e.c);\n      if (W === 0 || (e.apply(X, X), e.apply(V, V), e.apply(Y, Y), e.apply(q, q), Math.max(X.x, V.x, Y.x, q.x) <= $ || Math.min(X.x, V.x, Y.x, q.x) >= G || Math.max(X.y, V.y, Y.y, q.y) <= U || Math.min(X.y, V.y, Y.y, q.y) >= z))\n        return !1;\n      var K = W * (V.y - X.y), Z = W * (X.x - V.x), J = K * $ + Z * U, Q = K * G + Z * U, et = K * $ + Z * z, nt = K * G + Z * z;\n      if (Math.max(J, Q, et, nt) <= K * X.x + Z * X.y || Math.min(J, Q, et, nt) >= K * q.x + Z * q.y)\n        return !1;\n      var tt = W * (X.y - Y.y), it = W * (Y.x - X.x), st = tt * $ + it * U, at = tt * G + it * U, ut = tt * $ + it * z, ft = tt * G + it * z;\n      return !(Math.max(st, at, ut, ft) <= tt * X.x + it * X.y || Math.min(st, at, ut, ft) >= tt * q.x + it * q.y);\n    }, o.prototype.pad = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;\n    }, o.prototype.fit = function(t) {\n      var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), D = Math.max(this.y, t.y), N = Math.min(this.y + this.height, t.y + t.height);\n      return this.x = e, this.width = Math.max(r - e, 0), this.y = D, this.height = Math.max(N - D, 0), this;\n    }, o.prototype.ceil = function(t, e) {\n      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);\n      var r = Math.ceil((this.x + this.width - e) * t) / t, D = Math.ceil((this.y + this.height - e) * t) / t;\n      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = D - this.y, this;\n    }, o.prototype.enlarge = function(t) {\n      var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), D = Math.min(this.y, t.y), N = Math.max(this.y + this.height, t.y + t.height);\n      return this.x = e, this.width = r - e, this.y = D, this.height = N - D, this;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    }, o;\n  }()\n), Circle = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = SHAPES.CIRC;\n    }\n    return o.prototype.clone = function() {\n      return new o(this.x, this.y, this.radius);\n    }, o.prototype.contains = function(t, e) {\n      if (this.radius <= 0)\n        return !1;\n      var r = this.radius * this.radius, D = this.x - t, N = this.y - e;\n      return D *= D, N *= N, D + N <= r;\n    }, o.prototype.getBounds = function() {\n      return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n    }, o;\n  }()\n), Ellipse = (\n  /** @class */\n  function() {\n    function o(t, e, r, D) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), this.x = t, this.y = e, this.width = r, this.height = D, this.type = SHAPES.ELIP;\n    }\n    return o.prototype.clone = function() {\n      return new o(this.x, this.y, this.width, this.height);\n    }, o.prototype.contains = function(t, e) {\n      if (this.width <= 0 || this.height <= 0)\n        return !1;\n      var r = (t - this.x) / this.width, D = (e - this.y) / this.height;\n      return r *= r, D *= D, r + D <= 1;\n    }, o.prototype.getBounds = function() {\n      return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    }, o;\n  }()\n), Polygon = (\n  /** @class */\n  function() {\n    function o() {\n      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n        e[r] = t[r];\n      var D = Array.isArray(e[0]) ? e[0] : e;\n      if (typeof D[0] != \"number\") {\n        for (var N = [], k = 0, $ = D.length; k < $; k++)\n          N.push(D[k].x, D[k].y);\n        D = N;\n      }\n      this.points = D, this.type = SHAPES.POLY, this.closeStroke = !0;\n    }\n    return o.prototype.clone = function() {\n      var t = this.points.slice(), e = new o(t);\n      return e.closeStroke = this.closeStroke, e;\n    }, o.prototype.contains = function(t, e) {\n      for (var r = !1, D = this.points.length / 2, N = 0, k = D - 1; N < D; k = N++) {\n        var $ = this.points[N * 2], G = this.points[N * 2 + 1], U = this.points[k * 2], z = this.points[k * 2 + 1], X = G > e != z > e && t < (U - $) * ((e - G) / (z - G)) + $;\n        X && (r = !r);\n      }\n      return r;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(t, e) {\n        return t + \", \" + e;\n      }, \"\") + \"]\");\n    }, o;\n  }()\n), RoundedRectangle = (\n  /** @class */\n  function() {\n    function o(t, e, r, D, N) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), N === void 0 && (N = 20), this.x = t, this.y = e, this.width = r, this.height = D, this.radius = N, this.type = SHAPES.RREC;\n    }\n    return o.prototype.clone = function() {\n      return new o(this.x, this.y, this.width, this.height, this.radius);\n    }, o.prototype.contains = function(t, e) {\n      if (this.width <= 0 || this.height <= 0)\n        return !1;\n      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {\n        var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)\n          return !0;\n        var D = t - (this.x + r), N = e - (this.y + r), k = r * r;\n        if (D * D + N * N <= k || (D = t - (this.x + this.width - r), D * D + N * N <= k) || (N = e - (this.y + this.height - r), D * D + N * N <= k) || (D = t - (this.x + r), D * D + N * N <= k))\n          return !0;\n      }\n      return !1;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n    }, o;\n  }()\n), ObservablePoint = (\n  /** @class */\n  function() {\n    function o(t, e, r, D) {\n      r === void 0 && (r = 0), D === void 0 && (D = 0), this._x = r, this._y = D, this.cb = t, this.scope = e;\n    }\n    return o.prototype.clone = function(t, e) {\n      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new o(t, e, this._x, this._y);\n    }, o.prototype.set = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;\n    }, o.prototype.copyFrom = function(t) {\n      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;\n    }, o.prototype.copyTo = function(t) {\n      return t.set(this._x, this._y), t;\n    }, o.prototype.equals = function(t) {\n      return t.x === this._x && t.y === this._y;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:ObservablePoint x=0 y=0 scope=\" + this.scope + \"]\";\n    }, Object.defineProperty(o.prototype, \"x\", {\n      /** Position of the observable point on the x axis. */\n      get: function() {\n        return this._x;\n      },\n      set: function(t) {\n        this._x !== t && (this._x = t, this.cb.call(this.scope));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"y\", {\n      /** Position of the observable point on the y axis. */\n      get: function() {\n        return this._y;\n      },\n      set: function(t) {\n        this._y !== t && (this._y = t, this.cb.call(this.scope));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n), Matrix = (\n  /** @class */\n  function() {\n    function o(t, e, r, D, N, k) {\n      t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 0), k === void 0 && (k = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = D, this.tx = N, this.ty = k;\n    }\n    return o.prototype.fromArray = function(t) {\n      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];\n    }, o.prototype.set = function(t, e, r, D, N, k) {\n      return this.a = t, this.b = e, this.c = r, this.d = D, this.tx = N, this.ty = k, this;\n    }, o.prototype.toArray = function(t, e) {\n      this.array || (this.array = new Float32Array(9));\n      var r = e || this.array;\n      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;\n    }, o.prototype.apply = function(t, e) {\n      e = e || new Point();\n      var r = t.x, D = t.y;\n      return e.x = this.a * r + this.c * D + this.tx, e.y = this.b * r + this.d * D + this.ty, e;\n    }, o.prototype.applyInverse = function(t, e) {\n      e = e || new Point();\n      var r = 1 / (this.a * this.d + this.c * -this.b), D = t.x, N = t.y;\n      return e.x = this.d * r * D + -this.c * r * N + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * N + -this.b * r * D + (-this.ty * this.a + this.tx * this.b) * r, e;\n    }, o.prototype.translate = function(t, e) {\n      return this.tx += t, this.ty += e, this;\n    }, o.prototype.scale = function(t, e) {\n      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;\n    }, o.prototype.rotate = function(t) {\n      var e = Math.cos(t), r = Math.sin(t), D = this.a, N = this.c, k = this.tx;\n      return this.a = D * e - this.b * r, this.b = D * r + this.b * e, this.c = N * e - this.d * r, this.d = N * r + this.d * e, this.tx = k * e - this.ty * r, this.ty = k * r + this.ty * e, this;\n    }, o.prototype.append = function(t) {\n      var e = this.a, r = this.b, D = this.c, N = this.d;\n      return this.a = t.a * e + t.b * D, this.b = t.a * r + t.b * N, this.c = t.c * e + t.d * D, this.d = t.c * r + t.d * N, this.tx = t.tx * e + t.ty * D + this.tx, this.ty = t.tx * r + t.ty * N + this.ty, this;\n    }, o.prototype.setTransform = function(t, e, r, D, N, k, $, G, U) {\n      return this.a = Math.cos($ + U) * N, this.b = Math.sin($ + U) * N, this.c = -Math.sin($ - G) * k, this.d = Math.cos($ - G) * k, this.tx = t - (r * this.a + D * this.c), this.ty = e - (r * this.b + D * this.d), this;\n    }, o.prototype.prepend = function(t) {\n      var e = this.tx;\n      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {\n        var r = this.a, D = this.c;\n        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = D * t.a + this.d * t.c, this.d = D * t.b + this.d * t.d;\n      }\n      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;\n    }, o.prototype.decompose = function(t) {\n      var e = this.a, r = this.b, D = this.c, N = this.d, k = t.pivot, $ = -Math.atan2(-D, N), G = Math.atan2(r, e), U = Math.abs($ + G);\n      return U < 1e-5 || Math.abs(PI_2 - U) < 1e-5 ? (t.rotation = G, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = $, t.skew.y = G), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(D * D + N * N), t.position.x = this.tx + (k.x * e + k.y * D), t.position.y = this.ty + (k.x * r + k.y * N), t;\n    }, o.prototype.invert = function() {\n      var t = this.a, e = this.b, r = this.c, D = this.d, N = this.tx, k = t * D - e * r;\n      return this.a = D / k, this.b = -e / k, this.c = -r / k, this.d = t / k, this.tx = (r * this.ty - D * N) / k, this.ty = -(t * this.ty - e * N) / k, this;\n    }, o.prototype.identity = function() {\n      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n    }, o.prototype.clone = function() {\n      var t = new o();\n      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n    }, o.prototype.copyTo = function(t) {\n      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n    }, o.prototype.copyFrom = function(t) {\n      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n    }, Object.defineProperty(o, \"IDENTITY\", {\n      /**\n       * A default (identity) matrix\n       * @readonly\n       */\n      get: function() {\n        return new o();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"TEMP_MATRIX\", {\n      /**\n       * A temp matrix\n       * @readonly\n       */\n      get: function() {\n        return new o();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (var o = 0; o < 16; o++) {\n    var t = [];\n    rotationCayley.push(t);\n    for (var e = 0; e < 16; e++)\n      for (var r = signum(ux[o] * ux[e] + vx[o] * uy[e]), D = signum(uy[o] * ux[e] + vy[o] * uy[e]), N = signum(ux[o] * vx[e] + vx[o] * vy[e]), k = signum(uy[o] * vx[e] + vy[o] * vy[e]), $ = 0; $ < 16; $++)\n        if (ux[$] === r && uy[$] === D && vx[$] === N && vy[$] === k) {\n          t.push($);\n          break;\n        }\n  }\n  for (var o = 0; o < 16; o++) {\n    var G = new Matrix();\n    G.set(ux[o], uy[o], vx[o], vy[o], 0, 0), rotationMatrices.push(G);\n  }\n}\ninit();\nvar groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: function(o) {\n    return ux[o];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: function(o) {\n    return uy[o];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: function(o) {\n    return vx[o];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: function(o) {\n    return vy[o];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: function(o) {\n    return o & 8 ? o & 15 : -o & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {PIXI.GD8Symmetry} Composed operation\n   */\n  add: function(o, t) {\n    return rotationCayley[o][t];\n  },\n  /**\n   * Reverse of `add`.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n   * @returns {PIXI.GD8Symmetry} Result\n   */\n  sub: function(o, t) {\n    return rotationCayley[o][groupD8.inv(t)];\n  },\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof PIXI.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: function(o) {\n    return o ^ 4;\n  },\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: function(o) {\n    return (o & 3) === 2;\n  },\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof PIXI.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {PIXI.GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: function(o, t) {\n    return Math.abs(o) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(o) ? o > 0 ? groupD8.E : groupD8.W : t > 0 ? o > 0 ? groupD8.SE : groupD8.SW : o > 0 ? groupD8.NE : groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: function(o, t, e, r) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0);\n    var D = rotationMatrices[groupD8.inv(t)];\n    D.tx = e, D.ty = r, o.append(D);\n  }\n}, Transform = (\n  /** @class */\n  function() {\n    function o() {\n      this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n    }\n    return o.prototype.onChange = function() {\n      this._localID++;\n    }, o.prototype.updateSkew = function() {\n      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n    }, o.prototype.updateLocalTransform = function() {\n      var t = this.localTransform;\n      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);\n    }, o.prototype.updateTransform = function(t) {\n      var e = this.localTransform;\n      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {\n        var r = t.worldTransform, D = this.worldTransform;\n        D.a = e.a * r.a + e.b * r.c, D.b = e.a * r.b + e.b * r.d, D.c = e.c * r.a + e.d * r.c, D.d = e.c * r.b + e.d * r.d, D.tx = e.tx * r.a + e.ty * r.c + r.tx, D.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;\n      }\n    }, o.prototype.setFromMatrix = function(t) {\n      t.decompose(this), this._localID++;\n    }, Object.defineProperty(o.prototype, \"rotation\", {\n      /** The rotation of the object in radians. */\n      get: function() {\n        return this._rotation;\n      },\n      set: function(t) {\n        this._rotation !== t && (this._rotation = t, this.updateSkew());\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.IDENTITY = new o(), o;\n  }()\n);\n/*!\n * @pixi/display - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.SORTABLE_CHILDREN = !1;\nvar Bounds = (\n  /** @class */\n  function() {\n    function o() {\n      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n    }\n    return o.prototype.isEmpty = function() {\n      return this.minX > this.maxX || this.minY > this.maxY;\n    }, o.prototype.clear = function() {\n      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n    }, o.prototype.getRectangle = function(t) {\n      return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);\n    }, o.prototype.addPoint = function(t) {\n      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);\n    }, o.prototype.addPointMatrix = function(t, e) {\n      var r = t.a, D = t.b, N = t.c, k = t.d, $ = t.tx, G = t.ty, U = r * e.x + N * e.y + $, z = D * e.x + k * e.y + G;\n      this.minX = Math.min(this.minX, U), this.maxX = Math.max(this.maxX, U), this.minY = Math.min(this.minY, z), this.maxY = Math.max(this.maxY, z);\n    }, o.prototype.addQuad = function(t) {\n      var e = this.minX, r = this.minY, D = this.maxX, N = this.maxY, k = t[0], $ = t[1];\n      e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[2], $ = t[3], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[4], $ = t[5], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, k = t[6], $ = t[7], e = k < e ? k : e, r = $ < r ? $ : r, D = k > D ? k : D, N = $ > N ? $ : N, this.minX = e, this.minY = r, this.maxX = D, this.maxY = N;\n    }, o.prototype.addFrame = function(t, e, r, D, N) {\n      this.addFrameMatrix(t.worldTransform, e, r, D, N);\n    }, o.prototype.addFrameMatrix = function(t, e, r, D, N) {\n      var k = t.a, $ = t.b, G = t.c, U = t.d, z = t.tx, X = t.ty, V = this.minX, Y = this.minY, q = this.maxX, W = this.maxY, K = k * e + G * r + z, Z = $ * e + U * r + X;\n      V = K < V ? K : V, Y = Z < Y ? Z : Y, q = K > q ? K : q, W = Z > W ? Z : W, K = k * D + G * r + z, Z = $ * D + U * r + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, q = K > q ? K : q, W = Z > W ? Z : W, K = k * e + G * N + z, Z = $ * e + U * N + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, q = K > q ? K : q, W = Z > W ? Z : W, K = k * D + G * N + z, Z = $ * D + U * N + X, V = K < V ? K : V, Y = Z < Y ? Z : Y, q = K > q ? K : q, W = Z > W ? Z : W, this.minX = V, this.minY = Y, this.maxX = q, this.maxY = W;\n    }, o.prototype.addVertexData = function(t, e, r) {\n      for (var D = this.minX, N = this.minY, k = this.maxX, $ = this.maxY, G = e; G < r; G += 2) {\n        var U = t[G], z = t[G + 1];\n        D = U < D ? U : D, N = z < N ? z : N, k = U > k ? U : k, $ = z > $ ? z : $;\n      }\n      this.minX = D, this.minY = N, this.maxX = k, this.maxY = $;\n    }, o.prototype.addVertices = function(t, e, r, D) {\n      this.addVerticesMatrix(t.worldTransform, e, r, D);\n    }, o.prototype.addVerticesMatrix = function(t, e, r, D, N, k) {\n      N === void 0 && (N = 0), k === void 0 && (k = N);\n      for (var $ = t.a, G = t.b, U = t.c, z = t.d, X = t.tx, V = t.ty, Y = this.minX, q = this.minY, W = this.maxX, K = this.maxY, Z = r; Z < D; Z += 2) {\n        var J = e[Z], Q = e[Z + 1], et = $ * J + U * Q + X, nt = z * Q + G * J + V;\n        Y = Math.min(Y, et - N), W = Math.max(W, et + N), q = Math.min(q, nt - k), K = Math.max(K, nt + k);\n      }\n      this.minX = Y, this.minY = q, this.maxX = W, this.maxY = K;\n    }, o.prototype.addBounds = function(t) {\n      var e = this.minX, r = this.minY, D = this.maxX, N = this.maxY;\n      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > D ? t.maxX : D, this.maxY = t.maxY > N ? t.maxY : N;\n    }, o.prototype.addBoundsMask = function(t, e) {\n      var r = t.minX > e.minX ? t.minX : e.minX, D = t.minY > e.minY ? t.minY : e.minY, N = t.maxX < e.maxX ? t.maxX : e.maxX, k = t.maxY < e.maxY ? t.maxY : e.maxY;\n      if (r <= N && D <= k) {\n        var $ = this.minX, G = this.minY, U = this.maxX, z = this.maxY;\n        this.minX = r < $ ? r : $, this.minY = D < G ? D : G, this.maxX = N > U ? N : U, this.maxY = k > z ? k : z;\n      }\n    }, o.prototype.addBoundsMatrix = function(t, e) {\n      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);\n    }, o.prototype.addBoundsArea = function(t, e) {\n      var r = t.minX > e.x ? t.minX : e.x, D = t.minY > e.y ? t.minY : e.y, N = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, k = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;\n      if (r <= N && D <= k) {\n        var $ = this.minX, G = this.minY, U = this.maxX, z = this.maxY;\n        this.minX = r < $ ? r : $, this.minY = D < G ? D : G, this.maxX = N > U ? N : U, this.maxY = k > z ? k : z;\n      }\n    }, o.prototype.pad = function(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);\n    }, o.prototype.addFramePad = function(t, e, r, D, N, k) {\n      t -= N, e -= k, r += N, D += k, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > D ? this.maxY : D;\n    }, o;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$q = function(o, t) {\n  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$q(o, t);\n};\nfunction __extends$q(o, t) {\n  extendStatics$q(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar DisplayObject = (\n  /** @class */\n  function(o) {\n    __extends$q(t, o);\n    function t() {\n      var e = o.call(this) || this;\n      return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;\n    }\n    return t.mixin = function(e) {\n      for (var r = Object.keys(e), D = 0; D < r.length; ++D) {\n        var N = r[D];\n        Object.defineProperty(t.prototype, N, Object.getOwnPropertyDescriptor(e, N));\n      }\n    }, Object.defineProperty(t.prototype, \"destroyed\", {\n      /**\n       * Fired when this DisplayObject is added to a Container.\n       * @instance\n       * @event added\n       * @param {PIXI.Container} container - The container added to.\n       */\n      /**\n       * Fired when this DisplayObject is removed from a Container.\n       * @instance\n       * @event removed\n       * @param {PIXI.Container} container - The container removed from.\n       */\n      /**\n       * Fired when this DisplayObject is destroyed. This event is emitted once\n       * destroy is finished.\n       * @instance\n       * @event destroyed\n       */\n      /** Readonly flag for destroyed display objects. */\n      get: function() {\n        return this._destroyed;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._recursivePostUpdateTransform = function() {\n      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }, t.prototype.updateTransform = function() {\n      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }, t.prototype.getBounds = function(e, r) {\n      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Rectangle()), r = this._boundsRect), this._bounds.getRectangle(r);\n    }, t.prototype.getLocalBounds = function(e) {\n      e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());\n      var r = this.transform, D = this.parent;\n      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;\n      var N = this._bounds, k = this._boundsID;\n      this._bounds = this._localBounds;\n      var $ = this.getBounds(!1, e);\n      return this.parent = D, this.transform = r, this._bounds = N, this._bounds.updateID += this._boundsID - k, $;\n    }, t.prototype.toGlobal = function(e, r, D) {\n      return D === void 0 && (D = !1), D || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);\n    }, t.prototype.toLocal = function(e, r, D, N) {\n      return r && (e = r.toGlobal(e, D, N)), N || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, D);\n    }, t.prototype.setParent = function(e) {\n      if (!e || !e.addChild)\n        throw new Error(\"setParent: Argument must be a Container\");\n      return e.addChild(this), e;\n    }, t.prototype.setTransform = function(e, r, D, N, k, $, G, U, z) {\n      return e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 1), k === void 0 && (k = 0), $ === void 0 && ($ = 0), G === void 0 && (G = 0), U === void 0 && (U = 0), z === void 0 && (z = 0), this.position.x = e, this.position.y = r, this.scale.x = D || 1, this.scale.y = N || 1, this.rotation = k, this.skew.x = $, this.skew.y = G, this.pivot.x = U, this.pivot.y = z, this;\n    }, t.prototype.destroy = function(e) {\n      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit(\"destroyed\"), this.removeAllListeners();\n    }, Object.defineProperty(t.prototype, \"_tempDisplayObjectParent\", {\n      /**\n       * @protected\n       * @member {PIXI.Container}\n       */\n      get: function() {\n        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.enableTempParent = function() {\n      var e = this.parent;\n      return this.parent = this._tempDisplayObjectParent, e;\n    }, t.prototype.disableTempParent = function(e) {\n      this.parent = e;\n    }, Object.defineProperty(t.prototype, \"x\", {\n      /**\n       * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n       * An alias to position.x\n       */\n      get: function() {\n        return this.position.x;\n      },\n      set: function(e) {\n        this.transform.position.x = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"y\", {\n      /**\n       * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n       * An alias to position.y\n       */\n      get: function() {\n        return this.position.y;\n      },\n      set: function(e) {\n        this.transform.position.y = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"worldTransform\", {\n      /**\n       * Current transform of the object based on world (parent) factors.\n       * @readonly\n       */\n      get: function() {\n        return this.transform.worldTransform;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"localTransform\", {\n      /**\n       * Current transform of the object based on local factors: position, scale, other stuff.\n       * @readonly\n       */\n      get: function() {\n        return this.transform.localTransform;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"position\", {\n      /**\n       * The coordinate of the object relative to the local coordinates of the parent.\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.position;\n      },\n      set: function(e) {\n        this.transform.position.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"scale\", {\n      /**\n       * The scale factors of this object along the local coordinate axes.\n       *\n       * The default scale is (1, 1).\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.scale;\n      },\n      set: function(e) {\n        this.transform.scale.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"pivot\", {\n      /**\n       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n       * is the projection of `pivot` in the parent's local space.\n       *\n       * By default, the pivot is the origin (0, 0).\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.pivot;\n      },\n      set: function(e) {\n        this.transform.pivot.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"skew\", {\n      /**\n       * The skew factor for the object in radians.\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.skew;\n      },\n      set: function(e) {\n        this.transform.skew.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rotation\", {\n      /**\n       * The rotation of the object in radians.\n       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n       */\n      get: function() {\n        return this.transform.rotation;\n      },\n      set: function(e) {\n        this.transform.rotation = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"angle\", {\n      /**\n       * The angle of the object in degrees.\n       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n       */\n      get: function() {\n        return this.transform.rotation * RAD_TO_DEG;\n      },\n      set: function(e) {\n        this.transform.rotation = e * DEG_TO_RAD;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"zIndex\", {\n      /**\n       * The zIndex of the displayObject.\n       *\n       * If a container has the sortableChildren property set to true, children will be automatically\n       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n       * and thus rendered on top of other display objects within the same container.\n       * @see PIXI.Container#sortableChildren\n       */\n      get: function() {\n        return this._zIndex;\n      },\n      set: function(e) {\n        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"worldVisible\", {\n      /**\n       * Indicates if the object is globally visible.\n       * @readonly\n       */\n      get: function() {\n        var e = this;\n        do {\n          if (!e.visible)\n            return !1;\n          e = e.parent;\n        } while (e);\n        return !0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"mask\", {\n      /**\n       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n       * To remove a mask, set this property to `null`.\n       *\n       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n       * @example\n       * const graphics = new PIXI.Graphics();\n       * graphics.beginFill(0xFF3300);\n       * graphics.drawRect(50, 250, 100, 100);\n       * graphics.endFill();\n       *\n       * const sprite = new PIXI.Sprite(texture);\n       * sprite.mask = graphics;\n       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n       */\n      get: function() {\n        return this._mask;\n      },\n      set: function(e) {\n        if (this._mask !== e) {\n          if (this._mask) {\n            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n            r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));\n          }\n          if (this._mask = e, this._mask) {\n            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n            r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);\n          }\n        }\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(eventemitter3Exports)\n), TemporaryDisplayObject = (\n  /** @class */\n  function(o) {\n    __extends$q(t, o);\n    function t() {\n      var e = o !== null && o.apply(this, arguments) || this;\n      return e.sortDirty = null, e;\n    }\n    return t;\n  }(DisplayObject)\n);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\nfunction sortChildren(o, t) {\n  return o.zIndex === t.zIndex ? o._lastSortedIndex - t._lastSortedIndex : o.zIndex - t.zIndex;\n}\nvar Container = (\n  /** @class */\n  function(o) {\n    __extends$q(t, o);\n    function t() {\n      var e = o.call(this) || this;\n      return e.children = [], e.sortableChildren = settings.SORTABLE_CHILDREN, e.sortDirty = !1, e;\n    }\n    return t.prototype.onChildrenChange = function(e) {\n    }, t.prototype.addChild = function() {\n      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)\n        r[D] = e[D];\n      if (r.length > 1)\n        for (var N = 0; N < r.length; N++)\n          this.addChild(r[N]);\n      else {\n        var k = r[0];\n        k.parent && k.parent.removeChild(k), k.parent = this, this.sortDirty = !0, k.transform._parentID = -1, this.children.push(k), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit(\"childAdded\", k, this, this.children.length - 1), k.emit(\"added\", this);\n      }\n      return r[0];\n    }, t.prototype.addChildAt = function(e, r) {\n      if (r < 0 || r > this.children.length)\n        throw new Error(e + \"addChildAt: The index \" + r + \" supplied is out of bounds \" + this.children.length);\n      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit(\"added\", this), this.emit(\"childAdded\", e, this, r), e;\n    }, t.prototype.swapChildren = function(e, r) {\n      if (e !== r) {\n        var D = this.getChildIndex(e), N = this.getChildIndex(r);\n        this.children[D] = r, this.children[N] = e, this.onChildrenChange(D < N ? D : N);\n      }\n    }, t.prototype.getChildIndex = function(e) {\n      var r = this.children.indexOf(e);\n      if (r === -1)\n        throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n      return r;\n    }, t.prototype.setChildIndex = function(e, r) {\n      if (r < 0 || r >= this.children.length)\n        throw new Error(\"The index \" + r + \" supplied is out of bounds \" + this.children.length);\n      var D = this.getChildIndex(e);\n      removeItems(this.children, D, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);\n    }, t.prototype.getChildAt = function(e) {\n      if (e < 0 || e >= this.children.length)\n        throw new Error(\"getChildAt: Index (\" + e + \") does not exist.\");\n      return this.children[e];\n    }, t.prototype.removeChild = function() {\n      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)\n        r[D] = e[D];\n      if (r.length > 1)\n        for (var N = 0; N < r.length; N++)\n          this.removeChild(r[N]);\n      else {\n        var k = r[0], $ = this.children.indexOf(k);\n        if ($ === -1)\n          return null;\n        k.parent = null, k.transform._parentID = -1, removeItems(this.children, $, 1), this._boundsID++, this.onChildrenChange($), k.emit(\"removed\", this), this.emit(\"childRemoved\", k, this, $);\n      }\n      return r[0];\n    }, t.prototype.removeChildAt = function(e) {\n      var r = this.getChildAt(e);\n      return r.parent = null, r.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit(\"removed\", this), this.emit(\"childRemoved\", r, this, e), r;\n    }, t.prototype.removeChildren = function(e, r) {\n      e === void 0 && (e = 0), r === void 0 && (r = this.children.length);\n      var D = e, N = r, k = N - D, $;\n      if (k > 0 && k <= N) {\n        $ = this.children.splice(D, k);\n        for (var G = 0; G < $.length; ++G)\n          $[G].parent = null, $[G].transform && ($[G].transform._parentID = -1);\n        this._boundsID++, this.onChildrenChange(e);\n        for (var G = 0; G < $.length; ++G)\n          $[G].emit(\"removed\", this), this.emit(\"childRemoved\", $[G], this, G);\n        return $;\n      } else if (k === 0 && this.children.length === 0)\n        return [];\n      throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    }, t.prototype.sortChildren = function() {\n      for (var e = !1, r = 0, D = this.children.length; r < D; ++r) {\n        var N = this.children[r];\n        N._lastSortedIndex = r, !e && N.zIndex !== 0 && (e = !0);\n      }\n      e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;\n    }, t.prototype.updateTransform = function() {\n      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n      for (var e = 0, r = this.children.length; e < r; ++e) {\n        var D = this.children[e];\n        D.visible && D.updateTransform();\n      }\n    }, t.prototype.calculateBounds = function() {\n      this._bounds.clear(), this._calculateBounds();\n      for (var e = 0; e < this.children.length; e++) {\n        var r = this.children[e];\n        if (!(!r.visible || !r.renderable))\n          if (r.calculateBounds(), r._mask) {\n            var D = r._mask.isMaskData ? r._mask.maskObject : r._mask;\n            D ? (D.calculateBounds(), this._bounds.addBoundsMask(r._bounds, D._bounds)) : this._bounds.addBounds(r._bounds);\n          } else\n            r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);\n      }\n      this._bounds.updateID = this._boundsID;\n    }, t.prototype.getLocalBounds = function(e, r) {\n      r === void 0 && (r = !1);\n      var D = o.prototype.getLocalBounds.call(this, e);\n      if (!r)\n        for (var N = 0, k = this.children.length; N < k; ++N) {\n          var $ = this.children[N];\n          $.visible && $.updateTransform();\n        }\n      return D;\n    }, t.prototype._calculateBounds = function() {\n    }, t.prototype._renderWithCulling = function(e) {\n      var r = e.renderTexture.sourceFrame;\n      if (r.width > 0 && r.height > 0) {\n        var D, N;\n        if (this.cullArea ? (D = this.cullArea, N = this.worldTransform) : this._render !== t.prototype._render && (D = this.getBounds(!0)), D && r.intersects(D, N))\n          this._render(e);\n        else if (this.cullArea)\n          return;\n        for (var k = 0, $ = this.children.length; k < $; ++k) {\n          var G = this.children[k], U = G.cullable;\n          G.cullable = U || !this.cullArea, G.render(e), G.cullable = U;\n        }\n      }\n    }, t.prototype.render = function(e) {\n      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n        if (this._mask || this.filters && this.filters.length)\n          this.renderAdvanced(e);\n        else if (this.cullable)\n          this._renderWithCulling(e);\n        else {\n          this._render(e);\n          for (var r = 0, D = this.children.length; r < D; ++r)\n            this.children[r].render(e);\n        }\n    }, t.prototype.renderAdvanced = function(e) {\n      var r = this.filters, D = this._mask;\n      if (r) {\n        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n        for (var N = 0; N < r.length; N++)\n          r[N].enabled && this._enabledFilters.push(r[N]);\n      }\n      var k = r && this._enabledFilters && this._enabledFilters.length || D && (!D.isMaskData || D.enabled && (D.autoDetect || D.type !== MASK_TYPES.NONE));\n      if (k && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), D && e.mask.push(this, this._mask), this.cullable)\n        this._renderWithCulling(e);\n      else {\n        this._render(e);\n        for (var N = 0, $ = this.children.length; N < $; ++N)\n          this.children[N].render(e);\n      }\n      k && e.batch.flush(), D && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();\n    }, t.prototype._render = function(e) {\n    }, t.prototype.destroy = function(e) {\n      o.prototype.destroy.call(this), this.sortDirty = !1;\n      var r = typeof e == \"boolean\" ? e : e && e.children, D = this.removeChildren(0, this.children.length);\n      if (r)\n        for (var N = 0; N < D.length; ++N)\n          D[N].destroy(e);\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.scale.x * this.getLocalBounds().width;\n      },\n      set: function(e) {\n        var r = this.getLocalBounds().width;\n        r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.scale.y * this.getLocalBounds().height;\n      },\n      set: function(e) {\n        var r = this.getLocalBounds().height;\n        r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(DisplayObject)\n);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n/*!\n * @pixi/extensions - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/extensions is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$8 = function() {\n  return __assign$8 = Object.assign || function(t) {\n    for (var e = arguments, r, D = 1, N = arguments.length; D < N; D++) {\n      r = e[D];\n      for (var k in r)\n        Object.prototype.hasOwnProperty.call(r, k) && (t[k] = r[k]);\n    }\n    return t;\n  }, __assign$8.apply(this, arguments);\n}, ExtensionType;\n(function(o) {\n  o.Application = \"application\", o.RendererPlugin = \"renderer-webgl-plugin\", o.CanvasRendererPlugin = \"renderer-canvas-plugin\", o.Loader = \"loader\", o.LoadParser = \"load-parser\", o.ResolveParser = \"resolve-parser\", o.CacheParser = \"cache-parser\", o.DetectionParser = \"detection-parser\";\n})(ExtensionType || (ExtensionType = {}));\nvar normalizeExtension = function(o) {\n  if (typeof o == \"function\" || typeof o == \"object\" && o.extension) {\n    if (!o.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    var t = typeof o.extension != \"object\" ? { type: o.extension } : o.extension;\n    o = __assign$8(__assign$8({}, t), { ref: o });\n  }\n  if (typeof o == \"object\")\n    o = __assign$8({}, o);\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof o.type == \"string\" && (o.type = [o.type]), o;\n}, extensions = {\n  /** @ignore */\n  _addHandlers: null,\n  /** @ignore */\n  _removeHandlers: null,\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  remove: function() {\n    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = o[r];\n    return e.map(normalizeExtension).forEach(function(D) {\n      D.type.forEach(function(N) {\n        var k, $;\n        return ($ = (k = t._removeHandlers)[N]) === null || $ === void 0 ? void 0 : $.call(k, D);\n      });\n    }), this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  add: function() {\n    for (var o = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = o[r];\n    return e.map(normalizeExtension).forEach(function(D) {\n      D.type.forEach(function(N) {\n        var k = t._addHandlers, $ = t._queue;\n        k[N] ? k[N](D) : ($[N] = $[N] || [], $[N].push(D));\n      });\n    }), this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.\n   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handle: function(o, t, e) {\n    var r = this._addHandlers = this._addHandlers || {}, D = this._removeHandlers = this._removeHandlers || {};\n    if (r[o] || D[o])\n      throw new Error(\"Extension type \" + o + \" already has a handler\");\n    r[o] = t, D[o] = e;\n    var N = this._queue;\n    return N[o] && (N[o].forEach(function(k) {\n      return t(k);\n    }), delete N[o]), this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByMap: function(o, t) {\n    return this.handle(o, function(e) {\n      t[e.name] = e.ref;\n    }, function(e) {\n      delete t[e.name];\n    });\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByList: function(o, t) {\n    return this.handle(o, function(e) {\n      var r, D;\n      t.includes(e.ref) || (t.push(e.ref), o === ExtensionType.Loader && ((D = (r = e.ref).add) === null || D === void 0 || D.call(r)));\n    }, function(e) {\n      var r = t.indexOf(e.ref);\n      r !== -1 && t.splice(r, 1);\n    });\n  }\n};\n/*!\n * @pixi/runner - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/runner is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Runner = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.items = [], this._name = t, this._aliasCount = 0;\n    }\n    return o.prototype.emit = function(t, e, r, D, N, k, $, G) {\n      if (arguments.length > 8)\n        throw new Error(\"max arguments reached\");\n      var U = this, z = U.name, X = U.items;\n      this._aliasCount++;\n      for (var V = 0, Y = X.length; V < Y; V++)\n        X[V][z](t, e, r, D, N, k, $, G);\n      return X === this.items && this._aliasCount--, this;\n    }, o.prototype.ensureNonAliasedItems = function() {\n      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n    }, o.prototype.add = function(t) {\n      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;\n    }, o.prototype.remove = function(t) {\n      var e = this.items.indexOf(t);\n      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;\n    }, o.prototype.contains = function(t) {\n      return this.items.indexOf(t) !== -1;\n    }, o.prototype.removeAll = function() {\n      return this.ensureNonAliasedItems(), this.items.length = 0, this;\n    }, o.prototype.destroy = function() {\n      this.removeAll(), this.items = null, this._name = null;\n    }, Object.defineProperty(o.prototype, \"empty\", {\n      /**\n       * `true` if there are no this Runner contains no listeners\n       * @readonly\n       */\n      get: function() {\n        return this.items.length === 0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"name\", {\n      /**\n       * The name of the runner.\n       * @readonly\n       */\n      get: function() {\n        return this._name;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n);\nObject.defineProperties(Runner.prototype, {\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method dispatch\n   * @see PIXI.Runner#emit\n   */\n  dispatch: { value: Runner.prototype.emit },\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method run\n   * @see PIXI.Runner#emit\n   */\n  run: { value: Runner.prototype.emit }\n});\n/*!\n * @pixi/ticker - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/ticker is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.TARGET_FPMS = 0.06;\nvar UPDATE_PRIORITY;\n(function(o) {\n  o[o.INTERACTION = 50] = \"INTERACTION\", o[o.HIGH = 25] = \"HIGH\", o[o.NORMAL = 0] = \"NORMAL\", o[o.LOW = -25] = \"LOW\", o[o.UTILITY = -50] = \"UTILITY\";\n})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));\nvar TickerListener = (\n  /** @class */\n  function() {\n    function o(t, e, r, D) {\n      e === void 0 && (e = null), r === void 0 && (r = 0), D === void 0 && (D = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = D;\n    }\n    return o.prototype.match = function(t, e) {\n      return e === void 0 && (e = null), this.fn === t && this.context === e;\n    }, o.prototype.emit = function(t) {\n      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));\n      var e = this.next;\n      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;\n    }, o.prototype.connect = function(t) {\n      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;\n    }, o.prototype.destroy = function(t) {\n      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n      var e = this.next;\n      return this.next = t ? null : e, this.previous = null, e;\n    }, o;\n  }()\n), Ticker = (\n  /** @class */\n  function() {\n    function o() {\n      var t = this;\n      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings.TARGET_FPMS, this.elapsedMS = 1 / settings.TARGET_FPMS, this._tick = function(e) {\n        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));\n      };\n    }\n    return o.prototype._requestIfNeeded = function() {\n      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n    }, o.prototype._cancelIfNeeded = function() {\n      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n    }, o.prototype._startIfPossible = function() {\n      this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n    }, o.prototype.add = function(t, e, r) {\n      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r));\n    }, o.prototype.addOnce = function(t, e, r) {\n      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, r, !0));\n    }, o.prototype._addListener = function(t) {\n      var e = this._head.next, r = this._head;\n      if (!e)\n        t.connect(r);\n      else {\n        for (; e; ) {\n          if (t.priority > e.priority) {\n            t.connect(r);\n            break;\n          }\n          r = e, e = e.next;\n        }\n        t.previous || t.connect(r);\n      }\n      return this._startIfPossible(), this;\n    }, o.prototype.remove = function(t, e) {\n      for (var r = this._head.next; r; )\n        r.match(t, e) ? r = r.destroy() : r = r.next;\n      return this._head.next || this._cancelIfNeeded(), this;\n    }, Object.defineProperty(o.prototype, \"count\", {\n      /**\n       * The number of listeners on this ticker, calculated by walking through linked list\n       * @readonly\n       * @member {number}\n       */\n      get: function() {\n        if (!this._head)\n          return 0;\n        for (var t = 0, e = this._head; e = e.next; )\n          t++;\n        return t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.start = function() {\n      this.started || (this.started = !0, this._requestIfNeeded());\n    }, o.prototype.stop = function() {\n      this.started && (this.started = !1, this._cancelIfNeeded());\n    }, o.prototype.destroy = function() {\n      if (!this._protected) {\n        this.stop();\n        for (var t = this._head.next; t; )\n          t = t.destroy(!0);\n        this._head.destroy(), this._head = null;\n      }\n    }, o.prototype.update = function(t) {\n      t === void 0 && (t = performance.now());\n      var e;\n      if (t > this.lastTime) {\n        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {\n          var r = t - this._lastFrame | 0;\n          if (r < this._minElapsedMS)\n            return;\n          this._lastFrame = t - r % this._minElapsedMS;\n        }\n        this.deltaMS = e, this.deltaTime = this.deltaMS * settings.TARGET_FPMS;\n        for (var D = this._head, N = D.next; N; )\n          N = N.emit(this.deltaTime);\n        D.next || this._cancelIfNeeded();\n      } else\n        this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n      this.lastTime = t;\n    }, Object.defineProperty(o.prototype, \"FPS\", {\n      /**\n       * The frames per second at which this ticker is running.\n       * The default is approximately 60 in most modern browsers.\n       * **Note:** This does not factor in the value of\n       * {@link PIXI.Ticker#speed}, which is specific\n       * to scaling {@link PIXI.Ticker#deltaTime}.\n       * @member {number}\n       * @readonly\n       */\n      get: function() {\n        return 1e3 / this.elapsedMS;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"minFPS\", {\n      /**\n       * Manages the maximum amount of milliseconds allowed to\n       * elapse between invoking {@link PIXI.Ticker#update}.\n       * This value is used to cap {@link PIXI.Ticker#deltaTime},\n       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n       * When setting this property it is clamped to a value between\n       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n       * @member {number}\n       * @default 10\n       */\n      get: function() {\n        return 1e3 / this._maxElapsedMS;\n      },\n      set: function(t) {\n        var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, settings.TARGET_FPMS);\n        this._maxElapsedMS = 1 / r;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"maxFPS\", {\n      /**\n       * Manages the minimum amount of milliseconds required to\n       * elapse between invoking {@link PIXI.Ticker#update}.\n       * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n       * Otherwise it will be at least `minFPS`\n       * @member {number}\n       * @default 0\n       */\n      get: function() {\n        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n      },\n      set: function(t) {\n        if (t === 0)\n          this._minElapsedMS = 0;\n        else {\n          var e = Math.max(this.minFPS, t);\n          this._minElapsedMS = 1 / (e / 1e3);\n        }\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"shared\", {\n      /**\n       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n       * {@link PIXI.VideoResource} to update animation frames / video textures.\n       *\n       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n       *\n       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n       * @example\n       * let ticker = PIXI.Ticker.shared;\n       * // Set this to prevent starting this ticker when listeners are added.\n       * // By default this is true only for the PIXI.Ticker.shared instance.\n       * ticker.autoStart = false;\n       * // FYI, call this to ensure the ticker is stopped. It should be stopped\n       * // if you have not attempted to render anything yet.\n       * ticker.stop();\n       * // Call this when you are ready for a running shared ticker.\n       * ticker.start();\n       * @example\n       * // You may use the shared ticker to render...\n       * let renderer = PIXI.autoDetectRenderer();\n       * let stage = new PIXI.Container();\n       * document.body.appendChild(renderer.view);\n       * ticker.add(function (time) {\n       *     renderer.render(stage);\n       * });\n       * @example\n       * // Or you can just update it manually.\n       * ticker.autoStart = false;\n       * ticker.stop();\n       * function animate(time) {\n       *     ticker.update(time);\n       *     renderer.render(stage);\n       *     requestAnimationFrame(animate);\n       * }\n       * animate(performance.now());\n       * @member {PIXI.Ticker}\n       * @static\n       */\n      get: function() {\n        if (!o._shared) {\n          var t = o._shared = new o();\n          t.autoStart = !0, t._protected = !0;\n        }\n        return o._shared;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"system\", {\n      /**\n       * The system ticker instance used by {@link PIXI.InteractionManager} and by\n       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,\n       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.\n       *\n       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n       * @member {PIXI.Ticker}\n       * @static\n       */\n      get: function() {\n        if (!o._system) {\n          var t = o._system = new o();\n          t.autoStart = !0, t._protected = !0;\n        }\n        return o._system;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n), TickerPlugin = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.init = function(t) {\n      var e = this;\n      t = Object.assign({\n        autoStart: !0,\n        sharedTicker: !1\n      }, t), Object.defineProperty(this, \"ticker\", {\n        set: function(r) {\n          this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, UPDATE_PRIORITY.LOW);\n        },\n        get: function() {\n          return this._ticker;\n        }\n      }), this.stop = function() {\n        e._ticker.stop();\n      }, this.start = function() {\n        e._ticker.start();\n      }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();\n    }, o.destroy = function() {\n      if (this._ticker) {\n        var t = this._ticker;\n        this.ticker = null, t.destroy();\n      }\n    }, o.extension = ExtensionType.Application, o;\n  }()\n);\n/*!\n * @pixi/core - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/core is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;\nsettings.STRICT_TEXTURE_CACHE = !1;\nvar INSTALLED = [];\nfunction autoDetectResource(o, t) {\n  if (!o)\n    return null;\n  var e = \"\";\n  if (typeof o == \"string\") {\n    var r = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(o);\n    r && (e = r[1].toLowerCase());\n  }\n  for (var D = INSTALLED.length - 1; D >= 0; --D) {\n    var N = INSTALLED[D];\n    if (N.test && N.test(o, e))\n      return new N(o, t);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$p = function(o, t) {\n  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$p(o, t);\n};\nfunction __extends$p(o, t) {\n  extendStatics$p(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$7 = function() {\n  return __assign$7 = Object.assign || function(t) {\n    for (var e = arguments, r, D = 1, N = arguments.length; D < N; D++) {\n      r = e[D];\n      for (var k in r)\n        Object.prototype.hasOwnProperty.call(r, k) && (t[k] = r[k]);\n    }\n    return t;\n  }, __assign$7.apply(this, arguments);\n};\nfunction __rest$3(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)\n      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);\n  return e;\n}\nvar Resource = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner(\"setRealSize\"), this.onUpdate = new Runner(\"update\"), this.onError = new Runner(\"onError\");\n    }\n    return o.prototype.bind = function(t) {\n      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n    }, o.prototype.unbind = function(t) {\n      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);\n    }, o.prototype.resize = function(t, e) {\n      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));\n    }, Object.defineProperty(o.prototype, \"valid\", {\n      /**\n       * Has been validated\n       * @readonly\n       */\n      get: function() {\n        return !!this._width && !!this._height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.update = function() {\n      this.destroyed || this.onUpdate.emit();\n    }, o.prototype.load = function() {\n      return Promise.resolve(this);\n    }, Object.defineProperty(o.prototype, \"width\", {\n      /**\n       * The width of the resource.\n       * @readonly\n       */\n      get: function() {\n        return this._width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"height\", {\n      /**\n       * The height of the resource.\n       * @readonly\n       */\n      get: function() {\n        return this._height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.style = function(t, e, r) {\n      return !1;\n    }, o.prototype.dispose = function() {\n    }, o.prototype.destroy = function() {\n      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n    }, o.test = function(t, e) {\n      return !1;\n    }, o;\n  }()\n), BufferResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this, N = r || {}, k = N.width, $ = N.height;\n      if (!k || !$)\n        throw new Error(\"BufferResource width or height invalid\");\n      return D = o.call(this, k, $) || this, D.data = e, D;\n    }\n    return t.prototype.upload = function(e, r, D) {\n      var N = e.gl;\n      N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);\n      var k = r.realWidth, $ = r.realHeight;\n      return D.width === k && D.height === $ ? N.texSubImage2D(r.target, 0, 0, 0, k, $, r.format, D.type, this.data) : (D.width = k, D.height = $, N.texImage2D(r.target, 0, D.internalFormat, k, $, 0, r.format, D.type, this.data)), !0;\n    }, t.prototype.dispose = function() {\n      this.data = null;\n    }, t.test = function(e) {\n      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;\n    }, t;\n  }(Resource)\n), defaultBufferOptions = {\n  scaleMode: SCALE_MODES.NEAREST,\n  format: FORMATS.RGBA,\n  alphaMode: ALPHA_MODES.NPM\n}, BaseTexture = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      e === void 0 && (e = null), r === void 0 && (r = null);\n      var D = o.call(this) || this;\n      r = r || {};\n      var N = r.alphaMode, k = r.mipmap, $ = r.anisotropicLevel, G = r.scaleMode, U = r.width, z = r.height, X = r.wrapMode, V = r.format, Y = r.type, q = r.target, W = r.resolution, K = r.resourceOptions;\n      return e && !(e instanceof Resource) && (e = autoDetectResource(e, K), e.internal = !0), D.resolution = W || settings.RESOLUTION, D.width = Math.round((U || 0) * D.resolution) / D.resolution, D.height = Math.round((z || 0) * D.resolution) / D.resolution, D._mipmap = k !== void 0 ? k : settings.MIPMAP_TEXTURES, D.anisotropicLevel = $ !== void 0 ? $ : settings.ANISOTROPIC_LEVEL, D._wrapMode = X || settings.WRAP_MODE, D._scaleMode = G !== void 0 ? G : settings.SCALE_MODE, D.format = V || FORMATS.RGBA, D.type = Y || TYPES.UNSIGNED_BYTE, D.target = q || TARGETS.TEXTURE_2D, D.alphaMode = N !== void 0 ? N : ALPHA_MODES.UNPACK, D.uid = uid(), D.touched = 0, D.isPowerOfTwo = !1, D._refreshPOT(), D._glTextures = {}, D.dirtyId = 0, D.dirtyStyleId = 0, D.cacheId = null, D.valid = U > 0 && z > 0, D.textureCacheIds = [], D.destroyed = !1, D.resource = null, D._batchEnabled = 0, D._batchLocation = 0, D.parentTextureArray = null, D.setResource(e), D;\n    }\n    return Object.defineProperty(t.prototype, \"realWidth\", {\n      /**\n       * Pixel width of the source of this texture\n       * @readonly\n       */\n      get: function() {\n        return Math.round(this.width * this.resolution);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"realHeight\", {\n      /**\n       * Pixel height of the source of this texture\n       * @readonly\n       */\n      get: function() {\n        return Math.round(this.height * this.resolution);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"mipmap\", {\n      /**\n       * Mipmap mode of the texture, affects downscaled images\n       * @default PIXI.settings.MIPMAP_TEXTURES\n       */\n      get: function() {\n        return this._mipmap;\n      },\n      set: function(e) {\n        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"scaleMode\", {\n      /**\n       * The scale mode to apply when scaling this texture\n       * @default PIXI.settings.SCALE_MODE\n       */\n      get: function() {\n        return this._scaleMode;\n      },\n      set: function(e) {\n        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"wrapMode\", {\n      /**\n       * How the texture wraps\n       * @default PIXI.settings.WRAP_MODE\n       */\n      get: function() {\n        return this._wrapMode;\n      },\n      set: function(e) {\n        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.setStyle = function(e, r) {\n      var D;\n      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, D = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, D = !0), D && this.dirtyStyleId++, this;\n    }, t.prototype.setSize = function(e, r, D) {\n      return D = D || this.resolution, this.setRealSize(e * D, r * D, D);\n    }, t.prototype.setRealSize = function(e, r, D) {\n      return this.resolution = D || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;\n    }, t.prototype._refreshPOT = function() {\n      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n    }, t.prototype.setResolution = function(e) {\n      var r = this.resolution;\n      return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit(\"update\", this)), this._refreshPOT(), this);\n    }, t.prototype.setResource = function(e) {\n      if (this.resource === e)\n        return this;\n      if (this.resource)\n        throw new Error(\"Resource can be set only once\");\n      return e.bind(this), this.resource = e, this;\n    }, t.prototype.update = function() {\n      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n    }, t.prototype.onError = function(e) {\n      this.emit(\"error\", this, e);\n    }, t.prototype.destroy = function() {\n      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;\n    }, t.prototype.dispose = function() {\n      this.emit(\"dispose\", this);\n    }, t.prototype.castToBaseTexture = function() {\n      return this;\n    }, t.from = function(e, r, D) {\n      D === void 0 && (D = settings.STRICT_TEXTURE_CACHE);\n      var N = typeof e == \"string\", k = null;\n      if (N)\n        k = e;\n      else {\n        if (!e._pixiId) {\n          var $ = r && r.pixiIdPrefix || \"pixiid\";\n          e._pixiId = $ + \"_\" + uid();\n        }\n        k = e._pixiId;\n      }\n      var G = BaseTextureCache[k];\n      if (N && D && !G)\n        throw new Error('The cacheId \"' + k + '\" does not exist in BaseTextureCache.');\n      return G || (G = new t(e, r), G.cacheId = k, t.addToCache(G, k)), G;\n    }, t.fromBuffer = function(e, r, D, N) {\n      e = e || new Float32Array(r * D * 4);\n      var k = new BufferResource(e, { width: r, height: D }), $ = e instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;\n      return new t(k, Object.assign({}, defaultBufferOptions, N || { width: r, height: D, type: $ }));\n    }, t.addToCache = function(e, r) {\n      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), BaseTextureCache[r] && console.warn(\"BaseTexture added to the cache with an id [\" + r + \"] that already had an entry\"), BaseTextureCache[r] = e);\n    }, t.removeFromCache = function(e) {\n      if (typeof e == \"string\") {\n        var r = BaseTextureCache[e];\n        if (r) {\n          var D = r.textureCacheIds.indexOf(e);\n          return D > -1 && r.textureCacheIds.splice(D, 1), delete BaseTextureCache[e], r;\n        }\n      } else if (e && e.textureCacheIds) {\n        for (var N = 0; N < e.textureCacheIds.length; ++N)\n          delete BaseTextureCache[e.textureCacheIds[N]];\n        return e.textureCacheIds.length = 0, e;\n      }\n      return null;\n    }, t._globalBatch = 0, t;\n  }(eventemitter3Exports)\n), AbstractMultiResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this, N = r || {}, k = N.width, $ = N.height;\n      D = o.call(this, k, $) || this, D.items = [], D.itemDirtyIds = [];\n      for (var G = 0; G < e; G++) {\n        var U = new BaseTexture();\n        D.items.push(U), D.itemDirtyIds.push(-2);\n      }\n      return D.length = e, D._load = null, D.baseTexture = null, D;\n    }\n    return t.prototype.initFromArray = function(e, r) {\n      for (var D = 0; D < this.length; D++)\n        e[D] && (e[D].castToBaseTexture ? this.addBaseTextureAt(e[D].castToBaseTexture(), D) : e[D] instanceof Resource ? this.addResourceAt(e[D], D) : this.addResourceAt(autoDetectResource(e[D], r), D));\n    }, t.prototype.dispose = function() {\n      for (var e = 0, r = this.length; e < r; e++)\n        this.items[e].destroy();\n      this.items = null, this.itemDirtyIds = null, this._load = null;\n    }, t.prototype.addResourceAt = function(e, r) {\n      if (!this.items[r])\n        throw new Error(\"Index \" + r + \" is out of bounds\");\n      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;\n    }, t.prototype.bind = function(e) {\n      if (this.baseTexture !== null)\n        throw new Error(\"Only one base texture per TextureArray is allowed\");\n      o.prototype.bind.call(this, e);\n      for (var r = 0; r < this.length; r++)\n        this.items[r].parentTextureArray = e, this.items[r].on(\"update\", e.update, e);\n    }, t.prototype.unbind = function(e) {\n      o.prototype.unbind.call(this, e);\n      for (var r = 0; r < this.length; r++)\n        this.items[r].parentTextureArray = null, this.items[r].off(\"update\", e.update, e);\n    }, t.prototype.load = function() {\n      var e = this;\n      if (this._load)\n        return this._load;\n      var r = this.items.map(function(N) {\n        return N.resource;\n      }).filter(function(N) {\n        return N;\n      }), D = r.map(function(N) {\n        return N.load();\n      });\n      return this._load = Promise.all(D).then(function() {\n        var N = e.items[0], k = N.realWidth, $ = N.realHeight;\n        return e.resize(k, $), Promise.resolve(e);\n      }), this._load;\n    }, t;\n  }(Resource)\n), ArrayResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this, N = r || {}, k = N.width, $ = N.height, G, U;\n      return Array.isArray(e) ? (G = e, U = e.length) : U = e, D = o.call(this, U, { width: k, height: $ }) || this, G && D.initFromArray(G, r), D;\n    }\n    return t.prototype.addBaseTextureAt = function(e, r) {\n      if (e.resource)\n        this.addResourceAt(e.resource, r);\n      else\n        throw new Error(\"ArrayResource does not support RenderTexture\");\n      return this;\n    }, t.prototype.bind = function(e) {\n      o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_2D_ARRAY;\n    }, t.prototype.upload = function(e, r, D) {\n      var N = this, k = N.length, $ = N.itemDirtyIds, G = N.items, U = e.gl;\n      D.dirtyId < 0 && U.texImage3D(U.TEXTURE_2D_ARRAY, 0, D.internalFormat, this._width, this._height, k, 0, r.format, D.type, null);\n      for (var z = 0; z < k; z++) {\n        var X = G[z];\n        $[z] < X.dirtyId && ($[z] = X.dirtyId, X.valid && U.texSubImage3D(\n          U.TEXTURE_2D_ARRAY,\n          0,\n          0,\n          // xoffset\n          0,\n          // yoffset\n          z,\n          // zoffset\n          X.resource.width,\n          X.resource.height,\n          1,\n          r.format,\n          D.type,\n          X.resource.source\n        ));\n      }\n      return !0;\n    }, t;\n  }(AbstractMultiResource)\n), BaseImageResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      var r = this, D = e, N = D.naturalWidth || D.videoWidth || D.width, k = D.naturalHeight || D.videoHeight || D.height;\n      return r = o.call(this, N, k) || this, r.source = e, r.noSubImage = !1, r;\n    }\n    return t.crossOrigin = function(e, r, D) {\n      D === void 0 && r.indexOf(\"data:\") !== 0 ? e.crossOrigin = determineCrossOrigin(r) : D !== !1 && (e.crossOrigin = typeof D == \"string\" ? D : \"anonymous\");\n    }, t.prototype.upload = function(e, r, D, N) {\n      var k = e.gl, $ = r.realWidth, G = r.realHeight;\n      if (N = N || this.source, N instanceof HTMLImageElement) {\n        if (!N.complete || N.naturalWidth === 0)\n          return !1;\n      } else if (N instanceof HTMLVideoElement && N.readyState <= 1)\n        return !1;\n      return k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && r.target === k.TEXTURE_2D && D.width === $ && D.height === G ? k.texSubImage2D(k.TEXTURE_2D, 0, 0, 0, r.format, D.type, N) : (D.width = $, D.height = G, k.texImage2D(r.target, 0, D.internalFormat, r.format, D.type, N)), !0;\n    }, t.prototype.update = function() {\n      if (!this.destroyed) {\n        var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, D = e.naturalHeight || e.videoHeight || e.height;\n        this.resize(r, D), o.prototype.update.call(this);\n      }\n    }, t.prototype.dispose = function() {\n      this.source = null;\n    }, t;\n  }(Resource)\n), CanvasResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      return o.call(this, e) || this;\n    }\n    return t.test = function(e) {\n      var r = globalThis.OffscreenCanvas;\n      return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;\n    }, t;\n  }(BaseImageResource)\n), CubeResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this, N = r || {}, k = N.width, $ = N.height, G = N.autoLoad, U = N.linkBaseTexture;\n      if (e && e.length !== t.SIDES)\n        throw new Error(\"Invalid length. Got \" + e.length + \", expected 6\");\n      D = o.call(this, 6, { width: k, height: $ }) || this;\n      for (var z = 0; z < t.SIDES; z++)\n        D.items[z].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + z;\n      return D.linkBaseTexture = U !== !1, e && D.initFromArray(e, r), G !== !1 && D.load(), D;\n    }\n    return t.prototype.bind = function(e) {\n      o.prototype.bind.call(this, e), e.target = TARGETS.TEXTURE_CUBE_MAP;\n    }, t.prototype.addBaseTextureAt = function(e, r, D) {\n      if (!this.items[r])\n        throw new Error(\"Index \" + r + \" is out of bounds\");\n      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)\n        if (e.resource)\n          this.addResourceAt(e.resource, r);\n        else\n          throw new Error(\"CubeResource does not support copying of renderTexture.\");\n      else\n        e.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;\n      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;\n    }, t.prototype.upload = function(e, r, D) {\n      for (var N = this.itemDirtyIds, k = 0; k < t.SIDES; k++) {\n        var $ = this.items[k];\n        (N[k] < $.dirtyId || D.dirtyId < r.dirtyId) && ($.valid && $.resource ? ($.resource.upload(e, $, D), N[k] = $.dirtyId) : N[k] < -1 && (e.gl.texImage2D($.target, 0, D.internalFormat, r.realWidth, r.realHeight, 0, r.format, D.type, null), N[k] = -1));\n      }\n      return !0;\n    }, t.test = function(e) {\n      return Array.isArray(e) && e.length === t.SIDES;\n    }, t.SIDES = 6, t;\n  }(AbstractMultiResource)\n), ImageResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this;\n      if (r = r || {}, !(e instanceof HTMLImageElement)) {\n        var N = new Image();\n        BaseImageResource.crossOrigin(N, e, r.crossorigin), N.src = e, e = N;\n      }\n      return D = o.call(this, e) || this, !e.complete && D._width && D._height && (D._width = 0, D._height = 0), D.url = e.src, D._process = null, D.preserveBitmap = !1, D.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, D.alphaMode = typeof r.alphaMode == \"number\" ? r.alphaMode : null, D.bitmap = null, D._load = null, r.autoLoad !== !1 && D.load(), D;\n    }\n    return t.prototype.load = function(e) {\n      var r = this;\n      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(D, N) {\n        var k = r.source;\n        r.url = k.src;\n        var $ = function() {\n          r.destroyed || (k.onload = null, k.onerror = null, r.resize(k.width, k.height), r._load = null, r.createBitmap ? D(r.process()) : D(r));\n        };\n        k.complete && k.src ? $() : (k.onload = $, k.onerror = function(G) {\n          N(G), r.onError.emit(G);\n        });\n      }), this._load);\n    }, t.prototype.process = function() {\n      var e = this, r = this.source;\n      if (this._process !== null)\n        return this._process;\n      if (this.bitmap !== null || !globalThis.createImageBitmap)\n        return Promise.resolve(this);\n      var D = globalThis.createImageBitmap, N = !r.crossOrigin || r.crossOrigin === \"anonymous\";\n      return this._process = fetch(r.src, {\n        mode: N ? \"cors\" : \"no-cors\"\n      }).then(function(k) {\n        return k.blob();\n      }).then(function(k) {\n        return D(k, 0, 0, r.width, r.height, {\n          premultiplyAlpha: e.alphaMode === null || e.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n        });\n      }).then(function(k) {\n        return e.destroyed ? Promise.reject() : (e.bitmap = k, e.update(), e._process = null, Promise.resolve(e));\n      }), this._process;\n    }, t.prototype.upload = function(e, r, D) {\n      if (typeof this.alphaMode == \"number\" && (r.alphaMode = this.alphaMode), !this.createBitmap)\n        return o.prototype.upload.call(this, e, r, D);\n      if (!this.bitmap && (this.process(), !this.bitmap))\n        return !1;\n      if (o.prototype.upload.call(this, e, r, D, this.bitmap), !this.preserveBitmap) {\n        var N = !0, k = r._glTextures;\n        for (var $ in k) {\n          var G = k[$];\n          if (G !== D && G.dirtyId !== r.dirtyId) {\n            N = !1;\n            break;\n          }\n        }\n        N && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n      }\n      return !0;\n    }, t.prototype.dispose = function() {\n      this.source.onload = null, this.source.onerror = null, o.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n    }, t.test = function(e) {\n      return typeof e == \"string\" || e instanceof HTMLImageElement;\n    }, t;\n  }(BaseImageResource)\n), SVGResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this;\n      return r = r || {}, D = o.call(this, settings.ADAPTER.createCanvas()) || this, D._width = 0, D._height = 0, D.svg = e, D.scale = r.scale || 1, D._overrideWidth = r.width, D._overrideHeight = r.height, D._resolve = null, D._crossorigin = r.crossorigin, D._load = null, r.autoLoad !== !1 && D.load(), D;\n    }\n    return t.prototype.load = function() {\n      var e = this;\n      return this._load ? this._load : (this._load = new Promise(function(r) {\n        if (e._resolve = function() {\n          e.resize(e.source.width, e.source.height), r(e);\n        }, t.SVG_XML.test(e.svg.trim())) {\n          if (!btoa)\n            throw new Error(\"Your browser doesn't support base64 conversions.\");\n          e.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(e.svg)));\n        }\n        e._loadSvg();\n      }), this._load);\n    }, t.prototype._loadSvg = function() {\n      var e = this, r = new Image();\n      BaseImageResource.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(D) {\n        e._resolve && (r.onerror = null, e.onError.emit(D));\n      }, r.onload = function() {\n        if (e._resolve) {\n          var D = r.width, N = r.height;\n          if (!D || !N)\n            throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n          var k = D * e.scale, $ = N * e.scale;\n          (e._overrideWidth || e._overrideHeight) && (k = e._overrideWidth || e._overrideHeight / N * D, $ = e._overrideHeight || e._overrideWidth / D * N), k = Math.round(k), $ = Math.round($);\n          var G = e.source;\n          G.width = k, G.height = $, G._pixiId = \"canvas_\" + uid(), G.getContext(\"2d\").drawImage(r, 0, 0, D, N, 0, 0, k, $), e._resolve(), e._resolve = null;\n        }\n      };\n    }, t.getSize = function(e) {\n      var r = t.SVG_SIZE.exec(e), D = {};\n      return r && (D[r[1]] = Math.round(parseFloat(r[3])), D[r[5]] = Math.round(parseFloat(r[7]))), D;\n    }, t.prototype.dispose = function() {\n      o.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;\n    }, t.test = function(e, r) {\n      return r === \"svg\" || typeof e == \"string\" && e.startsWith(\"data:image/svg+xml\") || typeof e == \"string\" && t.SVG_XML.test(e);\n    }, t.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i, t;\n  }(BaseImageResource)\n), VideoResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = this;\n      if (r = r || {}, !(e instanceof HTMLVideoElement)) {\n        var N = document.createElement(\"video\");\n        N.setAttribute(\"preload\", \"auto\"), N.setAttribute(\"webkit-playsinline\", \"\"), N.setAttribute(\"playsinline\", \"\"), typeof e == \"string\" && (e = [e]);\n        var k = e[0].src || e[0];\n        BaseImageResource.crossOrigin(N, k, r.crossorigin);\n        for (var $ = 0; $ < e.length; ++$) {\n          var G = document.createElement(\"source\"), U = e[$], z = U.src, X = U.mime;\n          z = z || e[$];\n          var V = z.split(\"?\").shift().toLowerCase(), Y = V.slice(V.lastIndexOf(\".\") + 1);\n          X = X || t.MIME_TYPES[Y] || \"video/\" + Y, G.src = z, G.type = X, N.appendChild(G);\n        }\n        e = N;\n      }\n      return D = o.call(this, e) || this, D.noSubImage = !0, D._autoUpdate = !0, D._isConnectedToTicker = !1, D._updateFPS = r.updateFPS || 0, D._msToNextUpdate = 0, D.autoPlay = r.autoPlay !== !1, D._load = null, D._resolve = null, D._onCanPlay = D._onCanPlay.bind(D), D._onError = D._onError.bind(D), r.autoLoad !== !1 && D.load(), D;\n    }\n    return t.prototype.update = function(e) {\n      if (!this.destroyed) {\n        var r = Ticker.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (o.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n      }\n    }, t.prototype.load = function() {\n      var e = this;\n      if (this._load)\n        return this._load;\n      var r = this.source;\n      return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener(\"play\", this._onPlayStart.bind(this)), r.addEventListener(\"pause\", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener(\"canplay\", this._onCanPlay), r.addEventListener(\"canplaythrough\", this._onCanPlay), r.addEventListener(\"error\", this._onError, !0)), this._load = new Promise(function(D) {\n        e.valid ? D(e) : (e._resolve = D, r.load());\n      }), this._load;\n    }, t.prototype._onError = function(e) {\n      this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(e);\n    }, t.prototype._isSourcePlaying = function() {\n      var e = this.source;\n      return !e.paused && !e.ended && this._isSourceReady();\n    }, t.prototype._isSourceReady = function() {\n      var e = this.source;\n      return e.readyState > 2;\n    }, t.prototype._onPlayStart = function() {\n      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);\n    }, t.prototype._onPlayStop = function() {\n      this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n    }, t.prototype._onCanPlay = function() {\n      var e = this.source;\n      e.removeEventListener(\"canplay\", this._onCanPlay), e.removeEventListener(\"canplaythrough\", this._onCanPlay);\n      var r = this.valid;\n      this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();\n    }, t.prototype.dispose = function() {\n      this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n      var e = this.source;\n      e && (e.removeEventListener(\"error\", this._onError, !0), e.pause(), e.src = \"\", e.load()), o.prototype.dispose.call(this);\n    }, Object.defineProperty(t.prototype, \"autoUpdate\", {\n      /** Should the base texture automatically update itself, set to true by default. */\n      get: function() {\n        return this._autoUpdate;\n      },\n      set: function(e) {\n        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"updateFPS\", {\n      /**\n       * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n       */\n      get: function() {\n        return this._updateFPS;\n      },\n      set: function(e) {\n        e !== this._updateFPS && (this._updateFPS = e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.test = function(e, r) {\n      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;\n    }, t.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], t.MIME_TYPES = {\n      ogv: \"video/ogg\",\n      mov: \"video/quicktime\",\n      m4v: \"video/mp4\"\n    }, t;\n  }(BaseImageResource)\n), ImageBitmapResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      return o.call(this, e) || this;\n    }\n    return t.test = function(e) {\n      return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && e instanceof ImageBitmap;\n    }, t;\n  }(BaseImageResource)\n);\nINSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\nvar _resources = {\n  __proto__: null,\n  Resource,\n  BaseImageResource,\n  INSTALLED,\n  autoDetectResource,\n  AbstractMultiResource,\n  ArrayResource,\n  BufferResource,\n  CanvasResource,\n  CubeResource,\n  ImageResource,\n  SVGResource,\n  VideoResource,\n  ImageBitmapResource\n}, DepthResource = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return t.prototype.upload = function(e, r, D) {\n      var N = e.gl;\n      N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);\n      var k = r.realWidth, $ = r.realHeight;\n      return D.width === k && D.height === $ ? N.texSubImage2D(r.target, 0, 0, 0, k, $, r.format, D.type, this.data) : (D.width = k, D.height = $, N.texImage2D(r.target, 0, D.internalFormat, k, $, 0, r.format, D.type, this.data)), !0;\n    }, t;\n  }(BufferResource)\n), Framebuffer = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner(\"disposeFramebuffer\"), this.multisample = MSAA_QUALITY.NONE;\n    }\n    return Object.defineProperty(o.prototype, \"colorTexture\", {\n      /**\n       * Reference to the colorTexture.\n       * @readonly\n       */\n      get: function() {\n        return this.colorTextures[0];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.addColorTexture = function(t, e) {\n      return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {\n        scaleMode: SCALE_MODES.NEAREST,\n        resolution: 1,\n        mipmap: MIPMAP_MODES.OFF,\n        width: this.width,\n        height: this.height\n      }), this.dirtyId++, this.dirtyFormat++, this;\n    }, o.prototype.addDepthTexture = function(t) {\n      return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n        scaleMode: SCALE_MODES.NEAREST,\n        resolution: 1,\n        width: this.width,\n        height: this.height,\n        mipmap: MIPMAP_MODES.OFF,\n        format: FORMATS.DEPTH_COMPONENT,\n        type: TYPES.UNSIGNED_SHORT\n      }), this.dirtyId++, this.dirtyFormat++, this;\n    }, o.prototype.enableDepth = function() {\n      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n    }, o.prototype.enableStencil = function() {\n      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n    }, o.prototype.resize = function(t, e) {\n      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {\n        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;\n        for (var r = 0; r < this.colorTextures.length; r++) {\n          var D = this.colorTextures[r], N = D.resolution;\n          D.setSize(t / N, e / N);\n        }\n        if (this.depthTexture) {\n          var N = this.depthTexture.resolution;\n          this.depthTexture.setSize(t / N, e / N);\n        }\n      }\n    }, o.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, o.prototype.destroyDepthTexture = function() {\n      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n    }, o;\n  }()\n), BaseRenderTexture = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      e === void 0 && (e = {});\n      var r = this;\n      if (typeof e == \"number\") {\n        var D = arguments[0], N = arguments[1], k = arguments[2], $ = arguments[3];\n        e = { width: D, height: N, scaleMode: k, resolution: $ };\n      }\n      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY.NONE, r = o.call(this, null, e) || this, r.mipmap = MIPMAP_MODES.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Framebuffer(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;\n    }\n    return t.prototype.resize = function(e, r) {\n      this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n    }, t.prototype.dispose = function() {\n      this.framebuffer.dispose(), o.prototype.dispose.call(this);\n    }, t.prototype.destroy = function() {\n      o.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n    }, t;\n  }(BaseTexture)\n), TextureUvs = (\n  /** @class */\n  function() {\n    function o() {\n      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n    }\n    return o.prototype.set = function(t, e, r) {\n      var D = e.width, N = e.height;\n      if (r) {\n        var k = t.width / 2 / D, $ = t.height / 2 / N, G = t.x / D + k, U = t.y / N + $;\n        r = groupD8.add(r, groupD8.NW), this.x0 = G + k * groupD8.uX(r), this.y0 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x1 = G + k * groupD8.uX(r), this.y1 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x2 = G + k * groupD8.uX(r), this.y2 = U + $ * groupD8.uY(r), r = groupD8.add(r, 2), this.x3 = G + k * groupD8.uX(r), this.y3 = U + $ * groupD8.uY(r);\n      } else\n        this.x0 = t.x / D, this.y0 = t.y / N, this.x1 = (t.x + t.width) / D, this.y1 = t.y / N, this.x2 = (t.x + t.width) / D, this.y2 = (t.y + t.height) / N, this.x3 = t.x / D, this.y3 = (t.y + t.height) / N;\n      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n    }, o.prototype.toString = function() {\n      return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n    }, o;\n  }()\n), DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(o) {\n  o.destroy = function() {\n  }, o.on = function() {\n  }, o.once = function() {\n  }, o.emit = function() {\n  };\n}\nvar Texture = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r, D, N, k, $) {\n      var G = o.call(this) || this;\n      if (G.noFrame = !1, r || (G.noFrame = !0, r = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), G.baseTexture = e, G._frame = r, G.trim = N, G.valid = !1, G._uvs = DEFAULT_UVS, G.uvMatrix = null, G.orig = D || r, G._rotate = Number(k || 0), k === !0)\n        G._rotate = 2;\n      else if (G._rotate % 2 !== 0)\n        throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n      return G.defaultAnchor = $ ? new Point($.x, $.y) : new Point(0, 0), G._updateID = 0, G.textureCacheIds = [], e.valid ? G.noFrame ? e.valid && G.onBaseTextureUpdated(e) : G.frame = r : e.once(\"loaded\", G.onBaseTextureUpdated, G), G.noFrame && e.on(\"update\", G.onBaseTextureUpdated, G), G;\n    }\n    return t.prototype.update = function() {\n      this.baseTexture.resource && this.baseTexture.resource.update();\n    }, t.prototype.onBaseTextureUpdated = function(e) {\n      if (this.noFrame) {\n        if (!this.baseTexture.valid)\n          return;\n        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();\n      } else\n        this.frame = this._frame;\n      this.emit(\"update\", this);\n    }, t.prototype.destroy = function(e) {\n      if (this.baseTexture) {\n        if (e) {\n          var r = this.baseTexture.resource;\n          r && r.url && TextureCache[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();\n        }\n        this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n      }\n      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;\n    }, t.prototype.clone = function() {\n      var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), D = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n      return this.noFrame && (D._frame = e), D;\n    }, t.prototype.updateUvs = function() {\n      this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n    }, t.from = function(e, r, D) {\n      r === void 0 && (r = {}), D === void 0 && (D = settings.STRICT_TEXTURE_CACHE);\n      var N = typeof e == \"string\", k = null;\n      if (N)\n        k = e;\n      else if (e instanceof BaseTexture) {\n        if (!e.cacheId) {\n          var $ = r && r.pixiIdPrefix || \"pixiid\";\n          e.cacheId = $ + \"-\" + uid(), BaseTexture.addToCache(e, e.cacheId);\n        }\n        k = e.cacheId;\n      } else {\n        if (!e._pixiId) {\n          var $ = r && r.pixiIdPrefix || \"pixiid\";\n          e._pixiId = $ + \"_\" + uid();\n        }\n        k = e._pixiId;\n      }\n      var G = TextureCache[k];\n      if (N && D && !G)\n        throw new Error('The cacheId \"' + k + '\" does not exist in TextureCache.');\n      return !G && !(e instanceof BaseTexture) ? (r.resolution || (r.resolution = getResolutionOfUrl(e)), G = new t(new BaseTexture(e, r)), G.baseTexture.cacheId = k, BaseTexture.addToCache(G.baseTexture, k), t.addToCache(G, k)) : !G && e instanceof BaseTexture && (G = new t(e), t.addToCache(G, k)), G;\n    }, t.fromURL = function(e, r) {\n      var D = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), N = t.from(e, Object.assign({ resourceOptions: D }, r), !1), k = N.baseTexture.resource;\n      return N.baseTexture.valid ? Promise.resolve(N) : k.load().then(function() {\n        return Promise.resolve(N);\n      });\n    }, t.fromBuffer = function(e, r, D, N) {\n      return new t(BaseTexture.fromBuffer(e, r, D, N));\n    }, t.fromLoader = function(e, r, D, N) {\n      var k = new BaseTexture(e, Object.assign({\n        scaleMode: settings.SCALE_MODE,\n        resolution: getResolutionOfUrl(r)\n      }, N)), $ = k.resource;\n      $ instanceof ImageResource && ($.url = r);\n      var G = new t(k);\n      return D || (D = r), BaseTexture.addToCache(G.baseTexture, D), t.addToCache(G, D), D !== r && (BaseTexture.addToCache(G.baseTexture, r), t.addToCache(G, r)), G.baseTexture.valid ? Promise.resolve(G) : new Promise(function(U) {\n        G.baseTexture.once(\"loaded\", function() {\n          return U(G);\n        });\n      });\n    }, t.addToCache = function(e, r) {\n      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), TextureCache[r] && console.warn(\"Texture added to the cache with an id [\" + r + \"] that already had an entry\"), TextureCache[r] = e);\n    }, t.removeFromCache = function(e) {\n      if (typeof e == \"string\") {\n        var r = TextureCache[e];\n        if (r) {\n          var D = r.textureCacheIds.indexOf(e);\n          return D > -1 && r.textureCacheIds.splice(D, 1), delete TextureCache[e], r;\n        }\n      } else if (e && e.textureCacheIds) {\n        for (var N = 0; N < e.textureCacheIds.length; ++N)\n          TextureCache[e.textureCacheIds[N]] === e && delete TextureCache[e.textureCacheIds[N]];\n        return e.textureCacheIds.length = 0, e;\n      }\n      return null;\n    }, Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * Returns resolution of baseTexture\n       * @readonly\n       */\n      get: function() {\n        return this.baseTexture.resolution;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"frame\", {\n      /**\n       * The frame specifies the region of the base texture that this texture uses.\n       * Please call `updateUvs()` after you change coordinates of `frame` manually.\n       */\n      get: function() {\n        return this._frame;\n      },\n      set: function(e) {\n        this._frame = e, this.noFrame = !1;\n        var r = e.x, D = e.y, N = e.width, k = e.height, $ = r + N > this.baseTexture.width, G = D + k > this.baseTexture.height;\n        if ($ || G) {\n          var U = $ && G ? \"and\" : \"or\", z = \"X: \" + r + \" + \" + N + \" = \" + (r + N) + \" > \" + this.baseTexture.width, X = \"Y: \" + D + \" + \" + k + \" = \" + (D + k) + \" > \" + this.baseTexture.height;\n          throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + (z + \" \" + U + \" \" + X));\n        }\n        this.valid = N && k && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rotate\", {\n      /**\n       * Indicates whether the texture is rotated inside the atlas\n       * set to 2 to compensate for texture packer rotation\n       * set to 6 to compensate for spine packer rotation\n       * can be used to rotate or mirror sprites\n       * See {@link PIXI.groupD8} for explanation\n       */\n      get: function() {\n        return this._rotate;\n      },\n      set: function(e) {\n        this._rotate = e, this.valid && this.updateUvs();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Texture in pixels. */\n      get: function() {\n        return this.orig.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Texture in pixels. */\n      get: function() {\n        return this.orig.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.castToBaseTexture = function() {\n      return this.baseTexture;\n    }, Object.defineProperty(t, \"EMPTY\", {\n      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */\n      get: function() {\n        return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"WHITE\", {\n      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */\n      get: function() {\n        if (!t._WHITE) {\n          var e = settings.ADAPTER.createCanvas(16, 16), r = e.getContext(\"2d\");\n          e.width = 16, e.height = 16, r.fillStyle = \"white\", r.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);\n        }\n        return t._WHITE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(eventemitter3Exports)\n), RenderTexture = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      var D = o.call(this, e, r) || this;\n      return D.valid = !0, D.filterFrame = null, D.filterPoolKey = null, D.updateUvs(), D;\n    }\n    return Object.defineProperty(t.prototype, \"framebuffer\", {\n      /**\n       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.\n       * @readonly\n       */\n      get: function() {\n        return this.baseTexture.framebuffer;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"multisample\", {\n      /**\n       * Shortcut to `this.framebuffer.multisample`.\n       * @default PIXI.MSAA_QUALITY.NONE\n       */\n      get: function() {\n        return this.framebuffer.multisample;\n      },\n      set: function(e) {\n        this.framebuffer.multisample = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.resize = function(e, r, D) {\n      D === void 0 && (D = !0);\n      var N = this.baseTexture.resolution, k = Math.round(e * N) / N, $ = Math.round(r * N) / N;\n      this.valid = k > 0 && $ > 0, this._frame.width = this.orig.width = k, this._frame.height = this.orig.height = $, D && this.baseTexture.resize(k, $), this.updateUvs();\n    }, t.prototype.setResolution = function(e) {\n      var r = this.baseTexture;\n      r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));\n    }, t.create = function(e) {\n      for (var r = arguments, D = [], N = 1; N < arguments.length; N++)\n        D[N - 1] = r[N];\n      return typeof e == \"number\" && (deprecation(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\"), e = {\n        width: e,\n        height: D[0],\n        scaleMode: D[1],\n        resolution: D[2]\n      }), new t(new BaseRenderTexture(e));\n    }, t;\n  }(Texture)\n), RenderTexturePool = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n    }\n    return o.prototype.createTexture = function(t, e, r) {\n      r === void 0 && (r = MSAA_QUALITY.NONE);\n      var D = new BaseRenderTexture(Object.assign({\n        width: t,\n        height: e,\n        resolution: 1,\n        multisample: r\n      }, this.textureOptions));\n      return new RenderTexture(D);\n    }, o.prototype.getOptimalTexture = function(t, e, r, D) {\n      r === void 0 && (r = 1), D === void 0 && (D = MSAA_QUALITY.NONE);\n      var N;\n      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), N = ((t & 65535) << 16 | e & 65535) >>> 0, D > 1 && (N += D * 4294967296)) : N = D > 1 ? -D : -1, this.texturePool[N] || (this.texturePool[N] = []);\n      var k = this.texturePool[N].pop();\n      return k || (k = this.createTexture(t, e, D)), k.filterPoolKey = N, k.setResolution(r), k;\n    }, o.prototype.getFilterTexture = function(t, e, r) {\n      var D = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);\n      return D.filterFrame = t.filterFrame, D;\n    }, o.prototype.returnTexture = function(t) {\n      var e = t.filterPoolKey;\n      t.filterFrame = null, this.texturePool[e].push(t);\n    }, o.prototype.returnFilterTexture = function(t) {\n      this.returnTexture(t);\n    }, o.prototype.clear = function(t) {\n      if (t = t !== !1, t)\n        for (var e in this.texturePool) {\n          var r = this.texturePool[e];\n          if (r)\n            for (var D = 0; D < r.length; D++)\n              r[D].destroy(!0);\n        }\n      this.texturePool = {};\n    }, o.prototype.setScreenSize = function(t) {\n      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {\n        this.enableFullScreen = t.width > 0 && t.height > 0;\n        for (var e in this.texturePool)\n          if (Number(e) < 0) {\n            var r = this.texturePool[e];\n            if (r)\n              for (var D = 0; D < r.length; D++)\n                r[D].destroy(!0);\n            this.texturePool[e] = [];\n          }\n        this._pixelsWidth = t.width, this._pixelsHeight = t.height;\n      }\n    }, o.SCREEN_KEY = -1, o;\n  }()\n), Attribute = (\n  /** @class */\n  function() {\n    function o(t, e, r, D, N, k, $) {\n      e === void 0 && (e = 0), r === void 0 && (r = !1), D === void 0 && (D = TYPES.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = D, this.stride = N, this.start = k, this.instance = $;\n    }\n    return o.prototype.destroy = function() {\n      this.buffer = null;\n    }, o.from = function(t, e, r, D, N) {\n      return new o(t, e, r, D, N);\n    }, o;\n  }()\n), UID$4 = 0, Buffer$1 = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner(\"disposeBuffer\");\n    }\n    return o.prototype.update = function(t) {\n      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;\n    }, o.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, o.prototype.destroy = function() {\n      this.dispose(), this.data = null;\n    }, Object.defineProperty(o.prototype, \"index\", {\n      get: function() {\n        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      },\n      /**\n       * Flags whether this is an index buffer.\n       *\n       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n       * the buffer of type `ARRAY_BUFFER`.\n       *\n       * For backwards compatibility.\n       */\n      set: function(t) {\n        this.type = t ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.from = function(t) {\n      return t instanceof Array && (t = new Float32Array(t)), new o(t);\n    }, o;\n  }()\n), map$1$1 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(o, t) {\n  for (var e = 0, r = 0, D = {}, N = 0; N < o.length; N++)\n    r += t[N], e += o[N].length;\n  for (var k = new ArrayBuffer(e * 4), $ = null, G = 0, N = 0; N < o.length; N++) {\n    var U = t[N], z = o[N], X = getBufferType(z);\n    D[X] || (D[X] = new map$1$1[X](k)), $ = D[X];\n    for (var V = 0; V < z.length; V++) {\n      var Y = (V / U | 0) * r + G, q = V % U;\n      $[Y + q] = z[V];\n    }\n    G += U;\n  }\n  return new Float32Array(k);\n}\nvar byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n}, Geometry = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner(\"disposeGeometry\"), this.refCount = 0;\n    }\n    return o.prototype.addAttribute = function(t, e, r, D, N, k, $, G) {\n      if (r === void 0 && (r = 0), D === void 0 && (D = !1), G === void 0 && (G = !1), !e)\n        throw new Error(\"You must pass a buffer when creating an attribute\");\n      e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));\n      var U = t.split(\"|\");\n      if (U.length > 1) {\n        for (var z = 0; z < U.length; z++)\n          this.addAttribute(U[z], e, r, D, N);\n        return this;\n      }\n      var X = this.buffers.indexOf(e);\n      return X === -1 && (this.buffers.push(e), X = this.buffers.length - 1), this.attributes[t] = new Attribute(X, r, D, N, k, $, G), this.instanced = this.instanced || G, this;\n    }, o.prototype.getAttribute = function(t) {\n      return this.attributes[t];\n    }, o.prototype.getBuffer = function(t) {\n      return this.buffers[this.getAttribute(t).buffer];\n    }, o.prototype.addIndex = function(t) {\n      return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;\n    }, o.prototype.getIndex = function() {\n      return this.indexBuffer;\n    }, o.prototype.interleave = function() {\n      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n        return this;\n      var t = [], e = [], r = new Buffer$1(), D;\n      for (D in this.attributes) {\n        var N = this.attributes[D], k = this.buffers[N.buffer];\n        t.push(k.data), e.push(N.size * byteSizeMap$1[N.type] / 4), N.buffer = 0;\n      }\n      for (r.data = interleaveTypedArrays(t, e), D = 0; D < this.buffers.length; D++)\n        this.buffers[D] !== this.indexBuffer && this.buffers[D].destroy();\n      return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n    }, o.prototype.getSize = function() {\n      for (var t in this.attributes) {\n        var e = this.attributes[t], r = this.buffers[e.buffer];\n        return r.data.length / (e.stride / 4 || e.size);\n      }\n      return 0;\n    }, o.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, o.prototype.destroy = function() {\n      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n    }, o.prototype.clone = function() {\n      for (var t = new o(), e = 0; e < this.buffers.length; e++)\n        t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));\n      for (var e in this.attributes) {\n        var r = this.attributes[e];\n        t.attributes[e] = new Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);\n      }\n      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), t;\n    }, o.merge = function(t) {\n      for (var e = new o(), r = [], D = [], N = [], k, $ = 0; $ < t.length; $++) {\n        k = t[$];\n        for (var G = 0; G < k.buffers.length; G++)\n          D[G] = D[G] || 0, D[G] += k.buffers[G].data.length, N[G] = 0;\n      }\n      for (var $ = 0; $ < k.buffers.length; $++)\n        r[$] = new map$2[getBufferType(k.buffers[$].data)](D[$]), e.buffers[$] = new Buffer$1(r[$]);\n      for (var $ = 0; $ < t.length; $++) {\n        k = t[$];\n        for (var G = 0; G < k.buffers.length; G++)\n          r[G].set(k.buffers[G].data, N[G]), N[G] += k.buffers[G].data.length;\n      }\n      if (e.attributes = k.attributes, k.indexBuffer) {\n        e.indexBuffer = e.buffers[k.buffers.indexOf(k.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        for (var U = 0, z = 0, X = 0, V = 0, $ = 0; $ < k.buffers.length; $++)\n          if (k.buffers[$] !== k.indexBuffer) {\n            V = $;\n            break;\n          }\n        for (var $ in k.attributes) {\n          var Y = k.attributes[$];\n          (Y.buffer | 0) === V && (z += Y.size * byteSizeMap$1[Y.type] / 4);\n        }\n        for (var $ = 0; $ < t.length; $++) {\n          for (var q = t[$].indexBuffer.data, G = 0; G < q.length; G++)\n            e.indexBuffer.data[G + X] += U;\n          U += t[$].buffers[V].data.length / z, X += q.length;\n        }\n      }\n      return e;\n    }, o;\n  }()\n), Quad = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t() {\n      var e = o.call(this) || this;\n      return e.addAttribute(\"aVertexPosition\", new Float32Array([\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1\n      ])).addIndex([0, 1, 3, 2]), e;\n    }\n    return t;\n  }(Geometry)\n), QuadUv = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t() {\n      var e = o.call(this) || this;\n      return e.vertices = new Float32Array([\n        -1,\n        -1,\n        1,\n        -1,\n        1,\n        1,\n        -1,\n        1\n      ]), e.uvs = new Float32Array([\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1\n      ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute(\"aVertexPosition\", e.vertexBuffer).addAttribute(\"aTextureCoord\", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;\n    }\n    return t.prototype.map = function(e, r) {\n      var D = 0, N = 0;\n      return this.uvs[0] = D, this.uvs[1] = N, this.uvs[2] = D + r.width / e.width, this.uvs[3] = N, this.uvs[4] = D + r.width / e.width, this.uvs[5] = N + r.height / e.height, this.uvs[6] = D, this.uvs[7] = N + r.height / e.height, D = r.x, N = r.y, this.vertices[0] = D, this.vertices[1] = N, this.vertices[2] = D + r.width, this.vertices[3] = N, this.vertices[4] = D + r.width, this.vertices[5] = N + r.height, this.vertices[6] = D, this.vertices[7] = N + r.height, this.invalidate(), this;\n    }, t.prototype.invalidate = function() {\n      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n    }, t;\n  }(Geometry)\n), UID$2 = 0, UniformGroup = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!r, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0));\n    }\n    return o.prototype.update = function() {\n      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n    }, o.prototype.add = function(t, e, r) {\n      if (!this.ubo)\n        this.uniforms[t] = new o(e, r);\n      else\n        throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n    }, o.from = function(t, e, r) {\n      return new o(t, e, r);\n    }, o.uboFrom = function(t, e) {\n      return new o(t, e ?? !0, !0);\n    }, o;\n  }()\n), FilterState = (\n  /** @class */\n  function() {\n    function o() {\n      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;\n    }\n    return o.prototype.clear = function() {\n      this.target = null, this.filters = null, this.renderTexture = null;\n    }, o;\n  }()\n), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n        outputFrame: new Rectangle(),\n        inputSize: new Float32Array(4),\n        inputPixel: new Float32Array(4),\n        inputClamp: new Float32Array(4),\n        resolution: 1,\n        // legacy variables\n        filterArea: new Float32Array(4),\n        filterClamp: new Float32Array(4)\n      }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n    }\n    return o.prototype.push = function(t, e) {\n      for (var r, D, N = this.renderer, k = this.defaultFilterStack, $ = this.statePool.pop() || new FilterState(), G = this.renderer.renderTexture, U = e[0].resolution, z = e[0].multisample, X = e[0].padding, V = e[0].autoFit, Y = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, q = 1; q < e.length; q++) {\n        var W = e[q];\n        U = Math.min(U, W.resolution), z = Math.min(z, W.multisample), X = this.useMaxPadding ? Math.max(X, W.padding) : X + W.padding, V = V && W.autoFit, Y = Y || ((D = W.legacy) !== null && D !== void 0 ? D : !0);\n      }\n      k.length === 1 && (this.defaultFilterStack[0].renderTexture = G.current), k.push($), $.resolution = U, $.multisample = z, $.legacy = Y, $.target = t, $.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), $.sourceFrame.pad(X);\n      var K = this.tempRect.copyFrom(G.sourceFrame);\n      N.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(N.projection.transform).invert(), K), V ? ($.sourceFrame.fit(K), ($.sourceFrame.width <= 0 || $.sourceFrame.height <= 0) && ($.sourceFrame.width = 0, $.sourceFrame.height = 0)) : $.sourceFrame.intersects(K) || ($.sourceFrame.width = 0, $.sourceFrame.height = 0), this.roundFrame($.sourceFrame, G.current ? G.current.resolution : N.resolution, G.sourceFrame, G.destinationFrame, N.projection.transform), $.renderTexture = this.getOptimalFilterTexture($.sourceFrame.width, $.sourceFrame.height, U, z), $.filters = e, $.destinationFrame.width = $.renderTexture.width, $.destinationFrame.height = $.renderTexture.height;\n      var Z = this.tempRect;\n      Z.x = 0, Z.y = 0, Z.width = $.sourceFrame.width, Z.height = $.sourceFrame.height, $.renderTexture.filterFrame = $.sourceFrame, $.bindingSourceFrame.copyFrom(G.sourceFrame), $.bindingDestinationFrame.copyFrom(G.destinationFrame), $.transform = N.projection.transform, N.projection.transform = null, G.bind($.renderTexture, $.sourceFrame, Z), N.framebuffer.clear(0, 0, 0, 0);\n    }, o.prototype.pop = function() {\n      var t = this.defaultFilterStack, e = t.pop(), r = e.filters;\n      this.activeState = e;\n      var D = this.globalUniforms.uniforms;\n      D.outputFrame = e.sourceFrame, D.resolution = e.resolution;\n      var N = D.inputSize, k = D.inputPixel, $ = D.inputClamp;\n      if (N[0] = e.destinationFrame.width, N[1] = e.destinationFrame.height, N[2] = 1 / N[0], N[3] = 1 / N[1], k[0] = Math.round(N[0] * e.resolution), k[1] = Math.round(N[1] * e.resolution), k[2] = 1 / k[0], k[3] = 1 / k[1], $[0] = 0.5 * k[2], $[1] = 0.5 * k[3], $[2] = e.sourceFrame.width * N[2] - 0.5 * k[2], $[3] = e.sourceFrame.height * N[3] - 0.5 * k[3], e.legacy) {\n        var G = D.filterArea;\n        G[0] = e.destinationFrame.width, G[1] = e.destinationFrame.height, G[2] = e.sourceFrame.x, G[3] = e.sourceFrame.y, D.filterClamp = D.inputClamp;\n      }\n      this.globalUniforms.update();\n      var U = t[t.length - 1];\n      if (this.renderer.framebuffer.blit(), r.length === 1)\n        r[0].apply(this, e.renderTexture, U.renderTexture, CLEAR_MODES.BLEND, e), this.returnFilterTexture(e.renderTexture);\n      else {\n        var z = e.renderTexture, X = this.getOptimalFilterTexture(z.width, z.height, e.resolution);\n        X.filterFrame = z.filterFrame;\n        var V = 0;\n        for (V = 0; V < r.length - 1; ++V) {\n          V === 1 && e.multisample > 1 && (X = this.getOptimalFilterTexture(z.width, z.height, e.resolution), X.filterFrame = z.filterFrame), r[V].apply(this, z, X, CLEAR_MODES.CLEAR, e);\n          var Y = z;\n          z = X, X = Y;\n        }\n        r[V].apply(this, z, U.renderTexture, CLEAR_MODES.BLEND, e), V > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(z), this.returnFilterTexture(X);\n      }\n      e.clear(), this.statePool.push(e);\n    }, o.prototype.bindAndClear = function(t, e) {\n      e === void 0 && (e = CLEAR_MODES.CLEAR);\n      var r = this.renderer, D = r.renderTexture, N = r.state;\n      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {\n        var k = this.tempRect;\n        k.x = 0, k.y = 0, k.width = t.filterFrame.width, k.height = t.filterFrame.height, D.bind(t, t.filterFrame, k);\n      } else\n        t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? D.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n      var $ = N.stateId & 1 || this.forceClear;\n      (e === CLEAR_MODES.CLEAR || e === CLEAR_MODES.BLIT && $) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }, o.prototype.applyFilter = function(t, e, r, D) {\n      var N = this.renderer;\n      N.state.set(t.state), this.bindAndClear(r, D), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, N.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), N.geometry.bind(this.quadUv), N.geometry.draw(DRAW_MODES.TRIANGLES)) : (N.geometry.bind(this.quad), N.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));\n    }, o.prototype.calculateSpriteMatrix = function(t, e) {\n      var r = this.activeState, D = r.sourceFrame, N = r.destinationFrame, k = e._texture.orig, $ = t.set(N.width, 0, 0, N.height, D.x, D.y), G = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n      return G.invert(), $.prepend(G), $.scale(1 / k.width, 1 / k.height), $.translate(e.anchor.x, e.anchor.y), $;\n    }, o.prototype.destroy = function() {\n      this.renderer = null, this.texturePool.clear(!1);\n    }, o.prototype.getOptimalFilterTexture = function(t, e, r, D) {\n      return r === void 0 && (r = 1), D === void 0 && (D = MSAA_QUALITY.NONE), this.texturePool.getOptimalTexture(t, e, r, D);\n    }, o.prototype.getFilterTexture = function(t, e, r) {\n      if (typeof t == \"number\") {\n        var D = t;\n        t = e, e = D;\n      }\n      t = t || this.activeState.renderTexture;\n      var N = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || MSAA_QUALITY.NONE);\n      return N.filterFrame = t.filterFrame, N;\n    }, o.prototype.returnFilterTexture = function(t) {\n      this.texturePool.returnTexture(t);\n    }, o.prototype.emptyPool = function() {\n      this.texturePool.clear(!0);\n    }, o.prototype.resize = function() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }, o.prototype.transformAABB = function(t, e) {\n      var r = tempPoints[0], D = tempPoints[1], N = tempPoints[2], k = tempPoints[3];\n      r.set(e.left, e.top), D.set(e.left, e.bottom), N.set(e.right, e.top), k.set(e.right, e.bottom), t.apply(r, r), t.apply(D, D), t.apply(N, N), t.apply(k, k);\n      var $ = Math.min(r.x, D.x, N.x, k.x), G = Math.min(r.y, D.y, N.y, k.y), U = Math.max(r.x, D.x, N.x, k.x), z = Math.max(r.y, D.y, N.y, k.y);\n      e.x = $, e.y = G, e.width = U - $, e.height = z - G;\n    }, o.prototype.roundFrame = function(t, e, r, D, N) {\n      if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {\n        if (N) {\n          var k = N.a, $ = N.b, G = N.c, U = N.d;\n          if ((Math.abs($) > 1e-4 || Math.abs(G) > 1e-4) && (Math.abs(k) > 1e-4 || Math.abs(U) > 1e-4))\n            return;\n        }\n        N = N ? tempMatrix$2.copyFrom(N) : tempMatrix$2.identity(), N.translate(-r.x, -r.y).scale(D.width / r.width, D.height / r.height).translate(D.x, D.y), this.transformAABB(N, t), t.ceil(e), this.transformAABB(N.invert(), t);\n      }\n    }, o;\n  }()\n), ObjectRenderer = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t;\n    }\n    return o.prototype.flush = function() {\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o.prototype.start = function() {\n    }, o.prototype.stop = function() {\n      this.flush();\n    }, o.prototype.render = function(t) {\n    }, o;\n  }()\n), BatchSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;\n    }\n    return o.prototype.setObjectRenderer = function(t) {\n      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());\n    }, o.prototype.flush = function() {\n      this.setObjectRenderer(this.emptyRenderer);\n    }, o.prototype.reset = function() {\n      this.setObjectRenderer(this.emptyRenderer);\n    }, o.prototype.copyBoundTextures = function(t, e) {\n      for (var r = this.renderer.texture.boundTextures, D = e - 1; D >= 0; --D)\n        t[D] = r[D] || null, t[D] && (t[D]._batchLocation = D);\n    }, o.prototype.boundArray = function(t, e, r, D) {\n      for (var N = t.elements, k = t.ids, $ = t.count, G = 0, U = 0; U < $; U++) {\n        var z = N[U], X = z._batchLocation;\n        if (X >= 0 && X < D && e[X] === z) {\n          k[U] = X;\n          continue;\n        }\n        for (; G < D; ) {\n          var V = e[G];\n          if (V && V._batchEnabled === r && V._batchLocation === G) {\n            G++;\n            continue;\n          }\n          k[U] = G, z._batchLocation = G, e[G] = z;\n          break;\n        }\n      }\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), CONTEXT_UID_COUNTER = 0, ContextSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n        uint32Indices: !1\n      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), t.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1);\n    }\n    return Object.defineProperty(o.prototype, \"isLost\", {\n      /**\n       * `true` if the context is lost\n       * @readonly\n       */\n      get: function() {\n        return !this.gl || this.gl.isContextLost();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.contextChange = function(t) {\n      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n    }, o.prototype.initFromContext = function(t) {\n      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);\n    }, o.prototype.initFromOptions = function(t) {\n      var e = this.createContext(this.renderer.view, t);\n      this.initFromContext(e);\n    }, o.prototype.createContext = function(t, e) {\n      var r;\n      if (settings.PREFER_ENV >= ENV.WEBGL2 && (r = t.getContext(\"webgl2\", e)), r)\n        this.webGLVersion = 2;\n      else if (this.webGLVersion = 1, r = t.getContext(\"webgl\", e) || t.getContext(\"experimental-webgl\", e), !r)\n        throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n      return this.gl = r, this.getExtensions(), this.gl;\n    }, o.prototype.getExtensions = function() {\n      var t = this.gl, e = {\n        loseContext: t.getExtension(\"WEBGL_lose_context\"),\n        anisotropicFiltering: t.getExtension(\"EXT_texture_filter_anisotropic\"),\n        floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n        s3tc: t.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n        s3tc_sRGB: t.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n        etc: t.getExtension(\"WEBGL_compressed_texture_etc\"),\n        etc1: t.getExtension(\"WEBGL_compressed_texture_etc1\"),\n        pvrtc: t.getExtension(\"WEBGL_compressed_texture_pvrtc\") || t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n        atc: t.getExtension(\"WEBGL_compressed_texture_atc\"),\n        astc: t.getExtension(\"WEBGL_compressed_texture_astc\")\n      };\n      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {\n        drawBuffers: t.getExtension(\"WEBGL_draw_buffers\"),\n        depthTexture: t.getExtension(\"WEBGL_depth_texture\"),\n        vertexArrayObject: t.getExtension(\"OES_vertex_array_object\") || t.getExtension(\"MOZ_OES_vertex_array_object\") || t.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n        uint32ElementIndex: t.getExtension(\"OES_element_index_uint\"),\n        // Floats and half-floats\n        floatTexture: t.getExtension(\"OES_texture_float\"),\n        floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n        textureHalfFloat: t.getExtension(\"OES_texture_half_float\"),\n        textureHalfFloatLinear: t.getExtension(\"OES_texture_half_float_linear\")\n      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {\n        // Floats and half-floats\n        colorBufferFloat: t.getExtension(\"EXT_color_buffer_float\")\n      });\n    }, o.prototype.handleContextLost = function(t) {\n      var e = this;\n      t.preventDefault(), setTimeout(function() {\n        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();\n      }, 0);\n    }, o.prototype.handleContextRestored = function() {\n      this.renderer.runners.contextChange.emit(this.gl);\n    }, o.prototype.destroy = function() {\n      var t = this.renderer.view;\n      this.renderer = null, t.removeEventListener(\"webglcontextlost\", this.handleContextLost), t.removeEventListener(\"webglcontextrestored\", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n    }, o.prototype.postrender = function() {\n      this.renderer.renderingToScreen && this.gl.flush();\n    }, o.prototype.validateContext = function(t) {\n      var e = t.getContextAttributes(), r = \"WebGL2RenderingContext\" in globalThis && t instanceof globalThis.WebGL2RenderingContext;\n      r && (this.webGLVersion = 2), e && !e.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n      var D = r || !!t.getExtension(\"OES_element_index_uint\");\n      this.supports.uint32Indices = D, D || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n    }, o;\n  }()\n), GLFramebuffer = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n    }\n    return o;\n  }()\n), tempRectangle = new Rectangle(), FramebufferSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;\n    }\n    return o.prototype.contextChange = function() {\n      this.disposeAll(!0);\n      var t = this.gl = this.renderer.gl;\n      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {\n        var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;\n        settings.PREFER_ENV === ENV.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(D) {\n          return e.drawBuffersWEBGL(D);\n        } : (this.hasMRT = !1, t.drawBuffers = function() {\n        }), r || (this.writeDepthTexture = !1);\n      } else\n        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);\n    }, o.prototype.bind = function(t, e, r) {\n      r === void 0 && (r = 0);\n      var D = this.gl;\n      if (t) {\n        var N = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);\n        this.current !== t && (this.current = t, D.bindFramebuffer(D.FRAMEBUFFER, N.framebuffer)), N.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, N.mipLevel = r), N.dirtyId !== t.dirtyId && (N.dirtyId = t.dirtyId, N.dirtyFormat !== t.dirtyFormat ? (N.dirtyFormat = t.dirtyFormat, N.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : N.dirtySize !== t.dirtySize && (N.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));\n        for (var k = 0; k < t.colorTextures.length; k++) {\n          var $ = t.colorTextures[k];\n          this.renderer.texture.unbind($.parentTextureArray || $);\n        }\n        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {\n          var G = e.width >> r, U = e.height >> r, z = G / e.width;\n          this.setViewport(e.x * z, e.y * z, G, U);\n        } else {\n          var G = t.width >> r, U = t.height >> r;\n          this.setViewport(0, 0, G, U);\n        }\n      } else\n        this.current && (this.current = null, D.bindFramebuffer(D.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n    }, o.prototype.setViewport = function(t, e, r, D) {\n      var N = this.viewport;\n      t = Math.round(t), e = Math.round(e), r = Math.round(r), D = Math.round(D), (N.width !== r || N.height !== D || N.x !== t || N.y !== e) && (N.x = t, N.y = e, N.width = r, N.height = D, this.gl.viewport(t, e, r, D));\n    }, Object.defineProperty(o.prototype, \"size\", {\n      /**\n       * Get the size of the current width and height. Returns object with `width` and `height` values.\n       * @readonly\n       */\n      get: function() {\n        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.clear = function(t, e, r, D, N) {\n      N === void 0 && (N = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);\n      var k = this.gl;\n      k.clearColor(t, e, r, D), k.clear(N);\n    }, o.prototype.initFramebuffer = function(t) {\n      var e = this.gl, r = new GLFramebuffer(e.createFramebuffer());\n      return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;\n    }, o.prototype.resizeFramebuffer = function(t) {\n      var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];\n      r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));\n      var D = t.colorTextures, N = D.length;\n      e.drawBuffers || (N = Math.min(N, 1));\n      for (var k = 0; k < N; k++) {\n        var $ = D[k], G = $.parentTextureArray || $;\n        this.renderer.texture.bind(G, 0);\n      }\n      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);\n    }, o.prototype.updateFramebuffer = function(t, e) {\n      var r = this.gl, D = t.glFramebuffers[this.CONTEXT_UID], N = t.colorTextures, k = N.length;\n      r.drawBuffers || (k = Math.min(k, 1)), D.multisample > 1 && this.canMultisampleFramebuffer(t) ? (D.msaaBuffer = D.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, D.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, D.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, D.msaaBuffer)) : D.msaaBuffer && (r.deleteRenderbuffer(D.msaaBuffer), D.msaaBuffer = null, D.blitFramebuffer && (D.blitFramebuffer.dispose(), D.blitFramebuffer = null));\n      for (var $ = [], G = 0; G < k; G++) {\n        var U = N[G], z = U.parentTextureArray || U;\n        this.renderer.texture.bind(z, 0), !(G === 0 && D.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + G, U.target, z._glTextures[this.CONTEXT_UID].texture, e), $.push(r.COLOR_ATTACHMENT0 + G));\n      }\n      if ($.length > 1 && r.drawBuffers($), t.depthTexture) {\n        var X = this.writeDepthTexture;\n        if (X) {\n          var V = t.depthTexture;\n          this.renderer.texture.bind(V, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, V._glTextures[this.CONTEXT_UID].texture, e);\n        }\n      }\n      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (D.stencil = D.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, D.stencil), D.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, D.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, D.stencil)) : D.stencil && (r.deleteRenderbuffer(D.stencil), D.stencil = null);\n    }, o.prototype.canMultisampleFramebuffer = function(t) {\n      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;\n    }, o.prototype.detectSamples = function(t) {\n      var e = this.msaaSamples, r = MSAA_QUALITY.NONE;\n      if (t <= 1 || e === null)\n        return r;\n      for (var D = 0; D < e.length; D++)\n        if (e[D] <= t) {\n          r = e[D];\n          break;\n        }\n      return r === 1 && (r = MSAA_QUALITY.NONE), r;\n    }, o.prototype.blit = function(t, e, r) {\n      var D = this, N = D.current, k = D.renderer, $ = D.gl, G = D.CONTEXT_UID;\n      if (k.context.webGLVersion === 2 && N) {\n        var U = N.glFramebuffers[G];\n        if (U) {\n          if (!t) {\n            if (!U.msaaBuffer)\n              return;\n            var z = N.colorTextures[0];\n            if (!z)\n              return;\n            U.blitFramebuffer || (U.blitFramebuffer = new Framebuffer(N.width, N.height), U.blitFramebuffer.addColorTexture(0, z)), t = U.blitFramebuffer, t.colorTextures[0] !== z && (t.colorTextures[0] = z, t.dirtyId++, t.dirtyFormat++), (t.width !== N.width || t.height !== N.height) && (t.width = N.width, t.height = N.height, t.dirtyId++, t.dirtySize++);\n          }\n          e || (e = tempRectangle, e.width = N.width, e.height = N.height), r || (r = e);\n          var X = e.width === r.width && e.height === r.height;\n          this.bind(t), $.bindFramebuffer($.READ_FRAMEBUFFER, U.framebuffer), $.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, $.COLOR_BUFFER_BIT, X ? $.NEAREST : $.LINEAR);\n        }\n      }\n    }, o.prototype.disposeFramebuffer = function(t, e) {\n      var r = t.glFramebuffers[this.CONTEXT_UID], D = this.gl;\n      if (r) {\n        delete t.glFramebuffers[this.CONTEXT_UID];\n        var N = this.managedFramebuffers.indexOf(t);\n        N >= 0 && this.managedFramebuffers.splice(N, 1), t.disposeRunner.remove(this), e || (D.deleteFramebuffer(r.framebuffer), r.msaaBuffer && D.deleteRenderbuffer(r.msaaBuffer), r.stencil && D.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();\n      }\n    }, o.prototype.disposeAll = function(t) {\n      var e = this.managedFramebuffers;\n      this.managedFramebuffers = [];\n      for (var r = 0; r < e.length; r++)\n        this.disposeFramebuffer(e[r], t);\n    }, o.prototype.forceStencil = function() {\n      var t = this.current;\n      if (t) {\n        var e = t.glFramebuffers[this.CONTEXT_UID];\n        if (!(!e || e.stencil)) {\n          t.stencil = !0;\n          var r = t.width, D = t.height, N = this.gl, k = N.createRenderbuffer();\n          N.bindRenderbuffer(N.RENDERBUFFER, k), e.msaaBuffer ? N.renderbufferStorageMultisample(N.RENDERBUFFER, e.multisample, N.DEPTH24_STENCIL8, r, D) : N.renderbufferStorage(N.RENDERBUFFER, N.DEPTH_STENCIL, r, D), e.stencil = k, N.framebufferRenderbuffer(N.FRAMEBUFFER, N.DEPTH_STENCIL_ATTACHMENT, N.RENDERBUFFER, k);\n        }\n      }\n    }, o.prototype.reset = function() {\n      this.current = this.unknownFramebuffer, this.viewport = new Rectangle();\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n    }\n    return o.prototype.contextChange = function() {\n      this.disposeAll(!0);\n      var t = this.gl = this.renderer.gl, e = this.renderer.context;\n      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {\n        var r = this.renderer.context.extensions.vertexArrayObject;\n        settings.PREFER_ENV === ENV.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {\n          return r.createVertexArrayOES();\n        }, t.bindVertexArray = function(N) {\n          return r.bindVertexArrayOES(N);\n        }, t.deleteVertexArray = function(N) {\n          return r.deleteVertexArrayOES(N);\n        }) : (this.hasVao = !1, t.createVertexArray = function() {\n          return null;\n        }, t.bindVertexArray = function() {\n          return null;\n        }, t.deleteVertexArray = function() {\n          return null;\n        });\n      }\n      if (e.webGLVersion !== 2) {\n        var D = t.getExtension(\"ANGLE_instanced_arrays\");\n        D ? (t.vertexAttribDivisor = function(N, k) {\n          return D.vertexAttribDivisorANGLE(N, k);\n        }, t.drawElementsInstanced = function(N, k, $, G, U) {\n          return D.drawElementsInstancedANGLE(N, k, $, G, U);\n        }, t.drawArraysInstanced = function(N, k, $, G) {\n          return D.drawArraysInstancedANGLE(N, k, $, G);\n        }) : this.hasInstance = !1;\n      }\n      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;\n    }, o.prototype.bind = function(t, e) {\n      e = e || this.renderer.shader.shader;\n      var r = this.gl, D = t.glVertexArrayObjects[this.CONTEXT_UID], N = !1;\n      D || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = D = {}, N = !0);\n      var k = D[e.program.id] || this.initGeometryVao(t, e, N);\n      this._activeGeometry = t, this._activeVao !== k && (this._activeVao = k, this.hasVao ? r.bindVertexArray(k) : this.activateVao(t, e.program)), this.updateBuffers();\n    }, o.prototype.reset = function() {\n      this.unbind();\n    }, o.prototype.updateBuffers = function() {\n      for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {\n        var D = t.buffers[r];\n        e.update(D);\n      }\n    }, o.prototype.checkCompatibility = function(t, e) {\n      var r = t.attributes, D = e.attributeData;\n      for (var N in D)\n        if (!r[N])\n          throw new Error('shader and geometry incompatible, geometry missing the \"' + N + '\" attribute');\n    }, o.prototype.getSignature = function(t, e) {\n      var r = t.attributes, D = e.attributeData, N = [\"g\", t.id];\n      for (var k in r)\n        D[k] && N.push(k, D[k].location);\n      return N.join(\"-\");\n    }, o.prototype.initGeometryVao = function(t, e, r) {\n      r === void 0 && (r = !0);\n      var D = this.gl, N = this.CONTEXT_UID, k = this.renderer.buffer, $ = e.program;\n      $.glPrograms[N] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, $);\n      var G = this.getSignature(t, $), U = t.glVertexArrayObjects[this.CONTEXT_UID], z = U[G];\n      if (z)\n        return U[$.id] = z, z;\n      var X = t.buffers, V = t.attributes, Y = {}, q = {};\n      for (var W in X)\n        Y[W] = 0, q[W] = 0;\n      for (var W in V)\n        !V[W].size && $.attributeData[W] ? V[W].size = $.attributeData[W].size : V[W].size || console.warn(\"PIXI Geometry attribute '\" + W + \"' size cannot be determined (likely the bound shader does not have the attribute)\"), Y[V[W].buffer] += V[W].size * byteSizeMap[V[W].type];\n      for (var W in V) {\n        var K = V[W], Z = K.size;\n        K.stride === void 0 && (Y[K.buffer] === Z * byteSizeMap[K.type] ? K.stride = 0 : K.stride = Y[K.buffer]), K.start === void 0 && (K.start = q[K.buffer], q[K.buffer] += Z * byteSizeMap[K.type]);\n      }\n      z = D.createVertexArray(), D.bindVertexArray(z);\n      for (var J = 0; J < X.length; J++) {\n        var Q = X[J];\n        k.bind(Q), r && Q._glBuffers[N].refCount++;\n      }\n      return this.activateVao(t, $), this._activeVao = z, U[$.id] = z, U[G] = z, z;\n    }, o.prototype.disposeGeometry = function(t, e) {\n      var r;\n      if (this.managedGeometries[t.id]) {\n        delete this.managedGeometries[t.id];\n        var D = t.glVertexArrayObjects[this.CONTEXT_UID], N = this.gl, k = t.buffers, $ = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;\n        if (t.disposeRunner.remove(this), !!D) {\n          if ($)\n            for (var G = 0; G < k.length; G++) {\n              var U = k[G]._glBuffers[this.CONTEXT_UID];\n              U && (U.refCount--, U.refCount === 0 && !e && $.dispose(k[G], e));\n            }\n          if (!e) {\n            for (var z in D)\n              if (z[0] === \"g\") {\n                var X = D[z];\n                this._activeVao === X && this.unbind(), N.deleteVertexArray(X);\n              }\n          }\n          delete t.glVertexArrayObjects[this.CONTEXT_UID];\n        }\n      }\n    }, o.prototype.disposeAll = function(t) {\n      for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)\n        this.disposeGeometry(this.managedGeometries[e[r]], t);\n    }, o.prototype.activateVao = function(t, e) {\n      var r = this.gl, D = this.CONTEXT_UID, N = this.renderer.buffer, k = t.buffers, $ = t.attributes;\n      t.indexBuffer && N.bind(t.indexBuffer);\n      var G = null;\n      for (var U in $) {\n        var z = $[U], X = k[z.buffer], V = X._glBuffers[D];\n        if (e.attributeData[U]) {\n          G !== V && (N.bind(X), G = V);\n          var Y = e.attributeData[U].location;\n          if (r.enableVertexAttribArray(Y), r.vertexAttribPointer(Y, z.size, z.type || r.FLOAT, z.normalized, z.stride, z.start), z.instance)\n            if (this.hasInstance)\n              r.vertexAttribDivisor(Y, 1);\n            else\n              throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n        }\n      }\n    }, o.prototype.draw = function(t, e, r, D) {\n      var N = this.gl, k = this._activeGeometry;\n      if (k.indexBuffer) {\n        var $ = k.indexBuffer.data.BYTES_PER_ELEMENT, G = $ === 2 ? N.UNSIGNED_SHORT : N.UNSIGNED_INT;\n        $ === 2 || $ === 4 && this.canUseUInt32ElementIndex ? k.instanced ? N.drawElementsInstanced(t, e || k.indexBuffer.data.length, G, (r || 0) * $, D || 1) : N.drawElements(t, e || k.indexBuffer.data.length, G, (r || 0) * $) : console.warn(\"unsupported index buffer type: uint32\");\n      } else\n        k.instanced ? N.drawArraysInstanced(t, r, e || k.getSize(), D || 1) : N.drawArrays(t, r, e || k.getSize());\n      return this;\n    }, o.prototype.unbind = function() {\n      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), MaskData = (\n  /** @class */\n  function() {\n    function o(t) {\n      t === void 0 && (t = null), this.type = MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n    }\n    return Object.defineProperty(o.prototype, \"filter\", {\n      /**\n       * The sprite mask filter.\n       * If set to `null`, the default sprite mask filter is used.\n       * @default null\n       */\n      get: function() {\n        return this._filters ? this._filters[0] : null;\n      },\n      set: function(t) {\n        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.reset = function() {\n      this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n    }, o.prototype.copyCountersOrReset = function(t) {\n      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n    }, o;\n  }()\n);\nfunction compileShader(o, t, e) {\n  var r = o.createShader(t);\n  return o.shaderSource(r, e), o.compileShader(r), r;\n}\nfunction logPrettyShaderError(o, t) {\n  var e = o.getShaderSource(t).split(`\n`).map(function(U, z) {\n    return z + \": \" + U;\n  }), r = o.getShaderInfoLog(t), D = r.split(`\n`), N = {}, k = D.map(function(U) {\n    return parseFloat(U.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function(U) {\n    return U && !N[U] ? (N[U] = !0, !0) : !1;\n  }), $ = [\"\"];\n  k.forEach(function(U) {\n    e[U - 1] = \"%c\" + e[U - 1] + \"%c\", $.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var G = e.join(`\n`);\n  $[0] = G, console.error(r), console.groupCollapsed(\"click to view full shader code\"), console.warn.apply(console, $), console.groupEnd();\n}\nfunction logProgramError(o, t, e, r) {\n  o.getProgramParameter(t, o.LINK_STATUS) || (o.getShaderParameter(e, o.COMPILE_STATUS) || logPrettyShaderError(o, e), o.getShaderParameter(r, o.COMPILE_STATUS) || logPrettyShaderError(o, r), console.error(\"PixiJS Error: Could not initialize shader.\"), o.getProgramInfoLog(t) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", o.getProgramInfoLog(t)));\n}\nfunction booleanArray(o) {\n  for (var t = new Array(o), e = 0; e < t.length; e++)\n    t[e] = !1;\n  return t;\n}\nfunction defaultValue(o, t) {\n  switch (o) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * t);\n    case \"vec3\":\n      return new Float32Array(3 * t);\n    case \"vec4\":\n      return new Float32Array(4 * t);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * t);\n    case \"ivec3\":\n      return new Int32Array(3 * t);\n    case \"ivec4\":\n      return new Int32Array(4 * t);\n    case \"uvec2\":\n      return new Uint32Array(2 * t);\n    case \"uvec3\":\n      return new Uint32Array(3 * t);\n    case \"uvec4\":\n      return new Uint32Array(4 * t);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return booleanArray(2 * t);\n    case \"bvec3\":\n      return booleanArray(3 * t);\n    case \"bvec4\":\n      return booleanArray(4 * t);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar unknownContext = {}, context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context && context.isContextLost()) {\n    var o = settings.ADAPTER.createCanvas(), t = void 0;\n    settings.PREFER_ENV >= ENV.WEBGL2 && (t = o.getContext(\"webgl2\", {})), t || (t = o.getContext(\"webgl\", {}) || o.getContext(\"experimental-webgl\", {}), t ? t.getExtension(\"WEBGL_draw_buffers\") : t = null), context = t;\n  }\n  return context;\n}\nvar maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION.MEDIUM;\n    var o = getTestContext();\n    if (o && o.getShaderPrecisionFormat) {\n      var t = o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT);\n      maxFragmentPrecision = t.precision ? PRECISION.HIGH : PRECISION.MEDIUM;\n    }\n  }\n  return maxFragmentPrecision;\n}\nfunction setPrecision(o, t, e) {\n  if (o.substring(0, 9) !== \"precision\") {\n    var r = t;\n    return t === PRECISION.HIGH && e !== PRECISION.HIGH && (r = PRECISION.MEDIUM), \"precision \" + r + ` float;\n` + o;\n  } else if (e !== PRECISION.HIGH && o.substring(0, 15) === \"precision highp\")\n    return o.replace(\"precision highp\", \"precision mediump\");\n  return o;\n}\nvar GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(o) {\n  return GLSL_TO_SIZE[o];\n}\nvar GL_TABLE = null, GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(o, t) {\n  if (!GL_TABLE) {\n    var e = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (var r = 0; r < e.length; ++r) {\n      var D = e[r];\n      GL_TABLE[o[D]] = GL_TO_GLSL_TYPES[D];\n    }\n  }\n  return GL_TABLE[t];\n}\nvar uniformParsers = [\n  // a float cache layer\n  {\n    test: function(o) {\n      return o.type === \"float\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n            if(uv[\"` + o + '\"] !== ud[\"' + o + `\"].value)\n            {\n                ud[\"` + o + '\"].value = uv[\"' + o + `\"]\n                gl.uniform1f(ud[\"` + o + '\"].location, uv[\"' + o + `\"])\n            }\n            `;\n    }\n  },\n  // handling samplers\n  {\n    test: function(o, t) {\n      return (o.type === \"sampler2D\" || o.type === \"samplerCube\" || o.type === \"sampler2DArray\") && o.size === 1 && !o.isArray && (t == null || t.castToBaseTexture !== void 0);\n    },\n    code: function(o) {\n      return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"` + o + `\"], t);\n\n            if(ud[\"` + o + `\"].value !== t)\n            {\n                ud[\"` + o + `\"].value = t;\n                gl.uniform1i(ud[\"` + o + `\"].location, t);\n; // eslint-disable-line max-len\n            }`;\n    }\n  },\n  // uploading pixi matrix object to mat3\n  {\n    test: function(o, t) {\n      return o.type === \"mat3\" && o.size === 1 && !o.isArray && t.a !== void 0;\n    },\n    code: function(o) {\n      return `\n            gl.uniformMatrix3fv(ud[\"` + o + '\"].location, false, uv[\"' + o + `\"].toArray(true));\n            `;\n    },\n    codeUbo: function(o) {\n      return `\n                var ` + o + \"_matrix = uv.\" + o + `.toArray(true);\n\n                data[offset] = ` + o + `_matrix[0];\n                data[offset+1] = ` + o + `_matrix[1];\n                data[offset+2] = ` + o + `_matrix[2];\n        \n                data[offset + 4] = ` + o + `_matrix[3];\n                data[offset + 5] = ` + o + `_matrix[4];\n                data[offset + 6] = ` + o + `_matrix[5];\n        \n                data[offset + 8] = ` + o + `_matrix[6];\n                data[offset + 9] = ` + o + `_matrix[7];\n                data[offset + 10] = ` + o + `_matrix[8];\n            `;\n    }\n  },\n  // uploading a pixi point as a vec2 with caching layer\n  {\n    test: function(o, t) {\n      return o.type === \"vec2\" && o.size === 1 && !o.isArray && t.x !== void 0;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"` + o + `\"].location, v.x, v.y);\n                }`;\n    },\n    codeUbo: function(o) {\n      return `\n                v = uv.` + o + `;\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `;\n    }\n  },\n  // caching layer for a vec2\n  {\n    test: function(o) {\n      return o.type === \"vec2\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"` + o + `\"].location, v[0], v[1]);\n                }\n            `;\n    }\n  },\n  // upload a pixi rectangle as a vec4 with caching layer\n  {\n    test: function(o, t) {\n      return o.type === \"vec4\" && o.size === 1 && !o.isArray && t.width !== void 0;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"` + o + `\"].location, v.x, v.y, v.width, v.height)\n                }`;\n    },\n    codeUbo: function(o) {\n      return `\n                    v = uv.` + o + `;\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `;\n    }\n  },\n  // a caching layer for vec4 uploading\n  {\n    test: function(o) {\n      return o.type === \"vec4\" && o.size === 1 && !o.isArray;\n    },\n    code: function(o) {\n      return `\n                cv = ud[\"` + o + `\"].value;\n                v = uv[\"` + o + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"` + o + `\"].location, v[0], v[1], v[2], v[3])\n                }`;\n    }\n  }\n], GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(o, t) {\n  var e, r = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (var D in o.uniforms) {\n    var N = t[D];\n    if (!N) {\n      !((e = o.uniforms[D]) === null || e === void 0) && e.group && (o.uniforms[D].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.` + D + \", '\" + D + `');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.` + D + `, syncData);\n                    `));\n      continue;\n    }\n    for (var k = o.uniforms[D], $ = !1, G = 0; G < uniformParsers.length; G++)\n      if (uniformParsers[G].test(N, k)) {\n        r.push(uniformParsers[G].code(D, k)), $ = !0;\n        break;\n      }\n    if (!$) {\n      var U = N.size === 1 && !N.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, z = U[N.type].replace(\"location\", 'ud[\"' + D + '\"].location');\n      r.push(`\n            cu = ud[\"` + D + `\"];\n            cv = cu.value;\n            v = uv[\"` + D + `\"];\n            ` + z + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", r.join(`\n`));\n}\nvar fragTemplate$1 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction generateIfTestSrc(o) {\n  for (var t = \"\", e = 0; e < o; ++e)\n    e > 0 && (t += `\nelse `), e < o - 1 && (t += \"if(test == \" + e + \".0){}\");\n  return t;\n}\nfunction checkMaxIfStatementsInShader(o, t) {\n  if (o === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {\n    var r = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(o));\n    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))\n      o = o / 2 | 0;\n    else\n      break;\n  }\n  return o;\n}\nvar unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == \"boolean\")\n    return unsafeEval;\n  try {\n    var o = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = o({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\nvar defaultFragment$2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`, defaultVertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`, UID$1 = 0, nameCache = {}, Program = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      r === void 0 && (r = \"pixi-shader\"), this.id = UID$1++, this.vertexSrc = t || o.defaultVertexSrc, this.fragmentSrc = e || o.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== \"#version\" && (r = r.replace(/\\s+/g, \"-\"), nameCache[r] ? (nameCache[r]++, r += \"-\" + nameCache[r]) : nameCache[r] = 1, this.vertexSrc = \"#define SHADER_NAME \" + r + `\n` + this.vertexSrc, this.fragmentSrc = \"#define SHADER_NAME \" + r + `\n` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;\n    }\n    return Object.defineProperty(o, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source.\n       * @constant\n       */\n      get: function() {\n        return defaultVertex$3;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"defaultFragmentSrc\", {\n      /**\n       * The default fragment shader source.\n       * @constant\n       */\n      get: function() {\n        return defaultFragment$2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.from = function(t, e, r) {\n      var D = t + e, N = ProgramCache[D];\n      return N || (ProgramCache[D] = N = new o(t, e, r)), N;\n    }, o;\n  }()\n), Shader = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner(\"disposeShader\");\n    }\n    return o.prototype.checkUniformExists = function(t, e) {\n      if (e.uniforms[t])\n        return !0;\n      for (var r in e.uniforms) {\n        var D = e.uniforms[r];\n        if (D.group && this.checkUniformExists(t, D))\n          return !0;\n      }\n      return !1;\n    }, o.prototype.destroy = function() {\n      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();\n    }, Object.defineProperty(o.prototype, \"uniforms\", {\n      /**\n       * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n       * @readonly\n       */\n      get: function() {\n        return this.uniformGroup.uniforms;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.from = function(t, e, r) {\n      var D = Program.from(t, e);\n      return new o(D, r);\n    }, o;\n  }()\n), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = (\n  /** @class */\n  function() {\n    function o() {\n      this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n    }\n    return Object.defineProperty(o.prototype, \"blend\", {\n      /**\n       * Activates blending of the computed fragment color values.\n       * @default true\n       */\n      get: function() {\n        return !!(this.data & 1 << BLEND$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"offsets\", {\n      /**\n       * Activates adding an offset to depth values of polygon's fragments\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << OFFSET$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"culling\", {\n      /**\n       * Activates culling of polygons.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << CULLING$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"depthTest\", {\n      /**\n       * Activates depth comparisons and updates to the depth buffer.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << DEPTH_TEST$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"depthMask\", {\n      /**\n       * Enables or disables writing to the depth buffer.\n       * @default true\n       */\n      get: function() {\n        return !!(this.data & 1 << DEPTH_MASK$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"clockwiseFrontFace\", {\n      /**\n       * Specifies whether or not front or back-facing polygons can be culled.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << WINDING$1);\n      },\n      set: function(t) {\n        !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"blendMode\", {\n      /**\n       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      get: function() {\n        return this._blendMode;\n      },\n      set: function(t) {\n        this.blend = t !== BLEND_MODES.NONE, this._blendMode = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"polygonOffset\", {\n      /**\n       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n       * @default 0\n       */\n      get: function() {\n        return this._polygonOffset;\n      },\n      set: function(t) {\n        this.offsets = !!t, this._polygonOffset = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.toString = function() {\n      return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n    }, o.for2d = function() {\n      var t = new o();\n      return t.depthTest = !1, t.blend = !0, t;\n    }, o;\n  }()\n), defaultFragment$1 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`, defaultVertex$2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, Filter = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r, D) {\n      var N = this, k = Program.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);\n      return N = o.call(this, k, D) || this, N.padding = 0, N.resolution = settings.FILTER_RESOLUTION, N.multisample = settings.FILTER_MULTISAMPLE, N.enabled = !0, N.autoFit = !0, N.state = new State(), N;\n    }\n    return t.prototype.apply = function(e, r, D, N, k) {\n      e.applyFilter(this, r, D, N);\n    }, Object.defineProperty(t.prototype, \"blendMode\", {\n      /**\n       * Sets the blend mode of the filter.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      get: function() {\n        return this.state.blendMode;\n      },\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * The resolution of the filter. Setting this to be lower will lower the quality but\n       * increase the performance of the filter.\n       */\n      get: function() {\n        return this._resolution;\n      },\n      set: function(e) {\n        this._resolution = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source\n       * @constant\n       */\n      get: function() {\n        return defaultVertex$2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"defaultFragmentSrc\", {\n      /**\n       * The default fragment shader source\n       * @constant\n       */\n      get: function() {\n        return defaultFragment$1;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Shader)\n), vertex$4 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`, fragment$7 = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`, tempMat$1 = new Matrix(), TextureMatrix = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > \"u\" ? 0.5 : e, this.isSimple = !1;\n    }\n    return Object.defineProperty(o.prototype, \"texture\", {\n      /** Texture property. */\n      get: function() {\n        return this._texture;\n      },\n      set: function(t) {\n        this._texture = t, this._textureID = -1;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.multiplyUvs = function(t, e) {\n      e === void 0 && (e = t);\n      for (var r = this.mapCoord, D = 0; D < t.length; D += 2) {\n        var N = t[D], k = t[D + 1];\n        e[D] = N * r.a + k * r.c + r.tx, e[D + 1] = N * r.b + k * r.d + r.ty;\n      }\n      return e;\n    }, o.prototype.update = function(t) {\n      var e = this._texture;\n      if (!e || !e.valid || !t && this._textureID === e._updateID)\n        return !1;\n      this._textureID = e._updateID, this._updateID++;\n      var r = e._uvs;\n      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);\n      var D = e.orig, N = e.trim;\n      N && (tempMat$1.set(D.width / N.width, 0, 0, D.height / N.height, -N.x / N.width, -N.y / N.height), this.mapCoord.append(tempMat$1));\n      var k = e.baseTexture, $ = this.uClampFrame, G = this.clampMargin / k.resolution, U = this.clampOffset;\n      return $[0] = (e._frame.x + G + U) / k.width, $[1] = (e._frame.y + G + U) / k.height, $[2] = (e._frame.x + e._frame.width - G + U) / k.width, $[3] = (e._frame.y + e._frame.height - G + U) / k.height, this.uClampOffset[0] = U / k.realWidth, this.uClampOffset[1] = U / k.realHeight, this.isSimple = e._frame.width === k.width && e._frame.height === k.height && e.rotate === 0, !0;\n    }, o;\n  }()\n), SpriteMaskFilter = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r, D) {\n      var N = this, k = null;\n      return typeof e != \"string\" && r === void 0 && D === void 0 && (k = e, e = void 0, r = void 0, D = void 0), N = o.call(this, e || vertex$4, r || fragment$7, D) || this, N.maskSprite = k, N.maskMatrix = new Matrix(), N;\n    }\n    return Object.defineProperty(t.prototype, \"maskSprite\", {\n      /**\n       * Sprite mask\n       * @type {PIXI.DisplayObject}\n       */\n      get: function() {\n        return this._maskSprite;\n      },\n      set: function(e) {\n        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.apply = function(e, r, D, N) {\n      var k = this._maskSprite, $ = k._texture;\n      $.valid && ($.uvMatrix || ($.uvMatrix = new TextureMatrix($, 0)), $.uvMatrix.update(), this.uniforms.npmAlpha = $.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = $, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, k).prepend($.uvMatrix.mapCoord), this.uniforms.alpha = k.worldAlpha, this.uniforms.maskClamp = $.uvMatrix.uClampFrame, e.applyFilter(this, r, D, N));\n    }, t;\n  }(Filter)\n), MaskSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n    }\n    return o.prototype.setMaskStack = function(t) {\n      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);\n    }, o.prototype.push = function(t, e) {\n      var r = e;\n      if (!r.isMaskData) {\n        var D = this.maskDataPool.pop() || new MaskData();\n        D.pooled = !0, D.maskObject = e, r = D;\n      }\n      var N = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      if (r.copyCountersOrReset(N), r._colorMask = N ? N._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled)\n        switch (r.type) {\n          case MASK_TYPES.SCISSOR:\n            this.renderer.scissor.push(r);\n            break;\n          case MASK_TYPES.STENCIL:\n            this.renderer.stencil.push(r);\n            break;\n          case MASK_TYPES.SPRITE:\n            r.copyCountersOrReset(null), this.pushSpriteMask(r);\n            break;\n          case MASK_TYPES.COLOR:\n            this.pushColorMask(r);\n            break;\n        }\n      r.type === MASK_TYPES.SPRITE && this.maskStack.push(r);\n    }, o.prototype.pop = function(t) {\n      var e = this.maskStack.pop();\n      if (!(!e || e._target !== t)) {\n        if (e.enabled)\n          switch (e.type) {\n            case MASK_TYPES.SCISSOR:\n              this.renderer.scissor.pop(e);\n              break;\n            case MASK_TYPES.STENCIL:\n              this.renderer.stencil.pop(e.maskObject);\n              break;\n            case MASK_TYPES.SPRITE:\n              this.popSpriteMask(e);\n              break;\n            case MASK_TYPES.COLOR:\n              this.popColorMask(e);\n              break;\n          }\n        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {\n          var r = this.maskStack[this.maskStack.length - 1];\n          r.type === MASK_TYPES.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);\n        }\n      }\n    }, o.prototype.detect = function(t) {\n      var e = t.maskObject;\n      e ? e.isSprite ? t.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES.SCISSOR : t.type = MASK_TYPES.STENCIL : t.type = MASK_TYPES.COLOR;\n    }, o.prototype.pushSpriteMask = function(t) {\n      var e, r, D = t.maskObject, N = t._target, k = t._filters;\n      k || (k = this.alphaMaskPool[this.alphaMaskIndex], k || (k = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));\n      var $ = this.renderer, G = $.renderTexture, U, z;\n      if (G.current) {\n        var X = G.current;\n        U = t.resolution || X.resolution, z = (e = t.multisample) !== null && e !== void 0 ? e : X.multisample;\n      } else\n        U = t.resolution || $.resolution, z = (r = t.multisample) !== null && r !== void 0 ? r : $.multisample;\n      k[0].resolution = U, k[0].multisample = z, k[0].maskSprite = D;\n      var V = N.filterArea;\n      N.filterArea = D.getBounds(!0), $.filter.push(N, k), N.filterArea = V, t._filters || this.alphaMaskIndex++;\n    }, o.prototype.popSpriteMask = function(t) {\n      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n    }, o.prototype.pushColorMask = function(t) {\n      var e = t._colorMask, r = t._colorMask = e & t.colorMask;\n      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n    }, o.prototype.popColorMask = function(t) {\n      var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), AbstractMaskSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.maskStack = [], this.glConst = 0;\n    }\n    return o.prototype.getStackLength = function() {\n      return this.maskStack.length;\n    }, o.prototype.setMaskStack = function(t) {\n      var e = this.renderer.gl, r = this.getStackLength();\n      this.maskStack = t;\n      var D = this.getStackLength();\n      D !== r && (D === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));\n    }, o.prototype._useCurrent = function() {\n    }, o.prototype.destroy = function() {\n      this.renderer = null, this.maskStack = null;\n    }, o;\n  }()\n), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return r.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;\n    }\n    return t.prototype.getStackLength = function() {\n      var e = this.maskStack[this.maskStack.length - 1];\n      return e ? e._scissorCounter : 0;\n    }, t.prototype.calcScissorRect = function(e) {\n      var r;\n      if (!e._scissorRectLocal) {\n        var D = e._scissorRect, N = e.maskObject, k = this.renderer, $ = k.renderTexture, G = N.getBounds(!0, (r = rectPool.pop()) !== null && r !== void 0 ? r : new Rectangle());\n        this.roundFrameToPixels(G, $.current ? $.current.resolution : k.resolution, $.sourceFrame, $.destinationFrame, k.projection.transform), D && G.fit(D), e._scissorRectLocal = G;\n      }\n    }, t.isMatrixRotated = function(e) {\n      if (!e)\n        return !1;\n      var r = e.a, D = e.b, N = e.c, k = e.d;\n      return (Math.abs(D) > 1e-4 || Math.abs(N) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(k) > 1e-4);\n    }, t.prototype.testScissor = function(e) {\n      var r = e.maskObject;\n      if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))\n        return !1;\n      this.calcScissorRect(e);\n      var D = e._scissorRectLocal;\n      return D.width > 0 && D.height > 0;\n    }, t.prototype.roundFrameToPixels = function(e, r, D, N, k) {\n      t.isMatrixRotated(k) || (k = k ? tempMatrix$1.copyFrom(k) : tempMatrix$1.identity(), k.translate(-D.x, -D.y).scale(N.width / D.width, N.height / D.height).translate(N.x, N.y), this.renderer.filter.transformAABB(k, e), e.fit(N), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));\n    }, t.prototype.push = function(e) {\n      e._scissorRectLocal || this.calcScissorRect(e);\n      var r = this.renderer.gl;\n      e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();\n    }, t.prototype.pop = function(e) {\n      var r = this.renderer.gl;\n      e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);\n    }, t.prototype._useCurrent = function() {\n      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;\n      this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);\n    }, t;\n  }(AbstractMaskSystem)\n), StencilSystem = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return r.glConst = settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;\n    }\n    return t.prototype.getStackLength = function() {\n      var e = this.maskStack[this.maskStack.length - 1];\n      return e ? e._stencilCounter : 0;\n    }, t.prototype.push = function(e) {\n      var r = e.maskObject, D = this.renderer.gl, N = e._stencilCounter;\n      N === 0 && (this.renderer.framebuffer.forceStencil(), D.clearStencil(0), D.clear(D.STENCIL_BUFFER_BIT), D.enable(D.STENCIL_TEST)), e._stencilCounter++;\n      var k = e._colorMask;\n      k !== 0 && (e._colorMask = 0, D.colorMask(!1, !1, !1, !1)), D.stencilFunc(D.EQUAL, N, 4294967295), D.stencilOp(D.KEEP, D.KEEP, D.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, k !== 0 && (e._colorMask = k, D.colorMask((k & 1) !== 0, (k & 2) !== 0, (k & 4) !== 0, (k & 8) !== 0)), this._useCurrent();\n    }, t.prototype.pop = function(e) {\n      var r = this.renderer.gl;\n      if (this.getStackLength() === 0)\n        r.disable(r.STENCIL_TEST);\n      else {\n        var D = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, N = D ? D._colorMask : 15;\n        N !== 0 && (D._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, N !== 0 && (D._colorMask = N, r.colorMask((N & 1) !== 0, (N & 2) !== 0, (N & 4) !== 0, (N & 8) !== 0)), this._useCurrent();\n      }\n    }, t.prototype._useCurrent = function() {\n      var e = this.renderer.gl;\n      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);\n    }, t;\n  }(AbstractMaskSystem)\n), ProjectionSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;\n    }\n    return o.prototype.update = function(t, e, r, D) {\n      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, D), this.transform && this.projectionMatrix.append(this.transform);\n      var N = this.renderer;\n      N.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, N.globalUniforms.update(), N.shader.shader && N.shader.syncUniformGroup(N.shader.shader.uniforms.globals);\n    }, o.prototype.calculateProjection = function(t, e, r, D) {\n      var N = this.projectionMatrix, k = D ? -1 : 1;\n      N.identity(), N.a = 1 / e.width * 2, N.d = k * (1 / e.height * 2), N.tx = -1 - e.x * N.a, N.ty = -k - e.y * N.d;\n    }, o.prototype.setTransform = function(t) {\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();\n    }\n    return o.prototype.bind = function(t, e, r) {\n      t === void 0 && (t = null);\n      var D = this.renderer;\n      this.current = t;\n      var N, k, $;\n      t ? (N = t.baseTexture, $ = N.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), r || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, r = tempRect2), k = N.framebuffer) : ($ = D.resolution, e || (tempRect.width = D.screen.width, tempRect.height = D.screen.height, e = tempRect), r || (r = tempRect, r.width = e.width, r.height = e.height));\n      var G = this.viewportFrame;\n      G.x = r.x * $, G.y = r.y * $, G.width = r.width * $, G.height = r.height * $, t || (G.y = D.view.height - (G.y + G.height)), G.ceil(), this.renderer.framebuffer.bind(k, G), this.renderer.projection.update(r, e, $, !k), t ? this.renderer.mask.setMaskStack(N.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);\n    }, o.prototype.clear = function(t, e) {\n      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;\n      var r = this.destinationFrame, D = this.current ? this.current.baseTexture : this.renderer.screen, N = r.width !== D.width || r.height !== D.height;\n      if (N) {\n        var k = this.viewportFrame, $ = k.x, G = k.y, U = k.width, z = k.height;\n        $ = Math.round($), G = Math.round(G), U = Math.round(U), z = Math.round(z), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor($, G, U, z);\n      }\n      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), N && this.renderer.scissor.pop();\n    }, o.prototype.resize = function() {\n      this.bind(null);\n    }, o.prototype.reset = function() {\n      this.bind(null);\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n);\nfunction uboUpdate(o, t, e, r, D) {\n  e.buffer.update(D);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(o) {\n  for (var t = o.map(function(G) {\n    return {\n      data: G,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  }), e = 0, r = 0, D = 0, N = 0; N < t.length; N++) {\n    var k = t[N];\n    if (e = GLSL_TO_STD40_SIZE[k.data.type], k.data.size > 1 && (e = Math.max(e, 16) * k.data.size), k.dataLen = e, r % e !== 0 && r < 16) {\n      var $ = r % e % 16;\n      r += $, D += $;\n    }\n    r + e > 16 ? (D = Math.ceil(D / 16) * 16, k.offset = D, D += e, r = e) : (k.offset = D, r += e, D += e);\n  }\n  return D = Math.ceil(D / 16) * 16, { uboElements: t, size: D };\n}\nfunction getUBOData(o, t) {\n  var e = [];\n  for (var r in o)\n    t[r] && e.push(t[r]);\n  return e.sort(function(D, N) {\n    return D.index - N.index;\n  }), e;\n}\nfunction generateUniformBufferSync(o, t) {\n  if (!o.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  for (var e = getUBOData(o.uniforms, t), r = createUBOElements(e), D = r.uboElements, N = r.size, k = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `], $ = 0; $ < D.length; $++) {\n    for (var G = D[$], U = o.uniforms[G.data.name], z = G.data.name, X = !1, V = 0; V < uniformParsers.length; V++) {\n      var Y = uniformParsers[V];\n      if (Y.codeUbo && Y.test(G.data, U)) {\n        k.push(\"offset = \" + G.offset / 4 + \";\", uniformParsers[V].codeUbo(G.data.name, U)), X = !0;\n        break;\n      }\n    }\n    if (!X)\n      if (G.data.size > 1) {\n        var q = mapSize(G.data.type), W = Math.max(GLSL_TO_STD40_SIZE[G.data.type] / 16, 1), K = q / W, Z = (4 - K % 4) % 4;\n        k.push(`\n                cv = ud.` + z + `.value;\n                v = uv.` + z + `;\n                offset = ` + G.offset / 4 + `;\n\n                t = 0;\n\n                for(var i=0; i < ` + G.data.size * W + `; i++)\n                {\n                    for(var j = 0; j < ` + K + `; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ` + Z + `;\n                }\n\n                `);\n      } else {\n        var J = UBO_TO_SINGLE_SETTERS[G.data.type];\n        k.push(`\n                cv = ud.` + z + `.value;\n                v = uv.` + z + `;\n                offset = ` + G.offset / 4 + `;\n                ` + J + `;\n                `);\n      }\n  }\n  return k.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size: N,\n    // eslint-disable-next-line no-new-func\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", k.join(`\n`))\n  };\n}\nvar IGLUniformData = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o;\n  }()\n), GLProgram = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n    }\n    return o.prototype.destroy = function() {\n      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n    }, o;\n  }()\n);\nfunction getAttributeData(o, t) {\n  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_ATTRIBUTES), D = 0; D < r; D++) {\n    var N = t.getActiveAttrib(o, D);\n    if (N.name.indexOf(\"gl_\") !== 0) {\n      var k = mapType(t, N.type), $ = {\n        type: k,\n        name: N.name,\n        size: mapSize(k),\n        location: t.getAttribLocation(o, N.name)\n      };\n      e[N.name] = $;\n    }\n  }\n  return e;\n}\nfunction getUniformData(o, t) {\n  for (var e = {}, r = t.getProgramParameter(o, t.ACTIVE_UNIFORMS), D = 0; D < r; D++) {\n    var N = t.getActiveUniform(o, D), k = N.name.replace(/\\[.*?\\]$/, \"\"), $ = !!N.name.match(/\\[.*?\\]$/), G = mapType(t, N.type);\n    e[k] = {\n      name: k,\n      index: D,\n      type: G,\n      size: N.size,\n      isArray: $,\n      value: defaultValue(G, N.size)\n    };\n  }\n  return e;\n}\nfunction generateProgram(o, t) {\n  var e = compileShader(o, o.VERTEX_SHADER, t.vertexSrc), r = compileShader(o, o.FRAGMENT_SHADER, t.fragmentSrc), D = o.createProgram();\n  if (o.attachShader(D, e), o.attachShader(D, r), o.linkProgram(D), o.getProgramParameter(D, o.LINK_STATUS) || logProgramError(o, D, e, r), t.attributeData = getAttributeData(D, o), t.uniformData = getUniformData(D, o), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(t.vertexSrc)) {\n    var N = Object.keys(t.attributeData);\n    N.sort(function(z, X) {\n      return z > X ? 1 : -1;\n    });\n    for (var k = 0; k < N.length; k++)\n      t.attributeData[N[k]].location = k, o.bindAttribLocation(D, k, N[k]);\n    o.linkProgram(D);\n  }\n  o.deleteShader(e), o.deleteShader(r);\n  var $ = {};\n  for (var k in t.uniformData) {\n    var G = t.uniformData[k];\n    $[k] = {\n      location: o.getUniformLocation(D, k),\n      value: defaultValue(G.type, G.size)\n    };\n  }\n  var U = new GLProgram(D, $);\n  return U;\n}\nvar UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;\n    }\n    return o.prototype.systemCheck = function() {\n      if (!unsafeEvalSupported())\n        throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n    }, o.prototype.contextChange = function(t) {\n      this.gl = t, this.reset();\n    }, o.prototype.bind = function(t, e) {\n      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;\n      var r = t.program, D = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);\n      return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(D.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), D;\n    }, o.prototype.setUniforms = function(t) {\n      var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];\n      e.syncUniforms(r.uniformData, t, this.renderer);\n    }, o.prototype.syncUniformGroup = function(t, e) {\n      var r = this.getGlProgram();\n      (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));\n    }, o.prototype.syncUniforms = function(t, e, r) {\n      var D = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);\n      D(e.uniformData, t.uniforms, this.renderer, r);\n    }, o.prototype.createSyncGroups = function(t) {\n      var e = this.getSignature(t, this.shader.program.uniformData, \"u\");\n      return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];\n    }, o.prototype.syncUniformBufferGroup = function(t, e) {\n      var r = this.getGlProgram();\n      if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {\n        t.dirtyId = 0;\n        var D = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);\n        t.buffer.update(), D(r.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);\n      }\n      this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);\n    }, o.prototype.createSyncBufferGroup = function(t, e, r) {\n      var D = this.renderer.gl;\n      this.renderer.buffer.bind(t.buffer);\n      var N = this.gl.getUniformBlockIndex(e.program, r);\n      e.uniformBufferBindings[r] = this.shader.uniformBindCount, D.uniformBlockBinding(e.program, N, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n      var k = this.getSignature(t, this.shader.program.uniformData, \"ubo\"), $ = this._uboCache[k];\n      if ($ || ($ = this._uboCache[k] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {\n        var G = new Float32Array($.size / 4);\n        t.buffer.update(G);\n      }\n      return e.uniformGroups[t.id] = $.syncFunc, e.uniformGroups[t.id];\n    }, o.prototype.getSignature = function(t, e, r) {\n      var D = t.uniforms, N = [r + \"-\"];\n      for (var k in D)\n        N.push(k), e[k] && N.push(e[k].type);\n      return N.join(\"-\");\n    }, o.prototype.getGlProgram = function() {\n      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n    }, o.prototype.generateProgram = function(t) {\n      var e = this.gl, r = t.program, D = generateProgram(e, r);\n      return r.glPrograms[this.renderer.CONTEXT_UID] = D, D;\n    }, o.prototype.reset = function() {\n      this.program = null, this.shader = null;\n    }, o.prototype.disposeShader = function(t) {\n      this.shader === t && (this.shader = null);\n    }, o.prototype.destroy = function() {\n      this.renderer = null, this.destroyed = !0;\n    }, o;\n  }()\n);\nfunction mapWebGLBlendModesToPixi(o, t) {\n  return t === void 0 && (t = []), t[BLEND_MODES.NORMAL] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD] = [o.ONE, o.ONE], t[BLEND_MODES.MULTIPLY] = [o.DST_COLOR, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SCREEN] = [o.ONE, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.OVERLAY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DARKEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LIGHTEN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_DODGE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR_BURN] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HARD_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SOFT_LIGHT] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DIFFERENCE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.EXCLUSION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.HUE] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SATURATION] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.COLOR] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.LUMINOSITY] = [o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.NONE] = [0, 0], t[BLEND_MODES.NORMAL_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.ADD_NPM] = [o.SRC_ALPHA, o.ONE, o.ONE, o.ONE], t[BLEND_MODES.SCREEN_NPM] = [o.SRC_ALPHA, o.ONE_MINUS_SRC_COLOR, o.ONE, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SRC_IN] = [o.DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_OUT] = [o.ONE_MINUS_DST_ALPHA, o.ZERO], t[BLEND_MODES.SRC_ATOP] = [o.DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_OVER] = [o.ONE_MINUS_DST_ALPHA, o.ONE], t[BLEND_MODES.DST_IN] = [o.ZERO, o.SRC_ALPHA], t[BLEND_MODES.DST_OUT] = [o.ZERO, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.DST_ATOP] = [o.ONE_MINUS_DST_ALPHA, o.SRC_ALPHA], t[BLEND_MODES.XOR] = [o.ONE_MINUS_DST_ALPHA, o.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES.SUBTRACT] = [o.ONE, o.ONE, o.ONE, o.ONE, o.FUNC_REVERSE_SUBTRACT, o.FUNC_ADD], t;\n}\nvar BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = (\n  /** @class */\n  function() {\n    function o() {\n      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;\n    }\n    return o.prototype.contextChange = function(t) {\n      this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();\n    }, o.prototype.set = function(t) {\n      if (t = t || this.defaultState, this.stateId !== t.data) {\n        for (var e = this.stateId ^ t.data, r = 0; e; )\n          e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;\n        this.stateId = t.data;\n      }\n      for (var r = 0; r < this.checks.length; r++)\n        this.checks[r](this, t);\n    }, o.prototype.forceState = function(t) {\n      t = t || this.defaultState;\n      for (var e = 0; e < this.map.length; e++)\n        this.map[e].call(this, !!(t.data & 1 << e));\n      for (var e = 0; e < this.checks.length; e++)\n        this.checks[e](this, t);\n      this.stateId = t.data;\n    }, o.prototype.setBlend = function(t) {\n      this.updateCheck(o.checkBlendMode, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.BLEND);\n    }, o.prototype.setOffset = function(t) {\n      this.updateCheck(o.checkPolygonOffset, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n    }, o.prototype.setDepthTest = function(t) {\n      this.gl[t ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n    }, o.prototype.setDepthMask = function(t) {\n      this.gl.depthMask(t);\n    }, o.prototype.setCullFace = function(t) {\n      this.gl[t ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n    }, o.prototype.setFrontFace = function(t) {\n      this.gl.frontFace(this.gl[t ? \"CW\" : \"CCW\"]);\n    }, o.prototype.setBlendMode = function(t) {\n      if (t !== this.blendMode) {\n        this.blendMode = t;\n        var e = this.blendModes[t], r = this.gl;\n        e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));\n      }\n    }, o.prototype.setPolygonOffset = function(t, e) {\n      this.gl.polygonOffset(t, e);\n    }, o.prototype.reset = function() {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n    }, o.prototype.updateCheck = function(t, e) {\n      var r = this.checks.indexOf(t);\n      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);\n    }, o.checkBlendMode = function(t, e) {\n      t.setBlendMode(e.blendMode);\n    }, o.checkPolygonOffset = function(t, e) {\n      t.setPolygonOffset(1, e.polygonOffset);\n    }, o.prototype.destroy = function() {\n      this.gl = null;\n    }, o;\n  }()\n), TextureGCSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings.GC_MAX_IDLE, this.checkCountMax = settings.GC_MAX_CHECK_COUNT, this.mode = settings.GC_MODE;\n    }\n    return o.prototype.postrender = function() {\n      this.renderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n    }, o.prototype.run = function() {\n      for (var t = this.renderer.texture, e = t.managedTextures, r = !1, D = 0; D < e.length; D++) {\n        var N = e[D];\n        !N.framebuffer && this.count - N.touched > this.maxIdle && (t.destroyTexture(N, !0), e[D] = null, r = !0);\n      }\n      if (r) {\n        for (var k = 0, D = 0; D < e.length; D++)\n          e[D] !== null && (e[k++] = e[D]);\n        e.length = k;\n      }\n    }, o.prototype.unload = function(t) {\n      var e = this.renderer.texture, r = t._texture;\n      r && !r.framebuffer && e.destroyTexture(r);\n      for (var D = t.children.length - 1; D >= 0; D--)\n        this.unload(t.children[D]);\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n);\nfunction mapTypeAndFormatToInternalFormat(o) {\n  var t, e, r, D, N, k, $, G, U, z, X, V, Y, q, W, K, Z, J, Q, et, nt, tt, it;\n  return \"WebGL2RenderingContext\" in globalThis && o instanceof globalThis.WebGL2RenderingContext ? it = (t = {}, t[TYPES.UNSIGNED_BYTE] = (e = {}, e[FORMATS.RGBA] = o.RGBA8, e[FORMATS.RGB] = o.RGB8, e[FORMATS.RG] = o.RG8, e[FORMATS.RED] = o.R8, e[FORMATS.RGBA_INTEGER] = o.RGBA8UI, e[FORMATS.RGB_INTEGER] = o.RGB8UI, e[FORMATS.RG_INTEGER] = o.RG8UI, e[FORMATS.RED_INTEGER] = o.R8UI, e[FORMATS.ALPHA] = o.ALPHA, e[FORMATS.LUMINANCE] = o.LUMINANCE, e[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, e), t[TYPES.BYTE] = (r = {}, r[FORMATS.RGBA] = o.RGBA8_SNORM, r[FORMATS.RGB] = o.RGB8_SNORM, r[FORMATS.RG] = o.RG8_SNORM, r[FORMATS.RED] = o.R8_SNORM, r[FORMATS.RGBA_INTEGER] = o.RGBA8I, r[FORMATS.RGB_INTEGER] = o.RGB8I, r[FORMATS.RG_INTEGER] = o.RG8I, r[FORMATS.RED_INTEGER] = o.R8I, r), t[TYPES.UNSIGNED_SHORT] = (D = {}, D[FORMATS.RGBA_INTEGER] = o.RGBA16UI, D[FORMATS.RGB_INTEGER] = o.RGB16UI, D[FORMATS.RG_INTEGER] = o.RG16UI, D[FORMATS.RED_INTEGER] = o.R16UI, D[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT16, D), t[TYPES.SHORT] = (N = {}, N[FORMATS.RGBA_INTEGER] = o.RGBA16I, N[FORMATS.RGB_INTEGER] = o.RGB16I, N[FORMATS.RG_INTEGER] = o.RG16I, N[FORMATS.RED_INTEGER] = o.R16I, N), t[TYPES.UNSIGNED_INT] = (k = {}, k[FORMATS.RGBA_INTEGER] = o.RGBA32UI, k[FORMATS.RGB_INTEGER] = o.RGB32UI, k[FORMATS.RG_INTEGER] = o.RG32UI, k[FORMATS.RED_INTEGER] = o.R32UI, k[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT24, k), t[TYPES.INT] = ($ = {}, $[FORMATS.RGBA_INTEGER] = o.RGBA32I, $[FORMATS.RGB_INTEGER] = o.RGB32I, $[FORMATS.RG_INTEGER] = o.RG32I, $[FORMATS.RED_INTEGER] = o.R32I, $), t[TYPES.FLOAT] = (G = {}, G[FORMATS.RGBA] = o.RGBA32F, G[FORMATS.RGB] = o.RGB32F, G[FORMATS.RG] = o.RG32F, G[FORMATS.RED] = o.R32F, G[FORMATS.DEPTH_COMPONENT] = o.DEPTH_COMPONENT32F, G), t[TYPES.HALF_FLOAT] = (U = {}, U[FORMATS.RGBA] = o.RGBA16F, U[FORMATS.RGB] = o.RGB16F, U[FORMATS.RG] = o.RG16F, U[FORMATS.RED] = o.R16F, U), t[TYPES.UNSIGNED_SHORT_5_6_5] = (z = {}, z[FORMATS.RGB] = o.RGB565, z), t[TYPES.UNSIGNED_SHORT_4_4_4_4] = (X = {}, X[FORMATS.RGBA] = o.RGBA4, X), t[TYPES.UNSIGNED_SHORT_5_5_5_1] = (V = {}, V[FORMATS.RGBA] = o.RGB5_A1, V), t[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (Y = {}, Y[FORMATS.RGBA] = o.RGB10_A2, Y[FORMATS.RGBA_INTEGER] = o.RGB10_A2UI, Y), t[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (q = {}, q[FORMATS.RGB] = o.R11F_G11F_B10F, q), t[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (W = {}, W[FORMATS.RGB] = o.RGB9_E5, W), t[TYPES.UNSIGNED_INT_24_8] = (K = {}, K[FORMATS.DEPTH_STENCIL] = o.DEPTH24_STENCIL8, K), t[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Z = {}, Z[FORMATS.DEPTH_STENCIL] = o.DEPTH32F_STENCIL8, Z), t) : it = (J = {}, J[TYPES.UNSIGNED_BYTE] = (Q = {}, Q[FORMATS.RGBA] = o.RGBA, Q[FORMATS.RGB] = o.RGB, Q[FORMATS.ALPHA] = o.ALPHA, Q[FORMATS.LUMINANCE] = o.LUMINANCE, Q[FORMATS.LUMINANCE_ALPHA] = o.LUMINANCE_ALPHA, Q), J[TYPES.UNSIGNED_SHORT_5_6_5] = (et = {}, et[FORMATS.RGB] = o.RGB, et), J[TYPES.UNSIGNED_SHORT_4_4_4_4] = (nt = {}, nt[FORMATS.RGBA] = o.RGBA, nt), J[TYPES.UNSIGNED_SHORT_5_5_5_1] = (tt = {}, tt[FORMATS.RGBA] = o.RGBA, tt), J), it;\n}\nvar GLTexture = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;\n    }\n    return o;\n  }()\n), TextureSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n    }\n    return o.prototype.contextChange = function() {\n      var t = this.gl = this.renderer.gl;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);\n      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);\n      this.boundTextures.length = e;\n      for (var r = 0; r < e; r++)\n        this.boundTextures[r] = null;\n      this.emptyTextures = {};\n      var D = new GLTexture(t.createTexture());\n      t.bindTexture(t.TEXTURE_2D, D.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = D, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);\n      for (var r = 0; r < 6; r++)\n        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);\n      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);\n      for (var r = 0; r < this.boundTextures.length; r++)\n        this.bind(null, r);\n    }, o.prototype.bind = function(t, e) {\n      e === void 0 && (e = 0);\n      var r = this.gl;\n      if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {\n        t.touched = this.renderer.textureGC.count;\n        var D = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);\n        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, D.texture)), D.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : D.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;\n      } else\n        this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;\n    }, o.prototype.reset = function() {\n      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n      for (var t = 0; t < this.boundTextures.length; t++)\n        this.boundTextures[t] = this.unknownTexture;\n    }, o.prototype.unbind = function(t) {\n      var e = this, r = e.gl, D = e.boundTextures;\n      if (this._unknownBoundTextures) {\n        this._unknownBoundTextures = !1;\n        for (var N = 0; N < D.length; N++)\n          D[N] === this.unknownTexture && this.bind(null, N);\n      }\n      for (var N = 0; N < D.length; N++)\n        D[N] === t && (this.currentLocation !== N && (r.activeTexture(r.TEXTURE0 + N), this.currentLocation = N), r.bindTexture(t.target, this.emptyTextures[t.target].texture), D[N] = null);\n    }, o.prototype.ensureSamplerType = function(t) {\n      var e = this, r = e.boundTextures, D = e.hasIntegerTextures, N = e.CONTEXT_UID;\n      if (D)\n        for (var k = t - 1; k >= 0; --k) {\n          var $ = r[k];\n          if ($) {\n            var G = $._glTextures[N];\n            G.samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind($);\n          }\n        }\n    }, o.prototype.initTexture = function(t) {\n      var e = new GLTexture(this.gl.createTexture());\n      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on(\"dispose\", this.destroyTexture, this), e;\n    }, o.prototype.initTextureType = function(t, e) {\n      var r, D;\n      e.internalFormat = (D = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && D !== void 0 ? D : t.format, this.webGLVersion === 2 && t.type === TYPES.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;\n    }, o.prototype.updateTexture = function(t) {\n      var e = t._glTextures[this.CONTEXT_UID];\n      if (e) {\n        var r = this.renderer;\n        if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))\n          e.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);\n        else {\n          var D = t.realWidth, N = t.realHeight, k = r.gl;\n          (e.width !== D || e.height !== N || e.dirtyId < 0) && (e.width = D, e.height = N, k.texImage2D(t.target, 0, e.internalFormat, D, N, 0, t.format, e.type, null));\n        }\n        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;\n      }\n    }, o.prototype.destroyTexture = function(t, e) {\n      var r = this.gl;\n      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off(\"dispose\", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {\n        var D = this.managedTextures.indexOf(t);\n        D !== -1 && removeItems(this.managedTextures, D, 1);\n      }\n    }, o.prototype.updateTextureStyle = function(t) {\n      var e = t._glTextures[this.CONTEXT_UID];\n      e && ((t.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);\n    }, o.prototype.setStyle = function(t, e) {\n      var r = this.gl;\n      if (e.mipmap && t.mipmap !== MIPMAP_MODES.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {\n        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);\n        var D = this.renderer.context.extensions.anisotropicFiltering;\n        if (D && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES.LINEAR) {\n          var N = Math.min(t.anisotropicLevel, r.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n          r.texParameterf(t.target, D.TEXTURE_MAX_ANISOTROPY_EXT, N);\n        }\n      } else\n        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);\n      r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), _systems = {\n  __proto__: null,\n  FilterSystem,\n  BatchSystem,\n  ContextSystem,\n  FramebufferSystem,\n  GeometrySystem,\n  MaskSystem,\n  ScissorSystem,\n  StencilSystem,\n  ProjectionSystem,\n  RenderTextureSystem,\n  ShaderSystem,\n  StateSystem,\n  TextureGCSystem,\n  TextureSystem\n}, tempMatrix = new Matrix(), AbstractRenderer = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e, r) {\n      e === void 0 && (e = RENDERER_TYPE.UNKNOWN);\n      var D = o.call(this) || this;\n      return r = Object.assign({}, settings.RENDER_OPTIONS, r), D.options = r, D.type = e, D.screen = new Rectangle(0, 0, r.width, r.height), D.view = r.view || settings.ADAPTER.createCanvas(), D.resolution = r.resolution || settings.RESOLUTION, D.useContextAlpha = r.useContextAlpha, D.autoDensity = !!r.autoDensity, D.preserveDrawingBuffer = r.preserveDrawingBuffer, D.clearBeforeRender = r.clearBeforeRender, D._backgroundColor = 0, D._backgroundColorRgba = [0, 0, 0, 1], D._backgroundColorString = \"#000000\", D.backgroundColor = r.backgroundColor || D._backgroundColor, D.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (deprecation(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\"), D.useContextAlpha = r.transparent, D.backgroundAlpha = r.transparent ? 0 : 1), D._lastObjectRendered = null, D.plugins = {}, D;\n    }\n    return t.prototype.initPlugins = function(e) {\n      for (var r in e)\n        this.plugins[r] = new e[r](this);\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /**\n       * Same as view.width, actual number of pixels in the canvas by horizontal.\n       * @member {number}\n       * @readonly\n       * @default 800\n       */\n      get: function() {\n        return this.view.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /**\n       * Same as view.height, actual number of pixels in the canvas by vertical.\n       * @member {number}\n       * @readonly\n       * @default 600\n       */\n      get: function() {\n        return this.view.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.resize = function(e, r) {\n      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);\n      var D = this.view.width / this.resolution, N = this.view.height / this.resolution;\n      this.screen.width = D, this.screen.height = N, this.autoDensity && (this.view.style.width = D + \"px\", this.view.style.height = N + \"px\"), this.emit(\"resize\", D, N);\n    }, t.prototype.generateTexture = function(e, r, D, N) {\n      r === void 0 && (r = {}), typeof r == \"number\" && (deprecation(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\"), r = { scaleMode: r, resolution: D, region: N });\n      var k = r.region, $ = __rest$3(r, [\"region\"]);\n      N = k || e.getLocalBounds(null, !0), N.width === 0 && (N.width = 1), N.height === 0 && (N.height = 1);\n      var G = RenderTexture.create(__assign$7({ width: N.width, height: N.height }, $));\n      return tempMatrix.tx = -N.x, tempMatrix.ty = -N.y, this.render(e, {\n        renderTexture: G,\n        clear: !1,\n        transform: tempMatrix,\n        skipUpdateTransform: !!e.parent\n      }), G;\n    }, t.prototype.destroy = function(e) {\n      for (var r in this.plugins)\n        this.plugins[r].destroy(), this.plugins[r] = null;\n      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);\n      var D = this;\n      D.plugins = null, D.type = RENDERER_TYPE.UNKNOWN, D.view = null, D.screen = null, D._tempDisplayObjectParent = null, D.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;\n    }, Object.defineProperty(t.prototype, \"backgroundColor\", {\n      /**\n       * The background color to fill if not transparent\n       * @member {number}\n       */\n      get: function() {\n        return this._backgroundColor;\n      },\n      set: function(e) {\n        this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"backgroundAlpha\", {\n      /**\n       * The background color alpha. Setting this to 0 will make the canvas transparent.\n       * @member {number}\n       */\n      get: function() {\n        return this._backgroundColorRgba[3];\n      },\n      set: function(e) {\n        this._backgroundColorRgba[3] = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(eventemitter3Exports)\n), GLBuffer = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n    }\n    return o;\n  }()\n), BufferSystem = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};\n    }\n    return o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o.prototype.contextChange = function() {\n      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }, o.prototype.bind = function(t) {\n      var e = this, r = e.gl, D = e.CONTEXT_UID, N = t._glBuffers[D] || this.createGLBuffer(t);\n      r.bindBuffer(t.type, N.buffer);\n    }, o.prototype.bindBufferBase = function(t, e) {\n      var r = this, D = r.gl, N = r.CONTEXT_UID;\n      if (this.boundBufferBases[e] !== t) {\n        var k = t._glBuffers[N] || this.createGLBuffer(t);\n        this.boundBufferBases[e] = t, D.bindBufferBase(D.UNIFORM_BUFFER, e, k.buffer);\n      }\n    }, o.prototype.bindBufferRange = function(t, e, r) {\n      var D = this, N = D.gl, k = D.CONTEXT_UID;\n      r = r || 0;\n      var $ = t._glBuffers[k] || this.createGLBuffer(t);\n      N.bindBufferRange(N.UNIFORM_BUFFER, e || 0, $.buffer, r * 256, 256);\n    }, o.prototype.update = function(t) {\n      var e = this, r = e.gl, D = e.CONTEXT_UID, N = t._glBuffers[D];\n      if (t._updateID !== N.updateID)\n        if (N.updateID = t._updateID, r.bindBuffer(t.type, N.buffer), N.byteLength >= t.data.byteLength)\n          r.bufferSubData(t.type, 0, t.data);\n        else {\n          var k = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;\n          N.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, k);\n        }\n    }, o.prototype.dispose = function(t, e) {\n      if (this.managedBuffers[t.id]) {\n        delete this.managedBuffers[t.id];\n        var r = t._glBuffers[this.CONTEXT_UID], D = this.gl;\n        t.disposeRunner.remove(this), r && (e || D.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);\n      }\n    }, o.prototype.disposeAll = function(t) {\n      for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)\n        this.dispose(this.managedBuffers[e[r]], t);\n    }, o.prototype.createGLBuffer = function(t) {\n      var e = this, r = e.CONTEXT_UID, D = e.gl;\n      return t._glBuffers[r] = new GLBuffer(D.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];\n    }, o;\n  }()\n), Renderer = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      var r = o.call(this, RENDERER_TYPE.WEBGL, e) || this;\n      return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {\n        destroy: new Runner(\"destroy\"),\n        contextChange: new Runner(\"contextChange\"),\n        reset: new Runner(\"reset\"),\n        update: new Runner(\"update\"),\n        postrender: new Runner(\"postrender\"),\n        prerender: new Runner(\"prerender\"),\n        resize: new Runner(\"resize\")\n      }, r.runners.contextChange.add(r), r.globalUniforms = new UniformGroup({\n        projectionMatrix: new Matrix()\n      }, !0), r.addSystem(MaskSystem, \"mask\").addSystem(ContextSystem, \"context\").addSystem(StateSystem, \"state\").addSystem(ShaderSystem, \"shader\").addSystem(TextureSystem, \"texture\").addSystem(BufferSystem, \"buffer\").addSystem(GeometrySystem, \"geometry\").addSystem(FramebufferSystem, \"framebuffer\").addSystem(ScissorSystem, \"scissor\").addSystem(StencilSystem, \"stencil\").addSystem(ProjectionSystem, \"projection\").addSystem(TextureGCSystem, \"textureGC\").addSystem(FilterSystem, \"filter\").addSystem(RenderTextureSystem, \"renderTexture\").addSystem(BatchSystem, \"batch\"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({\n        alpha: !!r.useContextAlpha,\n        antialias: e.antialias,\n        premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== \"notMultiplied\",\n        stencil: !0,\n        preserveDrawingBuffer: e.preserveDrawingBuffer,\n        powerPreference: r.options.powerPreference\n      }), r.renderingToScreen = !0, sayHello(r.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\"), r.resize(r.options.width, r.options.height), r;\n    }\n    return t.create = function(e) {\n      if (isWebGLSupported())\n        return new t(e);\n      throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n    }, t.prototype.contextChange = function() {\n      var e = this.gl, r;\n      if (this.context.webGLVersion === 1) {\n        var D = e.getParameter(e.FRAMEBUFFER_BINDING);\n        e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, D);\n      } else {\n        var D = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);\n        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, D);\n      }\n      r >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : r >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : r >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;\n    }, t.prototype.addSystem = function(e, r) {\n      var D = new e(this);\n      if (this[r])\n        throw new Error('Whoops! The name \"' + r + '\" is already in use');\n      this[r] = D;\n      for (var N in this.runners)\n        this.runners[N].add(D);\n      return this;\n    }, t.prototype.render = function(e, r) {\n      var D, N, k, $;\n      if (r && (r instanceof RenderTexture ? (deprecation(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\"), D = r, N = arguments[2], k = arguments[3], $ = arguments[4]) : (D = r.renderTexture, N = r.clear, k = r.transform, $ = r.skipUpdateTransform)), this.renderingToScreen = !D, this.runners.prerender.emit(), this.emit(\"prerender\"), this.projection.transform = k, !this.context.isLost) {\n        if (D || (this._lastObjectRendered = e), !$) {\n          var G = e.enableTempParent();\n          e.updateTransform(), e.disableTempParent(G);\n        }\n        this.renderTexture.bind(D), this.batch.currentRenderer.start(), (N !== void 0 ? N : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), D && D.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit(\"postrender\");\n      }\n    }, t.prototype.generateTexture = function(e, r, D, N) {\n      r === void 0 && (r = {});\n      var k = o.prototype.generateTexture.call(this, e, r, D, N);\n      return this.framebuffer.blit(), k;\n    }, t.prototype.resize = function(e, r) {\n      o.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);\n    }, t.prototype.reset = function() {\n      return this.runners.reset.emit(), this;\n    }, t.prototype.clear = function() {\n      this.renderTexture.bind(), this.renderTexture.clear();\n    }, t.prototype.destroy = function(e) {\n      this.runners.destroy.emit();\n      for (var r in this.runners)\n        this.runners[r].destroy();\n      o.prototype.destroy.call(this, e), this.gl = null;\n    }, Object.defineProperty(t.prototype, \"extract\", {\n      /**\n       * Please use `plugins.extract` instead.\n       * @member {PIXI.Extract} extract\n       * @deprecated since 6.0.0\n       * @readonly\n       */\n      get: function() {\n        return deprecation(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\"), this.plugins.extract;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.registerPlugin = function(e, r) {\n      deprecation(\"6.5.0\", \"Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.\"), extensions.add({\n        name: e,\n        type: ExtensionType.RendererPlugin,\n        ref: r\n      });\n    }, t.__plugins = {}, t;\n  }(AbstractRenderer)\n);\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nfunction autoDetectRenderer(o) {\n  return Renderer.create(o);\n}\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, System = (\n  /** @class */\n  function() {\n    function o(t) {\n      deprecation(\"6.1.0\", \"System class is deprecated, implemement ISystem interface instead.\"), this.renderer = t;\n    }\n    return o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o;\n  }()\n), BatchDrawCall = (\n  /** @class */\n  function() {\n    function o() {\n      this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n    }\n    return o;\n  }()\n), BatchTextureArray = (\n  /** @class */\n  function() {\n    function o() {\n      this.elements = [], this.ids = [], this.count = 0;\n    }\n    return o.prototype.clear = function() {\n      for (var t = 0; t < this.count; t++)\n        this.elements[t] = null;\n      this.count = 0;\n    }, o;\n  }()\n), ViewableBuffer = (\n  /** @class */\n  function() {\n    function o(t) {\n      typeof t == \"number\" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n    }\n    return Object.defineProperty(o.prototype, \"int8View\", {\n      /** View on the raw binary data as a `Int8Array`. */\n      get: function() {\n        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"uint8View\", {\n      /** View on the raw binary data as a `Uint8Array`. */\n      get: function() {\n        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"int16View\", {\n      /**  View on the raw binary data as a `Int16Array`. */\n      get: function() {\n        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"uint16View\", {\n      /** View on the raw binary data as a `Uint16Array`. */\n      get: function() {\n        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"int32View\", {\n      /** View on the raw binary data as a `Int32Array`. */\n      get: function() {\n        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.view = function(t) {\n      return this[t + \"View\"];\n    }, o.prototype.destroy = function() {\n      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n    }, o.sizeOf = function(t) {\n      switch (t) {\n        case \"int8\":\n        case \"uint8\":\n          return 1;\n        case \"int16\":\n        case \"uint16\":\n          return 2;\n        case \"int32\":\n        case \"uint32\":\n        case \"float32\":\n          return 4;\n        default:\n          throw new Error(t + \" isn't a valid view type\");\n      }\n    }, o;\n  }()\n), AbstractBatchRenderer = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = State.for2d(), r.size = settings.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on(\"prerender\", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;\n    }\n    return t.prototype.contextChange = function() {\n      var e = this.renderer.gl;\n      settings.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n      for (var r = 0; r < this._packedGeometryPoolSize; r++)\n        this._packedGeometries[r] = new this.geometryClass();\n      this.initFlushBuffers();\n    }, t.prototype.initFlushBuffers = function() {\n      for (var e = t._drawCallPool, r = t._textureArrayPool, D = this.size / 4, N = Math.floor(D / this.MAX_TEXTURES) + 1; e.length < D; )\n        e.push(new BatchDrawCall());\n      for (; r.length < N; )\n        r.push(new BatchTextureArray());\n      for (var k = 0; k < this.MAX_TEXTURES; k++)\n        this._tempBoundTextures[k] = null;\n    }, t.prototype.onPrerender = function() {\n      this._flushId = 0;\n    }, t.prototype.render = function(e) {\n      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);\n    }, t.prototype.buildTexturesAndDrawCalls = function() {\n      var e = this, r = e._bufferedTextures, D = e.MAX_TEXTURES, N = t._textureArrayPool, k = this.renderer.batch, $ = this._tempBoundTextures, G = this.renderer.textureGC.count, U = ++BaseTexture._globalBatch, z = 0, X = N[0], V = 0;\n      k.copyBoundTextures($, D);\n      for (var Y = 0; Y < this._bufferSize; ++Y) {\n        var q = r[Y];\n        r[Y] = null, q._batchEnabled !== U && (X.count >= D && (k.boundArray(X, $, U, D), this.buildDrawCalls(X, V, Y), V = Y, X = N[++z], ++U), q._batchEnabled = U, q.touched = G, X.elements[X.count++] = q);\n      }\n      X.count > 0 && (k.boundArray(X, $, U, D), this.buildDrawCalls(X, V, this._bufferSize), ++z, ++U);\n      for (var Y = 0; Y < $.length; Y++)\n        $[Y] = null;\n      BaseTexture._globalBatch = U;\n    }, t.prototype.buildDrawCalls = function(e, r, D) {\n      var N = this, k = N._bufferedElements, $ = N._attributeBuffer, G = N._indexBuffer, U = N.vertexSize, z = t._drawCallPool, X = this._dcIndex, V = this._aIndex, Y = this._iIndex, q = z[X];\n      q.start = this._iIndex, q.texArray = e;\n      for (var W = r; W < D; ++W) {\n        var K = k[W], Z = K._texture.baseTexture, J = premultiplyBlendMode[Z.alphaMode ? 1 : 0][K.blendMode];\n        k[W] = null, r < W && q.blend !== J && (q.size = Y - q.start, r = W, q = z[++X], q.texArray = e, q.start = Y), this.packInterleavedGeometry(K, $, G, V, Y), V += K.vertexData.length / 2 * U, Y += K.indices.length, q.blend = J;\n      }\n      r < D && (q.size = Y - q.start, ++X), this._dcIndex = X, this._aIndex = V, this._iIndex = Y;\n    }, t.prototype.bindAndClearTexArray = function(e) {\n      for (var r = this.renderer.texture, D = 0; D < e.count; D++)\n        r.bind(e.elements[D], e.ids[D]), e.elements[D] = null;\n      e.count = 0;\n    }, t.prototype.updateGeometry = function() {\n      var e = this, r = e._packedGeometries, D = e._attributeBuffer, N = e._indexBuffer;\n      settings.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(D.rawBinaryData), r[this._flushId]._indexBuffer.update(N), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(D.rawBinaryData), r[this._flushId]._indexBuffer.update(N), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n    }, t.prototype.drawBatches = function() {\n      for (var e = this._dcIndex, r = this.renderer, D = r.gl, N = r.state, k = t._drawCallPool, $ = null, G = 0; G < e; G++) {\n        var U = k[G], z = U.texArray, X = U.type, V = U.size, Y = U.start, q = U.blend;\n        $ !== z && ($ = z, this.bindAndClearTexArray(z)), this.state.blendMode = q, N.set(this.state), D.drawElements(X, V, D.UNSIGNED_SHORT, Y * 2);\n      }\n    }, t.prototype.flush = function() {\n      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n    }, t.prototype.start = function() {\n      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }, t.prototype.stop = function() {\n      this.flush();\n    }, t.prototype.destroy = function() {\n      for (var e = 0; e < this._packedGeometryPoolSize; e++)\n        this._packedGeometries[e] && this._packedGeometries[e].destroy();\n      this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), o.prototype.destroy.call(this);\n    }, t.prototype.getAttributeBuffer = function(e) {\n      var r = nextPow2(Math.ceil(e / 8)), D = log2(r), N = r * 8;\n      this._aBuffers.length <= D && (this._iBuffers.length = D + 1);\n      var k = this._aBuffers[N];\n      return k || (this._aBuffers[N] = k = new ViewableBuffer(N * this.vertexSize * 4)), k;\n    }, t.prototype.getIndexBuffer = function(e) {\n      var r = nextPow2(Math.ceil(e / 12)), D = log2(r), N = r * 12;\n      this._iBuffers.length <= D && (this._iBuffers.length = D + 1);\n      var k = this._iBuffers[D];\n      return k || (this._iBuffers[D] = k = new Uint16Array(N)), k;\n    }, t.prototype.packInterleavedGeometry = function(e, r, D, N, k) {\n      for (var $ = r.uint32View, G = r.float32View, U = N / this.vertexSize, z = e.uvs, X = e.indices, V = e.vertexData, Y = e._texture.baseTexture._batchLocation, q = Math.min(e.worldAlpha, 1), W = q < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, q) : e._tintRGB + (q * 255 << 24), K = 0; K < V.length; K += 2)\n        G[N++] = V[K], G[N++] = V[K + 1], G[N++] = z[K], G[N++] = z[K + 1], $[N++] = W, G[N++] = Y;\n      for (var K = 0; K < X.length; K++)\n        D[k++] = U + X[K];\n    }, t._drawCallPool = [], t._textureArrayPool = [], t;\n  }(ObjectRenderer)\n), BatchShaderGenerator = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf(\"%count%\") < 0)\n        throw new Error('Fragment template must contain \"%count%\".');\n      if (e.indexOf(\"%forloop%\") < 0)\n        throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n    return o.prototype.generateShader = function(t) {\n      if (!this.programCache[t]) {\n        for (var e = new Int32Array(t), r = 0; r < t; r++)\n          e[r] = r;\n        this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);\n        var D = this.fragTemplate;\n        D = D.replace(/%count%/gi, \"\" + t), D = D.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, D);\n      }\n      var N = {\n        tint: new Float32Array([1, 1, 1, 1]),\n        translationMatrix: new Matrix(),\n        default: this.defaultGroupCache[t]\n      };\n      return new Shader(this.programCache[t], N);\n    }, o.prototype.generateSampleSrc = function(t) {\n      var e = \"\";\n      e += `\n`, e += `\n`;\n      for (var r = 0; r < t; r++)\n        r > 0 && (e += `\nelse `), r < t - 1 && (e += \"if(vTextureId < \" + r + \".5)\"), e += `\n{`, e += `\n\tcolor = texture2D(uSamplers[` + r + \"], vTextureCoord);\", e += `\n}`;\n      return e += `\n`, e += `\n`, e;\n    }, o;\n  }()\n), BatchGeometry = (\n  /** @class */\n  function(o) {\n    __extends$p(t, o);\n    function t(e) {\n      e === void 0 && (e = !1);\n      var r = o.call(this) || this;\n      return r._buffer = new Buffer$1(null, e, !1), r._indexBuffer = new Buffer$1(null, e, !0), r.addAttribute(\"aVertexPosition\", r._buffer, 2, !1, TYPES.FLOAT).addAttribute(\"aTextureCoord\", r._buffer, 2, !1, TYPES.FLOAT).addAttribute(\"aColor\", r._buffer, 4, !0, TYPES.UNSIGNED_BYTE).addAttribute(\"aTextureId\", r._buffer, 1, !0, TYPES.FLOAT).addIndex(r._indexBuffer), r;\n    }\n    return t;\n  }(Geometry)\n), defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`, defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`, BatchPluginFactory = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.create = function(t) {\n      var e = Object.assign({\n        vertex: defaultVertex,\n        fragment: defaultFragment,\n        geometryClass: BatchGeometry,\n        vertexSize: 6\n      }, t), r = e.vertex, D = e.fragment, N = e.vertexSize, k = e.geometryClass;\n      return (\n        /** @class */\n        function($) {\n          __extends$p(G, $);\n          function G(U) {\n            var z = $.call(this, U) || this;\n            return z.shaderGenerator = new BatchShaderGenerator(r, D), z.geometryClass = k, z.vertexSize = N, z;\n          }\n          return G;\n        }(AbstractBatchRenderer)\n      );\n    }, Object.defineProperty(o, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source\n       * @readonly\n       */\n      get: function() {\n        return defaultVertex;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"defaultFragmentTemplate\", {\n      /**\n       * The default fragment shader source\n       * @readonly\n       */\n      get: function() {\n        return defaultFragment;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n), BatchRenderer = BatchPluginFactory.create();\nObject.assign(BatchRenderer, {\n  extension: {\n    name: \"batch\",\n    type: ExtensionType.RendererPlugin\n  }\n});\nvar resources = {}, _loop_1 = function(o) {\n  Object.defineProperty(resources, o, {\n    get: function() {\n      return deprecation(\"6.0.0\", \"PIXI.systems.\" + o + \" has moved to PIXI.\" + o), _resources[o];\n    }\n  });\n};\nfor (var name in _resources)\n  _loop_1(name);\nvar systems = {}, _loop_2 = function(o) {\n  Object.defineProperty(systems, o, {\n    get: function() {\n      return deprecation(\"6.0.0\", \"PIXI.resources.\" + o + \" has moved to PIXI.\" + o), _systems[o];\n    }\n  });\n};\nfor (var name in _systems)\n  _loop_2(name);\nvar VERSION = \"6.5.9\";\nconst n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AbstractBatchRenderer,\n  AbstractMultiResource,\n  AbstractRenderer,\n  ArrayResource,\n  Attribute,\n  BaseImageResource,\n  BaseRenderTexture,\n  BaseTexture,\n  BatchDrawCall,\n  BatchGeometry,\n  BatchPluginFactory,\n  BatchRenderer,\n  BatchShaderGenerator,\n  BatchSystem,\n  BatchTextureArray,\n  Buffer: Buffer$1,\n  BufferResource,\n  CanvasResource,\n  ContextSystem,\n  CubeResource,\n  get ExtensionType() {\n    return ExtensionType;\n  },\n  Filter,\n  FilterState,\n  FilterSystem,\n  Framebuffer,\n  FramebufferSystem,\n  GLFramebuffer,\n  GLProgram,\n  GLTexture,\n  Geometry,\n  GeometrySystem,\n  IGLUniformData,\n  INSTALLED,\n  ImageBitmapResource,\n  ImageResource,\n  MaskData,\n  MaskSystem,\n  ObjectRenderer,\n  Program,\n  ProjectionSystem,\n  Quad,\n  QuadUv,\n  RenderTexture,\n  RenderTexturePool,\n  RenderTextureSystem,\n  Renderer,\n  Resource,\n  SVGResource,\n  ScissorSystem,\n  Shader,\n  ShaderSystem,\n  SpriteMaskFilter,\n  State,\n  StateSystem,\n  StencilSystem,\n  System,\n  Texture,\n  TextureGCSystem,\n  TextureMatrix,\n  TextureSystem,\n  TextureUvs,\n  UniformGroup,\n  VERSION,\n  VideoResource,\n  ViewableBuffer,\n  autoDetectRenderer,\n  autoDetectResource,\n  checkMaxIfStatementsInShader,\n  createUBOElements,\n  defaultFilterVertex,\n  defaultVertex: defaultVertex$1,\n  extensions,\n  generateProgram,\n  generateUniformBufferSync,\n  getTestContext,\n  getUBOData,\n  resources,\n  systems,\n  uniformParsers\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*!\n * @pixi/accessibility - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/accessibility is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar accessibleTarget = {\n  /**\n   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a\n   *   shadow div with attributes set\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessible: !1,\n  /**\n   * Sets the title attribute of the shadow div\n   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'\n   * @member {?string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleTitle: null,\n  /**\n   * Sets the aria-label attribute of the shadow div\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleHint: null,\n  /**\n   * @member {number}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   * @todo Needs docs.\n   */\n  tabIndex: 0,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleActive: !1,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleDiv: null,\n  /**\n   * Specify the type of div the accessible layer is. Screen readers treat the element differently\n   * depending on this type. Defaults to button.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default 'button'\n   */\n  accessibleType: \"button\",\n  /**\n   * Specify the pointer-events the accessible div will use\n   * Defaults to auto.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default 'auto'\n   */\n  accessiblePointerEvents: \"auto\",\n  /**\n   * Setting to false will prevent any children inside this container to\n   * be accessible. Defaults to true.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @default true\n   */\n  accessibleChildren: !0,\n  renderId: -1\n};\nDisplayObject.mixin(accessibleTarget);\nvar KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile.tablet || isMobile.phone) && this.createTouchHook();\n      var e = document.createElement(\"div\");\n      e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_TOUCH_POS_X + \"px\", e.style.left = DIV_TOUCH_POS_Y + \"px\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1);\n    }\n    return Object.defineProperty(o.prototype, \"isActive\", {\n      /**\n       * Value of `true` if accessibility is currently active and accessibility layers are showing.\n       * @member {boolean}\n       * @readonly\n       */\n      get: function() {\n        return this._isActive;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"isMobileAccessibility\", {\n      /**\n       * Value of `true` if accessibility is enabled for touch devices.\n       * @member {boolean}\n       * @readonly\n       */\n      get: function() {\n        return this._isMobileAccessibility;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.createTouchHook = function() {\n      var t = this, e = document.createElement(\"button\");\n      e.style.width = DIV_HOOK_SIZE + \"px\", e.style.height = DIV_HOOK_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_HOOK_POS_X + \"px\", e.style.left = DIV_HOOK_POS_Y + \"px\", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = \"#FF0000\", e.title = \"select to enable accessibility for this content\", e.addEventListener(\"focus\", function() {\n        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();\n      }), document.body.appendChild(e), this._hookDiv = e;\n    }, o.prototype.destroyTouchHook = function() {\n      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n    }, o.prototype.activate = function() {\n      var t;\n      this._isActive || (this._isActive = !0, globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.on(\"postrender\", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));\n    }, o.prototype.deactivate = function() {\n      var t;\n      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.off(\"postrender\", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));\n    }, o.prototype.updateAccessibleObjects = function(t) {\n      if (!(!t.visible || !t.accessibleChildren)) {\n        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);\n        var e = t.children;\n        if (e)\n          for (var r = 0; r < e.length; r++)\n            this.updateAccessibleObjects(e[r]);\n      }\n    }, o.prototype.update = function() {\n      var t = performance.now();\n      if (!(isMobile.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {\n        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n        var e = this.renderer.view.getBoundingClientRect(), r = e.left, D = e.top, N = e.width, k = e.height, $ = this.renderer, G = $.width, U = $.height, z = $.resolution, X = N / G * z, V = k / U * z, Y = this.div;\n        Y.style.left = r + \"px\", Y.style.top = D + \"px\", Y.style.width = G + \"px\", Y.style.height = U + \"px\";\n        for (var q = 0; q < this.children.length; q++) {\n          var W = this.children[q];\n          if (W.renderId !== this.renderId)\n            W._accessibleActive = !1, removeItems(this.children, q, 1), this.div.removeChild(W._accessibleDiv), this.pool.push(W._accessibleDiv), W._accessibleDiv = null, q--;\n          else {\n            Y = W._accessibleDiv;\n            var K = W.hitArea, Z = W.worldTransform;\n            W.hitArea ? (Y.style.left = (Z.tx + K.x * Z.a) * X + \"px\", Y.style.top = (Z.ty + K.y * Z.d) * V + \"px\", Y.style.width = K.width * Z.a * X + \"px\", Y.style.height = K.height * Z.d * V + \"px\") : (K = W.getBounds(), this.capHitArea(K), Y.style.left = K.x * X + \"px\", Y.style.top = K.y * V + \"px\", Y.style.width = K.width * X + \"px\", Y.style.height = K.height * V + \"px\", Y.title !== W.accessibleTitle && W.accessibleTitle !== null && (Y.title = W.accessibleTitle), Y.getAttribute(\"aria-label\") !== W.accessibleHint && W.accessibleHint !== null && Y.setAttribute(\"aria-label\", W.accessibleHint)), (W.accessibleTitle !== Y.title || W.tabIndex !== Y.tabIndex) && (Y.title = W.accessibleTitle, Y.tabIndex = W.tabIndex, this.debug && this.updateDebugHTML(Y));\n          }\n        }\n        this.renderId++;\n      }\n    }, o.prototype.updateDebugHTML = function(t) {\n      t.innerHTML = \"type: \" + t.type + \"</br> title : \" + t.title + \"</br> tabIndex: \" + t.tabIndex;\n    }, o.prototype.capHitArea = function(t) {\n      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);\n      var e = this.renderer, r = e.width, D = e.height;\n      t.x + t.width > r && (t.width = r - t.x), t.y + t.height > D && (t.height = D - t.y);\n    }, o.prototype.addChild = function(t) {\n      var e = this.pool.pop();\n      e || (e = document.createElement(\"button\"), e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\", e.style.position = \"absolute\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = \"none\", navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1 ? e.setAttribute(\"aria-live\", \"off\") : e.setAttribute(\"aria-live\", \"polite\"), navigator.userAgent.match(/rv:.*Gecko\\//) ? e.setAttribute(\"aria-relevant\", \"additions\") : e.setAttribute(\"aria-relevant\", \"text\"), e.addEventListener(\"click\", this._onClick.bind(this)), e.addEventListener(\"focus\", this._onFocus.bind(this)), e.addEventListener(\"focusout\", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = \"displayObject \" + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute(\"aria-label\", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;\n    }, o.prototype._onClick = function(t) {\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;\n      e.dispatchEvent(r, \"click\", D), e.dispatchEvent(r, \"pointertap\", D), e.dispatchEvent(r, \"tap\", D);\n    }, o.prototype._onFocus = function(t) {\n      t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"assertive\");\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;\n      e.dispatchEvent(r, \"mouseover\", D);\n    }, o.prototype._onFocusOut = function(t) {\n      t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"polite\");\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, D = e.eventData;\n      e.dispatchEvent(r, \"mouseout\", D);\n    }, o.prototype._onKeyDown = function(t) {\n      t.keyCode === KEY_CODE_TAB && this.activate();\n    }, o.prototype._onMouseMove = function(t) {\n      t.movementX === 0 && t.movementY === 0 || this.deactivate();\n    }, o.prototype.destroy = function() {\n      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n    }, o.extension = {\n      name: \"accessibility\",\n      type: [\n        ExtensionType.RendererPlugin,\n        ExtensionType.CanvasRendererPlugin\n      ]\n    }, o;\n  }()\n);\n/*!\n * @pixi/interaction - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar InteractionData = (\n  /** @class */\n  function() {\n    function o() {\n      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;\n    }\n    return Object.defineProperty(o.prototype, \"pointerId\", {\n      /**\n       * The unique identifier of the pointer. It will be the same as `identifier`.\n       * @readonly\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n       */\n      get: function() {\n        return this.identifier;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.getLocalPosition = function(t, e, r) {\n      return t.worldTransform.applyInverse(r || this.global, e);\n    }, o.prototype.copyEvent = function(t) {\n      \"isPrimary\" in t && t.isPrimary && (this.isPrimary = !0), this.button = \"button\" in t && t.button;\n      var e = \"buttons\" in t && t.buttons;\n      this.buttons = Number.isInteger(e) ? e : \"which\" in t && t.which, this.width = \"width\" in t && t.width, this.height = \"height\" in t && t.height, this.tiltX = \"tiltX\" in t && t.tiltX, this.tiltY = \"tiltY\" in t && t.tiltY, this.pointerType = \"pointerType\" in t && t.pointerType, this.pressure = \"pressure\" in t && t.pressure, this.rotationAngle = \"rotationAngle\" in t && t.rotationAngle, this.twist = \"twist\" in t && t.twist || 0, this.tangentialPressure = \"tangentialPressure\" in t && t.tangentialPressure || 0;\n    }, o.prototype.reset = function() {\n      this.isPrimary = !1;\n    }, o;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$o = function(o, t) {\n  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$o(o, t);\n};\nfunction __extends$o(o, t) {\n  extendStatics$o(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar InteractionEvent = (\n  /** @class */\n  function() {\n    function o() {\n      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;\n    }\n    return o.prototype.stopPropagation = function() {\n      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;\n    }, o.prototype.reset = function() {\n      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;\n    }, o;\n  }()\n), InteractionTrackingData = (\n  /** @class */\n  function() {\n    function o(t) {\n      this._pointerId = t, this._flags = o.FLAGS.NONE;\n    }\n    return o.prototype._doSet = function(t, e) {\n      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;\n    }, Object.defineProperty(o.prototype, \"pointerId\", {\n      /**\n       * Unique pointer id of the event\n       * @readonly\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._pointerId;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"flags\", {\n      /**\n       * State of the tracking data, expressed as bit flags\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._flags;\n      },\n      set: function(t) {\n        this._flags = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"none\", {\n      /**\n       * Is the tracked event inactive (not over or down)?\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._flags === o.FLAGS.NONE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"over\", {\n      /**\n       * Is the tracked event over the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & o.FLAGS.OVER) !== 0;\n      },\n      set: function(t) {\n        this._doSet(o.FLAGS.OVER, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"rightDown\", {\n      /**\n       * Did the right mouse button come down in the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & o.FLAGS.RIGHT_DOWN) !== 0;\n      },\n      set: function(t) {\n        this._doSet(o.FLAGS.RIGHT_DOWN, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"leftDown\", {\n      /**\n       * Did the left mouse button come down in the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & o.FLAGS.LEFT_DOWN) !== 0;\n      },\n      set: function(t) {\n        this._doSet(o.FLAGS.LEFT_DOWN, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.FLAGS = Object.freeze({\n      NONE: 0,\n      OVER: 1 << 0,\n      LEFT_DOWN: 1 << 1,\n      RIGHT_DOWN: 1 << 2\n    }), o;\n  }()\n), TreeSearch = (\n  /** @class */\n  function() {\n    function o() {\n      this._tempPoint = new Point();\n    }\n    return o.prototype.recursiveFindHit = function(t, e, r, D, N) {\n      var k;\n      if (!e || !e.visible)\n        return !1;\n      var $ = t.data.global;\n      N = e.interactive || N;\n      var G = !1, U = N, z = !0;\n      if (e.hitArea)\n        D && (e.worldTransform.applyInverse($, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? G = !0 : (D = !1, z = !1)), U = !1;\n      else if (e._mask && D) {\n        var X = e._mask.isMaskData ? e._mask.maskObject : e._mask;\n        X && !(!((k = X.containsPoint) === null || k === void 0) && k.call(X, $)) && (D = !1);\n      }\n      if (z && e.interactiveChildren && e.children)\n        for (var V = e.children, Y = V.length - 1; Y >= 0; Y--) {\n          var q = V[Y], W = this.recursiveFindHit(t, q, r, D, U);\n          if (W) {\n            if (!q.parent)\n              continue;\n            U = !1, W && (t.target && (D = !1), G = !0);\n          }\n        }\n      return N && (D && !t.target && !e.hitArea && e.containsPoint && e.containsPoint($) && (G = !0), e.interactive && (G && !t.target && (t.target = e), r && r(t, e, !!G))), G;\n    }, o.prototype.findHit = function(t, e, r, D) {\n      this.recursiveFindHit(t, e, r, D, !1);\n    }, o;\n  }()\n), interactiveTarget = {\n  interactive: !1,\n  interactiveChildren: !0,\n  hitArea: null,\n  /**\n   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n   * Setting this changes the 'cursor' property to `'pointer'`.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.buttonMode = true;\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(o) {\n    o ? this.cursor = \"pointer\" : this.cursor === \"pointer\" && (this.cursor = null);\n  },\n  /**\n   * This defines what cursor mode is used when the mouse cursor\n   * is hovered over the displayObject.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.cursor = 'wait';\n   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  cursor: null,\n  /**\n   * Internal set of all active pointers, by identifier\n   * @member {Map<number, InteractionTrackingData>}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   */\n  get trackedPointers() {\n    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;\n  },\n  /**\n   * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n   * @private\n   * @type {Map<number, InteractionTrackingData>}\n   */\n  _trackedPointers: void 0\n};\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1, hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n}, InteractionManager = (\n  /** @class */\n  function(o) {\n    __extends$o(t, o);\n    function t(e, r) {\n      var D = o.call(this) || this;\n      return r = r || {}, D.renderer = e, D.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, D.interactionFrequency = r.interactionFrequency || 10, D.mouse = new InteractionData(), D.mouse.identifier = MOUSE_POINTER_ID, D.mouse.global.set(-999999), D.activeInteractionData = {}, D.activeInteractionData[MOUSE_POINTER_ID] = D.mouse, D.interactionDataPool = [], D.eventData = new InteractionEvent(), D.interactionDOMElement = null, D.moveWhenInside = !1, D.eventsAdded = !1, D.tickerAdded = !1, D.mouseOverRenderer = !(\"PointerEvent\" in globalThis), D.supportsTouchEvents = \"ontouchstart\" in globalThis, D.supportsPointerEvents = !!globalThis.PointerEvent, D.onPointerUp = D.onPointerUp.bind(D), D.processPointerUp = D.processPointerUp.bind(D), D.onPointerCancel = D.onPointerCancel.bind(D), D.processPointerCancel = D.processPointerCancel.bind(D), D.onPointerDown = D.onPointerDown.bind(D), D.processPointerDown = D.processPointerDown.bind(D), D.onPointerMove = D.onPointerMove.bind(D), D.processPointerMove = D.processPointerMove.bind(D), D.onPointerOut = D.onPointerOut.bind(D), D.processPointerOverOut = D.processPointerOverOut.bind(D), D.onPointerOver = D.onPointerOver.bind(D), D.cursorStyles = {\n        default: \"inherit\",\n        pointer: \"pointer\"\n      }, D.currentCursorMode = null, D.cursor = null, D.resolution = 1, D.delayedEvents = [], D.search = new TreeSearch(), D._tempDisplayObject = new TemporaryDisplayObject(), D._eventListenerOptions = { capture: !0, passive: !1 }, D._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, D.setTargetElement(D.renderer.view, D.renderer.resolution), D;\n    }\n    return Object.defineProperty(t.prototype, \"useSystemTicker\", {\n      /**\n       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n       * @default true\n       */\n      get: function() {\n        return this._useSystemTicker;\n      },\n      set: function(e) {\n        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"lastObjectRendered\", {\n      /**\n       * Last rendered object or temp object.\n       * @readonly\n       * @protected\n       */\n      get: function() {\n        return this.renderer._lastObjectRendered || this._tempDisplayObject;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.hitTest = function(e, r) {\n      return hitTestEvent.target = null, hitTestEvent.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(hitTestEvent, r, null, !0), hitTestEvent.target;\n    }, t.prototype.setTargetElement = function(e, r) {\n      r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();\n    }, t.prototype.addTickerListener = function() {\n      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);\n    }, t.prototype.removeTickerListener = function() {\n      this.tickerAdded && (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n    }, t.prototype.addEvents = function() {\n      if (!(this.eventsAdded || !this.interactionDOMElement)) {\n        var e = this.interactionDOMElement.style;\n        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"none\", e.msTouchAction = \"none\") : this.supportsPointerEvents && (e.touchAction = \"none\"), this.supportsPointerEvents ? (globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;\n      }\n    }, t.prototype.removeEvents = function() {\n      if (!(!this.eventsAdded || !this.interactionDOMElement)) {\n        var e = this.interactionDOMElement.style;\n        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"\", e.msTouchAction = \"\") : this.supportsPointerEvents && (e.touchAction = \"\"), this.supportsPointerEvents ? (globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;\n      }\n    }, t.prototype.tickerUpdate = function(e) {\n      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n    }, t.prototype.update = function() {\n      if (this.interactionDOMElement) {\n        if (this._didMove) {\n          this._didMove = !1;\n          return;\n        }\n        this.cursor = null;\n        for (var e in this.activeInteractionData)\n          if (this.activeInteractionData.hasOwnProperty(e)) {\n            var r = this.activeInteractionData[e];\n            if (r.originalEvent && r.pointerType !== \"touch\") {\n              var D = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);\n              this.processInteractive(D, this.lastObjectRendered, this.processPointerOverOut, !0);\n            }\n          }\n        this.setCursorMode(this.cursor);\n      }\n    }, t.prototype.setCursorMode = function(e) {\n      e = e || \"default\";\n      var r = !0;\n      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {\n        this.currentCursorMode = e;\n        var D = this.cursorStyles[e];\n        if (D)\n          switch (typeof D) {\n            case \"string\":\n              r && (this.interactionDOMElement.style.cursor = D);\n              break;\n            case \"function\":\n              D(e);\n              break;\n            case \"object\":\n              r && Object.assign(this.interactionDOMElement.style, D);\n              break;\n          }\n        else\n          r && typeof e == \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);\n      }\n    }, t.prototype.dispatchEvent = function(e, r, D) {\n      (!D.stopPropagationHint || e === D.stopsPropagatingAt) && (D.currentTarget = e, D.type = r, e.emit(r, D), e[r] && e[r](D));\n    }, t.prototype.delayDispatchEvent = function(e, r, D) {\n      this.delayedEvents.push({ displayObject: e, eventString: r, eventData: D });\n    }, t.prototype.mapPositionToPoint = function(e, r, D) {\n      var N;\n      this.interactionDOMElement.parentElement ? N = this.interactionDOMElement.getBoundingClientRect() : N = {\n        x: 0,\n        y: 0,\n        width: this.interactionDOMElement.width,\n        height: this.interactionDOMElement.height,\n        left: 0,\n        top: 0\n      };\n      var k = 1 / this.resolution;\n      e.x = (r - N.left) * (this.interactionDOMElement.width / N.width) * k, e.y = (D - N.top) * (this.interactionDOMElement.height / N.height) * k;\n    }, t.prototype.processInteractive = function(e, r, D, N) {\n      var k = this.search.findHit(e, r, D, N), $ = this.delayedEvents;\n      if (!$.length)\n        return k;\n      e.stopPropagationHint = !1;\n      var G = $.length;\n      this.delayedEvents = [];\n      for (var U = 0; U < G; U++) {\n        var z = $[U], X = z.displayObject, V = z.eventString, Y = z.eventData;\n        Y.stopsPropagatingAt === X && (Y.stopPropagationHint = !0), this.dispatchEvent(X, V, Y);\n      }\n      return k;\n    }, t.prototype.onPointerDown = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e);\n        if (this.autoPreventDefault && r[0].isNormalized) {\n          var D = e.cancelable || !(\"cancelable\" in e);\n          D && e.preventDefault();\n        }\n        for (var N = r.length, k = 0; k < N; k++) {\n          var $ = r[k], G = this.getInteractionDataForPointerId($), U = this.configureInteractionEventForDOMEvent(this.eventData, $, G);\n          if (U.data.originalEvent = e, this.processInteractive(U, this.lastObjectRendered, this.processPointerDown, !0), this.emit(\"pointerdown\", U), $.pointerType === \"touch\")\n            this.emit(\"touchstart\", U);\n          else if ($.pointerType === \"mouse\" || $.pointerType === \"pen\") {\n            var z = $.button === 2;\n            this.emit(z ? \"rightdown\" : \"mousedown\", this.eventData);\n          }\n        }\n      }\n    }, t.prototype.processPointerDown = function(e, r, D) {\n      var N = e.data, k = e.data.identifier;\n      if (D) {\n        if (r.trackedPointers[k] || (r.trackedPointers[k] = new InteractionTrackingData(k)), this.dispatchEvent(r, \"pointerdown\", e), N.pointerType === \"touch\")\n          this.dispatchEvent(r, \"touchstart\", e);\n        else if (N.pointerType === \"mouse\" || N.pointerType === \"pen\") {\n          var $ = N.button === 2;\n          $ ? r.trackedPointers[k].rightDown = !0 : r.trackedPointers[k].leftDown = !0, this.dispatchEvent(r, $ ? \"rightdown\" : \"mousedown\", e);\n        }\n      }\n    }, t.prototype.onPointerComplete = function(e, r, D) {\n      var N = this.normalizeToPointerData(e), k = N.length, $ = e.target;\n      e.composedPath && e.composedPath().length > 0 && ($ = e.composedPath()[0]);\n      for (var G = $ !== this.interactionDOMElement ? \"outside\" : \"\", U = 0; U < k; U++) {\n        var z = N[U], X = this.getInteractionDataForPointerId(z), V = this.configureInteractionEventForDOMEvent(this.eventData, z, X);\n        if (V.data.originalEvent = e, this.processInteractive(V, this.lastObjectRendered, D, r || !G), this.emit(r ? \"pointercancel\" : \"pointerup\" + G, V), z.pointerType === \"mouse\" || z.pointerType === \"pen\") {\n          var Y = z.button === 2;\n          this.emit(Y ? \"rightup\" + G : \"mouseup\" + G, V);\n        } else\n          z.pointerType === \"touch\" && (this.emit(r ? \"touchcancel\" : \"touchend\" + G, V), this.releaseInteractionDataForPointerId(z.pointerId));\n      }\n    }, t.prototype.onPointerCancel = function(e) {\n      this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !0, this.processPointerCancel);\n    }, t.prototype.processPointerCancel = function(e, r) {\n      var D = e.data, N = e.data.identifier;\n      r.trackedPointers[N] !== void 0 && (delete r.trackedPointers[N], this.dispatchEvent(r, \"pointercancel\", e), D.pointerType === \"touch\" && this.dispatchEvent(r, \"touchcancel\", e));\n    }, t.prototype.onPointerUp = function(e) {\n      this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !1, this.processPointerUp);\n    }, t.prototype.processPointerUp = function(e, r, D) {\n      var N = e.data, k = e.data.identifier, $ = r.trackedPointers[k], G = N.pointerType === \"touch\", U = N.pointerType === \"mouse\" || N.pointerType === \"pen\", z = !1;\n      if (U) {\n        var X = N.button === 2, V = InteractionTrackingData.FLAGS, Y = X ? V.RIGHT_DOWN : V.LEFT_DOWN, q = $ !== void 0 && $.flags & Y;\n        D ? (this.dispatchEvent(r, X ? \"rightup\" : \"mouseup\", e), q && (this.dispatchEvent(r, X ? \"rightclick\" : \"click\", e), z = !0)) : q && this.dispatchEvent(r, X ? \"rightupoutside\" : \"mouseupoutside\", e), $ && (X ? $.rightDown = !1 : $.leftDown = !1);\n      }\n      D ? (this.dispatchEvent(r, \"pointerup\", e), G && this.dispatchEvent(r, \"touchend\", e), $ && ((!U || z) && this.dispatchEvent(r, \"pointertap\", e), G && (this.dispatchEvent(r, \"tap\", e), $.over = !1))) : $ && (this.dispatchEvent(r, \"pointerupoutside\", e), G && this.dispatchEvent(r, \"touchendoutside\", e)), $ && $.none && delete r.trackedPointers[k];\n    }, t.prototype.onPointerMove = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e);\n        (r[0].pointerType === \"mouse\" || r[0].pointerType === \"pen\") && (this._didMove = !0, this.cursor = null);\n        for (var D = r.length, N = 0; N < D; N++) {\n          var k = r[N], $ = this.getInteractionDataForPointerId(k), G = this.configureInteractionEventForDOMEvent(this.eventData, k, $);\n          G.data.originalEvent = e, this.processInteractive(G, this.lastObjectRendered, this.processPointerMove, !0), this.emit(\"pointermove\", G), k.pointerType === \"touch\" && this.emit(\"touchmove\", G), (k.pointerType === \"mouse\" || k.pointerType === \"pen\") && this.emit(\"mousemove\", G);\n        }\n        r[0].pointerType === \"mouse\" && this.setCursorMode(this.cursor);\n      }\n    }, t.prototype.processPointerMove = function(e, r, D) {\n      var N = e.data, k = N.pointerType === \"touch\", $ = N.pointerType === \"mouse\" || N.pointerType === \"pen\";\n      $ && this.processPointerOverOut(e, r, D), (!this.moveWhenInside || D) && (this.dispatchEvent(r, \"pointermove\", e), k && this.dispatchEvent(r, \"touchmove\", e), $ && this.dispatchEvent(r, \"mousemove\", e));\n    }, t.prototype.onPointerOut = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e), D = r[0];\n        D.pointerType === \"mouse\" && (this.mouseOverRenderer = !1, this.setCursorMode(null));\n        var N = this.getInteractionDataForPointerId(D), k = this.configureInteractionEventForDOMEvent(this.eventData, D, N);\n        k.data.originalEvent = D, this.processInteractive(k, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit(\"pointerout\", k), D.pointerType === \"mouse\" || D.pointerType === \"pen\" ? this.emit(\"mouseout\", k) : this.releaseInteractionDataForPointerId(N.identifier);\n      }\n    }, t.prototype.processPointerOverOut = function(e, r, D) {\n      var N = e.data, k = e.data.identifier, $ = N.pointerType === \"mouse\" || N.pointerType === \"pen\", G = r.trackedPointers[k];\n      D && !G && (G = r.trackedPointers[k] = new InteractionTrackingData(k)), G !== void 0 && (D && this.mouseOverRenderer ? (G.over || (G.over = !0, this.delayDispatchEvent(r, \"pointerover\", e), $ && this.delayDispatchEvent(r, \"mouseover\", e)), $ && this.cursor === null && (this.cursor = r.cursor)) : G.over && (G.over = !1, this.dispatchEvent(r, \"pointerout\", this.eventData), $ && this.dispatchEvent(r, \"mouseout\", e), G.none && delete r.trackedPointers[k]));\n    }, t.prototype.onPointerOver = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e), D = r[0], N = this.getInteractionDataForPointerId(D), k = this.configureInteractionEventForDOMEvent(this.eventData, D, N);\n        k.data.originalEvent = D, D.pointerType === \"mouse\" && (this.mouseOverRenderer = !0), this.emit(\"pointerover\", k), (D.pointerType === \"mouse\" || D.pointerType === \"pen\") && this.emit(\"mouseover\", k);\n      }\n    }, t.prototype.getInteractionDataForPointerId = function(e) {\n      var r = e.pointerId, D;\n      return r === MOUSE_POINTER_ID || e.pointerType === \"mouse\" ? D = this.mouse : this.activeInteractionData[r] ? D = this.activeInteractionData[r] : (D = this.interactionDataPool.pop() || new InteractionData(), D.identifier = r, this.activeInteractionData[r] = D), D.copyEvent(e), D;\n    }, t.prototype.releaseInteractionDataForPointerId = function(e) {\n      var r = this.activeInteractionData[e];\n      r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));\n    }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, D) {\n      return e.data = D, this.mapPositionToPoint(D.global, r.clientX, r.clientY), r.pointerType === \"touch\" && (r.globalX = D.global.x, r.globalY = D.global.y), D.originalEvent = r, e.reset(), e;\n    }, t.prototype.normalizeToPointerData = function(e) {\n      var r = [];\n      if (this.supportsTouchEvents && e instanceof TouchEvent)\n        for (var D = 0, N = e.changedTouches.length; D < N; D++) {\n          var k = e.changedTouches[D];\n          typeof k.button > \"u\" && (k.button = e.touches.length ? 1 : 0), typeof k.buttons > \"u\" && (k.buttons = e.touches.length ? 1 : 0), typeof k.isPrimary > \"u\" && (k.isPrimary = e.touches.length === 1 && e.type === \"touchstart\"), typeof k.width > \"u\" && (k.width = k.radiusX || 1), typeof k.height > \"u\" && (k.height = k.radiusY || 1), typeof k.tiltX > \"u\" && (k.tiltX = 0), typeof k.tiltY > \"u\" && (k.tiltY = 0), typeof k.pointerType > \"u\" && (k.pointerType = \"touch\"), typeof k.pointerId > \"u\" && (k.pointerId = k.identifier || 0), typeof k.pressure > \"u\" && (k.pressure = k.force || 0.5), typeof k.twist > \"u\" && (k.twist = 0), typeof k.tangentialPressure > \"u\" && (k.tangentialPressure = 0), typeof k.layerX > \"u\" && (k.layerX = k.offsetX = k.clientX), typeof k.layerY > \"u\" && (k.layerY = k.offsetY = k.clientY), k.isNormalized = !0, r.push(k);\n        }\n      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {\n        var $ = e;\n        typeof $.isPrimary > \"u\" && ($.isPrimary = !0), typeof $.width > \"u\" && ($.width = 1), typeof $.height > \"u\" && ($.height = 1), typeof $.tiltX > \"u\" && ($.tiltX = 0), typeof $.tiltY > \"u\" && ($.tiltY = 0), typeof $.pointerType > \"u\" && ($.pointerType = \"mouse\"), typeof $.pointerId > \"u\" && ($.pointerId = MOUSE_POINTER_ID), typeof $.pressure > \"u\" && ($.pressure = 0.5), typeof $.twist > \"u\" && ($.twist = 0), typeof $.tangentialPressure > \"u\" && ($.tangentialPressure = 0), $.isNormalized = !0, r.push($);\n      } else\n        r.push(e);\n      return r;\n    }, t.prototype.destroy = function() {\n      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;\n    }, t.extension = {\n      name: \"interaction\",\n      type: [\n        ExtensionType.RendererPlugin,\n        ExtensionType.CanvasRendererPlugin\n      ]\n    }, t;\n  }(eventemitter3Exports)\n);\n/*!\n * @pixi/extract - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.renderer = t;\n    }\n    return o.prototype.image = function(t, e, r) {\n      var D = new Image();\n      return D.src = this.base64(t, e, r), D;\n    }, o.prototype.base64 = function(t, e, r) {\n      return this.canvas(t).toDataURL(e, r);\n    }, o.prototype.canvas = function(t, e) {\n      var r = this._rawPixels(t, e), D = r.pixels, N = r.width, k = r.height, $ = r.flipY, G = new CanvasRenderTarget(N, k, 1), U = G.context.getImageData(0, 0, N, k);\n      if (o.arrayPostDivide(D, U.data), G.context.putImageData(U, 0, 0), $) {\n        var z = new CanvasRenderTarget(G.width, G.height, 1);\n        z.context.scale(1, -1), z.context.drawImage(G.canvas, 0, -k), G.destroy(), G = z;\n      }\n      return G.canvas;\n    }, o.prototype.pixels = function(t, e) {\n      var r = this._rawPixels(t, e).pixels;\n      return o.arrayPostDivide(r, r), r;\n    }, o.prototype._rawPixels = function(t, e) {\n      var r = this.renderer, D, N = !1, k, $ = !1;\n      if (t)\n        if (t instanceof RenderTexture)\n          k = t;\n        else {\n          var G = r.context.webGLVersion >= 2 ? r.multisample : MSAA_QUALITY.NONE;\n          if (k = this.renderer.generateTexture(t, { multisample: G }), G !== MSAA_QUALITY.NONE) {\n            var U = RenderTexture.create({\n              width: k.width,\n              height: k.height\n            });\n            r.framebuffer.bind(k.framebuffer), r.framebuffer.blit(U.framebuffer), r.framebuffer.bind(null), k.destroy(!0), k = U;\n          }\n          $ = !0;\n        }\n      k ? (D = k.baseTexture.resolution, e = e ?? k.frame, N = !1, r.renderTexture.bind(k)) : (D = r.resolution, e || (e = TEMP_RECT, e.width = r.width, e.height = r.height), N = !0, r.renderTexture.bind(null));\n      var z = Math.round(e.width * D), X = Math.round(e.height * D), V = new Uint8Array(BYTES_PER_PIXEL * z * X), Y = r.gl;\n      return Y.readPixels(Math.round(e.x * D), Math.round(e.y * D), z, X, Y.RGBA, Y.UNSIGNED_BYTE, V), $ && k.destroy(!0), { pixels: V, width: z, height: X, flipY: N };\n    }, o.prototype.destroy = function() {\n      this.renderer = null;\n    }, o.arrayPostDivide = function(t, e) {\n      for (var r = 0; r < t.length; r += 4) {\n        var D = e[r + 3] = t[r + 3];\n        D !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / D, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / D, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / D, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);\n      }\n    }, o.extension = {\n      name: \"extract\",\n      type: ExtensionType.RendererPlugin\n    }, o;\n  }()\n);\n/*!\n * @pixi/loaders - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar SignalBinding = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;\n    }\n    return o.prototype.detach = function() {\n      return this._owner === null ? !1 : (this._owner.detach(this), !0);\n    }, o;\n  }()\n);\nfunction _addSignalBinding(o, t) {\n  return o._head ? (o._tail._next = t, t._prev = o._tail, o._tail = t) : (o._head = t, o._tail = t), t._owner = o, t;\n}\nvar Signal = (\n  /** @class */\n  function() {\n    function o() {\n      this._head = this._tail = void 0;\n    }\n    return o.prototype.handlers = function(t) {\n      t === void 0 && (t = !1);\n      var e = this._head;\n      if (t)\n        return !!e;\n      for (var r = []; e; )\n        r.push(e), e = e._next;\n      return r;\n    }, o.prototype.has = function(t) {\n      if (!(t instanceof SignalBinding))\n        throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n      return t._owner === this;\n    }, o.prototype.dispatch = function() {\n      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n        e[r] = t[r];\n      var D = this._head;\n      if (!D)\n        return !1;\n      for (; D; )\n        D._once && this.detach(D), D._fn.apply(D._thisArg, e), D = D._next;\n      return !0;\n    }, o.prototype.add = function(t, e) {\n      if (e === void 0 && (e = null), typeof t != \"function\")\n        throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n      return _addSignalBinding(this, new SignalBinding(t, !1, e));\n    }, o.prototype.once = function(t, e) {\n      if (e === void 0 && (e = null), typeof t != \"function\")\n        throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n      return _addSignalBinding(this, new SignalBinding(t, !0, e));\n    }, o.prototype.detach = function(t) {\n      if (!(t instanceof SignalBinding))\n        throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);\n    }, o.prototype.detachAll = function() {\n      var t = this._head;\n      if (!t)\n        return this;\n      for (this._head = this._tail = null; t; )\n        t._owner = null, t = t._next;\n      return this;\n    }, o;\n  }()\n);\nfunction parseUri(o, t) {\n  t = t || {};\n  for (var e = {\n    // eslint-disable-next-line max-len\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      // eslint-disable-next-line max-len\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      // eslint-disable-next-line max-len\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, r = e.parser[t.strictMode ? \"strict\" : \"loose\"].exec(o), D = {}, N = 14; N--; )\n    D[e.key[N]] = r[N] || \"\";\n  return D[e.q.name] = {}, D[e.key[12]].replace(e.q.parser, function(k, $, G) {\n    $ && (D[e.q.name][$] = G);\n  }), D;\n}\nvar useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;\nfunction _noop$1() {\n}\nfunction setExtMap(o, t, e) {\n  t && t.indexOf(\".\") === 0 && (t = t.substring(1)), t && (o[t] = e);\n}\nfunction reqType(o) {\n  return o.toString().replace(\"object \", \"\");\n}\nvar LoaderResource = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != \"string\" || typeof e != \"string\")\n        throw new Error(\"Both name and url are required for constructing a resource.\");\n      r = r || {}, this._flags = 0, this._setFlag(o.STATUS_FLAGS.DATA_URL, e.indexOf(\"data:\") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? \"anonymous\" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = o.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();\n    }\n    return o.setExtensionLoadType = function(t, e) {\n      setExtMap(o._loadTypeMap, t, e);\n    }, o.setExtensionXhrType = function(t, e) {\n      setExtMap(o._xhrTypeMap, t, e);\n    }, Object.defineProperty(o.prototype, \"isDataUrl\", {\n      /**\n       * When the resource starts to load.\n       * @memberof PIXI.LoaderResource\n       * @callback OnStartSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       */\n      /**\n       * When the resource reports loading progress.\n       * @memberof PIXI.LoaderResource\n       * @callback OnProgressSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       * @param {number} percentage - The progress of the load in the range [0, 1].\n       */\n      /**\n       * When the resource finishes loading.\n       * @memberof PIXI.LoaderResource\n       * @callback OnCompleteSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       */\n      /**\n       * @memberof PIXI.LoaderResource\n       * @typedef {object} IMetadata\n       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n       *      element to use for loading, instead of creating one.\n       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n       *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n       * @property {string|string[]} [mimeType] - The mime type to use for the source element\n       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n       *      where each index is the mime type to use for the corresponding url index.\n       */\n      /**\n       * Stores whether or not this url is a data url.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(o.STATUS_FLAGS.DATA_URL);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"isComplete\", {\n      /**\n       * Describes if this resource has finished loading. Is true when the resource has completely\n       * loaded.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(o.STATUS_FLAGS.COMPLETE);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"isLoading\", {\n      /**\n       * Describes if this resource is currently loading. Is true when the resource starts loading,\n       * and is false again when complete.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(o.STATUS_FLAGS.LOADING);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.complete = function() {\n      this._clearEvents(), this._finish();\n    }, o.prototype.abort = function(t) {\n      if (!this.error) {\n        if (this.error = new Error(t), this._clearEvents(), this.xhr)\n          this.xhr.abort();\n        else if (this.xdr)\n          this.xdr.abort();\n        else if (this.data)\n          if (this.data.src)\n            this.data.src = o.EMPTY_GIF;\n          else\n            for (; this.data.firstChild; )\n              this.data.removeChild(this.data.firstChild);\n        this._finish();\n      }\n    }, o.prototype.load = function(t) {\n      var e = this;\n      if (!this.isLoading) {\n        if (this.isComplete) {\n          t && setTimeout(function() {\n            return t(e);\n          }, 1);\n          return;\n        } else\n          t && this.onComplete.once(t);\n        switch (this._setFlag(o.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != \"string\") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {\n          case o.LOAD_TYPE.IMAGE:\n            this.type = o.TYPE.IMAGE, this._loadElement(\"image\");\n            break;\n          case o.LOAD_TYPE.AUDIO:\n            this.type = o.TYPE.AUDIO, this._loadSourceElement(\"audio\");\n            break;\n          case o.LOAD_TYPE.VIDEO:\n            this.type = o.TYPE.VIDEO, this._loadSourceElement(\"video\");\n            break;\n          case o.LOAD_TYPE.XHR:\n          default:\n            typeof useXdr > \"u\" && (useXdr = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();\n            break;\n        }\n      }\n    }, o.prototype._hasFlag = function(t) {\n      return (this._flags & t) !== 0;\n    }, o.prototype._setFlag = function(t, e) {\n      this._flags = e ? this._flags | t : this._flags & ~t;\n    }, o.prototype._clearEvents = function() {\n      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener(\"error\", this._boundOnError, !1), this.data.removeEventListener(\"load\", this._boundComplete, !1), this.data.removeEventListener(\"progress\", this._boundOnProgress, !1), this.data.removeEventListener(\"canplaythrough\", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener(\"error\", this._boundXhrOnError, !1), this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, !1), this.xhr.removeEventListener(\"progress\", this._boundOnProgress, !1), this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));\n    }, o.prototype._finish = function() {\n      if (this.isComplete)\n        throw new Error(\"Complete called again for an already completed resource.\");\n      this._setFlag(o.STATUS_FLAGS.COMPLETE, !0), this._setFlag(o.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);\n    }, o.prototype._loadElement = function(t) {\n      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"image\" && typeof globalThis.Image < \"u\" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n    }, o.prototype._loadSourceElement = function(t) {\n      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"audio\" && typeof globalThis.Audio < \"u\" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {\n        this.abort(\"Unsupported element: \" + t);\n        return;\n      }\n      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)\n        if (navigator.isCocoonJS)\n          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n        else if (Array.isArray(this.url))\n          for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)\n            this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));\n        else {\n          var e = this.metadata.mimeType;\n          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));\n        }\n      this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.data.addEventListener(\"canplaythrough\", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n    }, o.prototype._loadXhr = function() {\n      typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n      var t = this.xhr = new XMLHttpRequest();\n      this.crossOrigin === \"use-credentials\" && (t.withCredentials = !0), t.open(\"GET\", this.url, !0), t.timeout = this.timeout, this.xhrType === o.XHR_RESPONSE_TYPE.JSON || this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = o.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener(\"error\", this._boundXhrOnError, !1), t.addEventListener(\"timeout\", this._boundXhrOnTimeout, !1), t.addEventListener(\"abort\", this._boundXhrOnAbort, !1), t.addEventListener(\"progress\", this._boundOnProgress, !1), t.addEventListener(\"load\", this._boundXhrOnLoad, !1), t.send();\n    }, o.prototype._loadXdr = function() {\n      typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n      var t = this.xhr = new globalThis.XDomainRequest();\n      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open(\"GET\", this.url, !0), setTimeout(function() {\n        return t.send();\n      }, 1);\n    }, o.prototype._createSource = function(t, e, r) {\n      r || (r = t + \"/\" + this._getExtension(e));\n      var D = document.createElement(\"source\");\n      return D.src = e, D.type = r, D;\n    }, o.prototype._onError = function(t) {\n      this.abort(\"Failed to load element using: \" + t.target.nodeName);\n    }, o.prototype._onProgress = function(t) {\n      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);\n    }, o.prototype._onTimeout = function() {\n      this.abort(\"Load timed out.\");\n    }, o.prototype._xhrOnError = function() {\n      var t = this.xhr;\n      this.abort(reqType(t) + \" Request failed. Status: \" + t.status + ', text: \"' + t.statusText + '\"');\n    }, o.prototype._xhrOnTimeout = function() {\n      var t = this.xhr;\n      this.abort(reqType(t) + \" Request timed out.\");\n    }, o.prototype._xhrOnAbort = function() {\n      var t = this.xhr;\n      this.abort(reqType(t) + \" Request was aborted by the user.\");\n    }, o.prototype._xhrOnLoad = function() {\n      var t = this.xhr, e = \"\", r = typeof t.status > \"u\" ? STATUS_OK : t.status;\n      (t.responseType === \"\" || t.responseType === \"text\" || typeof t.responseType > \"u\") && (e = t.responseText), r === STATUS_NONE && (e.length > 0 || t.responseType === o.XHR_RESPONSE_TYPE.BUFFER) ? r = STATUS_OK : r === STATUS_IE_BUG_EMPTY && (r = STATUS_EMPTY);\n      var D = r / 100 | 0;\n      if (D === STATUS_TYPE_OK)\n        if (this.xhrType === o.XHR_RESPONSE_TYPE.TEXT)\n          this.data = e, this.type = o.TYPE.TEXT;\n        else if (this.xhrType === o.XHR_RESPONSE_TYPE.JSON)\n          try {\n            this.data = JSON.parse(e), this.type = o.TYPE.JSON;\n          } catch ($) {\n            this.abort(\"Error trying to parse loaded json: \" + $);\n            return;\n          }\n        else if (this.xhrType === o.XHR_RESPONSE_TYPE.DOCUMENT)\n          try {\n            if (globalThis.DOMParser) {\n              var N = new DOMParser();\n              this.data = N.parseFromString(e, \"text/xml\");\n            } else {\n              var k = document.createElement(\"div\");\n              k.innerHTML = e, this.data = k;\n            }\n            this.type = o.TYPE.XML;\n          } catch ($) {\n            this.abort(\"Error trying to parse loaded xml: \" + $);\n            return;\n          }\n        else\n          this.data = t.response || e;\n      else {\n        this.abort(\"[\" + t.status + \"] \" + t.statusText + \": \" + t.responseURL);\n        return;\n      }\n      this.complete();\n    }, o.prototype._determineCrossOrigin = function(t, e) {\n      if (t.indexOf(\"data:\") === 0)\n        return \"\";\n      if (globalThis.origin !== globalThis.location.origin)\n        return \"anonymous\";\n      e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement(\"a\")), tempAnchor.href = t;\n      var r = parseUri(tempAnchor.href, { strictMode: !0 }), D = !r.port && e.port === \"\" || r.port === e.port, N = r.protocol ? r.protocol + \":\" : \"\";\n      return r.host !== e.hostname || !D || N !== e.protocol ? \"anonymous\" : \"\";\n    }, o.prototype._determineXhrType = function() {\n      return o._xhrTypeMap[this.extension] || o.XHR_RESPONSE_TYPE.TEXT;\n    }, o.prototype._determineLoadType = function() {\n      return o._loadTypeMap[this.extension] || o.LOAD_TYPE.XHR;\n    }, o.prototype._getExtension = function(t) {\n      t === void 0 && (t = this.url);\n      var e = \"\";\n      if (this.isDataUrl) {\n        var r = t.indexOf(\"/\");\n        e = t.substring(r + 1, t.indexOf(\";\", r));\n      } else {\n        var D = t.indexOf(\"?\"), N = t.indexOf(\"#\"), k = Math.min(D > -1 ? D : t.length, N > -1 ? N : t.length);\n        t = t.substring(0, k), e = t.substring(t.lastIndexOf(\".\") + 1);\n      }\n      return e.toLowerCase();\n    }, o.prototype._getMimeFromXhrType = function(t) {\n      switch (t) {\n        case o.XHR_RESPONSE_TYPE.BUFFER:\n          return \"application/octet-binary\";\n        case o.XHR_RESPONSE_TYPE.BLOB:\n          return \"application/blob\";\n        case o.XHR_RESPONSE_TYPE.DOCUMENT:\n          return \"application/xml\";\n        case o.XHR_RESPONSE_TYPE.JSON:\n          return \"application/json\";\n        case o.XHR_RESPONSE_TYPE.DEFAULT:\n        case o.XHR_RESPONSE_TYPE.TEXT:\n        default:\n          return \"text/plain\";\n      }\n    }, o;\n  }()\n);\n(function(o) {\n  (function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.DATA_URL = 1] = \"DATA_URL\", t[t.COMPLETE = 2] = \"COMPLETE\", t[t.LOADING = 4] = \"LOADING\";\n  })(o.STATUS_FLAGS || (o.STATUS_FLAGS = {})), function(t) {\n    t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.JSON = 1] = \"JSON\", t[t.XML = 2] = \"XML\", t[t.IMAGE = 3] = \"IMAGE\", t[t.AUDIO = 4] = \"AUDIO\", t[t.VIDEO = 5] = \"VIDEO\", t[t.TEXT = 6] = \"TEXT\";\n  }(o.TYPE || (o.TYPE = {})), function(t) {\n    t[t.XHR = 1] = \"XHR\", t[t.IMAGE = 2] = \"IMAGE\", t[t.AUDIO = 3] = \"AUDIO\", t[t.VIDEO = 4] = \"VIDEO\";\n  }(o.LOAD_TYPE || (o.LOAD_TYPE = {})), function(t) {\n    t.DEFAULT = \"text\", t.BUFFER = \"arraybuffer\", t.BLOB = \"blob\", t.DOCUMENT = \"document\", t.JSON = \"json\", t.TEXT = \"text\";\n  }(o.XHR_RESPONSE_TYPE || (o.XHR_RESPONSE_TYPE = {})), o._loadTypeMap = {\n    // images\n    gif: o.LOAD_TYPE.IMAGE,\n    png: o.LOAD_TYPE.IMAGE,\n    bmp: o.LOAD_TYPE.IMAGE,\n    jpg: o.LOAD_TYPE.IMAGE,\n    jpeg: o.LOAD_TYPE.IMAGE,\n    tif: o.LOAD_TYPE.IMAGE,\n    tiff: o.LOAD_TYPE.IMAGE,\n    webp: o.LOAD_TYPE.IMAGE,\n    tga: o.LOAD_TYPE.IMAGE,\n    avif: o.LOAD_TYPE.IMAGE,\n    svg: o.LOAD_TYPE.IMAGE,\n    \"svg+xml\": o.LOAD_TYPE.IMAGE,\n    // audio\n    mp3: o.LOAD_TYPE.AUDIO,\n    ogg: o.LOAD_TYPE.AUDIO,\n    wav: o.LOAD_TYPE.AUDIO,\n    // videos\n    mp4: o.LOAD_TYPE.VIDEO,\n    webm: o.LOAD_TYPE.VIDEO\n  }, o._xhrTypeMap = {\n    // xml\n    xhtml: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx: o.XHR_RESPONSE_TYPE.DOCUMENT,\n    // images\n    gif: o.XHR_RESPONSE_TYPE.BLOB,\n    png: o.XHR_RESPONSE_TYPE.BLOB,\n    bmp: o.XHR_RESPONSE_TYPE.BLOB,\n    jpg: o.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: o.XHR_RESPONSE_TYPE.BLOB,\n    tif: o.XHR_RESPONSE_TYPE.BLOB,\n    tiff: o.XHR_RESPONSE_TYPE.BLOB,\n    webp: o.XHR_RESPONSE_TYPE.BLOB,\n    tga: o.XHR_RESPONSE_TYPE.BLOB,\n    avif: o.XHR_RESPONSE_TYPE.BLOB,\n    // json\n    json: o.XHR_RESPONSE_TYPE.JSON,\n    // text\n    text: o.XHR_RESPONSE_TYPE.TEXT,\n    txt: o.XHR_RESPONSE_TYPE.TEXT,\n    // fonts\n    ttf: o.XHR_RESPONSE_TYPE.BUFFER,\n    otf: o.XHR_RESPONSE_TYPE.BUFFER\n  }, o.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(LoaderResource || (LoaderResource = {}));\nfunction _noop() {\n}\nfunction onlyOnce(o) {\n  return function() {\n    for (var e = arguments, r = [], D = 0; D < arguments.length; D++)\n      r[D] = e[D];\n    if (o === null)\n      throw new Error(\"Callback was already called.\");\n    var N = o;\n    o = null, N.apply(this, r);\n  };\n}\nvar AsyncQueueItem = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this.data = t, this.callback = e;\n    }\n    return o;\n  }()\n), AsyncQueue = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      var r = this;\n      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(D, N, k) {\n        if (k && typeof k != \"function\")\n          throw new Error(\"task callback must be a function\");\n        if (r.started = !0, D == null && r.idle()) {\n          setTimeout(function() {\n            return r.drain();\n          }, 1);\n          return;\n        }\n        var $ = new AsyncQueueItem(D, typeof k == \"function\" ? k : _noop);\n        N ? r._tasks.unshift($) : r._tasks.push($), setTimeout(r.process, 1);\n      }, this.process = function() {\n        for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {\n          var D = r._tasks.shift();\n          r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(D.data, onlyOnce(r._next(D)));\n        }\n      }, this._worker = t, e === 0)\n        throw new Error(\"Concurrency must not be zero\");\n      this.concurrency = e, this.buffer = e / 4;\n    }\n    return o.prototype._next = function(t) {\n      var e = this;\n      return function() {\n        for (var r = arguments, D = [], N = 0; N < arguments.length; N++)\n          D[N] = r[N];\n        e.workers -= 1, t.callback.apply(t, D), D[0] != null && e.error(D[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();\n      };\n    }, o.prototype.push = function(t, e) {\n      this._insert(t, !1, e);\n    }, o.prototype.kill = function() {\n      this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];\n    }, o.prototype.unshift = function(t, e) {\n      this._insert(t, !0, e);\n    }, o.prototype.length = function() {\n      return this._tasks.length;\n    }, o.prototype.running = function() {\n      return this.workers;\n    }, o.prototype.idle = function() {\n      return this._tasks.length + this.workers === 0;\n    }, o.prototype.pause = function() {\n      this.paused !== !0 && (this.paused = !0);\n    }, o.prototype.resume = function() {\n      if (this.paused !== !1) {\n        this.paused = !1;\n        for (var t = 1; t <= this.concurrency; t++)\n          this.process();\n      }\n    }, o.eachSeries = function(t, e, r, D) {\n      var N = 0, k = t.length;\n      function $(G) {\n        if (G || N === k) {\n          r && r(G);\n          return;\n        }\n        D ? setTimeout(function() {\n          e(t[N++], $);\n        }, 1) : e(t[N++], $);\n      }\n      $();\n    }, o.queue = function(t, e) {\n      return new o(t, e);\n    }, o;\n  }()\n), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\\w-]+)?$/, Loader = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      var r = this;\n      t === void 0 && (t = \"\"), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = \"\", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(G, U) {\n        return r._loadResource(G, U);\n      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(G, U) {\n        return r._loadResource(G, U);\n      }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();\n      for (var D = 0; D < o._plugins.length; ++D) {\n        var N = o._plugins[D], k = N.pre, $ = N.use;\n        k && this.pre(k), $ && this.use($);\n      }\n      this._protected = !1;\n    }\n    return o.prototype._add = function(t, e, r, D) {\n      if (this.loading && (!r || !r.parentResource))\n        throw new Error(\"Cannot add resources while the loader is running.\");\n      if (this.resources[t])\n        throw new Error('Resource named \"' + t + '\" already exists.');\n      if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, r), typeof D == \"function\" && this.resources[t].onAfterMiddleware.once(D), this.loading) {\n        for (var N = r.parentResource, k = [], $ = 0; $ < N.children.length; ++$)\n          N.children[$].isComplete || k.push(N.children[$]);\n        var G = N.progressChunk * (k.length + 1), U = G / (k.length + 2);\n        N.children.push(this.resources[t]), N.progressChunk = U;\n        for (var $ = 0; $ < k.length; ++$)\n          k[$].progressChunk = U;\n        this.resources[t].progressChunk = U;\n      }\n      return this._queue.push(this.resources[t]), this;\n    }, o.prototype.pre = function(t) {\n      return this._beforeMiddleware.push(t), this;\n    }, o.prototype.use = function(t) {\n      return this._afterMiddleware.push(t), this;\n    }, o.prototype.reset = function() {\n      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();\n      for (var t in this.resources) {\n        var e = this.resources[t];\n        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort(\"loader reset\");\n      }\n      return this.resources = {}, this;\n    }, o.prototype.load = function(t) {\n      if (deprecation(\"6.5.0\", \"@pixi/loaders is being replaced with @pixi/assets in the next major release.\"), typeof t == \"function\" && this.onComplete.once(t), this.loading)\n        return this;\n      if (this._queue.idle())\n        this._onStart(), this._onComplete();\n      else {\n        for (var e = this._queue._tasks.length, r = MAX_PROGRESS / e, D = 0; D < this._queue._tasks.length; ++D)\n          this._queue._tasks[D].data.progressChunk = r;\n        this._onStart(), this._queue.resume();\n      }\n      return this;\n    }, Object.defineProperty(o.prototype, \"concurrency\", {\n      /**\n       * The number of resources to load concurrently.\n       * @default 10\n       */\n      get: function() {\n        return this._queue.concurrency;\n      },\n      set: function(t) {\n        this._queue.concurrency = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype._prepareUrl = function(t) {\n      var e = parseUri(t, { strictMode: !0 }), r;\n      if (e.protocol || !e.path || t.indexOf(\"//\") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && t.charAt(0) !== \"/\" ? r = this.baseUrl + \"/\" + t : r = this.baseUrl + t, this.defaultQueryString) {\n        var D = rgxExtractUrlHash.exec(r)[0];\n        r = r.slice(0, r.length - D.length), r.indexOf(\"?\") !== -1 ? r += \"&\" + this.defaultQueryString : r += \"?\" + this.defaultQueryString, r += D;\n      }\n      return r;\n    }, o.prototype._loadResource = function(t, e) {\n      var r = this;\n      t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(D, N) {\n        D.call(r, t, function() {\n          N(t.isComplete ? {} : null);\n        });\n      }, function() {\n        t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());\n      }, !0);\n    }, o.prototype._onStart = function() {\n      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);\n    }, o.prototype._onComplete = function() {\n      this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);\n    }, o.prototype._onLoad = function(t) {\n      var e = this;\n      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(r, D) {\n        r.call(e, t, D);\n      }, function() {\n        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();\n      }, !0);\n    }, o.prototype.destroy = function() {\n      this._protected || this.reset();\n    }, Object.defineProperty(o, \"shared\", {\n      /** A premade instance of the loader that can be used to load resources. */\n      get: function() {\n        var t = o._shared;\n        return t || (t = new o(), t._protected = !0, o._shared = t), t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.registerPlugin = function(t) {\n      return deprecation(\"6.5.0\", \"Loader.registerPlugin() is deprecated, use extensions.add() instead.\"), extensions.add({\n        type: ExtensionType.Loader,\n        ref: t\n      }), o;\n    }, o._plugins = [], o;\n  }()\n);\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\nLoader.prototype.add = function(t, e, r, D) {\n  if (Array.isArray(t)) {\n    for (var N = 0; N < t.length; ++N)\n      this.add(t[N]);\n    return this;\n  }\n  if (typeof t == \"object\" && (r = t, D = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != \"string\" && (D = r, r = e, e = t), typeof e != \"string\")\n    throw new Error(\"No url passed to add resource to loader.\");\n  return typeof r == \"function\" && (D = r, r = null), this._add(t, e, r, D);\n};\nvar AppLoaderPlugin = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.init = function(t) {\n      t = Object.assign({\n        sharedLoader: !1\n      }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();\n    }, o.destroy = function() {\n      this.loader && (this.loader.destroy(), this.loader = null);\n    }, o.extension = ExtensionType.Application, o;\n  }()\n), TextureLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.add = function() {\n      LoaderResource.setExtensionLoadType(\"svg\", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType(\"svg\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n    }, o.use = function(t, e) {\n      if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === \"svg\")) {\n        var r = t.data, D = t.url, N = t.name, k = t.metadata;\n        Texture.fromLoader(r, D, N, k).then(function($) {\n          t.texture = $, e();\n        }).catch(e);\n      } else\n        e();\n    }, o.extension = ExtensionType.Loader, o;\n  }()\n), _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction encodeBinary(o) {\n  for (var t = \"\", e = 0; e < o.length; ) {\n    for (var r = [0, 0, 0], D = [0, 0, 0, 0], N = 0; N < r.length; ++N)\n      e < o.length ? r[N] = o.charCodeAt(e++) & 255 : r[N] = 0;\n    D[0] = r[0] >> 2, D[1] = (r[0] & 3) << 4 | r[1] >> 4, D[2] = (r[1] & 15) << 2 | r[2] >> 6, D[3] = r[2] & 63;\n    var k = e - (o.length - 1);\n    switch (k) {\n      case 2:\n        D[3] = 64, D[2] = 64;\n        break;\n      case 1:\n        D[3] = 64;\n        break;\n    }\n    for (var N = 0; N < D.length; ++N)\n      t += _keyStr.charAt(D[N]);\n  }\n  return t;\n}\nfunction parsing(o, t) {\n  if (!o.data) {\n    t();\n    return;\n  }\n  if (o.xhr && o.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof o.data == \"string\") {\n      var e = o.xhr.getResponseHeader(\"content-type\");\n      if (e && e.indexOf(\"image\") === 0) {\n        o.data = new Image(), o.data.src = \"data:\" + e + \";base64,\" + encodeBinary(o.xhr.responseText), o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {\n          o.data.onload = null, t();\n        };\n        return;\n      }\n    } else if (o.data.type.indexOf(\"image\") === 0) {\n      var r = globalThis.URL || globalThis.webkitURL, D = r.createObjectURL(o.data);\n      o.blob = o.data, o.data = new Image(), o.data.src = D, o.type = LoaderResource.TYPE.IMAGE, o.data.onload = function() {\n        r.revokeObjectURL(D), o.data.onload = null, t();\n      };\n      return;\n    }\n  }\n  t();\n}\nvar ParsingLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.extension = ExtensionType.Loader, o.use = parsing, o;\n  }()\n);\nextensions.add(TextureLoader, ParsingLoader);\n/*!\n * @pixi/compressed-textures - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/compressed-textures is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _a$2, INTERNAL_FORMATS;\n(function(o) {\n  o[o.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\", o[o.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\", o[o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\", o[o.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\", o[o.COMPRESSED_R11_EAC = 37488] = \"COMPRESSED_R11_EAC\", o[o.COMPRESSED_SIGNED_R11_EAC = 37489] = \"COMPRESSED_SIGNED_R11_EAC\", o[o.COMPRESSED_RG11_EAC = 37490] = \"COMPRESSED_RG11_EAC\", o[o.COMPRESSED_SIGNED_RG11_EAC = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\", o[o.COMPRESSED_RGB8_ETC2 = 37492] = \"COMPRESSED_RGB8_ETC2\", o[o.COMPRESSED_RGBA8_ETC2_EAC = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\", o[o.COMPRESSED_SRGB8_ETC2 = 37493] = \"COMPRESSED_SRGB8_ETC2\", o[o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\", o[o.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\", o[o.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\", o[o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\", o[o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\", o[o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\", o[o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\", o[o.COMPRESSED_RGB_ETC1_WEBGL = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\", o[o.COMPRESSED_RGB_ATC_WEBGL = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\", o[o.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\", o[o.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\", o[o.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = \"COMPRESSED_RGBA_ASTC_4x4_KHR\";\n})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));\nvar INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, // WEBGL_compressed_texture_s3tc\n_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc\n_a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc\n_a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc\n_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1\n_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt\n// WEBGL_compressed_texture_atc\n_a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n// WEBGL_compressed_texture_astc\n/* eslint-disable-next-line camelcase */\n_a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, _a$2);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$n = function(o, t) {\n  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$n(o, t);\n};\nfunction __extends$n(o, t) {\n  extendStatics$n(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction __awaiter(o, t, e, r) {\n  function D(N) {\n    return N instanceof e ? N : new e(function(k) {\n      k(N);\n    });\n  }\n  return new (e || (e = Promise))(function(N, k) {\n    function $(z) {\n      try {\n        U(r.next(z));\n      } catch (X) {\n        k(X);\n      }\n    }\n    function G(z) {\n      try {\n        U(r.throw(z));\n      } catch (X) {\n        k(X);\n      }\n    }\n    function U(z) {\n      z.done ? N(z.value) : D(z.value).then($, G);\n    }\n    U((r = r.apply(o, t || [])).next());\n  });\n}\nfunction __generator(o, t) {\n  var e = { label: 0, sent: function() {\n    if (N[0] & 1)\n      throw N[1];\n    return N[1];\n  }, trys: [], ops: [] }, r, D, N, k;\n  return k = { next: $(0), throw: $(1), return: $(2) }, typeof Symbol == \"function\" && (k[Symbol.iterator] = function() {\n    return this;\n  }), k;\n  function $(U) {\n    return function(z) {\n      return G([U, z]);\n    };\n  }\n  function G(U) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; e; )\n      try {\n        if (r = 1, D && (N = U[0] & 2 ? D.return : U[0] ? D.throw || ((N = D.return) && N.call(D), 0) : D.next) && !(N = N.call(D, U[1])).done)\n          return N;\n        switch (D = 0, N && (U = [U[0] & 2, N.value]), U[0]) {\n          case 0:\n          case 1:\n            N = U;\n            break;\n          case 4:\n            return e.label++, { value: U[1], done: !1 };\n          case 5:\n            e.label++, D = U[1], U = [0];\n            continue;\n          case 7:\n            U = e.ops.pop(), e.trys.pop();\n            continue;\n          default:\n            if (N = e.trys, !(N = N.length > 0 && N[N.length - 1]) && (U[0] === 6 || U[0] === 2)) {\n              e = 0;\n              continue;\n            }\n            if (U[0] === 3 && (!N || U[1] > N[0] && U[1] < N[3])) {\n              e.label = U[1];\n              break;\n            }\n            if (U[0] === 6 && e.label < N[1]) {\n              e.label = N[1], N = U;\n              break;\n            }\n            if (N && e.label < N[2]) {\n              e.label = N[2], e.ops.push(U);\n              break;\n            }\n            N[2] && e.ops.pop(), e.trys.pop();\n            continue;\n        }\n        U = t.call(o, e);\n      } catch (z) {\n        U = [6, z], D = 0;\n      } finally {\n        r = N = 0;\n      }\n    if (U[0] & 5)\n      throw U[1];\n    return { value: U[0] ? U[1] : void 0, done: !0 };\n  }\n}\nvar BlobResource = (\n  /** @class */\n  function(o) {\n    __extends$n(t, o);\n    function t(e, r) {\n      r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });\n      var D = this, N, k;\n      return typeof e == \"string\" ? (N = e, k = new Uint8Array()) : (N = null, k = e), D = o.call(this, k, r) || this, D.origin = N, D.buffer = k ? new ViewableBuffer(k) : null, D.origin && r.autoLoad !== !1 && D.load(), k && k.length && (D.loaded = !0, D.onBlobLoaded(D.buffer.rawBinaryData)), D;\n    }\n    return t.prototype.onBlobLoaded = function(e) {\n    }, t.prototype.load = function() {\n      return __awaiter(this, void 0, Promise, function() {\n        var e, r, D;\n        return __generator(this, function(N) {\n          switch (N.label) {\n            case 0:\n              return [4, fetch(this.origin)];\n            case 1:\n              return e = N.sent(), [4, e.blob()];\n            case 2:\n              return r = N.sent(), [4, r.arrayBuffer()];\n            case 3:\n              return D = N.sent(), this.data = new Uint32Array(D), this.buffer = new ViewableBuffer(D), this.loaded = !0, this.onBlobLoaded(D), this.update(), [2, this];\n          }\n        });\n      });\n    }, t;\n  }(BufferResource)\n), CompressedTextureResource = (\n  /** @class */\n  function(o) {\n    __extends$n(t, o);\n    function t(e, r) {\n      var D = o.call(this, e, r) || this;\n      return D.format = r.format, D.levels = r.levels || 1, D._width = r.width, D._height = r.height, D._extension = t._formatToExtension(D.format), (r.levelBuffers || D.buffer) && (D._levelBuffers = r.levelBuffers || t._createLevelBuffers(\n        e instanceof Uint8Array ? e : D.buffer.uint8View,\n        D.format,\n        D.levels,\n        4,\n        4,\n        // PVRTC has 8x4 blocks in 2bpp mode\n        D.width,\n        D.height\n      )), D;\n    }\n    return t.prototype.upload = function(e, r, D) {\n      var N = e.gl, k = e.context.extensions[this._extension];\n      if (!k)\n        throw new Error(this._extension + \" textures are not supported on the current machine\");\n      if (!this._levelBuffers)\n        return !1;\n      for (var $ = 0, G = this.levels; $ < G; $++) {\n        var U = this._levelBuffers[$], z = U.levelID, X = U.levelWidth, V = U.levelHeight, Y = U.levelBuffer;\n        N.compressedTexImage2D(N.TEXTURE_2D, z, this.format, X, V, 0, Y);\n      }\n      return !0;\n    }, t.prototype.onBlobLoaded = function() {\n      this._levelBuffers = t._createLevelBuffers(\n        this.buffer.uint8View,\n        this.format,\n        this.levels,\n        4,\n        4,\n        // PVRTC has 8x4 blocks in 2bpp mode\n        this.width,\n        this.height\n      );\n    }, t._formatToExtension = function(e) {\n      if (e >= 33776 && e <= 33779)\n        return \"s3tc\";\n      if (e >= 37488 && e <= 37497)\n        return \"etc\";\n      if (e >= 35840 && e <= 35843)\n        return \"pvrtc\";\n      if (e >= 36196)\n        return \"etc1\";\n      if (e >= 35986 && e <= 34798)\n        return \"atc\";\n      throw new Error(\"Invalid (compressed) texture format given!\");\n    }, t._createLevelBuffers = function(e, r, D, N, k, $, G) {\n      for (var U = new Array(D), z = e.byteOffset, X = $, V = G, Y = X + N - 1 & ~(N - 1), q = V + k - 1 & ~(k - 1), W = Y * q * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r], K = 0; K < D; K++)\n        U[K] = {\n          levelID: K,\n          levelWidth: D > 1 ? X : Y,\n          levelHeight: D > 1 ? V : q,\n          levelBuffer: new Uint8Array(e.buffer, z, W)\n        }, z += W, X = X >> 1 || 1, V = V >> 1 || 1, Y = X + N - 1 & ~(N - 1), q = V + k - 1 & ~(k - 1), W = Y * q * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[r];\n      return U;\n    }, t;\n  }(BlobResource)\n), CompressedTextureLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.use = function(t, e) {\n      var r = t.data, D = this;\n      if (t.type === LoaderResource.TYPE.JSON && r && r.cacheID && r.textures) {\n        for (var N = r.textures, k = void 0, $ = void 0, G = 0, U = N.length; G < U; G++) {\n          var z = N[G], X = z.src, V = z.format;\n          if (V || ($ = X), o.textureFormats[V]) {\n            k = X;\n            break;\n          }\n        }\n        if (k = k || $, !k) {\n          e(new Error(\"Cannot load compressed-textures in \" + t.url + \", make sure you provide a fallback\"));\n          return;\n        }\n        if (k === t.url) {\n          e(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n          return;\n        }\n        var Y = {\n          crossOrigin: t.crossOrigin,\n          metadata: t.metadata.imageMetadata,\n          parentResource: t\n        }, q = url$1.resolve(t.url.replace(D.baseUrl, \"\"), k), W = r.cacheID;\n        D.add(W, q, Y, function(K) {\n          if (K.error) {\n            e(K.error);\n            return;\n          }\n          var Z = K.texture, J = Z === void 0 ? null : Z, Q = K.textures, et = Q === void 0 ? {} : Q;\n          Object.assign(t, { texture: J, textures: et }), e();\n        });\n      } else\n        e();\n    }, Object.defineProperty(o, \"textureExtensions\", {\n      /**  Map of available texture extensions. */\n      get: function() {\n        if (!o._textureExtensions) {\n          var t = settings.ADAPTER.createCanvas(), e = t.getContext(\"webgl\");\n          if (!e)\n            return console.warn(\"WebGL not available for compressed textures. Silently failing.\"), {};\n          var r = {\n            s3tc: e.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n            s3tc_sRGB: e.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n            etc: e.getExtension(\"WEBGL_compressed_texture_etc\"),\n            etc1: e.getExtension(\"WEBGL_compressed_texture_etc1\"),\n            pvrtc: e.getExtension(\"WEBGL_compressed_texture_pvrtc\") || e.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n            atc: e.getExtension(\"WEBGL_compressed_texture_atc\"),\n            astc: e.getExtension(\"WEBGL_compressed_texture_astc\")\n          };\n          o._textureExtensions = r;\n        }\n        return o._textureExtensions;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"textureFormats\", {\n      /** Map of available texture formats. */\n      get: function() {\n        if (!o._textureFormats) {\n          var t = o.textureExtensions;\n          o._textureFormats = {};\n          for (var e in t) {\n            var r = t[e];\n            r && Object.assign(o._textureFormats, Object.getPrototypeOf(r));\n          }\n        }\n        return o._textureFormats;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.extension = ExtensionType.Loader, o;\n  }()\n);\nfunction registerCompressedTextures(o, t, e) {\n  var r = {\n    textures: {},\n    texture: null\n  };\n  if (!t)\n    return r;\n  var D = t.map(function(N) {\n    return new Texture(new BaseTexture(N, Object.assign({\n      mipmap: MIPMAP_MODES.OFF,\n      alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA\n    }, e)));\n  });\n  return D.forEach(function(N, k) {\n    var $ = N.baseTexture, G = o + \"-\" + (k + 1);\n    BaseTexture.addToCache($, G), Texture.addToCache(N, G), k === 0 && (BaseTexture.addToCache($, o), Texture.addToCache(N, o), r.texture = N), r.textures[G] = N;\n  }), r;\n}\nvar _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, DXGI_FORMAT;\n(function(o) {\n  o[o.DXGI_FORMAT_UNKNOWN = 0] = \"DXGI_FORMAT_UNKNOWN\", o[o.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\", o[o.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\", o[o.DXGI_FORMAT_R32G32B32A32_UINT = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\", o[o.DXGI_FORMAT_R32G32B32A32_SINT = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\", o[o.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\", o[o.DXGI_FORMAT_R32G32B32_FLOAT = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\", o[o.DXGI_FORMAT_R32G32B32_UINT = 7] = \"DXGI_FORMAT_R32G32B32_UINT\", o[o.DXGI_FORMAT_R32G32B32_SINT = 8] = \"DXGI_FORMAT_R32G32B32_SINT\", o[o.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\", o[o.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\", o[o.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\", o[o.DXGI_FORMAT_R16G16B16A16_UINT = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\", o[o.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\", o[o.DXGI_FORMAT_R16G16B16A16_SINT = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\", o[o.DXGI_FORMAT_R32G32_TYPELESS = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\", o[o.DXGI_FORMAT_R32G32_FLOAT = 16] = \"DXGI_FORMAT_R32G32_FLOAT\", o[o.DXGI_FORMAT_R32G32_UINT = 17] = \"DXGI_FORMAT_R32G32_UINT\", o[o.DXGI_FORMAT_R32G32_SINT = 18] = \"DXGI_FORMAT_R32G32_SINT\", o[o.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\", o[o.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\", o[o.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\", o[o.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\", o[o.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\", o[o.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\", o[o.DXGI_FORMAT_R10G10B10A2_UINT = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\", o[o.DXGI_FORMAT_R11G11B10_FLOAT = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\", o[o.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\", o[o.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\", o[o.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\", o[o.DXGI_FORMAT_R8G8B8A8_UINT = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\", o[o.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\", o[o.DXGI_FORMAT_R8G8B8A8_SINT = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\", o[o.DXGI_FORMAT_R16G16_TYPELESS = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\", o[o.DXGI_FORMAT_R16G16_FLOAT = 34] = \"DXGI_FORMAT_R16G16_FLOAT\", o[o.DXGI_FORMAT_R16G16_UNORM = 35] = \"DXGI_FORMAT_R16G16_UNORM\", o[o.DXGI_FORMAT_R16G16_UINT = 36] = \"DXGI_FORMAT_R16G16_UINT\", o[o.DXGI_FORMAT_R16G16_SNORM = 37] = \"DXGI_FORMAT_R16G16_SNORM\", o[o.DXGI_FORMAT_R16G16_SINT = 38] = \"DXGI_FORMAT_R16G16_SINT\", o[o.DXGI_FORMAT_R32_TYPELESS = 39] = \"DXGI_FORMAT_R32_TYPELESS\", o[o.DXGI_FORMAT_D32_FLOAT = 40] = \"DXGI_FORMAT_D32_FLOAT\", o[o.DXGI_FORMAT_R32_FLOAT = 41] = \"DXGI_FORMAT_R32_FLOAT\", o[o.DXGI_FORMAT_R32_UINT = 42] = \"DXGI_FORMAT_R32_UINT\", o[o.DXGI_FORMAT_R32_SINT = 43] = \"DXGI_FORMAT_R32_SINT\", o[o.DXGI_FORMAT_R24G8_TYPELESS = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\", o[o.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\", o[o.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\", o[o.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\", o[o.DXGI_FORMAT_R8G8_TYPELESS = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\", o[o.DXGI_FORMAT_R8G8_UNORM = 49] = \"DXGI_FORMAT_R8G8_UNORM\", o[o.DXGI_FORMAT_R8G8_UINT = 50] = \"DXGI_FORMAT_R8G8_UINT\", o[o.DXGI_FORMAT_R8G8_SNORM = 51] = \"DXGI_FORMAT_R8G8_SNORM\", o[o.DXGI_FORMAT_R8G8_SINT = 52] = \"DXGI_FORMAT_R8G8_SINT\", o[o.DXGI_FORMAT_R16_TYPELESS = 53] = \"DXGI_FORMAT_R16_TYPELESS\", o[o.DXGI_FORMAT_R16_FLOAT = 54] = \"DXGI_FORMAT_R16_FLOAT\", o[o.DXGI_FORMAT_D16_UNORM = 55] = \"DXGI_FORMAT_D16_UNORM\", o[o.DXGI_FORMAT_R16_UNORM = 56] = \"DXGI_FORMAT_R16_UNORM\", o[o.DXGI_FORMAT_R16_UINT = 57] = \"DXGI_FORMAT_R16_UINT\", o[o.DXGI_FORMAT_R16_SNORM = 58] = \"DXGI_FORMAT_R16_SNORM\", o[o.DXGI_FORMAT_R16_SINT = 59] = \"DXGI_FORMAT_R16_SINT\", o[o.DXGI_FORMAT_R8_TYPELESS = 60] = \"DXGI_FORMAT_R8_TYPELESS\", o[o.DXGI_FORMAT_R8_UNORM = 61] = \"DXGI_FORMAT_R8_UNORM\", o[o.DXGI_FORMAT_R8_UINT = 62] = \"DXGI_FORMAT_R8_UINT\", o[o.DXGI_FORMAT_R8_SNORM = 63] = \"DXGI_FORMAT_R8_SNORM\", o[o.DXGI_FORMAT_R8_SINT = 64] = \"DXGI_FORMAT_R8_SINT\", o[o.DXGI_FORMAT_A8_UNORM = 65] = \"DXGI_FORMAT_A8_UNORM\", o[o.DXGI_FORMAT_R1_UNORM = 66] = \"DXGI_FORMAT_R1_UNORM\", o[o.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\", o[o.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\", o[o.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\", o[o.DXGI_FORMAT_BC1_TYPELESS = 70] = \"DXGI_FORMAT_BC1_TYPELESS\", o[o.DXGI_FORMAT_BC1_UNORM = 71] = \"DXGI_FORMAT_BC1_UNORM\", o[o.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\", o[o.DXGI_FORMAT_BC2_TYPELESS = 73] = \"DXGI_FORMAT_BC2_TYPELESS\", o[o.DXGI_FORMAT_BC2_UNORM = 74] = \"DXGI_FORMAT_BC2_UNORM\", o[o.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\", o[o.DXGI_FORMAT_BC3_TYPELESS = 76] = \"DXGI_FORMAT_BC3_TYPELESS\", o[o.DXGI_FORMAT_BC3_UNORM = 77] = \"DXGI_FORMAT_BC3_UNORM\", o[o.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\", o[o.DXGI_FORMAT_BC4_TYPELESS = 79] = \"DXGI_FORMAT_BC4_TYPELESS\", o[o.DXGI_FORMAT_BC4_UNORM = 80] = \"DXGI_FORMAT_BC4_UNORM\", o[o.DXGI_FORMAT_BC4_SNORM = 81] = \"DXGI_FORMAT_BC4_SNORM\", o[o.DXGI_FORMAT_BC5_TYPELESS = 82] = \"DXGI_FORMAT_BC5_TYPELESS\", o[o.DXGI_FORMAT_BC5_UNORM = 83] = \"DXGI_FORMAT_BC5_UNORM\", o[o.DXGI_FORMAT_BC5_SNORM = 84] = \"DXGI_FORMAT_BC5_SNORM\", o[o.DXGI_FORMAT_B5G6R5_UNORM = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\", o[o.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\", o[o.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\", o[o.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\", o[o.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\", o[o.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\", o[o.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\", o[o.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\", o[o.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\", o[o.DXGI_FORMAT_BC6H_TYPELESS = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\", o[o.DXGI_FORMAT_BC6H_UF16 = 95] = \"DXGI_FORMAT_BC6H_UF16\", o[o.DXGI_FORMAT_BC6H_SF16 = 96] = \"DXGI_FORMAT_BC6H_SF16\", o[o.DXGI_FORMAT_BC7_TYPELESS = 97] = \"DXGI_FORMAT_BC7_TYPELESS\", o[o.DXGI_FORMAT_BC7_UNORM = 98] = \"DXGI_FORMAT_BC7_UNORM\", o[o.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\", o[o.DXGI_FORMAT_AYUV = 100] = \"DXGI_FORMAT_AYUV\", o[o.DXGI_FORMAT_Y410 = 101] = \"DXGI_FORMAT_Y410\", o[o.DXGI_FORMAT_Y416 = 102] = \"DXGI_FORMAT_Y416\", o[o.DXGI_FORMAT_NV12 = 103] = \"DXGI_FORMAT_NV12\", o[o.DXGI_FORMAT_P010 = 104] = \"DXGI_FORMAT_P010\", o[o.DXGI_FORMAT_P016 = 105] = \"DXGI_FORMAT_P016\", o[o.DXGI_FORMAT_420_OPAQUE = 106] = \"DXGI_FORMAT_420_OPAQUE\", o[o.DXGI_FORMAT_YUY2 = 107] = \"DXGI_FORMAT_YUY2\", o[o.DXGI_FORMAT_Y210 = 108] = \"DXGI_FORMAT_Y210\", o[o.DXGI_FORMAT_Y216 = 109] = \"DXGI_FORMAT_Y216\", o[o.DXGI_FORMAT_NV11 = 110] = \"DXGI_FORMAT_NV11\", o[o.DXGI_FORMAT_AI44 = 111] = \"DXGI_FORMAT_AI44\", o[o.DXGI_FORMAT_IA44 = 112] = \"DXGI_FORMAT_IA44\", o[o.DXGI_FORMAT_P8 = 113] = \"DXGI_FORMAT_P8\", o[o.DXGI_FORMAT_A8P8 = 114] = \"DXGI_FORMAT_A8P8\", o[o.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\", o[o.DXGI_FORMAT_P208 = 116] = \"DXGI_FORMAT_P208\", o[o.DXGI_FORMAT_V208 = 117] = \"DXGI_FORMAT_V208\", o[o.DXGI_FORMAT_V408 = 118] = \"DXGI_FORMAT_V408\", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\", o[o.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\", o[o.DXGI_FORMAT_FORCE_UINT = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(DXGI_FORMAT || (DXGI_FORMAT = {}));\nvar D3D10_RESOURCE_DIMENSION;\n(function(o) {\n  o[o.DDS_DIMENSION_TEXTURE1D = 2] = \"DDS_DIMENSION_TEXTURE1D\", o[o.DDS_DIMENSION_TEXTURE2D = 3] = \"DDS_DIMENSION_TEXTURE2D\", o[o.DDS_DIMENSION_TEXTURE3D = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));\nvar PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, // WEBGL_compressed_texture_s3tc\n_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb\n_b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);\nfunction parseDDS(o) {\n  var t = new Uint32Array(o), e = t[0];\n  if (e !== DDS_MAGIC)\n    throw new Error(\"Invalid DDS file magic word\");\n  var r = new Uint32Array(o, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), D = r[DDS_FIELDS.HEIGHT], N = r[DDS_FIELDS.WIDTH], k = r[DDS_FIELDS.MIPMAP_COUNT], $ = new Uint32Array(o, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), G = $[PF_FLAGS];\n  if (G & DDPF_FOURCC) {\n    var U = $[DDS_PF_FIELDS.FOURCC];\n    if (U !== FOURCC_DX10) {\n      var z = FOURCC_TO_FORMAT[U], X = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint8Array(o, X), Y = new CompressedTextureResource(V, {\n        format: z,\n        width: N,\n        height: D,\n        levels: k\n        // CompressedTextureResource will separate the levelBuffers for us!\n      });\n      return [Y];\n    }\n    var q = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, W = new Uint32Array(t.buffer, q, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), K = W[DDS_DX10_FIELDS.DXGI_FORMAT], Z = W[DDS_DX10_FIELDS.RESOURCE_DIMENSION], J = W[DDS_DX10_FIELDS.MISC_FLAG], Q = W[DDS_DX10_FIELDS.ARRAY_SIZE], et = DXGI_TO_FORMAT[K];\n    if (et === void 0)\n      throw new Error(\"DDSParser cannot parse texture data with DXGI format \" + K);\n    if (J === DDS_RESOURCE_MISC_TEXTURECUBE)\n      throw new Error(\"DDSParser does not support cubemap textures\");\n    if (Z === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n      throw new Error(\"DDSParser does not supported 3D texture data\");\n    var nt = new Array(), tt = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (Q === 1)\n      nt.push(new Uint8Array(o, tt));\n    else {\n      for (var it = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[et], st = 0, at = N, ut = D, ft = 0; ft < k; ft++) {\n        var ct = Math.max(1, at + 3 & -4), vt = Math.max(1, ut + 3 & -4), yt = ct * vt * it;\n        st += yt, at = at >>> 1, ut = ut >>> 1;\n      }\n      for (var mt = tt, ft = 0; ft < Q; ft++)\n        nt.push(new Uint8Array(o, mt, st)), mt += st;\n    }\n    return nt.map(function(_t) {\n      return new CompressedTextureResource(_t, {\n        format: et,\n        width: N,\n        height: D,\n        levels: k\n      });\n    });\n  }\n  throw G & DDPF_RGB ? new Error(\"DDSParser does not support uncompressed texture data.\") : G & DDPF_YUV ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : G & DDPF_LUMINANCE ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : G & DDPF_ALPHA ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nvar _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES.UNSIGNED_BYTE] = 1, _a$3[TYPES.UNSIGNED_SHORT] = 2, _a$3[TYPES.INT] = 4, _a$3[TYPES.UNSIGNED_INT] = 4, _a$3[TYPES.FLOAT] = 4, _a$3[TYPES.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS.RGBA] = 4, _b[FORMATS.RGB] = 3, _b[FORMATS.RG] = 2, _b[FORMATS.RED] = 1, _b[FORMATS.LUMINANCE] = 1, _b[FORMATS.LUMINANCE_ALPHA] = 2, _b[FORMATS.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES.UNSIGNED_SHORT_5_6_5] = 2, _c);\nfunction parseKTX(o, t, e) {\n  e === void 0 && (e = !1);\n  var r = new DataView(t);\n  if (!validate(o, r))\n    return null;\n  var D = r.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, N = r.getUint32(KTX_FIELDS.GL_TYPE, D), k = r.getUint32(KTX_FIELDS.GL_FORMAT, D), $ = r.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, D), G = r.getUint32(KTX_FIELDS.PIXEL_WIDTH, D), U = r.getUint32(KTX_FIELDS.PIXEL_HEIGHT, D) || 1, z = r.getUint32(KTX_FIELDS.PIXEL_DEPTH, D) || 1, X = r.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, D) || 1, V = r.getUint32(KTX_FIELDS.NUMBER_OF_FACES, D), Y = r.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, D), q = r.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, D);\n  if (U === 0 || z !== 1)\n    throw new Error(\"Only 2D textures are supported\");\n  if (V !== 1)\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  if (X !== 1)\n    throw new Error(\"WebGL does not support array textures\");\n  var W = 4, K = 4, Z = G + 3 & -4, J = U + 3 & -4, Q = new Array(X), et = G * U;\n  N === 0 && (et = Z * J);\n  var nt;\n  if (N !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[N] ? nt = TYPES_TO_BYTES_PER_COMPONENT[N] * FORMATS_TO_COMPONENTS[k] : nt = TYPES_TO_BYTES_PER_PIXEL[N] : nt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[$], nt === void 0)\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  for (var tt = e ? parseKvData(r, q, D) : null, it = et * nt, st = it, at = G, ut = U, ft = Z, ct = J, vt = FILE_HEADER_SIZE + q, yt = 0; yt < Y; yt++) {\n    for (var mt = r.getUint32(vt, D), _t = vt + 4, Tt = 0; Tt < X; Tt++) {\n      var Pt = Q[Tt];\n      Pt || (Pt = Q[Tt] = new Array(Y)), Pt[yt] = {\n        levelID: yt,\n        // don't align mipWidth when texture not compressed! (glType not zero)\n        levelWidth: Y > 1 || N !== 0 ? at : ft,\n        levelHeight: Y > 1 || N !== 0 ? ut : ct,\n        levelBuffer: new Uint8Array(t, _t, st)\n      }, _t += st;\n    }\n    vt += mt + 4, vt = vt % 4 !== 0 ? vt + 4 - vt % 4 : vt, at = at >> 1 || 1, ut = ut >> 1 || 1, ft = at + W - 1 & ~(W - 1), ct = ut + K - 1 & ~(K - 1), st = ft * ct * nt;\n  }\n  return N !== 0 ? {\n    uncompressed: Q.map(function(St) {\n      var gt = St[0].levelBuffer, bt = !1;\n      return N === TYPES.FLOAT ? gt = new Float32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4) : N === TYPES.UNSIGNED_INT ? (bt = !0, gt = new Uint32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)) : N === TYPES.INT && (bt = !0, gt = new Int32Array(St[0].levelBuffer.buffer, St[0].levelBuffer.byteOffset, St[0].levelBuffer.byteLength / 4)), {\n        resource: new BufferResource(gt, {\n          width: St[0].levelWidth,\n          height: St[0].levelHeight\n        }),\n        type: N,\n        format: bt ? convertFormatToInteger(k) : k\n      };\n    }),\n    kvData: tt\n  } : {\n    compressed: Q.map(function(St) {\n      return new CompressedTextureResource(null, {\n        format: $,\n        width: G,\n        height: U,\n        levels: Y,\n        levelBuffers: St\n      });\n    }),\n    kvData: tt\n  };\n}\nfunction validate(o, t) {\n  for (var e = 0; e < FILE_IDENTIFIER.length; e++)\n    if (t.getUint8(e) !== FILE_IDENTIFIER[e])\n      return console.error(o + \" is not a valid *.ktx file!\"), !1;\n  return !0;\n}\nfunction convertFormatToInteger(o) {\n  switch (o) {\n    case FORMATS.RGBA:\n      return FORMATS.RGBA_INTEGER;\n    case FORMATS.RGB:\n      return FORMATS.RGB_INTEGER;\n    case FORMATS.RG:\n      return FORMATS.RG_INTEGER;\n    case FORMATS.RED:\n      return FORMATS.RED_INTEGER;\n    default:\n      return o;\n  }\n}\nfunction parseKvData(o, t, e) {\n  for (var r = /* @__PURE__ */ new Map(), D = 0; D < t; ) {\n    var N = o.getUint32(FILE_HEADER_SIZE + D, e), k = FILE_HEADER_SIZE + D + 4, $ = 3 - (N + 3) % 4;\n    if (N === 0 || N > t - D) {\n      console.error(\"KTXLoader: keyAndValueByteSize out of bounds\");\n      break;\n    }\n    for (var G = 0; G < N && o.getUint8(k + G) !== 0; G++)\n      ;\n    if (G === -1) {\n      console.error(\"KTXLoader: Failed to find null byte terminating kvData key\");\n      break;\n    }\n    var U = new TextDecoder().decode(new Uint8Array(o.buffer, k, G)), z = new DataView(o.buffer, k + G + 1, N - G - 1);\n    r.set(U, z), D += 4 + N + $;\n  }\n  return r;\n}\nLoaderResource.setExtensionXhrType(\"dds\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar DDSLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.use = function(t, e) {\n      if (t.extension === \"dds\" && t.data)\n        try {\n          Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));\n        } catch (r) {\n          e(r);\n          return;\n        }\n      e();\n    }, o.extension = ExtensionType.Loader, o;\n  }()\n);\nLoaderResource.setExtensionXhrType(\"ktx\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar KTXLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.use = function(t, e) {\n      if (t.extension === \"ktx\" && t.data)\n        try {\n          var r = t.name || t.url, D = parseKTX(r, t.data, this.loadKeyValueData), N = D.compressed, k = D.uncompressed, $ = D.kvData;\n          if (N) {\n            var G = registerCompressedTextures(r, N, t.metadata);\n            if ($ && G.textures)\n              for (var U in G.textures)\n                G.textures[U].baseTexture.ktxKeyValueData = $;\n            Object.assign(t, G);\n          } else if (k) {\n            var z = {};\n            k.forEach(function(X, V) {\n              var Y = new Texture(new BaseTexture(X.resource, {\n                mipmap: MIPMAP_MODES.OFF,\n                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                type: X.type,\n                format: X.format\n              })), q = r + \"-\" + (V + 1);\n              $ && (Y.baseTexture.ktxKeyValueData = $), BaseTexture.addToCache(Y.baseTexture, q), Texture.addToCache(Y, q), V === 0 && (z[r] = Y, BaseTexture.addToCache(Y.baseTexture, r), Texture.addToCache(Y, r)), z[q] = Y;\n            }), Object.assign(t, { textures: z });\n          }\n        } catch (X) {\n          e(X);\n          return;\n        }\n      e();\n    }, o.extension = ExtensionType.Loader, o.loadKeyValueData = !1, o;\n  }()\n);\n/*!\n * @pixi/particle-container - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/particle-container is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$m = function(o, t) {\n  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$m(o, t);\n};\nfunction __extends$m(o, t) {\n  extendStatics$m(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\n(function(o) {\n  __extends$m(t, o);\n  function t(e, r, D, N) {\n    e === void 0 && (e = 1500), D === void 0 && (D = 16384), N === void 0 && (N = !1);\n    var k = o.call(this) || this, $ = 16384;\n    return D > $ && (D = $), k._properties = [!1, !0, !1, !1, !1], k._maxSize = e, k._batchSize = D, k._buffers = null, k._bufferUpdateIDs = [], k._updateID = 0, k.interactiveChildren = !1, k.blendMode = BLEND_MODES.NORMAL, k.autoResize = N, k.roundPixels = !0, k.baseTexture = null, k.setProperties(r), k._tint = 0, k.tintRgb = new Float32Array(4), k.tint = 16777215, k;\n  }\n  return t.prototype.setProperties = function(e) {\n    e && (this._properties[0] = \"vertices\" in e || \"scale\" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = \"position\" in e ? !!e.position : this._properties[1], this._properties[2] = \"rotation\" in e ? !!e.rotation : this._properties[2], this._properties[3] = \"uvs\" in e ? !!e.uvs : this._properties[3], this._properties[4] = \"tint\" in e || \"alpha\" in e ? !!e.tint || !!e.alpha : this._properties[4]);\n  }, t.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * @default 0xFFFFFF\n     */\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, hex2rgb(e, this.tintRgb);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.render = function(e) {\n    var r = this;\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", function() {\n      return r.onChildrenChange(0);\n    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));\n  }, t.prototype.onChildrenChange = function(e) {\n    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[r] = ++this._updateID;\n  }, t.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var e = 0; e < this._buffers.length; ++e)\n        this._buffers[e].destroy();\n      this._buffers = null;\n    }\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }, t;\n})(Container);\nvar ParticleBuffer = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      this.geometry = new Geometry(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];\n      for (var D = 0; D < t.length; ++D) {\n        var N = t[D];\n        N = {\n          attributeName: N.attributeName,\n          size: N.size,\n          uploadFunction: N.uploadFunction,\n          type: N.type || TYPES.FLOAT,\n          offset: N.offset\n        }, e[D] ? this.dynamicProperties.push(N) : this.staticProperties.push(N);\n      }\n      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n    }\n    return o.prototype.initBuffers = function() {\n      var t = this.geometry, e = 0;\n      this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;\n      for (var r = 0; r < this.dynamicProperties.length; ++r) {\n        var D = this.dynamicProperties[r];\n        D.offset = e, e += D.size, this.dynamicStride += D.size;\n      }\n      var N = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n      this.dynamicData = new Float32Array(N), this.dynamicDataUint32 = new Uint32Array(N), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);\n      var k = 0;\n      this.staticStride = 0;\n      for (var r = 0; r < this.staticProperties.length; ++r) {\n        var D = this.staticProperties[r];\n        D.offset = k, k += D.size, this.staticStride += D.size;\n      }\n      var $ = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n      this.staticData = new Float32Array($), this.staticDataUint32 = new Uint32Array($), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);\n      for (var r = 0; r < this.dynamicProperties.length; ++r) {\n        var D = this.dynamicProperties[r];\n        t.addAttribute(D.attributeName, this.dynamicBuffer, 0, D.type === TYPES.UNSIGNED_BYTE, D.type, this.dynamicStride * 4, D.offset * 4);\n      }\n      for (var r = 0; r < this.staticProperties.length; ++r) {\n        var D = this.staticProperties[r];\n        t.addAttribute(D.attributeName, this.staticBuffer, 0, D.type === TYPES.UNSIGNED_BYTE, D.type, this.staticStride * 4, D.offset * 4);\n      }\n    }, o.prototype.uploadDynamic = function(t, e, r) {\n      for (var D = 0; D < this.dynamicProperties.length; D++) {\n        var N = this.dynamicProperties[D];\n        N.uploadFunction(t, e, r, N.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, N.offset);\n      }\n      this.dynamicBuffer._updateID++;\n    }, o.prototype.uploadStatic = function(t, e, r) {\n      for (var D = 0; D < this.staticProperties.length; D++) {\n        var N = this.staticProperties[D];\n        N.uploadFunction(t, e, r, N.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, N.offset);\n      }\n      this.staticBuffer._updateID++;\n    }, o.prototype.destroy = function() {\n      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n    }, o;\n  }()\n), fragment$6 = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`, vertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`, ParticleRenderer = (\n  /** @class */\n  function(o) {\n    __extends$m(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return r.shader = null, r.properties = null, r.tempMatrix = new Matrix(), r.properties = [\n        // verticesData\n        {\n          attributeName: \"aVertexPosition\",\n          size: 2,\n          uploadFunction: r.uploadVertices,\n          offset: 0\n        },\n        // positionData\n        {\n          attributeName: \"aPositionCoord\",\n          size: 2,\n          uploadFunction: r.uploadPosition,\n          offset: 0\n        },\n        // rotationData\n        {\n          attributeName: \"aRotation\",\n          size: 1,\n          uploadFunction: r.uploadRotation,\n          offset: 0\n        },\n        // uvsData\n        {\n          attributeName: \"aTextureCoord\",\n          size: 2,\n          uploadFunction: r.uploadUvs,\n          offset: 0\n        },\n        // tintData\n        {\n          attributeName: \"aColor\",\n          size: 1,\n          type: TYPES.UNSIGNED_BYTE,\n          uploadFunction: r.uploadTint,\n          offset: 0\n        }\n      ], r.shader = Shader.from(vertex$3, fragment$6, {}), r.state = State.for2d(), r;\n    }\n    return t.prototype.render = function(e) {\n      var r = e.children, D = e._maxSize, N = e._batchSize, k = this.renderer, $ = r.length;\n      if ($ !== 0) {\n        $ > D && !e.autoResize && ($ = D);\n        var G = e._buffers;\n        G || (G = e._buffers = this.generateBuffers(e));\n        var U = r[0]._texture.baseTexture, z = U.alphaMode > 0;\n        this.state.blendMode = correctBlendMode(e.blendMode, z), k.state.set(this.state);\n        var X = k.gl, V = e.worldTransform.copyTo(this.tempMatrix);\n        V.prepend(k.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = V.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, z), this.shader.uniforms.uSampler = U, this.renderer.shader.bind(this.shader);\n        for (var Y = !1, q = 0, W = 0; q < $; q += N, W += 1) {\n          var K = $ - q;\n          K > N && (K = N), W >= G.length && G.push(this._generateOneMoreBuffer(e));\n          var Z = G[W];\n          Z.uploadDynamic(r, q, K);\n          var J = e._bufferUpdateIDs[W] || 0;\n          Y = Y || Z._updateID < J, Y && (Z._updateID = e._updateID, Z.uploadStatic(r, q, K)), k.geometry.bind(Z.geometry), X.drawElements(X.TRIANGLES, K * 6, X.UNSIGNED_SHORT, 0);\n        }\n      }\n    }, t.prototype.generateBuffers = function(e) {\n      for (var r = [], D = e._maxSize, N = e._batchSize, k = e._properties, $ = 0; $ < D; $ += N)\n        r.push(new ParticleBuffer(this.properties, k, N));\n      return r;\n    }, t.prototype._generateOneMoreBuffer = function(e) {\n      var r = e._batchSize, D = e._properties;\n      return new ParticleBuffer(this.properties, D, r);\n    }, t.prototype.uploadVertices = function(e, r, D, N, k, $) {\n      for (var G = 0, U = 0, z = 0, X = 0, V = 0; V < D; ++V) {\n        var Y = e[r + V], q = Y._texture, W = Y.scale.x, K = Y.scale.y, Z = q.trim, J = q.orig;\n        Z ? (U = Z.x - Y.anchor.x * J.width, G = U + Z.width, X = Z.y - Y.anchor.y * J.height, z = X + Z.height) : (G = J.width * (1 - Y.anchor.x), U = J.width * -Y.anchor.x, z = J.height * (1 - Y.anchor.y), X = J.height * -Y.anchor.y), N[$] = U * W, N[$ + 1] = X * K, N[$ + k] = G * W, N[$ + k + 1] = X * K, N[$ + k * 2] = G * W, N[$ + k * 2 + 1] = z * K, N[$ + k * 3] = U * W, N[$ + k * 3 + 1] = z * K, $ += k * 4;\n      }\n    }, t.prototype.uploadPosition = function(e, r, D, N, k, $) {\n      for (var G = 0; G < D; G++) {\n        var U = e[r + G].position;\n        N[$] = U.x, N[$ + 1] = U.y, N[$ + k] = U.x, N[$ + k + 1] = U.y, N[$ + k * 2] = U.x, N[$ + k * 2 + 1] = U.y, N[$ + k * 3] = U.x, N[$ + k * 3 + 1] = U.y, $ += k * 4;\n      }\n    }, t.prototype.uploadRotation = function(e, r, D, N, k, $) {\n      for (var G = 0; G < D; G++) {\n        var U = e[r + G].rotation;\n        N[$] = U, N[$ + k] = U, N[$ + k * 2] = U, N[$ + k * 3] = U, $ += k * 4;\n      }\n    }, t.prototype.uploadUvs = function(e, r, D, N, k, $) {\n      for (var G = 0; G < D; ++G) {\n        var U = e[r + G]._texture._uvs;\n        U ? (N[$] = U.x0, N[$ + 1] = U.y0, N[$ + k] = U.x1, N[$ + k + 1] = U.y1, N[$ + k * 2] = U.x2, N[$ + k * 2 + 1] = U.y2, N[$ + k * 3] = U.x3, N[$ + k * 3 + 1] = U.y3, $ += k * 4) : (N[$] = 0, N[$ + 1] = 0, N[$ + k] = 0, N[$ + k + 1] = 0, N[$ + k * 2] = 0, N[$ + k * 2 + 1] = 0, N[$ + k * 3] = 0, N[$ + k * 3 + 1] = 0, $ += k * 4);\n      }\n    }, t.prototype.uploadTint = function(e, r, D, N, k, $) {\n      for (var G = 0; G < D; ++G) {\n        var U = e[r + G], z = U._texture.baseTexture.alphaMode > 0, X = U.alpha, V = X < 1 && z ? premultiplyTint(U._tintRGB, X) : U._tintRGB + (X * 255 << 24);\n        N[$] = V, N[$ + k] = V, N[$ + k * 2] = V, N[$ + k * 3] = V, $ += k * 4;\n      }\n    }, t.prototype.destroy = function() {\n      o.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n    }, t.extension = {\n      name: \"particle\",\n      type: ExtensionType.RendererPlugin\n    }, t;\n  }(ObjectRenderer)\n);\n/*!\n * @pixi/graphics - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar LINE_JOIN;\n(function(o) {\n  o.MITER = \"miter\", o.BEVEL = \"bevel\", o.ROUND = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\nvar LINE_CAP;\n(function(o) {\n  o.BUTT = \"butt\", o.ROUND = \"round\", o.SQUARE = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\nvar GRAPHICS_CURVES = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(o, t) {\n    if (t === void 0 && (t = 20), !this.adaptive || !o || isNaN(o))\n      return t;\n    var e = Math.ceil(o / this.maxLength);\n    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;\n  }\n}, FillStyle = (\n  /** @class */\n  function() {\n    function o() {\n      this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();\n    }\n    return o.prototype.clone = function() {\n      var t = new o();\n      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;\n    }, o.prototype.reset = function() {\n      this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;\n    }, o.prototype.destroy = function() {\n      this.texture = null, this.matrix = null;\n    }, o;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$l = function(o, t) {\n  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$l(o, t);\n};\nfunction __extends$l(o, t) {\n  extendStatics$l(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction fixOrientation(o, t) {\n  var e, r;\n  t === void 0 && (t = !1);\n  var D = o.length;\n  if (!(D < 6)) {\n    for (var N = 0, k = 0, $ = o[D - 2], G = o[D - 1]; k < D; k += 2) {\n      var U = o[k], z = o[k + 1];\n      N += (U - $) * (z + G), $ = U, G = z;\n    }\n    if (!t && N > 0 || t && N <= 0)\n      for (var X = D / 2, k = X + X % 2; k < D; k += 2) {\n        var V = D - k - 2, Y = D - k - 1, q = k, W = k + 1;\n        e = [o[q], o[V]], o[V] = e[0], o[q] = e[1], r = [o[W], o[Y]], o[Y] = r[0], o[W] = r[1];\n      }\n  }\n}\nvar buildPoly = {\n  build: function(o) {\n    o.points = o.shape.points.slice();\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = o.holes, D = t.points, N = t.indices;\n    if (e.length >= 6) {\n      fixOrientation(e, !1);\n      for (var k = [], $ = 0; $ < r.length; $++) {\n        var G = r[$];\n        fixOrientation(G.points, !0), k.push(e.length / 2), e = e.concat(G.points);\n      }\n      var U = earcutExports(e, k, 2);\n      if (!U)\n        return;\n      for (var z = D.length / 2, $ = 0; $ < U.length; $ += 3)\n        N.push(U[$] + z), N.push(U[$ + 1] + z), N.push(U[$ + 2] + z);\n      for (var $ = 0; $ < e.length; $++)\n        D.push(e[$]);\n    }\n  }\n}, buildCircle = {\n  build: function(o) {\n    var t = o.points, e, r, D, N, k, $;\n    if (o.type === SHAPES.CIRC) {\n      var G = o.shape;\n      e = G.x, r = G.y, k = $ = G.radius, D = N = 0;\n    } else if (o.type === SHAPES.ELIP) {\n      var U = o.shape;\n      e = U.x, r = U.y, k = U.width, $ = U.height, D = N = 0;\n    } else {\n      var z = o.shape, X = z.width / 2, V = z.height / 2;\n      e = z.x + X, r = z.y + V, k = $ = Math.max(0, Math.min(z.radius, Math.min(X, V))), D = X - k, N = V - $;\n    }\n    if (!(k >= 0 && $ >= 0 && D >= 0 && N >= 0)) {\n      t.length = 0;\n      return;\n    }\n    var Y = Math.ceil(2.3 * Math.sqrt(k + $)), q = Y * 8 + (D ? 4 : 0) + (N ? 4 : 0);\n    if (t.length = q, q !== 0) {\n      if (Y === 0) {\n        t.length = 8, t[0] = t[6] = e + D, t[1] = t[3] = r + N, t[2] = t[4] = e - D, t[5] = t[7] = r - N;\n        return;\n      }\n      var W = 0, K = Y * 4 + (D ? 2 : 0) + 2, Z = K, J = q;\n      {\n        var Q = D + k, et = N, nt = e + Q, tt = e - Q, it = r + et;\n        if (t[W++] = nt, t[W++] = it, t[--K] = it, t[--K] = tt, N) {\n          var st = r - et;\n          t[Z++] = tt, t[Z++] = st, t[--J] = st, t[--J] = nt;\n        }\n      }\n      for (var at = 1; at < Y; at++) {\n        var ut = Math.PI / 2 * (at / Y), Q = D + Math.cos(ut) * k, et = N + Math.sin(ut) * $, nt = e + Q, tt = e - Q, it = r + et, st = r - et;\n        t[W++] = nt, t[W++] = it, t[--K] = it, t[--K] = tt, t[Z++] = tt, t[Z++] = st, t[--J] = st, t[--J] = nt;\n      }\n      {\n        var Q = D, et = N + $, nt = e + Q, tt = e - Q, it = r + et, st = r - et;\n        t[W++] = nt, t[W++] = it, t[--J] = st, t[--J] = nt, D && (t[W++] = tt, t[W++] = it, t[--J] = st, t[--J] = tt);\n      }\n    }\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = t.points, D = t.indices;\n    if (e.length !== 0) {\n      var N = r.length / 2, k = N, $, G;\n      if (o.type !== SHAPES.RREC) {\n        var U = o.shape;\n        $ = U.x, G = U.y;\n      } else {\n        var z = o.shape;\n        $ = z.x + z.width / 2, G = z.y + z.height / 2;\n      }\n      var X = o.matrix;\n      r.push(o.matrix ? X.a * $ + X.c * G + X.tx : $, o.matrix ? X.b * $ + X.d * G + X.ty : G), N++, r.push(e[0], e[1]);\n      for (var V = 2; V < e.length; V += 2)\n        r.push(e[V], e[V + 1]), D.push(N++, k, N);\n      D.push(k + 1, k, N);\n    }\n  }\n}, buildRectangle = {\n  build: function(o) {\n    var t = o.shape, e = t.x, r = t.y, D = t.width, N = t.height, k = o.points;\n    k.length = 0, k.push(e, r, e + D, r, e + D, r + N, e, r + N);\n  },\n  triangulate: function(o, t) {\n    var e = o.points, r = t.points, D = r.length / 2;\n    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(D, D + 1, D + 2, D + 1, D + 2, D + 3);\n  }\n};\nfunction getPt(o, t, e) {\n  var r = t - o;\n  return o + r * e;\n}\nfunction quadraticBezierCurve(o, t, e, r, D, N, k) {\n  k === void 0 && (k = []);\n  for (var $ = 20, G = k, U = 0, z = 0, X = 0, V = 0, Y = 0, q = 0, W = 0, K = 0; W <= $; ++W)\n    K = W / $, U = getPt(o, e, K), z = getPt(t, r, K), X = getPt(e, D, K), V = getPt(r, N, K), Y = getPt(U, X, K), q = getPt(z, V, K), !(W === 0 && G[G.length - 2] === Y && G[G.length - 1] === q) && G.push(Y, q);\n  return G;\n}\nvar buildRoundedRectangle = {\n  build: function(o) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(o);\n      return;\n    }\n    var t = o.shape, e = o.points, r = t.x, D = t.y, N = t.width, k = t.height, $ = Math.max(0, Math.min(t.radius, Math.min(N, k) / 2));\n    e.length = 0, $ ? (quadraticBezierCurve(r, D + $, r, D, r + $, D, e), quadraticBezierCurve(r + N - $, D, r + N, D, r + N, D + $, e), quadraticBezierCurve(r + N, D + k - $, r + N, D + k, r + N - $, D + k, e), quadraticBezierCurve(r + $, D + k, r, D + k, r, D + k - $, e)) : e.push(r, D, r + N, D, r + N, D + k, r, D + k);\n  },\n  triangulate: function(o, t) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(o, t);\n      return;\n    }\n    for (var e = o.points, r = t.points, D = t.indices, N = r.length / 2, k = earcutExports(e, null, 2), $ = 0, G = k.length; $ < G; $ += 3)\n      D.push(k[$] + N), D.push(k[$ + 1] + N), D.push(k[$ + 2] + N);\n    for (var $ = 0, G = e.length; $ < G; $++)\n      r.push(e[$], e[++$]);\n  }\n};\nfunction square(o, t, e, r, D, N, k, $) {\n  var G = o - e * D, U = t - r * D, z = o + e * N, X = t + r * N, V, Y;\n  k ? (V = r, Y = -e) : (V = -r, Y = e);\n  var q = G + V, W = U + Y, K = z + V, Z = X + Y;\n  return $.push(q, W), $.push(K, Z), 2;\n}\nfunction round$1(o, t, e, r, D, N, k, $) {\n  var G = e - o, U = r - t, z = Math.atan2(G, U), X = Math.atan2(D - o, N - t);\n  $ && z < X ? z += Math.PI * 2 : !$ && z > X && (X += Math.PI * 2);\n  var V = z, Y = X - z, q = Math.abs(Y), W = Math.sqrt(G * G + U * U), K = (15 * q * Math.sqrt(W) / Math.PI >> 0) + 1, Z = Y / K;\n  if (V += Z, $) {\n    k.push(o, t), k.push(e, r);\n    for (var J = 1, Q = V; J < K; J++, Q += Z)\n      k.push(o, t), k.push(o + Math.sin(Q) * W, t + Math.cos(Q) * W);\n    k.push(o, t), k.push(D, N);\n  } else {\n    k.push(e, r), k.push(o, t);\n    for (var J = 1, Q = V; J < K; J++, Q += Z)\n      k.push(o + Math.sin(Q) * W, t + Math.cos(Q) * W), k.push(o, t);\n    k.push(D, N), k.push(o, t);\n  }\n  return K * 2;\n}\nfunction buildNonNativeLine(o, t) {\n  var e = o.shape, r = o.points || e.points.slice(), D = t.closePointEps;\n  if (r.length !== 0) {\n    var N = o.lineStyle, k = new Point(r[0], r[1]), $ = new Point(r[r.length - 2], r[r.length - 1]), G = e.type !== SHAPES.POLY || e.closeStroke, U = Math.abs(k.x - $.x) < D && Math.abs(k.y - $.y) < D;\n    if (G) {\n      r = r.slice(), U && (r.pop(), r.pop(), $.set(r[r.length - 2], r[r.length - 1]));\n      var z = (k.x + $.x) * 0.5, X = ($.y + k.y) * 0.5;\n      r.unshift(z, X), r.push(z, X);\n    }\n    var V = t.points, Y = r.length / 2, q = r.length, W = V.length / 2, K = N.width / 2, Z = K * K, J = N.miterLimit * N.miterLimit, Q = r[0], et = r[1], nt = r[2], tt = r[3], it = 0, st = 0, at = -(et - tt), ut = Q - nt, ft = 0, ct = 0, vt = Math.sqrt(at * at + ut * ut);\n    at /= vt, ut /= vt, at *= K, ut *= K;\n    var yt = N.alignment, mt = (1 - yt) * 2, _t = yt * 2;\n    G || (N.cap === LINE_CAP.ROUND ? q += round$1(Q - at * (mt - _t) * 0.5, et - ut * (mt - _t) * 0.5, Q - at * mt, et - ut * mt, Q + at * _t, et + ut * _t, V, !0) + 2 : N.cap === LINE_CAP.SQUARE && (q += square(Q, et, at, ut, mt, _t, !0, V))), V.push(Q - at * mt, et - ut * mt), V.push(Q + at * _t, et + ut * _t);\n    for (var Tt = 1; Tt < Y - 1; ++Tt) {\n      Q = r[(Tt - 1) * 2], et = r[(Tt - 1) * 2 + 1], nt = r[Tt * 2], tt = r[Tt * 2 + 1], it = r[(Tt + 1) * 2], st = r[(Tt + 1) * 2 + 1], at = -(et - tt), ut = Q - nt, vt = Math.sqrt(at * at + ut * ut), at /= vt, ut /= vt, at *= K, ut *= K, ft = -(tt - st), ct = nt - it, vt = Math.sqrt(ft * ft + ct * ct), ft /= vt, ct /= vt, ft *= K, ct *= K;\n      var Pt = nt - Q, St = et - tt, gt = nt - it, bt = st - tt, Nt = Pt * gt + St * bt, At = St * gt - bt * Pt, It = At < 0;\n      if (Math.abs(At) < 1e-3 * Math.abs(Nt)) {\n        V.push(nt - at * mt, tt - ut * mt), V.push(nt + at * _t, tt + ut * _t), Nt >= 0 && (N.join === LINE_JOIN.ROUND ? q += round$1(nt, tt, nt - at * mt, tt - ut * mt, nt - ft * mt, tt - ct * mt, V, !1) + 4 : q += 2, V.push(nt - ft * _t, tt - ct * _t), V.push(nt + ft * mt, tt + ct * mt));\n        continue;\n      }\n      var Mt = (-at + Q) * (-ut + tt) - (-at + nt) * (-ut + et), dt = (-ft + it) * (-ct + tt) - (-ft + nt) * (-ct + st), $t = (Pt * dt - gt * Mt) / At, Dt = (bt * Mt - St * dt) / At, Vt = ($t - nt) * ($t - nt) + (Dt - tt) * (Dt - tt), Lt = nt + ($t - nt) * mt, Et = tt + (Dt - tt) * mt, Ht = nt - ($t - nt) * _t, kt = tt - (Dt - tt) * _t, wt = Math.min(Pt * Pt + St * St, gt * gt + bt * bt), Bt = It ? mt : _t, jt = wt + Bt * Bt * Z, Ct = Vt <= jt;\n      Ct ? N.join === LINE_JOIN.BEVEL || Vt / Z > J ? (It ? (V.push(Lt, Et), V.push(nt + at * _t, tt + ut * _t), V.push(Lt, Et), V.push(nt + ft * _t, tt + ct * _t)) : (V.push(nt - at * mt, tt - ut * mt), V.push(Ht, kt), V.push(nt - ft * mt, tt - ct * mt), V.push(Ht, kt)), q += 2) : N.join === LINE_JOIN.ROUND ? It ? (V.push(Lt, Et), V.push(nt + at * _t, tt + ut * _t), q += round$1(nt, tt, nt + at * _t, tt + ut * _t, nt + ft * _t, tt + ct * _t, V, !0) + 4, V.push(Lt, Et), V.push(nt + ft * _t, tt + ct * _t)) : (V.push(nt - at * mt, tt - ut * mt), V.push(Ht, kt), q += round$1(nt, tt, nt - at * mt, tt - ut * mt, nt - ft * mt, tt - ct * mt, V, !1) + 4, V.push(nt - ft * mt, tt - ct * mt), V.push(Ht, kt)) : (V.push(Lt, Et), V.push(Ht, kt)) : (V.push(nt - at * mt, tt - ut * mt), V.push(nt + at * _t, tt + ut * _t), N.join === LINE_JOIN.ROUND ? It ? q += round$1(nt, tt, nt + at * _t, tt + ut * _t, nt + ft * _t, tt + ct * _t, V, !0) + 2 : q += round$1(nt, tt, nt - at * mt, tt - ut * mt, nt - ft * mt, tt - ct * mt, V, !1) + 2 : N.join === LINE_JOIN.MITER && Vt / Z <= J && (It ? (V.push(Ht, kt), V.push(Ht, kt)) : (V.push(Lt, Et), V.push(Lt, Et)), q += 2), V.push(nt - ft * mt, tt - ct * mt), V.push(nt + ft * _t, tt + ct * _t), q += 2);\n    }\n    Q = r[(Y - 2) * 2], et = r[(Y - 2) * 2 + 1], nt = r[(Y - 1) * 2], tt = r[(Y - 1) * 2 + 1], at = -(et - tt), ut = Q - nt, vt = Math.sqrt(at * at + ut * ut), at /= vt, ut /= vt, at *= K, ut *= K, V.push(nt - at * mt, tt - ut * mt), V.push(nt + at * _t, tt + ut * _t), G || (N.cap === LINE_CAP.ROUND ? q += round$1(nt - at * (mt - _t) * 0.5, tt - ut * (mt - _t) * 0.5, nt - at * mt, tt - ut * mt, nt + at * _t, tt + ut * _t, V, !1) + 2 : N.cap === LINE_CAP.SQUARE && (q += square(nt, tt, at, ut, mt, _t, !1, V)));\n    for (var qt = t.indices, Qt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, Tt = W; Tt < q + W - 2; ++Tt)\n      Q = V[Tt * 2], et = V[Tt * 2 + 1], nt = V[(Tt + 1) * 2], tt = V[(Tt + 1) * 2 + 1], it = V[(Tt + 2) * 2], st = V[(Tt + 2) * 2 + 1], !(Math.abs(Q * (tt - st) + nt * (st - et) + it * (et - tt)) < Qt) && qt.push(Tt, Tt + 1, Tt + 2);\n  }\n}\nfunction buildNativeLine(o, t) {\n  var e = 0, r = o.shape, D = o.points || r.points, N = r.type !== SHAPES.POLY || r.closeStroke;\n  if (D.length !== 0) {\n    var k = t.points, $ = t.indices, G = D.length / 2, U = k.length / 2, z = U;\n    for (k.push(D[0], D[1]), e = 1; e < G; e++)\n      k.push(D[e * 2], D[e * 2 + 1]), $.push(z, z + 1), z++;\n    N && $.push(z, U);\n  }\n}\nfunction buildLine(o, t) {\n  o.lineStyle.native ? buildNativeLine(o, t) : buildNonNativeLine(o, t);\n}\nvar ArcUtils = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.curveTo = function(t, e, r, D, N, k) {\n      var $ = k[k.length - 2], G = k[k.length - 1], U = G - e, z = $ - t, X = D - e, V = r - t, Y = Math.abs(U * V - z * X);\n      if (Y < 1e-8 || N === 0)\n        return (k[k.length - 2] !== t || k[k.length - 1] !== e) && k.push(t, e), null;\n      var q = U * U + z * z, W = X * X + V * V, K = U * X + z * V, Z = N * Math.sqrt(q) / Y, J = N * Math.sqrt(W) / Y, Q = Z * K / q, et = J * K / W, nt = Z * V + J * z, tt = Z * X + J * U, it = z * (J + Q), st = U * (J + Q), at = V * (Z + et), ut = X * (Z + et), ft = Math.atan2(st - tt, it - nt), ct = Math.atan2(ut - tt, at - nt);\n      return {\n        cx: nt + t,\n        cy: tt + e,\n        radius: N,\n        startAngle: ft,\n        endAngle: ct,\n        anticlockwise: z * X > V * U\n      };\n    }, o.arc = function(t, e, r, D, N, k, $, G, U) {\n      for (var z = $ - k, X = GRAPHICS_CURVES._segmentsCount(Math.abs(z) * N, Math.ceil(Math.abs(z) / PI_2) * 40), V = z / (X * 2), Y = V * 2, q = Math.cos(V), W = Math.sin(V), K = X - 1, Z = K % 1 / K, J = 0; J <= K; ++J) {\n        var Q = J + Z * J, et = V + k + Y * Q, nt = Math.cos(et), tt = -Math.sin(et);\n        U.push((q * nt + W * tt) * N + r, (q * -tt + W * nt) * N + D);\n      }\n    }, o;\n  }()\n), BezierUtils = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.curveLength = function(t, e, r, D, N, k, $, G) {\n      for (var U = 10, z = 0, X = 0, V = 0, Y = 0, q = 0, W = 0, K = 0, Z = 0, J = 0, Q = 0, et = 0, nt = t, tt = e, it = 1; it <= U; ++it)\n        X = it / U, V = X * X, Y = V * X, q = 1 - X, W = q * q, K = W * q, Z = K * t + 3 * W * X * r + 3 * q * V * N + Y * $, J = K * e + 3 * W * X * D + 3 * q * V * k + Y * G, Q = nt - Z, et = tt - J, nt = Z, tt = J, z += Math.sqrt(Q * Q + et * et);\n      return z;\n    }, o.curveTo = function(t, e, r, D, N, k, $) {\n      var G = $[$.length - 2], U = $[$.length - 1];\n      $.length -= 2;\n      var z = GRAPHICS_CURVES._segmentsCount(o.curveLength(G, U, t, e, r, D, N, k)), X = 0, V = 0, Y = 0, q = 0, W = 0;\n      $.push(G, U);\n      for (var K = 1, Z = 0; K <= z; ++K)\n        Z = K / z, X = 1 - Z, V = X * X, Y = V * X, q = Z * Z, W = q * Z, $.push(Y * G + 3 * V * Z * t + 3 * X * q * r + W * N, Y * U + 3 * V * Z * e + 3 * X * q * D + W * k);\n    }, o;\n  }()\n), QuadraticUtils = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.curveLength = function(t, e, r, D, N, k) {\n      var $ = t - 2 * r + N, G = e - 2 * D + k, U = 2 * r - 2 * t, z = 2 * D - 2 * e, X = 4 * ($ * $ + G * G), V = 4 * ($ * U + G * z), Y = U * U + z * z, q = 2 * Math.sqrt(X + V + Y), W = Math.sqrt(X), K = 2 * X * W, Z = 2 * Math.sqrt(Y), J = V / W;\n      return (K * q + W * V * (q - Z) + (4 * Y * X - V * V) * Math.log((2 * W + J + q) / (J + Z))) / (4 * K);\n    }, o.curveTo = function(t, e, r, D, N) {\n      for (var k = N[N.length - 2], $ = N[N.length - 1], G = GRAPHICS_CURVES._segmentsCount(o.curveLength(k, $, t, e, r, D)), U = 0, z = 0, X = 1; X <= G; ++X) {\n        var V = X / G;\n        U = k + (t - k) * V, z = $ + (e - $) * V, N.push(U + (t + (r - t) * V - U) * V, z + (e + (D - e) * V - z) * V);\n      }\n    }, o;\n  }()\n), BatchPart = (\n  /** @class */\n  function() {\n    function o() {\n      this.reset();\n    }\n    return o.prototype.begin = function(t, e, r) {\n      this.reset(), this.style = t, this.start = e, this.attribStart = r;\n    }, o.prototype.end = function(t, e) {\n      this.attribSize = e - this.attribStart, this.size = t - this.start;\n    }, o.prototype.reset = function() {\n      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n    }, o;\n  }()\n), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = (\n  /** @class */\n  function() {\n    function o(t, e, r, D) {\n      e === void 0 && (e = null), r === void 0 && (r = null), D === void 0 && (D = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = D, this.type = t.type;\n    }\n    return o.prototype.clone = function() {\n      return new o(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n    }, o.prototype.destroy = function() {\n      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n    }, o;\n  }()\n), tmpPoint = new Point(), GraphicsGeometry = (\n  /** @class */\n  function(o) {\n    __extends$l(t, o);\n    function t() {\n      var e = o.call(this) || this;\n      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;\n    }\n    return Object.defineProperty(t.prototype, \"bounds\", {\n      /**\n       * Get the current bounds of the graphic geometry.\n       * @readonly\n       */\n      get: function() {\n        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.invalidate = function() {\n      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n      for (var e = 0; e < this.drawCalls.length; e++)\n        this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);\n      this.drawCalls.length = 0;\n      for (var e = 0; e < this.batches.length; e++) {\n        var r = this.batches[e];\n        r.reset(), BATCH_POOL.push(r);\n      }\n      this.batches.length = 0;\n    }, t.prototype.clear = function() {\n      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n    }, t.prototype.drawShape = function(e, r, D, N) {\n      r === void 0 && (r = null), D === void 0 && (D = null), N === void 0 && (N = null);\n      var k = new GraphicsData(e, r, D, N);\n      return this.graphicsData.push(k), this.dirty++, this;\n    }, t.prototype.drawHole = function(e, r) {\n      if (r === void 0 && (r = null), !this.graphicsData.length)\n        return null;\n      var D = new GraphicsData(e, null, null, r), N = this.graphicsData[this.graphicsData.length - 1];\n      return D.lineStyle = N.lineStyle, N.holes.push(D), this.dirty++, this;\n    }, t.prototype.destroy = function() {\n      o.prototype.destroy.call(this);\n      for (var e = 0; e < this.graphicsData.length; ++e)\n        this.graphicsData[e].destroy();\n      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n    }, t.prototype.containsPoint = function(e) {\n      for (var r = this.graphicsData, D = 0; D < r.length; ++D) {\n        var N = r[D];\n        if (N.fillStyle.visible && N.shape && (N.matrix ? N.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), N.shape.contains(tmpPoint.x, tmpPoint.y))) {\n          var k = !1;\n          if (N.holes)\n            for (var $ = 0; $ < N.holes.length; $++) {\n              var G = N.holes[$];\n              if (G.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                k = !0;\n                break;\n              }\n            }\n          if (!k)\n            return !0;\n        }\n      }\n      return !1;\n    }, t.prototype.updateBatches = function() {\n      if (!this.graphicsData.length) {\n        this.batchable = !0;\n        return;\n      }\n      if (this.validateBatching()) {\n        this.cacheDirty = this.dirty;\n        var e = this.uvs, r = this.graphicsData, D = null, N = null;\n        this.batches.length > 0 && (D = this.batches[this.batches.length - 1], N = D.style);\n        for (var k = this.shapeIndex; k < r.length; k++) {\n          this.shapeIndex++;\n          var $ = r[k], G = $.fillStyle, U = $.lineStyle, z = FILL_COMMANDS[$.type];\n          z.build($), $.matrix && this.transformPoints($.points, $.matrix), (G.visible || U.visible) && this.processHoles($.holes);\n          for (var X = 0; X < 2; X++) {\n            var V = X === 0 ? G : U;\n            if (V.visible) {\n              var Y = V.texture.baseTexture, q = this.indices.length, W = this.points.length / 2;\n              Y.wrapMode = WRAP_MODES.REPEAT, X === 0 ? this.processFill($) : this.processLine($);\n              var K = this.points.length / 2 - W;\n              K !== 0 && (D && !this._compareStyles(N, V) && (D.end(q, W), D = null), D || (D = BATCH_POOL.pop() || new BatchPart(), D.begin(V, q, W), this.batches.push(D), N = V), this.addUvs(this.points, e, V.texture, W, K, V.matrix));\n            }\n          }\n        }\n        var Z = this.indices.length, J = this.points.length / 2;\n        if (D && D.end(Z, J), this.batches.length === 0) {\n          this.batchable = !0;\n          return;\n        }\n        var Q = J > 65535;\n        this.indicesUint16 && this.indices.length === this.indicesUint16.length && Q === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = Q ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n      }\n    }, t.prototype._compareStyles = function(e, r) {\n      return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);\n    }, t.prototype.validateBatching = function() {\n      if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        return !1;\n      for (var e = 0, r = this.graphicsData.length; e < r; e++) {\n        var D = this.graphicsData[e], N = D.fillStyle, k = D.lineStyle;\n        if (N && !N.texture.baseTexture.valid || k && !k.texture.baseTexture.valid)\n          return !1;\n      }\n      return !0;\n    }, t.prototype.packBatches = function() {\n      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n      for (var e = this.batches, r = 0, D = e.length; r < D; r++)\n        for (var N = e[r], k = 0; k < N.size; k++) {\n          var $ = N.start + k;\n          this.indicesUint16[$] = this.indicesUint16[$] - N.attribStart;\n        }\n    }, t.prototype.isBatchable = function() {\n      if (this.points.length > 65535 * 2)\n        return !1;\n      for (var e = this.batches, r = 0; r < e.length; r++)\n        if (e[r].style.native)\n          return !1;\n      return this.points.length < t.BATCHABLE_SIZE * 2;\n    }, t.prototype.buildDrawCalls = function() {\n      for (var e = ++BaseTexture._globalBatch, r = 0; r < this.drawCalls.length; r++)\n        this.drawCalls[r].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[r]);\n      this.drawCalls.length = 0;\n      var D = this.colors, N = this.textureIds, k = DRAW_CALL_POOL.pop();\n      k || (k = new BatchDrawCall(), k.texArray = new BatchTextureArray()), k.texArray.count = 0, k.start = 0, k.size = 0, k.type = DRAW_MODES.TRIANGLES;\n      var $ = 0, G = null, U = 0, z = !1, X = DRAW_MODES.TRIANGLES, V = 0;\n      this.drawCalls.push(k);\n      for (var r = 0; r < this.batches.length; r++) {\n        var Y = this.batches[r], q = 8, W = Y.style, K = W.texture.baseTexture;\n        z !== !!W.native && (z = !!W.native, X = z ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES, G = null, $ = q, e++), G !== K && (G = K, K._batchEnabled !== e && ($ === q && (e++, $ = 0, k.size > 0 && (k = DRAW_CALL_POOL.pop(), k || (k = new BatchDrawCall(), k.texArray = new BatchTextureArray()), this.drawCalls.push(k)), k.start = V, k.size = 0, k.texArray.count = 0, k.type = X), K.touched = 1, K._batchEnabled = e, K._batchLocation = $, K.wrapMode = WRAP_MODES.REPEAT, k.texArray.elements[k.texArray.count++] = K, $++)), k.size += Y.size, V += Y.size, U = K._batchLocation, this.addColors(D, W.color, W.alpha, Y.attribSize, Y.attribStart), this.addTextureIds(N, U, Y.attribSize, Y.attribStart);\n      }\n      BaseTexture._globalBatch = e, this.packAttributes();\n    }, t.prototype.packAttributes = function() {\n      for (var e = this.points, r = this.uvs, D = this.colors, N = this.textureIds, k = new ArrayBuffer(e.length * 3 * 4), $ = new Float32Array(k), G = new Uint32Array(k), U = 0, z = 0; z < e.length / 2; z++)\n        $[U++] = e[z * 2], $[U++] = e[z * 2 + 1], $[U++] = r[z * 2], $[U++] = r[z * 2 + 1], G[U++] = D[z], $[U++] = N[z];\n      this._buffer.update(k), this._indexBuffer.update(this.indicesUint16);\n    }, t.prototype.processFill = function(e) {\n      if (e.holes.length)\n        buildPoly.triangulate(e, this);\n      else {\n        var r = FILL_COMMANDS[e.type];\n        r.triangulate(e, this);\n      }\n    }, t.prototype.processLine = function(e) {\n      buildLine(e, this);\n      for (var r = 0; r < e.holes.length; r++)\n        buildLine(e.holes[r], this);\n    }, t.prototype.processHoles = function(e) {\n      for (var r = 0; r < e.length; r++) {\n        var D = e[r], N = FILL_COMMANDS[D.type];\n        N.build(D), D.matrix && this.transformPoints(D.points, D.matrix);\n      }\n    }, t.prototype.calculateBounds = function() {\n      var e = this._bounds;\n      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);\n    }, t.prototype.transformPoints = function(e, r) {\n      for (var D = 0; D < e.length / 2; D++) {\n        var N = e[D * 2], k = e[D * 2 + 1];\n        e[D * 2] = r.a * N + r.c * k + r.tx, e[D * 2 + 1] = r.b * N + r.d * k + r.ty;\n      }\n    }, t.prototype.addColors = function(e, r, D, N, k) {\n      k === void 0 && (k = 0);\n      var $ = (r >> 16) + (r & 65280) + ((r & 255) << 16), G = premultiplyTint($, D);\n      e.length = Math.max(e.length, k + N);\n      for (var U = 0; U < N; U++)\n        e[k + U] = G;\n    }, t.prototype.addTextureIds = function(e, r, D, N) {\n      N === void 0 && (N = 0), e.length = Math.max(e.length, N + D);\n      for (var k = 0; k < D; k++)\n        e[N + k] = r;\n    }, t.prototype.addUvs = function(e, r, D, N, k, $) {\n      $ === void 0 && ($ = null);\n      for (var G = 0, U = r.length, z = D.frame; G < k; ) {\n        var X = e[(N + G) * 2], V = e[(N + G) * 2 + 1];\n        if ($) {\n          var Y = $.a * X + $.c * V + $.tx;\n          V = $.b * X + $.d * V + $.ty, X = Y;\n        }\n        G++, r.push(X / z.width, V / z.height);\n      }\n      var q = D.baseTexture;\n      (z.width < q.width || z.height < q.height) && this.adjustUvs(r, D, U, k);\n    }, t.prototype.adjustUvs = function(e, r, D, N) {\n      for (var k = r.baseTexture, $ = 1e-6, G = D + N * 2, U = r.frame, z = U.width / k.width, X = U.height / k.height, V = U.x / U.width, Y = U.y / U.height, q = Math.floor(e[D] + $), W = Math.floor(e[D + 1] + $), K = D + 2; K < G; K += 2)\n        q = Math.min(q, Math.floor(e[K] + $)), W = Math.min(W, Math.floor(e[K + 1] + $));\n      V -= q, Y -= W;\n      for (var K = D; K < G; K += 2)\n        e[K] = (e[K] + V) * z, e[K + 1] = (e[K + 1] + Y) * X;\n    }, t.BATCHABLE_SIZE = 100, t;\n  }(BatchGeometry)\n), LineStyle = (\n  /** @class */\n  function(o) {\n    __extends$l(t, o);\n    function t() {\n      var e = o !== null && o.apply(this, arguments) || this;\n      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;\n    }\n    return t.prototype.clone = function() {\n      var e = new t();\n      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;\n    }, t.prototype.reset = function() {\n      o.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;\n    }, t;\n  }(FillStyle)\n), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = (\n  /** @class */\n  function(o) {\n    __extends$l(t, o);\n    function t(e) {\n      e === void 0 && (e = null);\n      var r = o.call(this) || this;\n      return r.shader = null, r.pluginName = \"batch\", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new FillStyle(), r._lineStyle = new LineStyle(), r._matrix = null, r._holeMode = !1, r.state = State.for2d(), r._geometry = e || new GraphicsGeometry(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r;\n    }\n    return Object.defineProperty(t.prototype, \"geometry\", {\n      /**\n       * Includes vertex positions, face indices, normals, colors, UVs, and\n       * custom attributes within buffers, reducing the cost of passing all\n       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n       * @readonly\n       */\n      get: function() {\n        return this._geometry;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.clone = function() {\n      return this.finishPoly(), new t(this._geometry);\n    }, Object.defineProperty(t.prototype, \"blendMode\", {\n      get: function() {\n        return this.state.blendMode;\n      },\n      /**\n       * The blend mode to be applied to the graphic shape. Apply a value of\n       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n       * primitive in the GraphicsGeometry list is rendered sequentially, modes\n       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n       * be applied per-primitive.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The tint applied to each graphic shape. This is a hex value. A value of\n       * 0xFFFFFF will remove any tint effect.\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return this._tint;\n      },\n      set: function(e) {\n        this._tint = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"fill\", {\n      /**\n       * The current fill style.\n       * @readonly\n       */\n      get: function() {\n        return this._fillStyle;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"line\", {\n      /**\n       * The current line style.\n       * @readonly\n       */\n      get: function() {\n        return this._lineStyle;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.lineStyle = function(e, r, D, N, k) {\n      return e === void 0 && (e = null), r === void 0 && (r = 0), D === void 0 && (D = 1), N === void 0 && (N = 0.5), k === void 0 && (k = !1), typeof e == \"number\" && (e = { width: e, color: r, alpha: D, alignment: N, native: k }), this.lineTextureStyle(e);\n    }, t.prototype.lineTextureStyle = function(e) {\n      e = Object.assign({\n        width: 0,\n        texture: Texture.WHITE,\n        color: e && e.texture ? 16777215 : 0,\n        alpha: 1,\n        matrix: null,\n        alignment: 0.5,\n        native: !1,\n        cap: LINE_CAP.BUTT,\n        join: LINE_JOIN.MITER,\n        miterLimit: 10\n      }, e), this.currentPath && this.startPoly();\n      var r = e.width > 0 && e.alpha > 0;\n      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;\n    }, t.prototype.startPoly = function() {\n      if (this.currentPath) {\n        var e = this.currentPath.points, r = this.currentPath.points.length;\n        r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));\n      } else\n        this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n    }, t.prototype.finishPoly = function() {\n      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n    }, t.prototype.moveTo = function(e, r) {\n      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;\n    }, t.prototype.lineTo = function(e, r) {\n      this.currentPath || this.moveTo(0, 0);\n      var D = this.currentPath.points, N = D[D.length - 2], k = D[D.length - 1];\n      return (N !== e || k !== r) && D.push(e, r), this;\n    }, t.prototype._initCurve = function(e, r) {\n      e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);\n    }, t.prototype.quadraticCurveTo = function(e, r, D, N) {\n      this._initCurve();\n      var k = this.currentPath.points;\n      return k.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, r, D, N, k), this;\n    }, t.prototype.bezierCurveTo = function(e, r, D, N, k, $) {\n      return this._initCurve(), BezierUtils.curveTo(e, r, D, N, k, $, this.currentPath.points), this;\n    }, t.prototype.arcTo = function(e, r, D, N, k) {\n      this._initCurve(e, r);\n      var $ = this.currentPath.points, G = ArcUtils.curveTo(e, r, D, N, k, $);\n      if (G) {\n        var U = G.cx, z = G.cy, X = G.radius, V = G.startAngle, Y = G.endAngle, q = G.anticlockwise;\n        this.arc(U, z, X, V, Y, q);\n      }\n      return this;\n    }, t.prototype.arc = function(e, r, D, N, k, $) {\n      if ($ === void 0 && ($ = !1), N === k)\n        return this;\n      !$ && k <= N ? k += PI_2 : $ && N <= k && (N += PI_2);\n      var G = k - N;\n      if (G === 0)\n        return this;\n      var U = e + Math.cos(N) * D, z = r + Math.sin(N) * D, X = this._geometry.closePointEps, V = this.currentPath ? this.currentPath.points : null;\n      if (V) {\n        var Y = Math.abs(V[V.length - 2] - U), q = Math.abs(V[V.length - 1] - z);\n        Y < X && q < X || V.push(U, z);\n      } else\n        this.moveTo(U, z), V = this.currentPath.points;\n      return ArcUtils.arc(U, z, e, r, D, N, k, $, V), this;\n    }, t.prototype.beginFill = function(e, r) {\n      return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: r });\n    }, t.prototype.beginTextureFill = function(e) {\n      e = Object.assign({\n        texture: Texture.WHITE,\n        color: 16777215,\n        alpha: 1,\n        matrix: null\n      }, e), this.currentPath && this.startPoly();\n      var r = e.alpha > 0;\n      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;\n    }, t.prototype.endFill = function() {\n      return this.finishPoly(), this._fillStyle.reset(), this;\n    }, t.prototype.drawRect = function(e, r, D, N) {\n      return this.drawShape(new Rectangle(e, r, D, N));\n    }, t.prototype.drawRoundedRect = function(e, r, D, N, k) {\n      return this.drawShape(new RoundedRectangle(e, r, D, N, k));\n    }, t.prototype.drawCircle = function(e, r, D) {\n      return this.drawShape(new Circle(e, r, D));\n    }, t.prototype.drawEllipse = function(e, r, D, N) {\n      return this.drawShape(new Ellipse(e, r, D, N));\n    }, t.prototype.drawPolygon = function() {\n      for (var e = arguments, r = [], D = 0; D < arguments.length; D++)\n        r[D] = e[D];\n      var N, k = !0, $ = r[0];\n      $.points ? (k = $.closeStroke, N = $.points) : Array.isArray(r[0]) ? N = r[0] : N = r;\n      var G = new Polygon(N);\n      return G.closeStroke = k, this.drawShape(G), this;\n    }, t.prototype.drawShape = function(e) {\n      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;\n    }, t.prototype.clear = function() {\n      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n    }, t.prototype.isFastRect = function() {\n      var e = this._geometry.graphicsData;\n      return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);\n    }, t.prototype._render = function(e) {\n      this.finishPoly();\n      var r = this._geometry;\n      r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));\n    }, t.prototype._populateBatches = function() {\n      var e = this._geometry, r = this.blendMode, D = e.batches.length;\n      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = D, this.vertexData = new Float32Array(e.points);\n      for (var N = 0; N < D; N++) {\n        var k = e.batches[N], $ = k.style.color, G = new Float32Array(this.vertexData.buffer, k.attribStart * 4 * 2, k.attribSize * 2), U = new Float32Array(e.uvsFloat32.buffer, k.attribStart * 4 * 2, k.attribSize * 2), z = new Uint16Array(e.indicesUint16.buffer, k.start * 2, k.size), X = {\n          vertexData: G,\n          blendMode: r,\n          indices: z,\n          uvs: U,\n          _batchRGB: hex2rgb($),\n          _tintRGB: $,\n          _texture: k.style.texture,\n          alpha: k.style.alpha,\n          worldAlpha: 1\n        };\n        this.batches[N] = X;\n      }\n    }, t.prototype._renderBatched = function(e) {\n      if (this.batches.length) {\n        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n        for (var r = 0, D = this.batches.length; r < D; r++) {\n          var N = this.batches[r];\n          N.worldAlpha = this.worldAlpha * N.alpha, e.plugins[this.pluginName].render(N);\n        }\n      }\n    }, t.prototype._renderDirect = function(e) {\n      var r = this._resolveDirectShader(e), D = this._geometry, N = this.tint, k = this.worldAlpha, $ = r.uniforms, G = D.drawCalls;\n      $.translationMatrix = this.transform.worldTransform, $.tint[0] = (N >> 16 & 255) / 255 * k, $.tint[1] = (N >> 8 & 255) / 255 * k, $.tint[2] = (N & 255) / 255 * k, $.tint[3] = k, e.shader.bind(r), e.geometry.bind(D, r), e.state.set(this.state);\n      for (var U = 0, z = G.length; U < z; U++)\n        this._renderDrawCallDirect(e, D.drawCalls[U]);\n    }, t.prototype._renderDrawCallDirect = function(e, r) {\n      for (var D = r.texArray, N = r.type, k = r.size, $ = r.start, G = D.count, U = 0; U < G; U++)\n        e.texture.bind(D.elements[U], U);\n      e.geometry.draw(N, k, $);\n    }, t.prototype._resolveDirectShader = function(e) {\n      var r = this.shader, D = this.pluginName;\n      if (!r) {\n        if (!DEFAULT_SHADERS[D]) {\n          for (var N = e.plugins[D].MAX_TEXTURES, k = new Int32Array(N), $ = 0; $ < N; $++)\n            k[$] = $;\n          var G = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new Matrix(),\n            default: UniformGroup.from({ uSamplers: k }, !0)\n          }, U = e.plugins[D]._shader.program;\n          DEFAULT_SHADERS[D] = new Shader(U, G);\n        }\n        r = DEFAULT_SHADERS[D];\n      }\n      return r;\n    }, t.prototype._calculateBounds = function() {\n      this.finishPoly();\n      var e = this._geometry;\n      if (e.graphicsData.length) {\n        var r = e.bounds, D = r.minX, N = r.minY, k = r.maxX, $ = r.maxY;\n        this._bounds.addFrame(this.transform, D, N, k, $);\n      }\n    }, t.prototype.containsPoint = function(e) {\n      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);\n    }, t.prototype.calculateTints = function() {\n      if (this.batchTint !== this.tint) {\n        this.batchTint = this.tint;\n        for (var e = hex2rgb(this.tint, temp), r = 0; r < this.batches.length; r++) {\n          var D = this.batches[r], N = D._batchRGB, k = e[0] * N[0] * 255, $ = e[1] * N[1] * 255, G = e[2] * N[2] * 255, U = (k << 16) + ($ << 8) + (G | 0);\n          D._tintRGB = (U >> 16) + (U & 65280) + ((U & 255) << 16);\n        }\n      }\n    }, t.prototype.calculateVertices = function() {\n      var e = this.transform._worldID;\n      if (this._transformID !== e) {\n        this._transformID = e;\n        for (var r = this.transform.worldTransform, D = r.a, N = r.b, k = r.c, $ = r.d, G = r.tx, U = r.ty, z = this._geometry.points, X = this.vertexData, V = 0, Y = 0; Y < z.length; Y += 2) {\n          var q = z[Y], W = z[Y + 1];\n          X[V++] = D * q + k * W + G, X[V++] = $ * W + N * q + U;\n        }\n      }\n    }, t.prototype.closePath = function() {\n      var e = this.currentPath;\n      return e && (e.closeStroke = !0, this.finishPoly()), this;\n    }, t.prototype.setMatrix = function(e) {\n      return this._matrix = e, this;\n    }, t.prototype.beginHole = function() {\n      return this.finishPoly(), this._holeMode = !0, this;\n    }, t.prototype.endHole = function() {\n      return this.finishPoly(), this._holeMode = !1, this;\n    }, t.prototype.destroy = function(e) {\n      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, o.prototype.destroy.call(this, e);\n    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;\n  }(Container)\n);\n/*!\n * @pixi/sprite - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$k = function(o, t) {\n  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$k(o, t);\n};\nfunction __extends$k(o, t) {\n  extendStatics$k(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = (\n  /** @class */\n  function(o) {\n    __extends$k(t, o);\n    function t(e) {\n      var r = o.call(this) || this;\n      return r._anchor = new ObservablePoint(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = BLEND_MODES.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Texture.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = indices, r.pluginName = \"batch\", r.isSprite = !0, r._roundPixels = settings.ROUND_PIXELS, r;\n    }\n    return t.prototype._onTextureUpdate = function() {\n      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);\n    }, t.prototype._onAnchorUpdate = function() {\n      this._transformID = -1, this._transformTrimmedID = -1;\n    }, t.prototype.calculateVertices = function() {\n      var e = this._texture;\n      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {\n        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;\n        var r = this.transform.worldTransform, D = r.a, N = r.b, k = r.c, $ = r.d, G = r.tx, U = r.ty, z = this.vertexData, X = e.trim, V = e.orig, Y = this._anchor, q = 0, W = 0, K = 0, Z = 0;\n        if (X ? (W = X.x - Y._x * V.width, q = W + X.width, Z = X.y - Y._y * V.height, K = Z + X.height) : (W = -Y._x * V.width, q = W + V.width, Z = -Y._y * V.height, K = Z + V.height), z[0] = D * W + k * Z + G, z[1] = $ * Z + N * W + U, z[2] = D * q + k * Z + G, z[3] = $ * Z + N * q + U, z[4] = D * q + k * K + G, z[5] = $ * K + N * q + U, z[6] = D * W + k * K + G, z[7] = $ * K + N * W + U, this._roundPixels)\n          for (var J = settings.RESOLUTION, Q = 0; Q < z.length; ++Q)\n            z[Q] = Math.round((z[Q] * J | 0) / J);\n      }\n    }, t.prototype.calculateTrimmedVertices = function() {\n      if (!this.vertexTrimmedData)\n        this.vertexTrimmedData = new Float32Array(8);\n      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n        return;\n      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n      var e = this._texture, r = this.vertexTrimmedData, D = e.orig, N = this._anchor, k = this.transform.worldTransform, $ = k.a, G = k.b, U = k.c, z = k.d, X = k.tx, V = k.ty, Y = -N._x * D.width, q = Y + D.width, W = -N._y * D.height, K = W + D.height;\n      r[0] = $ * Y + U * W + X, r[1] = z * W + G * Y + V, r[2] = $ * q + U * W + X, r[3] = z * W + G * q + V, r[4] = $ * q + U * K + X, r[5] = z * K + G * q + V, r[6] = $ * Y + U * K + X, r[7] = z * K + G * Y + V;\n    }, t.prototype._render = function(e) {\n      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);\n    }, t.prototype._calculateBounds = function() {\n      var e = this._texture.trim, r = this._texture.orig;\n      !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n    }, t.prototype.getLocalBounds = function(e) {\n      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);\n    }, t.prototype.containsPoint = function(e) {\n      this.worldTransform.applyInverse(e, tempPoint$2);\n      var r = this._texture.orig.width, D = this._texture.orig.height, N = -r * this.anchor.x, k = 0;\n      return tempPoint$2.x >= N && tempPoint$2.x < N + r && (k = -D * this.anchor.y, tempPoint$2.y >= k && tempPoint$2.y < k + D);\n    }, t.prototype.destroy = function(e) {\n      o.prototype.destroy.call(this, e), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null;\n      var r = typeof e == \"boolean\" ? e : e && e.texture;\n      if (r) {\n        var D = typeof e == \"boolean\" ? e : e && e.baseTexture;\n        this._texture.destroy(!!D);\n      }\n      this._texture = null;\n    }, t.from = function(e, r) {\n      var D = e instanceof Texture ? e : Texture.from(e, r);\n      return new t(D);\n    }, Object.defineProperty(t.prototype, \"roundPixels\", {\n      get: function() {\n        return this._roundPixels;\n      },\n      /**\n       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n       *\n       * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n       * The main disadvantage is movement of objects may appear less smooth.\n       *\n       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n       * @default false\n       */\n      set: function(e) {\n        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n      },\n      set: function(e) {\n        var r = sign(this.scale.x) || 1;\n        this.scale.x = r * e / this._texture.orig.width, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n      },\n      set: function(e) {\n        var r = sign(this.scale.y) || 1;\n        this.scale.y = r * e / this._texture.orig.height, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"anchor\", {\n      /**\n       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n       * and passed to the constructor.\n       *\n       * The default is `(0,0)`, this means the sprite's origin is the top left.\n       *\n       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n       *\n       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n       *\n       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n       * @example\n       * const sprite = new PIXI.Sprite(texture);\n       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n       */\n      get: function() {\n        return this._anchor;\n      },\n      set: function(e) {\n        this._anchor.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The tint applied to the sprite. This is a hex value.\n       *\n       * A value of 0xFFFFFF will remove any tint effect.\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return this._tint;\n      },\n      set: function(e) {\n        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"texture\", {\n      /** The texture that the sprite is using. */\n      get: function() {\n        return this._texture;\n      },\n      set: function(e) {\n        this._texture !== e && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once(\"update\", this._onTextureUpdate, this)));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Container)\n);\n/*!\n * @pixi/text - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$j = function(o, t) {\n  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$j(o, t);\n};\nfunction __extends$j(o, t) {\n  extendStatics$j(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar TEXT_GRADIENT;\n(function(o) {\n  o[o.LINEAR_VERTICAL = 0] = \"LINEAR_VERTICAL\", o[o.LINEAR_HORIZONTAL = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nvar defaultStyle = {\n  align: \"left\",\n  breakWords: !1,\n  dropShadow: !1,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: !1,\n  whiteSpace: \"pre\",\n  wordWrap: !1,\n  wordWrapWidth: 100,\n  leading: 0\n}, genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n], TextStyle = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);\n    }\n    return o.prototype.clone = function() {\n      var t = {};\n      return deepCopyProperties(t, this, defaultStyle), new o(t);\n    }, o.prototype.reset = function() {\n      deepCopyProperties(this, defaultStyle, defaultStyle);\n    }, Object.defineProperty(o.prototype, \"align\", {\n      /**\n       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._align;\n      },\n      set: function(t) {\n        this._align !== t && (this._align = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"breakWords\", {\n      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n      get: function() {\n        return this._breakWords;\n      },\n      set: function(t) {\n        this._breakWords !== t && (this._breakWords = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadow\", {\n      /** Set a drop shadow for the text. */\n      get: function() {\n        return this._dropShadow;\n      },\n      set: function(t) {\n        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadowAlpha\", {\n      /** Set alpha for the drop shadow. */\n      get: function() {\n        return this._dropShadowAlpha;\n      },\n      set: function(t) {\n        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadowAngle\", {\n      /** Set a angle of the drop shadow. */\n      get: function() {\n        return this._dropShadowAngle;\n      },\n      set: function(t) {\n        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadowBlur\", {\n      /** Set a shadow blur radius. */\n      get: function() {\n        return this._dropShadowBlur;\n      },\n      set: function(t) {\n        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadowColor\", {\n      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */\n      get: function() {\n        return this._dropShadowColor;\n      },\n      set: function(t) {\n        var e = getColor(t);\n        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"dropShadowDistance\", {\n      /** Set a distance of the drop shadow. */\n      get: function() {\n        return this._dropShadowDistance;\n      },\n      set: function(t) {\n        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fill\", {\n      /**\n       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.\n       *\n       * Can be an array to create a gradient eg ['#000000','#FFFFFF']\n       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n       *\n       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n       */\n      get: function() {\n        return this._fill;\n      },\n      set: function(t) {\n        var e = getColor(t);\n        this._fill !== e && (this._fill = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fillGradientType\", {\n      /**\n       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.\n       *\n       * @see PIXI.TEXT_GRADIENT\n       */\n      get: function() {\n        return this._fillGradientType;\n      },\n      set: function(t) {\n        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fillGradientStops\", {\n      /**\n       * If fill is an array of colours to create a gradient, this array can set the stop points\n       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n       */\n      get: function() {\n        return this._fillGradientStops;\n      },\n      set: function(t) {\n        areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fontFamily\", {\n      /** The font family. */\n      get: function() {\n        return this._fontFamily;\n      },\n      set: function(t) {\n        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fontSize\", {\n      /**\n       * The font size\n       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')\n       */\n      get: function() {\n        return this._fontSize;\n      },\n      set: function(t) {\n        this._fontSize !== t && (this._fontSize = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fontStyle\", {\n      /**\n       * The font style\n       * ('normal', 'italic' or 'oblique')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontStyle;\n      },\n      set: function(t) {\n        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fontVariant\", {\n      /**\n       * The font variant\n       * ('normal' or 'small-caps')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontVariant;\n      },\n      set: function(t) {\n        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"fontWeight\", {\n      /**\n       * The font weight\n       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontWeight;\n      },\n      set: function(t) {\n        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"letterSpacing\", {\n      /** The amount of spacing between letters, default is 0. */\n      get: function() {\n        return this._letterSpacing;\n      },\n      set: function(t) {\n        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"lineHeight\", {\n      /** The line height, a number that represents the vertical space that a letter uses. */\n      get: function() {\n        return this._lineHeight;\n      },\n      set: function(t) {\n        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"leading\", {\n      /** The space between lines. */\n      get: function() {\n        return this._leading;\n      },\n      set: function(t) {\n        this._leading !== t && (this._leading = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"lineJoin\", {\n      /**\n       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n       * Default is 'miter' (creates a sharp corner).\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._lineJoin;\n      },\n      set: function(t) {\n        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"miterLimit\", {\n      /**\n       * The miter limit to use when using the 'miter' lineJoin mode.\n       *\n       * This can reduce or increase the spikiness of rendered text.\n       */\n      get: function() {\n        return this._miterLimit;\n      },\n      set: function(t) {\n        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"padding\", {\n      /**\n       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n       * by adding padding to all sides of the text.\n       */\n      get: function() {\n        return this._padding;\n      },\n      set: function(t) {\n        this._padding !== t && (this._padding = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"stroke\", {\n      /**\n       * A canvas fillstyle that will be used on the text stroke\n       * e.g 'blue', '#FCFF00'\n       */\n      get: function() {\n        return this._stroke;\n      },\n      set: function(t) {\n        var e = getColor(t);\n        this._stroke !== e && (this._stroke = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"strokeThickness\", {\n      /**\n       * A number that represents the thickness of the stroke.\n       *\n       * @default 0\n       */\n      get: function() {\n        return this._strokeThickness;\n      },\n      set: function(t) {\n        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"textBaseline\", {\n      /**\n       * The baseline of the text that is rendered.\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._textBaseline;\n      },\n      set: function(t) {\n        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"trim\", {\n      /** Trim transparent borders. */\n      get: function() {\n        return this._trim;\n      },\n      set: function(t) {\n        this._trim !== t && (this._trim = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"whiteSpace\", {\n      /**\n       * How newlines and spaces should be handled.\n       * Default is 'pre' (preserve, preserve).\n       *\n       *  value       | New lines     |   Spaces\n       *  ---         | ---           |   ---\n       * 'normal'     | Collapse      |   Collapse\n       * 'pre'        | Preserve      |   Preserve\n       * 'pre-line'   | Preserve      |   Collapse\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._whiteSpace;\n      },\n      set: function(t) {\n        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"wordWrap\", {\n      /** Indicates if word wrap should be used. */\n      get: function() {\n        return this._wordWrap;\n      },\n      set: function(t) {\n        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"wordWrapWidth\", {\n      /** The width at which text will wrap, it needs wordWrap to be set to true. */\n      get: function() {\n        return this._wordWrapWidth;\n      },\n      set: function(t) {\n        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.toFontString = function() {\n      var t = typeof this.fontSize == \"number\" ? this.fontSize + \"px\" : this.fontSize, e = this.fontFamily;\n      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(\",\"));\n      for (var r = e.length - 1; r >= 0; r--) {\n        var D = e[r].trim();\n        !/([\\\"\\'])[^\\'\\\"]+\\1/.test(D) && genericFontFamilies.indexOf(D) < 0 && (D = '\"' + D + '\"'), e[r] = D;\n      }\n      return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + t + \" \" + e.join(\",\");\n    }, o;\n  }()\n);\nfunction getSingleColor(o) {\n  return typeof o == \"number\" ? hex2string(o) : (typeof o == \"string\" && o.indexOf(\"0x\") === 0 && (o = o.replace(\"0x\", \"#\")), o);\n}\nfunction getColor(o) {\n  if (Array.isArray(o)) {\n    for (var t = 0; t < o.length; ++t)\n      o[t] = getSingleColor(o[t]);\n    return o;\n  } else\n    return getSingleColor(o);\n}\nfunction areArraysEqual(o, t) {\n  if (!Array.isArray(o) || !Array.isArray(t) || o.length !== t.length)\n    return !1;\n  for (var e = 0; e < o.length; ++e)\n    if (o[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction deepCopyProperties(o, t, e) {\n  for (var r in e)\n    Array.isArray(t[r]) ? o[r] = t[r].slice() : o[r] = t[r];\n}\nvar contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: !0\n}, TextMetrics = (\n  /** @class */\n  function() {\n    function o(t, e, r, D, N, k, $, G, U) {\n      this.text = t, this.style = e, this.width = r, this.height = D, this.lines = N, this.lineWidths = k, this.lineHeight = $, this.maxLineWidth = G, this.fontProperties = U;\n    }\n    return o.measureText = function(t, e, r, D) {\n      D === void 0 && (D = o._canvas), r = r ?? e.wordWrap;\n      var N = e.toFontString(), k = o.measureFont(N);\n      k.fontSize === 0 && (k.fontSize = e.fontSize, k.ascent = e.fontSize);\n      var $ = D.getContext(\"2d\", contextSettings);\n      $.font = N;\n      for (var G = r ? o.wordWrap(t, e, D) : t, U = G.split(/(?:\\r\\n|\\r|\\n)/), z = new Array(U.length), X = 0, V = 0; V < U.length; V++) {\n        var Y = $.measureText(U[V]).width + (U[V].length - 1) * e.letterSpacing;\n        z[V] = Y, X = Math.max(X, Y);\n      }\n      var q = X + e.strokeThickness;\n      e.dropShadow && (q += e.dropShadowDistance);\n      var W = e.lineHeight || k.fontSize + e.strokeThickness, K = Math.max(W, k.fontSize + e.strokeThickness) + (U.length - 1) * (W + e.leading);\n      return e.dropShadow && (K += e.dropShadowDistance), new o(t, e, q, K, U, z, W + e.leading, X, k);\n    }, o.wordWrap = function(t, e, r) {\n      r === void 0 && (r = o._canvas);\n      for (var D = r.getContext(\"2d\", contextSettings), N = 0, k = \"\", $ = \"\", G = /* @__PURE__ */ Object.create(null), U = e.letterSpacing, z = e.whiteSpace, X = o.collapseSpaces(z), V = o.collapseNewlines(z), Y = !X, q = e.wordWrapWidth + U, W = o.tokenize(t), K = 0; K < W.length; K++) {\n        var Z = W[K];\n        if (o.isNewline(Z)) {\n          if (!V) {\n            $ += o.addLine(k), Y = !X, k = \"\", N = 0;\n            continue;\n          }\n          Z = \" \";\n        }\n        if (X) {\n          var J = o.isBreakingSpace(Z), Q = o.isBreakingSpace(k[k.length - 1]);\n          if (J && Q)\n            continue;\n        }\n        var et = o.getFromCache(Z, U, G, D);\n        if (et > q)\n          if (k !== \"\" && ($ += o.addLine(k), k = \"\", N = 0), o.canBreakWords(Z, e.breakWords))\n            for (var nt = o.wordWrapSplit(Z), tt = 0; tt < nt.length; tt++) {\n              for (var it = nt[tt], st = 1; nt[tt + st]; ) {\n                var at = nt[tt + st], ut = it[it.length - 1];\n                if (!o.canBreakChars(ut, at, Z, tt, e.breakWords))\n                  it += at;\n                else\n                  break;\n                st++;\n              }\n              tt += it.length - 1;\n              var ft = o.getFromCache(it, U, G, D);\n              ft + N > q && ($ += o.addLine(k), Y = !1, k = \"\", N = 0), k += it, N += ft;\n            }\n          else {\n            k.length > 0 && ($ += o.addLine(k), k = \"\", N = 0);\n            var ct = K === W.length - 1;\n            $ += o.addLine(Z, !ct), Y = !1, k = \"\", N = 0;\n          }\n        else\n          et + N > q && (Y = !1, $ += o.addLine(k), k = \"\", N = 0), (k.length > 0 || !o.isBreakingSpace(Z) || Y) && (k += Z, N += et);\n      }\n      return $ += o.addLine(k, !1), $;\n    }, o.addLine = function(t, e) {\n      return e === void 0 && (e = !0), t = o.trimRight(t), t = e ? t + `\n` : t, t;\n    }, o.getFromCache = function(t, e, r, D) {\n      var N = r[t];\n      if (typeof N != \"number\") {\n        var k = t.length * e;\n        N = D.measureText(t).width + k, r[t] = N;\n      }\n      return N;\n    }, o.collapseSpaces = function(t) {\n      return t === \"normal\" || t === \"pre-line\";\n    }, o.collapseNewlines = function(t) {\n      return t === \"normal\";\n    }, o.trimRight = function(t) {\n      if (typeof t != \"string\")\n        return \"\";\n      for (var e = t.length - 1; e >= 0; e--) {\n        var r = t[e];\n        if (!o.isBreakingSpace(r))\n          break;\n        t = t.slice(0, -1);\n      }\n      return t;\n    }, o.isNewline = function(t) {\n      return typeof t != \"string\" ? !1 : o._newlines.indexOf(t.charCodeAt(0)) >= 0;\n    }, o.isBreakingSpace = function(t, e) {\n      return typeof t != \"string\" ? !1 : o._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;\n    }, o.tokenize = function(t) {\n      var e = [], r = \"\";\n      if (typeof t != \"string\")\n        return e;\n      for (var D = 0; D < t.length; D++) {\n        var N = t[D], k = t[D + 1];\n        if (o.isBreakingSpace(N, k) || o.isNewline(N)) {\n          r !== \"\" && (e.push(r), r = \"\"), e.push(N);\n          continue;\n        }\n        r += N;\n      }\n      return r !== \"\" && e.push(r), e;\n    }, o.canBreakWords = function(t, e) {\n      return e;\n    }, o.canBreakChars = function(t, e, r, D, N) {\n      return !0;\n    }, o.wordWrapSplit = function(t) {\n      return t.split(\"\");\n    }, o.measureFont = function(t) {\n      if (o._fonts[t])\n        return o._fonts[t];\n      var e = {\n        ascent: 0,\n        descent: 0,\n        fontSize: 0\n      }, r = o._canvas, D = o._context;\n      D.font = t;\n      var N = o.METRICS_STRING + o.BASELINE_SYMBOL, k = Math.ceil(D.measureText(N).width), $ = Math.ceil(D.measureText(o.BASELINE_SYMBOL).width), G = Math.ceil(o.HEIGHT_MULTIPLIER * $);\n      $ = $ * o.BASELINE_MULTIPLIER | 0, r.width = k, r.height = G, D.fillStyle = \"#f00\", D.fillRect(0, 0, k, G), D.font = t, D.textBaseline = \"alphabetic\", D.fillStyle = \"#000\", D.fillText(N, 0, $);\n      var U = D.getImageData(0, 0, k, G).data, z = U.length, X = k * 4, V = 0, Y = 0, q = !1;\n      for (V = 0; V < $; ++V) {\n        for (var W = 0; W < X; W += 4)\n          if (U[Y + W] !== 255) {\n            q = !0;\n            break;\n          }\n        if (!q)\n          Y += X;\n        else\n          break;\n      }\n      for (e.ascent = $ - V, Y = z - X, q = !1, V = G; V > $; --V) {\n        for (var W = 0; W < X; W += 4)\n          if (U[Y + W] !== 255) {\n            q = !0;\n            break;\n          }\n        if (!q)\n          Y -= X;\n        else\n          break;\n      }\n      return e.descent = V - $, e.fontSize = e.ascent + e.descent, o._fonts[t] = e, e;\n    }, o.clearMetrics = function(t) {\n      t === void 0 && (t = \"\"), t ? delete o._fonts[t] : o._fonts = {};\n    }, Object.defineProperty(o, \"_canvas\", {\n      /**\n       * Cached canvas element for measuring text\n       * TODO: this should be private, but isn't because of backward compat, will fix later.\n       * @ignore\n       */\n      get: function() {\n        if (!o.__canvas) {\n          var t = void 0;\n          try {\n            var e = new OffscreenCanvas(0, 0), r = e.getContext(\"2d\", contextSettings);\n            if (r && r.measureText)\n              return o.__canvas = e, e;\n            t = settings.ADAPTER.createCanvas();\n          } catch {\n            t = settings.ADAPTER.createCanvas();\n          }\n          t.width = t.height = 10, o.__canvas = t;\n        }\n        return o.__canvas;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o, \"_context\", {\n      /**\n       * TODO: this should be private, but isn't because of backward compat, will fix later.\n       * @ignore\n       */\n      get: function() {\n        return o.__context || (o.__context = o._canvas.getContext(\"2d\", contextSettings)), o.__context;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o;\n  }()\n);\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|ÉqÅ\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, Text = (\n  /** @class */\n  function(o) {\n    __extends$j(t, o);\n    function t(e, r, D) {\n      var N = this, k = !1;\n      D || (D = settings.ADAPTER.createCanvas(), k = !0), D.width = 3, D.height = 3;\n      var $ = Texture.from(D);\n      return $.orig = new Rectangle(), $.trim = new Rectangle(), N = o.call(this, $) || this, N._ownCanvas = k, N.canvas = D, N.context = D.getContext(\"2d\", {\n        // required for trimming to work without warnings\n        willReadFrequently: !0\n      }), N._resolution = settings.RESOLUTION, N._autoResolution = !0, N._text = null, N._style = null, N._styleListener = null, N._font = \"\", N.text = e, N.style = r, N.localStyleID = -1, N;\n    }\n    return t.prototype.updateText = function(e) {\n      var r = this._style;\n      if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {\n        this._font = this._style.toFontString();\n        var D = this.context, N = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), k = N.width, $ = N.height, G = N.lines, U = N.lineHeight, z = N.lineWidths, X = N.maxLineWidth, V = N.fontProperties;\n        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, k) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, $) + r.padding * 2) * this._resolution), D.scale(this._resolution, this._resolution), D.clearRect(0, 0, this.canvas.width, this.canvas.height), D.font = this._font, D.lineWidth = r.strokeThickness, D.textBaseline = r.textBaseline, D.lineJoin = r.lineJoin, D.miterLimit = r.miterLimit;\n        for (var Y, q, W = r.dropShadow ? 2 : 1, K = 0; K < W; ++K) {\n          var Z = r.dropShadow && K === 0, J = Z ? Math.ceil(Math.max(1, $) + r.padding * 2) : 0, Q = J * this._resolution;\n          if (Z) {\n            D.fillStyle = \"black\", D.strokeStyle = \"black\";\n            var et = r.dropShadowColor, nt = hex2rgb(typeof et == \"number\" ? et : string2hex(et)), tt = r.dropShadowBlur * this._resolution, it = r.dropShadowDistance * this._resolution;\n            D.shadowColor = \"rgba(\" + nt[0] * 255 + \",\" + nt[1] * 255 + \",\" + nt[2] * 255 + \",\" + r.dropShadowAlpha + \")\", D.shadowBlur = tt, D.shadowOffsetX = Math.cos(r.dropShadowAngle) * it, D.shadowOffsetY = Math.sin(r.dropShadowAngle) * it + Q;\n          } else\n            D.fillStyle = this._generateFillStyle(r, G, N), D.strokeStyle = r.stroke, D.shadowColor = \"black\", D.shadowBlur = 0, D.shadowOffsetX = 0, D.shadowOffsetY = 0;\n          var st = (U - V.fontSize) / 2;\n          (!t.nextLineHeightBehavior || U - V.fontSize < 0) && (st = 0);\n          for (var at = 0; at < G.length; at++)\n            Y = r.strokeThickness / 2, q = r.strokeThickness / 2 + at * U + V.ascent + st, r.align === \"right\" ? Y += X - z[at] : r.align === \"center\" && (Y += (X - z[at]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(G[at], Y + r.padding, q + r.padding - J, !0), r.fill && this.drawLetterSpacing(G[at], Y + r.padding, q + r.padding - J);\n        }\n        this.updateTexture();\n      }\n    }, t.prototype.drawLetterSpacing = function(e, r, D, N) {\n      N === void 0 && (N = !1);\n      var k = this._style, $ = k.letterSpacing, G = t.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n      if ($ === 0 || G) {\n        G && (this.context.letterSpacing = $, this.context.textLetterSpacing = $), N ? this.context.strokeText(e, r, D) : this.context.fillText(e, r, D);\n        return;\n      }\n      for (var U = r, z = Array.from ? Array.from(e) : e.split(\"\"), X = this.context.measureText(e).width, V = 0, Y = 0; Y < z.length; ++Y) {\n        var q = z[Y];\n        N ? this.context.strokeText(q, U, D) : this.context.fillText(q, U, D);\n        for (var W = \"\", K = Y + 1; K < z.length; ++K)\n          W += z[K];\n        V = this.context.measureText(W).width, U += X - V + $, X = V;\n      }\n    }, t.prototype.updateTexture = function() {\n      var e = this.canvas;\n      if (this._style.trim) {\n        var r = trimCanvas(e);\n        r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));\n      }\n      var D = this._texture, N = this._style, k = N.trim ? 0 : N.padding, $ = D.baseTexture;\n      D.trim.width = D._frame.width = e.width / this._resolution, D.trim.height = D._frame.height = e.height / this._resolution, D.trim.x = -k, D.trim.y = -k, D.orig.width = D._frame.width - k * 2, D.orig.height = D._frame.height - k * 2, this._onTextureUpdate(), $.setRealSize(e.width, e.height, this._resolution), D.updateUvs(), this.dirty = !1;\n    }, t.prototype._render = function(e) {\n      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), o.prototype._render.call(this, e);\n    }, t.prototype.updateTransform = function() {\n      this.updateText(!0), o.prototype.updateTransform.call(this);\n    }, t.prototype.getBounds = function(e, r) {\n      return this.updateText(!0), this._textureID === -1 && (e = !1), o.prototype.getBounds.call(this, e, r);\n    }, t.prototype.getLocalBounds = function(e) {\n      return this.updateText(!0), o.prototype.getLocalBounds.call(this, e);\n    }, t.prototype._calculateBounds = function() {\n      this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n    }, t.prototype._generateFillStyle = function(e, r, D) {\n      var N = e.fill;\n      if (Array.isArray(N)) {\n        if (N.length === 1)\n          return N[0];\n      } else\n        return N;\n      var k, $ = e.dropShadow ? e.dropShadowDistance : 0, G = e.padding || 0, U = this.canvas.width / this._resolution - $ - G * 2, z = this.canvas.height / this._resolution - $ - G * 2, X = N.slice(), V = e.fillGradientStops.slice();\n      if (!V.length)\n        for (var Y = X.length + 1, q = 1; q < Y; ++q)\n          V.push(q / Y);\n      if (X.unshift(N[0]), V.unshift(0), X.push(N[N.length - 1]), V.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n        k = this.context.createLinearGradient(U / 2, G, U / 2, z + G);\n        for (var W = D.fontProperties.fontSize + e.strokeThickness, q = 0; q < r.length; q++) {\n          var K = D.lineHeight * (q - 1) + W, Z = D.lineHeight * q, J = Z;\n          q > 0 && K > Z && (J = (Z + K) / 2);\n          var Q = Z + W, et = D.lineHeight * (q + 1), nt = Q;\n          q + 1 < r.length && et < Q && (nt = (Q + et) / 2);\n          for (var tt = (nt - J) / z, it = 0; it < X.length; it++) {\n            var st = 0;\n            typeof V[it] == \"number\" ? st = V[it] : st = it / X.length;\n            var at = Math.min(1, Math.max(0, J / z + st * tt));\n            at = Number(at.toFixed(5)), k.addColorStop(at, X[it]);\n          }\n        }\n      } else {\n        k = this.context.createLinearGradient(G, z / 2, U + G, z / 2);\n        for (var ut = X.length + 1, ft = 1, q = 0; q < X.length; q++) {\n          var ct = void 0;\n          typeof V[q] == \"number\" ? ct = V[q] : ct = ft / ut, k.addColorStop(ct, X[q]), ft++;\n        }\n      }\n      return k;\n    }, t.prototype.destroy = function(e) {\n      typeof e == \"boolean\" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), o.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n      },\n      set: function(e) {\n        this.updateText(!0);\n        var r = sign(this.scale.x) || 1;\n        this.scale.x = r * e / this._texture.orig.width, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n      },\n      set: function(e) {\n        this.updateText(!0);\n        var r = sign(this.scale.y) || 1;\n        this.scale.y = r * e / this._texture.orig.height, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"style\", {\n      /**\n       * Set the style of the text.\n       *\n       * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n       */\n      get: function() {\n        return this._style;\n      },\n      set: function(e) {\n        e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"text\", {\n      /** Set the copy for the text object. To split a line you can use '\\n'. */\n      get: function() {\n        return this._text;\n      },\n      set: function(e) {\n        e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * The resolution / device pixel ratio of the canvas.\n       *\n       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n       * @default 1\n       */\n      get: function() {\n        return this._resolution;\n      },\n      set: function(e) {\n        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;\n  }(Sprite)\n);\n/*!\n * @pixi/prepare - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.UPLOADS_PER_FRAME = 4;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$i = function(o, t) {\n  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$i(o, t);\n};\nfunction __extends$i(o, t) {\n  extendStatics$i(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar CountLimiter = (\n  /** @class */\n  function() {\n    function o(t) {\n      this.maxItemsPerFrame = t, this.itemsLeft = 0;\n    }\n    return o.prototype.beginFrame = function() {\n      this.itemsLeft = this.maxItemsPerFrame;\n    }, o.prototype.allowedToUpload = function() {\n      return this.itemsLeft-- > 0;\n    }, o;\n  }()\n);\nfunction findMultipleBaseTextures(o, t) {\n  var e = !1;\n  if (o && o._textures && o._textures.length) {\n    for (var r = 0; r < o._textures.length; r++)\n      if (o._textures[r] instanceof Texture) {\n        var D = o._textures[r].baseTexture;\n        t.indexOf(D) === -1 && (t.push(D), e = !0);\n      }\n  }\n  return e;\n}\nfunction findBaseTexture(o, t) {\n  if (o.baseTexture instanceof BaseTexture) {\n    var e = o.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTexture(o, t) {\n  if (o._texture && o._texture instanceof Texture) {\n    var e = o._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction drawText(o, t) {\n  return t instanceof Text ? (t.updateText(!0), !0) : !1;\n}\nfunction calculateTextStyle(o, t) {\n  if (t instanceof TextStyle) {\n    var e = t.toFontString();\n    return TextMetrics.measureFont(e), !0;\n  }\n  return !1;\n}\nfunction findText(o, t) {\n  if (o instanceof Text) {\n    t.indexOf(o.style) === -1 && t.push(o.style), t.indexOf(o) === -1 && t.push(o);\n    var e = o._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTextStyle(o, t) {\n  return o instanceof TextStyle ? (t.indexOf(o) === -1 && t.push(o), !0) : !1;\n}\nvar BasePrepare = (\n  /** @class */\n  function() {\n    function o(t) {\n      var e = this;\n      this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {\n        e.queue && e.prepareItems();\n      }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);\n    }\n    return o.prototype.upload = function(t, e) {\n      var r = this;\n      return typeof t == \"function\" && (e = t, t = null), e && deprecation(\"6.5.0\", \"BasePrepare.upload callback is deprecated, use the return Promise instead.\"), new Promise(function(D) {\n        t && r.add(t);\n        var N = function() {\n          e == null || e(), D();\n        };\n        r.queue.length ? (r.completes.push(N), r.ticking || (r.ticking = !0, Ticker.system.addOnce(r.tick, r, UPDATE_PRIORITY.UTILITY))) : N();\n      });\n    }, o.prototype.tick = function() {\n      setTimeout(this.delayedTick, 0);\n    }, o.prototype.prepareItems = function() {\n      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n        var t = this.queue[0], e = !1;\n        if (t && !t._destroyed) {\n          for (var r = 0, D = this.uploadHooks.length; r < D; r++)\n            if (this.uploadHooks[r](this.uploadHookHelper, t)) {\n              this.queue.shift(), e = !0;\n              break;\n            }\n        }\n        e || this.queue.shift();\n      }\n      if (this.queue.length)\n        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n      else {\n        this.ticking = !1;\n        var N = this.completes.slice(0);\n        this.completes.length = 0;\n        for (var r = 0, D = N.length; r < D; r++)\n          N[r]();\n      }\n    }, o.prototype.registerFindHook = function(t) {\n      return t && this.addHooks.push(t), this;\n    }, o.prototype.registerUploadHook = function(t) {\n      return t && this.uploadHooks.push(t), this;\n    }, o.prototype.add = function(t) {\n      for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)\n        ;\n      if (t instanceof Container)\n        for (var e = t.children.length - 1; e >= 0; e--)\n          this.add(t.children[e]);\n      return this;\n    }, o.prototype.destroy = function() {\n      this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n    }, o;\n  }()\n);\nfunction uploadBaseTextures(o, t) {\n  return t instanceof BaseTexture ? (t._glTextures[o.CONTEXT_UID] || o.texture.bind(t), !0) : !1;\n}\nfunction uploadGraphics(o, t) {\n  if (!(t instanceof Graphics))\n    return !1;\n  var e = t.geometry;\n  t.finishPoly(), e.updateBatches();\n  for (var r = e.batches, D = 0; D < r.length; D++) {\n    var N = r[D].style.texture;\n    N && uploadBaseTextures(o, N.baseTexture);\n  }\n  return e.batchable || o.geometry.bind(e, t._resolveDirectShader(o)), !0;\n}\nfunction findGraphics(o, t) {\n  return o instanceof Graphics ? (t.push(o), !0) : !1;\n}\nvar Prepare = (\n  /** @class */\n  function(o) {\n    __extends$i(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return r.uploadHookHelper = r.renderer, r.registerFindHook(findGraphics), r.registerUploadHook(uploadBaseTextures), r.registerUploadHook(uploadGraphics), r;\n    }\n    return t.extension = {\n      name: \"prepare\",\n      type: ExtensionType.RendererPlugin\n    }, t;\n  }(BasePrepare)\n);\n/*!\n * @pixi/spritesheet - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Spritesheet = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;\n      var D = this.baseTexture.resource;\n      this.resolution = this._updateResolution(r || (D ? D.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n    }\n    return o.prototype._updateResolution = function(t) {\n      t === void 0 && (t = null);\n      var e = this.data.meta.scale, r = getResolutionOfUrl(t, null);\n      return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;\n    }, o.prototype.parse = function(t) {\n      var e = this;\n      return t && deprecation(\"6.5.0\", \"Spritesheet.parse callback is deprecated, use the return Promise instead.\"), new Promise(function(r) {\n        e._callback = function(D) {\n          t == null || t(D), r(D);\n        }, e._batchIndex = 0, e._frameKeys.length <= o.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();\n      });\n    }, o.prototype._processFrames = function(t) {\n      for (var e = t, r = o.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {\n        var D = this._frameKeys[e], N = this._frames[D], k = N.frame;\n        if (k) {\n          var $ = null, G = null, U = N.trimmed !== !1 && N.sourceSize ? N.sourceSize : N.frame, z = new Rectangle(0, 0, Math.floor(U.w) / this.resolution, Math.floor(U.h) / this.resolution);\n          N.rotated ? $ = new Rectangle(Math.floor(k.x) / this.resolution, Math.floor(k.y) / this.resolution, Math.floor(k.h) / this.resolution, Math.floor(k.w) / this.resolution) : $ = new Rectangle(Math.floor(k.x) / this.resolution, Math.floor(k.y) / this.resolution, Math.floor(k.w) / this.resolution, Math.floor(k.h) / this.resolution), N.trimmed !== !1 && N.spriteSourceSize && (G = new Rectangle(Math.floor(N.spriteSourceSize.x) / this.resolution, Math.floor(N.spriteSourceSize.y) / this.resolution, Math.floor(k.w) / this.resolution, Math.floor(k.h) / this.resolution)), this.textures[D] = new Texture(this.baseTexture, $, z, G, N.rotated ? 2 : 0, N.anchor), Texture.addToCache(this.textures[D], D);\n        }\n        e++;\n      }\n    }, o.prototype._processAnimations = function() {\n      var t = this.data.animations || {};\n      for (var e in t) {\n        this.animations[e] = [];\n        for (var r = 0; r < t[e].length; r++) {\n          var D = t[e][r];\n          this.animations[e].push(this.textures[D]);\n        }\n      }\n    }, o.prototype._parseComplete = function() {\n      var t = this._callback;\n      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);\n    }, o.prototype._nextBatch = function() {\n      var t = this;\n      this._processFrames(this._batchIndex * o.BATCH_SIZE), this._batchIndex++, setTimeout(function() {\n        t._batchIndex * o.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());\n      }, 0);\n    }, o.prototype.destroy = function(t) {\n      var e;\n      t === void 0 && (t = !1);\n      for (var r in this.textures)\n        this.textures[r].destroy();\n      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n    }, o.BATCH_SIZE = 1e3, o;\n  }()\n), SpritesheetLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.use = function(t, e) {\n      var r, D, N = this, k = t.name + \"_image\";\n      if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || N.resources[k]) {\n        e();\n        return;\n      }\n      var $ = (D = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || D === void 0 ? void 0 : D.related_multi_packs;\n      if (Array.isArray($))\n        for (var G = function(q) {\n          if (typeof q != \"string\")\n            return \"continue\";\n          var W = q.replace(\".json\", \"\"), K = url$1.resolve(t.url.replace(N.baseUrl, \"\"), q);\n          if (N.resources[W] || Object.values(N.resources).some(function(J) {\n            return url$1.format(url$1.parse(J.url)) === K;\n          }))\n            return \"continue\";\n          var Z = {\n            crossOrigin: t.crossOrigin,\n            loadType: LoaderResource.LOAD_TYPE.XHR,\n            xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n            parentResource: t,\n            metadata: t.metadata\n          };\n          N.add(W, K, Z);\n        }, U = 0, z = $; U < z.length; U++) {\n          var X = z[U];\n          G(X);\n        }\n      var V = {\n        crossOrigin: t.crossOrigin,\n        metadata: t.metadata.imageMetadata,\n        parentResource: t\n      }, Y = o.getResourcePath(t, N.baseUrl);\n      N.add(k, Y, V, function(W) {\n        if (W.error) {\n          e(W.error);\n          return;\n        }\n        var K = new Spritesheet(W.texture, t.data, t.url);\n        K.parse().then(function() {\n          t.spritesheet = K, t.textures = K.textures, e();\n        });\n      });\n    }, o.getResourcePath = function(t, e) {\n      return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, \"\"), t.data.meta.image);\n    }, o.extension = ExtensionType.Loader, o;\n  }()\n);\n/*!\n * @pixi/sprite-tiling - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$h = function(o, t) {\n  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$h(o, t);\n};\nfunction __extends$h(o, t) {\n  extendStatics$h(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$1 = new Point();\n(function(o) {\n  __extends$h(t, o);\n  function t(e, r, D) {\n    r === void 0 && (r = 100), D === void 0 && (D = 100);\n    var N = o.call(this, e) || this;\n    return N.tileTransform = new Transform(), N._width = r, N._height = D, N.uvMatrix = N.texture.uvMatrix || new TextureMatrix(e), N.pluginName = \"tilingSprite\", N.uvRespectAnchor = !1, N;\n  }\n  return Object.defineProperty(t.prototype, \"clampMargin\", {\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(e) {\n      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tileScale\", {\n    /** The scaling of the image that is being tiled. */\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(e) {\n      this.tileTransform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tilePosition\", {\n    /** The offset of the image that is being tiled. */\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(e) {\n      this.tileTransform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._onTextureUpdate = function() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }, t.prototype._render = function(e) {\n    var r = this._texture;\n    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));\n  }, t.prototype._calculateBounds = function() {\n    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, D = this._width * (1 - this._anchor._x), N = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, e, r, D, N);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : o.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$1);\n    var r = this._width, D = this._height, N = -r * this.anchor._x;\n    if (tempPoint$1.x >= N && tempPoint$1.x < N + r) {\n      var k = -D * this.anchor._y;\n      if (tempPoint$1.y >= k && tempPoint$1.y < k + D)\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    o.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;\n  }, t.from = function(e, r) {\n    var D = e instanceof Texture ? e : Texture.from(e, r);\n    return new t(D, r.width, r.height);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Sprite);\nvar fragmentSimpleSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`, gl1VertexSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl1FragmentSrc = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`, gl2VertexSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl2FragmentSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`, tempMat = new Matrix(), TilingSpriteRenderer = (\n  /** @class */\n  function(o) {\n    __extends$h(t, o);\n    function t(e) {\n      var r = o.call(this, e) || this;\n      return e.runners.contextChange.add(r), r.quad = new QuadUv(), r.state = State.for2d(), r;\n    }\n    return t.prototype.contextChange = function() {\n      var e = this.renderer, r = { globals: e.globalUniforms };\n      this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, r), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, r) : Shader.from(gl1VertexSrc, gl1FragmentSrc, r);\n    }, t.prototype.render = function(e) {\n      var r = this.renderer, D = this.quad, N = D.vertices;\n      N[0] = N[6] = e._width * -e.anchor.x, N[1] = N[3] = e._height * -e.anchor.y, N[2] = N[4] = e._width * (1 - e.anchor.x), N[5] = N[7] = e._height * (1 - e.anchor.y);\n      var k = e.uvRespectAnchor ? e.anchor.x : 0, $ = e.uvRespectAnchor ? e.anchor.y : 0;\n      N = D.uvs, N[0] = N[6] = -k, N[1] = N[3] = -$, N[2] = N[4] = 1 - k, N[5] = N[7] = 1 - $, D.invalidate();\n      var G = e._texture, U = G.baseTexture, z = U.alphaMode > 0, X = e.tileTransform.localTransform, V = e.uvMatrix, Y = U.isPowerOfTwo && G.frame.width === U.width && G.frame.height === U.height;\n      Y && (U._glTextures[r.CONTEXT_UID] ? Y = U.wrapMode !== WRAP_MODES.CLAMP : U.wrapMode === WRAP_MODES.CLAMP && (U.wrapMode = WRAP_MODES.REPEAT));\n      var q = Y ? this.simpleShader : this.shader, W = G.width, K = G.height, Z = e._width, J = e._height;\n      tempMat.set(X.a * W / Z, X.b * W / J, X.c * K / Z, X.d * K / J, X.tx / Z, X.ty / J), tempMat.invert(), Y ? tempMat.prepend(V.mapCoord) : (q.uniforms.uMapCoord = V.mapCoord.toArray(!0), q.uniforms.uClampFrame = V.uClampFrame, q.uniforms.uClampOffset = V.uClampOffset), q.uniforms.uTransform = tempMat.toArray(!0), q.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, q.uniforms.uColor, z), q.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), q.uniforms.uSampler = G, r.shader.bind(q), r.geometry.bind(D), this.state.blendMode = correctBlendMode(e.blendMode, z), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }, t.extension = {\n      name: \"tilingSprite\",\n      type: ExtensionType.RendererPlugin\n    }, t;\n  }(ObjectRenderer)\n);\n/*!\n * @pixi/mesh - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$g = function(o, t) {\n  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$g(o, t);\n};\nfunction __extends$g(o, t) {\n  extendStatics$g(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar MeshBatchUvs = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n    }\n    return o.prototype.update = function(t) {\n      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {\n        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n        var e = this.uvBuffer.data;\n        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;\n      }\n    }, o;\n  }()\n), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = (\n  /** @class */\n  function(o) {\n    __extends$g(t, o);\n    function t(e, r, D, N) {\n      N === void 0 && (N = DRAW_MODES.TRIANGLES);\n      var k = o.call(this) || this;\n      return k.geometry = e, k.shader = r, k.state = D || State.for2d(), k.drawMode = N, k.start = 0, k.size = 0, k.uvs = null, k.indices = null, k.vertexData = new Float32Array(1), k.vertexDirty = -1, k._transformID = -1, k._roundPixels = settings.ROUND_PIXELS, k.batchUvs = null, k;\n    }\n    return Object.defineProperty(t.prototype, \"geometry\", {\n      /**\n       * Includes vertex positions, face indices, normals, colors, UVs, and\n       * custom attributes within buffers, reducing the cost of passing all\n       * this data to the GPU. Can be shared between multiple Mesh objects.\n       */\n      get: function() {\n        return this._geometry;\n      },\n      set: function(e) {\n        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"uvBuffer\", {\n      /**\n       * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n       * @readonly\n       */\n      get: function() {\n        return this.geometry.buffers[1];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"verticesBuffer\", {\n      /**\n       * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n       * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n       * @readonly\n       */\n      get: function() {\n        return this.geometry.buffers[0];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"material\", {\n      get: function() {\n        return this.shader;\n      },\n      /** Alias for {@link PIXI.Mesh#shader}. */\n      set: function(e) {\n        this.shader = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"blendMode\", {\n      get: function() {\n        return this.state.blendMode;\n      },\n      /**\n       * The blend mode to be applied to the Mesh. Apply a value of\n       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n       * @default PIXI.BLEND_MODES.NORMAL;\n       */\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"roundPixels\", {\n      get: function() {\n        return this._roundPixels;\n      },\n      /**\n       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n       * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n       * The main disadvantage is movement of objects may appear less smooth.\n       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n       * @default false\n       */\n      set: function(e) {\n        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The multiply tint applied to the Mesh. This is a hex value. A value of\n       * `0xFFFFFF` will remove any tint effect.\n       *\n       * Null for non-MeshMaterial shaders\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return \"tint\" in this.shader ? this.shader.tint : null;\n      },\n      set: function(e) {\n        this.shader.tint = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"texture\", {\n      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n      get: function() {\n        return \"texture\" in this.shader ? this.shader.texture : null;\n      },\n      set: function(e) {\n        this.shader.texture = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._render = function(e) {\n      var r = this.geometry.buffers[0].data, D = this.shader;\n      D.batchable && this.drawMode === DRAW_MODES.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);\n    }, t.prototype._renderDefault = function(e) {\n      var r = this.shader;\n      r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }, t.prototype._renderToBatch = function(e) {\n      var r = this.geometry, D = this.shader;\n      D.uvMatrix && (D.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = D._tintRGB, this._texture = D.texture;\n      var N = this.material.pluginName;\n      e.batch.setObjectRenderer(e.plugins[N]), e.plugins[N].render(this);\n    }, t.prototype.calculateVertices = function() {\n      var e = this.geometry, r = e.buffers[0], D = r.data, N = r._updateID;\n      if (!(N === this.vertexDirty && this._transformID === this.transform._worldID)) {\n        this._transformID = this.transform._worldID, this.vertexData.length !== D.length && (this.vertexData = new Float32Array(D.length));\n        for (var k = this.transform.worldTransform, $ = k.a, G = k.b, U = k.c, z = k.d, X = k.tx, V = k.ty, Y = this.vertexData, q = 0; q < Y.length / 2; q++) {\n          var W = D[q * 2], K = D[q * 2 + 1];\n          Y[q * 2] = $ * W + U * K + X, Y[q * 2 + 1] = G * W + z * K + V;\n        }\n        if (this._roundPixels)\n          for (var Z = settings.RESOLUTION, q = 0; q < Y.length; ++q)\n            Y[q] = Math.round((Y[q] * Z | 0) / Z);\n        this.vertexDirty = N;\n      }\n    }, t.prototype.calculateUvs = function() {\n      var e = this.geometry.buffers[1], r = this.shader;\n      r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n    }, t.prototype._calculateBounds = function() {\n      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }, t.prototype.containsPoint = function(e) {\n      if (!this.getBounds().contains(e.x, e.y))\n        return !1;\n      this.worldTransform.applyInverse(e, tempPoint);\n      for (var r = this.geometry.getBuffer(\"aVertexPosition\").data, D = tempPolygon.points, N = this.geometry.getIndex().data, k = N.length, $ = this.drawMode === 4 ? 3 : 1, G = 0; G + 2 < k; G += $) {\n        var U = N[G] * 2, z = N[G + 1] * 2, X = N[G + 2] * 2;\n        if (D[0] = r[U], D[1] = r[U + 1], D[2] = r[z], D[3] = r[z + 1], D[4] = r[X], D[5] = r[X + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))\n          return !0;\n      }\n      return !1;\n    }, t.prototype.destroy = function(e) {\n      o.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n    }, t.BATCHABLE_SIZE = 100, t;\n  }(Container)\n), fragment$5 = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`, vertex$2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`, MeshMaterial = (\n  /** @class */\n  function(o) {\n    __extends$g(t, o);\n    function t(e, r) {\n      var D = this, N = {\n        uSampler: e,\n        alpha: 1,\n        uTextureMatrix: Matrix.IDENTITY,\n        uColor: new Float32Array([1, 1, 1, 1])\n      };\n      return r = Object.assign({\n        tint: 16777215,\n        alpha: 1,\n        pluginName: \"batch\"\n      }, r), r.uniforms && Object.assign(N, r.uniforms), D = o.call(this, r.program || Program.from(vertex$2, fragment$5), N) || this, D._colorDirty = !1, D.uvMatrix = new TextureMatrix(e), D.batchable = r.program === void 0, D.pluginName = r.pluginName, D.tint = r.tint, D.alpha = r.alpha, D;\n    }\n    return Object.defineProperty(t.prototype, \"texture\", {\n      /** Reference to the texture being rendered. */\n      get: function() {\n        return this.uniforms.uSampler;\n      },\n      set: function(e) {\n        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"alpha\", {\n      get: function() {\n        return this._alpha;\n      },\n      /**\n       * This gets automatically set by the object using this.\n       * @default 1\n       */\n      set: function(e) {\n        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      get: function() {\n        return this._tint;\n      },\n      /**\n       * Multiply tint for the material.\n       * @default 0xFFFFFF\n       */\n      set: function(e) {\n        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.update = function() {\n      if (this._colorDirty) {\n        this._colorDirty = !1;\n        var e = this.texture.baseTexture;\n        premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);\n      }\n      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n    }, t;\n  }(Shader)\n), MeshGeometry = (\n  /** @class */\n  function(o) {\n    __extends$g(t, o);\n    function t(e, r, D) {\n      var N = o.call(this) || this, k = new Buffer$1(e), $ = new Buffer$1(r, !0), G = new Buffer$1(D, !0, !0);\n      return N.addAttribute(\"aVertexPosition\", k, 2, !1, TYPES.FLOAT).addAttribute(\"aTextureCoord\", $, 2, !1, TYPES.FLOAT).addIndex(G), N._updateId = -1, N;\n    }\n    return Object.defineProperty(t.prototype, \"vertexDirtyId\", {\n      /**\n       * If the vertex position is updated.\n       * @readonly\n       * @private\n       */\n      get: function() {\n        return this.buffers[0]._updateID;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Geometry)\n);\n/*!\n * @pixi/text-bitmap - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$f = function(o, t) {\n  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$f(o, t);\n};\nfunction __extends$f(o, t) {\n  extendStatics$f(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar BitmapFontData = (\n  /** @class */\n  function() {\n    function o() {\n      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n    }\n    return o;\n  }()\n), TextFormat = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.test = function(t) {\n      return typeof t == \"string\" && t.indexOf(\"info face=\") === 0;\n    }, o.parse = function(t) {\n      var e = t.match(/^[a-z]+\\s+.+$/gm), r = {\n        info: [],\n        common: [],\n        page: [],\n        char: [],\n        chars: [],\n        kerning: [],\n        kernings: [],\n        distanceField: []\n      };\n      for (var D in e) {\n        var N = e[D].match(/^[a-z]+/gm)[0], k = e[D].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm), $ = {};\n        for (var G in k) {\n          var U = k[G].split(\"=\"), z = U[0], X = U[1].replace(/\"/gm, \"\"), V = parseFloat(X), Y = isNaN(V) ? X : V;\n          $[z] = Y;\n        }\n        r[N].push($);\n      }\n      var q = new BitmapFontData();\n      return r.info.forEach(function(W) {\n        return q.info.push({\n          face: W.face,\n          size: parseInt(W.size, 10)\n        });\n      }), r.common.forEach(function(W) {\n        return q.common.push({\n          lineHeight: parseInt(W.lineHeight, 10)\n        });\n      }), r.page.forEach(function(W) {\n        return q.page.push({\n          id: parseInt(W.id, 10),\n          file: W.file\n        });\n      }), r.char.forEach(function(W) {\n        return q.char.push({\n          id: parseInt(W.id, 10),\n          page: parseInt(W.page, 10),\n          x: parseInt(W.x, 10),\n          y: parseInt(W.y, 10),\n          width: parseInt(W.width, 10),\n          height: parseInt(W.height, 10),\n          xoffset: parseInt(W.xoffset, 10),\n          yoffset: parseInt(W.yoffset, 10),\n          xadvance: parseInt(W.xadvance, 10)\n        });\n      }), r.kerning.forEach(function(W) {\n        return q.kerning.push({\n          first: parseInt(W.first, 10),\n          second: parseInt(W.second, 10),\n          amount: parseInt(W.amount, 10)\n        });\n      }), r.distanceField.forEach(function(W) {\n        return q.distanceField.push({\n          distanceRange: parseInt(W.distanceRange, 10),\n          fieldType: W.fieldType\n        });\n      }), q;\n    }, o;\n  }()\n), XMLFormat = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.test = function(t) {\n      return t instanceof XMLDocument && t.getElementsByTagName(\"page\").length && t.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n    }, o.parse = function(t) {\n      for (var e = new BitmapFontData(), r = t.getElementsByTagName(\"info\"), D = t.getElementsByTagName(\"common\"), N = t.getElementsByTagName(\"page\"), k = t.getElementsByTagName(\"char\"), $ = t.getElementsByTagName(\"kerning\"), G = t.getElementsByTagName(\"distanceField\"), U = 0; U < r.length; U++)\n        e.info.push({\n          face: r[U].getAttribute(\"face\"),\n          size: parseInt(r[U].getAttribute(\"size\"), 10)\n        });\n      for (var U = 0; U < D.length; U++)\n        e.common.push({\n          lineHeight: parseInt(D[U].getAttribute(\"lineHeight\"), 10)\n        });\n      for (var U = 0; U < N.length; U++)\n        e.page.push({\n          id: parseInt(N[U].getAttribute(\"id\"), 10) || 0,\n          file: N[U].getAttribute(\"file\")\n        });\n      for (var U = 0; U < k.length; U++) {\n        var z = k[U];\n        e.char.push({\n          id: parseInt(z.getAttribute(\"id\"), 10),\n          page: parseInt(z.getAttribute(\"page\"), 10) || 0,\n          x: parseInt(z.getAttribute(\"x\"), 10),\n          y: parseInt(z.getAttribute(\"y\"), 10),\n          width: parseInt(z.getAttribute(\"width\"), 10),\n          height: parseInt(z.getAttribute(\"height\"), 10),\n          xoffset: parseInt(z.getAttribute(\"xoffset\"), 10),\n          yoffset: parseInt(z.getAttribute(\"yoffset\"), 10),\n          xadvance: parseInt(z.getAttribute(\"xadvance\"), 10)\n        });\n      }\n      for (var U = 0; U < $.length; U++)\n        e.kerning.push({\n          first: parseInt($[U].getAttribute(\"first\"), 10),\n          second: parseInt($[U].getAttribute(\"second\"), 10),\n          amount: parseInt($[U].getAttribute(\"amount\"), 10)\n        });\n      for (var U = 0; U < G.length; U++)\n        e.distanceField.push({\n          fieldType: G[U].getAttribute(\"fieldType\"),\n          distanceRange: parseInt(G[U].getAttribute(\"distanceRange\"), 10)\n        });\n      return e;\n    }, o;\n  }()\n), XMLStringFormat = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.test = function(t) {\n      if (typeof t == \"string\" && t.indexOf(\"<font>\") > -1) {\n        var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n        return XMLFormat.test(e);\n      }\n      return !1;\n    }, o.parse = function(t) {\n      var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n      return XMLFormat.parse(e);\n    }, o;\n  }()\n), formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(o) {\n  for (var t = 0; t < formats.length; t++)\n    if (formats[t].test(o))\n      return formats[t];\n  return null;\n}\nfunction generateFillStyle(o, t, e, r, D, N) {\n  var k = e.fill;\n  if (Array.isArray(k)) {\n    if (k.length === 1)\n      return k[0];\n  } else\n    return k;\n  var $, G = e.dropShadow ? e.dropShadowDistance : 0, U = e.padding || 0, z = o.width / r - G - U * 2, X = o.height / r - G - U * 2, V = k.slice(), Y = e.fillGradientStops.slice();\n  if (!Y.length)\n    for (var q = V.length + 1, W = 1; W < q; ++W)\n      Y.push(W / q);\n  if (V.unshift(k[0]), Y.unshift(0), V.push(k[k.length - 1]), Y.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    $ = t.createLinearGradient(z / 2, U, z / 2, X + U);\n    for (var K = 0, Z = N.fontProperties.fontSize + e.strokeThickness, J = Z / X, W = 0; W < D.length; W++)\n      for (var Q = N.lineHeight * W, et = 0; et < V.length; et++) {\n        var nt = 0;\n        typeof Y[et] == \"number\" ? nt = Y[et] : nt = et / V.length;\n        var tt = Q / X + nt * J, it = Math.max(K, tt);\n        it = Math.min(it, 1), $.addColorStop(it, V[et]), K = it;\n      }\n  } else {\n    $ = t.createLinearGradient(U, X / 2, z + U, X / 2);\n    for (var st = V.length + 1, at = 1, W = 0; W < V.length; W++) {\n      var ut = void 0;\n      typeof Y[W] == \"number\" ? ut = Y[W] : ut = at / st, $.addColorStop(ut, V[W]), at++;\n    }\n  }\n  return $;\n}\nfunction drawGlyph(o, t, e, r, D, N, k) {\n  var $ = e.text, G = e.fontProperties;\n  t.translate(r, D), t.scale(N, N);\n  var U = k.strokeThickness / 2, z = -(k.strokeThickness / 2);\n  if (t.font = k.toFontString(), t.lineWidth = k.strokeThickness, t.textBaseline = k.textBaseline, t.lineJoin = k.lineJoin, t.miterLimit = k.miterLimit, t.fillStyle = generateFillStyle(o, t, k, N, [$], e), t.strokeStyle = k.stroke, k.dropShadow) {\n    var X = k.dropShadowColor, V = hex2rgb(typeof X == \"number\" ? X : string2hex(X)), Y = k.dropShadowBlur * N, q = k.dropShadowDistance * N;\n    t.shadowColor = \"rgba(\" + V[0] * 255 + \",\" + V[1] * 255 + \",\" + V[2] * 255 + \",\" + k.dropShadowAlpha + \")\", t.shadowBlur = Y, t.shadowOffsetX = Math.cos(k.dropShadowAngle) * q, t.shadowOffsetY = Math.sin(k.dropShadowAngle) * q;\n  } else\n    t.shadowColor = \"black\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;\n  k.stroke && k.strokeThickness && t.strokeText($, U, z + e.lineHeight - G.descent), k.fill && t.fillText($, U, z + e.lineHeight - G.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction splitTextToCharacters(o) {\n  return Array.from ? Array.from(o) : o.split(\"\");\n}\nfunction resolveCharacters(o) {\n  typeof o == \"string\" && (o = [o]);\n  for (var t = [], e = 0, r = o.length; e < r; e++) {\n    var D = o[e];\n    if (Array.isArray(D)) {\n      if (D.length !== 2)\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + D.length + \".\");\n      var N = D[0].charCodeAt(0), k = D[1].charCodeAt(0);\n      if (k < N)\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      for (var $ = N, G = k; $ <= G; $++)\n        t.push(String.fromCharCode($));\n    } else\n      t.push.apply(t, splitTextToCharacters(D));\n  }\n  if (t.length === 0)\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  return t;\n}\nfunction extractCharCode(o) {\n  return o.codePointAt ? o.codePointAt(0) : o.charCodeAt(0);\n}\nvar BitmapFont = (\n  /** @class */\n  function() {\n    function o(t, e, r) {\n      var D, N, k = t.info[0], $ = t.common[0], G = t.page[0], U = t.distanceField[0], z = getResolutionOfUrl(G.file), X = {};\n      this._ownsTextures = r, this.font = k.face, this.size = k.size, this.lineHeight = $.lineHeight / z, this.chars = {}, this.pageTextures = X;\n      for (var V = 0; V < t.page.length; V++) {\n        var Y = t.page[V], q = Y.id, W = Y.file;\n        X[q] = e instanceof Array ? e[V] : e[W], U != null && U.fieldType && U.fieldType !== \"none\" && (X[q].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, X[q].baseTexture.mipmap = MIPMAP_MODES.OFF);\n      }\n      for (var V = 0; V < t.char.length; V++) {\n        var K = t.char[V], q = K.id, Z = K.page, J = t.char[V], Q = J.x, et = J.y, nt = J.width, tt = J.height, it = J.xoffset, st = J.yoffset, at = J.xadvance;\n        Q /= z, et /= z, nt /= z, tt /= z, it /= z, st /= z, at /= z;\n        var ut = new Rectangle(Q + X[Z].frame.x / z, et + X[Z].frame.y / z, nt, tt);\n        this.chars[q] = {\n          xOffset: it,\n          yOffset: st,\n          xAdvance: at,\n          kerning: {},\n          texture: new Texture(X[Z].baseTexture, ut),\n          page: Z\n        };\n      }\n      for (var V = 0; V < t.kerning.length; V++) {\n        var ft = t.kerning[V], ct = ft.first, vt = ft.second, yt = ft.amount;\n        ct /= z, vt /= z, yt /= z, this.chars[vt] && (this.chars[vt].kerning[ct] = yt);\n      }\n      this.distanceFieldRange = U == null ? void 0 : U.distanceRange, this.distanceFieldType = (N = (D = U == null ? void 0 : U.fieldType) === null || D === void 0 ? void 0 : D.toLowerCase()) !== null && N !== void 0 ? N : \"none\";\n    }\n    return o.prototype.destroy = function() {\n      for (var t in this.chars)\n        this.chars[t].texture.destroy(), this.chars[t].texture = null;\n      for (var t in this.pageTextures)\n        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;\n      this.chars = null, this.pageTextures = null;\n    }, o.install = function(t, e, r) {\n      var D;\n      if (t instanceof BitmapFontData)\n        D = t;\n      else {\n        var N = autoDetectFormat(t);\n        if (!N)\n          throw new Error(\"Unrecognized data format for font.\");\n        D = N.parse(t);\n      }\n      e instanceof Texture && (e = [e]);\n      var k = new o(D, e, r);\n      return o.available[k.font] = k, k;\n    }, o.uninstall = function(t) {\n      var e = o.available[t];\n      if (!e)\n        throw new Error(\"No font found named '\" + t + \"'\");\n      e.destroy(), delete o.available[t];\n    }, o.from = function(t, e, r) {\n      if (!t)\n        throw new Error(\"[BitmapFont] Property `name` is required.\");\n      var D = Object.assign({}, o.defaultOptions, r), N = D.chars, k = D.padding, $ = D.resolution, G = D.textureWidth, U = D.textureHeight, z = resolveCharacters(N), X = e instanceof TextStyle ? e : new TextStyle(e), V = G, Y = new BitmapFontData();\n      Y.info[0] = {\n        face: X.fontFamily,\n        size: X.fontSize\n      }, Y.common[0] = {\n        lineHeight: X.fontSize\n      };\n      for (var q = 0, W = 0, K, Z, J, Q = 0, et = [], nt = 0; nt < z.length; nt++) {\n        K || (K = settings.ADAPTER.createCanvas(), K.width = G, K.height = U, Z = K.getContext(\"2d\"), J = new BaseTexture(K, { resolution: $ }), et.push(new Texture(J)), Y.page.push({\n          id: et.length - 1,\n          file: \"\"\n        }));\n        var tt = z[nt], it = TextMetrics.measureText(tt, X, !1, K), st = it.width, at = Math.ceil(it.height), ut = Math.ceil((X.fontStyle === \"italic\" ? 2 : 1) * st);\n        if (W >= U - at * $) {\n          if (W === 0)\n            throw new Error(\"[BitmapFont] textureHeight \" + U + \"px is too small \" + (\"(fontFamily: '\" + X.fontFamily + \"', fontSize: \" + X.fontSize + \"px, char: '\" + tt + \"')\"));\n          --nt, K = null, Z = null, J = null, W = 0, q = 0, Q = 0;\n          continue;\n        }\n        if (Q = Math.max(at + it.fontProperties.descent, Q), ut * $ + q >= V) {\n          if (q === 0)\n            throw new Error(\"[BitmapFont] textureWidth \" + G + \"px is too small \" + (\"(fontFamily: '\" + X.fontFamily + \"', fontSize: \" + X.fontSize + \"px, char: '\" + tt + \"')\"));\n          --nt, W += Q * $, W = Math.ceil(W), q = 0, Q = 0;\n          continue;\n        }\n        drawGlyph(K, Z, it, q, W, $, X);\n        var ft = extractCharCode(it.text);\n        Y.char.push({\n          id: ft,\n          page: et.length - 1,\n          x: q / $,\n          y: W / $,\n          width: ut,\n          height: at,\n          xoffset: 0,\n          yoffset: 0,\n          xadvance: Math.ceil(st - (X.dropShadow ? X.dropShadowDistance : 0) - (X.stroke ? X.strokeThickness : 0))\n        }), q += (ut + 2 * k) * $, q = Math.ceil(q);\n      }\n      for (var nt = 0, ct = z.length; nt < ct; nt++)\n        for (var vt = z[nt], yt = 0; yt < ct; yt++) {\n          var mt = z[yt], _t = Z.measureText(vt).width, Tt = Z.measureText(mt).width, Pt = Z.measureText(vt + mt).width, St = Pt - (_t + Tt);\n          St && Y.kerning.push({\n            first: extractCharCode(vt),\n            second: extractCharCode(mt),\n            amount: St\n          });\n        }\n      var gt = new o(Y, et, !0);\n      return o.available[t] !== void 0 && o.uninstall(t), o.available[t] = gt, gt;\n    }, o.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"], o.NUMERIC = [[\"0\", \"9\"]], o.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"], o.ASCII = [[\" \", \"~\"]], o.defaultOptions = {\n      resolution: 1,\n      textureWidth: 512,\n      textureHeight: 512,\n      padding: 4,\n      chars: o.ALPHANUMERIC\n    }, o.available = {}, o;\n  }()\n), msdfFrag = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n  if (median < 0.01) {\\r\n    alpha = 0.0;\\r\n  } else if (median > 0.99) {\\r\n    alpha = 1.0;\\r\n  }\\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\n\\r\n}\\r\n`, msdfVert = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];\n(function(o) {\n  __extends$f(t, o);\n  function t(e, r) {\n    r === void 0 && (r = {});\n    var D = o.call(this) || this;\n    D._tint = 16777215;\n    var N = Object.assign({}, t.styleDefaults, r), k = N.align, $ = N.tint, G = N.maxWidth, U = N.letterSpacing, z = N.fontName, X = N.fontSize;\n    if (!BitmapFont.available[z])\n      throw new Error('Missing BitmapFont \"' + z + '\"');\n    return D._activePagesMeshData = [], D._textWidth = 0, D._textHeight = 0, D._align = k, D._tint = $, D._font = void 0, D._fontName = z, D._fontSize = X, D.text = e, D._maxWidth = G, D._maxLineHeight = 0, D._letterSpacing = U, D._anchor = new ObservablePoint(function() {\n      D.dirty = !0;\n    }, D, 0, 0), D._roundPixels = settings.ROUND_PIXELS, D.dirty = !0, D._resolution = settings.RESOLUTION, D._autoResolution = !0, D._textureCache = {}, D;\n  }\n  return t.prototype.updateText = function() {\n    for (var e, r = BitmapFont.available[this._fontName], D = this.fontSize, N = D / r.size, k = new Point(), $ = [], G = [], U = [], z = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \", X = splitTextToCharacters(z), V = this._maxWidth * r.size / D, Y = r.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, q = null, W = 0, K = 0, Z = 0, J = -1, Q = 0, et = 0, nt = 0, tt = 0, it = 0; it < X.length; it++) {\n      var st = X[it], at = extractCharCode(st);\n      if (/(?:\\s)/.test(st) && (J = it, Q = W, tt++), st === \"\\r\" || st === `\n`) {\n        G.push(W), U.push(-1), K = Math.max(K, W), ++Z, ++et, k.x = 0, k.y += r.lineHeight, q = null, tt = 0;\n        continue;\n      }\n      var ut = r.chars[at];\n      if (ut) {\n        q && ut.kerning[q] && (k.x += ut.kerning[q]);\n        var ft = charRenderDataPool.pop() || {\n          texture: Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new Point()\n        };\n        ft.texture = ut.texture, ft.line = Z, ft.charCode = at, ft.position.x = k.x + ut.xOffset + this._letterSpacing / 2, ft.position.y = k.y + ut.yOffset, ft.prevSpaces = tt, $.push(ft), W = ft.position.x + Math.max(ut.xAdvance - ut.xOffset, ut.texture.orig.width), k.x += ut.xAdvance + this._letterSpacing, nt = Math.max(nt, ut.yOffset + ut.texture.height), q = at, J !== -1 && V > 0 && k.x > V && (++et, removeItems($, 1 + J - et, 1 + it - J), it = J, J = -1, G.push(Q), U.push($.length > 0 ? $[$.length - 1].prevSpaces : 0), K = Math.max(K, Q), Z++, k.x = 0, k.y += r.lineHeight, q = null, tt = 0);\n      }\n    }\n    var ct = X[X.length - 1];\n    ct !== \"\\r\" && ct !== `\n` && (/(?:\\s)/.test(ct) && (W = Q), G.push(W), K = Math.max(K, W), U.push(-1));\n    for (var vt = [], it = 0; it <= Z; it++) {\n      var yt = 0;\n      this._align === \"right\" ? yt = K - G[it] : this._align === \"center\" ? yt = (K - G[it]) / 2 : this._align === \"justify\" && (yt = U[it] < 0 ? 0 : (K - G[it]) / U[it]), vt.push(yt);\n    }\n    var mt = $.length, _t = {}, Tt = [], Pt = this._activePagesMeshData;\n    Y.push.apply(Y, Pt);\n    for (var it = 0; it < mt; it++) {\n      var St = $[it].texture, gt = St.baseTexture.uid;\n      if (!_t[gt]) {\n        var bt = Y.pop();\n        if (!bt) {\n          var Nt = new MeshGeometry(), At = void 0, It = void 0;\n          r.distanceFieldType === \"none\" ? (At = new MeshMaterial(Texture.EMPTY), It = BLEND_MODES.NORMAL) : (At = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), It = BLEND_MODES.NORMAL_NPM);\n          var Mt = new Mesh(Nt, At);\n          Mt.blendMode = It, bt = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh: Mt,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        bt.index = 0, bt.indexCount = 0, bt.vertexCount = 0, bt.uvsCount = 0, bt.total = 0;\n        var dt = this._textureCache;\n        dt[gt] = dt[gt] || new Texture(St.baseTexture), bt.mesh.texture = dt[gt], bt.mesh.tint = this._tint, Tt.push(bt), _t[gt] = bt;\n      }\n      _t[gt].total++;\n    }\n    for (var it = 0; it < Pt.length; it++)\n      Tt.indexOf(Pt[it]) === -1 && this.removeChild(Pt[it].mesh);\n    for (var it = 0; it < Tt.length; it++)\n      Tt[it].mesh.parent !== this && this.addChild(Tt[it].mesh);\n    this._activePagesMeshData = Tt;\n    for (var it in _t) {\n      var bt = _t[it], $t = bt.total;\n      if (!(((e = bt.indices) === null || e === void 0 ? void 0 : e.length) > 6 * $t) || bt.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n        bt.vertices = new Float32Array(4 * 2 * $t), bt.uvs = new Float32Array(4 * 2 * $t), bt.indices = new Uint16Array(6 * $t);\n      else\n        for (var Dt = bt.total, Vt = bt.vertices, Lt = Dt * 4 * 2; Lt < Vt.length; Lt++)\n          Vt[Lt] = 0;\n      bt.mesh.size = 6 * $t;\n    }\n    for (var it = 0; it < mt; it++) {\n      var st = $[it], Et = st.position.x + vt[st.line] * (this._align === \"justify\" ? st.prevSpaces : 1);\n      this._roundPixels && (Et = Math.round(Et));\n      var Ht = Et * N, kt = st.position.y * N, St = st.texture, wt = _t[St.baseTexture.uid], Bt = St.frame, jt = St._uvs, Ct = wt.index++;\n      wt.indices[Ct * 6 + 0] = 0 + Ct * 4, wt.indices[Ct * 6 + 1] = 1 + Ct * 4, wt.indices[Ct * 6 + 2] = 2 + Ct * 4, wt.indices[Ct * 6 + 3] = 0 + Ct * 4, wt.indices[Ct * 6 + 4] = 2 + Ct * 4, wt.indices[Ct * 6 + 5] = 3 + Ct * 4, wt.vertices[Ct * 8 + 0] = Ht, wt.vertices[Ct * 8 + 1] = kt, wt.vertices[Ct * 8 + 2] = Ht + Bt.width * N, wt.vertices[Ct * 8 + 3] = kt, wt.vertices[Ct * 8 + 4] = Ht + Bt.width * N, wt.vertices[Ct * 8 + 5] = kt + Bt.height * N, wt.vertices[Ct * 8 + 6] = Ht, wt.vertices[Ct * 8 + 7] = kt + Bt.height * N, wt.uvs[Ct * 8 + 0] = jt.x0, wt.uvs[Ct * 8 + 1] = jt.y0, wt.uvs[Ct * 8 + 2] = jt.x1, wt.uvs[Ct * 8 + 3] = jt.y1, wt.uvs[Ct * 8 + 4] = jt.x2, wt.uvs[Ct * 8 + 5] = jt.y2, wt.uvs[Ct * 8 + 6] = jt.x3, wt.uvs[Ct * 8 + 7] = jt.y3;\n    }\n    this._textWidth = K * N, this._textHeight = (k.y + r.lineHeight) * N;\n    for (var it in _t) {\n      var bt = _t[it];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        for (var qt = 0, Qt = this._textWidth * this.anchor.x, Kt = this._textHeight * this.anchor.y, Se = 0; Se < bt.total; Se++)\n          bt.vertices[qt++] -= Qt, bt.vertices[qt++] -= Kt, bt.vertices[qt++] -= Qt, bt.vertices[qt++] -= Kt, bt.vertices[qt++] -= Qt, bt.vertices[qt++] -= Kt, bt.vertices[qt++] -= Qt, bt.vertices[qt++] -= Kt;\n      this._maxLineHeight = nt * N;\n      var Oe = bt.mesh.geometry.getBuffer(\"aVertexPosition\"), ue = bt.mesh.geometry.getBuffer(\"aTextureCoord\"), _e = bt.mesh.geometry.getIndex();\n      Oe.data = bt.vertices, ue.data = bt.uvs, _e.data = bt.indices, Oe.update(), ue.update(), _e.update();\n    }\n    for (var it = 0; it < $.length; it++)\n      charRenderDataPool.push($[it]);\n    this._font = r, this.dirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.validate(), this.containerUpdateTransform();\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);\n    var r = BitmapFont.available[this._fontName], D = r.distanceFieldRange, N = r.distanceFieldType, k = r.size;\n    if (N !== \"none\")\n      for (var $ = this.worldTransform, G = $.a, U = $.b, z = $.c, X = $.d, V = Math.sqrt(G * G + U * U), Y = Math.sqrt(z * z + X * X), q = (Math.abs(V) + Math.abs(Y)) / 2, W = this.fontSize / k, K = 0, Z = this._activePagesMeshData; K < Z.length; K++) {\n        var J = Z[K];\n        J.mesh.shader.uniforms.uFWidth = q * D * W * this._resolution;\n      }\n    o.prototype._render.call(this, e);\n  }, t.prototype.getLocalBounds = function() {\n    return this.validate(), o.prototype.getLocalBounds.call(this);\n  }, t.prototype.validate = function() {\n    var e = BitmapFont.available[this._fontName];\n    if (!e)\n      throw new Error('Missing BitmapFont \"' + this._fontName + '\"');\n    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      if (this._tint !== e) {\n        this._tint = e;\n        for (var r = 0; r < this._activePagesMeshData.length; r++)\n          this._activePagesMeshData[r].mesh.tint = e;\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"align\", {\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    get: function() {\n      return this._align;\n    },\n    set: function(e) {\n      this._align !== e && (this._align = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontName\", {\n    /** The name of the BitmapFont. */\n    get: function() {\n      return this._fontName;\n    },\n    set: function(e) {\n      if (!BitmapFont.available[e])\n        throw new Error('Missing BitmapFont \"' + e + '\"');\n      this._fontName !== e && (this._fontName = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontSize\", {\n    /** The size of the font to display. */\n    get: function() {\n      var e;\n      return (e = this._fontSize) !== null && e !== void 0 ? e : BitmapFont.available[this._fontName].size;\n    },\n    set: function(e) {\n      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      typeof e == \"number\" ? this._anchor.set(e) : this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    /** The text of the BitmapText object. */\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxWidth\", {\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(e) {\n      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxLineHeight\", {\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._maxLineHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textWidth\", {\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._textWidth;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"letterSpacing\", {\n    /** Additional space between characters. */\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(e) {\n      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textHeight\", {\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._textHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.destroy = function(e) {\n    var r = this._textureCache, D = BitmapFont.available[this._fontName], N = D.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    N.push.apply(N, this._activePagesMeshData);\n    for (var k = 0, $ = this._activePagesMeshData; k < $.length; k++) {\n      var G = $[k];\n      this.removeChild(G.mesh);\n    }\n    this._activePagesMeshData = [], N.filter(function(X) {\n      return r[X.mesh.texture.baseTexture.uid];\n    }).forEach(function(X) {\n      X.mesh.texture = Texture.EMPTY;\n    });\n    for (var U in r) {\n      var z = r[U];\n      z.destroy(), delete r[U];\n    }\n    this._font = null, this._textureCache = null, o.prototype.destroy.call(this, e);\n  }, t.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  }, t;\n})(Container);\nvar BitmapFontLoader = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.add = function() {\n      LoaderResource.setExtensionXhrType(\"fnt\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n    }, o.use = function(t, e) {\n      var r = autoDetectFormat(t.data);\n      if (!r) {\n        e();\n        return;\n      }\n      for (var D = o.getBaseUrl(this, t), N = r.parse(t.data), k = {}, $ = function(W) {\n        k[W.metadata.pageFile] = W.texture, Object.keys(k).length === N.page.length && (t.bitmapFont = BitmapFont.install(N, k, !0), e());\n      }, G = 0; G < N.page.length; ++G) {\n        var U = N.page[G].file, z = D + U, X = !1;\n        for (var V in this.resources) {\n          var Y = this.resources[V];\n          if (Y.url === z) {\n            Y.metadata.pageFile = U, Y.texture ? $(Y) : Y.onAfterMiddleware.add($), X = !0;\n            break;\n          }\n        }\n        if (!X) {\n          var q = {\n            crossOrigin: t.crossOrigin,\n            loadType: LoaderResource.LOAD_TYPE.IMAGE,\n            metadata: Object.assign({ pageFile: U }, t.metadata.imageMetadata),\n            parentResource: t\n          };\n          this.add(z, q, $);\n        }\n      }\n    }, o.getBaseUrl = function(t, e) {\n      var r = e.isDataUrl ? \"\" : o.dirname(e.url);\n      return e.isDataUrl && (r === \".\" && (r = \"\"), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === \"/\" && (r += \"/\")), r = r.replace(t.baseUrl, \"\"), r && r.charAt(r.length - 1) !== \"/\" && (r += \"/\"), r;\n    }, o.dirname = function(t) {\n      var e = t.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n      return e === t ? \".\" : e === \"\" ? \"/\" : e;\n    }, o.extension = ExtensionType.Loader, o;\n  }()\n);\n/*!\n * @pixi/filter-alpha - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-alpha is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$e = function(o, t) {\n  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$e(o, t);\n};\nfunction __extends$e(o, t) {\n  extendStatics$e(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$4 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n(function(o) {\n  __extends$e(t, o);\n  function t(e) {\n    e === void 0 && (e = 1);\n    var r = o.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;\n    return r.alpha = e, r;\n  }\n  return Object.defineProperty(t.prototype, \"alpha\", {\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-blur - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$d = function(o, t) {\n  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$d(o, t);\n};\nfunction __extends$d(o, t) {\n  extendStatics$d(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(o, t) {\n  var e = Math.ceil(o / 2), r = vertTemplate, D = \"\", N;\n  t ? N = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\" : N = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  for (var k = 0; k < o; k++) {\n    var $ = N.replace(\"%index%\", k.toString());\n    $ = $.replace(\"%sampleIndex%\", k - (e - 1) + \".0\"), D += $, D += `\n`;\n  }\n  return r = r.replace(\"%blur%\", D), r = r.replace(\"%size%\", o.toString()), r;\n}\nvar GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, fragTemplate = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(`\n`);\nfunction generateBlurFragSource(o) {\n  for (var t = GAUSSIAN_VALUES[o], e = t.length, r = fragTemplate, D = \"\", N = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\", k, $ = 0; $ < o; $++) {\n    var G = N.replace(\"%index%\", $.toString());\n    k = $, $ >= e && (k = o - $ - 1), G = G.replace(\"%value%\", t[k].toString()), D += G, D += `\n`;\n  }\n  return r = r.replace(\"%blur%\", D), r = r.replace(\"%size%\", o.toString()), r;\n}\nvar BlurFilterPass = (\n  /** @class */\n  function(o) {\n    __extends$d(t, o);\n    function t(e, r, D, N, k) {\n      r === void 0 && (r = 8), D === void 0 && (D = 4), N === void 0 && (N = settings.FILTER_RESOLUTION), k === void 0 && (k = 5);\n      var $ = this, G = generateBlurVertSource(k, e), U = generateBlurFragSource(k);\n      return $ = o.call(\n        this,\n        // vertex shader\n        G,\n        // fragment shader\n        U\n      ) || this, $.horizontal = e, $.resolution = N, $._quality = 0, $.quality = D, $.blur = r, $;\n    }\n    return t.prototype.apply = function(e, r, D, N) {\n      if (D ? this.horizontal ? this.uniforms.strength = 1 / D.width * (D.width / r.width) : this.uniforms.strength = 1 / D.height * (D.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n        e.applyFilter(this, r, D, N);\n      else {\n        var k = e.getFilterTexture(), $ = e.renderer, G = r, U = k;\n        this.state.blend = !1, e.applyFilter(this, G, U, CLEAR_MODES.CLEAR);\n        for (var z = 1; z < this.passes - 1; z++) {\n          e.bindAndClear(G, CLEAR_MODES.BLIT), this.uniforms.uSampler = U;\n          var X = U;\n          U = G, G = X, $.shader.bind(this), $.geometry.draw(5);\n        }\n        this.state.blend = !0, e.applyFilter(this, U, D, N), e.returnFilterTexture(k);\n      }\n    }, Object.defineProperty(t.prototype, \"blur\", {\n      /**\n       * Sets the strength of both the blur.\n       * @default 16\n       */\n      get: function() {\n        return this.strength;\n      },\n      set: function(e) {\n        this.padding = 1 + Math.abs(e) * 2, this.strength = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"quality\", {\n      /**\n       * Sets the quality of the blur by modifying the number of passes. More passes means higher\n       * quality bluring but the lower the performance.\n       * @default 4\n       */\n      get: function() {\n        return this._quality;\n      },\n      set: function(e) {\n        this._quality = e, this.passes = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Filter)\n);\n(function(o) {\n  __extends$d(t, o);\n  function t(e, r, D, N) {\n    e === void 0 && (e = 8), r === void 0 && (r = 4), D === void 0 && (D = settings.FILTER_RESOLUTION), N === void 0 && (N = 5);\n    var k = o.call(this) || this;\n    return k.blurXFilter = new BlurFilterPass(!0, e, r, D, N), k.blurYFilter = new BlurFilterPass(!1, e, r, D, N), k.resolution = D, k.quality = r, k.blur = e, k.repeatEdgePixels = !1, k;\n  }\n  return t.prototype.apply = function(e, r, D, N) {\n    var k = Math.abs(this.blurXFilter.strength), $ = Math.abs(this.blurYFilter.strength);\n    if (k && $) {\n      var G = e.getFilterTexture();\n      this.blurXFilter.apply(e, r, G, CLEAR_MODES.CLEAR), this.blurYFilter.apply(e, G, D, N), e.returnFilterTexture(G);\n    } else\n      $ ? this.blurYFilter.apply(e, r, D, N) : this.blurXFilter.apply(e, r, D, N);\n  }, t.prototype.updatePadding = function() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     */\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    /**\n     * Sets the number of passes for blur. More passes means higher quality bluring.\n     * @default 1\n     */\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(e) {\n      this.blurXFilter.quality = this.blurYFilter.quality = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurX\", {\n    /**\n     * Sets the strength of the blurX property\n     * @default 2\n     */\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurY\", {\n    /**\n     * Sets the strength of the blurY property\n     * @default 2\n     */\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(e) {\n      this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    /**\n     * Sets the blendmode of the filter\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(e) {\n      this.blurYFilter.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"repeatEdgePixels\", {\n    /**\n     * If set to true the edge of the target will be clamped\n     * @default false\n     */\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(e) {\n      this._repeatEdgePixels = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-color-matrix - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-color-matrix is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$c = function(o, t) {\n  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$c(o, t);\n};\nfunction __extends$c(o, t) {\n  extendStatics$c(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$3 = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`, ColorMatrixFilter = (\n  /** @class */\n  function(o) {\n    __extends$c(t, o);\n    function t() {\n      var e = this, r = {\n        m: new Float32Array([\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0\n        ]),\n        uAlpha: 1\n      };\n      return e = o.call(this, defaultFilterVertex, fragment$3, r) || this, e.alpha = 1, e;\n    }\n    return t.prototype._loadMatrix = function(e, r) {\n      r === void 0 && (r = !1);\n      var D = e;\n      r && (this._multiply(D, this.uniforms.m, e), D = this._colorMatrix(D)), this.uniforms.m = D;\n    }, t.prototype._multiply = function(e, r, D) {\n      return e[0] = r[0] * D[0] + r[1] * D[5] + r[2] * D[10] + r[3] * D[15], e[1] = r[0] * D[1] + r[1] * D[6] + r[2] * D[11] + r[3] * D[16], e[2] = r[0] * D[2] + r[1] * D[7] + r[2] * D[12] + r[3] * D[17], e[3] = r[0] * D[3] + r[1] * D[8] + r[2] * D[13] + r[3] * D[18], e[4] = r[0] * D[4] + r[1] * D[9] + r[2] * D[14] + r[3] * D[19] + r[4], e[5] = r[5] * D[0] + r[6] * D[5] + r[7] * D[10] + r[8] * D[15], e[6] = r[5] * D[1] + r[6] * D[6] + r[7] * D[11] + r[8] * D[16], e[7] = r[5] * D[2] + r[6] * D[7] + r[7] * D[12] + r[8] * D[17], e[8] = r[5] * D[3] + r[6] * D[8] + r[7] * D[13] + r[8] * D[18], e[9] = r[5] * D[4] + r[6] * D[9] + r[7] * D[14] + r[8] * D[19] + r[9], e[10] = r[10] * D[0] + r[11] * D[5] + r[12] * D[10] + r[13] * D[15], e[11] = r[10] * D[1] + r[11] * D[6] + r[12] * D[11] + r[13] * D[16], e[12] = r[10] * D[2] + r[11] * D[7] + r[12] * D[12] + r[13] * D[17], e[13] = r[10] * D[3] + r[11] * D[8] + r[12] * D[13] + r[13] * D[18], e[14] = r[10] * D[4] + r[11] * D[9] + r[12] * D[14] + r[13] * D[19] + r[14], e[15] = r[15] * D[0] + r[16] * D[5] + r[17] * D[10] + r[18] * D[15], e[16] = r[15] * D[1] + r[16] * D[6] + r[17] * D[11] + r[18] * D[16], e[17] = r[15] * D[2] + r[16] * D[7] + r[17] * D[12] + r[18] * D[17], e[18] = r[15] * D[3] + r[16] * D[8] + r[17] * D[13] + r[18] * D[18], e[19] = r[15] * D[4] + r[16] * D[9] + r[17] * D[14] + r[18] * D[19] + r[19], e;\n    }, t.prototype._colorMatrix = function(e) {\n      var r = new Float32Array(e);\n      return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;\n    }, t.prototype.brightness = function(e, r) {\n      var D = [\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(D, r);\n    }, t.prototype.tint = function(e, r) {\n      var D = e >> 16 & 255, N = e >> 8 & 255, k = e & 255, $ = [\n        D / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        N / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        k / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix($, r);\n    }, t.prototype.greyscale = function(e, r) {\n      var D = [\n        e,\n        e,\n        e,\n        0,\n        0,\n        e,\n        e,\n        e,\n        0,\n        0,\n        e,\n        e,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(D, r);\n    }, t.prototype.blackAndWhite = function(e) {\n      var r = [\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.hue = function(e, r) {\n      e = (e || 0) / 180 * Math.PI;\n      var D = Math.cos(e), N = Math.sin(e), k = Math.sqrt, $ = 1 / 3, G = k($), U = D + (1 - D) * $, z = $ * (1 - D) - G * N, X = $ * (1 - D) + G * N, V = $ * (1 - D) + G * N, Y = D + $ * (1 - D), q = $ * (1 - D) - G * N, W = $ * (1 - D) - G * N, K = $ * (1 - D) + G * N, Z = D + $ * (1 - D), J = [\n        U,\n        z,\n        X,\n        0,\n        0,\n        V,\n        Y,\n        q,\n        0,\n        0,\n        W,\n        K,\n        Z,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(J, r);\n    }, t.prototype.contrast = function(e, r) {\n      var D = (e || 0) + 1, N = -0.5 * (D - 1), k = [\n        D,\n        0,\n        0,\n        0,\n        N,\n        0,\n        D,\n        0,\n        0,\n        N,\n        0,\n        0,\n        D,\n        0,\n        N,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(k, r);\n    }, t.prototype.saturate = function(e, r) {\n      e === void 0 && (e = 0);\n      var D = e * 2 / 3 + 1, N = (D - 1) * -0.5, k = [\n        D,\n        N,\n        N,\n        0,\n        0,\n        N,\n        D,\n        N,\n        0,\n        0,\n        N,\n        N,\n        D,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(k, r);\n    }, t.prototype.desaturate = function() {\n      this.saturate(-1);\n    }, t.prototype.negative = function(e) {\n      var r = [\n        -1,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -1,\n        0,\n        1,\n        0,\n        0,\n        0,\n        -1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.sepia = function(e) {\n      var r = [\n        0.393,\n        0.7689999,\n        0.18899999,\n        0,\n        0,\n        0.349,\n        0.6859999,\n        0.16799999,\n        0,\n        0,\n        0.272,\n        0.5339999,\n        0.13099999,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.technicolor = function(e) {\n      var r = [\n        1.9125277891456083,\n        -0.8545344976951645,\n        -0.09155508482755585,\n        0,\n        11.793603434377337,\n        -0.3087833385928097,\n        1.7658908555458428,\n        -0.10601743074722245,\n        0,\n        -70.35205161461398,\n        -0.231103377548616,\n        -0.7501899197440212,\n        1.847597816108189,\n        0,\n        30.950940869491138,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.polaroid = function(e) {\n      var r = [\n        1.438,\n        -0.062,\n        -0.062,\n        0,\n        0,\n        -0.122,\n        1.378,\n        -0.122,\n        0,\n        0,\n        -0.016,\n        -0.016,\n        1.483,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.toBGR = function(e) {\n      var r = [\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.kodachrome = function(e) {\n      var r = [\n        1.1285582396593525,\n        -0.3967382283601348,\n        -0.03992559172921793,\n        0,\n        63.72958762196502,\n        -0.16404339962244616,\n        1.0835251566291304,\n        -0.05498805115633132,\n        0,\n        24.732407896706203,\n        -0.16786010706155763,\n        -0.5603416277695248,\n        1.6014850761964943,\n        0,\n        35.62982807460946,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.browni = function(e) {\n      var r = [\n        0.5997023498159715,\n        0.34553243048391263,\n        -0.2708298674538042,\n        0,\n        47.43192855600873,\n        -0.037703249837783157,\n        0.8609577587992641,\n        0.15059552388459913,\n        0,\n        -36.96841498319127,\n        0.24113635128153335,\n        -0.07441037908422492,\n        0.44972182064877153,\n        0,\n        -7.562075277591283,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.vintage = function(e) {\n      var r = [\n        0.6279345635605994,\n        0.3202183420819367,\n        -0.03965408211312453,\n        0,\n        9.651285835294123,\n        0.02578397704808868,\n        0.6441188644374771,\n        0.03259127616149294,\n        0,\n        7.462829176470591,\n        0.0466055556782719,\n        -0.0851232987247891,\n        0.5241648018700465,\n        0,\n        5.159190588235296,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.colorTone = function(e, r, D, N, k) {\n      e = e || 0.2, r = r || 0.15, D = D || 16770432, N = N || 3375104;\n      var $ = (D >> 16 & 255) / 255, G = (D >> 8 & 255) / 255, U = (D & 255) / 255, z = (N >> 16 & 255) / 255, X = (N >> 8 & 255) / 255, V = (N & 255) / 255, Y = [\n        0.3,\n        0.59,\n        0.11,\n        0,\n        0,\n        $,\n        G,\n        U,\n        e,\n        0,\n        z,\n        X,\n        V,\n        r,\n        0,\n        $ - z,\n        G - X,\n        U - V,\n        0,\n        0\n      ];\n      this._loadMatrix(Y, k);\n    }, t.prototype.night = function(e, r) {\n      e = e || 0.1;\n      var D = [\n        e * -2,\n        -e,\n        0,\n        0,\n        0,\n        -e,\n        0,\n        e,\n        0,\n        0,\n        0,\n        e,\n        e * 2,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(D, r);\n    }, t.prototype.predator = function(e, r) {\n      var D = [\n        // row 1\n        11.224130630493164 * e,\n        -4.794486999511719 * e,\n        -2.8746118545532227 * e,\n        0 * e,\n        0.40342438220977783 * e,\n        // row 2\n        -3.6330697536468506 * e,\n        9.193157196044922 * e,\n        -2.951810836791992 * e,\n        0 * e,\n        -1.316135048866272 * e,\n        // row 3\n        -3.2184197902679443 * e,\n        -4.2375030517578125 * e,\n        7.476448059082031 * e,\n        0 * e,\n        0.8044459223747253 * e,\n        // row 4\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(D, r);\n    }, t.prototype.lsd = function(e) {\n      var r = [\n        2,\n        -0.4,\n        0.5,\n        0,\n        0,\n        -0.5,\n        2,\n        -0.4,\n        0,\n        0,\n        -0.4,\n        -0.5,\n        3,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.reset = function() {\n      var e = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(e, !1);\n    }, Object.defineProperty(t.prototype, \"matrix\", {\n      /**\n       * The matrix of the color matrix filter\n       * @member {number[]}\n       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n       */\n      get: function() {\n        return this.uniforms.m;\n      },\n      set: function(e) {\n        this.uniforms.m = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"alpha\", {\n      /**\n       * The opacity value to use when mixing the original and resultant colors.\n       *\n       * When the value is 0, the original color is used without modification.\n       * When the value is 1, the result color is used.\n       * When in the range (0, 1) the color is interpolated between the original and result by this amount.\n       * @default 1\n       */\n      get: function() {\n        return this.uniforms.uAlpha;\n      },\n      set: function(e) {\n        this.uniforms.uAlpha = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Filter)\n);\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n/*!\n * @pixi/filter-displacement - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$b = function(o, t) {\n  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$b(o, t);\n};\nfunction __extends$b(o, t) {\n  extendStatics$b(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$2 = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`, vertex$1 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n(function(o) {\n  __extends$b(t, o);\n  function t(e, r) {\n    var D = this, N = new Matrix();\n    return e.renderable = !1, D = o.call(this, vertex$1, fragment$2, {\n      mapSampler: e._texture,\n      filterMatrix: N,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this, D.maskSprite = e, D.maskMatrix = N, r == null && (r = 20), D.scale = new Point(r, r), D;\n  }\n  return t.prototype.apply = function(e, r, D, N) {\n    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    var k = this.maskSprite.worldTransform, $ = Math.sqrt(k.a * k.a + k.b * k.b), G = Math.sqrt(k.c * k.c + k.d * k.d);\n    $ !== 0 && G !== 0 && (this.uniforms.rotation[0] = k.a / $, this.uniforms.rotation[1] = k.b / $, this.uniforms.rotation[2] = k.c / G, this.uniforms.rotation[3] = k.d / G), e.applyFilter(this, r, D, N);\n  }, Object.defineProperty(t.prototype, \"map\", {\n    /** The texture used for the displacement map. Must be power of 2 sized texture. */\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(e) {\n      this.uniforms.mapSampler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-fxaa - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-fxaa is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$a = function(o, t) {\n  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$a(o, t);\n};\nfunction __extends$a(o, t) {\n  extendStatics$a(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertex = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`, fragment$1 = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(o) {\n  __extends$a(t, o);\n  function t() {\n    return o.call(this, vertex, fragment$1) || this;\n  }\n  return t;\n})(Filter);\n/*!\n * @pixi/filter-noise - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-noise is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$9 = function(o, t) {\n  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$9(o, t);\n};\nfunction __extends$9(o, t) {\n  extendStatics$9(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n(function(o) {\n  __extends$9(t, o);\n  function t(e, r) {\n    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());\n    var D = o.call(this, defaultFilterVertex, fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    return D.noise = e, D.seed = r, D;\n  }\n  return Object.defineProperty(t.prototype, \"noise\", {\n    /**\n     * The amount of noise to apply, this value should be in the range (0, 1].\n     * @default 0.5\n     */\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(e) {\n      this.uniforms.uNoise = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"seed\", {\n    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(e) {\n      this.uniforms.uSeed = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/mixin-cache-as-bitmap - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;\nvar CacheData = (\n  /** @class */\n  function() {\n    function o() {\n      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n    }\n    return o;\n  }()\n);\nObject.defineProperties(DisplayObject.prototype, {\n  /**\n   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution\n   * but can be overriden for performance. Lower values will reduce memory usage at the expense\n   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n   * @member {number} cacheAsBitmapResolution\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(o) {\n      o !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's\n   * sample count is used.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n   * @member {number} cacheAsBitmapMultisample\n   * @memberof PIXI.DisplayObject#\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(o) {\n      o !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = o, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * Set this to true if you want this display object to be cached as a bitmap.\n   * This basically takes a snap shot of the display object as it is at that moment. It can\n   * provide a performance benefit for complex static displayObjects.\n   * To remove simply set this property to `false`\n   *\n   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(o) {\n      if (this._cacheAsBitmap !== o) {\n        this._cacheAsBitmap = o;\n        var t;\n        o ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));\n};\nDisplayObject.prototype._initCachedDisplayObject = function(t) {\n  var e;\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var r = this.alpha;\n    this.alpha = 1, t.batch.flush();\n    var D = this.getLocalBounds(null, !0).clone();\n    if (this.filters && this.filters.length) {\n      var N = this.filters[0].padding;\n      D.pad(N);\n    }\n    D.ceil(settings.RESOLUTION);\n    var k = t.renderTexture.current, $ = t.renderTexture.sourceFrame.clone(), G = t.renderTexture.destinationFrame.clone(), U = t.projection.transform, z = RenderTexture.create({\n      width: D.width,\n      height: D.height,\n      resolution: this.cacheAsBitmapResolution || t.resolution,\n      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample\n    }), X = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = X, BaseTexture.addToCache(z.baseTexture, X), Texture.addToCache(z, X);\n    var V = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-D.x, -D.y);\n    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: z, clear: !0, transform: V, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = U, t.renderTexture.bind(k, $, G), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var Y = new Sprite(z);\n    Y.transform.worldTransform = this.transform.worldTransform, Y.anchor.x = -(D.x / D.width), Y.anchor.y = -(D.y / D.height), Y.alpha = r, Y._bounds = this._bounds, this._cacheData.sprite = Y, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = Y.containsPoint.bind(Y);\n  }\n};\nDisplayObject.prototype._renderCachedCanvas = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var e = this.getLocalBounds(null, !0), r = this.alpha;\n    this.alpha = 1;\n    var D = t.context, N = t._projTransform;\n    e.ceil(settings.RESOLUTION);\n    var k = RenderTexture.create({ width: e.width, height: e.height }), $ = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = $, BaseTexture.addToCache(k.baseTexture, $), Texture.addToCache(k, $);\n    var G = _tempMatrix;\n    this.transform.localTransform.copyTo(G), G.invert(), G.tx -= e.x, G.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: k, clear: !0, transform: G, skipUpdateTransform: !1 }), t.context = D, t._projTransform = N, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var U = new Sprite(k);\n    U.transform.worldTransform = this.transform.worldTransform, U.anchor.x = -(e.x / e.width), U.anchor.y = -(e.y / e.height), U.alpha = r, U._bounds = this._bounds, this._cacheData.sprite = U, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = U.containsPoint.bind(U);\n  }\n};\nDisplayObject.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function(t) {\n  this.cacheAsBitmap = !1, this.destroy(t);\n};\n/*!\n * @pixi/mixin-get-child-by-name - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-get-child-by-name is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.name = null;\nContainer.prototype.getChildByName = function(t, e) {\n  for (var r = 0, D = this.children.length; r < D; r++)\n    if (this.children[r].name === t)\n      return this.children[r];\n  if (e)\n    for (var r = 0, D = this.children.length; r < D; r++) {\n      var N = this.children[r];\n      if (N.getChildByName) {\n        var k = N.getChildByName(t, !0);\n        if (k)\n          return k;\n      }\n    }\n  return null;\n};\n/*!\n * @pixi/mixin-get-global-position - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-get-global-position is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.getGlobalPosition = function(t, e) {\n  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;\n};\n/*!\n * @pixi/app - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/app is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ResizePlugin = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.init = function(t) {\n      var e = this;\n      Object.defineProperty(\n        this,\n        \"resizeTo\",\n        /**\n         * The HTML element or window to automatically resize the\n         * renderer's view element to match width and height.\n         * @member {Window|HTMLElement}\n         * @name resizeTo\n         * @memberof PIXI.Application#\n         */\n        {\n          set: function(r) {\n            globalThis.removeEventListener(\"resize\", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener(\"resize\", this.queueResize), this.resize());\n          },\n          get: function() {\n            return this._resizeTo;\n          }\n        }\n      ), this.queueResize = function() {\n        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {\n          return e.resize();\n        }));\n      }, this.cancelResize = function() {\n        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);\n      }, this.resize = function() {\n        if (e._resizeTo) {\n          e.cancelResize();\n          var r, D;\n          if (e._resizeTo === globalThis.window)\n            r = globalThis.innerWidth, D = globalThis.innerHeight;\n          else {\n            var N = e._resizeTo, k = N.clientWidth, $ = N.clientHeight;\n            r = k, D = $;\n          }\n          e.renderer.resize(r, D);\n        }\n      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;\n    }, o.destroy = function() {\n      globalThis.removeEventListener(\"resize\", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n    }, o.extension = ExtensionType.Application, o;\n  }()\n), Application = (\n  /** @class */\n  function() {\n    function o(t) {\n      var e = this;\n      this.stage = new Container(), t = Object.assign({\n        forceCanvas: !1\n      }, t), this.renderer = autoDetectRenderer(t), o._plugins.forEach(function(r) {\n        r.init.call(e, t);\n      });\n    }\n    return o.registerPlugin = function(t) {\n      deprecation(\"6.5.0\", \"Application.registerPlugin() is deprecated, use extensions.add()\"), extensions.add({\n        type: ExtensionType.Application,\n        ref: t\n      });\n    }, o.prototype.render = function() {\n      this.renderer.render(this.stage);\n    }, Object.defineProperty(o.prototype, \"view\", {\n      /**\n       * Reference to the renderer's canvas element.\n       * @member {HTMLCanvasElement}\n       * @readonly\n       */\n      get: function() {\n        return this.renderer.view;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(o.prototype, \"screen\", {\n      /**\n       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n       * @member {PIXI.Rectangle}\n       * @readonly\n       */\n      get: function() {\n        return this.renderer.screen;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), o.prototype.destroy = function(t, e) {\n      var r = this, D = o._plugins.slice(0);\n      D.reverse(), D.forEach(function(N) {\n        N.destroy.call(r);\n      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;\n    }, o._plugins = [], o;\n  }()\n);\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ResizePlugin);\n/*!\n * @pixi/mesh-extras - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$8 = function(o, t) {\n  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$8(o, t);\n};\nfunction __extends$8(o, t) {\n  extendStatics$8(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar PlaneGeometry = (\n  /** @class */\n  function(o) {\n    __extends$8(t, o);\n    function t(e, r, D, N) {\n      e === void 0 && (e = 100), r === void 0 && (r = 100), D === void 0 && (D = 10), N === void 0 && (N = 10);\n      var k = o.call(this) || this;\n      return k.segWidth = D, k.segHeight = N, k.width = e, k.height = r, k.build(), k;\n    }\n    return t.prototype.build = function() {\n      for (var e = this.segWidth * this.segHeight, r = [], D = [], N = [], k = this.segWidth - 1, $ = this.segHeight - 1, G = this.width / k, U = this.height / $, z = 0; z < e; z++) {\n        var X = z % this.segWidth, V = z / this.segWidth | 0;\n        r.push(X * G, V * U), D.push(X / k, V / $);\n      }\n      for (var Y = k * $, z = 0; z < Y; z++) {\n        var q = z % k, W = z / k | 0, K = W * this.segWidth + q, Z = W * this.segWidth + q + 1, J = (W + 1) * this.segWidth + q, Q = (W + 1) * this.segWidth + q + 1;\n        N.push(K, Z, J, Z, Q, J);\n      }\n      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(D), this.indexBuffer.data = new Uint16Array(N), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n    }, t;\n  }(MeshGeometry)\n), RopeGeometry = (\n  /** @class */\n  function(o) {\n    __extends$8(t, o);\n    function t(e, r, D) {\n      e === void 0 && (e = 200), D === void 0 && (D = 0);\n      var N = o.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;\n      return N.points = r, N._width = e, N.textureScale = D, N.build(), N;\n    }\n    return Object.defineProperty(t.prototype, \"width\", {\n      /**\n       * The width (i.e., thickness) of the rope.\n       * @readonly\n       */\n      get: function() {\n        return this._width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.build = function() {\n      var e = this.points;\n      if (e) {\n        var r = this.getBuffer(\"aVertexPosition\"), D = this.getBuffer(\"aTextureCoord\"), N = this.getIndex();\n        if (!(e.length < 1)) {\n          r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), D.data = new Float32Array(e.length * 4), N.data = new Uint16Array((e.length - 1) * 6));\n          var k = D.data, $ = N.data;\n          k[0] = 0, k[1] = 0, k[2] = 0, k[3] = 1;\n          for (var G = 0, U = e[0], z = this._width * this.textureScale, X = e.length, V = 0; V < X; V++) {\n            var Y = V * 4;\n            if (this.textureScale > 0) {\n              var q = U.x - e[V].x, W = U.y - e[V].y, K = Math.sqrt(q * q + W * W);\n              U = e[V], G += K / z;\n            } else\n              G = V / (X - 1);\n            k[Y] = G, k[Y + 1] = 0, k[Y + 2] = G, k[Y + 3] = 1;\n          }\n          for (var Z = 0, V = 0; V < X - 1; V++) {\n            var Y = V * 2;\n            $[Z++] = Y, $[Z++] = Y + 1, $[Z++] = Y + 2, $[Z++] = Y + 2, $[Z++] = Y + 1, $[Z++] = Y + 3;\n          }\n          D.update(), N.update(), this.updateVertices();\n        }\n      }\n    }, t.prototype.updateVertices = function() {\n      var e = this.points;\n      if (!(e.length < 1)) {\n        for (var r = e[0], D, N = 0, k = 0, $ = this.buffers[0].data, G = e.length, U = 0; U < G; U++) {\n          var z = e[U], X = U * 4;\n          U < e.length - 1 ? D = e[U + 1] : D = z, k = -(D.x - r.x), N = D.y - r.y;\n          var V = Math.sqrt(N * N + k * k), Y = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n          N /= V, k /= V, N *= Y, k *= Y, $[X] = z.x + N, $[X + 1] = z.y + k, $[X + 2] = z.x - N, $[X + 3] = z.y - k, r = z;\n        }\n        this.buffers[0].update();\n      }\n    }, t.prototype.update = function() {\n      this.textureScale > 0 ? this.build() : this.updateVertices();\n    }, t;\n  }(MeshGeometry)\n);\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, D) {\n    D === void 0 && (D = 0);\n    var N = this, k = new RopeGeometry(e.height, r, D), $ = new MeshMaterial(e);\n    return D > 0 && (e.baseTexture.wrapMode = WRAP_MODES.REPEAT), N = o.call(this, k, $) || this, N.autoUpdate = !0, N;\n  }\n  return t.prototype._render = function(e) {\n    var r = this.geometry;\n    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), o.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar SimplePlane = (\n  /** @class */\n  function(o) {\n    __extends$8(t, o);\n    function t(e, r, D) {\n      var N = this, k = new PlaneGeometry(e.width, e.height, r, D), $ = new MeshMaterial(Texture.WHITE);\n      return N = o.call(this, k, $) || this, N.texture = e, N.autoResize = !0, N;\n    }\n    return t.prototype.textureUpdated = function() {\n      this._textureID = this.shader.texture._updateID;\n      var e = this.geometry, r = this.shader.texture, D = r.width, N = r.height;\n      this.autoResize && (e.width !== D || e.height !== N) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());\n    }, Object.defineProperty(t.prototype, \"texture\", {\n      get: function() {\n        return this.shader.texture;\n      },\n      set: function(e) {\n        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once(\"update\", this.textureUpdated, this));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._render = function(e) {\n      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), o.prototype._render.call(this, e);\n    }, t.prototype.destroy = function(e) {\n      this.shader.texture.off(\"update\", this.textureUpdated, this), o.prototype.destroy.call(this, e);\n    }, t;\n  }(Mesh)\n);\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, D, N, k) {\n    e === void 0 && (e = Texture.EMPTY);\n    var $ = this, G = new MeshGeometry(r, D, N);\n    G.getBuffer(\"aVertexPosition\").static = !1;\n    var U = new MeshMaterial(e);\n    return $ = o.call(this, G, U, null, k) || this, $.autoUpdate = !0, $;\n  }\n  return Object.defineProperty(t.prototype, \"vertices\", {\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this.autoUpdate && this.geometry.getBuffer(\"aVertexPosition\").update(), o.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n(function(o) {\n  __extends$8(t, o);\n  function t(e, r, D, N, k) {\n    r === void 0 && (r = DEFAULT_BORDER_SIZE), D === void 0 && (D = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE), k === void 0 && (k = DEFAULT_BORDER_SIZE);\n    var $ = o.call(this, Texture.WHITE, 4, 4) || this;\n    return $._origWidth = e.orig.width, $._origHeight = e.orig.height, $._width = $._origWidth, $._height = $._origHeight, $._leftWidth = r, $._rightWidth = N, $._topHeight = D, $._bottomHeight = k, $.texture = e, $;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }, Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.updateHorizontalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;\n  }, t.prototype.updateVerticalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;\n  }, t.prototype._getMinScale = function() {\n    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, D = this._topHeight + this._bottomHeight, N = this._height > D ? 1 : this._height / D, k = Math.min(r, N);\n    return k;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"leftWidth\", {\n    /** The width of the left column. */\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(e) {\n      this._leftWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rightWidth\", {\n    /** The width of the right column. */\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(e) {\n      this._rightWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"topHeight\", {\n    /** The height of the top row. */\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(e) {\n      this._topHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"bottomHeight\", {\n    /** The height of the bottom row. */\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(e) {\n      this._bottomHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._refresh = function() {\n    var e = this.texture, r = this.geometry.buffers[1].data;\n    this._origWidth = e.orig.width, this._origHeight = e.orig.height;\n    var D = 1 / this._origWidth, N = 1 / this._origHeight;\n    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = D * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - D * this._rightWidth, r[9] = r[11] = r[13] = r[15] = N * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - N * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }, t;\n})(SimplePlane);\n/*!\n * @pixi/sprite-animated - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$7 = function(o, t) {\n  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$7(o, t);\n};\nfunction __extends$7(o, t) {\n  extendStatics$7(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar AnimatedSprite = (\n  /** @class */\n  function(o) {\n    __extends$7(t, o);\n    function t(e, r) {\n      r === void 0 && (r = !0);\n      var D = o.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;\n      return D._textures = null, D._durations = null, D._autoUpdate = r, D._isConnectedToTicker = !1, D.animationSpeed = 1, D.loop = !0, D.updateAnchor = !1, D.onComplete = null, D.onFrameChange = null, D.onLoop = null, D._currentTime = 0, D._playing = !1, D._previousFrame = null, D.textures = e, D;\n    }\n    return t.prototype.stop = function() {\n      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n    }, t.prototype.play = function() {\n      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));\n    }, t.prototype.gotoAndStop = function(e) {\n      this.stop();\n      var r = this.currentFrame;\n      this._currentTime = e, r !== this.currentFrame && this.updateTexture();\n    }, t.prototype.gotoAndPlay = function(e) {\n      var r = this.currentFrame;\n      this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();\n    }, t.prototype.update = function(e) {\n      if (this._playing) {\n        var r = this.animationSpeed * e, D = this.currentFrame;\n        if (this._durations !== null) {\n          var N = this._currentTime % 1 * this._durations[this.currentFrame];\n          for (N += r / 60 * 1e3; N < 0; )\n            this._currentTime--, N += this._durations[this.currentFrame];\n          var k = Math.sign(this.animationSpeed * e);\n          for (this._currentTime = Math.floor(this._currentTime); N >= this._durations[this.currentFrame]; )\n            N -= this._durations[this.currentFrame] * k, this._currentTime += k;\n          this._currentTime += N / this._durations[this.currentFrame];\n        } else\n          this._currentTime += r;\n        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : D !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < D ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > D && this.onLoop()), this.updateTexture());\n      }\n    }, t.prototype.updateTexture = function() {\n      var e = this.currentFrame;\n      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n    }, t.prototype.destroy = function(e) {\n      this.stop(), o.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n    }, t.fromFrames = function(e) {\n      for (var r = [], D = 0; D < e.length; ++D)\n        r.push(Texture.from(e[D]));\n      return new t(r);\n    }, t.fromImages = function(e) {\n      for (var r = [], D = 0; D < e.length; ++D)\n        r.push(Texture.from(e[D]));\n      return new t(r);\n    }, Object.defineProperty(t.prototype, \"totalFrames\", {\n      /**\n       * The total number of frames in the AnimatedSprite. This is the same as number of textures\n       * assigned to the AnimatedSprite.\n       * @readonly\n       * @default 0\n       */\n      get: function() {\n        return this._textures.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"textures\", {\n      /** The array of textures used for this AnimatedSprite. */\n      get: function() {\n        return this._textures;\n      },\n      set: function(e) {\n        if (e[0] instanceof Texture)\n          this._textures = e, this._durations = null;\n        else {\n          this._textures = [], this._durations = [];\n          for (var r = 0; r < e.length; r++)\n            this._textures.push(e[r].texture), this._durations.push(e[r].time);\n        }\n        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"currentFrame\", {\n      /**\n       * The AnimatedSprites current frame index.\n       * @readonly\n       */\n      get: function() {\n        var e = Math.floor(this._currentTime) % this._textures.length;\n        return e < 0 && (e += this._textures.length), e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"playing\", {\n      /**\n       * Indicates if the AnimatedSprite is currently playing.\n       * @readonly\n       */\n      get: function() {\n        return this._playing;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"autoUpdate\", {\n      /** Whether to use PIXI.Ticker.shared to auto update animation time. */\n      get: function() {\n        return this._autoUpdate;\n      },\n      set: function(e) {\n        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Sprite)\n);\n/*!\n * pixi.js - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nextensions.add(\n  // Install renderer plugins\n  AccessibilityManager,\n  Extract,\n  InteractionManager,\n  ParticleRenderer,\n  Prepare,\n  BatchRenderer,\n  TilingSpriteRenderer,\n  // Install loader plugins\n  BitmapFontLoader,\n  CompressedTextureLoader,\n  DDSLoader,\n  KTXLoader,\n  SpritesheetLoader,\n  // Install application plugins\n  TickerPlugin,\n  AppLoaderPlugin\n);\nvar Ai;\nclass EventListenerCtn {\n  constructor() {\n    // リソースリーク対策\n    rt(this, Ai, []);\n  }\n  add(t, e, r, D = {}) {\n    if (t instanceof BaseTexture) {\n      switch (e) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          t.on(e, r, D), H(this, Ai).push(() => t.off(e, r, D));\n          break;\n      }\n      return;\n    }\n    if (t instanceof eventemitter3Exports) {\n      t.on(e, r, D), H(this, Ai).push(() => t.off(e, r, D));\n      return;\n    }\n    t.addEventListener(e, r, D), H(this, Ai).push(() => t.removeEventListener(e, r, { capture: D.capture ?? !1 }));\n  }\n  clear() {\n    for (const t of H(this, Ai))\n      t();\n    ot(this, Ai, []);\n  }\n}\nAi = new WeakMap();\nvar SEARCH_PATH_ARG_EXT = /* @__PURE__ */ ((o) => (o.DEFAULT = \"\", o.SP_GSM = \"png|jpg|jpeg|json|svg|webp|mp4|webm\", o.SCRIPT = \"sn|ssn\", o.FONT = \"woff2|woff|otf|ttf\", o.SOUND = \"mp3|m4a|ogg|aac|flac|wav\", o.HTML = \"htm|html\", o.CSS = \"css\", o.SN = \"sn\", o.PSD = \"psd\", o.TST_PNGPNG_ = \"png|png_\", o.TST_HH = \"hh\", o.TST_EEE = \"eee\", o.TST_GGG = \"ggg\", o.TST_PNGXML = \"png|xml\", o))(SEARCH_PATH_ARG_EXT || {}), eo, ro, Su;\nclass ConfigBase {\n  constructor(t) {\n    Ot(this, \"oCfg\", {\n      save_ns: \"\",\n      // 扱うセーブデータを一意に識別するキーワード文字列\n      window: {\n        // アプリケーションウインドウサイズ\n        width: 300,\n        height: 300\n      },\n      book: {\n        // プロジェクトの詳細情報です\n        title: \"\",\n        //作品タイトル\n        creator: \"\",\n        //著作者。同人ならペンネーム\n        cre_url: \"\",\n        //著作者URL。ツイッターやメール、サイトなど\n        publisher: \"\",\n        //出版社。同人ならサークル名\n        pub_url: \"\",\n        //出版社URL。無ければ省略します\n        detail: \"\",\n        // 内容紹介。端的に記入\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      // プレイヤーが読んだ文章を読み返せる履歴の長さ\n      init: {\n        bg_color: \"#000000\",\n        // 背景色\n        tagch_msecwait: 10,\n        // 通常文字表示待ち時間（未読／既読）\n        auto_msecpagewait: 3500,\n        // 自動文字表示、行クリック待ち時間（未読／既読）\n        escape: \"\"\n        // エスケープ文字\n      },\n      debug: {\n        devtool: !1,\n        token: !1,\n        tag: !1,\n        putCh: !1,\n        debugLog: !1,\n        baseTx: !1,\n        masume: !1,\n        // テキストレイヤ：ガイドマス目を表示するか\n        variable: !1\n      },\n      code: {},\n      // 暗号化しないフォルダ\n      debuger_token: \"\"\n      // デバッガとの接続トークン\n    });\n    Ot(this, \"userFnTail\", \"\");\n    // 4tst public\n    Ot(this, \"hPathFn2Exts\", {});\n    rt(this, eo, !1);\n    rt(this, ro, !1);\n    rt(this, Su, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n    this.sys = t;\n  }\n  async load(t) {\n    var e, r, D, N;\n    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((N = (D = t.log) == null ? void 0 : D.max_len) == null ? void 0 : N.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), ot(this, eo, this.matchPath(\n      \"^breakline$\",\n      \"png|jpg|jpeg|json|svg|webp|mp4|webm\"\n      /* SP_GSM */\n    ).length > 0), ot(this, ro, this.matchPath(\n      \"^breakpage$\",\n      \"png|jpg|jpeg|json|svg|webp|mp4|webm\"\n      /* SP_GSM */\n    ).length > 0), !!this.sys.crypto)\n      for (const k of Object.values(this.hPathFn2Exts))\n        for (const [$, G] of Object.entries(k)) {\n          if ($.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const U = G.slice(G.lastIndexOf(\"/\") + 1), z = k[$.slice(0, -10)], V = await (await this.sys.fetch(z)).text(), Y = this.sys.hash(V);\n          if (U !== Y)\n            throw `ファイル改竄エラーです fn:${z}`;\n        }\n  }\n  get existsBreakline() {\n    return H(this, eo);\n  }\n  get existsBreakpage() {\n    return H(this, ro);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1\n  searchPath(t, e = \"\") {\n    if (!t)\n      throw \"[searchPath] fnが空です\";\n    if (t.slice(0, 7) === \"http://\")\n      return t;\n    const r = t.match(H(this, Su));\n    let D = r ? r[1] : t;\n    const N = r ? r[2] : \"\";\n    if (this.userFnTail) {\n      const G = D + \"@@\" + this.userFnTail;\n      if (G in this.hPathFn2Exts) {\n        if (e === \"\")\n          D = G;\n        else\n          for (const U of Object.keys(this.hPathFn2Exts[G]))\n            if (`|${e}|`.indexOf(`|${U}|`) !== -1) {\n              D = G;\n              break;\n            }\n      }\n    }\n    const k = this.hPathFn2Exts[D];\n    if (!k)\n      throw `サーチパスに存在しないファイル【${t}】です`;\n    let $ = \"\";\n    if (!N) {\n      const G = int(k[\":cnt\"]);\n      if (e === \"\") {\n        if (G > 1)\n          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n        return t;\n      }\n      const U = `|${e}|`;\n      if (G > 1) {\n        let z = 0;\n        for (const X of Object.keys(k))\n          if (U.indexOf(`|${X}|`) !== -1 && ++z > 1)\n            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n      }\n      for (let z of Object.keys(k))\n        if (U.indexOf(`|${z}|`) > -1)\n          return k[z];\n      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;\n    }\n    if (e !== \"\" && `|${e}|`.indexOf(`|${N}|`) === -1)\n      throw `指定ファイルの拡張子【${N}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;\n    if ($ = k[N], !$)\n      throw `サーチパスに存在しない拡張子【${N}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;\n    return $;\n  }\n  matchPath(t, e = \"\") {\n    const r = [], D = new RegExp(t), N = new RegExp(e);\n    for (const [k, $] of Object.entries(this.hPathFn2Exts)) {\n      if (k.search(D) === -1)\n        continue;\n      if (e === \"\") {\n        r.push($);\n        continue;\n      }\n      const G = {};\n      let U = !1;\n      for (const z of Object.keys($))\n        z.search(N) !== -1 && (G[z] = k, U = !0);\n      U && r.push(G);\n    }\n    return r;\n  }\n  addPath(t, e) {\n    const r = {};\n    for (const [D, N] of Object.entries(e))\n      r[D] = (D.at(0) === \":\" ? \"\" : this.sys.cur) + N;\n    this.hPathFn2Exts[t] = r;\n  }\n}\neo = new WeakMap(), ro = new WeakMap(), Su = new WeakMap();\nclass Config extends ConfigBase {\n  constructor(t) {\n    super(t), this.sys = t;\n  }\n  static async generate(t) {\n    const e = new Config(t), r = t.cur + \"prj.json\", D = await (await t.fetch(r)).text(), N = JSON.parse(t.decStr(r, D));\n    return await e.load(N), e;\n  }\n  async load(t) {\n    await super.load(t), CmnLib.stageW = this.oCfg.window.width, CmnLib.stageH = this.oCfg.window.height, CmnLib.debugLog = this.oCfg.debug.debugLog;\n  }\n  searchPath(t, e = SEARCH_PATH_ARG_EXT.DEFAULT) {\n    return t.slice(0, 11) === \"downloads:/\" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === \"userdata:/\" ? this.sys.path_userdata + \"storage/\" + t.slice(10) : super.searchPath(t, e);\n  }\n}\nconst REG_TAG = /(?<name>[^\\s;\\]]+)/;\nfunction tagToken2Name_Args(o) {\n  const t = REG_TAG.exec(o.slice(1, -1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${o}】異常です(タグ解析)`;\n  const r = e.name;\n  return [r, o.slice(1 + r.length, -1)];\n}\nfunction tagToken2Name(o) {\n  const t = REG_TAG.exec(o.slice(1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${o}】異常です(タグ解析)`;\n  return e.name;\n}\nfunction splitAmpersand(o) {\n  const t = o.replaceAll(\"==\", \"＝\").replaceAll(\"!=\", \"≠\").split(\"=\"), e = t.length;\n  if (e < 2 || e > 3)\n    throw \"「&計算」書式では「=」指定が一つか二つ必要です\";\n  if (t[1].at(0) === \"&\")\n    throw \"「&計算」書式では「&」指定が不要です\";\n  return {\n    name: t[0].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    text: t[1].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    cast: e === 3 ? t[2].trim() : void 0\n  };\n}\nvar hn, cn, io, no, so, Ye, ao, Rs, iu;\nclass Grammar {\n  constructor() {\n    rt(this, Rs);\n    rt(this, hn, void 0);\n    rt(this, cn, void 0);\n    rt(this, io, new RegExp(\"\"));\n    rt(this, no, \"\");\n    rt(this, so, \"\");\n    rt(this, Ye, void 0);\n    rt(this, ao, void 0);\n    this.setEscape(\"\");\n  }\n  setEscape(t) {\n    if (H(this, Ye) && t in H(this, Ye))\n      throw \"[エスケープ文字] char【\" + t + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    ot(this, hn, new RegExp(\n      (t ? `\\\\${t}\\\\S|` : \"\") + // エスケープシーケンス\n      `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:(?=([^\"'#;\\\\]]+))\\\\1|([\"'#]).*?\\\\2|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^&;\\\\n\\\\t]+|^\\\\*[^\\\\s\\\\[&;\\\\\\\\]+|[^\\\\n\\\\t\\\\[;${t ? `\\\\${t}` : \"\"}]+`,\n      // 本文\n      \"gs\"\n    )), ot(this, cn, new RegExp(`[\\\\w\\\\s;[\\\\]*=&｜《》${t ? `\\\\${t}` : \"\"}]`)), ot(this, ao, new RegExp(`[\\\\n\\\\t;\\\\[*&${t ? `\\\\${t}` : \"\"}]`));\n  }\n  // 括弧マクロの定義\n  bracket2macro(t, e, r, D) {\n    const { name: N, text: k } = t;\n    if (!N)\n      throw \"[bracket2macro] nameは必須です\";\n    if (!k)\n      throw \"[bracket2macro] textは必須です\";\n    const $ = k.at(0);\n    if (!$)\n      throw \"[bracket2macro] textは必須です\";\n    if (k.length !== 2)\n      throw \"[bracket2macro] textは括弧の前後を示す二文字を指定してください\";\n    if (!(N in e))\n      throw `[bracket2macro] 未定義のタグ又はマクロ[${N}]です`;\n    H(this, Ye) ?? ot(this, Ye, {});\n    const G = k.charAt(1);\n    if ($ in H(this, Ye))\n      throw \"[bracket2macro] text【\" + $ + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (G in H(this, Ye))\n      throw \"[bracket2macro] text【\" + G + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (H(this, cn).test($))\n      throw \"[bracket2macro] text【\" + $ + \"】は括弧マクロに使用できない文字です\";\n    if (H(this, cn).test(G))\n      throw \"[bracket2macro] text【\" + G + \"】は括弧マクロに使用できない文字です\";\n    H(this, Ye)[G] = \"0\", H(this, Ye)[$] = `[${N} text=`, this.addC2M(`\\\\${$}[^\\\\${G}]*\\\\${G}`, `\\\\${$}\\\\${G}`), lt(this, Rs, iu).call(this, r, D);\n  }\n  // 一文字マクロの定義\n  char2macro(t, e, r, D) {\n    const { char: N, name: k } = t;\n    if (!N)\n      throw \"[char2macro] charは必須です\";\n    if (H(this, Ye) ?? ot(this, Ye, {}), N in H(this, Ye))\n      throw \"[char2macro] char【\" + N + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (H(this, cn).test(N))\n      throw \"[char2macro] char【\" + N + \"】は一文字マクロに使用できない文字です\";\n    if (!k)\n      throw \"[char2macro] nameは必須です\";\n    if (!(k in e))\n      throw `[char2macro] 未定義のタグ又はマクロ[${k}]です`;\n    H(this, Ye)[N] = `[${k}]`, this.addC2M(`\\\\${N}`, `\\\\${N}`), lt(this, Rs, iu).call(this, r, D);\n  }\n  addC2M(t, e) {\n    ot(this, no, H(this, no) + `${t}|`), ot(this, so, H(this, so) + `${e}`), ot(this, io, new RegExp(\n      `(${H(this, no)}[^${H(this, so)}]+)`,\n      \"g\"\n    ));\n  }\n  resolveScript(t) {\n    var D;\n    const e = ((D = t.replaceAll(/(\\r\\n|\\r)/g, `\n`).match(H(this, hn))) == null ? void 0 : D.flatMap((N) => {\n      if (!this.testTagLetml(N))\n        return N;\n      const k = /^([^\\]]+?])(.*)$/s.exec(N);\n      if (!k)\n        return N;\n      const [, $, G] = k;\n      return [$, G];\n    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };\n    return lt(this, Rs, iu).call(this, r), r;\n  }\n  testTagLetml(t) {\n    return /^\\[let_ml\\s/.test(t);\n  }\n  testTagEndLetml(t) {\n    return /^\\[endlet_ml\\s*]/.test(t);\n  }\n  analyzToken(t) {\n    return H(this, hn).lastIndex = 0, H(this, hn).exec(t);\n  }\n  testNoTxt(t) {\n    return H(this, ao).test(t);\n  }\n  //4tst\n}\nhn = new WeakMap(), cn = new WeakMap(), io = new WeakMap(), no = new WeakMap(), so = new WeakMap(), Ye = new WeakMap(), ao = new WeakMap(), Rs = new WeakSet(), iu = function(t, e = 0) {\n  if (H(this, Ye)) {\n    for (let r = t.len - 1; r >= e; --r) {\n      const D = t.aToken[r];\n      if (this.testNoTxt(D.at(0) ?? `\n`))\n        continue;\n      const N = t.aLNum[r], k = D.match(H(this, io));\n      if (!k)\n        continue;\n      let $ = 1;\n      for (let G = k.length - 1; G >= 0; --G) {\n        let U = k[G];\n        const z = H(this, Ye)[U.at(0) ?? \" \"];\n        z && (U = z + (z.slice(-1) === \"]\" ? \"\" : `'${U.slice(1, -1)}']`)), t.aToken.splice(r, $, U), t.aLNum.splice(r, $, N), $ = 0;\n      }\n    }\n    t.len = t.aToken.length;\n  }\n};\nvar oo, Os, nu, fn, Is;\nclass AnalyzeTagArg {\n  constructor() {\n    rt(this, Os);\n    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1\n    /*\n    ;[^\\n]*\n    |\t(?<key>[^\\s=\"'#|;]+)\n    \t(?: \\s | ;[^\\n]*\\n)*\n    \t=\n    \t(?: \\s | ;[^\\n]*\\n)*\n    \t(?:\t(?<val> [^\\s\"'#|;]+)\n    \t|\t([\"'#]) (?<val2>.*?) \\3 )\n    \t(?: \\|\n    \t\t(?: (?<def> [^\\s\"'#;]+)\n    \t|\t([\"'#]) (?<def2>.*?) \\6 ) )?\n    |\t(?<literal>[^\\s;]+)\n    \t*/\n    rt(this, oo, /;[^\\n]*|(?<key>[^\\s=\"'#|;]+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    rt(this, fn, {});\n    rt(this, Is, !1);\n  }\n  // 【属性 = 値 | 省略値】の分析\n  parse(t) {\n    ot(this, fn, {}), ot(this, Is, !1);\n    for (const { groups: e } of t.matchAll(H(this, oo))) {\n      const { key: r, val: D, val2: N, def: k, def2: $, literal: G } = e;\n      r ? H(this, fn)[r] = {\n        val: D ?? N,\n        def: k ?? $\n      } : G && (G === \"*\" ? ot(this, Is, !0) : H(this, fn)[G] = { val: \"1\" });\n    }\n  }\n  // 属性と値の位置をまとめて返す\n  parseinDetail(t, e, r, D) {\n    const N = {}, k = t.slice(1 + e, -1);\n    for (const { groups: $, index: G, 0: U } of k.matchAll(H(this, oo))) {\n      if (G === void 0)\n        continue;\n      const { key: z, val: X, val2: V, literal: Y } = $;\n      if (Y) {\n        if (Y.slice(-1) === \"=\") {\n          const J = Y.length - 1, { ch: Q } = lt(this, Os, nu).call(this, e, r, D, k, G + J);\n          N[Y.slice(0, -1)] = {\n            k_ln: r,\n            k_ch: Q - J,\n            v_ln: r,\n            v_ch: Q + 1,\n            //\tv_ch: ch +1+lenNm +literal.length +1,\n            v_len: 0\n          };\n        }\n        continue;\n      }\n      if (!z)\n        continue;\n      const { ln: q, ch: W } = lt(this, Os, nu).call(this, e, r, D, k, G), { ln: K, ch: Z } = lt(this, Os, nu).call(this, e, r, D, k, G + U.lastIndexOf(X ?? V) - (X ? 0 : 1));\n      N[z] = { k_ln: q, k_ch: W, v_ln: K, v_ch: Z, v_len: X ? X.length : V.length + 2 };\n    }\n    return N;\n  }\n  get hPrm() {\n    return H(this, fn);\n  }\n  get isKomeParam() {\n    return H(this, Is);\n  }\n}\noo = new WeakMap(), Os = new WeakSet(), nu = function(t, e, r, D, N) {\n  const $ = D.slice(0, N).split(`\n`), G = $.length;\n  return {\n    ln: e + G - 1,\n    ch: G < 2 ? r + 1 + t + N : $.at(-1).length\n  };\n}, fn = new WeakMap(), Is = new WeakMap();\nvar parsimmon_umd_minExports = {}, parsimmon_umd_min = {\n  get exports() {\n    return parsimmon_umd_minExports;\n  },\n  set exports(o) {\n    parsimmon_umd_minExports = o;\n  }\n};\n(function(o, t) {\n  (function(e, r) {\n    o.exports = r();\n  })(typeof self < \"u\" ? self : commonjsGlobal, function() {\n    return function(e) {\n      var r = {};\n      function D(N) {\n        if (r[N])\n          return r[N].exports;\n        var k = r[N] = { i: N, l: !1, exports: {} };\n        return e[N].call(k.exports, k, k.exports, D), k.l = !0, k.exports;\n      }\n      return D.m = e, D.c = r, D.d = function(N, k, $) {\n        D.o(N, k) || Object.defineProperty(N, k, { configurable: !1, enumerable: !0, get: $ });\n      }, D.r = function(N) {\n        Object.defineProperty(N, \"__esModule\", { value: !0 });\n      }, D.n = function(N) {\n        var k = N && N.__esModule ? function() {\n          return N.default;\n        } : function() {\n          return N;\n        };\n        return D.d(k, \"a\", k), k;\n      }, D.o = function(N, k) {\n        return Object.prototype.hasOwnProperty.call(N, k);\n      }, D.p = \"\", D(D.s = 0);\n    }([function(e, r, D) {\n      function N(ht) {\n        if (!(this instanceof N))\n          return new N(ht);\n        this._ = ht;\n      }\n      var k = N.prototype;\n      function $(ht, pt) {\n        for (var xt = 0; xt < ht; xt++)\n          pt(xt);\n      }\n      function G(ht, pt, xt) {\n        return function(Rt, Ft) {\n          $(Ft.length, function(Gt) {\n            Rt(Ft[Gt], Gt, Ft);\n          });\n        }(function(Rt, Ft, Gt) {\n          pt = ht(pt, Rt, Ft, Gt);\n        }, xt), pt;\n      }\n      function U(ht, pt) {\n        return G(function(xt, Rt, Ft, Gt) {\n          return xt.concat([ht(Rt, Ft, Gt)]);\n        }, [], pt);\n      }\n      function z(ht, pt) {\n        var xt = { v: 0, buf: pt };\n        return $(ht, function() {\n          var Rt;\n          xt = { v: xt.v << 1 | (Rt = xt.buf, Rt[0] >> 7), buf: function(Ft) {\n            var Gt = G(function(Ut, ee, Ee, Xe) {\n              return Ut.concat(Ee === Xe.length - 1 ? Buffer.from([ee, 0]).readUInt16BE(0) : Xe.readUInt16BE(Ee));\n            }, [], Ft);\n            return Buffer.from(U(function(Ut) {\n              return (Ut << 1 & 65535) >> 8;\n            }, Gt));\n          }(xt.buf) };\n        }), xt;\n      }\n      function X() {\n        return typeof Buffer < \"u\";\n      }\n      function V() {\n        if (!X())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function Y(ht) {\n        V();\n        var pt = G(function(Gt, Ut) {\n          return Gt + Ut;\n        }, 0, ht);\n        if (pt % 8 != 0)\n          throw new Error(\"The bits [\" + ht.join(\", \") + \"] add up to \" + pt + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var xt, Rt = pt / 8, Ft = (xt = function(Gt) {\n          return Gt > 48;\n        }, G(function(Gt, Ut) {\n          return Gt || (xt(Ut) ? Ut : Gt);\n        }, null, ht));\n        if (Ft)\n          throw new Error(Ft + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new N(function(Gt, Ut) {\n          var ee = Rt + Ut;\n          return ee > Gt.length ? st(Ut, Rt.toString() + \" bytes\") : it(ee, G(function(Ee, Xe) {\n            var Fe = z(Xe, Ee.buf);\n            return { coll: Ee.coll.concat(Fe.v), buf: Fe.buf };\n          }, { coll: [], buf: Gt.slice(Ut, ee) }, ht).coll);\n        });\n      }\n      function q(ht, pt) {\n        return new N(function(xt, Rt) {\n          return V(), Rt + pt > xt.length ? st(Rt, pt + \" bytes for \" + ht) : it(Rt + pt, xt.slice(Rt, Rt + pt));\n        });\n      }\n      function W(ht, pt) {\n        if (typeof (xt = pt) != \"number\" || Math.floor(xt) !== xt || pt < 0 || pt > 6)\n          throw new Error(ht + \" requires integer length in range [0, 6].\");\n        var xt;\n      }\n      function K(ht) {\n        return W(\"uintBE\", ht), q(\"uintBE(\" + ht + \")\", ht).map(function(pt) {\n          return pt.readUIntBE(0, ht);\n        });\n      }\n      function Z(ht) {\n        return W(\"uintLE\", ht), q(\"uintLE(\" + ht + \")\", ht).map(function(pt) {\n          return pt.readUIntLE(0, ht);\n        });\n      }\n      function J(ht) {\n        return W(\"intBE\", ht), q(\"intBE(\" + ht + \")\", ht).map(function(pt) {\n          return pt.readIntBE(0, ht);\n        });\n      }\n      function Q(ht) {\n        return W(\"intLE\", ht), q(\"intLE(\" + ht + \")\", ht).map(function(pt) {\n          return pt.readIntLE(0, ht);\n        });\n      }\n      function et(ht) {\n        return ht instanceof N;\n      }\n      function nt(ht) {\n        return {}.toString.call(ht) === \"[object Array]\";\n      }\n      function tt(ht) {\n        return X() && Buffer.isBuffer(ht);\n      }\n      function it(ht, pt) {\n        return { status: !0, index: ht, value: pt, furthest: -1, expected: [] };\n      }\n      function st(ht, pt) {\n        return nt(pt) || (pt = [pt]), { status: !1, index: -1, value: null, furthest: ht, expected: pt };\n      }\n      function at(ht, pt) {\n        if (!pt || ht.furthest > pt.furthest)\n          return ht;\n        var xt = ht.furthest === pt.furthest ? function(Rt, Ft) {\n          if (function() {\n            if (N._supportsSet !== void 0)\n              return N._supportsSet;\n            var ii = typeof Set < \"u\";\n            return N._supportsSet = ii, ii;\n          }() && Array.from) {\n            for (var Gt = new Set(Rt), Ut = 0; Ut < Ft.length; Ut++)\n              Gt.add(Ft[Ut]);\n            var ee = Array.from(Gt);\n            return ee.sort(), ee;\n          }\n          for (var Ee = {}, Xe = 0; Xe < Rt.length; Xe++)\n            Ee[Rt[Xe]] = !0;\n          for (var Fe = 0; Fe < Ft.length; Fe++)\n            Ee[Ft[Fe]] = !0;\n          var ri = [];\n          for (var nr in Ee)\n            ({}).hasOwnProperty.call(Ee, nr) && ri.push(nr);\n          return ri.sort(), ri;\n        }(ht.expected, pt.expected) : pt.expected;\n        return { status: ht.status, index: ht.index, value: ht.value, furthest: pt.furthest, expected: xt };\n      }\n      var ut = {};\n      function ft(ht, pt) {\n        if (tt(ht))\n          return { offset: pt, line: -1, column: -1 };\n        ht in ut || (ut[ht] = {});\n        for (var xt = ut[ht], Rt = 0, Ft = 0, Gt = 0, Ut = pt; Ut >= 0; ) {\n          if (Ut in xt) {\n            Rt = xt[Ut].line, Gt === 0 && (Gt = xt[Ut].lineStart);\n            break;\n          }\n          (ht.charAt(Ut) === `\n` || ht.charAt(Ut) === \"\\r\" && ht.charAt(Ut + 1) !== `\n`) && (Ft++, Gt === 0 && (Gt = Ut + 1)), Ut--;\n        }\n        var ee = Rt + Ft, Ee = pt - Gt;\n        return xt[pt] = { line: ee, lineStart: Gt }, { offset: pt, line: ee + 1, column: Ee + 1 };\n      }\n      function ct(ht) {\n        if (!et(ht))\n          throw new Error(\"not a parser: \" + ht);\n      }\n      function vt(ht, pt) {\n        return typeof ht == \"string\" ? ht.charAt(pt) : ht[pt];\n      }\n      function yt(ht) {\n        if (typeof ht != \"number\")\n          throw new Error(\"not a number: \" + ht);\n      }\n      function mt(ht) {\n        if (typeof ht != \"function\")\n          throw new Error(\"not a function: \" + ht);\n      }\n      function _t(ht) {\n        if (typeof ht != \"string\")\n          throw new Error(\"not a string: \" + ht);\n      }\n      var Tt = 2, Pt = 3, St = 8, gt = 5 * St, bt = 4 * St, Nt = \"  \";\n      function At(ht, pt) {\n        return new Array(pt + 1).join(ht);\n      }\n      function It(ht, pt, xt) {\n        var Rt = pt - ht.length;\n        return Rt <= 0 ? ht : At(xt, Rt) + ht;\n      }\n      function Mt(ht, pt, xt, Rt) {\n        return { from: ht - pt > 0 ? ht - pt : 0, to: ht + xt > Rt ? Rt : ht + xt };\n      }\n      function dt(ht, pt) {\n        var xt, Rt, Ft, Gt, Ut, ee = pt.index, Ee = ee.offset, Xe = 1;\n        if (Ee === ht.length)\n          return \"Got the end of the input\";\n        if (tt(ht)) {\n          var Fe = Ee - Ee % St, ri = Ee - Fe, nr = Mt(Fe, gt, bt + St, ht.length), ii = U(function(Le) {\n            return U(function(_s) {\n              return It(_s.toString(16), 2, \"0\");\n            }, Le);\n          }, function(Le, _s) {\n            var ys = Le.length, nn = [], bs = 0;\n            if (ys <= _s)\n              return [Le.slice()];\n            for (var xs = 0; xs < ys; xs++)\n              nn[bs] || nn.push([]), nn[bs].push(Le[xs]), (xs + 1) % _s == 0 && bs++;\n            return nn;\n          }(ht.slice(nr.from, nr.to).toJSON().data, St));\n          Gt = function(Le) {\n            return Le.from === 0 && Le.to === 1 ? { from: Le.from, to: Le.to } : { from: Le.from / St, to: Math.floor(Le.to / St) };\n          }(nr), Rt = Fe / St, xt = 3 * ri, ri >= 4 && (xt += 1), Xe = 2, Ft = U(function(Le) {\n            return Le.length <= 4 ? Le.join(\" \") : Le.slice(0, 4).join(\" \") + \"  \" + Le.slice(4).join(\" \");\n          }, ii), (Ut = (8 * (Gt.to > 0 ? Gt.to - 1 : Gt.to)).toString(16).length) < 2 && (Ut = 2);\n        } else {\n          var ms = ht.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          xt = ee.column - 1, Rt = ee.line - 1, Gt = Mt(Rt, Tt, Pt, ms.length), Ft = ms.slice(Gt.from, Gt.to), Ut = Gt.to.toString().length;\n        }\n        var Ap = Rt - Gt.from;\n        return tt(ht) && (Ut = (8 * (Gt.to > 0 ? Gt.to - 1 : Gt.to)).toString(16).length) < 2 && (Ut = 2), G(function(Le, _s, ys) {\n          var nn, bs = ys === Ap, xs = bs ? \"> \" : Nt;\n          return nn = tt(ht) ? It((8 * (Gt.from + ys)).toString(16), Ut, \"0\") : It((Gt.from + ys + 1).toString(), Ut, \" \"), [].concat(Le, [xs + nn + \" | \" + _s], bs ? [Nt + At(\" \", Ut) + \" | \" + It(\"\", xt, \" \") + At(\"^\", Xe)] : []);\n        }, [], Ft).join(`\n`);\n      }\n      function $t(ht, pt) {\n        return [`\n`, \"-- PARSING FAILED \" + At(\"-\", 50), `\n\n`, dt(ht, pt), `\n\n`, (xt = pt.expected, xt.length === 1 ? `Expected:\n\n` + xt[0] : `Expected one of the following: \n\n` + xt.join(\", \")), `\n`].join(\"\");\n        var xt;\n      }\n      function Dt(ht) {\n        return ht.flags !== void 0 ? ht.flags : [ht.global ? \"g\" : \"\", ht.ignoreCase ? \"i\" : \"\", ht.multiline ? \"m\" : \"\", ht.unicode ? \"u\" : \"\", ht.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function Vt() {\n        for (var ht = [].slice.call(arguments), pt = ht.length, xt = 0; xt < pt; xt += 1)\n          ct(ht[xt]);\n        return N(function(Rt, Ft) {\n          for (var Gt, Ut = new Array(pt), ee = 0; ee < pt; ee += 1) {\n            if (!(Gt = at(ht[ee]._(Rt, Ft), Gt)).status)\n              return Gt;\n            Ut[ee] = Gt.value, Ft = Gt.index;\n          }\n          return at(it(Ft, Ut), Gt);\n        });\n      }\n      function Lt() {\n        var ht = [].slice.call(arguments);\n        if (ht.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var pt = ht.pop();\n        return mt(pt), Vt.apply(null, ht).map(function(xt) {\n          return pt.apply(null, xt);\n        });\n      }\n      function Et() {\n        var ht = [].slice.call(arguments), pt = ht.length;\n        if (pt === 0)\n          return Ct(\"zero alternates\");\n        for (var xt = 0; xt < pt; xt += 1)\n          ct(ht[xt]);\n        return N(function(Rt, Ft) {\n          for (var Gt, Ut = 0; Ut < ht.length; Ut += 1)\n            if ((Gt = at(ht[Ut]._(Rt, Ft), Gt)).status)\n              return Gt;\n          return Gt;\n        });\n      }\n      function Ht(ht, pt) {\n        return kt(ht, pt).or(jt([]));\n      }\n      function kt(ht, pt) {\n        return ct(ht), ct(pt), Lt(ht, pt.then(ht).many(), function(xt, Rt) {\n          return [xt].concat(Rt);\n        });\n      }\n      function wt(ht) {\n        _t(ht);\n        var pt = \"'\" + ht + \"'\";\n        return N(function(xt, Rt) {\n          var Ft = Rt + ht.length, Gt = xt.slice(Rt, Ft);\n          return Gt === ht ? it(Ft, Gt) : st(Rt, pt);\n        });\n      }\n      function Bt(ht, pt) {\n        (function(Ft) {\n          if (!(Ft instanceof RegExp))\n            throw new Error(\"not a regexp: \" + Ft);\n          for (var Gt = Dt(Ft), Ut = 0; Ut < Gt.length; Ut++) {\n            var ee = Gt.charAt(Ut);\n            if (ee !== \"i\" && ee !== \"m\" && ee !== \"u\" && ee !== \"s\")\n              throw new Error('unsupported regexp flag \"' + ee + '\": ' + Ft);\n          }\n        })(ht), arguments.length >= 2 ? yt(pt) : pt = 0;\n        var xt = function(Ft) {\n          return RegExp(\"^(?:\" + Ft.source + \")\", Dt(Ft));\n        }(ht), Rt = \"\" + ht;\n        return N(function(Ft, Gt) {\n          var Ut = xt.exec(Ft.slice(Gt));\n          if (Ut) {\n            if (0 <= pt && pt <= Ut.length) {\n              var ee = Ut[0], Ee = Ut[pt];\n              return it(Gt + ee.length, Ee);\n            }\n            return st(Gt, \"valid match group (0 to \" + Ut.length + \") in \" + Rt);\n          }\n          return st(Gt, Rt);\n        });\n      }\n      function jt(ht) {\n        return N(function(pt, xt) {\n          return it(xt, ht);\n        });\n      }\n      function Ct(ht) {\n        return N(function(pt, xt) {\n          return st(xt, ht);\n        });\n      }\n      function qt(ht) {\n        if (et(ht))\n          return N(function(pt, xt) {\n            var Rt = ht._(pt, xt);\n            return Rt.index = xt, Rt.value = \"\", Rt;\n          });\n        if (typeof ht == \"string\")\n          return qt(wt(ht));\n        if (ht instanceof RegExp)\n          return qt(Bt(ht));\n        throw new Error(\"not a string, regexp, or parser: \" + ht);\n      }\n      function Qt(ht) {\n        return ct(ht), N(function(pt, xt) {\n          var Rt = ht._(pt, xt), Ft = pt.slice(xt, Rt.index);\n          return Rt.status ? st(xt, 'not \"' + Ft + '\"') : it(xt, null);\n        });\n      }\n      function Kt(ht) {\n        return mt(ht), N(function(pt, xt) {\n          var Rt = vt(pt, xt);\n          return xt < pt.length && ht(Rt) ? it(xt + 1, Rt) : st(xt, \"a character/byte matching \" + ht);\n        });\n      }\n      function Se(ht, pt) {\n        arguments.length < 2 && (pt = ht, ht = void 0);\n        var xt = N(function(Rt, Ft) {\n          return xt._ = pt()._, xt._(Rt, Ft);\n        });\n        return ht ? xt.desc(ht) : xt;\n      }\n      function Oe() {\n        return Ct(\"fantasy-land/empty\");\n      }\n      k.parse = function(ht) {\n        if (typeof ht != \"string\" && !tt(ht))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var pt, xt = this.skip(de)._(ht, 0);\n        return pt = xt.status ? { status: !0, value: xt.value } : { status: !1, index: ft(ht, xt.furthest), expected: xt.expected }, delete ut[ht], pt;\n      }, k.tryParse = function(ht) {\n        var pt = this.parse(ht);\n        if (pt.status)\n          return pt.value;\n        var xt = $t(ht, pt), Rt = new Error(xt);\n        throw Rt.type = \"ParsimmonError\", Rt.result = pt, Rt;\n      }, k.assert = function(ht, pt) {\n        return this.chain(function(xt) {\n          return ht(xt) ? jt(xt) : Ct(pt);\n        });\n      }, k.or = function(ht) {\n        return Et(this, ht);\n      }, k.trim = function(ht) {\n        return this.wrap(ht, ht);\n      }, k.wrap = function(ht, pt) {\n        return Lt(ht, this, pt, function(xt, Rt) {\n          return Rt;\n        });\n      }, k.thru = function(ht) {\n        return ht(this);\n      }, k.then = function(ht) {\n        return ct(ht), Vt(this, ht).map(function(pt) {\n          return pt[1];\n        });\n      }, k.many = function() {\n        var ht = this;\n        return N(function(pt, xt) {\n          for (var Rt = [], Ft = void 0; ; ) {\n            if (!(Ft = at(ht._(pt, xt), Ft)).status)\n              return at(it(xt, Rt), Ft);\n            if (xt === Ft.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            xt = Ft.index, Rt.push(Ft.value);\n          }\n        });\n      }, k.tieWith = function(ht) {\n        return _t(ht), this.map(function(pt) {\n          if (function(Ft) {\n            if (!nt(Ft))\n              throw new Error(\"not an array: \" + Ft);\n          }(pt), pt.length) {\n            _t(pt[0]);\n            for (var xt = pt[0], Rt = 1; Rt < pt.length; Rt++)\n              _t(pt[Rt]), xt += ht + pt[Rt];\n            return xt;\n          }\n          return \"\";\n        });\n      }, k.tie = function() {\n        return this.tieWith(\"\");\n      }, k.times = function(ht, pt) {\n        var xt = this;\n        return arguments.length < 2 && (pt = ht), yt(ht), yt(pt), N(function(Rt, Ft) {\n          for (var Gt = [], Ut = void 0, ee = void 0, Ee = 0; Ee < ht; Ee += 1) {\n            if (ee = at(Ut = xt._(Rt, Ft), ee), !Ut.status)\n              return ee;\n            Ft = Ut.index, Gt.push(Ut.value);\n          }\n          for (; Ee < pt && (ee = at(Ut = xt._(Rt, Ft), ee), Ut.status); Ee += 1)\n            Ft = Ut.index, Gt.push(Ut.value);\n          return at(it(Ft, Gt), ee);\n        });\n      }, k.result = function(ht) {\n        return this.map(function() {\n          return ht;\n        });\n      }, k.atMost = function(ht) {\n        return this.times(0, ht);\n      }, k.atLeast = function(ht) {\n        return Lt(this.times(ht), this.many(), function(pt, xt) {\n          return pt.concat(xt);\n        });\n      }, k.map = function(ht) {\n        mt(ht);\n        var pt = this;\n        return N(function(xt, Rt) {\n          var Ft = pt._(xt, Rt);\n          return Ft.status ? at(it(Ft.index, ht(Ft.value)), Ft) : Ft;\n        });\n      }, k.contramap = function(ht) {\n        mt(ht);\n        var pt = this;\n        return N(function(xt, Rt) {\n          var Ft = pt.parse(ht(xt.slice(Rt)));\n          return Ft.status ? it(Rt + xt.length, Ft.value) : Ft;\n        });\n      }, k.promap = function(ht, pt) {\n        return mt(ht), mt(pt), this.contramap(ht).map(pt);\n      }, k.skip = function(ht) {\n        return Vt(this, ht).map(function(pt) {\n          return pt[0];\n        });\n      }, k.mark = function() {\n        return Lt(ue, this, ue, function(ht, pt, xt) {\n          return { start: ht, value: pt, end: xt };\n        });\n      }, k.node = function(ht) {\n        return Lt(ue, this, ue, function(pt, xt, Rt) {\n          return { name: ht, value: xt, start: pt, end: Rt };\n        });\n      }, k.sepBy = function(ht) {\n        return Ht(this, ht);\n      }, k.sepBy1 = function(ht) {\n        return kt(this, ht);\n      }, k.lookahead = function(ht) {\n        return this.skip(qt(ht));\n      }, k.notFollowedBy = function(ht) {\n        return this.skip(Qt(ht));\n      }, k.desc = function(ht) {\n        nt(ht) || (ht = [ht]);\n        var pt = this;\n        return N(function(xt, Rt) {\n          var Ft = pt._(xt, Rt);\n          return Ft.status || (Ft.expected = ht), Ft;\n        });\n      }, k.fallback = function(ht) {\n        return this.or(jt(ht));\n      }, k.ap = function(ht) {\n        return Lt(ht, this, function(pt, xt) {\n          return pt(xt);\n        });\n      }, k.chain = function(ht) {\n        var pt = this;\n        return N(function(xt, Rt) {\n          var Ft = pt._(xt, Rt);\n          return Ft.status ? at(ht(Ft.value)._(xt, Ft.index), Ft) : Ft;\n        });\n      }, k.concat = k.or, k.empty = Oe, k.of = jt, k[\"fantasy-land/ap\"] = k.ap, k[\"fantasy-land/chain\"] = k.chain, k[\"fantasy-land/concat\"] = k.concat, k[\"fantasy-land/empty\"] = k.empty, k[\"fantasy-land/of\"] = k.of, k[\"fantasy-land/map\"] = k.map;\n      var ue = N(function(ht, pt) {\n        return it(pt, ft(ht, pt));\n      }), _e = N(function(ht, pt) {\n        return pt >= ht.length ? st(pt, \"any character/byte\") : it(pt + 1, vt(ht, pt));\n      }), ve = N(function(ht, pt) {\n        return it(ht.length, ht.slice(pt));\n      }), de = N(function(ht, pt) {\n        return pt < ht.length ? st(pt, \"EOF\") : it(pt, null);\n      }), fe = Bt(/[0-9]/).desc(\"a digit\"), ne = Bt(/[0-9]*/).desc(\"optional digits\"), Ve = Bt(/[a-z]/i).desc(\"a letter\"), vs = Bt(/[a-z]*/i).desc(\"optional letters\"), Ua = Bt(/\\s*/).desc(\"optional whitespace\"), zc = Bt(/\\s+/).desc(\"whitespace\"), ja = wt(\"\\r\"), gs = wt(`\n`), eu = wt(`\\r\n`), ru = Et(eu, gs, ja).desc(\"newline\"), Hc = Et(ru, de);\n      N.all = ve, N.alt = Et, N.any = _e, N.cr = ja, N.createLanguage = function(ht) {\n        var pt = {};\n        for (var xt in ht)\n          ({}).hasOwnProperty.call(ht, xt) && function(Rt) {\n            pt[Rt] = Se(function() {\n              return ht[Rt](pt);\n            });\n          }(xt);\n        return pt;\n      }, N.crlf = eu, N.custom = function(ht) {\n        return N(ht(it, st));\n      }, N.digit = fe, N.digits = ne, N.empty = Oe, N.end = Hc, N.eof = de, N.fail = Ct, N.formatError = $t, N.index = ue, N.isParser = et, N.lazy = Se, N.letter = Ve, N.letters = vs, N.lf = gs, N.lookahead = qt, N.makeFailure = st, N.makeSuccess = it, N.newline = ru, N.noneOf = function(ht) {\n        return Kt(function(pt) {\n          return ht.indexOf(pt) < 0;\n        }).desc(\"none of '\" + ht + \"'\");\n      }, N.notFollowedBy = Qt, N.of = jt, N.oneOf = function(ht) {\n        for (var pt = ht.split(\"\"), xt = 0; xt < pt.length; xt++)\n          pt[xt] = \"'\" + pt[xt] + \"'\";\n        return Kt(function(Rt) {\n          return ht.indexOf(Rt) >= 0;\n        }).desc(pt);\n      }, N.optWhitespace = Ua, N.Parser = N, N.range = function(ht, pt) {\n        return Kt(function(xt) {\n          return ht <= xt && xt <= pt;\n        }).desc(ht + \"-\" + pt);\n      }, N.regex = Bt, N.regexp = Bt, N.sepBy = Ht, N.sepBy1 = kt, N.seq = Vt, N.seqMap = Lt, N.seqObj = function() {\n        for (var ht, pt = {}, xt = 0, Rt = (ht = arguments, Array.prototype.slice.call(ht)), Ft = Rt.length, Gt = 0; Gt < Ft; Gt += 1) {\n          var Ut = Rt[Gt];\n          if (!et(Ut)) {\n            if (nt(Ut) && Ut.length === 2 && typeof Ut[0] == \"string\" && et(Ut[1])) {\n              var ee = Ut[0];\n              if (Object.prototype.hasOwnProperty.call(pt, ee))\n                throw new Error(\"seqObj: duplicate key \" + ee);\n              pt[ee] = !0, xt++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (xt === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return N(function(Ee, Xe) {\n          for (var Fe, ri = {}, nr = 0; nr < Ft; nr += 1) {\n            var ii, ms;\n            if (nt(Rt[nr]) ? (ii = Rt[nr][0], ms = Rt[nr][1]) : (ii = null, ms = Rt[nr]), !(Fe = at(ms._(Ee, Xe), Fe)).status)\n              return Fe;\n            ii && (ri[ii] = Fe.value), Xe = Fe.index;\n          }\n          return at(it(Xe, ri), Fe);\n        });\n      }, N.string = wt, N.succeed = jt, N.takeWhile = function(ht) {\n        return mt(ht), N(function(pt, xt) {\n          for (var Rt = xt; Rt < pt.length && ht(vt(pt, Rt)); )\n            Rt++;\n          return it(Rt, pt.slice(xt, Rt));\n        });\n      }, N.test = Kt, N.whitespace = zc, N[\"fantasy-land/empty\"] = Oe, N[\"fantasy-land/of\"] = jt, N.Binary = { bitSeq: Y, bitSeqObj: function(ht) {\n        V();\n        var pt = {}, xt = 0, Rt = U(function(Gt) {\n          if (nt(Gt)) {\n            var Ut = Gt;\n            if (Ut.length !== 2)\n              throw new Error(\"[\" + Ut.join(\", \") + \"] should be length 2, got length \" + Ut.length);\n            if (_t(Ut[0]), yt(Ut[1]), Object.prototype.hasOwnProperty.call(pt, Ut[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + Ut[0]);\n            return pt[Ut[0]] = !0, xt++, Ut;\n          }\n          return yt(Gt), [null, Gt];\n        }, ht);\n        if (xt < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + ht.join(\", \") + \"]\");\n        var Ft = U(function(Gt) {\n          return Gt[0];\n        }, Rt);\n        return Y(U(function(Gt) {\n          return Gt[1];\n        }, Rt)).map(function(Gt) {\n          return G(function(Ut, ee) {\n            return ee[0] !== null && (Ut[ee[0]] = ee[1]), Ut;\n          }, {}, U(function(Ut, ee) {\n            return [Ut, Gt[ee]];\n          }, Ft));\n        });\n      }, byte: function(ht) {\n        if (V(), yt(ht), ht > 255)\n          throw new Error(\"Value specified to byte constructor (\" + ht + \"=0x\" + ht.toString(16) + \") is larger in value than a single byte.\");\n        var pt = (ht > 15 ? \"0x\" : \"0x0\") + ht.toString(16);\n        return N(function(xt, Rt) {\n          var Ft = vt(xt, Rt);\n          return Ft === ht ? it(Rt + 1, Ft) : st(Rt, pt);\n        });\n      }, buffer: function(ht) {\n        return q(\"buffer\", ht).map(function(pt) {\n          return Buffer.from(pt);\n        });\n      }, encodedString: function(ht, pt) {\n        return q(\"string\", pt).map(function(xt) {\n          return xt.toString(ht);\n        });\n      }, uintBE: K, uint8BE: K(1), uint16BE: K(2), uint32BE: K(4), uintLE: Z, uint8LE: Z(1), uint16LE: Z(2), uint32LE: Z(4), intBE: J, int8BE: J(1), int16BE: J(2), int32BE: J(4), intLE: Q, int8LE: Q(1), int16LE: Q(2), int32LE: Q(4), floatBE: q(\"floatBE\", 4).map(function(ht) {\n        return ht.readFloatBE(0);\n      }), floatLE: q(\"floatLE\", 4).map(function(ht) {\n        return ht.readFloatLE(0);\n      }), doubleBE: q(\"doubleBE\", 8).map(function(ht) {\n        return ht.readDoubleBE(0);\n      }), doubleLE: q(\"doubleLE\", 8).map(function(ht) {\n        return ht.readDoubleLE(0);\n      }) }, e.exports = N;\n    }]);\n  });\n})(parsimmon_umd_min);\nvar dn, Zt, Jt, Ni, Li, Ss, Eu, lo, Xc, Tu, wu, $f;\nconst Lf = class {\n  constructor(t, e = \"\\\\\") {\n    rt(this, Zt);\n    rt(this, Li);\n    rt(this, lo);\n    rt(this, dn, null);\n    rt(this, Ni, {\n      \"!num!\": (t) => t.shift(),\n      \"!str!\": (t) => lt(this, lo, Xc).call(this, t.shift()),\n      \"!bool!\": (t) => t.shift(),\n      // 論理 NOT\n      \"!\": (t) => {\n        const e = t.shift();\n        return e[0] === \"!bool!\" ? !e[1] : String(lt(this, Zt, Jt).call(this, e)) !== \"true\";\n      },\n      // チルダ演算子（ビット反転）\n      \"~\": (t) => ~Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 乗算、除算、剰余\n      \"**\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) ** Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"*\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) * Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"/\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) / Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"¥\": (t) => Math.floor(H(this, Ni)[\"/\"](t)),\n      \"%\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) % Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 加算、減算、文字列の連結\n      \"+\": (t) => {\n        const e = lt(this, Zt, Jt).call(this, t.shift()), r = lt(this, Zt, Jt).call(this, t.shift());\n        return Object.prototype.toString.call(e) === \"[object String]\" || Object.prototype.toString.call(r) === \"[object String]\" ? String(e) + String(r) : Number(e) + Number(r);\n      },\n      \"-\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) - Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 関数\n      int: (t) => int(lt(this, Li, Ss).call(this, t.shift())),\n      parseInt: (t) => int(H(this, Ni).Number(t)),\n      Number: (t) => {\n        const e = lt(this, Zt, Jt).call(this, t.shift());\n        return Object.prototype.toString.call(e) !== \"[object String]\" ? Number(e) : lt(this, Li, Ss).call(this, H(this, dn).parse(String(e)).value);\n      },\n      ceil: (t) => Math.ceil(lt(this, Li, Ss).call(this, t.shift())),\n      floor: (t) => Math.floor(lt(this, Li, Ss).call(this, t.shift())),\n      round: (t) => Math.round(lt(this, Li, Ss).call(this, t.shift())),\n      isNaN: (t) => isNaN(Number(lt(this, Zt, Jt).call(this, t.shift()))),\n      // ビットシフト\n      \"<<\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) << Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \">>\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) >> Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \">>>\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) >>> Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 等値、非等値、厳密等価、厳密非等価\n      \"<\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) < Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"<=\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) <= Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \">\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) > Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \">=\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) >= Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 小なり、以下、大なり、以上\n      \"==\": (t) => {\n        const e = lt(this, Zt, Jt).call(this, t.shift()), r = lt(this, Zt, Jt).call(this, t.shift());\n        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);\n      },\n      \"!=\": (t) => !H(this, Ni)[\"==\"](t),\n      \"===\": (t) => {\n        const e = lt(this, Zt, Jt).call(this, t.shift()), r = lt(this, Zt, Jt).call(this, t.shift());\n        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);\n      },\n      \"!==\": (t) => !H(this, Ni)[\"===\"](t),\n      // ビット演算子\n      \"&\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) & Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"^\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) ^ Number(lt(this, Zt, Jt).call(this, t.shift())),\n      \"|\": (t) => Number(lt(this, Zt, Jt).call(this, t.shift())) | Number(lt(this, Zt, Jt).call(this, t.shift())),\n      // 論理 AND,OR\n      \"&&\": (t) => String(lt(this, Zt, Jt).call(this, t.shift())) === \"true\" && String(lt(this, Zt, Jt).call(this, t.shift())) === \"true\",\n      \"||\": (t) => String(lt(this, Zt, Jt).call(this, t.shift())) === \"true\" || String(lt(this, Zt, Jt).call(this, t.shift())) === \"true\",\n      // 条件\n      \"?\": (t) => {\n        const e = t.shift();\n        let r = !1;\n        if (e[0] === \"!bool!\")\n          r = !!e[1];\n        else {\n          const N = String(lt(this, Zt, Jt).call(this, e));\n          r = N !== \"true\" && N !== \"false\" ? int(N) !== 0 : N === \"true\";\n        }\n        const D = t.shift();\n        if (D[0] !== \":\")\n          throw Error(\"(PropParser)三項演算子の文法エラーです。: が見つかりません\");\n        return lt(this, Zt, Jt).call(this, D[r ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)三項演算子の文法エラーです。? が見つかりません\");\n      }\n    });\n    rt(this, Eu, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g);\n    Ot(this, \"getValAmpersand\", (t) => t.at(0) === \"&\" ? String(this.parse(t.slice(1))) : t);\n    this.val = t;\n    function r(K) {\n      const Z = [];\n      for (const J of K)\n        Z.push(\n          (J instanceof RegExp ? parsimmon_umd_minExports.regex(J) : parsimmon_umd_minExports.string(J)).trim(parsimmon_umd_minExports.optWhitespace)\n        );\n      return parsimmon_umd_minExports.alt.apply(null, Z);\n    }\n    function D(K, Z) {\n      const J = parsimmon_umd_minExports.lazy(() => parsimmon_umd_minExports.seq(K, J).or(Z));\n      return J;\n    }\n    function N(K, Z) {\n      let J = parsimmon_umd_minExports.lazy(\n        () => Z.chain(\n          (Q) => parsimmon_umd_minExports.seq(\n            K,\n            parsimmon_umd_minExports.of(Q),\n            J\n          ).or(parsimmon_umd_minExports.of(Q))\n        )\n      );\n      return J;\n    }\n    function k(K, Z) {\n      return parsimmon_umd_minExports.seqMap(\n        Z,\n        parsimmon_umd_minExports.seq(K, Z).many(),\n        (J, Q) => Q.reduce((et, nt) => [nt[0], et, nt[1]], J)\n      );\n    }\n    const $ = parsimmon_umd_minExports.alt(\n      parsimmon_umd_minExports.alt(\n        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        parsimmon_umd_minExports.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      parsimmon_umd_minExports.alt(\n        parsimmon_umd_minExports.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((K) => int(K))\n    ).map((K) => [\"!num!\", K]).desc(\"number\"), G = parsimmon_umd_minExports.string(\"null\").map(() => [\"!str!\", null]), U = parsimmon_umd_minExports.regex(/(true|false)/).map((K) => [\"!bool!\", K === \"true\"]).desc(\"boolean\"), z = parsimmon_umd_minExports.regex(new RegExp(`(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)`)).map((K) => [\"!str!\", K.slice(1, -1).replaceAll(e, \"\")]).desc(\"string\"), X = /\\[[^\\]]+\\]/g, V = parsimmon_umd_minExports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((K) => {\n      const Z = String(K).replaceAll(\n        X,\n        (Q) => \".\" + this.parse(Q.slice(1, -1))\n      );\n      if (Z.at(0) === \"-\") {\n        const Q = this.val.getVal(Z.slice(1));\n        if (Q == null || String(Q) === \"null\")\n          throw Error(\"(PropParser)数値以外に-符号がついています\");\n        return [\"!num!\", -Number(Q)];\n      }\n      const J = this.val.getVal(Z);\n      return J == null ? [\"!str!\", J] : typeof J == \"boolean\" ? [\"!bool!\", J] : Object.prototype.toString.call(J) === \"[object String]\" ? [\"!str!\", String(J)] : [\"!num!\", Number(J)];\n    }).desc(\"string\"), Y = parsimmon_umd_minExports.lazy(\n      () => parsimmon_umd_minExports.string(\"(\").then(H(this, dn)).skip(parsimmon_umd_minExports.string(\")\")).or($).or(G).or(U).or(z).or(V)\n    ), W = [\n      // 優先順位：19（メンバーへのアクセス、計算値によるメンバーへのアクセス）\n      // a.b  a[b]\n      { type: D, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      // ++ --\t\t// 優先順位：17（後置インクリメント・デクリメント）\n      { type: D, ops: r([/(!(?!=)|~)/]) },\n      // 優先順位：16\n      //\t{type: PREFIX, ops: ope([/(!(?!=)|++|--)/])},\n      // 「n!」階乗演算子は優先順位がよく判らないし、使わない・ミスも考え無いほうが\n      //\t\t// 優先順位：16（前置インクリメント・デクリメント）\n      { type: N, ops: r([\"**\"]) },\n      { type: k, ops: r([\"*\", \"/\", \"¥\", \"%\"]) },\n      { type: k, ops: r([\"+\", \"-\"]) },\n      { type: k, ops: r([/(>>>|<<|>>)/]) },\n      { type: k, ops: r([/(<=|<|>=|>)/]) },\n      { type: k, ops: r([/(===|!==|==|!=)/]) },\n      { type: k, ops: r([/&(?!&)/]) },\n      { type: k, ops: r([\"^\"]) },\n      { type: k, ops: r([/\\|(?!\\|)/]) },\n      { type: k, ops: r([\"&&\"]) },\n      { type: k, ops: r([\"||\"]) },\n      { type: N, ops: r([\":\"]) },\n      { type: N, ops: r([\"?\"]) }\n    ].reduce(\n      (K, Z) => Z.type(Z.ops, K),\n      Y\n    );\n    ot(this, dn, W.trim(parsimmon_umd_minExports.optWhitespace));\n  }\n  parse(t) {\n    const e = H(this, dn).parse(t);\n    if (!e.status)\n      throw Error(\"(PropParser)文法エラー【\" + t + \"】\");\n    const r = e.value;\n    return r[0] === \"!str!\" ? lt(this, lo, Xc).call(this, r[1]) : lt(this, Zt, Jt).call(this, r);\n  }\n  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1\n  // →これは改良しようがない。いい意味で改善の余地なし\n  static getValName(t) {\n    var $;\n    const e = H(this, Tu).exec(t.trim()), r = e == null ? void 0 : e.groups;\n    if (!r)\n      return null;\n    const { scope: D = \"tmp\", name: N, at: k = \"\" } = r;\n    return {\n      scope: D,\n      name: lt($ = Lf, wu, $f).call($, N),\n      at: k\n    };\n  }\n};\nlet PropParser = Lf;\ndn = new WeakMap(), Zt = new WeakSet(), Jt = function(t) {\n  const e = t.shift();\n  if (e instanceof Array)\n    return lt(this, Zt, Jt).call(this, e);\n  const r = H(this, Ni)[e];\n  return r ? r(t) : Object(null);\n}, Ni = new WeakMap(), Li = new WeakSet(), Ss = function(t) {\n  const e = lt(this, Zt, Jt).call(this, t);\n  if (Object.prototype.toString.call(e) !== \"[object Number]\")\n    throw Error(\"(PropParser)引数【\" + e + \"】が数値ではありません\");\n  return Number(e);\n}, Eu = new WeakMap(), lo = new WeakSet(), Xc = function(t) {\n  return t == null ? t : String(t).replaceAll(H(this, Eu), (e) => e.at(0) === \"$\" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));\n}, Tu = new WeakMap(), wu = new WeakSet(), $f = function(t) {\n  let e = 0, r = 0;\n  for (; ; ) {\n    if (e = t.indexOf('[\"'), e < 0) {\n      if (e = t.indexOf(\"['\"), e < 0)\n        break;\n      r = t.indexOf(\"']\", e + 2);\n    } else\n      r = t.indexOf('\"]', e + 2);\n    if (r < 0)\n      break;\n    t = t.slice(0, e) + \".\" + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;\n  }\n  return t;\n}, rt(PropParser, wu), rt(PropParser, Tu, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar wr, pn, Ds, Cr, uo, Cu, Gf, Pu, Uf, Mu, jf, Ru, zf;\nconst pe = class {\n  constructor(t, e, r) {\n    rt(this, Cu);\n    rt(this, Pu);\n    // ログ出力\n    rt(this, uo, !0);\n    this.sys = t, ot(pe, wr, r), ot(pe, pn, e), ot(pe, Ds, e.title), pe.myTrace = lt(pe, Mu, jf), e.log = (D) => lt(this, Cu, Gf).call(this, D), e.trace = (D) => lt(this, Pu, Uf).call(this, D), ot(pe, Cr, document.createElement(\"span\")), H(pe, Cr).hidden = !0, H(pe, Cr).textContent = \"\", H(pe, Cr).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(H(pe, Cr));\n  }\n  destroy() {\n    ot(pe, Ds, () => !1), document.body.removeChild(H(pe, Cr)), pe.myTrace = pe.trace_beforeNew;\n  }\n  // private禁止、galleryでエラーになる\n  static trace_beforeNew(t, e = \"E\") {\n    let r = `{${e}} ` + t, D = \"\";\n    switch (e) {\n      case \"D\":\n        D = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        D = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        D = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw r;\n      case \"E\":\n        console.error(\"%c\" + r, \"color:#FF3300;\");\n        return;\n      default:\n        D = \"color:black;\", r = \" \" + r;\n    }\n    console.info(\"%c\" + r, D);\n  }\n};\nlet DebugMng = pe;\nwr = new WeakMap(), pn = new WeakMap(), Ds = new WeakMap(), Cr = new WeakMap(), uo = new WeakMap(), Cu = new WeakSet(), Gf = function(t) {\n  let e = \"\";\n  return H(this, uo) && (ot(this, uo, !1), e = `== ${platformExports.description} ==\n`), this.sys.appendFile(\n    this.sys.path_downloads + \"log.txt\",\n    `${e}--- ${getDateStr(\"-\", \"_\", \"\")} [fn:${H(pe, wr).scriptFn} line:${H(pe, wr).lineNum}] prj:${this.sys.cur}\n${t.text || `(text is ${t.text})`}\n`,\n    (r) => {\n      r && console.log(r);\n    }\n  ), !1;\n}, Pu = new WeakSet(), Uf = function(t) {\n  return pe.myTrace(t.text || `(text is ${t.text})`, \"I\"), !1;\n}, Mu = new WeakSet(), jf = function(t, e = \"E\") {\n  var N, k;\n  let r = `{${e}} ` + pe.strPos() + t;\n  lt(N = pe, Ru, zf).call(N, r, e);\n  let D = \"\";\n  switch (e) {\n    case \"D\":\n      D = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      D = \"color:#F80;\";\n      break;\n    case \"F\":\n      D = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      if (H(k = pe, Ds).call(k, { text: t }), H(this, pn).dump_lay({}), H(this, pn).dump_val({}), H(pe, wr).dumpErrForeLine(), H(this, pn).dump_stack({}), e === \"ET\")\n        throw r;\n      console.error(\"%c\" + r, \"color:#F30;\");\n      return;\n    default:\n      D = \"\", r = \" \" + r;\n  }\n  console.info(\"%c\" + r, D);\n}, Ru = new WeakSet(), zf = function(t, e) {\n  let r = \"\";\n  switch (e) {\n    case \"D\":\n      r = \"color:#05A;\";\n      break;\n    case \"W\":\n      r = \"color:#F80;\";\n      break;\n    case \"F\":\n      r = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      r = \"color:#F30;\";\n      break;\n    default:\n      r = \"\";\n  }\n  H(pe, Cr).innerHTML += `<span style='${r}'>${t}</span><br/>`, H(pe, Cr).hidden = !1;\n}, rt(DebugMng, Mu), rt(DebugMng, Ru), rt(DebugMng, wr, void 0), rt(DebugMng, pn, void 0), rt(DebugMng, Ds, void 0), rt(DebugMng, Cr, void 0), Ot(DebugMng, \"myTrace\", pe.trace_beforeNew), Ot(DebugMng, \"strPos\", () => H(pe, wr) && H(pe, wr).lineNum > 0 ? `(fn:${H(pe, wr).scriptFn} line:${H(pe, wr).lineNum}) ` : \"\");\nclass Areas {\n  constructor() {\n    Ot(this, \"hAreas\", /* @__PURE__ */ Object.create(null));\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(t) {\n    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);\n  }\n  record(t) {\n    if (!this.search(t)) {\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (r + 1 === t) {\n          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;\n          return;\n        }\n      if (String(t + 1) in this.hAreas) {\n        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];\n        return;\n      }\n      this.hAreas[t] = t;\n    }\n  }\n  erase(t) {\n    if (this.search(t)) {\n      if (String(t) in this.hAreas) {\n        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];\n        return;\n      }\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (!(t < parseInt(e) || r < t)) {\n          if (this.hAreas[e] === t) {\n            this.hAreas[e] = t - 1;\n            return;\n          }\n          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;\n          return;\n        }\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  // 4tst\n  toString() {\n    let t = \",\";\n    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, D) => r - D))\n      t += e === this.hAreas[e] ? \",\" + e : \",\" + e + \"~\" + this.hAreas[e];\n    return t.slice(1);\n  }\n}\nvar ke, pr, we, ni, De, or, $r, ho, Ou, co, Yc, fo, po, Iu, Hf, Du, Vf, vr, Fr, Au, Xf, Nu, Yf, Lu, Wf, ku, qf, Bu, Kf, Fu, Zf, $u, Jf, Gu, Qf, As, su, vo, Wc, go, vn, mo, qc, Uu, ju, Ns, _o, Ls, au, zu, td, Hu, ed, yo, Kc, bo, Zc, Vu, rd, Xu, id, ks, ou;\nconst Ps = class {\n  constructor(t, e) {\n    rt(this, co);\n    //\t// しおり\n    // しおりの複写\n    rt(this, Iu);\n    // しおりの消去\n    rt(this, Du);\n    //\t//\t変数操作\n    // 変数代入・演算\n    rt(this, vr);\n    // 絶対値\n    rt(this, Au);\n    // 文字列から一字取りだし\n    rt(this, Nu);\n    // 文字列で検索\n    rt(this, Lu);\n    // 文字列の長さ\n    rt(this, ku);\n    // 正規表現で置換\n    rt(this, Bu);\n    // 四捨五入\n    rt(this, Fu);\n    // 正規表現で検索\n    rt(this, $u);\n    // 文字列から抜きだし\n    rt(this, Gu);\n    //\t// デバッグ・その他\n    // システム変数の全消去\n    rt(this, As);\n    // ゲーム変数の全消去\n    rt(this, vo);\n    rt(this, mo);\n    rt(this, Ls);\n    rt(this, zu);\n    rt(this, Hu);\n    rt(this, yo);\n    rt(this, bo);\n    rt(this, Vu);\n    rt(this, Xu);\n    rt(this, ks);\n    rt(this, ke, { sys: {}, save: {}, tmp: {}, mp: {} });\n    rt(this, pr, H(this, ke).save);\n    rt(this, we, H(this, ke).tmp);\n    rt(this, ni, void 0);\n    rt(this, De, { sys: {}, mark: {}, kidoku: {} });\n    rt(this, or, void 0);\n    rt(this, $r, {});\n    rt(this, ho, void 0);\n    rt(this, Ou, {\n      auth: (t, e) => lt(this, co, Yc).call(this, e.hBreakpoint.aData),\n      var: (t, e) => H(this, ni).send2Dbg(e.ri, { v: H(this, ke)[e.scope] ?? {} }),\n      set_var: (t, e) => {\n        try {\n          H(this, go).call(this, e.nm, e.val), H(this, ni).send2Dbg(e.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (t, e) => {\n        lt(this, co, Yc).call(this, e.a), H(this, ni).send2Dbg(e.ri, {});\n      },\n      disconnect: (t) => ot(Ps, vn, {})\n    });\n    rt(this, fo, () => {\n    });\n    rt(this, po, (t) => {\n    });\n    Ot(this, \"getMark\", (t) => H(this, De).mark[t]);\n    Ot(this, \"getAreaKidoku\", (t) => H(this, $r)[t]);\n    rt(this, go, (t, e, r = !0) => {\n      if (!t)\n        throw \"[変数に値セット] nameは必須です\";\n      if (e == null)\n        throw \"[変数に値セット] textは必須です（空文字はOK）\";\n      const D = PropParser.getValName(t);\n      if (D === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const N = H(this, ke)[D.scope];\n      if (!N)\n        throw \"[変数に値セット] scopeが異常【\" + D.scope + \"】です\";\n      const k = D.name;\n      if (k.slice(0, 6) === \"const.\" && k in N)\n        throw \"[変数に値セット] 変数【\" + k + \"】は書き換え不可です\";\n      this.setVal_Nochk(D.scope, k, e, r);\n    });\n    Ot(this, \"getVal\", (t, e) => {\n      if (!t)\n        throw \"[変数参照] nameは必須です\";\n      const r = PropParser.getValName(t);\n      if (r === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const D = H(this, ke)[r.scope];\n      if (!D)\n        throw \"[変数参照] scopeが異常【\" + r.scope + \"】です\";\n      const N = r.name;\n      let k = D[N];\n      if (!(N in D)) {\n        k = e;\n        let $ = \"\";\n        const G = N.split(\".\"), U = G.length;\n        for (let z = 0; z < U; ++z, $ += \".\") {\n          if ($ += G[z], !($ in D))\n            continue;\n          let X = JSON.parse(D[$]);\n          if (Object.prototype.toString.call(X) !== \"[object Object]\") {\n            if (z + 1 === U) {\n              k = X;\n              break;\n            }\n            continue;\n          }\n          let V = z;\n          for (; ++V < U; ) {\n            if (!(G[V] in X)) {\n              k = e;\n              break;\n            }\n            if (X = X[G[V]], Object.prototype.toString.call(X) !== \"[object Object]\" || V + 1 === U) {\n              k = X;\n              break;\n            }\n          }\n          k instanceof Object && (k = JSON.stringify(k));\n          break;\n        }\n      }\n      return k instanceof Function && (k = k()), r.at === \"@str\" ? k : lt(this, mo, qc).call(this, k);\n    });\n    rt(this, Uu, /^-?[\\d\\.]+$/);\n    // 変数のダンプ\n    rt(this, ju, () => {\n      const t = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let e in t) {\n        const r = H(this, ke)[e], D = t[e];\n        for (let [N, k] of Object.entries(r))\n          D[N] = Object.prototype.toString.call(k) === \"[object Function]\" ? k() : k;\n      }\n      return console.info(\"🥟 [dump_val]\", t), !1;\n    });\n    rt(this, Ns, !1);\n    rt(this, _o, {\n      // sys\n      \"sys:sn.tagCh.doWait\": (t) => lt(this, Ls, au).call(this, t),\n      \"sys:sn.tagCh.doWait_Kidoku\": (t) => lt(this, Ls, au).call(this, t),\n      \"sys:sn.tagCh.msecWait\": (t) => lt(this, zu, td).call(this, t),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (t) => lt(this, Hu, ed).call(this, t),\n      \"sys:sn.tagCh.canskip\": (t) => lt(this, Ls, au).call(this, t),\n      \"sys:sn.auto.msecPageWait\": (t) => lt(this, yo, Kc).call(this, t),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (t) => lt(this, yo, Kc).call(this, t),\n      \"sys:sn.auto.msecLineWait\": (t) => lt(this, bo, Zc).call(this, t),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (t) => lt(this, bo, Zc).call(this, t),\n      // save\n      \"save:sn.doRecLog\": (t) => {\n        H(this, po).call(this, ot(this, Ns, lt(this, Vu, rd).call(this, t)));\n      },\n      \"save:sn.userFnTail\": (t, e) => {\n        if (e.includes(\"@\"))\n          throw \"この変数では文字「@」は禁止です\";\n        this.cfg.userFnTail = e;\n      },\n      // tmp\n      \"tmp:sn.tagL.enabled\": (t) => lt(this, Xu, id).call(this, t),\n      \"tmp:sn.skip.all\": (t) => lt(this, ks, ou).call(this, t),\n      \"tmp:sn.skip.enabled\": (t) => lt(this, ks, ou).call(this, t),\n      \"tmp:sn.auto.enabled\": (t) => lt(this, ks, ou).call(this, t),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    });\n    if (this.cfg = t, e.let = (N) => lt(this, vr, Fr).call(this, N), e.let_abs = (N) => lt(this, Au, Xf).call(this, N), e.let_char_at = (N) => lt(this, Nu, Yf).call(this, N), e.let_index_of = (N) => lt(this, Lu, Wf).call(this, N), e.let_length = (N) => lt(this, ku, qf).call(this, N), e.let_replace = (N) => lt(this, Bu, Kf).call(this, N), e.let_round = (N) => lt(this, Fu, Zf).call(this, N), e.let_search = (N) => lt(this, $u, Jf).call(this, N), e.let_substr = (N) => lt(this, Gu, Qf).call(this, N), e.clearsysvar = () => lt(this, As, su).call(this), e.clearvar = () => lt(this, vo, Wc).call(this), e.dump_val = () => H(this, ju).call(this), e.copybookmark = (N) => lt(this, Iu, Hf).call(this, N), e.erasebookmark = (N) => lt(this, Du, Vf).call(this, N), H(this, pr)[\"sn.userFnTail\"] = \"\", this.defTmp(\"const.sn.bookmark.json\", () => {\n      const N = [];\n      for (const k of Object.keys(H(this, De).mark).sort()) {\n        const $ = { ...H(this, De).mark[k].json };\n        $.place = k, N.push($);\n      }\n      return JSON.stringify(N);\n    }), H(this, we)[\"const.sn.isFirstBoot\"] = !0, H(this, we)[\"sn.tagL.enabled\"] = !0, H(this, we)[\"sn.skip.all\"] = !1, H(this, we)[\"sn.skip.enabled\"] = !1, H(this, we)[\"sn.auto.enabled\"] = !1, H(this, we)[\"const.sn.last_page_text\"] = \"\", H(this, we)[\"const.sn.displayState\"] = !1, H(this, we)[\"const.Date.getTime\"] = () => (/* @__PURE__ */ new Date()).getTime(), H(this, we)[\"const.Date.getDateStr\"] = () => getDateStr(), H(this, we)[\"const.sn.platform\"] = JSON.stringify(platformExports), lt(this, As, su).call(this), lt(this, vo, Wc).call(this), H(this, we)[\"const.sn.config.window.width\"] = t.oCfg.window.width, H(this, we)[\"const.sn.config.window.height\"] = t.oCfg.window.height, H(this, we)[\"const.sn.config.book.title\"] = t.oCfg.book.title, H(this, we)[\"const.sn.config.book.version\"] = t.oCfg.book.version, H(this, we)[\"const.sn.Math.PI\"] = Math.PI, typeof window > \"u\")\n      return;\n    const r = window, D = r.AudioContext ?? r.webkitAudioContext;\n    H(this, we)[\"const.sn.needClick2Play\"] = () => new D().state === \"suspended\";\n  }\n  setSys(t) {\n    ot(this, ni, t), t.initVal(H(this, De), H(this, we), (e) => {\n      this.updateData(e), sessionStorage.clear();\n      const r = this.cfg.getNs();\n      ot(this, fo, this.cfg.oCfg.debug.variable ? () => {\n        const N = {};\n        for (const [X, V] of Object.entries(H(this, or)))\n          N[\"sys:\" + X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"sys\"] = JSON.stringify(N);\n        const k = {};\n        for (const [X, V] of Object.entries(H(this, pr)))\n          k[\"save:\" + X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"save\"] = JSON.stringify(k);\n        const $ = {};\n        for (const [X, V] of Object.entries(H(this, we)))\n          $[X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"tmp\"] = JSON.stringify($);\n        const G = {};\n        for (const [X, V] of Object.entries(H(this, ke).mp))\n          G[X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"mp\"] = JSON.stringify(G);\n        const U = {};\n        for (const [X, V] of Object.entries(H(this, De).mark))\n          U[X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"mark\"] = JSON.stringify(U);\n        const z = {};\n        for (const [X, V] of Object.entries(H(this, De).kidoku))\n          z[X] = V instanceof Function ? V() : V;\n        sessionStorage[r + \"kidoku\"] = JSON.stringify(z), t.flush();\n      } : () => t.flush()), ot(this, ho, (N, k) => t.callHook(N, k)), t.addHook((N, k) => {\n        var $, G;\n        return (G = ($ = H(this, Ou))[N]) == null ? void 0 : G.call($, N, k);\n      });\n      const D = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      (H(this, we)[\"const.sn.isFirstBoot\"] || D === -1) && lt(this, As, su).call(this);\n    });\n  }\n  updateData(t) {\n    ot(this, De, t), ot(this, or, H(this, ke).sys = H(this, De).sys), ot(this, $r, {});\n    for (const [e, r] of Object.entries(H(this, De).kidoku)) {\n      const D = new Areas();\n      D.hAreas = { ...r }, H(this, $r)[e] = D;\n    }\n  }\n  flush() {\n    H(this, fo).call(this);\n  }\n  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える\n  setDoRecProc(t) {\n    ot(this, po, t);\n  }\n  defTmp(t, e) {\n    H(this, we)[t] = e;\n  }\n  cloneMp() {\n    return { ...H(this, ke).mp };\n  }\n  setMp(t) {\n    H(this, ke).mp = t;\n  }\n  setMark(t, e) {\n    H(this, De).mark[t] = e, this.flush();\n  }\n  cloneSave() {\n    return { ...H(this, ke).save };\n  }\n  mark2save(t) {\n    ot(this, pr, H(this, ke).save = { ...t.hSave }), ot(this, Ns, H(this, pr)[\"sn.doRecLog\"] ?? !1);\n  }\n  // 既読系\n  loadScrWork(t) {\n    t in H(this, $r) || (H(this, $r)[t] = new Areas());\n  }\n  saveKidoku() {\n    for (const [t, { hAreas: e }] of Object.entries(H(this, $r)))\n      H(this, De).kidoku[t] = { ...e };\n    this.flush();\n  }\n  setVal_Nochk(t, e, r, D = !1) {\n    var $, G;\n    const N = H(this, ke)[t];\n    D && (r = lt(this, mo, qc).call(this, r));\n    const k = t + \":\" + e;\n    if (k in H(Ps, vn)) {\n      const U = N[e], z = r;\n      U != z && H(this, ho).call(this, \"data_break\", {\n        dataId: k,\n        old_v: U,\n        new_v: z\n      });\n    }\n    N[e] = r, (G = ($ = H(this, _o))[k]) == null || G.call($, e, r);\n  }\n  doRecLog() {\n    return H(this, Ns);\n  }\n  defValTrg(t, e) {\n    H(this, _o)[t] = e;\n  }\n};\nlet Variable = Ps;\nke = new WeakMap(), pr = new WeakMap(), we = new WeakMap(), ni = new WeakMap(), De = new WeakMap(), or = new WeakMap(), $r = new WeakMap(), ho = new WeakMap(), Ou = new WeakMap(), co = new WeakSet(), Yc = function(t) {\n  ot(Ps, vn, {});\n  for (const e of t)\n    H(Ps, vn)[e.dataId] = 1;\n}, fo = new WeakMap(), po = new WeakMap(), Iu = new WeakSet(), Hf = function(t) {\n  if (!(\"from\" in t))\n    throw \"fromは必須です\";\n  if (!(\"to\" in t))\n    throw \"toは必須です\";\n  const e = Number(t.from), r = Number(t.to);\n  if (e === r)\n    return !1;\n  if (!(e in H(this, De).mark))\n    throw `from:${e} のセーブデータは存在しません`;\n  return this.setMark(r, { ...H(this, De).mark[e] }), H(this, ni).copyBMFolder(e, r), !1;\n}, Du = new WeakSet(), Vf = function(t) {\n  const { place: e } = t;\n  if (!e)\n    throw \"placeは必須です\";\n  return delete H(this, De).mark[e], this.flush(), H(this, ni).eraseBMFolder(e), !1;\n}, vr = new WeakSet(), Fr = function(t) {\n  if (!t.name)\n    throw \"nameは必須です\";\n  let e = !0;\n  if (t.cast)\n    switch (t.cast) {\n      case \"num\":\n        argChk_Num(t, \"text\", NaN);\n        break;\n      case \"int\":\n        t.text = String(int(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"uint\":\n        t.text = String(uint(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"bool\":\n        argChk_Boolean(t, \"text\", !1);\n        break;\n      case \"str\":\n        e = !1;\n        break;\n      default:\n        throw \"cast【\" + t.cast + \"】は未定義です\";\n    }\n  return H(this, go).call(this, t.name, t.text, e), !1;\n}, Au = new WeakSet(), Xf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(e < 0 ? -e : e), lt(this, vr, Fr).call(this, t), !1;\n}, Nu = new WeakSet(), Yf = function(t) {\n  return t.text = (t.text ?? \"\").charAt(argChk_Num(t, \"pos\", 0)), lt(this, vr, Fr).call(this, t), !1;\n}, Lu = new WeakSet(), Wf = function(t) {\n  const { val: e } = t;\n  if (!e)\n    throw \"valは必須です\";\n  const r = argChk_Num(t, \"start\", 0);\n  return t.text = String((t.text ?? \"\").indexOf(e, r)), lt(this, vr, Fr).call(this, t), !1;\n}, ku = new WeakSet(), qf = function(t) {\n  return t.text = String((t.text ?? \"\").length), lt(this, vr, Fr).call(this, t), !1;\n}, Bu = new WeakSet(), Kf = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String(t.text ?? \"\").replace(r, String(t.val)), lt(this, vr, Fr).call(this, t), !1;\n}, Fu = new WeakSet(), Zf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(Math.round(e)), lt(this, vr, Fr).call(this, t), !1;\n}, $u = new WeakSet(), Jf = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String((t.text ?? \"\").search(r)), lt(this, vr, Fr).call(this, t), !1;\n}, Gu = new WeakSet(), Qf = function(t) {\n  const e = argChk_Num(t, \"pos\", 0);\n  return t.text = t.len !== \"all\" ? (t.text ?? \"\").slice(e, e + int(argChk_Num(t, \"len\", 1))) : (t.text ?? \"\").slice(e), lt(this, vr, Fr).call(this, t), !1;\n}, As = new WeakSet(), su = function() {\n  const t = ot(this, or, H(this, ke).sys = H(this, De).sys = {});\n  typeof process < \"u\" || (this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0), this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0)), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", !0), this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\"), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", argChk_Num(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", argChk_Num(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500), this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const [r, D] of Object.entries(H(this, De).kidoku))\n    D.hAreas = {}, H(this, $r)[r].clear();\n  return this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5), H(this, ke).mark = H(this, De).mark = {}, this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1), this.flush(), !1;\n}, vo = new WeakSet(), Wc = function() {\n  const t = H(this, pr)[\"const.sn.mesLayer\"] ?? \"\", e = H(this, pr)[\"sn.doRecLog\"] ?? !1, r = H(this, pr)[\"const.sn.sLog\"] ?? \"[]\";\n  return ot(this, pr, H(this, ke).save = {}), this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", t), this.setVal_Nochk(\"save\", \"sn.doRecLog\", e), this.setVal_Nochk(\"save\", \"const.sn.sLog\", r), !1;\n}, go = new WeakMap(), vn = new WeakMap(), mo = new WeakSet(), qc = function(t) {\n  const e = t;\n  if (e === \"true\")\n    return !0;\n  if (e === \"false\")\n    return !1;\n  if (e === \"null\")\n    return null;\n  if (e !== \"undefined\")\n    return H(this, Uu).test(e) ? parseFloat(e) : t;\n}, Uu = new WeakMap(), ju = new WeakMap(), Ns = new WeakMap(), _o = new WeakMap(), Ls = new WeakSet(), au = function(t) {\n  argChk_Boolean(H(this, or), t, !0);\n}, zu = new WeakSet(), td = function(t) {\n  argChk_Num(H(this, or), t, 10), H(this, or)[\"sn.tagCh.doWait\"];\n}, Hu = new WeakSet(), ed = function(t) {\n  argChk_Num(\n    H(this, or),\n    t,\n    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait\n  ), H(this, or)[\"sn.tagCh.doWait_Kidoku\"];\n}, yo = new WeakSet(), Kc = function(t) {\n  argChk_Num(\n    H(this, or),\n    t,\n    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait\n  );\n}, bo = new WeakSet(), Zc = function(t) {\n  argChk_Num(H(this, or), t, 500);\n}, Vu = new WeakSet(), rd = function(t) {\n  return argChk_Boolean(H(this, pr), t, !0);\n}, Xu = new WeakSet(), id = function(t) {\n  argChk_Boolean(H(this, we), t, !0);\n}, ks = new WeakSet(), ou = function(t) {\n  argChk_Boolean(H(this, we), t, !1);\n}, // reload 再生成 Main に受け渡すため static\nrt(Variable, vn, {});\nvar Easing = Object.freeze({\n  Linear: Object.freeze({\n    None: function(o) {\n      return o;\n    },\n    In: function(o) {\n      return this.None(o);\n    },\n    Out: function(o) {\n      return this.None(o);\n    },\n    InOut: function(o) {\n      return this.None(o);\n    }\n  }),\n  Quadratic: Object.freeze({\n    In: function(o) {\n      return o * o;\n    },\n    Out: function(o) {\n      return o * (2 - o);\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o : -0.5 * (--o * (o - 2) - 1);\n    }\n  }),\n  Cubic: Object.freeze({\n    In: function(o) {\n      return o * o * o;\n    },\n    Out: function(o) {\n      return --o * o * o + 1;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o : 0.5 * ((o -= 2) * o * o + 2);\n    }\n  }),\n  Quartic: Object.freeze({\n    In: function(o) {\n      return o * o * o * o;\n    },\n    Out: function(o) {\n      return 1 - --o * o * o * o;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o * o : -0.5 * ((o -= 2) * o * o * o - 2);\n    }\n  }),\n  Quintic: Object.freeze({\n    In: function(o) {\n      return o * o * o * o * o;\n    },\n    Out: function(o) {\n      return --o * o * o * o * o + 1;\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2);\n    }\n  }),\n  Sinusoidal: Object.freeze({\n    In: function(o) {\n      return 1 - Math.sin((1 - o) * Math.PI / 2);\n    },\n    Out: function(o) {\n      return Math.sin(o * Math.PI / 2);\n    },\n    InOut: function(o) {\n      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - o)));\n    }\n  }),\n  Exponential: Object.freeze({\n    In: function(o) {\n      return o === 0 ? 0 : Math.pow(1024, o - 1);\n    },\n    Out: function(o) {\n      return o === 1 ? 1 : 1 - Math.pow(2, -10 * o);\n    },\n    InOut: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2) < 1 ? 0.5 * Math.pow(1024, o - 1) : 0.5 * (-Math.pow(2, -10 * (o - 1)) + 2);\n    }\n  }),\n  Circular: Object.freeze({\n    In: function(o) {\n      return 1 - Math.sqrt(1 - o * o);\n    },\n    Out: function(o) {\n      return Math.sqrt(1 - --o * o);\n    },\n    InOut: function(o) {\n      return (o *= 2) < 1 ? -0.5 * (Math.sqrt(1 - o * o) - 1) : 0.5 * (Math.sqrt(1 - (o -= 2) * o) + 1);\n    }\n  }),\n  Elastic: Object.freeze({\n    In: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : -Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI);\n    },\n    Out: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : Math.pow(2, -10 * o) * Math.sin((o - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(o) {\n      return o === 0 ? 0 : o === 1 ? 1 : (o *= 2, o < 1 ? -0.5 * Math.pow(2, 10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (o - 1)) * Math.sin((o - 1.1) * 5 * Math.PI) + 1);\n    }\n  }),\n  Back: Object.freeze({\n    In: function(o) {\n      var t = 1.70158;\n      return o === 1 ? 1 : o * o * ((t + 1) * o - t);\n    },\n    Out: function(o) {\n      var t = 1.70158;\n      return o === 0 ? 0 : --o * o * ((t + 1) * o + t) + 1;\n    },\n    InOut: function(o) {\n      var t = 2.5949095;\n      return (o *= 2) < 1 ? 0.5 * (o * o * ((t + 1) * o - t)) : 0.5 * ((o -= 2) * o * ((t + 1) * o + t) + 2);\n    }\n  }),\n  Bounce: Object.freeze({\n    In: function(o) {\n      return 1 - Easing.Bounce.Out(1 - o);\n    },\n    Out: function(o) {\n      return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;\n    },\n    InOut: function(o) {\n      return o < 0.5 ? Easing.Bounce.In(o * 2) * 0.5 : Easing.Bounce.Out(o * 2 - 1) * 0.5 + 0.5;\n    }\n  }),\n  generatePow: function(o) {\n    return o === void 0 && (o = 4), o = o < Number.EPSILON ? Number.EPSILON : o, o = o > 1e4 ? 1e4 : o, {\n      In: function(t) {\n        return Math.pow(t, o);\n      },\n      Out: function(t) {\n        return 1 - Math.pow(1 - t, o);\n      },\n      InOut: function(t) {\n        return t < 0.5 ? Math.pow(t * 2, o) / 2 : (1 - Math.pow(2 - t * 2, o)) / 2 + 0.5;\n      }\n    };\n  }\n}), now$1;\ntypeof self > \"u\" && typeof process < \"u\" && process.hrtime ? now$1 = function() {\n  var o = process.hrtime();\n  return o[0] * 1e3 + o[1] / 1e6;\n} : typeof self < \"u\" && self.performance !== void 0 && self.performance.now !== void 0 ? now$1 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$1 = Date.now : now$1 = function() {\n  return (/* @__PURE__ */ new Date()).getTime();\n};\nvar now$1$1 = now$1, Group = (\n  /** @class */\n  function() {\n    function o() {\n      this._tweens = {}, this._tweensAddedDuringUpdate = {};\n    }\n    return o.prototype.getAll = function() {\n      var t = this;\n      return Object.keys(this._tweens).map(function(e) {\n        return t._tweens[e];\n      });\n    }, o.prototype.removeAll = function() {\n      this._tweens = {};\n    }, o.prototype.add = function(t) {\n      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;\n    }, o.prototype.remove = function(t) {\n      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];\n    }, o.prototype.update = function(t, e) {\n      t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);\n      var r = Object.keys(this._tweens);\n      if (r.length === 0)\n        return !1;\n      for (; r.length > 0; ) {\n        this._tweensAddedDuringUpdate = {};\n        for (var D = 0; D < r.length; D++) {\n          var N = this._tweens[r[D]], k = !e;\n          N && N.update(t, k) === !1 && !e && delete this._tweens[r[D]];\n        }\n        r = Object.keys(this._tweensAddedDuringUpdate);\n      }\n      return !0;\n    }, o;\n  }()\n), Interpolation = {\n  Linear: function(o, t) {\n    var e = o.length - 1, r = e * t, D = Math.floor(r), N = Interpolation.Utils.Linear;\n    return t < 0 ? N(o[0], o[1], r) : t > 1 ? N(o[e], o[e - 1], e - r) : N(o[D], o[D + 1 > e ? e : D + 1], r - D);\n  },\n  Bezier: function(o, t) {\n    for (var e = 0, r = o.length - 1, D = Math.pow, N = Interpolation.Utils.Bernstein, k = 0; k <= r; k++)\n      e += D(1 - t, r - k) * D(t, k) * o[k] * N(r, k);\n    return e;\n  },\n  CatmullRom: function(o, t) {\n    var e = o.length - 1, r = e * t, D = Math.floor(r), N = Interpolation.Utils.CatmullRom;\n    return o[0] === o[e] ? (t < 0 && (D = Math.floor(r = e * (1 + t))), N(o[(D - 1 + e) % e], o[D], o[(D + 1) % e], o[(D + 2) % e], r - D)) : t < 0 ? o[0] - (N(o[0], o[0], o[1], o[1], -r) - o[0]) : t > 1 ? o[e] - (N(o[e], o[e], o[e - 1], o[e - 1], r - e) - o[e]) : N(o[D ? D - 1 : 0], o[D], o[e < D + 1 ? e : D + 1], o[e < D + 2 ? e : D + 2], r - D);\n  },\n  Utils: {\n    Linear: function(o, t, e) {\n      return (t - o) * e + o;\n    },\n    Bernstein: function(o, t) {\n      var e = Interpolation.Utils.Factorial;\n      return e(o) / e(t) / e(o - t);\n    },\n    Factorial: function() {\n      var o = [1];\n      return function(t) {\n        var e = 1;\n        if (o[t])\n          return o[t];\n        for (var r = t; r > 1; r--)\n          e *= r;\n        return o[t] = e, e;\n      };\n    }(),\n    CatmullRom: function(o, t, e, r, D) {\n      var N = (e - o) * 0.5, k = (r - t) * 0.5, $ = D * D, G = D * $;\n      return (2 * t - 2 * e + N + k) * G + (-3 * t + 3 * e - 2 * N - k) * $ + N * D + t;\n    }\n  }\n}, Sequence = (\n  /** @class */\n  function() {\n    function o() {\n    }\n    return o.nextId = function() {\n      return o._nextId++;\n    }, o._nextId = 0, o;\n  }()\n), mainGroup = new Group(), Tween = (\n  /** @class */\n  function() {\n    function o(t, e) {\n      e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;\n    }\n    return o.prototype.getId = function() {\n      return this._id;\n    }, o.prototype.isPlaying = function() {\n      return this._isPlaying;\n    }, o.prototype.isPaused = function() {\n      return this._isPaused;\n    }, o.prototype.to = function(t, e) {\n      return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;\n    }, o.prototype.duration = function(t) {\n      return t === void 0 && (t = 1e3), this._duration = t, this;\n    }, o.prototype.start = function(t, e) {\n      if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !1), this._isPlaying)\n        return this;\n      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {\n        this._reversed = !1;\n        for (var r in this._valuesStartRepeat)\n          this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];\n      }\n      return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e), this;\n    }, o.prototype.startFromCurrentValues = function(t) {\n      return this.start(t, !0);\n    }, o.prototype._setupProperties = function(t, e, r, D, N) {\n      for (var k in r) {\n        var $ = t[k], G = Array.isArray($), U = G ? \"array\" : typeof $, z = !G && Array.isArray(r[k]);\n        if (!(U === \"undefined\" || U === \"function\")) {\n          if (z) {\n            var X = r[k];\n            if (X.length === 0)\n              continue;\n            X = X.map(this._handleRelativeValue.bind(this, $)), e[k] === void 0 && (r[k] = [$].concat(X));\n          }\n          if ((U === \"object\" || G) && $ && !z) {\n            e[k] = G ? [] : {};\n            for (var V in $)\n              e[k][V] = $[V];\n            D[k] = G ? [] : {}, this._setupProperties($, e[k], r[k], D[k], N);\n          } else\n            (typeof e[k] > \"u\" || N) && (e[k] = $), G || (e[k] *= 1), z ? D[k] = r[k].slice().reverse() : D[k] = e[k] || 0;\n        }\n      }\n    }, o.prototype.stop = function() {\n      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;\n    }, o.prototype.end = function() {\n      return this._goToEnd = !0, this.update(1 / 0), this;\n    }, o.prototype.pause = function(t) {\n      return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);\n    }, o.prototype.resume = function(t) {\n      return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);\n    }, o.prototype.stopChainedTweens = function() {\n      for (var t = 0, e = this._chainedTweens.length; t < e; t++)\n        this._chainedTweens[t].stop();\n      return this;\n    }, o.prototype.group = function(t) {\n      return t === void 0 && (t = mainGroup), this._group = t, this;\n    }, o.prototype.delay = function(t) {\n      return t === void 0 && (t = 0), this._delayTime = t, this;\n    }, o.prototype.repeat = function(t) {\n      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;\n    }, o.prototype.repeatDelay = function(t) {\n      return this._repeatDelayTime = t, this;\n    }, o.prototype.yoyo = function(t) {\n      return t === void 0 && (t = !1), this._yoyo = t, this;\n    }, o.prototype.easing = function(t) {\n      return t === void 0 && (t = Easing.Linear.None), this._easingFunction = t, this;\n    }, o.prototype.interpolation = function(t) {\n      return t === void 0 && (t = Interpolation.Linear), this._interpolationFunction = t, this;\n    }, o.prototype.chain = function() {\n      for (var t = [], e = 0; e < arguments.length; e++)\n        t[e] = arguments[e];\n      return this._chainedTweens = t, this;\n    }, o.prototype.onStart = function(t) {\n      return this._onStartCallback = t, this;\n    }, o.prototype.onEveryStart = function(t) {\n      return this._onEveryStartCallback = t, this;\n    }, o.prototype.onUpdate = function(t) {\n      return this._onUpdateCallback = t, this;\n    }, o.prototype.onRepeat = function(t) {\n      return this._onRepeatCallback = t, this;\n    }, o.prototype.onComplete = function(t) {\n      return this._onCompleteCallback = t, this;\n    }, o.prototype.onStop = function(t) {\n      return this._onStopCallback = t, this;\n    }, o.prototype.update = function(t, e) {\n      if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)\n        return !0;\n      var r, D, N = this._startTime + this._duration;\n      if (!this._goToEnd && !this._isPlaying) {\n        if (t > N)\n          return !1;\n        e && this.start(t, !0);\n      }\n      if (this._goToEnd = !1, t < this._startTime)\n        return !0;\n      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), D = (t - this._startTime) / this._duration, D = this._duration === 0 || D > 1 ? 1 : D;\n      var k = this._easingFunction(D);\n      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, k), this._onUpdateCallback && this._onUpdateCallback(this._object, D), D === 1)\n        if (this._repeat > 0) {\n          isFinite(this._repeat) && this._repeat--;\n          for (r in this._valuesStartRepeat)\n            !this._yoyo && typeof this._valuesEnd[r] == \"string\" && (this._valuesStartRepeat[r] = // eslint-disable-next-line\n            // @ts-ignore FIXME?\n            this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];\n          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;\n        } else {\n          this._onCompleteCallback && this._onCompleteCallback(this._object);\n          for (var $ = 0, G = this._chainedTweens.length; $ < G; $++)\n            this._chainedTweens[$].start(this._startTime + this._duration, !1);\n          return this._isPlaying = !1, !1;\n        }\n      return !0;\n    }, o.prototype._updateProperties = function(t, e, r, D) {\n      for (var N in r)\n        if (e[N] !== void 0) {\n          var k = e[N] || 0, $ = r[N], G = Array.isArray(t[N]), U = Array.isArray($), z = !G && U;\n          z ? t[N] = this._interpolationFunction($, D) : typeof $ == \"object\" && $ ? this._updateProperties(t[N], k, $, D) : ($ = this._handleRelativeValue(k, $), typeof $ == \"number\" && (t[N] = k + ($ - k) * D));\n        }\n    }, o.prototype._handleRelativeValue = function(t, e) {\n      return typeof e != \"string\" ? e : e.charAt(0) === \"+\" || e.charAt(0) === \"-\" ? t + parseFloat(e) : parseFloat(e);\n    }, o.prototype._swapEndStartRepeatValues = function(t) {\n      var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];\n      typeof r == \"string\" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;\n    }, o;\n  }()\n), TWEEN = mainGroup;\nTWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nTWEEN.add.bind(TWEEN);\nvar remove$6 = TWEEN.remove.bind(TWEEN), update = TWEEN.update.bind(TWEEN), xo;\nconst Yu = class {\n  static ease(t) {\n    if (!t)\n      return (e) => Easing.Linear.None(e);\n    if (!(t in H(Yu, xo)))\n      throw \"異常なease指定です\";\n    return H(Yu, xo)[t];\n  }\n};\nlet CmnTween = Yu;\nxo = new WeakMap(), rt(CmnTween, xo, {\n  \"Back.In\": (t) => Easing.Back.In(t),\n  \"Back.InOut\": (t) => Easing.Back.InOut(t),\n  \"Back.Out\": (t) => Easing.Back.Out(t),\n  \"Bounce.In\": (t) => Easing.Bounce.In(t),\n  \"Bounce.InOut\": (t) => Easing.Bounce.InOut(t),\n  \"Bounce.Out\": (t) => Easing.Bounce.Out(t),\n  \"Circular.In\": (t) => Easing.Circular.In(t),\n  \"Circular.InOut\": (t) => Easing.Circular.InOut(t),\n  \"Circular.Out\": (t) => Easing.Circular.Out(t),\n  \"Cubic.In\": (t) => Easing.Cubic.In(t),\n  \"Cubic.InOut\": (t) => Easing.Cubic.InOut(t),\n  \"Cubic.Out\": (t) => Easing.Cubic.Out(t),\n  \"Elastic.In\": (t) => Easing.Elastic.In(t),\n  \"Elastic.InOut\": (t) => Easing.Elastic.InOut(t),\n  \"Elastic.Out\": (t) => Easing.Elastic.Out(t),\n  \"Exponential.In\": (t) => Easing.Exponential.In(t),\n  \"Exponential.InOut\": (t) => Easing.Exponential.InOut(t),\n  \"Exponential.Out\": (t) => Easing.Exponential.Out(t),\n  \"Linear.None\": (t) => Easing.Linear.None(t),\n  \"Quadratic.In\": (t) => Easing.Quadratic.In(t),\n  \"Quadratic.InOut\": (t) => Easing.Quadratic.InOut(t),\n  \"Quadratic.Out\": (t) => Easing.Quadratic.Out(t),\n  \"Quartic.In\": (t) => Easing.Quartic.In(t),\n  \"Quartic.InOut\": (t) => Easing.Quartic.InOut(t),\n  \"Quartic.Out\": (t) => Easing.Quartic.Out(t),\n  \"Quintic.In\": (t) => Easing.Quintic.In(t),\n  \"Quintic.InOut\": (t) => Easing.Quintic.InOut(t),\n  \"Quintic.Out\": (t) => Easing.Quintic.Out(t),\n  \"Sinusoidal.In\": (t) => Easing.Sinusoidal.In(t),\n  \"Sinusoidal.InOut\": (t) => Easing.Sinusoidal.InOut(t),\n  \"Sinusoidal.Out\": (t) => Easing.Sinusoidal.Out(t)\n});\n/*!\n * @pixi/sound - v4.3.3\n * https://github.com/pixijs/pixi-sound\n * Compiled Fri, 10 Mar 2023 17:19:30 UTC\n *\n * @pixi/sound is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar s;\nfunction u() {\n  return s;\n}\nvar a = function(o, t) {\n  return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);\n  })(o, t);\n};\nfunction c(o, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  function e() {\n    this.constructor = o;\n  }\n  a(o, t), o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar l = function() {\n  return (l = Object.assign || function(o) {\n    for (var t, e = 1, r = arguments.length; e < r; e++)\n      for (var D in t = arguments[e])\n        Object.prototype.hasOwnProperty.call(t, D) && (o[D] = t[D]);\n    return o;\n  }).apply(this, arguments);\n}, p = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], h = {};\nfunction f(o) {\n  var t = l({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, o || {}), e = document.createElement(\"audio\"), r = {}, D = /^no$/;\n  p.forEach(function(N) {\n    var k = e.canPlayType(\"audio/\".concat(N)).replace(D, \"\"), $ = t[N] ? e.canPlayType(t[N]).replace(D, \"\") : \"\";\n    r[N] = !!k || !!$;\n  }), Object.assign(h, r);\n}\nf();\nvar d = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction _(o) {\n  var t = d, e = typeof o == \"string\" ? o : o.url;\n  if (!t.test(e))\n    return e;\n  for (var r = t.exec(e), D = r[2].split(\",\"), N = D[D.length - 1], k = 0, $ = D.length; k < $; k++) {\n    var G = D[k];\n    if (h[G]) {\n      N = G;\n      break;\n    }\n  }\n  var U = e.replace(r[1], N);\n  if (typeof o != \"string\") {\n    var z = o;\n    z.extension = N, z.url = U;\n  }\n  return U;\n}\nvar y = p.filter(function(o) {\n  return h[o];\n}), m = function() {\n  function o() {\n  }\n  return o.add = function() {\n    o.setLegacy(u().useLegacy);\n  }, o.setLegacy = function(t) {\n    t ? y.forEach(function(e) {\n      LoaderResource.setExtensionXhrType(e, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(e, LoaderResource.LOAD_TYPE.AUDIO);\n    }) : y.forEach(function(e) {\n      LoaderResource.setExtensionXhrType(e, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(e, LoaderResource.LOAD_TYPE.XHR);\n    });\n  }, o.pre = function(t, e) {\n    _(t), e();\n  }, o.use = function(t, e) {\n    t.data && y.indexOf(t.extension) > -1 ? t.sound = u().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();\n  }, o.extension = \"loader\", o;\n}(), b = 0, g = function(o) {\n  function t(e) {\n    var r = o.call(this) || this;\n    return r.id = b++, r.init(e), r;\n  }\n  return c(t, o), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n    }\n    return this;\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {\n    this._playing = !0;\n  }, t.prototype._onPause = function() {\n    this._playing = !1;\n  }, t.prototype.init = function(e) {\n    this._playing = !1, this._duration = e.source.duration;\n    var r = this._source = e.source.cloneNode(!1);\n    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on(\"refresh\", this.refresh, this), e.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = e;\n  }, t.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, t.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    var e = this._media.context, r = this._media.parent;\n    this._source.loop = this._loop || r.loop;\n    var D = e.volume * (e.muted ? 0 : 1), N = r.volume * (r.muted ? 0 : 1), k = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = k * D * N, this._source.playbackRate = this._speed * e.speed * r.speed;\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, D = this._paused || r.paused || e.paused;\n    D !== this._pausedReal && (this._pausedReal = D, D ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", D));\n  }, t.prototype.play = function(e) {\n    var r = this, D = e.start, N = e.end, k = e.speed, $ = e.loop, G = e.volume, U = e.muted;\n    this._speed = k, this._volume = G, this._loop = !!$, this._muted = U, this.refresh(), this.loop && N !== null && (this.loop = !1), this._start = D, this._end = N || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      r._source && (r._source.currentTime = D, r._source.onloadedmetadata = null, r.emit(\"progress\", D, r._duration), Ticker.shared.add(r._onUpdate, r));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, t.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, t.prototype._onComplete = function() {\n    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t.prototype.destroy = function() {\n    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var e = this._source;\n    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, t.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, t.PADDING = 0.1, t;\n}(eventemitter3Exports), v = function(o) {\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return c(t, o), t.prototype.init = function(e) {\n    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);\n  }, t.prototype.create = function() {\n    return new g(this);\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(t.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {\n    var r = this._source, D = this.parent;\n    if (r.readyState !== 4)\n      if (D.url) {\n        r.src = D.url;\n        var N = function() {\n          G(), D.isLoaded = !0;\n          var z = D.autoPlayStart();\n          e && e(null, D, z);\n        }, k = function() {\n          G(), e && e(new Error(\"Sound loading has been aborted\"));\n        }, $ = function() {\n          G();\n          var z = \"Failed to load audio element (code: \".concat(r.error.code, \")\");\n          e && e(new Error(z));\n        }, G = function() {\n          r.removeEventListener(\"canplaythrough\", N), r.removeEventListener(\"load\", N), r.removeEventListener(\"abort\", k), r.removeEventListener(\"error\", $);\n        };\n        r.addEventListener(\"canplaythrough\", N, !1), r.addEventListener(\"load\", N, !1), r.addEventListener(\"abort\", k, !1), r.addEventListener(\"error\", $, !1), r.load();\n      } else\n        e(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      D.isLoaded = !0;\n      var U = D.autoPlayStart();\n      e && setTimeout(function() {\n        e(null, D, U);\n      }, 0);\n    }\n  }, t;\n}(eventemitter3Exports), P = function() {\n  function o(t, e) {\n    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return o.prototype.play = function(t) {\n    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, o.prototype.destroy = function() {\n    this.parent = null;\n  }, o;\n}(), x = function() {\n  function o() {\n  }\n  return o.setParamValue = function(t, e) {\n    if (t.setValueAtTime) {\n      var r = u().context;\n      t.setValueAtTime(e, r.audioContext.currentTime);\n    } else\n      t.value = e;\n    return e;\n  }, o;\n}(), O = 0, j = function(o) {\n  function t(e) {\n    var r = o.call(this) || this;\n    return r.id = O++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;\n  }\n  return c(t, o), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n    }\n    return this;\n  }, t.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh(), this._update(!0);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(e) {\n    var r;\n    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(D) {\n      return D;\n    }).forEach(function(D) {\n      return D.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    if (this._source) {\n      var e = this._media.context, r = this._media.parent;\n      this._source.loop = this._loop || r.loop;\n      var D = e.volume * (e.muted ? 0 : 1), N = r.volume * (r.muted ? 0 : 1), k = this._volume * (this._muted ? 0 : 1);\n      x.setParamValue(this._gain.gain, k * N * D), x.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();\n    }\n  }, t.prototype.applyFilters = function() {\n    var e;\n    if (!((e = this._filters) === null || e === void 0) && e.length) {\n      this._source.disconnect();\n      var r = this._source;\n      this._filters.forEach(function(D) {\n        r.connect(D.destination), r = D;\n      }), r.connect(this._gain);\n    }\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, D = this._paused || r.paused || e.paused;\n    D !== this._pausedReal && (this._pausedReal = D, D ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", D));\n  }, t.prototype.play = function(e) {\n    var r = e.start, D = e.end, N = e.speed, k = e.loop, $ = e.volume, G = e.muted, U = e.filters;\n    this._paused = !1;\n    var z = this._media.nodes.cloneBufferSource(), X = z.source, V = z.gain;\n    this._source = X, this._gain = V, this._speed = N, this._volume = $, this._loop = !!k, this._muted = G, this._filters = U, this.refresh();\n    var Y = this._source.buffer.duration;\n    this._duration = Y, this._end = D, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = D, this._source.loopStart = r, this._source.start(0, r)) : D ? this._source.start(0, r, D - r) : this._source.start(0, r), this.emit(\"start\"), this._update(!0), this.enableTicker(!0);\n  }, t.prototype.enableTicker = function(e) {\n    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    var e;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {\n      return r.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;\n  }, t.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, t.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, t.prototype._updateListener = function() {\n    this._update();\n  }, t.prototype._update = function(e) {\n    if (e === void 0 && (e = !1), this._source) {\n      var r = this._now(), D = r - this._lastUpdate;\n      if (D > 0 || e) {\n        var N = this._source.playbackRate.value;\n        this._elapsed += D * N, this._lastUpdate = r;\n        var k = this._duration, $ = void 0;\n        if (this._source.loopStart) {\n          var G = this._source.loopEnd - this._source.loopStart;\n          $ = (this._source.loopStart + this._elapsed % G) / k;\n        } else\n          $ = this._elapsed % k / k;\n        this._progress = $, this.emit(\"progress\", this._progress, k);\n      }\n    }\n  }, t.prototype.init = function(e) {\n    this._media = e, e.context.events.on(\"refresh\", this.refresh, this), e.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, t.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n      this._source = null;\n    }\n  }, t.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t;\n}(eventemitter3Exports), w = function() {\n  function o(t, e) {\n    this._output = e, this._input = t;\n  }\n  return Object.defineProperty(o.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(D) {\n      D && D.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t && t.length) {\n      this._filters = t.slice(0), this._input.disconnect();\n      var r = null;\n      t.forEach(function(D) {\n        r === null ? e._input.connect(D.destination) : r.connect(D.destination), r = D;\n      }), r.connect(this._output);\n    }\n  }, enumerable: !1, configurable: !0 }), o.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, o;\n}(), A = function(o) {\n  function t(e) {\n    var r = this, D = e.audioContext, N = D.createBufferSource(), k = D.createGain(), $ = D.createAnalyser();\n    return N.connect($), $.connect(k), k.connect(e.destination), (r = o.call(this, $, k) || this).context = e, r.bufferSource = N, r.gain = k, r.analyser = $, r;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, t.prototype.cloneBufferSource = function() {\n    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();\n    r.buffer = e.buffer, x.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;\n    var D = this.context.audioContext.createGain();\n    return r.connect(D), D.connect(this.destination), { source: r, gain: D };\n  }, Object.defineProperty(t.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;\n}(w), F = function() {\n  function o() {\n  }\n  return o.prototype.init = function(t) {\n    this.parent = t, this._nodes = new A(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;\n  }, o.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch {\n    }\n    this._source = null, this.source = null;\n  }, o.prototype.create = function() {\n    return new j(this);\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t) {\n    this._nodes.filters = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t) {\n    this._source.buffer = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: !1, configurable: !0 }), o.prototype.load = function(t) {\n    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error(\"sound.url or sound.source must be set\"));\n  }, o.prototype._loadUrl = function(t) {\n    var e = this, r = new XMLHttpRequest(), D = this.parent.url;\n    r.open(\"GET\", D, !0), r.responseType = \"arraybuffer\", r.onload = function() {\n      e.source = r.response, e._decode(r.response, t);\n    }, r.send();\n  }, o.prototype._decode = function(t, e) {\n    var r = this, D = function(N, k) {\n      if (N)\n        e && e(N);\n      else {\n        r.parent.isLoaded = !0, r.buffer = k;\n        var $ = r.parent.autoPlayStart();\n        e && e(null, r.parent, $);\n      }\n    };\n    t instanceof AudioBuffer ? D(null, t) : this.parent.context.decode(t, D);\n  }, o;\n}(), E = function() {\n  function o(t, e) {\n    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var r = e.complete;\n    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return o.from = function(t) {\n    var e = {};\n    return typeof t == \"string\" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = l({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = _(e.url)), Object.freeze(e), new o(u().useLegacy ? new v() : new F(), e);\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return u().context;\n  }, enumerable: !1, configurable: !0 }), o.prototype.pause = function() {\n    return this.isPlaying = !1, this.paused = !0, this;\n  }, o.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;\n  }, Object.defineProperty(o.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t) {\n    this._paused = t, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t) {\n    this._speed = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t) {\n    this.media.filters = t;\n  }, enumerable: !1, configurable: !0 }), o.prototype.addSprites = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var D in t)\n        r[D] = this.addSprites(D, t[D]);\n      return r;\n    }\n    var N = new P(this, e);\n    return this._sprites[t] = N, N;\n  }, o.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, o.prototype.removeSprites = function(t) {\n    if (t) {\n      var e = this._sprites[t];\n      e !== void 0 && (e.destroy(), delete this._sprites[t]);\n    } else\n      for (var r in this._sprites)\n        this.removeSprites(r);\n    return this;\n  }, Object.defineProperty(o.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: !1, configurable: !0 }), o.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = !1, this._autoPlayOptions = null, this;\n    this.isPlaying = !1;\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._instances[t].stop();\n    return this;\n  }, o.prototype.play = function(t, e) {\n    var r, D = this;\n    if (typeof t == \"string\" ? r = { sprite: k = t, loop: this.loop, complete: e } : typeof t == \"function\" ? (r = {}).complete = t : r = t, (r = l({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {\n      var N = r.sprite, k = this._sprites[N];\n      r.start = k.start + (r.start || 0), r.end = k.end, r.speed = k.speed || 1, r.loop = k.loop || r.loop, delete r.sprite;\n    }\n    if (r.offset && (r.start = r.offset), !this.isLoaded)\n      return new Promise(function(G, U) {\n        D.autoPlay = !0, D._autoPlayOptions = r, D._preload(function(z, X, V) {\n          z ? U(z) : (r.loaded && r.loaded(z, X, V), G(V));\n        });\n      });\n    (this.singleInstance || r.singleInstance) && this._removeInstances();\n    var $ = this._createInstance();\n    return this._instances.push($), this.isPlaying = !0, $.once(\"end\", function() {\n      r.complete && r.complete(D), D._onComplete($);\n    }), $.once(\"stop\", function() {\n      D._onComplete($);\n    }), $.play(r), $;\n  }, o.prototype.refresh = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refresh();\n  }, o.prototype.refreshPaused = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(o.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t) {\n    this._volume = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t) {\n    this._muted = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t) {\n    this._loop = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), o.prototype._preload = function(t) {\n    this.media.load(t);\n  }, Object.defineProperty(o.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: !1, configurable: !0 }), o.prototype.autoPlayStart = function() {\n    var t;\n    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;\n  }, o.prototype._removeInstances = function() {\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._poolInstance(this._instances[t]);\n    this._instances.length = 0;\n  }, o.prototype._onComplete = function(t) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t);\n  }, o.prototype._createInstance = function() {\n    if (o._pool.length > 0) {\n      var t = o._pool.pop();\n      return t.init(this.media), t;\n    }\n    return this.media.create();\n  }, o.prototype._poolInstance = function(t) {\n    t.destroy(), o._pool.indexOf(t) < 0 && o._pool.push(t);\n  }, o._pool = [], o;\n}(), L = function(o) {\n  function t() {\n    var e = o !== null && o.apply(this, arguments) || this;\n    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;\n  }\n  return c(t, o), t.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, t.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, t;\n}(eventemitter3Exports), C = function(o) {\n  function t() {\n    var e = this, r = window, D = new t.AudioContext(), N = D.createDynamicsCompressor(), k = D.createAnalyser();\n    return k.connect(N), N.connect(D.destination), (e = o.call(this, k, N) || this)._ctx = D, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, D.sampleRate)) : 44100), e.compressor = N, e.analyser = k, e.events = new eventemitter3Exports(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = D.state === \"suspended\" && (\"ontouchstart\" in globalThis || \"onclick\" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener(\"mousedown\", e._unlock, !0), document.addEventListener(\"touchstart\", e._unlock, !0), document.addEventListener(\"touchend\", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener(\"focus\", e.onFocus), globalThis.addEventListener(\"blur\", e.onBlur), e;\n  }\n  return c(t, o), t.prototype.onFocus = function() {\n    var e = this._ctx.state;\n    e !== \"suspended\" && e !== \"interrupted\" && this._locked || this._ctx.resume();\n  }, t.prototype.onBlur = function() {\n    this._locked || this._ctx.suspend();\n  }, t.prototype._unlock = function() {\n    this._locked && (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, !0), document.removeEventListener(\"touchend\", this._unlock, !0), document.removeEventListener(\"touchstart\", this._unlock, !0), this._locked = !1));\n  }, t.prototype.playEmptySound = function() {\n    var e = this._ctx.createBufferSource();\n    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === \"suspended\" && e.context.resume();\n  }, Object.defineProperty(t, \"AudioContext\", { get: function() {\n    var e = window;\n    return e.AudioContext || e.webkitAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, \"OfflineAudioContext\", { get: function() {\n    var e = window;\n    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this);\n    var e = this._ctx;\n    e.close !== void 0 && e.close(), globalThis.removeEventListener(\"focus\", this.onFocus), globalThis.removeEventListener(\"blur\", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    e && this._ctx.state === \"running\" ? this._ctx.suspend() : e || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = e;\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, t.prototype.decode = function(e, r) {\n    var D = function(k) {\n      r(new Error((k == null ? void 0 : k.message) || \"Unable to decode file\"));\n    }, N = this._offlineCtx.decodeAudioData(e, function(k) {\n      r(null, k);\n    }, D);\n    N && N.catch(D);\n  }, t;\n}(w), S = function() {\n  function o() {\n    this.init();\n  }\n  return o.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new L(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(o.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t) {\n    this.useLegacy || (this._context.filters = t);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"supported\", { get: function() {\n    return C.AudioContext !== null;\n  }, enumerable: !1, configurable: !0 }), o.prototype.add = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var D in t) {\n        var N = this._getOptions(t[D], e);\n        r[D] = this.add(D, N);\n      }\n      return r;\n    }\n    if (e instanceof E)\n      return this._sounds[t] = e, e;\n    var k = this._getOptions(e), $ = E.from(k);\n    return this._sounds[t] = $, $;\n  }, o.prototype._getOptions = function(t, e) {\n    var r;\n    return r = typeof t == \"string\" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = l(l({}, r), e || {});\n  }, Object.defineProperty(o.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t) {\n    m.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: !1, configurable: !0 }), o.prototype.remove = function(t) {\n    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;\n  }, Object.defineProperty(o.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t) {\n    this._context.volume = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(o.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t) {\n    this._context.speed = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), o.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, o.prototype.pauseAll = function() {\n    return this._context.paused = !0, this._context.refreshPaused(), this;\n  }, o.prototype.resumeAll = function() {\n    return this._context.paused = !1, this._context.refreshPaused(), this;\n  }, o.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, o.prototype.muteAll = function() {\n    return this._context.muted = !0, this._context.refresh(), this;\n  }, o.prototype.unmuteAll = function() {\n    return this._context.muted = !1, this._context.refresh(), this;\n  }, o.prototype.removeAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].destroy(), delete this._sounds[t];\n    return this;\n  }, o.prototype.stopAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].stop();\n    return this;\n  }, o.prototype.exists = function(t, e) {\n    return !!this._sounds[t];\n  }, o.prototype.find = function(t) {\n    return this.exists(t, !0), this._sounds[t];\n  }, o.prototype.play = function(t, e) {\n    return this.find(t).play(e);\n  }, o.prototype.stop = function(t) {\n    return this.find(t).stop();\n  }, o.prototype.pause = function(t) {\n    return this.find(t).pause();\n  }, o.prototype.resume = function(t) {\n    return this.find(t).resume();\n  }, o.prototype.volume = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.volume = e), r.volume;\n  }, o.prototype.speed = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.speed = e), r.speed;\n  }, o.prototype.duration = function(t) {\n    return this.find(t).duration;\n  }, o.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, o;\n}(), M = function() {\n  function o(t, e) {\n    this.init(t, e);\n  }\n  return o.prototype.init = function(t, e) {\n    this.destination = t, this.source = e || t;\n  }, o.prototype.connect = function(t) {\n    this.source.connect(t);\n  }, o.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, o.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, o;\n}(), T = { __proto__: null, Filter: M, EqualizerFilter: function(o) {\n  function t(e, r, D, N, k, $, G, U, z, X) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0), D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = 0), $ === void 0 && ($ = 0), G === void 0 && (G = 0), U === void 0 && (U = 0), z === void 0 && (z = 0), X === void 0 && (X = 0);\n    var V = this;\n    if (!u().useLegacy) {\n      var Y = [{ f: t.F32, type: \"lowshelf\", gain: e }, { f: t.F64, type: \"peaking\", gain: r }, { f: t.F125, type: \"peaking\", gain: D }, { f: t.F250, type: \"peaking\", gain: N }, { f: t.F500, type: \"peaking\", gain: k }, { f: t.F1K, type: \"peaking\", gain: $ }, { f: t.F2K, type: \"peaking\", gain: G }, { f: t.F4K, type: \"peaking\", gain: U }, { f: t.F8K, type: \"peaking\", gain: z }, { f: t.F16K, type: \"highshelf\", gain: X }].map(function(K) {\n        var Z = u().context.audioContext.createBiquadFilter();\n        return Z.type = K.type, x.setParamValue(Z.Q, 1), Z.frequency.value = K.f, x.setParamValue(Z.gain, K.gain), Z;\n      });\n      (V = o.call(this, Y[0], Y[Y.length - 1]) || this).bands = Y, V.bandsMap = {};\n      for (var q = 0; q < V.bands.length; q++) {\n        var W = V.bands[q];\n        q > 0 && V.bands[q - 1].connect(W), V.bandsMap[W.frequency.value] = W;\n      }\n      return V;\n    }\n    V = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype.setGain = function(e, r) {\n    if (r === void 0 && (r = 0), !this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    x.setParamValue(this.bandsMap[e].gain, r);\n  }, t.prototype.getGain = function(e) {\n    if (!this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    return this.bandsMap[e].gain.value;\n  }, Object.defineProperty(t.prototype, \"f32\", { get: function() {\n    return this.getGain(t.F32);\n  }, set: function(e) {\n    this.setGain(t.F32, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f64\", { get: function() {\n    return this.getGain(t.F64);\n  }, set: function(e) {\n    this.setGain(t.F64, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f125\", { get: function() {\n    return this.getGain(t.F125);\n  }, set: function(e) {\n    this.setGain(t.F125, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f250\", { get: function() {\n    return this.getGain(t.F250);\n  }, set: function(e) {\n    this.setGain(t.F250, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f500\", { get: function() {\n    return this.getGain(t.F500);\n  }, set: function(e) {\n    this.setGain(t.F500, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f1k\", { get: function() {\n    return this.getGain(t.F1K);\n  }, set: function(e) {\n    this.setGain(t.F1K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f2k\", { get: function() {\n    return this.getGain(t.F2K);\n  }, set: function(e) {\n    this.setGain(t.F2K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f4k\", { get: function() {\n    return this.getGain(t.F4K);\n  }, set: function(e) {\n    this.setGain(t.F4K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f8k\", { get: function() {\n    return this.getGain(t.F8K);\n  }, set: function(e) {\n    this.setGain(t.F8K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f16k\", { get: function() {\n    return this.getGain(t.F16K);\n  }, set: function(e) {\n    this.setGain(t.F16K, e);\n  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {\n    this.bands.forEach(function(e) {\n      x.setParamValue(e.gain, 0);\n    });\n  }, t.prototype.destroy = function() {\n    this.bands.forEach(function(e) {\n      e.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;\n}(M), DistortionFilter: function(o) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!u().useLegacy) {\n      var D = u().context.audioContext.createWaveShaper();\n      return (r = o.call(this, D) || this)._distortion = D, r.amount = e, r;\n    }\n    r = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(e) {\n    this._amount = e;\n    for (var r, D = 1e3 * e, N = 44100, k = new Float32Array(N), $ = Math.PI / 180, G = 0; G < N; ++G)\n      r = 2 * G / N - 1, k[G] = (3 + D) * r * 20 * $ / (Math.PI + D * Math.abs(r));\n    this._distortion.curve = k, this._distortion.oversample = \"4x\";\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._distortion = null, o.prototype.destroy.call(this);\n  }, t;\n}(M), StereoFilter: function(o) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!u().useLegacy) {\n      var D, N, k, $ = u().context.audioContext;\n      return $.createStereoPanner ? k = D = $.createStereoPanner() : ((N = $.createPanner()).panningModel = \"equalpower\", k = N), (r = o.call(this, k) || this)._stereo = D, r._panner = N, r.pan = e, r;\n    }\n    r = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(e) {\n    this._pan = e, this._stereo ? x.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    o.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, t;\n}(M), ReverbFilter: function(o) {\n  function t(e, r, D) {\n    e === void 0 && (e = 3), r === void 0 && (r = 2), D === void 0 && (D = !1);\n    var N = this;\n    if (!u().useLegacy)\n      return (N = o.call(this, null) || this)._seconds = N._clamp(e, 1, 50), N._decay = N._clamp(r, 0, 100), N._reverse = D, N._rebuild(), N;\n    N = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype._clamp = function(e, r, D) {\n    return Math.min(D, Math.max(r, e));\n  }, Object.defineProperty(t.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(e) {\n    this._seconds = this._clamp(e, 1, 50), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(e) {\n    this._decay = this._clamp(e, 0, 100), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(e) {\n    this._reverse = e, this._rebuild();\n  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {\n    for (var e, r = u().context.audioContext, D = r.sampleRate, N = D * this._seconds, k = r.createBuffer(2, N, D), $ = k.getChannelData(0), G = k.getChannelData(1), U = 0; U < N; U++)\n      e = this._reverse ? N - U : U, $[U] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay), G[U] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay);\n    var z = u().context.audioContext.createConvolver();\n    z.buffer = k, this.init(z);\n  }, t;\n}(M), MonoFilter: function(o) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var r = u().context.audioContext, D = r.createChannelSplitter(), N = r.createChannelMerger();\n      return N.connect(D), (e = o.call(this, N, D) || this)._merger = N, e;\n    }\n    e = o.call(this, null) || this;\n  }\n  return c(t, o), t.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, o.prototype.destroy.call(this);\n  }, t;\n}(M), StreamFilter: function(o) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var r = u().context.audioContext, D = r.createMediaStreamDestination(), N = r.createMediaStreamSource(D.stream);\n      return (e = o.call(this, D, N) || this)._stream = D.stream, e;\n    }\n    e = o.call(this, null) || this;\n  }\n  return c(t, o), Object.defineProperty(t.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._stream = null, o.prototype.destroy.call(this);\n  }, t;\n}(M), TelephoneFilter: function(o) {\n  function t() {\n    if (!u().useLegacy) {\n      var e = u().context.audioContext, r = e.createBiquadFilter(), D = e.createBiquadFilter(), N = e.createBiquadFilter(), k = e.createBiquadFilter();\n      return r.type = \"lowpass\", x.setParamValue(r.frequency, 2e3), D.type = \"lowpass\", x.setParamValue(D.frequency, 2e3), N.type = \"highpass\", x.setParamValue(N.frequency, 500), k.type = \"highpass\", x.setParamValue(k.frequency, 500), r.connect(D), D.connect(N), N.connect(k), o.call(this, r, k) || this;\n    }\n    o.call(this, null);\n  }\n  return c(t, o), t;\n}(M) }, I = 0, B = { __proto__: null, playOnce: function(o, t) {\n  var e = \"alias\".concat(I++);\n  return u().add(e, { url: o, preload: !0, autoPlay: !0, loaded: function(r) {\n    r && (u().remove(e), t && t(r));\n  }, complete: function() {\n    u().remove(e), t && t(null);\n  } }), e;\n}, get PLAY_ID() {\n  return I;\n}, render: function(o, t) {\n  var e = document.createElement(\"canvas\");\n  t = l({ width: 512, height: 128, fill: \"black\" }, t || {}), e.width = t.width, e.height = t.height;\n  var r = BaseTexture.from(e);\n  if (!(o.media instanceof F))\n    return r;\n  var D = o.media, N = e.getContext(\"2d\");\n  N.fillStyle = t.fill;\n  for (var k = D.buffer.getChannelData(0), $ = Math.ceil(k.length / t.width), G = t.height / 2, U = 0; U < t.width; U++) {\n    for (var z = 1, X = -1, V = 0; V < $; V++) {\n      var Y = k[U * $ + V];\n      Y < z && (z = Y), Y > X && (X = Y);\n    }\n    N.fillRect(U, (1 + z) * G, 1, Math.max(1, (X - z) * G));\n  }\n  return r;\n}, resolveUrl: _, sineTone: function(o, t) {\n  o === void 0 && (o = 200), t === void 0 && (t = 1);\n  var e = E.from({ singleInstance: !0 });\n  if (!(e.media instanceof F))\n    return e;\n  for (var r = e.media, D = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), N = D.getChannelData(0), k = 0; k < N.length; k++) {\n    var $ = o * (k / D.sampleRate) * Math.PI;\n    N[k] = 2 * Math.sin($);\n  }\n  return r.buffer = D, e.isLoaded = !0, e;\n}, validateFormats: f, supported: h, extensions: p }, R = function(o) {\n  return s = o, o;\n}(new S());\n\"extensions\" in n ? extensions.add(m) : Loader.registerPlugin(m);\nvar Pe, $e, ki, Wu, nd, Bs, lu, qu, sd, Ku, ad, So, Jc, gn, za, Eo, Qc, Fs, $s, uu, To, tf, wo, Gs, hu, Zu, od, Gr, Ri, Ju, ld, Co, ef, mn, Ha, Qu, ud, Po, rf, th, hd, eh, cd, Us, cu;\nconst to = class {\n  constructor(t, e, r, D, N) {\n    // 音量設定（独自拡張）\n    rt(this, Wu);\n    rt(this, Bs);\n    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）\n    rt(this, qu);\n    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）\n    rt(this, Ku);\n    // BGMのフェード（loadから使うのでマクロ化禁止）\n    rt(this, So);\n    // 効果音のフェード\n    rt(this, gn);\n    // BGM の演奏\n    rt(this, Eo);\n    rt(this, $s);\n    rt(this, To);\n    // 全効果音再生の停止\n    rt(this, Gs);\n    // BGM 演奏の停止（loadから使うのでマクロ化禁止）\n    rt(this, Zu);\n    // 効果音再生の停止\n    rt(this, Gr);\n    // BGM フェードの終了待ち\n    rt(this, Ju);\n    // 効果音フェードの終了待ち\n    rt(this, Co);\n    // 音声フェードの停止\n    rt(this, mn);\n    // BGM 再生の終了待ち\n    rt(this, Qu);\n    // 効果音再生の終了待ち\n    rt(this, Po);\n    // 再生トラックの交換\n    rt(this, th);\n    rt(this, eh);\n    rt(this, Us);\n    rt(this, Pe, {});\n    rt(this, $e, {});\n    rt(this, ki, void 0);\n    rt(this, wo, () => {\n      R.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1)), ot(this, wo, () => {\n      });\n    });\n    this.cfg = t, this.val = r, this.main = D, this.sys = N, e.volume = (k) => lt(this, Wu, nd).call(this, k), e.fadebgm = (k) => lt(this, So, Jc).call(this, k), e.fadeoutbgm = (k) => lt(this, qu, sd).call(this, k), e.fadeoutse = (k) => lt(this, Ku, ad).call(this, k), e.fadese = (k) => lt(this, gn, za).call(this, k), e.playbgm = (k) => lt(this, Eo, Qc).call(this, k), e.playse = (k) => lt(this, $s, uu).call(this, k), e.stop_allse = () => lt(this, Gs, hu).call(this), e.stopbgm = (k) => lt(this, Zu, od).call(this, k), e.stopse = (k) => lt(this, Gr, Ri).call(this, k), e.wb = (k) => lt(this, Ju, ld).call(this, k), e.wf = (k) => lt(this, Co, ef).call(this, k), e.stopfadese = (k) => lt(this, mn, Ha).call(this, k), e.wl = (k) => lt(this, Qu, ud).call(this, k), e.ws = (k) => lt(this, Po, rf).call(this, k), e.xchgbuf = (k) => lt(this, th, hd).call(this, k), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\"), r.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(B.supported));\n  }\n  setEvtMng(t) {\n    ot(this, ki, t);\n  }\n  setNoticeChgVolume(t, e) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (r, D) => t(R.volumeAll = Number(D))), this.val.defValTrg(\"sys:sn.sound.movie_volume\", (r, D) => e(Number(D))), this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1)), this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    R.removeAll();\n  }\n  // しおりの読込（BGM状態復元）\n  playLoopFromSaveObj() {\n    const t = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    if (this.val.flush(), t === \"{}\") {\n      lt(this, Gs, hu).call(this);\n      return;\n    }\n    ot(this, $e, JSON.parse(t));\n    const e = Object.keys(H(this, $e)).map((r) => () => {\n      const D = \"save:const.sn.sound.\" + r + \".\", N = {\n        fn: String(this.val.getVal(D + \"fn\")),\n        buf: r,\n        join: !1,\n        loop: !0,\n        volume: Number(this.val.getVal(D + \"volume\")),\n        start_ms: Number(this.val.getVal(D + \"start_ms\")),\n        end_ms: Number(this.val.getVal(D + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(D + \"ret_ms\"))\n      };\n      N.buf === \"BGM\" ? lt(this, Eo, Qc).call(this, N) : lt(this, $s, uu).call(this, N);\n    });\n    lt(this, Gs, hu).call(this);\n    for (const r of e)\n      r();\n  }\n};\nlet SoundMng = to;\nPe = new WeakMap(), $e = new WeakMap(), ki = new WeakMap(), Wu = new WeakSet(), nd = function(t) {\n  const { buf: e = \"SE\" } = t, r = \"const.sn.sound.\" + e + \".volume\", D = lt(this, Bs, lu).call(this, t, 1);\n  return Number(this.val.getVal(\"sys:\" + r)) === D ? !1 : (this.val.setVal_Nochk(\"sys\", r, D), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal(\"save:\" + r)), lt(this, gn, za).call(this, t));\n}, Bs = new WeakSet(), lu = function(t, e) {\n  const r = argChk_Num(t, \"volume\", e);\n  return r < 0 ? 0 : r > 1 ? 1 : r;\n}, qu = new WeakSet(), sd = function(t) {\n  return t.volume = 0, lt(this, So, Jc).call(this, t);\n}, Ku = new WeakSet(), ad = function(t) {\n  return t.volume = 0, lt(this, gn, za).call(this, t);\n}, So = new WeakSet(), Jc = function(t) {\n  return t.buf = \"BGM\", lt(this, gn, za).call(this, t);\n}, gn = new WeakSet(), za = function(t) {\n  lt(this, mn, Ha).call(this, t);\n  const { buf: e = \"SE\" } = t, r = H(this, Pe)[e];\n  if (!(r != null && r.playing()) || !r.snd)\n    return !1;\n  const D = \"const.sn.sound.\" + e + \".\", N = D + \"volume\", k = lt(this, Bs, lu).call(this, t, NaN);\n  this.val.setVal_Nochk(\"save\", N, k);\n  const $ = k * Number(this.val.getVal(\"sys:\" + N, 1)), G = argChk_Boolean(t, \"stop\", k === 0);\n  G && (lt(this, Us, cu).call(this, e), this.val.setVal_Nochk(\"save\", D + \"fn\", \"\")), this.val.flush();\n  const U = argChk_Num(t, \"time\", NaN), z = argChk_Num(t, \"delay\", 0);\n  if (U === 0 && z === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, ki).isSkippingByKeyDown())\n    return r.snd.volume = $, G && lt(this, Gr, Ri).call(this, t), !1;\n  const X = argChk_Num(t, \"repeat\", 1);\n  return r.updFade = (V) => r.snd.volume = V, r.twFade = new Tween({ v: r.snd.volume }).to({ v: $ }, U).delay(z).easing(CmnTween.ease(t.ease)).repeat(X === 0 ? 1 / 0 : X - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onUpdate(({ v: V }) => r.updFade(V)).onComplete(() => {\n    const V = H(this, Pe)[r.now_buf];\n    (V == null ? void 0 : V.twFade) !== void 0 && (V.updFade = () => {\n    }, remove$6(V.twFade), delete V.twFade, G && (t.buf = r.now_buf, lt(this, Gr, Ri).call(this, t)), V.resumeFade && this.main.resume());\n  }).start(), !1;\n}, Eo = new WeakSet(), Qc = function(t) {\n  return t.buf = \"BGM\", t.canskip = !1, argChk_Boolean(t, \"loop\", !0), lt(this, $s, uu).call(this, t);\n}, Fs = new WeakMap(), $s = new WeakSet(), uu = function(t) {\n  const { buf: e = \"SE\", fn: r } = t;\n  if (lt(this, Gr, Ri).call(this, { buf: e }), !r)\n    throw `[playse] fnは必須です buf:${e}`;\n  if (argChk_Boolean(t, \"canskip\", !0) && H(this, ki).isSkippingByKeyDown())\n    return !1;\n  const D = argChk_Boolean(t, \"loop\", !1);\n  lt(this, eh, cd).call(this, e, D);\n  const N = \"const.sn.sound.\" + e + \".\";\n  this.val.setVal_Nochk(\"save\", N + \"fn\", r);\n  const k = lt(this, Bs, lu).call(this, t, 1);\n  this.val.setVal_Nochk(\"save\", N + \"volume\", k);\n  const $ = k * Number(this.val.getVal(\"sys:\" + N + \"volume\", 1)), G = argChk_Num(t, \"start_ms\", 0), U = argChk_Num(t, \"end_ms\", H(to, Fs)), z = argChk_Num(t, \"ret_ms\", 0), X = argChk_Num(t, \"pan\", 0), V = argChk_Num(t, \"speed\", 1);\n  if (G < 0)\n    throw `[playse] start_ms:${G} が負の値です`;\n  if (z < 0)\n    throw `[playse] ret_ms:${z} が負の値です`;\n  if (U > 0) {\n    if (G >= U)\n      throw `[playse] start_ms:${G} >= end_ms:${U} は異常値です`;\n    if (z >= U)\n      throw `[playse] ret_ms:${z} >= end_ms:${U} は異常値です`;\n  }\n  this.val.setVal_Nochk(\"save\", N + \"start_ms\", G), this.val.setVal_Nochk(\"save\", N + \"end_ms\", U), this.val.setVal_Nochk(\"save\", N + \"ret_ms\", z), this.val.flush();\n  const Y = R.find(r), q = H(this, Pe)[e] = {\n    now_buf: e,\n    snd: Y,\n    loop: D,\n    start_ms: G,\n    end_ms: U,\n    ret_ms: z,\n    resume: !1,\n    pan: X,\n    playing: () => !0,\n    // [ws]的にはここでtrueが欲しい\n    updFade: () => {\n    },\n    onend: () => {\n      const J = q.now_buf, Q = H(this, Pe)[J];\n      if (!Q)\n        return;\n      delete H(this, Pe)[J], Q.playing = () => !1;\n      const et = \"const.sn.sound.\" + J + \".\";\n      this.val.setVal_Nochk(\"tmp\", et + \"playing\", !1), t.buf = J, lt(this, mn, Ha).call(this, t), Q.resume && this.main.resume();\n    }\n  };\n  this.val.setVal_Nochk(\"tmp\", N + \"playing\", !0);\n  const W = {\n    loop: D,\n    speed: V,\n    volume: $,\n    loaded: (J, Q) => {\n      if (J) {\n        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${J}`, !1);\n        return;\n      }\n      if (!Q)\n        return;\n      const et = H(this, Pe)[q.now_buf];\n      et && (et.snd = Q);\n    }\n  };\n  let K = \"\";\n  if (G > 0 || U < H(to, Fs)) {\n    K = `${r};${G};${U};${z}`;\n    const J = (W.sprites ?? (W.sprites = {}))[K] = {\n      start: G / 1e3,\n      end: U / 1e3\n    };\n    W.preload = !0;\n    const Q = W.loaded;\n    W.loaded = (et, nt) => {\n      Q(et, nt);\n      const tt = nt, it = tt.duration;\n      if (J.end < 0) {\n        if (J.end += it, tt.removeSprites(K), tt.addSprites(K, J), J.start >= J.end)\n          throw `[playse] start_ms:${G} >= end_ms:${U}(${J.end * 1e3}) は異常値です`;\n        if (z >= J.end * 1e3)\n          throw `[playse] ret_ms:${z} >= end_ms:${U}(${J.end * 1e3}) は異常値です`;\n      }\n      if (J.start >= it)\n        throw `[playse] start_ms:${G} >= 音声ファイル再生時間:${it} は異常値です`;\n      if (U !== H(to, Fs) && J.end >= it)\n        throw `[playse] end_ms:${U} >= 音声ファイル再生時間:${it} は異常値です`;\n      tt.play(K, W.complete);\n    };\n  } else\n    W.autoPlay = !0;\n  if (D ? z !== 0 && (W.loop = !1, W.complete = async (J) => {\n    const Q = J.duration, et = z / 1e3, nt = U / 1e3;\n    if (et >= Q)\n      throw `[playse] ret_ms:${z} >= 音声ファイル再生時間:${Q} は異常値です`;\n    await R.play(r, {\n      // 一周目はループなし、なのでキャッシュされてる\n      start: et,\n      end: nt < 0 ? nt + Q : nt,\n      // 負の値は末尾から\n      speed: V,\n      loop: !0,\n      volume: $,\n      //\tsprite\t: sp_nm2,\t// err\n      //-\tmuted?: boolean;\n      filters: q.pan !== 0 ? [new T.StereoFilter(q.pan)] : []\n      //-\tcomplete?: CompleteCallback;\n      //-\tloaded?: LoadedCallback;\n      //-\tsingleInstance?: boolean;\n    });\n    const tt = H(this, Pe)[q.now_buf];\n    tt && (tt.snd = R.find(r));\n  }) : W.complete = () => {\n    var J;\n    return (J = H(this, Pe)[q.now_buf]) == null ? void 0 : J.onend();\n  }, H(this, wo).call(this), Y) {\n    if (Y.volume = $, K)\n      lt(this, To, tf).call(this, e, r, W);\n    else if (Y.isPlayable) {\n      const J = Y.options.source;\n      !(J instanceof ArrayBuffer) || J.byteLength === 0 ? Y.play(W) : q.snd = E.from({\n        ...W,\n        url: Y.options.url,\n        source: J\n      }), Y.filters = [new T.StereoFilter(X)];\n    }\n    return !1;\n  }\n  const Z = argChk_Boolean(t, \"join\", !0);\n  if (Z) {\n    const J = W.loaded;\n    W.loaded = (Q, et) => {\n      J == null || J(Q, et), this.main.resume();\n    };\n  }\n  return lt(this, To, tf).call(this, e, r, W), Z;\n}, To = new WeakSet(), tf = function(t, e, r) {\n  const D = this.cfg.searchPath(e, SEARCH_PATH_ARG_EXT.SOUND);\n  if (D.slice(-4) !== \".bin\") {\n    r.url = D;\n    const N = E.from(r);\n    if (t) {\n      const k = H(this, Pe)[t];\n      if (!k)\n        return;\n      k.snd = N, k.pan !== 0 && (N.filters = [new T.StereoFilter(k.pan)]);\n    }\n    r.loop || R.add(e, N);\n    return;\n  }\n  new Loader().add({ name: e, url: D, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((N, k) => {\n    this.sys.dec(N.extension, N.data).then(($) => {\n      N.data = $, k == null || k();\n    }).catch(($) => this.main.errScript(`Sound ロード失敗ですc fn:${N.name} ${$}`, !1));\n  }).load((N, k) => {\n    var G;\n    r.source = (G = k[e]) == null ? void 0 : G.data;\n    const $ = E.from(r);\n    if (t) {\n      const U = H(this, Pe)[t];\n      if (!U)\n        return;\n      U.snd = $, U.pan !== 0 && ($.filters = [new T.StereoFilter(U.pan)]);\n    }\n    r.loop || R.add(e, $);\n  });\n}, wo = new WeakMap(), Gs = new WeakSet(), hu = function() {\n  for (const t of Object.keys(H(this, Pe)))\n    lt(this, Gr, Ri).call(this, { buf: t });\n  return ot(this, Pe, {}), R.stopAll(), !1;\n}, Zu = new WeakSet(), od = function(t) {\n  return t.buf = \"BGM\", lt(this, Gr, Ri).call(this, t);\n}, Gr = new WeakSet(), Ri = function(t) {\n  var D;\n  const { buf: e = \"SE\" } = t;\n  lt(this, Us, cu).call(this, e);\n  const r = H(this, Pe)[e];\n  return r && ((D = r.snd) == null || D.stop(), r.onend()), !1;\n}, Ju = new WeakSet(), ld = function(t) {\n  return t.buf = \"BGM\", lt(this, Co, ef).call(this, t);\n}, Co = new WeakSet(), ef = function(t) {\n  const { buf: e = \"SE\" } = t, r = H(this, Pe)[e];\n  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = H(this, ki).waitEvent(\n    () => lt(this, mn, Ha).call(this, t),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, mn = new WeakSet(), Ha = function(t) {\n  var r, D;\n  const { buf: e = \"SE\" } = t;\n  return (D = (r = H(this, Pe)[e]) == null ? void 0 : r.twFade) == null || D.stop().end(), !1;\n}, Qu = new WeakSet(), ud = function(t) {\n  return t.buf = \"BGM\", lt(this, Po, rf).call(this, t);\n}, Po = new WeakSet(), rf = function(t) {\n  const { buf: e = \"SE\" } = t, r = H(this, Pe)[e];\n  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = H(this, ki).waitEvent(\n    () => {\n      t.buf = r.now_buf, lt(this, Gr, Ri).call(this, t);\n      const D = H(this, Pe)[t.buf];\n      !(D != null && D.playing()) || D.loop || D.onend();\n    },\n    argChk_Boolean(t, \"canskip\", !1),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, th = new WeakSet(), hd = function(t) {\n  const { buf: e = \"SE\", buf2: r = \"SE\" } = t;\n  if (e === r)\n    return !1;\n  const D = H(this, Pe)[e];\n  D && (D.now_buf = r);\n  const N = H(this, Pe)[r];\n  N && (N.now_buf = e), [H(this, Pe)[e], H(this, Pe)[r]] = [N, D];\n  const k = \"const.sn.sound.\" + e + \".\", $ = Number(this.val.getVal(\"save:\" + k + \"volume\")), G = Number(this.val.getVal(\"save:\" + k + \"fn\")), U = String(this.val.getVal(\"tmp:\" + k + \"playing\")) === \"true\", z = \"const.sn.sound.\" + r + \".\", X = Number(this.val.getVal(\"save:\" + z + \"volume\")), V = Number(this.val.getVal(\"save:\" + z + \"fn\")), Y = String(this.val.getVal(\"tmp:\" + z + \"playing\")) === \"true\";\n  return this.val.setVal_Nochk(\"save\", k + \"volume\", X), this.val.setVal_Nochk(\"save\", z + \"volume\", $), this.val.setVal_Nochk(\"save\", k + \"fn\", V), this.val.setVal_Nochk(\"save\", z + \"fn\", G), this.val.setVal_Nochk(\"tmp\", k + \"playing\", Y), this.val.setVal_Nochk(\"tmp\", z + \"playing\", U), e in H(this, $e) == r in H(this, $e) && (e in H(this, $e) ? (delete H(this, $e)[e], H(this, $e)[r] = 0) : (delete H(this, $e)[r], H(this, $e)[e] = 0), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e)))), this.val.flush(), !1;\n}, eh = new WeakSet(), cd = function(t, e) {\n  if (!e) {\n    lt(this, Us, cu).call(this, t);\n    return;\n  }\n  H(this, $e)[t] = 0, this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e))), this.val.flush();\n}, Us = new WeakSet(), cu = function(t) {\n  delete H(this, $e)[t], this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e))), this.val.flush();\n}, // 効果音の再生\nrt(SoundMng, Fs, 999e3);\nvar ye;\nconst kf = class {\n  constructor(t, e, r, D, N, k, $, G) {\n    rt(this, ye, void 0);\n    Ot(this, \"lay\", (t) => this.getPage(t).lay(t));\n    Ot(this, \"getPage\", (t) => kf.argChk_page(t, \"fore\") !== \"back\" ? H(this, ye).fore : H(this, ye).back);\n    this.cls = e, this.hArg = N, this.sys = k, this.val = $, this.ret = G;\n    const U = k.hFactoryCls[e];\n    if (!U)\n      throw `属性 class【${e}】が不正です`;\n    const z = U(), X = U();\n    z.layname = X.layname = t;\n    const V = N[\":id_tag\"] = `layer:${t} cls:${e} page:`;\n    z.spLay.name = z.name = V + \"A\", z.spLay.name = X.name = V + \"B\", r.addChild(z.spLay), D.addChild(X.spLay), argChk_Boolean(N, \"visible\", !0), argChk_Boolean(N, \"visible\", !0), G.isWait = z.lay(N) || X.lay(N), ot(this, ye, { fore: z, back: X });\n    const Y = `const.sn.lay.${t}`;\n    $.setVal_Nochk(\"tmp\", Y, !0), $.defTmp(Y + \".fore.alpha\", () => H(this, ye).fore.alpha), $.defTmp(Y + \".back.alpha\", () => H(this, ye).back.alpha), $.defTmp(Y + \".fore.height\", () => H(this, ye).fore.height), $.defTmp(Y + \".back.height\", () => H(this, ye).back.height), $.defTmp(Y + \".fore.visible\", () => H(this, ye).fore.spLay.visible), $.defTmp(Y + \".back.visible\", () => H(this, ye).back.spLay.visible), $.defTmp(Y + \".fore.width\", () => H(this, ye).fore.width), $.defTmp(Y + \".back.width\", () => H(this, ye).back.width), $.defTmp(Y + \".fore.x\", () => H(this, ye).fore.x), $.defTmp(Y + \".back.x\", () => H(this, ye).back.x), $.defTmp(Y + \".fore.y\", () => H(this, ye).fore.y), $.defTmp(Y + \".back.y\", () => H(this, ye).back.y);\n  }\n  destroy() {\n    H(this, ye).fore.destroy(), H(this, ye).back.destroy();\n  }\n  static argChk_page(t, e) {\n    const r = t.page ?? e;\n    if (r === \"fore\" || r === \"back\")\n      return t.page = r;\n    throw Error(\"属性 page【\" + r + \"】が不正です\");\n  }\n  get fore() {\n    return H(this, ye).fore;\n  }\n  get back() {\n    return H(this, ye).back;\n  }\n  transPage(t) {\n    [H(this, ye).back, H(this, ye).fore] = [H(this, ye).fore, H(this, ye).back], H(this, ye).back.copy(H(this, ye).fore, t);\n  }\n};\nlet Pages = kf;\nye = new WeakMap();\nvar rh, ih;\nconst Oi = class {\n  constructor() {\n    Ot(this, \"layname\", \"\");\n    Ot(this, \"name_\", \"\");\n    Ot(this, \"spLay\", new Sprite(Texture.EMPTY));\n  }\n  set name(t) {\n    this.name_ = t;\n  }\n  get name() {\n    return this.name_;\n  }\n  // tsy用\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(t) {\n    this.spLay.alpha = t;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(t) {\n    this.spLay.angle = t;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(t) {\n    this.spLay.scale.x = t;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(t) {\n    this.spLay.scale.y = t;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(t) {\n    this.spLay.x = t;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(t) {\n    this.spLay.y = t;\n  }\n  destroy() {\n  }\n  lay(t) {\n    return \"alpha\" in t && (this.spLay.alpha = argChk_Num(t, \"alpha\", 1)), Oi.setBlendmode(this.spLay, t), (\"pivot_x\" in t || \"pivot_y\" in t) && this.spLay.pivot.set(\n      argChk_Num(t, \"pivot_x\", this.spLay.pivot.x),\n      argChk_Num(t, \"pivot_y\", this.spLay.pivot.y)\n    ), \"rotation\" in t && (this.spLay.angle = argChk_Num(t, \"rotation\", 0)), (\"scale_x\" in t || \"scale_y\" in t) && this.spLay.scale.set(\n      argChk_Num(t, \"scale_x\", this.spLay.scale.x),\n      argChk_Num(t, \"scale_y\", this.spLay.scale.y)\n    ), \"visible\" in t && (this.spLay.visible = argChk_Boolean(t, \"visible\", !0)), !1;\n  }\n  static setBlendmode(t, e) {\n    const { blendmode: r } = e;\n    if (!r)\n      return;\n    const D = Oi.getBlendmodeNum(r);\n    t instanceof Sprite && (t.blendMode = D);\n    for (const N of t.children)\n      N instanceof Sprite && (N.blendMode = D);\n  }\n  static getBlendmodeNum(t) {\n    if (!t)\n      return BLEND_MODES.NORMAL;\n    const e = H(Oi, rh)[t];\n    if (e !== void 0)\n      return e;\n    throw `${t} はサポートされない blendmode です`;\n  }\n  static getNum2Blendmode(t) {\n    return H(Oi, ih)[t] ?? \"normal\";\n  }\n  // アニメ・動画があるか\n  get containMovement() {\n    return !1;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(t) {\n    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, \"filter\", !1) && (this.spLay.filters = []);\n  }\n  copy(t, e) {\n    const r = this.name_;\n    this.playback(t.record(), e), this.name = r;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(t, e) {\n    this.name = t.name, this.clearLay({ filter: \"true\" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;\n  }\n  snapshot(t, e) {\n    t.render(this.spLay, { clear: !1 }), e();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(t) {\n  }\n  makeDesignCastChildren(t) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(t, e, r, D = !1, N = !1) {\n    if (e.pos) {\n      Oi.setXYByPos(t, e.pos, r);\n      return;\n    }\n    const k = t.getBounds(), $ = r.scale.x < 0 ? -r.scale.x : r.scale.x, G = $ === 1 ? k.width : k.width * $, U = r.scale.y < 0 ? -r.scale.y : r.scale.y, z = U === 1 ? k.height : k.height * U;\n    let X = r.x;\n    \"left\" in e ? (X = argChk_Num(e, \"left\", 0), X > -1 && X < 1 && (X *= CmnLib.stageW)) : \"center\" in e ? (X = argChk_Num(e, \"center\", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = X - (N ? G / 3 : G) / 2) : \"right\" in e ? (X = argChk_Num(e, \"right\", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = X - (N ? G / 3 : G)) : \"s_right\" in e && (X = argChk_Num(e, \"s_right\", 0), X > -1 && X < 1 && (X *= CmnLib.stageW), X = CmnLib.stageW - X - (N ? G / 3 : G)), r.x = int(r.scale.x < 0 ? X + (N ? G / 3 : G) : X);\n    let V = r.y;\n    \"top\" in e ? (V = argChk_Num(e, \"top\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH)) : \"middle\" in e ? (V = argChk_Num(e, \"middle\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - z / 2) : \"bottom\" in e ? (V = argChk_Num(e, \"bottom\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - z) : \"s_bottom\" in e && (V = argChk_Num(e, \"s_bottom\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = CmnLib.stageH - V - z), r.y = int(r.scale.y < 0 ? V + z : V), D && !(\"left\" in e) && !(\"center\" in e) && !(\"right\" in e) && !(\"s_right\" in e) && !(\"top\" in e) && !(\"middle\" in e) && !(\"bottom\" in e) && !(\"s_bottom\" in e) && Oi.setXYByPos(t, \"c\", r);\n  }\n  static setXYByPos(t, e, r) {\n    if (e === \"stay\")\n      return;\n    if (t === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (r === void 0)\n      throw \"setXYByPos result === undefined\";\n    const D = t.getBounds(), N = r.scale.x < 0 ? -r.scale.x : r.scale.x, k = N === 1 ? D.width : D.width * N, $ = r.scale.y < 0 ? -r.scale.y : r.scale.y, G = $ === 1 ? D.height : D.height * $;\n    let U = 0;\n    !e || e === \"c\" ? U = CmnLib.stageW * 0.5 : e === \"r\" ? U = CmnLib.stageW - k * 0.5 : e === \"l\" ? U = k * 0.5 : U = int(e), r.x = int(U - k * 0.5), r.y = CmnLib.stageH - G, r.scale.x < 0 && (r.x += k), r.scale.y < 0 && (r.y += G);\n  }\n  static setXYCenter(t) {\n    const e = t.getBounds();\n    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;\n  }\n};\nlet Layer = Oi;\nrh = new WeakMap(), ih = new WeakMap(), rt(Layer, rh, {\n  normal: BLEND_MODES.NORMAL,\n  add: BLEND_MODES.ADD,\n  multiply: BLEND_MODES.MULTIPLY,\n  screen: BLEND_MODES.SCREEN\n  /*\n  \t\t'overlay'\t\t: BLEND_MODES.OVERLAY,\n  \t\t'darken'\t\t: BLEND_MODES.DARKEN,\n  \t\t'lighten'\t\t: BLEND_MODES.LIGHTEN,\n  \t\t'color_dodge'\t: BLEND_MODES.COLOR_DODGE,\n  \t\t'color_burn'\t: BLEND_MODES.COLOR_BURN,\n  \t\t'hard_light'\t: BLEND_MODES.HARD_LIGHT,\n  \t\t'soft_light'\t: BLEND_MODES.SOFT_LIGHT,\n  \t\t'difference'\t: BLEND_MODES.DIFFERENCE,\n  \t\t'exclusion'\t\t: BLEND_MODES.EXCLUSION,\n  \t\t'hue'\t\t\t: BLEND_MODES.HUE,\n  \t\t'saturation'\t: BLEND_MODES.SATURATION,\n  \t\t'color'\t\t\t: BLEND_MODES.COLOR,\n  \t\t'luminosity'\t: BLEND_MODES.LUMINOSITY,\n  \n  \t\t'normal_npm'\t: BLEND_MODES.NORMAL_NPM,\n  \t\t'add_npm'\t\t: BLEND_MODES.ADD_NPM,\n  \t\t'screen_npm'\t: BLEND_MODES.SCREEN_NPM,\n  \t\t'none'\t\t\t: BLEND_MODES.NONE,\n  \t\t'src_in'\t\t: BLEND_MODES.SRC_IN,\n  \t\t'src_out'\t\t: BLEND_MODES.SRC_OUT,\n  \t\t'src_atop'\t\t: BLEND_MODES.SRC_ATOP,\n  \t\t'dst_over'\t\t: BLEND_MODES.DST_OVER,\n  \t\t'dst_in'\t\t: BLEND_MODES.DST_IN,\n  \t\t'dst_out'\t\t: BLEND_MODES.DST_OUT,\n  \t\t'dst_atop'\t\t: BLEND_MODES.DST_ATOP,\n  \t\t'subtract'\t\t: BLEND_MODES.SUBTRACT,\n  \t\t'src_over'\t\t: BLEND_MODES.SRC_OVER,\n  \t\t'erase'\t\t\t: BLEND_MODES.ERASE,\n  \t\t'xor'\t\t\t: BLEND_MODES.XOR,\n  */\n}), rt(Layer, ih, {\n  0: \"normal\",\n  1: \"add\",\n  2: \"multiply\",\n  3: \"screen\"\n});\nfunction prefixNames(o) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  return t.map(function(r) {\n    return r.split(\" \").map(function(D) {\n      return D ? \"\" + o + D : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction prefixCSS(o, t) {\n  return t.replace(/([^}{]*){/gm, function(e, r) {\n    return r.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + o + \"$1\") + \"{\";\n  });\n}\nfunction ref(o, t) {\n  return function(e) {\n    e && (o[t] = e);\n  };\n}\nfunction refs(o, t, e) {\n  return function(r) {\n    r && (o[t][e] = r);\n  };\n}\nfunction Properties(o, t) {\n  return function(e) {\n    var r = e.prototype;\n    o.forEach(function(D) {\n      t(r, D);\n    });\n  };\n}\nfunction withMethods(o, t) {\n  return t === void 0 && (t = {}), function(e, r) {\n    o.forEach(function(D) {\n      var N = t[D] || D;\n      N in e || (e[N] = function() {\n        for (var k, $ = [], G = 0; G < arguments.length; G++)\n          $[G] = arguments[G];\n        var U = (k = this[r])[D].apply(k, $);\n        return U === this[r] ? this : U;\n      });\n    });\n  };\n}\nvar PolyMap = /* @__PURE__ */ function() {\n  function o() {\n    this.keys = [], this.values = [];\n  }\n  var t = o.prototype;\n  return t.get = function(e) {\n    return this.values[this.keys.indexOf(e)];\n  }, t.set = function(e, r) {\n    var D = this.keys, N = this.values, k = D.indexOf(e), $ = k === -1 ? D.length : k;\n    D[$] = e, N[$] = r;\n  }, o;\n}(), HashMap = /* @__PURE__ */ function() {\n  function o() {\n    this.object = {};\n  }\n  var t = o.prototype;\n  return t.get = function(e) {\n    return this.object[e];\n  }, t.set = function(e, r) {\n    this.object[e] = r;\n  }, o;\n}(), SUPPORT_MAP = typeof Map == \"function\", Link = /* @__PURE__ */ function() {\n  function o() {\n  }\n  var t = o.prototype;\n  return t.connect = function(e, r) {\n    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);\n  }, t.disconnect = function() {\n    var e = this.prev, r = this.next;\n    e && (e.next = r), r && (r.prev = e);\n  }, t.getIndex = function() {\n    for (var e = this, r = -1; e; )\n      e = e.prev, ++r;\n    return r;\n  }, o;\n}();\nfunction orderChanged(o, t) {\n  var e = [], r = [];\n  return o.forEach(function(D) {\n    var N = D[0], k = D[1], $ = new Link();\n    e[N] = $, r[k] = $;\n  }), e.forEach(function(D, N) {\n    D.connect(e[N - 1]);\n  }), o.filter(function(D, N) {\n    return !t[N];\n  }).map(function(D, N) {\n    var k = D[0], $ = D[1];\n    if (k === $)\n      return [0, 0];\n    var G = e[k], U = r[$ - 1], z = G.getIndex();\n    G.disconnect(), U ? G.connect(U, U.next) : G.connect(void 0, e[0]);\n    var X = G.getIndex();\n    return [z, X];\n  });\n}\nvar Result = /* @__PURE__ */ function() {\n  function o(e, r, D, N, k, $, G, U) {\n    this.prevList = e, this.list = r, this.added = D, this.removed = N, this.changed = k, this.maintained = $, this.changedBeforeAdded = G, this.fixed = U;\n  }\n  var t = o.prototype;\n  return Object.defineProperty(t, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(t, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), t.caculateOrdered = function() {\n    var e = orderChanged(this.changedBeforeAdded, this.fixed), r = this.changed, D = [];\n    this.cacheOrdered = e.filter(function(N, k) {\n      var $ = N[0], G = N[1], U = r[k], z = U[0], X = U[1];\n      if ($ !== G)\n        return D.push([z, X]), !0;\n    }), this.cachePureChanged = D;\n  }, o;\n}();\nfunction diff$1(o, t, e) {\n  var r = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, D = e || function(J) {\n    return J;\n  }, N = [], k = [], $ = [], G = o.map(D), U = t.map(D), z = new r(), X = new r(), V = [], Y = [], q = {}, W = [], K = 0, Z = 0;\n  return G.forEach(function(J, Q) {\n    z.set(J, Q);\n  }), U.forEach(function(J, Q) {\n    X.set(J, Q);\n  }), G.forEach(function(J, Q) {\n    var et = X.get(J);\n    typeof et > \"u\" ? (++Z, k.push(Q)) : q[et] = Z;\n  }), U.forEach(function(J, Q) {\n    var et = z.get(J);\n    typeof et > \"u\" ? (N.push(Q), ++K) : ($.push([et, Q]), Z = q[Q] || 0, V.push([et - Z, Q - K]), Y.push(Q === et), et !== Q && W.push([et, Q]));\n  }), k.reverse(), new Result(o, t, N, k, W, $, V, Y);\n}\nvar ListDiffer = /* @__PURE__ */ function() {\n  function o(e, r) {\n    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);\n  }\n  var t = o.prototype;\n  return t.update = function(e) {\n    var r = [].slice.call(e), D = diff$1(this.list, r, this.findKeyCallback);\n    return this.list = r, D;\n  }, o;\n}(), FUNCTION = \"function\", OBJECT = \"object\", STRING = \"string\", NUMBER = \"number\", UNDEFINED = \"undefined\", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {\n  cm: function(o) {\n    return o * 96 / 2.54;\n  },\n  mm: function(o) {\n    return o * 96 / 254;\n  },\n  in: function(o) {\n    return o * 96;\n  },\n  pt: function(o) {\n    return o * 96 / 72;\n  },\n  pc: function(o) {\n    return o * 96 / 6;\n  },\n  \"%\": function(o, t) {\n    return o * t / 100;\n  },\n  vw: function(o, t) {\n    return t === void 0 && (t = window.innerWidth), o / 100 * t;\n  },\n  vh: function(o, t) {\n    return t === void 0 && (t = window.innerHeight), o / 100 * t;\n  },\n  vmax: function(o, t) {\n    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), o / 100 * t;\n  },\n  vmin: function(o, t) {\n    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), o / 100 * t;\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$3() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), D = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)\n      r[D] = N[k];\n  return r;\n}\nfunction dot(o, t, e, r) {\n  return (o * r + t * e) / (e + r);\n}\nfunction isUndefined(o) {\n  return typeof o === UNDEFINED;\n}\nfunction isObject$2(o) {\n  return o && typeof o === OBJECT;\n}\nfunction isArray(o) {\n  return Array.isArray(o);\n}\nfunction isString(o) {\n  return typeof o === STRING;\n}\nfunction isNumber(o) {\n  return typeof o === NUMBER;\n}\nfunction isFunction$2(o) {\n  return typeof o === FUNCTION;\n}\nfunction isEqualSeparator(o, t) {\n  var e = o === \"\" || o == \" \", r = t === \"\" || t == \" \";\n  return r && e || o === t;\n}\nfunction findOpen(o, t, e, r, D) {\n  var N = findIgnore(o, t, e);\n  return N ? e : findClose(o, t, e + 1, r, D);\n}\nfunction findIgnore(o, t, e) {\n  if (!o.ignore)\n    return null;\n  var r = t.slice(Math.max(e - 3, 0), e + 3).join(\"\");\n  return new RegExp(o.ignore).exec(r);\n}\nfunction findClose(o, t, e, r, D) {\n  for (var N = function(U) {\n    var z = t[U].trim();\n    if (z === o.close && !findIgnore(o, t, U))\n      return {\n        value: U\n      };\n    var X = U, V = find$1(D, function(Y) {\n      var q = Y.open;\n      return q === z;\n    });\n    if (V && (X = findOpen(V, t, U, r, D)), X === -1)\n      return k = U, \"break\";\n    U = X, k = U;\n  }, k, $ = e; $ < r; ++$) {\n    var G = N($);\n    if ($ = k, typeof G == \"object\")\n      return G.value;\n    if (G === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction splitText(o, t) {\n  var e = isString(t) ? {\n    separator: t\n  } : t, r = e.separator, D = r === void 0 ? \",\" : r, N = e.isSeparateFirst, k = e.isSeparateOnlyOpenClose, $ = e.isSeparateOpenClose, G = $ === void 0 ? k : $, U = e.openCloseCharacters, z = U === void 0 ? OPEN_CLOSED_CHARACTERS : U, X = z.map(function(it) {\n    var st = it.open, at = it.close;\n    return st === at ? st : st + \"|\" + at;\n  }).join(\"|\"), V = \"(\\\\s*\" + D + \"\\\\s*|\" + X + \"|\\\\s+)\", Y = new RegExp(V, \"g\"), q = o.split(Y).filter(function(it) {\n    return it && it !== \"undefined\";\n  }), W = q.length, K = [], Z = [];\n  function J() {\n    return Z.length ? (K.push(Z.join(\"\")), Z = [], !0) : !1;\n  }\n  for (var Q = function(it) {\n    var st = q[it].trim(), at = it, ut = find$1(z, function(vt) {\n      var yt = vt.open;\n      return yt === st;\n    }), ft = find$1(z, function(vt) {\n      var yt = vt.close;\n      return yt === st;\n    });\n    if (ut) {\n      if (at = findOpen(ut, q, it, W, z), at !== -1 && G)\n        return J() && N || (K.push(q.slice(it, at + 1).join(\"\")), it = at, N) ? (et = it, \"break\") : (et = it, \"continue\");\n    } else if (ft && !findIgnore(ft, q, it)) {\n      var ct = __spreadArrays$3(z);\n      return ct.splice(z.indexOf(ft), 1), {\n        value: splitText(o, {\n          separator: D,\n          isSeparateFirst: N,\n          isSeparateOnlyOpenClose: k,\n          isSeparateOpenClose: G,\n          openCloseCharacters: ct\n        })\n      };\n    } else if (isEqualSeparator(st, D) && !k)\n      return J(), N ? (et = it, \"break\") : (et = it, \"continue\");\n    at === -1 && (at = W - 1), Z.push(q.slice(it, at + 1).join(\"\")), it = at, et = it;\n  }, et, nt = 0; nt < W; ++nt) {\n    var tt = Q(nt);\n    if (nt = et, typeof tt == \"object\")\n      return tt.value;\n    if (tt === \"break\")\n      break;\n  }\n  return Z.length && K.push(Z.join(\"\")), K;\n}\nfunction splitSpace(o) {\n  return splitText(o, \"\");\n}\nfunction splitComma(o) {\n  return splitText(o, \",\");\n}\nfunction splitBracket(o) {\n  var t = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(o);\n  return !t || t.length < 4 ? {} : {\n    prefix: t[1],\n    value: t[2],\n    suffix: t[3]\n  };\n}\nfunction splitUnit(o) {\n  var t = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(o);\n  if (!t)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var e = t[1], r = t[2], D = t[3];\n  return {\n    prefix: e,\n    unit: D,\n    value: parseFloat(r)\n  };\n}\nfunction camelize(o) {\n  return o.replace(/[\\s-_]+([^\\s-_])/g, function(t, e) {\n    return e.toUpperCase();\n  });\n}\nfunction decamelize(o, t) {\n  return t === void 0 && (t = \"-\"), o.replace(/([a-z])([A-Z])/g, function(e, r, D) {\n    return \"\" + r + t + D.toLowerCase();\n  });\n}\nfunction now() {\n  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();\n}\nfunction findIndex(o, t, e) {\n  e === void 0 && (e = -1);\n  for (var r = o.length, D = 0; D < r; ++D)\n    if (t(o[D], D, o))\n      return D;\n  return e;\n}\nfunction find$1(o, t, e) {\n  var r = findIndex(o, t);\n  return r > -1 ? o[r] : e;\n}\nvar requestAnimationFrame$1 = /* @__PURE__ */ function() {\n  var o = now(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    var r = now(), D = setTimeout(function() {\n      e(r - o);\n    }, 1e3 / 60);\n    return D;\n  };\n}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {\n  var o = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return o ? o.bind(window) : function(t) {\n    clearTimeout(t);\n  };\n}();\nfunction getKeys(o) {\n  return Object.keys(o);\n}\nfunction convertUnitSize(o, t) {\n  var e = splitUnit(o), r = e.value, D = e.unit;\n  if (isObject$2(t)) {\n    var N = t[D];\n    if (N) {\n      if (isFunction$2(N))\n        return N(r);\n      if (DEFAULT_UNIT_PRESETS[D])\n        return DEFAULT_UNIT_PRESETS[D](r, N);\n    }\n  } else if (D === \"%\")\n    return r * t / 100;\n  return DEFAULT_UNIT_PRESETS[D] ? DEFAULT_UNIT_PRESETS[D](r) : r;\n}\nfunction between(o, t, e) {\n  return Math.max(t, Math.min(o, e));\n}\nfunction checkBoundSize(o, t, e, r) {\n  return r === void 0 && (r = o[0] / o[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / r, TINY_NUM$1)], [throttle(t[1] * r, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(D) {\n    return D.every(function(N, k) {\n      var $ = t[k], G = throttle($, TINY_NUM$1);\n      return e ? N <= $ || N <= G : N >= $ || N >= G;\n    });\n  })[0] || o;\n}\nfunction calculateBoundSize(o, t, e, r) {\n  if (!r)\n    return o.map(function(Y, q) {\n      return between(Y, t[q], e[q]);\n    });\n  var D = o[0], N = o[1], k = r === !0 ? D / N : r, $ = checkBoundSize(o, t, !1, k), G = $[0], U = $[1], z = checkBoundSize(o, e, !0, k), X = z[0], V = z[1];\n  return D < G || N < U ? (D = G, N = U) : (D > X || N > V) && (D = X, N = V), [D, N];\n}\nfunction sum(o) {\n  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)\n    e += o[r];\n  return e;\n}\nfunction average(o) {\n  for (var t = o.length, e = 0, r = t - 1; r >= 0; --r)\n    e += o[r];\n  return t ? e / t : 0;\n}\nfunction getRad$1(o, t) {\n  var e = t[0] - o[0], r = t[1] - o[1], D = Math.atan2(r, e);\n  return D >= 0 ? D : D + Math.PI * 2;\n}\nfunction getCenterPoint(o) {\n  return [0, 1].map(function(t) {\n    return average(o.map(function(e) {\n      return e[t];\n    }));\n  });\n}\nfunction getShapeDirection(o) {\n  var t = getCenterPoint(o), e = getRad$1(t, o[0]), r = getRad$1(t, o[1]);\n  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;\n}\nfunction getDist$2(o, t) {\n  return Math.sqrt(Math.pow((t ? t[0] : 0) - o[0], 2) + Math.pow((t ? t[1] : 0) - o[1], 2));\n}\nfunction throttle(o, t) {\n  if (!t)\n    return o;\n  var e = 1 / t;\n  return Math.round(o / t) / e;\n}\nfunction throttleArray(o, t) {\n  return o.forEach(function(e, r) {\n    o[r] = throttle(o[r], t);\n  }), o;\n}\nfunction hasClass(o, t) {\n  return o.classList ? o.classList.contains(t) : !!o.className.match(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\"));\n}\nfunction addClass(o, t) {\n  o.classList ? o.classList.add(t) : o.className += \" \" + t;\n}\nfunction removeClass(o, t) {\n  if (o.classList)\n    o.classList.remove(t);\n  else {\n    var e = new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\");\n    o.className = o.className.replace(e, \" \");\n  }\n}\nfunction addEvent(o, t, e, r) {\n  o.addEventListener(t, e, r);\n}\nfunction removeEvent(o, t, e, r) {\n  o.removeEventListener(t, e, r);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$6 = function(o, t) {\n  return extendStatics$6 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$6(o, t);\n};\nfunction __extends$6(o, t) {\n  extendStatics$6(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$6 = function() {\n  return __assign$6 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$6.apply(this, arguments);\n};\nfunction __rest$2(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)\n      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);\n  return e;\n}\nfunction __spreadArrays$2() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), D = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)\n      r[D] = N[k];\n  return r;\n}\nfunction isDiff(o, t) {\n  if (o === t)\n    return !1;\n  for (var e in o)\n    if (!(e in t))\n      return !0;\n  for (var e in t)\n    if (o[e] !== t[e])\n      return !0;\n  return !1;\n}\nfunction diffObject(o, t) {\n  var e = Object.keys(o), r = Object.keys(t), D = diff$1(e, r, function(G) {\n    return G;\n  }), N = {}, k = {}, $ = {};\n  return D.added.forEach(function(G) {\n    var U = r[G];\n    N[U] = t[U];\n  }), D.removed.forEach(function(G) {\n    var U = e[G];\n    k[U] = o[U];\n  }), D.maintained.forEach(function(G) {\n    var U = G[0], z = e[U], X = [o[z], t[z]];\n    o[z] !== t[z] && ($[z] = X);\n  }), {\n    added: N,\n    removed: k,\n    changed: $\n  };\n}\nfunction executeHooks(o) {\n  o.forEach(function(t) {\n    t();\n  });\n}\nfunction fillKeys(o) {\n  var t = 0;\n  return o.map(function(e) {\n    return e == null ? \"$compat\" + ++t : \"\" + e;\n  });\n}\nfunction createProvider(o, t, e, r) {\n  if (isString(o) || isNumber(o))\n    return new TextProvider(\"text_\" + o, t, e, r, null, {});\n  var D = typeof o.type == \"string\" ? ElementProvider : o.type.prototype.render ? ComponentProvider : FunctionProvider;\n  return new D(o.type, t, e, r, o.ref, o.props);\n}\nfunction flat$1(o) {\n  var t = [];\n  return o.forEach(function(e) {\n    t = t.concat(isArray(e) ? flat$1(e) : e);\n  }), t;\n}\nfunction getAttributes(o) {\n  var t = o.className, e = __rest$2(o, [\"className\"]);\n  return t != null && (e.class = t), delete e.style, delete e.children, e;\n}\nfunction fillProps(o, t) {\n  if (!t)\n    return o;\n  for (var e in t)\n    isUndefined(o[e]) && (o[e] = t[e]);\n  return o;\n}\nfunction createElement(o, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var D = t || {}, N = D.key, k = D.ref, $ = __rest$2(D, [\"key\", \"ref\"]);\n  return {\n    type: o,\n    key: N,\n    ref: k,\n    props: __assign$6(__assign$6({}, $), {\n      children: flat$1(e).filter(function(G) {\n        return G != null && G !== !1;\n      })\n    })\n  };\n}\nvar Provider = /* @__PURE__ */ function() {\n  function o(e, r, D, N, k, $) {\n    $ === void 0 && ($ = {}), this.type = e, this.key = r, this.index = D, this.container = N, this.ref = k, this.props = $, this._providers = [];\n  }\n  var t = o.prototype;\n  return t._should = function(e, r) {\n    return !0;\n  }, t._update = function(e, r, D, N) {\n    if (this.base && !isString(r) && !N && !this._should(r.props, D))\n      return !1;\n    this.original = r, this._setState(D);\n    var k = this.props;\n    return isString(r) || (this.props = r.props, this.ref = r.ref), this._render(e, this.base ? k : {}, D), !0;\n  }, t._mounted = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._setState = function(e) {\n  }, t._updated = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._destroy = function() {\n    var e = this.ref;\n    e && e(null);\n  }, o;\n}();\nfunction diffAttributes(o, t, e) {\n  var r = diffObject(o, t), D = r.added, N = r.removed, k = r.changed;\n  for (var $ in D)\n    e.setAttribute($, D[$]);\n  for (var $ in k)\n    e.setAttribute($, k[$][1]);\n  for (var $ in N)\n    e.removeAttribute($);\n}\nfunction diffEvents(o, t, e) {\n  var r = diffObject(o, t), D = r.added, N = r.removed, k = r.changed;\n  for (var $ in N)\n    e.removeEventListener($);\n  for (var $ in D)\n    e.addEventListener($, D[$]);\n  for (var $ in k)\n    e.removeEventListener($), e.addEventListener($, k[$][1]);\n  for (var $ in N)\n    e.removeEventListener($);\n}\nfunction diffStyle(o, t, e) {\n  var r = e.style, D = diffObject(o, t), N = D.added, k = D.removed, $ = D.changed;\n  for (var G in N) {\n    var U = decamelize(G, \"-\");\n    r.setProperty ? r.setProperty(U, N[G]) : r[U] = N[G];\n  }\n  for (var G in $) {\n    var U = decamelize(G, \"-\");\n    r.setProperty ? r.setProperty(U, $[G][1]) : r[U] = $[G][1];\n  }\n  for (var G in k) {\n    var U = decamelize(G, \"-\");\n    r.removeProperty ? r.removeProperty(U) : r[U] = \"\";\n  }\n}\nfunction splitProps(o) {\n  var t = {}, e = {};\n  for (var r in o)\n    r.indexOf(\"on\") === 0 ? e[r.replace(\"on\", \"\").toLowerCase()] = o[r] : t[r] = o[r];\n  return {\n    attributes: t,\n    events: e\n  };\n}\nvar TextProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(r) {\n    var D = this, N = !this.base;\n    return N && (this.base = document.createTextNode(this.type.replace(\"text_\", \"\"))), r.push(function() {\n      N ? D._mounted() : D._updated();\n    }), !0;\n  }, e._unmount = function() {\n    this.base.parentNode.removeChild(this.base);\n  }, t;\n}(Provider), ElementProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.events = {}, r._isSVG = !1, r;\n  }\n  var e = t.prototype;\n  return e.addEventListener = function(r, D) {\n    var N = this.events;\n    N[r] = function(k) {\n      k.nativeEvent = k, D(k);\n    }, this.base.addEventListener(r, N[r]);\n  }, e.removeEventListener = function(r) {\n    var D = this.events;\n    this.base.removeEventListener(r, D[r]), delete D[r];\n  }, e._should = function(r) {\n    return isDiff(this.props, r);\n  }, e._render = function(r, D) {\n    var N = this, k = !this.base;\n    if (k) {\n      var $ = this._hasSVG();\n      this._isSVG = $;\n      var G = this.props.portalContainer;\n      if (!G) {\n        var U = this.type;\n        $ ? G = document.createElementNS(\"http://www.w3.org/2000/svg\", U) : G = document.createElement(U);\n      }\n      this.base = G;\n    }\n    renderProviders(this, this._providers, this.props.children, r, null);\n    var z = this.base, X = splitProps(D), V = X.attributes, Y = X.events, q = splitProps(this.props), W = q.attributes, K = q.events;\n    return diffAttributes(getAttributes(V), getAttributes(W), z), diffEvents(Y, K, this), diffStyle(D.style || {}, this.props.style || {}, z), r.push(function() {\n      k ? N._mounted() : N._updated();\n    }), !0;\n  }, e._unmount = function() {\n    var r = this.events, D = this.base;\n    for (var N in r)\n      D.removeEventListener(N, r[N]);\n    this._providers.forEach(function(k) {\n      k._unmount();\n    }), this.events = {}, this.props.portalContainer || D.parentNode.removeChild(D);\n  }, e._hasSVG = function() {\n    if (this._isSVG || this.type === \"svg\")\n      return !0;\n    var r = findContainerNode(this.container);\n    return r && \"ownerSVGElement\" in r;\n  }, t;\n}(Provider);\nfunction findContainerNode(o) {\n  if (!o)\n    return null;\n  var t = o.base;\n  return t instanceof Node ? t : findContainerNode(o.container);\n}\nfunction findDOMNode(o) {\n  if (!o)\n    return null;\n  if (o instanceof Node)\n    return o;\n  var t = o.$_provider._providers;\n  return t.length ? findDOMNode(t[0].base) : null;\n}\nvar FunctionProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(r) {\n    var D = this.type(this.props);\n    return renderProviders(this, this._providers, D ? [D] : [], r), !0;\n  }, e._unmount = function() {\n    this._providers.forEach(function(r) {\n      r._unmount();\n    });\n  }, t;\n}(Provider), ContainerProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t(r) {\n    var D = o.call(this, \"container\", \"container\", 0, null) || this;\n    return D.base = r, D;\n  }\n  var e = t.prototype;\n  return e._render = function() {\n    return !0;\n  }, e._unmount = function() {\n  }, t;\n}(Provider), ComponentProvider = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t(r, D, N, k, $, G) {\n    return G === void 0 && (G = {}), o.call(this, r, D, N, k, $, fillProps(G, r.defaultProps)) || this;\n  }\n  var e = t.prototype;\n  return e._should = function(r, D) {\n    return this.base.shouldComponentUpdate(fillProps(r, this.type.defaultProps), D || this.base.state);\n  }, e._render = function(r, D) {\n    var N = this;\n    this.props = fillProps(this.props, this.type.defaultProps);\n    var k = !this.base;\n    k ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;\n    var $ = this.base, G = $.state, U = $.render();\n    U && U.props && !U.props.children.length && (U.props.children = this.props.children), renderProviders(this, this._providers, U ? [U] : [], r), r.push(function() {\n      k ? (N._mounted(), $.componentDidMount()) : (N._updated(), $.componentDidUpdate(D, G));\n    });\n  }, e._setState = function(r) {\n    var D = this.base;\n    !D || !r || (D.state = r);\n  }, e._unmount = function() {\n    this._providers.forEach(function(r) {\n      r._unmount();\n    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();\n  }, t;\n}(Provider), Component = /* @__PURE__ */ function() {\n  function o(e) {\n    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};\n  }\n  var t = o.prototype;\n  return t.shouldComponentUpdate = function(e, r) {\n    return !0;\n  }, t.render = function() {\n    return null;\n  }, t.setState = function(e, r, D) {\n    var N = this;\n    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$6(__assign$6({}, this.$_state), e), D ? this.$_setState(r, D) : this.$_timer = setTimeout(function() {\n      N.$_timer = 0, N.$_setState(r, D);\n    });\n  }, t.forceUpdate = function(e) {\n    this.setState({}, e, !0);\n  }, t.componentDidMount = function() {\n  }, t.componentDidUpdate = function(e, r) {\n  }, t.componentWillUnmount = function() {\n  }, t.$_setState = function(e, r) {\n    var D = [], N = this.$_provider, k = renderProviders(N.container, [N], [N.original], D, __assign$6(__assign$6({}, this.state), this.$_state), r);\n    k && (e && D.push(e), executeHooks(D));\n  }, o;\n}(), PureComponent = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.shouldComponentUpdate = function(r, D) {\n    return isDiff(this.props, r) || isDiff(this.state, D);\n  }, t;\n}(Component), _Portal = /* @__PURE__ */ function(o) {\n  __extends$6(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    var r = this.props, D = r.element, N = r.container;\n    this._portalProvider = new ContainerProvider(N), renderProvider(D, N, this._portalProvider);\n  }, e.componentDidUpdate = function() {\n    var r = this.props, D = r.element, N = r.container;\n    renderProvider(D, N, this._portalProvider);\n  }, e.componentWillUnmount = function() {\n    var r = this.props.container;\n    renderProvider(null, r, this._portalProvider), this._portalProvider = null;\n  }, t;\n}(PureComponent);\nfunction updateProvider(o, t, e) {\n  var r = [];\n  renderProviders(o, o._providers, t, r, e), executeHooks(r);\n}\nfunction getNextSibiling(o, t) {\n  for (var e = o._providers, r = e.length, D = t.index + 1; D < r; ++D) {\n    var N = findDOMNode(e[D].base);\n    if (N)\n      return N;\n  }\n  return null;\n}\nfunction diffProviders(o, t, e) {\n  var r = e.map(function(G) {\n    return isString(G) ? null : G.key;\n  }), D = fillKeys(t.map(function(G) {\n    return G.key;\n  })), N = fillKeys(r), k = diff$1(D, N, function(G) {\n    return G;\n  });\n  k.removed.forEach(function(G) {\n    t.splice(G, 1)[0]._unmount();\n  }), k.ordered.forEach(function(G) {\n    var U = G[0], z = G[1], X = t.splice(U, 1)[0];\n    t.splice(z, 0, X);\n    var V = findDOMNode(X.base), Y = findDOMNode(t[z + 1] && t[z + 1].base);\n    V && V.parentNode.insertBefore(V, Y);\n  }), k.added.forEach(function(G) {\n    t.splice(G, 0, createProvider(e[G], r[G], G, o));\n  });\n  var $ = k.maintained.filter(function(G) {\n    G[0];\n    var U = G[1], z = e[U], X = t[U], V = isString(z) ? \"text_\" + z : z.type;\n    return V !== X.type ? (X._unmount(), t.splice(U, 1, createProvider(z, r[U], U, o)), !0) : (X.index = U, !1);\n  });\n  return __spreadArrays$2(k.added, $.map(function(G) {\n    G[0];\n    var U = G[1];\n    return U;\n  }));\n}\nfunction renderProviders(o, t, e, r, D, N) {\n  var k = diffProviders(o, t, e), $ = t.filter(function(U, z) {\n    return U._update(r, e[z], D, N);\n  }), G = findContainerNode(o);\n  return G && k.reverse().forEach(function(U) {\n    var z = t[U], X = findDOMNode(z.base);\n    if (X && G !== X && !X.parentNode) {\n      var V = getNextSibiling(o, z);\n      G.insertBefore(X, V);\n    }\n  }), $.length > 0;\n}\nfunction renderProvider(o, t, e) {\n  e === void 0 && (e = t.__REACT_COMPAT__);\n  var r = !!e;\n  return e || (e = new ContainerProvider(t)), updateProvider(e, o ? [o] : []), r || (t.__REACT_COMPAT__ = e), e;\n}\nfunction render(o, t, e) {\n  var r = t.__REACT_COMPAT__;\n  o && !r && (t.innerHTML = \"\"), renderProvider(o, t, r), e && e();\n}\nfunction createPortal(o, t) {\n  return createElement(_Portal, {\n    element: o,\n    container: t\n  });\n}\nvar version = \"simple-1.1.0\";\nfunction some(o, t) {\n  for (var e = o.length, r = 0; r < e; ++r)\n    if (t(o[r], r))\n      return !0;\n  return !1;\n}\nfunction find(o, t) {\n  for (var e = o.length, r = 0; r < e; ++r)\n    if (t(o[r], r))\n      return o[r];\n  return null;\n}\nfunction getUserAgentString(o) {\n  var t = o;\n  if (typeof t > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    t = navigator.userAgent || \"\";\n  }\n  return t.toLowerCase();\n}\nfunction execRegExp(o, t) {\n  try {\n    return new RegExp(o, \"g\").exec(t);\n  } catch {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var o = navigator.userAgentData, t = o.brands || o.uaList;\n  return !!(t && t.length);\n}\nfunction findVersion(o, t) {\n  var e = execRegExp(\"(\" + o + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", t);\n  return e ? e[3] : \"\";\n}\nfunction convertVersion(o) {\n  return o.replace(/_/g, \".\");\n}\nfunction findPreset(o, t) {\n  var e = null, r = \"-1\";\n  return some(o, function(D) {\n    var N = execRegExp(\"(\" + D.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", t);\n    return !N || D.brand ? !1 : (e = D, r = N[3] || \"-1\", D.versionAlias ? r = D.versionAlias : D.versionTest && (r = findVersion(D.versionTest.toLowerCase(), t) || r), r = convertVersion(r), !0);\n  }), {\n    preset: e,\n    version: r\n  };\n}\nfunction findPresetBrand(o, t) {\n  var e = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return some(o, function(r) {\n    var D = findBrand(t, r);\n    return D ? (e.brand = r.id, e.version = r.versionAlias || D.version, e.version !== \"-1\") : !1;\n  }), e;\n}\nfunction findBrand(o, t) {\n  return find(o, function(e) {\n    var r = e.brand;\n    return execRegExp(\"\" + t.test, r.toLowerCase());\n  });\n}\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}], OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction isWebView(o) {\n  return !!findPreset(WEBVIEW_PRESETS, o).preset;\n}\nfunction getLegacyAgent(o) {\n  var t = getUserAgentString(o), e = !!/mobi/g.exec(t), r = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(t),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, D = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, N = findPreset(BROWSER_PRESETS, t), k = N.preset, $ = N.version, G = findPreset(OS_PRESETS, t), U = G.preset, z = G.version, X = findPreset(CHROMIUM_PRESETS, t);\n  if (r.chromium = !!X.preset, r.chromiumVersion = X.version, !r.chromium) {\n    var V = findPreset(WEBKIT_PRESETS, t);\n    r.webkit = !!V.preset, r.webkitVersion = V.version;\n  }\n  return U && (D.name = U.id, D.version = z, D.majorVersion = parseInt(z, 10)), k && (r.name = k.id, r.version = $, r.webview && D.name === \"ios\" && r.name !== \"safari\" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {\n    browser: r,\n    os: D,\n    isMobile: e,\n    isHints: !1\n  };\n}\nfunction getClientHintsAgent(o) {\n  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = o && o.fullVersionList, D = t.mobile || !1, N = e[0], k = (o && o.platform || t.platform || navigator.platform).toLowerCase(), $ = {\n    name: N.brand,\n    version: N.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())\n  }, G = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  $.webkit = !$.chromium && some(WEBKIT_PRESETS, function(q) {\n    return findBrand(e, q);\n  });\n  var U = findPresetBrand(CHROMIUM_PRESETS, e);\n  if ($.chromium = !!U.brand, $.chromiumVersion = U.version, !$.chromium) {\n    var z = findPresetBrand(WEBKIT_PRESETS, e);\n    $.webkit = !!z.brand, $.webkitVersion = z.version;\n  }\n  var X = find(OS_PRESETS, function(q) {\n    return new RegExp(\"\" + q.test, \"g\").exec(k);\n  });\n  if (G.name = X ? X.id : \"\", o && (G.version = o.platformVersion), r && r.length) {\n    var V = findPresetBrand(BROWSER_PRESETS, r);\n    $.name = V.brand || $.name, $.version = V.version || $.version;\n  } else {\n    var Y = findPresetBrand(BROWSER_PRESETS, e);\n    $.name = Y.brand || $.name, $.version = Y.brand && o ? o.uaFullVersion : Y.version;\n  }\n  return $.webkit && (G.name = D ? \"ios\" : \"mac\"), G.name === \"ios\" && $.webview && ($.version = \"-1\"), G.version = convertVersion(G.version), $.version = convertVersion($.version), G.majorVersion = parseInt(G.version, 10), $.majorVersion = parseInt($.version, 10), {\n    browser: $,\n    os: G,\n    isMobile: D,\n    isHints: !0\n  };\n}\nfunction agent$1(o) {\n  return typeof o > \"u\" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(o);\n}\nfunction add(o, t, e, r, D, N) {\n  for (var k = 0; k < D; ++k) {\n    var $ = e + k * D, G = r + k * D;\n    o[$] += o[G] * N, t[$] += t[G] * N;\n  }\n}\nfunction swap(o, t, e, r, D) {\n  for (var N = 0; N < D; ++N) {\n    var k = e + N * D, $ = r + N * D, G = o[k], U = t[k];\n    o[k] = o[$], o[$] = G, t[k] = t[$], t[$] = U;\n  }\n}\nfunction divide(o, t, e, r, D) {\n  for (var N = 0; N < r; ++N) {\n    var k = e + N * r;\n    o[k] /= D, t[k] /= D;\n  }\n}\nfunction ignoreDimension(o, t, e) {\n  e === void 0 && (e = Math.sqrt(o.length));\n  for (var r = o.slice(), D = 0; D < e; ++D)\n    r[D * e + t - 1] = 0, r[(t - 1) * e + D] = 0;\n  return r[(t - 1) * (e + 1)] = 1, r;\n}\nfunction invert(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = o.slice(), r = createIdentityMatrix(t), D = 0; D < t; ++D) {\n    var N = t * D + D;\n    if (!throttle(e[N], TINY_NUM$1)) {\n      for (var k = D + 1; k < t; ++k)\n        if (e[t * D + k]) {\n          swap(e, r, D, k, t);\n          break;\n        }\n    }\n    if (!throttle(e[N], TINY_NUM$1))\n      return [];\n    divide(e, r, D, t, e[N]);\n    for (var k = 0; k < t; ++k) {\n      var $ = k, G = k + D * t, U = e[G];\n      !throttle(U, TINY_NUM$1) || D === k || add(e, r, $, D, t, -U);\n    }\n  }\n  return r;\n}\nfunction transpose(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = [], r = 0; r < t; ++r)\n    for (var D = 0; D < t; ++D)\n      e[D * t + r] = o[t * r + D];\n  return e;\n}\nfunction getOrigin(o, t) {\n  t === void 0 && (t = Math.sqrt(o.length));\n  for (var e = [], r = o[t * t - 1], D = 0; D < t - 1; ++D)\n    e[D] = o[t * (t - 1) + D] / r;\n  return e[t - 1] = 0, e;\n}\nfunction fromTranslation(o, t) {\n  for (var e = createIdentityMatrix(t), r = 0; r < t - 1; ++r)\n    e[t * (t - 1) + r] = o[r] || 0;\n  return e;\n}\nfunction convertPositionMatrix(o, t) {\n  for (var e = o.slice(), r = o.length; r < t - 1; ++r)\n    e[r] = 0;\n  return e[t - 1] = 1, e;\n}\nfunction convertDimension(o, t, e) {\n  if (t === void 0 && (t = Math.sqrt(o.length)), t === e)\n    return o;\n  for (var r = createIdentityMatrix(e), D = Math.min(t, e), N = 0; N < D - 1; ++N) {\n    for (var k = 0; k < D - 1; ++k)\n      r[N * e + k] = o[N * t + k];\n    r[(N + 1) * e - 1] = o[(N + 1) * t - 1], r[(e - 1) * e + N] = o[(t - 1) * t + N];\n  }\n  return r[e * e - 1] = o[t * t - 1], r;\n}\nfunction multiplies(o) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  var r = createIdentityMatrix(o);\n  return t.forEach(function(D) {\n    r = multiply(r, D, o);\n  }), r;\n}\nfunction multiply(o, t, e) {\n  e === void 0 && (e = Math.sqrt(o.length));\n  var r = [], D = o.length / e, N = t.length / D;\n  if (D) {\n    if (!N)\n      return o;\n  } else\n    return t;\n  for (var k = 0; k < e; ++k)\n    for (var $ = 0; $ < N; ++$) {\n      r[$ * e + k] = 0;\n      for (var G = 0; G < D; ++G)\n        r[$ * e + k] += o[G * e + k] * t[$ * D + G];\n    }\n  return r;\n}\nfunction plus(o, t) {\n  for (var e = Math.min(o.length, t.length), r = o.slice(), D = 0; D < e; ++D)\n    r[D] = r[D] + t[D];\n  return r;\n}\nfunction minus(o, t) {\n  for (var e = Math.min(o.length, t.length), r = o.slice(), D = 0; D < e; ++D)\n    r[D] = r[D] - t[D];\n  return r;\n}\nfunction convertCSStoMatrix(o, t) {\n  return t === void 0 && (t = o.length === 6), t ? [o[0], o[1], 0, o[2], o[3], 0, o[4], o[5], 1] : o;\n}\nfunction convertMatrixtoCSS(o, t) {\n  return t === void 0 && (t = o.length === 9), t ? [o[0], o[1], o[3], o[4], o[6], o[7]] : o;\n}\nfunction calculate(o, t, e) {\n  e === void 0 && (e = t.length);\n  var r = multiply(o, t, e), D = r[e - 1];\n  return r.map(function(N) {\n    return N / D;\n  });\n}\nfunction rotateX3d(o, t) {\n  return multiply(o, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateY3d(o, t) {\n  return multiply(o, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateZ3d(o, t) {\n  return multiply(o, createRotateMatrix(t, 4));\n}\nfunction scale3d(o, t) {\n  var e = t[0], r = e === void 0 ? 1 : e, D = t[1], N = D === void 0 ? 1 : D, k = t[2], $ = k === void 0 ? 1 : k;\n  return multiply(o, [r, 0, 0, 0, 0, N, 0, 0, 0, 0, $, 0, 0, 0, 0, 1], 4);\n}\nfunction rotate(o, t) {\n  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(o, 3));\n}\nfunction translate3d(o, t) {\n  var e = t[0], r = e === void 0 ? 0 : e, D = t[1], N = D === void 0 ? 0 : D, k = t[2], $ = k === void 0 ? 0 : k;\n  return multiply(o, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, N, $, 1], 4);\n}\nfunction matrix3d(o, t) {\n  return multiply(o, t, 4);\n}\nfunction createRotateMatrix(o, t) {\n  var e = Math.cos(o), r = Math.sin(o), D = createIdentityMatrix(t);\n  return D[0] = e, D[1] = r, D[t] = -r, D[t + 1] = e, D;\n}\nfunction createIdentityMatrix(o) {\n  for (var t = o * o, e = [], r = 0; r < t; ++r)\n    e[r] = r % (o + 1) ? 0 : 1;\n  return e;\n}\nfunction createScaleMatrix(o, t) {\n  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), D = 0; D < r; ++D)\n    e[(t + 1) * D] = o[D];\n  return e;\n}\nfunction createOriginMatrix(o, t) {\n  for (var e = createIdentityMatrix(t), r = Math.min(o.length, t - 1), D = 0; D < r; ++D)\n    e[t * (t - 1) + D] = o[D];\n  return e;\n}\nfunction createWarpMatrix(o, t, e, r, D, N, k, $) {\n  var G = o[0], U = o[1], z = t[0], X = t[1], V = e[0], Y = e[1], q = r[0], W = r[1], K = D[0], Z = D[1], J = N[0], Q = N[1], et = k[0], nt = k[1], tt = $[0], it = $[1], st = [G, 0, z, 0, V, 0, q, 0, U, 0, X, 0, Y, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, G, 0, z, 0, V, 0, q, 0, U, 0, X, 0, Y, 0, W, 0, 1, 0, 1, 0, 1, 0, 1, -K * G, -Z * G, -J * z, -Q * z, -et * V, -nt * V, -tt * q, -it * q, -K * U, -Z * U, -J * X, -Q * X, -et * Y, -nt * Y, -tt * W, -it * W], at = invert(st, 8);\n  if (!at.length)\n    return [];\n  var ut = multiply(at, [K, Z, J, Q, et, nt, tt, it], 8);\n  return ut[8] = 1, convertDimension(transpose(ut), 3, 4);\n}\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction parseMat(o) {\n  return toMat(parse$1(o));\n}\nfunction calculateMatrixDist(o, t) {\n  var e = calculate(o, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;\n  return [e[0] / r, e[1] / r, e[2] / r];\n}\nfunction toMat(o) {\n  var t = createMatrix();\n  return o.forEach(function(e) {\n    var r = e.matrixFunction, D = e.functionValue;\n    r && (t = r(t, D));\n  }), t;\n}\nfunction parse$1(o) {\n  var t = isArray(o) ? o : splitSpace(o);\n  return t.map(function(e) {\n    var r = splitBracket(e), D = r.prefix, N = r.value, k = null, $ = D, G = \"\";\n    if (D === \"translate\" || D === \"translateX\" || D === \"translate3d\") {\n      var U = splitComma(N).map(function(ut) {\n        return parseFloat(ut);\n      }), z = U[0], X = U[1], V = X === void 0 ? 0 : X, Y = U[2], q = Y === void 0 ? 0 : Y;\n      k = translate3d, G = [z, V, q];\n    } else if (D === \"translateY\") {\n      var V = parseFloat(N);\n      k = translate3d, G = [0, V, 0];\n    } else if (D === \"translateZ\") {\n      var q = parseFloat(N);\n      k = translate3d, G = [0, 0, q];\n    } else if (D === \"scale\" || D === \"scale3d\") {\n      var W = splitComma(N).map(function(ut) {\n        return parseFloat(ut);\n      }), K = W[0], Z = W[1], J = Z === void 0 ? K : Z, Q = W[2], et = Q === void 0 ? 1 : Q;\n      k = scale3d, G = [K, J, et];\n    } else if (D === \"scaleX\") {\n      var K = parseFloat(N);\n      k = scale3d, G = [K, 1, 1];\n    } else if (D === \"scaleY\") {\n      var J = parseFloat(N);\n      k = scale3d, G = [1, J, 1];\n    } else if (D === \"scaleZ\") {\n      var et = parseFloat(N);\n      k = scale3d, G = [1, 1, et];\n    } else if (D === \"rotate\" || D === \"rotateZ\" || D === \"rotateX\" || D === \"rotateY\") {\n      var nt = splitUnit(N), tt = nt.unit, it = nt.value, st = tt === \"rad\" ? it : it * Math.PI / 180;\n      D === \"rotate\" || D === \"rotateZ\" ? ($ = \"rotateZ\", k = rotateZ3d) : D === \"rotateX\" ? k = rotateX3d : D === \"rotateY\" && (k = rotateY3d), G = st;\n    } else if (D === \"matrix3d\")\n      k = matrix3d, G = splitComma(N).map(function(ut) {\n        return parseFloat(ut);\n      });\n    else if (D === \"matrix\") {\n      var at = splitComma(N).map(function(ut) {\n        return parseFloat(ut);\n      });\n      k = matrix3d, G = [at[0], at[1], 0, 0, at[2], at[3], 0, 0, 0, 0, 1, 0, at[4], at[5], 0, 1];\n    } else\n      $ = \"\";\n    return {\n      name: D,\n      functionName: $,\n      value: N,\n      matrixFunction: k,\n      functionValue: G\n    };\n  });\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$5 = function(o, t) {\n  return extendStatics$5 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$5(o, t);\n};\nfunction __extends$5(o, t) {\n  extendStatics$5(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar findKeyCallback = typeof Map == \"function\" ? void 0 : function() {\n  var o = 0;\n  return function(t) {\n    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++o);\n  };\n}(), ChildrenDiffer = /* @__PURE__ */ function(o) {\n  __extends$5(t, o);\n  function t(e) {\n    return e === void 0 && (e = []), o.call(this, e, findKeyCallback) || this;\n  }\n  return t;\n}(ListDiffer);\nfunction diff(o, t) {\n  return diff$1(o, t, findKeyCallback);\n}\nconst ChildrenDiffer$1 = ChildrenDiffer;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$1() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), D = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)\n      r[D] = N[k];\n  return r;\n}\nfunction tinyThrottle(o) {\n  return throttle(o, TINY_NUM$1);\n}\nfunction isSameConstants(o, t) {\n  return o.every(function(e, r) {\n    return tinyThrottle(e - t[r]) === 0;\n  });\n}\nfunction isSamePoint(o, t) {\n  return !tinyThrottle(o[0] - t[0]) && !tinyThrottle(o[1] - t[1]);\n}\nfunction getAreaSize(o) {\n  return o.length < 3 ? 0 : Math.abs(sum(o.map(function(t, e) {\n    var r = o[e + 1] || o[0];\n    return t[0] * r[1] - r[0] * t[1];\n  }))) / 2;\n}\nfunction fitPoints(o, t) {\n  var e = t.width, r = t.height, D = t.left, N = t.top, k = getMinMaxs(o), $ = k.minX, G = k.minY, U = k.maxX, z = k.maxY, X = e / (U - $), V = r / (z - G);\n  return o.map(function(Y) {\n    return [D + (Y[0] - $) * X, N + (Y[1] - G) * V];\n  });\n}\nfunction getMinMaxs(o) {\n  var t = o.map(function(r) {\n    return r[0];\n  }), e = o.map(function(r) {\n    return r[1];\n  });\n  return {\n    minX: Math.min.apply(Math, t),\n    minY: Math.min.apply(Math, e),\n    maxX: Math.max.apply(Math, t),\n    maxY: Math.max.apply(Math, e)\n  };\n}\nfunction isInside(o, t, e) {\n  var r = o[0], D = o[1], N = getMinMaxs(t), k = N.minX, $ = N.maxX, G = [[k, D], [$, D]], U = getLinearConstants(G[0], G[1]), z = convertLines(t), X = [];\n  if (z.forEach(function(q) {\n    var W = getLinearConstants(q[0], q[1]), K = q[0];\n    if (isSameConstants(U, W))\n      X.push({\n        pos: o,\n        line: q,\n        type: \"line\"\n      });\n    else {\n      var Z = getPointsOnLines(getIntersectionPointsByConstants(U, W), [G, q]);\n      Z.forEach(function(J) {\n        q.some(function(Q) {\n          return isSamePoint(Q, J);\n        }) ? X.push({\n          pos: J,\n          line: q,\n          type: \"point\"\n        }) : tinyThrottle(K[1] - D) !== 0 && X.push({\n          pos: J,\n          line: q,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), !e && find$1(X, function(q) {\n    return q[0] === r;\n  }))\n    return !0;\n  var V = 0, Y = {};\n  return X.forEach(function(q) {\n    var W = q.pos, K = q.type, Z = q.line;\n    if (!(W[0] > r))\n      if (K === \"intersection\")\n        ++V;\n      else {\n        if (K === \"line\")\n          return;\n        if (K === \"point\") {\n          var J = find$1(Z, function(nt) {\n            return nt[1] !== D;\n          }), Q = Y[W[0]], et = J[1] > D ? 1 : -1;\n          Q ? Q !== et && ++V : Y[W[0]] = et;\n        }\n      }\n  }), V % 2 === 1;\n}\nfunction getLinearConstants(o, t) {\n  var e = o[0], r = o[1], D = t[0], N = t[1], k = D - e, $ = N - r;\n  Math.abs(k) < TINY_NUM$1 && (k = 0), Math.abs($) < TINY_NUM$1 && ($ = 0);\n  var G = 0, U = 0, z = 0;\n  return k ? $ ? (G = -$ / k, U = 1, z = -G * e - r) : (U = 1, z = -r) : $ && (G = -1, z = e), [G, U, z];\n}\nfunction getIntersectionPointsByConstants(o, t) {\n  var e = o[0], r = o[1], D = o[2], N = t[0], k = t[1], $ = t[2], G = e === 0 && N === 0, U = r === 0 && k === 0, z = [];\n  if (G && U)\n    return [];\n  if (G) {\n    var X = -D / r, V = -$ / k;\n    return X !== V ? [] : [[-1 / 0, X], [1 / 0, X]];\n  } else if (U) {\n    var Y = -D / e, q = -$ / N;\n    return Y !== q ? [] : [[Y, -1 / 0], [Y, 1 / 0]];\n  } else if (e === 0) {\n    var W = -D / r, K = -(k * W + $) / N;\n    z = [[K, W]];\n  } else if (N === 0) {\n    var W = -$ / k, K = -(r * W + D) / e;\n    z = [[K, W]];\n  } else if (r === 0) {\n    var K = -D / e, W = -(N * K + $) / k;\n    z = [[K, W]];\n  } else if (k === 0) {\n    var K = -$ / N, W = -(e * K + D) / r;\n    z = [[K, W]];\n  } else {\n    var K = (r * $ - k * D) / (k * e - r * N), W = -(e * K + D) / r;\n    z = [[K, W]];\n  }\n  return z.map(function(Z) {\n    return [Z[0], Z[1]];\n  });\n}\nfunction getPointsOnLines(o, t) {\n  var e = t.map(function(X) {\n    return [0, 1].map(function(V) {\n      return [Math.min(X[0][V], X[1][V]), Math.max(X[0][V], X[1][V])];\n    });\n  }), r = [];\n  if (o.length === 2) {\n    var D = o[0], N = D[0], k = D[1];\n    if (tinyThrottle(N - o[1][0])) {\n      if (!tinyThrottle(k - o[1][1])) {\n        var U = Math.max.apply(Math, e.map(function(X) {\n          return X[0][0];\n        })), z = Math.min.apply(Math, e.map(function(X) {\n          return X[0][1];\n        }));\n        if (tinyThrottle(U - z) > 0)\n          return [];\n        r = [[U, k], [z, k]];\n      }\n    } else {\n      var $ = Math.max.apply(Math, e.map(function(X) {\n        return X[1][0];\n      })), G = Math.min.apply(Math, e.map(function(X) {\n        return X[1][1];\n      }));\n      if (tinyThrottle($ - G) > 0)\n        return [];\n      r = [[N, $], [N, G]];\n    }\n  }\n  return r.length || (r = o.filter(function(X) {\n    var V = X[0], Y = X[1];\n    return e.every(function(q) {\n      return 0 <= tinyThrottle(V - q[0][0]) && 0 <= tinyThrottle(q[0][1] - V) && 0 <= tinyThrottle(Y - q[1][0]) && 0 <= tinyThrottle(q[1][1] - Y);\n    });\n  })), r.map(function(X) {\n    return [tinyThrottle(X[0]), tinyThrottle(X[1])];\n  });\n}\nfunction convertLines(o) {\n  return __spreadArrays$1(o.slice(1), [o[0]]).map(function(t, e) {\n    return [o[e], t];\n  });\n}\nfunction getOverlapPointInfos(o, t) {\n  var e = o.slice(), r = t.slice();\n  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(r) === -1 && r.reverse();\n  var D = convertLines(e), N = convertLines(r), k = D.map(function(z) {\n    return getLinearConstants(z[0], z[1]);\n  }), $ = N.map(function(z) {\n    return getLinearConstants(z[0], z[1]);\n  }), G = [];\n  k.forEach(function(z, X) {\n    var V = D[X], Y = [];\n    $.forEach(function(q, W) {\n      var K = getIntersectionPointsByConstants(z, q), Z = getPointsOnLines(K, [V, N[W]]);\n      Y.push.apply(Y, Z.map(function(J) {\n        return {\n          index1: X,\n          index2: W,\n          pos: J,\n          type: \"intersection\"\n        };\n      }));\n    }), Y.sort(function(q, W) {\n      return getDist$2(V[0], q.pos) - getDist$2(V[0], W.pos);\n    }), G.push.apply(G, Y), isInside(V[1], r) && G.push({\n      index1: X,\n      index2: -1,\n      pos: V[1],\n      type: \"inside\"\n    });\n  }), N.forEach(function(z, X) {\n    if (isInside(z[1], e)) {\n      var V = !1, Y = findIndex(G, function(q) {\n        var W = q.index2;\n        return W === X ? (V = !0, !1) : !!V;\n      });\n      Y === -1 && (V = !1, Y = findIndex(G, function(q) {\n        var W = q.index1, K = q.index2;\n        return W === -1 && K + 1 === X ? (V = !0, !1) : !!V;\n      })), Y === -1 ? G.push({\n        index1: -1,\n        index2: X,\n        pos: z[1],\n        type: \"inside\"\n      }) : G.splice(Y, 0, {\n        index1: -1,\n        index2: X,\n        pos: z[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var U = {};\n  return G.filter(function(z) {\n    var X = z.pos, V = X[0] + \"x\" + X[1];\n    return U[V] ? !1 : (U[V] = !0, !0);\n  });\n}\nfunction getOverlapPoints(o, t) {\n  var e = getOverlapPointInfos(o, t);\n  return e.map(function(r) {\n    var D = r.pos;\n    return D;\n  });\n}\nfunction getOverlapSize(o, t) {\n  var e = getOverlapPoints(o, t);\n  return getAreaSize(e);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$5 = function() {\n  return __assign$5 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$5.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var o = 0, t = 0, e = arguments.length; t < e; t++)\n    o += arguments[t].length;\n  for (var r = Array(o), D = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], k = 0, $ = N.length; k < $; k++, D++)\n      r[D] = N[k];\n  return r;\n}\nvar EventEmitter = /* @__PURE__ */ function() {\n  function o() {\n    this._events = {};\n  }\n  var t = o.prototype;\n  return t.on = function(e, r) {\n    if (isObject$2(e))\n      for (var D in e)\n        this.on(D, e[D]);\n    else\n      this._addEvent(e, r, {});\n    return this;\n  }, t.off = function(e, r) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var D in e)\n        this.off(D);\n    else if (!r)\n      this._events[e] = [];\n    else {\n      var N = this._events[e];\n      if (N) {\n        var k = findIndex(N, function($) {\n          return $.listener === r;\n        });\n        k > -1 && N.splice(k, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, r) {\n    var D = this;\n    return r && this._addEvent(e, r, {\n      once: !0\n    }), new Promise(function(N) {\n      D._addEvent(e, N, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, r) {\n    var D = this;\n    r === void 0 && (r = {});\n    var N = this._events[e];\n    if (!e || !N)\n      return !0;\n    var k = !1;\n    return r.eventType = e, r.stop = function() {\n      k = !0;\n    }, r.currentTarget = this, __spreadArrays(N).forEach(function($) {\n      $.listener(r), $.once && D.off(e, $.listener);\n    }), !k;\n  }, t.trigger = function(e, r) {\n    return r === void 0 && (r = {}), this.emit(e, r);\n  }, t._addEvent = function(e, r, D) {\n    var N = this._events;\n    N[e] = N[e] || [];\n    var k = N[e];\n    k.push(__assign$5({\n      listener: r\n    }, D));\n  }, o;\n}();\nconst EventEmitter$1 = EventEmitter;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$4 = function(o, t) {\n  return extendStatics$4 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$4(o, t);\n};\nfunction __extends$4(o, t) {\n  extendStatics$4(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$4 = function() {\n  return __assign$4 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$4.apply(this, arguments);\n};\nfunction getDefaultScrollPosition$1(o) {\n  var t = o.container;\n  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];\n}\nfunction checkDefaultScrollEvent(o, t) {\n  return o.addEventListener(\"scroll\", t), function() {\n    o.removeEventListener(\"scroll\", t);\n  };\n}\nfunction getContainerElement(o) {\n  if (o) {\n    if (isString(o))\n      return document.querySelector(o);\n  } else\n    return null;\n  if (isFunction$2(o))\n    return o();\n  if (o instanceof Element)\n    return o;\n  if (\"current\" in o)\n    return o.current;\n  if (\"value\" in o)\n    return o.value;\n}\nvar DragScroll = /* @__PURE__ */ function(o) {\n  __extends$4(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {\n      var D = r._currentOptions;\n      r._lock || !D || r.emit(\"scrollDrag\", {\n        next: function(N) {\n          r.checkScroll({\n            container: D.container,\n            inputEvent: N\n          });\n        }\n      });\n    }, r;\n  }\n  var e = t.prototype;\n  return e.dragStart = function(r, D) {\n    var N = getContainerElement(D.container);\n    if (!N) {\n      this._flag = !1;\n      return;\n    }\n    var k = 0, $ = 0, G = 0, U = 0;\n    if (N === document.body)\n      G = window.innerWidth, U = window.innerHeight;\n    else {\n      var z = N.getBoundingClientRect();\n      k = z.top, $ = z.left, G = z.width, U = z.height;\n    }\n    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {\n      top: k,\n      left: $,\n      width: G,\n      height: U\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], D), this._currentOptions = D, this._registerScrollEvent(D);\n  }, e.drag = function(r, D) {\n    if (clearTimeout(this._timer), !!this._flag) {\n      var N = r.clientX, k = r.clientY, $ = D.threshold, G = $ === void 0 ? 0 : $, U = this, z = U._startRect, X = U._startPos;\n      this._currentOptions = D;\n      var V = [0, 0];\n      return z.top > k - G ? (X[1] > z.top || k < X[1]) && (V[1] = -1) : z.top + z.height < k + G && (X[1] < z.top + z.height || k > X[1]) && (V[1] = 1), z.left > N - G ? (X[0] > z.left || N < X[0]) && (V[0] = -1) : z.left + z.width < N + G && (X[0] < z.left + z.width || N > X[0]) && (V[0] = 1), !V[0] && !V[1] ? !1 : this._continueDrag(__assign$4(__assign$4({}, D), {\n        direction: V,\n        inputEvent: r,\n        isDrag: !0\n      }));\n    }\n  }, e.checkScroll = function(r) {\n    var D = this;\n    if (this._isWait)\n      return !1;\n    var N = r.prevScrollPos, k = N === void 0 ? this._prevScrollPos : N, $ = r.direction, G = r.throttleTime, U = G === void 0 ? 0 : G, z = r.inputEvent, X = r.isDrag, V = this._getScrollPosition($ || [0, 0], r), Y = V[0] - k[0], q = V[1] - k[1], W = $ || [Y ? Math.abs(Y) / Y : 0, q ? Math.abs(q) / q : 0];\n    return this._prevScrollPos = V, this._lock = !1, !Y && !q ? !1 : (this.emit(\"move\", {\n      offsetX: W[0] ? Y : 0,\n      offsetY: W[1] ? q : 0,\n      inputEvent: z\n    }), U && X && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n      D._continueDrag(r);\n    }, U)), !0);\n  }, e.dragEnd = function() {\n    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();\n  }, e._getScrollPosition = function(r, D) {\n    var N = D.container, k = D.getScrollPosition, $ = k === void 0 ? getDefaultScrollPosition$1 : k;\n    return $({\n      container: getContainerElement(N),\n      direction: r\n    });\n  }, e._continueDrag = function(r) {\n    var D = this, N, k = r.container, $ = r.direction, G = r.throttleTime, U = r.useScroll, z = r.isDrag, X = r.inputEvent;\n    if (!(!this._flag || z && this._isWait)) {\n      var V = now(), Y = Math.max(G + this._prevTime - V, 0);\n      if (Y > 0)\n        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n          D._continueDrag(r);\n        }, Y), !1;\n      this._prevTime = V;\n      var q = this._getScrollPosition($, r);\n      this._prevScrollPos = q, z && (this._isWait = !0), U || (this._lock = !0);\n      var W = {\n        container: getContainerElement(k),\n        direction: $,\n        inputEvent: X\n      };\n      return (N = r.requestScroll) === null || N === void 0 || N.call(r, W), this.emit(\"scroll\", W), this._isWait = !1, U || this.checkScroll(__assign$4(__assign$4({}, r), {\n        prevScrollPos: q,\n        direction: $,\n        inputEvent: X\n      }));\n    }\n  }, e._registerScrollEvent = function(r) {\n    this._unregisterScrollEvent();\n    var D = r.checkScrollEvent;\n    if (D) {\n      var N = D === !0 ? checkDefaultScrollEvent : D, k = getContainerElement(r.container);\n      D === !0 && (k === document.body || k === document.documentElement) ? this._unregister = checkDefaultScrollEvent(window, this._onScroll) : this._unregister = N(k, this._onScroll);\n    }\n  }, e._unregisterScrollEvent = function() {\n    var r;\n    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;\n  }, t;\n}(EventEmitter$1);\nconst DragScroll$1 = DragScroll;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$3 = function(o, t) {\n  return extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$3(o, t);\n};\nfunction __extends$3(o, t) {\n  extendStatics$3(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$3 = function() {\n  return __assign$3 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$3.apply(this, arguments);\n};\nfunction getRad(o, t) {\n  var e = t[0] - o[0], r = t[1] - o[1], D = Math.atan2(r, e);\n  return D >= 0 ? D : D + Math.PI * 2;\n}\nfunction getRotatiion(o) {\n  return getRad([\n    o[0].clientX,\n    o[0].clientY\n  ], [\n    o[1].clientX,\n    o[1].clientY\n  ]) / Math.PI * 180;\n}\nfunction isMultiTouch(o) {\n  return o.touches && o.touches.length >= 2;\n}\nfunction getEventClients(o) {\n  return o ? o.touches ? getClients(o.touches) : [getClient(o)] : [];\n}\nfunction isMouseEvent(o) {\n  return o && (o.type.indexOf(\"mouse\") > -1 || \"button\" in o);\n}\nfunction getPosition(o, t, e) {\n  var r = e.length, D = getAverageClient(o, r), N = D.clientX, k = D.clientY, $ = D.originalClientX, G = D.originalClientY, U = getAverageClient(t, r), z = U.clientX, X = U.clientY, V = getAverageClient(e, r), Y = V.clientX, q = V.clientY, W = N - z, K = k - X, Z = N - Y, J = k - q;\n  return {\n    clientX: $,\n    clientY: G,\n    deltaX: W,\n    deltaY: K,\n    distX: Z,\n    distY: J\n  };\n}\nfunction getDist$1(o) {\n  return Math.sqrt(Math.pow(o[0].clientX - o[1].clientX, 2) + Math.pow(o[0].clientY - o[1].clientY, 2));\n}\nfunction getClients(o) {\n  for (var t = Math.min(o.length, 2), e = [], r = 0; r < t; ++r)\n    e.push(getClient(o[r]));\n  return e;\n}\nfunction getClient(o) {\n  return {\n    clientX: o.clientX,\n    clientY: o.clientY\n  };\n}\nfunction getAverageClient(o, t) {\n  t === void 0 && (t = o.length);\n  for (var e = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, r = 0; r < t; ++r) {\n    var D = o[r];\n    e.originalClientX += \"originalClientX\" in D ? D.originalClientX : D.clientX, e.originalClientY += \"originalClientY\" in D ? D.originalClientY : D.clientY, e.clientX += D.clientX, e.clientY += D.clientY;\n  }\n  return t ? {\n    clientX: e.clientX / t,\n    clientY: e.clientY / t,\n    originalClientX: e.originalClientX / t,\n    originalClientY: e.originalClientY / t\n  } : e;\n}\nvar ClientStore = /* @__PURE__ */ function() {\n  function o(t) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length;\n  }\n  return o.prototype.getAngle = function(t) {\n    return t === void 0 && (t = this.prevClients), getRotatiion(t);\n  }, o.prototype.getRotation = function(t) {\n    return t === void 0 && (t = this.prevClients), getRotatiion(t) - getRotatiion(this.startClients);\n  }, o.prototype.getPosition = function(t, e) {\n    t === void 0 && (t = this.prevClients);\n    var r = getPosition(t || this.prevClients, this.prevClients, this.startClients), D = r.deltaX, N = r.deltaY;\n    return this.movement += Math.sqrt(D * D + N * N), this.prevClients = t, r;\n  }, o.prototype.getPositions = function(t) {\n    t === void 0 && (t = this.prevClients);\n    var e = this.prevClients;\n    return this.startClients.map(function(r, D) {\n      return getPosition([t[D]], [e[D]], [r]);\n    });\n  }, o.prototype.getMovement = function(t) {\n    var e = this.movement;\n    if (!t)\n      return e;\n    var r = getAverageClient(t, this.length), D = getAverageClient(this.prevClients, this.length), N = r.clientX - D.clientX, k = r.clientY - D.clientY;\n    return Math.sqrt(N * N + k * k) + e;\n  }, o.prototype.getDistance = function(t) {\n    return t === void 0 && (t = this.prevClients), getDist$1(t);\n  }, o.prototype.getScale = function(t) {\n    return t === void 0 && (t = this.prevClients), getDist$1(t) / getDist$1(this.startClients);\n  }, o.prototype.move = function(t, e) {\n    this.startClients.forEach(function(r) {\n      r.clientX -= t, r.clientY -= e;\n    }), this.prevClients.forEach(function(r) {\n      r.clientX -= t, r.clientY -= e;\n    });\n  }, o;\n}(), INPUT_TAGNAMES = [\"textarea\", \"input\"], Gesto = /* @__PURE__ */ function(o) {\n  __extends$3(t, o);\n  function t(e, r) {\n    r === void 0 && (r = {});\n    var D = o.call(this) || this;\n    D.options = {}, D.flag = !1, D.pinchFlag = !1, D.data = {}, D.isDrag = !1, D.isPinch = !1, D.isMouse = !1, D.isTouch = !1, D.clientStores = [], D.targets = [], D.prevTime = 0, D.doubleFlag = !1, D._dragFlag = !1, D._isTrusted = !1, D._isMouseEvent = !1, D._isSecondaryButton = !1, D._preventMouseEvent = !1, D._prevInputEvent = null, D.onDragStart = function(X, V) {\n      if (V === void 0 && (V = !0), !(!D.flag && X.cancelable === !1)) {\n        var Y = D.options, q = Y.container, W = Y.pinchOutside, K = Y.preventWheelClick, Z = Y.preventRightClick, J = Y.preventDefault, Q = Y.checkInput, et = Y.preventClickEventOnDragStart, nt = Y.preventClickEventOnDrag, tt = Y.preventClickEventByCondition, it = D.isTouch, st = !D.flag;\n        if (D._isSecondaryButton = X.which === 3 || X.button === 2, K && (X.which === 2 || X.button === 1) || Z && (X.which === 3 || X.button === 2))\n          return D.stop(), !1;\n        if (st) {\n          var at = document.activeElement, ut = X.target;\n          if (ut) {\n            var ft = ut.tagName.toLowerCase(), ct = INPUT_TAGNAMES.indexOf(ft) > -1, vt = ut.isContentEditable;\n            if (ct || vt) {\n              if (Q || at === ut || at && vt && at.isContentEditable && at.contains(ut))\n                return !1;\n            } else if ((J || X.type === \"touchstart\") && at) {\n              var yt = at.tagName.toLowerCase();\n              (at.isContentEditable || INPUT_TAGNAMES.indexOf(yt) > -1) && at.blur();\n            }\n            (et || nt || tt) && addEvent(window, \"click\", D._onClick, !0);\n          }\n          D.clientStores = [new ClientStore(getEventClients(X))], D.flag = !0, D.isDrag = !1, D._isTrusted = V, D._dragFlag = !0, D._prevInputEvent = X, D.data = {}, D.doubleFlag = now() - D.prevTime < 200, D._isMouseEvent = isMouseEvent(X), !D._isMouseEvent && D._preventMouseEvent && (D._preventMouseEvent = !1);\n          var mt = D._preventMouseEvent || D.emit(\"dragStart\", __assign$3(__assign$3({ data: D.data, datas: D.data, inputEvent: X, isMouseEvent: D._isMouseEvent, isSecondaryButton: D._isSecondaryButton, isTrusted: V, isDouble: D.doubleFlag }, D.getCurrentStore().getPosition()), { preventDefault: function() {\n            X.preventDefault();\n          }, preventDrag: function() {\n            D._dragFlag = !1;\n          } }));\n          mt === !1 && D.stop(), D._isMouseEvent && D.flag && J && X.preventDefault();\n        }\n        if (!D.flag)\n          return !1;\n        var _t = 0;\n        if (st ? (D._attchDragEvent(), it && W && (_t = setTimeout(function() {\n          addEvent(q, \"touchstart\", D.onDragStart, {\n            passive: !1\n          });\n        }))) : it && W && removeEvent(q, \"touchstart\", D.onDragStart), D.flag && isMultiTouch(X)) {\n          if (clearTimeout(_t), st && X.touches.length !== X.changedTouches.length)\n            return;\n          D.pinchFlag || D.onPinchStart(X);\n        }\n      }\n    }, D.onDrag = function(X, V) {\n      if (D.flag) {\n        var Y = D.options.preventDefault;\n        !D._isMouseEvent && Y && X.preventDefault(), D._prevInputEvent = X;\n        var q = getEventClients(X), W = D.moveClients(q, X, !1);\n        if (D._dragFlag) {\n          if (D.pinchFlag || W.deltaX || W.deltaY) {\n            var K = D._preventMouseEvent || D.emit(\"drag\", __assign$3(__assign$3({}, W), { isScroll: !!V, inputEvent: X }));\n            if (K === !1) {\n              D.stop();\n              return;\n            }\n          }\n          D.pinchFlag && D.onPinch(X, q);\n        }\n        D.getCurrentStore().getPosition(q, !0);\n      }\n    }, D.onDragEnd = function(X) {\n      if (D.flag) {\n        var V = D.options, Y = V.pinchOutside, q = V.container, W = V.preventClickEventOnDrag, K = V.preventClickEventOnDragStart, Z = V.preventClickEventByCondition, J = D.isDrag;\n        (W || K || Z) && requestAnimationFrame(function() {\n          D._allowClickEvent();\n        }), !Z && !K && W && !J && D._allowClickEvent(), D.isTouch && Y && removeEvent(q, \"touchstart\", D.onDragStart), D.pinchFlag && D.onPinchEnd(X);\n        var Q = X != null && X.touches ? getEventClients(X) : [], et = Q.length;\n        et === 0 || !D.options.keepDragging ? D.flag = !1 : D._addStore(new ClientStore(Q));\n        var nt = D._getPosition(), tt = now(), it = !J && D.doubleFlag;\n        D._prevInputEvent = null, D.prevTime = J || it ? 0 : tt, D.flag || (D._dettachDragEvent(), D._preventMouseEvent || D.emit(\"dragEnd\", __assign$3({ data: D.data, datas: D.data, isDouble: it, isDrag: J, isClick: !J, isMouseEvent: D._isMouseEvent, isSecondaryButton: D._isSecondaryButton, inputEvent: X, isTrusted: D._isTrusted }, nt)), D.clientStores = [], D._isMouseEvent || (D._preventMouseEvent = !0, requestAnimationFrame(function() {\n          requestAnimationFrame(function() {\n            D._preventMouseEvent = !1;\n          });\n        })));\n      }\n    }, D.onBlur = function() {\n      D.onDragEnd();\n    }, D._allowClickEvent = function() {\n      removeEvent(window, \"click\", D._onClick, !0);\n    }, D._onClick = function(X) {\n      D._allowClickEvent(), D._preventMouseEvent = !1;\n      var V = D.options.preventClickEventByCondition;\n      V != null && V(X) || (X.stopPropagation(), X.preventDefault());\n    }, D._onContextMenu = function(X) {\n      var V = D.options;\n      V.preventRightClick ? D.onDragEnd(X) : X.preventDefault();\n    }, D._passCallback = function() {\n    };\n    var N = [].concat(e);\n    D.options = __assign$3({ checkInput: !1, container: N.length > 1 ? window : N[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: [\"touch\", \"mouse\"] }, r);\n    var k = D.options, $ = k.container, G = k.events, U = k.checkWindowBlur;\n    if (D.isTouch = G.indexOf(\"touch\") > -1, D.isMouse = G.indexOf(\"mouse\") > -1, D.targets = N, D.isMouse && (N.forEach(function(X) {\n      addEvent(X, \"mousedown\", D.onDragStart), addEvent(X, \"mousemove\", D._passCallback);\n    }), addEvent($, \"contextmenu\", D._onContextMenu)), U && addEvent(window, \"blur\", D.onBlur), D.isTouch) {\n      var z = {\n        passive: !1\n      };\n      N.forEach(function(X) {\n        addEvent(X, \"touchstart\", D.onDragStart, z), addEvent(X, \"touchmove\", D._passCallback, z);\n      });\n    }\n    return D;\n  }\n  return t.prototype.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();\n  }, t.prototype.getMovement = function(e) {\n    return this.getCurrentStore().getMovement(e) + this.clientStores.slice(1).reduce(function(r, D) {\n      return r + D.movement;\n    }, 0);\n  }, t.prototype.isDragging = function() {\n    return this.isDrag;\n  }, t.prototype.isFlag = function() {\n    return this.flag;\n  }, t.prototype.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, t.prototype.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, t.prototype.isPinching = function() {\n    return this.isPinch;\n  }, t.prototype.scrollBy = function(e, r, D, N) {\n    N === void 0 && (N = !0), this.flag && (this.clientStores[0].move(e, r), N && this.onDrag(D, !0));\n  }, t.prototype.move = function(e, r) {\n    var D = e[0], N = e[1], k = this.getCurrentStore(), $ = k.prevClients;\n    return this.moveClients($.map(function(G) {\n      var U = G.clientX, z = G.clientY;\n      return {\n        clientX: U + D,\n        clientY: z + N,\n        originalClientX: U,\n        originalClientY: z\n      };\n    }), r, !0);\n  }, t.prototype.triggerDragStart = function(e) {\n    this.onDragStart(e, !1);\n  }, t.prototype.setEventData = function(e) {\n    var r = this.data;\n    for (var D in e)\n      r[D] = e[D];\n    return this;\n  }, t.prototype.setEventDatas = function(e) {\n    return this.setEventData(e);\n  }, t.prototype.getCurrentEvent = function(e) {\n    return e === void 0 && (e = this._prevInputEvent), __assign$3(__assign$3({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: e });\n  }, t.prototype.getEventData = function() {\n    return this.data;\n  }, t.prototype.getEventDatas = function() {\n    return this.data;\n  }, t.prototype.unset = function() {\n    var e = this, r = this.targets, D = this.options.container;\n    this.off(), removeEvent(window, \"blur\", this.onBlur), this.isMouse && (r.forEach(function(N) {\n      removeEvent(N, \"mousedown\", e.onDragStart);\n    }), removeEvent(D, \"contextmenu\", this._onContextMenu)), this.isTouch && (r.forEach(function(N) {\n      removeEvent(N, \"touchstart\", e.onDragStart);\n    }), removeEvent(D, \"touchstart\", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();\n  }, t.prototype.onPinchStart = function(e) {\n    var r = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > r)) {\n      var D = new ClientStore(getEventClients(e));\n      this.pinchFlag = !0, this._addStore(D);\n      var N = this.emit(\"pinchStart\", __assign$3(__assign$3({ data: this.data, datas: this.data, angle: D.getAngle(), touches: this.getCurrentStore().getPositions() }, D.getPosition()), { inputEvent: e, isTrusted: this._isTrusted }));\n      N === !1 && (this.pinchFlag = !1);\n    }\n  }, t.prototype.onPinch = function(e, r) {\n    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {\n      var D = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", __assign$3(__assign$3({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: D.getAngle(r), rotation: D.getRotation(r), touches: D.getPositions(r), scale: D.getScale(r), distance: D.getDistance(r) }, D.getPosition(r)), { inputEvent: e, isTrusted: this._isTrusted }));\n    }\n  }, t.prototype.onPinchEnd = function(e) {\n    if (this.pinchFlag) {\n      var r = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var D = this.getCurrentStore();\n      this.emit(\"pinchEnd\", __assign$3(__assign$3({ data: this.data, datas: this.data, isPinch: r, touches: D.getPositions() }, D.getPosition()), { inputEvent: e }));\n    }\n  }, t.prototype.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, t.prototype.moveClients = function(e, r, D) {\n    var N = this._getPosition(e, D), k = this.isDrag;\n    (N.deltaX || N.deltaY) && (this.isDrag = !0);\n    var $ = !1;\n    return !k && this.isDrag && ($ = !0), __assign$3(__assign$3({ data: this.data, datas: this.data }, N), { movement: this.getMovement(e), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: $ });\n  }, t.prototype._addStore = function(e) {\n    this.clientStores.splice(0, 0, e);\n  }, t.prototype._getPosition = function(e, r) {\n    var D = this.getCurrentStore(), N = D.getPosition(e, r), k = this.clientStores.slice(1).reduce(function(U, z) {\n      var X = z.getPosition();\n      return U.distX += X.distX, U.distY += X.distY, U;\n    }, N), $ = k.distX, G = k.distY;\n    return __assign$3(__assign$3({}, N), { distX: $, distY: G });\n  }, t.prototype._attchDragEvent = function() {\n    var e = this.options.container, r = {\n      passive: !1\n    };\n    this.isMouse && (addEvent(e, \"mousemove\", this.onDrag), addEvent(e, \"mouseup\", this.onDragEnd)), this.isTouch && (addEvent(e, \"touchmove\", this.onDrag, r), addEvent(e, \"touchend\", this.onDragEnd, r), addEvent(e, \"touchcancel\", this.onDragEnd, r));\n  }, t.prototype._dettachDragEvent = function() {\n    var e = this.options.container;\n    this.isMouse && (removeEvent(e, \"mousemove\", this.onDrag), removeEvent(e, \"mouseup\", this.onDragEnd)), this.isTouch && (removeEvent(e, \"touchstart\", this.onDragStart), removeEvent(e, \"touchmove\", this.onDrag), removeEvent(e, \"touchend\", this.onDragEnd), removeEvent(e, \"touchcancel\", this.onDragEnd));\n  }, t;\n}(EventEmitter$1);\nfunction hash$2(o) {\n  for (var t = 5381, e = o.length; e; )\n    t = t * 33 ^ o.charCodeAt(--e);\n  return t >>> 0;\n}\nvar stringHash = hash$2;\nfunction getHash(o) {\n  return stringHash(o).toString(36);\n}\nfunction getShadowRoot$1(o) {\n  if (o && o.getRootNode) {\n    var t = o.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction replaceStyle(o, t, e) {\n  return e.original ? t : t.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(r, D) {\n    var N = D.trim();\n    return (N ? splitComma(N) : [\"\"]).map(function(k) {\n      var $ = k.trim();\n      return $.indexOf(\"@\") === 0 ? $ : $.indexOf(\":global\") > -1 ? $.replace(/\\:global/g, \"\") : $.indexOf(\":host\") > -1 ? \"\" + $.replace(/\\:host/g, \".\" + o) : $ ? \".\" + o + \" \" + $ : \".\" + o;\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(o, t, e, r) {\n  var D = document.createElement(\"style\");\n  return D.setAttribute(\"type\", \"text/css\"), D.setAttribute(\"data-styled-id\", o), e.nonce && D.setAttribute(\"nonce\", e.nonce), D.innerHTML = replaceStyle(o, t, e), (r || document.head || document.body).appendChild(D), D;\n}\nfunction styled$1(o) {\n  var t = \"rCS\" + getHash(o), e = 0, r;\n  return {\n    className: t,\n    inject: function(D, N) {\n      N === void 0 && (N = {});\n      var k = getShadowRoot$1(D), $ = e === 0, G;\n      return (k || $) && (G = injectStyle(t, o, N, k)), $ && (r = G), k || ++e, {\n        destroy: function() {\n          k ? (k.removeChild(G), G = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));\n        }\n      };\n    }\n  };\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$2 = function(o, t) {\n  return extendStatics$2 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics$2(o, t);\n};\nfunction __extends$2(o, t) {\n  extendStatics$2(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$2 = function() {\n  return __assign$2 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$2.apply(this, arguments);\n};\nfunction __rest$1(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)\n      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);\n  return e;\n}\nvar StyledElement = /* @__PURE__ */ function(o) {\n  __extends$2(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.injectResult = null, r.tag = \"div\", r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this.props, D = r.className, N = D === void 0 ? \"\" : D;\n    r.cspNonce;\n    var k = r.portalContainer, $ = __rest$1(r, [\"className\", \"cspNonce\", \"portalContainer\"]), G = this.injector.className, U = this.tag, z = {};\n    return version.indexOf(\"simple\") > -1 && k && (z = {\n      portalContainer: k\n    }), createElement(U, __assign$2({\n      ref: ref(this, \"element\"),\n      \"data-styled-id\": G,\n      className: N + \" \" + G\n    }, z, $));\n  }, e.componentDidMount = function() {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  }, e.componentWillUnmount = function() {\n    this.injectResult.destroy(), this.injectResult = null;\n  }, e.getElement = function() {\n    return this.element;\n  }, t;\n}(Component);\nfunction styled(o, t) {\n  var e = styled$1(t);\n  return /* @__PURE__ */ function(r) {\n    __extends$2(D, r);\n    function D() {\n      var N = r !== null && r.apply(this, arguments) || this;\n      return N.injector = e, N.tag = o, N;\n    }\n    return D;\n  }(StyledElement);\n}\nvar extendStatics$1 = function(o, t) {\n  return extendStatics$1 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      Object.prototype.hasOwnProperty.call(r, D) && (e[D] = r[D]);\n  }, extendStatics$1(o, t);\n};\nfunction __extends$1(o, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  extendStatics$1(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$1 = function() {\n  return __assign$1 = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$1.apply(this, arguments);\n};\nfunction __rest(o, t) {\n  var e = {};\n  for (var r in o)\n    Object.prototype.hasOwnProperty.call(o, r) && t.indexOf(r) < 0 && (e[r] = o[r]);\n  if (o != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var D = 0, r = Object.getOwnPropertySymbols(o); D < r.length; D++)\n      t.indexOf(r[D]) < 0 && Object.prototype.propertyIsEnumerable.call(o, r[D]) && (e[r[D]] = o[r[D]]);\n  return e;\n}\nfunction __decorate$1(o, t, e, r) {\n  var D = arguments.length, N = D < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, k;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    N = Reflect.decorate(o, t, e, r);\n  else\n    for (var $ = o.length - 1; $ >= 0; $--)\n      (k = o[$]) && (N = (D < 3 ? k(N) : D > 3 ? k(t, e, N) : k(t, e)) || N);\n  return D > 3 && N && Object.defineProperty(t, e, N), N;\n}\nfunction __spreadArray(o, t, e) {\n  if (e || arguments.length === 2)\n    for (var r = 0, D = t.length, N; r < D; r++)\n      (N || !(r in t)) && (N || (N = Array.prototype.slice.call(t, 0, r)), N[r] = t[r]);\n  return o.concat(N || Array.prototype.slice.call(t));\n}\nfunction makeAble(o, t) {\n  var e;\n  return __assign$1({\n    events: {},\n    props: (e = {}, e[o] = Boolean, e),\n    name: o\n  }, t);\n}\nvar DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"], DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\nfunction getSVGCursor(o, t) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * o, 'px\" height=\"').concat(32 * o, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(o) {\n  var t = getSVGCursor(1, o), e = Math.round(o / 45) * 45 % 180, r = \"ns-resize\";\n  return e === 135 ? r = \"nwse-resize\" : e === 45 ? r = \"nesw-resize\" : e === 90 && (r = \"ew-resize\"), \"cursor:\".concat(r, \";cursor: url('\").concat(t, \"') 16 16, \").concat(r, \";\");\n}\nvar agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {\n  var o = typeof window > \"u\" ? {\n    userAgent: \"\"\n  } : window.navigator, t = /applewebkit\\/([^\\s]+)/g.exec(o.userAgent.toLowerCase());\n  return t ? parseFloat(t[1]) < 605 : !1;\n}(), browserName = agent.browser.name, browserVersion = parseInt(agent.browser.version, 10), IS_CHROME = browserName === \"chrome\", IS_CHROMIUM = agent.browser.chromium, chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0, IS_CHROMIUM109 = IS_CHROME && browserVersion >= 109 || IS_CHROMIUM && chromiumVersion >= 109, IS_FIREFOX = browserName === \"firefox\", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || browserVersion >= 15, PREFIX = \"moveable-\", directionCSS = DIRECTIONS.map(function(o) {\n  var t = \"\", e = \"\", r = \"center\", D = \"center\";\n  return o.indexOf(\"n\") > -1 && (t = \"top: -20px;\", D = \"bottom\"), o.indexOf(\"s\") > -1 && (t = \"top: 0px;\", D = \"top\"), o.indexOf(\"w\") > -1 && (e = \"left: -20px;\", r = \"right\"), o.indexOf(\"e\") > -1 && (e = \"left: 0px;\", r = \"left\"), '.around-control[data-direction*=\"'.concat(o, `\"] {\n        `).concat(e).concat(t, `\n        transform-origin: `).concat(r, \" \").concat(D, `;\n    }`);\n}).join(`\n`), MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n    outline: 1px solid transparent;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: calc(var(--moveable-control-padding, 20) * 1px);\n    height: calc(var(--moveable-control-padding, 20) * 1px);\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n`.concat(directionCSS, `\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n`).concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(o) {\n  return `\n.direction[data-rotation=\"`.concat(o, '\"], :global .view-control-rotation').concat(o, ` {\n\t`).concat(getCursorCSS(o), `\n}\n`);\n}).join(`\n`), `\n\n.line.direction:before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: calc(var(--moveable-line-padding, 0) * 1px);\n    bottom: 0;\n    left: 0;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n`).concat(IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\", `\n`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTION_REGION_TO_DIRECTION = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, DIRECTION_INDEXES = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\", \"waitToChangeTarget\", \"updateSelectors\", \"getTargets\", \"stopDrag\"];\nfunction setCustomDrag(o, t, e, r, D, N) {\n  var k, $;\n  N === void 0 && (N = \"draggable\");\n  var G = ($ = (k = t.gestos[N]) === null || k === void 0 ? void 0 : k.move(e, o.inputEvent)) !== null && $ !== void 0 ? $ : {}, U = G.originalDatas || G.datas, z = U[N] || (U[N] = {});\n  return __assign$1(__assign$1({}, D ? convertDragDist(t, G) : G), {\n    isPinch: !!r,\n    parentEvent: !0,\n    datas: z,\n    originalDatas: o.originalDatas\n  });\n}\nvar CustomGesto = /* @__PURE__ */ function() {\n  function o(e) {\n    var r;\n    e === void 0 && (e = \"draggable\"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {\n      draggable: {}\n    }, this.datas = (r = {}, r[e] = {}, r);\n  }\n  var t = o.prototype;\n  return t.dragStart = function(e, r) {\n    this.isDrag = !1, this.isFlag = !1;\n    var D = r.originalDatas;\n    return this.datas = D, D[this.ableName] || (D[this.ableName] = {}), __assign$1(__assign$1({}, this.move(e, r.inputEvent)), {\n      type: \"dragstart\"\n    });\n  }, t.drag = function(e, r) {\n    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);\n  }, t.move = function(e, r) {\n    var D, N, k = !1;\n    if (!this.isFlag)\n      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], D = e[0], N = e[1], this.isFlag = !0;\n    else {\n      var $ = this.isDrag;\n      D = this.prevX + e[0], N = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !$ && this.isDrag && (k = !0);\n    }\n    return this.prevX = D, this.prevY = N, {\n      type: \"drag\",\n      clientX: D,\n      clientY: N,\n      inputEvent: r,\n      isFirstDrag: k,\n      isDrag: this.isDrag,\n      distX: D - this.startX,\n      distY: N - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }, o;\n}();\nfunction calculatePointerDist(o, t) {\n  var e = t.clientX, r = t.clientY, D = t.datas, N = o.state, k = N.moveableClientRect, $ = N.rootMatrix, G = N.is3d, U = N.pos1, z = k.left, X = k.top, V = G ? 4 : 3, Y = minus(calculateInversePosition($, [e - z, r - X], V), U), q = Y[0], W = Y[1], K = getDragDist({\n    datas: D,\n    distX: q,\n    distY: W\n  }), Z = K[0], J = K[1];\n  return [Z, J];\n}\nfunction setDragStart(o, t) {\n  var e = t.datas, r = o.state, D = r.allMatrix, N = r.beforeMatrix, k = r.is3d, $ = r.left, G = r.top, U = r.origin, z = r.offsetMatrix, X = r.targetMatrix, V = r.transformOrigin, Y = k ? 4 : 3;\n  e.is3d = k, e.matrix = D, e.targetMatrix = X, e.beforeMatrix = N, e.offsetMatrix = z, e.transformOrigin = V, e.inverseMatrix = invert(D, Y), e.inverseBeforeMatrix = invert(N, Y), e.absoluteOrigin = convertPositionMatrix(plus([$, G], U), Y), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, Y), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, Y);\n}\nfunction getTransformDirection(o) {\n  return calculateMoveablePosition(o.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction resolveTransformEvent(o, t) {\n  var e = o.datas, r = o.originalDatas.beforeRenderable, D = e.transformIndex, N = r.nextTransforms, k = N.length, $ = r.nextTransformAppendedIndexes, G = 0;\n  D === -1 ? (t === \"translate\" ? G = 0 : t === \"rotate\" && (G = findIndex(N, function(V) {\n    return V.match(/scale\\(/g);\n  })), G === -1 && (G = N.length), e.transformIndex = G) : find$1($, function(V) {\n    return V.index === D && V.functionName === t;\n  }) ? G = D : G = D + $.filter(function(V) {\n    return V.index < D;\n  }).length;\n  var U = convertTransformInfo(N, G), z = U.targetFunction, X = t === \"rotate\" ? \"rotateZ\" : t;\n  e.beforeFunctionTexts = U.beforeFunctionTexts, e.afterFunctionTexts = U.afterFunctionTexts, e.beforeTransform = U.beforeFunctionMatrix, e.beforeTransform2 = U.beforeFunctionMatrix2, e.targetTansform = U.targetFunctionMatrix, e.afterTransform = U.afterFunctionMatrix, e.afterTransform2 = U.afterFunctionMatrix2, e.targetAllTransform = U.allFunctionMatrix, z.functionName === X ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : k > G && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], $, !0), [{\n    functionName: t,\n    index: G,\n    isAppend: !0\n  }], !1));\n}\nfunction convertTransformFormat(o, t, e) {\n  return \"\".concat(o.beforeFunctionTexts.join(\" \"), \" \").concat(o.isAppendTransform ? e : t, \" \").concat(o.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(o) {\n  var t = o.datas, e = o.distX, r = o.distY, D = getBeforeDragDist({\n    datas: t,\n    distX: e,\n    distY: r\n  }), N = D[0], k = D[1], $ = getTransfromMatrix(t, fromTranslation([N, k], 4));\n  return calculate($, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nfunction getTransfromMatrix(o, t, e) {\n  var r = o.beforeTransform, D = o.afterTransform, N = o.beforeTransform2, k = o.afterTransform2, $ = o.targetAllTransform, G = e ? multiply($, t, 4) : multiply(t, $, 4), U = multiply(invert(e ? N : r, 4), G, 4), z = multiply(U, invert(e ? k : D, 4), 4);\n  return z;\n}\nfunction getBeforeDragDist(o) {\n  var t = o.datas, e = o.distX, r = o.distY, D = t.inverseBeforeMatrix, N = t.is3d, k = t.startDragBeforeDist, $ = t.absoluteOrigin, G = N ? 4 : 3;\n  return minus(calculate(D, plus($, [e, r]), G), k);\n}\nfunction getDragDist(o, t) {\n  var e = o.datas, r = o.distX, D = o.distY, N = e.inverseBeforeMatrix, k = e.inverseMatrix, $ = e.is3d, G = e.startDragBeforeDist, U = e.startDragDist, z = e.absoluteOrigin, X = $ ? 4 : 3;\n  return minus(calculate(t ? N : k, plus(z, [r, D]), X), t ? G : U);\n}\nfunction getInverseDragDist(o, t) {\n  var e = o.datas, r = o.distX, D = o.distY, N = e.beforeMatrix, k = e.matrix, $ = e.is3d, G = e.startDragBeforeDist, U = e.startDragDist, z = e.absoluteOrigin, X = $ ? 4 : 3;\n  return minus(calculate(t ? N : k, plus(t ? G : U, [r, D]), X), z);\n}\nfunction calculateTransformOrigin(o, t, e, r, D, N) {\n  return r === void 0 && (r = t), D === void 0 && (D = e), N === void 0 && (N = [0, 0]), o ? o.map(function(k, $) {\n    var G = splitUnit(k), U = G.value, z = G.unit, X = $ ? D : r, V = $ ? e : t;\n    if (k === \"%\" || isNaN(U)) {\n      var Y = X ? N[$] / X : 0;\n      return V * Y;\n    } else if (z !== \"%\")\n      return U;\n    return V * U / 100;\n  }) : N;\n}\nfunction getPosIndexesByDirection(o) {\n  var t = [];\n  return o[1] >= 0 && (o[0] >= 0 && t.push(3), o[0] <= 0 && t.push(2)), o[1] <= 0 && (o[0] >= 0 && t.push(1), o[0] <= 0 && t.push(0)), t;\n}\nfunction getPosesByDirection(o, t) {\n  return getPosIndexesByDirection(t).map(function(e) {\n    return o[e];\n  });\n}\nfunction getPosByDirection(o, t) {\n  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, D = [dot(o[0][0], o[1][0], e, 1 - e), dot(o[0][1], o[1][1], e, 1 - e)], N = [dot(o[2][0], o[3][0], e, 1 - e), dot(o[2][1], o[3][1], e, 1 - e)];\n  return [dot(D[0], N[0], r, 1 - r), dot(D[1], N[1], r, 1 - r)];\n}\nfunction getDist(o, t, e, r, D, N) {\n  var k = calculatePoses(t, e, r, D), $ = getPosByDirection(k, N), G = o[0] - $[0], U = o[1] - $[1];\n  return [G, U];\n}\nfunction getNextMatrix(o, t, e, r) {\n  return multiply(o, getAbsoluteMatrix(t, r, e), r);\n}\nfunction getNextTransformMatrix(o, t, e) {\n  var r = o.transformOrigin, D = o.offsetMatrix, N = o.is3d, k = t.beforeTransform, $ = t.afterTransform, G = N ? 4 : 3, U = parseMat([e]);\n  return getNextMatrix(D, convertDimension(multiply(multiply(k, U, 4), $, 4), 4, G), r, G);\n}\nfunction scaleMatrix(o, t) {\n  var e = o.transformOrigin, r = o.offsetMatrix, D = o.is3d, N = o.targetMatrix, k = D ? 4 : 3;\n  return getNextMatrix(r, multiply(N, createScaleMatrix(t, k), k), e, k);\n}\nfunction fillTransformStartEvent(o) {\n  var t = getBeforeRenderableDatas(o);\n  return {\n    setTransform: function(e, r) {\n      r === void 0 && (r = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(o, r);\n    },\n    setTransformIndex: function(e) {\n      setTransformIndex(o, e);\n    }\n  };\n}\nfunction setDefaultTransformIndex(o, t) {\n  var e = getBeforeRenderableDatas(o), r = e.startTransforms;\n  setTransformIndex(o, findIndex(r, function(D) {\n    return D.indexOf(\"\".concat(t, \"(\")) === 0;\n  }));\n}\nfunction setTransformIndex(o, t) {\n  var e = getBeforeRenderableDatas(o), r = o.datas;\n  if (r.transformIndex = t, t !== -1) {\n    var D = e.startTransforms[t];\n    if (D) {\n      var N = parse$1([D]);\n      r.startValue = N[0].functionValue;\n    }\n  }\n}\nfunction fillOriginalTransform(o, t) {\n  var e = getBeforeRenderableDatas(o);\n  e.nextTransforms = splitSpace(t);\n}\nfunction getBeforeRenderableDatas(o) {\n  return o.originalDatas.beforeRenderable;\n}\nfunction getNextTransforms(o) {\n  var t = o.originalDatas.beforeRenderable;\n  return t.nextTransforms;\n}\nfunction getNextTransformText(o) {\n  return getNextTransforms(o).join(\" \");\n}\nfunction getNextStyle(o) {\n  return getBeforeRenderableDatas(o).nextStyle;\n}\nfunction fillTransformEvent(o, t, e, r, D) {\n  fillOriginalTransform(D, t);\n  var N = Draggable.drag(o, setCustomDrag(D, o.state, e, r, !1)), k = N ? N.transform : t;\n  return __assign$1(__assign$1({\n    transform: t,\n    drag: N\n  }, fillCSSObject({\n    transform: k\n  }, D)), {\n    afterTransform: k\n  });\n}\nfunction getTranslateDist(o, t, e, r, D) {\n  var N = o.state, k = N.left, $ = N.top, G = o.props.groupable, U = getNextTransformMatrix(o.state, D, t), z = G ? k : 0, X = G ? $ : 0, V = getDirectionOffset(o, e, U), Y = minus(r, V);\n  return minus(Y, [z, X]);\n}\nfunction getScaleDist(o, t, e, r, D) {\n  var N = getTranslateDist(o, \"scale(\".concat(t.join(\", \"), \")\"), e, r, D);\n  return N;\n}\nfunction getDirectionByPos(o, t, e) {\n  return [-1 + o[0] / (t / 2), -1 + o[1] / (e / 2)];\n}\nfunction getDirectionOffset(o, t, e) {\n  e === void 0 && (e = o.state.allMatrix);\n  var r = o.state, D = r.width, N = r.height, k = r.is3d, $ = k ? 4 : 3, G = [D / 2 * (1 + t[0]), N / 2 * (1 + t[1])];\n  return calculatePosition(e, G, $);\n}\nfunction getRotateDist(o, t, e) {\n  var r = e.fixedDirection, D = e.fixedPosition;\n  return getTranslateDist(o, \"rotate(\".concat(t, \"deg)\"), r, D, e);\n}\nfunction getResizeDist(o, t, e, r, D, N) {\n  var k = o.props.groupable, $ = o.state, G = $.transformOrigin, U = $.offsetMatrix, z = $.is3d, X = $.width, V = $.height, Y = $.left, q = $.top, W = N.fixedDirection, K = N.nextTargetMatrix || $.targetMatrix, Z = z ? 4 : 3, J = calculateTransformOrigin(D, t, e, X, V, G), Q = k ? Y : 0, et = k ? q : 0, nt = getNextMatrix(U, K, J, Z), tt = getDist(r, nt, t, e, Z, W);\n  return minus(tt, [Q, et]);\n}\nfunction getAbsolutePosition(o, t) {\n  return getPosByDirection(getAbsolutePosesByState(o.state), t);\n}\nfunction getGestoData(o, t) {\n  var e = o.targetGesto, r = o.controlGesto, D;\n  return e != null && e.isFlag() && (D = e.getEventData()[t]), !D && (r != null && r.isFlag()) && (D = r.getEventData()[t]), D || {};\n}\nfunction multiply2(o, t) {\n  return [o[0] * t[0], o[1] * t[1]];\n}\nfunction prefix() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  return prefixNames.apply(void 0, __spreadArray([PREFIX], o, !1));\n}\nfunction defaultSync(o) {\n  o();\n}\nfunction getTransformMatrix(o) {\n  return !o || o === \"none\" ? [1, 0, 0, 1, 0, 0] : isObject$2(o) ? o : parseMat(o);\n}\nfunction getAbsoluteMatrix(o, t, e) {\n  return multiplies(t, createOriginMatrix(e, t), o, createOriginMatrix(e.map(function(r) {\n    return -r;\n  }), t));\n}\nfunction measureSVGSize(o, t, e) {\n  if (t === \"%\") {\n    var r = getSVGViewBox(o.ownerSVGElement);\n    return r[e ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction getBeforeTransformOrigin(o) {\n  var t = getTransformOrigin(getComputedStyle$1$1(o, \":before\"));\n  return t.map(function(e, r) {\n    var D = splitUnit(e), N = D.value, k = D.unit;\n    return N * measureSVGSize(o, k, r === 0);\n  });\n}\nfunction getTransformOrigin(o) {\n  var t = o.transformOrigin;\n  return t ? t.split(\" \") : [\"0\", \"0\"];\n}\nfunction getElementTransform(o, t) {\n  t === void 0 && (t = getComputedStyle$1$1(o));\n  var e = t.transform;\n  if (e && e !== \"none\")\n    return t.transform;\n  if (\"transform\" in o) {\n    var r = o.transform, D = r.baseVal;\n    if (!D)\n      return \"\";\n    var N = D.length;\n    if (!N)\n      return \"\";\n    for (var k = [], $ = function(U) {\n      var z = D[U].matrix;\n      k.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(X) {\n        return z[X];\n      }).join(\", \"), \")\"));\n    }, G = 0; G < N; ++G)\n      $(G);\n    return k.join(\" \");\n  }\n  return \"\";\n}\nfunction getOffsetInfo(o, t, e, r, D) {\n  var N, k, $, G = o && o.ownerDocument ? o.ownerDocument : document, U = G.documentElement || G.body, z = !1, X, V;\n  if (!o || e)\n    X = o;\n  else {\n    var Y = (N = o == null ? void 0 : o.assignedSlot) === null || N === void 0 ? void 0 : N.parentElement, q = o.parentElement;\n    Y ? (z = !0, V = q, X = Y) : X = q;\n  }\n  for (var W = !1, K = o === t || X === t, Z = \"relative\", J = 1, Q = parseFloat((k = D) === null || k === void 0 ? void 0 : k.zoom) || 1, et = D == null ? void 0 : D.position; X && X !== U; ) {\n    t === X && (K = !0);\n    var nt = getComputedStyle$1$1(X), tt = X.tagName.toLowerCase(), it = getElementTransform(X, nt), st = nt.willChange, at = parseFloat(nt.zoom) || 1;\n    if (Z = nt.position, r && at !== 1) {\n      J = at;\n      break;\n    }\n    if (\n      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n      !e && r && Q !== 1 && et && et !== \"absolute\" || tt === \"svg\" || Z !== \"static\" || it && it !== \"none\" || st === \"transform\"\n    )\n      break;\n    var ut = ($ = o == null ? void 0 : o.assignedSlot) === null || $ === void 0 ? void 0 : $.parentNode, ft = X.parentNode;\n    ut && (z = !0, V = ft);\n    var ct = ft;\n    if (ct && ct.nodeType === 11) {\n      X = ct.host, W = !0, Z = getComputedStyle$1$1(X).position;\n      break;\n    }\n    X = ct, Z = \"relative\";\n  }\n  return {\n    offsetZoom: J,\n    hasSlot: z,\n    parentSlotElement: V,\n    isCustomElement: W,\n    isStatic: Z === \"static\",\n    isEnd: K || !X || X === U,\n    offsetParent: X || U\n  };\n}\nfunction getOffsetPosInfo(o, t, e) {\n  var r, D = o.tagName.toLowerCase(), N = o.offsetLeft, k = o.offsetTop, $ = isUndefined(N), G = !$, U, z;\n  return !G && D !== \"svg\" ? (U = IS_WEBKIT605 ? getBeforeTransformOrigin(o) : getTransformOrigin(e).map(function(X) {\n    return parseFloat(X);\n  }), z = U.slice(), G = !0, r = getSVGGraphicsOffset(o, U, o === t && t.tagName.toLowerCase() === \"g\"), N = r[0], k = r[1], U[0] = r[2], U[1] = r[3]) : (U = getTransformOrigin(e).map(function(X) {\n    return parseFloat(X);\n  }), z = U.slice()), {\n    tagName: D,\n    isSVG: $,\n    hasOffset: G,\n    offset: [N || 0, k || 0],\n    origin: U,\n    targetOrigin: z\n  };\n}\nfunction getBodyOffset(o, t, e) {\n  e === void 0 && (e = getComputedStyle$1$1(o));\n  var r = getComputedStyle$1$1(document.body), D = r.position;\n  if (!t && (!D || D === \"static\"))\n    return [0, 0];\n  var N = parseInt(r.marginLeft, 10), k = parseInt(r.marginTop, 10);\n  return e.position === \"absolute\" && ((e.top !== \"auto\" || e.bottom !== \"auto\") && (k = 0), (e.left !== \"auto\" || e.right !== \"auto\") && (N = 0)), [N, k];\n}\nfunction convert3DMatrixes(o) {\n  o.forEach(function(t) {\n    var e = t.matrix;\n    e && (t.matrix = convertDimension(e, 3, 4));\n  });\n}\nfunction getPositionFixedInfo(o) {\n  for (var t = o.parentElement, e = !1; t; ) {\n    var r = getComputedStyle$1$1(t).transform;\n    if (r && r !== \"none\") {\n      e = !0;\n      break;\n    }\n    if (t === document.body)\n      break;\n    t = t.parentElement;\n  }\n  return {\n    fixedContainer: t || document.body,\n    hasTransform: e\n  };\n}\nfunction makeMatrixCSS(o, t) {\n  return t === void 0 && (t = o.length > 9), \"\".concat(t ? \"matrix3d\" : \"matrix\", \"(\").concat(convertMatrixtoCSS(o, !t).join(\",\"), \")\");\n}\nfunction getSVGViewBox(o) {\n  var t = o.clientWidth, e = o.clientHeight;\n  if (!o)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: t,\n      clientHeight: e\n    };\n  var r = o.viewBox, D = r && r.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: D.x,\n    y: D.y,\n    width: D.width || t,\n    height: D.height || e,\n    clientWidth: t,\n    clientHeight: e\n  };\n}\nfunction getSVGMatrix(o, t) {\n  var e = getSVGViewBox(o), r = e.width, D = e.height, N = e.clientWidth, k = e.clientHeight, $ = N / r, G = k / D, U = o.preserveAspectRatio.baseVal, z = U.align, X = U.meetOrSlice, V = [0, 0], Y = [$, G], q = [0, 0];\n  if (z !== 1) {\n    var W = (z - 2) % 3, K = Math.floor((z - 2) / 3);\n    V[0] = r * W / 2, V[1] = D * K / 2;\n    var Z = X === 2 ? Math.max(G, $) : Math.min($, G);\n    Y[0] = Z, Y[1] = Z, q[0] = (N - r) / 2 * W, q[1] = (k - D) / 2 * K;\n  }\n  var J = createScaleMatrix(Y, t);\n  return J[t * (t - 1)] = q[0], J[t * (t - 1) + 1] = q[1], getAbsoluteMatrix(J, t, V);\n}\nfunction getSVGGraphicsOffset(o, t, e) {\n  if (!o.getBBox || !e && o.tagName.toLowerCase() === \"g\")\n    return [0, 0, 0, 0];\n  var r = o.getBBox(), D = getSVGViewBox(o.ownerSVGElement), N = r.x - D.x, k = r.y - D.y;\n  return [N, k, t[0] - N, t[1] - k];\n}\nfunction calculatePosition(o, t, e) {\n  return calculate(o, convertPositionMatrix(t, e), e);\n}\nfunction calculatePoses(o, t, e, r) {\n  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(D) {\n    return calculatePosition(o, D, r);\n  });\n}\nfunction getRect(o) {\n  var t = o.map(function(U) {\n    return U[0];\n  }), e = o.map(function(U) {\n    return U[1];\n  }), r = Math.min.apply(Math, t), D = Math.min.apply(Math, e), N = Math.max.apply(Math, t), k = Math.max.apply(Math, e), $ = N - r, G = k - D;\n  return {\n    left: r,\n    top: D,\n    right: N,\n    bottom: k,\n    width: $,\n    height: G\n  };\n}\nfunction calculateRect(o, t, e, r) {\n  var D = calculatePoses(o, t, e, r);\n  return getRect(D);\n}\nfunction getSVGOffset(o, t, e, r, D) {\n  var N, k = o.target, $ = o.origin, G = t.matrix, U = getSize(k), z = U.offsetWidth, X = U.offsetHeight, V = e.getBoundingClientRect(), Y = [0, 0];\n  e === document.body && (Y = getBodyOffset(k, !0));\n  for (var q = k.getBoundingClientRect(), W = q.left - V.left + e.scrollLeft - (e.clientLeft || 0) + Y[0], K = q.top - V.top + e.scrollTop - (e.clientTop || 0) + Y[1], Z = q.width, J = q.height, Q = multiplies(r, D, G), et = calculateRect(Q, z, X, r), nt = et.left, tt = et.top, it = et.width, st = et.height, at = calculatePosition(Q, $, r), ut = minus(at, [nt, tt]), ft = [W + ut[0] * Z / it, K + ut[1] * J / st], ct = [0, 0], vt = 0; ++vt < 10; ) {\n    var yt = invert(D, r);\n    N = minus(calculatePosition(yt, ft, r), calculatePosition(yt, at, r)), ct[0] = N[0], ct[1] = N[1];\n    var mt = multiplies(r, D, createOriginMatrix(ct, r), G), _t = calculateRect(mt, z, X, r), Tt = _t.left, Pt = _t.top, St = Tt - W, gt = Pt - K;\n    if (Math.abs(St) < 2 && Math.abs(gt) < 2)\n      break;\n    ft[0] -= St, ft[1] -= gt;\n  }\n  return ct.map(function(bt) {\n    return Math.round(bt);\n  });\n}\nfunction calculateMoveableClientPositions(o, t, e) {\n  var r = o.length === 16, D = r ? 4 : 3, N = t.map(function(G) {\n    return calculatePosition(o, G, D);\n  }), k = e.left, $ = e.top;\n  return N.map(function(G) {\n    return [G[0] + k, G[1] + $];\n  });\n}\nfunction calculateMoveablePosition(o, t, e, r) {\n  var D = o.length === 16, N = D ? 4 : 3, k = calculatePoses(o, e, r, N), $ = k[0], G = $[0], U = $[1], z = k[1], X = z[0], V = z[1], Y = k[2], q = Y[0], W = Y[1], K = k[3], Z = K[0], J = K[1], Q = calculatePosition(o, t, N), et = Q[0], nt = Q[1], tt = Math.min(G, X, q, Z), it = Math.min(U, V, W, J), st = Math.max(G, X, q, Z), at = Math.max(U, V, W, J);\n  G = G - tt || 0, X = X - tt || 0, q = q - tt || 0, Z = Z - tt || 0, U = U - it || 0, V = V - it || 0, W = W - it || 0, J = J - it || 0, et = et - tt || 0, nt = nt - it || 0;\n  var ut = getShapeDirection(calculatePoses(o, 100, 100, N));\n  return {\n    left: tt,\n    top: it,\n    right: st,\n    bottom: at,\n    origin: [et, nt],\n    pos1: [G, U],\n    pos2: [X, V],\n    pos3: [q, W],\n    pos4: [Z, J],\n    direction: ut\n  };\n}\nfunction getDistSize(o) {\n  return Math.sqrt(o[0] * o[0] + o[1] * o[1]);\n}\nfunction getDiagonalSize(o, t) {\n  return getDistSize([t[0] - o[0], t[1] - o[1]]);\n}\nfunction getLineStyle(o, t, e, r) {\n  e === void 0 && (e = 1), r === void 0 && (r = getRad$1(o, t));\n  var D = getDiagonalSize(o, t);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(o[0], \"px, \").concat(o[1], \"px) rotate(\").concat(r, \"rad) scaleY(\").concat(e, \")\"),\n    width: \"\".concat(D, \"px\")\n  };\n}\nfunction getControlTransform(o, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var D = e.length, N = e.reduce(function($, G) {\n    return $ + G[0];\n  }, 0) / D, k = e.reduce(function($, G) {\n    return $ + G[1];\n  }, 0) / D;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(N, \"px, \").concat(k, \"px) rotate(\").concat(o, \"rad) scale(\").concat(t, \")\")\n  };\n}\nfunction getProps(o, t) {\n  var e = o[t];\n  return isObject$2(e) ? __assign$1(__assign$1({}, o), e) : o;\n}\nfunction getSize(o, t) {\n  t === void 0 && (t = o ? getComputedStyle$1$1(o) : null);\n  var e = o && !isUndefined(o.offsetWidth), r = 0, D = 0, N = 0, k = 0, $ = 0, G = 0, U = 0, z = 0, X = 0, V = 0, Y = 0, q = 0, W = 1 / 0, K = 1 / 0, Z = 1 / 0, J = 1 / 0, Q = 0, et = 0, nt = !1;\n  if (o)\n    if (!e && o.tagName.toLowerCase() !== \"svg\") {\n      var tt = o.getBBox();\n      nt = !0, r = tt.width, D = tt.height, $ = r, G = D, U = r, z = D, N = r, k = D;\n    } else {\n      var it = o.style, st = t.boxSizing === \"border-box\", at = parseFloat(t.borderLeftWidth) || 0, ut = parseFloat(t.borderRightWidth) || 0, ft = parseFloat(t.borderTopWidth) || 0, ct = parseFloat(t.borderBottomWidth) || 0, vt = parseFloat(t.paddingLeft) || 0, yt = parseFloat(t.paddingRight) || 0, mt = parseFloat(t.paddingTop) || 0, _t = parseFloat(t.paddingBottom) || 0, Tt = vt + yt, Pt = mt + _t, St = at + ut, gt = ft + ct, bt = Tt + St, Nt = Pt + gt, At = t.position, It = 0, Mt = 0;\n      if (\"clientLeft\" in o) {\n        var dt = null;\n        if (At === \"absolute\") {\n          var $t = getOffsetInfo(o, document.body);\n          dt = $t.offsetParent;\n        } else\n          dt = o.parentElement;\n        if (dt) {\n          var Dt = getComputedStyle$1$1(dt);\n          It = parseFloat(Dt.width), Mt = parseFloat(Dt.height);\n        }\n      }\n      X = Math.max(Tt, convertUnitSize(t.minWidth, It) || 0), V = Math.max(Pt, convertUnitSize(t.minHeight, Mt) || 0), W = convertUnitSize(t.maxWidth, It), K = convertUnitSize(t.maxHeight, Mt), isNaN(W) && (W = 1 / 0), isNaN(K) && (K = 1 / 0), Q = convertUnitSize(it.width, 0) || 0, et = convertUnitSize(it.height, 0) || 0, $ = parseFloat(t.width) || 0, G = parseFloat(t.height) || 0, U = Math.abs($ - Q) < 1 ? between(X, Q || $, W) : $, z = Math.abs(G - et) < 1 ? between(V, et || G, K) : G, r = U, D = z, N = U, k = z, st ? (Z = W, J = K, Y = X, q = V, U = r - bt, z = D - Nt) : (Z = W + bt, J = K + Nt, Y = X + bt, q = V + Nt, r = U + bt, D = z + Nt), N = U + Tt, k = z + Pt;\n    }\n  return {\n    svg: nt,\n    offsetWidth: r,\n    offsetHeight: D,\n    clientWidth: N,\n    clientHeight: k,\n    contentWidth: U,\n    contentHeight: z,\n    inlineCSSWidth: Q,\n    inlineCSSHeight: et,\n    cssWidth: $,\n    cssHeight: G,\n    minWidth: X,\n    minHeight: V,\n    maxWidth: W,\n    maxHeight: K,\n    minOffsetWidth: Y,\n    minOffsetHeight: q,\n    maxOffsetWidth: Z,\n    maxOffsetHeight: J\n  };\n}\nfunction getRotationRad(o, t) {\n  return getRad$1(t > 0 ? o[0] : o[1], t > 0 ? o[1] : o[0]);\n}\nfunction resetClientRect() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction getExtendsRect(o, t) {\n  var e = o === document.body || o === document.documentElement, r = {\n    clientLeft: o.clientLeft,\n    clientTop: o.clientTop,\n    clientWidth: o.clientWidth,\n    clientHeight: o.clientHeight,\n    scrollWidth: o.scrollWidth,\n    scrollHeight: o.scrollHeight,\n    overflow: !1\n  };\n  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = getComputedStyle$1$1(o).overflow !== \"visible\", __assign$1(__assign$1({}, t), r);\n}\nfunction getClientRectByPosition(o, t, e, r) {\n  var D = o.left, N = o.right, k = o.top, $ = o.bottom, G = t.top, U = t.left, z = {\n    left: U + D,\n    top: G + k,\n    right: U + N,\n    bottom: G + $,\n    width: N - D,\n    height: $ - k\n  };\n  return e && r ? getExtendsRect(e, z) : z;\n}\nfunction getClientRect(o, t) {\n  var e = 0, r = 0, D = 0, N = 0;\n  if (o) {\n    var k = o.getBoundingClientRect();\n    e = k.left, r = k.top, D = k.width, N = k.height;\n  }\n  var $ = {\n    left: e,\n    top: r,\n    width: D,\n    height: N,\n    right: e + D,\n    bottom: r + N\n  };\n  return o && t ? getExtendsRect(o, $) : $;\n}\nfunction getTotalDirection(o, t, e, r) {\n  var D;\n  if (o)\n    D = o;\n  else if (t)\n    D = [0, 0];\n  else {\n    var N = e.target;\n    D = getDirection(N, r);\n  }\n  return D;\n}\nfunction getDirection(o, t) {\n  if (o) {\n    var e = o.getAttribute(\"data-rotation\") || \"\", r = o.getAttribute(\"data-direction\");\n    if (t.deg = e, !!r) {\n      var D = [0, 0];\n      return r.indexOf(\"w\") > -1 && (D[0] = -1), r.indexOf(\"e\") > -1 && (D[0] = 1), r.indexOf(\"n\") > -1 && (D[1] = -1), r.indexOf(\"s\") > -1 && (D[1] = 1), D;\n    }\n  }\n}\nfunction getAbsolutePoses(o, t) {\n  return [plus(t, o[0]), plus(t, o[1]), plus(t, o[2]), plus(t, o[3])];\n}\nfunction getAbsolutePosesByState(o) {\n  var t = o.left, e = o.top, r = o.pos1, D = o.pos2, N = o.pos3, k = o.pos4;\n  return getAbsolutePoses([r, D, N, k], [t, e]);\n}\nfunction roundSign(o) {\n  return Math.round(o % 1 === -0.5 ? o - 1 : o);\n}\nfunction unset(o, t) {\n  var e;\n  (e = o[t]) === null || e === void 0 || e.unset(), o[t] = null;\n}\nfunction fillCSSObject(o, t) {\n  if (t) {\n    var e = getBeforeRenderableDatas(t);\n    e.nextStyle = __assign$1(__assign$1({}, e.nextStyle), o);\n  }\n  return {\n    style: o,\n    cssText: getKeys(o).map(function(r) {\n      return \"\".concat(decamelize(r, \"-\"), \": \").concat(o[r], \";\");\n    }).join(\"\")\n  };\n}\nfunction fillAfterTransform(o, t, e) {\n  var r = t.afterTransform || t.transform;\n  return __assign$1(__assign$1({}, fillCSSObject(__assign$1(__assign$1(__assign$1({}, o.style), t.style), {\n    transform: r\n  }), e)), {\n    afterTransform: r,\n    transform: o.transform\n  });\n}\nfunction fillParams(o, t, e, r) {\n  var D = t.datas;\n  D.datas || (D.datas = {});\n  var N = __assign$1(__assign$1({}, e), {\n    target: o.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: o,\n    moveable: o,\n    datas: D.datas,\n    isFirstDrag: !!t.isFirstDrag,\n    isTrusted: t.isTrusted !== !1,\n    stopAble: function() {\n      D.isEventStart = !1;\n    },\n    stopDrag: function() {\n      var k;\n      (k = t.stop) === null || k === void 0 || k.call(t);\n    }\n  });\n  return D.isStartEvent ? r || (D.lastEvent = N) : D.isStartEvent = !0, N;\n}\nfunction fillEndParams(o, t, e) {\n  var r = t.datas, D = \"isDrag\" in e ? e.isDrag : t.isDrag;\n  return r.datas || (r.datas = {}), __assign$1(__assign$1({\n    isDrag: D\n  }, e), {\n    moveable: o,\n    target: o.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: o,\n    lastEvent: r.lastEvent,\n    isDouble: t.isDouble,\n    datas: r.datas,\n    isFirstDrag: !!t.isFirstDrag\n  });\n}\nfunction catchEvent(o, t, e) {\n  o._emitter.on(t, e);\n}\nfunction triggerEvent(o, t, e, r) {\n  return o.triggerEvent(t, e, r);\n}\nfunction getComputedStyle$1$1(o, t) {\n  return window.getComputedStyle(o, t);\n}\nfunction filterAbles(o, t, e) {\n  var r = {}, D = {};\n  return o.filter(function(N) {\n    var k = N.name;\n    if (r[k] || !t.some(function($) {\n      return N[$];\n    }))\n      return !1;\n    if (!e && N.ableGroup) {\n      if (D[N.ableGroup])\n        return !1;\n      D[N.ableGroup] = !0;\n    }\n    return r[k] = !0, !0;\n  });\n}\nfunction equals(o, t) {\n  return o === t || o == null && t == null;\n}\nfunction selectValue() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  for (var e = o.length - 1, r = 0; r < e; ++r) {\n    var D = o[r];\n    if (!isUndefined(D))\n      return D;\n  }\n  return o[e];\n}\nfunction groupBy(o, t) {\n  var e = [], r = [];\n  return o.forEach(function(D, N) {\n    var k = t(D, N, o), $ = r.indexOf(k), G = e[$] || [];\n    $ === -1 && (r.push(k), e.push(G)), G.push(D);\n  }), e;\n}\nfunction groupByMap(o, t) {\n  var e = [], r = {};\n  return o.forEach(function(D, N) {\n    var k = t(D, N, o), $ = r[k];\n    $ || ($ = [], r[k] = $, e.push($)), $.push(D);\n  }), e;\n}\nfunction flat(o) {\n  return o.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction maxOffset() {\n  for (var o = [], t = 0; t < arguments.length; t++)\n    o[t] = arguments[t];\n  return o.sort(function(e, r) {\n    return Math.abs(r) - Math.abs(e);\n  }), o[0];\n}\nfunction calculateInversePosition(o, t, e) {\n  return calculate(invert(o, e), convertPositionMatrix(t, e), e);\n}\nfunction convertDragDist(o, t) {\n  var e, r = o.is3d, D = o.rootMatrix, N = r ? 4 : 3;\n  return e = calculateInversePosition(D, [t.distX, t.distY], N), t.distX = e[0], t.distY = e[1], t;\n}\nfunction calculatePadding(o, t, e, r, D) {\n  return minus(calculatePosition(o, plus(e, t), D), r);\n}\nfunction convertCSSSize(o, t, e) {\n  return e ? \"\".concat(o / t * 100, \"%\") : \"\".concat(o, \"px\");\n}\nfunction getTinyDist(o) {\n  return Math.abs(o) <= TINY_NUM ? 0 : o;\n}\nfunction getDirectionViewClassName(o) {\n  return function(t) {\n    if (!t.isDragging(o))\n      return \"\";\n    var e = getGestoData(t, o), r = e.deg;\n    return r ? prefix(\"view-control-rotation\".concat(r)) : \"\";\n  };\n}\nfunction getDirectionCondition(o, t) {\n  return t === void 0 && (t = [o]), function(e, r) {\n    if (r.isRequest)\n      return t.some(function(N) {\n        return r.requestAble === N;\n      }) ? r.parentDirection : !1;\n    var D = r.inputEvent.target;\n    return hasClass(D, prefix(\"direction\")) && (!o || hasClass(D, prefix(o)));\n  };\n}\nfunction invertObject(o) {\n  var t = {};\n  for (var e in o)\n    t[o[e]] = e;\n  return t;\n}\nfunction convertTransformInfo(o, t) {\n  var e = o.slice(0, t < 0 ? void 0 : t), r = o.slice(0, t < 0 ? void 0 : t + 1), D = o[t] || \"\", N = t < 0 ? [] : o.slice(t), k = t < 0 ? [] : o.slice(t + 1), $ = parse$1(e), G = parse$1(r), U = parse$1([D]), z = parse$1(N), X = parse$1(k), V = toMat($), Y = toMat(G), q = toMat(z), W = toMat(X), K = multiply(V, q, 4);\n  return {\n    transforms: o,\n    beforeFunctionMatrix: V,\n    beforeFunctionMatrix2: Y,\n    targetFunctionMatrix: toMat(U),\n    afterFunctionMatrix: q,\n    afterFunctionMatrix2: W,\n    allFunctionMatrix: K,\n    beforeFunctions: $,\n    beforeFunctions2: G,\n    targetFunction: U[0],\n    afterFunctions: z,\n    afterFunctions2: X,\n    beforeFunctionTexts: e,\n    beforeFunctionTexts2: r,\n    targetFunctionText: D,\n    afterFunctionTexts: N,\n    afterFunctionTexts2: k\n  };\n}\nfunction isArrayFormat(o) {\n  return !o || !isObject$2(o) || o instanceof Element ? !1 : isArray(o) || \"length\" in o;\n}\nfunction getRefTarget(o, t) {\n  return o ? o instanceof Element ? o : isString(o) ? t ? document.querySelector(o) : o : isFunction$2(o) ? o() : \"current\" in o ? o.current : o : null;\n}\nfunction getRefTargets(o, t) {\n  if (!o)\n    return [];\n  var e = isArrayFormat(o) ? [].slice.call(o) : [o];\n  return e.reduce(function(r, D) {\n    return isString(D) && t ? __spreadArray(__spreadArray([], r, !0), [].slice.call(document.querySelectorAll(D)), !0) : (isArray(D) ? r.push(getRefTargets(D, t)) : r.push(getRefTarget(D, t)), r);\n  }, []);\n}\nfunction getAbsoluteRotation(o, t, e) {\n  var r = getRad$1(o, t) / Math.PI * 180;\n  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;\n}\nfunction getDragDistByState(o, t) {\n  var e = o.rootMatrix, r = o.is3d, D = r ? 4 : 3, N = invert(e, D);\n  return r || (N = convertDimension(N, 3, 4)), N[12] = 0, N[13] = 0, N[14] = 0, calculateMatrixDist(N, t);\n}\nfunction getSizeDistByDist(o, t, e, r, D) {\n  var N = o[0], k = o[1], $ = 0, G = 0;\n  if (D && N && k) {\n    var U = getRad$1([0, 0], t), z = getRad$1([0, 0], r), X = getDistSize(t), V = Math.cos(U - z) * X;\n    if (!r[0])\n      G = V, $ = G * e;\n    else if (!r[1])\n      $ = V, G = $ / e;\n    else {\n      var Y = r[0] * 2 * N, q = r[1] * 2 * k, W = getDistSize([Y + t[0], q + t[1]]) - getDistSize([Y, q]), K = getRad$1([0, 0], [e, 1]);\n      $ = Math.cos(K) * W, G = Math.sin(K) * W;\n    }\n  } else\n    $ = r[0] * t[0], G = r[1] * t[1];\n  return [$, G];\n}\nfunction getOffsetSizeDist(o, t, e, r) {\n  var D, N = e.ratio, k = e.startOffsetWidth, $ = e.startOffsetHeight, G = 0, U = 0, z = r.distX, X = r.distY, V = r.parentDistance, Y = r.parentDist, q = r.parentScale, W = e.fixedDirection, K = [0, 1].map(function(tt) {\n    return Math.abs(o[tt] - W[tt]);\n  }), Z = [0, 1].map(function(tt) {\n    var it = K[tt];\n    return it !== 0 && (it = 2 / it), it;\n  });\n  if (Y)\n    G = Y[0], U = Y[1], t && (G ? U || (U = G / N) : G = U * N);\n  else if (q)\n    G = (q[0] - 1) * k, U = (q[1] - 1) * $;\n  else if (V) {\n    var J = k * K[0], Q = $ * K[1], et = getDistSize([J, Q]);\n    G = V / et * J * Z[0], U = V / et * Q * Z[1];\n  } else {\n    var nt = getDragDist({\n      datas: e,\n      distX: z,\n      distY: X\n    });\n    nt = Z.map(function(tt, it) {\n      return nt[it] * tt;\n    }), D = getSizeDistByDist([k, $], nt, N, o, t), G = D[0], U = D[1];\n  }\n  return {\n    // direction,\n    // sizeDirection,\n    distWidth: G,\n    distHeight: U\n  };\n}\nfunction convertTransformUnit(o, t) {\n  if (t) {\n    if (o === \"left\")\n      return {\n        x: \"0%\",\n        y: \"50%\"\n      };\n    if (o === \"top\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (o === \"center\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (o === \"right\")\n      return {\n        x: \"100%\",\n        y: \"50%\"\n      };\n    if (o === \"bottom\")\n      return {\n        x: \"50%\",\n        y: \"100%\"\n      };\n    var e = o.split(\" \"), r = e[0], D = e[1], N = convertTransformUnit(r || \"\"), k = convertTransformUnit(D || \"\"), $ = __assign$1(__assign$1({}, N), k), G = {\n      x: \"50%\",\n      y: \"50%\"\n    };\n    return $.x && (G.x = $.x), $.y && (G.y = $.y), $.value && ($.x && !$.y && (G.y = $.value), !$.x && $.y && (G.x = $.value)), G;\n  }\n  return o === \"left\" ? {\n    x: \"0%\"\n  } : o === \"right\" ? {\n    x: \"100%\"\n  } : o === \"top\" ? {\n    y: \"0%\"\n  } : o === \"bottom\" ? {\n    y: \"100%\"\n  } : o ? o === \"center\" ? {\n    value: \"50%\"\n  } : {\n    value: o\n  } : {};\n}\nfunction convertTransformOriginArray(o, t, e) {\n  var r = convertTransformUnit(o, !0), D = r.x, N = r.y;\n  return [convertUnitSize(D, t) || 0, convertUnitSize(N, e) || 0];\n}\nfunction rotatePosesInfo(o, t, e) {\n  var r = o.map(function(N) {\n    return minus(N, t);\n  }), D = r.map(function(N) {\n    return rotate(N, e);\n  });\n  return {\n    prev: r,\n    next: D,\n    result: D.map(function(N) {\n      return plus(N, t);\n    })\n  };\n}\nfunction isDeepArrayEquals(o, t) {\n  return o.length === t.length && o.every(function(e, r) {\n    var D = t[r], N = isArray(e), k = isArray(D);\n    return N && k ? isDeepArrayEquals(e, D) : !N && !k ? e === D : !1;\n  });\n}\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function() {\n    return !0;\n  },\n  pinchStart: function(o, t) {\n    var e = t.datas, r = t.targets, D = t.angle, N = t.originalDatas, k = o.props, $ = k.pinchable, G = k.ables;\n    if (!$)\n      return !1;\n    var U = \"onPinch\".concat(r ? \"Group\" : \"\", \"Start\"), z = \"drag\".concat(r ? \"Group\" : \"\", \"ControlStart\"), X = ($ === !0 ? o.controlAbles : G.filter(function(W) {\n      return $.indexOf(W.name) > -1;\n    })).filter(function(W) {\n      return W.canPinch && W[z];\n    }), V = fillParams(o, t, {});\n    r && (V.targets = r);\n    var Y = triggerEvent(o, U, V);\n    e.isPinch = Y !== !1, e.ables = X;\n    var q = e.isPinch;\n    return q ? (X.forEach(function(W) {\n      if (N[W.name] = N[W.name] || {}, !!W[z]) {\n        var K = __assign$1(__assign$1({}, t), {\n          datas: N[W.name],\n          parentRotate: D,\n          isPinch: !0\n        });\n        W[z](o, K);\n      }\n    }), o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: [0, 0]\n    }, q) : !1;\n  },\n  pinch: function(o, t) {\n    var e = t.datas, r = t.scale, D = t.distance, N = t.originalDatas, k = t.inputEvent, $ = t.targets, G = t.angle;\n    if (e.isPinch) {\n      var U = D * (1 - 1 / r), z = fillParams(o, t, {});\n      $ && (z.targets = $);\n      var X = \"onPinch\".concat($ ? \"Group\" : \"\");\n      triggerEvent(o, X, z);\n      var V = e.ables, Y = \"drag\".concat($ ? \"Group\" : \"\", \"Control\");\n      return V.forEach(function(q) {\n        q[Y] && q[Y](o, __assign$1(__assign$1({}, t), {\n          datas: N[q.name],\n          inputEvent: k,\n          parentDistance: U,\n          parentRotate: G,\n          isPinch: !0\n        }));\n      }), z;\n    }\n  },\n  pinchEnd: function(o, t) {\n    var e = t.datas, r = t.isPinch, D = t.inputEvent, N = t.targets, k = t.originalDatas;\n    if (e.isPinch) {\n      var $ = \"onPinch\".concat(N ? \"Group\" : \"\", \"End\"), G = fillEndParams(o, t, {\n        isDrag: r\n      });\n      N && (G.targets = N), triggerEvent(o, $, G);\n      var U = e.ables, z = \"drag\".concat(N ? \"Group\" : \"\", \"ControlEnd\");\n      return U.forEach(function(X) {\n        X[z] && X[z](o, __assign$1(__assign$1({}, t), {\n          isDrag: r,\n          datas: k[X.name],\n          inputEvent: D,\n          isPinch: !0\n        }));\n      }), r;\n    }\n  },\n  pinchGroupStart: function(o, t) {\n    return this.pinchStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  pinchGroup: function(o, t) {\n    return this.pinch(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  pinchGroupEnd: function(o, t) {\n    return this.pinchEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  }\n});\nfunction fillChildEvents(o, t, e) {\n  var r = e.originalDatas;\n  r.groupable = r.groupable || {};\n  var D = r.groupable;\n  D.childDatas = D.childDatas || [];\n  var N = D.childDatas;\n  return o.moveables.map(function(k, $) {\n    return N[$] = N[$] || {}, N[$][t] = N[$][t] || {}, __assign$1(__assign$1({}, e), {\n      datas: N[$][t],\n      originalDatas: N[$]\n    });\n  });\n}\nfunction triggerChildGesto(o, t, e, r, D, N, k) {\n  var $ = !!e.match(/Start$/g), G = !!e.match(/End$/g), U = D.isPinch, z = D.datas, X = fillChildEvents(o, t.name, D), V = o.moveables, Y = X.map(function(q, W) {\n    var K = V[W], Z = K.state, J = Z.gestos, Q = q;\n    if ($)\n      Q = new CustomGesto(k).dragStart(r, q);\n    else {\n      if (J[k] || (J[k] = z.childGestos[W]), !J[k])\n        return;\n      Q = setCustomDrag(q, Z, r, U, N, k);\n    }\n    var et = t[e](K, __assign$1(__assign$1({}, Q), {\n      parentFlag: !0\n    }));\n    return G && (J[k] = null), et;\n  });\n  return $ && (z.childGestos = V.map(function(q) {\n    return q.state.gestos[k];\n  })), Y;\n}\nfunction triggerChildAbles(o, t, e, r, D, N) {\n  D === void 0 && (D = function(z, X) {\n    return X;\n  });\n  var k = !!e.match(/End$/g), $ = fillChildEvents(o, t.name, r), G = o.moveables, U = $.map(function(z, X) {\n    var V = G[X], Y = z;\n    Y = D(V, z);\n    var q = t[e](V, __assign$1(__assign$1({}, Y), {\n      parentFlag: !0\n    }));\n    return q && N && N(V, z, q, X), k && (V.state.gestos = {}), q;\n  });\n  return U;\n}\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"], HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"], VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction hasGuidelines(o, t) {\n  var e = o.props, r = e.snappable, D = e.bounds, N = e.innerBounds, k = e.verticalGuidelines, $ = e.horizontalGuidelines, G = e.snapGridWidth, U = e.snapGridHeight, z = o.state, X = z.guidelines, V = z.enableSnap;\n  return !r || !V || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(G || U || D || N || X && X.length || k && k.length || $ && $.length);\n}\nfunction getSnapDirections(o) {\n  return o === !1 ? {} : o === !0 || !o ? {\n    left: !0,\n    right: !0,\n    top: !0,\n    bottom: !0\n  } : o;\n}\nfunction mapSnapDirectionPoses(o, t) {\n  var e = getSnapDirections(o), r = {};\n  for (var D in e)\n    D in t && e[D] && (r[D] = t[D]);\n  return r;\n}\nfunction splitSnapDirectionPoses(o, t) {\n  var e = mapSnapDirectionPoses(o, t), r = HORIZONTAL_NAMES.filter(function(N) {\n    return N in e;\n  }), D = VERTICAL_NAMES.filter(function(N) {\n    return N in e;\n  });\n  return {\n    horizontal: r.map(function(N) {\n      return e[N];\n    }),\n    vertical: D.map(function(N) {\n      return e[N];\n    })\n  };\n}\nfunction calculateContainerPos(o, t, e) {\n  var r = calculatePosition(o, [t.clientLeft, t.clientTop], e);\n  return [t.left + r[0], t.top + r[1]];\n}\nfunction solveLineConstants(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];\n  Math.abs(r) < TINY_NUM$1 && (r = 0), Math.abs(D) < TINY_NUM$1 && (D = 0);\n  var N = 0, k = 0, $ = 0;\n  return r ? D ? (N = -D / r, k = 1, $ = N * t[0] - t[1]) : (k = 1, $ = -t[1]) : (N = -1, $ = t[0]), [N, k, $].map(function(G) {\n    return throttle(G, TINY_NUM$1);\n  });\n}\nfunction checkMoveableSnapPoses(o, t, e, r) {\n  var D = o.props, N = selectValue(r, D.snapThreshold, 5);\n  return checkSnapPoses(o.state.guidelines, t, e, N);\n}\nfunction checkSnapPoses(o, t, e, r) {\n  return {\n    vertical: checkSnap(o, \"vertical\", t, r),\n    horizontal: checkSnap(o, \"horizontal\", e, r)\n  };\n}\nfunction checkSnapKeepRatio(o, t, e) {\n  var r = e[0], D = e[1], N = t[0], k = t[1], $ = minus(e, t), G = $[0], U = $[1], z = U > 0, X = G > 0;\n  G = getTinyDist(G), U = getTinyDist(U);\n  var V = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, Y = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (G === 0 && U === 0)\n    return {\n      vertical: V,\n      horizontal: Y\n    };\n  var q = checkMoveableSnapPoses(o, G ? [r] : [], U ? [D] : []), W = q.vertical, K = q.horizontal;\n  W.posInfos.filter(function(yt) {\n    var mt = yt.pos;\n    return X ? mt >= N : mt <= N;\n  }), K.posInfos.filter(function(yt) {\n    var mt = yt.pos;\n    return z ? mt >= k : mt <= k;\n  }), W.isSnap = W.posInfos.length > 0, K.isSnap = K.posInfos.length > 0;\n  var Z = getNearestSnapGuidelineInfo(W), J = Z.isSnap, Q = Z.guideline, et = getNearestSnapGuidelineInfo(K), nt = et.isSnap, tt = et.guideline, it = nt ? tt.pos[1] : 0, st = J ? Q.pos[0] : 0;\n  if (G === 0)\n    nt && (Y.isSnap = !0, Y.pos = tt.pos[1], Y.offset = D - Y.pos);\n  else if (U === 0)\n    J && (V.isSnap = !0, V.pos = st, V.offset = r - st);\n  else {\n    var at = U / G, ut = e[1] - at * r, ft = 0, ct = 0, vt = !1;\n    J ? (ct = st, ft = at * ct + ut, vt = !0) : nt && (ft = it, ct = (ft - ut) / at, vt = !0), vt && (V.isSnap = !0, V.pos = ct, V.offset = r - ct, Y.isSnap = !0, Y.pos = ft, Y.offset = D - ft);\n  }\n  return {\n    vertical: V,\n    horizontal: Y\n  };\n}\nfunction checkSnaps(o, t, e) {\n  var r = splitSnapDirectionPoses(o.props.snapDirections, t);\n  return checkMoveableSnapPoses(o, r.vertical, r.horizontal, e);\n}\nfunction getNearestSnapGuidelineInfo(o) {\n  var t = o.isSnap;\n  if (!t)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  var e = o.posInfos[0], r = e.guidelineInfos[0], D = r.offset, N = r.dist, k = r.guideline;\n  return {\n    isSnap: t,\n    offset: D,\n    dist: N,\n    pos: e.pos,\n    guideline: k\n  };\n}\nfunction checkSnap(o, t, e, r) {\n  if (!o || !o.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      posInfos: []\n    };\n  var D = t === \"vertical\", N = D ? 0 : 1, k = e.map(function(G, U) {\n    var z = o.map(function(X) {\n      var V = X.pos, Y = G - V[N];\n      return {\n        offset: Y,\n        dist: Math.abs(Y),\n        guideline: X\n      };\n    }).filter(function(X) {\n      var V = X.guideline, Y = X.dist, q = V.type;\n      return !(q !== t || Y > r);\n    }).sort(function(X, V) {\n      return X.dist - V.dist;\n    });\n    return {\n      pos: G,\n      index: U,\n      guidelineInfos: z\n    };\n  }).filter(function(G) {\n    return G.guidelineInfos.length > 0;\n  }).sort(function(G, U) {\n    return G.guidelineInfos[0].dist - U.guidelineInfos[0].dist;\n  }), $ = k.length > 0;\n  return {\n    isSnap: $,\n    index: $ ? k[0].index : -1,\n    posInfos: k\n  };\n}\nfunction getSnapInfosByDirection(o, t, e, r) {\n  r === void 0 && (r = 1);\n  var D = [];\n  if (e[0] && e[1])\n    D = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function($) {\n      return getPosByDirection(t, $);\n    });\n  else if (!e[0] && !e[1])\n    for (var N = [t[0], t[1], t[3], t[2], t[0]], k = 0; k < 4; ++k)\n      D.push(N[k]), D.push([(N[k][0] + N[k + 1][0]) / 2, (N[k][1] + N[k + 1][1]) / 2]);\n  else\n    o.props.keepRatio ? D = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function($) {\n      return getPosByDirection(t, $);\n    }) : (D = getPosesByDirection(t, e), D.length > 1 && D.push([(D[0][0] + D[1][0]) / 2, (D[0][1] + D[1][1]) / 2]));\n  return checkMoveableSnapPoses(o, D.map(function($) {\n    return $[0];\n  }), D.map(function($) {\n    return $[1];\n  }), r);\n}\nfunction checkSnapBoundPriority(o, t) {\n  var e = Math.abs(o.offset), r = Math.abs(t.offset);\n  return o.isBound && t.isBound ? r - e : o.isBound ? -1 : t.isBound ? 1 : o.isSnap && t.isSnap ? r - e : o.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : r < TINY_NUM ? -1 : e - r;\n}\nfunction getNearOffsetInfo(o, t) {\n  return o.slice().sort(function(e, r) {\n    var D = e.sign[t], N = r.sign[t], k = e.offset[t], $ = r.offset[t];\n    if (D) {\n      if (!N)\n        return -1;\n    } else\n      return 1;\n    return checkSnapBoundPriority({\n      isBound: e.isBound,\n      isSnap: e.isSnap,\n      offset: k\n    }, {\n      isBound: r.isBound,\n      isSnap: r.isSnap,\n      offset: $\n    });\n  })[0];\n}\nfunction getCheckSnapDirections(o, t, e) {\n  var r = [];\n  if (e)\n    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [o[0], -o[1]]], [t, [-o[0], o[1]]]), r.push([t, o]);\n  else if (o[0] && o[1] || !o[0] && !o[1]) {\n    var D = o[0] ? o : [1, 1];\n    [1, -1].forEach(function(k) {\n      [1, -1].forEach(function($) {\n        var G = [k * D[0], $ * D[1]];\n        t[0] === G[0] && t[1] === G[1] || r.push([t, G]);\n      });\n    });\n  } else if (o[0]) {\n    var N = Math.abs(t[0]) === 1 ? [1] : [1, -1];\n    N.forEach(function(k) {\n      r.push([[t[0], -1], [k * o[0], -1]], [[t[0], 0], [k * o[0], 0]], [[t[0], 1], [k * o[0], 1]]);\n    });\n  } else if (o[1]) {\n    var N = Math.abs(t[1]) === 1 ? [1] : [1, -1];\n    N.forEach(function($) {\n      r.push([[-1, t[1]], [-1, $ * o[1]]], [[0, t[1]], [0, $ * o[1]]], [[1, t[1]], [1, $ * o[1]]]);\n    });\n  }\n  return r;\n}\nfunction isStartLine(o, t) {\n  var e = average([t[0][0], t[1][0]]), r = average([t[0][1], t[1][1]]);\n  return {\n    vertical: e <= o[0],\n    horizontal: r <= o[1]\n  };\n}\nfunction hitTestLine(o, t) {\n  var e = t[0], r = t[1], D = r[0] - e[0], N = r[1] - e[1];\n  Math.abs(D) < TINY_NUM && (D = 0), Math.abs(N) < TINY_NUM && (N = 0);\n  var k, $;\n  if (!D)\n    k = e[0], $ = o[0];\n  else if (!N)\n    k = e[1], $ = o[1];\n  else {\n    var G = N / D;\n    k = G * (o[0] - e[0]) + e[1], $ = o[1];\n  }\n  return k - $;\n}\nfunction isSameStartLine(o, t, e, r) {\n  return r === void 0 && (r = TINY_NUM), o.every(function(D) {\n    var N = hitTestLine(D, t), k = N <= 0;\n    return k === e || Math.abs(N) <= r;\n  });\n}\nfunction checkInnerBoundDot(o, t, e, r, D) {\n  return D === void 0 && (D = 0), r && t - D <= o || !r && o <= e + D ? {\n    isBound: !0,\n    offset: r ? t - o : e - o\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction checkInnerBound(o, t) {\n  var e = t.line, r = t.centerSign, D = t.verticalSign, N = t.horizontalSign, k = t.lineConstants, $ = o.props.innerBounds;\n  if (!$)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var G = $.left, U = $.top, z = $.width, X = $.height, V = [[G, U], [G, U + X]], Y = [[G, U], [G + z, U]], q = [[G + z, U], [G + z, U + X]], W = [[G, U + X], [G + z, U + X]];\n  if (isSameStartLine([[G, U], [G + z, U], [G, U + X], [G + z, U + X]], e, r))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var K = checkLineBoundCollision(e, k, Y, D), Z = checkLineBoundCollision(e, k, W, D), J = checkLineBoundCollision(e, k, V, N), Q = checkLineBoundCollision(e, k, q, N), et = K.isBound && Z.isBound, nt = K.isBound || Z.isBound, tt = J.isBound && Q.isBound, it = J.isBound || Q.isBound, st = maxOffset(K.offset, Z.offset), at = maxOffset(J.offset, Q.offset), ut = [0, 0], ft = !1, ct = !1;\n  return Math.abs(at) < Math.abs(st) ? (ut = [st, 0], ft = nt, ct = et) : (ut = [0, at], ft = it, ct = tt), {\n    isAllBound: ct,\n    isVerticalBound: nt,\n    isHorizontalBound: it,\n    isBound: ft,\n    offset: ut\n  };\n}\nfunction checkLineBoundCollision(o, t, e, r, D, N) {\n  var k = t[0], $ = t[1], G = o[0], U = e[0], z = e[1], X = getTinyDist(z[1] - U[1]), V = getTinyDist(z[0] - U[0]), Y = $, q = k, W = -k / $;\n  if (V) {\n    if (!X) {\n      if (N && !Y)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (q) {\n        var Q = (U[1] - G[1]) / W + G[0];\n        return checkInnerBoundDot(Q, U[0], z[0], r, D);\n      } else {\n        var Z = U[1] - G[1], J = Math.abs(Z) <= (D || 0);\n        return {\n          isBound: J,\n          offset: J ? Z : 0\n        };\n      }\n    }\n  } else {\n    if (N && !q)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (Y) {\n      var K = W * (U[0] - G[0]) + G[1];\n      return checkInnerBoundDot(K, U[1], z[1], r, D);\n    } else {\n      var Z = U[0] - G[0], J = Math.abs(Z) <= (D || 0);\n      return {\n        isBound: J,\n        offset: J ? Z : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction getInnerBoundInfo(o, t, e) {\n  return t.map(function(r) {\n    var D = checkInnerBound(o, r), N = D.isBound, k = D.offset, $ = D.isVerticalBound, G = D.isHorizontalBound, U = r.multiple, z = getDragDist({\n      datas: e,\n      distX: k[0],\n      distY: k[1]\n    }).map(function(X, V) {\n      return X * (U[V] ? 2 / U[V] : 0);\n    });\n    return {\n      sign: U,\n      isBound: N,\n      isVerticalBound: $,\n      isHorizontalBound: G,\n      isSnap: !1,\n      offset: z\n    };\n  });\n}\nfunction getInnerBoundDragInfo(o, t, e) {\n  var r, D = getCheckInnerBoundLineInfos(o, t, [0, 0], !1).map(function(V) {\n    return __assign$1(__assign$1({}, V), {\n      multiple: V.multiple.map(function(Y) {\n        return Math.abs(Y) * 2;\n      })\n    });\n  }), N = getInnerBoundInfo(o, D, e), k = getNearOffsetInfo(N, 0), $ = getNearOffsetInfo(N, 1), G = 0, U = 0, z = k.isVerticalBound || $.isVerticalBound, X = k.isHorizontalBound || $.isHorizontalBound;\n  return (z || X) && (r = getInverseDragDist({\n    datas: e,\n    distX: -k.offset[0],\n    distY: -$.offset[1]\n  }), G = r[0], U = r[1]), {\n    vertical: {\n      isBound: z,\n      offset: G\n    },\n    horizontal: {\n      isBound: X,\n      offset: U\n    }\n  };\n}\nfunction getCheckSnapLineDirections(o, t) {\n  var e = [], r = o[0], D = o[1];\n  return r && D ? e.push([[0, D * 2], o, [-r, D]], [[r * 2, 0], o, [r, -D]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : D ? (e.push([[0, D * 2], [1, D], [-1, D]]), t && e.push([[-1, 0], [-1, D], [-1, -D]], [[1, 0], [1, D], [1, -D]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;\n}\nfunction getCheckInnerBoundLineInfos(o, t, e, r) {\n  var D = o.state, N = D.allMatrix, k = D.is3d, $ = calculatePoses(N, 100, 100, k ? 4 : 3), G = getPosByDirection($, [0, 0]);\n  return getCheckSnapLineDirections(e, r).map(function(U) {\n    var z = U[0], X = U[1], V = U[2], Y = [getPosByDirection($, X), getPosByDirection($, V)], q = solveLineConstants(Y), W = isStartLine(G, Y), K = W.vertical, Z = W.horizontal, J = hitTestLine(G, Y) <= 0;\n    return {\n      multiple: z,\n      centerSign: J,\n      verticalSign: K,\n      horizontalSign: Z,\n      lineConstants: q,\n      line: [getPosByDirection(t, X), getPosByDirection(t, V)]\n    };\n  });\n}\nfunction isBoundRotate$1(o, t, e, r) {\n  var D = r ? o.map(function(N) {\n    return rotate(N, r);\n  }) : o;\n  return [[D[0], D[1]], [D[1], D[3]], [D[3], D[2]], [D[2], D[0]]].some(function(N) {\n    var k = hitTestLine(e, N) <= 0;\n    return !isSameStartLine(t, N, k);\n  });\n}\nfunction getDistPointLine(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];\n  if (!r)\n    return Math.abs(t[0]);\n  if (!D)\n    return Math.abs(t[1]);\n  var N = D / r;\n  return Math.abs((-N * t[0] + t[1]) / Math.sqrt(Math.pow(N, 2) + 1));\n}\nfunction solveReverseLine(o) {\n  var t = o[0], e = o[1], r = e[0] - t[0], D = e[1] - t[1];\n  if (!r)\n    return [t[0], 0];\n  if (!D)\n    return [0, t[1]];\n  var N = D / r, k = -N * t[0] + t[1];\n  return [-k / (N + 1 / N), k / (N * N + 1)];\n}\nfunction checkRotateInnerBounds(o, t, e, r, D) {\n  var N = o.props.innerBounds, k = D * Math.PI / 180;\n  if (!N)\n    return [];\n  var $ = N.left, G = N.top, U = N.width, z = N.height, X = $ - r[0], V = $ + U - r[0], Y = G - r[1], q = G + z - r[1], W = [[X, Y], [V, Y], [X, q], [V, q]], K = getPosByDirection(e, [0, 0]);\n  if (!isBoundRotate$1(e, W, K, 0))\n    return [];\n  var Z = [], J = W.map(function(Q) {\n    return [getDistSize(Q), getRad$1([0, 0], Q)];\n  });\n  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(Q) {\n    var et = getRad$1([0, 0], solveReverseLine(Q)), nt = getDistPointLine(Q);\n    Z.push.apply(Z, J.filter(function(tt) {\n      var it = tt[0];\n      return it && nt <= it;\n    }).map(function(tt) {\n      var it = tt[0], st = tt[1], at = Math.acos(it ? nt / it : 0), ut = st + at, ft = st - at;\n      return [k + ut - et, k + ft - et];\n    }).reduce(function(tt, it) {\n      return tt.push.apply(tt, it), tt;\n    }, []).filter(function(tt) {\n      return !isBoundRotate$1(t, W, K, tt);\n    }).map(function(tt) {\n      return throttle(tt * 180 / Math.PI, TINY_NUM);\n    }));\n  }), Z;\n}\nfunction checkInnerBoundPoses(o) {\n  var t = o.props.innerBounds;\n  if (!t)\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  var e = o.getRect(), r = e.pos1, D = e.pos2, N = e.pos3, k = e.pos4, $ = [r, D, N, k], G = getPosByDirection($, [0, 0]), U = t.left, z = t.top, X = t.width, V = t.height, Y = [[U, z], [U, z + V]], q = [[U, z], [U + X, z]], W = [[U + X, z], [U + X, z + V]], K = [[U, z + V], [U + X, z + V]], Z = getCheckInnerBoundLineInfos(o, $, [0, 0], !1), J = [], Q = [], et = {\n    top: !1,\n    bottom: !1,\n    left: !1,\n    right: !1\n  };\n  return Z.forEach(function(nt) {\n    var tt = nt.line, it = nt.lineConstants, st = isStartLine(G, tt), at = st.horizontal, ut = st.vertical, ft = checkLineBoundCollision(tt, it, q, ut, 1, !0), ct = checkLineBoundCollision(tt, it, K, ut, 1, !0), vt = checkLineBoundCollision(tt, it, Y, at, 1, !0), yt = checkLineBoundCollision(tt, it, W, at, 1, !0);\n    ft.isBound && !et.top && (J.push(z), et.top = !0), ct.isBound && !et.bottom && (J.push(z + V), et.bottom = !0), vt.isBound && !et.left && (Q.push(U), et.left = !0), yt.isBound && !et.right && (Q.push(U + X), et.right = !0);\n  }), {\n    horizontal: J,\n    vertical: Q\n  };\n}\nfunction checkBoundPoses(o, t, e) {\n  var r = o || {}, D = r.position, N = D === void 0 ? \"client\" : D, k = r.left, $ = k === void 0 ? -1 / 0 : k, G = r.top, U = G === void 0 ? -1 / 0 : G, z = r.right, X = z === void 0 ? 1 / 0 : z, V = r.bottom, Y = V === void 0 ? 1 / 0 : V, q = {\n    position: N,\n    left: $,\n    top: U,\n    right: X,\n    bottom: Y\n  };\n  return {\n    vertical: checkBounds(q, t, !0),\n    horizontal: checkBounds(q, e, !1)\n  };\n}\nfunction getBounds(o, t) {\n  var e = o.state, r = e.containerClientRect, D = r.clientHeight, N = r.clientWidth, k = r.clientLeft, $ = r.clientTop, G = e.snapOffset, U = G.left, z = G.top, X = G.right, V = G.bottom, Y = t || o.props.bounds || {}, q = Y.position || \"client\", W = q === \"css\", K = Y.left, Z = K === void 0 ? -1 / 0 : K, J = Y.top, Q = J === void 0 ? -1 / 0 : J, et = Y.right, nt = et === void 0 ? W ? -1 / 0 : 1 / 0 : et, tt = Y.bottom, it = tt === void 0 ? W ? -1 / 0 : 1 / 0 : tt;\n  return W && (nt = N + X - U - nt, it = D + V - z - it), {\n    left: Z + U - k,\n    right: nt + U - k,\n    top: Q + z - $,\n    bottom: it + z - $\n  };\n}\nfunction checkBoundKeepRatio(o, t, e) {\n  var r = getBounds(o), D = r.left, N = r.top, k = r.right, $ = r.bottom, G = e[0], U = e[1], z = minus(e, t), X = z[0], V = z[1];\n  Math.abs(X) < TINY_NUM && (X = 0), Math.abs(V) < TINY_NUM && (V = 0);\n  var Y = V > 0, q = X > 0, W = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, K = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (X === 0 && V === 0)\n    return {\n      vertical: W,\n      horizontal: K\n    };\n  if (X === 0)\n    Y ? $ < U && (K.pos = $, K.offset = U - $) : N > U && (K.pos = N, K.offset = U - N);\n  else if (V === 0)\n    q ? k < G && (W.pos = k, W.offset = G - k) : D > G && (W.pos = D, W.offset = G - D);\n  else {\n    var Z = V / X, J = e[1] - Z * G, Q = 0, et = 0, nt = !1;\n    q && k <= G ? (Q = Z * k + J, et = k, nt = !0) : !q && G <= D && (Q = Z * D + J, et = D, nt = !0), nt && (Q < N || Q > $) && (nt = !1), nt || (Y && $ <= U ? (Q = $, et = (Q - J) / Z, nt = !0) : !Y && U <= N && (Q = N, et = (Q - J) / Z, nt = !0)), nt && (W.isBound = !0, W.pos = et, W.offset = G - et, K.isBound = !0, K.pos = Q, K.offset = U - Q);\n  }\n  return {\n    vertical: W,\n    horizontal: K\n  };\n}\nfunction checkBounds(o, t, e) {\n  var r = o[e ? \"left\" : \"top\"], D = o[e ? \"right\" : \"bottom\"], N = Math.min.apply(Math, t), k = Math.max.apply(Math, t), $ = [];\n  return r + 1 > N && $.push({\n    isBound: !0,\n    offset: N - r,\n    pos: r\n  }), D - 1 < k && $.push({\n    isBound: !0,\n    offset: k - D,\n    pos: D\n  }), $.length || $.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), $.sort(function(G, U) {\n    return Math.abs(U.offset) - Math.abs(G.offset);\n  });\n}\nfunction isBoundRotate(o, t, e) {\n  var r = e ? o.map(function(D) {\n    return rotate(D, e);\n  }) : o;\n  return r.some(function(D) {\n    return D[0] < t.left && Math.abs(D[0] - t.left) > 0.1 || D[0] > t.right && Math.abs(D[0] - t.right) > 0.1 || D[1] < t.top && Math.abs(D[1] - t.top) > 0.1 || D[1] > t.bottom && Math.abs(D[1] - t.bottom) > 0.1;\n  });\n}\nfunction boundRotate(o, t, e) {\n  var r = getDistSize(o), D = Math.sqrt(r * r - t * t) || 0;\n  return [D, -D].sort(function(N, k) {\n    return Math.abs(N - o[e ? 0 : 1]) - Math.abs(k - o[e ? 0 : 1]);\n  }).map(function(N) {\n    return getRad$1([0, 0], e ? [N, t] : [t, N]);\n  });\n}\nfunction checkRotateBounds(o, t, e, r, D) {\n  if (!o.props.bounds)\n    return [];\n  var N = D * Math.PI / 180, k = getBounds(o), $ = k.left, G = k.top, U = k.right, z = k.bottom, X = $ - r[0], V = U - r[0], Y = G - r[1], q = z - r[1], W = {\n    left: X,\n    top: Y,\n    right: V,\n    bottom: q\n  };\n  if (!isBoundRotate(e, W, 0))\n    return [];\n  var K = [];\n  return [[X, 0], [V, 0], [Y, 1], [q, 1]].forEach(function(Z) {\n    var J = Z[0], Q = Z[1];\n    e.forEach(function(et) {\n      var nt = getRad$1([0, 0], et);\n      K.push.apply(K, boundRotate(et, J, Q).map(function(tt) {\n        return N + tt - nt;\n      }).filter(function(tt) {\n        return !isBoundRotate(t, W, tt);\n      }).map(function(tt) {\n        return throttle(tt * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  }), K;\n}\nfunction renderGuideline(o, t) {\n  var e, r = o.direction, D = o.classNames, N = o.size, k = o.pos, $ = o.zoom, G = o.key, U = r === \"horizontal\", z = U ? \"Y\" : \"X\";\n  return t.createElement(\"div\", {\n    key: G,\n    className: D.join(\" \"),\n    style: (e = {}, e[U ? \"width\" : \"height\"] = \"\".concat(N), e.transform = \"translate(\".concat(k[0], \", \").concat(k[1], \") translate\").concat(z, \"(-50%) scale\").concat(z, \"(\").concat($, \")\"), e)\n  });\n}\nfunction renderInnerGuideline(o, t) {\n  return renderGuideline(__assign$1(__assign$1({}, o), {\n    classNames: __spreadArray([prefix(\"line\", \"guideline\", o.direction)], o.classNames, !0).filter(function(e) {\n      return e;\n    }),\n    size: o.size || \"\".concat(o.sizeValue, \"px\"),\n    pos: o.pos || o.posValue.map(function(e) {\n      return \"\".concat(throttle(e, 0.1), \"px\");\n    })\n  }), t);\n}\nfunction renderSnapPoses(o, t, e, r, D, N, k, $) {\n  var G = o.props.zoom;\n  return e.map(function(U, z) {\n    var X = U.type, V = U.pos, Y = [0, 0];\n    return Y[k] = r, Y[k ? 0 : 1] = -D + V, renderInnerGuideline({\n      key: \"\".concat(t, \"TargetGuideline\").concat(z),\n      classNames: [prefix(\"target\", \"bold\", X)],\n      posValue: Y,\n      sizeValue: N,\n      zoom: G,\n      direction: t\n    }, $);\n  });\n}\nfunction renderGuidelines(o, t, e, r, D, N) {\n  var k = o.props, $ = k.zoom, G = k.isDisplayInnerSnapDigit, U = t === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, z = D[U.start], X = D[U.end];\n  return e.filter(function(V) {\n    var Y = V.hide, q = V.elementRect;\n    if (Y)\n      return !1;\n    if (G && q) {\n      var W = q.rect;\n      if (W[U.start] <= z && X <= W[U.end])\n        return !1;\n    }\n    return !0;\n  }).map(function(V, Y) {\n    var q = V.pos, W = V.size, K = V.element, Z = V.className, J = [-r[0] + q[0], -r[1] + q[1]];\n    return renderInnerGuideline({\n      key: \"\".concat(t, \"-default-guideline-\").concat(Y),\n      classNames: K ? [prefix(\"bold\"), Z] : [prefix(\"normal\"), Z],\n      direction: t,\n      posValue: J,\n      sizeValue: W,\n      zoom: $\n    }, N);\n  });\n}\nfunction renderDigitLine(o, t, e, r, D, N, k, $) {\n  var G, U = o.props, z = U.snapDigit, X = z === void 0 ? 0 : z, V = U.isDisplaySnapDigit, Y = V === void 0 ? !0 : V, q = U.snapDistFormat, W = q === void 0 ? function(nt, tt) {\n    return nt;\n  } : q, K = U.zoom, Z = t === \"horizontal\" ? \"X\" : \"Y\", J = t === \"vertical\" ? \"height\" : \"width\", Q = Math.abs(D), et = Y ? parseFloat(Q.toFixed(X)) : 0;\n  return $.createElement(\"div\", {\n    key: \"\".concat(t, \"-\").concat(e, \"-guideline-\").concat(r),\n    className: prefix(\"guideline-group\", t),\n    style: (G = {\n      left: \"\".concat(N[0], \"px\"),\n      top: \"\".concat(N[1], \"px\")\n    }, G[J] = \"\".concat(Q, \"px\"), G)\n  }, renderInnerGuideline({\n    direction: t,\n    classNames: [prefix(e), k],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: Q,\n    zoom: K\n  }, $), $.createElement(\"div\", {\n    className: prefix(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(Z, \"(-50%) scale(\").concat(K, \")\")\n    }\n  }, et > 0 ? W(et, t) : \"\"));\n}\nfunction groupByElementGuidelines(o, t, e, r) {\n  var D = o === \"vertical\" ? 0 : 1, N = o === \"vertical\" ? 1 : 0, k = D ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, $ = e[k.start], G = e[k.end];\n  return groupBy(t, function(U) {\n    return U.pos[D];\n  }).map(function(U) {\n    var z = [], X = [], V = [];\n    return U.forEach(function(Y) {\n      var q, W, K = Y.element, Z = Y.elementRect.rect;\n      if (Z[k.end] < $)\n        z.push(Y);\n      else if (G < Z[k.start])\n        X.push(Y);\n      else if (Z[k.start] <= $ && G <= Z[k.end] && r) {\n        var J = Y.pos, Q = {\n          element: K,\n          rect: __assign$1(__assign$1({}, Z), (q = {}, q[k.end] = Z[k.start], q))\n        }, et = {\n          element: K,\n          rect: __assign$1(__assign$1({}, Z), (W = {}, W[k.start] = Z[k.end], W))\n        }, nt = [0, 0], tt = [0, 0];\n        nt[D] = J[D], nt[N] = J[N], tt[D] = J[D], tt[N] = J[N] + Y.size, z.push({\n          type: o,\n          pos: nt,\n          size: 0,\n          elementRect: Q\n        }), X.push({\n          type: o,\n          pos: tt,\n          size: 0,\n          elementRect: et\n        });\n      }\n    }), z.sort(function(Y, q) {\n      return q.pos[N] - Y.pos[N];\n    }), X.sort(function(Y, q) {\n      return Y.pos[N] - q.pos[N];\n    }), {\n      total: U,\n      start: z,\n      end: X,\n      inner: V\n    };\n  });\n}\nfunction renderDashedGuidelines(o, t, e, r, D) {\n  var N = o.props.isDisplayInnerSnapDigit, k = [];\n  return [\"vertical\", \"horizontal\"].forEach(function($) {\n    var G = t.filter(function(K) {\n      return K.type === $;\n    }), U = $ === \"vertical\" ? 1 : 0, z = U ? 0 : 1, X = groupByElementGuidelines($, G, r, N), V = U ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, Y = U ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, q = r[V.start], W = r[V.end];\n    X.forEach(function(K) {\n      var Z = K.total, J = K.start, Q = K.end, et = K.inner, nt = e[z] + Z[0].pos[z] - r[Y.start], tt = r;\n      J.forEach(function(it) {\n        var st = it.elementRect.rect, at = tt[V.start] - st[V.end];\n        if (at > 0) {\n          var ut = [0, 0];\n          ut[U] = e[U] + tt[V.start] - q - at, ut[z] = nt, k.push(renderDigitLine(o, $, \"dashed\", k.length, at, ut, it.className, D));\n        }\n        tt = st;\n      }), tt = r, Q.forEach(function(it) {\n        var st = it.elementRect.rect, at = st[V.start] - tt[V.end];\n        if (at > 0) {\n          var ut = [0, 0];\n          ut[U] = e[U] + tt[V.end] - q, ut[z] = nt, k.push(renderDigitLine(o, $, \"dashed\", k.length, at, ut, it.className, D));\n        }\n        tt = st;\n      }), et.forEach(function(it) {\n        var st = it.elementRect.rect, at = q - st[V.start], ut = st[V.end] - W, ft = [0, 0], ct = [0, 0];\n        ft[U] = e[U] - at, ft[z] = nt, ct[U] = e[U] + W - q, ct[z] = nt, k.push(renderDigitLine(o, $, \"dashed\", k.length, at, ft, it.className, D)), k.push(renderDigitLine(o, $, \"dashed\", k.length, ut, ct, it.className, D));\n      });\n    });\n  }), k;\n}\nfunction renderGapGuidelines(o, t, e, r, D) {\n  var N = [];\n  return [\"horizontal\", \"vertical\"].forEach(function(k) {\n    var $ = t.filter(function(K) {\n      return K.type === k;\n    }).slice(0, 1), G = k === \"vertical\" ? 0 : 1, U = G ? 0 : 1, z = G ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = G ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, V = r[z.start], Y = r[z.end], q = r[X.start], W = r[X.end];\n    $.forEach(function(K) {\n      var Z = K.gap, J = K.gapRects, Q = Math.max.apply(Math, __spreadArray([q], J.map(function(tt) {\n        var it = tt.rect;\n        return it[X.start];\n      }), !1)), et = Math.min.apply(Math, __spreadArray([W], J.map(function(tt) {\n        var it = tt.rect;\n        return it[X.end];\n      }), !1)), nt = (Q + et) / 2;\n      Q === et || nt === (q + W) / 2 || J.forEach(function(tt) {\n        var it = tt.rect, st = tt.className, at = [e[0], e[1]];\n        if (it[z.end] < V)\n          at[G] += it[z.end] - V;\n        else if (Y < it[z.start])\n          at[G] += it[z.start] - V - Z;\n        else\n          return;\n        at[U] += nt - q, N.push(renderDigitLine(o, G ? \"vertical\" : \"horizontal\", \"gap\", N.length, Z, at, st, D));\n      });\n    });\n  }), N;\n}\nfunction solveEquation(o, t, e, r) {\n  var D = t[0] - o[0], N = t[1] - o[1];\n  if (Math.abs(D) < TINY_NUM$1 && (D = 0), Math.abs(N) < TINY_NUM$1 && (N = 0), !D)\n    return r ? [0, 0] : [0, e];\n  if (!N)\n    return r ? [e, 0] : [0, 0];\n  var k = N / D, $ = o[1] - k * o[0];\n  if (r) {\n    var G = k * (t[0] + e) + $;\n    return [e, G - t[1]];\n  } else {\n    var U = (t[1] + e - $) / k;\n    return [U - t[0], e];\n  }\n}\nfunction solveNextOffset(o, t, e, r, D) {\n  var N = solveEquation(o, t, e, r);\n  if (!N)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  var k = getDist$2(o, t), $ = getDist$2(N, o), G = getDist$2(N, t), U = $ > k || G > k, z = getDragDist({\n    datas: D,\n    distX: N[0],\n    distY: N[1]\n  }), X = z[0], V = z[1];\n  return {\n    offset: [X, V],\n    isOutside: U\n  };\n}\nfunction getSnapBound(o, t) {\n  return o.isBound ? o.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;\n}\nfunction checkThrottleDragRotate(o, t, e, r, D) {\n  var N = t[0], k = t[1], $ = e[0], G = e[1], U = r[0], z = r[1], X = D[0], V = D[1], Y = -X, q = -V;\n  if (o && N && k) {\n    Y = 0, q = 0;\n    var W = [];\n    if ($ && G ? W.push([0, V], [X, 0]) : $ ? W.push([X, 0]) : G ? W.push([0, V]) : U && z ? W.push([0, V], [X, 0]) : U ? W.push([X, 0]) : z && W.push([0, V]), W.length) {\n      W.sort(function(Q, et) {\n        return getDistSize(minus([N, k], Q)) - getDistSize(minus([N, k], et));\n      });\n      var K = W[0];\n      if (K[0] && Math.abs(N) > TINY_NUM$1)\n        Y = -K[0], q = k * Math.abs(N + Y) / Math.abs(N) - k;\n      else if (K[1] && Math.abs(k) > TINY_NUM$1) {\n        var Z = k;\n        q = -K[1], Y = N * Math.abs(k + q) / Math.abs(Z) - N;\n      }\n      if (o && G && $)\n        if (Math.abs(Y) > TINY_NUM$1 && Math.abs(Y) < Math.abs(X)) {\n          var J = Math.abs(X) / Math.abs(Y);\n          Y *= J, q *= J;\n        } else if (Math.abs(q) > TINY_NUM$1 && Math.abs(q) < Math.abs(V)) {\n          var J = Math.abs(V) / Math.abs(q);\n          Y *= J, q *= J;\n        } else\n          Y = maxOffset(-X, Y), q = maxOffset(-V, q);\n    }\n  } else\n    Y = N || $ ? -X : 0, q = k || G ? -V : 0;\n  return [Y, q];\n}\nfunction checkSnapBoundsDrag(o, t, e, r, D, N) {\n  if (!hasGuidelines(o, \"draggable\"))\n    return [{\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }, {\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }];\n  var k = getAbsolutePoses(N.absolutePoses, [t, e]), $ = getRect(k), G = $.left, U = $.right, z = $.top, X = $.bottom, V = {\n    horizontal: k.map(function(yt) {\n      return yt[1];\n    }),\n    vertical: k.map(function(yt) {\n      return yt[0];\n    })\n  }, Y = getSnapDirections(o.props.snapDirections), q = splitSnapDirectionPoses(Y, {\n    left: G,\n    right: U,\n    top: z,\n    bottom: X,\n    center: (G + U) / 2,\n    middle: (z + X) / 2\n  }), W = checkMoveableSnapBounds(o, D, q, V), K = W.vertical, Z = W.horizontal, J = getInnerBoundDragInfo(o, k, N), Q = J.vertical, et = J.horizontal, nt = K.isSnap, tt = Z.isSnap, it = K.isBound || Q.isBound, st = Z.isBound || et.isBound, at = maxOffset(K.offset, Q.offset), ut = maxOffset(Z.offset, et.offset), ft = checkThrottleDragRotate(r, [t, e], [it, st], [nt, tt], [at, ut]), ct = ft[0], vt = ft[1];\n  return [{\n    isBound: it,\n    isSnap: nt,\n    offset: ct\n  }, {\n    isBound: st,\n    isSnap: tt,\n    offset: vt\n  }];\n}\nfunction checkMoveableSnapBounds(o, t, e, r) {\n  r === void 0 && (r = e);\n  var D = checkBoundPoses(getBounds(o), r.vertical, r.horizontal), N = D.horizontal, k = D.vertical, $ = t ? {\n    horizontal: {\n      isSnap: !1,\n      index: -1\n    },\n    vertical: {\n      isSnap: !1,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(o, e.vertical, e.horizontal), G = $.horizontal, U = $.vertical, z = getSnapBound(N[0], G), X = getSnapBound(k[0], U), V = Math.abs(z), Y = Math.abs(X);\n  return {\n    horizontal: {\n      isBound: N[0].isBound,\n      isSnap: G.isSnap,\n      snapIndex: G.index,\n      offset: z,\n      dist: V,\n      bounds: N,\n      snap: G\n    },\n    vertical: {\n      isBound: k[0].isBound,\n      isSnap: U.isSnap,\n      snapIndex: U.index,\n      offset: X,\n      dist: Y,\n      bounds: k,\n      snap: U\n    }\n  };\n}\nfunction checkSnapBounds(o, t, e, r, D) {\n  var N = checkBoundPoses(t, e, r), k = N.horizontal, $ = N.vertical, G = checkSnapPoses(o, e, r, D), U = G.horizontal, z = G.vertical, X = getSnapBound(k[0], U), V = getSnapBound($[0], z), Y = Math.abs(X), q = Math.abs(V);\n  return {\n    horizontal: {\n      isBound: k[0].isBound,\n      isSnap: U.isSnap,\n      snapIndex: U.index,\n      offset: X,\n      dist: Y,\n      bounds: k,\n      snap: U\n    },\n    vertical: {\n      isBound: $[0].isBound,\n      isSnap: z.isSnap,\n      snapIndex: z.index,\n      offset: V,\n      dist: q,\n      bounds: $,\n      snap: z\n    }\n  };\n}\nfunction checkSnapRightLine(o, t, e, r) {\n  var D = getRad$1(o, t) / Math.PI * 180, N = e.vertical, k = N.isBound, $ = N.isSnap, G = N.dist, U = e.horizontal, z = U.isBound, X = U.isSnap, V = U.dist, Y = D % 180, q = Y < 3 || Y > 177, W = Y > 87 && Y < 93;\n  return V < G && (k || $ && !W && (!r || !q)) ? \"vertical\" : z || X && !q && (!r || !W) ? \"horizontal\" : \"\";\n}\nfunction getSnapBoundInfo(o, t, e, r, D, N) {\n  return e.map(function(k) {\n    var $ = k[0], G = k[1], U = getPosByDirection(t, $), z = getPosByDirection(t, G), X = r ? checkSnapBoundsKeepRatio(o, U, z, D) : checkMoveableSnapBounds(o, D, {\n      vertical: [z[0]],\n      horizontal: [z[1]]\n    }), V = X.horizontal, Y = V.offset, q = V.isBound, W = V.isSnap, K = X.vertical, Z = K.offset, J = K.isBound, Q = K.isSnap, et = minus(G, $);\n    if (!Z && !Y)\n      return {\n        isBound: J || q,\n        isSnap: Q || W,\n        sign: et,\n        offset: [0, 0]\n      };\n    var nt = checkSnapRightLine(U, z, X, r);\n    if (!nt)\n      return {\n        sign: et,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    var tt = nt === \"vertical\", it = [0, 0];\n    return !r && Math.abs(G[0]) === 1 && Math.abs(G[1]) === 1 && $[0] !== G[0] && $[1] !== G[1] ? it = getDragDist({\n      datas: N,\n      distX: -Z,\n      distY: -Y\n    }) : it = solveNextOffset(U, z, -(tt ? Z : Y), tt, N).offset, it = it.map(function(st, at) {\n      return st * (et[at] ? 2 / et[at] : 0);\n    }), {\n      sign: et,\n      isBound: tt ? J : q,\n      isSnap: tt ? Q : W,\n      offset: it\n    };\n  });\n}\nfunction getSnapBoundOffset(o, t) {\n  return o.isBound ? o.offset : t.isSnap ? t.offset : 0;\n}\nfunction checkSnapBoundsKeepRatio(o, t, e, r) {\n  var D = checkBoundKeepRatio(o, t, e), N = D.horizontal, k = D.vertical, $ = r ? {\n    horizontal: {\n      isSnap: !1\n    },\n    vertical: {\n      isSnap: !1\n    }\n  } : checkSnapKeepRatio(o, t, e), G = $.horizontal, U = $.vertical, z = getSnapBoundOffset(N, G), X = getSnapBoundOffset(k, U), V = Math.abs(z), Y = Math.abs(X);\n  return {\n    horizontal: {\n      isBound: N.isBound,\n      isSnap: G.isSnap,\n      offset: z,\n      dist: V\n    },\n    vertical: {\n      isBound: k.isBound,\n      isSnap: U.isSnap,\n      offset: X,\n      dist: Y\n    }\n  };\n}\nfunction checkMaxBounds(o, t, e, r, D) {\n  var N = [-e[0], -e[1]], k = o.state, $ = k.width, G = k.height, U = o.props.bounds, z = 1 / 0, X = 1 / 0;\n  if (U) {\n    var V = [[e[0], -e[1]], [-e[0], e[1]]], Y = U.left, q = Y === void 0 ? -1 / 0 : Y, W = U.top, K = W === void 0 ? -1 / 0 : W, Z = U.right, J = Z === void 0 ? 1 / 0 : Z, Q = U.bottom, et = Q === void 0 ? 1 / 0 : Q;\n    V.forEach(function(nt) {\n      var tt = nt[0] !== N[0], it = nt[1] !== N[1], st = getPosByDirection(t, nt), at = getRad$1(r, st) * 360 / Math.PI;\n      if (it) {\n        var ut = st.slice();\n        (Math.abs(at - 360) < 2 || Math.abs(at - 180) < 2) && (ut[1] = r[1]);\n        var ft = solveNextOffset(r, ut, (r[1] < st[1] ? et : K) - st[1], !1, D), ct = ft.offset, vt = ct[1], yt = ft.isOutside;\n        isNaN(vt) || (X = G + (yt ? 1 : -1) * Math.abs(vt));\n      }\n      if (tt) {\n        var ut = st.slice();\n        (Math.abs(at - 90) < 2 || Math.abs(at - 270) < 2) && (ut[0] = r[0]);\n        var mt = solveNextOffset(r, ut, (r[0] < st[0] ? J : q) - st[0], !0, D), _t = mt.offset[0], Tt = mt.isOutside;\n        isNaN(_t) || (z = $ + (Tt ? 1 : -1) * Math.abs(_t));\n      }\n    });\n  }\n  return {\n    maxWidth: z,\n    maxHeight: X\n  };\n}\nfunction getTotalGuidelines(o) {\n  var t = o.state, e = t.containerClientRect, r = t.hasFixed, D = e.overflow, N = e.scrollHeight, k = e.scrollWidth, $ = e.clientHeight, G = e.clientWidth, U = e.clientLeft, z = e.clientTop, X = o.props, V = X.snapGap, Y = V === void 0 ? !0 : V, q = X.verticalGuidelines, W = X.horizontalGuidelines, K = X.snapThreshold, Z = K === void 0 ? 5 : K, J = X.snapGridWidth, Q = J === void 0 ? 0 : J, et = X.snapGridHeight, nt = et === void 0 ? 0 : et, tt = X.maxSnapElementGuidelineDistance, it = tt === void 0 ? 1 / 0 : tt, st = getRect(getAbsolutePosesByState(o.state)), at = st.top, ut = st.left, ft = st.bottom, ct = st.right, vt = {\n    top: at,\n    left: ut,\n    bottom: ft,\n    right: ct,\n    center: (ut + ct) / 2,\n    middle: (at + ft) / 2\n  }, yt = getElementGuidelines(o), mt = __spreadArray([], yt, !0);\n  Y && mt.push.apply(mt, getGapGuidelines(o, vt, Z)), mt.push.apply(mt, getGridGuidelines(Q, nt, D ? k : G, D ? N : $, U, z));\n  var _t = __assign$1({}, t.snapOffset || {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  });\n  if (r) {\n    var Tt = e.left, Pt = e.top;\n    _t.left += Tt, _t.top += Pt, _t.right += Tt, _t.bottom += Pt;\n  }\n  return mt.push.apply(mt, getDefaultGuidelines(W || !1, q || !1, D ? k : G, D ? N : $, U, z, _t)), mt = mt.filter(function(St) {\n    var gt = St.element, bt = St.elementRect, Nt = St.type;\n    if (!gt || !bt)\n      return !0;\n    var At = bt.rect;\n    return checkBetweenRects(vt, At, Nt, it);\n  }), mt;\n}\nfunction getGapGuidelines(o, t, e) {\n  var r = o.props, D = r.maxSnapElementGuidelineDistance, N = D === void 0 ? 1 / 0 : D, k = r.maxSnapElementGapDistance, $ = k === void 0 ? 1 / 0 : k, G = o.state.elementRects, U = [];\n  return [[\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(z) {\n    var X = z[0], V = z[1], Y = z[2], q = t[V.start], W = t[V.end], K = t[V.center], Z = t[Y.start], J = t[Y.end];\n    function Q(tt) {\n      var it = tt.rect;\n      return it[V.end] < q + e ? q - it[V.end] : W - e < it[V.start] ? it[V.start] - W : -1;\n    }\n    var et = G.filter(function(tt) {\n      var it = tt.rect;\n      return it[Y.start] > J || it[Y.end] < Z ? !1 : Q(tt) > 0;\n    }).sort(function(tt, it) {\n      return Q(tt) - Q(it);\n    }), nt = [];\n    et.forEach(function(tt) {\n      et.forEach(function(it) {\n        if (tt !== it) {\n          var st = tt.rect, at = it.rect, ut = st[Y.start], ft = st[Y.end], ct = at[Y.start], vt = at[Y.end];\n          ut > vt || ct > ft || nt.push([tt, it]);\n        }\n      });\n    }), nt.forEach(function(tt) {\n      var it = tt[0], st = tt[1], at = it.rect, ut = st.rect, ft = at[V.start], ct = at[V.end], vt = ut[V.start], yt = ut[V.end], mt = 0, _t = 0, Tt = !1, Pt = !1, St = !1;\n      if (ct <= q && W <= vt) {\n        if (Pt = !0, mt = (vt - ct - (W - q)) / 2, _t = ct + mt + (W - q) / 2, Math.abs(_t - K) > e)\n          return;\n      } else if (ct < vt && yt < q + e) {\n        if (Tt = !0, mt = vt - ct, _t = yt + mt, Math.abs(_t - q) > e)\n          return;\n      } else if (ct < vt && W - e < ft) {\n        if (St = !0, mt = vt - ct, _t = ft - mt, Math.abs(_t - W) > e)\n          return;\n      } else\n        return;\n      mt && checkBetweenRects(t, ut, X, N) && (mt > $ || U.push({\n        type: X,\n        pos: X === \"vertical\" ? [_t, 0] : [0, _t],\n        element: st.element,\n        size: 0,\n        className: st.className,\n        isStart: Tt,\n        isCenter: Pt,\n        isEnd: St,\n        gap: mt,\n        hide: !0,\n        gapRects: [it, st]\n      }));\n    });\n  }), U;\n}\nfunction getGridGuidelines(o, t, e, r, D, N) {\n  D === void 0 && (D = 0), N === void 0 && (N = 0);\n  var k = [];\n  if (t)\n    for (var $ = 0; $ <= r; $ += t)\n      k.push({\n        type: \"horizontal\",\n        pos: [0, throttle($ - N, 0.1)],\n        size: e,\n        hide: !0\n      });\n  if (o)\n    for (var $ = 0; $ <= e; $ += o)\n      k.push({\n        type: \"vertical\",\n        pos: [throttle($ - D, 0.1), 0],\n        size: r,\n        hide: !0\n      });\n  return k;\n}\nfunction checkBetweenRects(o, t, e, r) {\n  return e === \"horizontal\" ? Math.abs(o.right - t.left) <= r || Math.abs(o.left - t.right) <= r || o.left <= t.right && t.left <= o.right : e === \"vertical\" ? Math.abs(o.bottom - t.top) <= r || Math.abs(o.top - t.bottom) <= r || o.top <= t.bottom && t.top <= o.bottom : !0;\n}\nfunction getElementGuidelines(o) {\n  var t = o.state, e = o.props.elementGuidelines, r = e === void 0 ? [] : e;\n  if (!r.length)\n    return t.elementRects = [], [];\n  var D = (t.elementRects || []).filter(function(V) {\n    return !V.refresh;\n  }), N = r.map(function(V) {\n    return isObject$2(V) && \"element\" in V ? __assign$1(__assign$1({}, V), {\n      element: getRefTarget(V.element, !0)\n    }) : {\n      element: getRefTarget(V, !0)\n    };\n  }).filter(function(V) {\n    return V.element;\n  }), k = diff(D.map(function(V) {\n    return V.element;\n  }), N.map(function(V) {\n    return V.element;\n  })), $ = k.maintained, G = k.added, U = [];\n  $.forEach(function(V) {\n    var Y = V[0], q = V[1];\n    U[q] = D[Y];\n  }), getSnapElementRects(o, G.map(function(V) {\n    return N[V];\n  })).map(function(V, Y) {\n    U[G[Y]] = V;\n  }), t.elementRects = U;\n  var z = getSnapDirections(o.props.elementSnapDirections), X = [];\n  return U.forEach(function(V) {\n    var Y = V.element, q = V.top, W = q === void 0 ? z.top : q, K = V.left, Z = K === void 0 ? z.left : K, J = V.right, Q = J === void 0 ? z.right : J, et = V.bottom, nt = et === void 0 ? z.bottom : et, tt = V.center, it = tt === void 0 ? z.center : tt, st = V.middle, at = st === void 0 ? z.middle : st, ut = V.className, ft = V.rect, ct = splitSnapDirectionPoses({\n      top: W,\n      right: Q,\n      left: Z,\n      bottom: nt,\n      center: it,\n      middle: at\n    }, ft), vt = ct.horizontal, yt = ct.vertical, mt = ft.top, _t = ft.left, Tt = ft.right - _t, Pt = ft.bottom - mt, St = [Tt, Pt];\n    yt.forEach(function(gt) {\n      X.push({\n        type: \"vertical\",\n        element: Y,\n        pos: [throttle(gt, 0.1), mt],\n        size: Pt,\n        sizes: St,\n        className: ut,\n        elementRect: V\n      });\n    }), vt.forEach(function(gt) {\n      X.push({\n        type: \"horizontal\",\n        element: Y,\n        pos: [_t, throttle(gt, 0.1)],\n        size: Tt,\n        sizes: St,\n        className: ut,\n        elementRect: V\n      });\n    });\n  }), X;\n}\nfunction getDefaultGuidelines(o, t, e, r, D, N, k) {\n  D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  });\n  var $ = [], G = k.left, U = k.top, z = k.bottom, X = k.right, V = e + X - G, Y = r + z - U;\n  return o && o.forEach(function(q) {\n    var W = isObject$2(q) ? q : {\n      pos: q\n    };\n    $.push({\n      type: \"horizontal\",\n      pos: [G, throttle(W.pos - N + U, 0.1)],\n      size: V,\n      className: W.className\n    });\n  }), t && t.forEach(function(q) {\n    var W = isObject$2(q) ? q : {\n      pos: q\n    };\n    $.push({\n      type: \"vertical\",\n      pos: [throttle(W.pos - D + G, 0.1), U],\n      size: Y,\n      className: W.className\n    });\n  }), $;\n}\nfunction getSnapElementRects(o, t) {\n  if (!t.length)\n    return [];\n  var e = o.state, r = e.containerClientRect, D = e.targetClientRect, N = D.top, k = D.left, $ = e.rootMatrix, G = e.is3d, U = G ? 4 : 3, z = calculateContainerPos($, r, U), X = z[0], V = z[1], Y = getAbsolutePosesByState(e), q = getMinMaxs(Y), W = q.minX, K = q.minY, Z = minus([W, K], calculateInversePosition($, [k - X, N - V], U)).map(function(et) {\n    return roundSign(et);\n  }), J = Z[0], Q = Z[1];\n  return t.map(function(et) {\n    var nt = et.element.getBoundingClientRect(), tt = nt.left - X, it = nt.top - V, st = it + nt.height, at = tt + nt.width, ut = calculateInversePosition($, [tt, it], U), ft = ut[0], ct = ut[1], vt = calculateInversePosition($, [at, st], U), yt = vt[0], mt = vt[1];\n    return __assign$1(__assign$1({}, et), {\n      rect: {\n        left: ft + J,\n        right: yt + J,\n        top: ct + Q,\n        bottom: mt + Q,\n        center: (ft + yt) / 2 + J,\n        middle: (ct + mt) / 2 + Q\n      }\n    });\n  });\n}\nfunction checkSnapInfo(o) {\n  var t = o.state, e = t.container, r = o.props.snapContainer || e;\n  if (t.snapContainer === r && t.guidelines && t.guidelines.length)\n    return !1;\n  var D = t.containerClientRect, N = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n  if (e !== r) {\n    var k = getRefTarget(r, !0);\n    if (k) {\n      var $ = getClientRect(k), G = getDragDistByState(t, [$.left - D.left, $.top - D.top]), U = getDragDistByState(t, [$.right - D.right, $.bottom - D.bottom]);\n      N.left = throttle(G[0], 1e-5), N.top = throttle(G[1], 1e-5), N.right = throttle(U[0], 1e-5), N.bottom = throttle(U[1], 1e-5);\n    }\n  }\n  return t.snapContainer = r, t.snapOffset = N, t.guidelines = getTotalGuidelines(o), t.enableSnap = !0, !0;\n}\nfunction getNextFixedPoses(o, t, e, r, D, N) {\n  var k = calculatePoses(o, t, e, N ? 4 : 3), $ = getPosByDirection(k, r);\n  return getAbsolutePoses(k, minus(D, $));\n}\nfunction getSizeOffsetInfo(o, t, e, r, D, N) {\n  var k = N.fixedDirection, $ = getCheckSnapDirections(e, k, r), G = getCheckInnerBoundLineInfos(o, t, e, r), U = __spreadArray(__spreadArray([], getSnapBoundInfo(o, t, $, r, D, N), !0), getInnerBoundInfo(o, G, N), !0), z = getNearOffsetInfo(U, 0), X = getNearOffsetInfo(U, 1);\n  return {\n    width: {\n      isBound: z.isBound,\n      offset: z.offset[0]\n    },\n    height: {\n      isBound: X.isBound,\n      offset: X.offset[1]\n    }\n  };\n}\nfunction recheckSizeByTwoDirection(o, t, e, r, D, N, k, $, G) {\n  var U = getPosByDirection(t, k), z = checkMoveableSnapBounds(o, $, {\n    vertical: [U[0]],\n    horizontal: [U[1]]\n  }), X = z.horizontal.offset, V = z.vertical.offset;\n  if (throttle(V, FLOAT_POINT_NUM) || throttle(X, FLOAT_POINT_NUM)) {\n    var Y = getDragDist({\n      datas: G,\n      distX: -V,\n      distY: -X\n    }), q = Y[0], W = Y[1], K = Math.min(D || 1 / 0, e + k[0] * q), Z = Math.min(N || 1 / 0, r + k[1] * W);\n    return [K - e, Z - r];\n  }\n  return [0, 0];\n}\nfunction checkSizeDist(o, t, e, r, D, N, k, $) {\n  for (var G = getAbsolutePosesByState(o.state), U = o.props.keepRatio, z = 0, X = 0, V = 0; V < 2; ++V) {\n    var Y = t(z, X), q = getSizeOffsetInfo(o, Y, D, U, k, $), W = q.width, K = q.height, Z = W.isBound, J = K.isBound, Q = W.offset, et = K.offset;\n    if (V === 1 && (Z || (Q = 0), J || (et = 0)), V === 0 && k && !Z && !J)\n      return [0, 0];\n    if (U) {\n      var nt = Math.abs(Q) * (e ? 1 / e : 1), tt = Math.abs(et) * (r ? 1 / r : 1), it = Z && J ? nt < tt : J || !Z && nt < tt;\n      it ? Q = e * et / r : et = r * Q / e;\n    }\n    z += Q, X += et;\n  }\n  if (D[0] && D[1]) {\n    var st = checkMaxBounds(o, G, D, N, $), at = st.maxWidth, ut = st.maxHeight, ft = recheckSizeByTwoDirection(o, t(z, X).map(function(yt) {\n      return yt.map(function(mt) {\n        return throttle(mt, FLOAT_POINT_NUM);\n      });\n    }), e + z, r + X, at, ut, D, k, $), Q = ft[0], et = ft[1];\n    z += Q, X += et;\n  }\n  return [z, X];\n}\nfunction checkSnapRotate(o, t, e) {\n  if (!hasGuidelines(o, \"rotatable\"))\n    return {\n      isSnap: !1,\n      rotation: e\n    };\n  var r = t.pos1, D = t.pos2, N = t.pos3, k = t.pos4, $ = t.origin, G = e * Math.PI / 180, U = [r, D, N, k].map(function(Y) {\n    return minus(Y, $);\n  }), z = U.map(function(Y) {\n    return rotate(Y, G);\n  }), X = __spreadArray(__spreadArray([], checkRotateBounds(o, U, z, $, e), !0), checkRotateInnerBounds(o, U, z, $, e), !0);\n  X.sort(function(Y, q) {\n    return Math.abs(Y - e) - Math.abs(q - e);\n  });\n  var V = X.length > 0;\n  return {\n    isSnap: V,\n    rotation: V ? X[0] : e\n  };\n}\nfunction checkSnapResize(o, t, e, r, D, N, k) {\n  if (!hasGuidelines(o, \"resizable\"))\n    return [0, 0];\n  var $ = k.fixedDirection, G = k.nextAllMatrix, U = o.state, z = U.allMatrix, X = U.is3d;\n  return checkSizeDist(o, function(V, Y) {\n    return getNextFixedPoses(G || z, t + V, e + Y, $, D, X);\n  }, t, e, r, D, N, k);\n}\nfunction checkSnapScale(o, t, e, r, D) {\n  if (!hasGuidelines(o, \"scalable\"))\n    return [0, 0];\n  var N = D.startOffsetWidth, k = D.startOffsetHeight, $ = D.fixedPosition, G = D.fixedDirection, U = D.is3d, z = checkSizeDist(o, function(X, V) {\n    return getNextFixedPoses(scaleMatrix(D, plus(t, [X / N, V / k])), N, k, G, $, U);\n  }, N, k, e, $, r, D);\n  return [z[0] / N, z[1] / k];\n}\nfunction startCheckSnapDrag(o, t) {\n  t.absolutePoses = getAbsolutePosesByState(o.state);\n}\nfunction getSnapGuidelines(o) {\n  var t = [];\n  return o.forEach(function(e) {\n    e.guidelineInfos.forEach(function(r) {\n      var D = r.guideline;\n      t.indexOf(D) > -1 || t.push(D);\n    });\n  }), t;\n}\nfunction addBoundGuidelines(o, t, e, r, D, N) {\n  var k = checkBoundPoses(getBounds(o, N), t, e), $ = k.vertical, G = k.horizontal;\n  $.forEach(function(V) {\n    V.isBound && r.push({\n      type: \"bounds\",\n      pos: V.pos\n    });\n  }), G.forEach(function(V) {\n    V.isBound && D.push({\n      type: \"bounds\",\n      pos: V.pos\n    });\n  });\n  var U = checkInnerBoundPoses(o), z = U.vertical, X = U.horizontal;\n  z.forEach(function(V) {\n    findIndex(r, function(Y) {\n      var q = Y.type, W = Y.pos;\n      return q === \"bounds\" && W === V;\n    }) >= 0 || r.push({\n      type: \"bounds\",\n      pos: V\n    });\n  }), X.forEach(function(V) {\n    findIndex(D, function(Y) {\n      var q = Y.type, W = Y.pos;\n      return q === \"bounds\" && W === V;\n    }) >= 0 || D.push({\n      type: \"bounds\",\n      pos: V\n    });\n  });\n}\nvar directionCondition$2 = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]), Snappable = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapDirections: [Boolean, Object],\n    elementSnapDirections: [Boolean, Object],\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    snapRenderThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function,\n    maxSnapElementGuidelineDistance: Number,\n    maxSnapElementGapDistance: Number\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [`:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-size: calc(12px * var(--zoom));\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n    bottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n    left: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`],\n  render: function(o, t) {\n    var e = o.state, r = e.top, D = e.left, N = e.pos1, k = e.pos2, $ = e.pos3, G = e.pos4, U = e.snapRenderInfo, z = o.props.snapRenderThreshold, X = z === void 0 ? 1 : z;\n    if (!U || !U.render || !hasGuidelines(o, \"\"))\n      return [];\n    e.guidelines = getTotalGuidelines(o);\n    var V = Math.min(N[0], k[0], $[0], G[0]), Y = Math.min(N[1], k[1], $[1], G[1]), q = U.externalPoses || [], W = getAbsolutePosesByState(o.state), K = [], Z = [], J = [], Q = [], et = [], nt = getRect(W), tt = nt.width, it = nt.height, st = nt.top, at = nt.left, ut = nt.bottom, ft = nt.right, ct = {\n      left: at,\n      right: ft,\n      top: st,\n      bottom: ut,\n      center: (at + ft) / 2,\n      middle: (st + ut) / 2\n    }, vt = q.length > 0, yt = vt ? getRect(q) : {};\n    if (!U.request) {\n      if (U.direction && et.push(getSnapInfosByDirection(o, W, U.direction, X)), U.snap) {\n        var mt = getRect(W);\n        U.center && (mt.middle = (mt.top + mt.bottom) / 2, mt.center = (mt.left + mt.right) / 2), et.push(checkSnaps(o, mt, X));\n      }\n      vt && (U.center && (yt.middle = (yt.top + yt.bottom) / 2, yt.center = (yt.left + yt.right) / 2), et.push(checkSnaps(o, yt, X))), et.forEach(function(St) {\n        var gt = St.vertical.posInfos, bt = St.horizontal.posInfos;\n        K.push.apply(K, gt.filter(function(Nt) {\n          var At = Nt.guidelineInfos;\n          return At.some(function(It) {\n            var Mt = It.guideline;\n            return !Mt.hide;\n          });\n        }).map(function(Nt) {\n          return {\n            type: \"snap\",\n            pos: Nt.pos\n          };\n        })), Z.push.apply(Z, bt.filter(function(Nt) {\n          var At = Nt.guidelineInfos;\n          return At.some(function(It) {\n            var Mt = It.guideline;\n            return !Mt.hide;\n          });\n        }).map(function(Nt) {\n          return {\n            type: \"snap\",\n            pos: Nt.pos\n          };\n        })), J.push.apply(J, getSnapGuidelines(gt)), Q.push.apply(Q, getSnapGuidelines(bt));\n      });\n    }\n    addBoundGuidelines(o, [at, ft], [st, ut], K, Z), vt && addBoundGuidelines(o, [yt.left, yt.right], [yt.top, yt.bottom], K, Z, U.externalBounds);\n    var _t = __spreadArray(__spreadArray([], J, !0), Q, !0), Tt = _t.filter(function(St) {\n      return St.element && !St.gapRects;\n    }), Pt = _t.filter(function(St) {\n      return St.gapRects;\n    }).sort(function(St, gt) {\n      return St.gap - gt.gap;\n    });\n    return triggerEvent(o, \"onSnap\", {\n      guidelines: _t.filter(function(St) {\n        var gt = St.element;\n        return !gt;\n      }),\n      elements: Tt,\n      gaps: Pt\n    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(o, Tt, [V, Y], ct, t), !0), renderGapGuidelines(o, Pt, [V, Y], ct, t), !0), renderGuidelines(o, \"horizontal\", Q, [D, r], ct, t), !0), renderGuidelines(o, \"vertical\", J, [D, r], ct, t), !0), renderSnapPoses(o, \"horizontal\", Z, V, r, tt, 0, t), !0), renderSnapPoses(o, \"vertical\", K, Y, D, it, 1, t), !0);\n  },\n  dragStart: function(o, t) {\n    o.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, checkSnapInfo(o);\n  },\n  drag: function(o) {\n    var t = o.state;\n    checkSnapInfo(o) || (t.guidelines = getTotalGuidelines(o)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);\n  },\n  pinchStart: function(o) {\n    this.unset(o);\n  },\n  dragEnd: function(o) {\n    this.unset(o);\n  },\n  dragControlCondition: function(o, t) {\n    if (directionCondition$2(o, t) || dragControlCondition(o, t))\n      return !0;\n    if (!t.isRequest && t.inputEvent)\n      return hasClass(t.inputEvent.target, prefix(\"snap-control\"));\n  },\n  dragControlStart: function(o) {\n    o.state.snapRenderInfo = null, checkSnapInfo(o);\n  },\n  dragControl: function(o) {\n    this.drag(o);\n  },\n  dragControlEnd: function(o) {\n    this.unset(o);\n  },\n  dragGroupStart: function(o, t) {\n    this.dragStart(o, t);\n  },\n  dragGroup: function(o) {\n    this.drag(o);\n  },\n  dragGroupEnd: function(o) {\n    this.unset(o);\n  },\n  dragGroupControlStart: function(o) {\n    o.state.snapRenderInfo = null, checkSnapInfo(o);\n  },\n  dragGroupControl: function(o) {\n    this.drag(o);\n  },\n  dragGroupControlEnd: function(o) {\n    this.unset(o);\n  },\n  unset: function(o) {\n    var t = o.state;\n    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];\n  }\n};\nfunction renderDirectionControlsByInfos(o, t, e, r) {\n  var D = o.getState(), N = D.renderPoses, k = D.rotation, $ = D.direction, G = getProps(o.props, t).zoom, U = $ > 0 ? 1 : -1, z = k / Math.PI * 180, X = {}, V = o.renderState;\n  V.renderDirectionMap || (V.renderDirectionMap = {});\n  var Y = V.renderDirectionMap;\n  return e.forEach(function(q) {\n    var W = q.dir;\n    X[W] = !0;\n  }), e.map(function(q) {\n    var W = q.data, K = q.classNames, Z = q.dir, J = DIRECTION_INDEXES[Z];\n    if (!J || !X[Z])\n      return null;\n    Y[Z] = !0;\n    var Q = (throttle(z, 15) + U * DIRECTION_ROTATIONS[Z] + 720) % 180, et = {};\n    return getKeys(W).forEach(function(nt) {\n      et[\"data-\".concat(nt)] = W[nt];\n    }), r.createElement(\"div\", __assign$1({\n      className: prefix.apply(void 0, __spreadArray([\"control\", \"direction\", Z, t], K, !1)),\n      \"data-rotation\": Q,\n      \"data-direction\": Z\n    }, et, {\n      key: \"direction-\".concat(Z),\n      style: getControlTransform.apply(void 0, __spreadArray([k, G], J.map(function(nt) {\n        return N[nt];\n      }), !1))\n    }));\n  });\n}\nfunction renderDirectionControls(o, t, e, r) {\n  var D = getProps(o.props, e), N = D.renderDirections, k = N === void 0 ? t : N, $ = D.displayAroundControls;\n  if (!k)\n    return [];\n  var G = k === !0 ? DIRECTIONS : k;\n  return __spreadArray(__spreadArray([], $ ? renderAroundControls(o, r, e, G) : [], !0), renderDirectionControlsByInfos(o, e, G.map(function(U) {\n    return {\n      data: {},\n      classNames: [],\n      dir: U\n    };\n  }), r), !0);\n}\nfunction renderLine(o, t, e, r, D, N) {\n  for (var k = [], $ = 6; $ < arguments.length; $++)\n    k[$ - 6] = arguments[$];\n  var G = getRad$1(e, r), U = t ? throttle(G / Math.PI * 180, 15) % 180 : -1;\n  return o.createElement(\"div\", {\n    key: \"line-\".concat(N),\n    className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", t ? \"edge\" : \"\", t], k, !1)),\n    \"data-rotation\": U,\n    \"data-line-key\": N,\n    \"data-direction\": t,\n    style: getLineStyle(e, r, D, G)\n  });\n}\nfunction renderEdgeLines(o, t, e, r, D) {\n  var N = e === !0 ? DIRECTIONS4 : e;\n  return N.map(function(k, $) {\n    var G = DIRECTION_INDEXES[k], U = G[0], z = G[1];\n    if (z != null)\n      return renderLine(o, k, r[U], r[z], D, \"\".concat(t, \"Edge\").concat($), t);\n  }).filter(Boolean);\n}\nfunction getRenderDirections(o) {\n  return function(t, e) {\n    var r = getProps(t.props, o).edge;\n    return r && (r === !0 || r.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, o, r, t.getState().renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, o, e), !0) : renderAllDirections(t, o, e);\n  };\n}\nfunction renderAllDirections(o, t, e) {\n  return renderDirectionControls(o, DIRECTIONS, t, e);\n}\nfunction renderDiagonalDirections(o, t, e) {\n  return renderDirectionControls(o, [\"nw\", \"ne\", \"sw\", \"se\"], t, e);\n}\nfunction renderAroundControls(o, t, e, r) {\n  var D = o.renderState;\n  D.renderDirectionMap || (D.renderDirectionMap = {});\n  var N = o.getState(), k = N.renderPoses, $ = N.rotation, G = N.direction, U = D.renderDirectionMap, z = o.props.zoom, X = G > 0 ? 1 : -1, V = $ / Math.PI * 180;\n  return (r || getKeys(U)).map(function(Y) {\n    var q = DIRECTION_INDEXES[Y];\n    if (!q)\n      return null;\n    var W = (throttle(V, 15) + X * DIRECTION_ROTATIONS[Y] + 720) % 180, K = [\"around-control\"];\n    return e && K.push(\"direction\", e), t.createElement(\"div\", {\n      className: prefix.apply(void 0, K),\n      \"data-rotation\": W,\n      \"data-direction\": Y,\n      key: \"direction-around-\".concat(Y),\n      style: getControlTransform.apply(void 0, __spreadArray([$, z], q.map(function(Z) {\n        return k[Z];\n      }), !1))\n    });\n  });\n}\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  requestStyle: function() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  requestChildStyle: function() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  render: function(o, t) {\n    var e = o.props, r = e.throttleDragRotate, D = e.zoom, N = o.getState(), k = N.dragInfo, $ = N.beforeOrigin;\n    if (!r || !k)\n      return [];\n    var G = k.dist;\n    if (!G[0] && !G[1])\n      return [];\n    var U = getDistSize(G), z = getRad$1(G, [0, 0]);\n    return [t.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat(U, \"px\"),\n        transform: \"translate(\".concat($[0], \"px, \").concat($[1], \"px) rotate(\").concat(z, \"rad) scaleY(\").concat(D, \")\")\n      }\n    })];\n  },\n  dragStart: function(o, t) {\n    var e = t.datas, r = t.parentEvent, D = t.parentGesto, N = o.state, k = N.gestos, $ = N.style;\n    if (k.draggable)\n      return !1;\n    k.draggable = D || o.targetGesto, e.datas = {}, e.left = parseFloat($.left || \"\") || 0, e.top = parseFloat($.top || \"\") || 0, e.bottom = parseFloat($.bottom || \"\") || 0, e.right = parseFloat($.right || \"\") || 0, e.startValue = [0, 0], setDragStart(o, t), setDefaultTransformIndex(t, \"translate\"), startCheckSnapDrag(o, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];\n    var G = fillParams(o, t, __assign$1({\n      set: function(z) {\n        e.startValue = z;\n      }\n    }, fillTransformStartEvent(t))), U = r || triggerEvent(o, \"onDragStart\", G);\n    return U !== !1 ? (e.isDrag = !0, o.state.dragInfo = {\n      startRect: o.getRect(),\n      dist: [0, 0]\n    }) : (k.draggable = null, e.isPinch = !1), e.isDrag ? G : !1;\n  },\n  drag: function(o, t) {\n    if (t) {\n      resolveTransformEvent(t, \"translate\");\n      var e = t.datas, r = t.parentEvent, D = t.parentFlag, N = t.isPinch, k = t.isRequest, $ = t.deltaOffset, G = t.distX, U = t.distY, z = e.isDrag, X = e.prevDist, V = e.prevBeforeDist, Y = e.startValue;\n      if (z) {\n        $ && (G += $[0], U += $[1]);\n        var q = o.props, W = q.parentMoveable, K = r ? 0 : q.throttleDrag || 0, Z = r ? 0 : q.throttleDragRotate || 0, J = 0, Q = !1, et = !1, nt = !1, tt = !1;\n        if (!r && Z > 0 && (G || U)) {\n          var it = q.startDragRotate || 0, st = throttle(it + getRad$1([0, 0], [G, U]) * 180 / Math.PI, Z) - it, at = U * Math.abs(Math.cos((st - 90) / 180 * Math.PI)), ut = G * Math.abs(Math.cos(st / 180 * Math.PI)), ft = getDistSize([ut, at]);\n          J = st * Math.PI / 180, G = ft * Math.cos(J), U = ft * Math.sin(J);\n        }\n        if (!N && !r && !D) {\n          var ct = checkSnapBoundsDrag(o, G, U, Z, k || $, e), vt = ct[0], yt = ct[1];\n          Q = vt.isSnap, et = vt.isBound, nt = yt.isSnap, tt = yt.isBound;\n          var mt = vt.offset, _t = yt.offset;\n          G += mt, U += _t;\n        }\n        var Tt = plus(getBeforeDragDist({\n          datas: e,\n          distX: G,\n          distY: U\n        }), Y), Pt = plus(getTransformDist({\n          datas: e,\n          distX: G,\n          distY: U\n        }), Y);\n        throttleArray(Pt, TINY_NUM), throttleArray(Tt, TINY_NUM), Z || (!Q && !et && (Pt[0] = throttle(Pt[0], K), Tt[0] = throttle(Tt[0], K)), !nt && !tt && (Pt[1] = throttle(Pt[1], K), Tt[1] = throttle(Tt[1], K)));\n        var St = minus(Tt, Y), gt = minus(Pt, Y), bt = minus(gt, X), Nt = minus(St, V);\n        e.prevDist = gt, e.prevBeforeDist = St, e.passDelta = bt, e.passDist = gt;\n        var At = e.left + St[0], It = e.top + St[1], Mt = e.right - St[0], dt = e.bottom - St[1], $t = convertTransformFormat(e, \"translate(\".concat(Pt[0], \"px, \").concat(Pt[1], \"px)\"), \"translate(\".concat(gt[0], \"px, \").concat(gt[1], \"px)\"));\n        if (fillOriginalTransform(t, $t), o.state.dragInfo.dist = r ? [0, 0] : gt, !(!r && !W && bt.every(function(Ht) {\n          return !Ht;\n        }) && Nt.some(function(Ht) {\n          return !Ht;\n        }))) {\n          var Dt = o.state, Vt = Dt.width, Lt = Dt.height, Et = fillParams(o, t, __assign$1({\n            transform: $t,\n            dist: gt,\n            delta: bt,\n            translate: Pt,\n            beforeDist: St,\n            beforeDelta: Nt,\n            beforeTranslate: Tt,\n            left: At,\n            top: It,\n            right: Mt,\n            bottom: dt,\n            width: Vt,\n            height: Lt,\n            isPinch: N\n          }, fillCSSObject({\n            transform: $t\n          }, t)));\n          return !r && triggerEvent(o, \"onDrag\", Et), Et;\n        }\n      }\n    }\n  },\n  dragAfter: function(o, t) {\n    var e = t.datas, r = e.deltaOffset;\n    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(o, __assign$1(__assign$1({}, t), {\n      deltaOffset: r\n    }))) : !1;\n  },\n  dragEnd: function(o, t) {\n    var e = t.parentEvent, r = t.datas;\n    if (o.state.dragInfo = null, !!r.isDrag) {\n      r.isDrag = !1;\n      var D = fillEndParams(o, t, {});\n      return !e && triggerEvent(o, \"onDragEnd\", D), D;\n    }\n  },\n  dragGroupStart: function(o, t) {\n    var e = t.datas, r = t.clientX, D = t.clientY, N = this.dragStart(o, t);\n    if (!N)\n      return !1;\n    var k = triggerChildGesto(o, this, \"dragStart\", [r || 0, D || 0], t, !1, \"draggable\"), $ = __assign$1(__assign$1({}, N), {\n      targets: o.props.targets,\n      events: k\n    }), G = triggerEvent(o, \"onDragGroupStart\", $);\n    return e.isDrag = G !== !1, e.isDrag ? N : !1;\n  },\n  dragGroup: function(o, t) {\n    var e = t.datas;\n    if (e.isDrag) {\n      var r = this.drag(o, t), D = t.datas.passDelta, N = triggerChildGesto(o, this, \"drag\", D, t, !1, \"draggable\");\n      if (r) {\n        var k = __assign$1({\n          targets: o.props.targets,\n          events: N\n        }, r);\n        return triggerEvent(o, \"onDragGroup\", k), k;\n      }\n    }\n  },\n  dragGroupEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isDrag) {\n      this.dragEnd(o, t);\n      var D = triggerChildGesto(o, this, \"dragEnd\", [0, 0], t, !1, \"draggable\");\n      return triggerEvent(o, \"onDragGroupEnd\", fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: D\n      })), e;\n    }\n  },\n  /**\n   * @method Moveable.Draggable#request\n   * @param {object} [e] - the draggable's request parameter\n   * @param {number} [e.x] - x position\n   * @param {number} [e.y] - y position\n   * @param {number} [e.deltaX] - X number to move\n   * @param {number} [e.deltaY] - Y number to move\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"draggable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 });\n   * moveable.request(\"draggable\", { x: 220, y: 100 });\n   * moveable.request(\"draggable\", { x: 240, y: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(o) {\n    var t = {}, e = o.getRect(), r = 0, D = 0;\n    return {\n      isControl: !1,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(N) {\n        return \"x\" in N ? r = N.x - e.left : \"deltaX\" in N && (r += N.deltaX), \"y\" in N ? D = N.y - e.top : \"deltaY\" in N && (D += N.deltaY), {\n          datas: t,\n          distX: r,\n          distY: D\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(o) {\n    o.state.gestos.draggable = null, o.state.dragInfo = null;\n  }\n}, directionCondition$1 = getDirectionCondition(\"resizable\"), Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    displayAroundControls: Boolean,\n    keepRatio: Boolean,\n    resizeFormat: Function,\n    keepRatioFinally: Boolean,\n    edge: Boolean,\n    checkResizableError: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onBeforeResize: \"beforeResize\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onBeforeResizeGroup: \"beforeResizeGroup\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: getRenderDirections(\"resizable\"),\n  dragControlCondition: directionCondition$1,\n  viewClassName: getDirectionViewClassName(\"resizable\"),\n  dragControlStart: function(o, t) {\n    var e, r = t.inputEvent, D = t.isPinch, N = t.isGroup, k = t.parentDirection, $ = t.parentGesto, G = t.datas, U = t.parentFixedDirection, z = t.parentEvent, X = getTotalDirection(k, D, r, G), V = o.state, Y = V.target, q = V.width, W = V.height, K = V.gestos;\n    if (!X || !Y || K.resizable)\n      return !1;\n    K.resizable = $ || o.controlGesto, !D && setDragStart(o, t), G.datas = {}, G.direction = X, G.startOffsetWidth = q, G.startOffsetHeight = W, G.prevWidth = 0, G.prevHeight = 0, G.minSize = [0, 0], G.startWidth = V.inlineCSSWidth || V.cssWidth, G.startHeight = V.inlineCSSHeight || V.cssHeight, G.maxSize = [1 / 0, 1 / 0], N || (G.minSize = [V.minOffsetWidth, V.minOffsetHeight], G.maxSize = [V.maxOffsetWidth, V.maxOffsetHeight]);\n    var Z = o.props.transformOrigin || \"% %\";\n    G.transformOrigin = Z && isString(Z) ? Z.split(\" \") : Z, G.startOffsetMatrix = V.offsetMatrix, G.startTransformOrigin = V.transformOrigin, G.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !X[0] && !X[1] || X[0] || !X[1];\n    function J(at) {\n      G.ratio = at && isFinite(at) ? at : 0;\n    }\n    G.startPositions = getAbsolutePosesByState(o.state);\n    function Q(at) {\n      G.fixedDirection = at, G.fixedPosition = getPosByDirection(G.startPositions, at);\n    }\n    function et(at) {\n      var ut = o.state, ft = ut.width, ct = ut.height;\n      G.fixedPosition = at, G.fixedDirection = getDirectionByPos(at, ft, ct);\n    }\n    function nt(at) {\n      G.minSize = [convertUnitSize(\"\".concat(at[0]), 0) || 0, convertUnitSize(\"\".concat(at[1]), 0) || 0];\n    }\n    function tt(at) {\n      var ut = [at[0] || 1 / 0, at[1] || 1 / 0];\n      (!isNumber(ut[0]) || isFinite(ut[0])) && (ut[0] = convertUnitSize(\"\".concat(ut[0]), 0) || 1 / 0), (!isNumber(ut[1]) || isFinite(ut[1])) && (ut[1] = convertUnitSize(\"\".concat(ut[1]), 0) || 1 / 0), G.maxSize = ut;\n    }\n    J(q / W), Q(U || [-X[0], -X[1]]), G.setFixedDirection = Q, G.setFixedPosition = et, G.setMin = nt, G.setMax = tt;\n    var it = fillParams(o, t, {\n      direction: X,\n      startRatio: G.ratio,\n      set: function(at) {\n        var ut = at[0], ft = at[1];\n        G.startWidth = ut, G.startHeight = ft;\n      },\n      setMin: nt,\n      setMax: tt,\n      setRatio: J,\n      setFixedDirection: Q,\n      setFixedPosition: et,\n      setOrigin: function(at) {\n        G.transformOrigin = at;\n      },\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    }), st = z || triggerEvent(o, \"onResizeStart\", it);\n    return G.startFixedDirection = G.fixedDirection, G.startFixedPosition = G.fixedPosition, st !== !1 && (G.isResize = !0, o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: X\n    }), G.isResize ? it : !1;\n  },\n  dragControl: function(o, t) {\n    var e, r = t.datas, D = t.parentFlag, N = t.isPinch, k = t.parentKeepRatio, $ = t.dragClient, G = t.parentDist, U = t.isRequest, z = t.isGroup, X = t.parentEvent, V = t.resolveMatrix, Y = r.isResize, q = r.transformOrigin, W = r.startWidth, K = r.startHeight, Z = r.prevWidth, J = r.prevHeight, Q = r.minSize, et = r.maxSize, nt = r.ratio, tt = r.startOffsetWidth, it = r.startOffsetHeight, st = r.isWidth;\n    if (!Y)\n      return;\n    if (V) {\n      var at = o.state.is3d, ut = r.startOffsetMatrix, ft = r.startTransformOrigin, ct = at ? 4 : 3, vt = parseMat(getNextTransforms(t)), yt = Math.sqrt(vt.length);\n      ct !== yt && (vt = convertDimension(vt, yt, ct));\n      var mt = getNextMatrix(ut, vt, ft, ct), _t = calculatePoses(mt, tt, it, ct);\n      r.startPositions = _t, r.nextTargetMatrix = vt, r.nextAllMatrix = mt;\n    }\n    var Tt = getProps(o.props, \"resizable\"), Pt = Tt.resizeFormat, St = Tt.throttleResize, gt = St === void 0 ? D ? 0 : 1 : St, bt = Tt.parentMoveable, Nt = Tt.keepRatioFinally, At = r.direction, It = At, Mt = 0, dt = 0;\n    !At[0] && !At[1] && (It = [1, 1]);\n    var $t = nt && (k ?? Tt.keepRatio) || !1;\n    function Dt() {\n      var ue = r.fixedDirection, _e = getOffsetSizeDist(It, $t, r, t);\n      Mt = _e.distWidth, dt = _e.distHeight;\n      var ve = It[0] - ue[0] || $t ? Math.max(tt + Mt, TINY_NUM) : tt, de = It[1] - ue[1] || $t ? Math.max(it + dt, TINY_NUM) : it;\n      return $t && tt && it && (st ? de = ve / nt : ve = de * nt), [ve, de];\n    }\n    var Vt = Dt(), Lt = Vt[0], Et = Vt[1];\n    X || (r.setFixedDirection(r.fixedDirection), triggerEvent(o, \"onBeforeResize\", fillParams(o, t, {\n      startFixedDirection: r.startFixedDirection,\n      startFixedPosition: r.startFixedPosition,\n      setFixedDirection: function(ue) {\n        var _e;\n        return r.setFixedDirection(ue), _e = Dt(), Lt = _e[0], Et = _e[1], [Lt, Et];\n      },\n      setFixedPosition: function(ue) {\n        var _e;\n        return r.setFixedPosition(ue), _e = Dt(), Lt = _e[0], Et = _e[1], [Lt, Et];\n      },\n      boundingWidth: Lt,\n      boundingHeight: Et,\n      setSize: function(ue) {\n        Lt = ue[0], Et = ue[1];\n      }\n    }, !0)));\n    var Ht = $;\n    $ || (!D && N ? Ht = getAbsolutePosition(o, [0, 0]) : Ht = r.fixedPosition);\n    var kt = [0, 0];\n    N || (kt = checkSnapResize(o, Lt, Et, At, Ht, U, r)), G && (!G[0] && (kt[0] = 0), !G[1] && (kt[1] = 0));\n    function wt() {\n      var ue;\n      Pt && (ue = Pt([Lt, Et]), Lt = ue[0], Et = ue[1]), Lt = throttle(Lt, gt), Et = throttle(Et, gt);\n    }\n    if ($t) {\n      It[0] && It[1] && kt[0] && kt[1] && (Math.abs(kt[0]) > Math.abs(kt[1]) ? kt[1] = 0 : kt[0] = 0);\n      var Bt = !kt[0] && !kt[1];\n      Bt && wt(), It[0] && !It[1] || kt[0] && !kt[1] || Bt && st ? (Lt += kt[0], Et = Lt / nt) : (!It[0] && It[1] || !kt[0] && kt[1] || Bt && !st) && (Et += kt[1], Lt = Et * nt);\n    } else\n      Lt += kt[0], Et += kt[1], Lt = Math.max(0, Lt), Et = Math.max(0, Et);\n    e = calculateBoundSize([Lt, Et], Q, et, $t ? nt : !1), Lt = e[0], Et = e[1], wt(), $t && (z || Nt) && (st ? Et = Lt / nt : Lt = Et * nt), Mt = Lt - tt, dt = Et - it;\n    var jt = [Mt - Z, dt - J];\n    r.prevWidth = Mt, r.prevHeight = dt;\n    var Ct = getResizeDist(o, Lt, Et, Ht, q, r);\n    if (!(!bt && jt.every(function(ue) {\n      return !ue;\n    }) && Ct.every(function(ue) {\n      return !ue;\n    }))) {\n      var qt = Draggable.drag(o, setCustomDrag(t, o.state, Ct, !!N, !1, \"draggable\")), Qt = qt.transform, Kt = W + Mt, Se = K + dt, Oe = fillParams(o, t, __assign$1({\n        width: Kt,\n        height: Se,\n        offsetWidth: Math.round(Lt),\n        offsetHeight: Math.round(Et),\n        startRatio: nt,\n        boundingWidth: Lt,\n        boundingHeight: Et,\n        direction: At,\n        dist: [Mt, dt],\n        delta: jt,\n        isPinch: !!N,\n        drag: qt\n      }, fillAfterTransform({\n        style: {\n          width: \"\".concat(Kt, \"px\"),\n          height: \"\".concat(Se, \"px\")\n        },\n        transform: Qt\n      }, qt, t)));\n      return !X && triggerEvent(o, \"onResize\", Oe), Oe;\n    }\n  },\n  dragControlAfter: function(o, t) {\n    var e = t.datas, r = e.isResize, D = e.startOffsetWidth, N = e.startOffsetHeight, k = e.prevWidth, $ = e.prevHeight;\n    if (!(!r || o.props.checkResizableError === !1)) {\n      var G = o.state, U = G.width, z = G.height, X = U - (D + k), V = z - (N + $), Y = Math.abs(X) > 3, q = Math.abs(V) > 3;\n      if (Y && (e.startWidth += X, e.startOffsetWidth += X, e.prevWidth += X), q && (e.startHeight += V, e.startOffsetHeight += V, e.prevHeight += V), Y || q)\n        return this.dragControl(o, t);\n    }\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas, r = t.parentEvent;\n    if (e.isResize) {\n      e.isResize = !1;\n      var D = fillEndParams(o, t, {});\n      return !r && triggerEvent(o, \"onResizeEnd\", D), D;\n    }\n  },\n  dragGroupControlCondition: directionCondition$1,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = this.dragControlStart(o, __assign$1(__assign$1({}, t), {\n      isGroup: !0\n    }));\n    if (!r)\n      return !1;\n    var D = fillChildEvents(o, \"resizable\", t);\n    function N(q, W) {\n      var K = e.fixedDirection, Z = e.fixedPosition, J = W.datas.startPositions || getAbsolutePosesByState(q.state), Q = getPosByDirection(J, K), et = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [Q[0] - Z[0], Q[1] - Z[1], 1], 3), nt = et[0], tt = et[1];\n      return W.datas.originalX = nt, W.datas.originalY = tt, W;\n    }\n    var k = e.startOffsetWidth, $ = e.startOffsetHeight;\n    function G() {\n      var q = e.minSize;\n      D.forEach(function(W) {\n        var K = W.datas, Z = K.minSize, J = K.startOffsetWidth, Q = K.startOffsetHeight, et = k * (J ? Z[0] / J : 0), nt = $ * (Q ? Z[1] / Q : 0);\n        q[0] = Math.max(q[0], et), q[1] = Math.max(q[1], nt);\n      });\n    }\n    function U() {\n      var q = e.maxSize;\n      D.forEach(function(W) {\n        var K = W.datas, Z = K.maxSize, J = K.startOffsetWidth, Q = K.startOffsetHeight, et = k * (J ? Z[0] / J : 0), nt = $ * (Q ? Z[1] / Q : 0);\n        q[0] = Math.min(q[0], et), q[1] = Math.min(q[1], nt);\n      });\n    }\n    var z = triggerChildAbles(o, this, \"dragControlStart\", t, function(q, W) {\n      return N(q, W);\n    });\n    G(), U();\n    var X = function(q) {\n      r.setFixedDirection(q), z.forEach(function(W, K) {\n        W.setFixedDirection(q), N(W.moveable, D[K]);\n      });\n    };\n    e.setFixedDirection = X;\n    var V = __assign$1(__assign$1({}, r), {\n      targets: o.props.targets,\n      events: z.map(function(q) {\n        return __assign$1(__assign$1({}, q), {\n          setMin: function(W) {\n            q.setMin(W), G();\n          },\n          setMax: function(W) {\n            q.setMax(W), U();\n          }\n        });\n      }),\n      setFixedDirection: X,\n      setMin: function(q) {\n        r.setMin(q), G();\n      },\n      setMax: function(q) {\n        r.setMax(q), U();\n      }\n    }), Y = triggerEvent(o, \"onResizeGroupStart\", V);\n    return e.isResize = Y !== !1, e.isResize ? r : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (e.isResize) {\n      var r = getProps(o.props, \"resizable\");\n      catchEvent(o, \"onBeforeResize\", function(Y) {\n        triggerEvent(o, \"onBeforeResizeGroup\", fillParams(o, t, __assign$1(__assign$1({}, Y), {\n          targets: r.targets\n        }), !0));\n      });\n      var D = this.dragControl(o, __assign$1(__assign$1({}, t), {\n        isGroup: !0\n      }));\n      if (D) {\n        var N = D.boundingWidth, k = D.boundingHeight, $ = D.dist, G = r.keepRatio, U = [N / (N - $[0]), k / (k - $[1])], z = e.fixedPosition, X = triggerChildAbles(o, this, \"dragControl\", t, function(Y, q) {\n          var W = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [q.datas.originalX * U[0], q.datas.originalY * U[1], 1], 3), K = W[0], Z = W[1];\n          return __assign$1(__assign$1({}, q), {\n            parentDist: null,\n            parentScale: U,\n            dragClient: plus(z, [K, Z]),\n            parentKeepRatio: G\n          });\n        }), V = __assign$1({\n          targets: r.targets,\n          events: X\n        }, D);\n        return triggerEvent(o, \"onResizeGroup\", V), V;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isResize) {\n      this.dragControlEnd(o, t);\n      var D = triggerChildAbles(o, this, \"dragControlEnd\", t), N = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: D\n      });\n      return triggerEvent(o, \"onResizeGroupEnd\", N), e;\n    }\n  },\n  /**\n   * @method Moveable.Resizable#request\n   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"resizable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(o) {\n    var t = {}, e = 0, r = 0, D = o.getRect();\n    return {\n      isControl: !0,\n      requestStart: function(N) {\n        var k;\n        return {\n          datas: t,\n          parentDirection: N.direction || [1, 1],\n          parentIsWidth: (k = N == null ? void 0 : N.horizontal) !== null && k !== void 0 ? k : !0\n        };\n      },\n      request: function(N) {\n        return \"offsetWidth\" in N ? e = N.offsetWidth - D.offsetWidth : \"deltaWidth\" in N && (e += N.deltaWidth), \"offsetHeight\" in N ? r = N.offsetHeight - D.offsetHeight : \"deltaHeight\" in N && (r += N.deltaHeight), {\n          datas: t,\n          parentDist: [e, r],\n          parentKeepRatio: N.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(o) {\n    o.state.gestos.resizable = null;\n  }\n};\nfunction setRotateStartInfo(o, t, e, r, D) {\n  var N = o.props.groupable, k = o.state, $ = k.is3d ? 4 : 3, G = t.origin, U = calculatePosition(\n    o.state.rootMatrix,\n    // TO-DO #710\n    minus([G[0], G[1]], N ? [0, 0] : [k.left, k.top]),\n    $\n  ), z = plus([D.left, D.top], U);\n  t.startAbsoluteOrigin = z, t.prevDeg = getRad$1(z, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(z, [e, r]);\n}\nfunction getAbsoluteDist(o, t, e) {\n  var r = e.defaultDeg, D = e.prevDeg, N = D % 360, k = Math.floor(D / 360);\n  N < 0 && (N += 360), N > o && N > 270 && o < 90 ? ++k : N < o && N < 90 && o > 270 && --k;\n  var $ = t * (k * 360 + o - r);\n  return e.prevDeg = r + $, $;\n}\nfunction getAbsoluteDistByClient(o, t, e, r) {\n  return getAbsoluteDist(getRad$1(r.startAbsoluteOrigin, [o, t]) / Math.PI * 180, e, r);\n}\nfunction getRotateInfo(o, t, e, r, D, N) {\n  var k = o.props.throttleRotate, $ = k === void 0 ? 0 : k, G = e.prevSnapDeg, U = 0, z = !1;\n  if (N) {\n    var X = checkSnapRotate(o, t, r);\n    z = X.isSnap, U = D + X.rotation;\n  }\n  z || (U = throttle(D + r, $));\n  var V = U - D;\n  return e.prevSnapDeg = V, [V - G, V, U];\n}\nfunction getRotationPositions(o, t, e) {\n  var r = t[0], D = t[1], N = t[2], k = t[3];\n  if (o === \"none\")\n    return [];\n  if (isArray(o))\n    return o.map(function(W) {\n      return getRotationPositions(W, [r, D, N, k], e)[0];\n    });\n  var $ = (o || \"top\").split(\"-\"), G = $[0], U = $[1], z = [r, D];\n  G === \"left\" ? z = [N, r] : G === \"right\" ? z = [D, k] : G === \"bottom\" && (z = [k, N]);\n  var X = [(z[0][0] + z[1][0]) / 2, (z[0][1] + z[1][1]) / 2], V = getRotationRad(z, e);\n  if (U) {\n    var Y = U === \"top\" || U === \"left\", q = G === \"bottom\" || G === \"left\";\n    X = z[Y && !q || !Y && q ? 0 : 1];\n  }\n  return [[X, V]];\n}\nfunction dragControlCondition(o, t) {\n  if (t.isRequest)\n    return t.requestAble === \"rotatable\";\n  var e = t.inputEvent.target;\n  if (hasClass(e, prefix(\"rotation-control\")) || o.props.rotateAroundControls && hasClass(e, prefix(\"around-control\")) || hasClass(e, prefix(\"control\")) && hasClass(e, prefix(\"rotatable\")))\n    return !0;\n  var r = o.props.rotationTarget;\n  return r ? getRefTargets(r, !0).some(function(D) {\n    return D ? e === D || e.contains(D) : !1;\n  }) : !1;\n}\nvar css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\n    cursor: alias;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n`, Rotatable = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object,\n    rotateAroundControls: Boolean,\n    edge: Boolean,\n    resolveAblesWithRotatable: Object,\n    displayAroundControls: Boolean\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onBeforeRotate: \"beforeRotate\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onBeforeRotateGroup: \"beforeRotateGroup\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [css],\n  viewClassName: function(o) {\n    return o.isDragging(\"rotatable\") ? prefix(\"view-rotation-dragging\") : \"\";\n  },\n  render: function(o, t) {\n    var e = getProps(o.props, \"rotatable\"), r = e.rotatable, D = e.rotationPosition, N = e.zoom, k = e.renderDirections, $ = e.rotateAroundControls, G = e.resolveAblesWithRotatable, U = o.getState(), z = U.renderPoses, X = U.direction;\n    if (!r)\n      return null;\n    var V = getRotationPositions(D, z, X), Y = [];\n    if (V.forEach(function(Z, J) {\n      var Q = Z[0], et = Z[1];\n      Y.push(t.createElement(\"div\", {\n        key: \"rotation\".concat(J),\n        className: prefix(\"rotation\"),\n        style: {\n          // tslint:disable-next-line: max-line-length\n          transform: \"translate(-50%) translate(\".concat(Q[0], \"px, \").concat(Q[1], \"px) rotate(\").concat(et, \"rad)\")\n        }\n      }, t.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(N, \")\")\n        }\n      }), t.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(N, \")\")\n        }\n      })));\n    }), k) {\n      var q = getKeys(G || {}), W = {};\n      q.forEach(function(Z) {\n        G[Z].forEach(function(J) {\n          W[J] = Z;\n        });\n      });\n      var K = [];\n      isArray(k) && (K = k.map(function(Z) {\n        var J = W[Z];\n        return {\n          data: J ? {\n            resolve: J\n          } : {},\n          classNames: J ? [\"move\"] : [],\n          dir: Z\n        };\n      })), Y.push.apply(Y, renderDirectionControlsByInfos(o, \"rotatable\", K, t));\n    }\n    return $ && Y.push.apply(Y, renderAroundControls(o, t)), Y;\n  },\n  dragControlCondition,\n  dragControlStart: function(o, t) {\n    var e, r, D = t.datas, N = t.clientX, k = t.clientY, $ = t.parentRotate, G = t.parentFlag, U = t.isPinch, z = t.isRequest, X = o.state, V = X.target, Y = X.left, q = X.top, W = X.direction, K = X.beforeDirection, Z = X.targetTransform, J = X.moveableClientRect, Q = X.offsetMatrix, et = X.targetMatrix, nt = X.allMatrix, tt = X.width, it = X.height;\n    if (!z && !V)\n      return !1;\n    var st = o.getRect();\n    D.rect = st, D.transform = Z, D.left = Y, D.top = q;\n    var at = function(Mt) {\n      var dt = o.state, $t = dt.allMatrix, Dt = dt.is3d, Vt = dt.width, Lt = dt.height, Et = getDirectionByPos(Mt, Vt, Lt);\n      D.fixedDirection = Et, D.fixedPosition = calculatePosition($t, Mt, Dt ? 4 : 3), bt && bt.setFixedPosition(Mt);\n    }, ut = function(Mt) {\n      D.fixedDirection = Mt, D.fixedPosition = getDirectionOffset(o, Mt), bt && bt.setFixedDirection(Mt);\n    }, ft = N, ct = k;\n    if (z || U || G) {\n      var vt = $ || 0;\n      D.beforeInfo = {\n        origin: st.beforeOrigin,\n        prevDeg: vt,\n        defaultDeg: vt,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, D.afterInfo = __assign$1(__assign$1({}, D.beforeInfo), {\n        origin: st.origin\n      }), D.absoluteInfo = __assign$1(__assign$1({}, D.beforeInfo), {\n        origin: st.origin,\n        startValue: vt\n      });\n    } else {\n      var yt = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;\n      if (yt) {\n        var mt = yt.getAttribute(\"data-direction\") || \"\", _t = DIRECTION_REGION_TO_DIRECTION[mt];\n        if (_t) {\n          D.isControl = !0, D.isAroundControl = hasClass(yt, prefix(\"around-control\")), D.controlDirection = _t;\n          var Tt = yt.getAttribute(\"data-resolve\");\n          Tt && (D.resolveAble = Tt);\n          var Pt = calculateMoveableClientPositions(X.rootMatrix, X.renderPoses, J);\n          e = getPosByDirection(Pt, _t), ft = e[0], ct = e[1];\n        }\n      }\n      D.beforeInfo = {\n        origin: st.beforeOrigin\n      }, D.afterInfo = {\n        origin: st.origin\n      }, D.absoluteInfo = {\n        origin: st.origin,\n        startValue: st.rotation\n      };\n      var St = at;\n      at = function(Mt) {\n        var dt = X.is3d ? 4 : 3, $t = plus(getOrigin(et, dt), Mt), Dt = $t[0], Vt = $t[1], Lt = calculate(Q, convertPositionMatrix([Dt, Vt], dt)), Et = calculate(nt, convertPositionMatrix([Mt[0], Mt[1]], dt));\n        St(Mt);\n        var Ht = X.posDelta;\n        D.beforeInfo.origin = minus(Lt, Ht), D.afterInfo.origin = minus(Et, Ht), D.absoluteInfo.origin = minus(Et, Ht), setRotateStartInfo(o, D.beforeInfo, ft, ct, J), setRotateStartInfo(o, D.afterInfo, ft, ct, J), setRotateStartInfo(o, D.absoluteInfo, ft, ct, J);\n      }, ut = function(Mt) {\n        var dt = getPosByDirection([[0, 0], [tt, 0], [0, it], [tt, it]], Mt);\n        at(dt);\n      };\n    }\n    D.startClientX = ft, D.startClientY = ct, D.direction = W, D.beforeDirection = K, D.startValue = 0, D.datas = {}, setDefaultTransformIndex(t, \"rotate\");\n    var gt = !1, bt = !1;\n    if (D.isControl && D.resolveAble) {\n      var Nt = D.resolveAble;\n      Nt === \"resizable\" && (bt = Resizable.dragControlStart(o, __assign$1(__assign$1({}, new CustomGesto(\"resizable\").dragStart([0, 0], t)), {\n        parentPosition: D.controlPosition,\n        parentFixedPosition: D.fixedPosition\n      })));\n    }\n    bt || (gt = Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))), at(X.transformOrigin);\n    var At = fillParams(o, t, __assign$1(__assign$1({\n      set: function(Mt) {\n        D.startValue = Mt * Math.PI / 180;\n      },\n      setFixedDirection: ut,\n      setFixedPosition: at\n    }, fillTransformStartEvent(t)), {\n      dragStart: gt,\n      resizeStart: bt\n    })), It = triggerEvent(o, \"onRotateStart\", At);\n    return D.isRotate = It !== !1, X.snapRenderInfo = {\n      request: t.isRequest\n    }, D.isRotate ? At : !1;\n  },\n  dragControl: function(o, t) {\n    var e, r, D, N = t.datas, k = t.clientDistX, $ = t.clientDistY, G = t.parentRotate, U = t.parentFlag, z = t.isPinch, X = t.groupDelta, V = N.beforeDirection, Y = N.beforeInfo, q = N.afterInfo, W = N.absoluteInfo, K = N.isRotate, Z = N.startValue, J = N.rect, Q = N.startClientX, et = N.startClientY;\n    if (K) {\n      resolveTransformEvent(t, \"rotate\");\n      var nt = getTransformDirection(t), tt = V * nt, it = o.props.parentMoveable, st = 0, at, ut, ft = 0, ct, vt, yt = 0, mt, _t, Tt = 180 / Math.PI * Z, Pt = W.startValue, St = !1, gt = Q + k, bt = et + $;\n      if (!U && \"parentDist\" in t) {\n        var Nt = t.parentDist;\n        at = Nt, ct = Nt, mt = Nt;\n      } else\n        z || U ? (at = getAbsoluteDist(G, V, Y), ct = getAbsoluteDist(G, tt, q), mt = getAbsoluteDist(G, tt, W)) : (at = getAbsoluteDistByClient(gt, bt, V, Y), ct = getAbsoluteDistByClient(gt, bt, tt, q), mt = getAbsoluteDistByClient(gt, bt, tt, W), St = !0);\n      if (ut = Tt + at, vt = Tt + ct, _t = Pt + mt, triggerEvent(o, \"onBeforeRotate\", fillParams(o, t, {\n        beforeRotation: ut,\n        rotation: vt,\n        absoluteRotation: _t,\n        setRotation: function(Ht) {\n          ct = Ht - Tt, at = ct, mt = ct;\n        }\n      }, !0)), e = getRotateInfo(o, J, Y, at, Tt, St), st = e[0], at = e[1], ut = e[2], r = getRotateInfo(o, J, q, ct, Tt, St), ft = r[0], ct = r[1], vt = r[2], D = getRotateInfo(o, J, W, mt, Pt, St), yt = D[0], mt = D[1], _t = D[2], !(!yt && !ft && !st && !it)) {\n        var At = convertTransformFormat(N, \"rotate(\".concat(vt, \"deg)\"), \"rotate(\".concat(ct, \"deg)\")), It = getRotateDist(o, ct, N), Mt = minus(plus(X || [0, 0], It), N.prevInverseDist || [0, 0]);\n        N.prevInverseDist = It, N.requestValue = null;\n        var dt = fillTransformEvent(o, At, Mt, z, t), $t = dt, Dt = getDist$2([gt, bt], W.startAbsoluteOrigin) - W.startDist, Vt = void 0;\n        if (N.resolveAble === \"resizable\") {\n          var Lt = Resizable.dragControl(o, __assign$1(__assign$1({}, setCustomDrag(t, o.state, [t.deltaX, t.deltaY], !!z, !1, \"resizable\")), {\n            resolveMatrix: !0,\n            parentDistance: Dt\n          }));\n          Lt && (Vt = Lt, $t = fillAfterTransform($t, Lt, t));\n        }\n        var Et = fillParams(o, t, __assign$1(__assign$1({\n          delta: ft,\n          dist: ct,\n          rotate: vt,\n          rotation: vt,\n          beforeDist: at,\n          beforeDelta: st,\n          beforeRotate: ut,\n          beforeRotation: ut,\n          absoluteDist: mt,\n          absoluteDelta: yt,\n          absoluteRotate: _t,\n          absoluteRotation: _t,\n          isPinch: !!z,\n          resize: Vt\n        }, dt), $t));\n        return triggerEvent(o, \"onRotate\", Et), Et;\n      }\n    }\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    if (e.isRotate) {\n      e.isRotate = !1;\n      var r = fillEndParams(o, t, {});\n      return triggerEvent(o, \"onRotateEnd\", r), r;\n    }\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = o.state, D = r.left, N = r.top, k = r.beforeOrigin, $ = this.dragControlStart(o, t);\n    if (!$)\n      return !1;\n    $.set(e.beforeDirection * o.rotation);\n    var G = triggerChildAbles(o, this, \"dragControlStart\", t, function(X, V) {\n      var Y = X.state, q = Y.left, W = Y.top, K = Y.beforeOrigin, Z = plus(minus([q, W], [D, N]), minus(K, k));\n      return V.datas.startGroupClient = Z, V.datas.groupClient = Z, __assign$1(__assign$1({}, V), {\n        parentRotate: 0\n      });\n    }), U = __assign$1(__assign$1({}, $), {\n      targets: o.props.targets,\n      events: G\n    }), z = triggerEvent(o, \"onRotateGroupStart\", U);\n    return e.isRotate = z !== !1, e.isRotate ? $ : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (e.isRotate) {\n      catchEvent(o, \"onBeforeRotate\", function(U) {\n        triggerEvent(o, \"onBeforeRotateGroup\", fillParams(o, t, __assign$1(__assign$1({}, U), {\n          targets: o.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(o, t);\n      if (r) {\n        var D = e.beforeDirection, N = r.beforeDist, k = N / 180 * Math.PI, $ = triggerChildAbles(o, this, \"dragControl\", t, function(U, z) {\n          var X = z.datas.startGroupClient, V = z.datas.groupClient, Y = V[0], q = V[1], W = rotate(X, k * D), K = W[0], Z = W[1], J = [K - Y, Z - q];\n          return z.datas.groupClient = [K, Z], __assign$1(__assign$1({}, z), {\n            parentRotate: N,\n            groupDelta: J\n          });\n        });\n        o.rotation = D * r.beforeRotation;\n        var G = __assign$1({\n          targets: o.props.targets,\n          events: $,\n          set: function(U) {\n            o.rotation = U;\n          },\n          setGroupRotation: function(U) {\n            o.rotation = U;\n          }\n        }, r);\n        return triggerEvent(o, \"onRotateGroup\", G), G;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isRotate) {\n      this.dragControlEnd(o, t);\n      var D = triggerChildAbles(o, this, \"dragControlEnd\", t), N = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: D\n      });\n      return triggerEvent(o, \"onRotateGroupEnd\", N), e;\n    }\n  },\n  /**\n   * @method Moveable.Rotatable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.deltaRotate=0] -  delta number of rotation\n   * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n   *\n   * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"rotatable\");\n   *\n   * // request\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   *\n   * requester.request({ rotate: 10 });\n   * requester.request({ rotate: 20 });\n   * requester.request({ rotate: 30 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(o) {\n    var t = {}, e = 0, r = o.getRotation();\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(D) {\n        return \"deltaRotate\" in D ? e += D.deltaRotate : \"rotate\" in D && (e = D.rotate - r), {\n          datas: t,\n          parentDist: e\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, directionCondition = getDirectionCondition(\"scalable\"), Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean,\n    edge: Boolean,\n    displayAroundControls: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onBeforeScale: \"beforeScale\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onBeforeScaleGroup: \"beforeScaleGroup\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: getRenderDirections(\"scalable\"),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName(\"scalable\"),\n  dragControlStart: function(o, t) {\n    var e = t.datas, r = t.isPinch, D = t.inputEvent, N = t.parentDirection, k = getTotalDirection(N, r, D, e), $ = o.state, G = $.width, U = $.height, z = $.targetTransform, X = $.target, V = $.pos1, Y = $.pos2, q = $.pos4;\n    if (!k || !X)\n      return !1;\n    r || setDragStart(o, t), e.datas = {}, e.transform = z, e.prevDist = [1, 1], e.direction = k, e.startOffsetWidth = G, e.startOffsetHeight = U, e.startValue = [1, 1];\n    var W = getDist$2(V, Y), K = getDist$2(Y, q), Z = !k[0] && !k[1] || k[0] || !k[1];\n    e.scaleWidth = W, e.scaleHeight = K, e.scaleXRatio = W / G, e.scaleYRatio = K / U, setDefaultTransformIndex(t, \"scale\"), e.isWidth = Z;\n    function J(tt) {\n      e.ratio = tt && isFinite(tt) ? tt : 0;\n    }\n    e.startPositions = getAbsolutePosesByState(o.state);\n    function Q(tt) {\n      e.fixedDirection = tt, e.fixedPosition = getPosByDirection(e.startPositions, tt);\n    }\n    e.setFixedDirection = Q, J(getDist$2(V, Y) / getDist$2(Y, q)), Q([-k[0], -k[1]]);\n    var et = fillParams(o, t, __assign$1(__assign$1({\n      direction: k,\n      set: function(tt) {\n        e.startValue = tt;\n      },\n      setRatio: J,\n      setFixedDirection: Q\n    }, fillTransformStartEvent(t)), {\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    })), nt = triggerEvent(o, \"onScaleStart\", et);\n    return e.startFixedDirection = e.fixedDirection, nt !== !1 && (e.isScale = !0, o.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: k\n    }), e.isScale ? et : !1;\n  },\n  dragControl: function(o, t) {\n    resolveTransformEvent(t, \"scale\");\n    var e = t.datas, r = t.parentKeepRatio, D = t.parentFlag, N = t.isPinch, k = t.dragClient, $ = t.isRequest, G = e.prevDist, U = e.direction, z = e.startOffsetWidth, X = e.startOffsetHeight, V = e.isScale, Y = e.startValue, q = e.isWidth, W = e.ratio;\n    if (!V)\n      return !1;\n    var K = o.props, Z = K.throttleScale, J = K.parentMoveable, Q = U;\n    !U[0] && !U[1] && (Q = [1, 1]);\n    var et = W && (r ?? K.keepRatio) || !1, nt = o.state;\n    function tt() {\n      var bt = getOffsetSizeDist(Q, et, e, t), Nt = bt.distWidth, At = bt.distHeight, It = z ? (z + Nt) / z : 1, Mt = X ? (X + At) / X : 1;\n      return It = Q[0] || et ? It * Y[0] : Y[0], Mt = Q[1] || et ? Mt * Y[1] : Y[1], It === 0 && (It = (G[0] > 0 ? 1 : -1) * MIN_SCALE), Mt === 0 && (Mt = (G[1] > 0 ? 1 : -1) * MIN_SCALE), [It, Mt];\n    }\n    var it = tt();\n    if (!N && o.props.groupable) {\n      var st = nt.snapRenderInfo || {}, at = st.direction;\n      isArray(at) && (at[0] || at[1]) && (nt.snapRenderInfo = {\n        direction: U,\n        request: t.isRequest\n      });\n    }\n    triggerEvent(o, \"onBeforeScale\", fillParams(o, t, {\n      scale: it,\n      setFixedDirection: function(bt) {\n        return e.setFixedDirection(bt), it = tt(), it;\n      },\n      startFixedDirection: e.startFixedDirection,\n      setScale: function(bt) {\n        it = bt;\n      }\n    }, !0));\n    var ut = [it[0] / Y[0], it[1] / Y[1]], ft = k, ct = [0, 0];\n    if (k || (!D && N ? ft = getAbsolutePosition(o, [0, 0]) : ft = e.fixedPosition), N || (ct = checkSnapScale(o, ut, U, $, e)), et) {\n      Q[0] && Q[1] && ct[0] && ct[1] && (Math.abs(ct[0] * z) > Math.abs(ct[1] * X) ? ct[1] = 0 : ct[0] = 0);\n      var vt = !ct[0] && !ct[1];\n      if (vt && (q ? ut[0] = throttle(ut[0] * Y[0], Z) / Y[0] : ut[1] = throttle(ut[1] * Y[1], Z) / Y[1]), Q[0] && !Q[1] || ct[0] && !ct[1] || vt && q) {\n        ut[0] += ct[0];\n        var yt = z * ut[0] * Y[0] / W;\n        ut[1] = yt / X / Y[1];\n      } else if (!Q[0] && Q[1] || !ct[0] && ct[1] || vt && !q) {\n        ut[1] += ct[1];\n        var mt = X * ut[1] * Y[1] * W;\n        ut[0] = mt / z / Y[0];\n      }\n    } else\n      ut[0] += ct[0], ut[1] += ct[1], ct[0] || (ut[0] = throttle(ut[0] * Y[0], Z) / Y[0]), ct[1] || (ut[1] = throttle(ut[1] * Y[1], Z) / Y[1]);\n    ut[0] === 0 && (ut[0] = (G[0] > 0 ? 1 : -1) * MIN_SCALE), ut[1] === 0 && (ut[1] = (G[1] > 0 ? 1 : -1) * MIN_SCALE);\n    var _t = [ut[0] / G[0], ut[1] / G[1]];\n    it = multiply2(ut, Y);\n    var Tt = getScaleDist(o, ut, e.fixedDirection, ft, e), Pt = minus(Tt, e.prevInverseDist || [0, 0]);\n    if (e.prevDist = ut, e.prevInverseDist = Tt, it[0] === G[0] && it[1] === G[1] && Pt.every(function(bt) {\n      return !bt;\n    }) && !J)\n      return !1;\n    var St = convertTransformFormat(e, \"scale(\".concat(it.join(\", \"), \")\"), \"scale(\".concat(ut.join(\", \"), \")\")), gt = fillParams(o, t, __assign$1({\n      offsetWidth: z,\n      offsetHeight: X,\n      direction: U,\n      scale: it,\n      dist: ut,\n      delta: _t,\n      isPinch: !!N\n    }, fillTransformEvent(o, St, Pt, N, t)));\n    return triggerEvent(o, \"onScale\", gt), gt;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    if (!e.isScale)\n      return !1;\n    e.isScale = !1;\n    var r = fillEndParams(o, t, {});\n    return triggerEvent(o, \"onScaleEnd\", r), r;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(o, t) {\n    var e = t.datas, r = this.dragControlStart(o, t);\n    if (!r)\n      return !1;\n    var D = fillChildEvents(o, \"resizable\", t);\n    function N(z, X) {\n      var V = e.fixedDirection, Y = e.fixedPosition, q = X.datas.startPositions || getAbsolutePosesByState(z.state), W = getPosByDirection(q, V), K = calculate(createRotateMatrix(-o.rotation / 180 * Math.PI, 3), [W[0] - Y[0], W[1] - Y[1], 1], 3), Z = K[0], J = K[1];\n      return X.datas.originalX = Z, X.datas.originalY = J, X;\n    }\n    e.moveableScale = o.scale;\n    var k = triggerChildAbles(o, this, \"dragControlStart\", t, function(z, X) {\n      return N(z, X);\n    }), $ = function(z) {\n      r.setFixedDirection(z), k.forEach(function(X, V) {\n        X.setFixedDirection(z), N(X.moveable, D[V]);\n      });\n    };\n    e.setFixedDirection = $;\n    var G = __assign$1(__assign$1({}, r), {\n      targets: o.props.targets,\n      events: k,\n      setFixedDirection: $\n    }), U = triggerEvent(o, \"onScaleGroupStart\", G);\n    return e.isScale = U !== !1, e.isScale ? G : !1;\n  },\n  dragGroupControl: function(o, t) {\n    var e = t.datas;\n    if (e.isScale) {\n      catchEvent(o, \"onBeforeScale\", function(X) {\n        triggerEvent(o, \"onBeforeScaleGroup\", fillParams(o, t, __assign$1(__assign$1({}, X), {\n          targets: o.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(o, t);\n      if (r) {\n        var D = e.moveableScale;\n        o.scale = [r.scale[0] * D[0], r.scale[1] * D[1]];\n        var N = o.props.keepRatio, k = r.dist, $ = r.scale, G = e.fixedPosition, U = triggerChildAbles(o, this, \"dragControl\", t, function(X, V) {\n          var Y = calculate(createRotateMatrix(o.rotation / 180 * Math.PI, 3), [V.datas.originalX * k[0], V.datas.originalY * k[1], 1], 3), q = Y[0], W = Y[1];\n          return __assign$1(__assign$1({}, V), {\n            parentDist: null,\n            parentScale: $,\n            parentKeepRatio: N,\n            dragClient: plus(G, [q, W])\n          });\n        }), z = __assign$1({\n          targets: o.props.targets,\n          events: U\n        }, r);\n        return triggerEvent(o, \"onScaleGroup\", z), z;\n      }\n    }\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isScale) {\n      this.dragControlEnd(o, t);\n      var D = triggerChildAbles(o, this, \"dragControlEnd\", t), N = fillEndParams(o, t, {\n        targets: o.props.targets,\n        events: D\n      });\n      return triggerEvent(o, \"onScaleGroupEnd\", N), e;\n    }\n  },\n  /**\n   * @method Moveable.Scalable#request\n   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"scalable\");\n   *\n   * // request\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function() {\n    var o = {}, t = 0, e = 0;\n    return {\n      isControl: !0,\n      requestStart: function(r) {\n        return {\n          datas: o,\n          parentDirection: r.direction || [1, 1]\n        };\n      },\n      request: function(r) {\n        return t += r.deltaWidth, e += r.deltaHeight, {\n          datas: o,\n          parentDist: [t, e],\n          parentKeepRatio: r.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: o,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction getMiddleLinePos(o, t) {\n  return o.map(function(e, r) {\n    return dot(e, t[r], 1, 2);\n  });\n}\nfunction getTriangleRad(o, t, e) {\n  var r = getRad$1(o, t), D = getRad$1(o, e), N = D - r;\n  return N >= 0 ? N : N + 2 * Math.PI;\n}\nfunction isValidPos(o, t) {\n  var e = getTriangleRad(o[0], o[1], o[2]), r = getTriangleRad(t[0], t[1], t[2]), D = Math.PI;\n  return !(e >= D && r <= D || e <= D && r >= D);\n}\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array,\n    edge: Boolean,\n    displayAroundControls: Boolean\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  viewClassName: getDirectionViewClassName(\"warpable\"),\n  render: function(o, t) {\n    var e = o.props, r = e.resizable, D = e.scalable, N = e.warpable, k = e.zoom;\n    if (r || D || !N)\n      return [];\n    var $ = o.state, G = $.pos1, U = $.pos2, z = $.pos3, X = $.pos4, V = getMiddleLinePos(G, U), Y = getMiddleLinePos(U, G), q = getMiddleLinePos(G, z), W = getMiddleLinePos(z, G), K = getMiddleLinePos(z, X), Z = getMiddleLinePos(X, z), J = getMiddleLinePos(U, X), Q = getMiddleLinePos(X, U);\n    return __spreadArray([t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(V, K, k)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(Y, Z, k)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(q, J, k)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(W, Q, k)\n    })], renderAllDirections(o, \"warpable\", t), !0);\n  },\n  dragControlCondition: function(o, t) {\n    if (t.isRequest)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"warpable\"));\n  },\n  dragControlStart: function(o, t) {\n    var e = t.datas, r = t.inputEvent, D = o.props.target, N = r.target, k = getDirection(N, e);\n    if (!k || !D)\n      return !1;\n    var $ = o.state, G = $.transformOrigin, U = $.is3d, z = $.targetTransform, X = $.targetMatrix, V = $.width, Y = $.height, q = $.left, W = $.top;\n    e.datas = {}, e.targetTransform = z, e.warpTargetMatrix = U ? X : convertDimension(X, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = k, e.left = q, e.top = W, e.poses = [[0, 0], [V, 0], [0, Y], [V, Y]].map(function(J) {\n      return minus(J, G);\n    }), e.nextPoses = e.poses.map(function(J) {\n      var Q = J[0], et = J[1];\n      return calculate(e.warpTargetMatrix, [Q, et, 0, 1], 4);\n    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState($), e.posIndexes = getPosIndexesByDirection(k), setDragStart(o, t), setDefaultTransformIndex(t, \"matrix3d\"), $.snapRenderInfo = {\n      request: t.isRequest,\n      direction: k\n    };\n    var K = fillParams(o, t, __assign$1({\n      set: function(J) {\n        e.startValue = J;\n      }\n    }, fillTransformStartEvent(t))), Z = triggerEvent(o, \"onWarpStart\", K);\n    return Z !== !1 && (e.isWarp = !0), e.isWarp;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = t.isRequest, D = t.distX, N = t.distY, k = e.targetInverseMatrix, $ = e.prevMatrix, G = e.isWarp, U = e.startValue, z = e.poses, X = e.posIndexes, V = e.absolutePoses;\n    if (!G)\n      return !1;\n    if (resolveTransformEvent(t, \"matrix3d\"), hasGuidelines(o, \"warpable\")) {\n      var Y = X.map(function(at) {\n        return V[at];\n      });\n      Y.length > 1 && Y.push([(Y[0][0] + Y[1][0]) / 2, (Y[0][1] + Y[1][1]) / 2]);\n      var q = checkMoveableSnapBounds(o, r, {\n        horizontal: Y.map(function(at) {\n          return at[1] + N;\n        }),\n        vertical: Y.map(function(at) {\n          return at[0] + D;\n        })\n      }), W = q.horizontal, K = q.vertical;\n      N -= W.offset, D -= K.offset;\n    }\n    var Z = getDragDist({\n      datas: e,\n      distX: D,\n      distY: N\n    }, !0), J = e.nextPoses.slice();\n    if (X.forEach(function(at) {\n      J[at] = plus(J[at], Z);\n    }), !NEARBY_POS.every(function(at) {\n      return isValidPos(at.map(function(ut) {\n        return z[ut];\n      }), at.map(function(ut) {\n        return J[ut];\n      }));\n    }))\n      return !1;\n    var Q = createWarpMatrix(z[0], z[2], z[1], z[3], J[0], J[2], J[1], J[3]);\n    if (!Q.length)\n      return !1;\n    var et = multiply(k, Q, 4), nt = getTransfromMatrix(e, et, !0), tt = multiply(invert($, 4), nt, 4);\n    e.prevMatrix = nt;\n    var it = multiply(U, nt, 4), st = convertTransformFormat(e, \"matrix3d(\".concat(it.join(\", \"), \")\"), \"matrix3d(\".concat(nt.join(\", \"), \")\"));\n    return fillOriginalTransform(t, st), triggerEvent(o, \"onWarp\", fillParams(o, t, __assign$1({\n      delta: tt,\n      matrix: it,\n      dist: nt,\n      multiply,\n      transform: st\n    }, fillCSSObject({\n      transform: st\n    }, t)))), !0;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas, r = t.isDrag;\n    return e.isWarp ? (e.isWarp = !1, triggerEvent(o, \"onWarpEnd\", fillEndParams(o, t, {})), r) : !1;\n  }\n}, AREA_PIECES = /* @__PURE__ */ prefix(\"area-pieces\"), AREA_PIECE = /* @__PURE__ */ prefix(\"area-piece\"), AVOID = /* @__PURE__ */ prefix(\"avoid\"), VIEW_DRAGGING = prefix(\"view-dragging\");\nfunction restoreStyle(o) {\n  var t = o.areaElement;\n  if (t) {\n    var e = o.state, r = e.width, D = e.height;\n    removeClass(t, AVOID), t.style.cssText += \"left: 0px; top: 0px; width: \".concat(r, \"px; height: \").concat(D, \"px\");\n  }\n}\nfunction renderPieces(o) {\n  return o.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }), o.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function(o, t) {\n    var e = o.props, r = e.target, D = e.dragArea, N = e.groupable, k = e.passDragArea, $ = o.getState(), G = $.width, U = $.height, z = $.renderPoses, X = k ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (N)\n      return [t.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(o, \"areaElement\"),\n        className: X\n      }), renderPieces(t)];\n    if (!r || !D)\n      return [];\n    var V = createWarpMatrix([0, 0], [G, 0], [0, U], [G, U], z[0], z[1], z[2], z[3]), Y = V.length ? makeMatrixCSS(V, !0) : \"none\";\n    return [t.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(o, \"areaElement\"),\n      className: X,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(G, \"px\"),\n        height: \"\".concat(U, \"px\"),\n        transformOrigin: \"0 0\",\n        transform: Y\n      }\n    }), renderPieces(t)];\n  },\n  dragStart: function(o, t) {\n    var e = t.datas, r = t.clientX, D = t.clientY, N = t.inputEvent;\n    if (!N)\n      return !1;\n    e.isDragArea = !1;\n    var k = o.areaElement, $ = o.state, G = $.moveableClientRect, U = $.renderPoses, z = $.rootMatrix, X = $.is3d, V = G.left, Y = G.top, q = getRect(U), W = q.left, K = q.top, Z = q.width, J = q.height, Q = X ? 4 : 3, et = calculateInversePosition(z, [r - V, D - Y], Q), nt = et[0], tt = et[1];\n    nt -= W, tt -= K;\n    var it = [{\n      left: W,\n      top: K,\n      width: Z,\n      height: tt - 10\n    }, {\n      left: W,\n      top: K,\n      width: nt - 10,\n      height: J\n    }, {\n      left: W,\n      top: K + tt + 10,\n      width: Z,\n      height: J - tt - 10\n    }, {\n      left: W + nt + 10,\n      top: K,\n      width: Z - nt - 10,\n      height: J\n    }], st = [].slice.call(k.nextElementSibling.children);\n    it.forEach(function(at, ut) {\n      st[ut].style.cssText = \"left: \".concat(at.left, \"px;top: \").concat(at.top, \"px; width: \").concat(at.width, \"px; height: \").concat(at.height, \"px;\");\n    }), addClass(k, AVOID), $.disableNativeEvent = !0;\n  },\n  drag: function(o, t) {\n    var e = t.datas, r = t.inputEvent;\n    if (this.enableNativeEvent(o), !r)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, restoreStyle(o));\n  },\n  dragEnd: function(o, t) {\n    this.enableNativeEvent(o);\n    var e = t.inputEvent, r = t.datas;\n    if (!e)\n      return !1;\n    r.isDragArea || restoreStyle(o);\n  },\n  dragGroupStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragGroup: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragGroupEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  unset: function(o) {\n    restoreStyle(o), o.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent: function(o) {\n    var t = o.state;\n    t.disableNativeEvent && requestAnimationFrame$1(function() {\n      t.disableNativeEvent = !1;\n    });\n  }\n}, Origin = makeAble(\"origin\", {\n  render: function(o, t) {\n    var e = o.props.zoom, r = o.getState(), D = r.beforeOrigin, N = r.rotation;\n    return [t.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(N, e, D),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction getDefaultScrollPosition(o) {\n  var t = o.scrollContainer;\n  return [t.scrollLeft, t.scrollTop];\n}\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    scrollThrottleTime: Number,\n    getScrollPosition: Function,\n    scrollOptions: Object\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragRelation: \"strong\",\n  dragStart: function(o, t) {\n    var e = o.props, r = e.scrollContainer, D = r === void 0 ? o.getContainer() : r, N = e.scrollOptions, k = new DragScroll$1(), $ = getRefTarget(D, !0);\n    t.datas.dragScroll = k, o.state.dragScroll = k;\n    var G = t.isControl ? \"controlGesto\" : \"targetGesto\", U = t.targets;\n    k.on(\"scroll\", function(z) {\n      var X = z.container, V = z.direction, Y = fillParams(o, t, {\n        scrollContainer: X,\n        direction: V\n      }), q = U ? \"onScrollGroup\" : \"onScroll\";\n      U && (Y.targets = U), triggerEvent(o, q, Y);\n    }).on(\"move\", function(z) {\n      var X = z.offsetX, V = z.offsetY, Y = z.inputEvent;\n      o[G].scrollBy(X, V, Y.inputEvent, !0);\n    }).on(\"scrollDrag\", function(z) {\n      var X = z.next;\n      X(o[G].getCurrentEvent());\n    }), k.dragStart(t, __assign$1({\n      container: $\n    }, N));\n  },\n  checkScroll: function(o, t) {\n    var e = t.datas.dragScroll;\n    if (e) {\n      var r = o.props, D = r.scrollContainer, N = D === void 0 ? o.getContainer() : D, k = r.scrollThreshold, $ = k === void 0 ? 0 : k, G = r.scrollThrottleTime, U = G === void 0 ? 0 : G, z = r.getScrollPosition, X = z === void 0 ? getDefaultScrollPosition : z, V = r.scrollOptions;\n      return e.drag(t, __assign$1({\n        container: N,\n        threshold: $,\n        throttleTime: U,\n        getScrollPosition: function(Y) {\n          return X({\n            scrollContainer: Y.container,\n            direction: Y.direction\n          });\n        }\n      }, V)), !0;\n    }\n  },\n  drag: function(o, t) {\n    return this.checkScroll(o, t);\n  },\n  dragEnd: function(o, t) {\n    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      isControl: !0\n    }));\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroup: function(o, t) {\n    return this.drag(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupEnd: function(o, t) {\n    return this.dragEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragStart(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets,\n      isControl: !0\n    }));\n  },\n  dragGroupControl: function(o, t) {\n    return this.drag(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  dragGroupControEnd: function(o, t) {\n    return this.dragEnd(o, __assign$1(__assign$1({}, t), {\n      targets: o.props.targets\n    }));\n  },\n  unset: function(o) {\n    var t, e = o.state;\n    (t = e.dragScroll) === null || t === void 0 || t.dragEnd(), e.dragScroll = null;\n  }\n}, Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    useResizeObserver: Boolean,\n    useMutationObserver: Boolean,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Object,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    hideDefaultLines: Boolean,\n    props: Object,\n    flushSync: Function,\n    stopPropagation: Boolean,\n    preventClickEventOnDrag: Boolean,\n    preventClickDefault: Boolean,\n    viewContainer: Object,\n    persistData: Object,\n    useAccuratePosition: Boolean,\n    firstRenderState: Object,\n    linePadding: Boolean,\n    displayAroundControls: Boolean,\n    controlPadding: Number,\n    preventDefault: Boolean,\n    requestStyles: Array\n  },\n  events: {\n    onChangeTargets: \"changeTargets\"\n  }\n}, Padding = makeAble(\"padding\", {\n  render: function(o, t) {\n    var e = o.props;\n    if (e.dragArea)\n      return [];\n    var r = e.padding || {}, D = r.left, N = D === void 0 ? 0 : D, k = r.top, $ = k === void 0 ? 0 : k, G = r.right, U = G === void 0 ? 0 : G, z = r.bottom, X = z === void 0 ? 0 : z, V = o.getState(), Y = V.renderPoses, q = V.pos1, W = V.pos2, K = V.pos3, Z = V.pos4, J = [q, W, K, Z], Q = [];\n    return N > 0 && Q.push([0, 2]), $ > 0 && Q.push([0, 1]), U > 0 && Q.push([1, 3]), X > 0 && Q.push([2, 3]), Q.map(function(et, nt) {\n      var tt = et[0], it = et[1], st = J[tt], at = J[it], ut = Y[tt], ft = Y[it], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], st, at, ut, ft);\n      if (ct.length)\n        return t.createElement(\"div\", {\n          key: \"padding\".concat(nt),\n          className: prefix(\"padding\"),\n          style: {\n            transform: makeMatrixCSS(ct, !0)\n          }\n        });\n    });\n  }\n}), RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction calculateRatio(o, t) {\n  var e = o[0] + o[1], r = e > t ? t / e : 1;\n  return o[0] *= r, o[1] = t - o[1] * r, o;\n}\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\nfunction getRadiusStyles(o, t, e, r, D, N, k, $) {\n  D === void 0 && (D = 0), N === void 0 && (N = 0), k === void 0 && (k = e), $ === void 0 && ($ = r);\n  var G = [], U = !1, z = o.filter(function(V) {\n    return !V.virtual;\n  }), X = z.map(function(V) {\n    var Y = V.horizontal, q = V.vertical, W = V.pos;\n    if (q && !U && (U = !0, G.push(\"/\")), U) {\n      var K = Math.max(0, q === 1 ? W[1] - N : $ - W[1]);\n      return G.push(convertCSSSize(K, r, t)), K;\n    } else {\n      var K = Math.max(0, Y === 1 ? W[0] - D : k - W[0]);\n      return G.push(convertCSSSize(K, e, t)), K;\n    }\n  });\n  return {\n    radiusPoses: z,\n    styles: G,\n    raws: X\n  };\n}\nfunction getRadiusRange(o) {\n  for (var t = [0, 0], e = [0, 0], r = o.length, D = 0; D < r; ++D) {\n    var N = o[D];\n    N.sub && (N.horizontal && (t[1] === 0 && (t[0] = D), t[1] = D - t[0] + 1, e[0] = D + 1), N.vertical && (e[1] === 0 && (e[0] = D), e[1] = D - e[0] + 1));\n  }\n  return {\n    horizontalRange: t,\n    verticalRange: e\n  };\n}\nfunction getRadiusValues(o, t, e, r, D, N, k) {\n  var $, G, U, z;\n  N === void 0 && (N = [0, 0]), k === void 0 && (k = !1);\n  var X = o.indexOf(\"/\"), V = (X > -1 ? o.slice(0, X) : o).length, Y = o.slice(0, V), q = o.slice(V + 1), W = Y.length, K = q.length, Z = K > 0, J = Y[0], Q = J === void 0 ? \"0px\" : J, et = Y[1], nt = et === void 0 ? Q : et, tt = Y[2], it = tt === void 0 ? Q : tt, st = Y[3], at = st === void 0 ? nt : st, ut = q[0], ft = ut === void 0 ? Q : ut, ct = q[1], vt = ct === void 0 ? Z ? ft : nt : ct, yt = q[2], mt = yt === void 0 ? Z ? ft : it : yt, _t = q[3], Tt = _t === void 0 ? Z ? vt : at : _t, Pt = [Q, nt, it, at].map(function(It) {\n    return convertUnitSize(It, t);\n  }), St = [ft, vt, mt, Tt].map(function(It) {\n    return convertUnitSize(It, e);\n  }), gt = Pt.slice(), bt = St.slice();\n  $ = calculateRatio([gt[0], gt[1]], t), gt[0] = $[0], gt[1] = $[1], G = calculateRatio([gt[3], gt[2]], t), gt[3] = G[0], gt[2] = G[1], U = calculateRatio([bt[0], bt[3]], e), bt[0] = U[0], bt[3] = U[1], z = calculateRatio([bt[1], bt[2]], e), bt[1] = z[0], bt[2] = z[1];\n  var Nt = k ? gt : gt.slice(0, Math.max(N[0], W)), At = k ? bt : bt.slice(0, Math.max(N[1], K));\n  return __spreadArray(__spreadArray([], Nt.map(function(It, Mt) {\n    var dt = RADIUS_DIRECTIONS[Mt];\n    return {\n      virtual: Mt >= W,\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Mt],\n      vertical: 0,\n      pos: [r + It, D + (VERTICAL_RADIUS_DIRECTIONS[Mt] === -1 ? e : 0)],\n      sub: !0,\n      raw: Pt[Mt],\n      direction: dt\n    };\n  }), !0), At.map(function(It, Mt) {\n    var dt = RADIUS_DIRECTIONS[Mt];\n    return {\n      virtual: Mt >= K,\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[Mt],\n      pos: [r + (HORIZONTAL_RADIUS_DIRECTIONS[Mt] === -1 ? t : 0), D + It],\n      sub: !0,\n      raw: St[Mt],\n      direction: dt\n    };\n  }), !0);\n}\nfunction removeRadiusPos(o, t, e, r, D) {\n  D === void 0 && (D = t.length);\n  var N = getRadiusRange(o.slice(r)), k = N.horizontalRange, $ = N.verticalRange, G = e - r, U = 0;\n  if (G === 0)\n    U = D;\n  else if (G > 0 && G < k[1])\n    U = k[1] - G;\n  else if (G >= $[0])\n    U = $[0] + $[1] - G;\n  else\n    return;\n  o.splice(e, U), t.splice(e, U);\n}\nfunction addRadiusPos(o, t, e, r, D, N, k, $, G, U, z) {\n  U === void 0 && (U = 0), z === void 0 && (z = 0);\n  var X = getRadiusRange(o.slice(e)), V = X.horizontalRange, Y = X.verticalRange;\n  if (r > -1)\n    for (var q = HORIZONTAL_RADIUS_DIRECTIONS[r] === 1 ? N - U : $ - N, W = V[1]; W <= r; ++W) {\n      var K = VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? z : G, Z = 0;\n      if (r === W ? Z = N : W === 0 ? Z = U + q : HORIZONTAL_RADIUS_DIRECTIONS[W] === -1 && (Z = $ - (t[e][0] - U)), o.splice(e + W, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[W],\n        vertical: 0,\n        pos: [Z, K]\n      }), t.splice(e + W, 0, [Z, K]), W === 0)\n        break;\n    }\n  else if (D > -1) {\n    var J = VERTICAL_RADIUS_DIRECTIONS[D] === 1 ? k - z : G - k;\n    if (V[1] === 0 && Y[1] === 0) {\n      var Q = [U + J, z];\n      o.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: Q\n      }), t.push(Q);\n    }\n    for (var et = Y[0], W = Y[1]; W <= D; ++W) {\n      var Z = HORIZONTAL_RADIUS_DIRECTIONS[W] === 1 ? U : $, K = 0;\n      if (D === W ? K = k : W === 0 ? K = z + J : VERTICAL_RADIUS_DIRECTIONS[W] === 1 ? K = t[e + et][1] : VERTICAL_RADIUS_DIRECTIONS[W] === -1 && (K = G - (t[e + et][1] - z)), o.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[W],\n        pos: [Z, K]\n      }), t.push([Z, K]), W === 0)\n        break;\n    }\n  }\n}\nfunction splitRadiusPoses(o, t) {\n  t === void 0 && (t = o.map(function(D) {\n    return D.raw;\n  }));\n  var e = o.map(function(D, N) {\n    return D.horizontal ? t[N] : null;\n  }).filter(function(D) {\n    return D != null;\n  }), r = o.map(function(D, N) {\n    return D.vertical ? t[N] : null;\n  }).filter(function(D) {\n    return D != null;\n  });\n  return {\n    horizontals: e,\n    verticals: r\n  };\n}\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]], CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction getClipStyles(o, t, e) {\n  var r = o.props.clipRelative, D = o.state, N = D.width, k = D.height, $ = t, G = $.type, U = $.poses, z = G === \"rect\", X = G === \"circle\";\n  if (G === \"polygon\")\n    return e.map(function(tt) {\n      return \"\".concat(convertCSSSize(tt[0], N, r), \" \").concat(convertCSSSize(tt[1], k, r));\n    });\n  if (z || G === \"inset\") {\n    var V = e[1][1], Y = e[3][0], q = e[7][0], W = e[5][1];\n    if (z)\n      return [V, Y, W, q].map(function(tt) {\n        return \"\".concat(tt, \"px\");\n      });\n    var K = [V, N - Y, k - W, q].map(function(tt, it) {\n      return convertCSSSize(tt, it % 2 ? N : k, r);\n    });\n    if (e.length > 8) {\n      var Z = minus(e[4], e[0]), J = Z[0], Q = Z[1];\n      K.push.apply(K, __spreadArray([\"round\"], getRadiusStyles(U.slice(8).map(function(tt, it) {\n        return __assign$1(__assign$1({}, tt), {\n          pos: e[it]\n        });\n      }), r, J, Q, q, V, Y, W).styles, !1));\n    }\n    return K;\n  } else if (X || G === \"ellipse\") {\n    var et = e[0], nt = convertCSSSize(Math.abs(e[1][1] - et[1]), X ? Math.sqrt((N * N + k * k) / 2) : k, r), K = X ? [nt] : [convertCSSSize(Math.abs(e[2][0] - et[0]), N, r), nt];\n    return K.push(\"at\", convertCSSSize(et[0], N, r), convertCSSSize(et[1], k, r)), K;\n  }\n}\nfunction getRectPoses(o, t, e, r) {\n  var D = [r, (r + t) / 2, t], N = [o, (o + e) / 2, e];\n  return CLIP_RECT_DIRECTIONS.map(function(k) {\n    var $ = k[0], G = k[1], U = k[2], z = D[$ + 1], X = N[G + 1];\n    return {\n      vertical: Math.abs(G),\n      horizontal: Math.abs($),\n      direction: U,\n      pos: [z, X]\n    };\n  });\n}\nfunction getControlSize(o) {\n  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];\n  return o.forEach(function(r) {\n    var D = r.pos;\n    t[0] = Math.min(t[0], D[0]), t[1] = Math.max(t[1], D[0]), e[0] = Math.min(e[0], D[1]), e[1] = Math.max(e[1], D[1]);\n  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];\n}\nfunction getClipPath(o, t, e, r, D) {\n  var N, k, $, G, U, z, X;\n  if (o) {\n    var V = D;\n    if (!V) {\n      var Y = getComputedStyle(o), q = Y.clipPath;\n      V = q !== \"none\" ? q : Y.clip;\n    }\n    if (!((!V || V === \"none\" || V === \"auto\") && (V = r, !V))) {\n      var W = splitBracket(V), K = W.prefix, Z = K === void 0 ? V : K, J = W.value, Q = J === void 0 ? \"\" : J, et = Z === \"circle\", nt = \" \";\n      if (Z === \"polygon\") {\n        var tt = splitComma(Q || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n        nt = \",\";\n        var it = tt.map(function(qt) {\n          var Qt = qt.split(\" \"), Kt = Qt[0], Se = Qt[1];\n          return {\n            vertical: 1,\n            horizontal: 1,\n            pos: [convertUnitSize(Kt, t), convertUnitSize(Se, e)]\n          };\n        }), st = getMinMaxs(it.map(function(qt) {\n          return qt.pos;\n        }));\n        return {\n          type: Z,\n          clipText: V,\n          poses: it,\n          splitter: nt,\n          left: st.minX,\n          right: st.maxX,\n          top: st.minY,\n          bottom: st.maxY\n        };\n      } else if (et || Z === \"ellipse\") {\n        var at = \"\", ut = \"\", ft = 0, ct = 0, tt = splitSpace(Q);\n        if (et) {\n          var vt = \"\";\n          N = tt[0], vt = N === void 0 ? \"50%\" : N, k = tt[2], at = k === void 0 ? \"50%\" : k, $ = tt[3], ut = $ === void 0 ? \"50%\" : $, ft = convertUnitSize(vt, Math.sqrt((t * t + e * e) / 2)), ct = ft;\n        } else {\n          var yt = \"\", mt = \"\";\n          G = tt[0], yt = G === void 0 ? \"50%\" : G, U = tt[1], mt = U === void 0 ? \"50%\" : U, z = tt[3], at = z === void 0 ? \"50%\" : z, X = tt[4], ut = X === void 0 ? \"50%\" : X, ft = convertUnitSize(yt, t), ct = convertUnitSize(mt, e);\n        }\n        var _t = [convertUnitSize(at, t), convertUnitSize(ut, e)], it = __spreadArray([{\n          vertical: 1,\n          horizontal: 1,\n          pos: _t,\n          direction: \"nesw\"\n        }], CLIP_DIRECTIONS.slice(0, et ? 1 : 2).map(function(Kt) {\n          return {\n            vertical: Math.abs(Kt[1]),\n            horizontal: Kt[0],\n            direction: Kt[2],\n            sub: !0,\n            pos: [_t[0] + Kt[0] * ft, _t[1] + Kt[1] * ct]\n          };\n        }), !0);\n        return {\n          type: Z,\n          clipText: V,\n          radiusX: ft,\n          radiusY: ct,\n          left: _t[0] - ft,\n          top: _t[1] - ct,\n          right: _t[0] + ft,\n          bottom: _t[1] + ct,\n          poses: it,\n          splitter: nt\n        };\n      } else if (Z === \"inset\") {\n        var tt = splitSpace(Q || \"0 0 0 0\"), Tt = tt.indexOf(\"round\"), Pt = (Tt > -1 ? tt.slice(0, Tt) : tt).length, St = tt.slice(Pt + 1), gt = tt.slice(0, Pt), bt = gt[0], Nt = gt[1], At = Nt === void 0 ? bt : Nt, It = gt[2], Mt = It === void 0 ? bt : It, dt = gt[3], $t = dt === void 0 ? At : dt, Dt = [bt, Mt].map(function(Kt) {\n          return convertUnitSize(Kt, e);\n        }), Vt = Dt[0], Lt = Dt[1], Et = [$t, At].map(function(Kt) {\n          return convertUnitSize(Kt, t);\n        }), Ht = Et[0], kt = Et[1], wt = t - kt, Bt = e - Lt, jt = getRadiusValues(St, wt - Ht, Bt - Vt, Ht, Vt), it = __spreadArray(__spreadArray([], getRectPoses(Vt, wt, Bt, Ht), !0), jt, !0);\n        return {\n          type: \"inset\",\n          clipText: V,\n          poses: it,\n          top: Vt,\n          left: Ht,\n          right: wt,\n          bottom: Bt,\n          radius: St,\n          splitter: nt\n        };\n      } else if (Z === \"rect\") {\n        var tt = splitComma(Q || \"0px, \".concat(t, \"px, \").concat(e, \"px, 0px\"));\n        nt = \",\";\n        var Ct = tt.map(function(_e) {\n          var ve = splitUnit(_e).value;\n          return ve;\n        }), Vt = Ct[0], kt = Ct[1], Lt = Ct[2], Ht = Ct[3], it = getRectPoses(Vt, kt, Lt, Ht);\n        return {\n          type: \"rect\",\n          clipText: V,\n          poses: it,\n          top: Vt,\n          right: kt,\n          bottom: Lt,\n          left: Ht,\n          values: tt,\n          splitter: nt\n        };\n      }\n    }\n  }\n}\nfunction moveControlPos(o, t, e, r, D) {\n  var N = o[t], k = N.direction, $ = N.sub, G = o.map(function() {\n    return [0, 0];\n  }), U = k ? k.split(\"\") : [];\n  if (r && t < 8) {\n    var z = U.filter(function(vt) {\n      return vt === \"w\" || vt === \"e\";\n    }), X = U.filter(function(vt) {\n      return vt === \"n\" || vt === \"s\";\n    }), V = z[0], Y = X[0];\n    G[t] = e;\n    var q = getControlSize(o), W = q[0], K = q[1], Z = W && K ? W / K : 0;\n    if (Z && D) {\n      var J = (t + 4) % 8, Q = o[J].pos, et = [0, 0];\n      k.indexOf(\"w\") > -1 ? et[0] = -1 : k.indexOf(\"e\") > -1 && (et[0] = 1), k.indexOf(\"n\") > -1 ? et[1] = -1 : k.indexOf(\"s\") > -1 && (et[1] = 1);\n      var nt = getSizeDistByDist([W, K], e, Z, et, !0), tt = W + nt[0], it = K + nt[1], st = Q[1], at = Q[1], ut = Q[0], ft = Q[0];\n      et[0] === -1 ? ut = ft - tt : et[0] === 1 ? ft = ut + tt : (ut = ut - tt / 2, ft = ft + tt / 2), et[1] === -1 ? st = at - it : (et[1] === 1 || (st = at - it / 2), at = st + it);\n      var ct = getRectPoses(st, ft, at, ut);\n      o.forEach(function(vt, yt) {\n        G[yt][0] = ct[yt].pos[0] - vt.pos[0], G[yt][1] = ct[yt].pos[1] - vt.pos[1];\n      });\n    } else\n      o.forEach(function(vt, yt) {\n        var mt = vt.direction;\n        mt && (mt.indexOf(V) > -1 && (G[yt][0] = e[0]), mt.indexOf(Y) > -1 && (G[yt][1] = e[1]));\n      }), V && (G[1][0] = e[0] / 2, G[5][0] = e[0] / 2), Y && (G[3][1] = e[1] / 2, G[7][1] = e[1] / 2);\n  } else\n    k && !$ ? U.forEach(function(vt) {\n      var yt = vt === \"n\" || vt === \"s\";\n      o.forEach(function(mt, _t) {\n        var Tt = mt.direction, Pt = mt.horizontal, St = mt.vertical;\n        !Tt || Tt.indexOf(vt) === -1 || (G[_t] = [yt || !Pt ? 0 : e[0], !yt || !St ? 0 : e[1]]);\n      });\n    }) : G[t] = e;\n  return G;\n}\nfunction addClipPath(o, t) {\n  var e = calculatePointerDist(o, t), r = e[0], D = e[1], N = t.datas, k = N.clipPath, $ = N.clipIndex, G = k, U = G.type, z = G.poses, X = G.splitter, V = z.map(function(J) {\n    return J.pos;\n  });\n  if (U === \"polygon\")\n    V.splice($, 0, [r, D]);\n  else if (U === \"inset\") {\n    var Y = HORIZONTAL_RADIUS_ORDER.indexOf($), q = VERTICAL_RADIUS_ORDER.indexOf($), W = z.length;\n    if (addRadiusPos(z, V, 8, Y, q, r, D, V[4][0], V[4][1], V[0][0], V[0][1]), W === z.length)\n      return;\n  } else\n    return;\n  var K = getClipStyles(o, k, V), Z = \"\".concat(U, \"(\").concat(K.join(X), \")\");\n  triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n    clipEventType: \"added\",\n    clipType: U,\n    poses: V,\n    clipStyles: K,\n    clipStyle: Z,\n    distX: 0,\n    distY: 0\n  }, fillCSSObject({\n    clipPath: Z\n  }, t))));\n}\nfunction removeClipPath(o, t) {\n  var e = t.datas, r = e.clipPath, D = e.clipIndex, N = r, k = N.type, $ = N.poses, G = N.splitter, U = $.map(function(Y) {\n    return Y.pos;\n  }), z = U.length;\n  if (k === \"polygon\")\n    $.splice(D, 1), U.splice(D, 1);\n  else if (k === \"inset\") {\n    if (D < 8 || (removeRadiusPos($, U, D, 8, z), z === $.length))\n      return;\n  } else\n    return;\n  var X = getClipStyles(o, r, U), V = \"\".concat(k, \"(\").concat(X.join(G), \")\");\n  triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n    clipEventType: \"removed\",\n    clipType: k,\n    poses: U,\n    clipStyles: X,\n    clipStyle: V,\n    distX: 0,\n    distY: 0\n  }, fillCSSObject({\n    clipPath: V\n  }, t))));\n}\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    keepRatio: Boolean,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [`.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`, `:host {\n    --bounds-color: #d66;\n}`, `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`, `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`],\n  render: function(o, t) {\n    var e = o.props, r = e.customClipPath, D = e.defaultClipPath, N = e.clipArea, k = e.zoom, $ = e.groupable, G = o.getState(), U = G.target, z = G.width, X = G.height, V = G.allMatrix, Y = G.is3d, q = G.left, W = G.top, K = G.pos1, Z = G.pos2, J = G.pos3, Q = G.pos4, et = G.clipPathState, nt = G.snapBoundInfos, tt = G.rotation;\n    if (!U || $)\n      return [];\n    var it = getClipPath(U, z, X, D || \"inset\", et || r);\n    if (!it)\n      return [];\n    var st = Y ? 4 : 3, at = it.type, ut = it.poses, ft = ut.map(function(Bt) {\n      var jt = calculatePosition(V, Bt.pos, st);\n      return [jt[0] - q, jt[1] - W];\n    }), ct = [], vt = [], yt = at === \"rect\", mt = at === \"inset\", _t = at === \"polygon\";\n    if (yt || mt || _t) {\n      var Tt = mt ? ft.slice(0, 8) : ft;\n      vt = Tt.map(function(Bt, jt) {\n        var Ct = jt === 0 ? Tt[Tt.length - 1] : Tt[jt - 1], qt = getRad$1(Ct, Bt), Qt = getDiagonalSize(Ct, Bt);\n        return t.createElement(\"div\", {\n          key: \"clipLine\".concat(jt),\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": jt,\n          style: {\n            width: \"\".concat(Qt, \"px\"),\n            transform: \"translate(\".concat(Ct[0], \"px, \").concat(Ct[1], \"px) rotate(\").concat(qt, \"rad) scaleY(\").concat(k, \")\")\n          }\n        });\n      });\n    }\n    if (ct = ft.map(function(Bt, jt) {\n      return t.createElement(\"div\", {\n        key: \"clipControl\".concat(jt),\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": jt,\n        style: {\n          transform: \"translate(\".concat(Bt[0], \"px, \").concat(Bt[1], \"px) rotate(\").concat(tt, \"rad) scale(\").concat(k, \")\")\n        }\n      });\n    }), mt && ct.push.apply(ct, ft.slice(8).map(function(Bt, jt) {\n      return t.createElement(\"div\", {\n        key: \"clipRadiusControl\".concat(jt),\n        className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n        \"data-clip-index\": 8 + jt,\n        style: {\n          transform: \"translate(\".concat(Bt[0], \"px, \").concat(Bt[1], \"px) rotate(\").concat(tt, \"rad) scale(\").concat(k, \")\")\n        }\n      });\n    })), at === \"circle\" || at === \"ellipse\") {\n      var Pt = it.left, St = it.top, gt = it.radiusX, bt = it.radiusY, Nt = minus(calculatePosition(V, [Pt, St], st), calculatePosition(V, [0, 0], st)), At = Nt[0], It = Nt[1], Mt = \"none\";\n      if (!N) {\n        for (var dt = Math.max(10, gt / 5, bt / 5), $t = [], Dt = 0; Dt <= dt; ++Dt) {\n          var Vt = Math.PI * 2 / dt * Dt;\n          $t.push([gt + (gt - k) * Math.cos(Vt), bt + (bt - k) * Math.sin(Vt)]);\n        }\n        $t.push([gt, -2]), $t.push([-2, -2]), $t.push([-2, bt * 2 + 2]), $t.push([gt * 2 + 2, bt * 2 + 2]), $t.push([gt * 2 + 2, -2]), $t.push([gt, -2]), Mt = \"polygon(\".concat($t.map(function(Bt) {\n          return \"\".concat(Bt[0], \"px \").concat(Bt[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      ct.push(t.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(gt * 2, \"px\"),\n          height: \"\".concat(bt * 2, \"px\"),\n          clipPath: Mt,\n          transform: \"translate(\".concat(-q + At, \"px, \").concat(-W + It, \"px) \").concat(makeMatrixCSS(V))\n        }\n      }));\n    }\n    if (N) {\n      var Lt = getRect(__spreadArray([K, Z, J, Q], ft, !0)), Et = Lt.width, Ht = Lt.height, kt = Lt.left, wt = Lt.top;\n      if (_t || yt || mt) {\n        var $t = mt ? ft.slice(0, 8) : ft;\n        ct.push(t.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(Et, \"px\"),\n            height: \"\".concat(Ht, \"px\"),\n            transform: \"translate(\".concat(kt, \"px, \").concat(wt, \"px)\"),\n            clipPath: \"polygon(\".concat($t.map(function(jt) {\n              return \"\".concat(jt[0] - kt, \"px \").concat(jt[1] - wt, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    return nt && [\"vertical\", \"horizontal\"].forEach(function(Bt) {\n      var jt = nt[Bt], Ct = Bt === \"horizontal\";\n      jt.isSnap && vt.push.apply(vt, jt.snap.posInfos.map(function(qt, Qt) {\n        var Kt = qt.pos, Se = minus(calculatePosition(V, Ct ? [0, Kt] : [Kt, 0], st), [q, W]), Oe = minus(calculatePosition(V, Ct ? [z, Kt] : [Kt, X], st), [q, W]);\n        return renderLine(t, \"\", Se, Oe, k, \"clip\".concat(Bt, \"snap\").concat(Qt), \"guideline\");\n      })), jt.isBound && vt.push.apply(vt, jt.bounds.map(function(qt, Qt) {\n        var Kt = qt.pos, Se = minus(calculatePosition(V, Ct ? [0, Kt] : [Kt, 0], st), [q, W]), Oe = minus(calculatePosition(V, Ct ? [z, Kt] : [Kt, X], st), [q, W]);\n        return renderLine(t, \"\", Se, Oe, k, \"clip\".concat(Bt, \"bounds\").concat(Qt), \"guideline\", \"bounds\", \"bold\");\n      }));\n    }), __spreadArray(__spreadArray([], ct, !0), vt, !0);\n  },\n  dragControlCondition: function(o, t) {\n    return t.inputEvent && (t.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(o, t) {\n    var e = o.props, r = e.dragWithClip, D = r === void 0 ? !0 : r;\n    return D ? !1 : this.dragControlStart(o, t);\n  },\n  drag: function(o, t) {\n    return this.dragControl(o, __assign$1(__assign$1({}, t), {\n      isDragTarget: !0\n    }));\n  },\n  dragEnd: function(o, t) {\n    return this.dragControlEnd(o, t);\n  },\n  dragControlStart: function(o, t) {\n    var e = o.state, r = o.props, D = r.defaultClipPath, N = r.customClipPath, k = e.target, $ = e.width, G = e.height, U = t.inputEvent ? t.inputEvent.target : null, z = U && U.getAttribute(\"class\") || \"\", X = t.datas, V = getClipPath(k, $, G, D || \"inset\", N);\n    if (!V)\n      return !1;\n    var Y = V.clipText, q = V.type, W = V.poses, K = triggerEvent(o, \"onClipStart\", fillParams(o, t, {\n      clipType: q,\n      clipStyle: Y,\n      poses: W.map(function(Z) {\n        return Z.pos;\n      })\n    }));\n    return K === !1 ? (X.isClipStart = !1, !1) : (X.isControl = z && z.indexOf(\"clip-control\") > -1, X.isLine = z.indexOf(\"clip-line\") > -1, X.isArea = z.indexOf(\"clip-area\") > -1 || z.indexOf(\"clip-ellipse\") > -1, X.clipIndex = U ? parseInt(U.getAttribute(\"data-clip-index\"), 10) : -1, X.clipPath = V, X.isClipStart = !0, e.clipPathState = Y, setDragStart(o, t), !0);\n  },\n  dragControl: function(o, t) {\n    var e, r, D = t.datas, N = t.originalDatas, k = t.isDragTarget;\n    if (!D.isClipStart)\n      return !1;\n    var $ = D, G = $.isControl, U = $.isLine, z = $.isArea, X = $.clipIndex, V = $.clipPath;\n    if (!V)\n      return !1;\n    var Y = getProps(o.props, \"clippable\"), q = Y.keepRatio, W = 0, K = 0, Z = N.draggable, J = getDragDist(t);\n    k && Z ? (e = Z.prevBeforeDist, W = e[0], K = e[1]) : (W = J[0], K = J[1]);\n    var Q = [W, K], et = o.state, nt = et.width, tt = et.height, it = !z && !G && !U, st = V.type, at = V.poses, ut = V.splitter, ft = at.map(function(pt) {\n      return pt.pos;\n    });\n    it && (W = -W, K = -K);\n    var ct = !G || at[X].direction === \"nesw\", vt = st === \"inset\" || st === \"rect\", yt = at.map(function() {\n      return [0, 0];\n    });\n    if (G && !ct) {\n      var mt = at[X], _t = mt.horizontal, Tt = mt.vertical, Pt = [W * Math.abs(_t), K * Math.abs(Tt)];\n      yt = moveControlPos(at, X, Pt, vt, q);\n    } else\n      ct && (yt = ft.map(function() {\n        return [W, K];\n      }));\n    var St = ft.map(function(pt, xt) {\n      return plus(pt, yt[xt]);\n    }), gt = __spreadArray([], St, !0);\n    et.snapBoundInfos = null;\n    var bt = V.type === \"circle\", Nt = V.type === \"ellipse\";\n    if (bt || Nt) {\n      var At = getRect(St), It = Math.abs(At.bottom - At.top), Mt = Math.abs(Nt ? At.right - At.left : It), dt = St[0][1] + It, $t = St[0][0] - Mt, Dt = St[0][0] + Mt;\n      bt && (gt.push([Dt, At.bottom]), yt.push([1, 0])), gt.push([At.left, dt]), yt.push([0, 1]), gt.push([$t, At.bottom]), yt.push([1, 0]);\n    }\n    var Vt = getDefaultGuidelines((Y.clipHorizontalGuidelines || []).map(function(pt) {\n      return convertUnitSize(\"\".concat(pt), tt);\n    }), (Y.clipVerticalGuidelines || []).map(function(pt) {\n      return convertUnitSize(\"\".concat(pt), nt);\n    }), nt, tt), Lt = [], Et = [];\n    if (bt || Nt)\n      Lt = [gt[4][0], gt[2][0]], Et = [gt[1][1], gt[3][1]];\n    else if (vt) {\n      var Ht = [gt[0], gt[2], gt[4], gt[6]], kt = [yt[0], yt[2], yt[4], yt[6]];\n      Lt = Ht.filter(function(pt, xt) {\n        return kt[xt][0];\n      }).map(function(pt) {\n        return pt[0];\n      }), Et = Ht.filter(function(pt, xt) {\n        return kt[xt][1];\n      }).map(function(pt) {\n        return pt[1];\n      });\n    } else\n      Lt = gt.filter(function(pt, xt) {\n        return yt[xt][0];\n      }).map(function(pt) {\n        return pt[0];\n      }), Et = gt.filter(function(pt, xt) {\n        return yt[xt][1];\n      }).map(function(pt) {\n        return pt[1];\n      });\n    var wt = [0, 0], Bt = checkSnapBounds(Vt, Y.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: nt,\n      bottom: tt\n    }, Lt, Et, 5), jt = Bt.horizontal, Ct = Bt.vertical, qt = jt.offset, Qt = Ct.offset;\n    if (jt.isBound && (wt[1] += qt), Ct.isBound && (wt[0] += Qt), (Nt || bt) && yt[0][0] === 0 && yt[0][1] === 0) {\n      var At = getRect(St), Kt = At.bottom - At.top, Se = Nt ? At.right - At.left : Kt, Oe = Ct.isBound ? Math.abs(Qt) : Ct.snapIndex === 0 ? -Qt : Qt, ue = jt.isBound ? Math.abs(qt) : jt.snapIndex === 0 ? -qt : qt;\n      Se -= Oe, Kt -= ue, bt && (Kt = checkSnapBoundPriority(Ct, jt) > 0 ? Kt : Se, Se = Kt);\n      var _e = gt[0];\n      gt[1][1] = _e[1] - Kt, gt[2][0] = _e[0] + Se, gt[3][1] = _e[1] + Kt, gt[4][0] = _e[0] - Se;\n    } else if (vt && q && G) {\n      var ve = getControlSize(at), de = ve[0], fe = ve[1], ne = de && fe ? de / fe : 0, Ve = at[X], vs = Ve.direction || \"\", Ua = gt[1][1], dt = gt[5][1], $t = gt[7][0], Dt = gt[3][0];\n      qt <= Qt ? qt = Qt / ne : Qt = qt * ne, vs.indexOf(\"w\") > -1 ? $t -= Qt : vs.indexOf(\"e\") > -1 ? Dt -= Qt : ($t += Qt / 2, Dt -= Qt / 2), vs.indexOf(\"n\") > -1 ? Ua -= qt : vs.indexOf(\"s\") > -1 ? dt -= qt : (Ua += qt / 2, dt -= qt / 2);\n      var zc = getRectPoses(Ua, Dt, dt, $t);\n      gt.forEach(function(Ft, Gt) {\n        var Ut;\n        Ut = zc[Gt].pos, Ft[0] = Ut[0], Ft[1] = Ut[1];\n      });\n    } else\n      gt.forEach(function(pt, xt) {\n        var Rt = yt[xt];\n        Rt[0] && (pt[0] -= Qt), Rt[1] && (pt[1] -= qt);\n      });\n    var ja = getClipStyles(o, V, St), gs = \"\".concat(st, \"(\").concat(ja.join(ut), \")\");\n    if (et.clipPathState = gs, bt || Nt)\n      Lt = [gt[4][0], gt[2][0]], Et = [gt[1][1], gt[3][1]];\n    else if (vt) {\n      var Ht = [gt[0], gt[2], gt[4], gt[6]];\n      Lt = Ht.map(function(xt) {\n        return xt[0];\n      }), Et = Ht.map(function(xt) {\n        return xt[1];\n      });\n    } else\n      Lt = gt.map(function(pt) {\n        return pt[0];\n      }), Et = gt.map(function(pt) {\n        return pt[1];\n      });\n    if (et.snapBoundInfos = checkSnapBounds(Vt, Y.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: nt,\n      bottom: tt\n    }, Lt, Et, 1), Z) {\n      var eu = et.is3d, ru = et.allMatrix, Hc = eu ? 4 : 3, ht = wt;\n      k && (ht = [Q[0] + wt[0] - J[0], Q[1] + wt[1] - J[1]]), Z.deltaOffset = multiply(ru, [ht[0], ht[1], 0, 0], Hc);\n    }\n    return triggerEvent(o, \"onClip\", fillParams(o, t, __assign$1({\n      clipEventType: \"changed\",\n      clipType: st,\n      poses: St,\n      clipStyle: gs,\n      clipStyles: ja,\n      distX: W,\n      distY: K\n    }, fillCSSObject((r = {}, r[st === \"rect\" ? \"clip\" : \"clipPath\"] = gs, r), t)))), !0;\n  },\n  dragControlEnd: function(o, t) {\n    this.unset(o);\n    var e = t.isDrag, r = t.datas, D = t.isDouble, N = r.isLine, k = r.isClipStart, $ = r.isControl;\n    return k ? (triggerEvent(o, \"onClipEnd\", fillEndParams(o, t, {})), D && ($ ? removeClipPath(o, t) : N && addClipPath(o, t)), D || e) : !1;\n  },\n  unset: function(o) {\n    o.state.clipPathState = \"\", o.state.snapBoundInfos = null;\n  }\n}, OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [`:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`],\n  dragControlCondition: function(o, t) {\n    return t.isRequest ? t.requestAble === \"originDraggable\" : hasClass(t.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function(o, t) {\n    var e = t.datas;\n    setDragStart(o, t);\n    var r = fillParams(o, t, {\n      dragStart: Draggable.dragStart(o, new CustomGesto().dragStart([0, 0], t))\n    }), D = triggerEvent(o, \"onDragOriginStart\", r);\n    return e.startOrigin = o.state.transformOrigin, e.startTargetOrigin = o.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, D === !1 ? (e.isDragOrigin = !1, !1) : r;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = t.isPinch, D = t.isRequest;\n    if (!e.isDragOrigin)\n      return !1;\n    var N = getDragDist(t), k = N[0], $ = N[1], G = o.state, U = G.width, z = G.height, X = G.offsetMatrix, V = G.targetMatrix, Y = G.is3d, q = o.props.originRelative, W = q === void 0 ? !0 : q, K = Y ? 4 : 3, Z = [k, $];\n    if (D) {\n      var J = t.distOrigin;\n      (J[0] || J[1]) && (Z = J);\n    }\n    var Q = plus(e.startOrigin, Z), et = plus(e.startTargetOrigin, Z), nt = minus(Z, e.prevOrigin), tt = getNextMatrix(X, V, Q, K), it = o.getRect(), st = getRect(calculatePoses(tt, U, z, K)), at = [it.left - st.left, it.top - st.top];\n    e.prevOrigin = Z;\n    var ut = [convertCSSSize(et[0], U, W), convertCSSSize(et[1], z, W)].join(\" \"), ft = Draggable.drag(o, setCustomDrag(t, o.state, at, !!r, !1)), ct = fillParams(o, t, __assign$1(__assign$1({\n      width: U,\n      height: z,\n      origin: Q,\n      dist: Z,\n      delta: nt,\n      transformOrigin: ut,\n      drag: ft\n    }, fillCSSObject({\n      transformOrigin: ut,\n      transform: ft.transform\n    }, t)), {\n      afterTransform: ft.transform\n    }));\n    return triggerEvent(o, \"onDragOrigin\", ct), ct;\n  },\n  dragControlEnd: function(o, t) {\n    var e = t.datas;\n    return e.isDragOrigin ? (triggerEvent(o, \"onDragOriginEnd\", fillEndParams(o, t, {})), !0) : !1;\n  },\n  dragGroupControlCondition: function(o, t) {\n    return this.dragControlCondition(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    var e = this.dragControlStart(o, t);\n    return !!e;\n  },\n  dragGroupControl: function(o, t) {\n    var e = this.dragControl(o, t);\n    return e ? (o.transformOrigin = e.transformOrigin, !0) : !1;\n  },\n  /**\n  * @method Moveable.OriginDraggable#request\n  * @param {object} e - the OriginDraggable's request parameter\n  * @param {number} [e.x] - x position\n  * @param {number} [e.y] - y position\n  * @param {number} [e.deltaX] - x number to move\n  * @param {number} [e.deltaY] - y number to move\n  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n  * @param {array} [e.origin] - transform-origin position\n  * @param {number} [e.isInstant] - Whether to execute the request instantly\n  * @return {Moveable.Requester} Moveable Requester\n  * @example\n   * // Instantly Request (requestStart - request - requestEnd)\n  * // Use Relative Value\n  * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n  * // Use Transform Value\n  * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n  * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n  * // requestStart\n  * const requester = moveable.request(\"originDraggable\");\n  *\n  * // request\n  * // Use Relative Value\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n  *\n  * // requestEnd\n  * requester.requestEnd();\n  */\n  request: function(o) {\n    var t = {}, e = o.getRect(), r = 0, D = 0, N = e.transformOrigin, k = [0, 0];\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function($) {\n        return \"deltaOrigin\" in $ ? (k[0] += $.deltaOrigin[0], k[1] += $.deltaOrigin[1]) : \"origin\" in $ ? (k[0] = $.origin[0] - N[0], k[1] = $.origin[1] - N[1]) : (\"x\" in $ ? r = $.x - e.left : \"deltaX\" in $ && (r += $.deltaX), \"y\" in $ ? D = $.y - e.top : \"deltaY\" in $ && (D += $.deltaY)), {\n          datas: t,\n          distX: r,\n          distY: D,\n          distOrigin: k\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction addBorderRadiusByLine(o, t, e, r) {\n  var D = o.filter(function(G) {\n    var U = G.virtual, z = G.horizontal;\n    return z && !U;\n  }).length, N = o.filter(function(G) {\n    var U = G.virtual, z = G.vertical;\n    return z && !U;\n  }).length, k = -1;\n  if (t === 0 && (D === 0 ? k = 0 : D === 1 && (k = 1)), t === 2 && (D <= 2 ? k = 2 : D <= 3 && (k = 3)), t === 3 && (N === 0 ? k = 4 : N < 4 && (k = 7)), t === 1 && (N <= 1 ? k = 5 : N <= 2 && (k = 6)), !(k === -1 || !o[k].virtual)) {\n    var $ = o[k];\n    addBorderRadius(o, k), k < 4 ? $.pos[0] = e : $.pos[1] = r;\n  }\n}\nfunction addBorderRadius(o, t) {\n  t < 4 ? o.slice(0, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }) : (o[0].virtual && (o[0].virtual = !1), o.slice(4, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }));\n}\nfunction removeBorderRadius(o, t) {\n  t < 4 ? o.slice(t, 4).forEach(function(e) {\n    e.virtual = !0;\n  }) : o.slice(t).forEach(function(e) {\n    e.virtual = !0;\n  });\n}\nfunction getBorderRadius(o, t, e, r, D) {\n  r === void 0 && (r = [0, 0]);\n  var N = [];\n  return !o || o === \"0px\" ? N = [] : N = splitSpace(o), getRadiusValues(N, t, e, 0, 0, r, D);\n}\nfunction triggerRoundEvent(o, t, e, r, D) {\n  var N = o.state, k = N.width, $ = N.height, G = getRadiusStyles(D, o.props.roundRelative, k, $), U = G.raws, z = G.styles, X = G.radiusPoses, V = splitRadiusPoses(X, U), Y = V.horizontals, q = V.verticals, W = z.join(\" \");\n  N.borderRadiusState = W;\n  var K = fillParams(o, t, __assign$1({\n    horizontals: Y,\n    verticals: q,\n    borderRadius: W,\n    width: k,\n    height: $,\n    delta: r,\n    dist: e\n  }, fillCSSObject({\n    borderRadius: W\n  }, t)));\n  return triggerEvent(o, \"onRound\", K), K;\n}\nfunction getStyleBorderRadius(o) {\n  var t, e, r = o.getState().style, D = r.borderRadius || \"\";\n  if (!D && o.props.groupable) {\n    var N = o.moveables[0], k = o.getTargets()[0];\n    k && ((N == null ? void 0 : N.props.target) === k ? (D = (e = (t = o.moveables[0]) === null || t === void 0 ? void 0 : t.state.style.borderRadius) !== null && e !== void 0 ? e : \"\", r.borderRadius = D) : (D = getComputedStyle(k).borderRadius, r.borderRadius = D));\n  }\n  return D;\n}\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean,\n    roundPadding: Number,\n    isDisplayShadowRoundControls: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\",\n    onRoundGroupStart: \"roundGroupStart\",\n    onRoundGroup: \"roundGroup\",\n    onRoundGroupEnd: \"roundGroupEnd\"\n  },\n  css: [`.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n    z-index: 3;\n}`, `.control.border-radius.vertical {\n    background: #d6d;\n    z-index: 2;\n}`, `.control.border-radius.virtual {\n    opacity: 0.5;\n    z-index: 1;\n}`, `:host.round-line-clickable .line.direction {\n    cursor: pointer;\n}`],\n  className: function(o) {\n    var t = o.props.roundClickable;\n    return t === !0 || t === \"line\" ? prefix(\"round-line-clickable\") : \"\";\n  },\n  requestStyle: function() {\n    return [\"borderRadius\"];\n  },\n  requestChildStyle: function() {\n    return [\"borderRadius\"];\n  },\n  render: function(o, t) {\n    var e = o.getState(), r = e.target, D = e.width, N = e.height, k = e.allMatrix, $ = e.is3d, G = e.left, U = e.top, z = e.borderRadiusState, X = o.props, V = X.minRoundControls, Y = V === void 0 ? [0, 0] : V, q = X.maxRoundControls, W = q === void 0 ? [4, 4] : q, K = X.zoom, Z = X.roundPadding, J = Z === void 0 ? 0 : Z, Q = X.isDisplayShadowRoundControls, et = X.groupable;\n    if (!r)\n      return null;\n    var nt = z || getStyleBorderRadius(o), tt = $ ? 4 : 3, it = getBorderRadius(nt, D, N, Y, !0);\n    if (!it)\n      return null;\n    var st = 0, at = 0, ut = et ? [0, 0] : [G, U];\n    return it.map(function(ft, ct) {\n      var vt = ft.horizontal, yt = ft.vertical, mt = ft.direction || \"\", _t = __spreadArray([], ft.pos, !0);\n      at += Math.abs(vt), st += Math.abs(yt), vt && mt.indexOf(\"n\") > -1 && (_t[1] -= J), yt && mt.indexOf(\"w\") > -1 && (_t[0] -= J), vt && mt.indexOf(\"s\") > -1 && (_t[1] += J), yt && mt.indexOf(\"e\") > -1 && (_t[0] += J);\n      var Tt = minus(calculatePosition(k, _t, tt), ut), Pt = ft.vertical ? st <= W[1] && (Q || !ft.virtual) : at <= W[0] && (Q || !ft.virtual);\n      return t.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(ct),\n        className: prefix(\"control\", \"border-radius\", ft.vertical ? \"vertical\" : \"\", ft.virtual ? \"virtual\" : \"\"),\n        \"data-radius-index\": ct,\n        style: {\n          display: Pt ? \"block\" : \"none\",\n          transform: \"translate(\".concat(Tt[0], \"px, \").concat(Tt[1], \"px) scale(\").concat(K, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(o, t) {\n    if (!t.inputEvent || t.isRequest)\n      return !1;\n    var e = t.inputEvent.target.getAttribute(\"class\") || \"\";\n    return e.indexOf(\"border-radius\") > -1 || e.indexOf(\"moveable-line\") > -1 && e.indexOf(\"moveable-direction\") > -1;\n  },\n  dragGroupControlCondition: function(o, t) {\n    return this.dragControlCondition(o, t);\n  },\n  dragControlStart: function(o, t) {\n    var e = t.inputEvent, r = t.datas, D = e.target, N = D.getAttribute(\"class\") || \"\", k = N.indexOf(\"border-radius\") > -1, $ = N.indexOf(\"moveable-line\") > -1 && N.indexOf(\"moveable-direction\") > -1, G = k ? parseInt(D.getAttribute(\"data-radius-index\"), 10) : -1, U = -1;\n    if ($) {\n      var z = D.getAttribute(\"data-line-key\") || \"\";\n      z && (U = parseInt(z.replace(/render-line-/g, \"\"), 10), isNaN(U) && (U = -1));\n    }\n    if (!k && !$)\n      return !1;\n    var X = fillParams(o, t, {}), V = triggerEvent(o, \"onRoundStart\", X);\n    if (V === !1)\n      return !1;\n    r.lineIndex = U, r.controlIndex = G, r.isControl = k, r.isLine = $, setDragStart(o, t);\n    var Y = o.props, q = Y.roundRelative, W = Y.minRoundControls, K = W === void 0 ? [0, 0] : W, Z = o.state, J = Z.width, Q = Z.height;\n    r.isRound = !0, r.prevDist = [0, 0];\n    var et = getStyleBorderRadius(o), nt = getBorderRadius(et || \"\", J, Q, K, !0) || [];\n    return r.controlPoses = nt, Z.borderRadiusState = getRadiusStyles(nt, q, J, Q).styles.join(\" \"), X;\n  },\n  dragControl: function(o, t) {\n    var e = t.datas, r = e.controlPoses;\n    if (!e.isRound || !e.isControl || !r.length)\n      return !1;\n    var D = e.controlIndex, N = getDragDist(t), k = N[0], $ = N[1], G = [k, $], U = minus(G, e.prevDist), z = o.props.maxRoundControls, X = z === void 0 ? [4, 4] : z, V = o.state, Y = V.width, q = V.height, W = r[D], K = W.vertical, Z = W.horizontal, J = r.map(function(et) {\n      var nt = et.horizontal, tt = et.vertical, it = [nt * Z * G[0], tt * K * G[1]];\n      if (nt) {\n        if (X[0] === 1)\n          return it;\n        if (X[0] < 4 && nt !== Z)\n          return it;\n      } else {\n        if (X[1] === 0)\n          return it[1] = tt * Z * G[0] / Y * q, it;\n        if (K) {\n          if (X[1] === 1)\n            return it;\n          if (X[1] < 4 && tt !== K)\n            return it;\n        }\n      }\n      return [0, 0];\n    });\n    J[D] = G;\n    var Q = r.map(function(et, nt) {\n      return __assign$1(__assign$1({}, et), {\n        pos: plus(et.pos, J[nt])\n      });\n    });\n    return D < 4 ? Q.slice(0, D + 1).forEach(function(et) {\n      et.virtual = !1;\n    }) : Q.slice(4, D + 1).forEach(function(et) {\n      et.virtual = !1;\n    }), e.prevDist = [k, $], triggerRoundEvent(o, t, G, U, Q);\n  },\n  dragControlEnd: function(o, t) {\n    var e = o.state;\n    e.borderRadiusState = \"\";\n    var r = t.datas, D = t.isDouble;\n    if (!r.isRound)\n      return !1;\n    var N = r.isControl, k = r.controlIndex, $ = r.isLine, G = r.lineIndex, U = r.controlPoses, z = U.filter(function(Z) {\n      var J = Z.virtual;\n      return J;\n    }).length, X = o.props.roundClickable, V = X === void 0 ? !0 : X;\n    if (D && V) {\n      if (N && (V === !0 || V === \"control\"))\n        removeBorderRadius(U, k);\n      else if ($ && (V === !0 || V === \"line\")) {\n        var Y = calculatePointerDist(o, t), q = Y[0], W = Y[1];\n        addBorderRadiusByLine(U, G, q, W);\n      }\n      z !== U.filter(function(Z) {\n        var J = Z.virtual;\n        return J;\n      }).length && triggerRoundEvent(o, t, [0, 0], [0, 0], U);\n    }\n    var K = fillEndParams(o, t, {});\n    return triggerEvent(o, \"onRoundEnd\", K), e.borderRadiusState = \"\", K;\n  },\n  dragGroupControlStart: function(o, t) {\n    var e = this.dragControlStart(o, t);\n    if (!e)\n      return !1;\n    var r = o.moveables, D = o.props.targets, N = fillChildEvents(o, \"roundable\", t), k = __assign$1({\n      targets: o.props.targets,\n      events: N.map(function($, G) {\n        return __assign$1(__assign$1({}, $), {\n          target: D[G],\n          moveable: r[G],\n          currentTarget: r[G]\n        });\n      })\n    }, e);\n    return triggerEvent(o, \"onRoundGroupStart\", k), e;\n  },\n  dragGroupControl: function(o, t) {\n    var e = this.dragControl(o, t);\n    if (!e)\n      return !1;\n    var r = o.moveables, D = o.props.targets, N = fillChildEvents(o, \"roundable\", t), k = __assign$1({\n      targets: o.props.targets,\n      events: N.map(function($, G) {\n        return __assign$1(__assign$1(__assign$1({}, $), {\n          target: D[G],\n          moveable: r[G],\n          currentTarget: r[G]\n        }), fillCSSObject({\n          borderRadius: e.borderRadius\n        }, $));\n      })\n    }, e);\n    return triggerEvent(o, \"onRoundGroup\", k), k;\n  },\n  dragGroupControlEnd: function(o, t) {\n    var e = o.moveables, r = o.props.targets, D = fillChildEvents(o, \"roundable\", t);\n    catchEvent(o, \"onRound\", function($) {\n      var G = __assign$1({\n        targets: o.props.targets,\n        events: D.map(function(U, z) {\n          return __assign$1(__assign$1(__assign$1({}, U), {\n            target: r[z],\n            moveable: e[z],\n            currentTarget: e[z]\n          }), fillCSSObject({\n            borderRadius: $.borderRadius\n          }, U));\n        })\n      }, $);\n      triggerEvent(o, \"onRoundGroup\", G);\n    });\n    var N = this.dragControlEnd(o, t);\n    if (!N)\n      return !1;\n    var k = __assign$1({\n      targets: o.props.targets,\n      events: D.map(function($, G) {\n        var U;\n        return __assign$1(__assign$1({}, $), {\n          target: r[G],\n          moveable: e[G],\n          currentTarget: e[G],\n          lastEvent: (U = $.datas) === null || U === void 0 ? void 0 : U.lastEvent\n        });\n      })\n    }, N);\n    return triggerEvent(o, \"onRoundGroupEnd\", k), k;\n  },\n  unset: function(o) {\n    o.state.borderRadiusState = \"\";\n  }\n};\nfunction isIdentityMatrix(o, t) {\n  var e = t ? 4 : 3, r = createIdentityMatrix(e), D = \"matrix\".concat(t ? \"3d\" : \"\", \"(\").concat(r.join(\",\"), \")\");\n  return o === D || o === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  setTransform: function(o, t) {\n    var e = o.state, r = e.is3d, D = e.target, N = e.targetMatrix, k = D == null ? void 0 : D.style.transform, $ = r ? \"matrix3d(\".concat(N.join(\",\"), \")\") : \"matrix(\".concat(convertMatrixtoCSS(N, !0), \")\"), G = !k || k === \"none\" ? $ : k;\n    t.datas.startTransforms = isIdentityMatrix(G, r) ? [] : splitSpace(G);\n  },\n  resetStyle: function(o) {\n    var t = o.datas;\n    t.nextStyle = {}, t.nextTransforms = o.datas.startTransforms, t.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(o, t) {\n    return fillParams(o, t, {\n      setTransform: function(e) {\n        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);\n      },\n      isPinch: !!t.isPinch\n    });\n  },\n  fillDragParams: function(o, t) {\n    return fillParams(o, t, {\n      isPinch: !!t.isPinch\n    });\n  },\n  dragStart: function(o, t) {\n    this.setTransform(o, t), this.resetStyle(t), triggerEvent(o, \"onBeforeRenderStart\", this.fillDragStartParams(o, t));\n  },\n  drag: function(o, t) {\n    this.resetStyle(t), triggerEvent(o, \"onBeforeRender\", fillParams(o, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  dragEnd: function(o, t) {\n    triggerEvent(o, \"onBeforeRenderEnd\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    }));\n  },\n  dragGroupStart: function(o, t) {\n    var e = this;\n    this.dragStart(o, t);\n    var r = fillChildEvents(o, \"beforeRenderable\", t), D = o.moveables, N = r.map(function(k, $) {\n      var G = D[$];\n      return e.setTransform(G, k), e.resetStyle(k), e.fillDragStartParams(G, k);\n    });\n    triggerEvent(o, \"onBeforeRenderGroupStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      setTransform: function() {\n      },\n      events: N\n    }));\n  },\n  dragGroup: function(o, t) {\n    var e = this;\n    this.drag(o, t);\n    var r = fillChildEvents(o, \"beforeRenderable\", t), D = o.moveables, N = r.map(function(k, $) {\n      var G = D[$];\n      return e.resetStyle(k), e.fillDragParams(G, k);\n    });\n    triggerEvent(o, \"onBeforeRenderGroup\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      events: N\n    }));\n  },\n  dragGroupEnd: function(o, t) {\n    this.dragEnd(o, t), triggerEvent(o, \"onBeforeRenderGroupEnd\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: o.props.targets\n    }));\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragGroupStart(o, t);\n  },\n  dragGroupControl: function(o, t) {\n    return this.dragGroup(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    return this.dragGroupEnd(o, t);\n  }\n}, Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  dragStart: function(o, t) {\n    triggerEvent(o, \"onRenderStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  drag: function(o, t) {\n    triggerEvent(o, \"onRender\", this.fillDragParams(o, t));\n  },\n  dragAfter: function(o, t) {\n    if (t.resultCount)\n      return this.drag(o, t);\n  },\n  dragEnd: function(o, t) {\n    triggerEvent(o, \"onRenderEnd\", this.fillDragEndParams(o, t));\n  },\n  dragGroupStart: function(o, t) {\n    triggerEvent(o, \"onRenderGroupStart\", fillParams(o, t, {\n      isPinch: !!t.isPinch,\n      targets: o.props.targets\n    }));\n  },\n  dragGroup: function(o, t) {\n    var e = this, r = fillChildEvents(o, \"beforeRenderable\", t), D = o.moveables, N = r.map(function(k, $) {\n      var G = D[$];\n      return e.fillDragParams(G, k);\n    });\n    triggerEvent(o, \"onRenderGroup\", fillParams(o, t, __assign$1(__assign$1({\n      isPinch: !!t.isPinch,\n      targets: o.props.targets,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))), {\n      events: N\n    })));\n  },\n  dragGroupEnd: function(o, t) {\n    var e = this, r = fillChildEvents(o, \"beforeRenderable\", t), D = o.moveables, N = r.map(function(k, $) {\n      var G = D[$];\n      return e.fillDragEndParams(G, k);\n    });\n    triggerEvent(o, \"onRenderGroupEnd\", fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: o.props.targets,\n      events: N,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t)))));\n  },\n  dragControlStart: function(o, t) {\n    return this.dragStart(o, t);\n  },\n  dragControl: function(o, t) {\n    return this.drag(o, t);\n  },\n  dragControlAfter: function(o, t) {\n    return this.dragAfter(o, t);\n  },\n  dragControlEnd: function(o, t) {\n    return this.dragEnd(o, t);\n  },\n  dragGroupControlStart: function(o, t) {\n    return this.dragGroupStart(o, t);\n  },\n  dragGroupControl: function(o, t) {\n    return this.dragGroup(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    return this.dragGroupEnd(o, t);\n  },\n  fillDragParams: function(o, t) {\n    return fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))));\n  },\n  fillDragEndParams: function(o, t) {\n    return fillParams(o, t, __assign$1({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))));\n  }\n};\nfunction triggerAble(o, t, e, r, D, N, k) {\n  var $ = D === \"Start\", G = o.state.target, U = N.isRequest;\n  if (!G || $ && r.indexOf(\"Control\") > -1 && !U && o.areaElement === N.inputEvent.target)\n    return !1;\n  var z = \"\".concat(e).concat(r).concat(D), X = \"\".concat(e).concat(r, \"Condition\"), V = D === \"End\", Y = D === \"After\", q = $ && (!o.targetGesto || !o.controlGesto || !o.targetGesto.isFlag() || !o.controlGesto.isFlag());\n  q && o.updateRect(D, !0, !1), N.clientDistX = N.distX, N.clientDistY = N.distY, D === \"\" && !U && convertDragDist(o.state, N);\n  var W = __spreadArray([], o[t], !0);\n  if (U) {\n    var K = N.requestAble;\n    W.some(function(ct) {\n      return ct.name === K;\n    }) || W.push.apply(W, o.props.ables.filter(function(ct) {\n      return ct.name === K;\n    }));\n  }\n  if (!W.length || W.every(function(ct) {\n    return ct.dragRelation;\n  }))\n    return !1;\n  var Z = __spreadArray(__spreadArray([BeforeRenderable], W, !0), [Renderable], !1).filter(function(ct) {\n    return ct[z];\n  }), J = N.datas;\n  q && Z.forEach(function(ct) {\n    ct.unset && ct.unset(o);\n  });\n  var Q = N.inputEvent, et;\n  V && Q && (et = document.elementFromPoint(N.clientX, N.clientY) || Q.target);\n  var nt = 0, tt = !1, it = function() {\n    var ct;\n    tt = !0, (ct = N.stop) === null || ct === void 0 || ct.call(N);\n  }, st = Z.filter(function(ct) {\n    var vt = ct.name, yt = J[vt] || (J[vt] = {});\n    if ($ && (yt.isEventStart = !ct[X] || ct[X](o, N)), yt.isEventStart) {\n      var mt = ct[z](o, __assign$1(__assign$1({}, N), {\n        stop: it,\n        resultCount: nt,\n        datas: yt,\n        originalDatas: J,\n        inputTarget: et\n      }));\n      return o._emitter.off(), $ && mt === !1 && (yt.isEventStart = !1), nt += mt || yt.isEventStart ? 1 : 0, mt;\n    }\n    return !1;\n  }), at = st.length, ut = !1;\n  if (tt && (ut = !0), !ut && $ && Z.length && !at && (ut = Z.filter(function(ct) {\n    var vt = ct.name, yt = J[vt];\n    return yt.isEventStart ? ct.dragRelation !== \"strong\" : !1;\n  }).length), (V || ut) && (o.state.gestos = {}, o.moveables && o.moveables.forEach(function(ct) {\n    ct.state.gestos = {};\n  }), Z.forEach(function(ct) {\n    ct.unset && ct.unset(o);\n  })), $ && !ut && !U && at && o.props.preventDefault && (N == null || N.preventDefault()), o.isUnmounted || ut)\n    return !1;\n  if (!$ && at && !k || V) {\n    var ft = o.props.flushSync || defaultSync;\n    ft(function() {\n      o.updateRect(V ? D : \"\", !0, !1), o.forceUpdate();\n    });\n  }\n  return !$ && !V && !Y && at && !k && triggerAble(o, t, e, r, D + \"After\", N), !0;\n}\nfunction checkMoveableTarget(o) {\n  return function(t) {\n    var e = o.props.dragTarget, r = t.inputEvent.target, D = o.areaElement;\n    return e && (r === e || e.contains(r)) || r === D || !o.isMoveableElement(r) && !o.controlBox.getElement().contains(r) || hasClass(r, \"moveable-area\") || hasClass(r, \"moveable-padding\") || hasClass(r, \"moveable-edgeDraggable\");\n  };\n}\nfunction getTargetAbleGesto(o, t, e) {\n  var r = o.controlBox.getElement(), D = [], N = o.props.dragTarget;\n  return D.push(r), (!o.props.dragArea || N) && D.push(t), getAbleGesto(o, D, \"targetAbles\", e, {\n    dragStart: checkMoveableTarget(o),\n    pinchStart: checkMoveableTarget(o)\n  });\n}\nfunction getAbleGesto(o, t, e, r, D) {\n  D === void 0 && (D = {});\n  var N = e === \"targetAbles\", k = o.props, $ = k.pinchOutside, G = k.pinchThreshold, U = k.preventClickEventOnDrag, z = k.preventClickDefault, X = k.checkInput, V = k.preventDefault, Y = V === void 0 ? !0 : V, q = {\n    preventDefault: Y,\n    preventRightClick: !0,\n    preventWheelClick: !0,\n    container: window,\n    pinchThreshold: G,\n    pinchOutside: $,\n    preventClickEventOnDrag: N ? U : !1,\n    preventClickEventOnDragStart: N ? z : !1,\n    preventClickEventByCondition: N ? null : function(Z) {\n      return o.controlBox.getElement().contains(Z.target);\n    },\n    checkInput: N ? X : !1\n  }, W = new Gesto(t, q), K = r === \"Control\";\n  return [\"drag\", \"pinch\"].forEach(function(Z) {\n    [\"Start\", \"\", \"End\"].forEach(function(J) {\n      W.on(\"\".concat(Z).concat(J), function(Q) {\n        var et, nt = Q.eventType;\n        if (D[nt] && !D[nt](Q)) {\n          Q.stop();\n          return;\n        }\n        var tt = triggerAble(o, e, Z, r, J, Q);\n        tt ? (o.props.stopPropagation || J === \"Start\" && K) && ((et = Q == null ? void 0 : Q.inputEvent) === null || et === void 0 || et.stopPropagation()) : Q.stop();\n      });\n    });\n  }), W;\n}\nvar EventManager = /* @__PURE__ */ function() {\n  function o(e, r, D) {\n    var N = this;\n    this.target = e, this.moveable = r, this.eventName = D, this.ables = [], this._onEvent = function(k) {\n      var $ = N.eventName, G = N.moveable;\n      G.state.disableNativeEvent || N.ables.forEach(function(U) {\n        U[$](G, {\n          inputEvent: k\n        });\n      });\n    }, e.addEventListener(D.toLowerCase(), this._onEvent);\n  }\n  var t = o.prototype;\n  return t.setAbles = function(e) {\n    this.ables = e;\n  }, t.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;\n  }, o;\n}();\nfunction getShadowRoot(o) {\n  if (o && o.getRootNode) {\n    var t = o.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction getMatrixStackInfo(o, t, e) {\n  for (var r = o, D = [], N = document.documentElement || document.body, k = !e && o === t || o === N, $ = k, G = !1, U = 3, z, X, V, Y = !1, q = getOffsetInfo(t, t, !0).offsetParent, W = 1; r && !$; ) {\n    $ = k;\n    var K = getComputedStyle(r), Z = K.position, J = getElementTransform(r, K), Q = convertCSStoMatrix(getTransformMatrix(J)), et = Z === \"fixed\", nt = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    et && (Y = !0, nt = getPositionFixedInfo(r), q = nt.fixedContainer);\n    var tt = Q.length;\n    !G && tt === 16 && (G = !0, U = 4, convert3DMatrixes(D), V && (V = convertDimension(V, 3, 4))), G && tt === 9 && (Q = convertDimension(Q, 3, 4));\n    var it = getOffsetPosInfo(r, o, K), st = it.tagName, at = it.hasOffset, ut = it.isSVG, ft = it.origin, ct = it.targetOrigin, vt = it.offset, yt = vt[0], mt = vt[1];\n    st === \"svg\" && V && (D.push({\n      type: \"target\",\n      target: r,\n      matrix: getSVGMatrix(r, U)\n    }), D.push({\n      type: \"offset\",\n      target: r,\n      matrix: createIdentityMatrix(U)\n    }));\n    var _t = void 0, Tt = !1, Pt = !1, St = parseFloat(K.zoom) || 1;\n    if (et)\n      _t = nt.fixedContainer, Tt = !0;\n    else {\n      var gt = getOffsetInfo(r, t, !1, !0, K), bt = gt.offsetZoom;\n      if (_t = gt.offsetParent, Tt = gt.isEnd, Pt = gt.isStatic, W *= bt, (gt.isCustomElement || bt !== 1) && Pt)\n        yt -= _t.offsetLeft, mt -= _t.offsetTop;\n      else if (IS_FIREFOX || IS_CHROMIUM109) {\n        var Nt = gt.parentSlotElement;\n        if (Nt) {\n          for (var At = _t, It = 0, Mt = 0; At && getShadowRoot(At); )\n            It += At.offsetLeft, Mt += At.offsetTop, At = At.offsetParent;\n          yt -= It, mt -= Mt;\n        }\n      }\n    }\n    IS_WEBKIT && !IS_SAFARI_ABOVE15 && at && !ut && Pt && (Z === \"relative\" || Z === \"static\") && (yt -= _t.offsetLeft, mt -= _t.offsetTop, k = k || Tt);\n    var dt = 0, $t = 0, Dt = 0, Vt = 0;\n    if (et)\n      at && nt.hasTransform && (Dt = _t.clientLeft, Vt = _t.clientTop);\n    else if (at && q !== _t && (dt = _t.clientLeft, $t = _t.clientTop), at && _t === N) {\n      var Lt = getBodyOffset(r, !1, K);\n      yt += Lt[0], mt += Lt[1];\n    }\n    if (D.push({\n      type: \"target\",\n      target: r,\n      matrix: getAbsoluteMatrix(Q, U, ft)\n    }), at) {\n      var Et = r === o, Ht = Et ? 0 : r.scrollLeft, kt = Et ? 0 : r.scrollTop;\n      D.push({\n        type: \"offset\",\n        target: r,\n        matrix: createOriginMatrix([yt - Ht + dt - Dt, mt - kt + $t - Vt], U)\n      });\n    } else\n      D.push({\n        type: \"offset\",\n        target: r,\n        origin: ft\n      });\n    if (St !== 1 && D.push({\n      type: \"zoom\",\n      target: r,\n      matrix: getAbsoluteMatrix(createScaleMatrix([St, St], U), U, [0, 0])\n    }), V || (V = Q), z || (z = ft), X || (X = ct), $ || et)\n      break;\n    r = _t, k = Tt, (!e || r === N) && ($ = k);\n  }\n  return V || (V = createIdentityMatrix(U)), z || (z = [0, 0]), X || (X = [0, 0]), {\n    zoom: W,\n    offsetContainer: q,\n    matrixes: D,\n    targetMatrix: V,\n    transformOrigin: z,\n    targetOrigin: X,\n    is3d: G,\n    hasFixed: Y\n  };\n}\nfunction calculateMatrixStack(o, t, e, r) {\n  var D;\n  e === void 0 && (e = t);\n  var N = getMatrixStackInfo(o, t), k = N.matrixes, $ = N.is3d, G = N.targetMatrix, U = N.transformOrigin, z = N.targetOrigin, X = N.offsetContainer, V = N.hasFixed, Y = N.zoom, q = getMatrixStackInfo(X, e, !0), W = q.matrixes, K = q.is3d, Z = q.offsetContainer, J = q.zoom, Q = r || K || $, et = Q ? 4 : 3, nt = o.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in o, tt = G, it = createIdentityMatrix(et), st = createIdentityMatrix(et), at = createIdentityMatrix(et), ut = createIdentityMatrix(et), ft = k.length;\n  W.reverse(), k.reverse(), !$ && Q && (tt = convertDimension(tt, 3, 4), convert3DMatrixes(k)), !K && Q && convert3DMatrixes(W), W.forEach(function(Pt) {\n    st = multiply(st, Pt.matrix, et);\n  });\n  var ct = e || document.body, vt = ((D = W[0]) === null || D === void 0 ? void 0 : D.target) || getOffsetInfo(ct, ct, !0).offsetParent, yt = W.slice(1).reduce(function(Pt, St) {\n    return multiply(Pt, St.matrix, et);\n  }, createIdentityMatrix(et));\n  k.forEach(function(Pt, St) {\n    if (ft - 2 === St && (at = it.slice()), ft - 1 === St && (ut = it.slice()), !Pt.matrix) {\n      var gt = k[St + 1], bt = getSVGOffset(Pt, gt, vt, et, multiply(yt, it, et));\n      Pt.matrix = createOriginMatrix(bt, et);\n    }\n    it = multiply(it, Pt.matrix, et);\n  });\n  var mt = !nt && $;\n  tt || (tt = createIdentityMatrix(mt ? 4 : 3));\n  var _t = makeMatrixCSS(nt && tt.length === 16 ? convertDimension(tt, 4, 3) : tt, mt), Tt = st;\n  return st = ignoreDimension(st, et, et), {\n    hasZoom: Y !== 1 || J !== 1,\n    hasFixed: V,\n    rootMatrix: st,\n    originalRootMatrix: Tt,\n    beforeMatrix: at,\n    offsetMatrix: ut,\n    allMatrix: it,\n    targetMatrix: tt,\n    targetTransform: _t,\n    transformOrigin: U,\n    targetOrigin: z,\n    is3d: Q,\n    offsetContainer: X,\n    offsetRootContainer: Z\n  };\n}\nfunction calculateElementInfo(o, t, e, r) {\n  e === void 0 && (e = t);\n  var D = 0, N = 0, k = 0, $ = {}, G = getSize(o);\n  if (o && (D = G.offsetWidth, N = G.offsetHeight), o) {\n    var U = calculateMatrixStack(o, t, e, r), z = calculateMoveablePosition(U.allMatrix, U.transformOrigin, D, N);\n    $ = __assign$1(__assign$1({}, U), z);\n    var X = calculateMoveablePosition(U.allMatrix, [50, 50], 100, 100);\n    k = getRotationRad([X.pos1, X.pos2], X.direction);\n  }\n  var V = r ? 4 : 3;\n  return __assign$1(__assign$1(__assign$1({\n    hasZoom: !1,\n    width: D,\n    height: N,\n    rotation: k\n  }, G), {\n    originalRootMatrix: createIdentityMatrix(V),\n    rootMatrix: createIdentityMatrix(V),\n    beforeMatrix: createIdentityMatrix(V),\n    offsetMatrix: createIdentityMatrix(V),\n    allMatrix: createIdentityMatrix(V),\n    targetMatrix: createIdentityMatrix(V),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!r,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null\n  }), $);\n}\nfunction getMoveableTargetInfo(o, t, e, r, D, N) {\n  N === void 0 && (N = []);\n  var k = 1, $ = [0, 0], G = resetClientRect(), U = resetClientRect(), z = resetClientRect(), X = resetClientRect(), V = [0, 0], Y = {}, q = calculateElementInfo(t, e, D, !0);\n  if (t) {\n    var W = getComputedStyle(t);\n    N.forEach(function(ct) {\n      Y[ct] = W[ct];\n    });\n    var K = q.is3d ? 4 : 3, Z = calculateMoveablePosition(q.offsetMatrix, plus(q.transformOrigin, getOrigin(q.targetMatrix, K)), q.width, q.height);\n    k = Z.direction, $ = plus(Z.origin, [Z.left - q.left, Z.top - q.top]), X = getClientRect(q.offsetRootContainer);\n    var J = getOffsetInfo(r, r, !0).offsetParent || q.offsetRootContainer;\n    if (q.hasZoom) {\n      var Q = calculateMoveablePosition(multiply(q.originalRootMatrix, q.allMatrix), q.transformOrigin, q.width, q.height), et = calculateMoveablePosition(q.originalRootMatrix, getTransformOrigin(getComputedStyle(J)).map(function(ct) {\n        return parseFloat(ct);\n      }), J.offsetWidth, J.offsetHeight);\n      if (G = getClientRectByPosition(Q, X), z = getClientRectByPosition(et, X, J, !0), o) {\n        var nt = Q.left, tt = Q.top;\n        U = getClientRectByPosition({\n          left: nt,\n          top: tt,\n          bottom: tt,\n          right: tt\n        }, X);\n      }\n    } else {\n      G = getClientRect(t), z = getClientRect(J, !0), o && (U = getClientRect(o));\n      var it = z.left, st = z.top, at = z.clientLeft, ut = z.clientTop, ft = [G.left - it, G.top - st];\n      V = minus(calculateInversePosition(q.rootMatrix, ft, 4), [at + q.left, ut + q.top]);\n    }\n  }\n  return __assign$1({\n    targetClientRect: G,\n    containerClientRect: z,\n    moveableClientRect: U,\n    rootContainerClientRect: X,\n    beforeDirection: k,\n    beforeOrigin: $,\n    originalBeforeOrigin: $,\n    target: t,\n    style: Y,\n    offsetDelta: V\n  }, q);\n}\nfunction getPersistState(o) {\n  var t = o.pos1, e = o.pos2, r = o.pos3, D = o.pos4;\n  if (!t || !e || !r || !D)\n    return null;\n  var N = getMinMaxs([t, e, r, D]), k = [N.minX, N.minY], $ = minus(o.origin, k);\n  return t = minus(t, k), e = minus(e, k), r = minus(r, k), D = minus(D, k), __assign$1(__assign$1({}, o), {\n    left: o.left,\n    top: o.top,\n    posDelta: k,\n    pos1: t,\n    pos2: e,\n    pos3: r,\n    pos4: D,\n    origin: $,\n    beforeOrigin: $,\n    // originalBeforeOrigin: origin,\n    isPersisted: !0\n  });\n}\nvar MoveableManager$1 = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.state = __assign$1({\n      container: null,\n      gestos: {},\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: !1,\n      posDelta: [0, 0]\n    }, getMoveableTargetInfo(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {\n      mouseEnter: null,\n      mouseLeave: null\n    }, r._emitter = new EventEmitter$1(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._reiszeObserver = null, r._observerId = 0, r._mutationObserver = null, r._mutationObserverId = 0, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r.checkUpdateRect = function() {\n      if (!r.isDragging()) {\n        var D = r.props.parentMoveable;\n        if (D) {\n          D.checkUpdateRect();\n          return;\n        }\n        cancelAnimationFrame$1(r._observerId), r._observerId = requestAnimationFrame$1(function() {\n          r.isDragging() || r.updateRect();\n        });\n      }\n    }, r._onPreventClick = function(D) {\n      D.stopPropagation(), D.preventDefault();\n    }, r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this.props, D = this.getState(), N = r.parentPosition, k = r.className, $ = r.target, G = r.zoom, U = r.cspNonce, z = r.translateZ, X = r.cssStyled, V = r.portalContainer, Y = r.groupable, q = r.linePadding, W = r.controlPadding;\n    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();\n    var K = N || [0, 0], Z = K[0], J = K[1], Q = D.left, et = D.top, nt = D.target, tt = D.direction, it = D.hasFixed, st = D.offsetDelta, at = r.targets, ut = this.isDragging(), ft = {};\n    this.getEnabledAbles().forEach(function(Tt) {\n      ft[\"data-able-\".concat(Tt.name.toLowerCase())] = !0;\n    });\n    var ct = this._getAbleClassName(), vt = at && at.length && (nt || Y) || $ || !this._hasFirstTarget && this.state.isPersisted, yt = this.controlBox || this.props.firstRenderState || this.props.persistData, mt = [Q - Z, et - J];\n    !Y && r.useAccuratePosition && (mt[0] += st[0], mt[1] += st[1]);\n    var _t = {\n      position: it ? \"fixed\" : \"absolute\",\n      display: vt ? \"block\" : \"none\",\n      visibility: yt ? \"visible\" : \"hidden\",\n      transform: \"translate3d(\".concat(mt[0], \"px, \").concat(mt[1], \"px, \").concat(z, \")\"),\n      \"--zoom\": G,\n      \"--zoompx\": \"\".concat(G, \"px\")\n    };\n    return q && (_t[\"--moveable-line-padding\"] = q), W && (_t[\"--moveable-control-padding\"] = W), createElement(X, __assign$1({\n      cspNonce: U,\n      ref: ref(this, \"controlBox\"),\n      className: \"\".concat(prefix(\"control-box\", tt === -1 ? \"reverse\" : \"\", ut ? \"dragging\" : \"\"), \" \").concat(ct, \" \").concat(k)\n    }, ft, {\n      onClick: this._onPreventClick,\n      portalContainer: V,\n      style: _t\n    }), this.renderAbles(), this._renderLines());\n  }, e.componentDidMount = function() {\n    this.isMoveableMounted = !0, this.isUnmounted = !1, this.controlBox.getElement();\n    var r = this.props, D = r.parentMoveable, N = r.container, k = r.wrapperMoveable;\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !N && !D && !k && !this.state.isPersisted && (this.updateRect(\"\", !1, !1), this.forceUpdate());\n  }, e.componentDidUpdate = function(r) {\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);\n  }, e.componentWillUnmount = function() {\n    var r, D;\n    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (r = this._reiszeObserver) === null || r === void 0 || r.disconnect(), (D = this._mutationObserver) === null || D === void 0 || D.disconnect();\n    var N = this._viewContainer;\n    N && this._changeAbleViewClassNames([]), unset(this, \"targetGesto\"), unset(this, \"controlGesto\");\n    var k = this.events;\n    for (var $ in k) {\n      var G = k[$];\n      G && G.destroy();\n    }\n  }, e.getTargets = function() {\n    var r = this.props.target;\n    return r ? [r] : [];\n  }, e.getAble = function(r) {\n    var D = this.props.ables || [];\n    return find$1(D, function(N) {\n      return N.name === r;\n    });\n  }, e.getContainer = function() {\n    var r = this.props, D = r.parentMoveable, N = r.wrapperMoveable, k = r.container;\n    return k || N && N.getContainer() || D && D.getContainer() || this.controlBox.getElement().parentElement;\n  }, e.isMoveableElement = function(r) {\n    var D;\n    return r && (((D = r.getAttribute) === null || D === void 0 ? void 0 : D.call(r, \"class\")) || \"\").indexOf(PREFIX) > -1;\n  }, e.dragStart = function(r) {\n    var D = this.targetGesto, N = this.controlGesto;\n    return D && checkMoveableTarget(this)({\n      inputEvent: r\n    }) ? D.isFlag() || D.triggerDragStart(r) : N && this.isMoveableElement(r.target) && (N.isFlag() || N.triggerDragStart(r)), this;\n  }, e.hitTest = function(r) {\n    var D = this.state, N = D.target, k = D.pos1, $ = D.pos2, G = D.pos3, U = D.pos4, z = D.targetClientRect;\n    if (!N)\n      return 0;\n    var X;\n    if (r instanceof Element) {\n      var V = r.getBoundingClientRect();\n      X = {\n        left: V.left,\n        top: V.top,\n        width: V.width,\n        height: V.height\n      };\n    } else\n      X = __assign$1({\n        width: 0,\n        height: 0\n      }, r);\n    var Y = X.left, q = X.top, W = X.width, K = X.height, Z = fitPoints([k, $, U, G], z), J = getOverlapSize(Z, [[Y, q], [Y + W, q], [Y + W, q + K], [Y, q + K]]), Q = getAreaSize(Z);\n    return !J || !Q ? 0 : Math.min(100, J / Q * 100);\n  }, e.isInside = function(r, D) {\n    var N = this.state, k = N.target, $ = N.pos1, G = N.pos2, U = N.pos3, z = N.pos4, X = N.targetClientRect;\n    return k ? isInside([r, D], fitPoints([$, G, z, U], X)) : !1;\n  }, e.updateRect = function(r, D, N) {\n    N === void 0 && (N = !0);\n    var k = this.props, $ = k.parentMoveable, G = this.state, U = G.target || this.props.target, z = this.getContainer(), X = $ ? $._rootContainer : this._rootContainer, V = getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), U, z, z, X || z, this._getRequestStyles());\n    if (!U && this._hasFirstTarget && k.persistData) {\n      var Y = getPersistState(k.persistData);\n      for (var q in Y)\n        V[q] = Y[q];\n    }\n    this.updateState(V, $ ? !1 : N);\n  }, e.isDragging = function(r) {\n    var D, N, k = this.targetGesto, $ = this.controlGesto;\n    if (k != null && k.isFlag()) {\n      if (!r)\n        return !0;\n      var G = k.getEventData();\n      return !!(!((D = G[r]) === null || D === void 0) && D.isEventStart);\n    }\n    if ($ != null && $.isFlag()) {\n      if (!r)\n        return !0;\n      var G = $.getEventData();\n      return !!(!((N = G[r]) === null || N === void 0) && N.isEventStart);\n    }\n    return !1;\n  }, e.updateTarget = function(r) {\n    this.updateRect(r, !0);\n  }, e.getRect = function() {\n    var r = this.state, D = getAbsolutePosesByState(this.state), N = D[0], k = D[1], $ = D[2], G = D[3], U = getRect(D), z = r.width, X = r.height, V = U.width, Y = U.height, q = U.left, W = U.top, K = [r.left, r.top], Z = plus(K, r.origin), J = plus(K, r.beforeOrigin), Q = r.transformOrigin;\n    return {\n      width: V,\n      height: Y,\n      left: q,\n      top: W,\n      pos1: N,\n      pos2: k,\n      pos3: $,\n      pos4: G,\n      offsetWidth: z,\n      offsetHeight: X,\n      beforeOrigin: J,\n      origin: Z,\n      transformOrigin: Q,\n      rotation: this.getRotation()\n    };\n  }, e.getManager = function() {\n    return this;\n  }, e.stopDrag = function(r) {\n    var D, N;\n    (!r || r === \"target\") && ((D = this.targetGesto) === null || D === void 0 || D.stop()), (!r || r === \"control\") && ((N = this.controlGesto) === null || N === void 0 || N.stop());\n  }, e.getRotation = function() {\n    var r = this.state, D = r.pos1, N = r.pos2, k = r.direction;\n    return getAbsoluteRotation(D, N, k);\n  }, e.request = function(r, D, N) {\n    D === void 0 && (D = {});\n    var k = this.props, $ = k.ables, G = k.groupable, U = $.filter(function(K) {\n      return K.name === r;\n    })[0];\n    if (this.isDragging() || !U || !U.request)\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    var z = this, X = U.request(this), V = N || D.isInstant, Y = X.isControl ? \"controlAbles\" : \"targetAbles\", q = \"\".concat(G ? \"Group\" : \"\").concat(X.isControl ? \"Control\" : \"\"), W = {\n      request: function(K) {\n        return triggerAble(z, Y, \"drag\", q, \"\", __assign$1(__assign$1({}, X.request(K)), {\n          requestAble: r,\n          isRequest: !0\n        }), V), this;\n      },\n      requestEnd: function() {\n        return triggerAble(z, Y, \"drag\", q, \"End\", __assign$1(__assign$1({}, X.requestEnd()), {\n          requestAble: r,\n          isRequest: !0\n        }), V), this;\n      }\n    };\n    return triggerAble(z, Y, \"drag\", q, \"Start\", __assign$1(__assign$1({}, X.requestStart(D)), {\n      requestAble: r,\n      isRequest: !0\n    }), V), V ? W.request(D).requestEnd() : W;\n  }, e.destroy = function() {\n    this.componentWillUnmount();\n  }, e.updateRenderPoses = function() {\n    var r = this.getState(), D = this.props, N = r.originalBeforeOrigin, k = r.transformOrigin, $ = r.allMatrix, G = r.is3d, U = r.pos1, z = r.pos2, X = r.pos3, V = r.pos4, Y = r.left, q = r.top, W = r.isPersisted, K = D.padding || {}, Z = K.left, J = Z === void 0 ? 0 : Z, Q = K.top, et = Q === void 0 ? 0 : Q, nt = K.bottom, tt = nt === void 0 ? 0 : nt, it = K.right, st = it === void 0 ? 0 : it, at = G ? 4 : 3, ut = [];\n    W ? ut = k : this.controlBox && D.groupable ? ut = N : ut = plus(N, [Y, q]), r.renderPoses = [plus(U, calculatePadding($, [-J, -et], k, ut, at)), plus(z, calculatePadding($, [st, -et], k, ut, at)), plus(X, calculatePadding($, [-J, tt], k, ut, at)), plus(V, calculatePadding($, [st, tt], k, ut, at))];\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1;\n    var r = this.props, D = r.target, N = r.container, k = r.parentMoveable, $ = this.state, G = $.target, U = $.container;\n    if (!(!G && !D)) {\n      this.updateAbles();\n      var z = !equals(G, D), X = z || !equals(U, N);\n      if (X) {\n        var V = N || this.controlBox;\n        V && this.unsetAbles(), this.updateState({\n          target: D,\n          container: N\n        }), !k && V && this.updateRect(\"End\", !1, !1), this._isPropTargetChanged = z;\n      }\n    }\n  }, e.waitToChangeTarget = function() {\n    return new Promise(function() {\n    });\n  }, e.triggerEvent = function(r, D) {\n    this._emitter.trigger(r, D);\n    var N = this.props[r];\n    return N && N(D);\n  }, e.useCSS = function(r, D) {\n    var N = this.props.customStyledMap, k = r + D;\n    return N[k] || (N[k] = styled(r, D)), N[k];\n  }, e.getState = function() {\n    var r, D = this.props;\n    (D.target || !((r = D.targets) === null || r === void 0) && r.length) && (this._hasFirstTarget = !0);\n    var N = this.controlBox, k = D.persistData, $ = D.firstRenderState;\n    if ($ && !N)\n      return $;\n    if (!this._hasFirstTarget && k) {\n      var G = getPersistState(k);\n      if (G)\n        return this.updateState(G, !1), this.state;\n    }\n    return this.state.isPersisted = !1, this.state;\n  }, e.updateSelectors = function() {\n  }, e.unsetAbles = function() {\n    var r = this;\n    this.targetAbles.forEach(function(D) {\n      D.unset && D.unset(r);\n    });\n  }, e.updateAbles = function(r, D) {\n    r === void 0 && (r = this.props.ables), D === void 0 && (D = \"\");\n    var N = this.props, k = N.triggerAblesSimultaneously, $ = this.getEnabledAbles(r), G = \"drag\".concat(D, \"Start\"), U = \"pinch\".concat(D, \"Start\"), z = \"drag\".concat(D, \"ControlStart\"), X = filterAbles($, [G, U], k), V = filterAbles($, [z], k);\n    this.enabledAbles = $, this.targetAbles = X, this.controlAbles = V;\n  }, e.updateState = function(r, D) {\n    if (D) {\n      if (this.isUnmounted)\n        return;\n      this.setState(r);\n    } else {\n      var N = this.state;\n      for (var k in r)\n        N[k] = r[k];\n    }\n  }, e.getEnabledAbles = function(r) {\n    r === void 0 && (r = this.props.ables);\n    var D = this.props;\n    return r.filter(function(N) {\n      return N && (N.always && D[N.name] !== !1 || D[N.name]);\n    });\n  }, e.renderAbles = function() {\n    var r = this, D = this.props, N = D.triggerAblesSimultaneously, k = {\n      createElement\n    };\n    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], N).map(function($) {\n      var G = $.render;\n      return G(r, k) || [];\n    })).filter(function($) {\n      return $;\n    }), function($) {\n      var G = $.key;\n      return G;\n    }).map(function($) {\n      return $[0];\n    });\n  }, e.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }, e._getRequestStyles = function() {\n    var r = this.getEnabledAbles().reduce(function(D, N) {\n      var k, $, G = ($ = (k = N.requestStyle) === null || k === void 0 ? void 0 : k.call(N)) !== null && $ !== void 0 ? $ : [];\n      return __spreadArray(__spreadArray([], D, !0), G, !0);\n    }, __spreadArray([], this.props.requestStyles || [], !0));\n    return r;\n  }, e._updateObserver = function(r) {\n    this._updateResizeObserver(r), this._updateMutationObserver(r);\n  }, e._updateEvents = function() {\n    var r = this.controlBox.getElement(), D = this.targetAbles.length, N = this.controlAbles.length, k = this.props, $ = k.dragTarget || k.target, G = !D && this.targetGesto || this._isTargetChanged(!0);\n    G && (unset(this, \"targetGesto\"), this.updateState({\n      gesto: null\n    })), N || unset(this, \"controlGesto\"), $ && D && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, $, \"\")), !this.controlGesto && N && (this.controlGesto = getAbleGesto(this, r, \"controlAbles\", \"Control\"));\n  }, e._updateTargets = function() {\n    var r = this.props;\n    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;\n  }, e._renderLines = function() {\n    var r = this.props, D = r, N = D.zoom, k = D.hideDefaultLines, $ = D.hideChildMoveableDefaultLines, G = D.parentMoveable;\n    if (k || G && $)\n      return [];\n    var U = this.getState().renderPoses, z = {\n      createElement\n    };\n    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(X, V) {\n      var Y = X[0], q = X[1];\n      return renderLine(z, \"\", U[Y], U[q], N, \"render-line-\".concat(V));\n    });\n  }, e._isTargetChanged = function(r) {\n    var D = this.props, N = D.dragTarget || D.target, k = this._prevTarget, $ = this._prevDragArea, G = D.dragArea, U = !G && k !== N, z = (r || G) && $ !== G;\n    return U || z;\n  }, e._updateNativeEvents = function() {\n    var r = this, D = this.props, N = D.dragArea ? this.areaElement : this.state.target, k = this.events, $ = getKeys(k);\n    if (this._isTargetChanged())\n      for (var G in k) {\n        var U = k[G];\n        U && U.destroy(), k[G] = null;\n      }\n    if (N) {\n      var z = this.enabledAbles;\n      $.forEach(function(X) {\n        var V = filterAbles(z, [X]), Y = V.length > 0, q = k[X];\n        if (!Y) {\n          q && (q.destroy(), k[X] = null);\n          return;\n        }\n        q || (q = new EventManager(N, r, X), k[X] = q), q.setAbles(V);\n      });\n    }\n  }, e._checkUpdateRootContainer = function() {\n    var r = this.props.rootContainer;\n    !this._rootContainer && r && (this._rootContainer = getRefTarget(r, !0));\n  }, e._checkUpdateViewContainer = function() {\n    var r = this.props.viewContainer;\n    !this._viewContainer && r && (this._viewContainer = getRefTarget(r, !0));\n    var D = this._viewContainer;\n    D && this._changeAbleViewClassNames(__spreadArray(__spreadArray([], this._getAbleViewClassNames(), !0), [this.isDragging() ? VIEW_DRAGGING : \"\"], !1));\n  }, e._changeAbleViewClassNames = function(r) {\n    var D = this._viewContainer, N = groupBy(r.filter(Boolean), function(z) {\n      return z;\n    }).map(function(z) {\n      var X = z[0];\n      return X;\n    }), k = this._viewClassNames, $ = diff$1(k, N), G = $.removed, U = $.added;\n    G.forEach(function(z) {\n      removeClass(D, k[z]);\n    }), U.forEach(function(z) {\n      addClass(D, N[z]);\n    }), this._viewClassNames = N;\n  }, e._getAbleViewClassNames = function() {\n    var r = this;\n    return (this.getEnabledAbles().map(function(D) {\n      var N;\n      return ((N = D.viewClassName) === null || N === void 0 ? void 0 : N.call(D, r)) || \"\";\n    }).join(\" \") + \" \".concat(this._getAbleClassName(\"-view\"))).split(/\\s+/g);\n  }, e._getAbleClassName = function(r) {\n    var D = this;\n    r === void 0 && (r = \"\");\n    var N = this.getEnabledAbles(), k = this.targetGesto, $ = this.controlGesto, G = k != null && k.isFlag() ? k.getEventData() : {}, U = $ != null && $.isFlag() ? $.getEventData() : {};\n    return N.map(function(z) {\n      var X, V, Y, q = z.name, W = ((X = z.className) === null || X === void 0 ? void 0 : X.call(z, D)) || \"\";\n      return (!((V = G[q]) === null || V === void 0) && V.isEventStart || !((Y = U[q]) === null || Y === void 0) && Y.isEventStart) && (W += \" \".concat(prefix(\"\".concat(q).concat(r, \"-dragging\")))), W.trim();\n    }).filter(Boolean).join(\" \");\n  }, e._updateResizeObserver = function(r) {\n    var D, N = this.props, k = N.target;\n    if (!window.ResizeObserver || !k || !N.useResizeObserver) {\n      (D = this._reiszeObserver) === null || D === void 0 || D.disconnect();\n      return;\n    }\n    if (!(r.target === k && this._reiszeObserver)) {\n      var $ = new ResizeObserver(this.checkUpdateRect);\n      $.observe(k, {\n        box: \"border-box\"\n      }), this._reiszeObserver = $;\n    }\n  }, e._updateMutationObserver = function(r) {\n    var D = this, N, k = this.props, $ = k.target;\n    if (!window.MutationObserver || !$ || !k.useMutationObserver) {\n      (N = this._mutationObserver) === null || N === void 0 || N.disconnect();\n      return;\n    }\n    if (!(r.target === $ && this._mutationObserver)) {\n      var G = new MutationObserver(function(U) {\n        for (var z = 0, X = U; z < X.length; z++) {\n          var V = X[z];\n          V.type === \"attributes\" && V.attributeName === \"style\" && D.checkUpdateRect();\n        }\n      });\n      G.observe($, {\n        attributes: !0\n      }), this._mutationObserver = G;\n    }\n  }, t.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: !0,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    isWrapperMounted: !1,\n    parentPosition: null,\n    portalContainer: null,\n    useResizeObserver: !1,\n    useMutationObserver: !1,\n    preventDefault: !0,\n    linePadding: 0,\n    controlPadding: 0,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: !1,\n    passDragArea: !1,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: !1,\n    padding: {},\n    pinchOutside: !0,\n    checkInput: !1,\n    groupable: !1,\n    hideDefaultLines: !1,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: !1,\n    preventClickDefault: !1,\n    preventClickEventOnDrag: !0,\n    flushSync: defaultSync,\n    firstRenderState: null,\n    persistData: null,\n    viewContainer: null,\n    requestStyles: [],\n    useAccuratePosition: !1\n  }, t;\n}(PureComponent), Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean,\n    groupableProps: Object,\n    targetGroups: Object,\n    hideChildMoveableDefaultLines: Boolean\n  },\n  events: {},\n  render: function(o, t) {\n    var e, r = o.props, D = r.targets || [], N = o.getState(), k = N.left, $ = N.top, G = N.isPersisted, U = [k, $], z = r.zoom || 1, X = o.renderGroupRects, V = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];\n    G ? D = V.map(function() {\n      return null;\n    }) : V = [];\n    var Y = o.getRequestChildStyles();\n    return o.moveables = o.moveables.slice(0, D.length), __spreadArray(__spreadArray([], D.map(function(q, W) {\n      return t.createElement(MoveableManager$1, {\n        key: \"moveable\" + W,\n        ref: refs(o, \"moveables\", W),\n        target: q,\n        origin: !1,\n        requestStyles: Y,\n        cssStyled: r.cssStyled,\n        customStyledMap: r.customStyledMap,\n        useResizeObserver: r.useResizeObserver,\n        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,\n        parentMoveable: o,\n        parentPosition: U,\n        persistData: V[W],\n        zoom: z\n      });\n    }), !0), flat(X.map(function(q, W) {\n      var K = q.pos1, Z = q.pos2, J = q.pos3, Q = q.pos4, et = [K, Z, J, Q];\n      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(nt, tt) {\n        var it = nt[0], st = nt[1];\n        return renderLine(t, \"\", minus(et[it], U), minus(et[st], U), z, \"group-rect-\".concat(W, \"-\").concat(tt));\n      });\n    })), !0);\n  }\n}, Clickable = makeAble(\"clickable\", {\n  props: {\n    clickable: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: !0,\n  dragRelation: \"weak\",\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dragStart: function() {\n  },\n  dragControlStart: function() {\n  },\n  dragGroupStart: function(o, t) {\n    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;\n  },\n  dragEnd: function(o, t) {\n    var e = o.props.target, r = t.inputEvent, D = t.inputTarget, N = o.isMoveableElement(D), k = !N && o.controlBox.getElement().contains(D);\n    if (!(!r || !D || t.isDrag || o.isMoveableElement(D) || k)) {\n      var $ = e.contains(D);\n      triggerEvent(o, \"onClick\", fillParams(o, t, {\n        isDouble: t.isDouble,\n        inputTarget: D,\n        isTarget: e === D,\n        moveableTarget: o.props.target,\n        containsTarget: $\n      }));\n    }\n  },\n  dragGroupEnd: function(o, t) {\n    var e = t.inputEvent, r = t.inputTarget;\n    if (!(!e || !r || t.isDrag || o.isMoveableElement(r) || t.datas.inputTarget === r)) {\n      var D = o.props.targets, N = D.indexOf(r), k = N > -1, $ = !1;\n      N === -1 && (N = findIndex(D, function(G) {\n        return G.contains(r);\n      }), $ = N > -1), triggerEvent(o, \"onClickGroup\", fillParams(o, t, {\n        isDouble: t.isDouble,\n        targets: D,\n        inputTarget: r,\n        targetIndex: N,\n        isTarget: k,\n        containsTarget: $,\n        moveableTarget: D[N]\n      }));\n    }\n  },\n  dragControlEnd: function(o, t) {\n    this.dragEnd(o, t);\n  },\n  dragGroupControlEnd: function(o, t) {\n    this.dragEnd(o, t);\n  }\n});\nfunction getDraggableEvent(o) {\n  var t = o.originalDatas.draggable;\n  return t || (o.originalDatas.draggable = {}, t = o.originalDatas.draggable), __assign$1(__assign$1({}, o), {\n    datas: t\n  });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  css: [`.edge.edgeDraggable.line {\n    cursor: move;\n}`],\n  render: function(o, t) {\n    var e = o.props, r = e.edgeDraggable;\n    return r ? renderEdgeLines(t, \"edgeDraggable\", r, o.getState().renderPoses, e.zoom) : [];\n  },\n  dragCondition: function(o, t) {\n    var e, r = o.props, D = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !D ? !1 : !r.draggable && hasClass(D, prefix(\"direction\")) && hasClass(D, prefix(\"edge\")) && hasClass(D, prefix(\"edgeDraggable\"));\n  },\n  dragStart: function(o, t) {\n    return Draggable.dragStart(o, getDraggableEvent(t));\n  },\n  drag: function(o, t) {\n    return Draggable.drag(o, getDraggableEvent(t));\n  },\n  dragEnd: function(o, t) {\n    return Draggable.dragEnd(o, getDraggableEvent(t));\n  },\n  dragGroupCondition: function(o, t) {\n    var e, r = o.props, D = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !D ? !1 : !r.draggable && hasClass(D, prefix(\"direction\")) && hasClass(D, prefix(\"line\"));\n  },\n  dragGroupStart: function(o, t) {\n    return Draggable.dragGroupStart(o, getDraggableEvent(t));\n  },\n  dragGroup: function(o, t) {\n    return Draggable.dragGroup(o, getDraggableEvent(t));\n  },\n  dragGroupEnd: function(o, t) {\n    return Draggable.dragGroupEnd(o, getDraggableEvent(t));\n  },\n  unset: function(o) {\n    return Draggable.unset(o);\n  }\n}), IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean,\n    individualGroupableProps: Function\n  },\n  events: {}\n}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {\n  return __assign$1(__assign$1({}, o), \"events\" in t ? t.events : {});\n}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(o, t) {\n  return __assign$1(__assign$1({}, o), t.props);\n}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nfunction solveConstantsDistance(o, t) {\n  var e = o[0], r = o[1], D = o[2];\n  return (e * t[0] + r * t[1] + D) / Math.sqrt(e * e + r * r);\n}\nfunction solveC(o, t) {\n  var e = o[0], r = o[1];\n  return -e * t[0] - r * t[1];\n}\nfunction getMaxPos(o, t) {\n  return Math.max.apply(Math, o.map(function(e) {\n    var r = e[0], D = e[1], N = e[2], k = e[3];\n    return Math.max(r[t], D[t], N[t], k[t]);\n  }));\n}\nfunction getMinPos(o, t) {\n  return Math.min.apply(Math, o.map(function(e) {\n    var r = e[0], D = e[1], N = e[2], k = e[3];\n    return Math.min(r[t], D[t], N[t], k[t]);\n  }));\n}\nfunction getGroupRect(o, t) {\n  var e, r = [0, 0], D = [0, 0], N = [0, 0], k = [0, 0], $ = 0, G = 0;\n  if (!o.length)\n    return {\n      pos1: r,\n      pos2: D,\n      pos3: N,\n      pos4: k,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: $,\n      height: G,\n      rotation: t\n    };\n  var U = throttle(t, TINY_NUM);\n  if (U % 90) {\n    var z = U / 180 * Math.PI, X = Math.tan(z), V = -1 / X, Y = [MAX_NUM, MIN_NUM], q = [[0, 0], [0, 0]], W = [MAX_NUM, MIN_NUM], K = [[0, 0], [0, 0]];\n    o.forEach(function(St) {\n      St.forEach(function(gt) {\n        var bt = solveConstantsDistance([-X, 1, 0], gt), Nt = solveConstantsDistance([-V, 1, 0], gt);\n        Y[0] > bt && (q[0] = gt, Y[0] = bt), Y[1] < bt && (q[1] = gt, Y[1] = bt), W[0] > Nt && (K[0] = gt, W[0] = Nt), W[1] < Nt && (K[1] = gt, W[1] = Nt);\n      });\n    });\n    var Z = q[0], J = q[1], Q = K[0], et = K[1], nt = [-X, 1, solveC([-X, 1], Z)], tt = [-X, 1, solveC([-X, 1], J)], it = [-V, 1, solveC([-V, 1], Q)], st = [-V, 1, solveC([-V, 1], et)];\n    e = [[nt, it], [nt, st], [tt, it], [tt, st]].map(function(St) {\n      var gt = St[0], bt = St[1];\n      return getIntersectionPointsByConstants(gt, bt)[0];\n    }), r = e[0], D = e[1], N = e[2], k = e[3], $ = W[1] - W[0], G = Y[1] - Y[0];\n  } else {\n    var at = getMinPos(o, 0), ut = getMinPos(o, 1), ft = getMaxPos(o, 0), ct = getMaxPos(o, 1);\n    if (r = [at, ut], D = [ft, ut], N = [at, ct], k = [ft, ct], $ = ft - at, G = ct - ut, U % 180) {\n      var vt = [N, r, k, D];\n      r = vt[0], D = vt[1], N = vt[2], k = vt[3], $ = ct - ut, G = ft - at;\n    }\n  }\n  if (U % 360 > 180) {\n    var vt = [k, N, D, r];\n    r = vt[0], D = vt[1], N = vt[2], k = vt[3];\n  }\n  var yt = getMinMaxs([r, D, N, k]), mt = yt.minX, _t = yt.minY, Tt = yt.maxX, Pt = yt.maxY;\n  return {\n    pos1: r,\n    pos2: D,\n    pos3: N,\n    pos4: k,\n    width: $,\n    height: G,\n    minX: mt,\n    minY: _t,\n    maxX: Tt,\n    maxY: Pt,\n    rotation: t\n  };\n}\nfunction findMoveableGroups(o, t) {\n  var e = t.map(function(r) {\n    if (isArray(r)) {\n      var D = findMoveableGroups(o, r), N = D.length;\n      return N > 1 ? D : N === 1 ? D[0] : null;\n    } else {\n      var k = find$1(o, function($) {\n        var G = $.manager;\n        return G.props.target === r;\n      });\n      return k ? (k.finded = !0, k.manager) : null;\n    }\n  }).filter(Boolean);\n  return e.length === 1 && isArray(e[0]) ? e[0] : e;\n}\nvar MoveableGroup = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.differ = new ChildrenDiffer$1(), r.moveables = [], r.transformOrigin = \"50% 50%\", r.renderGroupRects = [], r._targetGroups = [], r._hasFirstTargets = !1, r;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    o.prototype.componentDidMount.call(this);\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1, this.updateAbles();\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, D, N) {\n    var k;\n    N === void 0 && (N = !0);\n    var $ = this.state;\n    if (!this.controlBox || $.isPersisted)\n      return;\n    this.moveables.forEach(function(Dt) {\n      Dt.updateRect(r, !1, !1);\n    });\n    var G = this.props, U = this.moveables, z = $.target || G.target, X = U.map(function(Dt) {\n      return {\n        finded: !1,\n        manager: Dt\n      };\n    }), V = this.props.targetGroups || [], Y = findMoveableGroups(X, V);\n    Y.push.apply(Y, X.filter(function(Dt) {\n      var Vt = Dt.finded;\n      return !Vt;\n    }).map(function(Dt) {\n      var Vt = Dt.manager;\n      return Vt;\n    }));\n    var q = [], W = !D || r !== \"\" && G.updateGroup, K = G.defaultGroupRotate || 0;\n    if (!this._hasFirstTargets) {\n      var Z = (k = this.props.persistData) === null || k === void 0 ? void 0 : k.rotation;\n      Z != null && (K = Z);\n    }\n    function J(Dt, Vt, Lt) {\n      var Et = Dt.map(function(qt) {\n        if (isArray(qt)) {\n          var Qt = J(qt, Vt), Kt = [Qt.pos1, Qt.pos2, Qt.pos3, Qt.pos4];\n          return q.push(Qt), {\n            poses: Kt,\n            rotation: Qt.rotation\n          };\n        } else\n          return {\n            poses: getAbsolutePosesByState(qt.state),\n            rotation: qt.getRotation()\n          };\n      }), Ht = Et.map(function(qt) {\n        var Qt = qt.rotation;\n        return Qt;\n      }), kt = 0, wt = Ht[0], Bt = Ht.every(function(qt) {\n        return Math.abs(wt - qt) < 0.1;\n      });\n      W ? kt = Bt ? wt : K : kt = !Lt && Bt ? wt : Vt;\n      var jt = Et.map(function(qt) {\n        var Qt = qt.poses;\n        return Qt;\n      }), Ct = getGroupRect(jt, kt);\n      return Ct;\n    }\n    var Q = J(Y, this.rotation, !0);\n    W && (this.rotation = Q.rotation, this.transformOrigin = G.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]), this._targetGroups = V, this.renderGroupRects = q;\n    var et = this.transformOrigin, nt = this.rotation, tt = this.scale, it = Q.width, st = Q.height, at = Q.minX, ut = Q.minY, ft = rotatePosesInfo([[0, 0], [it, 0], [0, st], [it, st]], convertTransformOriginArray(et, it, st), this.rotation / 180 * Math.PI), ct = getMinMaxs(ft.result), vt = ct.minX, yt = ct.minY, mt = \" rotate(\".concat(nt, \"deg)\") + \" scale(\".concat(tt[0] >= 0 ? 1 : -1, \", \").concat(tt[1] >= 0 ? 1 : -1, \")\"), _t = \"translate(\".concat(-vt, \"px, \").concat(-yt, \"px)\").concat(mt);\n    this.controlBox.getElement().style.transform = \"translate3d(\".concat(at, \"px, \").concat(ut, \"px, \").concat(this.props.translateZ || 0, \")\"), z.style.cssText += \"left:0px;top:0px;\" + \"transform-origin:\".concat(et, \";\") + \"width:\".concat(it, \"px;height:\").concat(st, \"px;\") + \"transform: \".concat(_t), $.width = it, $.height = st;\n    var Tt = this.getContainer(), Pt = getMoveableTargetInfo(this.controlBox.getElement(), z, this.controlBox.getElement(), this.getContainer(), this._rootContainer || Tt, []), St = [Pt.left, Pt.top], gt = getAbsolutePosesByState(Pt), bt = gt[0], Nt = gt[1], At = gt[2], It = gt[3], Mt = getMinMaxs([bt, Nt, At, It]), dt = [Mt.minX, Mt.minY], $t = tt[0] * tt[1] > 0 ? 1 : -1;\n    Pt.pos1 = minus(bt, dt), Pt.pos2 = minus(Nt, dt), Pt.pos3 = minus(At, dt), Pt.pos4 = minus(It, dt), Pt.left = at - Pt.left + dt[0], Pt.top = ut - Pt.top + dt[1], Pt.origin = minus(plus(St, Pt.origin), dt), Pt.beforeOrigin = minus(plus(St, Pt.beforeOrigin), dt), Pt.originalBeforeOrigin = plus(St, Pt.originalBeforeOrigin), Pt.transformOrigin = minus(plus(St, Pt.transformOrigin), dt), z.style.transform = \"translate(\".concat(-vt - dt[0], \"px, \").concat(-yt - dt[1], \"px)\") + mt, this.updateState(__assign$1(__assign$1({}, Pt), {\n      posDelta: dt,\n      direction: $t,\n      beforeDirection: $t\n    }), N);\n  }, e.getRect = function() {\n    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.triggerEvent = function(r, D, N) {\n    if (N || r.indexOf(\"Group\") > -1)\n      return o.prototype.triggerEvent.call(this, r, D);\n    this._emitter.trigger(r, D);\n  }, e.getRequestChildStyles = function() {\n    var r = this.getEnabledAbles().reduce(function(D, N) {\n      var k, $, G = ($ = (k = N.requestChildStyle) === null || k === void 0 ? void 0 : k.call(N)) !== null && $ !== void 0 ? $ : [];\n      return __spreadArray(__spreadArray([], D, !0), G, !0);\n    }, []);\n    return r;\n  }, e.updateAbles = function() {\n    o.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), \"Group\");\n  }, e._updateTargets = function() {\n    o.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;\n  }, e._updateEvents = function() {\n    var r = this.state, D = this.props, N = this._prevTarget, k = D.dragTarget || this.areaElement;\n    N !== k && (unset(this, \"targetGesto\"), unset(this, \"controlGesto\"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.getElement().style.display = \"block\"), r.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, k, \"Group\")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\")));\n    var $ = !equals(r.container, D.container);\n    $ && (r.container = D.container);\n    var G = D.targets, U = this.differ.update(G), z = U.added, X = U.changed, V = U.removed, Y = z.length || V.length;\n    ($ || Y || this.transformOrigin !== (D.defaultGroupOrigin || \"50% 50%\") || X.length || G.length && !isDeepArrayEquals(this._targetGroups, D.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!Y;\n  }, e._updateObserver = function() {\n  }, t.defaultProps = __assign$1(__assign$1({}, MoveableManager$1.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: !0,\n    dragArea: !0,\n    keepRatio: !0,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  }), t;\n}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.moveables = [], r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this, D, N = this.props, k = N.cspNonce, $ = N.cssStyled, G = N.persistData, U = N.targets || [], z = U.length, X = this.isUnmounted || !z, V = (D = G == null ? void 0 : G.children) !== null && D !== void 0 ? D : [];\n    return X && !z && V.length ? U = V.map(function() {\n      return null;\n    }) : X || (V = []), createElement($, {\n      cspNonce: k,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, U.map(function(Y, q) {\n      var W, K, Z = (K = (W = N.individualGroupableProps) === null || W === void 0 ? void 0 : W.call(N, Y, q)) !== null && K !== void 0 ? K : {};\n      return createElement(MoveableManager$1, __assign$1({\n        key: \"moveable\" + q,\n        ref: refs(r, \"moveables\", q)\n      }, N, Z, {\n        target: Y,\n        wrapperMoveable: r,\n        isWrapperMounted: r.isMoveableMounted,\n        persistData: V[q]\n      }));\n    }));\n  }, e.componentDidUpdate = function() {\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, D, N) {\n    N === void 0 && (N = !0), this.moveables.forEach(function(k) {\n      k.updateRect(r, D, N);\n    });\n  }, e.getRect = function() {\n    return __assign$1(__assign$1({}, o.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  }, e.dragStart = function() {\n    return this;\n  }, e.hitTest = function() {\n    return 0;\n  }, e.isInside = function() {\n    return !1;\n  }, e.isDragging = function() {\n    return !1;\n  }, e.updateRenderPoses = function() {\n  }, e.checkUpdate = function() {\n  }, e.triggerEvent = function() {\n  }, e.updateAbles = function() {\n  }, e._updateEvents = function() {\n  }, e._updateObserver = function() {\n  }, t;\n}(MoveableManager$1);\nfunction getElementTargets(o, t) {\n  var e = [];\n  return o.forEach(function(r) {\n    if (r) {\n      if (isString(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      isArray(r) ? e.push.apply(e, getElementTargets(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction getTargetGroups(o, t) {\n  var e = [];\n  return o.forEach(function(r) {\n    if (r) {\n      if (isString(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      isArray(r) ? e.push(getTargetGroups(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction compareRefTargets(o, t) {\n  return o.length !== t.length || o.some(function(e, r) {\n    var D = t[r];\n    return !e && !D ? !1 : e != D ? isArray(e) && isArray(D) ? compareRefTargets(e, D) : !0 : !1;\n  });\n}\nvar InitialMoveable = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    var r = o !== null && o.apply(this, arguments) || this;\n    return r.refTargets = [], r.selectorMap = {}, r._differ = new ChildrenDiffer$1(), r._elementTargets = [], r._onChangeTargets = null, r;\n  }\n  var e = t.prototype;\n  return t.makeStyled = function() {\n    var r = {}, D = this.getTotalAbles();\n    D.forEach(function(k) {\n      var $ = k.css;\n      $ && $.forEach(function(G) {\n        r[G] = !0;\n      });\n    });\n    var N = getKeys(r).join(`\n`);\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + N));\n  }, t.getTotalAbles = function() {\n    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);\n  }, e.render = function() {\n    var r, D = this.constructor;\n    D.defaultStyled || D.makeStyled();\n    var N = this.props, k = N.ables, $ = N.props, G = __rest(N, [\"ables\", \"props\"]), U = this._updateRefs(!0), z = getElementTargets(U, this.selectorMap), X = z.length > 1, V = D.getTotalAbles(), Y = __spreadArray(__spreadArray([], V, !0), k || [], !0), q = __assign$1(__assign$1(__assign$1({}, G), $ || {}), {\n      ables: Y,\n      cssStyled: D.defaultStyled,\n      customStyledMap: D.customStyledMap\n    });\n    this._elementTargets = z;\n    var W = null, K = this.moveable, Z = G.persistData;\n    if (Z != null && Z.children && (X = !0), G.individualGroupable)\n      return createElement(MoveableIndividualGroup, __assign$1({\n        key: \"individual-group\",\n        ref: ref(this, \"moveable\")\n      }, q, {\n        target: null,\n        targets: z\n      }));\n    if (X) {\n      var J = getTargetGroups(U, this.selectorMap);\n      if (K && !K.props.groupable && !K.props.individualGroupable) {\n        var Q = K.props.target;\n        Q && z.indexOf(Q) > -1 && (W = __assign$1({}, K.state));\n      }\n      return createElement(MoveableGroup, __assign$1({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, q, (r = G.groupableProps) !== null && r !== void 0 ? r : {}, {\n        target: null,\n        targets: z,\n        targetGroups: J,\n        firstRenderState: W\n      }));\n    } else {\n      var et = z[0];\n      if (K && (K.props.groupable || K.props.individualGroupable)) {\n        var nt = K.moveables || [], tt = find$1(nt, function(it) {\n          return it.props.target === et;\n        });\n        tt && (W = __assign$1({}, tt.state));\n      }\n      return createElement(MoveableManager$1, __assign$1({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, q, {\n        target: et,\n        firstRenderState: W\n      }));\n    }\n  }, e.componentDidMount = function() {\n    this._checkChangeTargets(), this._updateRefs();\n  }, e.componentDidUpdate = function() {\n    this._checkChangeTargets();\n  }, e.componentWillUnmount = function() {\n    this.selectorMap = {}, this.refTargets = [];\n  }, e.getTargets = function() {\n    var r, D;\n    return (D = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && D !== void 0 ? D : [];\n  }, e.updateSelectors = function() {\n    this.selectorMap = {}, this._updateRefs();\n  }, e.waitToChangeTarget = function() {\n    var r = this, D;\n    return this._onChangeTargets = function() {\n      r._onChangeTargets = null, D();\n    }, new Promise(function(N) {\n      D = N;\n    });\n  }, e.waitToChangeTargets = function() {\n    return this.waitToChangeTarget();\n  }, e.getManager = function() {\n    return this.moveable;\n  }, e._updateRefs = function(r) {\n    var D = this.refTargets, N = getRefTargets(this.props.target || this.props.targets), k = typeof document < \"u\", $ = compareRefTargets(D, N), G = this.selectorMap, U = {};\n    return this.refTargets.forEach(function z(X) {\n      if (isString(X)) {\n        var V = G[X];\n        V ? U[X] = G[X] : k && ($ = !0, U[X] = [].slice.call(document.querySelectorAll(X)));\n      } else\n        isArray(X) && X.forEach(z);\n    }), this.refTargets = N, this.selectorMap = U, !r && $ && this.forceUpdate(), N;\n  }, e._checkChangeTargets = function() {\n    var r, D, N, k = this._differ.update(this._elementTargets), $ = k.added, G = k.removed, U = $.length || G.length;\n    U && ((D = (r = this.props).onChangeTargets) === null || D === void 0 || D.call(r, {\n      moveable: this.moveable,\n      targets: this._elementTargets\n    }), (N = this._onChangeTargets) === null || N === void 0 || N.call(this)), this._updateRefs();\n  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, \"moveable\", void 0), t;\n}(PureComponent), Moveable$1 = /* @__PURE__ */ function(o) {\n  __extends$1(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return t.defaultAbles = MOVEABLE_ABLES, t;\n}(InitialMoveable), Moveable$2 = Moveable$1;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(o, t) {\n  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var D in r)\n      r.hasOwnProperty(D) && (e[D] = r[D]);\n  }, extendStatics(o, t);\n};\nfunction __extends(o, t) {\n  extendStatics(o, t);\n  function e() {\n    this.constructor = o;\n  }\n  o.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign = function() {\n  return __assign = Object.assign || function(t) {\n    for (var e, r = 1, D = arguments.length; r < D; r++) {\n      e = arguments[r];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign.apply(this, arguments);\n};\nfunction __decorate(o, t, e, r) {\n  var D = arguments.length, N = D < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, k;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    N = Reflect.decorate(o, t, e, r);\n  else\n    for (var $ = o.length - 1; $ >= 0; $--)\n      (k = o[$]) && (N = (D < 3 ? k(N) : D > 3 ? k(t, e, N) : k(t, e)) || N);\n  return D > 3 && N && Object.defineProperty(t, e, N), N;\n}\nvar InnerMoveable = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t(r) {\n    var D = o.call(this, r) || this;\n    return D.state = {}, D.state = D.props, D;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    return createPortal(createElement(Moveable$2, __assign({\n      ref: ref(this, \"moveable\")\n    }, this.state)), this.state.parentElement);\n  }, t;\n}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS, MoveableManager = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t(r, D) {\n    D === void 0 && (D = {});\n    var N = o.call(this) || this;\n    N.tempElement = document.createElement(\"div\");\n    var k = __assign({}, D), $ = {};\n    EVENTS.forEach(function(U) {\n      $[camelize(\"on \".concat(U))] = function(z) {\n        return N.trigger(U, z);\n      };\n    }), render(createElement(InnerMoveable, __assign({\n      ref: ref(N, \"innerMoveable\"),\n      parentElement: r\n    }, k, $)), N.tempElement);\n    var G = k.target;\n    return isArray(G) && G.length > 1 && N.updateRect(), N;\n  }\n  var e = t.prototype;\n  return e.setState = function(r, D) {\n    this.innerMoveable.setState(r, D);\n  }, e.forceUpdate = function(r) {\n    this.innerMoveable.forceUpdate(r);\n  }, e.dragStart = function(r) {\n    var D = this.innerMoveable;\n    D.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);\n  }, e.destroy = function() {\n    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;\n  }, e.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  }, t = __decorate([Properties(METHODS, function(r, D) {\n    r[D] || (r[D] = function() {\n      for (var N = [], k = 0; k < arguments.length; k++)\n        N[k] = arguments[k];\n      var $ = this.getMoveable();\n      if (!(!$ || !$[D]))\n        return $[D].apply($, N);\n    });\n  }), Properties(PROPERTIES, function(r, D) {\n    Object.defineProperty(r, D, {\n      get: function() {\n        return this.getMoveable().props[D];\n      },\n      set: function(N) {\n        var k;\n        this.setState((k = {}, k[D] = N, k));\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  })], t), t;\n}(EventEmitter$1), Moveable = /* @__PURE__ */ function(o) {\n  __extends(t, o);\n  function t() {\n    return o !== null && o.apply(this, arguments) || this;\n  }\n  return t;\n}(MoveableManager), Ur, js, zs, Hs, Vs, Mo, _n, yn, Ro, nf;\nconst zt = class {\n  constructor(t, e = !1) {\n    // divでmovを更新\n    rt(this, Ro);\n    Ot(this, \"hArg\", {});\n    Ot(this, \"id_tag\", \"\");\n    Ot(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0\n    });\n    Ot(this, \"child\");\n    Ot(this, \"parent\");\n    Ot(this, \"fncLay\", () => {\n    });\n    Ot(this, \"mov\");\n    Ot(this, \"div\");\n    Ot(this, \"lx\", 0);\n    // これ以後の this変数スケールは SKYNovel スクリプト値\n    Ot(this, \"ly\", 0);\n    Ot(this, \"rect\", Rectangle.EMPTY);\n    // cvsResizeBaseやhint座標など計算用\n    Ot(this, \"pivot\", new Point(0, 0));\n    Ot(this, \"scale\", new Point(1, 1));\n    Ot(this, \"rotation\", 0);\n    Ot(this, \"oldFn\", () => \"\");\n    Ot(this, \"rotatable\", !0);\n    this.bg_col = t, this.isLay = e;\n  }\n  static init(t, e, r, D, N, k, $) {\n    zt.sys = e, ot(zt, js, r), zt.prpPrs = D, ot(zt, zs, N), ot(zt, Hs, k), zt.hPages = $, Main.cvs.insertAdjacentHTML(\"beforebegin\", `<div id=\"${H(zt, Vs)}\" style=\"width: ${CmnLib.stageW * e.cvsScale}px; height: ${CmnLib.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`), ot(zt, Ur, document.getElementById(H(zt, Vs))), zt.divHint.classList.add(\"sn_design_hint\"), t.view.parentElement.appendChild(zt.divHint), addStyle(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(t, e, r, D) {\n    zt.divHint.innerHTML = t;\n    const N = window.getComputedStyle(zt.divHint), k = parseFloat(N.width), $ = parseFloat(N.height);\n    zt.divHint.style.cssText = `display: block; left: ${Math.max(10, D.lx + e - k)}px;\n\t\ttop: ${Math.max(10, D.ly + r - $ - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const t = H(zt, Ur).style;\n    t.width = `${CmnLib.stageW * zt.sys.cvsScale}px`, t.height = `${CmnLib.stageH * zt.sys.cvsScale}px`;\n  }\n  destroy() {\n    var t;\n    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(t) {\n    if (!this.includeDesignArg(t))\n      return;\n    this.id_tag || (this.id_tag = t[\":id_tag\"] ?? \"\"), this.hArg = t;\n    const e = t[\":id_dc\"] ?? this.id_tag;\n    H(zt, _n)[e] = this;\n  }\n  includeDesignArg(t) {\n    return Object.keys(t).some((e) => e in this.hDesignArg);\n  }\n  getRect() {\n    return Rectangle.EMPTY;\n  }\n  cnvPosArg(t, e) {\n    return {};\n  }\n  cnvSizeArg(t, e) {\n    return {};\n  }\n  setPos(t, e) {\n  }\n  setSize(t, e) {\n  }\n  setOther(t) {\n  }\n  adopt(t) {\n    this.child = t, t.parent = this;\n  }\n  static enterMode() {\n    zt.leaveMode(), H(zt, Ur).style.display = \"inline\", ot(zt, Mo, 0), ot(zt, _n, {});\n  }\n  static allHide() {\n    H(zt, yn).forEach((t) => t.visible = !1);\n  }\n  set visible(t) {\n    !this.div || !this.mov || (this.div.style.display = t ? \"inline\" : \"none\", this.mov.updateTarget());\n  }\n  static leaveMode() {\n    H(zt, Ur).textContent = \"\", H(zt, Ur).style.display = \"none\", H(zt, yn).forEach((t) => t.destroy()), ot(zt, yn, []);\n  }\n  cvsResize() {\n    var t;\n    lt(this, Ro, nf).call(this), (t = this.mov) == null || t.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    const t = this.hArg[\":id_dc\"] ?? this.id_tag;\n    H(zt, _n)[t] = this;\n    const e = this.div = document.createElement(\"div\");\n    e.id = H(zt, Vs) + \"_\" + ++Ie(zt, Mo)._, e.classList.add(\"sn_design_cast\"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = \"none\", this.rect = this.getRect(), lt(this, Ro, nf).call(this), (this.parent ? document.querySelector(\n      `[data-id_dc=\"${this.parent.id_tag}\"]`\n      // 親なので\n    ) ?? H(zt, Ur) : H(zt, Ur)).appendChild(e);\n    const r = {\n      // movがdivを操作する際の雑用。スケールはHTML DOM\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    }, D = () => {\n      r.aPos = [NaN, NaN], r.roDeg = this.rotation;\n      const G = this.pivot.x * zt.sys.cvsScale, U = this.pivot.y * zt.sys.cvsScale;\n      r.trOrg = `${G}px ${U}px`, r.origin = [G, U];\n    }, N = (G) => {\n      zt.sys.send2Dbg(\"_changeCast\", {\n        ...G,\n        \":id_tag\": this.id_tag\n      }), zt.divHint.style.display = \"none\";\n    }, k = () => {\n      const [G, U] = r.aPos;\n      if (isNaN(G)) {\n        zt.divHint.style.display = \"none\";\n        return;\n      }\n      const z = int(this.rect.x += G / zt.sys.cvsScale + this.pivot.x), X = int(this.rect.y += U / zt.sys.cvsScale + this.pivot.y);\n      this.setPos(z, X);\n      const V = uint(this.rect.width), Y = uint(this.rect.height);\n      this.setSize(V, Y), N({\n        ...this.cnvPosArg(z, X),\n        ...this.cnvSizeArg(V, Y)\n      });\n    };\n    let $;\n    this.mov = new Moveable(document.body, {\n      target: e,\n      draggable: !0,\n      resizable: !0,\n      //\tscalable\t: true,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: !0\n    }).on(\"dragStart\", (G) => {\n      var z;\n      D(), this.onDragStart();\n      const U = (z = this.child) == null ? void 0 : z.mov;\n      U && ($ = U.target, U.isInside(G.clientX, G.clientY) && (U.target = void 0));\n    }).on(\"drag\", (G) => {\n      r.aPos = G.beforeTranslate, this.procDragHint(G, G.left, G.top);\n    }).on(\"dragEnd\", () => {\n      var G, U;\n      k(), (G = this.child) != null && G.mov && (this.child.mov.target = $), (U = this.parent) != null && U.mov && (this.parent.mov.target = this.parent.div);\n    }).on(\"resizeStart\", D).on(\"resize\", (G) => {\n      e.style.width = `${G.width}px`, e.style.height = `${G.height}px`, r.aPos = G.drag.beforeTranslate, this.rect.width = G.width / zt.sys.cvsScale, this.rect.height = G.height / zt.sys.cvsScale, this.procResizeHint(G, G.drag.left, G.drag.top);\n    }).on(\"resizeEnd\", k).on(\"rotateStart\", (G) => {\n      D(), G.set(r.roDeg);\n    }).on(\"rotate\", (G) => {\n      r.roDeg = G.beforeRotate, zt.setHint(int(r.roDeg) + \"度\", G.drag.left, G.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = r.roDeg, this.setOther({}), N({ rotation: int(r.roDeg) });\n    }).on(\"dragOriginStart\", () => D).on(\"dragOrigin\", (G) => {\n      r.trOrg = G.transformOrigin, r.origin = G.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [G, U] = r.origin;\n      r.trOrg = `${G}px ${U}px`;\n      const z = this.pivot.x = G / zt.sys.cvsScale, X = this.pivot.y = U / zt.sys.cvsScale;\n      this.setOther({});\n      const V = int(this.rect.x + z), Y = int(this.rect.y + X);\n      this.setPos(V, Y), N({\n        ...this.cnvPosArg(V, Y),\n        pivot_x: int(z),\n        pivot_y: int(X)\n      });\n    }).on(\"render\", () => {\n      const { aPos: G, roDeg: U, trOrg: z } = r;\n      e.style.transformOrigin = z, e.style.transform = `translate(${G[0]}px, ${G[1]}px) rotate(${U}deg)`;\n    }), H(zt, yn).push(this), e.addEventListener(\"dragenter\", () => e.classList.add(\"drag_border\")), e.addEventListener(\"dragover\", (G) => {\n      G.stopPropagation(), G.preventDefault(), G.dataTransfer && (G.dataTransfer.dropEffect = \"copy\");\n    }), e.addEventListener(\"dragleave\", () => e.classList.remove(\"drag_border\")), e.addEventListener(\"drop\", (G) => {\n      G.stopPropagation(), G.preventDefault(), e.classList.remove(\"drag_border\");\n      const U = G.dataTransfer;\n      if (!U || U.files.length === 0)\n        return;\n      const z = U.files[0], X = {\n        \":id_tag\": this.id_tag,\n        fn: getFn(z.name),\n        ext: getExt(z.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: H(zt, Hs).searchPath(this.oldFn(), SEARCH_PATH_ARG_EXT.SP_GSM)\n      };\n      z.arrayBuffer().then((V) => {\n        X.buf = V;\n        try {\n          X.url = H(zt, js).cnvPath4Dbg(\n            H(zt, Hs).searchPath(z.name, SEARCH_PATH_ARG_EXT.SP_GSM)\n          );\n        } catch {\n        }\n        zt.sys.send2Dbg(\"_dropFile\", X);\n      }).catch((V) => console.error(\"drop2dc %o\", V));\n    }), e.addEventListener(\"dblclick\", (G) => {\n      G.preventDefault(), zt.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(t, e, r) {\n    const [D, N] = t.beforeTranslate;\n    zt.setHint(\n      `(${int(this.rect.x + D / zt.sys.cvsScale)}, ${int(this.rect.y + N / zt.sys.cvsScale)})`,\n      e,\n      r,\n      this\n    );\n  }\n  procResizeHint(t, e, r) {\n    zt.setHint(\n      `(${int(t.drag.left)}, ${int(t.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,\n      e,\n      r,\n      this\n    );\n  }\n  static replaceToken(t) {\n    var z, X, V, Y, q, W, K, Z;\n    const r = t[\":id_tag\"], D = H(zt, _n)[r];\n    if (!document.querySelector(`div[data-id_dc='${r}']`) || !D)\n      return;\n    const k = t[\":token\"];\n    H(zt, js).replace(t[\":idx_tkn\"], k);\n    const [$, G] = tagToken2Name_Args(k);\n    D.child && (D.child.hArg[\":token\"] = D.hArg[\":token\"]), H(zt, zs).parse(G);\n    const U = H(zt, zs).hPrm;\n    if (\"pivot_x\" in U || \"pivot_y\" in U) {\n      const J = Number(zt.prpPrs.getValAmpersand(U.pivot_x.val)), Q = Number(zt.prpPrs.getValAmpersand(U.pivot_y.val));\n      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`pivot_xかpivot_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${k}`, \"F\"), D.pivot.set(J, Q);\n    }\n    if (\"left\" in U || \"top\" in U || \"x\" in U || \"y\" in U) {\n      const J = int(zt.prpPrs.getValAmpersand(((z = U.left) == null ? void 0 : z.val) ?? ((X = U.x) == null ? void 0 : X.val) ?? \"0\")), Q = int(zt.prpPrs.getValAmpersand(((V = U.top) == null ? void 0 : V.val) ?? ((Y = U.y) == null ? void 0 : Y.val) ?? \"0\"));\n      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${k}`, \"F\"), D.rect.x = J - D.pivot.x, D.rect.y = Q - D.pivot.y, D.setPos(J, Q);\n    }\n    if (\"width\" in U || \"height\" in U) {\n      const J = int(zt.prpPrs.getValAmpersand(((q = U.width) == null ? void 0 : q.val) ?? \"0\")), Q = int(zt.prpPrs.getValAmpersand(((W = U.height) == null ? void 0 : W.val) ?? \"0\"));\n      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${k}`, \"F\"), D.rect.width = J, D.rect.height = Q, D.setSize(J, Q);\n    }\n    if (\"scale_x\" in U || \"scale_y\" in U) {\n      const J = Number(zt.prpPrs.getValAmpersand(((K = U.scale_x) == null ? void 0 : K.val) ?? \"0\")), Q = Number(zt.prpPrs.getValAmpersand(((Z = U.scale_y) == null ? void 0 : Z.val) ?? \"0\"));\n      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`scale_xかscale_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${k}`, \"F\"), D.scale.set(J, Q);\n    }\n    if (\"rotation\" in U) {\n      const J = Number(zt.prpPrs.getValAmpersand(U.rotation.val));\n      isNaN(J) && DebugMng.myTrace(`rotationが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${k}`, \"F\"), D.rotation = J;\n    }\n    D.setOther(U), D.cvsResize();\n  }\n};\nlet DesignCast = zt;\nUr = new WeakMap(), js = new WeakMap(), zs = new WeakMap(), Hs = new WeakMap(), Vs = new WeakMap(), Mo = new WeakMap(), _n = new WeakMap(), yn = new WeakMap(), Ro = new WeakSet(), nf = function() {\n  this.fncLay(), this.div && Object.assign(this.div.style, {\n    left: `${this.lx + this.rect.x * zt.sys.cvsScale}px`,\n    top: `${this.ly + this.rect.y * zt.sys.cvsScale}px`,\n    width: `${this.rect.width * zt.sys.cvsScale}px`,\n    height: `${this.rect.height * zt.sys.cvsScale}px`,\n    transformOrigin: `${this.pivot.x * zt.sys.cvsScale}px ${this.pivot.y * zt.sys.cvsScale}px`,\n    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n  });\n}, rt(DesignCast, Ur, void 0), Ot(DesignCast, \"sys\"), rt(DesignCast, js, void 0), Ot(DesignCast, \"prpPrs\"), rt(DesignCast, zs, void 0), rt(DesignCast, Hs, void 0), Ot(DesignCast, \"hPages\"), Ot(DesignCast, \"divHint\", document.createElement(\"div\")), rt(DesignCast, Vs, \"DesignMode\"), rt(DesignCast, Mo, 0), rt(DesignCast, _n, {}), rt(DesignCast, yn, []);\nvar Bi;\nclass GrpLayDesignCast extends DesignCast {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    rt(this, Bi, void 0);\n    Ot(this, \"oldFn\", () => this.hArg.fn ?? \"\");\n    this.spLay = e, this.gl = r;\n  }\n  setSp(e) {\n    ot(this, Bi, e);\n  }\n  getRect() {\n    var e, r;\n    return new Rectangle(this.spLay.x, this.spLay.y, ((e = H(this, Bi)) == null ? void 0 : e.width) ?? 0, ((r = H(this, Bi)) == null ? void 0 : r.height) ?? 0);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.x = e, this.spLay.y = r;\n  }\n  setSize(e, r) {\n    H(this, Bi).width = e, H(this, Bi).height = r;\n  }\n  setOther(e) {\n    if (\"fn\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.fn.val);\n      this.gl.lay({ fn: r });\n    }\n    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nBi = new WeakMap();\nclass TxtLayDesignCast extends DesignCast {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    Ot(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0,\n      pl: 0,\n      pr: 0,\n      pt: 0,\n      pb: 0\n    });\n    this.spLay = e, this.ts = r;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(this.spLay.x, this.spLay.y, e.$width, e.$height);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay(this.cnvSizeArg(e, r));\n  }\n  setOther(e) {\n    var r;\n    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nvar Oo, sf;\nclass TxtLayPadDesignCast extends DesignCast {\n  constructor(e) {\n    super(\"#9e2\");\n    rt(this, Oo);\n    Ot(this, \"rotatable\", !1);\n    this.ts = e;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(\n      e.pad_left,\n      e.pad_top,\n      e.$width - e.pad_left - e.pad_right,\n      e.$height - e.pad_top - e.pad_bottom\n    );\n  }\n  cnvPosArg(e, r) {\n    return { pl: e, pt: r };\n  }\n  cnvSizeArg(e, r) {\n    const D = this.ts.infTL;\n    return {\n      pr: D.$width - D.pad_left - e,\n      pb: D.$height - D.pad_top - r\n    };\n  }\n  setPos(e, r) {\n    this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay({ ...this.cnvSizeArg(e, r), \":redraw\": !0 });\n  }\n  setOther(e) {\n    var D, N, k, $;\n    const r = this.ts.infTL;\n    if ((\"pl\" in e || \"pt\" in e) && (this.setPos(\n      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        ((D = e.pl) == null ? void 0 : D.val) ?? `${r.pad_left}`\n      )),\n      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        ((N = e.pt) == null ? void 0 : N.val) ?? `${r.pad_top}`\n      ))\n    ), this.cvsResize()), \"pr\" in e || \"pb\" in e) {\n      this.ts.lay({\n        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          ((k = e.pr) == null ? void 0 : k.val) ?? `${r.pad_right}`\n        )),\n        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          (($ = e.pb) == null ? void 0 : $.val) ?? `${r.pad_bottom}`\n        ))\n      });\n      const G = this.getRect();\n      this.setSize(\n        this.rect.width = G.width,\n        this.rect.height = G.height\n      ), this.cvsResize();\n    }\n  }\n  procDragHint(e, r, D) {\n    const [N, k] = e.beforeTranslate;\n    lt(this, Oo, sf).call(this, r, D, N, k);\n  }\n  procResizeHint(e, r, D) {\n    const [N, k] = e.drag.beforeTranslate;\n    lt(this, Oo, sf).call(this, r, D, N, k);\n  }\n}\nOo = new WeakSet(), sf = function(e, r, D, N) {\n  const k = this.rect.x, $ = this.rect.y, G = this.rect.width, U = this.rect.height, z = this.ts.infTL, X = int(k + D / DesignCast.sys.cvsScale), V = int($ + N / DesignCast.sys.cvsScale), Y = int(z.$width - X - G), q = int(z.$height - V - U), W = (K) => \"&nbsp;\".repeat(K);\n  DesignCast.setHint(\n    W(5 + 5 + 1) + `上幅=${V}<br/>\n\t\t\t左幅=${X + W(1 + 3 + 5 + 1)}右幅=${Y}<br/>` + W(5) + `内側 ${int(G)} x ${int(U)}<br/>` + W(5 + 5) + `下幅=${q}`,\n    e,\n    r,\n    this\n  );\n};\nclass BtnDesignCast extends DesignCast {\n  constructor(t, e) {\n    super(\"#e92\"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x), this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y), this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x), this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y), this.rotation = argChk_Num(e, \"rotation\", this.rotation), this.sethArg(e);\n  }\n  sethArg(t) {\n    super.sethArg(t);\n    const e = this.hArg.layer ?? \"\";\n    this.fncLay = !this.parent && !this.child && e ? () => {\n      const r = DesignCast.hPages[e].fore;\n      this.lx = r.x * DesignCast.sys.cvsScale, this.ly = r.y * DesignCast.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.btn.x = t, this.btn.y = e;\n  }\n  setOther(t) {\n    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n  }\n}\nclass TxtBtnDesignCast extends BtnDesignCast {\n  constructor(e, r, D) {\n    super(e, r);\n    Ot(this, \"oldFn\", () => this.hArg.b_pic ?? \"\");\n    this.txt = D, argChk_Boolean(r, \"design\", !0) || (this.setPos = () => {\n    }, this.setSize = () => {\n    });\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(e, r) {\n    this.txt.width = e, this.txt.height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"b_pic\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.b_pic.val ?? \"\");\n      this.btn.update_b_pic(r, this.txt);\n    }\n  }\n}\nvar si;\nclass PicBtnDesignCast extends BtnDesignCast {\n  constructor(e, r) {\n    super(e, r);\n    rt(this, si, void 0);\n    Ot(this, \"oldFn\", () => this.hArg.pic ?? \"\");\n  }\n  setSp(e) {\n    ot(this, si, e);\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, H(this, si).width, H(this, si).height);\n  }\n  setSize(e, r) {\n    H(this, si).width = e, H(this, si).height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"pic\" in e) {\n      const r = DesignCast.prpPrs.getValAmpersand(e.pic.val);\n      this.btn.update_pic(r, H(this, si));\n    }\n  }\n}\nsi = new WeakMap();\nvar nh, Fi, ai, bn, xn, jr, Xs, Sn, Io, Ys, zr, oi, li, $i, Do, Ao, No, sh, fd, ah, dd, Lo, af, oh, pd, Ws, fu, qs, Pr, Ks, lh, En, ko;\nconst Yt = class extends Layer {\n  constructor() {\n    super();\n    rt(this, zr, new GrpLayDesignCast(this.spLay, this));\n    rt(this, oi, \"\");\n    rt(this, li, \"\");\n    rt(this, $i, \"\");\n    Ot(this, \"lay\", (e) => this.laySub(e, (r) => {\n      r && H(Yt, ai).resume();\n    }));\n    rt(this, Do, 0);\n    rt(this, Ao, 0);\n    rt(this, qs, void 0);\n    rt(this, Pr, void 0);\n    rt(this, Ks, () => {\n    });\n    Ot(this, \"record\", () => ({\n      ...super.record(),\n      sBkFn: H(this, li),\n      sBkFace: H(this, $i),\n      idc_hArg: H(this, zr).gethArg()\n    }));\n    //showDesignCastChildren() {}\n    Ot(this, \"dump\", () => super.dump() + `, \"pic\":\"${H(this, oi)}\"`);\n    CmnLib.isDbg && (this.setSp = (e) => H(this, zr).setSp(e), this.cvsResize = () => {\n      super.cvsResize(), H(this, zr).cvsResize();\n    });\n  }\n  static init(e, r, D, N, k, $) {\n    ot(Yt, ai, e), ot(Yt, bn, r), ot(Yt, xn, D), ot(Yt, jr, N), ot(Yt, Xs, $);\n    const G = () => {\n      const U = H(Yt, Sn) * H(Yt, Io);\n      for (const z of Object.values(Yt.hFn2VElm))\n        z.volume = U;\n    };\n    k.setNoticeChgVolume(\n      (U) => {\n        ot(Yt, Sn, U), G();\n      },\n      (U) => {\n        ot(Yt, Io, U), G();\n      }\n    ), H(Yt, jr).crypto && ot(Yt, No, lt(Yt, ah, dd));\n  }\n  static setEvtMng(e) {\n    ot(Yt, Ys, e);\n  }\n  static destroy() {\n    H(Yt, nh).clear(), ot(Yt, Fi, {}), Yt.hFn2ResAniSpr = {}, Yt.hFn2VElm = {};\n  }\n  setSp(e) {\n  }\n  laySub(e, r) {\n    var G;\n    lt(G = Yt, Ws, fu).call(G, H(this, li));\n    const { fn: D, face: N = \"\" } = e;\n    if (H(this, zr).sethArg(e), !D)\n      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), ot(this, li, \"\"), ot(this, oi, ot(this, $i, N)), r(!1), !1;\n    const k = \"fn\" in e, $ = \"face\" in e;\n    return this.clearLay({ filter: \"true\" }), k && ot(this, li, D), $ && ot(this, $i, N), super.lay(e), e.dx = 0, e.dy = 0, Yt.csv2Sprites(\n      ot(this, oi, D + (N ? \",\" + N : \"\")),\n      this.spLay,\n      (U) => {\n        (\"width\" in e || \"height\" in e) && (U.width = argChk_Num(e, \"width\", 0), U.height = argChk_Num(e, \"height\", 0)), ot(this, Do, U.width), ot(this, Ao, U.height), Layer.setXY(U, e, this.spLay, !0), this.setSp(U);\n      },\n      (U) => {\n        Layer.setBlendmode(this.spLay, e), r(U);\n      }\n    );\n  }\n  get width() {\n    return H(this, Do);\n  }\n  get height() {\n    return H(this, Ao);\n  }\n  //\tstatic #ldrHFn: {[name: string]: 1} = {};\n  static csv2Sprites(e, r, D, N = () => {\n  }) {\n    let k = !1;\n    if (e.slice(0, 5) === \"data:\") {\n      const z = () => {\n        const X = Sprite.from(e);\n        r == null || r.addChild(X), D(X), N(k);\n      };\n      return e in TextureCache ? z() : (k = !0, new Loader().add(e, e).load(z)), k;\n    }\n    const $ = [], G = new Loader();\n    e.split(\",\").forEach((z, X) => {\n      if (!z)\n        throw \"face属性に空要素が含まれます\";\n      const { dx: V, dy: Y, blendmode: q, fn: W } = H(Yt, Fi)[z] || {\n        fn: z,\n        dx: 0,\n        dy: 0,\n        blendmode: BLEND_MODES.NORMAL\n      }, K = X === 0 ? D : (Q) => {\n        Q.x = V, Q.y = Y, Q.blendMode = q;\n      };\n      if ($.push({ fn: W, fnc: K }), W in Yt.hFn2ResAniSpr || W in TextureCache || W in Loader.shared.resources)\n        return;\n      k = !0;\n      const Z = H(Yt, bn).searchPath(W, SEARCH_PATH_ARG_EXT.SP_GSM), J = H(this, jr).crypto ? { xhrType: Z.slice(-5) === \".json\" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};\n      G.add({ ...J, name: W, url: Z });\n    });\n    const U = (z) => {\n      var X;\n      for (const { fn: V, fnc: Y } of $) {\n        const q = lt(X = Yt, oh, pd).call(X, V, z);\n        q.name = V, r == null || r.addChild(q), Y(q);\n      }\n      N(k);\n    };\n    return k ? G.use((z, X) => {\n      H(this, jr).dec(z.extension, z.data).then((V) => {\n        var Y;\n        return H(Y = Yt, No).call(Y, V, z, () => X == null ? void 0 : X());\n      }).catch((V) => H(this, ai).errScript(`Graphic ロード失敗です fn:${z.name} ${V}`, !1));\n    }).load((z, X) => U(X)) : U({}), k;\n  }\n  static wv(e) {\n    var k;\n    const { fn: r } = e;\n    if (!r)\n      throw \"fnは必須です\";\n    const D = Yt.hFn2VElm[r];\n    if (!D || D.loop)\n      return !1;\n    if (H(this, Xs).getVal(\"tmp:sn.skip.enabled\") || H(this, Ys).isSkippingByKeyDown() || D.ended)\n      return lt(k = Yt, Ws, fu).call(k, r), !1;\n    const N = () => {\n      var $;\n      lt($ = Yt, Ws, fu).call($, r), H(this, ai).resume();\n    };\n    return D.addEventListener(\"ended\", N, { once: !0, passive: !0 }), H(Yt, Ys).waitEvent(\n      () => {\n        D.removeEventListener(\"ended\", N), N();\n      },\n      argChk_Boolean(e, \"canskip\", !0),\n      argChk_Boolean(e, \"global\", !1)\n    );\n  }\n  renderStart() {\n    ot(this, qs, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), ot(this, Pr, new Sprite(H(this, qs))), H(this, Pr).visible = !1, this.spLay.addChildAt(H(this, Pr), 0), H(this, Pr).position.set(-this.spLay.x, -this.spLay.y);\n    let e = () => {\n      const r = this.spLay.alpha;\n      this.spLay.alpha = 1;\n      for (const D of this.spLay.children)\n        D.visible = !0;\n      H(this, Pr).visible = !1, H(Yt, xn).renderer.render(this.spLay, { renderTexture: H(this, qs) }), this.spLay.alpha = r;\n      for (const D of this.spLay.children)\n        D.visible = !1;\n    };\n    if (!this.containMovement) {\n      let r = e;\n      e = () => {\n        e = () => {\n        }, r();\n      };\n    }\n    ot(this, Ks, () => {\n      e(), H(this, Pr).visible = !0;\n    }), H(Yt, xn).ticker.add(H(this, Ks));\n  }\n  renderEnd() {\n    H(Yt, xn).ticker.remove(H(this, Ks)), this.spLay.removeChild(H(this, Pr));\n    for (const e of this.spLay.children)\n      e.visible = !0;\n    H(this, Pr).destroy(!0);\n  }\n  // https://regex101.com/r/ZUnoFq/1\n  static loadPic2Img(e, r, D) {\n    const N = e.replace(H(Yt, lh), \"\"), k = e === N ? \"\" : e.slice(N.length), $ = H(this, ko)[e];\n    if ($) {\n      r.src = $;\n      return;\n    }\n    const G = H(this, En)[e];\n    if (G) {\n      G.push(r);\n      return;\n    }\n    H(this, En)[e] = [r];\n    const U = H(Yt, bn).searchPath(N, SEARCH_PATH_ARG_EXT.SP_GSM), z = new Loader().add({ name: e, url: U, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });\n    H(Yt, jr).crypto && getExt(U) === \"bin\" && z.use((X, V) => {\n      H(Yt, jr).dec(X.extension, X.data).then((Y) => {\n        if (X.extension !== \"bin\") {\n          V == null || V();\n          return;\n        }\n        X.data = Y, Y instanceof HTMLImageElement && (X.type = LoaderResource.TYPE.IMAGE), V == null || V();\n      }).catch((Y) => H(Yt, ai).errScript(`GrpLayer loadPic ロード失敗です fn:${X.name} ${Y}`, !1));\n    }), z.load((X, V) => {\n      for (const [Y, { data: { src: q } }] of Object.entries(V)) {\n        const W = H(this, ko)[Y] = q + (q.slice(0, 5) === \"blob:\" ? \"\" : k);\n        for (const K of H(this, En)[Y])\n          K.src = W, D && (K.onload = () => D(K));\n        delete H(this, En)[Y];\n      }\n    });\n  }\n  setPos(e) {\n    Layer.setXY(\n      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],\n      e,\n      this.spLay,\n      !0\n    );\n  }\n  static add_face(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (r in H(Yt, Fi))\n      throw \"一つのname（\" + r + \"）に対して同じ画像を複数割り当てられません\";\n    const { fn: D = r } = e;\n    return H(Yt, Fi)[r] = {\n      fn: D,\n      dx: argChk_Num(e, \"dx\", 0),\n      dy: argChk_Num(e, \"dy\", 0),\n      blendmode: Layer.getBlendmodeNum(e.blendmode || \"\")\n    }, !1;\n  }\n  static clearFace2Name() {\n    ot(Yt, Fi, {});\n  }\n  // アニメ・動画を含むか\n  get containMovement() {\n    if (H(this, oi) === \"\")\n      return !1;\n    const e = this.spLay.children;\n    return H(this, oi).split(\",\").some(\n      (r, D) => e[D] instanceof AnimatedSprite || Yt.hFn2VElm[r]\n    );\n  }\n  clearLay(e) {\n    super.clearLay(e);\n    for (const r of this.spLay.removeChildren())\n      r.destroy();\n    ot(this, li, \"\"), ot(this, $i, \"\"), ot(this, oi, \"\");\n  }\n  playback(e, r) {\n    if (super.playback(e, r), e.sBkFn === \"\" && e.sBkFace === \"\") {\n      ot(this, li, e.sBkFn), ot(this, $i, e.sBkFace), H(this, zr).sethArg(e.idc_hArg);\n      return;\n    }\n    r.push(new Promise((D) => this.laySub(\n      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: Layer.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },\n      (N) => {\n        this.spLay.position.set(e.x, e.y), D();\n      }\n      // Layer.setXY()の後に再度移動\n    )));\n  }\n  makeDesignCast(e) {\n    this.spLay.visible && e(H(this, zr));\n  }\n  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    H(this, zr).visible = !0;\n  }\n};\nlet GrpLayer = Yt;\nnh = new WeakMap(), Fi = new WeakMap(), ai = new WeakMap(), bn = new WeakMap(), xn = new WeakMap(), jr = new WeakMap(), Xs = new WeakMap(), Sn = new WeakMap(), Io = new WeakMap(), Ys = new WeakMap(), zr = new WeakMap(), oi = new WeakMap(), li = new WeakMap(), $i = new WeakMap(), Do = new WeakMap(), Ao = new WeakMap(), No = new WeakMap(), sh = new WeakSet(), fd = function(e) {\n  const r = /([^\\d]+)\\d+\\.(\\w+)/.exec(e[0]);\n  if (!r)\n    return [];\n  const D = r[1].length, N = -r[2].length - 1;\n  return e.sort(\n    (k, $) => int(k.slice(D, N)) > int($.slice(D, N)) ? 1 : -1\n  );\n}, ah = new WeakSet(), dd = function(e, r, D) {\n  var U;\n  if (r.data = e, r.extension === \"bin\" && (e instanceof HTMLImageElement ? (r.texture = Texture.fromLoader(e, r.url, r.name), r.type = LoaderResource.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = H(Yt, Sn), Yt.hFn2VElm[r.name] = lt(U = Yt, Lo, af).call(U, e), r.type = LoaderResource.TYPE.VIDEO)), r.extension !== \"json\") {\n    D();\n    return;\n  }\n  if (typeof e != \"string\") {\n    D();\n    return;\n  }\n  const { meta: N, frames: k } = r.data = JSON.parse(e);\n  if (r.type = LoaderResource.TYPE.JSON, !(N != null && N.image)) {\n    D();\n    return;\n  }\n  const $ = getFn(N.image), G = H(Yt, bn).searchPath($, SEARCH_PATH_ARG_EXT.SP_GSM);\n  new Loader().use((z, X) => {\n    H(this, jr).dec(z.extension, z.data).then((V) => {\n      z.data = V, V instanceof HTMLImageElement && (z.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(V.src)), X == null || X();\n    }).catch((V) => H(this, ai).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${z.name} ${V}`, !1));\n  }).add({ name: $, url: G, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((z, X) => {\n    for (const { data: V } of Object.values(z.resources)) {\n      const { baseTexture: Y } = Texture.from(V), q = Object.values(k);\n      Yt.hFn2ResAniSpr[r.name] = {\n        aTex: q.map(({ frame: { x: W, y: K, w: Z, h: J } }) => new Texture(\n          Y,\n          new Rectangle(W, K, Z, J)\n        )),\n        meta: N\n      };\n    }\n    D();\n  });\n}, Lo = new WeakSet(), af = function(e) {\n  return H(Yt, Xs).getVal(\"const.sn.needClick2Play\") && (DebugMng.trace_beforeNew(`[lay系] ${DebugMng.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, \"W\"), e.muted = !0), e.setAttribute(\"playsinline\", \"\"), e;\n}, oh = new WeakSet(), pd = function(e, r) {\n  const D = Yt.hFn2ResAniSpr[e];\n  if (D) {\n    const N = new AnimatedSprite(D.aTex);\n    return N.animationSpeed = D.meta.animationSpeed ?? 1, N.play(), N;\n  }\n  return e in TextureCache ? Sprite.from(e) : e in Yt.hFn2VElm ? Sprite.from(Yt.hFn2VElm[e]) : e in r ? new Sprite(r[e].texture) : new Sprite();\n}, Ws = new WeakSet(), fu = function(e) {\n  const r = Yt.hFn2VElm[e];\n  r && (delete Yt.hFn2VElm[e], r.pause(), r.currentTime = r.duration);\n}, qs = new WeakMap(), Pr = new WeakMap(), Ks = new WeakMap(), lh = new WeakMap(), En = new WeakMap(), ko = new WeakMap(), rt(GrpLayer, sh), rt(GrpLayer, ah), rt(GrpLayer, Lo), rt(GrpLayer, oh), rt(GrpLayer, Ws), rt(GrpLayer, nh, new EventListenerCtn()), rt(GrpLayer, Fi, {}), rt(GrpLayer, ai, void 0), rt(GrpLayer, bn, void 0), rt(GrpLayer, xn, void 0), rt(GrpLayer, jr, void 0), rt(GrpLayer, Xs, void 0), rt(GrpLayer, Sn, 1), rt(GrpLayer, Io, 1), rt(GrpLayer, Ys, void 0), Ot(GrpLayer, \"hFn2ResAniSpr\", {}), rt(GrpLayer, No, (e, r, D) => {\n  var N, k;\n  switch (r.type) {\n    case LoaderResource.TYPE.JSON:\n      const $ = r.spritesheet._frameKeys;\n      lt(N = Yt, sh, fd).call(N, $), Yt.hFn2ResAniSpr[r.name] = {\n        aTex: $.map((U) => Texture.from(U)),\n        meta: r.data.meta\n      };\n      break;\n    case LoaderResource.TYPE.VIDEO:\n      const G = r.data;\n      G.volume = H(Yt, Sn), Yt.hFn2VElm[r.name] = lt(k = Yt, Lo, af).call(k, G);\n  }\n  D();\n}), Ot(GrpLayer, \"hFn2VElm\", {}), rt(GrpLayer, lh, /\\?([^?]+)$/), rt(GrpLayer, En, {}), rt(GrpLayer, ko, {});\nvar Zs, Bo, Tn, se, Hr, ui, uh, lr, Gi, Wt, gr, We, qe, Js, du, Mr, hi, Fo, Qs, hh, vd, wn, ta, Ui, Cn, Pn, Mn, ea, $o, ji, Go, of, ci, Uo, fi, Vr, ra, jo, lf, zi, Rn, zo, uf, Qe;\nconst te = class extends Container {\n  constructor(e, r, D) {\n    super();\n    rt(this, Js);\n    rt(this, hh);\n    rt(this, Go);\n    // 「g」などで下が欠ける問題対策\n    rt(this, jo);\n    rt(this, zo);\n    rt(this, se, document.createElement(\"span\"));\n    // サンプリング元\n    rt(this, Hr, new Container());\n    // サンプリング先\n    rt(this, ui, new Graphics());\n    rt(this, lr, new TxtLayDesignCast(this.spLay, this));\n    rt(this, Gi, new TxtLayPadDesignCast(this));\n    rt(this, Wt, {\n      fontsize: 24,\n      $width: 0,\n      // レイヤサイズであり、背景色（画像）サイズ\n      $height: 0,\n      pad_left: 0,\n      // paddingLeft（レイヤサイズの内側のスペーサー）\n      pad_right: 0,\n      // paddingRight\n      pad_top: 0,\n      // paddingTop\n      pad_bottom: 0\n      // paddingBottom\n    });\n    rt(this, gr, !1);\n    rt(this, We, 0);\n    rt(this, qe, 0);\n    rt(this, Mr, 0);\n    rt(this, hi, !1);\n    rt(this, Fo, 0);\n    rt(this, Qs, 0);\n    rt(this, wn, void 0);\n    // 文字にかけるフィルター\n    rt(this, ta, []);\n    rt(this, Ui, []);\n    rt(this, Cn, 0);\n    rt(this, ji, () => !1);\n    rt(this, ra, 0);\n    rt(this, zi, \"Quadratic.Out\");\n    rt(this, Rn, \"Quadratic.Out\");\n    rt(this, Qe, void 0);\n    this.spLay = e, this.canFocus = r, this.sys = D, H(this, se).classList.add(\"sn_tx\"), H(this, se).style.position = \"absolute\", H(te, Bo).view.parentElement.appendChild(H(this, se)), this.addChild(H(this, Hr)), this.addChild(H(this, ui)), H(this, ui).name = \"grpDbgMasume\", H(this, lr).adopt(H(this, Gi));\n  }\n  static init(e, r) {\n    ot(te, Zs, e), ot(te, Bo, r), ot(te, Pn, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), ot(te, Mn, /[［（｛〈「『【〔“〝]/), ot(te, ea, /[─‥…]/);\n  }\n  static setEvtMng(e) {\n    ot(te, Tn, e);\n  }\n  static destroy() {\n    ot(te, ci, /* @__PURE__ */ Object.create(null)), ot(te, fi, /* @__PURE__ */ Object.create(null)), ot(te, Vr, new Container());\n  }\n  lay(e) {\n    const r = H(this, se).style;\n    if (\"style\" in e)\n      if (e.style) {\n        const D = document.createElement(\"span\");\n        D.style.cssText = e.style;\n        const N = D.style.length;\n        for (let k = 0; k < N; ++k) {\n          const $ = D.style[k];\n          if ($ in H(te, uh)) {\n            DebugMng.myTrace(`${$}は指定できません`, \"W\");\n            continue;\n          }\n          r[$] = D.style[$];\n        }\n        !D.style.opacity && \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n      } else\n        H(this, se).style.cssText = \"\";\n    else\n      \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n    if (\"width\" in e && (r.width = (e.width ?? \"0\") + \"px\"), \"height\" in e && (r.height = (e.height ?? \"0\") + \"px\"), \"pl\" in e && (r.paddingLeft = (e.pl ?? \"0\") + \"px\"), \"pr\" in e && (r.paddingRight = (e.pr ?? \"0\") + \"px\"), \"pt\" in e && (r.paddingTop = (e.pt ?? \"0\") + \"px\"), \"pb\" in e && (r.paddingBottom = (e.pb ?? \"0\") + \"px\"), \"kinsoku_sol\" in e && ot(te, Pn, new RegExp(`[${e.kinsoku_sol}]`)), \"kinsoku_eol\" in e && ot(te, Mn, new RegExp(`[${e.kinsoku_eol}]`)), \"kinsoku_dns\" in e && ot(te, ea, new RegExp(`[${e.kinsoku_dns}]`)), lt(this, Js, du).call(this), H(this, lr).sethArg(e), ot(this, Mr, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? \"inline\" : \"none\", r.textShadow = e.filter ?? r.textShadow ?? \"\", ot(this, gr, argChk_Boolean(e, \"break_fixed\", H(this, gr))), ot(this, We, argChk_Num(e, \"break_fixed_left\", H(this, We))), ot(this, qe, argChk_Num(e, \"break_fixed_top\", H(this, qe))), \":redraw\" in e && H(this, Cn) > 0) {\n      const D = [\n        H(this, se).innerHTML.replaceAll(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>　</span>`\n      ];\n      lt(this, zo, uf).call(this), this.goTxt(D, !0);\n    }\n  }\n  cvsResize() {\n    const e = H(this, se).style, r = this.sys.cvsScale;\n    e.left = `${this.sys.ofsLeft4elm + H(this, Mr) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, H(this, lr).cvsResize(), H(this, Gi).cvsResize();\n  }\n  get tategaki() {\n    return H(this, hi);\n  }\n  get infTL() {\n    return H(this, Wt);\n  }\n  get getWidth() {\n    return H(this, Wt).$width;\n  }\n  get getHeight() {\n    return H(this, Wt).$height;\n  }\n  setSize(e, r) {\n    H(this, Wt).$width = e, H(this, Wt).$height = r, H(this, se).style.width = H(this, Wt).$width + \"px\", H(this, se).style.height = H(this, Wt).$height + \"px\";\n  }\n  goTxt(e, r) {\n    var Q, et, nt;\n    H(te, Vr).visible = !1;\n    let D = H(this, Ui).length, N = \"\";\n    if (D === 0) {\n      if (H(te, Zs).oCfg.debug.masume && (CmnLib.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${H(this, Wt).pad_left} pr:${H(this, Wt).pad_right} pt:${H(this, Wt).pad_top} pb:${H(this, Wt).pad_bottom} w:${H(this, Wt).$width} h:${H(this, Wt).$height}`), H(this, ui).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-H(this, Wt).pad_left, -H(this, Wt).pad_top, H(this, Wt).$width, H(this, Wt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(\n        0,\n        0,\n        H(this, Wt).$width - H(this, Wt).pad_left - H(this, Wt).pad_right,\n        H(this, Wt).$height - H(this, Wt).pad_top - H(this, Wt).pad_bottom\n      ).endFill()), H(this, se).innerHTML = [...e].join(\"\").replaceAll(/[\\n\\t]/g, \"\") + H(te, $o), !H(this, gr)) {\n        const tt = globalThis.getComputedStyle(H(this, se)), it = parseFloat(tt.fontSize);\n        H(this, hi) ? (ot(this, We, (H(this, Wt).$width - H(this, Wt).pad_left - H(this, Wt).pad_right - it * 1.5) * this.sys.cvsScale), ot(this, qe, 0)) : (ot(this, We, 0), ot(this, qe, it / 2 * this.sys.cvsScale));\n      }\n    } else\n      N = H(this, se).innerHTML, H(this, se).querySelectorAll(\":scope > br\").forEach((tt) => H(this, se).removeChild(tt)), H(this, se).insertAdjacentHTML(\n        \"beforeend\",\n        e.slice(H(this, Cn)).join(\"\").replaceAll(/[\\n\\t]/g, \"\") + H(te, $o)\n        // 末尾改行削除挙動対策\n      ), --D, (Q = H(this, se).querySelector(\".sn_ch_last\")) == null || Q.remove();\n    ot(this, Cn, e.length);\n    const k = this.sys.cvsScale, $ = H(this, se).getBoundingClientRect(), G = $.left + H(this, Wt).pad_left, U = $.top + H(this, Wt).pad_top;\n    let z;\n    if (k === 1)\n      z = (tt, it) => new Rectangle(\n        tt.left - G,\n        tt.top - U,\n        tt.width,\n        tt.height + (\"gjqy\".includes(it) ? H(this, ra) : 0)\n      );\n    else {\n      const tt = this.sys.ofsPadLeft_Dom2PIXI + $.left * (1 - k), it = this.sys.ofsPadTop_Dom2PIXI + $.top * (1 - k);\n      z = (st, at) => new Rectangle(\n        (st.left - tt) / k - G,\n        (st.top - it) / k - U,\n        st.width / k,\n        (st.height + (\"gjqy\".includes(at) ? H(this, ra) : 0)) / k\n      );\n    }\n    let X = 0, V = 2, Y = !1;\n    do {\n      const tt = ot(this, Ui, lt(this, jo, lf).call(this, H(this, se), z));\n      if (X = tt.length, !Y && (X < 2 || D === X)) {\n        D > 0 && D === X && (H(this, se).innerHTML = N.replaceAll('class=\"sn_ch\"', 'class=\"sn_ch sn_ch_in_default\"'));\n        break;\n      }\n      Y = !0;\n      let it = -1 / 0;\n      for (; V < X; ++V) {\n        const st = tt[V];\n        if (st.elm.tagName === \"RT\")\n          continue;\n        const at = this.tategaki ? st.rect.y : st.rect.x;\n        if (it <= at || ((nt = (et = st.elm.previousElementSibling) == null ? void 0 : et.children[0]) == null ? void 0 : nt.tagName) === \"BR\") {\n          it = at, H(this, gr) || (ot(this, We, st.rect.x), ot(this, qe, st.rect.y));\n          continue;\n        }\n        let ut = V - 1;\n        for (; tt[ut].elm.tagName === \"RT\"; )\n          --ut;\n        const ft = tt[ut], ct = ft.ch;\n        if (!H(this, gr)) {\n          ot(this, We, ft.rect.x), ot(this, qe, ft.rect.y);\n          const _t = globalThis.getComputedStyle(ft.elm), Tt = parseFloat(_t.fontSize);\n          H(this, hi) ? ot(this, qe, H(this, qe) + Tt) : ot(this, We, H(this, We) + Tt);\n        }\n        it = -1 / 0;\n        const vt = V;\n        if (H(te, ea).test(ct) && ct === st.ch)\n          V = ut;\n        else {\n          if (H(te, Mn).test(ct))\n            V = ut;\n          else if (H(te, Pn).test(st.ch))\n            for (V = ut + 1; V > 0 && H(te, Pn).test(tt[--V].ch); )\n              ;\n          else {\n            ++V;\n            continue;\n          }\n          for (V = ut + 1; V > 0 && H(te, Mn).test(tt[--V].ch); )\n            ;\n        }\n        const yt = tt[V].elm.parentElement, mt = document.createElement(\"br\");\n        if (yt.classList.contains(\"sn_tx\"))\n          yt.insertBefore(mt, tt[V].elm);\n        else {\n          const _t = yt.parentElement;\n          _t.classList.contains(\"sn_ch\") ? _t.parentElement.insertBefore(mt, _t) : _t.insertBefore(mt, yt);\n        }\n        V += 2, V < vt && (V = vt), X = -1;\n        break;\n      }\n    } while (X < 0);\n    const q = CmnLib.debugLog ? (tt, it) => console.log(`🍌 masume ch:${tt.ch} x:${it.x} y:${it.y} w:${it.width} h:${it.height}`) : () => {\n    }, W = H(te, Zs).oCfg.debug.masume ? (tt, it) => {\n      q(tt, it), H(this, ui).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(it.x, it.y, it.width, it.height).endFill();\n    } : () => {\n    }, K = CmnTween.ease(H(this, zi));\n    for (let tt = D; tt < X; ++tt) {\n      const it = H(this, Ui)[tt], st = it.rect, at = JSON.parse(it.elm.dataset.arg ?? '{\"delay\": 0}'), ut = JSON.parse(it.elm.dataset.add ?? \"{}\"), ft = H(te, ci)[ut.ch_in_style];\n      if (W(it, st), it.elm.dataset.cmd === \"grp\") {\n        const ct = new Container();\n        H(this, Hr).addChild(ct), GrpLayer.csv2Sprites(at.pic, ct, (vt) => {\n          lt(this, Go, of).call(this, ct, at, ut, st, K, ft ?? {}), ct.parent || ct.removeChild(vt);\n        });\n      }\n      if (it.elm.dataset.lnk) {\n        const ct = it.elm.parentElement.closest(\"[data-arg]\"), vt = JSON.parse(ct.dataset.arg ?? \"{}\");\n        vt.key = `lnk=[${tt}] ` + this.name;\n        const yt = new Sprite();\n        lt(this, Go, of).call(this, yt, vt, ut, st, K, ft ?? {});\n        const mt = vt.style ?? \"\", _t = mt + (vt.style_hover ?? \"\"), Tt = mt + (vt.style_clicked ?? \"\"), Pt = vt.r_style ?? \"\", St = Pt + (vt.r_style_hover ?? \"\"), gt = Pt + (vt.r_style_clicked ?? \"\"), bt = ct.querySelectorAll(\"rt\");\n        bt.forEach((Mt) => Mt.dataset.st_r_bk = Mt.style.cssText);\n        const Nt = ct.style.cssText, At = (Mt, dt) => {\n          ct.style.cssText = Nt + Mt, bt.forEach(($t) => $t.style.cssText = $t.dataset.st_r_bk + dt);\n        };\n        argChk_Boolean(vt, \"enabled\", !0) ? H(te, Tn).button(\n          vt,\n          yt,\n          () => At(mt, Pt),\n          () => this.canFocus() ? (At(_t, St), !0) : !1,\n          () => At(Tt, gt)\n        ) : At(\n          mt + (vt.style_disable ?? \"color: gray;\"),\n          Pt + (vt.r_style_disable ?? \"color: gray;\")\n        ), H(this, Hr).addChild(yt);\n      }\n    }\n    const Z = H(this, se).querySelectorAll(\"span.sn_ch\");\n    ot(this, ji, () => (ot(this, ji, () => !1), Z.forEach((tt) => tt.className = tt.className.replaceAll(/ go_ch_in_[^\\s\"]+/g, \"\")), H(te, Vr).position.set(\n      H(this, We),\n      H(this, qe)\n    ), H(te, Vr).visible = !0, H(te, Tn).noticeCompTxt(), !0)), Z.forEach((tt) => tt.className = tt.className.replaceAll(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\")), D > 0 && ++D;\n    let J;\n    for (let tt = X - 2; tt >= 0; --tt) {\n      const it = H(this, Ui)[tt];\n      if (it.elm.tagName === \"SPAN\") {\n        J = it.elm;\n        break;\n      }\n    }\n    if (!J || r || D === X) {\n      H(this, ji).call(this);\n      return;\n    }\n    J.addEventListener(\"animationend\", H(this, ji), { once: !0, passive: !0 });\n  }\n  skipChIn() {\n    let e = H(this, ji).call(this);\n    for (const r of H(this, ta))\n      r.tw && (r.tw.stop().end(), e = !0);\n    return ot(this, ta, []), e;\n  }\n  static initChStyle() {\n    ot(te, ci, /* @__PURE__ */ Object.create(null)), ot(te, fi, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(e) {\n    return H(te, ci)[e];\n  }\n  static ch_in_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (H(te, Uo).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in H(te, ci))\n      throw `name【${r}】はすでにあります`;\n    const D = String(e.x ?? \"=0\"), N = String(e.y ?? \"=0\");\n    return H(te, ci)[r] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      // アニメ・FI時間\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: D,\n      // 初期x値\n      y: N,\n      // [tsy]と同様に絶対・相対指定可能\n      // {x:500}\t\t\tX位置を500に\n      // {x:'=500'}\t\t現在のX位置に+500加算した位置\n      // {x:'=-500'}\t\t現在のX位置に-500加算した位置\n      // {x:'250,500'}\t+250から＋500までの間でランダムな値をX位置に\n      // {x:'=250,500'}\t+250から＋500までの間でランダムな値を現在のX位置に加算\n      nx: parseFloat(D.at(0) === \"=\" ? D.slice(1) : D),\n      ny: parseFloat(N.at(0) === \"=\" ? N.slice(1) : N),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !0),\n      // 文字を順番に出すか（true）同時か（false）\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  static getChOutStyle(e) {\n    return H(te, fi)[e];\n  }\n  static ch_out_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (H(te, Uo).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in H(te, fi))\n      throw `name【${r}】はすでにあります`;\n    const D = String(e.x ?? \"=0\"), N = String(e.y ?? \"=0\");\n    return H(te, fi)[r] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      // アニメ・FI時間\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: D,\n      // 初期x値\n      y: N,\n      // [tsy]と同様に絶対・相対指定可能\n      // {x:500}\t\t\tX位置を500に\n      // {x:'=500'}\t\t現在のX位置に+500加算した位置\n      // {x:'=-500'}\t\t現在のX位置に-500加算した位置\n      // {x:'250,500'}\t+250から＋500までの間でランダムな値をX位置に\n      // {x:'=250,500'}\t+250から＋500までの間でランダムな値を現在のX位置に加算\n      nx: parseFloat(D.at(0) === \"=\" ? D.slice(1) : D),\n      ny: parseFloat(N.at(0) === \"=\" ? N.slice(1) : N),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !1),\n      // 文字を順番に出すか（true）同時か（false）\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  dispBreak(e) {\n    const r = H(te, Vr);\n    r.visible = !1, this.addChild(r), GrpLayer.csv2Sprites(e, r, (D) => {\n      r.parent || r.removeChild(D);\n    });\n  }\n  static delBreak() {\n    const e = H(te, Vr);\n    e.parent && (e.parent.removeChild(e), e.removeChildren()), ot(te, Vr, new Container());\n  }\n  reNew() {\n    var r;\n    lt(this, zo, uf).call(this);\n    const e = new te(this.spLay, () => this.canFocus(), this.sys);\n    return ot(e, Wt, H(this, Wt)), H(e, se).style.cssText = H(this, se).style.cssText, ot(e, Mr, H(this, Mr)), e.name = this.name, lt(r = e, Js, du).call(r), H(e, lr).sethArg(H(this, lr).gethArg()), ot(e, wn, H(this, wn)), ot(e, zi, H(this, zi)), ot(e, Rn, H(this, Rn)), ot(e, gr, H(this, gr)), ot(e, We, H(this, We)), ot(e, qe, H(this, qe)), this.destroy(), e;\n  }\n  record() {\n    return {\n      infTL: H(this, Wt),\n      cssText: H(this, se).style.cssText,\n      left: H(this, Mr),\n      idc_hArg: H(this, lr).gethArg(),\n      ch_filter: H(this, wn),\n      fi_easing: H(this, zi),\n      fo_easing: H(this, Rn),\n      break_fixed: H(this, gr),\n      break_fixed_left: H(this, We),\n      break_fixed_top: H(this, qe)\n    };\n  }\n  playback(e) {\n    ot(this, Wt, e.infTL), this.position.set(H(this, Wt).pad_left, H(this, Wt).pad_top), H(this, se).style.cssText = e.cssText, ot(this, Mr, e.left), lt(this, Js, du).call(this), H(this, lr).sethArg(e.idc_hArg), ot(this, wn, e.ch_filter), ot(this, zi, e.fi_easing), ot(this, Rn, e.fo_easing), ot(this, gr, e.break_fixed ?? !1), ot(this, We, e.break_fixed_left ?? 0), ot(this, qe, e.break_fixed_top ?? 0);\n  }\n  snapshot(e, r) {\n    lt(this, hh, vd).call(this, (D) => {\n      ot(this, Qe, new Sprite(D)), H(this, hi) && (H(this, Qe).x += CmnLib.stageW - (H(this, Mr) + H(this, Wt).$width)), H(this, Qe).y -= H(this, Qs), H(this, Qe).texture.frame = new Rectangle(\n        0,\n        0,\n        Math.min(H(this, Qe).width, H(this, Wt).$width - H(this, Mr)),\n        Math.min(H(this, Qe).height, H(this, Wt).$height)\n      ), H(this, Hr).addChild(H(this, Qe)), e.render(H(this, Qe), { clear: !1 }), r();\n    }, !1);\n  }\n  snapshot_end() {\n    H(this, Qe) && (H(this, Hr).removeChild(H(this, Qe)), ot(this, Qe, void 0));\n  }\n  makeDesignCast(e) {\n    e(H(this, lr));\n    const r = H(this, lr).gethArg();\n    H(this, Gi).sethArg({ ...r, \":id_dc\": r[\":id_tag\"] + \"_pad\" }), e(H(this, Gi));\n  }\n  showDesignCast() {\n    H(this, lr).visible = !0, H(this, Gi).visible = !0;\n  }\n  dump() {\n    const e = [], r = H(this, se).style, D = r.length;\n    for (let N = 0; N < D; ++N) {\n      const k = r[N];\n      e.push(`\"${k}\":\"${r[k].replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${H(this, se).textContent.replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${e.join(\",\")}}`;\n  }\n  destroy() {\n    te.delBreak(), H(this, se).parentElement.removeChild(H(this, se)), this.removeChild(H(this, Hr)), this.removeChild(H(this, ui)), super.destroy();\n  }\n};\nlet TxtStage = te;\nZs = new WeakMap(), Bo = new WeakMap(), Tn = new WeakMap(), se = new WeakMap(), Hr = new WeakMap(), ui = new WeakMap(), uh = new WeakMap(), lr = new WeakMap(), Gi = new WeakMap(), Wt = new WeakMap(), gr = new WeakMap(), We = new WeakMap(), qe = new WeakMap(), Js = new WeakSet(), du = function() {\n  const e = H(this, se).style, r = parseFloat(e.fontSize || \"0\");\n  H(this, Wt).fontsize = r, H(this, Wt).pad_left = parseFloat(e.paddingLeft || \"0\"), H(this, Wt).pad_right = parseFloat(e.paddingRight || \"0\"), H(this, Wt).pad_top = parseFloat(e.paddingTop || \"0\"), H(this, Wt).pad_bottom = parseFloat(e.paddingBottom || \"0\"), H(this, Wt).$width = parseFloat(e.width || \"0\"), H(this, Wt).$height = parseFloat(e.height || \"0\"), this.position.set(H(this, Wt).pad_left, H(this, Wt).pad_top), ot(this, hi, e.writingMode === \"vertical-rl\"), ot(this, Fo, 0), ot(this, Qs, 0);\n  const D = e.lineHeight ?? \"0\";\n  ot(this, ra, H(this, hi) ? 0 : (D.slice(-2) === \"px\" ? parseFloat(D) : r * parseFloat(D) - r) / 2);\n}, Mr = new WeakMap(), hi = new WeakMap(), Fo = new WeakMap(), Qs = new WeakMap(), hh = new WeakSet(), vd = function(e, r = !0) {\n  const D = {\n    escape: (K) => K.replaceAll(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (K) => {\n      const Z = U(K).toLowerCase();\n      return N()[Z] || \"\";\n    },\n    dataAsUrl: Y,\n    isDataUrl: z,\n    resolveUrl: X,\n    getAndEncode: V,\n    asArray: (K) => {\n      const Z = [], J = K.length;\n      for (let Q = 0; Q < J; ++Q)\n        Z.push(K[Q]);\n      return Z;\n    }\n  };\n  function N() {\n    const K = \"application/font-woff\", Z = \"image/jpeg\";\n    return {\n      woff: K,\n      woff2: K,\n      ttf: \"application/font-truetype\",\n      eot: \"application/vnd.ms-fontobject\",\n      png: \"image/png\",\n      jpg: Z,\n      jpeg: Z,\n      gif: \"image/gif\",\n      tiff: \"image/tiff\",\n      svg: \"image/svg+xml\"\n    };\n  }\n  const k = q(), $ = W();\n  function G(K) {\n    return $.resolveAll().then((Z) => {\n      const J = document.createElement(\"style\");\n      return K.appendChild(J), J.appendChild(document.createTextNode(Z)), K;\n    });\n  }\n  function U(K) {\n    const Z = /\\.([^\\.\\/]*?)$/g.exec(K);\n    return (Z == null ? void 0 : Z[1]) ?? \"\";\n  }\n  function z(K) {\n    return K.search(/^(data:)/) !== -1;\n  }\n  function X(K, Z) {\n    const J = document.implementation.createHTMLDocument(), Q = J.createElement(\"base\");\n    J.head.appendChild(Q);\n    const et = J.createElement(\"a\");\n    return J.body.appendChild(et), Q.href = Z, et.href = K, et.href;\n  }\n  function V(K) {\n    let Z = 3e4;\n    return new Promise(function(J) {\n      const Q = new XMLHttpRequest();\n      Q.onreadystatechange = et, Q.ontimeout = nt, Q.responseType = \"blob\", Q.timeout = Z, Q.open(\"GET\", K, !0), Q.send();\n      function et() {\n        if (Q.readyState !== 4)\n          return;\n        if (Q.status !== 200) {\n          tt(\"cannot fetch resource: \" + K + \", status: \" + Q.status);\n          return;\n        }\n        const it = new FileReader();\n        it.onloadend = function() {\n          const st = it.result.toString().split(/,/)[1];\n          J(st);\n        }, it.readAsDataURL(Q.response);\n      }\n      function nt() {\n        tt(\"timeout of \" + Z + \"ms occured while fetching resource: \" + K);\n      }\n      function tt(it) {\n        console.error(it), J(\"\");\n      }\n    });\n  }\n  function Y(K, Z) {\n    return \"data:\" + Z + \";base64,\" + K;\n  }\n  function q() {\n    const K = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll: et,\n      shouldProcess: Z\n    };\n    function Z(nt) {\n      return nt.search(K) !== -1;\n    }\n    function J(nt) {\n      const tt = [];\n      let it;\n      for (; it = K.exec(nt); )\n        tt.push(it[1]);\n      return tt.filter(function(st) {\n        return !D.isDataUrl(st);\n      });\n    }\n    function Q(nt, tt, it, st) {\n      return Promise.resolve(tt).then((ut) => it ? D.resolveUrl(ut, it) : ut).then(st || D.getAndEncode).then((ut) => D.dataAsUrl(ut, D.mimeType(tt))).then((ut) => nt.replace(at(tt), \"$1\" + ut + \"$3\"));\n      function at(ut) {\n        return new RegExp(`(url\\\\(['\"]?)(` + D.escape(ut) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function et(nt, tt, it) {\n      if (st())\n        return Promise.resolve(nt);\n      return Promise.resolve(nt).then(J).then((at) => {\n        let ut = Promise.resolve(nt);\n        for (const ft of at)\n          ut = ut.then((ct) => Q(ct, ft, tt, it));\n        return ut;\n      });\n      function st() {\n        return !Z(nt);\n      }\n    }\n  }\n  function W() {\n    return {\n      resolveAll: K,\n      impl: { readAll: Z }\n    };\n    function K() {\n      return Z().then((J) => Promise.allSettled(\n        J.map((Q) => Q.resolve())\n      )).then((J) => J.join(`\n`));\n    }\n    function Z() {\n      return Promise.resolve(D.asArray(document.styleSheets)).then(Q).then(J).then((nt) => nt.map(et));\n      function J(nt) {\n        return nt.filter((tt) => tt.type === CSSRule.FONT_FACE_RULE).filter((tt) => k.shouldProcess(tt.style.getPropertyValue(\"src\")));\n      }\n      function Q(nt) {\n        const tt = [];\n        for (const it of nt)\n          try {\n            if (it.href)\n              continue;\n            D.asArray(it.cssRules || []).forEach(tt.push.bind(tt));\n          } catch (st) {\n            console.error(\"Error while reading CSS rules from \" + it.href, st.toString());\n          }\n        return tt;\n      }\n      function et(nt) {\n        return {\n          resolve: function() {\n            const it = (nt.parentStyleSheet || {}).href;\n            return k.inlineAll(nt.cssText, it);\n          },\n          src: function() {\n            return nt.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(H(this, se)).then((K) => {\n    const Z = K.cloneNode(!0);\n    return Z.style.padding = \"0px\", Z.style.paddingRight = H(this, Fo) + \"px\", Z.style.paddingTop = H(this, Qs) + \"px\", Z.style.left = \"0px\", Z.style.top = \"0px\", Z.style.width = H(this, Wt).$width - H(this, Wt).pad_left - H(this, Wt).pad_right + \"px\", Z.style.height = H(this, Wt).$height - H(this, Wt).pad_top - H(this, Wt).pad_bottom + \"px\", H(this, se).hidden = r, Z;\n  }).then(G).then((K) => {\n    K.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const Z = new Image();\n    return Z.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${H(this, Wt).$width}px\" height=\"${H(this, Wt).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(K).replaceAll(\"#\", \"%23\").replaceAll(`\n`, \"%0A\")}</foreignObject></svg>`, new Promise((J) => Z.onload = () => J(Z));\n  }).then((K) => new Promise((Z) => setTimeout(() => Z(K), 100))).then((K) => {\n    const Z = document.createElement(\"canvas\");\n    Z.width = H(this, Wt).$width, Z.height = H(this, Wt).$height, Z.getContext(\"2d\").drawImage(K, 0, 0), Z.toBlob((J) => {\n      if (!J)\n        return;\n      const Q = URL.createObjectURL(J);\n      Texture.from(Q).once(\"update\", (et) => {\n        e(et), URL.revokeObjectURL(Q);\n      });\n    });\n  }).catch((K) => DebugMng.myTrace(`goTxt() = ${K}`));\n}, wn = new WeakMap(), ta = new WeakMap(), Ui = new WeakMap(), Cn = new WeakMap(), Pn = new WeakMap(), Mn = new WeakMap(), ea = new WeakMap(), $o = new WeakMap(), ji = new WeakMap(), Go = new WeakSet(), of = function(e, r, D, N, k, $) {\n  e.alpha = 0, r.x && (N.x = r.x.at(0) === \"=\" ? N.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (N.y = r.y.at(0) === \"=\" ? N.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (N.width = parseInt(r.width)), r.height && (N.height = parseInt(r.height)), r.wait && ($.wait = parseInt(r.wait)), e.width = N.width, e.height = N.height, $.x ? e.position.set(\n    $.x.at(0) === \"=\" ? N.x + e.width * $.nx : $.nx,\n    $.y.at(0) === \"=\" ? N.y + e.height * $.ny : $.ny\n  ) : e.position.set(N.x, N.y);\n  const G = {\n    sp: e,\n    tw: new Tween(e).to({ alpha: 1, x: N.x, y: N.y, width: N.width, height: N.height, angle: 0 }, $.wait ?? 0).easing(k).delay((D.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {\n      G.tw = void 0;\n    }).start()\n  };\n  H(this, ta).push(G);\n}, ci = new WeakMap(), Uo = new WeakMap(), fi = new WeakMap(), Vr = new WeakMap(), ra = new WeakMap(), jo = new WeakSet(), lf = function(e, r) {\n  const D = [];\n  if (e.nodeType !== e.TEXT_NODE)\n    return Array.from(e.childNodes).map((G) => lt(this, jo, lf).call(this, G, r)).flat();\n  const N = e.ownerDocument.createRange();\n  N.selectNodeContents(e);\n  let k = 0;\n  const $ = N.endOffset;\n  for (; k < $; ) {\n    N.setStart(e, k), N.setEnd(e, ++k);\n    const G = N.toString();\n    D.push({\n      ch: G,\n      rect: r(N.getBoundingClientRect(), G),\n      elm: N.startContainer.parentElement\n    });\n  }\n  return N.detach(), D;\n}, zi = new WeakMap(), Rn = new WeakMap(), zo = new WeakSet(), uf = function() {\n  var k;\n  H(this, ui).clear(), ot(this, Ui, []), ot(this, Cn, 0), this.skipChIn();\n  const e = H(this, se).cloneNode(!0);\n  e.textContent = \"\";\n  const r = H(this, se);\n  r.parentElement.insertBefore(e, r);\n  let D = 0;\n  r.querySelectorAll(\"span.sn_ch\").forEach(($) => {\n    var z, X, V;\n    const G = JSON.parse(\n      ($ == null ? void 0 : $.dataset.add) ?? // 通常文字\n      ((z = $ == null ? void 0 : $.children[0]) == null ? void 0 : z.getAttribute(\"data-add\")) ?? // ルビ\n      ((V = (X = $ == null ? void 0 : $.children[0]) == null ? void 0 : X.children[0]) == null ? void 0 : V.getAttribute(\"data-add\")) ?? \"{}\"\n      // 縦中横\n    );\n    if (!G.ch_out_style)\n      return;\n    const U = H(te, fi)[G.ch_out_style];\n    if (U) {\n      if (U.wait === 0) {\n        $.style.display = \"none\";\n        return;\n      }\n      D += U.wait, U.join || ($.style.animationDelay = \"0ms\"), $.classList.add(`go_ch_out_${G.ch_out_style}`);\n    }\n  });\n  const N = () => {\n    r.parentElement.removeChild(r);\n    for (const $ of H(this, Hr).removeChildren())\n      $ instanceof Container && H(te, Tn).unButton($), $.destroy();\n  };\n  D === 0 ? (H(this, se).textContent = \"\", N()) : (k = r.lastElementChild) == null || k.addEventListener(\"animationend\", N, { once: !0, passive: !0 }), ot(this, se, e);\n}, Qe = new WeakMap(), rt(TxtStage, Zs, void 0), rt(TxtStage, Bo, void 0), rt(TxtStage, Tn, void 0), rt(TxtStage, uh, {\n  \"background-color\": 0,\n  \"border-bottom-width\": 0,\n  \"border-left-width\": 0,\n  \"border-right-width\": 0,\n  \"border-top-width\": 0,\n  \"margin-bottom\": 0,\n  \"margin-left\": 0,\n  \"margin-right\": 0,\n  \"margin-top\": 0\n}), rt(TxtStage, Pn, void 0), rt(TxtStage, Mn, void 0), rt(TxtStage, ea, void 0), rt(TxtStage, $o, \"<span class='sn_ch sn_ch_last'>　</span>\"), rt(TxtStage, ci, /* @__PURE__ */ Object.create(null)), rt(TxtStage, Uo, /[\\s\\.,]/), rt(TxtStage, fi, /* @__PURE__ */ Object.create(null)), rt(TxtStage, Vr, new Container());\nvar On, Xr, Ho;\nconst Ii = class {\n  constructor() {\n    rt(this, Xr, () => {\n    });\n  }\n  static setting(t) {\n    t.sesame && ot(Ii, On, t.sesame);\n  }\n  static getSesame() {\n    return H(Ii, On);\n  }\n  static destroy() {\n    ot(Ii, On, \"ヽ\");\n  }\n  init(t) {\n    ot(this, Xr, t);\n  }\n  static setEscape(t) {\n    ot(Ii, Ho, new RegExp(\n      `${t ? `(?<ce>\\\\${t}\\\\S)|` : \"\"}｜(?<str>[^《\\\\n]+)《(?<ruby>[^》\\\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\\\n])《(?<kan_ruby>[^》\\\\n]+)》)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^｜《》]+?|.)`,\n      \"gs\"\n    ));\n  }\n  putTxt(t) {\n    for (const { groups: e } of t.matchAll(H(Ii, Ho))) {\n      const { ruby: r, kan_ruby: D, kan: N, ce: k, txt: $ = \"\", str: G } = e;\n      if (r) {\n        this.putTxtRb(decodeURIComponent(G), r);\n        continue;\n      }\n      if (D) {\n        this.putTxtRb(N, D);\n        continue;\n      }\n      if (k) {\n        H(this, Xr).call(this, k.slice(1), \"\");\n        continue;\n      }\n      for (const U of Array.from($))\n        H(this, Xr).call(this, U, \"\");\n    }\n  }\n  putTxtRb(t, e) {\n    if (/^\\w+｜{\"/.test(e)) {\n      H(this, Xr).call(this, t, e);\n      return;\n    }\n    const r = Array.from(t), D = r.length;\n    if (/^\\*.?$/.test(e)) {\n      const G = \"center｜\" + (e === \"*\" ? H(Ii, On) : e.charAt(1));\n      for (let U = 0; U < D; ++U)\n        H(this, Xr).call(this, r[U], G);\n      return;\n    }\n    if (D === 1 || e.indexOf(\" \") === -1) {\n      H(this, Xr).call(this, t, decodeURIComponent(e));\n      return;\n    }\n    const N = e.split(\" \"), k = N.length, $ = k > D ? k : D;\n    for (let G = 0; G < $; ++G)\n      H(this, Xr).call(this, G < D ? r[G] : \"\", G < k ? decodeURIComponent(N[G]) : \"\");\n  }\n};\nlet RubySpliter = Ii;\nOn = new WeakMap(), Xr = new WeakMap(), Ho = new WeakMap(), rt(RubySpliter, On, \"ヽ\"), /*\n\t\t★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/\n\t\t2E80..2FDF CJK部首補助＋康熙部首\n\t\t3005 々（漢字の踊り字）\n\t\t3007 〇（漢数字のゼロ）\n\t\t303B 〻（漢字の踊り字）\n\t\t3400..4DBF CJK統合漢字拡張A\n\t\t4E00..9FFF CJK統合漢字\n\t\tF900..FAFF CJK互換漢字\n\t\t20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで\n\n\t\t[\\x{2E80}-\\x{2FDF}々〇〻\\x{3400}-\\x{4DBF}\\x{4E00}-\\x{9FFF}\\x{F900}-\\x{FAFF}\\x{20000}-\\x{2FFFF}]\n\t\t[\\u2E80-\\u2FDF々〇〻\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uF900-\\uFAFF\\u20000-\\u2FFFF]\n\t\t[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\\u20000-\\u2FFFF]\t\t// 含まれない文字がある\n\t\t[⺀-⿟々〇〻㐀-鿿豈-﫿\\u20000-\\u2FFFF]\t\t\t// ヽ--30FD が変に引っかかる。多分\\u2000-\\u2FFF解釈\n\t\t\\\\u{20000}-\\\\u{2FFFF}\t// 五桁だとエラー\n\n\t\t【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683\n\t\t\t> このHiraganaプロパティ、長音記号は含まれていません。\n\t\t\t> \\p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ\n\t\t\n\t\t・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php\n*/\nrt(RubySpliter, Ho, void 0);\nvar Vo, Xo, Rr, di, ia, na, Yo, hf, sa, aa, Wo, cf;\nconst un = class extends Container {\n  constructor(e, r, D, N) {\n    var q;\n    super();\n    rt(this, Yo);\n    rt(this, Wo);\n    Ot(this, \"getBtnBounds\", () => H(this, Rr));\n    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用\n    rt(this, Rr, new Rectangle());\n    rt(this, di, void 0);\n    rt(this, ia, void 0);\n    rt(this, na, void 0);\n    Ot(this, \"normal\", () => {\n    });\n    rt(this, sa, () => !1);\n    rt(this, aa, () => {\n    });\n    this.hArg = e, this.evtMng = r, this.resolve = D, this.canFocus = N, CmnLib.isDbg && (this.makeDesignCast = (W) => W(H(this, di)), this.cvsResize = () => H(this, di).cvsResize());\n    let k = {\n      x: this.x = uint(e.left ?? 0),\n      y: this.y = uint(e.top ?? 0),\n      rotation: this.angle = argChk_Num(e, \"rotation\", this.angle),\n      // flash : rotation is in degrees.\n      // pixijs: rotation is in radians, angle is in degrees.\n      pivot_x: this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    this.getBtnBounds = () => (H(this, Rr).x = k.x, H(this, Rr).y = k.y, H(this, Rr));\n    const $ = k.enabled = argChk_Boolean(e, \"enabled\", !0);\n    if ($ && r.button(this.hArg, this, () => this.normal(), () => H(this, sa).call(this), () => H(this, aa).call(this)), e.pic) {\n      k.type = \"pic\", ot(this, di, new PicBtnDesignCast(this, e)), GrpLayer.csv2Sprites(\n        e.pic,\n        this,\n        (W) => {\n          lt(this, Wo, cf).call(this, W, k), H(this, Rr).width = W.width * k.scale_x, H(this, Rr).height = W.height * k.scale_y;\n        },\n        (W) => D\n      );\n      return;\n    }\n    if (!e.text)\n      throw \"textまたはpic属性は必須です\";\n    const G = argChk_Num(e, \"height\", 30), U = new TextStyle({\n      align: \"center\",\n      dropShadow: !0,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: $ ? \"black\" : \"gray\",\n      fontFamily: un.fontFamily,\n      fontSize: G,\n      padding: 5\n    });\n    if (e.style)\n      try {\n        const W = JSON.parse(e.style);\n        for (const [K, Z] of Object.entries(W))\n          U[K] = Z;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style\", W.message));\n      }\n    const z = new Text(e.text ?? \"\", U);\n    z.alpha = argChk_Num(e, \"alpha\", z.alpha), z.width = argChk_Num(e, \"width\", 100), z.height = e.height = G, this.setText = (W) => z.text = W, k.type = \"text\", k = { ...k, ...U }, k.alpha = z.alpha, k.text = z.text, k.width = z.width, k.height = z.height, ot(this, di, new TxtBtnDesignCast(this, e, z));\n    let X = !1;\n    if (k.width = this.width, k.height = this.height, e.b_pic && (k.b_pic = e.b_pic, X = GrpLayer.csv2Sprites(\n      e.b_pic,\n      this,\n      (W) => {\n        lt(this, Yo, hf).call(this, W, z), k.width = this.width, k.height = this.height;\n      },\n      (W) => {\n        Layer.setBlendmode(this, e), W && D();\n      }\n    )), z.name = JSON.stringify(k), this.addChild(z), H(this, Rr).width = z.width, H(this, Rr).height = z.height, e.b_pic || Layer.setBlendmode(this, e), H(q = un, Vo).call(q, this, z), !$) {\n      X || D();\n      return;\n    }\n    const V = U.clone();\n    if (e.style_hover)\n      try {\n        const W = JSON.parse(e.style_hover);\n        for (const [K, Z] of Object.entries(W))\n          V[K] = Z;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style_hover\", W.message));\n      }\n    else\n      V.fill = \"white\";\n    const Y = V.clone();\n    if (e.style_clicked)\n      try {\n        const W = JSON.parse(e.style_clicked);\n        for (const [K, Z] of Object.entries(W))\n          Y[K] = Z;\n      } catch (W) {\n        throw new Error(mesErrJSON(e, \"style_clicked\", W.message));\n      }\n    else\n      Y.dropShadow = !1;\n    this.normal = () => z.style = U, ot(this, sa, () => N() ? (z.style = V, !0) : !1), ot(this, aa, () => z.style = Y), X || D();\n  }\n  static init(e) {\n    e.oCfg.debug.masume && (ot(un, Vo, (r, D) => r.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(D.x, D.y, D.width, D.height).endFill()\n    )), ot(un, Xo, (r, D, N, k) => r.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(D.x, D.y, N, k).endFill()\n    )));\n  }\n  setText(e) {\n  }\n  destroy(e) {\n    this.evtMng.unButton(this), super.destroy();\n  }\n  makeDesignCast(e) {\n  }\n  showDesignCast() {\n    H(this, di).visible = !0;\n  }\n  cvsResize() {\n  }\n  update_b_pic(e, r) {\n    const D = JSON.parse(r.name ?? \"{}\");\n    H(this, ia) && this.removeChild(H(this, ia)), this.hArg.b_pic = D.b_pic = e, r.name = JSON.stringify(D), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (N) => lt(this, Yo, hf).call(this, N, r),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n  update_pic(e, r) {\n    const D = JSON.parse(r.name ?? \"{}\");\n    H(this, na) && this.removeChild(H(this, na)), this.hArg.pic = D.pic = e, r.name = JSON.stringify(D), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (N) => lt(this, Wo, cf).call(this, N, D),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n};\nlet Button = un;\nVo = new WeakMap(), Xo = new WeakMap(), Rr = new WeakMap(), di = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), Yo = new WeakSet(), hf = function(e, r) {\n  ot(this, ia, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(\n    r.x,\n    r.y,\n    1,\n    1,\n    r.rotation,\n    0,\n    0,\n    (e.width - r.width) / 2,\n    (e.height - r.height) / 2\n  ), e.name = r.name;\n}, sa = new WeakMap(), aa = new WeakMap(), Wo = new WeakSet(), cf = function(e, r) {\n  var X;\n  ot(this, na, e), r.alpha = e.alpha = argChk_Num(this.hArg, \"alpha\", e.alpha), H(this, di).setSp(e);\n  const D = e.width / 3, N = e.height, k = e.texture.baseTexture, $ = new Texture(k, new Rectangle(0, 0, D, N)), G = new Texture(k, new Rectangle(D, 0, D, N)), U = new Texture(k, new Rectangle(D * 2, 0, D, N)), z = () => e.texture = $;\n  z(), this.normal = z, ot(this, sa, () => this.canFocus() ? (e.texture = U, !0) : !1), ot(this, aa, () => e.texture = G), \"width\" in this.hArg ? (r.width = uint(this.hArg.width), this.scale.x *= r.width / D) : r.width = D, \"height\" in this.hArg ? (r.height = uint(this.hArg.height), this.scale.y *= r.height / N) : r.height = N, e.name = JSON.stringify(r), H(X = un, Xo).call(X, this, e, D, N);\n}, Ot(Button, \"fontFamily\", \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif\"), rt(Button, Vo, (e, r) => {\n}), rt(Button, Xo, (e, r, D, N) => {\n});\nvar oa, Or, qo, la, Ko, ff, Zo, df, Jo, In, Qo, pi, Dn, ch, gd, vi, mr, Ir, ge, Yr, he, tl, Wr, fh, tr, An, Va, Nn, ua, Ln, Xa, ha, el, pf, rl, vf, kn, Bn, ca, il, fa, Hi, er, dh, md, ur, nl, da, pu, gi, sn, qr, Dr, _r, yr, sl, gf, pa, vu, al, mf, Fn;\nconst ie = class extends Layer {\n  constructor() {\n    super();\n    rt(this, An);\n    rt(this, Ln);\n    rt(this, el);\n    rt(this, rl);\n    rt(this, dh);\n    rt(this, da);\n    rt(this, gi);\n    rt(this, sl);\n    rt(this, pa);\n    rt(this, al);\n    // バック\n    rt(this, vi, 0);\n    rt(this, mr, 0);\n    rt(this, Ir, !1);\n    rt(this, ge, void 0);\n    rt(this, Yr, \"\");\n    // 背景画像無し（＝単色塗り）\n    // 文字表示\n    rt(this, he, new TxtStage(this.spLay, () => this.canFocus(), H(ie, Qo)));\n    rt(this, tl, new RubySpliter());\n    rt(this, Wr, document.createElement(\"span\"));\n    rt(this, tr, new Container());\n    rt(this, Nn, \"\");\n    rt(this, ua, !0);\n    rt(this, ha, \"\");\n    rt(this, kn, \"\");\n    rt(this, Bn, (e) => \"\");\n    rt(this, ca, \"\");\n    rt(this, il, new RegExp(\"[　]\"));\n    Ot(this, \"isCur\", !1);\n    rt(this, Hi, () => \"\");\n    rt(this, er, \"\");\n    rt(this, ur, !1);\n    rt(this, nl, (e, r) => {\n      var U, z, X;\n      H(ie, oa).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\\`${e}\\` ruby:\\`${r}\\` name:\\`${this.name_}\\``);\n      const D = r.split(\"｜\");\n      let N = \"\";\n      const [k, ...$] = D, G = $.join(\"｜\");\n      switch (D.length) {\n        case 1:\n          if (ot(this, ur, !0), e === `\n`) {\n            H(this, Dr) ? (ot(this, Dr, !1), N = \"<ruby>　<rt>　</rt></ruby><br/>\") : N = \"<br/>\";\n            break;\n          }\n          H(this, Dr) && (ot(this, Dr, !1), r === \"\" && (r = \"　\")), N = lt(this, da, pu).call(this, e, r, H(this, er));\n          break;\n        default:\n          switch (k) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              ot(this, Dr, !1), ot(this, ur, !0), N = lt(this, da, pu).call(this, e, G, k);\n              break;\n            case \"gotxt\":\n              lt(this, pa, vu).call(this), H(this, ur) ? (this.isCur && H(ie, la).recText(\n                H(this, _r).join(\"\").replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, \"\").replaceAll(/style='(anim\\S+ \\S+?;\\s*)+/g, \"style='\").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replaceAll(/class='sn_ch .+?'/g, \"class='sn_ch'\").replaceAll(\"display: none;\", \"\").replaceAll(\"class='offrec'\", \"style='display: none;'\")\n                // 囲んだ領域は履歴で非表示\n              ), H(this, he).goTxt(H(this, _r), H(this, qr) === 0), ot(this, ur, !1), ot(this, qr, 0)) : this.isCur && H(ie, In).noticeCompTxt();\n              return;\n            case \"add\":\n              {\n                const V = JSON.parse(G), { style: Y = \"\", wait: q = null } = V, { cl: W, sty: K } = lt(this, gi, sn).call(this, !0, q);\n                H(this, _r).push(`<span${W} style='${K} display: inline; ${Y}'>`), delete V.style, lt(this, sl, gf).call(this, V);\n              }\n              return;\n            case \"add_close\":\n              H(this, _r).push(\"</span>\"), lt(this, pa, vu).call(this);\n              return;\n            case \"grp\":\n              ot(this, ur, !0);\n              {\n                const V = JSON.parse(G);\n                if (V.id ?? (V.id = H(this, _r).length), V.id === \"break\") {\n                  H(this, he).dispBreak(V.pic);\n                  return;\n                }\n                ot(this, Dr, !1), V.delay = H(this, qr), V.r ?? (V.r = \"\"), V.style ?? (V.style = \"\"), V.r_style ?? (V.r_style = \"\");\n                const { cl: Y, sty: q, lnk: W } = lt(this, gi, sn).call(this, !0, V.wait);\n                N = `<span${Y} style='${q} ${V.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(V)}'${W} style='${q} display: inline;'>　</span><rt${W}${this.mkStyle_r_align(\n                  \"　\",\n                  V.r,\n                  H(this, er),\n                  H(this, Wr).style.cssText + (((U = H(this, yr).at(-1)) == null ? void 0 : U.o.r_style) ?? \"\") + V.r_style\n                )}>${V.r}</rt></ruby></span>`;\n              }\n              break;\n            case \"tcy\":\n              ot(this, Dr, !1), ot(this, ur, !0);\n              {\n                H(ie, Or).doRecLog() && ot(this, Fn, H(this, Fn) + (e + (r ? `《${r}》` : \"\")));\n                const { t: V, r: Y = \"\", wait: q = null, style: W = \"\", r_style: K = \"\" } = JSON.parse(G), Z = CmnLib.isSafari ? Y.replaceAll(/[A-Za-z0-9]/g, (nt) => String.fromCharCode(nt.charCodeAt(0) + 65248)) : Y, { cl: J, sty: Q, lnk: et } = lt(this, gi, sn).call(this, !0, q);\n                N = `<span${J} style='${Q}${H(this, Bn).call(this, V)} ${W}'><ruby><span${et} style='${Q} display: inline;\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;'>${V}</span><rt${et}${this.mkStyle_r_align(\n                  V,\n                  Z,\n                  H(this, er),\n                  H(this, Wr).style.cssText + (((z = H(this, yr).at(-1)) == null ? void 0 : z.o.r_style) ?? \"\") + K\n                )}>${Z}</rt></ruby></span>`;\n              }\n              break;\n            case \"del\":\n              TxtStage.delBreak();\n              return;\n            case \"span\":\n              ot(this, ur, !0), lt(this, al, mf).call(this, JSON.parse(G));\n              return;\n            case \"link\":\n              ot(this, ur, !0);\n              {\n                const V = JSON.parse(G);\n                V[\":link\"] = \" data-lnk='@'\";\n                const { cl: Y, sty: q, curpos: W } = lt(this, gi, sn).call(this, !1, V.wait);\n                H(this, _r).push(`<span${Y} style='${q} display: inline; ${V.style ?? \"\"}' ${W} data-arg='${G}'>`), delete V.style, lt(this, al, mf).call(this, V);\n              }\n              return;\n            case \"endlink\":\n              ot(this, ur, !0), H(this, _r).push(\"</span>\"), lt(this, pa, vu).call(this);\n              return;\n            default:\n              ot(this, ur, !0), N = lt(this, da, pu).call(this, e, r, H(this, er));\n          }\n          break;\n      }\n      H(this, _r).push(H(X = ie, fa).call(X, N));\n    });\n    rt(this, qr, 0);\n    rt(this, Dr, !0);\n    rt(this, _r, []);\n    rt(this, yr, []);\n    Ot(this, \"click\", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : H(this, he).skipChIn());\n    rt(this, Fn, \"\");\n    Ot(this, \"addButton\", (e) => new Promise((r) => {\n      e.key = `btn=[${H(this, tr).children.length}] ` + this.name_, e[\":id_tag\"] = e.key.slice(0, -7), argChk_Boolean(e, \"hint_tate\", H(this, he).tategaki);\n      const D = new Button(e, H(ie, In), () => r(), () => this.canFocus());\n      D.name = JSON.stringify(e).replaceAll('\"', \"'\"), H(this, tr).addChild(D);\n    }));\n    Ot(this, \"record\", () => ({\n      ...super.record(),\n      enabled: this.enabled,\n      r_cssText: H(this, Wr).style.cssText,\n      r_align: H(this, er),\n      // バック\n      b_do: H(this, ge) === void 0 ? void 0 : H(this, ge) instanceof Sprite ? \"Sprite\" : \"Graphics\",\n      b_pic: H(this, Yr),\n      b_color: H(this, vi),\n      b_alpha: H(this, mr),\n      b_alpha_isfixed: H(this, Ir),\n      ffs: H(this, kn),\n      txs: H(this, he).record(),\n      strNoFFS: H(this, ca),\n      btns: H(this, tr).children.map((e) => e.name)\n    }));\n    this.spLay.addChild(H(this, he)), H(this, tl).init(H(this, nl)), this.spLay.addChild(H(this, tr)), H(this, tr).name = \"cntBtn\";\n    const e = 16;\n    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(e, r, D, N, k, $) {\n    var G, U;\n    ot(ie, oa, e), TxtStage.init(e, $), ot(ie, Or, D), ot(ie, la, N), ot(ie, qo, k), D.setDoRecProc(ie.chgDoRec), r.autowc = (z) => {\n      var X;\n      return lt(X = ie, ch, gd).call(X, z);\n    }, r.autowc({ enabled: !1, text: \"\", time: 0 }), r.ch_in_style = (z) => {\n      var X;\n      return lt(X = ie, Ko, ff).call(X, z);\n    }, r.ch_out_style = (z) => {\n      var X;\n      return lt(X = ie, Zo, df).call(X, z);\n    }, TxtStage.initChStyle(), initStyle(), addStyle(\n      e.matchPath(\".+\", SEARCH_PATH_ARG_EXT.FONT).flatMap((z) => Object.values(z).map((X) => `\n@font-face {\n\tfont-family: '${X}';\n\tsrc: url('${H(this, oa).searchPath(X, SEARCH_PATH_ARG_EXT.FONT)}');\n}\n`)).join(\"\") + `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`\n      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須\n    ), lt(G = ie, Ko, ff).call(G, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !0,\n      ease: \"ease-out\"\n    }), lt(U = ie, Zo, df).call(U, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !1,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(e, r, D) {\n    ot(ie, Jo, e), ot(ie, In, r), ot(ie, Qo, D), TxtStage.setEvtMng(r);\n  }\n  destroy() {\n    H(this, ge) && (this.spLay.removeChild(H(this, ge)).destroy(), ot(this, ge, void 0)), this.clearText(), H(this, he).destroy();\n  }\n  static destroy() {\n    ot(ie, pi, !1), ot(ie, Dn, {}), ot(ie, fa, (e) => e);\n  }\n  set name(e) {\n    this.name_ = e, H(this, he).name = e;\n  }\n  get name() {\n    return this.name_;\n  }\n  // getは継承しないらしい\n  cvsResize() {\n    H(this, he).cvsResize();\n  }\n  cvsResizeChildren() {\n    for (const e of H(this, tr).children)\n      e.cvsResize();\n  }\n  lay(e) {\n    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[\":id_tag\"] = this.name_.slice(0, -7), RubySpliter.setting(e), lt(this, rl, vf).call(this, e), H(this, he).lay(e), \"r_align\" in e && ot(this, er, e.r_align ?? \"\"), ot(this, Hi, CmnLib.isSafari ? H(this, he).tategaki ? (r, D) => `text-align: start; height: ${D}em; padding-top: ${r}; padding-bottom: ${r};` : (r, D) => `text-align: start; width: ${D}em; padding-left: ${r}; padding-right: ${r};` : H(this, he).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), CmnLib.isFirefox && (this.mkStyle_r_align = lt(this, dh, md)), \"r_style\" in e)\n      if (e.r_style) {\n        const r = document.createElement(\"span\");\n        r.style.cssText = e.r_style;\n        const D = r.style.length, N = H(this, Wr).style;\n        for (let k = 0; k < D; ++k) {\n          const $ = r.style[k];\n          if ($ in H(ie, fh)) {\n            DebugMng.myTrace(`${$}は指定できません`, \"W\");\n            continue;\n          }\n          N[$] = r.style[$];\n        }\n      } else\n        H(this, Wr).style.cssText = \"\";\n    if (\"alpha\" in e)\n      for (const r of H(this, tr).children)\n        r.alpha = this.spLay.alpha;\n    return lt(this, An, Va).call(this, e), lt(this, Ln, Xa).call(this, e), lt(this, el, pf).call(this, e, (r) => {\n      r && H(ie, Jo).resume();\n    });\n  }\n  get width() {\n    return H(this, he).getWidth;\n  }\n  get height() {\n    return H(this, he).getHeight;\n  }\n  chgBackAlpha(e) {\n    const r = H(this, Ir) ? H(this, mr) : e * H(this, mr);\n    H(this, ge) instanceof Graphics && (H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), this.spLay.addChildAt(\n      ot(this, ge, new Graphics()).beginFill(H(this, vi)).lineStyle(void 0).drawRect(0, 0, H(this, he).getWidth, H(this, he).getHeight).endFill(),\n      0\n    ), H(this, ge).name = \"back(color)\"), H(this, ge) && (H(this, ge).visible = r > 0, H(this, ge).alpha = r);\n  }\n  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定\n  static chgDoRec(e) {\n    ot(ie, fa, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);\n  }\n  mkStyle_r_align(e, r, D, N = \"\") {\n    if (!D)\n      return ` style='${N}'`;\n    const k = e.length * 2;\n    if (k - r.length < 0)\n      return ` style='text-align: ${D}; ${N}'`;\n    let $ = \"\";\n    switch (D) {\n      case \"justify\":\n        $ = H(this, Hi).call(this, \"0\", k);\n        break;\n      case \"121\":\n        $ = H(this, Hi).call(this, `calc(${(k - r.length) / (r.length * 2)}em)`, k);\n        break;\n      case \"even\":\n        $ = H(this, Hi).call(this, `calc(${(k - r.length) / (r.length + 1)}em)`, k);\n        break;\n      case \"1ruby\":\n        $ = H(this, Hi).call(this, \"1em\", k);\n        break;\n      default:\n        $ = `text-align: ${D};`;\n    }\n    return ` style='${$} ${N}'`;\n  }\n  tagCh(e) {\n    H(this, tl).putTxt(e);\n  }\n  clearText() {\n    this.spLay.addChild(ot(this, he, H(this, he).reNew())), ot(this, qr, 0), ot(this, Dr, !0), ot(this, _r, []), ot(this, Fn, \"\"), H(ie, la).recPagebreak();\n  }\n  get pageText() {\n    return H(this, Fn).replace(\"《　》\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var e;\n    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && H(e = ie, qo).call(e, this);\n  }\n  clearLay(e) {\n    super.clearLay(e), this.clearText();\n    for (const r of H(this, tr).removeChildren())\n      r.destroy();\n  }\n  playback(e, r) {\n    super.playback(e, r), this.enabled = e.enabled, H(this, Wr).style.cssText = e.r_cssText, ot(this, er, e.r_align), this.cvsResize(), lt(this, rl, vf).call(this, e), H(this, he).playback(e.txs), ot(this, mr, e.b_alpha), ot(this, Ir, e.b_alpha_isfixed), r.push(new Promise((N) => {\n      const k = e.b_do ? e.b_do === \"Sprite\" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: \"\" };\n      k.b_alpha = e.b_alpha, k.b_alpha_isfixed = e.b_alpha_isfixed, lt(this, el, pf).call(this, k, ($) => {\n        $ && N();\n      }) || N();\n    }));\n    const D = e.btns;\n    r = r.concat(D.map((N) => this.addButton(JSON.parse(N.replaceAll(\"'\", '\"')))));\n  }\n  snapshot(e, r) {\n    e.render(this.spLay, { clear: !1 }), H(this, he).snapshot(e, r);\n  }\n  snapshot_end() {\n    H(this, he).snapshot_end();\n  }\n  makeDesignCast(e) {\n    this.spLay.visible && H(this, he).makeDesignCast(e);\n  }\n  makeDesignCastChildren(e) {\n    if (this.spLay.visible)\n      for (const r of H(this, tr).children)\n        r.makeDesignCast(e);\n  }\n  showDesignCast() {\n    H(this, he).showDesignCast();\n  }\n  showDesignCastChildren() {\n    for (const e of H(this, tr).children)\n      e.showDesignCast();\n  }\n  dump() {\n    return H(this, nl).call(this, \"\", \"gotxt｜\"), super.dump() + `, \"enabled\":\"${this.enabled}\", ${H(this, he).dump()}, \"b_pic\":\"${H(this, Yr)}\", \"b_color\":\"${H(this, vi)}\", \"b_alpha\":${H(this, mr)}, \"b_alpha_isfixed\":\"${H(this, Ir)}\", \"width\":${H(this, he).getWidth}, \"height\":${H(this, he).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Sprite ? \"Sprite\" : e instanceof Graphics ? \"Graphics\" : e instanceof Container ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${H(this, tr).children.map((e) => e.children[0].name ?? \"{}\").join(\",\")}]`;\n  }\n};\nlet TxtLayer = ie;\noa = new WeakMap(), Or = new WeakMap(), qo = new WeakMap(), la = new WeakMap(), Ko = new WeakSet(), ff = function(e) {\n  const r = TxtStage.ch_in_style(e), D = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, N = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: k } = e;\n  return addStyle(`\n.sn_ch_in_${k} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${k} {\n\topacity: ${r.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${k} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes sn_ch_in_${k} {\n\tfrom {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${D}, ${N});}\n\tto {opacity: 1; transform: none;}\n}\n`), !1;\n}, Zo = new WeakSet(), df = function(e) {\n  const r = TxtStage.ch_out_style(e), D = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, N = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: k } = e;\n  return addStyle(`\n.go_ch_out_${k} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${k} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes go_ch_out_${k} {\n\tto {\n\t\topacity: ${r.alpha};\n\t\ttransform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${D}, ${N});\n\t}\n`), !1;\n}, Jo = new WeakMap(), In = new WeakMap(), Qo = new WeakMap(), pi = new WeakMap(), Dn = new WeakMap(), ch = new WeakSet(), gd = function(e) {\n  ot(ie, pi, argChk_Boolean(e, \"enabled\", H(ie, pi))), H(ie, Or).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", H(ie, pi));\n  const { text: r } = e;\n  if (\"text\" in e != \"time\" in e)\n    throw \"[autowc] textとtimeは同時指定必須です\";\n  if (H(ie, Or).setVal_Nochk(\"save\", \"const.sn.autowc.text\", r), !r)\n    return H(ie, Or).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\"), !1;\n  const D = r.length;\n  if (H(ie, pi) && D === 0)\n    throw '[autowc] enabled === false かつ text === \"\" は許されません';\n  const N = String(e.time).split(\",\");\n  if (N.length !== D)\n    throw \"[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい\";\n  return ot(ie, Dn, {}), N.forEach((k, $) => H(ie, Dn)[r[$]] = uint(k)), H(ie, Or).setVal_Nochk(\"save\", \"const.sn.autowc.time\", e.time), !1;\n}, vi = new WeakMap(), mr = new WeakMap(), Ir = new WeakMap(), ge = new WeakMap(), Yr = new WeakMap(), he = new WeakMap(), tl = new WeakMap(), Wr = new WeakMap(), fh = new WeakMap(), tr = new WeakMap(), An = new WeakSet(), Va = function(e) {\n  const { in_style: r } = e;\n  if (!r)\n    return;\n  const D = TxtStage.getChInStyle(r);\n  if (!D)\n    throw `存在しないin_style【${r}】です`;\n  ot(this, Nn, r), ot(this, ua, D.join);\n}, Nn = new WeakMap(), ua = new WeakMap(), Ln = new WeakSet(), Xa = function(e) {\n  const { out_style: r } = e;\n  if (!r)\n    return;\n  if (!TxtStage.getChOutStyle(r))\n    throw `存在しないout_style【${r}】です`;\n  ot(this, ha, r);\n}, ha = new WeakMap(), el = new WeakSet(), pf = function(e, r) {\n  if (\"back_clear\" in e)\n    return argChk_Boolean(e, \"back_clear\", !1) && (ot(this, vi, 0), ot(this, mr, 0), ot(this, Ir, !1), ot(this, Yr, \"\")), r(!1), !1;\n  ot(this, mr, argChk_Num(e, \"b_alpha\", H(this, mr))), ot(this, Ir, argChk_Boolean(e, \"b_alpha_isfixed\", H(this, Ir)));\n  const D = (H(this, Ir) ? 1 : Number(H(ie, Or).getVal(\"sys:TextLayer.Back.Alpha\"))) * H(this, mr);\n  if (e.b_pic) {\n    if (H(this, Yr) !== e.b_pic)\n      return ot(this, Yr, e.b_pic), H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), GrpLayer.csv2Sprites(H(this, Yr), this.spLay, (N) => {\n        ot(this, ge, N), N.name = \"back(pic)\", N.visible = D > 0, N.alpha = D, H(this, he).setSize(N.width, N.height), this.spLay.setChildIndex(N, 0), r(!0);\n      });\n  } else\n    \"b_color\" in e && (ot(this, vi, argChk_Color(e, \"b_color\", 0)), H(this, ge) && (this.spLay.removeChild(H(this, ge)), H(this, ge).destroy()), ot(this, Yr, \"\"), this.spLay.addChildAt(\n      ot(this, ge, new Graphics()).beginFill(H(this, vi)).lineStyle(void 0).drawRect(0, 0, H(this, he).getWidth, H(this, he).getHeight).endFill(),\n      0\n    ), H(this, ge).name = \"back(color)\");\n  return H(this, ge) && (H(this, ge).visible = D > 0, H(this, ge).alpha = D), r(!1), !1;\n}, rl = new WeakSet(), vf = function(e) {\n  \"noffs\" in e && (ot(this, ca, e.noffs ?? \"\"), ot(this, il, new RegExp(`[　${H(this, ca)}]`))), \"ffs\" in e && (H(this, kn) ?? ot(this, kn, \"\"), ot(this, Bn, H(this, kn) === \"\" ? () => \"\" : (r) => H(this, il).test(r) ? \"\" : ` font-feature-settings: ${H(this, kn)};`));\n}, kn = new WeakMap(), Bn = new WeakMap(), ca = new WeakMap(), il = new WeakMap(), fa = new WeakMap(), Hi = new WeakMap(), er = new WeakMap(), dh = new WeakSet(), md = function(e, r, D, N = \"\") {\n  if (!D)\n    return ` style='${N}'`;\n  const k = e.length * 2;\n  if (k - r.length < 0)\n    return ` style='text-align: ${D}; ${N}'`;\n  let $ = \"\";\n  switch (D) {\n    case \"left\":\n      $ = \"ruby-align: start;\";\n      break;\n    case \"center\":\n      $ = \"ruby-align: center;\";\n      break;\n    case \"right\":\n      $ = \"ruby-align: start;\";\n      break;\n    case \"justify\":\n      $ = \"ruby-align: space-between;\";\n      break;\n    case \"121\":\n      $ = \"ruby-align: space-around;\";\n      break;\n    case \"even\":\n      const G = (k - r.length) / (r.length + 1);\n      $ = \"ruby-align: space-between; \" + (H(this, he).tategaki ? `padding-top: ${G}em; padding-bottom: ${G}em;` : `padding-left: ${G}em; padding-right: ${G}em;`);\n      break;\n    case \"1ruby\":\n      $ = \"ruby-align: space-between; \" + (H(this, he).tategaki ? \"padding-top: 1em; padding-bottom: 1em;\" : \"padding-left: 1em; padding-right: 1em;\");\n      break;\n    default:\n      $ = `text-align: ${D};`;\n  }\n  return ` style='${$} ${N}'`;\n}, ur = new WeakMap(), nl = new WeakMap(), da = new WeakSet(), pu = function(e, r, D) {\n  var U;\n  const N = e === \" \" ? \"&nbsp;\" : e;\n  H(ie, Or).doRecLog() && ot(this, Fn, H(this, Fn) + (N + (r ? `《${r}》` : \"\")));\n  const { cl: k, sty: $, lnk: G } = lt(this, gi, sn).call(this, !0, null, e);\n  return r ? `<span${k} style='${$} ${H(this, Bn).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要\n  Array.from(e).map((z, X) => `<span${k}${G} style='${X > 0 ? lt(this, gi, sn).call(this, !0, null, e).sty : $} display: inline;'>${z === \" \" ? \"&nbsp;\" : z}</span>`).join(\"\")}<rt${G}${this.mkStyle_r_align(\n    e,\n    r,\n    D,\n    H(this, Wr).style.cssText + (((U = H(this, yr).at(-1)) == null ? void 0 : U.o.r_style) ?? \"\")\n  )}>${r}</rt></ruby></span>` : `<span${k} style='${$} ${H(this, Bn).call(this, e)}'${G}>${N}</span>`;\n}, gi = new WeakSet(), sn = function(e, r, D = `\n`) {\n  var $, G, U;\n  const N = H(this, ua) ? r ?? (($ = H(this, yr).at(0)) == null ? void 0 : $.o.wait) ?? (H(ie, pi) ? H(ie, Dn)[D.at(0) ?? \"\"] ?? 0 : LayerMng.msecChWait) : 0;\n  H(ie, In).isSkippingByKeyDown() ? ot(this, qr, 0) : e && H(this, ua) && ot(this, qr, H(this, qr) + Number(N));\n  const k = `data-add='{\"ch_in_style\":\"${H(this, Nn)}\", \"ch_out_style\":\"${H(this, ha)}\"}'`;\n  return {\n    cl: ` class='sn_ch${N > 0 ? ` sn_ch_in_${H(this, Nn)}` : \"\"}'`,\n    // TxtStage.goTxt()はこれ単位で文字出現させる\n    sty: `animation-delay: ${H(this, qr)}ms;${((G = H(this, yr).at(-1)) == null ? void 0 : G.o.style) ?? \"\"}`,\n    // TxtStage.goTxt()はこれ単位で文字出現させる\n    lnk: (((U = H(this, yr).at(0)) == null ? void 0 : U.o[\":link\"]) ?? \"\") + \" \" + k,\n    curpos: k\n  };\n}, qr = new WeakMap(), Dr = new WeakMap(), _r = new WeakMap(), yr = new WeakMap(), sl = new WeakSet(), gf = function(e) {\n  H(this, yr).push({\n    o: e,\n    r_align: H(this, er),\n    ch_in_style: H(this, Nn),\n    ch_out_style: H(this, ha)\n  }), \"r_align\" in e && ot(this, er, e.r_align), lt(this, An, Va).call(this, e), lt(this, Ln, Xa).call(this, e);\n}, pa = new WeakSet(), vu = function() {\n  const e = H(this, yr).pop();\n  e && (ot(this, er, e.r_align), lt(this, An, Va).call(this, { in_style: e.ch_in_style }), lt(this, Ln, Xa).call(this, { out_style: e.ch_out_style }));\n}, al = new WeakSet(), mf = function(e) {\n  const r = H(this, yr).at(-1);\n  if (!r) {\n    lt(this, sl, gf).call(this, e);\n    return;\n  }\n  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = \"\", r.o.r_style = \"\"), \"r_align\" in e && ot(this, er, e.r_align), lt(this, An, Va).call(this, e), lt(this, Ln, Xa).call(this, e);\n}, Fn = new WeakMap(), // 文字出現演出\nrt(TxtLayer, Ko), // 文字消去演出\nrt(TxtLayer, Zo), rt(TxtLayer, ch), rt(TxtLayer, oa, void 0), rt(TxtLayer, Or, void 0), rt(TxtLayer, qo, void 0), rt(TxtLayer, la, void 0), rt(TxtLayer, Jo, void 0), rt(TxtLayer, In, void 0), rt(TxtLayer, Qo, void 0), // 文字ごとのウェイト\nrt(TxtLayer, pi, !1), rt(TxtLayer, Dn, {}), // cssチェック・保存用\nrt(TxtLayer, fh, {\n  \"text-align\": 0,\n  \"text-align-last\": 0,\n  height: 0,\n  width: 0,\n  \"padding-left\": 0,\n  \"padding-right\": 0,\n  \"padding-top\": 0,\n  \"padding-bottom\": 0\n}), rt(TxtLayer, fa, (e) => e);\nvar va, $n, ph, _d, ga, ma, gu, vh, yd, gh, bd, ol, mh, xd, _h, Sd;\nclass FrameMng {\n  constructor(t, e, r, D, N, k, $) {\n    //\tHTMLフレーム\n    // フレーム追加\n    rt(this, ph);\n    rt(this, ma);\n    // フレーム変数を取得\n    rt(this, vh);\n    // フレーム変数に設定\n    rt(this, gh);\n    rt(this, mh);\n    // フレームをトゥイーン開始\n    rt(this, _h);\n    rt(this, va, void 0);\n    rt(this, $n, /* @__PURE__ */ Object.create(null));\n    rt(this, ga, {});\n    // フレームに設定\n    rt(this, ol, 1);\n    this.cfg = t, this.appPixi = r, this.val = D, this.main = N, this.sys = k, this.hTwInf = $, e.add_frame = (G) => lt(this, ph, _d).call(this, G), e.let_frame = (G) => lt(this, vh, yd).call(this, G), e.set_frame = (G) => lt(this, gh, bd).call(this, G), e.frame = (G) => lt(this, mh, xd).call(this, G), e.tsy_frame = (G) => lt(this, _h, Sd).call(this, G);\n  }\n  setEvtMng(t) {\n    ot(this, va, t);\n  }\n  destroy() {\n    for (const t of Object.values(H(this, $n)))\n      t.parentElement.removeChild(t);\n    ot(this, $n, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(t) {\n    return H(this, ga)[t];\n  }\n  cvsResize() {\n    for (const [t, e] of Object.entries(H(this, $n))) {\n      const r = \"const.sn.frm.\" + t, D = Number(this.val.getVal(r + \".x\")), N = Number(this.val.getVal(r + \".y\")), k = Number(this.val.getVal(r + \".width\")), $ = Number(this.val.getVal(r + \".height\"));\n      e.style.left = `${this.sys.ofsLeft4elm + D * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + N * this.sys.cvsScale}px`, e.width = String(k * this.sys.cvsScale), e.height = String($ * this.sys.cvsScale);\n    }\n  }\n}\nva = new WeakMap(), $n = new WeakMap(), ph = new WeakSet(), _d = function(t) {\n  const { id: e, src: r, alpha: D = 1, scale_x: N = 1, scale_y: k = 1, rotate: $ = 0 } = t;\n  if (!e)\n    throw \"idは必須です\";\n  if (!r)\n    throw \"srcは必須です\";\n  const G = \"const.sn.frm.\" + e;\n  if (this.val.getVal(`tmp:${G}`))\n    throw `frame【${e}】はすでにあります`;\n  const U = argChk_Boolean(t, \"visible\", !0), z = t.b_color ? ` background-color: ${t.b_color};` : \"\", X = lt(this, ma, gu).call(this, t);\n  Main.cvs.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${e}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${D}; position: absolute; left:${this.sys.ofsLeft4elm + X.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + X.y * this.sys.cvsScale}px; z-index: 1; ${z} border: 0px; overflow: hidden; display: ${U ? \"inline\" : \"none\"}; transform: scale(${N}, ${k}) rotate(${$}deg);\" width=\"${X.width * this.sys.cvsScale}\" height=\"${X.height * this.sys.cvsScale}\"></iframe>`);\n  const V = this.cfg.searchPath(r, SEARCH_PATH_ARG_EXT.HTML), Y = new Loader().add({ name: r, url: V, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });\n  return this.sys.crypto && Y.use((q, W) => {\n    try {\n      q.data = this.sys.decStr(q.extension, q.data);\n    } catch (K) {\n      this.main.errScript(`[add_frame]Html ロード失敗です src:${q.name} ${K}`, !1);\n    }\n    W == null || W();\n  }), Y.load((q, W) => {\n    var Z;\n    const K = document.getElementById(e);\n    H(this, $n)[e] = K, H(this, ga)[e] = !1, K.srcdoc = String((Z = W[r]) == null ? void 0 : Z.data).replace(\"sn_repRes();\", \"\").replaceAll(\n      /\\s(?:src|href)=([\"'])(\\S+)\\1/g,\n      (J, Q, et) => et.slice(0, 3) === \"../\" ? this.sys.cur + et.slice(4) : J.replace(Q, Q + V.slice(0, V.lastIndexOf(\"/\") + 1))\n    ), K.onload = () => {\n      var Q;\n      this.val.setVal_Nochk(\"tmp\", G, !0), this.val.setVal_Nochk(\"tmp\", G + \".alpha\", D), this.val.setVal_Nochk(\"tmp\", G + \".x\", X.x), this.val.setVal_Nochk(\"tmp\", G + \".y\", X.y), this.val.setVal_Nochk(\"tmp\", G + \".scale_x\", N), this.val.setVal_Nochk(\"tmp\", G + \".scale_y\", k), this.val.setVal_Nochk(\"tmp\", G + \".rotate\", $), this.val.setVal_Nochk(\"tmp\", G + \".width\", X.width), this.val.setVal_Nochk(\"tmp\", G + \".height\", X.height), this.val.setVal_Nochk(\"tmp\", G + \".visible\", U);\n      const J = K.contentWindow;\n      H(this, va).resvFlameEvent(J), (Q = J.sn_repRes) == null || Q.call(J, (et) => GrpLayer.loadPic2Img(et.dataset.src ?? \"\", et)), this.main.resume();\n    };\n  }), !0;\n}, ga = new WeakMap(), ma = new WeakSet(), gu = function(t) {\n  const e = { ...t }, r = this.sys.resolution;\n  return new DOMRect(\n    argChk_Num(e, \"x\", 0) * r,\n    argChk_Num(e, \"y\", 0) * r,\n    argChk_Num(e, \"width\", CmnLib.stageW) * r,\n    argChk_Num(e, \"height\", CmnLib.stageH) * r\n  );\n}, vh = new WeakSet(), yd = function(t) {\n  const { id: e, var_name: r } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const D = document.getElementById(e);\n  if (!D)\n    throw `id【${e}】はフレームではありません`;\n  const N = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${N}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  const k = D.contentWindow;\n  if (!k.hasOwnProperty(r))\n    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;\n  const $ = k[r];\n  return this.val.setVal_Nochk(\n    \"tmp\",\n    N + \".\" + r,\n    argChk_Boolean(t, \"function\", !1) ? $() : $\n  ), !1;\n}, gh = new WeakSet(), bd = function(t) {\n  const { id: e, var_name: r, text: D } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const N = document.getElementById(e);\n  if (!N)\n    throw `id【${e}】はフレームではありません`;\n  const k = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${k}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  if (!D)\n    throw \"textは必須です\";\n  this.val.setVal_Nochk(\"tmp\", k + \".\" + r, D);\n  const $ = N.contentWindow;\n  return $[r] = D, !1;\n}, ol = new WeakMap(), mh = new WeakSet(), xd = function(t) {\n  const { id: e } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const r = document.getElementById(e);\n  if (!r)\n    throw `id【${e}】はフレームではありません`;\n  const D = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(\"tmp:\" + D))\n    throw `frame【${e}】が読み込まれていません`;\n  const N = r.style;\n  if (argChk_Boolean(t, \"float\", !1) ? N.zIndex = `${++Ie(this, ol)._}` : \"index\" in t ? N.zIndex = `${argChk_Num(t, \"index\", 0)}` : t.dive && (N.zIndex = `-${++Ie(this, ol)._}`), \"alpha\" in t) {\n    const $ = N.opacity = String(t.alpha);\n    this.val.setVal_Nochk(\"tmp\", D + \".alpha\", $);\n  }\n  const k = lt(this, ma, gu).call(this, t);\n  if ((\"x\" in t || \"y\" in t) && (N.left = `${this.sys.ofsLeft4elm + k.x * this.sys.cvsScale}px`, N.top = `${this.sys.ofsTop4elm + k.y * this.sys.cvsScale}px`, this.val.setVal_Nochk(\"tmp\", D + \".x\", k.x), this.val.setVal_Nochk(\"tmp\", D + \".y\", k.y)), \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) {\n    const $ = argChk_Num(t, \"scale_x\", 1), G = argChk_Num(t, \"scale_y\", 1), U = argChk_Num(t, \"rotate\", 0);\n    N.transform = `scale(${$}, ${G}) rotate(${U}deg)`, this.val.setVal_Nochk(\"tmp\", D + \".scale_x\", $), this.val.setVal_Nochk(\"tmp\", D + \".scale_y\", G), this.val.setVal_Nochk(\"tmp\", D + \".rotate\", U);\n  }\n  if (\"width\" in t && (r.width = String(k.width * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", D + \".width\", k.width)), \"height\" in t && (r.height = String(k.height * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", D + \".height\", k.height)), \"visible\" in t) {\n    const $ = argChk_Boolean(t, \"visible\", !0);\n    N.display = $ ? \"inline\" : \"none\", this.val.setVal_Nochk(\"tmp\", D + \".visible\", $);\n  }\n  if (\"b_color\" in t && (N.backgroundColor = t.b_color), \"disabled\" in t) {\n    const $ = H(this, ga)[e] = argChk_Boolean(t, \"disabled\", !0);\n    r.contentDocument.body.querySelectorAll(\"input,select\").forEach((U) => U.disabled = $);\n  }\n  return !1;\n}, _h = new WeakSet(), Sd = function(t) {\n  const { id: e, alpha: r, x: D, y: N, scale_x: k, scale_y: $, rotate: G, width: U, height: z, ease: X, path: V, chain: Y } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const q = document.getElementById(e);\n  if (!q)\n    throw `id【${e}】はフレームではありません`;\n  const W = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${W}`, 0))\n    throw `frame【${e}】が読み込まれていません`;\n  const K = {};\n  r && (K.a = q.style.opacity), (D || N || k || $ || G) && (K.x = Number(this.val.getVal(`tmp:${W}.x`)), K.y = Number(this.val.getVal(`tmp:${W}.y`)), K.sx = Number(this.val.getVal(`tmp:${W}.scale_x`)), K.sy = Number(this.val.getVal(`tmp:${W}.scale_y`)), K.r = Number(this.val.getVal(`tmp:${W}.rotate`))), U && (K.w = this.val.getVal(`tmp:${W}.width`)), z && (K.h = this.val.getVal(`tmp:${W}.height`));\n  const Z = cnvTweenArg(t, K), J = {};\n  let Q = () => {\n  };\n  r && (J.a = argChk_Num(Z, \"alpha\", 0), Q = () => {\n    q.style.opacity = K.a, this.val.setVal_Nochk(\"tmp\", \"alpha\", K.a);\n  });\n  let et = () => {\n  };\n  const nt = lt(this, ma, gu).call(this, Z);\n  (D || N || k || $ || G) && (J.x = nt.x, J.y = nt.y, J.sx = argChk_Num(Z, \"scale_x\", 1), J.sy = argChk_Num(Z, \"scale_y\", 1), J.r = argChk_Num(Z, \"rotate\", 0), et = () => {\n    q.style.left = this.sys.ofsLeft4elm + K.x * this.sys.cvsScale + \"px\", q.style.top = this.sys.ofsTop4elm + K.y * this.sys.cvsScale + \"px\", q.style.transform = `scale(${K.sx}, ${K.sy}) rotate(${K.r}deg)`, this.val.setVal_Nochk(\"tmp\", W + \".x\", K.x), this.val.setVal_Nochk(\"tmp\", W + \".y\", K.y), this.val.setVal_Nochk(\"tmp\", W + \".scale_x\", K.sx), this.val.setVal_Nochk(\"tmp\", W + \".scale_y\", K.sy), this.val.setVal_Nochk(\"tmp\", W + \".rotate\", K.r);\n  });\n  let tt = () => {\n  };\n  U && (J.w = nt.width, tt = () => {\n    q.width = K.w * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", W + \".width\", K.w);\n  });\n  let it = () => {\n  };\n  z && (J.h = nt.height, it = () => {\n    q.height = K.h * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", W + \".height\", K.h);\n  }), this.appPixi.stage.interactive = !1;\n  const st = `frm\n${e}`, at = () => {\n    var St, gt;\n    this.appPixi.stage.interactive = !0;\n    const Pt = this.hTwInf[st];\n    Pt && (delete this.hTwInf[st], (St = Pt.tw) == null || St.stop(), Pt.resume && this.main.resume(), (gt = Pt.onEnd) == null || gt.call(Pt));\n  }, ut = argChk_Num(t, \"time\", NaN) * (this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, va).isSkippingByKeyDown() ? 0 : 1), ft = CmnTween.ease(X), ct = argChk_Num(t, \"repeat\", 1), vt = ct === 0 ? 1 / 0 : ct - 1, yt = argChk_Boolean(t, \"yoyo\", !1), mt = argChk_Num(t, \"delay\", 0), _t = new Tween(K).to(J, ut).easing(ft).repeat(vt).yoyo(yt).delay(mt).onUpdate(() => {\n    Q(), et(), tt(), it();\n  });\n  let Tt = _t;\n  if (V) {\n    CmnLib.debugLog && console.group(`🍝 [tsy_frame] path=${V}= start(${K.x},${K.y},${K.alpha})`);\n    for (const { groups: Pt } of V.matchAll(LayerMng.REG_TSY_PATH)) {\n      const { x: St, x2: gt, y: bt, y2: Nt, o: At, o2: It, json: Mt } = Pt;\n      let dt = {};\n      if (Mt)\n        try {\n          dt = JSON.parse(Mt);\n        } catch (Vt) {\n          console.error(`🍝 json=${Mt} ` + Vt);\n          continue;\n        }\n      else\n        (St ?? gt) && (dt.x = St ?? gt), (bt ?? Nt) && (dt.y = bt ?? Nt), (At ?? It) && (dt.alpha = At ?? It);\n      const $t = cnvTweenArg(dt, K);\n      CmnLib.debugLog && console.info(`🍝 {x:${St} y:${bt} o:${At}} => hTo:${JSON.stringify($t)}`);\n      const Dt = new Tween(K).to($t, ut).easing(ft).repeat(vt).yoyo(yt);\n      Tt.chain(Dt), Tt = Dt;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (Tt.onComplete(at), Y) {\n    const Pt = this.hTwInf[Y ?? \"\"];\n    if (!Pt || !Pt.tw)\n      throw `${Y}は存在しない・または終了したトゥイーンです`;\n    delete Pt.onEnd, Pt.tw.chain(_t);\n  } else\n    _t.start();\n  return this.hTwInf[st] = { tw: Tt, resume: !1 }, !1;\n};\nvar br, le, Te, Vi, Gn, ya, ll, ul, hl, ba, cl, _f, Xi, Ar, yh, Ed, rr, bh, Td, xh, wd, Sh, Cd, ae, Kr, Zr, fl, Eh, Pd, xa, mu, Th, Md, wh, dl, Ch, Un, jn, mi, Ae, zn, Ph, Rd, Ne, Ke, sr, Mh, Od, Rh, Id, Oh, Dd, Hn, Ya, Ih, Ad, hr, Dh, Nd, Ah, Ld, Nh, kd, Lh, Bd, kh, Fd, Yi, Vn, Wa, cr, Bh, $d, pl, Fh, Gd, Jr, Xn, Wi, Es, Nr, Qr, $h, Ud, Gh, jd, Uh, zd, jh, Hd, zh, Vd, Hh, Xd, Vh, Yd, vl, yf, Xh, Wd, Yh, qd, Wh, Kd, qh, Zd, Kh, Jd, Zh, Qd, Jh, tp;\nconst Di = class {\n  constructor(t, e, r, D, N, k, $, G, U, z) {\n    rt(this, cl);\n    // 既存の全文字レイヤの実際のバック不透明度、を再計算\n    rt(this, yh);\n    //\t//\tシステム\n    // スナップショット\n    rt(this, bh);\n    // プラグインの読み込み\n    rt(this, xh);\n    //\t//\tレイヤ共通\n    // レイヤを追加する\n    rt(this, Sh);\n    rt(this, Eh);\n    rt(this, xa);\n    // レイヤ設定の消去\n    rt(this, Th);\n    // ページ裏表を交換\n    rt(this, Ph);\n    rt(this, Ke);\n    rt(this, Mh);\n    rt(this, Rh);\n    // トランス終了待ち\n    rt(this, Oh);\n    // レイヤのトランジションの停止\n    rt(this, Hn);\n    // 画面を揺らす\n    rt(this, Ih);\n    rt(this, Dh);\n    // トゥイーン終了待ち\n    rt(this, Ah);\n    // トゥイーン中断\n    rt(this, Nh);\n    // 一時停止\n    rt(this, Lh);\n    // 一時停止再開\n    rt(this, kh);\n    // 文字を追加する\n    rt(this, Vn);\n    rt(this, Bh);\n    rt(this, Fh);\n    rt(this, Wi);\n    rt(this, $h);\n    // ハイパーリンクの終了\n    rt(this, Gh);\n    // ページ両面の文字消去\n    rt(this, Uh);\n    // インライン画像表示\n    rt(this, jh);\n    // ハイパーリンク\n    rt(this, zh);\n    // 改行\n    rt(this, Hh);\n    // 履歴改行\n    rt(this, Vh);\n    // 履歴書き込み\n    rt(this, vl);\n    // 履歴リセット\n    rt(this, Xh);\n    // 文字列と複数ルビの追加\n    rt(this, Yh);\n    // インラインスタイル設定\n    rt(this, Wh);\n    // tcy縦中横を表示する\n    rt(this, qh);\n    // レイヤのダンプ\n    rt(this, Kh);\n    // イベント有無の切替\n    rt(this, Zh);\n    // ボタンを表示\n    rt(this, Jh);\n    rt(this, br, void 0);\n    rt(this, le, new Container());\n    rt(this, Te, new Container());\n    rt(this, Vi, void 0);\n    rt(this, Gn, void 0);\n    rt(this, ya, new EventListenerCtn());\n    rt(this, ll, () => update());\n    rt(this, ul, {\n      attach: (t) => (DesignCast.leaveMode(), !1),\n      continue: (t) => (DesignCast.leaveMode(), !1),\n      disconnect: (t) => (DesignCast.leaveMode(), !1),\n      _enterDesign: (t) => {\n        DesignCast.enterMode();\n        for (const e of H(this, Kr)) {\n          const r = H(this, ae)[e].fore;\n          r.makeDesignCastChildren((D) => D.make()), r.makeDesignCast((D) => D.make());\n        }\n        return lt(this, cl, _f).call(this, H(this, Zr)), !1;\n      },\n      _replaceToken: (t, e) => (DesignCast.replaceToken(e), !1),\n      _selectNode: (t, e) => (lt(this, cl, _f).call(this, e.node), !1)\n    });\n    rt(this, hl, \"\");\n    rt(this, ba, \"\");\n    Ot(this, \"getFrmDisabled\", (t) => H(this, Vi).getFrmDisabled(t));\n    rt(this, Xi, void 0);\n    rt(this, Ar, void 0);\n    rt(this, rr, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh(\"｜　《\" + t + \"》\"));\n    Ot(this, \"goTxt\", () => {\n    });\n    Ot(this, \"breakLine\", () => {\n    });\n    Ot(this, \"breakPage\", () => {\n    });\n    rt(this, ae, {});\n    // しおりLoad時再読込\n    rt(this, Kr, []);\n    // 最適化用\n    rt(this, Zr, \"\");\n    rt(this, fl, \"\");\n    rt(this, wh, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`);\n    rt(this, dl, {\n      rule: Texture.EMPTY,\n      vague: 0,\n      tick: 0\n    });\n    rt(this, Ch, new Filter(void 0, H(this, wh), H(this, dl)));\n    rt(this, Un, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    rt(this, jn, new Sprite(H(this, Un)));\n    rt(this, mi, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    rt(this, Ae, new Sprite(H(this, mi)));\n    rt(this, zn, []);\n    rt(this, Ne, { tw: void 0, resume: !1 });\n    // トゥイーン開始\n    rt(this, hr, {});\n    rt(this, cr, (t) => {\n      throw H(this, Xn).call(this), 0;\n    });\n    // 操作対象のメッセージレイヤの指定\n    rt(this, pl, (t) => {\n      throw H(this, Xn).call(this), 0;\n    });\n    rt(this, Jr, void 0);\n    // カレントテキストレイヤ\n    rt(this, Xn, () => {\n      throw \"文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい\";\n    });\n    rt(this, Nr, \"\");\n    rt(this, Qr, []);\n    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = D, this.main = N, this.scrItr = k, this.sys = $, this.sndMng = G, this.alzTagArg = U, this.prpPrs = z;\n    const X = () => {\n      if ($.cvsResize(), this.cvsResizeDesign(), H(this, ba))\n        for (const W of H(this, Kr))\n          H(this, ae)[W].fore.cvsResizeChildren();\n      else\n        for (const W of H(this, Kr))\n          H(this, ae)[W].fore.cvsResize();\n      H(this, Vi).cvsResize(), H(this, Ar).cvsResize();\n    };\n    if (CmnLib.isMobile)\n      H(this, ya).add(globalThis, \"orientationchange\", X, { passive: !0 });\n    else {\n      let W;\n      H(this, ya).add(globalThis, \"resize\", () => {\n        W || (W = setTimeout(() => {\n          W = void 0, X();\n        }, 1e3 / 60 * 10));\n      }, { passive: !0 });\n    }\n    $.cvsResize(), TxtLayer.init(t, e, D, this, (W) => H(this, ae)[W.layname].fore === W, r), GrpLayer.init(N, t, r, $, G, D), Button.init(t), ot(this, Vi, new FrameMng(t, e, r, D, N, $, H(this, hr))), $.hFactoryCls.grp = () => new GrpLayer(), $.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (W) => lt(this, xh, wd).call(this, W), e.snapshot = (W) => lt(this, bh, Td).call(this, W), e.add_lay = (W) => lt(this, Sh, Cd).call(this, W), e.clear_lay = (W) => lt(this, Th, Md).call(this, W), e.finish_trans = () => lt(this, Hn, Ya).call(this), e.lay = (W) => lt(this, Eh, Pd).call(this, W), e.trans = (W) => lt(this, Ph, Rd).call(this, W), e.wt = (W) => lt(this, Oh, Dd).call(this, W), e.quake = (W) => lt(this, Ih, Ad).call(this, W), e.stop_quake = (W) => e.finish_trans(W), e.wq = (W) => e.wt(W), e.pause_tsy = (W) => lt(this, Lh, Bd).call(this, W), e.resume_tsy = (W) => lt(this, kh, Fd).call(this, W), e.stop_tsy = (W) => lt(this, Nh, kd).call(this, W), e.tsy = (W) => lt(this, Dh, Nd).call(this, W), e.wait_tsy = (W) => lt(this, Ah, Ld).call(this, W), e.ch = (W) => lt(this, Vn, Wa).call(this, W), e.clear_text = (W) => lt(this, $h, Ud).call(this, W), e.current = (W) => H(this, pl).call(this, W), e.endlink = (W) => lt(this, Gh, jd).call(this, W), e.er = (W) => lt(this, Uh, zd).call(this, W), e.graph = (W) => lt(this, jh, Hd).call(this, W), e.link = (W) => lt(this, zh, Vd).call(this, W), e.r = (W) => lt(this, Hh, Xd).call(this, W), e.rec_ch = (W) => lt(this, vl, yf).call(this, W), e.rec_r = (W) => lt(this, Vh, Yd).call(this, W), e.reset_rec = (W) => lt(this, Xh, Wd).call(this, W), e.ruby2 = (W) => lt(this, Yh, qd).call(this, W), e.span = (W) => lt(this, Wh, Kd).call(this, W), e.tcy = (W) => lt(this, qh, Zd).call(this, W), e.add_face = (W) => GrpLayer.add_face(W), e.wv = (W) => GrpLayer.wv(W), e.dump_lay = (W) => lt(this, Kh, Jd).call(this, W), e.enable_event = (W) => lt(this, Zh, Qd).call(this, W), e.button = (W) => lt(this, Jh, tp).call(this, W), t.existsBreakline && (this.breakLine = () => H(this, rr).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakline\"}')), t.existsBreakpage && (this.breakPage = () => H(this, rr).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakpage\"}')), ot(this, Gn, parseColor(String(t.oCfg.init.bg_color)));\n    const V = new Graphics();\n    V.beginFill(H(this, Gn), 1).lineStyle(0, H(this, Gn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), H(this, le).addChild(V.clone()), H(this, Te).addChild(V), H(this, Te).visible = !1, H(this, le).name = \"page:A\", H(this, Te).name = \"page:B\", ot(this, br, r.stage), H(this, br).addChild(H(this, Te)), H(this, br).addChild(H(this, le)), H(this, br).addChild(H(this, jn)), H(this, br).addChild(H(this, Ae)), H(this, br).name = \"stage\", r.ticker.add(H(this, ll));\n    const Y = (W, K) => {\n      lt(this, yh, Ed).call(this, Number(K));\n    };\n    Y(\"\", D.getVal(\"sys:TextLayer.Back.Alpha\", 1)), D.defValTrg(\"sys:TextLayer.Back.Alpha\", Y);\n    const q = (W, K) => Button.fontFamily = K;\n    q(\"\", D.getVal(\"tmp:sn.button.fontFamily\", Button.fontFamily)), D.defValTrg(\"tmp:sn.button.fontFamily\", q), D.defTmp(\"const.sn.log.json\", () => JSON.stringify(\n      H(this, Nr) ? [...H(this, Qr), { text: H(this, Nr).replaceAll(\"</span><span class='sn_ch'>\", \"\") }] : H(this, Qr)\n    )), D.defTmp(\"const.sn.last_page_text\", () => {\n      var W;\n      return ((W = this.currentTxtlayFore) == null ? void 0 : W.pageText) ?? \"\";\n    }), CmnLib.isDbg && (DesignCast.init(r, $, k, z, U, t, H(this, ae)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), $.addHook((W, K) => {\n      var Z, J;\n      (J = (Z = H(this, ul))[W]) != null && J.call(Z, W, K) && delete H(this, ul)[W];\n    }));\n  }\n  cvsResizeDesign() {\n  }\n  cover(t, e = 0) {\n    H(this, Xi) && (H(this, br).removeChild(H(this, Xi)), H(this, Xi).destroy(), ot(this, Xi, void 0)), t && H(this, br).addChild(\n      ot(this, Xi, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()\n    );\n  }\n  setEvtMng(t) {\n    ot(this, Ar, t), H(this, Vi).setEvtMng(t), GrpLayer.setEvtMng(t);\n  }\n  before_destroy() {\n    for (const t of Object.values(H(this, ae)))\n      t.destroy();\n  }\n  destroy() {\n    H(this, ya).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), H(this, Vi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(H(this, ll)), ot(Di, Yi, 10);\n  }\n  // トゥイーン全停止\n  stopAllTw() {\n    ot(this, hr, {}), removeAll();\n  }\n  clearBreak() {\n    this.currentTxtlayFore && (this.clearBreak = () => H(this, rr).call(this, \"del｜break\"), this.clearBreak());\n  }\n  clickTxtLay() {\n    return this.currentTxtlayFore ? lt(this, Ke, sr).call(this).some((t) => {\n      const e = H(this, ae)[t].fore;\n      return e instanceof TxtLayer && e.click();\n    }) : !1;\n  }\n  static get msecChWait() {\n    return H(Di, Yi);\n  }\n  static set msecChWait(t) {\n    ot(Di, Yi, t);\n  }\n  setNormalChWait() {\n    ot(Di, Yi, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    return H(this, Xn).call(this), this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    return H(this, Jr) ? H(this, Jr).fore : null;\n  }\n  recText(t) {\n    ot(this, Nr, t), this.val.setVal_Nochk(\n      \"save\",\n      \"const.sn.sLog\",\n      String(this.val.getVal(\"const.sn.log.json\"))\n      // これを起動したい\n    );\n  }\n  recPagebreak() {\n    if (!H(this, Nr))\n      return;\n    const t = H(this, Nr).replaceAll(\"</span><span class='sn_ch'>\", \"\");\n    H(this, Qr).push({ text: t }) > this.cfg.oCfg.log.max_len && ot(this, Qr, H(this, Qr).slice(-this.cfg.oCfg.log.max_len)), ot(this, Nr, \"\");\n  }\n  record() {\n    const t = {};\n    for (const e of H(this, Kr)) {\n      const r = H(this, ae)[e];\n      t[e] = {\n        cls: r.cls,\n        fore: r.fore.record(),\n        back: r.back.record()\n      };\n    }\n    return t;\n  }\n  playback(t, e) {\n    var k;\n    ot(this, Qr, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\")))), ot(this, Nr, \"\");\n    const r = [], D = [];\n    for (const [$, { fore: G, fore: { idx: U }, back: z, cls: X }] of Object.entries(t)) {\n      D.push({ layer: $, idx: U });\n      const V = (k = H(this, ae))[$] ?? (k[$] = new Pages($, X, H(this, le), H(this, Te), {}, this.sys, this.val, { isWait: !1 }));\n      V.fore.playback(G, r), V.back.playback(z, r);\n    }\n    const N = H(this, le).children.length;\n    Promise.allSettled(r).then(() => {\n      for (const { layer: $, idx: G } of D.sort(({ idx: U }, { idx: z }) => U === z ? 0 : U < z ? -1 : 1)) {\n        const { fore: U, back: z } = H(this, ae)[$];\n        if (!U)\n          return;\n        const X = N > G ? G : N - 1;\n        H(this, le).setChildIndex(U.spLay, X), H(this, Te).setChildIndex(z.spLay, X);\n      }\n      e();\n    }).catch(($) => console.error(\"fn:LayerMng.ts playback e:%o\", $));\n  }\n};\nlet LayerMng = Di;\nbr = new WeakMap(), le = new WeakMap(), Te = new WeakMap(), Vi = new WeakMap(), Gn = new WeakMap(), ya = new WeakMap(), ll = new WeakMap(), ul = new WeakMap(), hl = new WeakMap(), ba = new WeakMap(), cl = new WeakSet(), _f = function(t) {\n  [Ie(this, hl)._, this.ba = \"\"] = t.split(\"/\");\n  const e = H(this, ae)[H(this, hl)];\n  e && (DesignCast.allHide(), H(this, ba) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());\n}, Xi = new WeakMap(), Ar = new WeakMap(), yh = new WeakSet(), Ed = function(t) {\n  for (const e of lt(this, Ke, sr).call(this)) {\n    const r = H(this, ae)[e];\n    r.fore instanceof TxtLayer && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));\n  }\n}, rr = new WeakMap(), bh = new WeakSet(), Td = function(t) {\n  const e = t.fn ? t.fn.slice(0, 10) === \"userdata:/\" ? t.fn : `downloads:/${t.fn + getDateStr(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${getDateStr(\"-\", \"_\", \"\", \"_\")}.png`, r = this.cfg.searchPath(e);\n  if (!(\"layer\" in t) && this.sys.canCapturePage(r, () => this.main.resume()))\n    return !0;\n  const D = getExt(r), N = argChk_Color(t, \"b_color\", H(this, Gn)), k = autoDetectRenderer({\n    width: argChk_Num(t, \"width\", CmnLib.stageW),\n    height: argChk_Num(t, \"height\", CmnLib.stageH),\n    backgroundAlpha: N > 16777216 && D === \"png\" ? 0 : 1,\n    antialias: argChk_Boolean(t, \"smoothing\", !1),\n    preserveDrawingBuffer: !0,\n    backgroundColor: N & 16777215,\n    autoDensity: !0\n  }), $ = [], G = t.page !== \"back\" ? \"fore\" : \"back\";\n  if (H(this, Ne).tw)\n    $.push(new Promise((U) => {\n      H(this, Te).visible = !0;\n      for (const z of H(this, zn))\n        k.render(z, { clear: !1 });\n      H(this, Te).visible = !1, H(this, jn).visible = !0, H(this, le).filters = H(this, Ae).filters, H(this, le).visible = !0, k.render(H(this, le), { clear: !1 }), H(this, le).visible = !1, H(this, le).filters = [], U();\n    }));\n  else\n    for (const U of lt(this, Ke, sr).call(this, t.layer))\n      $.push(\n        new Promise((z) => H(this, ae)[U][G].snapshot(k, () => z()))\n      );\n  return Promise.allSettled($).then(async () => {\n    const U = RenderTexture.create({ width: k.width, height: k.height });\n    if (k.render(H(this, br), { renderTexture: U }), await this.sys.savePic(\n      r,\n      k.plugins.extract.base64(Sprite.from(U))\n    ), !H(this, Ne).tw)\n      for (const z of lt(this, Ke, sr).call(this, t.layer))\n        H(this, ae)[z][G].snapshot_end();\n    k.destroy(!0), this.main.resume();\n  }), !0;\n}, xh = new WeakSet(), wd = function(t) {\n  const { fn: e } = t;\n  if (!e)\n    throw \"fnは必須です\";\n  const r = argChk_Boolean(t, \"join\", !0);\n  switch (getExt(e)) {\n    case \"css\":\n      (async () => {\n        const D = await fetch(e);\n        if (!D.ok)\n          throw new Error(\"Network response was not ok.\");\n        addStyle(await D.text()), r && this.main.resume();\n      })();\n      break;\n    default:\n      throw \"サポートされない拡張子です\";\n  }\n  return r;\n}, Sh = new WeakSet(), Cd = function(t) {\n  const { layer: e, class: r } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  if (e.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (e in H(this, ae))\n    throw `layer【${e}】はすでにあります`;\n  if (!r)\n    throw \"clsは必須です\";\n  const D = { isWait: !1 };\n  switch (H(this, ae)[e] = new Pages(e, r, H(this, le), H(this, Te), t, this.sys, this.val, D), H(this, Kr).push(e), r) {\n    case \"txt\":\n      H(this, Zr) || (ot(this, Xn, () => {\n      }), ot(this, cr, lt(this, Bh, $d)), ot(this, pl, lt(this, Fh, Gd)), this.hTag.current({ layer: e }), this.goTxt = () => {\n        this.val.getVal(\"sn.skip.enabled\") ? ot(Di, Yi, 0) : this.setNormalChWait();\n        for (const N of lt(this, Ke, sr).call(this)) {\n          const k = H(this, ae)[N].fore;\n          k instanceof TxtLayer && H(this, rr).call(this, \"gotxt｜\", k, !1);\n        }\n      }), this.val.setVal_Nochk(\n        \"save\",\n        \"const.sn.layer.\" + (e ?? H(this, Zr)) + \".enabled\",\n        !0\n      );\n      break;\n    case \"grp\":\n      if (H(this, fl))\n        break;\n      ot(this, fl, e);\n      break;\n  }\n  return this.scrItr.recodeDesign(t), D.isWait;\n}, ae = new WeakMap(), Kr = new WeakMap(), Zr = new WeakMap(), fl = new WeakMap(), Eh = new WeakSet(), Pd = function(t) {\n  const e = lt(this, Wi, Es).call(this, t), r = H(this, ae)[e], D = r.back.spLay, N = r.fore.spLay;\n  if (argChk_Boolean(t, \"float\", !1))\n    H(this, Te).setChildIndex(D, H(this, Te).children.length - 1), H(this, le).setChildIndex(N, H(this, le).children.length - 1), lt(this, xa, mu).call(this);\n  else if (t.index)\n    argChk_Num(t, \"index\", 0) && (H(this, Te).setChildIndex(D, t.index), H(this, le).setChildIndex(N, t.index), lt(this, xa, mu).call(this));\n  else if (t.dive) {\n    const { dive: k } = t;\n    let $ = 0;\n    if (e === k)\n      throw \"[lay] 属性 layerとdiveが同じ【\" + k + \"】です\";\n    const G = H(this, ae)[k];\n    if (!G)\n      throw \"[lay] 属性 dive【\" + k + \"】が不正です。レイヤーがありません\";\n    const U = G.back, z = G.fore, X = H(this, Te).getChildIndex(U.spLay), V = H(this, le).getChildIndex(z.spLay);\n    $ = X < V ? X : V, $ > H(this, Te).getChildIndex(D) && --$, H(this, le).setChildIndex(N, $), H(this, Te).setChildIndex(D, $), lt(this, xa, mu).call(this);\n  }\n  return t[\":id_tag\"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);\n}, xa = new WeakSet(), mu = function() {\n  ot(this, Kr, lt(this, Rh, Id).call(this));\n}, Th = new WeakSet(), Md = function(t) {\n  return lt(this, Mh, Od).call(this, t, (e) => {\n    const r = H(this, ae)[lt(this, Wi, Es).call(this, { layer: e })];\n    t.page === \"both\" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);\n  }), !1;\n}, wh = new WeakMap(), dl = new WeakMap(), Ch = new WeakMap(), Un = new WeakMap(), jn = new WeakMap(), mi = new WeakMap(), Ae = new WeakMap(), zn = new WeakMap(), Ph = new WeakSet(), Rd = function(t) {\n  lt(this, Hn, Ya).call(this), H(this, Ar).hideHint();\n  const { layer: e } = t;\n  ot(this, zn, []);\n  const r = {}, D = [];\n  for (const K of lt(this, Ke, sr).call(this, e))\n    r[K] = !0, D.push(H(this, ae)[K].fore);\n  const N = [];\n  for (const K of lt(this, Ke, sr).call(this)) {\n    const Z = H(this, ae)[K][r[K] ? \"back\" : \"fore\"];\n    H(this, zn).push(Z.spLay), N.push(Z);\n  }\n  H(this, Un).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, Te), { renderTexture: H(this, Un) });\n  let k = () => {\n    H(this, Te).visible = !0;\n    for (const K of H(this, zn))\n      this.appPixi.renderer.render(K, { renderTexture: H(this, Un), clear: !1 });\n    H(this, Te).visible = !1;\n  };\n  if (!N.some((K) => K.containMovement)) {\n    let K = k;\n    k = () => {\n      k = () => {\n      }, K();\n    };\n  }\n  H(this, mi).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, le), { renderTexture: H(this, mi) });\n  let $ = () => {\n    H(this, le).visible = !0, this.appPixi.renderer.render(H(this, le), { renderTexture: H(this, mi) }), H(this, le).visible = !1;\n  };\n  if (!D.some((K) => K.containMovement)) {\n    let K = $;\n    $ = () => {\n      $ = () => {\n      }, K();\n    };\n  }\n  const G = () => {\n    k(), H(this, jn).visible = !0, $(), H(this, Ae).visible = !0;\n  };\n  H(this, Ae).alpha = 1;\n  const U = () => {\n    var Z;\n    this.appPixi.ticker && this.appPixi.ticker.remove(G), [Ie(this, le)._, Ie(this, Te)._] = [H(this, Te), H(this, le)];\n    const K = [];\n    for (const [J, Q] of Object.entries(H(this, ae))) {\n      if (r[J]) {\n        Q.transPage(K);\n        continue;\n      }\n      const { fore: { spLay: et }, back: { spLay: nt } } = Q, tt = H(this, le).getChildIndex(nt);\n      H(this, le).removeChild(nt), H(this, Te).removeChild(et), H(this, le).addChildAt(et, tt), H(this, Te).addChildAt(nt, tt);\n    }\n    Promise.allSettled(K), H(this, le).visible = !0, H(this, Te).visible = !1, H(this, jn).visible = !1, H(this, Ae).visible = !1, (Z = H(this, Ne).tw) == null || Z.stop(), H(this, Ne).resume && this.main.resume(), ot(this, Ne, { tw: void 0, resume: !1 });\n  };\n  ot(this, Ne, { tw: void 0, resume: !1 });\n  const z = argChk_Num(t, \"time\", 0);\n  if (z === 0 || H(this, Ar).isSkippingByKeyDown())\n    return U(), !1;\n  const { ease: X, glsl: V, rule: Y } = t, q = CmnTween.ease(X);\n  if (!V && !Y)\n    return H(this, Ae).filters = [], H(this, Ne).tw = new Tween(H(this, Ae)).to({ alpha: 0 }, z).delay(argChk_Num(t, \"delay\", 0)).easing(q).onComplete(U).start(), this.appPixi.ticker.add(G), !1;\n  const W = V ? new Filter(void 0, V, H(this, dl)) : H(this, Ch);\n  if (W.uniforms.vague = argChk_Num(t, \"vague\", 0.04), W.uniforms.tick = 0, H(this, Ne).tw = new Tween(W.uniforms).to({ tick: 1 }, z).delay(argChk_Num(t, \"delay\", 0)).easing(q).onComplete(U), H(this, Ae).filters = [W], V)\n    return H(this, Ne).tw.start(), this.appPixi.ticker.add(G), !1;\n  if (!Y)\n    throw \"ruleが指定されていません\";\n  return GrpLayer.csv2Sprites(Y, void 0, (K) => {\n    var Z;\n    W.uniforms.rule = K.texture, K.destroy(), (Z = H(this, Ne).tw) == null || Z.start(), this.appPixi.ticker.add(G);\n  }), !1;\n}, Ne = new WeakMap(), Ke = new WeakSet(), sr = function(t = \"\") {\n  return t ? t.split(\",\") : H(this, Kr);\n}, Mh = new WeakSet(), Od = function(t, e) {\n  const r = lt(this, Ke, sr).call(this, t.layer);\n  for (const D of r) {\n    if (!D)\n      continue;\n    const N = H(this, ae)[D];\n    if (!N)\n      throw \"存在しないlayer【\" + D + \"】です\";\n    e(D, N);\n  }\n  return r;\n}, Rh = new WeakSet(), Id = function(t = \"\") {\n  return lt(this, Ke, sr).call(this, t).sort((e, r) => {\n    const D = H(this, le).getChildIndex(H(this, ae)[e].fore.spLay), N = H(this, le).getChildIndex(H(this, ae)[r].fore.spLay);\n    return D < N ? -1 : D > N ? 1 : 0;\n  });\n}, Oh = new WeakSet(), Dd = function(t) {\n  return H(this, Ne).tw ? (H(this, Ne).resume = !0, H(this, Ar).waitLimitedEvent(t, () => lt(this, Hn, Ya).call(this))) : !1;\n}, Hn = new WeakSet(), Ya = function() {\n  var t;\n  return (t = H(this, Ne).tw) == null || t.end(), !1;\n}, Ih = new WeakSet(), Ad = function(t) {\n  lt(this, Hn, Ya).call(this);\n  const e = argChk_Num(t, \"time\", NaN);\n  if (e === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, Ar).isSkippingByKeyDown())\n    return !1;\n  const { layer: r, ease: D } = t, N = [];\n  for (const Y of lt(this, Ke, sr).call(this, r))\n    N.push(H(this, ae)[Y].fore.spLay);\n  H(this, mi).resize(CmnLib.stageW, CmnLib.stageH);\n  const k = () => {\n    H(this, le).visible = !0;\n    for (const Y of N)\n      this.appPixi.renderer.render(\n        Y,\n        { renderTexture: H(this, mi), clear: !1 }\n      );\n    H(this, le).visible = !1;\n  };\n  H(this, Ae).visible = !0, H(this, Ae).alpha = 1;\n  const $ = uint(argChk_Num(t, \"hmax\", 10)), G = uint(argChk_Num(t, \"vmax\", 10)), U = $ === 0 ? () => {\n  } : () => H(this, Ae).x = Math.round(Math.random() * $ * 2) - $, z = G === 0 ? () => {\n  } : () => H(this, Ae).y = Math.round(Math.random() * G * 2) - G;\n  H(this, Ae).filters = [];\n  const X = argChk_Num(t, \"repeat\", 1), V = new Tween(H(this, Ae)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(D)).onUpdate(() => {\n    U(), z();\n  }).repeat(X === 0 ? 1 / 0 : X - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onComplete(() => {\n    var Y, q;\n    (Y = this.appPixi.ticker) == null || Y.remove(k), H(this, le).visible = !0, H(this, Ae).visible = !1, H(this, Ae).x = 0, H(this, Ae).y = 0, (q = H(this, Ne).tw) == null || q.stop(), H(this, Ne).resume && this.main.resume(), ot(this, Ne, { tw: void 0, resume: !1 });\n  }).start();\n  return ot(this, Ne, { tw: V, resume: !1 }), this.appPixi.ticker.add(k), !1;\n}, hr = new WeakMap(), Dh = new WeakSet(), Nd = function(t) {\n  const { layer: e, render: r, path: D, name: N, ease: k, chain: $ } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  const G = lt(this, Wi, Es).call(this, t);\n  let U = H(this, ae)[G].fore, z = () => {\n  };\n  const X = H(this, Ar).isSkippingByKeyDown();\n  !X && r && (U.renderStart(), z = () => U.renderEnd());\n  const V = N ?? e, Y = () => {\n    var ut, ft;\n    const at = H(this, hr)[V];\n    at && (z(), delete H(this, hr)[V], (ut = at.tw) == null || ut.stop(), at.resume && this.main.resume(), (ft = at.onEnd) == null || ft.call(at));\n  }, q = cnvTweenArg(t, U), W = argChk_Num(t, \"time\", NaN) * (this.val.getVal(\"tmp:sn.skip.enabled\") || X ? 0 : 1), K = CmnTween.ease(k), Z = argChk_Num(t, \"repeat\", 1), J = Z === 0 ? 1 / 0 : Z - 1, Q = argChk_Boolean(t, \"yoyo\", !1), et = argChk_Num(t, \"delay\", 0), nt = new Tween(U).to(q, W).easing(K).repeat(J).yoyo(Q).delay(et);\n  let tt = nt;\n  if (D) {\n    CmnLib.debugLog && console.group(`🍝 [tsy] path=${D}= start(${U.x},${U.y},${U.alpha})`);\n    for (const { groups: at } of D.matchAll(Di.REG_TSY_PATH)) {\n      const { x: ut, x2: ft, y: ct, y2: vt, o: yt, o2: mt, json: _t } = at;\n      let Tt = {};\n      if (_t)\n        try {\n          Tt = JSON.parse(_t);\n        } catch (gt) {\n          console.error(`🍝 json=${_t} ` + gt);\n          continue;\n        }\n      else\n        (ut ?? ft) && (Tt.x = ut ?? ft), (ct ?? vt) && (Tt.y = ct ?? vt), (yt ?? mt) && (Tt.alpha = yt ?? mt);\n      const Pt = cnvTweenArg(Tt, U);\n      CmnLib.debugLog && console.info(`🍝 ${_t ?? `{x:${ut} y:${ct} o:${yt}}`} => hTo:${JSON.stringify(Pt)}`);\n      const St = new Tween(U).to(Pt, W).easing(K).repeat(J).yoyo(Q);\n      tt.chain(St), tt = St;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (tt.onComplete(Y), $) {\n    const at = H(this, hr)[$ ?? \"\"];\n    if (!(at != null && at.tw))\n      throw `${$}は存在しない・または終了したトゥイーンです`;\n    delete at.onEnd, at.tw.chain(nt);\n  } else\n    nt.start();\n  const it = argChk_Boolean(t, \"arrive\", !1), st = argChk_Boolean(t, \"backlay\", !1);\n  return H(this, hr)[V] = { tw: tt, resume: !1, onEnd: () => {\n    if (it && Object.assign(U, q), st) {\n      const at = H(this, ae)[G].back.spLay;\n      for (const ut of Object.keys(hMemberCnt))\n        at[ut] = U[ut];\n    }\n  } }, !1;\n}, Ah = new WeakSet(), Ld = function(t) {\n  const { layer: e = \"\", id: r, name: D } = t, N = r ? `frm\n${r}` : D ?? e;\n  if (!N)\n    throw \"トゥイーンが指定されていません\";\n  const k = H(this, hr)[N];\n  return k != null && k.tw ? k.resume = H(this, Ar).waitEvent(\n    () => {\n      var $;\n      return ($ = k.tw) == null ? void 0 : $.end();\n    },\n    // stop()とend()は別\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ) : !1;\n}, Nh = new WeakSet(), kd = function(t) {\n  var k, $;\n  const { layer: e = \"\", id: r, name: D } = t, N = r ? `frm\n${r}` : D ?? e;\n  if (!N)\n    throw \"トゥイーンが指定されていません\";\n  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.end(), !1;\n}, Lh = new WeakSet(), Bd = function(t) {\n  var k, $;\n  const { layer: e = \"\", id: r, name: D } = t, N = r ? `frm\n${r}` : D ?? e;\n  if (!N)\n    throw \"トゥイーンが指定されていません\";\n  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.pause(), !1;\n}, kh = new WeakSet(), Fd = function(t) {\n  var k, $;\n  const { layer: e = \"\", id: r, name: D } = t, N = r ? `frm\n${r}` : D ?? e;\n  if (!N)\n    throw \"トゥイーンが指定されていません\";\n  return ($ = (k = H(this, hr)[N]) == null ? void 0 : k.tw) == null || $.resume(), !1;\n}, Yi = new WeakMap(), Vn = new WeakSet(), Wa = function(t) {\n  const { text: e } = t;\n  if (!e)\n    throw \"textは必須です\";\n  const r = H(this, cr).call(this, t);\n  delete t.text, this.val.getVal(\"tmp:sn.skip.enabled\") ? t.wait = 0 : \"wait\" in t && argChk_Num(t, \"wait\", NaN);\n  const D = encodeURIComponent(JSON.stringify(t));\n  H(this, rr).call(this, \"add｜\" + D, r);\n  const N = argChk_Boolean(t, \"record\", !0), k = this.val.doRecLog();\n  return N || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", N), r.tagCh(e.replaceAll(\"[r]\", `\n`)), this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", k), H(this, rr).call(this, \"add_close｜\", r), !1;\n}, cr = new WeakMap(), Bh = new WeakSet(), $d = function(t) {\n  const e = lt(this, Wi, Es).call(this, t, H(this, Zr)), D = H(this, ae)[e].getPage(t);\n  if (!(D instanceof TxtLayer))\n    throw e + \"はTxtLayerではありません\";\n  return D;\n}, pl = new WeakMap(), Fh = new WeakSet(), Gd = function(t) {\n  const { layer: e } = t;\n  if (!e)\n    throw \"[current] layerは必須です\";\n  if (ot(this, Jr, H(this, ae)[e]), !(H(this, Jr).getPage(t) instanceof TxtLayer))\n    throw `${e}はTxtLayerではありません`;\n  this.recPagebreak(), ot(this, Zr, e), this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", e);\n  for (const r of lt(this, Ke, sr).call(this)) {\n    const D = H(this, ae)[r];\n    D.fore instanceof TxtLayer && (D.fore.isCur = D.back.isCur = r === e);\n  }\n  return !1;\n}, Jr = new WeakMap(), Xn = new WeakMap(), Wi = new WeakSet(), Es = function(t, e = \"\") {\n  const r = t.layer ?? e;\n  if (r.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (!(r in H(this, ae)))\n    throw \"属性 layer【\" + r + \"】が不正です。レイヤーがありません\";\n  return t.layer = r;\n}, Nr = new WeakMap(), Qr = new WeakMap(), $h = new WeakSet(), Ud = function(t) {\n  const e = H(this, cr).call(this, t);\n  return t.layer === H(this, Zr) && t.page === \"fore\" && this.recPagebreak(), e.clearText(), !1;\n}, Gh = new WeakSet(), jd = function(t) {\n  return H(this, rr).call(this, \"endlink｜\", H(this, cr).call(this, t)), !1;\n}, Uh = new WeakSet(), zd = function(t) {\n  return argChk_Boolean(t, \"rec_page_break\", !0) && this.recPagebreak(), H(this, Jr) && (H(this, Jr).fore.clearLay(t), H(this, Jr).back.clearLay(t)), !1;\n}, jh = new WeakSet(), Hd = function(t) {\n  if (!t.pic)\n    throw \"[graph] picは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, rr).call(this, \"grp｜\" + e, H(this, cr).call(this, t)), !1;\n}, zh = new WeakSet(), Vd = function(t) {\n  t.style ?? (t.style = \"background-color: rgba(255,0,0,0.5);\"), t.style_hover ?? (t.style_hover = \"background-color: rgba(255,0,0,0.9);\"), t.style_clicked ?? (t.style_clicked = t.style);\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, rr).call(this, \"link｜\" + e, H(this, cr).call(this, t)), !1;\n}, Hh = new WeakSet(), Xd = function(t) {\n  return t.text = `\n`, lt(this, Vn, Wa).call(this, t);\n}, Vh = new WeakSet(), Yd = function(t) {\n  return lt(this, vl, yf).call(this, { ...t, text: \"[r]\" });\n}, vl = new WeakSet(), yf = function(t) {\n  return t.text ? (t.record = !0, t.style ?? (t.style = \"\"), t.style += \"display: none;\", t.wait = 0, lt(this, Vn, Wa).call(this, t)) : !1;\n}, Xh = new WeakSet(), Wd = function(t) {\n  return ot(this, Qr, []), ot(this, Nr, t.text ?? \"\"), this.val.setVal_Nochk(\n    \"save\",\n    \"const.sn.sLog\",\n    t.text ? `[{text:\"${t.text}\"}]` : \"[]\"\n  ), !1;\n}, Yh = new WeakSet(), qd = function(t) {\n  const { t: e, r } = t;\n  if (!e)\n    throw \"[ruby2] tは必須です\";\n  if (!r)\n    throw \"[ruby2] rは必須です\";\n  return t.text = \"｜\" + encodeURIComponent(e) + \"《\" + encodeURIComponent(r) + \"》\", delete t.t, delete t.r, lt(this, Vn, Wa).call(this, t);\n}, Wh = new WeakSet(), Kd = function(t) {\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, rr).call(this, \"span｜\" + e, H(this, cr).call(this, t)), !1;\n}, qh = new WeakSet(), Zd = function(t) {\n  if (!t.t)\n    throw \"[tcy] tは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, rr).call(this, \"tcy｜\" + e, H(this, cr).call(this, t)), !1;\n}, Kh = new WeakSet(), Jd = function(t) {\n  console.group(\"🥟 [dump_lay]\");\n  for (const e of lt(this, Ke, sr).call(this, t.layer)) {\n    const r = H(this, ae)[e];\n    try {\n      console.info(\n        `%c${r.fore.name.slice(0, -7)} %o`,\n        `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`,\n        JSON.parse(`{\"back\":{${r.back.dump()}}, \"fore\":{${r.fore.dump()}}}`)\n      );\n    } catch (D) {\n      console.error(\"dump_lay err:%o\", D), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);\n    }\n  }\n  return console.groupEnd(), !1;\n}, Zh = new WeakSet(), Qd = function(t) {\n  const e = lt(this, Wi, Es).call(this, t, H(this, Zr)), r = argChk_Boolean(t, \"enabled\", !0);\n  return H(this, cr).call(this, t).enabled = r, this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + e + \".enabled\", r), !1;\n}, Jh = new WeakSet(), tp = function(t) {\n  return Pages.argChk_page(t, \"back\"), t.clicksebuf ?? (t.clicksebuf = \"SYS\"), t.entersebuf ?? (t.entersebuf = \"SYS\"), t.leavesebuf ?? (t.leavesebuf = \"SYS\"), t.fn || (t.fn = this.scrItr.scriptFn), H(this, cr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;\n}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1\n// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\\n\n/*\n\\(\\s*\n(?:\t(?<x>[-=\\d\\.]+)\t|\t(['\"])\t(?<x2>.*?)\t\\2\t)?\n(?:\n\t\\s*,\\s*\n\t(?:\t(?<y>[-=\\d\\.]+)\t|\t(['\"])\t(?<y2>.*?)\t\\5\t)?\n\t(?:\n\t\t\\s*,\\s*\n\t\t(?:\t(?<o>[-=\\d\\.]+)\t|\t(['\"])\t(?<o2>.*?)\t\\8\t)\n\n\t)?\n)?\n|\n(?<json>\\{[^{}]*})\n*/\nOt(LayerMng, \"REG_TSY_PATH\", /\\(\\s*(?:(?<x>[-=\\d\\.]+)|(['\"])(?<x2>.*?)\\2)?(?:\\s*,\\s*(?:(?<y>[-=\\d\\.]+)|(['\"])(?<y2>.*?)\\5)?(?:\\s*,\\s*(?:(?<o>[-=\\d\\.]+)|(['\"])(?<o2>.*?)\\8))?)?|(?<json>\\{[^{}]*})/g), //\t// 文字・文字レイヤ\nrt(LayerMng, Yi, 10);\nvar Ce, be, Sa, Qh, ep, gl, Yn, qa;\nclass FocusMng {\n  constructor() {\n    rt(this, Qh);\n    rt(this, Yn);\n    rt(this, Ce, []);\n    rt(this, be, -1);\n    rt(this, Sa, new EventListenerCtn());\n    rt(this, gl, CmnLib.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, H(this, Ce)[t].btn) : () => {\n    });\n  }\n  destroy() {\n    ot(this, Ce, []), ot(this, be, -1), H(this, Sa).clear();\n  }\n  add(t, e, r) {\n    if (H(this, Ce).findIndex(($) => $.btn === t) >= 0)\n      return;\n    if (t instanceof Container) {\n      t.on(\"pointerdown\", () => {\n        for (let $ = H(this, Ce).length - 1; $ >= 0; --$)\n          if (H(this, Ce)[$].btn === t) {\n            ot(this, be, $);\n            return;\n          }\n        ot(this, be, -1);\n      }), H(this, Ce).push({ btn: t, on: e, off: r });\n      return;\n    }\n    H(this, Sa).add(t, \"focus\", () => {\n      for (let $ = H(this, Ce).length - 1; $ >= 0; --$)\n        if (H(this, Ce)[$].btn === t) {\n          ot(this, be, $);\n          return;\n        }\n      ot(this, be, -1);\n    });\n    let D = ($) => {\n    }, N = t.localName === \"button\" || t.localName === \"a\" ? ($) => !$.isTrusted && $.key === \"Enter\" : ($) => $.key === \"Enter\";\n    const k = t;\n    switch (k.type ?? \"\") {\n      case \"checkbox\":\n        D = () => k.checked = !k.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (D = ($) => lt(this, Qh, ep).call(this, t, $.key), N = () => !1);\n        break;\n      case \"range\":\n        D = ($) => {\n          $.isTrusted || ($.key === \"ArrowUp\" ? k.stepUp() : k.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        D = ($) => {\n          if ($.isTrusted)\n            return;\n          let G = (k.selectionStart ?? 0) + ($.key === \"ArrowUp\" ? -1 : 1);\n          G < 0 && (G = 0), k.setSelectionRange(G, G);\n        };\n        break;\n    }\n    H(this, Sa).add(t, \"keydown\", ($) => {\n      if (!($.key !== \"ArrowUp\" && $.key !== \"ArrowDown\" && $.key !== \"Enter\")) {\n        if ($.stopPropagation(), $.stopImmediatePropagation(), N($)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        D($);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), H(this, Ce).push({ btn: t, on: e, off: r });\n  }\n  remove(t) {\n    const e = H(this, Ce).findIndex((r) => r.btn === t);\n    e < 0 || (H(this, Ce).splice(e, 1), H(this, Ce).length === 0 ? ot(this, be, -1) : e <= H(this, be) && --Ie(this, be)._);\n  }\n  isFocus(t) {\n    return H(this, be) < 0 ? !1 : H(this, Ce)[H(this, be)].btn === t;\n  }\n  prev() {\n    lt(this, Yn, qa).call(this);\n    const t = H(this, Ce).length;\n    if (t !== 0) {\n      --Ie(this, be)._ < 0 && ot(this, be, t - 1);\n      for (let e = t; e >= 1; --e) {\n        const r = (H(this, be) + e) % t;\n        if (H(this, Ce)[r].on()) {\n          ot(this, be, r), H(this, gl).call(this, r);\n          return;\n        }\n      }\n      ot(this, be, -1);\n    }\n  }\n  next() {\n    lt(this, Yn, qa).call(this);\n    const t = H(this, Ce).length;\n    if (t !== 0) {\n      ++Ie(this, be)._ >= t && ot(this, be, 0);\n      for (let e = 0; e < t; ++e) {\n        const r = (H(this, be) + e) % t;\n        if (H(this, Ce)[r].on()) {\n          ot(this, be, r), H(this, gl).call(this, r);\n          return;\n        }\n      }\n      ot(this, be, -1);\n    }\n  }\n  getFocus() {\n    if (H(this, be) < 0)\n      return null;\n    lt(this, Yn, qa).call(this), H(this, be) >= H(this, Ce).length && ot(this, be, 0);\n    const t = H(this, Ce)[H(this, be)];\n    return t.on() ? t.btn : null;\n  }\n  blur() {\n    lt(this, Yn, qa).call(this), ot(this, be, -1), globalThis.focus();\n  }\n}\nCe = new WeakMap(), be = new WeakMap(), Sa = new WeakMap(), Qh = new WeakSet(), ep = function(t, e) {\n  const r = t.querySelectorAll(\"input[type]\"), D = r.length;\n  for (let N = 0; N < D; ++N)\n    if (r[N].checked) {\n      r[(N + D + (e === \"ArrowUp\" ? -1 : 1)) % D].checked = !0;\n      break;\n    }\n}, gl = new WeakMap(), Yn = new WeakSet(), qa = function() {\n  for (let t = H(this, Ce).length - 1; t >= 0; --t) {\n    const e = H(this, Ce)[t];\n    !(e.btn instanceof Container) || e.btn.parent ? e.off() : H(this, Ce).splice(t, 1);\n  }\n};\nvar top = \"top\", bottom = \"bottom\", right = \"right\", left = \"left\", auto = \"auto\", basePlacements = [top, bottom, right, left], start = \"start\", end = \"end\", clippingParents = \"clippingParents\", viewport = \"viewport\", popper = \"popper\", reference = \"reference\", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(o, t) {\n  return o.concat([t + \"-\" + start, t + \"-\" + end]);\n}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(o, t) {\n  return o.concat([t, t + \"-\" + start, t + \"-\" + end]);\n}, []), beforeRead = \"beforeRead\", read$6 = \"read\", afterRead = \"afterRead\", beforeMain = \"beforeMain\", main$1 = \"main\", afterMain = \"afterMain\", beforeWrite = \"beforeWrite\", write$6 = \"write\", afterWrite = \"afterWrite\", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];\nfunction getNodeName(o) {\n  return o ? (o.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(o) {\n  if (o == null)\n    return window;\n  if (o.toString() !== \"[object Window]\") {\n    var t = o.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return o;\n}\nfunction isElement(o) {\n  var t = getWindow(o).Element;\n  return o instanceof t || o instanceof Element;\n}\nfunction isHTMLElement(o) {\n  var t = getWindow(o).HTMLElement;\n  return o instanceof t || o instanceof HTMLElement;\n}\nfunction isShadowRoot(o) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = getWindow(o).ShadowRoot;\n  return o instanceof t || o instanceof ShadowRoot;\n}\nfunction applyStyles(o) {\n  var t = o.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var r = t.styles[e] || {}, D = t.attributes[e] || {}, N = t.elements[e];\n    !isHTMLElement(N) || !getNodeName(N) || (Object.assign(N.style, r), Object.keys(D).forEach(function(k) {\n      var $ = D[k];\n      $ === !1 ? N.removeAttribute(k) : N.setAttribute(k, $ === !0 ? \"\" : $);\n    }));\n  });\n}\nfunction effect$2(o) {\n  var t = o.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(r) {\n      var D = t.elements[r], N = t.attributes[r] || {}, k = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), $ = k.reduce(function(G, U) {\n        return G[U] = \"\", G;\n      }, {});\n      !isHTMLElement(D) || !getNodeName(D) || (Object.assign(D.style, $), Object.keys(N).forEach(function(G) {\n        D.removeAttribute(G);\n      }));\n    });\n  };\n}\nconst applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(o) {\n  return o.split(\"-\")[0];\n}\nvar max = Math.max, min = Math.min, round = Math.round;\nfunction getUAString() {\n  var o = navigator.userAgentData;\n  return o != null && o.brands && Array.isArray(o.brands) ? o.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(o, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var r = o.getBoundingClientRect(), D = 1, N = 1;\n  t && isHTMLElement(o) && (D = o.offsetWidth > 0 && round(r.width) / o.offsetWidth || 1, N = o.offsetHeight > 0 && round(r.height) / o.offsetHeight || 1);\n  var k = isElement(o) ? getWindow(o) : window, $ = k.visualViewport, G = !isLayoutViewport() && e, U = (r.left + (G && $ ? $.offsetLeft : 0)) / D, z = (r.top + (G && $ ? $.offsetTop : 0)) / N, X = r.width / D, V = r.height / N;\n  return {\n    width: X,\n    height: V,\n    top: z,\n    right: U + X,\n    bottom: z + V,\n    left: U,\n    x: U,\n    y: z\n  };\n}\nfunction getLayoutRect(o) {\n  var t = getBoundingClientRect(o), e = o.offsetWidth, r = o.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {\n    x: o.offsetLeft,\n    y: o.offsetTop,\n    width: e,\n    height: r\n  };\n}\nfunction contains(o, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (o.contains(t))\n    return !0;\n  if (e && isShadowRoot(e)) {\n    var r = t;\n    do {\n      if (r && o.isSameNode(r))\n        return !0;\n      r = r.parentNode || r.host;\n    } while (r);\n  }\n  return !1;\n}\nfunction getComputedStyle$1(o) {\n  return getWindow(o).getComputedStyle(o);\n}\nfunction isTableElement(o) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(o)) >= 0;\n}\nfunction getDocumentElement(o) {\n  return ((isElement(o) ? o.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    o.document\n  )) || window.document).documentElement;\n}\nfunction getParentNode(o) {\n  return getNodeName(o) === \"html\" ? o : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    o.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    o.parentNode || // DOM Element detected\n    (isShadowRoot(o) ? o.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(o)\n  );\n}\nfunction getTrueOffsetParent(o) {\n  return !isHTMLElement(o) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle$1(o).position === \"fixed\" ? null : o.offsetParent;\n}\nfunction getContainingBlock(o) {\n  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());\n  if (e && isHTMLElement(o)) {\n    var r = getComputedStyle$1(o);\n    if (r.position === \"fixed\")\n      return null;\n  }\n  var D = getParentNode(o);\n  for (isShadowRoot(D) && (D = D.host); isHTMLElement(D) && [\"html\", \"body\"].indexOf(getNodeName(D)) < 0; ) {\n    var N = getComputedStyle$1(D);\n    if (N.transform !== \"none\" || N.perspective !== \"none\" || N.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(N.willChange) !== -1 || t && N.willChange === \"filter\" || t && N.filter && N.filter !== \"none\")\n      return D;\n    D = D.parentNode;\n  }\n  return null;\n}\nfunction getOffsetParent(o) {\n  for (var t = getWindow(o), e = getTrueOffsetParent(o); e && isTableElement(e) && getComputedStyle$1(e).position === \"static\"; )\n    e = getTrueOffsetParent(e);\n  return e && (getNodeName(e) === \"html\" || getNodeName(e) === \"body\" && getComputedStyle$1(e).position === \"static\") ? t : e || getContainingBlock(o) || t;\n}\nfunction getMainAxisFromPlacement(o) {\n  return [\"top\", \"bottom\"].indexOf(o) >= 0 ? \"x\" : \"y\";\n}\nfunction within(o, t, e) {\n  return max(o, min(t, e));\n}\nfunction withinMaxClamp(o, t, e) {\n  var r = within(o, t, e);\n  return r > e ? e : r;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(o) {\n  return Object.assign({}, getFreshSideObject(), o);\n}\nfunction expandToHashMap(o, t) {\n  return t.reduce(function(e, r) {\n    return e[r] = o, e;\n  }, {});\n}\nvar toPaddingObject = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, mergePaddingObject(typeof t != \"number\" ? t : expandToHashMap(t, basePlacements));\n};\nfunction arrow(o) {\n  var t, e = o.state, r = o.name, D = o.options, N = e.elements.arrow, k = e.modifiersData.popperOffsets, $ = getBasePlacement(e.placement), G = getMainAxisFromPlacement($), U = [left, right].indexOf($) >= 0, z = U ? \"height\" : \"width\";\n  if (!(!N || !k)) {\n    var X = toPaddingObject(D.padding, e), V = getLayoutRect(N), Y = G === \"y\" ? top : left, q = G === \"y\" ? bottom : right, W = e.rects.reference[z] + e.rects.reference[G] - k[G] - e.rects.popper[z], K = k[G] - e.rects.reference[G], Z = getOffsetParent(N), J = Z ? G === \"y\" ? Z.clientHeight || 0 : Z.clientWidth || 0 : 0, Q = W / 2 - K / 2, et = X[Y], nt = J - V[z] - X[q], tt = J / 2 - V[z] / 2 + Q, it = within(et, tt, nt), st = G;\n    e.modifiersData[r] = (t = {}, t[st] = it, t.centerOffset = it - tt, t);\n  }\n}\nfunction effect$1(o) {\n  var t = o.state, e = o.options, r = e.element, D = r === void 0 ? \"[data-popper-arrow]\" : r;\n  if (D != null && !(typeof D == \"string\" && (D = t.elements.popper.querySelector(D), !D))) {\n    if ( true && (isHTMLElement(D) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !contains(t.elements.popper, D)) {\n       true && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = D;\n  }\n}\nconst arrow$1 = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(o) {\n  return o.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(o, t) {\n  var e = o.x, r = o.y, D = t.devicePixelRatio || 1;\n  return {\n    x: round(e * D) / D || 0,\n    y: round(r * D) / D || 0\n  };\n}\nfunction mapToStyles(o) {\n  var t, e = o.popper, r = o.popperRect, D = o.placement, N = o.variation, k = o.offsets, $ = o.position, G = o.gpuAcceleration, U = o.adaptive, z = o.roundOffsets, X = o.isFixed, V = k.x, Y = V === void 0 ? 0 : V, q = k.y, W = q === void 0 ? 0 : q, K = typeof z == \"function\" ? z({\n    x: Y,\n    y: W\n  }) : {\n    x: Y,\n    y: W\n  };\n  Y = K.x, W = K.y;\n  var Z = k.hasOwnProperty(\"x\"), J = k.hasOwnProperty(\"y\"), Q = left, et = top, nt = window;\n  if (U) {\n    var tt = getOffsetParent(e), it = \"clientHeight\", st = \"clientWidth\";\n    if (tt === getWindow(e) && (tt = getDocumentElement(e), getComputedStyle$1(tt).position !== \"static\" && $ === \"absolute\" && (it = \"scrollHeight\", st = \"scrollWidth\")), tt = tt, D === top || (D === left || D === right) && N === end) {\n      et = bottom;\n      var at = X && tt === nt && nt.visualViewport ? nt.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        tt[it]\n      );\n      W -= at - r.height, W *= G ? 1 : -1;\n    }\n    if (D === left || (D === top || D === bottom) && N === end) {\n      Q = right;\n      var ut = X && tt === nt && nt.visualViewport ? nt.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        tt[st]\n      );\n      Y -= ut - r.width, Y *= G ? 1 : -1;\n    }\n  }\n  var ft = Object.assign({\n    position: $\n  }, U && unsetSides), ct = z === !0 ? roundOffsetsByDPR({\n    x: Y,\n    y: W\n  }, getWindow(e)) : {\n    x: Y,\n    y: W\n  };\n  if (Y = ct.x, W = ct.y, G) {\n    var vt;\n    return Object.assign({}, ft, (vt = {}, vt[et] = J ? \"0\" : \"\", vt[Q] = Z ? \"0\" : \"\", vt.transform = (nt.devicePixelRatio || 1) <= 1 ? \"translate(\" + Y + \"px, \" + W + \"px)\" : \"translate3d(\" + Y + \"px, \" + W + \"px, 0)\", vt));\n  }\n  return Object.assign({}, ft, (t = {}, t[et] = J ? W + \"px\" : \"\", t[Q] = Z ? Y + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction computeStyles(o) {\n  var t = o.state, e = o.options, r = e.gpuAcceleration, D = r === void 0 ? !0 : r, N = e.adaptive, k = N === void 0 ? !0 : N, $ = e.roundOffsets, G = $ === void 0 ? !0 : $;\n  if (true) {\n    var U = getComputedStyle$1(t.elements.popper).transitionProperty || \"\";\n    k && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(X) {\n      return U.indexOf(X) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var z = {\n    placement: getBasePlacement(t.placement),\n    variation: getVariation(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: D,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, z, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: k,\n    roundOffsets: G\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, z, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: G\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: !0\n};\nfunction effect(o) {\n  var t = o.state, e = o.instance, r = o.options, D = r.scroll, N = D === void 0 ? !0 : D, k = r.resize, $ = k === void 0 ? !0 : k, G = getWindow(t.elements.popper), U = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return N && U.forEach(function(z) {\n    z.addEventListener(\"scroll\", e.update, passive);\n  }), $ && G.addEventListener(\"resize\", e.update, passive), function() {\n    N && U.forEach(function(z) {\n      z.removeEventListener(\"scroll\", e.update, passive);\n    }), $ && G.removeEventListener(\"resize\", e.update, passive);\n  };\n}\nconst eventListeners = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(o) {\n  return o.replace(/left|right|bottom|top/g, function(t) {\n    return hash$1[t];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(o) {\n  return o.replace(/start|end/g, function(t) {\n    return hash[t];\n  });\n}\nfunction getWindowScroll(o) {\n  var t = getWindow(o), e = t.pageXOffset, r = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: r\n  };\n}\nfunction getWindowScrollBarX(o) {\n  return getBoundingClientRect(getDocumentElement(o)).left + getWindowScroll(o).scrollLeft;\n}\nfunction getViewportRect(o, t) {\n  var e = getWindow(o), r = getDocumentElement(o), D = e.visualViewport, N = r.clientWidth, k = r.clientHeight, $ = 0, G = 0;\n  if (D) {\n    N = D.width, k = D.height;\n    var U = isLayoutViewport();\n    (U || !U && t === \"fixed\") && ($ = D.offsetLeft, G = D.offsetTop);\n  }\n  return {\n    width: N,\n    height: k,\n    x: $ + getWindowScrollBarX(o),\n    y: G\n  };\n}\nfunction getDocumentRect(o) {\n  var t, e = getDocumentElement(o), r = getWindowScroll(o), D = (t = o.ownerDocument) == null ? void 0 : t.body, N = max(e.scrollWidth, e.clientWidth, D ? D.scrollWidth : 0, D ? D.clientWidth : 0), k = max(e.scrollHeight, e.clientHeight, D ? D.scrollHeight : 0, D ? D.clientHeight : 0), $ = -r.scrollLeft + getWindowScrollBarX(o), G = -r.scrollTop;\n  return getComputedStyle$1(D || e).direction === \"rtl\" && ($ += max(e.clientWidth, D ? D.clientWidth : 0) - N), {\n    width: N,\n    height: k,\n    x: $,\n    y: G\n  };\n}\nfunction isScrollParent(o) {\n  var t = getComputedStyle$1(o), e = t.overflow, r = t.overflowX, D = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + D + r);\n}\nfunction getScrollParent(o) {\n  return [\"html\", \"body\", \"#document\"].indexOf(getNodeName(o)) >= 0 ? o.ownerDocument.body : isHTMLElement(o) && isScrollParent(o) ? o : getScrollParent(getParentNode(o));\n}\nfunction listScrollParents(o, t) {\n  var e;\n  t === void 0 && (t = []);\n  var r = getScrollParent(o), D = r === ((e = o.ownerDocument) == null ? void 0 : e.body), N = getWindow(r), k = D ? [N].concat(N.visualViewport || [], isScrollParent(r) ? r : []) : r, $ = t.concat(k);\n  return D ? $ : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    $.concat(listScrollParents(getParentNode(k)))\n  );\n}\nfunction rectToClientRect(o) {\n  return Object.assign({}, o, {\n    left: o.x,\n    top: o.y,\n    right: o.x + o.width,\n    bottom: o.y + o.height\n  });\n}\nfunction getInnerBoundingClientRect(o, t) {\n  var e = getBoundingClientRect(o, !1, t === \"fixed\");\n  return e.top = e.top + o.clientTop, e.left = e.left + o.clientLeft, e.bottom = e.top + o.clientHeight, e.right = e.left + o.clientWidth, e.width = o.clientWidth, e.height = o.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction getClientRectFromMixedType(o, t, e) {\n  return t === viewport ? rectToClientRect(getViewportRect(o, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(o)));\n}\nfunction getClippingParents(o) {\n  var t = listScrollParents(getParentNode(o)), e = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(o).position) >= 0, r = e && isHTMLElement(o) ? getOffsetParent(o) : o;\n  return isElement(r) ? t.filter(function(D) {\n    return isElement(D) && contains(D, r) && getNodeName(D) !== \"body\";\n  }) : [];\n}\nfunction getClippingRect(o, t, e, r) {\n  var D = t === \"clippingParents\" ? getClippingParents(o) : [].concat(t), N = [].concat(D, [e]), k = N[0], $ = N.reduce(function(G, U) {\n    var z = getClientRectFromMixedType(o, U, r);\n    return G.top = max(z.top, G.top), G.right = min(z.right, G.right), G.bottom = min(z.bottom, G.bottom), G.left = max(z.left, G.left), G;\n  }, getClientRectFromMixedType(o, k, r));\n  return $.width = $.right - $.left, $.height = $.bottom - $.top, $.x = $.left, $.y = $.top, $;\n}\nfunction computeOffsets(o) {\n  var t = o.reference, e = o.element, r = o.placement, D = r ? getBasePlacement(r) : null, N = r ? getVariation(r) : null, k = t.x + t.width / 2 - e.width / 2, $ = t.y + t.height / 2 - e.height / 2, G;\n  switch (D) {\n    case top:\n      G = {\n        x: k,\n        y: t.y - e.height\n      };\n      break;\n    case bottom:\n      G = {\n        x: k,\n        y: t.y + t.height\n      };\n      break;\n    case right:\n      G = {\n        x: t.x + t.width,\n        y: $\n      };\n      break;\n    case left:\n      G = {\n        x: t.x - e.width,\n        y: $\n      };\n      break;\n    default:\n      G = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var U = D ? getMainAxisFromPlacement(D) : null;\n  if (U != null) {\n    var z = U === \"y\" ? \"height\" : \"width\";\n    switch (N) {\n      case start:\n        G[U] = G[U] - (t[z] / 2 - e[z] / 2);\n        break;\n      case end:\n        G[U] = G[U] + (t[z] / 2 - e[z] / 2);\n        break;\n    }\n  }\n  return G;\n}\nfunction detectOverflow(o, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, D = r === void 0 ? o.placement : r, N = e.strategy, k = N === void 0 ? o.strategy : N, $ = e.boundary, G = $ === void 0 ? clippingParents : $, U = e.rootBoundary, z = U === void 0 ? viewport : U, X = e.elementContext, V = X === void 0 ? popper : X, Y = e.altBoundary, q = Y === void 0 ? !1 : Y, W = e.padding, K = W === void 0 ? 0 : W, Z = mergePaddingObject(typeof K != \"number\" ? K : expandToHashMap(K, basePlacements)), J = V === popper ? reference : popper, Q = o.rects.popper, et = o.elements[q ? J : V], nt = getClippingRect(isElement(et) ? et : et.contextElement || getDocumentElement(o.elements.popper), G, z, k), tt = getBoundingClientRect(o.elements.reference), it = computeOffsets({\n    reference: tt,\n    element: Q,\n    strategy: \"absolute\",\n    placement: D\n  }), st = rectToClientRect(Object.assign({}, Q, it)), at = V === popper ? st : tt, ut = {\n    top: nt.top - at.top + Z.top,\n    bottom: at.bottom - nt.bottom + Z.bottom,\n    left: nt.left - at.left + Z.left,\n    right: at.right - nt.right + Z.right\n  }, ft = o.modifiersData.offset;\n  if (V === popper && ft) {\n    var ct = ft[D];\n    Object.keys(ut).forEach(function(vt) {\n      var yt = [right, bottom].indexOf(vt) >= 0 ? 1 : -1, mt = [top, bottom].indexOf(vt) >= 0 ? \"y\" : \"x\";\n      ut[vt] += ct[mt] * yt;\n    });\n  }\n  return ut;\n}\nfunction computeAutoPlacement(o, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, D = e.boundary, N = e.rootBoundary, k = e.padding, $ = e.flipVariations, G = e.allowedAutoPlacements, U = G === void 0 ? placements : G, z = getVariation(r), X = z ? $ ? variationPlacements : variationPlacements.filter(function(q) {\n    return getVariation(q) === z;\n  }) : basePlacements, V = X.filter(function(q) {\n    return U.indexOf(q) >= 0;\n  });\n  V.length === 0 && (V = X,  true && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var Y = V.reduce(function(q, W) {\n    return q[W] = detectOverflow(o, {\n      placement: W,\n      boundary: D,\n      rootBoundary: N,\n      padding: k\n    })[getBasePlacement(W)], q;\n  }, {});\n  return Object.keys(Y).sort(function(q, W) {\n    return Y[q] - Y[W];\n  });\n}\nfunction getExpandedFallbackPlacements(o) {\n  if (getBasePlacement(o) === auto)\n    return [];\n  var t = getOppositePlacement(o);\n  return [getOppositeVariationPlacement(o), t, getOppositeVariationPlacement(t)];\n}\nfunction flip(o) {\n  var t = o.state, e = o.options, r = o.name;\n  if (!t.modifiersData[r]._skip) {\n    for (var D = e.mainAxis, N = D === void 0 ? !0 : D, k = e.altAxis, $ = k === void 0 ? !0 : k, G = e.fallbackPlacements, U = e.padding, z = e.boundary, X = e.rootBoundary, V = e.altBoundary, Y = e.flipVariations, q = Y === void 0 ? !0 : Y, W = e.allowedAutoPlacements, K = t.options.placement, Z = getBasePlacement(K), J = Z === K, Q = G || (J || !q ? [getOppositePlacement(K)] : getExpandedFallbackPlacements(K)), et = [K].concat(Q).reduce(function(It, Mt) {\n      return It.concat(getBasePlacement(Mt) === auto ? computeAutoPlacement(t, {\n        placement: Mt,\n        boundary: z,\n        rootBoundary: X,\n        padding: U,\n        flipVariations: q,\n        allowedAutoPlacements: W\n      }) : Mt);\n    }, []), nt = t.rects.reference, tt = t.rects.popper, it = /* @__PURE__ */ new Map(), st = !0, at = et[0], ut = 0; ut < et.length; ut++) {\n      var ft = et[ut], ct = getBasePlacement(ft), vt = getVariation(ft) === start, yt = [top, bottom].indexOf(ct) >= 0, mt = yt ? \"width\" : \"height\", _t = detectOverflow(t, {\n        placement: ft,\n        boundary: z,\n        rootBoundary: X,\n        altBoundary: V,\n        padding: U\n      }), Tt = yt ? vt ? right : left : vt ? bottom : top;\n      nt[mt] > tt[mt] && (Tt = getOppositePlacement(Tt));\n      var Pt = getOppositePlacement(Tt), St = [];\n      if (N && St.push(_t[ct] <= 0), $ && St.push(_t[Tt] <= 0, _t[Pt] <= 0), St.every(function(It) {\n        return It;\n      })) {\n        at = ft, st = !1;\n        break;\n      }\n      it.set(ft, St);\n    }\n    if (st)\n      for (var gt = q ? 3 : 1, bt = function(Mt) {\n        var dt = et.find(function($t) {\n          var Dt = it.get($t);\n          if (Dt)\n            return Dt.slice(0, Mt).every(function(Vt) {\n              return Vt;\n            });\n        });\n        if (dt)\n          return at = dt, \"break\";\n      }, Nt = gt; Nt > 0; Nt--) {\n        var At = bt(Nt);\n        if (At === \"break\")\n          break;\n      }\n    t.placement !== at && (t.modifiersData[r]._skip = !0, t.placement = at, t.reset = !0);\n  }\n}\nconst flip$1 = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction getSideOffsets(o, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: o.top - t.height - e.y,\n    right: o.right - t.width + e.x,\n    bottom: o.bottom - t.height + e.y,\n    left: o.left - t.width - e.x\n  };\n}\nfunction isAnySideFullyClipped(o) {\n  return [top, right, bottom, left].some(function(t) {\n    return o[t] >= 0;\n  });\n}\nfunction hide(o) {\n  var t = o.state, e = o.name, r = t.rects.reference, D = t.rects.popper, N = t.modifiersData.preventOverflow, k = detectOverflow(t, {\n    elementContext: \"reference\"\n  }), $ = detectOverflow(t, {\n    altBoundary: !0\n  }), G = getSideOffsets(k, r), U = getSideOffsets($, D, N), z = isAnySideFullyClipped(G), X = isAnySideFullyClipped(U);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: G,\n    popperEscapeOffsets: U,\n    isReferenceHidden: z,\n    hasPopperEscaped: X\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": z,\n    \"data-popper-escaped\": X\n  });\n}\nconst hide$1 = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(o, t, e) {\n  var r = getBasePlacement(o), D = [left, top].indexOf(r) >= 0 ? -1 : 1, N = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: o\n  })) : e, k = N[0], $ = N[1];\n  return k = k || 0, $ = ($ || 0) * D, [left, right].indexOf(r) >= 0 ? {\n    x: $,\n    y: k\n  } : {\n    x: k,\n    y: $\n  };\n}\nfunction offset(o) {\n  var t = o.state, e = o.options, r = o.name, D = e.offset, N = D === void 0 ? [0, 0] : D, k = placements.reduce(function(z, X) {\n    return z[X] = distanceAndSkiddingToXY(X, t.rects, N), z;\n  }, {}), $ = k[t.placement], G = $.x, U = $.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += G, t.modifiersData.popperOffsets.y += U), t.modifiersData[r] = k;\n}\nconst offset$1 = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(o) {\n  var t = o.state, e = o.name;\n  t.modifiersData[e] = computeOffsets({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(o) {\n  return o === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(o) {\n  var t = o.state, e = o.options, r = o.name, D = e.mainAxis, N = D === void 0 ? !0 : D, k = e.altAxis, $ = k === void 0 ? !1 : k, G = e.boundary, U = e.rootBoundary, z = e.altBoundary, X = e.padding, V = e.tether, Y = V === void 0 ? !0 : V, q = e.tetherOffset, W = q === void 0 ? 0 : q, K = detectOverflow(t, {\n    boundary: G,\n    rootBoundary: U,\n    padding: X,\n    altBoundary: z\n  }), Z = getBasePlacement(t.placement), J = getVariation(t.placement), Q = !J, et = getMainAxisFromPlacement(Z), nt = getAltAxis(et), tt = t.modifiersData.popperOffsets, it = t.rects.reference, st = t.rects.popper, at = typeof W == \"function\" ? W(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : W, ut = typeof at == \"number\" ? {\n    mainAxis: at,\n    altAxis: at\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, at), ft = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {\n    x: 0,\n    y: 0\n  };\n  if (tt) {\n    if (N) {\n      var vt, yt = et === \"y\" ? top : left, mt = et === \"y\" ? bottom : right, _t = et === \"y\" ? \"height\" : \"width\", Tt = tt[et], Pt = Tt + K[yt], St = Tt - K[mt], gt = Y ? -st[_t] / 2 : 0, bt = J === start ? it[_t] : st[_t], Nt = J === start ? -st[_t] : -it[_t], At = t.elements.arrow, It = Y && At ? getLayoutRect(At) : {\n        width: 0,\n        height: 0\n      }, Mt = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject(), dt = Mt[yt], $t = Mt[mt], Dt = within(0, it[_t], It[_t]), Vt = Q ? it[_t] / 2 - gt - Dt - dt - ut.mainAxis : bt - Dt - dt - ut.mainAxis, Lt = Q ? -it[_t] / 2 + gt + Dt + $t + ut.mainAxis : Nt + Dt + $t + ut.mainAxis, Et = t.elements.arrow && getOffsetParent(t.elements.arrow), Ht = Et ? et === \"y\" ? Et.clientTop || 0 : Et.clientLeft || 0 : 0, kt = (vt = ft == null ? void 0 : ft[et]) != null ? vt : 0, wt = Tt + Vt - kt - Ht, Bt = Tt + Lt - kt, jt = within(Y ? min(Pt, wt) : Pt, Tt, Y ? max(St, Bt) : St);\n      tt[et] = jt, ct[et] = jt - Tt;\n    }\n    if ($) {\n      var Ct, qt = et === \"x\" ? top : left, Qt = et === \"x\" ? bottom : right, Kt = tt[nt], Se = nt === \"y\" ? \"height\" : \"width\", Oe = Kt + K[qt], ue = Kt - K[Qt], _e = [top, left].indexOf(Z) !== -1, ve = (Ct = ft == null ? void 0 : ft[nt]) != null ? Ct : 0, de = _e ? Oe : Kt - it[Se] - st[Se] - ve + ut.altAxis, fe = _e ? Kt + it[Se] + st[Se] - ve - ut.altAxis : ue, ne = Y && _e ? withinMaxClamp(de, Kt, fe) : within(Y ? de : Oe, Kt, Y ? fe : ue);\n      tt[nt] = ne, ct[nt] = ne - Kt;\n    }\n    t.modifiersData[r] = ct;\n  }\n}\nconst preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(o) {\n  return {\n    scrollLeft: o.scrollLeft,\n    scrollTop: o.scrollTop\n  };\n}\nfunction getNodeScroll(o) {\n  return o === getWindow(o) || !isHTMLElement(o) ? getWindowScroll(o) : getHTMLElementScroll(o);\n}\nfunction isElementScaled(o) {\n  var t = o.getBoundingClientRect(), e = round(t.width) / o.offsetWidth || 1, r = round(t.height) / o.offsetHeight || 1;\n  return e !== 1 || r !== 1;\n}\nfunction getCompositeRect(o, t, e) {\n  e === void 0 && (e = !1);\n  var r = isHTMLElement(t), D = isHTMLElement(t) && isElementScaled(t), N = getDocumentElement(t), k = getBoundingClientRect(o, D, e), $ = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, G = {\n    x: 0,\n    y: 0\n  };\n  return (r || !r && !e) && ((getNodeName(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  isScrollParent(N)) && ($ = getNodeScroll(t)), isHTMLElement(t) ? (G = getBoundingClientRect(t, !0), G.x += t.clientLeft, G.y += t.clientTop) : N && (G.x = getWindowScrollBarX(N))), {\n    x: k.left + $.scrollLeft - G.x,\n    y: k.top + $.scrollTop - G.y,\n    width: k.width,\n    height: k.height\n  };\n}\nfunction order(o) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];\n  o.forEach(function(N) {\n    t.set(N.name, N);\n  });\n  function D(N) {\n    e.add(N.name);\n    var k = [].concat(N.requires || [], N.requiresIfExists || []);\n    k.forEach(function($) {\n      if (!e.has($)) {\n        var G = t.get($);\n        G && D(G);\n      }\n    }), r.push(N);\n  }\n  return o.forEach(function(N) {\n    e.has(N.name) || D(N);\n  }), r;\n}\nfunction orderModifiers(o) {\n  var t = order(o);\n  return modifierPhases.reduce(function(e, r) {\n    return e.concat(t.filter(function(D) {\n      return D.phase === r;\n    }));\n  }, []);\n}\nfunction debounce(o) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(o());\n      });\n    })), t;\n  };\n}\nfunction format(o) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)\n    e[r - 1] = arguments[r];\n  return [].concat(e).reduce(function(D, N) {\n    return D.replace(/%s/, N);\n  }, o);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction validateModifiers(o) {\n  o.forEach(function(t) {\n    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, r, D) {\n      return D.indexOf(e) === r;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(r) {\n            return '\"' + r + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(r) {\n        o.find(function(D) {\n          return D.name === r;\n        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), r, r));\n      });\n    });\n  });\n}\nfunction uniqueBy(o, t) {\n  var e = /* @__PURE__ */ new Set();\n  return o.filter(function(r) {\n    var D = t(r);\n    if (!e.has(D))\n      return e.add(D), !0;\n  });\n}\nfunction mergeByName(o) {\n  var t = o.reduce(function(e, r) {\n    var D = e[r.name];\n    return e[r.name] = D ? Object.assign({}, D, r, {\n      options: Object.assign({}, D.options, r.options),\n      data: Object.assign({}, D.data, r.data)\n    }) : r, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var o = arguments.length, t = new Array(o), e = 0; e < o; e++)\n    t[e] = arguments[e];\n  return !t.some(function(r) {\n    return !(r && typeof r.getBoundingClientRect == \"function\");\n  });\n}\nfunction popperGenerator(o) {\n  o === void 0 && (o = {});\n  var t = o, e = t.defaultModifiers, r = e === void 0 ? [] : e, D = t.defaultOptions, N = D === void 0 ? DEFAULT_OPTIONS : D;\n  return function($, G, U) {\n    U === void 0 && (U = N);\n    var z = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, N),\n      modifiersData: {},\n      elements: {\n        reference: $,\n        popper: G\n      },\n      attributes: {},\n      styles: {}\n    }, X = [], V = !1, Y = {\n      state: z,\n      setOptions: function(Z) {\n        var J = typeof Z == \"function\" ? Z(z.options) : Z;\n        W(), z.options = Object.assign({}, N, z.options, J), z.scrollParents = {\n          reference: isElement($) ? listScrollParents($) : $.contextElement ? listScrollParents($.contextElement) : [],\n          popper: listScrollParents(G)\n        };\n        var Q = orderModifiers(mergeByName([].concat(r, z.options.modifiers)));\n        if (z.orderedModifiers = Q.filter(function(ft) {\n          return ft.enabled;\n        }), \"development\" !== \"production\") {\n          var et = uniqueBy([].concat(Q, z.options.modifiers), function(ft) {\n            var ct = ft.name;\n            return ct;\n          });\n          if (validateModifiers(et), getBasePlacement(z.options.placement) === auto) {\n            var nt = z.orderedModifiers.find(function(ft) {\n              var ct = ft.name;\n              return ct === \"flip\";\n            });\n            nt || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var tt = getComputedStyle$1(G), it = tt.marginTop, st = tt.marginRight, at = tt.marginBottom, ut = tt.marginLeft;\n          [it, st, at, ut].some(function(ft) {\n            return parseFloat(ft);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return q(), Y.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!V) {\n          var Z = z.elements, J = Z.reference, Q = Z.popper;\n          if (!areValidElements(J, Q)) {\n             true && console.error(INVALID_ELEMENT_ERROR);\n            return;\n          }\n          z.rects = {\n            reference: getCompositeRect(J, getOffsetParent(Q), z.options.strategy === \"fixed\"),\n            popper: getLayoutRect(Q)\n          }, z.reset = !1, z.placement = z.options.placement, z.orderedModifiers.forEach(function(ft) {\n            return z.modifiersData[ft.name] = Object.assign({}, ft.data);\n          });\n          for (var et = 0, nt = 0; nt < z.orderedModifiers.length; nt++) {\n            if ( true && (et += 1, et > 100)) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n            if (z.reset === !0) {\n              z.reset = !1, nt = -1;\n              continue;\n            }\n            var tt = z.orderedModifiers[nt], it = tt.fn, st = tt.options, at = st === void 0 ? {} : st, ut = tt.name;\n            typeof it == \"function\" && (z = it({\n              state: z,\n              options: at,\n              name: ut,\n              instance: Y\n            }) || z);\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function() {\n        return new Promise(function(K) {\n          Y.forceUpdate(), K(z);\n        });\n      }),\n      destroy: function() {\n        W(), V = !0;\n      }\n    };\n    if (!areValidElements($, G))\n      return  true && console.error(INVALID_ELEMENT_ERROR), Y;\n    Y.setOptions(U).then(function(K) {\n      !V && U.onFirstUpdate && U.onFirstUpdate(K);\n    });\n    function q() {\n      z.orderedModifiers.forEach(function(K) {\n        var Z = K.name, J = K.options, Q = J === void 0 ? {} : J, et = K.effect;\n        if (typeof et == \"function\") {\n          var nt = et({\n            state: z,\n            name: Z,\n            instance: Y,\n            options: Q\n          }), tt = function() {\n          };\n          X.push(nt || tt);\n        }\n      });\n    }\n    function W() {\n      X.forEach(function(K) {\n        return K();\n      }), X = [];\n    }\n    return Y;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\");\nvar Ze, qi, Be, ml, _l, bf, yl, xf, bl, Sf, Ea, Ta, xl, Ef, Me, xr, _i, yi, Sl, Ki, Ts, El, Tl, ze, wa, Ca, wl, tc, rp, Cl, Wn, ec, ip, Pl, Tf, rc, np, Ml, wf, qn, Ka, Kn, ic, sp, nc, ap, Sr, sc, op, ac, lp, Pa, _u, bi, Zn, Jn, oc, up, Je;\nclass EventMng {\n  constructor(t, e, r, D, N, k, $, G, U) {\n    rt(this, _l);\n    rt(this, yl);\n    rt(this, bl);\n    rt(this, xl);\n    rt(this, Ki);\n    rt(this, tc);\n    // イベントを全消去\n    rt(this, ec);\n    rt(this, Pl);\n    // イベントを予約\n    rt(this, rc);\n    rt(this, Ml);\n    rt(this, qn);\n    // 行末クリック待ち\n    rt(this, ic);\n    // 改ページクリック待ち\n    rt(this, nc);\n    rt(this, sc);\n    // フォーカス移動\n    rt(this, ac);\n    // ウェイトを入れる\n    rt(this, Pa);\n    // クリックを待つ\n    rt(this, oc);\n    rt(this, Ze, new EventListenerCtn());\n    rt(this, qi, new GamepadListener({\n      analog: !1,\n      deadZone: 0.3\n    }));\n    rt(this, Be, new FocusMng());\n    rt(this, ml, (t) => {\n    });\n    rt(this, Ea, !1);\n    rt(this, Ta, !1);\n    rt(this, Me, {});\n    rt(this, xr, {});\n    rt(this, _i, !1);\n    rt(this, yi, !1);\n    // 予約イベントの発生待ち中か\n    rt(this, Sl, (t) => H(this, Me)[t] ?? H(this, xr)[t]);\n    rt(this, El, () => {\n      ot(this, El, () => {\n      }), this.scrItr.firstWait();\n    });\n    rt(this, Tl, {\n      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n    });\n    rt(this, ze, void 0);\n    rt(this, wa, void 0);\n    rt(this, Ca, void 0);\n    rt(this, wl, {\n      placement: \"bottom\",\n      fallbackPlacements: [\"top\", \"bottom\"]\n    });\n    rt(this, Cl, (t, e) => {\n    });\n    rt(this, Wn, new EventListenerCtn());\n    rt(this, Kn, () => this.layMng.goTxt());\n    // スキップ中断予約\n    rt(this, Sr, () => !1);\n    rt(this, bi, () => {\n    });\n    rt(this, Zn, new eventemitter3Exports());\n    rt(this, Jn, \"sn:notice_comp_txt\");\n    // 0:no push  1:one push  2:push repeating\n    rt(this, Je, {\n      Alt: 0,\n      Meta: 0,\n      // COMMANDキー\n      Control: 0,\n      ArrowDown: 0,\n      End: 0,\n      Enter: 0,\n      Escape: 0,\n      \" \": 0,\n      GoBack: 0\n      // AndroidのBackキーだと思う\n    });\n    var W, K;\n    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = D, this.layMng = N, this.val = k, this.sndMng = $, this.scrItr = G, this.sys = U, e.clear_event = (Z) => lt(this, ec, ip).call(this, Z), e.event = (Z) => lt(this, rc, np).call(this, Z), e.l = (Z) => lt(this, ic, sp).call(this, Z), e.p = (Z) => lt(this, nc, ap).call(this, Z), e.s = () => (G.recodePage(), lt(this, Ki, Ts).call(this, () => {\n    }, !1, !0)), e.set_cancel_skip = () => lt(this, sc, op).call(this), e.set_focus = (Z) => lt(this, ac, lp).call(this, Z), e.wait = (Z) => lt(this, Pa, _u).call(this, Z), e.waitclick = () => lt(this, oc, up).call(this), $.setEvtMng(this), G.setOtherObj(this, N), TxtLayer.setEvtMng(D, this, U), N.setEvtMng(this), U.setFire((Z, J) => this.fire(Z, J)), CmnLib.isDbg) {\n      const Z = {\n        pause: () => {\n          if (ot(this, _i, !0), !H(this, yi))\n            return;\n          const J = {};\n          G.recodeDesign(J), U.callHook(\"_enterDesign\", J), U.send2Dbg(\"_enterDesign\", J);\n        },\n        stopOnBreakpoint: () => ot(this, _i, !0),\n        stopOnDataBreakpoint: () => ot(this, _i, !0),\n        continue: () => ot(this, _i, !1),\n        disconnect: () => ot(this, _i, !1)\n      };\n      Z.attach = Z.stopOnEntry = Z.stopOnStep = Z.stopOnStepIn = Z.stopOnStepOut = Z.stopOnBackstep = Z.pause, U.addHook((J) => {\n        var Q;\n        return (Q = Z[J]) == null ? void 0 : Q.call(Z);\n      });\n    }\n    addStyle(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`);\n    for (const Z of Array.from(document.getElementsByClassName(\"sn_hint\")))\n      (W = Z.parentElement) == null || W.removeChild(Z);\n    (K = Main.cvs.parentElement) == null || K.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), ot(this, ze, document.querySelector(\".sn_hint\")), ot(this, wa, H(this, ze).querySelector(\"span\")), ot(this, Ca, createPopper(H(this, Tl), H(this, ze))), H(this, ze).hidden = !0, r.stage.interactive = !0, CmnLib.isMobile ? r.stage.on(\"pointerdown\", (Z) => this.fire(\"click\", Z)) : H(this, Ze).add(r.stage, \"pointerdown\", (Z) => {\n      switch (Z.data.button) {\n        case 0:\n          this.fire(\"click\", Z);\n          break;\n        case 1:\n          this.fire(\"middleclick\", Z);\n          break;\n      }\n    }), H(this, Ze).add(window, \"keydown\", (Z) => lt(this, _l, bf).call(this, Z)), H(this, Ze).add(Main.cvs, \"contextmenu\", (Z) => lt(this, yl, xf).call(this, Z));\n    const z = () => k.setVal_Nochk(\"tmp\", \"const.sn.navigator.language\", navigator.language);\n    H(this, Ze).add(window, \"languagechange\", (Z) => {\n      z(), this.fire(\"sn:chgNavLang\", Z), clearTextureCache();\n    }), z();\n    const X = (Z) => {\n      CmnLib.isDarkMode = Z.matches, k.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", CmnLib.isDarkMode);\n    }, V = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    X(V), H(this, Ze).add(V, \"change\", (Z) => {\n      X(Z), this.fire(\"sn:chgDarkMode\", Z);\n    }), \"WheelEvent\" in window && (H(this, Ze).add(Main.cvs, \"wheel\", (Z) => lt(this, bl, Sf).call(this, Z), { passive: !0 }), ot(this, ml, (Z) => H(this, Ze).add(Z, \"wheel\", (J) => lt(this, bl, Sf).call(this, J), { passive: !0 })), ot(this, Cl, (Z, J) => Z.add(Main.cvs, \"wheel\", (Q) => {\n      Q.isComposing || Q.deltaY <= 0 || (Q.stopPropagation(), J());\n    }))), CmnLib.debugLog && (H(this, qi).on(\"gamepad:connected\", (Z) => console.log(`👺<'gamepad:connected' index:${Z.detail.index} id:${Z.detail.gamepad.id}`)), H(this, qi).on(\"gamepad:disconnected\", (Z) => console.log(`👺<'gamepad:disconnected' index:${Z.detail.index} id:${Z.detail.gamepad.id}`)));\n    const Y = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      // '7', '8', '9',\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      // '4', '5', '6',\n      \"\",\n      \"ArrowDown\",\n      \"\"\n      // '1', '2', '3',\n    ], q = [0, 0];\n    H(this, qi).on(\"gamepad:axis\", (Z) => {\n      if (!document.hasFocus() || Z.detail.stick !== 0)\n        return;\n      q[Z.detail.axis] = Z.detail.value;\n      const J = (q[1] + 1) * 3 + (q[0] + 1), Q = Y[J];\n      if (!Q)\n        return;\n      const et = H(this, Be).getFocus();\n      (!et || et instanceof Container ? globalThis : et).dispatchEvent(new KeyboardEvent(\"keydown\", { key: Q, bubbles: !0 })), !(!et || et instanceof Container) && et.getAttribute(\"type\") === \"range\" && et.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n    }), H(this, qi).on(\"gamepad:button\", (Z) => {\n      if (document.hasFocus())\n        if (Z.detail.button % 2 === 0) {\n          const J = H(this, Be).getFocus();\n          (!J || J instanceof Container ? globalThis : J).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n        } else\n          Main.cvs.dispatchEvent(new Event(\"contextmenu\"));\n    }), H(this, qi).start(), H(this, Ze).add(window, \"keyup\", (Z) => {\n      Z.isComposing || Z.key in H(this, Je) && (H(this, Je)[Z.key] = 0);\n    }), k.defTmp(\"const.sn.key.alternate\", () => H(this, Je).Alt > 0), k.defTmp(\"const.sn.key.command\", () => H(this, Je).Meta > 0), k.defTmp(\"const.sn.key.control\", () => H(this, Je).Control > 0), k.defTmp(\"const.sn.key.end\", () => H(this, Je).End > 0), k.defTmp(\"const.sn.key.escape\", () => H(this, Je).Escape > 0), k.defTmp(\"const.sn.key.back\", () => H(this, Je).GoBack > 0);\n  }\n  resvFlameEvent(t) {\n    H(this, Ze).add(t, \"keydown\", (e) => lt(this, _l, bf).call(this, e)), H(this, Ze).add(t, \"contextmenu\", (e) => lt(this, yl, xf).call(this, e)), H(this, ml).call(this, t);\n  }\n  destroy() {\n    H(this, Be).destroy(), H(this, Ze).clear();\n  }\n  fire(t, e) {\n    var N;\n    if (H(this, Sr).call(this) || !H(this, yi) || H(this, _i))\n      return;\n    const r = t.toLowerCase();\n    if (CmnLib.debugLog && console.log(`👺 fire<(key:\\`${r}\\` type:${e.type} e:%o)`, { ...e }), r === \"enter\") {\n      const k = H(this, Be).getFocus();\n      if (k instanceof Container) {\n        k.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const D = H(this, Sl).call(this, r);\n    if (!D) {\n      r.slice(0, 5) === \"swipe\" && globalThis.scrollBy(\n        -e.deltaX,\n        -e.deltaY\n      );\n      return;\n    }\n    r.slice(-5) !== \"wheel\" && ((N = e.preventDefault) == null || N.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== \"dom=\" && this.layMng.clickTxtLay()) && (ot(this, yi, !1), D(e));\n  }\n  popLocalEvts() {\n    const t = H(this, Me);\n    return ot(this, Me, {}), t;\n  }\n  pushLocalEvts(t) {\n    ot(this, Me, t);\n  }\n  waitEvent(t, e = !0, r = !1) {\n    if (e && r)\n      throw \"canskipとglobalを同時にtrue指定できません\";\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku)\n        return t(), !1;\n      H(this, Sr).call(this);\n    }\n    return lt(this, Ki, Ts).call(this, t, e, r);\n  }\n  unButton(t) {\n    H(this, Be).remove(t);\n  }\n  button(t, e, r, D, N) {\n    var X;\n    !t.fn && !t.label && this.main.errScript(\"fnまたはlabelは必須です\"), e.interactive = e.buttonMode = !0;\n    const k = ((X = t.key) == null ? void 0 : X.toLowerCase()) ?? \" \";\n    t.fn || (t.fn = this.scrItr.scriptFn);\n    const $ = argChk_Boolean(t, \"global\", !1);\n    $ ? H(this, xr)[k] = () => this.main.resumeByJumpOrCall(t) : H(this, Me)[k] = () => this.main.resumeByJumpOrCall(t), e.on(\"pointerdown\", (V) => this.fire(k, V));\n    const G = t.hint ? () => lt(this, tc, rp).call(this, t, e) : () => {\n    }, U = () => {\n      r(), H(this, ze).hidden = !0;\n    }, z = () => (G(), D());\n    if (e.on(\"pointerover\", z), e.on(\"pointerout\", () => {\n      H(this, Be).isFocus(e) ? z() : U();\n    }), e.on(\"pointerdown\", () => {\n      H(this, ze).hidden = !0;\n      const V = H(this, Be).getFocus();\n      N(), V instanceof Button && V.normal();\n    }), e.on(\n      \"pointerup\",\n      CmnLib.isMobile ? U : () => {\n        H(this, Be).isFocus(e) ? z() : U();\n      }\n    ), H(this, Be).add(e, z, U), t.clickse && (this.cfg.searchPath(t.clickse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerdown\", () => {\n      const V = { fn: t.clickse, join: !1 };\n      t.clicksebuf && (V.buf = t.clicksebuf), this.hTag.playse(V);\n    })), t.enterse && (this.cfg.searchPath(t.enterse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerover\", () => {\n      const V = { fn: t.enterse, join: !1 };\n      t.entersebuf && (V.buf = t.entersebuf), this.hTag.playse(V);\n    })), t.leavese && (this.cfg.searchPath(t.leavese, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerout\", () => {\n      const V = { fn: t.leavese, join: !1 };\n      t.leavesebuf && (V.buf = t.leavesebuf), this.hTag.playse(V);\n    })), t.onenter) {\n      const V = k + t.onenter.toLowerCase(), Y = { fn: t.fn, label: t.onenter, call: !0, key: V };\n      $ ? H(this, xr)[V] = () => this.main.resumeByJumpOrCall(Y) : H(this, Me)[V] = () => this.main.resumeByJumpOrCall(Y), e.on(\"pointerover\", (q) => this.fire(V, q));\n    }\n    if (t.onleave) {\n      const V = k + t.onleave.toLowerCase(), Y = { fn: t.fn, label: t.onleave, call: !0, key: V };\n      $ ? H(this, xr)[V] = () => this.main.resumeByJumpOrCall(Y) : H(this, Me)[V] = () => this.main.resumeByJumpOrCall(Y), e.on(\"pointerout\", (q) => this.fire(V, q));\n    }\n  }\n  hideHint() {\n    H(this, ze).hidden = !0;\n  }\n  cvsResize() {\n    H(this, ze).hidden = !0;\n  }\n  // 予約イベントの発生待ちしない waitEvent()\n  waitLimitedEvent(t, e) {\n    H(this, Kn).call(this), this.val.saveKidoku();\n    const r = () => {\n      H(this, Wn).clear(), e();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n      !this.scrItr.isNextKidoku)\n        H(this, Sr).call(this);\n      else\n        return r(), !1;\n    return argChk_Boolean(t, \"canskip\", !0) && (H(this, Wn).add(window, \"pointerdown\", (D) => {\n      D.stopPropagation(), r();\n    }), H(this, Wn).add(window, \"keydown\", (D) => {\n      D.isComposing || (D.stopPropagation(), r());\n    }), H(this, Cl).call(this, H(this, Wn), r)), !0;\n  }\n  noticeCompTxt() {\n    H(this, Zn).emit(H(this, Jn));\n  }\n  // キー押下によるスキップ中か\n  isSkippingByKeyDown() {\n    return this.scrItr.skip4page ? !0 : Object.keys(H(this, Je)).some((t) => H(this, Je)[t] === 2);\n  }\n}\nZe = new WeakMap(), qi = new WeakMap(), Be = new WeakMap(), ml = new WeakMap(), _l = new WeakSet(), bf = function(t) {\n  if (t.isComposing)\n    return;\n  t.key in H(this, Je) && (H(this, Je)[t.key] = t.repeat ? 2 : 1);\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + t.key;\n  this.fire(e, t);\n}, yl = new WeakSet(), xf = function(t) {\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(e, t), t.preventDefault();\n}, bl = new WeakSet(), Sf = function(t) {\n  if (t.isComposing)\n    return;\n  if (H(this, Ea)) {\n    ot(this, Ta, !0);\n    return;\n  }\n  ot(this, Ea, !0), lt(this, xl, Ef).call(this);\n  const e = (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\") + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(e, t);\n}, Ea = new WeakMap(), Ta = new WeakMap(), xl = new WeakSet(), Ef = function() {\n  setTimeout(() => {\n    if (H(this, Ta)) {\n      ot(this, Ta, !1), lt(this, xl, Ef).call(this);\n      return;\n    }\n    ot(this, Ea, !1);\n  }, 250);\n}, Me = new WeakMap(), xr = new WeakMap(), _i = new WeakMap(), yi = new WeakMap(), Sl = new WeakMap(), Ki = new WeakSet(), Ts = function(t, e = !0, r = !0) {\n  if (H(this, Kn).call(this), this.val.saveKidoku(), e ? H(this, Me).click = //this.hTag.event({key:'enter', breakout: fnc});\n  //hTag.event({key:'down', breakout: fnc});\n  //\thTag.event()は内部で使わず、こうする\n  H(this, Me).enter = H(this, Me).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});\n  //\thTag.event()は内部で使わず、こうする\n  H(this, Me)[\"wheel.y>0\"] = t : (delete H(this, Me).click, delete H(this, Me).enter, delete H(this, Me).arrowdown, delete H(this, Me)[\"wheel.y>0\"]), ot(this, Sl, r ? (D) => H(this, Me)[D] ?? H(this, xr)[D] : (D) => H(this, Me)[D]), ot(this, yi, !0), H(this, El).call(this), CmnLib.debugLog) {\n    const D = /* @__PURE__ */ Object.create(null);\n    D.local = Object.keys(H(this, Me)), D.global = Object.keys(H(this, xr)), console.log(\"🎍 wait event... %o\", D);\n  }\n  return !0;\n}, El = new WeakMap(), Tl = new WeakMap(), ze = new WeakMap(), wa = new WeakMap(), Ca = new WeakMap(), wl = new WeakMap(), tc = new WeakSet(), rp = function(t, e) {\n  const r = e instanceof Button ? e.getBtnBounds() : e.getBounds();\n  if (!(t[\":タグ名\"] === \"link\")) {\n    const N = e.parent.parent;\n    r.x += N.x, r.y += N.y;\n  }\n  if (!t.hint) {\n    H(this, ze).hidden = !0;\n    return;\n  }\n  H(this, ze).style.cssText = `position:${H(this, ze).style.position}; transform:${H(this, ze).style.transform};` + (t.hint_style ?? \"\"), H(this, wa).style.cssText = \"\", H(this, wa).textContent = t.hint ?? \"\";\n  try {\n    const N = t.hint_opt ? { ...H(this, wl), ...JSON.parse(t.hint_opt) } : H(this, wl);\n    H(this, Ca).setOptions(N);\n  } catch (N) {\n    console.error(mesErrJSON(t, \"hint_opt\", N.message));\n  }\n  H(this, Tl).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,\n    width: r.width,\n    height: r.height\n  }), H(this, Ca).update(), H(this, ze).hidden = !1;\n}, Cl = new WeakMap(), Wn = new WeakMap(), ec = new WeakSet(), ip = function(t) {\n  const e = argChk_Boolean(t, \"global\", !1), r = e ? H(this, xr) : H(this, Me);\n  for (const [D, N] of Object.entries(r))\n    lt(this, Pl, Tf).call(this, D, N);\n  return e ? ot(this, xr, {}) : ot(this, Me, {}), ot(this, yi, !1), !1;\n}, Pl = new WeakSet(), Tf = function(t, e) {\n  t.slice(0, 4) === \"dom=\" && lt(this, qn, Ka).call(this, t).el.forEach((r) => r.removeEventListener(\"click\", e));\n}, rc = new WeakSet(), np = function(t) {\n  const e = t.key;\n  if (!e)\n    throw \"keyは必須です\";\n  const r = e.toLowerCase(), D = argChk_Boolean(t, \"call\", !1), N = argChk_Boolean(t, \"global\", !1) ? H(this, xr) : H(this, Me);\n  if (argChk_Boolean(t, \"del\", !1)) {\n    if (t.fn || t.label || D)\n      throw \"fn/label/callとdelは同時指定できません\";\n    return lt(this, Pl, Tf).call(this, e, N[r]), delete N[r], !1;\n  }\n  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === \"dom=\") {\n    const k = lt(this, qn, Ka).call(this, e);\n    if (k.el.length === 0) {\n      if (argChk_Boolean(t, \"need_err\", !0))\n        throw `HTML内にセレクタ（${k.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n      return !1;\n    }\n    let $ = [\"click\", \"keydown\"];\n    switch (k.el[0].type ?? \"\") {\n      case \"checkbox\":\n        $ = [\"input\"];\n        break;\n      case \"range\":\n        $ = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        $ = [\"input\", \"change\"];\n        break;\n    }\n    $.forEach((U, z) => k.el.forEach((X) => {\n      H(this, Ze).add(X, U, (V) => {\n        if (!H(this, yi) || this.layMng.getFrmDisabled(k.id) || U === \"keydown\" && V.key !== \"Enter\")\n          return;\n        const Y = X.dataset;\n        for (const [q, W] of Object.entries(Y))\n          this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${q}`, W);\n        this.fire(e, V);\n      }), z === 0 && H(this, Be).add(\n        X,\n        () => lt(this, Ml, wf).call(this, X) ? (X.focus(), !0) : !1,\n        () => {\n        }\n      );\n    }));\n  }\n  return N[r] = () => this.main.resumeByJumpOrCall(t), !1;\n}, Ml = new WeakSet(), wf = function(t) {\n  if (t.offsetParent === null)\n    return !1;\n  let e = t;\n  do {\n    if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || e != null && e.disabled)\n      return !1;\n    e = e.parentElement;\n  } while (e !== null);\n  return !0;\n}, qn = new WeakSet(), Ka = function(t) {\n  const e = t.indexOf(\":\");\n  let r = \"\";\n  if (e >= 0) {\n    const D = t.slice(4, e), N = `const.sn.frm.${D}`;\n    if (!this.val.getVal(`tmp:${N}`, 0))\n      throw `HTML【${D}】が読み込まれていません`;\n    const $ = document.getElementById(D).contentWindow;\n    return r = t.slice(e + 1), { el: $.document.querySelectorAll(r), id: D, sel: r };\n  }\n  return r = t.slice(4), { el: document.querySelectorAll(r), id: \"\", sel: r };\n}, Kn = new WeakMap(), ic = new WeakSet(), sp = function(t) {\n  if (this.scrItr.skip4page)\n    return !1;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\"))\n    return H(this, Kn).call(this), !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n    !this.scrItr.isNextKidoku)\n      H(this, Sr).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return !1;\n  }\n  return this.val.getVal(\"tmp:sn.auto.enabled\") ? lt(this, Pa, _u).call(this, {\n    time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n  }) : (argChk_Boolean(t, \"visible\", !0) && this.layMng.breakLine(), lt(this, Ki, Ts).call(this, () => this.main.resume()));\n}, nc = new WeakSet(), ap = function(t) {\n  if (this.scrItr.recodePage(), this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n    !this.scrItr.isNextKidoku)\n      H(this, Sr).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\")\n      return H(this, Kn).call(this), !1;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return lt(this, Pa, _u).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  argChk_Boolean(t, \"visible\", !0) && this.layMng.breakPage();\n  const e = () => {\n    this.sndMng.clearCache(), this.main.resume();\n  };\n  return lt(this, Ki, Ts).call(this, argChk_Boolean(t, \"er\", !1) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(t), e();\n  } : e);\n}, Sr = new WeakMap(), sc = new WeakSet(), op = function() {\n  return ot(this, Sr, () => (ot(this, Sr, () => !1), this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", !0), this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", !1), this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", !1), this.layMng.setNormalChWait(), H(this, bi).call(this), !0)), !1;\n}, ac = new WeakSet(), lp = function(t) {\n  const { add: e, del: r, to: D } = t;\n  if ((e == null ? void 0 : e.slice(0, 4)) === \"dom=\") {\n    const N = lt(this, qn, Ka).call(this, e);\n    if (N.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${N.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return N.el.forEach((k) => H(this, Be).add(\n      k,\n      () => lt(this, Ml, wf).call(this, k) ? (k.focus(), !0) : !1,\n      () => {\n      }\n    )), !1;\n  }\n  if ((r == null ? void 0 : r.slice(0, 4)) === \"dom=\") {\n    const N = lt(this, qn, Ka).call(this, r);\n    if (N.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${N.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return N.el.forEach((k) => H(this, Be).remove(k)), !1;\n  }\n  if (!D)\n    throw \"[set_focus] add か to は必須です\";\n  switch (D) {\n    case \"null\":\n      H(this, Be).blur();\n      break;\n    case \"next\":\n      H(this, Be).next();\n      break;\n    case \"prev\":\n      H(this, Be).prev();\n      break;\n  }\n  return !1;\n}, Pa = new WeakSet(), _u = function(t) {\n  const e = argChk_Num(t, \"time\", NaN);\n  return this.scrItr.skip4page ? !1 : this.val.getVal(\"tmp:sn.skip.enabled\") ? (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n  !this.scrItr.isNextKidoku && H(this, Sr).call(this), !1) : (H(this, Zn).once(H(this, Jn), () => {\n    H(this, Zn).off(H(this, Jn));\n    const r = new Tween({}).to({}, e).onComplete(() => {\n      ot(this, bi, () => {\n      }), r.stop(), this.main.resume();\n    }).start();\n    ot(this, bi, () => r.end());\n  }), ot(this, bi, () => {\n    ot(this, bi, () => {\n    }), H(this, Zn).off(H(this, Jn));\n  }), this.waitEvent(\n    () => H(this, bi).call(this),\n    argChk_Boolean(t, \"canskip\", !0),\n    // スキップ中は利かない\n    argChk_Boolean(t, \"global\", !1)\n  ));\n}, bi = new WeakMap(), Zn = new WeakMap(), Jn = new WeakMap(), oc = new WeakSet(), up = function() {\n  return this.scrItr.skip4page ? !1 : ((this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\")) && H(this, Sr).call(this), lt(this, Ki, Ts).call(this, () => this.main.resume()));\n}, Je = new WeakMap();\nclass CallStack {\n  constructor(t = \"\", e = 0, r = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    Ot(this, \"toString\", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);\n    this.fn = t, this.idx = e, this.csArg = r;\n  }\n}\nvar oe, ce, Xt, xe, me, xi, Rl, Cf, Qn, Zi, lc, Ji, Ol, Pf, Il, Mf, Dl, Qi, ws, ts, Za, es, Si, Re, uc, hp, rs, Ja, hc, cp, Al, Ma, fr, cc, fp, fc, dp, Ei, an, dc, pp, is, ns, Nl, Ll, kl, dr, pc, vp, vc, gp, gc, mp, Bl, Rf, mc, _p, yc, yp, bc, bp, Fl, Of, $l, ss, Qa, as, Ti, ln, Gl, If, Ul, jl, Df, xc, Sc, zl, Ec, xp, Ge, Tc, Sp, Hl, Af, wc, Cc, Pc, Ep, Mc, Tp, wi, Vl, Nf, Rc, wp, Oc, Cp, Ic, Dc, Pp, Xl, Ra, Ac, Mp, Oa, yu, Ia, Nc, Rp, Lr, Lc, Op, Da, bu, kc, Ip, kr, Ue;\nconst ar = class {\n  constructor(t, e, r, D, N, k, $, G, U) {\n    rt(this, Rl);\n    rt(this, Ol);\n    rt(this, Il);\n    rt(this, Qi);\n    rt(this, ts);\n    rt(this, uc);\n    rt(this, rs);\n    rt(this, hc);\n    //\t//\t変数操作\n    // インラインテキスト代入\n    rt(this, cc);\n    //\t// デバッグ・その他\n    // スタックのダンプ\n    rt(this, fc);\n    rt(this, Ei);\n    // 外部へスクリプトを表示\n    rt(this, dc);\n    // FIFOバッファ（push/unshift）\n    rt(this, pc);\n    rt(this, vc);\n    //\t// ラベル・ジャンプ\n    // サブルーチンコール\n    rt(this, gc);\n    rt(this, Bl);\n    // シナリオジャンプ\n    rt(this, mc);\n    // ページ移動\n    rt(this, yc);\n    // コールスタック破棄\n    rt(this, bc);\n    // サブルーチンから戻る\n    rt(this, Fl);\n    rt(this, ss);\n    rt(this, Ti);\n    // 初期化前に終了した場合向け\n    rt(this, Gl);\n    rt(this, jl);\n    rt(this, Ec);\n    //{} シナリオキャッシュ\n    rt(this, Tc);\n    rt(this, Hl);\n    rt(this, Pc);\n    rt(this, Mc);\n    rt(this, Vl);\n    //\t// マクロ\n    // 括弧マクロの定義\n    rt(this, Rc);\n    // 一文字マクロの定義\n    rt(this, Oc);\n    rt(this, Dc);\n    // https://regex101.com/r/Lk9ASK/1\n    //\t// しおり\n    // しおりの読込\n    rt(this, Ac);\n    rt(this, Oa);\n    // スクリプト再読込\n    rt(this, Nc);\n    rt(this, Lc);\n    rt(this, Da);\n    // しおりの保存\n    rt(this, kc);\n    rt(this, oe, { aToken: [\"\"], len: 1, aLNum: [1] });\n    rt(this, ce, \"\");\n    rt(this, Xt, 0);\n    rt(this, xe, 0);\n    Ot(this, \"addLineNum\", (t) => ot(this, xe, H(this, xe) + t));\n    rt(this, me, []);\n    // FILOバッファ（push/pop）\n    rt(this, xi, new Grammar());\n    Ot(this, \"firstWait\", () => {\n    });\n    rt(this, Qn, {\n      //auth: // constructorで\n      //launch:\t// ここでは冒頭停止に間に合わないのでanalyzeInit()で\n      disconnect: () => {\n        ot(ar, es, {}), ot(ar, Si, {}), this.isBreak = () => !1, H(this, Qn).continue({}), ot(this, Re, 0);\n      },\n      restart: () => this.isBreak = () => !1,\n      // ブレークポイント登録\n      add_break: (t) => lt(this, Rl, Cf).call(this, t.fn, t.o),\n      data_break: (t) => {\n        H(this, Re) === 0 && (ot(this, Re, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook(\"stopOnDataBreakpoint\", {}), this.sys.send2Dbg(\"stopOnDataBreakpoint\", {}));\n      },\n      set_func_break: (t) => {\n        ot(ar, Si, {});\n        for (const e of t.a)\n          H(ar, Si)[e.name] = 1;\n        this.sys.send2Dbg(t.ri, {});\n      },\n      // 情報問い合わせ系\n      stack: (t) => this.sys.send2Dbg(t.ri, { a: lt(this, hc, cp).call(this) }),\n      eval: (t) => {\n        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });\n      },\n      // デバッガからの操作系\n      continue: () => {\n        lt(this, ts, Za).call(this) || (ot(this, Xt, H(this, Xt) - H(this, Qi, ws)), ot(this, Re, 3), this.main.setLoop(!0), this.main.resume());\n      },\n      stepover: (t) => lt(this, Ol, Pf).call(this, t),\n      stepin: () => {\n        if (lt(this, ts, Za).call(this))\n          return;\n        const t = H(this, oe).aToken[H(this, Xt) - H(this, Qi, ws)];\n        this.sys.callHook(`stopOnStep${H(this, Ra).test(t) ? \"In\" : \"\"}`, {}), ot(this, Xt, H(this, Xt) - H(this, Qi, ws)), ot(this, Re, H(this, Re) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();\n      },\n      stepout: (t) => {\n        lt(this, ts, Za).call(this) || (H(this, me).length > 0 ? lt(this, Il, Mf).call(this, !0) : lt(this, Ol, Pf).call(this, t));\n      },\n      pause: () => {\n        ot(this, Re, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        ot(this, Re, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    });\n    rt(this, Zi, (t) => this.cfg.searchPath(t, SEARCH_PATH_ARG_EXT.SCRIPT));\n    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)\n    rt(this, Ji, (t) => (this.sys.pathBaseCnvSnPath4Dbg + H(this, Zi).call(this, t)).replace(H(ar, lc), `$1/prj/$2/${H(this, ce)}$3`));\n    Ot(this, \"cnvPath4Dbg\", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace(\"/crypto_prj/\", \"/prj/\"));\n    rt(this, Dl, 0);\n    rt(this, Re, 0);\n    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu\n    Ot(this, \"isBreak\", (t) => !1);\n    // result = true : waitする  resume()で再開\n    rt(this, Al, (t) => {\n    });\n    rt(this, Ma, void 0);\n    rt(this, fr, void 0);\n    rt(this, is, () => {\n    });\n    rt(this, ns, () => {\n    });\n    rt(this, Nl, \"\");\n    rt(this, Ll, {});\n    Ot(this, \"noticeBreak\", (t) => {\n    });\n    rt(this, kl, 5);\n    //\t// 条件分岐\n    rt(this, dr, [-1]);\n    rt(this, $l, \"\");\n    rt(this, as, \"\");\n    // シナリオ解析処理ループ・冒頭処理\n    Ot(this, \"nextToken\", () => \"\");\n    rt(this, Ul, (t) => {\n    });\n    rt(this, xc, /(\\*{2,})([^\\|]*)/);\n    rt(this, Sc, /\\[macro\\s/);\n    rt(this, zl, /\\[endmacro[\\s\\]]/);\n    rt(this, Ge, /* @__PURE__ */ Object.create(null));\n    rt(this, wc, /^\\[(call|loadplugin)\\s/);\n    rt(this, Cc, /\\bfn\\s*=\\s*[^\\s\\]]+/);\n    rt(this, wi, !1);\n    // マクロ定義の開始\n    rt(this, Ic, new RegExp(`[\"'#;\\\\]　]+`));\n    rt(this, Xl, \"call\");\n    rt(this, Ra, /\\[(call)\\b/);\n    rt(this, Ia, !1);\n    // セーブポイント指定\n    rt(this, Lr, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    });\n    rt(this, kr, []);\n    rt(this, Ue, -1);\n    this.cfg = t, this.hTag = e, this.main = r, this.val = D, this.alzTagArg = N, this.runAnalyze = k, this.prpPrs = $, this.sndMng = G, this.sys = U, e.let_ml = (X) => lt(this, cc, fp).call(this, X), e.endlet_ml = () => !1, e.dump_stack = () => lt(this, fc, dp).call(this), e.dump_script = (X) => lt(this, dc, pp).call(this, X), e.else = // その他ifブロック開始\n    e.elsif = // 別条件のifブロック開始\n    e.endif = () => lt(this, pc, vp).call(this), e.if = (X) => lt(this, vc, gp).call(this, X), e.call = (X) => lt(this, gc, mp).call(this, X), e.jump = (X) => lt(this, mc, _p).call(this, X), e.page = (X) => lt(this, yc, yp).call(this, X), e.pop_stack = (X) => lt(this, bc, bp).call(this, X), e.return = (X) => lt(this, Fl, Of).call(this, X), e.bracket2macro = (X) => lt(this, Rc, wp).call(this, X), e.char2macro = (X) => lt(this, Oc, Cp).call(this, X), e.endmacro = (X) => lt(this, Fl, Of).call(this, X), e.macro = (X) => lt(this, Dc, Pp).call(this, X), e.load = (X) => lt(this, Ac, Mp).call(this, X), e.reload_script = (X) => lt(this, Nc, Rp).call(this, X), e.record_place = () => lt(this, Lc, Op).call(this), e.save = (X) => lt(this, kc, Ip).call(this, X), t.oCfg.debug.token && ot(this, Ul, (X) => console.log(`🌱 トークン fn:${H(this, ce)} idx:${H(this, Xt)} ln:${H(this, xe)} token【${X}】`)), D.defTmp(\"const.sn.vctCallStk.length\", () => H(this, me).length);\n    const z = t.oCfg.init.escape;\n    if (H(this, xi).setEscape(z), RubySpliter.setEscape(z), CmnLib.isDbg) {\n      U.addHook((V, Y) => {\n        var q, W;\n        return (W = (q = H(this, Qn))[V]) == null ? void 0 : W.call(q, Y);\n      }), this.isBreak = lt(this, uc, hp);\n      const X = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        }, this.sys.send2Dbg(\"hi\", {});\n      }, H(this, Qn).auth = (V) => {\n        const Y = V.hBreakpoint.hFn2hLineBP;\n        for (const [q, W] of Object.entries(Y))\n          lt(this, Rl, Cf).call(this, q, W);\n        ot(ar, Si, {});\n        for (const q of V.hBreakpoint.aFunc)\n          H(ar, Si)[q.name] = 1;\n        if (V.stopOnEntry) {\n          for (; ; ) {\n            let q = this.nextToken();\n            if (!q)\n              break;\n            const W = q.charCodeAt(0);\n            if (W === 91 || W === 38 || W === 42 && q.length === 1)\n              break;\n            W === 10 && ot(this, xe, H(this, xe) + q.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {}), this.analyzeInit = X, this.analyzeInit();\n        } else\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          }, this.analyzeInit = X, this.analyzeInit();\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    t.oCfg.debug.tag && ot(this, Al, (X) => console.log(`🌲 タグ解析 fn:${H(this, ce)} idx:${H(this, Xt)} ln:${H(this, xe)} [${X} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return H(this, ce);\n  }\n  subIdxToken() {\n    --Ie(this, Xt)._;\n  }\n  get lineNum() {\n    return H(this, xe);\n  }\n  destroy() {\n    this.isBreak = () => !1;\n  }\n  タグ解析(t) {\n    const [e, r] = tagToken2Name_Args(t), D = this.hTag[e];\n    if (!D)\n      throw `未定義のタグ【${e}】です`;\n    this.alzTagArg.parse(r), H(this, Al).call(this, e);\n    const N = this.alzTagArg.hPrm;\n    if (N.cond) {\n      const G = N.cond.val;\n      if (!G || G.at(0) === \"&\")\n        throw \"属性condは「&」が不要です\";\n      const U = this.prpPrs.parse(G), z = String(U);\n      if (z === \"null\" || z === \"undefined\" || !U)\n        return !1;\n    }\n    let k = {};\n    const $ = H(this, me).length;\n    if (this.alzTagArg.isKomeParam) {\n      if ($ === 0)\n        throw \"属性「*」はマクロのみ有効です\";\n      k = { ...H(this, me)[H(this, me).length - 1].csArg };\n    }\n    k[\":タグ名\"] = e;\n    for (const [G, { val: U, def: z }] of Object.entries(N)) {\n      let X = U;\n      if ((X == null ? void 0 : X.at(0)) === \"%\") {\n        if ($ === 0)\n          throw \"属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）\";\n        const V = H(this, me)[H(this, me).length - 1].csArg[X.slice(1)];\n        if (V) {\n          k[G] = V;\n          continue;\n        }\n        if (z === void 0 || z === \"null\")\n          continue;\n        X = z;\n      }\n      if (X = this.prpPrs.getValAmpersand(X ?? \"\"), X !== \"undefined\") {\n        k[G] = X;\n        continue;\n      }\n      z !== void 0 && (X = this.prpPrs.getValAmpersand(z), X !== \"undefined\" && (k[G] = X));\n    }\n    return D(k);\n  }\n  setOtherObj(t, e) {\n    ot(this, Ma, t), ot(this, fr, e);\n  }\n  dumpErrForeLine() {\n    if (H(this, Xt) === 0) {\n      console.group(`🥟 Error line (from 0 rows before) fn:${H(this, ce)}`), console.groupEnd();\n      return;\n    }\n    let t = \"\";\n    for (let k = H(this, Xt) - 1; k >= 0 && (t = H(this, oe).aToken[k] + t, !((t.match(/\\n/g) ?? []).length >= H(this, kl))); --k)\n      ;\n    const e = t.split(`\n`).slice(-H(this, kl)), r = e.length;\n    console.group(`🥟 Error line (from ${r} rows before) fn:${H(this, ce)}`);\n    const D = String(H(this, xe)).length, N = lt(this, Ei, an).call(this, H(this, oe), H(this, Xt));\n    for (let k = 0; k < r; ++k) {\n      const $ = H(this, xe) - r + k + 1, G = `${String($).padStart(D, \" \")}: %c`, U = e[k], z = U.length > 75 ? U.slice(0, 75) + \"…\" : U;\n      k === r - 1 ? console.info(\n        G + z.slice(0, N.col_s) + \"%c\" + z.slice(N.col_s),\n        \"color: black; background-color: skyblue;\",\n        \"color: black; background-color: pink;\"\n      ) : console.info(G + z, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const t = lt(this, Ec, xp).call(this, H(this, oe), !!this.val.getVal(\"mp:const.sn.macro.name\"), H(this, xe), H(this, as), H(this, Xt));\n    ot(this, Xt, t.idx), ot(this, xe, t.ln), this.runAnalyze();\n  }\n  get isKidoku() {\n    return H(this, wi);\n  }\n  get isNextKidoku() {\n    let t = H(this, ce), e = H(this, Xt), r = H(this, oe).len;\n    if (H(this, me).length > 0) {\n      const N = H(this, me)[0];\n      t = N.fn, e = N.idx;\n      const k = H(this, Ge)[t];\n      k && (r = k.len);\n    }\n    const D = this.val.getAreaKidoku(t);\n    return !D || e === r ? !1 : D.search(e);\n  }\n  get normalWait() {\n    return H(this, wi) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return H(this, Ia);\n  }\n  recodePage() {\n    if (ot(this, Ia, !1), !this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: t, idx: e } = lt(this, Da, bu).call(this), r = e - 1, D = r + \":\" + t, N = H(this, kr).findIndex(($) => $.key === D);\n    if (N > -1) {\n      ot(this, Ue, N);\n      return;\n    }\n    const k = {\n      key: D,\n      fn: t,\n      idx: r,\n      retFn: t,\n      retIdx: 0,\n      retMark: { ...H(this, Lr) }\n    };\n    if (H(this, Ue) >= 0) {\n      const $ = H(this, kr)[H(this, Ue)];\n      k.retFn = $.fn, k.retIdx = $.idx + 1;\n    }\n    ++Ie(this, Ue)._ === H(this, kr).length ? H(this, kr).push(k) : H(this, kr)[H(this, Ue)] = k;\n  }\n  recodeDesign(t) {\n    let e = \"\", r = 0;\n    const D = H(this, me).length;\n    if (t.design_unit && D > 0) {\n      const $ = H(this, me)[0];\n      e = $.fn, r = $.idx;\n    } else\n      e = H(this, ce), r = H(this, Xt);\n    t[\":path\"] = H(this, Ji).call(this, e);\n    const N = lt(this, Ei, an).call(this, H(this, Ge)[e], r);\n    t[\":ln\"] = N.ln, t[\":col_s\"] = N.col_s, t[\":col_e\"] = N.col_e;\n    const k = r - 1;\n    t[\":idx_tkn\"] = k, t[\":token\"] = H(this, Ge)[e].aToken[k], this.sys.send2Dbg(\"_recodeDesign\", t);\n  }\n  replace(t, e) {\n    H(this, oe).aToken[t] = e;\n  }\n};\nlet ScriptIterator = ar;\noe = new WeakMap(), ce = new WeakMap(), Xt = new WeakMap(), xe = new WeakMap(), me = new WeakMap(), xi = new WeakMap(), Rl = new WeakSet(), Cf = function(t, e) {\n  H(ar, es)[H(this, Ji).call(this, t)] = e;\n}, Qn = new WeakMap(), Zi = new WeakMap(), lc = new WeakMap(), Ji = new WeakMap(), Ol = new WeakSet(), Pf = function(t) {\n  if (lt(this, ts, Za).call(this))\n    return;\n  const e = H(this, oe).aToken[H(this, Xt) - H(this, Qi, ws)];\n  H(this, Ra).test(e) ? lt(this, Il, Mf).call(this, !1) : (this.sys.callHook(\"stopOnStep\", {}), H(this, Qn).stepin(t));\n}, Il = new WeakSet(), Mf = function(t) {\n  this.sys.callHook(`stopOnStep${t ? \"Out\" : \"\"}`, {}), ot(this, Dl, H(this, me).length - (t ? 1 : 0)), ot(this, Xt, H(this, Xt) - H(this, Qi, ws)), ot(this, Re, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();\n}, Dl = new WeakMap(), Qi = new WeakSet(), ws = function() {\n  return H(this, Re) === 2 || H(this, Re) === 4 ? 1 : 0;\n}, ts = new WeakSet(), Za = function() {\n  return H(this, Xt) < H(this, oe).len ? !1 : (this.sys.callHook(\"stopOnEntry\", {}), this.main.setLoop(!1, \"スクリプト終端です\"), !0);\n}, es = new WeakMap(), Si = new WeakMap(), Re = new WeakMap(), uc = new WeakSet(), hp = function(t) {\n  switch (H(this, Re)) {\n    case 6:\n      lt(this, rs, Ja).call(this), ot(this, Re, 7);\n      break;\n    case 7:\n      if (H(this, me).length !== H(this, Dl))\n        break;\n      return ot(this, Re, 4), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 5:\n      lt(this, rs, Ja).call(this), ot(this, Re, 4);\n      break;\n    case 4:\n      return lt(this, rs, Ja).call(this), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 3:\n      lt(this, rs, Ja).call(this), ot(this, Re, 0);\n      break;\n    default:\n      if (tagToken2Name(t) in H(ar, Si))\n        return ot(this, Re, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook(\"stopOnBreakpoint\", {}), this.sys.send2Dbg(\"stopOnBreakpoint\", {}), !0;\n      {\n        const e = H(ar, es)[H(this, Ji).call(this, H(this, ce))];\n        if (!e)\n          break;\n        const r = e[H(this, xe)];\n        if (!r)\n          break;\n        if (r.condition) {\n          if (!this.prpPrs.parse(r.condition))\n            break;\n        } else if (\"hitCondition\" in r && --r.hitCondition > 0)\n          break;\n        const D = H(this, Re) === 0;\n        ot(this, Re, 2), this.main.setLoop(!1, D ? (r.condition ? \"条件\" : \"ヒットカウント\") + \"ブレーク\" : \"ステップ実行\");\n        const N = D ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(N, {}), this.sys.send2Dbg(N, {});\n      }\n      return !0;\n  }\n  return !1;\n}, rs = new WeakSet(), Ja = function() {\n  var e;\n  const t = (e = H(ar, es)[getFn(H(this, ce))]) == null ? void 0 : e[H(this, xe)];\n  t != null && t.hitCondition && --t.hitCondition;\n}, hc = new WeakSet(), cp = function() {\n  const t = H(this, Re) === 3 ? 1 : 0, e = H(this, oe).aToken[H(this, Xt) - 1 + t], r = H(this, Ji).call(this, H(this, ce)), D = tagToken2Name(e), N = D ? `[${D}]` : e, k = this.val.getVal(\"mp:const.sn.macro\") ?? \"{}\";\n  if (H(this, Xt) === 0)\n    return [{ fn: r, ln: 1, col: 1, nm: N, ma: k }];\n  const $ = lt(this, Ei, an).call(this, H(this, oe), H(this, Xt)), G = [{ fn: r, ln: $.ln, col: $.col_s + 1, nm: N, ma: k }], U = H(this, me).length;\n  if (U === 0)\n    return G;\n  for (let z = U - 1; z >= 0; --z) {\n    const X = H(this, me)[z], V = H(this, Ge)[X.fn], Y = V.aToken[X.idx - 1], q = lt(this, Ei, an).call(this, V, X.idx), W = tagToken2Name(Y);\n    G.push({\n      fn: H(this, Ji).call(this, X.fn),\n      ln: q.ln,\n      col: q.col_s + 1,\n      nm: W ? `[${W}]` : Y,\n      ma: X.csArg[\":hMp\"][\"const.sn.macro\"] ?? \"{}\"\n    });\n  }\n  return G;\n}, Al = new WeakMap(), Ma = new WeakMap(), fr = new WeakMap(), cc = new WeakSet(), fp = function(t) {\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  let r = \"\";\n  const D = H(this, oe).len;\n  for (; H(this, Xt) < D && (r = H(this, oe).aToken[H(this, Xt)], r === \"\"); ++Ie(this, Xt)._)\n    ;\n  return t.text = r, t.cast = \"str\", this.hTag.let(t), ot(this, Xt, H(this, Xt) + 2), ot(this, xe, H(this, xe) + (r.match(/\\n/g) ?? []).length), !1;\n}, fc = new WeakSet(), dp = function() {\n  if (H(this, Xt) === 0)\n    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${H(this, ce)} line:1 col:0`), console.groupEnd(), !1;\n  const t = lt(this, Ei, an).call(this, H(this, oe), H(this, Xt)), e = `スクリプト現在地 fn:${H(this, ce)} line:${t.ln} col:${t.col_s + 1}`;\n  console.group(`🥟 [dump_stack] ${e}`);\n  const r = H(this, me).length;\n  if (r > 0) {\n    console.info(e);\n    for (let D = r - 1; D >= 0; --D) {\n      const N = H(this, me)[D], k = N.csArg[\":hMp\"], $ = k ? k[\":タグ名\"] : void 0, G = N.csArg[\":タグ名\"] ?? \"\", U = lt(this, Ei, an).call(this, H(this, Ge)[N.fn], N.idx);\n      console.info(\n        `${r - D}つ前のコール元 fn:${N.fn} line:${U.ln} col:${U.col_s + 1}` + ($ ? \"（[\" + $ + \"]マクロ内）\" : \" \") + `で [${G} ...]をコール`\n      );\n    }\n  }\n  return console.groupEnd(), !1;\n}, Ei = new WeakSet(), an = function(t, e) {\n  const r = { ln: 1, col_s: 0, col_e: 0 };\n  if (!t)\n    return r;\n  let D = e - 1;\n  const N = r.ln = t.aLNum[D];\n  for (; t.aLNum[D] === N; ) {\n    if (t.aToken[D].at(0) !== `\n`) {\n      const k = t.aToken[D].length;\n      r.col_e > 0 && (r.col_s += k), r.col_e += k;\n    }\n    if (--D < 0)\n      break;\n  }\n  return r;\n}, dc = new WeakSet(), pp = function(t) {\n  const { set_fnc: e, break_fnc: r } = t;\n  if (!e)\n    throw \"set_fncは必須です\";\n  if (ot(this, is, globalThis[e]), !H(this, is)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内に関数${e}が見つかりません`;\n    return ot(this, is, () => {\n    }), !1;\n  }\n  if (this.noticeBreak = (D) => {\n    H(this, Nl) !== H(this, ce) && (ot(this, Nl, H(this, ce)), H(this, is).call(this, H(this, Ll)[H(this, ce)] = H(this, Ll)[H(this, ce)] ?? H(this, oe).aToken.join(\"\"))), H(this, ns).call(this, H(this, xe), D);\n  }, this.noticeBreak(!0), !r)\n    return !1;\n  if (ot(this, ns, globalThis[r]), !H(this, ns)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML内に関数${r}が見つかりません`;\n    ot(this, ns, () => {\n    });\n  }\n  return !1;\n}, is = new WeakMap(), ns = new WeakMap(), Nl = new WeakMap(), Ll = new WeakMap(), kl = new WeakMap(), dr = new WeakMap(), pc = new WeakSet(), vp = function() {\n  if (H(this, dr)[0] === -1)\n    throw \"ifブロック内ではありません\";\n  return ot(this, Xt, H(this, dr)[0]), H(this, dr).shift(), !1;\n}, vc = new WeakSet(), gp = function(t) {\n  const { exp: e } = t;\n  if (!e)\n    throw \"expは必須です\";\n  if (e.at(0) === \"&\")\n    throw \"属性expは「&」が不要です\";\n  let r = 0, D = this.prpPrs.parse(e) ? H(this, Xt) : -1;\n  const N = H(this, oe).aLNum[H(this, Xt)];\n  let k = H(this, xe) - (N || 0);\n  const $ = H(this, oe).len;\n  for (; H(this, Xt) < $; ++Ie(this, Xt)._) {\n    const G = H(this, oe).aLNum[H(this, Xt)];\n    H(this, oe).aLNum[H(this, Xt)] = (G || 0) + k;\n    const U = H(this, oe).aToken[H(this, Xt)];\n    if (!U)\n      continue;\n    const z = U.charCodeAt(0);\n    if (z === 10) {\n      ot(this, xe, H(this, xe) + U.length);\n      continue;\n    }\n    if (z !== 91)\n      continue;\n    const [X, V] = tagToken2Name_Args(U);\n    if (!(X in this.hTag))\n      throw `未定義のタグ[${X}]です`;\n    switch (this.alzTagArg.parse(V), X) {\n      case \"if\":\n        ++r;\n        break;\n      case \"elsif\":\n        if (r > 0 || D > -1)\n          break;\n        const Y = this.alzTagArg.hPrm.exp.val;\n        if (Y.at(0) === \"&\")\n          throw \"属性expは「&」が不要です\";\n        this.prpPrs.parse(Y) && (D = H(this, Xt) + 1);\n        break;\n      case \"else\":\n        if (r > 0)\n          break;\n        D === -1 && (D = H(this, Xt) + 1);\n        break;\n      case \"endif\":\n        if (r > 0) {\n          --r;\n          break;\n        }\n        return D === -1 ? (++Ie(this, Xt)._, H(this, oe).aLNum[H(this, Xt)] += k) : (H(this, dr).unshift(H(this, Xt) + 1), ot(this, Xt, D), ot(this, xe, H(this, oe).aLNum[H(this, Xt)])), !1;\n    }\n  }\n  throw \"[endif]がないままスクリプト終端です\";\n}, gc = new WeakSet(), mp = function(t) {\n  argChk_Boolean(t, \"count\", !1) || lt(this, Vl, Nf).call(this);\n  const { fn: e } = t;\n  return e && H(this, Zi).call(this, e), lt(this, Bl, Rf).call(this, { \":hEvt1Time\": H(this, Ma).popLocalEvts(), \":hMp\": this.val.cloneMp() }), argChk_Boolean(t, \"clear_local_event\", !1) && this.hTag.clear_event({}), lt(this, Ti, ln).call(this, e, t.label), !0;\n}, Bl = new WeakSet(), Rf = function(t) {\n  H(this, oe).aLNum[H(this, Xt)] = H(this, xe), H(this, $l) || (t[\":resvToken\"] = \"\", lt(this, ss, Qa).call(this)), H(this, me).push(new CallStack(H(this, ce), H(this, Xt), t)), H(this, dr).unshift(-1);\n}, mc = new WeakSet(), _p = function(t) {\n  return argChk_Boolean(t, \"count\", !0) || lt(this, Vl, Nf).call(this), H(this, dr)[0] = -1, lt(this, Ti, ln).call(this, t.fn, t.label), !0;\n}, yc = new WeakSet(), yp = function(t) {\n  if (H(this, Ue) === -1)\n    return !1;\n  if (argChk_Boolean(t, \"clear\", !1))\n    return ot(this, kr, []), ot(this, Ue, -1), !1;\n  const { to: e } = t;\n  if (!e)\n    throw \"clearかtoは必須です\";\n  const r = H(this, Ue);\n  switch (e) {\n    case \"prev\":\n      H(this, Ue) > 0 && --Ie(this, Ue)._;\n      break;\n    case \"next\":\n      const $ = H(this, kr).length;\n      H(this, Ue) < $ - 1 && ++Ie(this, Ue)._;\n      break;\n    default:\n      throw `属性to「${e}」は異常です`;\n  }\n  if (r === H(this, Ue))\n    return !1;\n  const D = H(this, kr)[H(this, Ue)], { fn: N, idx: k } = lt(this, Da, bu).call(this);\n  return D.key === k + \":\" + N ? !1 : lt(this, Oa, yu).call(this, { fn: D.retFn, index: D.retIdx }, D.retMark);\n}, bc = new WeakSet(), bp = function(t) {\n  if (argChk_Boolean(t, \"clear\", !1))\n    ot(this, me, []);\n  else if (!H(this, me).pop())\n    throw \"[pop_stack] スタックが空です\";\n  return lt(this, ss, Qa).call(this), ot(this, dr, [-1]), this.val.setMp({}), !1;\n}, Fl = new WeakSet(), Of = function(t) {\n  const e = H(this, me).pop();\n  if (!e)\n    throw \"[return] スタックが空です\";\n  const r = e.csArg;\n  H(this, dr).shift();\n  const D = r[\":hMp\"];\n  D && this.val.setMp(D);\n  const N = r[\":resvToken\"];\n  N ? this.nextToken = () => (lt(this, ss, Qa).call(this), N) : lt(this, ss, Qa).call(this), r[\":hEvt1Time\"] && H(this, Ma).pushLocalEvts(r[\":hEvt1Time\"]);\n  const { fn: k, label: $ } = t;\n  return k || $ ? (lt(this, Ti, ln).call(this, k, $), !0) : e.fn in H(this, Ge) ? (lt(this, Hl, Af).call(this, e), !1) : (lt(this, Ti, ln).call(this, e.fn, \"\", e.idx), !0);\n}, $l = new WeakMap(), ss = new WeakSet(), Qa = function() {\n  ot(this, $l, \"\"), this.nextToken = lt(this, Gl, If);\n}, as = new WeakMap(), Ti = new WeakSet(), ln = function(t = \"\", e = \"\", r = 0) {\n  if (!t && !e && this.main.errScript(\"[jump系] fnまたはlabelは必須です\"), e ? (e.at(0) !== \"*\" && this.main.errScript(\"[jump系] labelは*で始まります\"), ot(this, as, e), H(this, as).slice(0, 2) !== \"**\" && ot(this, Xt, r)) : (ot(this, as, \"\"), ot(this, Xt, r)), !t) {\n    this.analyzeInit();\n    return;\n  }\n  if (t.includes(\"@\"))\n    throw \"[jump系] fn には文字「@」は禁止です\";\n  const D = H(this, Zi).call(this, t);\n  if (t === H(this, ce)) {\n    this.analyzeInit();\n    return;\n  }\n  ot(this, ce, t);\n  const N = H(this, Ge)[t];\n  if (N) {\n    ot(this, oe, N), this.analyzeInit();\n    return;\n  }\n  const k = new Loader();\n  let $ = \"\";\n  try {\n    $ = H(this, Zi).call(this, t + \"@\"), k.add({ name: t + \":base\", url: D }), k.add({ name: t, url: $ });\n  } catch {\n    k.add({ name: t, url: D });\n  }\n  k.use((G, U) => {\n    try {\n      G.data = this.sys.decStr(G.extension, G.data);\n    } catch (z) {\n      this.main.errScript(`[jump系]snロード失敗です fn:${G.name} ${z}`, !1);\n    }\n    U == null || U();\n  }).load((G, U) => {\n    if ($) {\n      const z = U[t + \":base\"].data, X = U[t].data, V = z.split(`\n`), Y = X.split(`\n`), q = V.length, W = Y.length;\n      for (let K = 0; K < W && K < q; ++K)\n        Y[K] || (Y[K] = V[K]);\n      U[t].data = Y.join(`\n`), delete U[t + \":base\"];\n    }\n    this.nextToken = lt(this, Gl, If), ot(this, xe, 1), lt(this, Tc, Sp).call(this, U[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());\n  }), this.main.stop();\n}, Gl = new WeakSet(), If = function() {\n  var e, r;\n  if (lt(this, jl, Df).call(this))\n    return \"\";\n  lt(this, Mc, Tp).call(this), (e = H(this, oe).aLNum)[r = H(this, Xt)] || (e[r] = H(this, xe));\n  const t = H(this, oe).aToken[H(this, Xt)];\n  return H(this, Ul).call(this, t), ++Ie(this, Xt)._, t;\n}, Ul = new WeakMap(), jl = new WeakSet(), Df = function() {\n  return H(this, Xt) < H(this, oe).len ? !1 : (this.main.errScript(\"スクリプト終端です\"), !0);\n}, xc = new WeakMap(), Sc = new WeakMap(), zl = new WeakMap(), Ec = new WeakSet(), xp = function(t, e, r, D, N) {\n  var z, X;\n  const k = t.aToken.length;\n  if (!D) {\n    if (lt(this, jl, Df).call(this))\n      return { idx: N, ln: r };\n    if (t.aLNum[N])\n      r = t.aLNum[N];\n    else {\n      r = 1;\n      for (let V = 0; V < N; ++V) {\n        (z = t.aLNum)[V] || (z[V] = r);\n        const Y = t.aToken[V];\n        Y.charCodeAt(0) === 10 ? r += Y.length : r += (Y.match(/\\n/g) ?? []).length;\n      }\n      t.aLNum[N] = r;\n    }\n    return { idx: N, ln: r };\n  }\n  t.aLNum[0] = 1;\n  const $ = D.match(H(this, xc));\n  if ($) {\n    D = $[1];\n    let V = N;\n    switch ($[2]) {\n      case \"before\":\n        for (; t.aToken[--V] !== D; )\n          V === 0 && DebugMng.myTrace(\"[jump系 無名ラベルbefore] \" + r + \"行目以前で\" + (e ? \"マクロ内に\" : \"\") + \"ラベル【\" + D + \"】がありません\", \"ET\"), e && t.aToken[V].search(H(this, Sc)) > -1 && DebugMng.myTrace(\"[jump系 無名ラベルbefore] マクロ内にラベル【\" + D + \"】がありません\", \"ET\");\n        return { idx: V + 1, ln: t.aLNum[V] };\n      case \"after\":\n        for (; t.aToken[++V] !== D; )\n          V === k && DebugMng.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + D + \"】がありません\", \"ET\"), t.aToken[V].search(H(this, zl)) > -1 && DebugMng.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + D + \"】がありません\", \"ET\");\n        return { idx: V + 1, ln: t.aLNum[V] };\n      default:\n        DebugMng.myTrace(\"[jump系] 無名ラベル指定【label=\" + D + \"】が間違っています\", \"ET\");\n    }\n  }\n  r = 1;\n  const G = new RegExp(\n    \"^\" + D.replaceAll(\"*\", \"\\\\*\") + \"(?=\\\\s|;|\\\\[|\\\\||$)\"\n  );\n  let U = !1;\n  for (let V = 0; V < k; ++V) {\n    (X = t.aLNum)[V] || (X[V] = r);\n    const Y = t.aToken[V];\n    if (U) {\n      H(this, xi).testTagEndLetml(Y) ? U = !1 : r += (Y.match(/\\n/g) ?? []).length;\n      continue;\n    }\n    const q = Y.charCodeAt(0);\n    if (q === 10) {\n      r += Y.length;\n      continue;\n    }\n    if (q === 42) {\n      if (Y.search(G) > -1)\n        return { idx: V + 1, ln: r };\n      continue;\n    }\n    q === 91 && (r += (Y.match(/\\n/g) ?? []).length, H(this, xi).testTagLetml(Y) && (U = !0));\n  }\n  throw U ? \"[let_ml]の終端・[endlet_ml]がありません\" : (DebugMng.myTrace(`[jump系] ラベル【${D}】がありません`, \"ET\"), \"Dummy\");\n}, Ge = new WeakMap(), Tc = new WeakSet(), Sp = function(t) {\n  let e = \"\";\n  try {\n    e = \"ScriptIterator.resolveScript\";\n    const r = H(this, xi).resolveScript(t);\n    e = \"ScriptIterator.replaceScript_Wildcard\", lt(this, Pc, Ep).call(this, r), H(this, Ge)[H(this, ce)] = ot(this, oe, r);\n  } catch (r) {\n    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);\n  }\n  this.val.loadScrWork(H(this, ce));\n}, Hl = new WeakSet(), Af = function(t) {\n  ot(this, ce, t.fn), ot(this, Xt, t.idx);\n  const e = H(this, Ge)[H(this, ce)];\n  e && ot(this, oe, e), ot(this, xe, H(this, oe).aLNum[t.idx]);\n}, wc = new WeakMap(), Cc = new WeakMap(), Pc = new WeakSet(), Ep = function(t) {\n  for (let e = t.len - 1; e >= 0; --e) {\n    const r = t.aToken[e];\n    if (!H(this, wc).test(r))\n      continue;\n    const [D, N] = tagToken2Name_Args(r);\n    this.alzTagArg.parse(N);\n    const k = this.alzTagArg.hPrm.fn;\n    if (!k)\n      continue;\n    const { val: $ } = k;\n    if (!$ || $.slice(-1) !== \"*\")\n      continue;\n    t.aToken.splice(e, 1, \"\t\", \"; \" + r), t.aLNum.splice(e, 1, NaN, NaN);\n    const G = D === \"loadplugin\" ? SEARCH_PATH_ARG_EXT.CSS : SEARCH_PATH_ARG_EXT.SN, U = this.cfg.matchPath(\"^\" + $.slice(0, -1) + \".*\", G);\n    for (const z of U) {\n      const X = r.replace(\n        H(this, Cc),\n        \"fn=\" + decodeURIComponent(getFn(z[G]))\n      );\n      t.aToken.splice(e, 0, X), t.aLNum.splice(e, 0, NaN);\n    }\n  }\n  t.len = t.aToken.length;\n}, Mc = new WeakSet(), Tp = function() {\n  const t = this.val.getAreaKidoku(H(this, ce));\n  if (!t)\n    throw `recordKidoku fn:'${H(this, ce)}' (areas === null)`;\n  if (H(this, me).length > 0) {\n    t.record(H(this, Xt));\n    return;\n  }\n  ot(this, wi, t.search(H(this, Xt))), this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", H(this, wi)), !H(this, wi) && t.record(H(this, Xt));\n}, wi = new WeakMap(), Vl = new WeakSet(), Nf = function() {\n  var t;\n  (t = this.val.getAreaKidoku(H(this, ce))) == null || t.erase(H(this, Xt)), ot(this, wi, !1);\n}, Rc = new WeakSet(), wp = function(t) {\n  return H(this, xi).bracket2macro(t, this.hTag, H(this, oe), H(this, Xt)), !1;\n}, Oc = new WeakSet(), Cp = function(t) {\n  return H(this, xi).char2macro(t, this.hTag, H(this, oe), H(this, Xt)), !1;\n}, Ic = new WeakMap(), Dc = new WeakSet(), Pp = function(t) {\n  var N, k;\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  if (e in this.hTag)\n    throw `[${e}]はタグかすでに定義済みのマクロです`;\n  if (H(this, Ic).test(e))\n    throw `[${e}]はマクロ名として異常です`;\n  const r = H(this, xe), D = new CallStack(H(this, ce), H(this, Xt));\n  for (ot(this, Xl, H(this, Xl) + (\"|\" + e)), ot(this, Ra, new RegExp(`\\\\[(${H(this, Xl)})\\\\b`)), this.hTag[e] = ($) => ($.design_unit = t.design_unit, lt(this, Bl, Rf).call(this, { ...$, \":hMp\": this.val.cloneMp() }), this.val.setMp($), this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(t)), this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", H(this, ce)), ot(this, xe, r), lt(this, Hl, Af).call(this, D), !1); H(this, Xt) < H(this, oe).len; ++Ie(this, Xt)._) {\n    (N = H(this, oe).aLNum)[k = H(this, Xt)] || (N[k] = H(this, xe));\n    const $ = H(this, oe).aToken[H(this, Xt)];\n    if ($.search(H(this, zl)) > -1)\n      return ++Ie(this, Xt)._, !1;\n    const G = $.charCodeAt(0);\n    G === 10 ? ot(this, xe, H(this, xe) + $.length) : G === 91 && ot(this, xe, H(this, xe) + ($.match(/\\n/g) ?? []).length);\n  }\n  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;\n}, Xl = new WeakMap(), Ra = new WeakMap(), Ac = new WeakSet(), Mp = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  if (\"fn\" in t != \"label\" in t)\n    throw \"fnとlabelはセットで指定して下さい\";\n  const r = this.val.getMark(e);\n  if (!r)\n    throw `place【${e}】は存在しません`;\n  return lt(this, Oa, yu).call(this, t, r);\n}, Oa = new WeakSet(), yu = function(t, e, r = !0) {\n  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), H(this, fr).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, \"do_rec\", !0) && ot(this, Lr, {\n    hSave: this.val.cloneSave(),\n    hPages: { ...e.hPages },\n    aIfStk: [...e.aIfStk]\n  });\n  const D = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(D);\n  const N = String(this.val.getVal(\"save:const.sn.scriptFn\")), k = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  return ot(this, dr, [...H(this, Lr).aIfStk]), ot(this, me, []), H(this, fr).cover(!0), H(this, fr).stopAllTw(), \"index\" in t ? (H(this, fr).playback(H(this, Lr).hPages, () => {\n    H(this, fr).cover(!1), ot(this, Ia, !0), lt(this, Ti, ln).call(this, t.fn ?? N, \"\", t.index ?? k);\n  }), !0) : (delete H(this, Ge)[N], H(this, fr).playback(\n    H(this, Lr).hPages,\n    \"label\" in t ? () => {\n      H(this, fr).cover(!1), ot(this, ce, N), ot(this, Xt, k), this.hTag.call({ fn: t.fn, label: t.label });\n    } : () => {\n      H(this, fr).cover(!1), lt(this, Ti, ln).call(this, N, \"\", k);\n    }\n  ), !0);\n}, Ia = new WeakMap(), Nc = new WeakSet(), Rp = function(t) {\n  const e = this.val.getMark(0);\n  delete H(this, Ge)[getFn(e.hSave[\"const.sn.scriptFn\"])];\n  const r = {};\n  for (const D in H(this, Ge))\n    try {\n      H(this, Zi).call(this, D + \"@\");\n    } catch {\n      r[D] = H(this, Ge)[D];\n    }\n  return ot(this, Ge, r), t.do_rec = !1, lt(this, Oa, yu).call(this, t, e, !1);\n}, Lr = new WeakMap(), Lc = new WeakSet(), Op = function() {\n  if (this.main.isDestroyed())\n    return !1;\n  const { fn: t, idx: e } = lt(this, Da, bu).call(this);\n  return this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", t), this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", e), ot(this, Lr, {\n    hSave: this.val.cloneSave(),\n    hPages: H(this, fr).record(),\n    aIfStk: H(this, dr).slice(H(this, me).length)\n  }), !1;\n}, Da = new WeakSet(), bu = function() {\n  if (H(this, me).length === 0)\n    return {\n      fn: H(this, ce),\n      idx: H(this, Xt)\n    };\n  const e = H(this, me)[0];\n  return {\n    fn: e.fn,\n    idx: e.idx\n  };\n}, kc = new WeakSet(), Ip = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  delete t[\":タグ名\"], delete t.place, t.text = (t.text ?? \"\").replace(/^(<br\\/>)+/, \"\"), H(this, Lr).json = t, this.val.setMark(e, H(this, Lr));\n  const r = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  return e === r && this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", r + 1), !1;\n}, kr = new WeakMap(), Ue = new WeakMap(), rt(ScriptIterator, lc, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/), // reload 再生成 Main に受け渡すため static\nrt(ScriptIterator, es, {}), rt(ScriptIterator, Si, {});\nvar ir, Er, He, Tr, Ci, os, je, Yl, Pi, Aa, ls, Wl, ql, Na, Bc, Dp, Kl, Zl, La, ka, xu, us, hs;\nconst Ms = class {\n  constructor(t) {\n    rt(this, Bc);\n    rt(this, ka);\n    rt(this, ir, void 0);\n    rt(this, Er, void 0);\n    rt(this, He, /* @__PURE__ */ Object.create(null));\n    // タグ処理辞書\n    rt(this, Tr, void 0);\n    rt(this, Ci, void 0);\n    rt(this, os, void 0);\n    rt(this, je, void 0);\n    rt(this, Yl, void 0);\n    rt(this, Pi, void 0);\n    rt(this, Aa, void 0);\n    rt(this, ls, () => {\n    });\n    rt(this, Wl, new AnalyzeTagArg());\n    rt(this, ql, !1);\n    rt(this, Na, \"skynovel\");\n    rt(this, Kl, () => H(this, ls).call(this));\n    // メイン処理（シナリオ解析）\n    rt(this, Zl, (t = lt(this, ka, xu)) => {\n      H(this, us) || (H(this, Pi).clearBreak(), ot(this, ls, t), this.resume = (e = lt(this, ka, xu)) => {\n        ot(this, ls, e);\n      }, H(this, je).noticeBreak(!1));\n    });\n    Ot(this, \"resume\", H(this, Zl));\n    Ot(this, \"stop\", () => {\n      ot(this, ls, () => {\n      }), this.resume = H(this, Zl), H(this, je).noticeBreak(!0);\n    });\n    rt(this, La, !0);\n    rt(this, us, !1);\n    Ot(this, \"isDestroyed\", () => H(this, us));\n    rt(this, hs, void 0);\n    this.sys = t, skipHello(), Config.generate(t).then((e) => ot(this, ir, e)).then(() => lt(this, Bc, Dp).call(this)).catch((e) => console.error(\"load err fn:prj.json e:%o\", e));\n  }\n  // thisの扱いによりメソッド代入はダメ\n  errScript(t, e = !0) {\n    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log(\"🍜 SKYNovel err!\"), e)\n      throw t;\n  }\n  resumeByJumpOrCall(t) {\n    if (t.url) {\n      globalThis.open(t.url);\n      return;\n    }\n    H(this, Tr).setVal_Nochk(\"tmp\", \"sn.eventArg\", t.arg ?? \"\"), H(this, Tr).setVal_Nochk(\"tmp\", \"sn.eventLabel\", t.label ?? \"\"), argChk_Boolean(t, \"call\", !1) ? (H(this, je).subIdxToken(), this.resume(() => H(this, He).call(t))) : (H(this, He).clear_event({}), this.resume(() => H(this, He).jump(t)));\n  }\n  setLoop(t, e = \"\") {\n    ot(this, La, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : \"\");\n  }\n  fire(t, e) {\n    H(this, Aa).fire(t, e);\n  }\n  async destroy(t = 0) {\n    H(this, us) || (ot(this, us, !0), H(this, ql) && (this.stop(), ot(this, La, !1), H(this, Pi).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), ot(this, He, {}), H(this, Aa).destroy(), H(this, je).destroy(), H(this, Pi).destroy(), H(this, Yl).destroy(), H(this, Er).ticker.remove(H(this, Kl)), H(this, hs) && H(this, Er) && Ms.cvs.parentNode.appendChild(H(this, hs)), clearTextureCache(), H(this, Er).destroy(!0), this.sys.destroy()));\n  }\n};\nlet Main = Ms;\nir = new WeakMap(), Er = new WeakMap(), He = new WeakMap(), Tr = new WeakMap(), Ci = new WeakMap(), os = new WeakMap(), je = new WeakMap(), Yl = new WeakMap(), Pi = new WeakMap(), Aa = new WeakMap(), ls = new WeakMap(), Wl = new WeakMap(), ql = new WeakMap(), Na = new WeakMap(), Bc = new WeakSet(), Dp = async function() {\n  var D;\n  const t = (D = document.createElement(\"canvas\")) == null ? void 0 : D.getContext(\"2d\");\n  if (!t)\n    throw \"argChk_Color err\";\n  CmnLib.cc4ColorName = t;\n  const e = {\n    width: H(this, ir).oCfg.window.width,\n    height: H(this, ir).oCfg.window.height,\n    backgroundColor: parseColor(String(H(this, ir).oCfg.init.bg_color)),\n    // このString()は後方互換性のため必須\n    //\tresolution\t\t: sys.resolution,\n    resolution: globalThis.devicePixelRatio ?? 1\n    // 理想\n  }, r = document.getElementById(H(this, Na));\n  r && (ot(this, hs, r.cloneNode(!0)), H(this, hs).id = H(this, Na), e.view = r), ot(this, Er, new Application(e)), Ms.cvs = H(this, Er).view, r || (document.body.appendChild(Ms.cvs), Ms.cvs.id = H(this, Na)), ot(this, Tr, new Variable(H(this, ir), H(this, He))), ot(this, Ci, new PropParser(H(this, Tr), H(this, ir).oCfg.init.escape ?? \"\\\\\")), await Promise.allSettled(this.sys.init(H(this, He), H(this, Er), H(this, Tr), this)), H(this, He).title({ text: H(this, ir).oCfg.book.title || \"SKYNovel\" }), ot(this, os, new SoundMng(H(this, ir), H(this, He), H(this, Tr), this, this.sys)), ot(this, je, new ScriptIterator(H(this, ir), H(this, He), this, H(this, Tr), H(this, Wl), () => lt(this, ka, xu).call(this), H(this, Ci), H(this, os), this.sys)), ot(this, Yl, new DebugMng(this.sys, H(this, He), H(this, je))), ot(this, Pi, new LayerMng(H(this, ir), H(this, He), H(this, Er), H(this, Tr), this, H(this, je), this.sys, H(this, os), H(this, Wl), H(this, Ci))), ot(this, Aa, new EventMng(H(this, ir), H(this, He), H(this, Er), this, H(this, Pi), H(this, Tr), H(this, os), H(this, je), this.sys)), H(this, Er).ticker.add(H(this, Kl)), this.resumeByJumpOrCall({ fn: \"main\" }), ot(this, ql, !0);\n}, Kl = new WeakMap(), Zl = new WeakMap(), La = new WeakMap(), ka = new WeakSet(), xu = function() {\n  for (; H(this, La); ) {\n    let t = H(this, je).nextToken();\n    if (!t)\n      break;\n    const e = t.charCodeAt(0);\n    if (e !== 9) {\n      if (e === 10) {\n        H(this, je).addLineNum(t.length);\n        continue;\n      }\n      if (e === 91) {\n        if (H(this, je).isBreak(t))\n          return;\n        try {\n          const r = (t.match(/\\n/g) ?? []).length;\n          if (r > 0 && H(this, je).addLineNum(r), H(this, je).タグ解析(t)) {\n            this.stop();\n            break;\n          }\n          continue;\n        } catch (r) {\n          r instanceof Error ? this.errScript(`[${tagToken2Name(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);\n          return;\n        }\n      }\n      if (e === 38)\n        try {\n          if (t.slice(-1) !== \"&\") {\n            if (H(this, je).isBreak(t))\n              return;\n            const r = splitAmpersand(t.slice(1));\n            r.name = H(this, Ci).getValAmpersand(r.name), r.text = String(H(this, Ci).parse(r.text)), H(this, He).let(r);\n            continue;\n          }\n          if (t.charAt(1) === \"&\")\n            throw new Error(\"「&表示&」書式では「&」指定が不要です\");\n          t = String(H(this, Ci).parse(t.slice(1, -1)));\n        } catch (r) {\n          this.errScript(\n            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,\n            !1\n          );\n          return;\n        }\n      else {\n        if (e === 59)\n          continue;\n        if (e === 42 && t.length > 1)\n          continue;\n      }\n      try {\n        H(this, Pi).currentTxtlayForeNeedErr.tagCh(t);\n      } catch (r) {\n        this.errScript(\n          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,\n          !1\n        );\n        return;\n      }\n    }\n  }\n}, us = new WeakMap(), hs = new WeakMap(), Ot(Main, \"cvs\");\nconst PACKET_TYPES = /* @__PURE__ */ Object.create(null);\nPACKET_TYPES.open = \"0\";\nPACKET_TYPES.close = \"1\";\nPACKET_TYPES.ping = \"2\";\nPACKET_TYPES.pong = \"3\";\nPACKET_TYPES.message = \"4\";\nPACKET_TYPES.upgrade = \"5\";\nPACKET_TYPES.noop = \"6\";\nconst PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\nObject.keys(PACKET_TYPES).forEach((o) => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[o]] = o;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" }, withNativeBlob$1 = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", withNativeArrayBuffer$2 = typeof ArrayBuffer == \"function\", isView$1 = (o) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(o) : o && o.buffer instanceof ArrayBuffer, encodePacket = ({ type: o, data: t }, e, r) => withNativeBlob$1 && t instanceof Blob ? e ? r(t) : encodeBlobAsBase64(t, r) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? r(t) : encodeBlobAsBase64(new Blob([t]), r) : r(PACKET_TYPES[o] + (t || \"\")), encodeBlobAsBase64 = (o, t) => {\n  const e = new FileReader();\n  return e.onload = function() {\n    const r = e.result.split(\",\")[1];\n    t(\"b\" + (r || \"\"));\n  }, e.readAsDataURL(o);\n}, chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", lookup$1 = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let o = 0; o < chars.length; o++)\n  lookup$1[chars.charCodeAt(o)] = o;\nconst decode$1 = (o) => {\n  let t = o.length * 0.75, e = o.length, r, D = 0, N, k, $, G;\n  o[o.length - 1] === \"=\" && (t--, o[o.length - 2] === \"=\" && t--);\n  const U = new ArrayBuffer(t), z = new Uint8Array(U);\n  for (r = 0; r < e; r += 4)\n    N = lookup$1[o.charCodeAt(r)], k = lookup$1[o.charCodeAt(r + 1)], $ = lookup$1[o.charCodeAt(r + 2)], G = lookup$1[o.charCodeAt(r + 3)], z[D++] = N << 2 | k >> 4, z[D++] = (k & 15) << 4 | $ >> 2, z[D++] = ($ & 3) << 6 | G & 63;\n  return U;\n}, withNativeArrayBuffer$1 = typeof ArrayBuffer == \"function\", decodePacket = (o, t) => {\n  if (typeof o != \"string\")\n    return {\n      type: \"message\",\n      data: mapBinary(o, t)\n    };\n  const e = o.charAt(0);\n  return e === \"b\" ? {\n    type: \"message\",\n    data: decodeBase64Packet(o.substring(1), t)\n  } : PACKET_TYPES_REVERSE[e] ? o.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[e],\n    data: o.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[e]\n  } : ERROR_PACKET;\n}, decodeBase64Packet = (o, t) => {\n  if (withNativeArrayBuffer$1) {\n    const e = decode$1(o);\n    return mapBinary(e, t);\n  } else\n    return { base64: !0, data: o };\n}, mapBinary = (o, t) => {\n  switch (t) {\n    case \"blob\":\n      return o instanceof ArrayBuffer ? new Blob([o]) : o;\n    case \"arraybuffer\":\n    default:\n      return o;\n  }\n}, SEPARATOR = String.fromCharCode(30), encodePayload = (o, t) => {\n  const e = o.length, r = new Array(e);\n  let D = 0;\n  o.forEach((N, k) => {\n    encodePacket(N, !1, ($) => {\n      r[k] = $, ++D === e && t(r.join(SEPARATOR));\n    });\n  });\n}, decodePayload = (o, t) => {\n  const e = o.split(SEPARATOR), r = [];\n  for (let D = 0; D < e.length; D++) {\n    const N = decodePacket(e[D], t);\n    if (r.push(N), N.type === \"error\")\n      break;\n  }\n  return r;\n}, protocol$1 = 4;\nfunction Emitter(o) {\n  if (o)\n    return mixin(o);\n}\nfunction mixin(o) {\n  for (var t in Emitter.prototype)\n    o[t] = Emitter.prototype[t];\n  return o;\n}\nEmitter.prototype.on = Emitter.prototype.addEventListener = function(o, t) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + o] = this._callbacks[\"$\" + o] || []).push(t), this;\n};\nEmitter.prototype.once = function(o, t) {\n  function e() {\n    this.off(o, e), t.apply(this, arguments);\n  }\n  return e.fn = t, this.on(o, e), this;\n};\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(o, t) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var e = this._callbacks[\"$\" + o];\n  if (!e)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + o], this;\n  for (var r, D = 0; D < e.length; D++)\n    if (r = e[D], r === t || r.fn === t) {\n      e.splice(D, 1);\n      break;\n    }\n  return e.length === 0 && delete this._callbacks[\"$\" + o], this;\n};\nEmitter.prototype.emit = function(o) {\n  this._callbacks = this._callbacks || {};\n  for (var t = new Array(arguments.length - 1), e = this._callbacks[\"$\" + o], r = 1; r < arguments.length; r++)\n    t[r - 1] = arguments[r];\n  if (e) {\n    e = e.slice(0);\n    for (var r = 0, D = e.length; r < D; ++r)\n      e[r].apply(this, t);\n  }\n  return this;\n};\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\nEmitter.prototype.listeners = function(o) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + o] || [];\n};\nEmitter.prototype.hasListeners = function(o) {\n  return !!this.listeners(o).length;\n};\nconst globalThisShim = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction pick(o, ...t) {\n  return t.reduce((e, r) => (o.hasOwnProperty(r) && (e[r] = o[r]), e), {});\n}\nconst NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;\nfunction installTimerFunctions(o, t) {\n  t.useNativeTimers ? (o.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), o.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (o.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), o.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));\n}\nconst BASE64_OVERHEAD = 1.33;\nfunction byteLength(o) {\n  return typeof o == \"string\" ? utf8Length(o) : Math.ceil((o.byteLength || o.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(o) {\n  let t = 0, e = 0;\n  for (let r = 0, D = o.length; r < D; r++)\n    t = o.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);\n  return e;\n}\nclass TransportError extends Error {\n  constructor(t, e, r) {\n    super(t), this.description = e, this.context = r, this.type = \"TransportError\";\n  }\n}\nclass Transport extends Emitter {\n  /**\n   * Transport abstract constructor.\n   *\n   * @param {Object} opts - options\n   * @protected\n   */\n  constructor(t) {\n    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;\n  }\n  /**\n   * Emits an error.\n   *\n   * @param {String} reason\n   * @param description\n   * @param context - the error context\n   * @return {Transport} for chaining\n   * @protected\n   */\n  onError(t, e, r) {\n    return super.emitReserved(\"error\", new TransportError(t, e, r)), this;\n  }\n  /**\n   * Opens the transport.\n   */\n  open() {\n    return this.readyState = \"opening\", this.doOpen(), this;\n  }\n  /**\n   * Closes the transport.\n   */\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  /**\n   * Sends multiple packets.\n   *\n   * @param {Array} packets\n   */\n  send(t) {\n    this.readyState === \"open\" && this.write(t);\n  }\n  /**\n   * Called upon open\n   *\n   * @protected\n   */\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  /**\n   * Called with data.\n   *\n   * @param {String} data\n   * @protected\n   */\n  onData(t) {\n    const e = decodePacket(t, this.socket.binaryType);\n    this.onPacket(e);\n  }\n  /**\n   * Called with a decoded packet.\n   *\n   * @protected\n   */\n  onPacket(t) {\n    super.emitReserved(\"packet\", t);\n  }\n  /**\n   * Called upon close.\n   *\n   * @protected\n   */\n  onClose(t) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", t);\n  }\n  /**\n   * Pauses the transport, in order not to lose packets during an upgrade.\n   *\n   * @param onPause\n   */\n  pause(t) {\n  }\n}\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map$1 = {};\nlet seed = 0, i = 0, prev;\nfunction encode$1(o) {\n  let t = \"\";\n  do\n    t = alphabet[o % length] + t, o = Math.floor(o / length);\n  while (o > 0);\n  return t;\n}\nfunction yeast() {\n  const o = encode$1(+/* @__PURE__ */ new Date());\n  return o !== prev ? (seed = 0, prev = o) : o + \".\" + encode$1(seed++);\n}\nfor (; i < length; i++)\n  map$1[alphabet[i]] = i;\nfunction encode(o) {\n  let t = \"\";\n  for (let e in o)\n    o.hasOwnProperty(e) && (t.length && (t += \"&\"), t += encodeURIComponent(e) + \"=\" + encodeURIComponent(o[e]));\n  return t;\n}\nfunction decode(o) {\n  let t = {}, e = o.split(\"&\");\n  for (let r = 0, D = e.length; r < D; r++) {\n    let N = e[r].split(\"=\");\n    t[decodeURIComponent(N[0])] = decodeURIComponent(N[1]);\n  }\n  return t;\n}\nlet value = !1;\ntry {\n  value = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst hasCORS = value;\nfunction XHR(o) {\n  const t = o.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!t || hasCORS))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!t)\n    try {\n      return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction empty() {\n}\nconst hasXHR2 = function() {\n  return new XHR({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass Polling extends Transport {\n  /**\n   * XHR Polling constructor.\n   *\n   * @param {Object} opts\n   * @package\n   */\n  constructor(t) {\n    if (super(t), this.polling = !1, typeof location < \"u\") {\n      const r = location.protocol === \"https:\";\n      let D = location.port;\n      D || (D = r ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && t.hostname !== location.hostname || D !== t.port, this.xs = t.secure !== r;\n    }\n    const e = t && t.forceBase64;\n    this.supportsBinary = hasXHR2 && !e;\n  }\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @protected\n   */\n  doOpen() {\n    this.poll();\n  }\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n   * @package\n   */\n  pause(t) {\n    this.readyState = \"pausing\";\n    const e = () => {\n      this.readyState = \"paused\", t();\n    };\n    if (this.polling || !this.writable) {\n      let r = 0;\n      this.polling && (r++, this.once(\"pollComplete\", function() {\n        --r || e();\n      })), this.writable || (r++, this.once(\"drain\", function() {\n        --r || e();\n      }));\n    } else\n      e();\n  }\n  /**\n   * Starts polling cycle.\n   *\n   * @private\n   */\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @protected\n   */\n  onData(t) {\n    const e = (r) => {\n      if (this.readyState === \"opening\" && r.type === \"open\" && this.onOpen(), r.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(r);\n    };\n    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  /**\n   * For polling, send a close packet.\n   *\n   * @protected\n   */\n  doClose() {\n    const t = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? t() : this.once(\"open\", t);\n  }\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} packets - data packets\n   * @protected\n   */\n  write(t) {\n    this.writable = !1, encodePayload(t, (e) => {\n      this.doWrite(e, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @private\n   */\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"https\" : \"http\";\n    let r = \"\";\n    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === \"https\" && Number(this.opts.port) !== 443 || e === \"http\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port);\n    const D = encode(t), N = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (N ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (D.length ? \"?\" + D : \"\");\n  }\n  /**\n   * Creates a request.\n   *\n   * @param {String} method\n   * @private\n   */\n  request(t = {}) {\n    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);\n  }\n  /**\n   * Sends data.\n   *\n   * @param {String} data to send.\n   * @param {Function} called upon flush.\n   * @private\n   */\n  doWrite(t, e) {\n    const r = this.request({\n      method: \"POST\",\n      data: t\n    });\n    r.on(\"success\", e), r.on(\"error\", (D, N) => {\n      this.onError(\"xhr post error\", D, N);\n    });\n  }\n  /**\n   * Starts a poll cycle.\n   *\n   * @private\n   */\n  doPoll() {\n    const t = this.request();\n    t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (e, r) => {\n      this.onError(\"xhr poll error\", e, r);\n    }), this.pollXhr = t;\n  }\n}\nclass Request extends Emitter {\n  /**\n   * Request constructor\n   *\n   * @param {Object} options\n   * @package\n   */\n  constructor(t, e) {\n    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();\n  }\n  /**\n   * Creates the XHR object and sends the request.\n   *\n   * @private\n   */\n  create() {\n    const t = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n    const e = this.xhr = new XHR(t);\n    try {\n      e.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n          for (let r in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        e.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof e.status == \"number\" ? e.status : 0);\n        }, 0));\n      }, e.send(this.data);\n    } catch (r) {\n      this.setTimeoutFn(() => {\n        this.onError(r);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);\n  }\n  /**\n   * Called upon error.\n   *\n   * @private\n   */\n  onError(t) {\n    this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n  }\n  /**\n   * Cleans up house.\n   *\n   * @private\n   */\n  cleanup(t) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = empty, t)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete Request.requests[this.index], this.xhr = null;\n    }\n  }\n  /**\n   * Called upon load.\n   *\n   * @private\n   */\n  onLoad() {\n    const t = this.xhr.responseText;\n    t !== null && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n  }\n  /**\n   * Aborts the request.\n   *\n   * @package\n   */\n  abort() {\n    this.cleanup();\n  }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", unloadHandler);\n  else if (typeof addEventListener == \"function\") {\n    const o = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(o, unloadHandler, !1);\n  }\n}\nfunction unloadHandler() {\n  for (let o in Request.requests)\n    Request.requests.hasOwnProperty(o) && Request.requests[o].abort();\n}\nconst nextTick = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = \"arraybuffer\", isReactNative = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n  /**\n   * WebSocket transport constructor.\n   *\n   * @param {Object} opts - connection options\n   * @protected\n   */\n  constructor(t) {\n    super(t), this.supportsBinary = !t.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const t = this.uri(), e = this.opts.protocols, r = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, r);\n    } catch (D) {\n      return this.emitReserved(\"error\", D);\n    }\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();\n  }\n  /**\n   * Adds event listeners to the socket\n   *\n   * @private\n   */\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (t) => this.onClose({\n      description: \"websocket connection closed\",\n      context: t\n    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError(\"websocket error\", t);\n  }\n  write(t) {\n    this.writable = !1;\n    for (let e = 0; e < t.length; e++) {\n      const r = t[e], D = e === t.length - 1;\n      encodePacket(r, this.supportsBinary, (N) => {\n        const k = {};\n        try {\n          usingBrowserWebSocket && this.ws.send(N);\n        } catch {\n        }\n        D && nextTick(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @private\n   */\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"wss\" : \"ws\";\n    let r = \"\";\n    this.opts.port && (e === \"wss\" && Number(this.opts.port) !== 443 || e === \"ws\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);\n    const D = encode(t), N = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (N ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (D.length ? \"?\" + D : \"\");\n  }\n  /**\n   * Feature detection for WebSocket.\n   *\n   * @return {Boolean} whether this transport is available.\n   * @private\n   */\n  check() {\n    return !!WebSocket;\n  }\n}\nconst transports = {\n  websocket: WS,\n  polling: Polling\n}, re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, parts = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction parse(o) {\n  const t = o, e = o.indexOf(\"[\"), r = o.indexOf(\"]\");\n  e != -1 && r != -1 && (o = o.substring(0, e) + o.substring(e, r).replace(/:/g, \";\") + o.substring(r, o.length));\n  let D = re.exec(o || \"\"), N = {}, k = 14;\n  for (; k--; )\n    N[parts[k]] = D[k] || \"\";\n  return e != -1 && r != -1 && (N.source = t, N.host = N.host.substring(1, N.host.length - 1).replace(/;/g, \":\"), N.authority = N.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), N.ipv6uri = !0), N.pathNames = pathNames(N, N.path), N.queryKey = queryKey(N, N.query), N;\n}\nfunction pathNames(o, t) {\n  const e = /\\/{2,9}/g, r = t.replace(e, \"/\").split(\"/\");\n  return (t.slice(0, 1) == \"/\" || t.length === 0) && r.splice(0, 1), t.slice(-1) == \"/\" && r.splice(r.length - 1, 1), r;\n}\nfunction queryKey(o, t) {\n  const e = {};\n  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, D, N) {\n    D && (e[D] = N);\n  }), e;\n}\nlet Socket$1 = class Cs extends Emitter {\n  /**\n   * Socket constructor.\n   *\n   * @param {String|Object} uri - uri or options\n   * @param {Object} opts - options\n   */\n  constructor(t, e = {}) {\n    super(), this.writeBuffer = [], t && typeof t == \"object\" && (e = t, t = null), t ? (t = parse(t), e.hostname = t.host, e.secure = t.protocol === \"https\" || t.protocol === \"wss\", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < \"u\" && location.protocol === \"https:\", e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = e.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      addTrailingSlash: !0,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !0\n    }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\"), typeof this.opts.query == \"string\" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, addEventListener(\"beforeunload\", this.beforeunloadEventListener, !1)), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  /**\n   * Creates transport of the given type.\n   *\n   * @param {String} name - transport name\n   * @return {Transport}\n   * @private\n   */\n  createTransport(t) {\n    const e = Object.assign({}, this.opts.query);\n    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);\n    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n      query: e,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new transports[t](r);\n  }\n  /**\n   * Initializes transport to use and starts probe.\n   *\n   * @private\n   */\n  open() {\n    let t;\n    if (this.opts.rememberUpgrade && Cs.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      t = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      t = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      t = this.createTransport(t);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    t.open(), this.setTransport(t);\n  }\n  /**\n   * Sets the current transport. Disables the existing one (if any).\n   *\n   * @private\n   */\n  setTransport(t) {\n    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (e) => this.onClose(\"transport close\", e));\n  }\n  /**\n   * Probes a transport.\n   *\n   * @param {String} name - transport name\n   * @private\n   */\n  probe(t) {\n    let e = this.createTransport(t), r = !1;\n    Cs.priorWebsocketSuccess = !1;\n    const D = () => {\n      r || (e.send([{ type: \"ping\", data: \"probe\" }]), e.once(\"packet\", (X) => {\n        if (!r)\n          if (X.type === \"pong\" && X.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e)\n              return;\n            Cs.priorWebsocketSuccess = e.name === \"websocket\", this.transport.pause(() => {\n              r || this.readyState !== \"closed\" && (z(), this.setTransport(e), e.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const V = new Error(\"probe error\");\n            V.transport = e.name, this.emitReserved(\"upgradeError\", V);\n          }\n      }));\n    };\n    function N() {\n      r || (r = !0, z(), e.close(), e = null);\n    }\n    const k = (X) => {\n      const V = new Error(\"probe error: \" + X);\n      V.transport = e.name, N(), this.emitReserved(\"upgradeError\", V);\n    };\n    function $() {\n      k(\"transport closed\");\n    }\n    function G() {\n      k(\"socket closed\");\n    }\n    function U(X) {\n      e && X.name !== e.name && N();\n    }\n    const z = () => {\n      e.removeListener(\"open\", D), e.removeListener(\"error\", k), e.removeListener(\"close\", $), this.off(\"close\", G), this.off(\"upgrading\", U);\n    };\n    e.once(\"open\", D), e.once(\"error\", k), e.once(\"close\", $), this.once(\"close\", G), this.once(\"upgrading\", U), e.open();\n  }\n  /**\n   * Called when connection is deemed open.\n   *\n   * @private\n   */\n  onOpen() {\n    if (this.readyState = \"open\", Cs.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade) {\n      let t = 0;\n      const e = this.upgrades.length;\n      for (; t < e; t++)\n        this.probe(this.upgrades[t]);\n    }\n  }\n  /**\n   * Handles a packet.\n   *\n   * @private\n   */\n  onPacket(t) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(t.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const e = new Error(\"server error\");\n          e.code = t.data, this.onError(e);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n          break;\n      }\n  }\n  /**\n   * Called upon handshake completion.\n   *\n   * @param {Object} data - handshake obj\n   * @private\n   */\n  onHandshake(t) {\n    this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  /**\n   * Sets and resets ping timeout timer based on server pings.\n   *\n   * @private\n   */\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  /**\n   * Called on `drain` event\n   *\n   * @private\n   */\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  /**\n   * Flush write buffers.\n   *\n   * @private\n   */\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const t = this.getWritablePackets();\n      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n    }\n  }\n  /**\n   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n   * long-polling)\n   *\n   * @private\n   */\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let e = 1;\n    for (let r = 0; r < this.writeBuffer.length; r++) {\n      const D = this.writeBuffer[r].data;\n      if (D && (e += byteLength(D)), r > 0 && e > this.maxPayload)\n        return this.writeBuffer.slice(0, r);\n      e += 2;\n    }\n    return this.writeBuffer;\n  }\n  /**\n   * Sends a message.\n   *\n   * @param {String} msg - message.\n   * @param {Object} options.\n   * @param {Function} callback function.\n   * @return {Socket} for chaining.\n   */\n  write(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  send(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} type: packet type.\n   * @param {String} data.\n   * @param {Object} options.\n   * @param {Function} fn - callback function.\n   * @private\n   */\n  sendPacket(t, e, r, D) {\n    if (typeof e == \"function\" && (D = e, e = void 0), typeof r == \"function\" && (D = r, r = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    r = r || {}, r.compress = r.compress !== !1;\n    const N = {\n      type: t,\n      data: e,\n      options: r\n    };\n    this.emitReserved(\"packetCreate\", N), this.writeBuffer.push(N), D && this.once(\"flush\", D), this.flush();\n  }\n  /**\n   * Closes the connection.\n   */\n  close() {\n    const t = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, e = () => {\n      this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n    }, r = () => {\n      this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? r() : t();\n    }) : this.upgrading ? r() : t()), this;\n  }\n  /**\n   * Called upon transport error\n   *\n   * @private\n   */\n  onError(t) {\n    Cs.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n  }\n  /**\n   * Called upon transport close.\n   *\n   * @private\n   */\n  onClose(t, e) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && (removeEventListener(\"beforeunload\", this.beforeunloadEventListener, !1), removeEventListener(\"offline\", this.offlineEventListener, !1)), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  /**\n   * Filters upgrades, returning only those matching client transports.\n   *\n   * @param {Array} upgrades - server upgrades\n   * @private\n   */\n  filterUpgrades(t) {\n    const e = [];\n    let r = 0;\n    const D = t.length;\n    for (; r < D; r++)\n      ~this.transports.indexOf(t[r]) && e.push(t[r]);\n    return e;\n  }\n};\nSocket$1.protocol = protocol$1;\nfunction url(o, t = \"\", e) {\n  let r = o;\n  e = e || typeof location < \"u\" && location, o == null && (o = e.protocol + \"//\" + e.host), typeof o == \"string\" && (o.charAt(0) === \"/\" && (o.charAt(1) === \"/\" ? o = e.protocol + o : o = e.host + o), /^(https?|wss?):\\/\\//.test(o) || (typeof e < \"u\" ? o = e.protocol + \"//\" + o : o = \"https://\" + o), r = parse(o)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = \"80\" : /^(http|ws)s$/.test(r.protocol) && (r.port = \"443\")), r.path = r.path || \"/\";\n  const N = r.host.indexOf(\":\") !== -1 ? \"[\" + r.host + \"]\" : r.host;\n  return r.id = r.protocol + \"://\" + N + \":\" + r.port + t, r.href = r.protocol + \"://\" + N + (e && e.port === r.port ? \"\" : \":\" + r.port), r;\n}\nconst withNativeArrayBuffer = typeof ArrayBuffer == \"function\", isView = (o) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(o) : o.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == \"function\" || typeof Blob < \"u\" && toString.call(Blob) === \"[object BlobConstructor]\", withNativeFile = typeof File == \"function\" || typeof File < \"u\" && toString.call(File) === \"[object FileConstructor]\";\nfunction isBinary(o) {\n  return withNativeArrayBuffer && (o instanceof ArrayBuffer || isView(o)) || withNativeBlob && o instanceof Blob || withNativeFile && o instanceof File;\n}\nfunction hasBinary(o, t) {\n  if (!o || typeof o != \"object\")\n    return !1;\n  if (Array.isArray(o)) {\n    for (let e = 0, r = o.length; e < r; e++)\n      if (hasBinary(o[e]))\n        return !0;\n    return !1;\n  }\n  if (isBinary(o))\n    return !0;\n  if (o.toJSON && typeof o.toJSON == \"function\" && arguments.length === 1)\n    return hasBinary(o.toJSON(), !0);\n  for (const e in o)\n    if (Object.prototype.hasOwnProperty.call(o, e) && hasBinary(o[e]))\n      return !0;\n  return !1;\n}\nfunction deconstructPacket(o) {\n  const t = [], e = o.data, r = o;\n  return r.data = _deconstructPacket(e, t), r.attachments = t.length, { packet: r, buffers: t };\n}\nfunction _deconstructPacket(o, t) {\n  if (!o)\n    return o;\n  if (isBinary(o)) {\n    const e = { _placeholder: !0, num: t.length };\n    return t.push(o), e;\n  } else if (Array.isArray(o)) {\n    const e = new Array(o.length);\n    for (let r = 0; r < o.length; r++)\n      e[r] = _deconstructPacket(o[r], t);\n    return e;\n  } else if (typeof o == \"object\" && !(o instanceof Date)) {\n    const e = {};\n    for (const r in o)\n      Object.prototype.hasOwnProperty.call(o, r) && (e[r] = _deconstructPacket(o[r], t));\n    return e;\n  }\n  return o;\n}\nfunction reconstructPacket(o, t) {\n  return o.data = _reconstructPacket(o.data, t), delete o.attachments, o;\n}\nfunction _reconstructPacket(o, t) {\n  if (!o)\n    return o;\n  if (o && o._placeholder === !0) {\n    if (typeof o.num == \"number\" && o.num >= 0 && o.num < t.length)\n      return t[o.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(o))\n    for (let e = 0; e < o.length; e++)\n      o[e] = _reconstructPacket(o[e], t);\n  else if (typeof o == \"object\")\n    for (const e in o)\n      Object.prototype.hasOwnProperty.call(o, e) && (o[e] = _reconstructPacket(o[e], t));\n  return o;\n}\nconst protocol = 5;\nvar PacketType;\n(function(o) {\n  o[o.CONNECT = 0] = \"CONNECT\", o[o.DISCONNECT = 1] = \"DISCONNECT\", o[o.EVENT = 2] = \"EVENT\", o[o.ACK = 3] = \"ACK\", o[o.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", o[o.BINARY_EVENT = 5] = \"BINARY_EVENT\", o[o.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\nclass Encoder {\n  /**\n   * Encoder constructor\n   *\n   * @param {function} replacer - custom replacer to pass down to JSON.parse\n   */\n  constructor(t) {\n    this.replacer = t;\n  }\n  /**\n   * Encode a packet as a single string if non-binary, or as a\n   * buffer sequence, depending on packet type.\n   *\n   * @param {Object} obj - packet object\n   */\n  encode(t) {\n    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? this.encodeAsBinary({\n      type: t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,\n      nsp: t.nsp,\n      data: t.data,\n      id: t.id\n    }) : [this.encodeAsString(t)];\n  }\n  /**\n   * Encode packet as string.\n   */\n  encodeAsString(t) {\n    let e = \"\" + t.type;\n    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + \"-\"), t.nsp && t.nsp !== \"/\" && (e += t.nsp + \",\"), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;\n  }\n  /**\n   * Encode packet as 'buffer sequence' by removing blobs, and\n   * deconstructing packet into object with placeholders and\n   * a list of buffers.\n   */\n  encodeAsBinary(t) {\n    const e = deconstructPacket(t), r = this.encodeAsString(e.packet), D = e.buffers;\n    return D.unshift(r), D;\n  }\n}\nclass Decoder extends Emitter {\n  /**\n   * Decoder constructor\n   *\n   * @param {function} reviver - custom reviver to pass down to JSON.stringify\n   */\n  constructor(t) {\n    super(), this.reviver = t;\n  }\n  /**\n   * Decodes an encoded packet string into packet JSON.\n   *\n   * @param {String} obj - encoded packet\n   */\n  add(t) {\n    let e;\n    if (typeof t == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      e = this.decodeString(t);\n      const r = e.type === PacketType.BINARY_EVENT;\n      r || e.type === PacketType.BINARY_ACK ? (e.type = r ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n    } else if (isBinary(t) || t.base64)\n      if (this.reconstructor)\n        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + t);\n  }\n  /**\n   * Decode a packet String (JSON data)\n   *\n   * @param {String} str\n   * @return {Object} packet\n   */\n  decodeString(t) {\n    let e = 0;\n    const r = {\n      type: Number(t.charAt(0))\n    };\n    if (PacketType[r.type] === void 0)\n      throw new Error(\"unknown packet type \" + r.type);\n    if (r.type === PacketType.BINARY_EVENT || r.type === PacketType.BINARY_ACK) {\n      const N = e + 1;\n      for (; t.charAt(++e) !== \"-\" && e != t.length; )\n        ;\n      const k = t.substring(N, e);\n      if (k != Number(k) || t.charAt(e) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      r.attachments = Number(k);\n    }\n    if (t.charAt(e + 1) === \"/\") {\n      const N = e + 1;\n      for (; ++e && !(t.charAt(e) === \",\" || e === t.length); )\n        ;\n      r.nsp = t.substring(N, e);\n    } else\n      r.nsp = \"/\";\n    const D = t.charAt(e + 1);\n    if (D !== \"\" && Number(D) == D) {\n      const N = e + 1;\n      for (; ++e; ) {\n        const k = t.charAt(e);\n        if (k == null || Number(k) != k) {\n          --e;\n          break;\n        }\n        if (e === t.length)\n          break;\n      }\n      r.id = Number(t.substring(N, e + 1));\n    }\n    if (t.charAt(++e)) {\n      const N = this.tryParse(t.substr(e));\n      if (Decoder.isPayloadValid(r.type, N))\n        r.data = N;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return r;\n  }\n  tryParse(t) {\n    try {\n      return JSON.parse(t, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(t, e) {\n    switch (t) {\n      case PacketType.CONNECT:\n        return typeof e == \"object\";\n      case PacketType.DISCONNECT:\n        return e === void 0;\n      case PacketType.CONNECT_ERROR:\n        return typeof e == \"string\" || typeof e == \"object\";\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(e) && e.length > 0;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(e);\n    }\n  }\n  /**\n   * Deallocates a parser's resources\n   */\n  destroy() {\n    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);\n  }\n}\nclass BinaryReconstructor {\n  constructor(t) {\n    this.packet = t, this.buffers = [], this.reconPack = t;\n  }\n  /**\n   * Method to be called when binary data received from connection\n   * after a BINARY_EVENT packet.\n   *\n   * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n   * @return {null | Object} returns null if more binary data is expected or\n   *   a reconstructed packet object if all buffers have been received.\n   */\n  takeBinaryData(t) {\n    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n      const e = reconstructPacket(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), e;\n    }\n    return null;\n  }\n  /**\n   * Cleans up binary packet reconstruction variables.\n   */\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Decoder,\n  Encoder,\n  get PacketType() {\n    return PacketType;\n  },\n  protocol\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction on(o, t, e) {\n  return o.on(t, e), function() {\n    o.off(t, e);\n  };\n}\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n  newListener: 1,\n  removeListener: 1\n});\nclass Socket extends Emitter {\n  /**\n   * `Socket` constructor.\n   */\n  constructor(t, e, r) {\n    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();\n  }\n  /**\n   * Whether the socket is currently disconnected\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"connect\", () => {\n   *   console.log(socket.disconnected); // false\n   * });\n   *\n   * socket.on(\"disconnect\", () => {\n   *   console.log(socket.disconnected); // true\n   * });\n   */\n  get disconnected() {\n    return !this.connected;\n  }\n  /**\n   * Subscribe to open, close and packet events\n   *\n   * @private\n   */\n  subEvents() {\n    if (this.subs)\n      return;\n    const t = this.io;\n    this.subs = [\n      on(t, \"open\", this.onopen.bind(this)),\n      on(t, \"packet\", this.onpacket.bind(this)),\n      on(t, \"error\", this.onerror.bind(this)),\n      on(t, \"close\", this.onclose.bind(this))\n    ];\n  }\n  /**\n   * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n   *\n   * @example\n   * const socket = io();\n   *\n   * console.log(socket.active); // true\n   *\n   * socket.on(\"disconnect\", (reason) => {\n   *   if (reason === \"io server disconnect\") {\n   *     // the disconnection was initiated by the server, you need to manually reconnect\n   *     console.log(socket.active); // false\n   *   }\n   *   // else the socket will automatically try to reconnect\n   *   console.log(socket.active); // true\n   * });\n   */\n  get active() {\n    return !!this.subs;\n  }\n  /**\n   * \"Opens\" the socket.\n   *\n   * @example\n   * const socket = io({\n   *   autoConnect: false\n   * });\n   *\n   * socket.connect();\n   */\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  /**\n   * Alias for {@link connect()}.\n   */\n  open() {\n    return this.connect();\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * This method mimics the WebSocket.send() method.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   *\n   * @example\n   * socket.send(\"hello\");\n   *\n   * // this is equivalent to\n   * socket.emit(\"message\", \"hello\");\n   *\n   * @return self\n   */\n  send(...t) {\n    return t.unshift(\"message\"), this.emit.apply(this, t), this;\n  }\n  /**\n   * Override `emit`.\n   * If the event is in `events`, it's emitted normally.\n   *\n   * @example\n   * socket.emit(\"hello\", \"world\");\n   *\n   * // all serializable datastructures are supported (no need to call JSON.stringify)\n   * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n   *\n   * // with an acknowledgement from the server\n   * socket.emit(\"hello\", \"world\", (val) => {\n   *   // ...\n   * });\n   *\n   * @return self\n   */\n  emit(t, ...e) {\n    if (RESERVED_EVENTS.hasOwnProperty(t))\n      throw new Error('\"' + t.toString() + '\" is a reserved event name');\n    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)\n      return this._addToQueue(e), this;\n    const r = {\n      type: PacketType.EVENT,\n      data: e\n    };\n    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == \"function\") {\n      const k = this.ids++, $ = e.pop();\n      this._registerAckCallback(k, $), r.id = k;\n    }\n    const D = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!D || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;\n  }\n  /**\n   * @private\n   */\n  _registerAckCallback(t, e) {\n    var r;\n    const D = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;\n    if (D === void 0) {\n      this.acks[t] = e;\n      return;\n    }\n    const N = this.io.setTimeoutFn(() => {\n      delete this.acks[t];\n      for (let k = 0; k < this.sendBuffer.length; k++)\n        this.sendBuffer[k].id === t && this.sendBuffer.splice(k, 1);\n      e.call(this, new Error(\"operation has timed out\"));\n    }, D);\n    this.acks[t] = (...k) => {\n      this.io.clearTimeoutFn(N), e.apply(this, [null, ...k]);\n    };\n  }\n  /**\n   * Emits an event and waits for an acknowledgement\n   *\n   * @example\n   * // without timeout\n   * const response = await socket.emitWithAck(\"hello\", \"world\");\n   *\n   * // with a specific timeout\n   * try {\n   *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n   * } catch (err) {\n   *   // the server did not acknowledge the event in the given delay\n   * }\n   *\n   * @return a Promise that will be fulfilled when the server acknowledges the event\n   */\n  emitWithAck(t, ...e) {\n    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n    return new Promise((D, N) => {\n      e.push((k, $) => r ? k ? N(k) : D($) : D(k)), this.emit(t, ...e);\n    });\n  }\n  /**\n   * Add the packet to the queue.\n   * @param args\n   * @private\n   */\n  _addToQueue(t) {\n    let e;\n    typeof t[t.length - 1] == \"function\" && (e = t.pop());\n    const r = {\n      id: this._queueSeq++,\n      tryCount: 0,\n      pending: !1,\n      args: t,\n      flags: Object.assign({ fromQueue: !0 }, this.flags)\n    };\n    t.push((D, ...N) => r !== this._queue[0] ? void 0 : (D !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), e && e(D)) : (this._queue.shift(), e && e(null, ...N)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();\n  }\n  /**\n   * Send the first packet of the queue, and wait for an acknowledgement from the server.\n   * @param force - whether to resend a packet that has not been acknowledged yet\n   *\n   * @private\n   */\n  _drainQueue(t = !1) {\n    if (!this.connected || this._queue.length === 0)\n      return;\n    const e = this._queue[0];\n    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param packet\n   * @private\n   */\n  packet(t) {\n    t.nsp = this.nsp, this.io._packet(t);\n  }\n  /**\n   * Called upon engine `open`.\n   *\n   * @private\n   */\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((t) => {\n      this._sendConnectPacket(t);\n    }) : this._sendConnectPacket(this.auth);\n  }\n  /**\n   * Sends a CONNECT packet to initiate the Socket.IO session.\n   *\n   * @param data\n   * @private\n   */\n  _sendConnectPacket(t) {\n    this.packet({\n      type: PacketType.CONNECT,\n      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t\n    });\n  }\n  /**\n   * Called upon engine or manager `error`.\n   *\n   * @param err\n   * @private\n   */\n  onerror(t) {\n    this.connected || this.emitReserved(\"connect_error\", t);\n  }\n  /**\n   * Called upon engine `close`.\n   *\n   * @param reason\n   * @param description\n   * @private\n   */\n  onclose(t, e) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n  }\n  /**\n   * Called with socket packet.\n   *\n   * @param packet\n   * @private\n   */\n  onpacket(t) {\n    if (t.nsp === this.nsp)\n      switch (t.type) {\n        case PacketType.CONNECT:\n          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case PacketType.EVENT:\n        case PacketType.BINARY_EVENT:\n          this.onevent(t);\n          break;\n        case PacketType.ACK:\n        case PacketType.BINARY_ACK:\n          this.onack(t);\n          break;\n        case PacketType.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case PacketType.CONNECT_ERROR:\n          this.destroy();\n          const r = new Error(t.data.message);\n          r.data = t.data.data, this.emitReserved(\"connect_error\", r);\n          break;\n      }\n  }\n  /**\n   * Called upon a server event.\n   *\n   * @param packet\n   * @private\n   */\n  onevent(t) {\n    const e = t.data || [];\n    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n  }\n  emitEvent(t) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const e = this._anyListeners.slice();\n      for (const r of e)\n        r.apply(this, t);\n    }\n    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == \"string\" && (this._lastOffset = t[t.length - 1]);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @private\n   */\n  ack(t) {\n    const e = this;\n    let r = !1;\n    return function(...D) {\n      r || (r = !0, e.packet({\n        type: PacketType.ACK,\n        id: t,\n        data: D\n      }));\n    };\n  }\n  /**\n   * Called upon a server acknowlegement.\n   *\n   * @param packet\n   * @private\n   */\n  onack(t) {\n    const e = this.acks[t.id];\n    typeof e == \"function\" && (e.apply(this, t.data), delete this.acks[t.id]);\n  }\n  /**\n   * Called upon server connect.\n   *\n   * @private\n   */\n  onconnect(t, e) {\n    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\"), this._drainQueue(!0);\n  }\n  /**\n   * Emit buffered events (received and emitted).\n   *\n   * @private\n   */\n  emitBuffered() {\n    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {\n      this.notifyOutgoingListeners(t), this.packet(t);\n    }), this.sendBuffer = [];\n  }\n  /**\n   * Called upon server disconnect.\n   *\n   * @private\n   */\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  /**\n   * Called upon forced client/server side disconnections,\n   * this method ensures the manager stops tracking us and\n   * that reconnections don't get triggered for this.\n   *\n   * @private\n   */\n  destroy() {\n    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);\n  }\n  /**\n   * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n   *\n   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"disconnect\", (reason) => {\n   *   // console.log(reason); prints \"io client disconnect\"\n   * });\n   *\n   * socket.disconnect();\n   *\n   * @return self\n   */\n  disconnect() {\n    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  /**\n   * Alias for {@link disconnect()}.\n   *\n   * @return self\n   */\n  close() {\n    return this.disconnect();\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @example\n   * socket.compress(false).emit(\"hello\");\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return self\n   */\n  compress(t) {\n    return this.flags.compress = t, this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n   * ready to send messages.\n   *\n   * @example\n   * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n   *\n   * @returns self\n   */\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n   * given number of milliseconds have elapsed without an acknowledgement from the server:\n   *\n   * @example\n   * socket.timeout(5000).emit(\"my-event\", (err) => {\n   *   if (err) {\n   *     // the server did not acknowledge the event in the given delay\n   *   }\n   * });\n   *\n   * @returns self\n   */\n  timeout(t) {\n    return this.flags.timeout = t, this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * @example\n   * socket.onAny((event, ...args) => {\n   *   console.log(`got ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  onAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @example\n   * socket.prependAny((event, ...args) => {\n   *   console.log(`got event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  prependAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @example\n   * const catchAllListener = (event, ...args) => {\n   *   console.log(`got event ${event}`);\n   * }\n   *\n   * socket.onAny(catchAllListener);\n   *\n   * // remove a specific listener\n   * socket.offAny(catchAllListener);\n   *\n   * // or remove all listeners\n   * socket.offAny();\n   *\n   * @param listener\n   */\n  offAny(t) {\n    if (!this._anyListeners)\n      return this;\n    if (t) {\n      const e = this._anyListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * Note: acknowledgements sent to the server are not included.\n   *\n   * @example\n   * socket.onAnyOutgoing((event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  onAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * Note: acknowledgements sent to the server are not included.\n   *\n   * @example\n   * socket.prependAnyOutgoing((event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  prependAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @example\n   * const catchAllListener = (event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * }\n   *\n   * socket.onAnyOutgoing(catchAllListener);\n   *\n   * // remove a specific listener\n   * socket.offAnyOutgoing(catchAllListener);\n   *\n   * // or remove all listeners\n   * socket.offAnyOutgoing();\n   *\n   * @param [listener] - the catch-all listener (optional)\n   */\n  offAnyOutgoing(t) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (t) {\n      const e = this._anyOutgoingListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  /**\n   * Notify the listeners for each packet sent\n   *\n   * @param packet\n   *\n   * @private\n   */\n  notifyOutgoingListeners(t) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const e = this._anyOutgoingListeners.slice();\n      for (const r of e)\n        r.apply(this, t.data);\n    }\n  }\n}\nfunction Backoff(o) {\n  o = o || {}, this.ms = o.min || 100, this.max = o.max || 1e4, this.factor = o.factor || 2, this.jitter = o.jitter > 0 && o.jitter <= 1 ? o.jitter : 0, this.attempts = 0;\n}\nBackoff.prototype.duration = function() {\n  var o = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var t = Math.random(), e = Math.floor(t * this.jitter * o);\n    o = Math.floor(t * 10) & 1 ? o + e : o - e;\n  }\n  return Math.min(o, this.max) | 0;\n};\nBackoff.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function(o) {\n  this.ms = o;\n};\nBackoff.prototype.setMax = function(o) {\n  this.max = o;\n};\nBackoff.prototype.setJitter = function(o) {\n  this.jitter = o;\n};\nclass Manager extends Emitter {\n  constructor(t, e) {\n    var r;\n    super(), this.nsps = {}, this.subs = [], t && typeof t == \"object\" && (e = t, t = void 0), e = e || {}, e.path = e.path || \"/socket.io\", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n    const D = e.parser || parser;\n    this.encoder = new D.Encoder(), this.decoder = new D.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(t) {\n    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n  }\n  reconnectionAttempts(t) {\n    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n  }\n  reconnectionDelay(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);\n  }\n  randomizationFactor(t) {\n    var e;\n    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);\n  }\n  reconnectionDelayMax(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);\n  }\n  timeout(t) {\n    return arguments.length ? (this._timeout = t, this) : this._timeout;\n  }\n  /**\n   * Starts trying to reconnect if reconnection is enabled and we have not\n   * started reconnecting yet\n   *\n   * @private\n   */\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  /**\n   * Sets the current transport `socket`.\n   *\n   * @param {Function} fn - optional, callback\n   * @return self\n   * @public\n   */\n  open(t) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Socket$1(this.uri, this.opts);\n    const e = this.engine, r = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const D = on(e, \"open\", function() {\n      r.onopen(), t && t();\n    }), N = on(e, \"error\", (k) => {\n      r.cleanup(), r._readyState = \"closed\", this.emitReserved(\"error\", k), t ? t(k) : r.maybeReconnectOnOpen();\n    });\n    if (this._timeout !== !1) {\n      const k = this._timeout;\n      k === 0 && D();\n      const $ = this.setTimeoutFn(() => {\n        D(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n      }, k);\n      this.opts.autoUnref && $.unref(), this.subs.push(function() {\n        clearTimeout($);\n      });\n    }\n    return this.subs.push(D), this.subs.push(N), this;\n  }\n  /**\n   * Alias for open()\n   *\n   * @return self\n   * @public\n   */\n  connect(t) {\n    return this.open(t);\n  }\n  /**\n   * Called upon transport open.\n   *\n   * @private\n   */\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const t = this.engine;\n    this.subs.push(on(t, \"ping\", this.onping.bind(this)), on(t, \"data\", this.ondata.bind(this)), on(t, \"error\", this.onerror.bind(this)), on(t, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  /**\n   * Called upon a ping.\n   *\n   * @private\n   */\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  /**\n   * Called with data.\n   *\n   * @private\n   */\n  ondata(t) {\n    try {\n      this.decoder.add(t);\n    } catch (e) {\n      this.onclose(\"parse error\", e);\n    }\n  }\n  /**\n   * Called when parser fully decodes a packet.\n   *\n   * @private\n   */\n  ondecoded(t) {\n    nextTick(() => {\n      this.emitReserved(\"packet\", t);\n    }, this.setTimeoutFn);\n  }\n  /**\n   * Called upon socket error.\n   *\n   * @private\n   */\n  onerror(t) {\n    this.emitReserved(\"error\", t);\n  }\n  /**\n   * Creates a new socket for the given `nsp`.\n   *\n   * @return {Socket}\n   * @public\n   */\n  socket(t, e) {\n    let r = this.nsps[t];\n    return r ? this._autoConnect && !r.active && r.connect() : (r = new Socket(this, t, e), this.nsps[t] = r), r;\n  }\n  /**\n   * Called upon a socket close.\n   *\n   * @param socket\n   * @private\n   */\n  _destroy(t) {\n    const e = Object.keys(this.nsps);\n    for (const r of e)\n      if (this.nsps[r].active)\n        return;\n    this._close();\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param packet\n   * @private\n   */\n  _packet(t) {\n    const e = this.encoder.encode(t);\n    for (let r = 0; r < e.length; r++)\n      this.engine.write(e[r], t.options);\n  }\n  /**\n   * Clean up transport subscriptions and packet buffer.\n   *\n   * @private\n   */\n  cleanup() {\n    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();\n  }\n  /**\n   * Close the current socket.\n   *\n   * @private\n   */\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  /**\n   * Alias for close()\n   *\n   * @private\n   */\n  disconnect() {\n    return this._close();\n  }\n  /**\n   * Called upon engine close.\n   *\n   * @private\n   */\n  onclose(t, e) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  /**\n   * Attempt a reconnection.\n   *\n   * @private\n   */\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const t = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const e = this.backoff.duration();\n      this._reconnecting = !0;\n      const r = this.setTimeoutFn(() => {\n        t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), !t.skipReconnect && t.open((D) => {\n          D ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", D)) : t.onreconnect();\n        }));\n      }, e);\n      this.opts.autoUnref && r.unref(), this.subs.push(function() {\n        clearTimeout(r);\n      });\n    }\n  }\n  /**\n   * Called upon successful reconnect.\n   *\n   * @private\n   */\n  onreconnect() {\n    const t = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n  }\n}\nconst cache = {};\nfunction lookup(o, t) {\n  typeof o == \"object\" && (t = o, o = void 0), t = t || {};\n  const e = url(o, t.path || \"/socket.io\"), r = e.source, D = e.id, N = e.path, k = cache[D] && N in cache[D].nsps, $ = t.forceNew || t[\"force new connection\"] || t.multiplex === !1 || k;\n  let G;\n  return $ ? G = new Manager(r, t) : (cache[D] || (cache[D] = new Manager(r, t)), G = cache[D]), e.query && !t.query && (t.query = e.queryKey), G.socket(e.path, t);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\nvar Br, ti, ei, cs, fs, tn, en, rn, Fc, $c, Jl, Ba, Gc, Fa, ds, Uc, ps, $a;\nconst jc = class {\n  constructor(t = {}, e) {\n    Ot(this, \"hFactoryCls\", {});\n    Ot(this, \"elc\", new EventListenerCtn());\n    Ot(this, \"fetch\", (t) => fetch(t));\n    Ot(this, \"resolution\", 1);\n    Ot(this, \"cfg\");\n    Ot(this, \"data\", { sys: {}, mark: {}, kidoku: {} });\n    Ot(this, \"val\");\n    Ot(this, \"appPixi\");\n    rt(this, Br, 0);\n    rt(this, ti, 0);\n    rt(this, ei, 1);\n    rt(this, cs, 0);\n    rt(this, fs, 0);\n    rt(this, tn, 0);\n    rt(this, en, 0);\n    Ot(this, \"isFullScr\", !1);\n    Ot(this, \"extPort\", 3776);\n    rt(this, rn, void 0);\n    rt(this, Fc, {\n      auth: (t) => {\n        if (t.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"接続\");\n      },\n      continue: () => this.toast(\"再生\"),\n      disconnect: () => this.toast(\"切断\"),\n      restart: (t) => {\n        this.send2Dbg((t == null ? void 0 : t.ri) ?? \"\", {}), this.end(), this.run();\n      },\n      pause: () => this.toast(\"一時停止\"),\n      stopOnEntry: () => this.toast(\"一時停止\"),\n      stopOnDataBreakpoint: () => this.toast(\"注意\"),\n      stopOnBreakpoint: () => this.toast(\"注意\"),\n      stopOnStep: () => this.toast(\"一歩進む\"),\n      stopOnStepIn: () => this.toast(\"ステップイン\"),\n      stopOnStepOut: () => this.toast(\"ステップアウト\"),\n      stopOnBackstep: () => this.toast(\"一歩戻る\"),\n      _addPath: (t) => this.cfg.addPath(t.fn, t.o)\n    });\n    Ot(this, \"pathBaseCnvSnPath4Dbg\", \"\");\n    Ot(this, \"fire\");\n    rt(this, Jl, []);\n    Ot(this, \"callHook\", (t, e) => {\n    });\n    Ot(this, \"send2Dbg\", (t, e) => {\n      var r;\n      (r = H(this, rn)) == null || r.emit(\"data\", t, e);\n    });\n    Ot(this, \"copyBMFolder\", (t, e) => {\n    });\n    Ot(this, \"eraseBMFolder\", (t) => {\n    });\n    Ot(this, \"close\", () => !1);\n    Ot(this, \"_export\", () => !1);\n    Ot(this, \"_import\", () => !1);\n    Ot(this, \"navigate_to\", () => !1);\n    Ot(this, \"title\", (t) => {\n      const { text: e } = t;\n      if (!e)\n        throw \"[title] textは必須です\";\n      return ot(this, Ba, e), this.titleSub(H(this, Ba) + H(this, Fa)), !1;\n    });\n    rt(this, Ba, \"\");\n    rt(this, Gc, (t) => {\n      if (!t.key)\n        return this.tglFlscr_sub(), !1;\n      const e = t.key.toLowerCase();\n      return this.elc.add(document, \"keydown\", (r) => {\n        (r.altKey ? r.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (r.ctrlKey ? r.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (r.shiftKey ? r.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());\n      }, { passive: !0 }), !1;\n    });\n    Ot(this, \"update_check\", () => !1);\n    Ot(this, \"window\", () => !1);\n    rt(this, Fa, \"\");\n    rt(this, ds, (t, e) => ({ ret: e.toString(), ext_num: 0 }));\n    rt(this, Uc, {\n      1: { ext: \"jpeg\", fnc: (t) => H(this, ps).call(this, t), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (t) => H(this, ps).call(this, t), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (t) => H(this, ps).call(this, t), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (t) => H(this, ps).call(this, t), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (t) => t.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (t) => t.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (t) => t.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (t) => H(this, $a).call(this, t), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (t) => H(this, $a).call(this, t), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (t) => H(this, $a).call(this, t), mime: \"video/ogv\" }\n    });\n    rt(this, ps, (t) => new Promise((e, r) => {\n      const D = new Image();\n      D.onload = () => e(D), D.onerror = (N) => r(N), D.src = URL.createObjectURL(t);\n    }));\n    rt(this, $a, (t) => new Promise((e, r) => {\n      const D = document.createElement(\"video\");\n      this.elc.add(D, \"error\", () => {\n        var N;\n        return r(((N = D == null ? void 0 : D.error) == null ? void 0 : N.message) ?? \"\");\n      }), this.elc.add(D, \"canplay\", () => e(D)), D.src = URL.createObjectURL(t);\n    }));\n    Ot(this, \"enc\", (t) => t);\n    Ot(this, \"stk\", () => \"\");\n    Ot(this, \"hash\", (t) => \"\");\n    Ot(this, \"isApp\", !1);\n    Ot(this, \"$path_downloads\", \"\");\n    Ot(this, \"$path_userdata\", \"\");\n    this.hPlg = t, this.arg = e;\n  }\n  async loaded(t, e) {\n    const r = t.snsys_pre;\n    return delete t.snsys_pre, r == null ? void 0 : r.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (D) => ot(this, ds, D),\n      setEnc: (D) => this.enc = D,\n      getStK: (D) => this.stk = D,\n      getHash: (D) => this.hash = D\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  destroy() {\n    this.elc.clear();\n  }\n  async loadPath(t, e) {\n    this.cfg = e;\n  }\n  initVal(t, e, r) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(t, e, r, D) {\n    this.val = r, this.appPixi = e;\n    let N = \"\";\n    try {\n      this.val.setSys(this), N = \"sys\", N += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), N = \"kidoku\", this.val.saveKidoku();\n    } catch (k) {\n      console.error(`セーブデータ（${N}）が壊れています。一度クリアする必要があります %o`, k);\n    }\n    return t.close = (k) => this.close(k), t.export = (k) => this._export(k), t.import = (k) => this._import(k), t.navigate_to = (k) => this.navigate_to(k), t.title = (k) => this.title(k), t.toggle_full_screen = (k) => H(this, Gc).call(this, k), t.update_check = (k) => this.update_check(k), t.window = (k) => this.window(k), r.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp), r.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => CmnLib.isDbg), r.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => CmnLib.isPackaged), this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr), r.setVal_Nochk(\"sys\", jc.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), CmnLib.isDbg && this.attach_debug(D), this.hFactoryCls = {}, Object.values(this.hPlg).map((k) => k.init({\n      addTag: ($, G) => {\n        if (t[$])\n          throw `すでに定義済みのタグ[${$}]です`;\n        t[$] = G;\n      },\n      addLayCls: ($, G) => {\n        if (this.hFactoryCls[$])\n          throw `すでに定義済みのレイヤcls【${$}】です`;\n        this.hFactoryCls[$] = G;\n      },\n      searchPath: ($, G = \"\") => this.cfg.searchPath($, G),\n      getVal: r.getVal,\n      resume: () => D.resume(),\n      render: ($, G, U = !1) => this.appPixi.renderer.render($, { renderTexture: G, clear: U }),\n      setDec: ($) => ot(this, ds, $),\n      setEnc: ($) => this.enc = $,\n      getStK: ($) => this.stk = $,\n      getHash: ($) => this.hash = $\n    }));\n  }\n  get cvsWidth() {\n    return H(this, Br);\n  }\n  get cvsHeight() {\n    return H(this, ti);\n  }\n  get cvsScale() {\n    return H(this, ei);\n  }\n  get ofsLeft4elm() {\n    return H(this, cs);\n  }\n  get ofsTop4elm() {\n    return H(this, fs);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return H(this, tn);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return H(this, en);\n  }\n  cvsResize() {\n    var G;\n    let t = globalThis.innerWidth, e = globalThis.innerHeight;\n    const r = Main.cvs, D = r.parentElement !== document.body;\n    if (D) {\n      const U = globalThis.getComputedStyle(r);\n      t = parseFloat(U.width), e = parseFloat(U.height);\n    }\n    if (CmnLib.isMobile) {\n      const z = (((G = screen.orientation) == null ? void 0 : G.angle) ?? 0) % 180 === 0;\n      (z && t > e || !z && t < e) && ([t, e] = [e, t]);\n    }\n    const N = r.getBoundingClientRect();\n    if (argChk_Boolean(CmnLib.hDip, \"expanding\", !0) || D || CmnLib.stageW > t || CmnLib.stageH > e)\n      if (CmnLib.stageW / CmnLib.stageH <= t / e ? (ot(this, ti, e), ot(this, Br, CmnLib.stageW / CmnLib.stageH * e)) : (ot(this, Br, t), ot(this, ti, CmnLib.stageH / CmnLib.stageW * t)), ot(this, ei, H(this, Br) / CmnLib.stageW), D)\n        ot(this, tn, 0), ot(this, en, 0);\n      else {\n        const U = 1 - H(this, ei);\n        CmnLib.isMobile ? (ot(this, tn, (t - H(this, Br)) / 2 * U), ot(this, en, (e - H(this, ti)) / 2 * U)) : (ot(this, tn, N.left * U), ot(this, en, N.top * U));\n      }\n    else\n      ot(this, Br, CmnLib.stageW), ot(this, ti, CmnLib.stageH), ot(this, ei, 1), ot(this, tn, 0), ot(this, en, 0);\n    const k = r.parentElement.style;\n    D || (k.position = \"relative\", k.width = `${H(this, Br)}px`, k.height = `${H(this, ti)}px`);\n    const $ = r.style;\n    $.width = k.width, $.height = k.height, D ? (ot(this, cs, N.left), ot(this, fs, N.top)) : (ot(this, cs, 0), ot(this, fs, 0)), this.isFullScr && (ot(this, cs, H(this, cs) + (t - H(this, Br)) / 2), ot(this, fs, H(this, fs) + (e - H(this, ti)) / 2));\n  }\n  // デバッガ接続\n  attach_debug(t) {\n    this.attach_debug = () => {\n    };\n    const e = document.createElement(\"style\");\n    e.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`, document.getElementsByTagName(\"head\")[0].appendChild(e), this.addHook((r, D) => {\n      var N, k;\n      return (k = (N = H(this, Fc))[r]) == null ? void 0 : k.call(N, D);\n    }), ot(this, rn, lookup(`http://localhost:${this.extPort}`)), H(this, rn).on(\"data\", (r, D) => {\n      this.callHook(r, D);\n    }).on(\"disconnect\", () => t.setLoop(!0)), this.callHook = (r, D) => {\n      for (const N of H(this, Jl))\n        N(r, D);\n    };\n  }\n  end() {\n    var t;\n    (t = H(this, rn)) == null || t.disconnect(), ot(this, rn, void 0);\n  }\n  toast(t) {\n    const e = document.body;\n    e.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach((k) => e.removeChild(k));\n    const r = document.createElement(\"img\"), D = H(jc, $c)[t];\n    r.src = `data:image/svg+xml;base64,${D.dat}`;\n    const N = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * H(this, ei);\n    r.width = r.height = N, r.style.cssText = `position: absolute;\nleft: ${(CmnLib.stageW - N) / 2 * H(this, ei) + N * (D.dx ?? 0)}px;\ntop: ${(CmnLib.stageH - N) / 2 * H(this, ei) + N * (D.dy ?? 0)}px;`, r.classList.add(\"sn_toast\", D.ease ?? \"sn_BounceInOut\"), D.ease || r.addEventListener(\"animationend\", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Main.cvs);\n  }\n  setFire(t) {\n    this.fire = t;\n  }\n  addHook(t) {\n    H(this, Jl).push(t);\n  }\n  titleSub(t) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(t) {\n    ot(this, Fa, t), this.titleSub(H(this, Ba) + H(this, Fa));\n  }\n  decStr(t, e) {\n    return H(this, ds).call(this, t, e).ret;\n  }\n  async dec(t, e) {\n    const { ret: r, ext_num: D } = H(this, ds).call(this, t, e), N = H(this, Uc)[D];\n    return N != null && N.fnc ? await N.fnc(new Blob([r], { type: N.mime })) : r;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  canCapturePage(t, e) {\n    return !1;\n  }\n  async savePic(t, e) {\n  }\n  async appendFile(t, e, r) {\n  }\n  async ensureFileSync(t) {\n  }\n};\nlet SysBase = jc;\nBr = new WeakMap(), ti = new WeakMap(), ei = new WeakMap(), cs = new WeakMap(), fs = new WeakMap(), tn = new WeakMap(), en = new WeakMap(), rn = new WeakMap(), Fc = new WeakMap(), $c = new WeakMap(), Jl = new WeakMap(), Ba = new WeakMap(), Gc = new WeakMap(), Fa = new WeakMap(), ds = new WeakMap(), Uc = new WeakMap(), ps = new WeakMap(), $a = new WeakMap(), Ot(SysBase, \"VALNM_CFG_NS\", \"const.sn.cfg.ns\"), rt(SysBase, $c, {\n  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ \n  接続: { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  切断: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  再生: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一時停止: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  注意: { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  一歩進む: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一歩戻る: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  ステップイン: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  ステップアウト: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nvar assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < \"u\" ? window : commonjsGlobal, util$6 = {\n  assign,\n  create: create$1,\n  trim: trim$1,\n  bind: bind$1,\n  slice: slice$1,\n  each: each$7,\n  map,\n  pluck: pluck$1,\n  isList: isList$1,\n  isFunction: isFunction$1,\n  isObject: isObject$1,\n  Global: Global$5\n};\nfunction make_assign() {\n  return Object.assign ? Object.assign : function(t, e, r, D) {\n    for (var N = 1; N < arguments.length; N++)\n      each$7(Object(arguments[N]), function(k, $) {\n        t[$] = k;\n      });\n    return t;\n  };\n}\nfunction make_create() {\n  if (Object.create)\n    return function(t, e, r, D) {\n      var N = slice$1(arguments, 1);\n      return assign.apply(this, [Object.create(t)].concat(N));\n    };\n  {\n    let o = function() {\n    };\n    return function(e, r, D, N) {\n      var k = slice$1(arguments, 1);\n      return o.prototype = e, assign.apply(this, [new o()].concat(k));\n    };\n  }\n}\nfunction make_trim() {\n  return String.prototype.trim ? function(t) {\n    return String.prototype.trim.call(t);\n  } : function(t) {\n    return t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n}\nfunction bind$1(o, t) {\n  return function() {\n    return t.apply(o, Array.prototype.slice.call(arguments, 0));\n  };\n}\nfunction slice$1(o, t) {\n  return Array.prototype.slice.call(o, t || 0);\n}\nfunction each$7(o, t) {\n  pluck$1(o, function(e, r) {\n    return t(e, r), !1;\n  });\n}\nfunction map(o, t) {\n  var e = isList$1(o) ? [] : {};\n  return pluck$1(o, function(r, D) {\n    return e[D] = t(r, D), !1;\n  }), e;\n}\nfunction pluck$1(o, t) {\n  if (isList$1(o)) {\n    for (var e = 0; e < o.length; e++)\n      if (t(o[e], e))\n        return o[e];\n  } else\n    for (var r in o)\n      if (o.hasOwnProperty(r) && t(o[r], r))\n        return o[r];\n}\nfunction isList$1(o) {\n  return o != null && typeof o != \"function\" && typeof o.length == \"number\";\n}\nfunction isFunction$1(o) {\n  return o && {}.toString.call(o) === \"[object Function]\";\n}\nfunction isObject$1(o) {\n  return o && {}.toString.call(o) === \"[object Object]\";\n}\nvar util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {\n  createStore\n}, storeAPI = {\n  version: \"2.0.12\",\n  enabled: !1,\n  // get returns the value of the given key. If that value\n  // is undefined, it returns optionalDefaultValue instead.\n  get: function(o, t) {\n    var e = this.storage.read(this._namespacePrefix + o);\n    return this._deserialize(e, t);\n  },\n  // set will store the given value at key and returns value.\n  // Calling set with value === undefined is equivalent to calling remove.\n  set: function(o, t) {\n    return t === void 0 ? this.remove(o) : (this.storage.write(this._namespacePrefix + o, this._serialize(t)), t);\n  },\n  // remove deletes the key and value stored at the given key.\n  remove: function(o) {\n    this.storage.remove(this._namespacePrefix + o);\n  },\n  // each will call the given callback once for each key-value pair\n  // in this store.\n  each: function(o) {\n    var t = this;\n    this.storage.each(function(e, r) {\n      o.call(t, t._deserialize(e), (r || \"\").replace(t._namespaceRegexp, \"\"));\n    });\n  },\n  // clearAll will remove all the stored key-value pairs in this store.\n  clearAll: function() {\n    this.storage.clearAll();\n  },\n  // additional functionality that can't live in plugins\n  // ---------------------------------------------------\n  // hasNamespace returns true if this store instance has the given namespace.\n  hasNamespace: function(o) {\n    return this._namespacePrefix == \"__storejs_\" + o + \"_\";\n  },\n  // createStore creates a store.js instance with the first\n  // functioning storage in the list of storage candidates,\n  // and applies the the given mixins to the instance.\n  createStore: function() {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function(o) {\n    this._addPlugin(o);\n  },\n  namespace: function(o) {\n    return createStore(this.storage, this.plugins, o);\n  }\n};\nfunction _warn() {\n  var o = typeof console > \"u\" ? null : console;\n  if (o) {\n    var t = o.warn ? o.warn : o.log;\n    t.apply(o, arguments);\n  }\n}\nfunction createStore(o, t, e) {\n  e || (e = \"\"), o && !isList(o) && (o = [o]), t && !isList(t) && (t = [t]);\n  var r = e ? \"__storejs_\" + e + \"_\" : \"\", D = e ? new RegExp(\"^\" + r) : null, N = /^[a-zA-Z0-9_\\-]*$/;\n  if (!N.test(e))\n    throw new Error(\"store.js namespaces can only have alphanumerics + underscores and dashes\");\n  var k = {\n    _namespacePrefix: r,\n    _namespaceRegexp: D,\n    _testStorage: function(G) {\n      try {\n        var U = \"__storejs__test__\";\n        G.write(U, U);\n        var z = G.read(U) === U;\n        return G.remove(U), z;\n      } catch {\n        return !1;\n      }\n    },\n    _assignPluginFnProp: function(G, U) {\n      var z = this[U];\n      this[U] = function() {\n        var V = slice(arguments, 0), Y = this;\n        function q() {\n          if (z)\n            return each$6(arguments, function(K, Z) {\n              V[Z] = K;\n            }), z.apply(Y, V);\n        }\n        var W = [q].concat(V);\n        return G.apply(Y, W);\n      };\n    },\n    _serialize: function(G) {\n      return JSON.stringify(G);\n    },\n    _deserialize: function(G, U) {\n      if (!G)\n        return U;\n      var z = \"\";\n      try {\n        z = JSON.parse(G);\n      } catch {\n        z = G;\n      }\n      return z !== void 0 ? z : U;\n    },\n    _addStorage: function(G) {\n      this.enabled || this._testStorage(G) && (this.storage = G, this.enabled = !0);\n    },\n    _addPlugin: function(G) {\n      var U = this;\n      if (isList(G)) {\n        each$6(G, function(V) {\n          U._addPlugin(V);\n        });\n        return;\n      }\n      var z = pluck(this.plugins, function(V) {\n        return G === V;\n      });\n      if (!z) {\n        if (this.plugins.push(G), !isFunction(G))\n          throw new Error(\"Plugins must be function values that return objects\");\n        var X = G.call(this);\n        if (!isObject(X))\n          throw new Error(\"Plugins must return an object of function properties\");\n        each$6(X, function(V, Y) {\n          if (!isFunction(V))\n            throw new Error(\"Bad plugin property: \" + Y + \" from plugin \" + G.name + \". Plugins should only return functions.\");\n          U._assignPluginFnProp(V, Y);\n        });\n      }\n    },\n    // Put deprecated properties in the private API, so as to not expose it to accidential\n    // discovery through inspection of the store object.\n    // Deprecated: addStorage\n    addStorage: function(G) {\n      _warn(\"store.addStorage(storage) is deprecated. Use createStore([storages])\"), this._addStorage(G);\n    }\n  }, $ = create(k, storeAPI, {\n    plugins: []\n  });\n  return $.raw = {}, each$6($, function(G, U) {\n    isFunction(G) && ($.raw[U] = bind($, G));\n  }), each$6(o, function(G) {\n    $._addStorage(G);\n  }), each$6(t, function(G) {\n    $._addPlugin(G);\n  }), $;\n}\nvar util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {\n  name: \"localStorage\",\n  read: read$5,\n  write: write$5,\n  each: each$5,\n  remove: remove$5,\n  clearAll: clearAll$5\n};\nfunction localStorage() {\n  return Global$4.localStorage;\n}\nfunction read$5(o) {\n  return localStorage().getItem(o);\n}\nfunction write$5(o, t) {\n  return localStorage().setItem(o, t);\n}\nfunction each$5(o) {\n  for (var t = localStorage().length - 1; t >= 0; t--) {\n    var e = localStorage().key(t);\n    o(read$5(e), e);\n  }\n}\nfunction remove$5(o) {\n  return localStorage().removeItem(o);\n}\nfunction clearAll$5() {\n  return localStorage().clear();\n}\nvar util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {\n  name: \"oldFF-globalStorage\",\n  read: read$4,\n  write: write$4,\n  each: each$4,\n  remove: remove$4,\n  clearAll: clearAll$4\n}, globalStorage = Global$3.globalStorage;\nfunction read$4(o) {\n  return globalStorage[o];\n}\nfunction write$4(o, t) {\n  globalStorage[o] = t;\n}\nfunction each$4(o) {\n  for (var t = globalStorage.length - 1; t >= 0; t--) {\n    var e = globalStorage.key(t);\n    o(globalStorage[e], e);\n  }\n}\nfunction remove$4(o) {\n  return globalStorage.removeItem(o);\n}\nfunction clearAll$4() {\n  each$4(function(o, t) {\n    delete globalStorage[o];\n  });\n}\nvar util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {\n  name: \"oldIE-userDataStorage\",\n  write: write$3,\n  read: read$3,\n  each: each$3,\n  remove: remove$3,\n  clearAll: clearAll$3\n}, storageName = \"storejs\", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : \"\").match(/ (MSIE 8|MSIE 9|MSIE 10)\\./);\nfunction write$3(o, t) {\n  if (!disable) {\n    var e = fixKey(o);\n    _withStorageEl(function(r) {\n      r.setAttribute(e, t), r.save(storageName);\n    });\n  }\n}\nfunction read$3(o) {\n  if (!disable) {\n    var t = fixKey(o), e = null;\n    return _withStorageEl(function(r) {\n      e = r.getAttribute(t);\n    }), e;\n  }\n}\nfunction each$3(o) {\n  _withStorageEl(function(t) {\n    for (var e = t.XMLDocument.documentElement.attributes, r = e.length - 1; r >= 0; r--) {\n      var D = e[r];\n      o(t.getAttribute(D.name), D.name);\n    }\n  });\n}\nfunction remove$3(o) {\n  var t = fixKey(o);\n  _withStorageEl(function(e) {\n    e.removeAttribute(t), e.save(storageName);\n  });\n}\nfunction clearAll$3() {\n  _withStorageEl(function(o) {\n    var t = o.XMLDocument.documentElement.attributes;\n    o.load(storageName);\n    for (var e = t.length - 1; e >= 0; e--)\n      o.removeAttribute(t[e].name);\n    o.save(storageName);\n  });\n}\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\");\nfunction fixKey(o) {\n  return o.replace(/^\\d/, \"___$&\").replace(forbiddenCharsRegex, \"___\");\n}\nfunction _makeIEStorageElFunction() {\n  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)\n    return null;\n  var o = \"script\", t, e, r;\n  try {\n    e = new ActiveXObject(\"htmlfile\"), e.open(), e.write(\"<\" + o + \">document.w=window</\" + o + '><iframe src=\"/favicon.ico\"></iframe>'), e.close(), t = e.w.frames[0].document, r = t.createElement(\"div\");\n  } catch {\n    r = doc$1.createElement(\"div\"), t = doc$1.body;\n  }\n  return function(D) {\n    var N = [].slice.call(arguments, 0);\n    N.unshift(r), t.appendChild(r), r.addBehavior(\"#default#userData\"), r.load(storageName), D.apply(this, N), t.removeChild(r);\n  };\n}\nvar util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {\n  name: \"cookieStorage\",\n  read: read$2,\n  write: write$2,\n  each: each$2,\n  remove: remove$2,\n  clearAll: clearAll$2\n}, doc = Global$1.document;\nfunction read$2(o) {\n  if (!o || !_has(o))\n    return null;\n  var t = \"(?:^|.*;\\\\s*)\" + escape(o).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\";\n  return unescape(doc.cookie.replace(new RegExp(t), \"$1\"));\n}\nfunction each$2(o) {\n  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)\n    if (trim(t[e])) {\n      var r = t[e].split(\"=\"), D = unescape(r[0]), N = unescape(r[1]);\n      o(N, D);\n    }\n}\nfunction write$2(o, t) {\n  o && (doc.cookie = escape(o) + \"=\" + escape(t) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\");\n}\nfunction remove$2(o) {\n  !o || !_has(o) || (doc.cookie = escape(o) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\");\n}\nfunction clearAll$2() {\n  each$2(function(o, t) {\n    remove$2(t);\n  });\n}\nfunction _has(o) {\n  return new RegExp(\"(?:^|;\\\\s*)\" + escape(o).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\").test(doc.cookie);\n}\nvar util = util$6, Global = util.Global, sessionStorage_1 = {\n  name: \"sessionStorage\",\n  read: read$1,\n  write: write$1,\n  each: each$1,\n  remove: remove$1,\n  clearAll: clearAll$1\n};\nfunction sessionStorage$1() {\n  return Global.sessionStorage;\n}\nfunction read$1(o) {\n  return sessionStorage$1().getItem(o);\n}\nfunction write$1(o, t) {\n  return sessionStorage$1().setItem(o, t);\n}\nfunction each$1(o) {\n  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {\n    var e = sessionStorage$1().key(t);\n    o(read$1(e), e);\n  }\n}\nfunction remove$1(o) {\n  return sessionStorage$1().removeItem(o);\n}\nfunction clearAll$1() {\n  return sessionStorage$1().clear();\n}\nvar memoryStorage_1 = {\n  name: \"memoryStorage\",\n  read,\n  write,\n  each,\n  remove,\n  clearAll\n}, memoryStorage = {};\nfunction read(o) {\n  return memoryStorage[o];\n}\nfunction write(o, t) {\n  memoryStorage[o] = t;\n}\nfunction each(o) {\n  for (var t in memoryStorage)\n    memoryStorage.hasOwnProperty(t) && o(memoryStorage[t], t);\n}\nfunction remove(o) {\n  delete memoryStorage[o];\n}\nfunction clearAll(o) {\n  memoryStorage = {};\n}\nvar all = [\n  // Listed in order of usage preference\n  localStorage_1,\n  oldFFGlobalStorage,\n  oldIEUserDataStorage,\n  cookieStorage,\n  sessionStorage_1,\n  memoryStorage_1\n], json2$1 = {}, hasRequiredJson2;\nfunction requireJson2() {\n  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != \"object\" && (JSON = {}), function() {\n    var rx_one = /^[\\],:{}\\s]*$/, rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, rx_four = /(?:^|:|,)(?:\\s*\\[)+/g, rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g, rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    function f(o) {\n      return o < 10 ? \"0\" + o : o;\n    }\n    function this_value() {\n      return this.valueOf();\n    }\n    typeof Date.prototype.toJSON != \"function\" && (Date.prototype.toJSON = function() {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);\n    var gap, indent, meta, rep;\n    function quote(o) {\n      return rx_escapable.lastIndex = 0, rx_escapable.test(o) ? '\"' + o.replace(rx_escapable, function(t) {\n        var e = meta[t];\n        return typeof e == \"string\" ? e : \"\\\\u\" + (\"0000\" + t.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + o + '\"';\n    }\n    function str(o, t) {\n      var e, r, D, N, k = gap, $, G = t[o];\n      switch (G && typeof G == \"object\" && typeof G.toJSON == \"function\" && (G = G.toJSON(o)), typeof rep == \"function\" && (G = rep.call(t, o, G)), typeof G) {\n        case \"string\":\n          return quote(G);\n        case \"number\":\n          return isFinite(G) ? String(G) : \"null\";\n        case \"boolean\":\n        case \"null\":\n          return String(G);\n        case \"object\":\n          if (!G)\n            return \"null\";\n          if (gap += indent, $ = [], Object.prototype.toString.apply(G) === \"[object Array]\") {\n            for (N = G.length, e = 0; e < N; e += 1)\n              $[e] = str(e, G) || \"null\";\n            return D = $.length === 0 ? \"[]\" : gap ? `[\n` + gap + $.join(`,\n` + gap) + `\n` + k + \"]\" : \"[\" + $.join(\",\") + \"]\", gap = k, D;\n          }\n          if (rep && typeof rep == \"object\")\n            for (N = rep.length, e = 0; e < N; e += 1)\n              typeof rep[e] == \"string\" && (r = rep[e], D = str(r, G), D && $.push(quote(r) + (gap ? \": \" : \":\") + D));\n          else\n            for (r in G)\n              Object.prototype.hasOwnProperty.call(G, r) && (D = str(r, G), D && $.push(quote(r) + (gap ? \": \" : \":\") + D));\n          return D = $.length === 0 ? \"{}\" : gap ? `{\n` + gap + $.join(`,\n` + gap) + `\n` + k + \"}\" : \"{\" + $.join(\",\") + \"}\", gap = k, D;\n      }\n    }\n    typeof JSON.stringify != \"function\" && (meta = {\n      // table of character substitutions\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    }, JSON.stringify = function(o, t, e) {\n      var r;\n      if (gap = \"\", indent = \"\", typeof e == \"number\")\n        for (r = 0; r < e; r += 1)\n          indent += \" \";\n      else\n        typeof e == \"string\" && (indent = e);\n      if (rep = t, t && typeof t != \"function\" && (typeof t != \"object\" || typeof t.length != \"number\"))\n        throw new Error(\"JSON.stringify\");\n      return str(\"\", { \"\": o });\n    }), typeof JSON.parse != \"function\" && (JSON.parse = function(text, reviver) {\n      var j;\n      function walk(o, t) {\n        var e, r, D = o[t];\n        if (D && typeof D == \"object\")\n          for (e in D)\n            Object.prototype.hasOwnProperty.call(D, e) && (r = walk(D, e), r !== void 0 ? D[e] = r : delete D[e]);\n        return reviver.call(o, t, D);\n      }\n      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(o) {\n        return \"\\\\u\" + (\"0000\" + o.charCodeAt(0).toString(16)).slice(-4);\n      })), rx_one.test(\n        text.replace(rx_two, \"@\").replace(rx_three, \"]\").replace(rx_four, \"\")\n      ))\n        return j = eval(\"(\" + text + \")\"), typeof reviver == \"function\" ? walk({ \"\": j }, \"\") : j;\n      throw new SyntaxError(\"JSON.parse\");\n    });\n  }()), json2$1;\n}\nvar json2 = json2Plugin;\nfunction json2Plugin() {\n  return requireJson2(), {};\n}\nvar engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);\n/*!\ndevtools-detect\nhttps://github.com/sindresorhus/devtools-detect\nBy Sindre Sorhus\nMIT License\n*/\nconst devtools = {\n  isOpen: !1,\n  orientation: void 0\n}, threshold = 170, emitEvent = (o, t) => {\n  globalThis.dispatchEvent(new globalThis.CustomEvent(\"devtoolschange\", {\n    detail: {\n      isOpen: o,\n      orientation: t\n    }\n  }));\n}, main = ({ emitEvents: o = !0 } = {}) => {\n  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, r = t ? \"vertical\" : \"horizontal\";\n  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== r) && o && emitEvent(!0, r), devtools.isOpen = !0, devtools.orientation = r) : (devtools.isOpen && o && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);\n};\nmain({ emitEvents: !1 });\nsetInterval(main, 500);\nvar Ga, Ql, Mi, tu;\nclass SysWeb extends SysBase {\n  constructor(e = {}, r = { cur: \"prj/\", crypto: !1, dip: \"\" }) {\n    super(e, r);\n    rt(this, Ga, \"\");\n    rt(this, Ql, \":\");\n    Ot(this, \"run\", async () => {\n      H(this, Mi) && (H(this, Mi).destroy(10), await new Promise((r) => setTimeout(r, 10))), ot(this, Mi, new Main(this));\n    });\n    rt(this, Mi, void 0);\n    Ot(this, \"pathBaseCnvSnPath4Dbg\", \"${pathbase}/\");\n    // プレイデータをエクスポート\n    Ot(this, \"_export\", () => ((async () => {\n      const e = JSON.stringify({\n        sys: this.data.sys,\n        mark: this.data.mark,\n        kidoku: this.data.kidoku\n      }), r = this.crypto ? await this.enc(e) : e, D = new Blob([r], { type: \"text/json\" }), N = document.createElement(\"a\");\n      N.href = URL.createObjectURL(D), N.download = (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + getDateStr(\"-\", \"_\", \"\") + \".swpd\", N.click(), CmnLib.debugLog && console.log(\"プレイデータをエクスポートしました\"), setTimeout(() => this.fire(\"sn:exported\", new Event(\"click\")), 10);\n    })(), !1));\n    // プレイデータをインポート\n    Ot(this, \"_import\", () => (new Promise((e, r) => {\n      const D = document.createElement(\"input\");\n      D.type = \"file\", D.accept = \".swpd, text/plain\", D.onchange = () => {\n        D.files ? e(D.files[0]) : r();\n      }, D.click();\n    }).then((e) => new Promise((r) => {\n      const D = new FileReader();\n      D.readAsText(e), D.onload = () => r(D.result);\n    })).then(async (e) => {\n      const r = JSON.parse(this.crypto ? this.decStr(\"json\", e) : e);\n      if (!r.sys || !r.mark || !r.kidoku)\n        throw new Error(\"異常なプレイデータです\");\n      if (r.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {\n        console.error(`別のゲーム【プロジェクト名=${r.sys[SysBase.VALNM_CFG_NS]}】のプレイデータです`);\n        return;\n      }\n      this.data.sys = r.sys, this.data.mark = r.mark, this.data.kidoku = r.kidoku, this.flush(), this.val.updateData(r), CmnLib.debugLog && console.log(\"プレイデータをインポートしました\"), this.fire(\"sn:imported\", new Event(\"click\"));\n    }).catch((e) => console.error(`異常なプレイデータです ${e.message}`)), !1));\n    // ＵＲＬを開く\n    Ot(this, \"navigate_to\", (e) => {\n      const { url: r } = e;\n      if (!r)\n        throw \"[navigate_to] urlは必須です\";\n      return globalThis.open(r, \"_blank\"), !1;\n    });\n    rt(this, tu, {});\n    const D = r.cur.split(\"/\");\n    ot(this, Ga, D.length > 2 ? D.slice(0, -2).join(\"/\") + \"/\" : \"\"), globalThis.onload = async () => this.loaded(e, r);\n  }\n  async loaded(e, r) {\n    await super.loaded(e, r), document.querySelectorAll(\"[data-prj]\").forEach(($) => {\n      const G = $.attributes.getNamedItem(\"data-prj\");\n      G && $.addEventListener(\"click\", () => this.runSN(G.value), { passive: !0 });\n    }), document.querySelectorAll(\"[data-reload]\").forEach(\n      ($) => $.addEventListener(\"click\", () => this.run(), { passive: !0 })\n      //this.elc.add(v, 'click', ()=> this.run(), {passive: true})\n      // ギャラリーであっても、ここには一度しか来ないので\n    ), r.dip && (CmnLib.hDip = JSON.parse(r.dip));\n    const D = new URLSearchParams(location.search), N = D.get(\"dip\");\n    if (N && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(N.replaceAll(\"%2C\", \",\")) }), !argChk_Boolean(CmnLib.hDip, \"oninit_run\", !0))\n      return;\n    argChk_Boolean(CmnLib.hDip, \"dbg\", !1) && (CmnLib.isDbg = !0, this.fetch = ($) => fetch($, { mode: \"cors\" })), this.extPort = argChk_Num(CmnLib.hDip, \"port\", this.extPort);\n    const k = D.get(\"cur\");\n    k && (r.cur = H(this, Ga) + k + \"/\"), this.run();\n  }\n  runSN(e) {\n    this.arg.cur = H(this, Ga) + e + \"/\", H(this, Ql) !== this.arg.cur && (ot(this, Ql, this.arg.cur), this.run());\n  }\n  stop() {\n    H(this, Mi) && (H(this, Mi).destroy(), ot(this, Mi, void 0));\n  }\n  async loadPath(e, r) {\n    await super.loadPath(e, r);\n    const D = this.arg.cur + \"path.json\", N = await fetch(D);\n    if (!N.ok)\n      throw Error(N.statusText);\n    const k = await N.text(), $ = JSON.parse(this.decStr(D, k));\n    for (const [G, U] of Object.entries($)) {\n      const z = e[G] = U;\n      for (const [X, V] of Object.entries(z))\n        X !== \":cnt\" && (z[X] = this.arg.cur + V);\n    }\n  }\n  initVal(e, r, D) {\n    const N = encodeURIComponent(document.location.hostname);\n    r[\"const.sn.isDebugger\"] = N === \"localhost\" || N === \"127.0.0.1\";\n    const k = this.cfg.getNs();\n    this.flush = this.crypto ? async () => {\n      store_legacy.set(k + \"sys_\", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(k + \"mark_\", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(k + \"kidoku_\", this.enc(JSON.stringify(this.data.kidoku)));\n    } : () => {\n      store_legacy.set(k + \"sys\", this.data.sys), store_legacy.set(k + \"mark\", this.data.mark), store_legacy.set(k + \"kidoku\", this.data.kidoku);\n    };\n    const $ = k + (this.arg.crypto ? \"sys_\" : \"sys\");\n    if (r[\"const.sn.isFirstBoot\"] = store_legacy.get($) === void 0) {\n      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), D(this.data);\n      return;\n    }\n    if (!this.crypto) {\n      this.data.sys = store_legacy.get(k + \"sys\"), this.data.mark = store_legacy.get(k + \"mark\"), this.data.kidoku = store_legacy.get(k + \"kidoku\"), D(this.data);\n      return;\n    }\n    let G = \"\";\n    try {\n      G = \"sys\", this.data.sys = JSON.parse(this.decStr(\"json\", store_legacy.get(k + \"sys_\"))), G += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), G = \"mark\", this.data.mark = JSON.parse(this.decStr(\"json\", store_legacy.get(k + \"mark_\"))), G = \"kidoku\", this.data.kidoku = JSON.parse(this.decStr(\"json\", store_legacy.get(k + \"kidoku_\")));\n    } catch (U) {\n      console.error(`セーブデータ（${G}）が壊れています。一度クリアする必要があります %o`, U);\n    }\n    D(this.data);\n  }\n  init(e, r, D, N) {\n    super.init(e, r, D, N);\n    const k = r.view.parentElement;\n    if (\"requestFullscreen\" in document.body)\n      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : k.requestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = !!document.fullscreenElement);\n    else {\n      const $ = document;\n      this.tglFlscr_sub = () => this.isFullScr ? $.webkitCancelFullScreen() : k.webkitRequestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = !!$.webkitFullscreenElement);\n    }\n    return this.cfg.oCfg.debug.devtool || this.elc.add(window, \"devtoolschange\", ($) => {\n      $.detail.isOpen && (console.error(\"DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。\"), N.destroy());\n    }, { once: !0, passive: !0 }), [];\n  }\n  cvsResize() {\n    if (super.cvsResize(), this.isFullScr) {\n      const e = Main.cvs.style;\n      e.width = e.height = \"\";\n    }\n  }\n  // タイトル指定\n  titleSub(e) {\n    document.title = e, document.querySelectorAll(\"[data-title]\").forEach((r) => r.textContent = e);\n  }\n  async savePic(e, r) {\n    const D = document.createElement(\"a\");\n    D.href = r, D.download = e, D.click(), CmnLib.debugLog && console.log(\"画像ファイルをダウンロードします\");\n  }\n  async appendFile(e, r, D) {\n    const N = (H(this, tu)[e] ?? \"\") + r;\n    H(this, tu)[e] = N;\n    const k = new Blob([N], { type: \"text/json\" }), $ = document.createElement(\"a\");\n    $.href = URL.createObjectURL(k), $.download = e, $.click();\n  }\n}\nGa = new WeakMap(), Ql = new WeakMap(), Mi = new WeakMap(), tu = new WeakMap();\n\n//# sourceMappingURL=web.js.map\n\n\n//# sourceURL=webpack://gallery/./node_modules/@famibee/skynovel/dist/web.js?");

/***/ })

}]);