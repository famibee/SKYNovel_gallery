"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel"],{

/***/ "./node_modules/@famibee/skynovel/dist/web.js":
/*!****************************************************!*\
  !*** ./node_modules/@famibee/skynovel/dist/web.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ CmnLib),\n/* harmony export */   \"Layer\": () => (/* binding */ Layer),\n/* harmony export */   \"SysWeb\": () => (/* binding */ SysWeb),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ argChk_Boolean),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ argChk_Num)\n/* harmony export */ });\nvar Ql = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n};\nvar H = (n, t, e) => (Ql(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), it = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, et = (n, t, e, o) => (Ql(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), Re = (n, t, e, o) => ({\n  set _(R) {\n    et(n, t, R, e);\n  },\n  get _() {\n    return H(n, t, o);\n  }\n}), at = (n, t, e) => (Ql(n, t, \"access private method\"), e);\nvar commonjsGlobal$1 = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {}, platform$1 = { exports: {} };\n/*!\n * Platform.js v1.3.6\n * Copyright 2014-2020 Benjamin Tan\n * Copyright 2011-2013 John-David Dalton\n * Available under MIT license\n */\n(function(n, t) {\n  (function() {\n    var e = {\n      function: !0,\n      object: !0\n    }, o = e[typeof window] && window || this, R = t, N = n && !n.nodeType && n, M = R && N && typeof commonjsGlobal$1 == \"object\" && commonjsGlobal$1;\n    M && (M.global === M || M.window === M || M.self === M) && (o = M);\n    var D = Math.pow(2, 53) - 1, L = /\\bOpera/, B = Object.prototype, $ = B.hasOwnProperty, k = B.toString;\n    function U(tt) {\n      return tt = String(tt), tt.charAt(0).toUpperCase() + tt.slice(1);\n    }\n    function z(tt, nt, st) {\n      var ut = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      return nt && st && /^Win/i.test(tt) && !/^Windows Phone /i.test(tt) && (ut = ut[/[\\d.]+$/.exec(tt)]) && (tt = \"Windows \" + ut), tt = String(tt), nt && st && (tt = tt.replace(RegExp(nt, \"i\"), st)), tt = V(\n        tt.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]\n      ), tt;\n    }\n    function X(tt, nt) {\n      var st = -1, ut = tt ? tt.length : 0;\n      if (typeof ut == \"number\" && ut > -1 && ut <= D)\n        for (; ++st < ut; )\n          nt(tt[st], st, tt);\n      else\n        W(tt, nt);\n    }\n    function V(tt) {\n      return tt = Q(tt), /^(?:webOS|i(?:OS|P))/.test(tt) ? tt : U(tt);\n    }\n    function W(tt, nt) {\n      for (var st in tt)\n        $.call(tt, st) && nt(tt[st], st, tt);\n    }\n    function Y(tt) {\n      return tt == null ? U(tt) : k.call(tt).slice(8, -1);\n    }\n    function q(tt, nt) {\n      var st = tt != null ? typeof tt[nt] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(st) && (st == \"object\" ? !!tt[nt] : !0);\n    }\n    function Z(tt) {\n      return String(tt).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function K(tt, nt) {\n      var st = null;\n      return X(tt, function(ut, ct) {\n        st = nt(st, ut, ct, tt);\n      }), st;\n    }\n    function Q(tt) {\n      return String(tt).replace(/^ +| +$/g, \"\");\n    }\n    function J(tt) {\n      var nt = o, st = tt && typeof tt == \"object\" && Y(tt) != \"String\";\n      st && (nt = tt, tt = null);\n      var ut = nt.navigator || {}, ct = ut.userAgent || \"\";\n      tt || (tt = ct);\n      var dt = st ? !!ut.likeChrome : /\\bChrome\\b/.test(tt) && !/internal|\\n/i.test(k.toString()), Et = \"Object\", vt = st ? Et : \"ScriptBridgingProxyObject\", _t = st ? Et : \"Environment\", St = st && nt.java ? \"JavaPackage\" : Y(nt.java), Ft = st ? Et : \"RuntimeObject\", mt = /\\bJava/.test(St) && nt.java, ht = mt && Y(nt.environment) == _t, pt = mt ? \"a\" : \"\\u03B1\", xt = mt ? \"b\" : \"\\u03B2\", At = nt.document || {}, Rt = nt.operamini || nt.opera, Lt = L.test(Lt = st && Rt ? Rt[\"[[Class]]\"] : Y(Rt)) ? Lt : Rt = null, lt, $t = tt, Pt = [], kt = null, Ot = tt == ct, gt = Ot && Rt && typeof Rt.version == \"function\" && Rt.version(), Gt, Tt = Zt([\n        { label: \"EdgeHTML\", pattern: \"Edge\" },\n        \"Trident\",\n        { label: \"WebKit\", pattern: \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]), bt = se([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { label: \"Microsoft Edge\", pattern: \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { label: \"Samsung Internet\", pattern: \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { label: \"Silk\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { label: \"SRWare Iron\", pattern: \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { label: \"Yandex Browser\", pattern: \"YaBrowser\" },\n        { label: \"UC Browser\", pattern: \"UCBrowser\" },\n        \"Opera Mini\",\n        { label: \"Opera Mini\", pattern: \"OPiOS\" },\n        \"Opera\",\n        { label: \"Opera\", pattern: \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { label: \"Chrome\", pattern: \"(?:HeadlessChrome)\" },\n        { label: \"Chrome Mobile\", pattern: \"(?:CriOS|CrMo)\" },\n        { label: \"Firefox\", pattern: \"(?:Firefox|Minefield)\" },\n        { label: \"Firefox for iOS\", pattern: \"FxiOS\" },\n        { label: \"IE\", pattern: \"IEMobile\" },\n        { label: \"IE\", pattern: \"MSIE\" },\n        \"Safari\"\n      ]), wt = Te([\n        { label: \"BlackBerry\", pattern: \"BB10\" },\n        \"BlackBerry\",\n        { label: \"Galaxy S\", pattern: \"GT-I9000\" },\n        { label: \"Galaxy S2\", pattern: \"GT-I9100\" },\n        { label: \"Galaxy S3\", pattern: \"GT-I9300\" },\n        { label: \"Galaxy S4\", pattern: \"GT-I9500\" },\n        { label: \"Galaxy S5\", pattern: \"SM-G900\" },\n        { label: \"Galaxy S6\", pattern: \"SM-G920\" },\n        { label: \"Galaxy S6 Edge\", pattern: \"SM-G925\" },\n        { label: \"Galaxy S7\", pattern: \"SM-G930\" },\n        { label: \"Galaxy S7 Edge\", pattern: \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { label: \"Kindle Fire\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { label: \"Wii U\", pattern: \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { label: \"Xbox 360\", pattern: \"Xbox\" },\n        \"Xoom\"\n      ]), Mt = Yt({\n        Apple: { iPad: 1, iPhone: 1, iPod: 1 },\n        Alcatel: {},\n        Archos: {},\n        Amazon: { Kindle: 1, \"Kindle Fire\": 1 },\n        Asus: { Transformer: 1 },\n        \"Barnes & Noble\": { Nook: 1 },\n        BlackBerry: { PlayBook: 1 },\n        Google: { \"Google TV\": 1, Nexus: 1 },\n        HP: { TouchPad: 1 },\n        HTC: {},\n        Huawei: {},\n        Lenovo: {},\n        LG: {},\n        Microsoft: { Xbox: 1, \"Xbox One\": 1 },\n        Motorola: { Xoom: 1 },\n        Nintendo: { \"Wii U\": 1, Wii: 1 },\n        Nokia: { Lumia: 1 },\n        Oppo: {},\n        Samsung: { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        Sony: { PlayStation: 1, \"PlayStation Vita\": 1 },\n        Xiaomi: { Mi: 1, Redmi: 1 }\n      }), Ct = ie([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { label: \"Chrome OS\", pattern: \"CrOS\" },\n        \"Debian\",\n        { label: \"DragonFly BSD\", pattern: \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function Zt(de) {\n        return K(de, function(ae, Jt) {\n          return ae || RegExp(\"\\\\b\" + (Jt.pattern || Z(Jt)) + \"\\\\b\", \"i\").exec(tt) && (Jt.label || Jt);\n        });\n      }\n      function Yt(de) {\n        return K(de, function(ae, Jt, Pe) {\n          return ae || (Jt[wt] || Jt[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(wt)] || RegExp(\"\\\\b\" + Z(Pe) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(tt)) && Pe;\n        });\n      }\n      function se(de) {\n        return K(de, function(ae, Jt) {\n          return ae || RegExp(\"\\\\b\" + (Jt.pattern || Z(Jt)) + \"\\\\b\", \"i\").exec(tt) && (Jt.label || Jt);\n        });\n      }\n      function ie(de) {\n        return K(de, function(ae, Jt) {\n          var Pe = Jt.pattern || Z(Jt);\n          return !ae && (ae = RegExp(\"\\\\b\" + Pe + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(tt)) && (ae = z(ae, Pe, Jt.label || Jt)), ae;\n        });\n      }\n      function Te(de) {\n        return K(de, function(ae, Jt) {\n          var Pe = Jt.pattern || Z(Jt);\n          return !ae && (ae = RegExp(\"\\\\b\" + Pe + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(tt) || RegExp(\"\\\\b\" + Pe + \" *\\\\w+-[\\\\w]*\", \"i\").exec(tt) || RegExp(\"\\\\b\" + Pe + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(tt)) && ((ae = String(Jt.label && !RegExp(Pe, \"i\").test(Jt.label) ? Jt.label : ae).split(\"/\"))[1] && !/[\\d.]+/.test(ae[0]) && (ae[0] += \" \" + ae[1]), Jt = Jt.label || Jt, ae = V(ae[0].replace(RegExp(Pe, \"i\"), Jt).replace(RegExp(\"; *(?:\" + Jt + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + Jt + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"))), ae;\n        });\n      }\n      function ge(de) {\n        return K(de, function(ae, Jt) {\n          return ae || (RegExp(Jt + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(tt) || 0)[1] || null;\n        });\n      }\n      function Fe() {\n        return this.description || \"\";\n      }\n      if (Tt && (Tt = [Tt]), /\\bAndroid\\b/.test(Ct) && !wt && (lt = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(tt)) && (wt = Q(lt[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null), Mt && !wt ? wt = Te([Mt]) : Mt && wt && (wt = wt.replace(RegExp(\"^(\" + Z(Mt) + \")[-_.\\\\s]\", \"i\"), Mt + \" \").replace(RegExp(\"^(\" + Z(Mt) + \")[-_.]?(\\\\w)\", \"i\"), Mt + \" $2\")), (lt = /\\bGoogle TV\\b/.exec(wt)) && (wt = lt[0]), /\\bSimulator\\b/i.test(tt) && (wt = (wt ? wt + \" \" : \"\") + \"Simulator\"), bt == \"Opera Mini\" && /\\bOPiOS\\b/.test(tt) && Pt.push(\"running in Turbo/Uncompressed mode\"), bt == \"IE\" && /\\blike iPhone OS\\b/.test(tt) ? (lt = J(tt.replace(/like iPhone OS/, \"\")), Mt = lt.manufacturer, wt = lt.product) : /^iP/.test(wt) ? (bt || (bt = \"Safari\"), Ct = \"iOS\" + ((lt = / OS ([\\d_]+)/i.exec(tt)) ? \" \" + lt[1].replace(/_/g, \".\") : \"\")) : bt == \"Konqueror\" && /^Linux\\b/i.test(Ct) ? Ct = \"Kubuntu\" : Mt && Mt != \"Google\" && (/Chrome/.test(bt) && !/\\bMobile Safari\\b/i.test(tt) || /\\bVita\\b/.test(wt)) || /\\bAndroid\\b/.test(Ct) && /^Chrome/.test(bt) && /\\bVersion\\//i.test(tt) ? (bt = \"Android Browser\", Ct = /\\bAndroid\\b/.test(Ct) ? Ct : \"Android\") : bt == \"Silk\" ? (/\\bMobi/i.test(tt) || (Ct = \"Android\", Pt.unshift(\"desktop mode\")), /Accelerated *= *true/i.test(tt) && Pt.unshift(\"accelerated\")) : bt == \"UC Browser\" && /\\bUCWEB\\b/.test(tt) ? Pt.push(\"speed mode\") : bt == \"PaleMoon\" && (lt = /\\bFirefox\\/([\\d.]+)\\b/.exec(tt)) ? Pt.push(\"identifying as Firefox \" + lt[1]) : bt == \"Firefox\" && (lt = /\\b(Mobile|Tablet|TV)\\b/i.exec(tt)) ? (Ct || (Ct = \"Firefox OS\"), wt || (wt = lt[1])) : !bt || (lt = !/\\bMinefield\\b/i.test(tt) && /\\b(?:Firefox|Safari)\\b/.exec(bt)) ? (bt && !wt && /[\\/,]|^[^(]+?\\)/.test(tt.slice(tt.indexOf(lt + \"/\") + 8)) && (bt = null), (lt = wt || Mt || Ct) && (wt || Mt || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(Ct)) && (bt = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(Ct) ? Ct : lt) + \" Browser\")) : bt == \"Electron\" && (lt = (/\\bChrome\\/([\\d.]+)\\b/.exec(tt) || 0)[1]) && Pt.push(\"Chromium \" + lt), gt || (gt = ge([\n        \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n        \"Version\",\n        Z(bt),\n        \"(?:Firefox|Minefield|NetFront)\"\n      ])), (lt = Tt == \"iCab\" && parseFloat(gt) > 3 && \"WebKit\" || /\\bOpera\\b/.test(bt) && (/\\bOPR\\b/.test(tt) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(tt) && !/^(?:Trident|EdgeHTML)$/.test(Tt) && \"WebKit\" || !Tt && /\\bMSIE\\b/i.test(tt) && (Ct == \"Mac OS\" ? \"Tasman\" : \"Trident\") || Tt == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(bt) && \"NetFront\") && (Tt = [lt]), bt == \"IE\" && (lt = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(tt) || 0)[1]) ? (bt += \" Mobile\", Ct = \"Windows Phone \" + (/\\+$/.test(lt) ? lt : lt + \".x\"), Pt.unshift(\"desktop mode\")) : /\\bWPDesktop\\b/i.test(tt) ? (bt = \"IE Mobile\", Ct = \"Windows Phone 8.x\", Pt.unshift(\"desktop mode\"), gt || (gt = (/\\brv:([\\d.]+)/.exec(tt) || 0)[1])) : bt != \"IE\" && Tt == \"Trident\" && (lt = /\\brv:([\\d.]+)/.exec(tt)) && (bt && Pt.push(\"identifying as \" + bt + (gt ? \" \" + gt : \"\")), bt = \"IE\", gt = lt[1]), Ot) {\n        if (q(nt, \"global\"))\n          if (mt && (lt = mt.lang.System, $t = lt.getProperty(\"os.arch\"), Ct = Ct || lt.getProperty(\"os.name\") + \" \" + lt.getProperty(\"os.version\")), ht) {\n            try {\n              gt = nt.require(\"ringo/engine\").version.join(\".\"), bt = \"RingoJS\";\n            } catch {\n              (lt = nt.system) && lt.global.system == nt.system && (bt = \"Narwhal\", Ct || (Ct = lt[0].os || null));\n            }\n            bt || (bt = \"Rhino\");\n          } else\n            typeof nt.process == \"object\" && !nt.process.browser && (lt = nt.process) && (typeof lt.versions == \"object\" && (typeof lt.versions.electron == \"string\" ? (Pt.push(\"Node \" + lt.versions.node), bt = \"Electron\", gt = lt.versions.electron) : typeof lt.versions.nw == \"string\" && (Pt.push(\"Chromium \" + gt, \"Node \" + lt.versions.node), bt = \"NW.js\", gt = lt.versions.nw)), bt || (bt = \"Node.js\", $t = lt.arch, Ct = lt.platform, gt = /[\\d.]+/.exec(lt.version), gt = gt ? gt[0] : null));\n        else\n          Y(lt = nt.runtime) == vt ? (bt = \"Adobe AIR\", Ct = lt.flash.system.Capabilities.os) : Y(lt = nt.phantom) == Ft ? (bt = \"PhantomJS\", gt = (lt = lt.version || null) && lt.major + \".\" + lt.minor + \".\" + lt.patch) : typeof At.documentMode == \"number\" && (lt = /\\bTrident\\/(\\d+)/i.exec(tt)) ? (gt = [gt, At.documentMode], (lt = +lt[1] + 4) != gt[1] && (Pt.push(\"IE \" + gt[1] + \" mode\"), Tt && (Tt[1] = \"\"), gt[1] = lt), gt = bt == \"IE\" ? String(gt[1].toFixed(1)) : gt[0]) : typeof At.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(bt) && (Pt.push(\"masking as \" + bt + \" \" + gt), bt = \"IE\", gt = \"11.0\", Tt = [\"Trident\"], Ct = \"Windows\");\n        Ct = Ct && V(Ct);\n      }\n      if (gt && (lt = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(gt) || /(?:alpha|beta)(?: ?\\d)?/i.exec(tt + \";\" + (Ot && ut.appMinorVersion)) || /\\bMinefield\\b/i.test(tt) && \"a\") && (kt = /b/i.test(lt) ? \"beta\" : \"alpha\", gt = gt.replace(RegExp(lt + \"\\\\+?$\"), \"\") + (kt == \"beta\" ? xt : pt) + (/\\d+\\+?/.exec(lt) || \"\")), bt == \"Fennec\" || bt == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(Ct))\n        bt = \"Firefox Mobile\";\n      else if (bt == \"Maxthon\" && gt)\n        gt = gt.replace(/\\.[\\d.]+/, \".x\");\n      else if (/\\bXbox\\b/i.test(wt))\n        wt == \"Xbox 360\" && (Ct = null), wt == \"Xbox 360\" && /\\bIEMobile\\b/.test(tt) && Pt.unshift(\"mobile mode\");\n      else if ((/^(?:Chrome|IE|Opera)$/.test(bt) || bt && !wt && !/Browser|Mobi/.test(bt)) && (Ct == \"Windows CE\" || /Mobi/i.test(tt)))\n        bt += \" Mobile\";\n      else if (bt == \"IE\" && Ot)\n        try {\n          nt.external === null && Pt.unshift(\"platform preview\");\n        } catch {\n          Pt.unshift(\"embedded\");\n        }\n      else\n        (/\\bBlackBerry\\b/.test(wt) || /\\bBB10\\b/.test(tt)) && (lt = (RegExp(wt.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(tt) || 0)[1] || gt) ? (lt = [lt, /BB10/.test(tt)], Ct = (lt[1] ? (wt = null, Mt = \"BlackBerry\") : \"Device Software\") + \" \" + lt[0], gt = null) : this != W && wt != \"Wii\" && (Ot && Rt || /Opera/.test(bt) && /\\b(?:MSIE|Firefox)\\b/i.test(tt) || bt == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(Ct) || bt == \"IE\" && (Ct && !/^Win/.test(Ct) && gt > 5.5 || /\\bWindows XP\\b/.test(Ct) && gt > 8 || gt == 8 && !/\\bTrident\\b/.test(tt))) && !L.test(lt = J.call(W, tt.replace(L, \"\") + \";\")) && lt.name && (lt = \"ing as \" + lt.name + ((lt = lt.version) ? \" \" + lt : \"\"), L.test(bt) ? (/\\bIE\\b/.test(lt) && Ct == \"Mac OS\" && (Ct = null), lt = \"identify\" + lt) : (lt = \"mask\" + lt, Lt ? bt = V(Lt.replace(/([a-z])([A-Z])/g, \"$1 $2\")) : bt = \"Opera\", /\\bIE\\b/.test(lt) && (Ct = null), Ot || (gt = null)), Tt = [\"Presto\"], Pt.push(lt));\n      (lt = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(tt) || 0)[1]) && (lt = [parseFloat(lt.replace(/\\.(\\d)$/, \".0$1\")), lt], bt == \"Safari\" && lt[1].slice(-1) == \"+\" ? (bt = \"WebKit Nightly\", kt = \"alpha\", gt = lt[1].slice(0, -1)) : (gt == lt[1] || gt == (lt[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(tt) || 0)[1])) && (gt = null), lt[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(tt) || 0)[1], lt[0] == 537.36 && lt[2] == 537.36 && parseFloat(lt[1]) >= 28 && Tt == \"WebKit\" && (Tt = [\"Blink\"]), !Ot || !dt && !lt[1] ? (Tt && (Tt[1] = \"like Safari\"), lt = (lt = lt[0], lt < 400 ? 1 : lt < 500 ? 2 : lt < 526 ? 3 : lt < 533 ? 4 : lt < 534 ? \"4+\" : lt < 535 ? 5 : lt < 537 ? 6 : lt < 538 ? 7 : lt < 601 ? 8 : lt < 602 ? 9 : lt < 604 ? 10 : lt < 606 ? 11 : lt < 608 ? 12 : \"12\")) : (Tt && (Tt[1] = \"like Chrome\"), lt = lt[1] || (lt = lt[0], lt < 530 ? 1 : lt < 532 ? 2 : lt < 532.05 ? 3 : lt < 533 ? 4 : lt < 534.03 ? 5 : lt < 534.07 ? 6 : lt < 534.1 ? 7 : lt < 534.13 ? 8 : lt < 534.16 ? 9 : lt < 534.24 ? 10 : lt < 534.3 ? 11 : lt < 535.01 ? 12 : lt < 535.02 ? \"13+\" : lt < 535.07 ? 15 : lt < 535.11 ? 16 : lt < 535.19 ? 17 : lt < 536.05 ? 18 : lt < 536.1 ? 19 : lt < 537.01 ? 20 : lt < 537.11 ? \"21+\" : lt < 537.13 ? 23 : lt < 537.18 ? 24 : lt < 537.24 ? 25 : lt < 537.36 ? 26 : Tt != \"Blink\" ? \"27\" : \"28\")), Tt && (Tt[1] += \" \" + (lt += typeof lt == \"number\" ? \".x\" : /[.+]/.test(lt) ? \"\" : \"+\")), bt == \"Safari\" && (!gt || parseInt(gt) > 45) ? gt = lt : bt == \"Chrome\" && /\\bHeadlessChrome/i.test(tt) && Pt.unshift(\"headless\")), bt == \"Opera\" && (lt = /\\bzbov|zvav$/.exec(Ct)) ? (bt += \" \", Pt.unshift(\"desktop mode\"), lt == \"zvav\" ? (bt += \"Mini\", gt = null) : bt += \"Mobile\", Ct = Ct.replace(RegExp(\" *\" + lt + \"$\"), \"\")) : bt == \"Safari\" && /\\bChrome\\b/.exec(Tt && Tt[1]) ? (Pt.unshift(\"desktop mode\"), bt = \"Chrome Mobile\", gt = null, /\\bOS X\\b/.test(Ct) ? (Mt = \"Apple\", Ct = \"iOS 4.3+\") : Ct = null) : /\\bSRWare Iron\\b/.test(bt) && !gt && (gt = ge(\"Chrome\")), gt && gt.indexOf(lt = /[\\d.]+$/.exec(Ct)) == 0 && tt.indexOf(\"/\" + lt + \"-\") > -1 && (Ct = Q(Ct.replace(lt, \"\"))), Ct && Ct.indexOf(bt) != -1 && !RegExp(bt + \" OS\").test(Ct) && (Ct = Ct.replace(RegExp(\" *\" + Z(bt) + \" *\"), \"\")), Tt && !/\\b(?:Avant|Nook)\\b/.test(bt) && (/Browser|Lunascape|Maxthon/.test(bt) || bt != \"Safari\" && /^iOS/.test(Ct) && /\\bSafari\\b/.test(Tt[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(bt) && Tt[1]) && (lt = Tt[Tt.length - 1]) && Pt.push(lt), Pt.length && (Pt = [\"(\" + Pt.join(\"; \") + \")\"]), Mt && wt && wt.indexOf(Mt) < 0 && Pt.push(\"on \" + Mt), wt && Pt.push((/^on /.test(Pt[Pt.length - 1]) ? \"\" : \"on \") + wt), Ct && (lt = / ([\\d.+]+)$/.exec(Ct), Gt = lt && Ct.charAt(Ct.length - lt[0].length - 1) == \"/\", Ct = {\n        architecture: 32,\n        family: lt && !Gt ? Ct.replace(lt[0], \"\") : Ct,\n        version: lt ? lt[1] : null,\n        toString: function() {\n          var de = this.version;\n          return this.family + (de && !Gt ? \" \" + de : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n        }\n      }), (lt = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec($t)) && !/\\bi686\\b/i.test($t) ? (Ct && (Ct.architecture = 64, Ct.family = Ct.family.replace(RegExp(\" *\" + lt), \"\")), bt && (/\\bWOW64\\b/i.test(tt) || Ot && /\\w(?:86|32)$/.test(ut.cpuClass || ut.platform) && !/\\bWin64; x64\\b/i.test(tt)) && Pt.unshift(\"32-bit\")) : Ct && /^OS X/.test(Ct.family) && bt == \"Chrome\" && parseFloat(gt) >= 39 && (Ct.architecture = 64), tt || (tt = null);\n      var xe = {};\n      return xe.description = tt, xe.layout = Tt && Tt[0], xe.manufacturer = Mt, xe.name = bt, xe.prerelease = kt, xe.product = wt, xe.ua = tt, xe.version = bt && gt, xe.os = Ct || {\n        architecture: null,\n        family: null,\n        version: null,\n        toString: function() {\n          return \"null\";\n        }\n      }, xe.parse = J, xe.toString = Fe, xe.version && Pt.unshift(gt), xe.name && Pt.unshift(bt), Ct && bt && !(Ct == String(Ct).split(\" \")[0] && (Ct == bt.split(\" \")[0] || wt)) && Pt.push(wt ? \"(\" + Ct + \")\" : \"on \" + Ct), Pt.length && (xe.description = Pt.join(\" \")), xe;\n    }\n    var rt = J();\n    R && N ? W(rt, function(tt, nt) {\n      R[nt] = tt;\n    }) : o.platform = rt;\n  }).call(commonjsGlobal$1);\n})(platform$1, platform$1.exports);\nconst platform = platform$1.exports;\nfunction int(n) {\n  return parseInt(String(n), 10);\n}\nfunction uint(n) {\n  const t = parseInt(String(n), 10);\n  return t < 0 ? -t : t;\n}\n\"toInt\" in String.prototype || (String.prototype.toInt = function() {\n  return int(this);\n});\n\"toUint\" in String.prototype || (String.prototype.toUint = function() {\n  const n = int(this);\n  return n < 0 ? -n : n;\n});\nfunction getDateStr(n = \"/\", t = \" \", e = \":\", o = \"\") {\n  const R = new Date();\n  return R.getFullYear() + n + String(100 + R.getMonth() + 1).slice(1, 3) + n + String(100 + R.getDate()).slice(1, 3) + t + String(100 + R.getHours()).slice(1, 3) + e + String(100 + R.getMinutes()).slice(1, 3) + (o === \"\" ? \"\" : o + String(R.getMilliseconds()));\n}\nconst hMemberCnt = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction cnvTweenArg(n, t) {\n  const e = {};\n  for (const o in hMemberCnt) {\n    if (!(o in n))\n      continue;\n    const R = String(n[o]), N = (R.charAt(0) === \"=\" ? R.slice(1) : R).split(\",\"), M = e[o] = parseFloat(N[0]);\n    N.length > 1 && (e[o] += Math.round(Math.random() * (parseFloat(N[1]) - M + 1))), R.charAt(0) === \"=\" && (e[o] += parseFloat(t[o]));\n  }\n  return e;\n}\nconst css_key4del = \"/* SKYNovel */\";\nfunction initStyle() {\n  const n = document.getElementsByTagName(\"head\")[0], t = n.children.length;\n  for (let e = t - 1; e >= 0; --e) {\n    const o = n.children[e];\n    o instanceof HTMLStyleElement && o.innerText.slice(0, 14) === css_key4del && n.removeChild(o);\n  }\n}\nfunction addStyle(n) {\n  const t = document.createElement(\"style\");\n  t.innerHTML = css_key4del + n, document.getElementsByTagName(\"head\")[0].appendChild(t);\n}\nfunction argChk_Num(n, t, e) {\n  const o = n[t];\n  if (!(t in n)) {\n    if (isNaN(e))\n      throw `[${n[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${t} \\u306F\\u5FC5\\u9808\\u3067\\u3059`;\n    return n[t] = e, e;\n  }\n  const R = String(o).slice(0, 2) === \"0x\" ? parseInt(o) : parseFloat(o);\n  if (isNaN(R))\n    throw `[${n[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${t} \\u306E\\u5024\\u3010${o}\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  return n[t] = R;\n}\nfunction argChk_Boolean(n, t, e) {\n  if (!(t in n))\n    return n[t] = e;\n  const o = n[t];\n  if (o === null)\n    return !1;\n  const R = String(o);\n  return n[t] = R === \"false\" ? !1 : Boolean(R);\n}\nfunction parseColor(n) {\n  if (n.charAt(0) === \"#\")\n    return parseInt(n.slice(1), 16);\n  const t = Number(n);\n  if (!isNaN(t))\n    return t;\n  if (n === \"black\")\n    return 0;\n  CmnLib.cc4ColorName.fillStyle = n;\n  const e = CmnLib.cc4ColorName.fillStyle;\n  if (e === \"#000000\")\n    throw `\\u8272\\u540D\\u524D ${n} \\u304C\\u7570\\u5E38\\u3067\\u3059`;\n  return parseInt(e.slice(1), 16);\n}\nfunction argChk_Color(n, t, e) {\n  const o = n[t];\n  return o ? n[t] = parseColor(String(o)) : n[t] = e;\n}\nconst REG_ERRMES_JSON = /JSON at position (\\d+)$/;\nfunction mesErrJSON(n, t = \"\", e = \"\") {\n  var R;\n  const o = ((R = e.match(REG_ERRMES_JSON)) != null ? R : [\"\", \"\"])[1];\n  return `[${n[\":\\u30BF\\u30B0\\u540D\"]}] ${t} \\u5C5E\\u6027\\u306E\\u89E3\\u6790\\u30A8\\u30E9\\u30FC : ${e}\n${n[t]}${o ? `\n${\"^\".padStart(Number(o))}` : \"\"}`;\n}\nconst REG_FN = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction getFn(n) {\n  var t;\n  return ((t = n.match(REG_FN)) != null ? t : [\"\"])[0];\n}\nconst REG_EXT = /\\.([^\\.]+)$/;\nfunction getExt(n) {\n  var t;\n  return ((t = n.match(REG_EXT)) != null ? t : [\"\", \"\"])[1];\n}\nclass CmnLib {\n}\nCmnLib.stageW = 0;\nCmnLib.stageH = 0;\nCmnLib.debugLog = !1;\nCmnLib.isSafari = platform$1.exports.name === \"Safari\";\nCmnLib.isFirefox = platform$1.exports.name === \"Firefox\";\nvar Fh, Bh;\nCmnLib.isMac = new RegExp(\"OS X\").test((Bh = (Fh = platform$1.exports.os) == null ? void 0 : Fh.family) != null ? Bh : \"\");\nvar $h, kh;\nCmnLib.isMobile = !new RegExp(\"(Windows|OS X)\").test((kh = ($h = platform$1.exports.os) == null ? void 0 : $h.family) != null ? kh : \"\");\nCmnLib.hDip = {};\nCmnLib.isDbg = !1;\nCmnLib.isPackaged = !1;\nCmnLib.isDarkMode = !1;\nconst PACKET_TYPES = /* @__PURE__ */ Object.create(null);\nPACKET_TYPES.open = \"0\";\nPACKET_TYPES.close = \"1\";\nPACKET_TYPES.ping = \"2\";\nPACKET_TYPES.pong = \"3\";\nPACKET_TYPES.message = \"4\";\nPACKET_TYPES.upgrade = \"5\";\nPACKET_TYPES.noop = \"6\";\nconst PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\nObject.keys(PACKET_TYPES).forEach((n) => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[n]] = n;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" }, withNativeBlob$1 = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", withNativeArrayBuffer$2 = typeof ArrayBuffer == \"function\", isView$1 = (n) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, encodePacket = ({ type: n, data: t }, e, o) => withNativeBlob$1 && t instanceof Blob ? e ? o(t) : encodeBlobAsBase64(t, o) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? o(t) : encodeBlobAsBase64(new Blob([t]), o) : o(PACKET_TYPES[n] + (t || \"\")), encodeBlobAsBase64 = (n, t) => {\n  const e = new FileReader();\n  return e.onload = function() {\n    const o = e.result.split(\",\")[1];\n    t(\"b\" + o);\n  }, e.readAsDataURL(n);\n}, chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", lookup$1 = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let n = 0; n < chars.length; n++)\n  lookup$1[chars.charCodeAt(n)] = n;\nconst decode$3 = (n) => {\n  let t = n.length * 0.75, e = n.length, o, R = 0, N, M, D, L;\n  n[n.length - 1] === \"=\" && (t--, n[n.length - 2] === \"=\" && t--);\n  const B = new ArrayBuffer(t), $ = new Uint8Array(B);\n  for (o = 0; o < e; o += 4)\n    N = lookup$1[n.charCodeAt(o)], M = lookup$1[n.charCodeAt(o + 1)], D = lookup$1[n.charCodeAt(o + 2)], L = lookup$1[n.charCodeAt(o + 3)], $[R++] = N << 2 | M >> 4, $[R++] = (M & 15) << 4 | D >> 2, $[R++] = (D & 3) << 6 | L & 63;\n  return B;\n}, withNativeArrayBuffer$1 = typeof ArrayBuffer == \"function\", decodePacket = (n, t) => {\n  if (typeof n != \"string\")\n    return {\n      type: \"message\",\n      data: mapBinary(n, t)\n    };\n  const e = n.charAt(0);\n  return e === \"b\" ? {\n    type: \"message\",\n    data: decodeBase64Packet(n.substring(1), t)\n  } : PACKET_TYPES_REVERSE[e] ? n.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[e],\n    data: n.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[e]\n  } : ERROR_PACKET;\n}, decodeBase64Packet = (n, t) => {\n  if (withNativeArrayBuffer$1) {\n    const e = decode$3(n);\n    return mapBinary(e, t);\n  } else\n    return { base64: !0, data: n };\n}, mapBinary = (n, t) => {\n  switch (t) {\n    case \"blob\":\n      return n instanceof ArrayBuffer ? new Blob([n]) : n;\n    case \"arraybuffer\":\n    default:\n      return n;\n  }\n}, SEPARATOR = String.fromCharCode(30), encodePayload = (n, t) => {\n  const e = n.length, o = new Array(e);\n  let R = 0;\n  n.forEach((N, M) => {\n    encodePacket(N, !1, (D) => {\n      o[M] = D, ++R === e && t(o.join(SEPARATOR));\n    });\n  });\n}, decodePayload = (n, t) => {\n  const e = n.split(SEPARATOR), o = [];\n  for (let R = 0; R < e.length; R++) {\n    const N = decodePacket(e[R], t);\n    if (o.push(N), N.type === \"error\")\n      break;\n  }\n  return o;\n}, protocol$1 = 4;\nfunction Emitter(n) {\n  if (n)\n    return mixin(n);\n}\nfunction mixin(n) {\n  for (var t in Emitter.prototype)\n    n[t] = Emitter.prototype[t];\n  return n;\n}\nEmitter.prototype.on = Emitter.prototype.addEventListener = function(n, t) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + n] = this._callbacks[\"$\" + n] || []).push(t), this;\n};\nEmitter.prototype.once = function(n, t) {\n  function e() {\n    this.off(n, e), t.apply(this, arguments);\n  }\n  return e.fn = t, this.on(n, e), this;\n};\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(n, t) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var e = this._callbacks[\"$\" + n];\n  if (!e)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + n], this;\n  for (var o, R = 0; R < e.length; R++)\n    if (o = e[R], o === t || o.fn === t) {\n      e.splice(R, 1);\n      break;\n    }\n  return e.length === 0 && delete this._callbacks[\"$\" + n], this;\n};\nEmitter.prototype.emit = function(n) {\n  this._callbacks = this._callbacks || {};\n  for (var t = new Array(arguments.length - 1), e = this._callbacks[\"$\" + n], o = 1; o < arguments.length; o++)\n    t[o - 1] = arguments[o];\n  if (e) {\n    e = e.slice(0);\n    for (var o = 0, R = e.length; o < R; ++o)\n      e[o].apply(this, t);\n  }\n  return this;\n};\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\nEmitter.prototype.listeners = function(n) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + n] || [];\n};\nEmitter.prototype.hasListeners = function(n) {\n  return !!this.listeners(n).length;\n};\nconst globalThisShim = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction pick(n, ...t) {\n  return t.reduce((e, o) => (n.hasOwnProperty(o) && (e[o] = n[o]), e), {});\n}\nconst NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(n, t) {\n  t.useNativeTimers ? (n.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), n.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (n.setTimeoutFn = setTimeout.bind(globalThisShim), n.clearTimeoutFn = clearTimeout.bind(globalThisShim));\n}\nconst BASE64_OVERHEAD = 1.33;\nfunction byteLength(n) {\n  return typeof n == \"string\" ? utf8Length(n) : Math.ceil((n.byteLength || n.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(n) {\n  let t = 0, e = 0;\n  for (let o = 0, R = n.length; o < R; o++)\n    t = n.charCodeAt(o), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (o++, e += 4);\n  return e;\n}\nclass TransportError extends Error {\n  constructor(t, e, o) {\n    super(t), this.description = e, this.context = o, this.type = \"TransportError\";\n  }\n}\nclass Transport extends Emitter {\n  constructor(t) {\n    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = \"\", this.socket = t.socket;\n  }\n  onError(t, e, o) {\n    return super.emitReserved(\"error\", new TransportError(t, e, o)), this;\n  }\n  open() {\n    return (this.readyState === \"closed\" || this.readyState === \"\") && (this.readyState = \"opening\", this.doOpen()), this;\n  }\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  send(t) {\n    this.readyState === \"open\" && this.write(t);\n  }\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  onData(t) {\n    const e = decodePacket(t, this.socket.binaryType);\n    this.onPacket(e);\n  }\n  onPacket(t) {\n    super.emitReserved(\"packet\", t);\n  }\n  onClose(t) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", t);\n  }\n}\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map$3 = {};\nlet seed = 0, i = 0, prev;\nfunction encode$3(n) {\n  let t = \"\";\n  do\n    t = alphabet[n % length] + t, n = Math.floor(n / length);\n  while (n > 0);\n  return t;\n}\nfunction yeast() {\n  const n = encode$3(+new Date());\n  return n !== prev ? (seed = 0, prev = n) : n + \".\" + encode$3(seed++);\n}\nfor (; i < length; i++)\n  map$3[alphabet[i]] = i;\nfunction encode$2(n) {\n  let t = \"\";\n  for (let e in n)\n    n.hasOwnProperty(e) && (t.length && (t += \"&\"), t += encodeURIComponent(e) + \"=\" + encodeURIComponent(n[e]));\n  return t;\n}\nfunction decode$2(n) {\n  let t = {}, e = n.split(\"&\");\n  for (let o = 0, R = e.length; o < R; o++) {\n    let N = e[o].split(\"=\");\n    t[decodeURIComponent(N[0])] = decodeURIComponent(N[1]);\n  }\n  return t;\n}\nlet value = !1;\ntry {\n  value = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst hasCORS = value;\nfunction XHR(n) {\n  const t = n.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!t || hasCORS))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!t)\n    try {\n      return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction empty() {\n}\nconst hasXHR2 = function() {\n  return new XHR({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass Polling extends Transport {\n  constructor(t) {\n    if (super(t), this.polling = !1, typeof location < \"u\") {\n      const o = location.protocol === \"https:\";\n      let R = location.port;\n      R || (R = o ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && t.hostname !== location.hostname || R !== t.port, this.xs = t.secure !== o;\n    }\n    const e = t && t.forceBase64;\n    this.supportsBinary = hasXHR2 && !e;\n  }\n  get name() {\n    return \"polling\";\n  }\n  doOpen() {\n    this.poll();\n  }\n  pause(t) {\n    this.readyState = \"pausing\";\n    const e = () => {\n      this.readyState = \"paused\", t();\n    };\n    if (this.polling || !this.writable) {\n      let o = 0;\n      this.polling && (o++, this.once(\"pollComplete\", function() {\n        --o || e();\n      })), this.writable || (o++, this.once(\"drain\", function() {\n        --o || e();\n      }));\n    } else\n      e();\n  }\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  onData(t) {\n    const e = (o) => {\n      if (this.readyState === \"opening\" && o.type === \"open\" && this.onOpen(), o.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(o);\n    };\n    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  doClose() {\n    const t = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? t() : this.once(\"open\", t);\n  }\n  write(t) {\n    this.writable = !1, encodePayload(t, (e) => {\n      this.doWrite(e, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"https\" : \"http\";\n    let o = \"\";\n    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === \"https\" && Number(this.opts.port) !== 443 || e === \"http\" && Number(this.opts.port) !== 80) && (o = \":\" + this.opts.port);\n    const R = encode$2(t), N = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (N ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + o + this.opts.path + (R.length ? \"?\" + R : \"\");\n  }\n  request(t = {}) {\n    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);\n  }\n  doWrite(t, e) {\n    const o = this.request({\n      method: \"POST\",\n      data: t\n    });\n    o.on(\"success\", e), o.on(\"error\", (R, N) => {\n      this.onError(\"xhr post error\", R, N);\n    });\n  }\n  doPoll() {\n    const t = this.request();\n    t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (e, o) => {\n      this.onError(\"xhr poll error\", e, o);\n    }), this.pollXhr = t;\n  }\n}\nclass Request extends Emitter {\n  constructor(t, e) {\n    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();\n  }\n  create() {\n    const t = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n    const e = this.xhr = new XHR(t);\n    try {\n      e.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n          for (let o in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(o) && e.setRequestHeader(o, this.opts.extraHeaders[o]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        e.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof e.status == \"number\" ? e.status : 0);\n        }, 0));\n      }, e.send(this.data);\n    } catch (o) {\n      this.setTimeoutFn(() => {\n        this.onError(o);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);\n  }\n  onError(t) {\n    this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n  }\n  cleanup(t) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = empty, t)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete Request.requests[this.index], this.xhr = null;\n    }\n  }\n  onLoad() {\n    const t = this.xhr.responseText;\n    t !== null && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n  }\n  abort() {\n    this.cleanup();\n  }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", unloadHandler);\n  else if (typeof addEventListener == \"function\") {\n    const n = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(n, unloadHandler, !1);\n  }\n}\nfunction unloadHandler() {\n  for (let n in Request.requests)\n    Request.requests.hasOwnProperty(n) && Request.requests[n].abort();\n}\nconst nextTick = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = \"arraybuffer\", isReactNative = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n  constructor(t) {\n    super(t), this.supportsBinary = !t.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const t = this.uri(), e = this.opts.protocols, o = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (o.headers = this.opts.extraHeaders);\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, o);\n    } catch (R) {\n      return this.emitReserved(\"error\", R);\n    }\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();\n  }\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (t) => this.onClose({\n      description: \"websocket connection closed\",\n      context: t\n    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError(\"websocket error\", t);\n  }\n  write(t) {\n    this.writable = !1;\n    for (let e = 0; e < t.length; e++) {\n      const o = t[e], R = e === t.length - 1;\n      encodePacket(o, this.supportsBinary, (N) => {\n        const M = {};\n        try {\n          usingBrowserWebSocket && this.ws.send(N);\n        } catch {\n        }\n        R && nextTick(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"wss\" : \"ws\";\n    let o = \"\";\n    this.opts.port && (e === \"wss\" && Number(this.opts.port) !== 443 || e === \"ws\" && Number(this.opts.port) !== 80) && (o = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);\n    const R = encode$2(t), N = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (N ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + o + this.opts.path + (R.length ? \"?\" + R : \"\");\n  }\n  check() {\n    return !!WebSocket;\n  }\n}\nconst transports = {\n  websocket: WS,\n  polling: Polling\n}, re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, parts = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction parse$2(n) {\n  const t = n, e = n.indexOf(\"[\"), o = n.indexOf(\"]\");\n  e != -1 && o != -1 && (n = n.substring(0, e) + n.substring(e, o).replace(/:/g, \";\") + n.substring(o, n.length));\n  let R = re.exec(n || \"\"), N = {}, M = 14;\n  for (; M--; )\n    N[parts[M]] = R[M] || \"\";\n  return e != -1 && o != -1 && (N.source = t, N.host = N.host.substring(1, N.host.length - 1).replace(/;/g, \":\"), N.authority = N.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), N.ipv6uri = !0), N.pathNames = pathNames(N, N.path), N.queryKey = queryKey(N, N.query), N;\n}\nfunction pathNames(n, t) {\n  const e = /\\/{2,9}/g, o = t.replace(e, \"/\").split(\"/\");\n  return (t.substr(0, 1) == \"/\" || t.length === 0) && o.splice(0, 1), t.substr(t.length - 1, 1) == \"/\" && o.splice(o.length - 1, 1), o;\n}\nfunction queryKey(n, t) {\n  const e = {};\n  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(o, R, N) {\n    R && (e[R] = N);\n  }), e;\n}\nclass Socket$1 extends Emitter {\n  constructor(t, e = {}) {\n    super(), t && typeof t == \"object\" && (e = t, t = null), t ? (t = parse$2(t), e.hostname = t.host, e.secure = t.protocol === \"https\" || t.protocol === \"wss\", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse$2(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < \"u\" && location.protocol === \"https:\", e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = e.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.readyState = \"\", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !0\n    }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\", typeof this.opts.query == \"string\" && (this.opts.query = decode$2(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && addEventListener(\"beforeunload\", () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, !1), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  createTransport(t) {\n    const e = Object.assign({}, this.opts.query);\n    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);\n    const o = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n      query: e,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new transports[t](o);\n  }\n  open() {\n    let t;\n    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      t = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      t = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      t = this.createTransport(t);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    t.open(), this.setTransport(t);\n  }\n  setTransport(t) {\n    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (e) => this.onClose(\"transport close\", e));\n  }\n  probe(t) {\n    let e = this.createTransport(t), o = !1;\n    Socket$1.priorWebsocketSuccess = !1;\n    const R = () => {\n      o || (e.send([{ type: \"ping\", data: \"probe\" }]), e.once(\"packet\", (k) => {\n        if (!o)\n          if (k.type === \"pong\" && k.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e)\n              return;\n            Socket$1.priorWebsocketSuccess = e.name === \"websocket\", this.transport.pause(() => {\n              o || this.readyState !== \"closed\" && ($(), this.setTransport(e), e.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const U = new Error(\"probe error\");\n            U.transport = e.name, this.emitReserved(\"upgradeError\", U);\n          }\n      }));\n    };\n    function N() {\n      o || (o = !0, $(), e.close(), e = null);\n    }\n    const M = (k) => {\n      const U = new Error(\"probe error: \" + k);\n      U.transport = e.name, N(), this.emitReserved(\"upgradeError\", U);\n    };\n    function D() {\n      M(\"transport closed\");\n    }\n    function L() {\n      M(\"socket closed\");\n    }\n    function B(k) {\n      e && k.name !== e.name && N();\n    }\n    const $ = () => {\n      e.removeListener(\"open\", R), e.removeListener(\"error\", M), e.removeListener(\"close\", D), this.off(\"close\", L), this.off(\"upgrading\", B);\n    };\n    e.once(\"open\", R), e.once(\"error\", M), e.once(\"close\", D), this.once(\"close\", L), this.once(\"upgrading\", B), e.open();\n  }\n  onOpen() {\n    if (this.readyState = \"open\", Socket$1.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade && this.transport.pause) {\n      let t = 0;\n      const e = this.upgrades.length;\n      for (; t < e; t++)\n        this.probe(this.upgrades[t]);\n    }\n  }\n  onPacket(t) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(t.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const e = new Error(\"server error\");\n          e.code = t.data, this.onError(e);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n          break;\n      }\n  }\n  onHandshake(t) {\n    this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const t = this.getWritablePackets();\n      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n    }\n  }\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let e = 1;\n    for (let o = 0; o < this.writeBuffer.length; o++) {\n      const R = this.writeBuffer[o].data;\n      if (R && (e += byteLength(R)), o > 0 && e > this.maxPayload)\n        return this.writeBuffer.slice(0, o);\n      e += 2;\n    }\n    return this.writeBuffer;\n  }\n  write(t, e, o) {\n    return this.sendPacket(\"message\", t, e, o), this;\n  }\n  send(t, e, o) {\n    return this.sendPacket(\"message\", t, e, o), this;\n  }\n  sendPacket(t, e, o, R) {\n    if (typeof e == \"function\" && (R = e, e = void 0), typeof o == \"function\" && (R = o, o = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    o = o || {}, o.compress = o.compress !== !1;\n    const N = {\n      type: t,\n      data: e,\n      options: o\n    };\n    this.emitReserved(\"packetCreate\", N), this.writeBuffer.push(N), R && this.once(\"flush\", R), this.flush();\n  }\n  close() {\n    const t = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, e = () => {\n      this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n    }, o = () => {\n      this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? o() : t();\n    }) : this.upgrading ? o() : t()), this;\n  }\n  onError(t) {\n    Socket$1.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n  }\n  onClose(t, e) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && removeEventListener(\"offline\", this.offlineEventListener, !1), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  filterUpgrades(t) {\n    const e = [];\n    let o = 0;\n    const R = t.length;\n    for (; o < R; o++)\n      ~this.transports.indexOf(t[o]) && e.push(t[o]);\n    return e;\n  }\n}\nSocket$1.protocol = protocol$1;\nfunction url$1(n, t = \"\", e) {\n  let o = n;\n  e = e || typeof location < \"u\" && location, n == null && (n = e.protocol + \"//\" + e.host), typeof n == \"string\" && (n.charAt(0) === \"/\" && (n.charAt(1) === \"/\" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\\/\\//.test(n) || (typeof e < \"u\" ? n = e.protocol + \"//\" + n : n = \"https://\" + n), o = parse$2(n)), o.port || (/^(http|ws)$/.test(o.protocol) ? o.port = \"80\" : /^(http|ws)s$/.test(o.protocol) && (o.port = \"443\")), o.path = o.path || \"/\";\n  const N = o.host.indexOf(\":\") !== -1 ? \"[\" + o.host + \"]\" : o.host;\n  return o.id = o.protocol + \"://\" + N + \":\" + o.port + t, o.href = o.protocol + \"://\" + N + (e && e.port === o.port ? \"\" : \":\" + o.port), o;\n}\nconst withNativeArrayBuffer = typeof ArrayBuffer == \"function\", isView = (n) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == \"function\" || typeof Blob < \"u\" && toString.call(Blob) === \"[object BlobConstructor]\", withNativeFile = typeof File == \"function\" || typeof File < \"u\" && toString.call(File) === \"[object FileConstructor]\";\nfunction isBinary(n) {\n  return withNativeArrayBuffer && (n instanceof ArrayBuffer || isView(n)) || withNativeBlob && n instanceof Blob || withNativeFile && n instanceof File;\n}\nfunction hasBinary(n, t) {\n  if (!n || typeof n != \"object\")\n    return !1;\n  if (Array.isArray(n)) {\n    for (let e = 0, o = n.length; e < o; e++)\n      if (hasBinary(n[e]))\n        return !0;\n    return !1;\n  }\n  if (isBinary(n))\n    return !0;\n  if (n.toJSON && typeof n.toJSON == \"function\" && arguments.length === 1)\n    return hasBinary(n.toJSON(), !0);\n  for (const e in n)\n    if (Object.prototype.hasOwnProperty.call(n, e) && hasBinary(n[e]))\n      return !0;\n  return !1;\n}\nfunction deconstructPacket(n) {\n  const t = [], e = n.data, o = n;\n  return o.data = _deconstructPacket(e, t), o.attachments = t.length, { packet: o, buffers: t };\n}\nfunction _deconstructPacket(n, t) {\n  if (!n)\n    return n;\n  if (isBinary(n)) {\n    const e = { _placeholder: !0, num: t.length };\n    return t.push(n), e;\n  } else if (Array.isArray(n)) {\n    const e = new Array(n.length);\n    for (let o = 0; o < n.length; o++)\n      e[o] = _deconstructPacket(n[o], t);\n    return e;\n  } else if (typeof n == \"object\" && !(n instanceof Date)) {\n    const e = {};\n    for (const o in n)\n      Object.prototype.hasOwnProperty.call(n, o) && (e[o] = _deconstructPacket(n[o], t));\n    return e;\n  }\n  return n;\n}\nfunction reconstructPacket(n, t) {\n  return n.data = _reconstructPacket(n.data, t), n.attachments = void 0, n;\n}\nfunction _reconstructPacket(n, t) {\n  if (!n)\n    return n;\n  if (n && n._placeholder === !0) {\n    if (typeof n.num == \"number\" && n.num >= 0 && n.num < t.length)\n      return t[n.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(n))\n    for (let e = 0; e < n.length; e++)\n      n[e] = _reconstructPacket(n[e], t);\n  else if (typeof n == \"object\")\n    for (const e in n)\n      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = _reconstructPacket(n[e], t));\n  return n;\n}\nconst protocol = 5;\nvar PacketType;\n(function(n) {\n  n[n.CONNECT = 0] = \"CONNECT\", n[n.DISCONNECT = 1] = \"DISCONNECT\", n[n.EVENT = 2] = \"EVENT\", n[n.ACK = 3] = \"ACK\", n[n.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", n[n.BINARY_EVENT = 5] = \"BINARY_EVENT\", n[n.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\nclass Encoder {\n  constructor(t) {\n    this.replacer = t;\n  }\n  encode(t) {\n    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];\n  }\n  encodeAsString(t) {\n    let e = \"\" + t.type;\n    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + \"-\"), t.nsp && t.nsp !== \"/\" && (e += t.nsp + \",\"), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;\n  }\n  encodeAsBinary(t) {\n    const e = deconstructPacket(t), o = this.encodeAsString(e.packet), R = e.buffers;\n    return R.unshift(o), R;\n  }\n}\nclass Decoder extends Emitter {\n  constructor(t) {\n    super(), this.reviver = t;\n  }\n  add(t) {\n    let e;\n    if (typeof t == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n    } else if (isBinary(t) || t.base64)\n      if (this.reconstructor)\n        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + t);\n  }\n  decodeString(t) {\n    let e = 0;\n    const o = {\n      type: Number(t.charAt(0))\n    };\n    if (PacketType[o.type] === void 0)\n      throw new Error(\"unknown packet type \" + o.type);\n    if (o.type === PacketType.BINARY_EVENT || o.type === PacketType.BINARY_ACK) {\n      const N = e + 1;\n      for (; t.charAt(++e) !== \"-\" && e != t.length; )\n        ;\n      const M = t.substring(N, e);\n      if (M != Number(M) || t.charAt(e) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      o.attachments = Number(M);\n    }\n    if (t.charAt(e + 1) === \"/\") {\n      const N = e + 1;\n      for (; ++e && !(t.charAt(e) === \",\" || e === t.length); )\n        ;\n      o.nsp = t.substring(N, e);\n    } else\n      o.nsp = \"/\";\n    const R = t.charAt(e + 1);\n    if (R !== \"\" && Number(R) == R) {\n      const N = e + 1;\n      for (; ++e; ) {\n        const M = t.charAt(e);\n        if (M == null || Number(M) != M) {\n          --e;\n          break;\n        }\n        if (e === t.length)\n          break;\n      }\n      o.id = Number(t.substring(N, e + 1));\n    }\n    if (t.charAt(++e)) {\n      const N = this.tryParse(t.substr(e));\n      if (Decoder.isPayloadValid(o.type, N))\n        o.data = N;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return o;\n  }\n  tryParse(t) {\n    try {\n      return JSON.parse(t, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(t, e) {\n    switch (t) {\n      case PacketType.CONNECT:\n        return typeof e == \"object\";\n      case PacketType.DISCONNECT:\n        return e === void 0;\n      case PacketType.CONNECT_ERROR:\n        return typeof e == \"string\" || typeof e == \"object\";\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(e) && e.length > 0;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(e);\n    }\n  }\n  destroy() {\n    this.reconstructor && this.reconstructor.finishedReconstruction();\n  }\n}\nclass BinaryReconstructor {\n  constructor(t) {\n    this.packet = t, this.buffers = [], this.reconPack = t;\n  }\n  takeBinaryData(t) {\n    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n      const e = reconstructPacket(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), e;\n    }\n    return null;\n  }\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  protocol,\n  get PacketType() {\n    return PacketType;\n  },\n  Encoder,\n  Decoder\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction on(n, t, e) {\n  return n.on(t, e), function() {\n    n.off(t, e);\n  };\n}\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nclass Socket extends Emitter {\n  constructor(t, e, o) {\n    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, o && o.auth && (this.auth = o.auth), this.io._autoConnect && this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs)\n      return;\n    const t = this.io;\n    this.subs = [\n      on(t, \"open\", this.onopen.bind(this)),\n      on(t, \"packet\", this.onpacket.bind(this)),\n      on(t, \"error\", this.onerror.bind(this)),\n      on(t, \"close\", this.onclose.bind(this))\n    ];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  open() {\n    return this.connect();\n  }\n  send(...t) {\n    return t.unshift(\"message\"), this.emit.apply(this, t), this;\n  }\n  emit(t, ...e) {\n    if (RESERVED_EVENTS.hasOwnProperty(t))\n      throw new Error('\"' + t + '\" is a reserved event name');\n    e.unshift(t);\n    const o = {\n      type: PacketType.EVENT,\n      data: e\n    };\n    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == \"function\") {\n      const M = this.ids++, D = e.pop();\n      this._registerAckCallback(M, D), o.id = M;\n    }\n    const R = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!R || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;\n  }\n  _registerAckCallback(t, e) {\n    const o = this.flags.timeout;\n    if (o === void 0) {\n      this.acks[t] = e;\n      return;\n    }\n    const R = this.io.setTimeoutFn(() => {\n      delete this.acks[t];\n      for (let N = 0; N < this.sendBuffer.length; N++)\n        this.sendBuffer[N].id === t && this.sendBuffer.splice(N, 1);\n      e.call(this, new Error(\"operation has timed out\"));\n    }, o);\n    this.acks[t] = (...N) => {\n      this.io.clearTimeoutFn(R), e.apply(this, [null, ...N]);\n    };\n  }\n  packet(t) {\n    t.nsp = this.nsp, this.io._packet(t);\n  }\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((t) => {\n      this.packet({ type: PacketType.CONNECT, data: t });\n    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });\n  }\n  onerror(t) {\n    this.connected || this.emitReserved(\"connect_error\", t);\n  }\n  onclose(t, e) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n  }\n  onpacket(t) {\n    if (t.nsp === this.nsp)\n      switch (t.type) {\n        case PacketType.CONNECT:\n          if (t.data && t.data.sid) {\n            const R = t.data.sid;\n            this.onconnect(R);\n          } else\n            this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case PacketType.EVENT:\n        case PacketType.BINARY_EVENT:\n          this.onevent(t);\n          break;\n        case PacketType.ACK:\n        case PacketType.BINARY_ACK:\n          this.onack(t);\n          break;\n        case PacketType.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case PacketType.CONNECT_ERROR:\n          this.destroy();\n          const o = new Error(t.data.message);\n          o.data = t.data.data, this.emitReserved(\"connect_error\", o);\n          break;\n      }\n  }\n  onevent(t) {\n    const e = t.data || [];\n    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n  }\n  emitEvent(t) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const e = this._anyListeners.slice();\n      for (const o of e)\n        o.apply(this, t);\n    }\n    super.emit.apply(this, t);\n  }\n  ack(t) {\n    const e = this;\n    let o = !1;\n    return function(...R) {\n      o || (o = !0, e.packet({\n        type: PacketType.ACK,\n        id: t,\n        data: R\n      }));\n    };\n  }\n  onack(t) {\n    const e = this.acks[t.id];\n    typeof e == \"function\" && (e.apply(this, t.data), delete this.acks[t.id]);\n  }\n  onconnect(t) {\n    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\");\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {\n      this.notifyOutgoingListeners(t), this.packet(t);\n    }), this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);\n  }\n  disconnect() {\n    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(t) {\n    return this.flags.compress = t, this;\n  }\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  timeout(t) {\n    return this.flags.timeout = t, this;\n  }\n  onAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n  }\n  prependAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n  }\n  offAny(t) {\n    if (!this._anyListeners)\n      return this;\n    if (t) {\n      const e = this._anyListeners;\n      for (let o = 0; o < e.length; o++)\n        if (t === e[o])\n          return e.splice(o, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n  }\n  prependAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n  }\n  offAnyOutgoing(t) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (t) {\n      const e = this._anyOutgoingListeners;\n      for (let o = 0; o < e.length; o++)\n        if (t === e[o])\n          return e.splice(o, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(t) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const e = this._anyOutgoingListeners.slice();\n      for (const o of e)\n        o.apply(this, t.data);\n    }\n  }\n}\nfunction Backoff(n) {\n  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;\n}\nBackoff.prototype.duration = function() {\n  var n = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var t = Math.random(), e = Math.floor(t * this.jitter * n);\n    n = (Math.floor(t * 10) & 1) == 0 ? n - e : n + e;\n  }\n  return Math.min(n, this.max) | 0;\n};\nBackoff.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function(n) {\n  this.ms = n;\n};\nBackoff.prototype.setMax = function(n) {\n  this.max = n;\n};\nBackoff.prototype.setJitter = function(n) {\n  this.jitter = n;\n};\nclass Manager extends Emitter {\n  constructor(t, e) {\n    var o;\n    super(), this.nsps = {}, this.subs = [], t && typeof t == \"object\" && (e = t, t = void 0), e = e || {}, e.path = e.path || \"/socket.io\", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((o = e.randomizationFactor) !== null && o !== void 0 ? o : 0.5), this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n    const R = e.parser || parser;\n    this.encoder = new R.Encoder(), this.decoder = new R.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(t) {\n    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n  }\n  reconnectionAttempts(t) {\n    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n  }\n  reconnectionDelay(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);\n  }\n  randomizationFactor(t) {\n    var e;\n    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);\n  }\n  reconnectionDelayMax(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);\n  }\n  timeout(t) {\n    return arguments.length ? (this._timeout = t, this) : this._timeout;\n  }\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  open(t) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Socket$1(this.uri, this.opts);\n    const e = this.engine, o = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const R = on(e, \"open\", function() {\n      o.onopen(), t && t();\n    }), N = on(e, \"error\", (M) => {\n      o.cleanup(), o._readyState = \"closed\", this.emitReserved(\"error\", M), t ? t(M) : o.maybeReconnectOnOpen();\n    });\n    if (this._timeout !== !1) {\n      const M = this._timeout;\n      M === 0 && R();\n      const D = this.setTimeoutFn(() => {\n        R(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n      }, M);\n      this.opts.autoUnref && D.unref(), this.subs.push(function() {\n        clearTimeout(D);\n      });\n    }\n    return this.subs.push(R), this.subs.push(N), this;\n  }\n  connect(t) {\n    return this.open(t);\n  }\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const t = this.engine;\n    this.subs.push(on(t, \"ping\", this.onping.bind(this)), on(t, \"data\", this.ondata.bind(this)), on(t, \"error\", this.onerror.bind(this)), on(t, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(t) {\n    this.decoder.add(t);\n  }\n  ondecoded(t) {\n    this.emitReserved(\"packet\", t);\n  }\n  onerror(t) {\n    this.emitReserved(\"error\", t);\n  }\n  socket(t, e) {\n    let o = this.nsps[t];\n    return o || (o = new Socket(this, t, e), this.nsps[t] = o), o;\n  }\n  _destroy(t) {\n    const e = Object.keys(this.nsps);\n    for (const o of e)\n      if (this.nsps[o].active)\n        return;\n    this._close();\n  }\n  _packet(t) {\n    const e = this.encoder.encode(t);\n    for (let o = 0; o < e.length; o++)\n      this.engine.write(e[o], t.options);\n  }\n  cleanup() {\n    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(t, e) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const t = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const e = this.backoff.duration();\n      this._reconnecting = !0;\n      const o = this.setTimeoutFn(() => {\n        t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), !t.skipReconnect && t.open((R) => {\n          R ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", R)) : t.onreconnect();\n        }));\n      }, e);\n      this.opts.autoUnref && o.unref(), this.subs.push(function() {\n        clearTimeout(o);\n      });\n    }\n  }\n  onreconnect() {\n    const t = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n  }\n}\nconst cache = {};\nfunction lookup(n, t) {\n  typeof n == \"object\" && (t = n, n = void 0), t = t || {};\n  const e = url$1(n, t.path || \"/socket.io\"), o = e.source, R = e.id, N = e.path, M = cache[R] && N in cache[R].nsps, D = t.forceNew || t[\"force new connection\"] || t.multiplex === !1 || M;\n  let L;\n  return D ? L = new Manager(o, t) : (cache[R] || (cache[R] = new Manager(o, t)), L = cache[R]), e.query && !t.query && (t.query = e.queryKey), L.socket(e.path, t);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\nvar __accessCheck$5 = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet$5 = (n, t, e) => (__accessCheck$5(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd$5 = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet$5 = (n, t, e, o) => (__accessCheck$5(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), _cvsWidth, _cvsHeight, _cvsScale, _ofsLeft4elm, _ofsTop4elm, _ofsPadLeft_Dom2PIXI, _ofsPadTop_Dom2PIXI, _sk, _hHook, _hToastDat, _aFncHook, _main_title, _tglFlscr, _info_title, _preFromPlg, _hN2Ext, _genImage, _genVideo;\nconst _SysBase = class {\n  constructor(n = {}, t) {\n    this.hPlg = n, this.arg = t, this.hFactoryCls = {}, this.fetch = (e) => fetch(e), this.resolution = 1, this.data = { sys: {}, mark: {}, kidoku: {} }, __privateAdd$5(this, _cvsWidth, 0), __privateAdd$5(this, _cvsHeight, 0), __privateAdd$5(this, _cvsScale, 1), __privateAdd$5(this, _ofsLeft4elm, 0), __privateAdd$5(this, _ofsTop4elm, 0), __privateAdd$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateAdd$5(this, _ofsPadTop_Dom2PIXI, 0), this.isFullScr = !1, this.extPort = 3776, __privateAdd$5(this, _sk, void 0), __privateAdd$5(this, _hHook, {\n      auth: (e) => {\n        if (e.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"\\u63A5\\u7D9A\");\n      },\n      continue: () => this.toast(\"\\u518D\\u751F\"),\n      disconnect: () => this.toast(\"\\u5207\\u65AD\"),\n      restart: (e) => {\n        var o;\n        this.send2Dbg((o = e == null ? void 0 : e.ri) != null ? o : \"\", {}), this.end(), this.run();\n      },\n      pause: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnEntry: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnDataBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnStep: () => this.toast(\"\\u4E00\\u6B69\\u9032\\u3080\"),\n      stopOnStepIn: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3\"),\n      stopOnStepOut: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8\"),\n      stopOnBackstep: () => this.toast(\"\\u4E00\\u6B69\\u623B\\u308B\"),\n      _addPath: (e) => this.cfg.addPath(e.fn, e.o)\n    }), this.pathBaseCnvSnPath4Dbg = \"\", __privateAdd$5(this, _aFncHook, []), this.callHook = (e, o) => {\n    }, this.send2Dbg = (e, o) => {\n      var R;\n      (R = __privateGet$5(this, _sk)) == null || R.emit(\"data\", e, o);\n    }, this.copyBMFolder = (e, o) => {\n    }, this.eraseBMFolder = (e) => {\n    }, this.close = () => !1, this._export = () => !1, this._import = () => !1, this.navigate_to = () => !1, this.title = (e) => {\n      const { text: o } = e;\n      if (!o)\n        throw \"[title] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      return __privateSet$5(this, _main_title, o), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title)), !1;\n    }, __privateAdd$5(this, _main_title, \"\"), __privateAdd$5(this, _tglFlscr, (e) => {\n      if (!e.key)\n        return this.tglFlscr_sub(), !1;\n      const o = e.key.toLowerCase();\n      return document.addEventListener(\"keydown\", (R) => {\n        (R.altKey ? R.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (R.ctrlKey ? R.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (R.shiftKey ? R.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + R.key.toLowerCase() === o && (R.stopPropagation(), this.tglFlscr_sub());\n      }, { passive: !0 }), !1;\n    }), this.update_check = () => !1, this.window = () => !1, __privateAdd$5(this, _info_title, \"\"), __privateAdd$5(this, _preFromPlg, (e, o) => ({ ret: o.toString(), ext_num: 0 })), __privateAdd$5(this, _hN2Ext, {\n      1: { ext: \"jpeg\", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (e) => e.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (e) => e.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (e) => e.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (e) => e.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (e) => e.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (e) => e.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: \"video/ogv\" }\n    }), __privateAdd$5(this, _genImage, (e) => new Promise((o, R) => {\n      const N = new Image();\n      N.onload = () => o(N), N.onerror = (M) => R(M), N.src = URL.createObjectURL(e);\n    })), __privateAdd$5(this, _genVideo, (e) => new Promise((o, R) => {\n      const N = document.createElement(\"video\");\n      N.addEventListener(\"error\", () => {\n        var M, D;\n        return R((D = (M = N == null ? void 0 : N.error) == null ? void 0 : M.message) != null ? D : \"\");\n      }), N.addEventListener(\"canplay\", () => o(N)), N.src = URL.createObjectURL(e);\n    })), this.enc = (e) => e, this.stk = () => \"\", this.hash = (e) => \"\", this.isApp = !1, this.$path_downloads = \"\", this.$path_userdata = \"\", this.canCapturePage = (e) => !1;\n  }\n  async loaded(n, t) {\n    const e = n.snsys_pre;\n    return delete n.snsys_pre, e == null ? void 0 : e.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (o) => __privateSet$5(this, _preFromPlg, o),\n      setEnc: (o) => this.enc = o,\n      getStK: (o) => this.stk = o,\n      getHash: (o) => this.hash = o\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  async loadPath(n, t) {\n    this.cfg = t;\n  }\n  initVal(n, t, e) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(n, t, e, o) {\n    this.val = e, this.appPixi = t;\n    let R = \"\";\n    try {\n      this.val.setSys(this), R = \"sys\", R += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), R = \"kidoku\", this.val.saveKidoku();\n    } catch (M) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${R}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, M);\n    }\n    n.close = (M) => this.close(M), n.export = (M) => this._export(M), n.import = (M) => this._import(M), n.navigate_to = (M) => this.navigate_to(M), n.title = (M) => this.title(M), n.toggle_full_screen = (M) => __privateGet$5(this, _tglFlscr).call(this, M), n.update_check = (M) => this.update_check(M), n.window = (M) => this.window(M), e.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp), e.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => CmnLib.isDbg), e.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => CmnLib.isPackaged), this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr), e.setVal_Nochk(\"sys\", _SysBase.VALNM_CFG_NS, this.cfg.oCfg.save_ns), e.flush(), CmnLib.isDbg && this.attach_debug(o), this.hFactoryCls = {};\n    const N = [];\n    for (const M in this.hPlg)\n      N.push(this.hPlg[M].init({\n        addTag: (D, L) => {\n          if (n[D])\n            throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30BF\\u30B0[${D}]\\u3067\\u3059`;\n          n[D] = L;\n        },\n        addLayCls: (D, L) => {\n          if (this.hFactoryCls[D])\n            throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30EC\\u30A4\\u30E4cls\\u3010${D}\\u3011\\u3067\\u3059`;\n          this.hFactoryCls[D] = L;\n        },\n        searchPath: (D, L = \"\") => this.cfg.searchPath(D, L),\n        getVal: e.getVal,\n        resume: () => o.resume(),\n        render: (D, L, B = !1) => this.appPixi.renderer.render(D, { renderTexture: L, clear: B }),\n        setDec: (D) => __privateSet$5(this, _preFromPlg, D),\n        setEnc: (D) => this.enc = D,\n        getStK: (D) => this.stk = D,\n        getHash: (D) => this.hash = D\n      }));\n    return N;\n  }\n  get cvsWidth() {\n    return __privateGet$5(this, _cvsWidth);\n  }\n  get cvsHeight() {\n    return __privateGet$5(this, _cvsHeight);\n  }\n  get cvsScale() {\n    return __privateGet$5(this, _cvsScale);\n  }\n  get ofsLeft4elm() {\n    return __privateGet$5(this, _ofsLeft4elm);\n  }\n  get ofsTop4elm() {\n    return __privateGet$5(this, _ofsTop4elm);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return __privateGet$5(this, _ofsPadLeft_Dom2PIXI);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return __privateGet$5(this, _ofsPadTop_Dom2PIXI);\n  }\n  cvsResize() {\n    var D, L;\n    let n = globalThis.innerWidth, t = globalThis.innerHeight;\n    const e = this.appPixi.view, o = e.parentElement !== document.body;\n    if (o) {\n      const B = globalThis.getComputedStyle(e);\n      n = parseFloat(B.width), t = parseFloat(B.height);\n    }\n    if (CmnLib.isMobile) {\n      const $ = ((L = (D = screen.orientation) == null ? void 0 : D.angle) != null ? L : 0) % 180 === 0;\n      ($ && n > t || !$ && n < t) && ([n, t] = [t, n]);\n    }\n    const R = e.getBoundingClientRect();\n    if (argChk_Boolean(CmnLib.hDip, \"expanding\", !0) || o || CmnLib.stageW > n || CmnLib.stageH > t)\n      if (CmnLib.stageW / CmnLib.stageH <= n / t ? (__privateSet$5(this, _cvsHeight, t), __privateSet$5(this, _cvsWidth, CmnLib.stageW / CmnLib.stageH * t)) : (__privateSet$5(this, _cvsWidth, n), __privateSet$5(this, _cvsHeight, CmnLib.stageH / CmnLib.stageW * n)), __privateSet$5(this, _cvsScale, __privateGet$5(this, _cvsWidth) / CmnLib.stageW), o)\n        __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);\n      else {\n        const B = 1 - __privateGet$5(this, _cvsScale);\n        CmnLib.isMobile ? (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, (n - __privateGet$5(this, _cvsWidth)) / 2 * B), __privateSet$5(this, _ofsPadTop_Dom2PIXI, (t - __privateGet$5(this, _cvsHeight)) / 2 * B)) : (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, R.left * B), __privateSet$5(this, _ofsPadTop_Dom2PIXI, R.top * B));\n      }\n    else\n      __privateSet$5(this, _cvsWidth, CmnLib.stageW), __privateSet$5(this, _cvsHeight, CmnLib.stageH), __privateSet$5(this, _cvsScale, 1), __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);\n    const N = e.parentElement.style;\n    o || (N.position = \"relative\", N.width = `${__privateGet$5(this, _cvsWidth)}px`, N.height = `${__privateGet$5(this, _cvsHeight)}px`);\n    const M = e.style;\n    M.width = N.width, M.height = N.height, __privateSet$5(this, _ofsLeft4elm, R.left), __privateSet$5(this, _ofsTop4elm, R.top), this.isFullScr && (__privateSet$5(this, _ofsLeft4elm, __privateGet$5(this, _ofsLeft4elm) + (n - __privateGet$5(this, _cvsWidth)) / 2), __privateSet$5(this, _ofsTop4elm, __privateGet$5(this, _ofsTop4elm) + (t - __privateGet$5(this, _cvsHeight)) / 2));\n  }\n  attach_debug(n) {\n    this.attach_debug = () => {\n    };\n    const t = document.createElement(\"style\");\n    t.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`, document.getElementsByTagName(\"head\")[0].appendChild(t), this.addHook((e, o) => {\n      var R, N;\n      return (N = (R = __privateGet$5(this, _hHook))[e]) == null ? void 0 : N.call(R, o);\n    }), __privateSet$5(this, _sk, lookup(`http://localhost:${this.extPort}`)), __privateGet$5(this, _sk).on(\"data\", (e, o) => {\n      this.callHook(e, o);\n    }).on(\"disconnect\", () => n.setLoop(!0)), this.callHook = (e, o) => __privateGet$5(this, _aFncHook).forEach((R) => R(e, o));\n  }\n  end() {\n    var n;\n    (n = __privateGet$5(this, _sk)) == null || n.disconnect(), __privateSet$5(this, _sk, void 0);\n  }\n  toast(n) {\n    var N, M, D;\n    const t = document.body;\n    t.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach((L) => t.removeChild(L));\n    const e = document.createElement(\"img\"), o = __privateGet$5(_SysBase, _hToastDat)[n];\n    e.src = `data:image/svg+xml;base64,${o.dat}`;\n    const R = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * __privateGet$5(this, _cvsScale);\n    e.width = e.height = R, e.style.cssText = `position: absolute;\nleft: ${(CmnLib.stageW - R) / 2 * __privateGet$5(this, _cvsScale) + R * ((N = o.dx) != null ? N : 0)}px;\ntop: ${(CmnLib.stageH - R) / 2 * __privateGet$5(this, _cvsScale) + R * ((M = o.dy) != null ? M : 0)}px;`, e.classList.add(\"sn_toast\", (D = o.ease) != null ? D : \"sn_BounceInOut\"), o.ease || e.addEventListener(\"animationend\", () => t.removeChild(e), { once: !0, passive: !0 }), t.insertBefore(e, this.appPixi.view);\n  }\n  setFire(n) {\n    this.fire = n;\n  }\n  addHook(n) {\n    __privateGet$5(this, _aFncHook).push(n);\n  }\n  titleSub(n) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(n) {\n    __privateSet$5(this, _info_title, n), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title));\n  }\n  decStr(n, t) {\n    return __privateGet$5(this, _preFromPlg).call(this, n, t).ret;\n  }\n  async dec(n, t) {\n    const { ret: e, ext_num: o } = __privateGet$5(this, _preFromPlg).call(this, n, t), R = __privateGet$5(this, _hN2Ext)[o];\n    return R != null && R.fnc ? await R.fnc(new Blob([e], { type: R.mime })) : e;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  async savePic(n, t) {\n  }\n  async appendFile(n, t, e) {\n  }\n  async ensureFileSync(n) {\n  }\n};\nlet SysBase = _SysBase;\n_cvsWidth = /* @__PURE__ */ new WeakMap();\n_cvsHeight = /* @__PURE__ */ new WeakMap();\n_cvsScale = /* @__PURE__ */ new WeakMap();\n_ofsLeft4elm = /* @__PURE__ */ new WeakMap();\n_ofsTop4elm = /* @__PURE__ */ new WeakMap();\n_ofsPadLeft_Dom2PIXI = /* @__PURE__ */ new WeakMap();\n_ofsPadTop_Dom2PIXI = /* @__PURE__ */ new WeakMap();\n_sk = /* @__PURE__ */ new WeakMap();\n_hHook = /* @__PURE__ */ new WeakMap();\n_hToastDat = /* @__PURE__ */ new WeakMap();\n_aFncHook = /* @__PURE__ */ new WeakMap();\n_main_title = /* @__PURE__ */ new WeakMap();\n_tglFlscr = /* @__PURE__ */ new WeakMap();\n_info_title = /* @__PURE__ */ new WeakMap();\n_preFromPlg = /* @__PURE__ */ new WeakMap();\n_hN2Ext = /* @__PURE__ */ new WeakMap();\n_genImage = /* @__PURE__ */ new WeakMap();\n_genVideo = /* @__PURE__ */ new WeakMap();\nSysBase.VALNM_CFG_NS = \"const.sn.cfg.ns\";\n__privateAdd$5(SysBase, _hToastDat, {\n  \\u63A5\\u7D9A: { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  \\u5207\\u65AD: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  \\u518D\\u751F: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \\u4E00\\u6642\\u505C\\u6B62: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \\u6CE8\\u610F: { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \\u4E00\\u6B69\\u9032\\u3080: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \\u4E00\\u6B69\\u623B\\u308B: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nvar __accessCheck$4 = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet$4 = (n, t, e) => (__accessCheck$4(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd$4 = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet$4 = (n, t, e, o) => (__accessCheck$4(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), _existsBreakline, _existsBreakpage, _REG_PATH;\nconst _Config = class {\n  constructor(n) {\n    this.sys = n, this.oCfg = {\n      save_ns: \"\",\n      window: {\n        width: 300,\n        height: 300\n      },\n      book: {\n        title: \"\",\n        creator: \"\",\n        cre_url: \"\",\n        publisher: \"\",\n        pub_url: \"\",\n        detail: \"\",\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      init: {\n        bg_color: \"#000000\",\n        tagch_msecwait: 10,\n        auto_msecpagewait: 3500,\n        escape: \"\"\n      },\n      debug: {\n        devtool: !1,\n        token: !1,\n        tag: !1,\n        putCh: !1,\n        debugLog: !1,\n        baseTx: !1,\n        masume: !1,\n        variable: !1\n      },\n      code: {},\n      debuger_token: \"\"\n    }, this.userFnTail = \"\", this.hPathFn2Exts = {}, __privateAdd$4(this, _existsBreakline, !1), __privateAdd$4(this, _existsBreakpage, !1), __privateAdd$4(this, _REG_PATH, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n  }\n  static async generate(n) {\n    const t = new _Config(n), e = n.cur + \"prj.json\", o = await (await n.fetch(e)).text(), R = JSON.parse(n.decStr(e, o));\n    return await t.load(R), t;\n  }\n  async load(n) {\n    var t, e, o, R, N, M, D, L;\n    if (this.oCfg.save_ns = (t = n == null ? void 0 : n.save_ns) != null ? t : this.oCfg.save_ns, CmnLib.stageW = this.oCfg.window.width = Number((o = (e = n == null ? void 0 : n.window) == null ? void 0 : e.width) != null ? o : this.oCfg.window.width), CmnLib.stageH = this.oCfg.window.height = Number((N = (R = n == null ? void 0 : n.window) == null ? void 0 : R.height) != null ? N : this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...n.book }, this.oCfg.log.max_len = (L = (D = (M = n.log) == null ? void 0 : M.max_len) == null ? void 0 : D.max_len) != null ? L : this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...n.init }, this.oCfg.debug = { ...this.oCfg.debug, ...n.debug }, CmnLib.debugLog = this.oCfg.debug.debugLog, this.oCfg.debuger_token = n.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), __privateSet$4(this, _existsBreakline, this.matchPath(\"^breakline$\", _Config.EXT_SPRITE).length > 0), __privateSet$4(this, _existsBreakpage, this.matchPath(\"^breakpage$\", _Config.EXT_SPRITE).length > 0), this.sys.crypto)\n      for (const B in this.hPathFn2Exts) {\n        const $ = this.hPathFn2Exts[B];\n        for (const k in $) {\n          if (k.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const U = $[k].slice($[k].lastIndexOf(\"/\") + 1), z = $[k.slice(0, -10)], V = await (await this.sys.fetch(z)).text(), W = this.sys.hash(V);\n          if (U !== W)\n            throw `\\u30D5\\u30A1\\u30A4\\u30EB\\u6539\\u7AC4\\u30A8\\u30E9\\u30FC\\u3067\\u3059 fn:${z}`;\n        }\n      }\n  }\n  get existsBreakline() {\n    return __privateGet$4(this, _existsBreakline);\n  }\n  get existsBreakpage() {\n    return __privateGet$4(this, _existsBreakpage);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  searchPath(n, t = \"\") {\n    if (!n)\n      throw \"[searchPath] fn\\u304C\\u7A7A\\u3067\\u3059\";\n    if (n.slice(0, 7) === \"http://\")\n      return n;\n    if (n.slice(0, 11) === \"downloads:/\") {\n      const D = this.sys.path_downloads + n.slice(11);\n      return this.sys.ensureFileSync(D), D;\n    }\n    if (n.slice(0, 10) === \"userdata:/\") {\n      const D = this.sys.path_userdata + \"storage/\" + n.slice(10);\n      return this.sys.ensureFileSync(D), D;\n    }\n    const e = n.match(__privateGet$4(this, _REG_PATH));\n    let o = e ? e[1] : n;\n    const R = e ? e[2] : \"\";\n    if (this.userFnTail) {\n      const D = o + \"@@\" + this.userFnTail;\n      if (D in this.hPathFn2Exts) {\n        if (t === \"\")\n          o = D;\n        else\n          for (let L in this.hPathFn2Exts[D])\n            if (`|${t}|`.indexOf(`|${L}|`) !== -1) {\n              o = D;\n              break;\n            }\n      }\n    }\n    const N = this.hPathFn2Exts[o];\n    if (!N)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${n}\\u3011\\u3067\\u3059`;\n    let M = \"\";\n    if (!R) {\n      const D = int(N[\":cnt\"]);\n      if (t === \"\") {\n        if (D > 1)\n          throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${n}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${t}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n        return n;\n      }\n      const L = `|${t}|`;\n      if (D > 1) {\n        let B = 0;\n        for (const $ in N)\n          if (L.indexOf(`|${$}|`) !== -1 && ++B > 1)\n            throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${n}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${t}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n      }\n      for (let B in N)\n        if (L.indexOf(`|${B}|`) > -1)\n          return N[B];\n      throw `\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${t}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3059\\u308B\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${n}\\u3011`;\n    }\n    if (t !== \"\" && `|${t}|`.indexOf(`|${R}|`) === -1)\n      throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u62E1\\u5F35\\u5B50\\u3010${R}\\u3011\\u306F\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${t}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${n}\\u3011`;\n    if (M = N[R], !M)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3010${R}\\u3011\\u3067\\u3059\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${n}\\u3011\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${t}\\u3011`;\n    return M;\n  }\n  matchPath(n, t = \"\") {\n    const e = [], o = new RegExp(n), R = new RegExp(t);\n    for (let N in this.hPathFn2Exts) {\n      if (N.search(o) === -1)\n        continue;\n      const M = this.hPathFn2Exts[N];\n      if (t === \"\") {\n        e.push(M);\n        continue;\n      }\n      const D = {};\n      let L = !1;\n      for (const B in M)\n        B.search(R) !== -1 && (D[B] = N, L = !0);\n      L && e.push(D);\n    }\n    return e;\n  }\n  addPath(n, t) {\n    const e = {};\n    for (const o in t)\n      e[o] = (o.charAt(0) === \":\" ? \"\" : this.sys.cur) + t[o];\n    this.hPathFn2Exts[n] = e;\n  }\n};\nlet Config = _Config;\n_existsBreakline = /* @__PURE__ */ new WeakMap();\n_existsBreakpage = /* @__PURE__ */ new WeakMap();\n_REG_PATH = /* @__PURE__ */ new WeakMap();\nConfig.EXT_SPRITE = \"png|jpg|jpeg|json|svg|webp|mp4|webm\";\nConfig.EXT_SCRIPT = \"sn|ssn\";\nConfig.EXT_FONT = \"woff2|woff|otf|ttf\";\nConfig.EXT_SOUND = \"mp3|m4a|ogg|aac|flac|wav\";\nConfig.EXT_HTML = \"htm|html\";\nvar Yi, Vr, Sa;\nconst di = class {\n  constructor() {\n    it(this, Vr, () => {\n    });\n  }\n  static setting(t) {\n    t.sesame && et(di, Yi, t.sesame);\n  }\n  static getSesame() {\n    return H(di, Yi);\n  }\n  static destroy() {\n    et(di, Yi, \"\\u30FD\");\n  }\n  init(t) {\n    et(this, Vr, t);\n  }\n  static setEscape(t) {\n    et(di, Sa, new RegExp(\n      `${t ? `(?<ce>\\\\${t}\\\\S)|` : \"\"}\\uFF5C(?<str>[^\\u300A\\\\n]+)\\u300A(?<ruby>[^\\u300B\\\\n]+)\\u300B|(?:(?<kan>[\\u2E80-\\u2FDF\\u3005\\u3007\\u303B\\u3400-\\u9FFF\\u8C48-\\uFAFF]+[\\u3041-\\u30FF]*|[^\\u3000\\uFF5C\\u300A\\u300B\\\\n])\\u300A(?<kan_ruby>[^\\u300B\\\\n]+)\\u300B)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^\\u3000\\uFF5C\\u300A\\u300B]+(?=\\uFF5C)|[^\\u3000\\uFF5C\\u300A\\u300B]*[\\u3041-\\u30FF](?=[\\u2E80-\\u2FDF\\u3005\\u3007\\u303B\\u3400-\\u9FFF\\u8C48-\\uFAFF]+\\u300A)|.)`,\n      \"gs\"\n    ));\n  }\n  putTxt(t) {\n    var o;\n    let e = null;\n    for (; e = H(di, Sa).exec(t); ) {\n      const R = e == null ? void 0 : e.groups;\n      if (!R)\n        continue;\n      const N = R.ruby;\n      if (N) {\n        this.putTxtRb(R.str, N);\n        continue;\n      }\n      const M = R.kan_ruby;\n      if (M) {\n        this.putTxtRb(R.kan, M);\n        continue;\n      }\n      if (R.ce) {\n        H(this, Vr).call(this, R.ce.slice(1), \"\");\n        continue;\n      }\n      Array.from((o = R.txt) != null ? o : \"\").forEach((D) => H(this, Vr).call(this, D, \"\"));\n    }\n  }\n  putTxtRb(t, e) {\n    const o = Array.from(t), R = o.length;\n    if (e.charAt(0) === \"*\" && e.length <= 2) {\n      const L = \"center\\uFF5C\" + (e === \"*\" ? H(di, Yi) : e.charAt(1));\n      for (let B = 0; B < R; ++B)\n        H(this, Vr).call(this, o[B], L);\n      return;\n    }\n    if (R === 1 || e.indexOf(\" \") === -1) {\n      H(this, Vr).call(this, t, e.replaceAll(\"\t\", \" \"));\n      return;\n    }\n    const N = e.split(\" \"), M = N.length, D = M > R ? M : R;\n    for (let L = 0; L < D; ++L)\n      H(this, Vr).call(this, L < R ? o[L] : \"\", L < M ? N[L].replaceAll(\"\t\", \" \") : \"\");\n  }\n};\nlet RubySpliter = di;\nYi = new WeakMap(), Vr = new WeakMap(), Sa = new WeakMap(), it(RubySpliter, Yi, \"\\u30FD\"), it(RubySpliter, Sa, void 0);\nconst REG_TAG = /(?<name>[^\\s;\\]]+)/;\nfunction tagToken2Name_Args(n) {\n  const t = REG_TAG.exec(n.slice(1, -1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${n}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  const o = e.name;\n  return [o, n.slice(1 + o.length, -1)];\n}\nfunction tagToken2Name(n) {\n  const t = REG_TAG.exec(n.slice(1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${n}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  return e.name;\n}\nfunction splitAmpersand(n) {\n  const t = n.replaceAll(\"==\", \"\\uFF1D\").replaceAll(\"!=\", \"\\u2260\").split(\"=\"), e = t.length;\n  if (e < 2 || e > 3)\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C=\\u300D\\u6307\\u5B9A\\u304C\\u4E00\\u3064\\u304B\\u4E8C\\u3064\\u5FC5\\u8981\\u3067\\u3059\";\n  if (t[1].charAt(0) === \"&\")\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  return {\n    name: t[0].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    text: t[1].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    cast: e === 3 ? t[2].trim() : void 0\n  };\n}\nvar qi, Wn, Yn, qn, $e;\nclass Grammar {\n  constructor() {\n    it(this, qi, void 0);\n    it(this, Wn, void 0);\n    it(this, Yn, void 0);\n    it(this, qn, void 0);\n    it(this, $e, void 0);\n    et(this, Wn, new RegExp(\"\")), et(this, Yn, \"\"), et(this, qn, \"\"), this.replaceScr_C2M_And_let_ml = (t, e = 0) => {\n      if (!!H(this, $e)) {\n        for (let o = t.len - 1; o >= e; --o) {\n          const R = t.aToken[o];\n          if (this.REG_TOKEN_NOTXT.test(R.charAt(0)))\n            continue;\n          const N = t.aLNum[o], M = R.match(H(this, Wn));\n          if (!M)\n            continue;\n          let D = 1;\n          for (let L = M.length - 1; L >= 0; --L) {\n            let B = M[L];\n            const $ = H(this, $e)[B.charAt(0)];\n            $ && (B = $ + ($.slice(-1) === \"]\" ? \"\" : `'${B.slice(1, -1)}']`)), t.aToken.splice(o, D, B), t.aLNum.splice(o, D, N), D = 0;\n          }\n        }\n        t.len = t.aToken.length;\n      }\n    }, this.setEscape(\"\");\n  }\n  setEscape(t) {\n    if (H(this, $e) && t in H(this, $e))\n      throw \"[\\u30A8\\u30B9\\u30B1\\u30FC\\u30D7\\u6587\\u5B57] char\\u3010\" + t + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    const e = t != null ? t : \"\\\\\";\n    this.REG_TOKEN = new RegExp(\n      (t ? `\\\\${t}\\\\S|` : \"\") + `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:[^\"'#;\\\\]]+|` + (e ? `(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)` : `([\"'#]).*?\\\\1`) + `|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^;\\\\n\\\\t&]+|^\\\\*\\\\w+|[^\\\\n\\\\t\\\\[;${t ? `\\\\${t}` : \"\"}]+`,\n      \"gs\"\n    ), RubySpliter.setEscape(t), et(this, qi, new RegExp(`[\\\\w\\\\s;[\\\\]*=&\\uFF5C\\u300A\\u300B${t ? `\\\\${t}` : \"\"}]`)), this.REG_TOKEN_NOTXT = new RegExp(`[\\\\n\\\\t;\\\\[*&${t ? `\\\\${t}` : \"\"}]`);\n  }\n  matchToken(t) {\n    var e;\n    return (e = t.match(this.REG_TOKEN)) != null ? e : [];\n  }\n  bracket2macro(t, e, o) {\n    var L;\n    const { name: R, text: N } = t;\n    if (!R)\n      throw \"[bracket2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!N)\n      throw \"[bracket2macro] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (N.length !== 2)\n      throw \"[bracket2macro] text\\u306F\\u62EC\\u5F27\\u306E\\u524D\\u5F8C\\u3092\\u793A\\u3059\\u4E8C\\u6587\\u5B57\\u3092\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\";\n    (L = H(this, $e)) != null || et(this, $e, {});\n    const M = N.charAt(0), D = N.charAt(1);\n    if (M in H(this, $e))\n      throw \"[bracket2macro] text\\u3010\" + M + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (D in H(this, $e))\n      throw \"[bracket2macro] text\\u3010\" + D + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (H(this, qi).test(M))\n      throw \"[bracket2macro] text\\u3010\" + M + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (H(this, qi).test(D))\n      throw \"[bracket2macro] text\\u3010\" + D + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    H(this, $e)[D] = \"0\", H(this, $e)[M] = `[${R} text=`, this.addC2M(`\\\\${M}[^\\\\${D}]*\\\\${D}`, `\\\\${M}\\\\${D}`), this.replaceScr_C2M_And_let_ml(e, o);\n  }\n  char2macro(t, e, o, R) {\n    var D;\n    const { char: N, name: M } = t;\n    if (!N)\n      throw \"[char2macro] char\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if ((D = H(this, $e)) != null || et(this, $e, {}), N in H(this, $e))\n      throw \"[char2macro] char\\u3010\" + N + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (H(this, qi).test(N))\n      throw \"[char2macro] char\\u3010\" + N + \"\\u3011\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (!M)\n      throw \"[char2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!(M in e))\n      throw `[char2macro] \\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u53C8\\u306F\\u30DE\\u30AF\\u30ED[${M}]\\u3067\\u3059`;\n    H(this, $e)[N] = `[${M}]`, this.addC2M(`\\\\${N}`, `\\\\${N}`), this.replaceScr_C2M_And_let_ml(o, R);\n  }\n  addC2M(t, e) {\n    et(this, Yn, H(this, Yn) + `${t}|`), et(this, qn, H(this, qn) + `${e}`), et(this, Wn, new RegExp(\n      `(${H(this, Yn)}[^${H(this, qn)}]+)`,\n      \"g\"\n    ));\n  }\n}\nqi = new WeakMap(), Wn = new WeakMap(), Yn = new WeakMap(), qn = new WeakMap(), $e = new WeakMap();\nvar su, Zi, Zn;\nclass AnalyzeTagArg {\n  constructor() {\n    it(this, su, /;[^\\n]*|(?<key>\\w+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    it(this, Zi, {});\n    it(this, Zn, !1);\n  }\n  go(t) {\n    var o, R;\n    if (et(this, Zi, {}), et(this, Zn, !1), !t)\n      return;\n    let e = null;\n    for (; e = H(this, su).exec(t); ) {\n      const N = e == null ? void 0 : e.groups;\n      !N || (N.key ? H(this, Zi)[N.key] = {\n        val: (o = N.val) != null ? o : N.val2,\n        def: (R = N.def) != null ? R : N.def2\n      } : N.literal && (N.literal === \"*\" ? et(this, Zn, !0) : H(this, Zi)[N.literal] = { val: \"1\" }));\n    }\n  }\n  get hPrm() {\n    return H(this, Zi);\n  }\n  get isKomeParam() {\n    return H(this, Zn);\n  }\n}\nsu = new WeakMap(), Zi = new WeakMap(), Zn = new WeakMap();\nvar parsimmon_umd_min = { exports: {} };\n(function(n, t) {\n  (function(e, o) {\n    n.exports = o();\n  })(typeof self < \"u\" ? self : commonjsGlobal$1, function() {\n    return function(e) {\n      var o = {};\n      function R(N) {\n        if (o[N])\n          return o[N].exports;\n        var M = o[N] = { i: N, l: !1, exports: {} };\n        return e[N].call(M.exports, M, M.exports, R), M.l = !0, M.exports;\n      }\n      return R.m = e, R.c = o, R.d = function(N, M, D) {\n        R.o(N, M) || Object.defineProperty(N, M, { configurable: !1, enumerable: !0, get: D });\n      }, R.r = function(N) {\n        Object.defineProperty(N, \"__esModule\", { value: !0 });\n      }, R.n = function(N) {\n        var M = N && N.__esModule ? function() {\n          return N.default;\n        } : function() {\n          return N;\n        };\n        return R.d(M, \"a\", M), M;\n      }, R.o = function(N, M) {\n        return Object.prototype.hasOwnProperty.call(N, M);\n      }, R.p = \"\", R(R.s = 0);\n    }([function(e, o, R) {\n      function N(ot) {\n        if (!(this instanceof N))\n          return new N(ot);\n        this._ = ot;\n      }\n      var M = N.prototype;\n      function D(ot, ft) {\n        for (var yt = 0; yt < ot; yt++)\n          ft(yt);\n      }\n      function L(ot, ft, yt) {\n        return function(It, Nt) {\n          D(Nt.length, function(Dt) {\n            It(Nt[Dt], Dt, Nt);\n          });\n        }(function(It, Nt, Dt) {\n          ft = ot(ft, It, Nt, Dt);\n        }, yt), ft;\n      }\n      function B(ot, ft) {\n        return L(function(yt, It, Nt, Dt) {\n          return yt.concat([ot(It, Nt, Dt)]);\n        }, [], ft);\n      }\n      function $(ot, ft) {\n        var yt = { v: 0, buf: ft };\n        return D(ot, function() {\n          var It;\n          yt = { v: yt.v << 1 | (It = yt.buf, It[0] >> 7), buf: function(Nt) {\n            var Dt = L(function(Bt, Wt, pe, Be) {\n              return Bt.concat(pe === Be.length - 1 ? Buffer.from([Wt, 0]).readUInt16BE(0) : Be.readUInt16BE(pe));\n            }, [], Nt);\n            return Buffer.from(B(function(Bt) {\n              return (Bt << 1 & 65535) >> 8;\n            }, Dt));\n          }(yt.buf) };\n        }), yt;\n      }\n      function k() {\n        return typeof Buffer < \"u\";\n      }\n      function U() {\n        if (!k())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function z(ot) {\n        U();\n        var ft = L(function(Dt, Bt) {\n          return Dt + Bt;\n        }, 0, ot);\n        if (ft % 8 != 0)\n          throw new Error(\"The bits [\" + ot.join(\", \") + \"] add up to \" + ft + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var yt, It = ft / 8, Nt = (yt = function(Dt) {\n          return Dt > 48;\n        }, L(function(Dt, Bt) {\n          return Dt || (yt(Bt) ? Bt : Dt);\n        }, null, ot));\n        if (Nt)\n          throw new Error(Nt + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new N(function(Dt, Bt) {\n          var Wt = It + Bt;\n          return Wt > Dt.length ? tt(Bt, It.toString() + \" bytes\") : rt(Wt, L(function(pe, Be) {\n            var Oe = $(Be, pe.buf);\n            return { coll: pe.coll.concat(Oe.v), buf: Oe.buf };\n          }, { coll: [], buf: Dt.slice(Bt, Wt) }, ot).coll);\n        });\n      }\n      function X(ot, ft) {\n        return new N(function(yt, It) {\n          return U(), It + ft > yt.length ? tt(It, ft + \" bytes for \" + ot) : rt(It + ft, yt.slice(It, It + ft));\n        });\n      }\n      function V(ot, ft) {\n        if (typeof (yt = ft) != \"number\" || Math.floor(yt) !== yt || ft < 0 || ft > 6)\n          throw new Error(ot + \" requires integer length in range [0, 6].\");\n        var yt;\n      }\n      function W(ot) {\n        return V(\"uintBE\", ot), X(\"uintBE(\" + ot + \")\", ot).map(function(ft) {\n          return ft.readUIntBE(0, ot);\n        });\n      }\n      function Y(ot) {\n        return V(\"uintLE\", ot), X(\"uintLE(\" + ot + \")\", ot).map(function(ft) {\n          return ft.readUIntLE(0, ot);\n        });\n      }\n      function q(ot) {\n        return V(\"intBE\", ot), X(\"intBE(\" + ot + \")\", ot).map(function(ft) {\n          return ft.readIntBE(0, ot);\n        });\n      }\n      function Z(ot) {\n        return V(\"intLE\", ot), X(\"intLE(\" + ot + \")\", ot).map(function(ft) {\n          return ft.readIntLE(0, ot);\n        });\n      }\n      function K(ot) {\n        return ot instanceof N;\n      }\n      function Q(ot) {\n        return {}.toString.call(ot) === \"[object Array]\";\n      }\n      function J(ot) {\n        return k() && Buffer.isBuffer(ot);\n      }\n      function rt(ot, ft) {\n        return { status: !0, index: ot, value: ft, furthest: -1, expected: [] };\n      }\n      function tt(ot, ft) {\n        return Q(ft) || (ft = [ft]), { status: !1, index: -1, value: null, furthest: ot, expected: ft };\n      }\n      function nt(ot, ft) {\n        if (!ft || ot.furthest > ft.furthest)\n          return ot;\n        var yt = ot.furthest === ft.furthest ? function(It, Nt) {\n          if (function() {\n            if (N._supportsSet !== void 0)\n              return N._supportsSet;\n            var jr = typeof Set < \"u\";\n            return N._supportsSet = jr, jr;\n          }() && Array.from) {\n            for (var Dt = new Set(It), Bt = 0; Bt < Nt.length; Bt++)\n              Dt.add(Nt[Bt]);\n            var Wt = Array.from(Dt);\n            return Wt.sort(), Wt;\n          }\n          for (var pe = {}, Be = 0; Be < It.length; Be++)\n            pe[It[Be]] = !0;\n          for (var Oe = 0; Oe < Nt.length; Oe++)\n            pe[Nt[Oe]] = !0;\n          var zr = [];\n          for (var Ke in pe)\n            ({}).hasOwnProperty.call(pe, Ke) && zr.push(Ke);\n          return zr.sort(), zr;\n        }(ot.expected, ft.expected) : ft.expected;\n        return { status: ot.status, index: ot.index, value: ot.value, furthest: ft.furthest, expected: yt };\n      }\n      var st = {};\n      function ut(ot, ft) {\n        if (J(ot))\n          return { offset: ft, line: -1, column: -1 };\n        ot in st || (st[ot] = {});\n        for (var yt = st[ot], It = 0, Nt = 0, Dt = 0, Bt = ft; Bt >= 0; ) {\n          if (Bt in yt) {\n            It = yt[Bt].line, Dt === 0 && (Dt = yt[Bt].lineStart);\n            break;\n          }\n          (ot.charAt(Bt) === `\n` || ot.charAt(Bt) === \"\\r\" && ot.charAt(Bt + 1) !== `\n`) && (Nt++, Dt === 0 && (Dt = Bt + 1)), Bt--;\n        }\n        var Wt = It + Nt, pe = ft - Dt;\n        return yt[ft] = { line: Wt, lineStart: Dt }, { offset: ft, line: Wt + 1, column: pe + 1 };\n      }\n      function ct(ot) {\n        if (!K(ot))\n          throw new Error(\"not a parser: \" + ot);\n      }\n      function dt(ot, ft) {\n        return typeof ot == \"string\" ? ot.charAt(ft) : ot[ft];\n      }\n      function Et(ot) {\n        if (typeof ot != \"number\")\n          throw new Error(\"not a number: \" + ot);\n      }\n      function vt(ot) {\n        if (typeof ot != \"function\")\n          throw new Error(\"not a function: \" + ot);\n      }\n      function _t(ot) {\n        if (typeof ot != \"string\")\n          throw new Error(\"not a string: \" + ot);\n      }\n      var St = 2, Ft = 3, mt = 8, ht = 5 * mt, pt = 4 * mt, xt = \"  \";\n      function At(ot, ft) {\n        return new Array(ft + 1).join(ot);\n      }\n      function Rt(ot, ft, yt) {\n        var It = ft - ot.length;\n        return It <= 0 ? ot : At(yt, It) + ot;\n      }\n      function Lt(ot, ft, yt, It) {\n        return { from: ot - ft > 0 ? ot - ft : 0, to: ot + yt > It ? It : ot + yt };\n      }\n      function lt(ot, ft) {\n        var yt, It, Nt, Dt, Bt, Wt = ft.index, pe = Wt.offset, Be = 1;\n        if (pe === ot.length)\n          return \"Got the end of the input\";\n        if (J(ot)) {\n          var Oe = pe - pe % mt, zr = pe - Oe, Ke = Lt(Oe, ht, pt + mt, ot.length), jr = B(function(we) {\n            return B(function(Dn) {\n              return Rt(Dn.toString(16), 2, \"0\");\n            }, we);\n          }, function(we, Dn) {\n            var Ln = we.length, ji = [], Fn = 0;\n            if (Ln <= Dn)\n              return [we.slice()];\n            for (var Bn = 0; Bn < Ln; Bn++)\n              ji[Fn] || ji.push([]), ji[Fn].push(we[Bn]), (Bn + 1) % Dn == 0 && Fn++;\n            return ji;\n          }(ot.slice(Ke.from, Ke.to).toJSON().data, mt));\n          Dt = function(we) {\n            return we.from === 0 && we.to === 1 ? { from: we.from, to: we.to } : { from: we.from / mt, to: Math.floor(we.to / mt) };\n          }(Ke), It = Oe / mt, yt = 3 * zr, zr >= 4 && (yt += 1), Be = 2, Nt = B(function(we) {\n            return we.length <= 4 ? we.join(\" \") : we.slice(0, 4).join(\" \") + \"  \" + we.slice(4).join(\" \");\n          }, jr), (Bt = (8 * (Dt.to > 0 ? Dt.to - 1 : Dt.to)).toString(16).length) < 2 && (Bt = 2);\n        } else {\n          var Mn = ot.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          yt = Wt.column - 1, It = Wt.line - 1, Dt = Lt(It, St, Ft, Mn.length), Nt = Mn.slice(Dt.from, Dt.to), Bt = Dt.to.toString().length;\n        }\n        var Pf = It - Dt.from;\n        return J(ot) && (Bt = (8 * (Dt.to > 0 ? Dt.to - 1 : Dt.to)).toString(16).length) < 2 && (Bt = 2), L(function(we, Dn, Ln) {\n          var ji, Fn = Ln === Pf, Bn = Fn ? \"> \" : xt;\n          return ji = J(ot) ? Rt((8 * (Dt.from + Ln)).toString(16), Bt, \"0\") : Rt((Dt.from + Ln + 1).toString(), Bt, \" \"), [].concat(we, [Bn + ji + \" | \" + Dn], Fn ? [xt + At(\" \", Bt) + \" | \" + Rt(\"\", yt, \" \") + At(\"^\", Be)] : []);\n        }, [], Nt).join(`\n`);\n      }\n      function $t(ot, ft) {\n        return [`\n`, \"-- PARSING FAILED \" + At(\"-\", 50), `\n\n`, lt(ot, ft), `\n\n`, (yt = ft.expected, yt.length === 1 ? `Expected:\n\n` + yt[0] : `Expected one of the following: \n\n` + yt.join(\", \")), `\n`].join(\"\");\n        var yt;\n      }\n      function Pt(ot) {\n        return ot.flags !== void 0 ? ot.flags : [ot.global ? \"g\" : \"\", ot.ignoreCase ? \"i\" : \"\", ot.multiline ? \"m\" : \"\", ot.unicode ? \"u\" : \"\", ot.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function kt() {\n        for (var ot = [].slice.call(arguments), ft = ot.length, yt = 0; yt < ft; yt += 1)\n          ct(ot[yt]);\n        return N(function(It, Nt) {\n          for (var Dt, Bt = new Array(ft), Wt = 0; Wt < ft; Wt += 1) {\n            if (!(Dt = nt(ot[Wt]._(It, Nt), Dt)).status)\n              return Dt;\n            Bt[Wt] = Dt.value, Nt = Dt.index;\n          }\n          return nt(rt(Nt, Bt), Dt);\n        });\n      }\n      function Ot() {\n        var ot = [].slice.call(arguments);\n        if (ot.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var ft = ot.pop();\n        return vt(ft), kt.apply(null, ot).map(function(yt) {\n          return ft.apply(null, yt);\n        });\n      }\n      function gt() {\n        var ot = [].slice.call(arguments), ft = ot.length;\n        if (ft === 0)\n          return Ct(\"zero alternates\");\n        for (var yt = 0; yt < ft; yt += 1)\n          ct(ot[yt]);\n        return N(function(It, Nt) {\n          for (var Dt, Bt = 0; Bt < ot.length; Bt += 1)\n            if ((Dt = nt(ot[Bt]._(It, Nt), Dt)).status)\n              return Dt;\n          return Dt;\n        });\n      }\n      function Gt(ot, ft) {\n        return Tt(ot, ft).or(Mt([]));\n      }\n      function Tt(ot, ft) {\n        return ct(ot), ct(ft), Ot(ot, ft.then(ot).many(), function(yt, It) {\n          return [yt].concat(It);\n        });\n      }\n      function bt(ot) {\n        _t(ot);\n        var ft = \"'\" + ot + \"'\";\n        return N(function(yt, It) {\n          var Nt = It + ot.length, Dt = yt.slice(It, Nt);\n          return Dt === ot ? rt(Nt, Dt) : tt(It, ft);\n        });\n      }\n      function wt(ot, ft) {\n        (function(Nt) {\n          if (!(Nt instanceof RegExp))\n            throw new Error(\"not a regexp: \" + Nt);\n          for (var Dt = Pt(Nt), Bt = 0; Bt < Dt.length; Bt++) {\n            var Wt = Dt.charAt(Bt);\n            if (Wt !== \"i\" && Wt !== \"m\" && Wt !== \"u\" && Wt !== \"s\")\n              throw new Error('unsupported regexp flag \"' + Wt + '\": ' + Nt);\n          }\n        })(ot), arguments.length >= 2 ? Et(ft) : ft = 0;\n        var yt = function(Nt) {\n          return RegExp(\"^(?:\" + Nt.source + \")\", Pt(Nt));\n        }(ot), It = \"\" + ot;\n        return N(function(Nt, Dt) {\n          var Bt = yt.exec(Nt.slice(Dt));\n          if (Bt) {\n            if (0 <= ft && ft <= Bt.length) {\n              var Wt = Bt[0], pe = Bt[ft];\n              return rt(Dt + Wt.length, pe);\n            }\n            return tt(Dt, \"valid match group (0 to \" + Bt.length + \") in \" + It);\n          }\n          return tt(Dt, It);\n        });\n      }\n      function Mt(ot) {\n        return N(function(ft, yt) {\n          return rt(yt, ot);\n        });\n      }\n      function Ct(ot) {\n        return N(function(ft, yt) {\n          return tt(yt, ot);\n        });\n      }\n      function Zt(ot) {\n        if (K(ot))\n          return N(function(ft, yt) {\n            var It = ot._(ft, yt);\n            return It.index = yt, It.value = \"\", It;\n          });\n        if (typeof ot == \"string\")\n          return Zt(bt(ot));\n        if (ot instanceof RegExp)\n          return Zt(wt(ot));\n        throw new Error(\"not a string, regexp, or parser: \" + ot);\n      }\n      function Yt(ot) {\n        return ct(ot), N(function(ft, yt) {\n          var It = ot._(ft, yt), Nt = ft.slice(yt, It.index);\n          return It.status ? tt(yt, 'not \"' + Nt + '\"') : rt(yt, null);\n        });\n      }\n      function se(ot) {\n        return vt(ot), N(function(ft, yt) {\n          var It = dt(ft, yt);\n          return yt < ft.length && ot(It) ? rt(yt + 1, It) : tt(yt, \"a character/byte matching \" + ot);\n        });\n      }\n      function ie(ot, ft) {\n        arguments.length < 2 && (ft = ot, ot = void 0);\n        var yt = N(function(It, Nt) {\n          return yt._ = ft()._, yt._(It, Nt);\n        });\n        return ot ? yt.desc(ot) : yt;\n      }\n      function Te() {\n        return Ct(\"fantasy-land/empty\");\n      }\n      M.parse = function(ot) {\n        if (typeof ot != \"string\" && !J(ot))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var ft, yt = this.skip(de)._(ot, 0);\n        return ft = yt.status ? { status: !0, value: yt.value } : { status: !1, index: ut(ot, yt.furthest), expected: yt.expected }, delete st[ot], ft;\n      }, M.tryParse = function(ot) {\n        var ft = this.parse(ot);\n        if (ft.status)\n          return ft.value;\n        var yt = $t(ot, ft), It = new Error(yt);\n        throw It.type = \"ParsimmonError\", It.result = ft, It;\n      }, M.assert = function(ot, ft) {\n        return this.chain(function(yt) {\n          return ot(yt) ? Mt(yt) : Ct(ft);\n        });\n      }, M.or = function(ot) {\n        return gt(this, ot);\n      }, M.trim = function(ot) {\n        return this.wrap(ot, ot);\n      }, M.wrap = function(ot, ft) {\n        return Ot(ot, this, ft, function(yt, It) {\n          return It;\n        });\n      }, M.thru = function(ot) {\n        return ot(this);\n      }, M.then = function(ot) {\n        return ct(ot), kt(this, ot).map(function(ft) {\n          return ft[1];\n        });\n      }, M.many = function() {\n        var ot = this;\n        return N(function(ft, yt) {\n          for (var It = [], Nt = void 0; ; ) {\n            if (!(Nt = nt(ot._(ft, yt), Nt)).status)\n              return nt(rt(yt, It), Nt);\n            if (yt === Nt.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            yt = Nt.index, It.push(Nt.value);\n          }\n        });\n      }, M.tieWith = function(ot) {\n        return _t(ot), this.map(function(ft) {\n          if (function(Nt) {\n            if (!Q(Nt))\n              throw new Error(\"not an array: \" + Nt);\n          }(ft), ft.length) {\n            _t(ft[0]);\n            for (var yt = ft[0], It = 1; It < ft.length; It++)\n              _t(ft[It]), yt += ot + ft[It];\n            return yt;\n          }\n          return \"\";\n        });\n      }, M.tie = function() {\n        return this.tieWith(\"\");\n      }, M.times = function(ot, ft) {\n        var yt = this;\n        return arguments.length < 2 && (ft = ot), Et(ot), Et(ft), N(function(It, Nt) {\n          for (var Dt = [], Bt = void 0, Wt = void 0, pe = 0; pe < ot; pe += 1) {\n            if (Wt = nt(Bt = yt._(It, Nt), Wt), !Bt.status)\n              return Wt;\n            Nt = Bt.index, Dt.push(Bt.value);\n          }\n          for (; pe < ft && (Wt = nt(Bt = yt._(It, Nt), Wt), Bt.status); pe += 1)\n            Nt = Bt.index, Dt.push(Bt.value);\n          return nt(rt(Nt, Dt), Wt);\n        });\n      }, M.result = function(ot) {\n        return this.map(function() {\n          return ot;\n        });\n      }, M.atMost = function(ot) {\n        return this.times(0, ot);\n      }, M.atLeast = function(ot) {\n        return Ot(this.times(ot), this.many(), function(ft, yt) {\n          return ft.concat(yt);\n        });\n      }, M.map = function(ot) {\n        vt(ot);\n        var ft = this;\n        return N(function(yt, It) {\n          var Nt = ft._(yt, It);\n          return Nt.status ? nt(rt(Nt.index, ot(Nt.value)), Nt) : Nt;\n        });\n      }, M.contramap = function(ot) {\n        vt(ot);\n        var ft = this;\n        return N(function(yt, It) {\n          var Nt = ft.parse(ot(yt.slice(It)));\n          return Nt.status ? rt(It + yt.length, Nt.value) : Nt;\n        });\n      }, M.promap = function(ot, ft) {\n        return vt(ot), vt(ft), this.contramap(ot).map(ft);\n      }, M.skip = function(ot) {\n        return kt(this, ot).map(function(ft) {\n          return ft[0];\n        });\n      }, M.mark = function() {\n        return Ot(ge, this, ge, function(ot, ft, yt) {\n          return { start: ot, value: ft, end: yt };\n        });\n      }, M.node = function(ot) {\n        return Ot(ge, this, ge, function(ft, yt, It) {\n          return { name: ot, value: yt, start: ft, end: It };\n        });\n      }, M.sepBy = function(ot) {\n        return Gt(this, ot);\n      }, M.sepBy1 = function(ot) {\n        return Tt(this, ot);\n      }, M.lookahead = function(ot) {\n        return this.skip(Zt(ot));\n      }, M.notFollowedBy = function(ot) {\n        return this.skip(Yt(ot));\n      }, M.desc = function(ot) {\n        Q(ot) || (ot = [ot]);\n        var ft = this;\n        return N(function(yt, It) {\n          var Nt = ft._(yt, It);\n          return Nt.status || (Nt.expected = ot), Nt;\n        });\n      }, M.fallback = function(ot) {\n        return this.or(Mt(ot));\n      }, M.ap = function(ot) {\n        return Ot(ot, this, function(ft, yt) {\n          return ft(yt);\n        });\n      }, M.chain = function(ot) {\n        var ft = this;\n        return N(function(yt, It) {\n          var Nt = ft._(yt, It);\n          return Nt.status ? nt(ot(Nt.value)._(yt, Nt.index), Nt) : Nt;\n        });\n      }, M.concat = M.or, M.empty = Te, M.of = Mt, M[\"fantasy-land/ap\"] = M.ap, M[\"fantasy-land/chain\"] = M.chain, M[\"fantasy-land/concat\"] = M.concat, M[\"fantasy-land/empty\"] = M.empty, M[\"fantasy-land/of\"] = M.of, M[\"fantasy-land/map\"] = M.map;\n      var ge = N(function(ot, ft) {\n        return rt(ft, ut(ot, ft));\n      }), Fe = N(function(ot, ft) {\n        return ft >= ot.length ? tt(ft, \"any character/byte\") : rt(ft + 1, dt(ot, ft));\n      }), xe = N(function(ot, ft) {\n        return rt(ot.length, ot.slice(ft));\n      }), de = N(function(ot, ft) {\n        return ft < ot.length ? tt(ft, \"EOF\") : rt(ft, null);\n      }), ae = wt(/[0-9]/).desc(\"a digit\"), Jt = wt(/[0-9]*/).desc(\"optional digits\"), Pe = wt(/[a-z]/i).desc(\"a letter\"), ha = wt(/[a-z]*/i).desc(\"optional letters\"), Jl = wt(/\\s*/).desc(\"optional whitespace\"), Bo = wt(/\\s+/).desc(\"whitespace\"), ca = bt(\"\\r\"), $o = bt(`\n`), ko = bt(`\\r\n`), Go = gt(ko, $o, ca).desc(\"newline\"), fa = gt(Go, de);\n      N.all = xe, N.alt = gt, N.any = Fe, N.cr = ca, N.createLanguage = function(ot) {\n        var ft = {};\n        for (var yt in ot)\n          ({}).hasOwnProperty.call(ot, yt) && function(It) {\n            ft[It] = ie(function() {\n              return ot[It](ft);\n            });\n          }(yt);\n        return ft;\n      }, N.crlf = ko, N.custom = function(ot) {\n        return N(ot(rt, tt));\n      }, N.digit = ae, N.digits = Jt, N.empty = Te, N.end = fa, N.eof = de, N.fail = Ct, N.formatError = $t, N.index = ge, N.isParser = K, N.lazy = ie, N.letter = Pe, N.letters = ha, N.lf = $o, N.lookahead = Zt, N.makeFailure = tt, N.makeSuccess = rt, N.newline = Go, N.noneOf = function(ot) {\n        return se(function(ft) {\n          return ot.indexOf(ft) < 0;\n        }).desc(\"none of '\" + ot + \"'\");\n      }, N.notFollowedBy = Yt, N.of = Mt, N.oneOf = function(ot) {\n        for (var ft = ot.split(\"\"), yt = 0; yt < ft.length; yt++)\n          ft[yt] = \"'\" + ft[yt] + \"'\";\n        return se(function(It) {\n          return ot.indexOf(It) >= 0;\n        }).desc(ft);\n      }, N.optWhitespace = Jl, N.Parser = N, N.range = function(ot, ft) {\n        return se(function(yt) {\n          return ot <= yt && yt <= ft;\n        }).desc(ot + \"-\" + ft);\n      }, N.regex = wt, N.regexp = wt, N.sepBy = Gt, N.sepBy1 = Tt, N.seq = kt, N.seqMap = Ot, N.seqObj = function() {\n        for (var ot, ft = {}, yt = 0, It = (ot = arguments, Array.prototype.slice.call(ot)), Nt = It.length, Dt = 0; Dt < Nt; Dt += 1) {\n          var Bt = It[Dt];\n          if (!K(Bt)) {\n            if (Q(Bt) && Bt.length === 2 && typeof Bt[0] == \"string\" && K(Bt[1])) {\n              var Wt = Bt[0];\n              if (Object.prototype.hasOwnProperty.call(ft, Wt))\n                throw new Error(\"seqObj: duplicate key \" + Wt);\n              ft[Wt] = !0, yt++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (yt === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return N(function(pe, Be) {\n          for (var Oe, zr = {}, Ke = 0; Ke < Nt; Ke += 1) {\n            var jr, Mn;\n            if (Q(It[Ke]) ? (jr = It[Ke][0], Mn = It[Ke][1]) : (jr = null, Mn = It[Ke]), !(Oe = nt(Mn._(pe, Be), Oe)).status)\n              return Oe;\n            jr && (zr[jr] = Oe.value), Be = Oe.index;\n          }\n          return nt(rt(Be, zr), Oe);\n        });\n      }, N.string = bt, N.succeed = Mt, N.takeWhile = function(ot) {\n        return vt(ot), N(function(ft, yt) {\n          for (var It = yt; It < ft.length && ot(dt(ft, It)); )\n            It++;\n          return rt(It, ft.slice(yt, It));\n        });\n      }, N.test = se, N.whitespace = Bo, N[\"fantasy-land/empty\"] = Te, N[\"fantasy-land/of\"] = Mt, N.Binary = { bitSeq: z, bitSeqObj: function(ot) {\n        U();\n        var ft = {}, yt = 0, It = B(function(Dt) {\n          if (Q(Dt)) {\n            var Bt = Dt;\n            if (Bt.length !== 2)\n              throw new Error(\"[\" + Bt.join(\", \") + \"] should be length 2, got length \" + Bt.length);\n            if (_t(Bt[0]), Et(Bt[1]), Object.prototype.hasOwnProperty.call(ft, Bt[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + Bt[0]);\n            return ft[Bt[0]] = !0, yt++, Bt;\n          }\n          return Et(Dt), [null, Dt];\n        }, ot);\n        if (yt < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + ot.join(\", \") + \"]\");\n        var Nt = B(function(Dt) {\n          return Dt[0];\n        }, It);\n        return z(B(function(Dt) {\n          return Dt[1];\n        }, It)).map(function(Dt) {\n          return L(function(Bt, Wt) {\n            return Wt[0] !== null && (Bt[Wt[0]] = Wt[1]), Bt;\n          }, {}, B(function(Bt, Wt) {\n            return [Bt, Dt[Wt]];\n          }, Nt));\n        });\n      }, byte: function(ot) {\n        if (U(), Et(ot), ot > 255)\n          throw new Error(\"Value specified to byte constructor (\" + ot + \"=0x\" + ot.toString(16) + \") is larger in value than a single byte.\");\n        var ft = (ot > 15 ? \"0x\" : \"0x0\") + ot.toString(16);\n        return N(function(yt, It) {\n          var Nt = dt(yt, It);\n          return Nt === ot ? rt(It + 1, Nt) : tt(It, ft);\n        });\n      }, buffer: function(ot) {\n        return X(\"buffer\", ot).map(function(ft) {\n          return Buffer.from(ft);\n        });\n      }, encodedString: function(ot, ft) {\n        return X(\"string\", ft).map(function(yt) {\n          return yt.toString(ot);\n        });\n      }, uintBE: W, uint8BE: W(1), uint16BE: W(2), uint32BE: W(4), uintLE: Y, uint8LE: Y(1), uint16LE: Y(2), uint32LE: Y(4), intBE: q, int8BE: q(1), int16BE: q(2), int32BE: q(4), intLE: Z, int8LE: Z(1), int16LE: Z(2), int32LE: Z(4), floatBE: X(\"floatBE\", 4).map(function(ot) {\n        return ot.readFloatBE(0);\n      }), floatLE: X(\"floatLE\", 4).map(function(ot) {\n        return ot.readFloatLE(0);\n      }), doubleBE: X(\"doubleBE\", 8).map(function(ot) {\n        return ot.readDoubleBE(0);\n      }), doubleLE: X(\"doubleLE\", 8).map(function(ot) {\n        return ot.readDoubleLE(0);\n      }) }, e.exports = N;\n    }]);\n  });\n})(parsimmon_umd_min);\nvar pi, zt, jt, Xr, vi, $n, Ca, Ia, th, au, ou, Gh;\nconst Dh = class {\n  constructor(t, e = \"\\\\\") {\n    it(this, zt);\n    it(this, vi);\n    it(this, Ia);\n    it(this, pi, void 0);\n    it(this, Xr, void 0);\n    it(this, Ca, void 0);\n    this.val = t, et(this, pi, null), et(this, Xr, {\n      \"!num!\": (W) => W.shift(),\n      \"!str!\": (W) => at(this, Ia, th).call(this, W.shift()),\n      \"!bool!\": (W) => W.shift(),\n      \"!\": (W) => {\n        const Y = W.shift();\n        return Y[0] === \"!bool!\" ? !Boolean(Y[1]) : String(at(this, zt, jt).call(this, Y)) !== \"true\";\n      },\n      \"~\": (W) => ~Number(at(this, zt, jt).call(this, W.shift())),\n      \"**\": (W) => Number(at(this, zt, jt).call(this, W.shift())) ** Number(at(this, zt, jt).call(this, W.shift())),\n      \"*\": (W) => Number(at(this, zt, jt).call(this, W.shift())) * Number(at(this, zt, jt).call(this, W.shift())),\n      \"/\": (W) => Number(at(this, zt, jt).call(this, W.shift())) / Number(at(this, zt, jt).call(this, W.shift())),\n      \"\\xA5\": (W) => Math.floor(H(this, Xr)[\"/\"](W)),\n      \"%\": (W) => Number(at(this, zt, jt).call(this, W.shift())) % Number(at(this, zt, jt).call(this, W.shift())),\n      \"+\": (W) => {\n        const Y = at(this, zt, jt).call(this, W.shift()), q = at(this, zt, jt).call(this, W.shift());\n        return Object.prototype.toString.call(Y) === \"[object String]\" || Object.prototype.toString.call(q) === \"[object String]\" ? String(Y) + String(q) : Number(Y) + Number(q);\n      },\n      \"-\": (W) => Number(at(this, zt, jt).call(this, W.shift())) - Number(at(this, zt, jt).call(this, W.shift())),\n      int: (W) => int(at(this, vi, $n).call(this, W.shift())),\n      parseInt: (W) => int(H(this, Xr).Number(W)),\n      Number: (W) => {\n        const Y = at(this, zt, jt).call(this, W.shift());\n        return Object.prototype.toString.call(Y) !== \"[object String]\" ? Number(Y) : at(this, vi, $n).call(this, H(this, pi).parse(String(Y)).value);\n      },\n      ceil: (W) => Math.ceil(at(this, vi, $n).call(this, W.shift())),\n      floor: (W) => Math.floor(at(this, vi, $n).call(this, W.shift())),\n      round: (W) => Math.round(at(this, vi, $n).call(this, W.shift())),\n      isNaN: (W) => isNaN(Number(at(this, zt, jt).call(this, W.shift()))),\n      \"<<\": (W) => Number(at(this, zt, jt).call(this, W.shift())) << Number(at(this, zt, jt).call(this, W.shift())),\n      \">>\": (W) => Number(at(this, zt, jt).call(this, W.shift())) >> Number(at(this, zt, jt).call(this, W.shift())),\n      \">>>\": (W) => Number(at(this, zt, jt).call(this, W.shift())) >>> Number(at(this, zt, jt).call(this, W.shift())),\n      \"<\": (W) => Number(at(this, zt, jt).call(this, W.shift())) < Number(at(this, zt, jt).call(this, W.shift())),\n      \"<=\": (W) => Number(at(this, zt, jt).call(this, W.shift())) <= Number(at(this, zt, jt).call(this, W.shift())),\n      \">\": (W) => Number(at(this, zt, jt).call(this, W.shift())) > Number(at(this, zt, jt).call(this, W.shift())),\n      \">=\": (W) => Number(at(this, zt, jt).call(this, W.shift())) >= Number(at(this, zt, jt).call(this, W.shift())),\n      \"==\": (W) => {\n        const Y = at(this, zt, jt).call(this, W.shift()), q = at(this, zt, jt).call(this, W.shift());\n        return Y == null && q == null && (!Y || !q) ? Y == q : String(Y) === String(q);\n      },\n      \"!=\": (W) => !H(this, Xr)[\"==\"](W),\n      \"===\": (W) => {\n        const Y = at(this, zt, jt).call(this, W.shift()), q = at(this, zt, jt).call(this, W.shift());\n        return Object.prototype.toString.call(Y) != Object.prototype.toString.call(q) ? !1 : String(Y) === String(q);\n      },\n      \"!==\": (W) => !H(this, Xr)[\"===\"](W),\n      \"&\": (W) => Number(at(this, zt, jt).call(this, W.shift())) & Number(at(this, zt, jt).call(this, W.shift())),\n      \"^\": (W) => Number(at(this, zt, jt).call(this, W.shift())) ^ Number(at(this, zt, jt).call(this, W.shift())),\n      \"|\": (W) => Number(at(this, zt, jt).call(this, W.shift())) | Number(at(this, zt, jt).call(this, W.shift())),\n      \"&&\": (W) => String(at(this, zt, jt).call(this, W.shift())) === \"true\" && String(at(this, zt, jt).call(this, W.shift())) === \"true\",\n      \"||\": (W) => String(at(this, zt, jt).call(this, W.shift())) === \"true\" || String(at(this, zt, jt).call(this, W.shift())) === \"true\",\n      \"?\": (W) => {\n        const Y = W.shift();\n        let q = !1;\n        if (Y[0] === \"!bool!\")\n          q = Boolean(Y[1]);\n        else {\n          const K = String(at(this, zt, jt).call(this, Y));\n          q = K !== \"true\" && K !== \"false\" ? int(K) !== 0 : K === \"true\";\n        }\n        const Z = W.shift();\n        if (Z[0] !== \":\")\n          throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002: \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n        return at(this, zt, jt).call(this, Z[q ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002? \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n      }\n    }), et(this, Ca, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g), this.getValAmpersand = (W) => W.charAt(0) === \"&\" ? String(this.parse(W.slice(1))) : W;\n    function o(W) {\n      const Y = [];\n      return W.forEach((q) => Y.push(\n        (q instanceof RegExp ? parsimmon_umd_min.exports.regex(q) : parsimmon_umd_min.exports.string(q)).trim(parsimmon_umd_min.exports.optWhitespace)\n      )), parsimmon_umd_min.exports.alt.apply(null, Y);\n    }\n    function R(W, Y) {\n      const q = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(W, q).or(Y));\n      return q;\n    }\n    function N(W, Y) {\n      let q = parsimmon_umd_min.exports.lazy(\n        () => Y.chain(\n          (Z) => parsimmon_umd_min.exports.seq(\n            W,\n            parsimmon_umd_min.exports.of(Z),\n            q\n          ).or(parsimmon_umd_min.exports.of(Z))\n        )\n      );\n      return q;\n    }\n    function M(W, Y) {\n      return parsimmon_umd_min.exports.seqMap(\n        Y,\n        parsimmon_umd_min.exports.seq(W, Y).many(),\n        (q, Z) => Z.reduce((K, Q) => [Q[0], K, Q[1]], q)\n      );\n    }\n    const D = parsimmon_umd_min.exports.alt(\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((W) => int(W))\n    ).map((W) => [\"!num!\", W]).desc(\"number\"), L = parsimmon_umd_min.exports.string(\"null\").map(() => [\"!str!\", null]), B = parsimmon_umd_min.exports.regex(/(true|false)/).map((W) => [\"!bool!\", W === \"true\"]).desc(\"boolean\"), $ = parsimmon_umd_min.exports.regex(new RegExp(`(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)`)).map((W) => [\"!str!\", W.slice(1, -1).replaceAll(e, \"\")]).desc(\"string\"), k = /\\[[^\\]]+\\]/g, U = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((W) => {\n      const Y = String(W).replace(\n        k,\n        (Z) => \".\" + this.parse(Z.slice(1, -1))\n      );\n      if (Y.charAt(0) === \"-\") {\n        const Z = this.val.getVal(Y.slice(1));\n        if (Z == null || String(Z) === \"null\")\n          throw Error(\"(PropParser)\\u6570\\u5024\\u4EE5\\u5916\\u306B-\\u7B26\\u53F7\\u304C\\u3064\\u3044\\u3066\\u3044\\u307E\\u3059\");\n        return [\"!num!\", -Number(Z)];\n      }\n      const q = this.val.getVal(Y);\n      return q == null ? [\"!str!\", q] : typeof q == \"boolean\" ? [\"!bool!\", q] : Object.prototype.toString.call(q) === \"[object String]\" ? [\"!str!\", String(q)] : [\"!num!\", Number(q)];\n    }).desc(\"string\"), z = parsimmon_umd_min.exports.lazy(\n      () => parsimmon_umd_min.exports.string(\"(\").then(H(this, pi)).skip(parsimmon_umd_min.exports.string(\")\")).or(D).or(L).or(B).or($).or(U)\n    ), V = [\n      { type: R, ops: o([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      { type: R, ops: o([/(!(?!=)|~)/]) },\n      { type: N, ops: o([\"**\"]) },\n      { type: M, ops: o([\"*\", \"/\", \"\\xA5\", \"%\"]) },\n      { type: M, ops: o([\"+\", \"-\"]) },\n      { type: M, ops: o([/(>>>|<<|>>)/]) },\n      { type: M, ops: o([/(<=|<|>=|>)/]) },\n      { type: M, ops: o([/(===|!==|==|!=)/]) },\n      { type: M, ops: o([/&(?!&)/]) },\n      { type: M, ops: o([\"^\"]) },\n      { type: M, ops: o([/\\|(?!\\|)/]) },\n      { type: M, ops: o([\"&&\"]) },\n      { type: M, ops: o([\"||\"]) },\n      { type: N, ops: o([\":\"]) },\n      { type: N, ops: o([\"?\"]) }\n    ].reduce(\n      (W, Y) => Y.type(Y.ops, W),\n      z\n    );\n    et(this, pi, V.trim(parsimmon_umd_min.exports.optWhitespace));\n  }\n  parse(t) {\n    const e = H(this, pi).parse(t);\n    if (!e.status)\n      throw Error(\"(PropParser)\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3010\" + t + \"\\u3011\");\n    const o = e.value;\n    return o[0] === \"!str!\" ? at(this, Ia, th).call(this, o[1]) : at(this, zt, jt).call(this, o);\n  }\n  static getValName(t) {\n    var R, N;\n    const e = H(this, au).exec(t.trim()), o = e == null ? void 0 : e.groups;\n    if (!!o)\n      return {\n        scope: o.scope || \"tmp\",\n        name: at(R = Dh, ou, Gh).call(R, o.name),\n        at: (N = o.at) != null ? N : \"\"\n      };\n  }\n};\nlet PropParser = Dh;\npi = new WeakMap(), zt = new WeakSet(), jt = function(t) {\n  const e = t.shift();\n  if (e instanceof Array)\n    return at(this, zt, jt).call(this, e);\n  const o = H(this, Xr)[e];\n  return o ? o(t) : Object(null);\n}, Xr = new WeakMap(), vi = new WeakSet(), $n = function(t) {\n  const e = at(this, zt, jt).call(this, t);\n  if (Object.prototype.toString.call(e) !== \"[object Number]\")\n    throw Error(\"(PropParser)\\u5F15\\u6570\\u3010\" + e + \"\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\");\n  return Number(e);\n}, Ca = new WeakMap(), Ia = new WeakSet(), th = function(t) {\n  return t == null ? t : String(t).replace(H(this, Ca), (e) => e.charAt(0) === \"$\" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));\n}, au = new WeakMap(), ou = new WeakSet(), Gh = function(t) {\n  let e = 0, o = 0;\n  for (; ; ) {\n    if (e = t.indexOf('[\"'), e < 0) {\n      if (e = t.indexOf(\"['\"), e < 0)\n        break;\n      o = t.indexOf(\"']\", e + 2);\n    } else\n      o = t.indexOf('\"]', e + 2);\n    if (o < 0)\n      break;\n    t = t.slice(0, e) + \".\" + t.slice(e + 2, o) + t.slice(o + 2), e = o - 2;\n  }\n  return t;\n}, it(PropParser, ou), it(PropParser, au, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar __accessCheck$3 = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet$3 = (n, t, e) => (__accessCheck$3(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd$3 = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet$3 = (n, t, e, o) => (__accessCheck$3(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod$3 = (n, t, e) => (__accessCheck$3(n, t, \"access private method\"), e), _scrItr$1, _hTag, _title, _spnDbg, _first, _log, log_fn, _trace, trace_fn, _st_trace, st_trace_fn, _dspDbg, dspDbg_fn;\nconst _DebugMng = class {\n  constructor(n, t, e) {\n    this.sys = n, __privateAdd$3(this, _log), __privateAdd$3(this, _trace), __privateAdd$3(this, _first, !0), __privateSet$3(_DebugMng, _scrItr$1, e), __privateSet$3(_DebugMng, _hTag, t), __privateSet$3(_DebugMng, _title, t.title), _DebugMng.myTrace = __privateMethod$3(_DebugMng, _st_trace, st_trace_fn), t.log = (o) => __privateMethod$3(this, _log, log_fn).call(this, o), t.trace = (o) => __privateMethod$3(this, _trace, trace_fn).call(this, o), __privateSet$3(_DebugMng, _spnDbg, document.createElement(\"span\")), __privateGet$3(_DebugMng, _spnDbg).hidden = !0, __privateGet$3(_DebugMng, _spnDbg).textContent = \"\", __privateGet$3(_DebugMng, _spnDbg).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(__privateGet$3(_DebugMng, _spnDbg));\n  }\n  destroy() {\n    __privateSet$3(_DebugMng, _title, () => !1), document.body.removeChild(__privateGet$3(_DebugMng, _spnDbg)), _DebugMng.myTrace = _DebugMng.trace_beforeNew;\n  }\n  static trace_beforeNew(n, t = \"E\") {\n    let e = `{${t}} ` + n, o = \"\";\n    switch (t) {\n      case \"D\":\n        o = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        o = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        o = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw e;\n      case \"E\":\n        console.error(\"%c\" + e, \"color:#FF3300;\");\n        return;\n      default:\n        o = \"color:black;\", e = \" \" + e;\n    }\n    console.info(\"%c\" + e, o);\n  }\n};\nlet DebugMng = _DebugMng;\n_scrItr$1 = /* @__PURE__ */ new WeakMap();\n_hTag = /* @__PURE__ */ new WeakMap();\n_title = /* @__PURE__ */ new WeakMap();\n_spnDbg = /* @__PURE__ */ new WeakMap();\n_first = /* @__PURE__ */ new WeakMap();\n_log = /* @__PURE__ */ new WeakSet();\nlog_fn = function(n) {\n  let t = \"\";\n  return __privateGet$3(this, _first) && (__privateSet$3(this, _first, !1), t = `== ${platform.description} ==\n`), this.sys.appendFile(\n    this.sys.path_downloads + \"log.txt\",\n    `${t}--- ${getDateStr(\"-\", \"_\", \"\")} [fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}] prj:${this.sys.cur}\n${n.text || `(text is ${n.text})`}\n`,\n    (e) => {\n      e && console.log(e);\n    }\n  ), !1;\n};\n_trace = /* @__PURE__ */ new WeakSet();\ntrace_fn = function(n) {\n  return _DebugMng.myTrace(n.text || `(text is ${n.text})`, \"I\"), !1;\n};\n_st_trace = /* @__PURE__ */ new WeakSet();\nst_trace_fn = function(n, t = \"E\") {\n  var e, o;\n  let R = `{${t}} `;\n  __privateGet$3(_DebugMng, _scrItr$1) && __privateGet$3(_DebugMng, _scrItr$1).lineNum > 0 && (R += `(fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}) `), R += n, __privateMethod$3(e = _DebugMng, _dspDbg, dspDbg_fn).call(e, R, t);\n  let N = \"\";\n  switch (t) {\n    case \"D\":\n      N = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      N = \"color:#F80;\";\n      break;\n    case \"F\":\n      N = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      if (__privateGet$3(o = _DebugMng, _title).call(o, { text: n }), __privateGet$3(this, _hTag).dump_lay({}), __privateGet$3(this, _hTag).dump_val({}), __privateGet$3(_DebugMng, _scrItr$1).dumpErrForeLine(), __privateGet$3(this, _hTag).dump_stack({}), t === \"ET\")\n        throw R;\n      console.error(\"%c\" + R, \"color:#F30;\");\n      return;\n    default:\n      N = \"\", R = \" \" + R;\n  }\n  console.info(\"%c\" + R, N);\n};\n_dspDbg = /* @__PURE__ */ new WeakSet();\ndspDbg_fn = function(n, t) {\n  let e = \"\";\n  switch (t) {\n    case \"D\":\n      e = \"color:#05A;\";\n      break;\n    case \"W\":\n      e = \"color:#F80;\";\n      break;\n    case \"F\":\n      e = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      e = \"color:#F30;\";\n      break;\n    default:\n      e = \"\";\n  }\n  __privateGet$3(_DebugMng, _spnDbg).innerHTML += `<span style='${e}'>${n}</span><br/>`, __privateGet$3(_DebugMng, _spnDbg).hidden = !1;\n};\n__privateAdd$3(DebugMng, _st_trace);\n__privateAdd$3(DebugMng, _dspDbg);\n__privateAdd$3(DebugMng, _scrItr$1, void 0);\n__privateAdd$3(DebugMng, _hTag, void 0);\n__privateAdd$3(DebugMng, _title, void 0);\n__privateAdd$3(DebugMng, _spnDbg, void 0);\nDebugMng.myTrace = _DebugMng.trace_beforeNew;\nclass Areas {\n  constructor() {\n    this.hAreas = {};\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(t) {\n    for (const e in this.hAreas)\n      if (!(t < parseInt(e)) && t <= this.hAreas[e])\n        return !0;\n    return !1;\n  }\n  record(t) {\n    if (!this.search(t)) {\n      for (const e in this.hAreas)\n        if (this.hAreas[e] + 1 === t) {\n          t + 1 in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;\n          return;\n        }\n      if (t + 1 in this.hAreas) {\n        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];\n        return;\n      }\n      this.hAreas[t] = t;\n    }\n  }\n  erase(t) {\n    if (!!this.search(t)) {\n      if (t in this.hAreas) {\n        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];\n        return;\n      }\n      for (const e in this.hAreas)\n        if (!(t < parseInt(e)) && !(this.hAreas[e] < t)) {\n          if (this.hAreas[e] === t) {\n            this.hAreas[e] = t - 1;\n            return;\n          }\n          this.hAreas[t + 1] = this.hAreas[e], this.hAreas[e] = t - 1;\n          return;\n        }\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  toString() {\n    let t = \"\";\n    const e = [];\n    for (const o in this.hAreas)\n      e.push(parseInt(o));\n    return e.sort(function(o, R) {\n      return o - R;\n    }), e.forEach((o) => {\n      t += \",\" + o + (o === this.hAreas[o]) ? \"\" : 0;\n    }), t !== \"\" && (t = t.slice(1)), t;\n  }\n}\nvar Se, je, fe, Wr, _e, Ve, or, wa, Ra, Pa, eh, Kn, Jn, uu, Uh, lu, Hh, ur, Rr, hu, zh, cu, jh, fu, Vh, du, Xh, pu, Wh, vu, Yh, gu, qh, _u, Zh, Qn, Uo, Aa, rh, ts, Ki, Oa, ih, Na, Ma, Ji, es, rs, Ho, mu, Kh, yu, Jh, Da, nh, La, sh, bu, Qh, Eu, tc, is, zo;\nconst Xn = class {\n  constructor(t, e) {\n    it(this, Pa);\n    it(this, uu);\n    it(this, lu);\n    it(this, ur);\n    it(this, hu);\n    it(this, cu);\n    it(this, fu);\n    it(this, du);\n    it(this, pu);\n    it(this, vu);\n    it(this, gu);\n    it(this, _u);\n    it(this, Qn);\n    it(this, Aa);\n    it(this, Oa);\n    it(this, rs);\n    it(this, mu);\n    it(this, yu);\n    it(this, Da);\n    it(this, La);\n    it(this, bu);\n    it(this, Eu);\n    it(this, is);\n    it(this, Se, void 0);\n    it(this, je, void 0);\n    it(this, fe, void 0);\n    it(this, Wr, void 0);\n    it(this, _e, void 0);\n    it(this, Ve, void 0);\n    it(this, or, void 0);\n    it(this, wa, void 0);\n    it(this, Ra, void 0);\n    it(this, Kn, void 0);\n    it(this, Jn, void 0);\n    it(this, ts, void 0);\n    it(this, Na, void 0);\n    it(this, Ma, void 0);\n    it(this, Ji, void 0);\n    it(this, es, void 0);\n    var N;\n    if (this.cfg = t, et(this, Se, { sys: {}, save: {}, tmp: {}, mp: {} }), et(this, je, H(this, Se).save), et(this, fe, H(this, Se).tmp), et(this, _e, { sys: {}, mark: {}, kidoku: {} }), et(this, or, {}), et(this, Ra, {\n      auth: (M, D) => at(this, Pa, eh).call(this, D.hBreakpoint.aData),\n      var: (M, D) => {\n        var L;\n        return H(this, Wr).send2Dbg(D.ri, { v: (L = H(this, Se)[D.scope]) != null ? L : {} });\n      },\n      set_var: (M, D) => {\n        try {\n          H(this, ts).call(this, D.nm, D.val), H(this, Wr).send2Dbg(D.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (M, D) => {\n        at(this, Pa, eh).call(this, D.a), H(this, Wr).send2Dbg(D.ri, {});\n      },\n      disconnect: (M) => et(Xn, Ki, {})\n    }), et(this, Kn, () => {\n    }), et(this, Jn, (M) => {\n    }), this.getMark = (M) => H(this, _e).mark[M], this.getAreaKidoku = (M) => H(this, or)[M], et(this, ts, (M, D, L = !0) => {\n      if (!M)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      if (D == null)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\\uFF08\\u7A7A\\u6587\\u5B57\\u306FOK\\uFF09\";\n      const B = PropParser.getValName(M);\n      if (B === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + M + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const $ = H(this, Se)[B.scope];\n      if (!$)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] scope\\u304C\\u7570\\u5E38\\u3010\" + B.scope + \"\\u3011\\u3067\\u3059\";\n      const k = B.name;\n      if (k.slice(0, 6) === \"const.\" && k in $)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] \\u5909\\u6570\\u3010\" + k + \"\\u3011\\u306F\\u66F8\\u304D\\u63DB\\u3048\\u4E0D\\u53EF\\u3067\\u3059\";\n      this.setVal_Nochk(B.scope, k, D, L);\n    }), this.getVal = (M, D) => {\n      if (!M)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      const L = PropParser.getValName(M);\n      if (L === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + M + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const B = H(this, Se)[L.scope];\n      if (!B)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] scope\\u304C\\u7570\\u5E38\\u3010\" + L.scope + \"\\u3011\\u3067\\u3059\";\n      const $ = L.name;\n      let k = B[$];\n      if (!($ in B)) {\n        k = D;\n        let U = \"\";\n        const z = $.split(\".\"), X = z.length;\n        for (let V = 0; V < X; ++V, U += \".\") {\n          if (U += z[V], !(U in B))\n            continue;\n          let W = JSON.parse(B[U]);\n          if (Object.prototype.toString.call(W) !== \"[object Object]\") {\n            if (V + 1 === X) {\n              k = W;\n              break;\n            }\n            continue;\n          }\n          let Y = V;\n          for (; ++Y < X; ) {\n            if (!(z[Y] in W)) {\n              k = D;\n              break;\n            }\n            if (W = W[z[Y]], Object.prototype.toString.call(W) !== \"[object Object]\" || Y + 1 === X) {\n              k = W;\n              break;\n            }\n          }\n          k instanceof Object && (k = JSON.stringify(k));\n          break;\n        }\n      }\n      return k instanceof Function && (k = k()), L.at === \"@str\" ? k : at(this, Oa, ih).call(this, k);\n    }, et(this, Na, /^-?[\\d\\.]+$/), et(this, Ma, () => {\n      const M = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let D in M) {\n        const L = H(this, Se)[D], B = M[D];\n        for (let $ in L) {\n          const k = L[$];\n          Object.prototype.toString.call(k) === \"[object Function]\" ? B[$] = k() : B[$] = k;\n        }\n      }\n      return console.info(\"\\u{1F95F} [dump_val]\", M), !1;\n    }), et(this, Ji, !1), et(this, es, {\n      \"sys:sn.tagCh.doWait\": (M) => at(this, rs, Ho).call(this, M),\n      \"sys:sn.tagCh.doWait_Kidoku\": (M) => at(this, rs, Ho).call(this, M),\n      \"sys:sn.tagCh.msecWait\": (M) => at(this, mu, Kh).call(this, M),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (M) => at(this, yu, Jh).call(this, M),\n      \"sys:sn.tagCh.canskip\": (M) => at(this, rs, Ho).call(this, M),\n      \"sys:sn.auto.msecPageWait\": (M) => at(this, Da, nh).call(this, M),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (M) => at(this, Da, nh).call(this, M),\n      \"sys:sn.auto.msecLineWait\": (M) => at(this, La, sh).call(this, M),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (M) => at(this, La, sh).call(this, M),\n      \"save:sn.doRecLog\": (M) => {\n        H(this, Jn).call(this, et(this, Ji, at(this, bu, Qh).call(this, M)));\n      },\n      \"save:sn.userFnTail\": (M, D) => this.cfg.userFnTail = D,\n      \"tmp:sn.tagL.enabled\": (M) => at(this, Eu, tc).call(this, M),\n      \"tmp:sn.skip.all\": (M) => at(this, is, zo).call(this, M),\n      \"tmp:sn.skip.enabled\": (M) => at(this, is, zo).call(this, M),\n      \"tmp:sn.auto.enabled\": (M) => at(this, is, zo).call(this, M),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    }), e.let = (M) => at(this, ur, Rr).call(this, M), e.let_abs = (M) => at(this, hu, zh).call(this, M), e.let_char_at = (M) => at(this, cu, jh).call(this, M), e.let_index_of = (M) => at(this, fu, Vh).call(this, M), e.let_length = (M) => at(this, du, Xh).call(this, M), e.let_replace = (M) => at(this, pu, Wh).call(this, M), e.let_round = (M) => at(this, vu, Yh).call(this, M), e.let_search = (M) => at(this, gu, qh).call(this, M), e.let_substr = (M) => at(this, _u, Zh).call(this, M), e.clearsysvar = () => at(this, Qn, Uo).call(this), e.clearvar = () => at(this, Aa, rh).call(this), e.dump_val = () => H(this, Ma).call(this), e.copybookmark = (M) => at(this, uu, Uh).call(this, M), e.erasebookmark = (M) => at(this, lu, Hh).call(this, M), H(this, je)[\"sn.userFnTail\"] = \"\", this.defTmp(\"const.sn.bookmark.json\", () => {\n      const M = [];\n      return Object.keys(H(this, _e).mark).sort().forEach((D) => {\n        const L = { ...H(this, _e).mark[D].json };\n        L.place = D, M.push(L);\n      }), JSON.stringify(M);\n    }), H(this, fe)[\"const.sn.isFirstBoot\"] = !0, H(this, fe)[\"sn.tagL.enabled\"] = !0, H(this, fe)[\"sn.skip.all\"] = !1, H(this, fe)[\"sn.skip.enabled\"] = !1, H(this, fe)[\"sn.auto.enabled\"] = !1, H(this, fe)[\"const.sn.last_page_text\"] = \"\", H(this, fe)[\"const.sn.displayState\"] = !1, H(this, fe)[\"const.Date.getTime\"] = () => new Date().getTime(), H(this, fe)[\"const.Date.getDateStr\"] = () => getDateStr(), H(this, fe)[\"const.sn.platform\"] = JSON.stringify(platform), at(this, Qn, Uo).call(this), at(this, Aa, rh).call(this), H(this, fe)[\"const.sn.config.window.width\"] = t.oCfg.window.width, H(this, fe)[\"const.sn.config.window.height\"] = t.oCfg.window.height, H(this, fe)[\"const.sn.config.book.title\"] = t.oCfg.book.title, H(this, fe)[\"const.sn.config.book.version\"] = t.oCfg.book.version, H(this, fe)[\"const.sn.Math.PI\"] = Math.PI, typeof window > \"u\")\n      return;\n    const o = window, R = (N = o.AudioContext) != null ? N : o.webkitAudioContext;\n    H(this, fe)[\"const.sn.needClick2Play\"] = () => new R().state === \"suspended\";\n  }\n  setSys(t) {\n    et(this, Wr, t), t.initVal(H(this, _e), H(this, fe), (e) => {\n      this.updateData(e), sessionStorage.clear();\n      const o = this.cfg.getNs();\n      et(this, Kn, this.cfg.oCfg.debug.variable ? () => {\n        const N = {};\n        Object.keys(H(this, Ve)).forEach((k) => {\n          const U = H(this, Ve)[k];\n          N[\"sys:\" + k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"sys\"] = JSON.stringify(N);\n        const M = {};\n        Object.keys(H(this, je)).forEach((k) => {\n          const U = H(this, je)[k];\n          M[\"save:\" + k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"save\"] = JSON.stringify(M);\n        const D = {};\n        Object.keys(H(this, fe)).forEach((k) => {\n          const U = H(this, fe)[k];\n          D[k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"tmp\"] = JSON.stringify(D);\n        const L = {};\n        Object.keys(H(this, Se).mp).forEach((k) => {\n          const U = H(this, Se).mp[k];\n          L[k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"mp\"] = JSON.stringify(L);\n        const B = {};\n        Object.keys(H(this, _e).mark).forEach((k) => {\n          const U = H(this, _e).mark[k];\n          B[k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"mark\"] = JSON.stringify(B);\n        const $ = {};\n        Object.keys(H(this, _e).kidoku).forEach((k) => {\n          const U = H(this, _e).kidoku[k];\n          $[k] = U instanceof Function ? U() : U;\n        }), sessionStorage[o + \"kidoku\"] = JSON.stringify($), t.flush();\n      } : () => t.flush()), et(this, wa, (N, M) => t.callHook(N, M)), t.addHook((N, M) => {\n        var D, L;\n        return (L = (D = H(this, Ra))[N]) == null ? void 0 : L.call(D, N, M);\n      });\n      const R = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      (H(this, fe)[\"const.sn.isFirstBoot\"] || R === -1) && at(this, Qn, Uo).call(this);\n    });\n  }\n  updateData(t) {\n    et(this, _e, t), et(this, Ve, H(this, Se).sys = H(this, _e).sys), et(this, or, {});\n    for (const e in H(this, _e).kidoku) {\n      const o = new Areas();\n      o.hAreas = { ...H(this, _e).kidoku[e] }, H(this, or)[e] = o;\n    }\n  }\n  flush() {\n    H(this, Kn).call(this);\n  }\n  setDoRecProc(t) {\n    et(this, Jn, t);\n  }\n  defTmp(t, e) {\n    H(this, fe)[t] = e;\n  }\n  cloneMp() {\n    return { ...H(this, Se).mp };\n  }\n  setMp(t) {\n    H(this, Se).mp = t;\n  }\n  setMark(t, e) {\n    H(this, _e).mark[t] = e, this.flush();\n  }\n  cloneSave() {\n    return { ...H(this, Se).save };\n  }\n  mark2save(t) {\n    var e;\n    et(this, je, H(this, Se).save = { ...t.hSave }), et(this, Ji, (e = H(this, je)[\"sn.doRecLog\"]) != null ? e : !1);\n  }\n  loadScrWork(t) {\n    t in H(this, or) || (H(this, or)[t] = new Areas());\n  }\n  saveKidoku() {\n    for (const t in H(this, or))\n      H(this, _e).kidoku[t] = { ...H(this, or)[t].hAreas };\n    this.flush();\n  }\n  setVal_Nochk(t, e, o, R = !1) {\n    var D, L;\n    const N = H(this, Se)[t];\n    R && (o = at(this, Oa, ih).call(this, o));\n    const M = t + \":\" + e;\n    if (M in H(Xn, Ki)) {\n      const B = N[e], $ = o;\n      B != $ && H(this, wa).call(this, \"data_break\", {\n        dataId: M,\n        old_v: B,\n        new_v: $\n      });\n    }\n    N[e] = o, (L = (D = H(this, es))[M]) == null || L.call(D, e, o);\n  }\n  doRecLog() {\n    return H(this, Ji);\n  }\n  defValTrg(t, e) {\n    H(this, es)[t] = e;\n  }\n};\nlet Variable = Xn;\nSe = new WeakMap(), je = new WeakMap(), fe = new WeakMap(), Wr = new WeakMap(), _e = new WeakMap(), Ve = new WeakMap(), or = new WeakMap(), wa = new WeakMap(), Ra = new WeakMap(), Pa = new WeakSet(), eh = function(t) {\n  et(Xn, Ki, {}), t.forEach((e) => H(Xn, Ki)[e.dataId] = 1);\n}, Kn = new WeakMap(), Jn = new WeakMap(), uu = new WeakSet(), Uh = function(t) {\n  if (!(\"from\" in t))\n    throw \"from\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!(\"to\" in t))\n    throw \"to\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.from), o = Number(t.to);\n  if (e === o)\n    return !1;\n  if (!(e in H(this, _e).mark))\n    throw `from:${e} \\u306E\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  return this.setMark(o, { ...H(this, _e).mark[e] }), H(this, Wr).copyBMFolder(e, o), !1;\n}, lu = new WeakSet(), Hh = function(t) {\n  const { place: e } = t;\n  if (!e)\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return delete H(this, _e).mark[e], this.flush(), H(this, Wr).eraseBMFolder(e), !1;\n}, ur = new WeakSet(), Rr = function(t) {\n  if (!t.name)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let e = !0;\n  if (t.cast)\n    switch (t.cast) {\n      case \"num\":\n        argChk_Num(t, \"text\", NaN);\n        break;\n      case \"int\":\n        t.text = String(int(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"uint\":\n        t.text = String(uint(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"bool\":\n        argChk_Boolean(t, \"text\", !1);\n        break;\n      case \"str\":\n        e = !1;\n        break;\n      default:\n        throw \"cast\\u3010\" + t.cast + \"\\u3011\\u306F\\u672A\\u5B9A\\u7FA9\\u3067\\u3059\";\n    }\n  return H(this, ts).call(this, t.name, t.text, e), !1;\n}, hu = new WeakSet(), zh = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(e < 0 ? -e : e), at(this, ur, Rr).call(this, t), !1;\n}, cu = new WeakSet(), jh = function(t) {\n  var e;\n  return t.text = ((e = t.text) != null ? e : \"\").charAt(argChk_Num(t, \"pos\", 0)), at(this, ur, Rr).call(this, t), !1;\n}, fu = new WeakSet(), Vh = function(t) {\n  var R;\n  const { val: e } = t;\n  if (!e)\n    throw \"val\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = argChk_Num(t, \"start\", 0);\n  return t.text = String(((R = t.text) != null ? R : \"\").indexOf(e, o)), at(this, ur, Rr).call(this, t), !1;\n}, du = new WeakSet(), Xh = function(t) {\n  var e;\n  return t.text = String(((e = t.text) != null ? e : \"\").length), at(this, ur, Rr).call(this, t), !1;\n}, pu = new WeakSet(), Wh = function(t) {\n  var R;\n  if (!t.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String((R = t.text) != null ? R : \"\").replace(o, String(t.val)), at(this, ur, Rr).call(this, t), !1;\n}, vu = new WeakSet(), Yh = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(Math.round(e)), at(this, ur, Rr).call(this, t), !1;\n}, gu = new WeakSet(), qh = function(t) {\n  var R;\n  if (!t.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String(((R = t.text) != null ? R : \"\").search(o)), at(this, ur, Rr).call(this, t), !1;\n}, _u = new WeakSet(), Zh = function(t) {\n  var o, R;\n  const e = argChk_Num(t, \"pos\", 0);\n  return t.text = t.len !== \"all\" ? ((o = t.text) != null ? o : \"\").slice(e, e + int(argChk_Num(t, \"len\", 1))) : ((R = t.text) != null ? R : \"\").slice(e), at(this, ur, Rr).call(this, t), !1;\n}, Qn = new WeakSet(), Uo = function() {\n  var o, R;\n  const t = et(this, Ve, H(this, Se).sys = H(this, _e).sys = {});\n  typeof process < \"u\" || (this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0), this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0)), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", !0), this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\"), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", argChk_Num(t, \"sn.auto.msecPageWait\", (o = this.cfg.oCfg.init.auto_msecpagewait) != null ? o : 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", argChk_Num(t, \"sn.auto.msecPageWait\", (R = this.cfg.oCfg.init.auto_msecpagewait) != null ? R : 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500), this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const N in H(this, _e).kidoku)\n    H(this, _e).kidoku[N].hAreas = {}, H(this, or)[N].clear();\n  return this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5), H(this, Se).mark = H(this, _e).mark = {}, this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1), this.flush(), !1;\n}, Aa = new WeakSet(), rh = function() {\n  var R, N, M;\n  const t = (R = H(this, je)[\"const.sn.mesLayer\"]) != null ? R : \"\", e = (N = H(this, je)[\"sn.doRecLog\"]) != null ? N : !1, o = (M = H(this, je)[\"const.sn.sLog\"]) != null ? M : \"[]\";\n  return et(this, je, H(this, Se).save = {}), this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", t), this.setVal_Nochk(\"save\", \"sn.doRecLog\", e), this.setVal_Nochk(\"save\", \"const.sn.sLog\", o), !1;\n}, ts = new WeakMap(), Ki = new WeakMap(), Oa = new WeakSet(), ih = function(t) {\n  const e = t;\n  if (e === \"true\")\n    return !0;\n  if (e === \"false\")\n    return !1;\n  if (e === \"null\")\n    return null;\n  if (e !== \"undefined\")\n    return H(this, Na).test(e) ? parseFloat(e) : t;\n}, Na = new WeakMap(), Ma = new WeakMap(), Ji = new WeakMap(), es = new WeakMap(), rs = new WeakSet(), Ho = function(t) {\n  argChk_Boolean(H(this, Ve), t, !0);\n}, mu = new WeakSet(), Kh = function(t) {\n  argChk_Num(H(this, Ve), t, 10), H(this, Ve)[\"sn.tagCh.doWait\"];\n}, yu = new WeakSet(), Jh = function(t) {\n  argChk_Num(\n    H(this, Ve),\n    t,\n    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait\n  ), H(this, Ve)[\"sn.tagCh.doWait_Kidoku\"];\n}, Da = new WeakSet(), nh = function(t) {\n  argChk_Num(\n    H(this, Ve),\n    t,\n    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait\n  );\n}, La = new WeakSet(), sh = function(t) {\n  argChk_Num(H(this, Ve), t, 500);\n}, bu = new WeakSet(), Qh = function(t) {\n  return argChk_Boolean(H(this, je), t, !0);\n}, Eu = new WeakSet(), tc = function(t) {\n  argChk_Boolean(H(this, fe), t, !0);\n}, is = new WeakSet(), zo = function(t) {\n  argChk_Boolean(H(this, fe), t, !1);\n}, it(Variable, Ki, {});\nvar Easing = {\n  Linear: {\n    None: function(n) {\n      return n;\n    }\n  },\n  Quadratic: {\n    In: function(n) {\n      return n * n;\n    },\n    Out: function(n) {\n      return n * (2 - n);\n    },\n    InOut: function(n) {\n      return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);\n    }\n  },\n  Cubic: {\n    In: function(n) {\n      return n * n * n;\n    },\n    Out: function(n) {\n      return --n * n * n + 1;\n    },\n    InOut: function(n) {\n      return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);\n    }\n  },\n  Quartic: {\n    In: function(n) {\n      return n * n * n * n;\n    },\n    Out: function(n) {\n      return 1 - --n * n * n * n;\n    },\n    InOut: function(n) {\n      return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);\n    }\n  },\n  Quintic: {\n    In: function(n) {\n      return n * n * n * n * n;\n    },\n    Out: function(n) {\n      return --n * n * n * n * n + 1;\n    },\n    InOut: function(n) {\n      return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);\n    }\n  },\n  Sinusoidal: {\n    In: function(n) {\n      return 1 - Math.cos(n * Math.PI / 2);\n    },\n    Out: function(n) {\n      return Math.sin(n * Math.PI / 2);\n    },\n    InOut: function(n) {\n      return 0.5 * (1 - Math.cos(Math.PI * n));\n    }\n  },\n  Exponential: {\n    In: function(n) {\n      return n === 0 ? 0 : Math.pow(1024, n - 1);\n    },\n    Out: function(n) {\n      return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);\n    },\n    InOut: function(n) {\n      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);\n    }\n  },\n  Circular: {\n    In: function(n) {\n      return 1 - Math.sqrt(1 - n * n);\n    },\n    Out: function(n) {\n      return Math.sqrt(1 - --n * n);\n    },\n    InOut: function(n) {\n      return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);\n    }\n  },\n  Elastic: {\n    In: function(n) {\n      return n === 0 ? 0 : n === 1 ? 1 : -Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI);\n    },\n    Out: function(n) {\n      return n === 0 ? 0 : n === 1 ? 1 : Math.pow(2, -10 * n) * Math.sin((n - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(n) {\n      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2, n < 1 ? -0.5 * Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI) + 1);\n    }\n  },\n  Back: {\n    In: function(n) {\n      var t = 1.70158;\n      return n * n * ((t + 1) * n - t);\n    },\n    Out: function(n) {\n      var t = 1.70158;\n      return --n * n * ((t + 1) * n + t) + 1;\n    },\n    InOut: function(n) {\n      var t = 2.5949095;\n      return (n *= 2) < 1 ? 0.5 * (n * n * ((t + 1) * n - t)) : 0.5 * ((n -= 2) * n * ((t + 1) * n + t) + 2);\n    }\n  },\n  Bounce: {\n    In: function(n) {\n      return 1 - Easing.Bounce.Out(1 - n);\n    },\n    Out: function(n) {\n      return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;\n    },\n    InOut: function(n) {\n      return n < 0.5 ? Easing.Bounce.In(n * 2) * 0.5 : Easing.Bounce.Out(n * 2 - 1) * 0.5 + 0.5;\n    }\n  }\n}, now$2;\ntypeof self > \"u\" && typeof process < \"u\" && process.hrtime ? now$2 = function() {\n  var n = process.hrtime();\n  return n[0] * 1e3 + n[1] / 1e6;\n} : typeof self < \"u\" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {\n  return new Date().getTime();\n};\nvar now$1$1 = now$2, Group = function() {\n  function n() {\n    this._tweens = {}, this._tweensAddedDuringUpdate = {};\n  }\n  return n.prototype.getAll = function() {\n    var t = this;\n    return Object.keys(this._tweens).map(function(e) {\n      return t._tweens[e];\n    });\n  }, n.prototype.removeAll = function() {\n    this._tweens = {};\n  }, n.prototype.add = function(t) {\n    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;\n  }, n.prototype.remove = function(t) {\n    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];\n  }, n.prototype.update = function(t, e) {\n    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);\n    var o = Object.keys(this._tweens);\n    if (o.length === 0)\n      return !1;\n    for (; o.length > 0; ) {\n      this._tweensAddedDuringUpdate = {};\n      for (var R = 0; R < o.length; R++) {\n        var N = this._tweens[o[R]], M = !e;\n        N && N.update(t, M) === !1 && !e && delete this._tweens[o[R]];\n      }\n      o = Object.keys(this._tweensAddedDuringUpdate);\n    }\n    return !0;\n  }, n;\n}(), Interpolation = {\n  Linear: function(n, t) {\n    var e = n.length - 1, o = e * t, R = Math.floor(o), N = Interpolation.Utils.Linear;\n    return t < 0 ? N(n[0], n[1], o) : t > 1 ? N(n[e], n[e - 1], e - o) : N(n[R], n[R + 1 > e ? e : R + 1], o - R);\n  },\n  Bezier: function(n, t) {\n    for (var e = 0, o = n.length - 1, R = Math.pow, N = Interpolation.Utils.Bernstein, M = 0; M <= o; M++)\n      e += R(1 - t, o - M) * R(t, M) * n[M] * N(o, M);\n    return e;\n  },\n  CatmullRom: function(n, t) {\n    var e = n.length - 1, o = e * t, R = Math.floor(o), N = Interpolation.Utils.CatmullRom;\n    return n[0] === n[e] ? (t < 0 && (R = Math.floor(o = e * (1 + t))), N(n[(R - 1 + e) % e], n[R], n[(R + 1) % e], n[(R + 2) % e], o - R)) : t < 0 ? n[0] - (N(n[0], n[0], n[1], n[1], -o) - n[0]) : t > 1 ? n[e] - (N(n[e], n[e], n[e - 1], n[e - 1], o - e) - n[e]) : N(n[R ? R - 1 : 0], n[R], n[e < R + 1 ? e : R + 1], n[e < R + 2 ? e : R + 2], o - R);\n  },\n  Utils: {\n    Linear: function(n, t, e) {\n      return (t - n) * e + n;\n    },\n    Bernstein: function(n, t) {\n      var e = Interpolation.Utils.Factorial;\n      return e(n) / e(t) / e(n - t);\n    },\n    Factorial: function() {\n      var n = [1];\n      return function(t) {\n        var e = 1;\n        if (n[t])\n          return n[t];\n        for (var o = t; o > 1; o--)\n          e *= o;\n        return n[t] = e, e;\n      };\n    }(),\n    CatmullRom: function(n, t, e, o, R) {\n      var N = (e - n) * 0.5, M = (o - t) * 0.5, D = R * R, L = R * D;\n      return (2 * t - 2 * e + N + M) * L + (-3 * t + 3 * e - 2 * N - M) * D + N * R + t;\n    }\n  }\n}, Sequence = function() {\n  function n() {\n  }\n  return n.nextId = function() {\n    return n._nextId++;\n  }, n._nextId = 0, n;\n}(), mainGroup = new Group(), Tween = function() {\n  function n(t, e) {\n    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;\n  }\n  return n.prototype.getId = function() {\n    return this._id;\n  }, n.prototype.isPlaying = function() {\n    return this._isPlaying;\n  }, n.prototype.isPaused = function() {\n    return this._isPaused;\n  }, n.prototype.to = function(t, e) {\n    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;\n  }, n.prototype.duration = function(t) {\n    return this._duration = t, this;\n  }, n.prototype.start = function(t) {\n    if (this._isPlaying)\n      return this;\n    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {\n      this._reversed = !1;\n      for (var e in this._valuesStartRepeat)\n        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];\n    }\n    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == \"string\" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;\n  }, n.prototype._setupProperties = function(t, e, o, R) {\n    for (var N in o) {\n      var M = t[N], D = Array.isArray(M), L = D ? \"array\" : typeof M, B = !D && Array.isArray(o[N]);\n      if (!(L === \"undefined\" || L === \"function\")) {\n        if (B) {\n          var $ = o[N];\n          if ($.length === 0)\n            continue;\n          $ = $.map(this._handleRelativeValue.bind(this, M)), o[N] = [M].concat($);\n        }\n        if ((L === \"object\" || D) && M && !B) {\n          e[N] = D ? [] : {};\n          for (var k in M)\n            e[N][k] = M[k];\n          R[N] = D ? [] : {}, this._setupProperties(M, e[N], o[N], R[N]);\n        } else\n          typeof e[N] > \"u\" && (e[N] = M), D || (e[N] *= 1), B ? R[N] = o[N].slice().reverse() : R[N] = e[N] || 0;\n      }\n    }\n  }, n.prototype.stop = function() {\n    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;\n  }, n.prototype.end = function() {\n    return this._goToEnd = !0, this.update(1 / 0), this;\n  }, n.prototype.pause = function(t) {\n    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);\n  }, n.prototype.resume = function(t) {\n    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);\n  }, n.prototype.stopChainedTweens = function() {\n    for (var t = 0, e = this._chainedTweens.length; t < e; t++)\n      this._chainedTweens[t].stop();\n    return this;\n  }, n.prototype.group = function(t) {\n    return this._group = t, this;\n  }, n.prototype.delay = function(t) {\n    return this._delayTime = t, this;\n  }, n.prototype.repeat = function(t) {\n    return this._initialRepeat = t, this._repeat = t, this;\n  }, n.prototype.repeatDelay = function(t) {\n    return this._repeatDelayTime = t, this;\n  }, n.prototype.yoyo = function(t) {\n    return this._yoyo = t, this;\n  }, n.prototype.easing = function(t) {\n    return this._easingFunction = t, this;\n  }, n.prototype.interpolation = function(t) {\n    return this._interpolationFunction = t, this;\n  }, n.prototype.chain = function() {\n    for (var t = [], e = 0; e < arguments.length; e++)\n      t[e] = arguments[e];\n    return this._chainedTweens = t, this;\n  }, n.prototype.onStart = function(t) {\n    return this._onStartCallback = t, this;\n  }, n.prototype.onUpdate = function(t) {\n    return this._onUpdateCallback = t, this;\n  }, n.prototype.onRepeat = function(t) {\n    return this._onRepeatCallback = t, this;\n  }, n.prototype.onComplete = function(t) {\n    return this._onCompleteCallback = t, this;\n  }, n.prototype.onStop = function(t) {\n    return this._onStopCallback = t, this;\n  }, n.prototype.update = function(t, e) {\n    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)\n      return !0;\n    var o, R, N = this._startTime + this._duration;\n    if (!this._goToEnd && !this._isPlaying) {\n      if (t > N)\n        return !1;\n      e && this.start(t);\n    }\n    if (this._goToEnd = !1, t < this._startTime)\n      return !0;\n    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), R = (t - this._startTime) / this._duration, R = this._duration === 0 || R > 1 ? 1 : R;\n    var M = this._easingFunction(R);\n    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, M), this._onUpdateCallback && this._onUpdateCallback(this._object, R), R === 1)\n      if (this._repeat > 0) {\n        isFinite(this._repeat) && this._repeat--;\n        for (o in this._valuesStartRepeat)\n          !this._yoyo && typeof this._valuesEnd[o] == \"string\" && (this._valuesStartRepeat[o] = this._valuesStartRepeat[o] + parseFloat(this._valuesEnd[o])), this._yoyo && this._swapEndStartRepeatValues(o), this._valuesStart[o] = this._valuesStartRepeat[o];\n        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;\n      } else {\n        this._onCompleteCallback && this._onCompleteCallback(this._object);\n        for (var D = 0, L = this._chainedTweens.length; D < L; D++)\n          this._chainedTweens[D].start(this._startTime + this._duration);\n        return this._isPlaying = !1, !1;\n      }\n    return !0;\n  }, n.prototype._updateProperties = function(t, e, o, R) {\n    for (var N in o)\n      if (e[N] !== void 0) {\n        var M = e[N] || 0, D = o[N], L = Array.isArray(t[N]), B = Array.isArray(D), $ = !L && B;\n        $ ? t[N] = this._interpolationFunction(D, R) : typeof D == \"object\" && D ? this._updateProperties(t[N], M, D, R) : (D = this._handleRelativeValue(M, D), typeof D == \"number\" && (t[N] = M + (D - M) * R));\n      }\n  }, n.prototype._handleRelativeValue = function(t, e) {\n    return typeof e != \"string\" ? e : e.charAt(0) === \"+\" || e.charAt(0) === \"-\" ? t + parseFloat(e) : parseFloat(e);\n  }, n.prototype._swapEndStartRepeatValues = function(t) {\n    var e = this._valuesStartRepeat[t], o = this._valuesEnd[t];\n    typeof o == \"string\" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(o) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;\n  }, n;\n}();\nSequence.nextId;\nvar TWEEN = mainGroup;\nTWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nTWEEN.add.bind(TWEEN);\nTWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN), Fa;\nconst xu = class {\n  static ease(t) {\n    if (!t)\n      return (e) => Easing.Linear.None(e);\n    if (!(t in H(xu, Fa)))\n      throw \"\\u7570\\u5E38\\u306Aease\\u6307\\u5B9A\\u3067\\u3059\";\n    return H(xu, Fa)[t];\n  }\n};\nlet CmnTween = xu;\nFa = new WeakMap(), it(CmnTween, Fa, {\n  \"Back.In\": (t) => Easing.Back.In(t),\n  \"Back.InOut\": (t) => Easing.Back.InOut(t),\n  \"Back.Out\": (t) => Easing.Back.Out(t),\n  \"Bounce.In\": (t) => Easing.Bounce.In(t),\n  \"Bounce.InOut\": (t) => Easing.Bounce.InOut(t),\n  \"Bounce.Out\": (t) => Easing.Bounce.Out(t),\n  \"Circular.In\": (t) => Easing.Circular.In(t),\n  \"Circular.InOut\": (t) => Easing.Circular.InOut(t),\n  \"Circular.Out\": (t) => Easing.Circular.Out(t),\n  \"Cubic.In\": (t) => Easing.Cubic.In(t),\n  \"Cubic.InOut\": (t) => Easing.Cubic.InOut(t),\n  \"Cubic.Out\": (t) => Easing.Cubic.Out(t),\n  \"Elastic.In\": (t) => Easing.Elastic.In(t),\n  \"Elastic.InOut\": (t) => Easing.Elastic.InOut(t),\n  \"Elastic.Out\": (t) => Easing.Elastic.Out(t),\n  \"Exponential.In\": (t) => Easing.Exponential.In(t),\n  \"Exponential.InOut\": (t) => Easing.Exponential.InOut(t),\n  \"Exponential.Out\": (t) => Easing.Exponential.Out(t),\n  \"Linear.None\": (t) => Easing.Linear.None(t),\n  \"Quadratic.In\": (t) => Easing.Quadratic.In(t),\n  \"Quadratic.InOut\": (t) => Easing.Quadratic.InOut(t),\n  \"Quadratic.Out\": (t) => Easing.Quadratic.Out(t),\n  \"Quartic.In\": (t) => Easing.Quartic.In(t),\n  \"Quartic.InOut\": (t) => Easing.Quartic.InOut(t),\n  \"Quartic.Out\": (t) => Easing.Quartic.Out(t),\n  \"Quintic.In\": (t) => Easing.Quintic.In(t),\n  \"Quintic.InOut\": (t) => Easing.Quintic.InOut(t),\n  \"Quintic.Out\": (t) => Easing.Quintic.Out(t),\n  \"Sinusoidal.In\": (t) => Easing.Sinusoidal.In(t),\n  \"Sinusoidal.InOut\": (t) => Easing.Sinusoidal.InOut(t),\n  \"Sinusoidal.Out\": (t) => Easing.Sinusoidal.Out(t)\n});\n/*!\n * @pixi/settings - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$6;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$6 || (ENV$6 = {}));\nvar RENDERER_TYPE$6;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$6 || (RENDERER_TYPE$6 = {}));\nvar BUFFER_BITS$6;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$6 || (BUFFER_BITS$6 = {}));\nvar BLEND_MODES$6;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$6 || (BLEND_MODES$6 = {}));\nvar DRAW_MODES$6;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$6 || (DRAW_MODES$6 = {}));\nvar FORMATS$6;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$6 || (FORMATS$6 = {}));\nvar TARGETS$6;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$6 || (TARGETS$6 = {}));\nvar TYPES$6;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$6 || (TYPES$6 = {}));\nvar SAMPLER_TYPES$6;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$6 || (SAMPLER_TYPES$6 = {}));\nvar SCALE_MODES$6;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$6 || (SCALE_MODES$6 = {}));\nvar WRAP_MODES$6;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$6 || (WRAP_MODES$6 = {}));\nvar MIPMAP_MODES$6;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$6 || (MIPMAP_MODES$6 = {}));\nvar ALPHA_MODES$6;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$6 || (ALPHA_MODES$6 = {}));\nvar CLEAR_MODES$6;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$6 || (CLEAR_MODES$6 = {}));\nvar GC_MODES$6;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$6 || (GC_MODES$6 = {}));\nvar PRECISION$6;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$6 || (PRECISION$6 = {}));\nvar MASK_TYPES$6;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$6 || (MASK_TYPES$6 = {}));\nvar COLOR_MASK_BITS$6;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$6 || (COLOR_MASK_BITS$6 = {}));\nvar MSAA_QUALITY$6;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$6 || (MSAA_QUALITY$6 = {}));\nvar BUFFER_TYPE$6;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$6 || (BUFFER_TYPE$6 = {}));\nvar BrowserAdapter$1 = {\n  createCanvas: function(n, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = n, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var n;\n    return (n = document.baseURI) !== null && n !== void 0 ? n : window.location.href;\n  },\n  fetch: function(n, t) {\n    return fetch(n, t);\n  }\n}, appleIphone$1 = /iPhone/i, appleIpod$1 = /iPod/i, appleTablet$1 = /iPad/i, appleUniversal$1 = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone$1 = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet$1 = /Android/i, amazonPhone$1 = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet$1 = /Silk/i, windowsPhone$1 = /Windows Phone/i, windowsTablet$1 = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry$1 = /BlackBerry/i, otherBlackBerry10$1 = /BB10/i, otherOpera$1 = /Opera Mini/i, otherChrome$1 = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox$1 = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13$1 = function(n) {\n  return typeof n < \"u\" && n.platform === \"MacIntel\" && typeof n.maxTouchPoints == \"number\" && n.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch$1(n) {\n  return function(t) {\n    return t.test(n);\n  };\n}\nfunction isMobile$1$1(n) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !n && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof n == \"string\" ? t.userAgent = n : n && n.userAgent && (t = {\n    userAgent: n.userAgent,\n    platform: n.platform,\n    maxTouchPoints: n.maxTouchPoints || 0\n  });\n  var e = t.userAgent, o = e.split(\"[FBAN\");\n  typeof o[1] < \"u\" && (e = o[0]), o = e.split(\"Twitter\"), typeof o[1] < \"u\" && (e = o[0]);\n  var R = createMatch$1(e), N = {\n    apple: {\n      phone: R(appleIphone$1) && !R(windowsPhone$1),\n      ipod: R(appleIpod$1),\n      tablet: !R(appleIphone$1) && (R(appleTablet$1) || isAppleTabletOnIos13$1(t)) && !R(windowsPhone$1),\n      universal: R(appleUniversal$1),\n      device: (R(appleIphone$1) || R(appleIpod$1) || R(appleTablet$1) || R(appleUniversal$1) || isAppleTabletOnIos13$1(t)) && !R(windowsPhone$1)\n    },\n    amazon: {\n      phone: R(amazonPhone$1),\n      tablet: !R(amazonPhone$1) && R(amazonTablet$1),\n      device: R(amazonPhone$1) || R(amazonTablet$1)\n    },\n    android: {\n      phone: !R(windowsPhone$1) && R(amazonPhone$1) || !R(windowsPhone$1) && R(androidPhone$1),\n      tablet: !R(windowsPhone$1) && !R(amazonPhone$1) && !R(androidPhone$1) && (R(amazonTablet$1) || R(androidTablet$1)),\n      device: !R(windowsPhone$1) && (R(amazonPhone$1) || R(amazonTablet$1) || R(androidPhone$1) || R(androidTablet$1)) || R(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: R(windowsPhone$1),\n      tablet: R(windowsTablet$1),\n      device: R(windowsPhone$1) || R(windowsTablet$1)\n    },\n    other: {\n      blackberry: R(otherBlackBerry$1),\n      blackberry10: R(otherBlackBerry10$1),\n      opera: R(otherOpera$1),\n      firefox: R(otherFirefox$1),\n      chrome: R(otherChrome$1),\n      device: R(otherBlackBerry$1) || R(otherBlackBerry10$1) || R(otherOpera$1) || R(otherFirefox$1) || R(otherChrome$1)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;\n}\nvar isMobile$2 = isMobile$1$1(globalThis.navigator);\nfunction canUploadSameBuffer$1() {\n  return !isMobile$2.apple.device;\n}\nfunction maxRecommendedTextures$1(n) {\n  var t = !0;\n  if (isMobile$2.tablet || isMobile$2.phone) {\n    if (isMobile$2.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 11 && (t = !1);\n      }\n    }\n    if (isMobile$2.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? n : 4;\n}\nvar settings$1 = {\n  ADAPTER: BrowserAdapter$1,\n  MIPMAP_TEXTURES: MIPMAP_MODES$6.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY$6.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  GC_MODE: GC_MODES$6.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES$6.CLAMP,\n  SCALE_MODE: SCALE_MODES$6.LINEAR,\n  PRECISION_VERTEX: PRECISION$6.HIGH,\n  PRECISION_FRAGMENT: isMobile$2.apple.device ? PRECISION$6.HIGH : PRECISION$6.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),\n  CREATE_IMAGE_BITMAP: !1,\n  ROUND_PIXELS: !1\n};\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$5;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$5 || (ENV$5 = {}));\nvar RENDERER_TYPE$5;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {}));\nvar BUFFER_BITS$5;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {}));\nvar BLEND_MODES$5;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$5 || (BLEND_MODES$5 = {}));\nvar DRAW_MODES$5;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$5 || (DRAW_MODES$5 = {}));\nvar FORMATS$5;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$5 || (FORMATS$5 = {}));\nvar TARGETS$5;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$5 || (TARGETS$5 = {}));\nvar TYPES$5;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$5 || (TYPES$5 = {}));\nvar SAMPLER_TYPES$5;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {}));\nvar SCALE_MODES$5;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$5 || (SCALE_MODES$5 = {}));\nvar WRAP_MODES$5;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$5 || (WRAP_MODES$5 = {}));\nvar MIPMAP_MODES$5;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {}));\nvar ALPHA_MODES$5;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {}));\nvar CLEAR_MODES$5;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {}));\nvar GC_MODES$5;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$5 || (GC_MODES$5 = {}));\nvar PRECISION$5;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$5 || (PRECISION$5 = {}));\nvar MASK_TYPES$5;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$5 || (MASK_TYPES$5 = {}));\nvar COLOR_MASK_BITS$5;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$5 || (COLOR_MASK_BITS$5 = {}));\nvar MSAA_QUALITY$5;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {}));\nvar BUFFER_TYPE$5;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));\nvar eventemitter3 = { exports: {} };\n(function(n) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function o() {\n  }\n  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));\n  function R(L, B, $) {\n    this.fn = L, this.context = B, this.once = $ || !1;\n  }\n  function N(L, B, $, k, U) {\n    if (typeof $ != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var z = new R($, k || L, U), X = e ? e + B : B;\n    return L._events[X] ? L._events[X].fn ? L._events[X] = [L._events[X], z] : L._events[X].push(z) : (L._events[X] = z, L._eventsCount++), L;\n  }\n  function M(L, B) {\n    --L._eventsCount === 0 ? L._events = new o() : delete L._events[B];\n  }\n  function D() {\n    this._events = new o(), this._eventsCount = 0;\n  }\n  D.prototype.eventNames = function() {\n    var B = [], $, k;\n    if (this._eventsCount === 0)\n      return B;\n    for (k in $ = this._events)\n      t.call($, k) && B.push(e ? k.slice(1) : k);\n    return Object.getOwnPropertySymbols ? B.concat(Object.getOwnPropertySymbols($)) : B;\n  }, D.prototype.listeners = function(B) {\n    var $ = e ? e + B : B, k = this._events[$];\n    if (!k)\n      return [];\n    if (k.fn)\n      return [k.fn];\n    for (var U = 0, z = k.length, X = new Array(z); U < z; U++)\n      X[U] = k[U].fn;\n    return X;\n  }, D.prototype.listenerCount = function(B) {\n    var $ = e ? e + B : B, k = this._events[$];\n    return k ? k.fn ? 1 : k.length : 0;\n  }, D.prototype.emit = function(B, $, k, U, z, X) {\n    var V = e ? e + B : B;\n    if (!this._events[V])\n      return !1;\n    var W = this._events[V], Y = arguments.length, q, Z;\n    if (W.fn) {\n      switch (W.once && this.removeListener(B, W.fn, void 0, !0), Y) {\n        case 1:\n          return W.fn.call(W.context), !0;\n        case 2:\n          return W.fn.call(W.context, $), !0;\n        case 3:\n          return W.fn.call(W.context, $, k), !0;\n        case 4:\n          return W.fn.call(W.context, $, k, U), !0;\n        case 5:\n          return W.fn.call(W.context, $, k, U, z), !0;\n        case 6:\n          return W.fn.call(W.context, $, k, U, z, X), !0;\n      }\n      for (Z = 1, q = new Array(Y - 1); Z < Y; Z++)\n        q[Z - 1] = arguments[Z];\n      W.fn.apply(W.context, q);\n    } else {\n      var K = W.length, Q;\n      for (Z = 0; Z < K; Z++)\n        switch (W[Z].once && this.removeListener(B, W[Z].fn, void 0, !0), Y) {\n          case 1:\n            W[Z].fn.call(W[Z].context);\n            break;\n          case 2:\n            W[Z].fn.call(W[Z].context, $);\n            break;\n          case 3:\n            W[Z].fn.call(W[Z].context, $, k);\n            break;\n          case 4:\n            W[Z].fn.call(W[Z].context, $, k, U);\n            break;\n          default:\n            if (!q)\n              for (Q = 1, q = new Array(Y - 1); Q < Y; Q++)\n                q[Q - 1] = arguments[Q];\n            W[Z].fn.apply(W[Z].context, q);\n        }\n    }\n    return !0;\n  }, D.prototype.on = function(B, $, k) {\n    return N(this, B, $, k, !1);\n  }, D.prototype.once = function(B, $, k) {\n    return N(this, B, $, k, !0);\n  }, D.prototype.removeListener = function(B, $, k, U) {\n    var z = e ? e + B : B;\n    if (!this._events[z])\n      return this;\n    if (!$)\n      return M(this, z), this;\n    var X = this._events[z];\n    if (X.fn)\n      X.fn === $ && (!U || X.once) && (!k || X.context === k) && M(this, z);\n    else {\n      for (var V = 0, W = [], Y = X.length; V < Y; V++)\n        (X[V].fn !== $ || U && !X[V].once || k && X[V].context !== k) && W.push(X[V]);\n      W.length ? this._events[z] = W.length === 1 ? W[0] : W : M(this, z);\n    }\n    return this;\n  }, D.prototype.removeAllListeners = function(B) {\n    var $;\n    return B ? ($ = e ? e + B : B, this._events[$] && M(this, $)) : (this._events = new o(), this._eventsCount = 0), this;\n  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, n.exports = D;\n})(eventemitter3);\nconst EventEmitter$5 = eventemitter3.exports;\nvar earcut$1 = { exports: {} };\nearcut$1.exports = earcut;\nearcut$1.exports.default = earcut;\nfunction earcut(n, t, e) {\n  e = e || 2;\n  var o = t && t.length, R = o ? t[0] * e : n.length, N = linkedList(n, 0, R, e, !0), M = [];\n  if (!N || N.next === N.prev)\n    return M;\n  var D, L, B, $, k, U, z;\n  if (o && (N = eliminateHoles(n, t, N, e)), n.length > 80 * e) {\n    D = B = n[0], L = $ = n[1];\n    for (var X = e; X < R; X += e)\n      k = n[X], U = n[X + 1], k < D && (D = k), U < L && (L = U), k > B && (B = k), U > $ && ($ = U);\n    z = Math.max(B - D, $ - L), z = z !== 0 ? 32767 / z : 0;\n  }\n  return earcutLinked(N, M, e, D, L, z, 0), M;\n}\nfunction linkedList(n, t, e, o, R) {\n  var N, M;\n  if (R === signedArea(n, t, e, o) > 0)\n    for (N = t; N < e; N += o)\n      M = insertNode(N, n[N], n[N + 1], M);\n  else\n    for (N = e - o; N >= t; N -= o)\n      M = insertNode(N, n[N], n[N + 1], M);\n  return M && equals$1(M, M.next) && (removeNode(M), M = M.next), M;\n}\nfunction filterPoints(n, t) {\n  if (!n)\n    return n;\n  t || (t = n);\n  var e = n, o;\n  do\n    if (o = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {\n      if (removeNode(e), e = t = e.prev, e === e.next)\n        break;\n      o = !0;\n    } else\n      e = e.next;\n  while (o || e !== t);\n  return t;\n}\nfunction earcutLinked(n, t, e, o, R, N, M) {\n  if (!!n) {\n    !M && N && indexCurve(n, o, R, N);\n    for (var D = n, L, B; n.prev !== n.next; ) {\n      if (L = n.prev, B = n.next, N ? isEarHashed(n, o, R, N) : isEar(n)) {\n        t.push(L.i / e | 0), t.push(n.i / e | 0), t.push(B.i / e | 0), removeNode(n), n = B.next, D = B.next;\n        continue;\n      }\n      if (n = B, n === D) {\n        M ? M === 1 ? (n = cureLocalIntersections(filterPoints(n), t, e), earcutLinked(n, t, e, o, R, N, 2)) : M === 2 && splitEarcut(n, t, e, o, R, N) : earcutLinked(filterPoints(n), t, e, o, R, N, 1);\n        break;\n      }\n    }\n  }\n}\nfunction isEar(n) {\n  var t = n.prev, e = n, o = n.next;\n  if (area(t, e, o) >= 0)\n    return !1;\n  for (var R = t.x, N = e.x, M = o.x, D = t.y, L = e.y, B = o.y, $ = R < N ? R < M ? R : M : N < M ? N : M, k = D < L ? D < B ? D : B : L < B ? L : B, U = R > N ? R > M ? R : M : N > M ? N : M, z = D > L ? D > B ? D : B : L > B ? L : B, X = o.next; X !== t; ) {\n    if (X.x >= $ && X.x <= U && X.y >= k && X.y <= z && pointInTriangle(R, D, N, L, M, B, X.x, X.y) && area(X.prev, X, X.next) >= 0)\n      return !1;\n    X = X.next;\n  }\n  return !0;\n}\nfunction isEarHashed(n, t, e, o) {\n  var R = n.prev, N = n, M = n.next;\n  if (area(R, N, M) >= 0)\n    return !1;\n  for (var D = R.x, L = N.x, B = M.x, $ = R.y, k = N.y, U = M.y, z = D < L ? D < B ? D : B : L < B ? L : B, X = $ < k ? $ < U ? $ : U : k < U ? k : U, V = D > L ? D > B ? D : B : L > B ? L : B, W = $ > k ? $ > U ? $ : U : k > U ? k : U, Y = zOrder(z, X, t, e, o), q = zOrder(V, W, t, e, o), Z = n.prevZ, K = n.nextZ; Z && Z.z >= Y && K && K.z <= q; ) {\n    if (Z.x >= z && Z.x <= V && Z.y >= X && Z.y <= W && Z !== R && Z !== M && pointInTriangle(D, $, L, k, B, U, Z.x, Z.y) && area(Z.prev, Z, Z.next) >= 0 || (Z = Z.prevZ, K.x >= z && K.x <= V && K.y >= X && K.y <= W && K !== R && K !== M && pointInTriangle(D, $, L, k, B, U, K.x, K.y) && area(K.prev, K, K.next) >= 0))\n      return !1;\n    K = K.nextZ;\n  }\n  for (; Z && Z.z >= Y; ) {\n    if (Z.x >= z && Z.x <= V && Z.y >= X && Z.y <= W && Z !== R && Z !== M && pointInTriangle(D, $, L, k, B, U, Z.x, Z.y) && area(Z.prev, Z, Z.next) >= 0)\n      return !1;\n    Z = Z.prevZ;\n  }\n  for (; K && K.z <= q; ) {\n    if (K.x >= z && K.x <= V && K.y >= X && K.y <= W && K !== R && K !== M && pointInTriangle(D, $, L, k, B, U, K.x, K.y) && area(K.prev, K, K.next) >= 0)\n      return !1;\n    K = K.nextZ;\n  }\n  return !0;\n}\nfunction cureLocalIntersections(n, t, e) {\n  var o = n;\n  do {\n    var R = o.prev, N = o.next.next;\n    !equals$1(R, N) && intersects(R, o, o.next, N) && locallyInside(R, N) && locallyInside(N, R) && (t.push(R.i / e | 0), t.push(o.i / e | 0), t.push(N.i / e | 0), removeNode(o), removeNode(o.next), o = n = N), o = o.next;\n  } while (o !== n);\n  return filterPoints(o);\n}\nfunction splitEarcut(n, t, e, o, R, N) {\n  var M = n;\n  do {\n    for (var D = M.next.next; D !== M.prev; ) {\n      if (M.i !== D.i && isValidDiagonal(M, D)) {\n        var L = splitPolygon(M, D);\n        M = filterPoints(M, M.next), L = filterPoints(L, L.next), earcutLinked(M, t, e, o, R, N, 0), earcutLinked(L, t, e, o, R, N, 0);\n        return;\n      }\n      D = D.next;\n    }\n    M = M.next;\n  } while (M !== n);\n}\nfunction eliminateHoles(n, t, e, o) {\n  var R = [], N, M, D, L, B;\n  for (N = 0, M = t.length; N < M; N++)\n    D = t[N] * o, L = N < M - 1 ? t[N + 1] * o : n.length, B = linkedList(n, D, L, o, !1), B === B.next && (B.steiner = !0), R.push(getLeftmost(B));\n  for (R.sort(compareX), N = 0; N < R.length; N++)\n    e = eliminateHole(R[N], e);\n  return e;\n}\nfunction compareX(n, t) {\n  return n.x - t.x;\n}\nfunction eliminateHole(n, t) {\n  var e = findHoleBridge(n, t);\n  if (!e)\n    return t;\n  var o = splitPolygon(e, n);\n  return filterPoints(o, o.next), filterPoints(e, e.next);\n}\nfunction findHoleBridge(n, t) {\n  var e = t, o = n.x, R = n.y, N = -1 / 0, M;\n  do {\n    if (R <= e.y && R >= e.next.y && e.next.y !== e.y) {\n      var D = e.x + (R - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if (D <= o && D > N && (N = D, M = e.x < e.next.x ? e : e.next, D === o))\n        return M;\n    }\n    e = e.next;\n  } while (e !== t);\n  if (!M)\n    return null;\n  var L = M, B = M.x, $ = M.y, k = 1 / 0, U;\n  e = M;\n  do\n    o >= e.x && e.x >= B && o !== e.x && pointInTriangle(R < $ ? o : N, R, B, $, R < $ ? N : o, R, e.x, e.y) && (U = Math.abs(R - e.y) / (o - e.x), locallyInside(e, n) && (U < k || U === k && (e.x > M.x || e.x === M.x && sectorContainsSector(M, e))) && (M = e, k = U)), e = e.next;\n  while (e !== L);\n  return M;\n}\nfunction sectorContainsSector(n, t) {\n  return area(n.prev, n, t.prev) < 0 && area(t.next, n, n.next) < 0;\n}\nfunction indexCurve(n, t, e, o) {\n  var R = n;\n  do\n    R.z === 0 && (R.z = zOrder(R.x, R.y, t, e, o)), R.prevZ = R.prev, R.nextZ = R.next, R = R.next;\n  while (R !== n);\n  R.prevZ.nextZ = null, R.prevZ = null, sortLinked(R);\n}\nfunction sortLinked(n) {\n  var t, e, o, R, N, M, D, L, B = 1;\n  do {\n    for (e = n, n = null, N = null, M = 0; e; ) {\n      for (M++, o = e, D = 0, t = 0; t < B && (D++, o = o.nextZ, !!o); t++)\n        ;\n      for (L = B; D > 0 || L > 0 && o; )\n        D !== 0 && (L === 0 || !o || e.z <= o.z) ? (R = e, e = e.nextZ, D--) : (R = o, o = o.nextZ, L--), N ? N.nextZ = R : n = R, R.prevZ = N, N = R;\n      e = o;\n    }\n    N.nextZ = null, B *= 2;\n  } while (M > 1);\n  return n;\n}\nfunction zOrder(n, t, e, o, R) {\n  return n = (n - e) * R | 0, t = (t - o) * R | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n | t << 1;\n}\nfunction getLeftmost(n) {\n  var t = n, e = n;\n  do\n    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;\n  while (t !== n);\n  return e;\n}\nfunction pointInTriangle(n, t, e, o, R, N, M, D) {\n  return (R - M) * (t - D) >= (n - M) * (N - D) && (n - M) * (o - D) >= (e - M) * (t - D) && (e - M) * (N - D) >= (R - M) * (o - D);\n}\nfunction isValidDiagonal(n, t) {\n  return n.next.i !== t.i && n.prev.i !== t.i && !intersectsPolygon(n, t) && (locallyInside(n, t) && locallyInside(t, n) && middleInside(n, t) && (area(n.prev, n, t.prev) || area(n, t.prev, t)) || equals$1(n, t) && area(n.prev, n, n.next) > 0 && area(t.prev, t, t.next) > 0);\n}\nfunction area(n, t, e) {\n  return (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y);\n}\nfunction equals$1(n, t) {\n  return n.x === t.x && n.y === t.y;\n}\nfunction intersects(n, t, e, o) {\n  var R = sign$1(area(n, t, e)), N = sign$1(area(n, t, o)), M = sign$1(area(e, o, n)), D = sign$1(area(e, o, t));\n  return !!(R !== N && M !== D || R === 0 && onSegment(n, e, t) || N === 0 && onSegment(n, o, t) || M === 0 && onSegment(e, n, o) || D === 0 && onSegment(e, t, o));\n}\nfunction onSegment(n, t, e) {\n  return t.x <= Math.max(n.x, e.x) && t.x >= Math.min(n.x, e.x) && t.y <= Math.max(n.y, e.y) && t.y >= Math.min(n.y, e.y);\n}\nfunction sign$1(n) {\n  return n > 0 ? 1 : n < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(n, t) {\n  var e = n;\n  do {\n    if (e.i !== n.i && e.next.i !== n.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, n, t))\n      return !0;\n    e = e.next;\n  } while (e !== n);\n  return !1;\n}\nfunction locallyInside(n, t) {\n  return area(n.prev, n, n.next) < 0 ? area(n, t, n.next) >= 0 && area(n, n.prev, t) >= 0 : area(n, t, n.prev) < 0 || area(n, n.next, t) < 0;\n}\nfunction middleInside(n, t) {\n  var e = n, o = !1, R = (n.x + t.x) / 2, N = (n.y + t.y) / 2;\n  do\n    e.y > N != e.next.y > N && e.next.y !== e.y && R < (e.next.x - e.x) * (N - e.y) / (e.next.y - e.y) + e.x && (o = !o), e = e.next;\n  while (e !== n);\n  return o;\n}\nfunction splitPolygon(n, t) {\n  var e = new Node$1(n.i, n.x, n.y), o = new Node$1(t.i, t.x, t.y), R = n.next, N = t.prev;\n  return n.next = t, t.prev = n, e.next = R, R.prev = e, o.next = e, e.prev = o, N.next = o, o.prev = N, o;\n}\nfunction insertNode(n, t, e, o) {\n  var R = new Node$1(n, t, e);\n  return o ? (R.next = o.next, R.prev = o, o.next.prev = R, o.next = R) : (R.prev = R, R.next = R), R;\n}\nfunction removeNode(n) {\n  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);\n}\nfunction Node$1(n, t, e) {\n  this.i = n, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nearcut.deviation = function(n, t, e, o) {\n  var R = t && t.length, N = R ? t[0] * e : n.length, M = Math.abs(signedArea(n, 0, N, e));\n  if (R)\n    for (var D = 0, L = t.length; D < L; D++) {\n      var B = t[D] * e, $ = D < L - 1 ? t[D + 1] * e : n.length;\n      M -= Math.abs(signedArea(n, B, $, e));\n    }\n  var k = 0;\n  for (D = 0; D < o.length; D += 3) {\n    var U = o[D] * e, z = o[D + 1] * e, X = o[D + 2] * e;\n    k += Math.abs(\n      (n[U] - n[X]) * (n[z + 1] - n[U + 1]) - (n[U] - n[z]) * (n[X + 1] - n[U + 1])\n    );\n  }\n  return M === 0 && k === 0 ? 0 : Math.abs((k - M) / M);\n};\nfunction signedArea(n, t, e, o) {\n  for (var R = 0, N = t, M = e - o; N < e; N += o)\n    R += (n[M] - n[N]) * (n[N + 1] + n[M + 1]), M = N;\n  return R;\n}\nearcut.flatten = function(n) {\n  for (var t = n[0][0].length, e = { vertices: [], holes: [], dimensions: t }, o = 0, R = 0; R < n.length; R++) {\n    for (var N = 0; N < n[R].length; N++)\n      for (var M = 0; M < t; M++)\n        e.vertices.push(n[R][N][M]);\n    R > 0 && (o += n[R - 1].length, e.holes.push(o));\n  }\n  return e;\n};\nvar punycode$1 = { exports: {} };\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n(function(n, t) {\n  (function(e) {\n    var o = t && !t.nodeType && t, R = n && !n.nodeType && n, N = typeof commonjsGlobal$1 == \"object\" && commonjsGlobal$1;\n    (N.global === N || N.window === N || N.self === N) && (e = N);\n    var M, D = 2147483647, L = 36, B = 1, $ = 26, k = 38, U = 700, z = 72, X = 128, V = \"-\", W = /^xn--/, Y = /[^\\x20-\\x7E]/, q = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, Z = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, K = L - B, Q = Math.floor, J = String.fromCharCode, rt;\n    function tt(ht) {\n      throw RangeError(Z[ht]);\n    }\n    function nt(ht, pt) {\n      for (var xt = ht.length, At = []; xt--; )\n        At[xt] = pt(ht[xt]);\n      return At;\n    }\n    function st(ht, pt) {\n      var xt = ht.split(\"@\"), At = \"\";\n      xt.length > 1 && (At = xt[0] + \"@\", ht = xt[1]), ht = ht.replace(q, \".\");\n      var Rt = ht.split(\".\"), Lt = nt(Rt, pt).join(\".\");\n      return At + Lt;\n    }\n    function ut(ht) {\n      for (var pt = [], xt = 0, At = ht.length, Rt, Lt; xt < At; )\n        Rt = ht.charCodeAt(xt++), Rt >= 55296 && Rt <= 56319 && xt < At ? (Lt = ht.charCodeAt(xt++), (Lt & 64512) == 56320 ? pt.push(((Rt & 1023) << 10) + (Lt & 1023) + 65536) : (pt.push(Rt), xt--)) : pt.push(Rt);\n      return pt;\n    }\n    function ct(ht) {\n      return nt(ht, function(pt) {\n        var xt = \"\";\n        return pt > 65535 && (pt -= 65536, xt += J(pt >>> 10 & 1023 | 55296), pt = 56320 | pt & 1023), xt += J(pt), xt;\n      }).join(\"\");\n    }\n    function dt(ht) {\n      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : L;\n    }\n    function Et(ht, pt) {\n      return ht + 22 + 75 * (ht < 26) - ((pt != 0) << 5);\n    }\n    function vt(ht, pt, xt) {\n      var At = 0;\n      for (ht = xt ? Q(ht / U) : ht >> 1, ht += Q(ht / pt); ht > K * $ >> 1; At += L)\n        ht = Q(ht / K);\n      return Q(At + (K + 1) * ht / (ht + k));\n    }\n    function _t(ht) {\n      var pt = [], xt = ht.length, At, Rt = 0, Lt = X, lt = z, $t, Pt, kt, Ot, gt, Gt, Tt, bt, wt;\n      for ($t = ht.lastIndexOf(V), $t < 0 && ($t = 0), Pt = 0; Pt < $t; ++Pt)\n        ht.charCodeAt(Pt) >= 128 && tt(\"not-basic\"), pt.push(ht.charCodeAt(Pt));\n      for (kt = $t > 0 ? $t + 1 : 0; kt < xt; ) {\n        for (Ot = Rt, gt = 1, Gt = L; kt >= xt && tt(\"invalid-input\"), Tt = dt(ht.charCodeAt(kt++)), (Tt >= L || Tt > Q((D - Rt) / gt)) && tt(\"overflow\"), Rt += Tt * gt, bt = Gt <= lt ? B : Gt >= lt + $ ? $ : Gt - lt, !(Tt < bt); Gt += L)\n          wt = L - bt, gt > Q(D / wt) && tt(\"overflow\"), gt *= wt;\n        At = pt.length + 1, lt = vt(Rt - Ot, At, Ot == 0), Q(Rt / At) > D - Lt && tt(\"overflow\"), Lt += Q(Rt / At), Rt %= At, pt.splice(Rt++, 0, Lt);\n      }\n      return ct(pt);\n    }\n    function St(ht) {\n      var pt, xt, At, Rt, Lt, lt, $t, Pt, kt, Ot, gt, Gt = [], Tt, bt, wt, Mt;\n      for (ht = ut(ht), Tt = ht.length, pt = X, xt = 0, Lt = z, lt = 0; lt < Tt; ++lt)\n        gt = ht[lt], gt < 128 && Gt.push(J(gt));\n      for (At = Rt = Gt.length, Rt && Gt.push(V); At < Tt; ) {\n        for ($t = D, lt = 0; lt < Tt; ++lt)\n          gt = ht[lt], gt >= pt && gt < $t && ($t = gt);\n        for (bt = At + 1, $t - pt > Q((D - xt) / bt) && tt(\"overflow\"), xt += ($t - pt) * bt, pt = $t, lt = 0; lt < Tt; ++lt)\n          if (gt = ht[lt], gt < pt && ++xt > D && tt(\"overflow\"), gt == pt) {\n            for (Pt = xt, kt = L; Ot = kt <= Lt ? B : kt >= Lt + $ ? $ : kt - Lt, !(Pt < Ot); kt += L)\n              Mt = Pt - Ot, wt = L - Ot, Gt.push(\n                J(Et(Ot + Mt % wt, 0))\n              ), Pt = Q(Mt / wt);\n            Gt.push(J(Et(Pt, 0))), Lt = vt(xt, bt, At == Rt), xt = 0, ++At;\n          }\n        ++xt, ++pt;\n      }\n      return Gt.join(\"\");\n    }\n    function Ft(ht) {\n      return st(ht, function(pt) {\n        return W.test(pt) ? _t(pt.slice(4).toLowerCase()) : pt;\n      });\n    }\n    function mt(ht) {\n      return st(ht, function(pt) {\n        return Y.test(pt) ? \"xn--\" + St(pt) : pt;\n      });\n    }\n    if (M = {\n      version: \"1.3.2\",\n      ucs2: {\n        decode: ut,\n        encode: ct\n      },\n      decode: _t,\n      encode: St,\n      toASCII: mt,\n      toUnicode: Ft\n    }, o && R)\n      if (n.exports == o)\n        R.exports = M;\n      else\n        for (rt in M)\n          M.hasOwnProperty(rt) && (o[rt] = M[rt]);\n    else\n      e.punycode = M;\n  })(commonjsGlobal$1);\n})(punycode$1, punycode$1.exports);\nvar util$8 = {\n  isString: function(n) {\n    return typeof n == \"string\";\n  },\n  isObject: function(n) {\n    return typeof n == \"object\" && n !== null;\n  },\n  isNull: function(n) {\n    return n === null;\n  },\n  isNullOrUndefined: function(n) {\n    return n == null;\n  }\n}, querystring$1 = {};\nfunction hasOwnProperty$2(n, t) {\n  return Object.prototype.hasOwnProperty.call(n, t);\n}\nvar decode$1 = function(n, t, e, o) {\n  t = t || \"&\", e = e || \"=\";\n  var R = {};\n  if (typeof n != \"string\" || n.length === 0)\n    return R;\n  var N = /\\+/g;\n  n = n.split(t);\n  var M = 1e3;\n  o && typeof o.maxKeys == \"number\" && (M = o.maxKeys);\n  var D = n.length;\n  M > 0 && D > M && (D = M);\n  for (var L = 0; L < D; ++L) {\n    var B = n[L].replace(N, \"%20\"), $ = B.indexOf(e), k, U, z, X;\n    $ >= 0 ? (k = B.substr(0, $), U = B.substr($ + 1)) : (k = B, U = \"\"), z = decodeURIComponent(k), X = decodeURIComponent(U), hasOwnProperty$2(R, z) ? Array.isArray(R[z]) ? R[z].push(X) : R[z] = [R[z], X] : R[z] = X;\n  }\n  return R;\n}, stringifyPrimitive$1 = function(n) {\n  switch (typeof n) {\n    case \"string\":\n      return n;\n    case \"boolean\":\n      return n ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(n) ? n : \"\";\n    default:\n      return \"\";\n  }\n}, encode$1 = function(n, t, e, o) {\n  return t = t || \"&\", e = e || \"=\", n === null && (n = void 0), typeof n == \"object\" ? Object.keys(n).map(function(R) {\n    var N = encodeURIComponent(stringifyPrimitive$1(R)) + e;\n    return Array.isArray(n[R]) ? n[R].map(function(M) {\n      return N + encodeURIComponent(stringifyPrimitive$1(M));\n    }).join(t) : N + encodeURIComponent(stringifyPrimitive$1(n[R]));\n  }).join(t) : o ? encodeURIComponent(stringifyPrimitive$1(o)) + e + encodeURIComponent(stringifyPrimitive$1(n)) : \"\";\n};\nquerystring$1.decode = querystring$1.parse = decode$1;\nquerystring$1.encode = querystring$1.stringify = encode$1;\nvar punycode = punycode$1.exports, util$7 = util$8, parse$1 = urlParse, resolve$1 = urlResolve, format$1 = urlFormat;\nfunction Url() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", `\n`, \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n}, querystring = querystring$1;\nfunction urlParse(n, t, e) {\n  if (n && util$7.isObject(n) && n instanceof Url)\n    return n;\n  var o = new Url();\n  return o.parse(n, t, e), o;\n}\nUrl.prototype.parse = function(n, t, e) {\n  if (!util$7.isString(n))\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof n);\n  var o = n.indexOf(\"?\"), R = o !== -1 && o < n.indexOf(\"#\") ? \"?\" : \"#\", N = n.split(R), M = /\\\\/g;\n  N[0] = N[0].replace(M, \"/\"), n = N.join(R);\n  var D = n;\n  if (D = D.trim(), !e && n.split(\"#\").length === 1) {\n    var L = simplePathPattern.exec(D);\n    if (L)\n      return this.path = D, this.href = D, this.pathname = L[1], L[2] ? (this.search = L[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = \"\", this.query = {}), this;\n  }\n  var B = protocolPattern.exec(D);\n  if (B) {\n    B = B[0];\n    var $ = B.toLowerCase();\n    this.protocol = $, D = D.substr(B.length);\n  }\n  if (e || B || D.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var k = D.substr(0, 2) === \"//\";\n    k && !(B && hostlessProtocol[B]) && (D = D.substr(2), this.slashes = !0);\n  }\n  if (!hostlessProtocol[B] && (k || B && !slashedProtocol[B])) {\n    for (var U = -1, z = 0; z < hostEndingChars.length; z++) {\n      var X = D.indexOf(hostEndingChars[z]);\n      X !== -1 && (U === -1 || X < U) && (U = X);\n    }\n    var V, W;\n    U === -1 ? W = D.lastIndexOf(\"@\") : W = D.lastIndexOf(\"@\", U), W !== -1 && (V = D.slice(0, W), D = D.slice(W + 1), this.auth = decodeURIComponent(V)), U = -1;\n    for (var z = 0; z < nonHostChars.length; z++) {\n      var X = D.indexOf(nonHostChars[z]);\n      X !== -1 && (U === -1 || X < U) && (U = X);\n    }\n    U === -1 && (U = D.length), this.host = D.slice(0, U), D = D.slice(U), this.parseHost(), this.hostname = this.hostname || \"\";\n    var Y = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!Y)\n      for (var q = this.hostname.split(/\\./), z = 0, Z = q.length; z < Z; z++) {\n        var K = q[z];\n        if (!!K && !K.match(hostnamePartPattern)) {\n          for (var Q = \"\", J = 0, rt = K.length; J < rt; J++)\n            K.charCodeAt(J) > 127 ? Q += \"x\" : Q += K[J];\n          if (!Q.match(hostnamePartPattern)) {\n            var tt = q.slice(0, z), nt = q.slice(z + 1), st = K.match(hostnamePartStart);\n            st && (tt.push(st[1]), nt.unshift(st[2])), nt.length && (D = \"/\" + nt.join(\".\") + D), this.hostname = tt.join(\".\");\n            break;\n          }\n        }\n      }\n    this.hostname.length > hostnameMaxLen ? this.hostname = \"\" : this.hostname = this.hostname.toLowerCase(), Y || (this.hostname = punycode.toASCII(this.hostname));\n    var ut = this.port ? \":\" + this.port : \"\", ct = this.hostname || \"\";\n    this.host = ct + ut, this.href += this.host, Y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), D[0] !== \"/\" && (D = \"/\" + D));\n  }\n  if (!unsafeProtocol[$])\n    for (var z = 0, Z = autoEscape.length; z < Z; z++) {\n      var dt = autoEscape[z];\n      if (D.indexOf(dt) !== -1) {\n        var Et = encodeURIComponent(dt);\n        Et === dt && (Et = escape(dt)), D = D.split(dt).join(Et);\n      }\n    }\n  var vt = D.indexOf(\"#\");\n  vt !== -1 && (this.hash = D.substr(vt), D = D.slice(0, vt));\n  var _t = D.indexOf(\"?\");\n  if (_t !== -1 ? (this.search = D.substr(_t), this.query = D.substr(_t + 1), t && (this.query = querystring.parse(this.query)), D = D.slice(0, _t)) : t && (this.search = \"\", this.query = {}), D && (this.pathname = D), slashedProtocol[$] && this.hostname && !this.pathname && (this.pathname = \"/\"), this.pathname || this.search) {\n    var ut = this.pathname || \"\", St = this.search || \"\";\n    this.path = ut + St;\n  }\n  return this.href = this.format(), this;\n};\nfunction urlFormat(n) {\n  return util$7.isString(n) && (n = urlParse(n)), n instanceof Url ? n.format() : Url.prototype.format.call(n);\n}\nUrl.prototype.format = function() {\n  var n = this.auth || \"\";\n  n && (n = encodeURIComponent(n), n = n.replace(/%3A/i, \":\"), n += \"@\");\n  var t = this.protocol || \"\", e = this.pathname || \"\", o = this.hash || \"\", R = !1, N = \"\";\n  this.host ? R = n + this.host : this.hostname && (R = n + (this.hostname.indexOf(\":\") === -1 ? this.hostname : \"[\" + this.hostname + \"]\"), this.port && (R += \":\" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (N = querystring.stringify(this.query));\n  var M = this.search || N && \"?\" + N || \"\";\n  return t && t.substr(-1) !== \":\" && (t += \":\"), this.slashes || (!t || slashedProtocol[t]) && R !== !1 ? (R = \"//\" + (R || \"\"), e && e.charAt(0) !== \"/\" && (e = \"/\" + e)) : R || (R = \"\"), o && o.charAt(0) !== \"#\" && (o = \"#\" + o), M && M.charAt(0) !== \"?\" && (M = \"?\" + M), e = e.replace(/[?#]/g, function(D) {\n    return encodeURIComponent(D);\n  }), M = M.replace(\"#\", \"%23\"), t + R + e + M + o;\n};\nfunction urlResolve(n, t) {\n  return urlParse(n, !1, !0).resolve(t);\n}\nUrl.prototype.resolve = function(n) {\n  return this.resolveObject(urlParse(n, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(n) {\n  if (util$7.isString(n)) {\n    var t = new Url();\n    t.parse(n, !1, !0), n = t;\n  }\n  for (var e = new Url(), o = Object.keys(this), R = 0; R < o.length; R++) {\n    var N = o[R];\n    e[N] = this[N];\n  }\n  if (e.hash = n.hash, n.href === \"\")\n    return e.href = e.format(), e;\n  if (n.slashes && !n.protocol) {\n    for (var M = Object.keys(n), D = 0; D < M.length; D++) {\n      var L = M[D];\n      L !== \"protocol\" && (e[L] = n[L]);\n    }\n    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = \"/\"), e.href = e.format(), e;\n  }\n  if (n.protocol && n.protocol !== e.protocol) {\n    if (!slashedProtocol[n.protocol]) {\n      for (var B = Object.keys(n), $ = 0; $ < B.length; $++) {\n        var k = B[$];\n        e[k] = n[k];\n      }\n      return e.href = e.format(), e;\n    }\n    if (e.protocol = n.protocol, !n.host && !hostlessProtocol[n.protocol]) {\n      for (var Z = (n.pathname || \"\").split(\"/\"); Z.length && !(n.host = Z.shift()); )\n        ;\n      n.host || (n.host = \"\"), n.hostname || (n.hostname = \"\"), Z[0] !== \"\" && Z.unshift(\"\"), Z.length < 2 && Z.unshift(\"\"), e.pathname = Z.join(\"/\");\n    } else\n      e.pathname = n.pathname;\n    if (e.search = n.search, e.query = n.query, e.host = n.host || \"\", e.auth = n.auth, e.hostname = n.hostname || n.host, e.port = n.port, e.pathname || e.search) {\n      var U = e.pathname || \"\", z = e.search || \"\";\n      e.path = U + z;\n    }\n    return e.slashes = e.slashes || n.slashes, e.href = e.format(), e;\n  }\n  var X = e.pathname && e.pathname.charAt(0) === \"/\", V = n.host || n.pathname && n.pathname.charAt(0) === \"/\", W = V || X || e.host && n.pathname, Y = W, q = e.pathname && e.pathname.split(\"/\") || [], Z = n.pathname && n.pathname.split(\"/\") || [], K = e.protocol && !slashedProtocol[e.protocol];\n  if (K && (e.hostname = \"\", e.port = null, e.host && (q[0] === \"\" ? q[0] = e.host : q.unshift(e.host)), e.host = \"\", n.protocol && (n.hostname = null, n.port = null, n.host && (Z[0] === \"\" ? Z[0] = n.host : Z.unshift(n.host)), n.host = null), W = W && (Z[0] === \"\" || q[0] === \"\")), V)\n    e.host = n.host || n.host === \"\" ? n.host : e.host, e.hostname = n.hostname || n.hostname === \"\" ? n.hostname : e.hostname, e.search = n.search, e.query = n.query, q = Z;\n  else if (Z.length)\n    q || (q = []), q.pop(), q = q.concat(Z), e.search = n.search, e.query = n.query;\n  else if (!util$7.isNullOrUndefined(n.search)) {\n    if (K) {\n      e.hostname = e.host = q.shift();\n      var Q = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n      Q && (e.auth = Q.shift(), e.host = e.hostname = Q.shift());\n    }\n    return e.search = n.search, e.query = n.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.href = e.format(), e;\n  }\n  if (!q.length)\n    return e.pathname = null, e.search ? e.path = \"/\" + e.search : e.path = null, e.href = e.format(), e;\n  for (var J = q.slice(-1)[0], rt = (e.host || n.host || q.length > 1) && (J === \".\" || J === \"..\") || J === \"\", tt = 0, nt = q.length; nt >= 0; nt--)\n    J = q[nt], J === \".\" ? q.splice(nt, 1) : J === \"..\" ? (q.splice(nt, 1), tt++) : tt && (q.splice(nt, 1), tt--);\n  if (!W && !Y)\n    for (; tt--; tt)\n      q.unshift(\"..\");\n  W && q[0] !== \"\" && (!q[0] || q[0].charAt(0) !== \"/\") && q.unshift(\"\"), rt && q.join(\"/\").substr(-1) !== \"/\" && q.push(\"\");\n  var st = q[0] === \"\" || q[0] && q[0].charAt(0) === \"/\";\n  if (K) {\n    e.hostname = e.host = st ? \"\" : q.length ? q.shift() : \"\";\n    var Q = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n    Q && (e.auth = Q.shift(), e.host = e.hostname = Q.shift());\n  }\n  return W = W || e.host && q.length, W && !st && q.unshift(\"\"), q.length ? e.pathname = q.join(\"/\") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.auth = n.auth || e.auth, e.slashes = e.slashes || n.slashes, e.href = e.format(), e;\n};\nUrl.prototype.parseHost = function() {\n  var n = this.host, t = portPattern.exec(n);\n  t && (t = t[0], t !== \":\" && (this.port = t.substr(1)), n = n.substr(0, n.length - t.length)), n && (this.hostname = n);\n};\n/*!\n * @pixi/utils - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar url = {\n  parse: parse$1,\n  format: format$1,\n  resolve: resolve$1\n};\nsettings$1.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nvar saidHello = !1, VERSION = \"6.5.1\";\nfunction skipHello() {\n  saidHello = !0;\n}\nfunction sayHello(n) {\n  var t;\n  if (!saidHello) {\n    if (settings$1.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n      var e = [\n        `\n %c %c %c PixiJS ` + VERSION + \" - \\u2730 \" + n + ` \\u2730  %c  %c  http://www.pixijs.com/  %c %c \\u2665%c\\u2665%c\\u2665 \n\n`,\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff66a5; background: #030307; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ffc3dc; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\"\n      ];\n      (t = globalThis.console).log.apply(t, e);\n    } else\n      globalThis.console && globalThis.console.log(\"PixiJS \" + VERSION + \" - \" + n + \" - http://www.pixijs.com/\");\n    saidHello = !0;\n  }\n}\nvar supported;\nfunction isWebGLSupported() {\n  return typeof supported > \"u\" && (supported = function() {\n    var t = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings$1.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      var e = settings$1.ADAPTER.createCanvas(), o = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t), R = !!(o && o.getContextAttributes().stencil);\n      if (o) {\n        var N = o.getExtension(\"WEBGL_lose_context\");\n        N && N.loseContext();\n      }\n      return o = null, R;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\nvar aliceblue = \"#f0f8ff\", antiquewhite = \"#faebd7\", aqua = \"#00ffff\", aquamarine = \"#7fffd4\", azure = \"#f0ffff\", beige = \"#f5f5dc\", bisque = \"#ffe4c4\", black = \"#000000\", blanchedalmond = \"#ffebcd\", blue = \"#0000ff\", blueviolet = \"#8a2be2\", brown = \"#a52a2a\", burlywood = \"#deb887\", cadetblue = \"#5f9ea0\", chartreuse = \"#7fff00\", chocolate = \"#d2691e\", coral = \"#ff7f50\", cornflowerblue = \"#6495ed\", cornsilk = \"#fff8dc\", crimson = \"#dc143c\", cyan = \"#00ffff\", darkblue = \"#00008b\", darkcyan = \"#008b8b\", darkgoldenrod = \"#b8860b\", darkgray = \"#a9a9a9\", darkgreen = \"#006400\", darkgrey = \"#a9a9a9\", darkkhaki = \"#bdb76b\", darkmagenta = \"#8b008b\", darkolivegreen = \"#556b2f\", darkorange = \"#ff8c00\", darkorchid = \"#9932cc\", darkred = \"#8b0000\", darksalmon = \"#e9967a\", darkseagreen = \"#8fbc8f\", darkslateblue = \"#483d8b\", darkslategray = \"#2f4f4f\", darkslategrey = \"#2f4f4f\", darkturquoise = \"#00ced1\", darkviolet = \"#9400d3\", deeppink = \"#ff1493\", deepskyblue = \"#00bfff\", dimgray = \"#696969\", dimgrey = \"#696969\", dodgerblue = \"#1e90ff\", firebrick = \"#b22222\", floralwhite = \"#fffaf0\", forestgreen = \"#228b22\", fuchsia = \"#ff00ff\", gainsboro = \"#dcdcdc\", ghostwhite = \"#f8f8ff\", goldenrod = \"#daa520\", gold = \"#ffd700\", gray = \"#808080\", green = \"#008000\", greenyellow = \"#adff2f\", grey = \"#808080\", honeydew = \"#f0fff0\", hotpink = \"#ff69b4\", indianred = \"#cd5c5c\", indigo = \"#4b0082\", ivory = \"#fffff0\", khaki = \"#f0e68c\", lavenderblush = \"#fff0f5\", lavender = \"#e6e6fa\", lawngreen = \"#7cfc00\", lemonchiffon = \"#fffacd\", lightblue = \"#add8e6\", lightcoral = \"#f08080\", lightcyan = \"#e0ffff\", lightgoldenrodyellow = \"#fafad2\", lightgray = \"#d3d3d3\", lightgreen = \"#90ee90\", lightgrey = \"#d3d3d3\", lightpink = \"#ffb6c1\", lightsalmon = \"#ffa07a\", lightseagreen = \"#20b2aa\", lightskyblue = \"#87cefa\", lightslategray = \"#778899\", lightslategrey = \"#778899\", lightsteelblue = \"#b0c4de\", lightyellow = \"#ffffe0\", lime = \"#00ff00\", limegreen = \"#32cd32\", linen = \"#faf0e6\", magenta = \"#ff00ff\", maroon = \"#800000\", mediumaquamarine = \"#66cdaa\", mediumblue = \"#0000cd\", mediumorchid = \"#ba55d3\", mediumpurple = \"#9370db\", mediumseagreen = \"#3cb371\", mediumslateblue = \"#7b68ee\", mediumspringgreen = \"#00fa9a\", mediumturquoise = \"#48d1cc\", mediumvioletred = \"#c71585\", midnightblue = \"#191970\", mintcream = \"#f5fffa\", mistyrose = \"#ffe4e1\", moccasin = \"#ffe4b5\", navajowhite = \"#ffdead\", navy = \"#000080\", oldlace = \"#fdf5e6\", olive = \"#808000\", olivedrab = \"#6b8e23\", orange = \"#ffa500\", orangered = \"#ff4500\", orchid = \"#da70d6\", palegoldenrod = \"#eee8aa\", palegreen = \"#98fb98\", paleturquoise = \"#afeeee\", palevioletred = \"#db7093\", papayawhip = \"#ffefd5\", peachpuff = \"#ffdab9\", peru = \"#cd853f\", pink = \"#ffc0cb\", plum = \"#dda0dd\", powderblue = \"#b0e0e6\", purple = \"#800080\", rebeccapurple = \"#663399\", red = \"#ff0000\", rosybrown = \"#bc8f8f\", royalblue = \"#4169e1\", saddlebrown = \"#8b4513\", salmon = \"#fa8072\", sandybrown = \"#f4a460\", seagreen = \"#2e8b57\", seashell = \"#fff5ee\", sienna = \"#a0522d\", silver = \"#c0c0c0\", skyblue = \"#87ceeb\", slateblue = \"#6a5acd\", slategray = \"#708090\", slategrey = \"#708090\", snow = \"#fffafa\", springgreen = \"#00ff7f\", steelblue = \"#4682b4\", tan = \"#d2b48c\", teal = \"#008080\", thistle = \"#d8bfd8\", tomato = \"#ff6347\", turquoise = \"#40e0d0\", violet = \"#ee82ee\", wheat = \"#f5deb3\", white = \"#ffffff\", whitesmoke = \"#f5f5f5\", yellow = \"#ffff00\", yellowgreen = \"#9acd32\", cssColorNames = {\n  aliceblue,\n  antiquewhite,\n  aqua,\n  aquamarine,\n  azure,\n  beige,\n  bisque,\n  black,\n  blanchedalmond,\n  blue,\n  blueviolet,\n  brown,\n  burlywood,\n  cadetblue,\n  chartreuse,\n  chocolate,\n  coral,\n  cornflowerblue,\n  cornsilk,\n  crimson,\n  cyan,\n  darkblue,\n  darkcyan,\n  darkgoldenrod,\n  darkgray,\n  darkgreen,\n  darkgrey,\n  darkkhaki,\n  darkmagenta,\n  darkolivegreen,\n  darkorange,\n  darkorchid,\n  darkred,\n  darksalmon,\n  darkseagreen,\n  darkslateblue,\n  darkslategray,\n  darkslategrey,\n  darkturquoise,\n  darkviolet,\n  deeppink,\n  deepskyblue,\n  dimgray,\n  dimgrey,\n  dodgerblue,\n  firebrick,\n  floralwhite,\n  forestgreen,\n  fuchsia,\n  gainsboro,\n  ghostwhite,\n  goldenrod,\n  gold,\n  gray,\n  green,\n  greenyellow,\n  grey,\n  honeydew,\n  hotpink,\n  indianred,\n  indigo,\n  ivory,\n  khaki,\n  lavenderblush,\n  lavender,\n  lawngreen,\n  lemonchiffon,\n  lightblue,\n  lightcoral,\n  lightcyan,\n  lightgoldenrodyellow,\n  lightgray,\n  lightgreen,\n  lightgrey,\n  lightpink,\n  lightsalmon,\n  lightseagreen,\n  lightskyblue,\n  lightslategray,\n  lightslategrey,\n  lightsteelblue,\n  lightyellow,\n  lime,\n  limegreen,\n  linen,\n  magenta,\n  maroon,\n  mediumaquamarine,\n  mediumblue,\n  mediumorchid,\n  mediumpurple,\n  mediumseagreen,\n  mediumslateblue,\n  mediumspringgreen,\n  mediumturquoise,\n  mediumvioletred,\n  midnightblue,\n  mintcream,\n  mistyrose,\n  moccasin,\n  navajowhite,\n  navy,\n  oldlace,\n  olive,\n  olivedrab,\n  orange,\n  orangered,\n  orchid,\n  palegoldenrod,\n  palegreen,\n  paleturquoise,\n  palevioletred,\n  papayawhip,\n  peachpuff,\n  peru,\n  pink,\n  plum,\n  powderblue,\n  purple,\n  rebeccapurple,\n  red,\n  rosybrown,\n  royalblue,\n  saddlebrown,\n  salmon,\n  sandybrown,\n  seagreen,\n  seashell,\n  sienna,\n  silver,\n  skyblue,\n  slateblue,\n  slategray,\n  slategrey,\n  snow,\n  springgreen,\n  steelblue,\n  tan,\n  teal,\n  thistle,\n  tomato,\n  turquoise,\n  violet,\n  wheat,\n  white,\n  whitesmoke,\n  yellow,\n  yellowgreen\n};\nfunction hex2rgb(n, t) {\n  return t === void 0 && (t = []), t[0] = (n >> 16 & 255) / 255, t[1] = (n >> 8 & 255) / 255, t[2] = (n & 255) / 255, t;\n}\nfunction hex2string(n) {\n  var t = n.toString(16);\n  return t = \"000000\".substring(0, 6 - t.length) + t, \"#\" + t;\n}\nfunction string2hex(n) {\n  return typeof n == \"string\" && (n = cssColorNames[n.toLowerCase()] || n, n[0] === \"#\" && (n = n.slice(1))), parseInt(n, 16);\n}\nfunction mapPremultipliedBlendModes$1() {\n  for (var n = [], t = [], e = 0; e < 32; e++)\n    n[e] = e, t[e] = e;\n  n[BLEND_MODES$5.NORMAL_NPM] = BLEND_MODES$5.NORMAL, n[BLEND_MODES$5.ADD_NPM] = BLEND_MODES$5.ADD, n[BLEND_MODES$5.SCREEN_NPM] = BLEND_MODES$5.SCREEN, t[BLEND_MODES$5.NORMAL] = BLEND_MODES$5.NORMAL_NPM, t[BLEND_MODES$5.ADD] = BLEND_MODES$5.ADD_NPM, t[BLEND_MODES$5.SCREEN] = BLEND_MODES$5.SCREEN_NPM;\n  var o = [];\n  return o.push(t), o.push(n), o;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes$1();\nfunction correctBlendMode(n, t) {\n  return premultiplyBlendMode[t ? 1 : 0][n];\n}\nfunction premultiplyRgba(n, t, e, o) {\n  return e = e || new Float32Array(4), o || o === void 0 ? (e[0] = n[0] * t, e[1] = n[1] * t, e[2] = n[2] * t) : (e[0] = n[0], e[1] = n[1], e[2] = n[2]), e[3] = t, e;\n}\nfunction premultiplyTint(n, t) {\n  if (t === 1)\n    return (t * 255 << 24) + n;\n  if (t === 0)\n    return 0;\n  var e = n >> 16 & 255, o = n >> 8 & 255, R = n & 255;\n  return e = e * t + 0.5 | 0, o = o * t + 0.5 | 0, R = R * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (o << 8) + R;\n}\nfunction premultiplyTintToRgba(n, t, e, o) {\n  return e = e || new Float32Array(4), e[0] = (n >> 16 & 255) / 255, e[1] = (n >> 8 & 255) / 255, e[2] = (n & 255) / 255, (o || o === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;\n}\nfunction createIndicesForQuads(n, t) {\n  t === void 0 && (t = null);\n  var e = n * 6;\n  if (t = t || new Uint16Array(e), t.length !== e)\n    throw new Error(\"Out buffer length is incorrect, got \" + t.length + \" and expected \" + e);\n  for (var o = 0, R = 0; o < e; o += 6, R += 4)\n    t[o + 0] = R + 0, t[o + 1] = R + 1, t[o + 2] = R + 2, t[o + 3] = R + 0, t[o + 4] = R + 2, t[o + 5] = R + 3;\n  return t;\n}\nfunction getBufferType(n) {\n  if (n.BYTES_PER_ELEMENT === 4)\n    return n instanceof Float32Array ? \"Float32Array\" : n instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (n.BYTES_PER_ELEMENT === 2) {\n    if (n instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (n.BYTES_PER_ELEMENT === 1 && n instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nfunction nextPow2(n) {\n  return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;\n}\nfunction isPow2(n) {\n  return !(n & n - 1) && !!n;\n}\nfunction log2(n) {\n  var t = (n > 65535 ? 1 : 0) << 4;\n  n >>>= t;\n  var e = (n > 255 ? 1 : 0) << 3;\n  return n >>>= e, t |= e, e = (n > 15 ? 1 : 0) << 2, n >>>= e, t |= e, e = (n > 3 ? 1 : 0) << 1, n >>>= e, t |= e, t | n >> 1;\n}\nfunction removeItems(n, t, e) {\n  var o = n.length, R;\n  if (!(t >= o || e === 0)) {\n    e = t + e > o ? o - t : e;\n    var N = o - e;\n    for (R = t; R < N; ++R)\n      n[R] = n[R + e];\n    n.length = N;\n  }\n}\nfunction sign(n) {\n  return n === 0 ? 0 : n < 0 ? -1 : 1;\n}\nvar nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nvar warnings$1 = {};\nfunction deprecation$1(n, t, e) {\n  if (e === void 0 && (e = 3), !warnings$1[t]) {\n    var o = new Error().stack;\n    typeof o > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + n) : (o = o.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + n), console.warn(o), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + n), console.warn(o))), warnings$1[t] = !0;\n  }\n}\nvar ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction clearTextureCache() {\n  var n;\n  for (n in TextureCache)\n    delete TextureCache[n];\n  for (n in BaseTextureCache)\n    delete BaseTextureCache[n];\n}\nvar CanvasRenderTarget = function() {\n  function n(t, e, o) {\n    this.canvas = settings$1.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = o || settings$1.RESOLUTION, this.resize(t, e);\n  }\n  return n.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }, n.prototype.resize = function(t, e) {\n    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n  }, n.prototype.destroy = function() {\n    this.context = null, this.canvas = null;\n  }, Object.defineProperty(n.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(t) {\n      this.canvas.width = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(t) {\n      this.canvas.height = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}();\nfunction trimCanvas(n) {\n  var t = n.width, e = n.height, o = n.getContext(\"2d\"), R = o.getImageData(0, 0, t, e), N = R.data, M = N.length, D = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  }, L = null, B, $, k;\n  for (B = 0; B < M; B += 4)\n    N[B + 3] !== 0 && ($ = B / 4 % t, k = ~~(B / 4 / t), D.top === null && (D.top = k), (D.left === null || $ < D.left) && (D.left = $), (D.right === null || D.right < $) && (D.right = $ + 1), (D.bottom === null || D.bottom < k) && (D.bottom = k));\n  return D.top !== null && (t = D.right - D.left, e = D.bottom - D.top + 1, L = o.getImageData(D.left, D.top, t, e)), {\n    height: e,\n    width: t,\n    data: L\n  };\n}\nvar tempAnchor$1;\nfunction determineCrossOrigin(n, t) {\n  if (t === void 0 && (t = globalThis.location), n.indexOf(\"data:\") === 0)\n    return \"\";\n  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement(\"a\")), tempAnchor$1.href = n;\n  var e = url.parse(tempAnchor$1.href), o = !e.port && t.port === \"\" || e.port === t.port;\n  return e.hostname !== t.hostname || !o || e.protocol !== t.protocol ? \"anonymous\" : \"\";\n}\nfunction getResolutionOfUrl(n, t) {\n  var e = settings$1.RETINA_PREFIX.exec(n);\n  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;\n}\n/*!\n * @pixi/extensions - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/extensions is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$9 = function() {\n  return __assign$9 = Object.assign || function(t) {\n    for (var e = arguments, o, R = 1, N = arguments.length; R < N; R++) {\n      o = e[R];\n      for (var M in o)\n        Object.prototype.hasOwnProperty.call(o, M) && (t[M] = o[M]);\n    }\n    return t;\n  }, __assign$9.apply(this, arguments);\n}, ExtensionType;\n(function(n) {\n  n.Application = \"application\", n.RendererPlugin = \"renderer-webgl-plugin\", n.CanvasRendererPlugin = \"renderer-canvas-plugin\", n.Loader = \"loader\", n.LoadParser = \"load-parser\", n.ResolveParser = \"resolve-parser\", n.CacheParser = \"cache-parser\", n.DetectionParser = \"detection-parser\";\n})(ExtensionType || (ExtensionType = {}));\nvar normalizeExtension = function(n) {\n  if (typeof n == \"function\" || typeof n == \"object\" && n.extension) {\n    if (!n.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    var t = typeof n.extension != \"object\" ? { type: n.extension } : n.extension;\n    n = __assign$9(__assign$9({}, t), { ref: n });\n  }\n  if (typeof n == \"object\")\n    n = __assign$9({}, n);\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof n.type == \"string\" && (n.type = [n.type]), n;\n}, extensions = {\n  _addHandlers: null,\n  _removeHandlers: null,\n  _queue: {},\n  remove: function() {\n    for (var n = arguments, t = this, e = [], o = 0; o < arguments.length; o++)\n      e[o] = n[o];\n    return e.map(normalizeExtension).forEach(function(R) {\n      R.type.forEach(function(N) {\n        var M, D;\n        return (D = (M = t._removeHandlers)[N]) === null || D === void 0 ? void 0 : D.call(M, R);\n      });\n    }), this;\n  },\n  add: function() {\n    for (var n = arguments, t = this, e = [], o = 0; o < arguments.length; o++)\n      e[o] = n[o];\n    return e.map(normalizeExtension).forEach(function(R) {\n      R.type.forEach(function(N) {\n        var M = t._addHandlers, D = t._queue;\n        M[N] ? M[N](R) : (D[N] = D[N] || [], D[N].push(R));\n      });\n    }), this;\n  },\n  handle: function(n, t, e) {\n    var o = this._addHandlers = this._addHandlers || {}, R = this._removeHandlers = this._removeHandlers || {};\n    if (o[n] || R[n])\n      throw new Error(\"Extension type \" + n + \" already has a handler\");\n    o[n] = t, R[n] = e;\n    var N = this._queue;\n    return N[n] && (N[n].forEach(function(M) {\n      return t(M);\n    }), delete N[n]), this;\n  },\n  handleByMap: function(n, t) {\n    return this.handle(n, function(e) {\n      t[e.name] = e.ref;\n    }, function(e) {\n      delete t[e.name];\n    });\n  },\n  handleByList: function(n, t) {\n    return this.handle(n, function(e) {\n      var o, R;\n      t.push(e.ref), n === ExtensionType.Loader && ((R = (o = e.ref).add) === null || R === void 0 || R.call(o));\n    }, function(e) {\n      var o = t.indexOf(e.ref);\n      o !== -1 && t.splice(o, 1);\n    });\n  }\n};\n/*!\n * @pixi/runner - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/runner is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Runner = function() {\n  function n(t) {\n    this.items = [], this._name = t, this._aliasCount = 0;\n  }\n  return n.prototype.emit = function(t, e, o, R, N, M, D, L) {\n    if (arguments.length > 8)\n      throw new Error(\"max arguments reached\");\n    var B = this, $ = B.name, k = B.items;\n    this._aliasCount++;\n    for (var U = 0, z = k.length; U < z; U++)\n      k[U][$](t, e, o, R, N, M, D, L);\n    return k === this.items && this._aliasCount--, this;\n  }, n.prototype.ensureNonAliasedItems = function() {\n    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n  }, n.prototype.add = function(t) {\n    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;\n  }, n.prototype.remove = function(t) {\n    var e = this.items.indexOf(t);\n    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;\n  }, n.prototype.contains = function(t) {\n    return this.items.indexOf(t) !== -1;\n  }, n.prototype.removeAll = function() {\n    return this.ensureNonAliasedItems(), this.items.length = 0, this;\n  }, n.prototype.destroy = function() {\n    this.removeAll(), this.items = null, this._name = null;\n  }, Object.defineProperty(n.prototype, \"empty\", {\n    get: function() {\n      return this.items.length === 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"name\", {\n    get: function() {\n      return this._name;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}();\nObject.defineProperties(Runner.prototype, {\n  dispatch: { value: Runner.prototype.emit },\n  run: { value: Runner.prototype.emit }\n});\n/*!\n * @pixi/ticker - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/ticker is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.TARGET_FPMS = 0.06;\nvar UPDATE_PRIORITY;\n(function(n) {\n  n[n.INTERACTION = 50] = \"INTERACTION\", n[n.HIGH = 25] = \"HIGH\", n[n.NORMAL = 0] = \"NORMAL\", n[n.LOW = -25] = \"LOW\", n[n.UTILITY = -50] = \"UTILITY\";\n})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));\nvar TickerListener = function() {\n  function n(t, e, o, R) {\n    e === void 0 && (e = null), o === void 0 && (o = 0), R === void 0 && (R = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = o, this.once = R;\n  }\n  return n.prototype.match = function(t, e) {\n    return e === void 0 && (e = null), this.fn === t && this.context === e;\n  }, n.prototype.emit = function(t) {\n    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));\n    var e = this.next;\n    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;\n  }, n.prototype.connect = function(t) {\n    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;\n  }, n.prototype.destroy = function(t) {\n    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n    var e = this.next;\n    return this.next = t ? null : e, this.previous = null, e;\n  }, n;\n}(), Ticker = function() {\n  function n() {\n    var t = this;\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings$1.TARGET_FPMS, this.elapsedMS = 1 / settings$1.TARGET_FPMS, this._tick = function(e) {\n      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));\n    };\n  }\n  return n.prototype._requestIfNeeded = function() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }, n.prototype._cancelIfNeeded = function() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }, n.prototype._startIfPossible = function() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }, n.prototype.add = function(t, e, o) {\n    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o));\n  }, n.prototype.addOnce = function(t, e, o) {\n    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o, !0));\n  }, n.prototype._addListener = function(t) {\n    var e = this._head.next, o = this._head;\n    if (!e)\n      t.connect(o);\n    else {\n      for (; e; ) {\n        if (t.priority > e.priority) {\n          t.connect(o);\n          break;\n        }\n        o = e, e = e.next;\n      }\n      t.previous || t.connect(o);\n    }\n    return this._startIfPossible(), this;\n  }, n.prototype.remove = function(t, e) {\n    for (var o = this._head.next; o; )\n      o.match(t, e) ? o = o.destroy() : o = o.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }, Object.defineProperty(n.prototype, \"count\", {\n    get: function() {\n      if (!this._head)\n        return 0;\n      for (var t = 0, e = this._head; e = e.next; )\n        t++;\n      return t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.start = function() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }, n.prototype.stop = function() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }, n.prototype.destroy = function() {\n    if (!this._protected) {\n      this.stop();\n      for (var t = this._head.next; t; )\n        t = t.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }, n.prototype.update = function(t) {\n    t === void 0 && (t = performance.now());\n    var e;\n    if (t > this.lastTime) {\n      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {\n        var o = t - this._lastFrame | 0;\n        if (o < this._minElapsedMS)\n          return;\n        this._lastFrame = t - o % this._minElapsedMS;\n      }\n      this.deltaMS = e, this.deltaTime = this.deltaMS * settings$1.TARGET_FPMS;\n      for (var R = this._head, N = R.next; N; )\n        N = N.emit(this.deltaTime);\n      R.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = t;\n  }, Object.defineProperty(n.prototype, \"FPS\", {\n    get: function() {\n      return 1e3 / this.elapsedMS;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"minFPS\", {\n    get: function() {\n      return 1e3 / this._maxElapsedMS;\n    },\n    set: function(t) {\n      var e = Math.min(this.maxFPS, t), o = Math.min(Math.max(0, e) / 1e3, settings$1.TARGET_FPMS);\n      this._maxElapsedMS = 1 / o;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"maxFPS\", {\n    get: function() {\n      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n    },\n    set: function(t) {\n      if (t === 0)\n        this._minElapsedMS = 0;\n      else {\n        var e = Math.max(this.minFPS, t);\n        this._minElapsedMS = 1 / (e / 1e3);\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"shared\", {\n    get: function() {\n      if (!n._shared) {\n        var t = n._shared = new n();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return n._shared;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"system\", {\n    get: function() {\n      if (!n._system) {\n        var t = n._system = new n();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return n._system;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}(), TickerPlugin = function() {\n  function n() {\n  }\n  return n.init = function(t) {\n    var e = this;\n    t = Object.assign({\n      autoStart: !0,\n      sharedTicker: !1\n    }, t), Object.defineProperty(this, \"ticker\", {\n      set: function(o) {\n        this._ticker && this._ticker.remove(this.render, this), this._ticker = o, o && o.add(this.render, this, UPDATE_PRIORITY.LOW);\n      },\n      get: function() {\n        return this._ticker;\n      }\n    }), this.stop = function() {\n      e._ticker.stop();\n    }, this.start = function() {\n      e._ticker.start();\n    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();\n  }, n.destroy = function() {\n    if (this._ticker) {\n      var t = this._ticker;\n      this.ticker = null, t.destroy();\n    }\n  }, n.extension = ExtensionType.Application, n;\n}();\n/*!\n * @pixi/math - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;\n(function(n) {\n  n[n.POLY = 0] = \"POLY\", n[n.RECT = 1] = \"RECT\", n[n.CIRC = 2] = \"CIRC\", n[n.ELIP = 3] = \"ELIP\", n[n.RREC = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\nvar Point = function() {\n  function n(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;\n  }\n  return n.prototype.clone = function() {\n    return new n(this.x, this.y);\n  }, n.prototype.copyFrom = function(t) {\n    return this.set(t.x, t.y), this;\n  }, n.prototype.copyTo = function(t) {\n    return t.set(this.x, this.y), t;\n  }, n.prototype.equals = function(t) {\n    return t.x === this.x && t.y === this.y;\n  }, n.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n  }, n;\n}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {\n  function n(t, e, o, R) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), this.x = Number(t), this.y = Number(e), this.width = Number(o), this.height = Number(R), this.type = SHAPES.RECT;\n  }\n  return Object.defineProperty(n.prototype, \"left\", {\n    get: function() {\n      return this.x;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"right\", {\n    get: function() {\n      return this.x + this.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"top\", {\n    get: function() {\n      return this.y;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"bottom\", {\n    get: function() {\n      return this.y + this.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"EMPTY\", {\n    get: function() {\n      return new n(0, 0, 0, 0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.clone = function() {\n    return new n(this.x, this.y, this.width, this.height);\n  }, n.prototype.copyFrom = function(t) {\n    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;\n  }, n.prototype.copyTo = function(t) {\n    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;\n  }, n.prototype.contains = function(t, e) {\n    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;\n  }, n.prototype.intersects = function(t, e) {\n    if (!e) {\n      var o = this.x < t.x ? t.x : this.x, R = this.right > t.right ? t.right : this.right;\n      if (R <= o)\n        return !1;\n      var N = this.y < t.y ? t.y : this.y, M = this.bottom > t.bottom ? t.bottom : this.bottom;\n      return M > N;\n    }\n    var D = this.left, L = this.right, B = this.top, $ = this.bottom;\n    if (L <= D || $ <= B)\n      return !1;\n    var k = tempPoints$1[0].set(t.left, t.top), U = tempPoints$1[1].set(t.left, t.bottom), z = tempPoints$1[2].set(t.right, t.top), X = tempPoints$1[3].set(t.right, t.bottom);\n    if (z.x <= k.x || U.y <= k.y)\n      return !1;\n    var V = Math.sign(e.a * e.d - e.b * e.c);\n    if (V === 0 || (e.apply(k, k), e.apply(U, U), e.apply(z, z), e.apply(X, X), Math.max(k.x, U.x, z.x, X.x) <= D || Math.min(k.x, U.x, z.x, X.x) >= L || Math.max(k.y, U.y, z.y, X.y) <= B || Math.min(k.y, U.y, z.y, X.y) >= $))\n      return !1;\n    var W = V * (U.y - k.y), Y = V * (k.x - U.x), q = W * D + Y * B, Z = W * L + Y * B, K = W * D + Y * $, Q = W * L + Y * $;\n    if (Math.max(q, Z, K, Q) <= W * k.x + Y * k.y || Math.min(q, Z, K, Q) >= W * X.x + Y * X.y)\n      return !1;\n    var J = V * (k.y - z.y), rt = V * (z.x - k.x), tt = J * D + rt * B, nt = J * L + rt * B, st = J * D + rt * $, ut = J * L + rt * $;\n    return !(Math.max(tt, nt, st, ut) <= J * k.x + rt * k.y || Math.min(tt, nt, st, ut) >= J * X.x + rt * X.y);\n  }, n.prototype.pad = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;\n  }, n.prototype.fit = function(t) {\n    var e = Math.max(this.x, t.x), o = Math.min(this.x + this.width, t.x + t.width), R = Math.max(this.y, t.y), N = Math.min(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = Math.max(o - e, 0), this.y = R, this.height = Math.max(N - R, 0), this;\n  }, n.prototype.ceil = function(t, e) {\n    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);\n    var o = Math.ceil((this.x + this.width - e) * t) / t, R = Math.ceil((this.y + this.height - e) * t) / t;\n    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = o - this.x, this.height = R - this.y, this;\n  }, n.prototype.enlarge = function(t) {\n    var e = Math.min(this.x, t.x), o = Math.max(this.x + this.width, t.x + t.width), R = Math.min(this.y, t.y), N = Math.max(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = o - e, this.y = R, this.height = N - R, this;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, n;\n}(), Circle = function() {\n  function n(t, e, o) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), this.x = t, this.y = e, this.radius = o, this.type = SHAPES.CIRC;\n  }\n  return n.prototype.clone = function() {\n    return new n(this.x, this.y, this.radius);\n  }, n.prototype.contains = function(t, e) {\n    if (this.radius <= 0)\n      return !1;\n    var o = this.radius * this.radius, R = this.x - t, N = this.y - e;\n    return R *= R, N *= N, R + N <= o;\n  }, n.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n  }, n;\n}(), Ellipse = function() {\n  function n(t, e, o, R) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), this.x = t, this.y = e, this.width = o, this.height = R, this.type = SHAPES.ELIP;\n  }\n  return n.prototype.clone = function() {\n    return new n(this.x, this.y, this.width, this.height);\n  }, n.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    var o = (t - this.x) / this.width, R = (e - this.y) / this.height;\n    return o *= o, R *= R, o + R <= 1;\n  }, n.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, n;\n}(), Polygon = function() {\n  function n() {\n    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)\n      e[o] = t[o];\n    var R = Array.isArray(e[0]) ? e[0] : e;\n    if (typeof R[0] != \"number\") {\n      for (var N = [], M = 0, D = R.length; M < D; M++)\n        N.push(R[M].x, R[M].y);\n      R = N;\n    }\n    this.points = R, this.type = SHAPES.POLY, this.closeStroke = !0;\n  }\n  return n.prototype.clone = function() {\n    var t = this.points.slice(), e = new n(t);\n    return e.closeStroke = this.closeStroke, e;\n  }, n.prototype.contains = function(t, e) {\n    for (var o = !1, R = this.points.length / 2, N = 0, M = R - 1; N < R; M = N++) {\n      var D = this.points[N * 2], L = this.points[N * 2 + 1], B = this.points[M * 2], $ = this.points[M * 2 + 1], k = L > e != $ > e && t < (B - D) * ((e - L) / ($ - L)) + D;\n      k && (o = !o);\n    }\n    return o;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(t, e) {\n      return t + \", \" + e;\n    }, \"\") + \"]\");\n  }, n;\n}(), RoundedRectangle = function() {\n  function n(t, e, o, R, N) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), N === void 0 && (N = 20), this.x = t, this.y = e, this.width = o, this.height = R, this.radius = N, this.type = SHAPES.RREC;\n  }\n  return n.prototype.clone = function() {\n    return new n(this.x, this.y, this.width, this.height, this.radius);\n  }, n.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {\n      var o = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n      if (e >= this.y + o && e <= this.y + this.height - o || t >= this.x + o && t <= this.x + this.width - o)\n        return !0;\n      var R = t - (this.x + o), N = e - (this.y + o), M = o * o;\n      if (R * R + N * N <= M || (R = t - (this.x + this.width - o), R * R + N * N <= M) || (N = e - (this.y + this.height - o), R * R + N * N <= M) || (R = t - (this.x + o), R * R + N * N <= M))\n        return !0;\n    }\n    return !1;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n  }, n;\n}(), ObservablePoint = function() {\n  function n(t, e, o, R) {\n    o === void 0 && (o = 0), R === void 0 && (R = 0), this._x = o, this._y = R, this.cb = t, this.scope = e;\n  }\n  return n.prototype.clone = function(t, e) {\n    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new n(t, e, this._x, this._y);\n  }, n.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;\n  }, n.prototype.copyFrom = function(t) {\n    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;\n  }, n.prototype.copyTo = function(t) {\n    return t.set(this._x, this._y), t;\n  }, n.prototype.equals = function(t) {\n    return t.x === this._x && t.y === this._y;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:ObservablePoint x=\" + 0 + \" y=\" + 0 + \" scope=\" + this.scope + \"]\";\n  }, Object.defineProperty(n.prototype, \"x\", {\n    get: function() {\n      return this._x;\n    },\n    set: function(t) {\n      this._x !== t && (this._x = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"y\", {\n    get: function() {\n      return this._y;\n    },\n    set: function(t) {\n      this._y !== t && (this._y = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}(), Matrix = function() {\n  function n(t, e, o, R, N, M) {\n    t === void 0 && (t = 1), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 0), M === void 0 && (M = 0), this.array = null, this.a = t, this.b = e, this.c = o, this.d = R, this.tx = N, this.ty = M;\n  }\n  return n.prototype.fromArray = function(t) {\n    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];\n  }, n.prototype.set = function(t, e, o, R, N, M) {\n    return this.a = t, this.b = e, this.c = o, this.d = R, this.tx = N, this.ty = M, this;\n  }, n.prototype.toArray = function(t, e) {\n    this.array || (this.array = new Float32Array(9));\n    var o = e || this.array;\n    return t ? (o[0] = this.a, o[1] = this.b, o[2] = 0, o[3] = this.c, o[4] = this.d, o[5] = 0, o[6] = this.tx, o[7] = this.ty, o[8] = 1) : (o[0] = this.a, o[1] = this.c, o[2] = this.tx, o[3] = this.b, o[4] = this.d, o[5] = this.ty, o[6] = 0, o[7] = 0, o[8] = 1), o;\n  }, n.prototype.apply = function(t, e) {\n    e = e || new Point();\n    var o = t.x, R = t.y;\n    return e.x = this.a * o + this.c * R + this.tx, e.y = this.b * o + this.d * R + this.ty, e;\n  }, n.prototype.applyInverse = function(t, e) {\n    e = e || new Point();\n    var o = 1 / (this.a * this.d + this.c * -this.b), R = t.x, N = t.y;\n    return e.x = this.d * o * R + -this.c * o * N + (this.ty * this.c - this.tx * this.d) * o, e.y = this.a * o * N + -this.b * o * R + (-this.ty * this.a + this.tx * this.b) * o, e;\n  }, n.prototype.translate = function(t, e) {\n    return this.tx += t, this.ty += e, this;\n  }, n.prototype.scale = function(t, e) {\n    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;\n  }, n.prototype.rotate = function(t) {\n    var e = Math.cos(t), o = Math.sin(t), R = this.a, N = this.c, M = this.tx;\n    return this.a = R * e - this.b * o, this.b = R * o + this.b * e, this.c = N * e - this.d * o, this.d = N * o + this.d * e, this.tx = M * e - this.ty * o, this.ty = M * o + this.ty * e, this;\n  }, n.prototype.append = function(t) {\n    var e = this.a, o = this.b, R = this.c, N = this.d;\n    return this.a = t.a * e + t.b * R, this.b = t.a * o + t.b * N, this.c = t.c * e + t.d * R, this.d = t.c * o + t.d * N, this.tx = t.tx * e + t.ty * R + this.tx, this.ty = t.tx * o + t.ty * N + this.ty, this;\n  }, n.prototype.setTransform = function(t, e, o, R, N, M, D, L, B) {\n    return this.a = Math.cos(D + B) * N, this.b = Math.sin(D + B) * N, this.c = -Math.sin(D - L) * M, this.d = Math.cos(D - L) * M, this.tx = t - (o * this.a + R * this.c), this.ty = e - (o * this.b + R * this.d), this;\n  }, n.prototype.prepend = function(t) {\n    var e = this.tx;\n    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {\n      var o = this.a, R = this.c;\n      this.a = o * t.a + this.b * t.c, this.b = o * t.b + this.b * t.d, this.c = R * t.a + this.d * t.c, this.d = R * t.b + this.d * t.d;\n    }\n    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;\n  }, n.prototype.decompose = function(t) {\n    var e = this.a, o = this.b, R = this.c, N = this.d, M = t.pivot, D = -Math.atan2(-R, N), L = Math.atan2(o, e), B = Math.abs(D + L);\n    return B < 1e-5 || Math.abs(PI_2 - B) < 1e-5 ? (t.rotation = L, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = D, t.skew.y = L), t.scale.x = Math.sqrt(e * e + o * o), t.scale.y = Math.sqrt(R * R + N * N), t.position.x = this.tx + (M.x * e + M.y * R), t.position.y = this.ty + (M.x * o + M.y * N), t;\n  }, n.prototype.invert = function() {\n    var t = this.a, e = this.b, o = this.c, R = this.d, N = this.tx, M = t * R - e * o;\n    return this.a = R / M, this.b = -e / M, this.c = -o / M, this.d = t / M, this.tx = (o * this.ty - R * N) / M, this.ty = -(t * this.ty - e * N) / M, this;\n  }, n.prototype.identity = function() {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n  }, n.prototype.clone = function() {\n    var t = new n();\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, n.prototype.copyTo = function(t) {\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, n.prototype.copyFrom = function(t) {\n    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n  }, Object.defineProperty(n, \"IDENTITY\", {\n    get: function() {\n      return new n();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"TEMP_MATRIX\", {\n    get: function() {\n      return new n();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (var n = 0; n < 16; n++) {\n    var t = [];\n    rotationCayley.push(t);\n    for (var e = 0; e < 16; e++)\n      for (var o = signum(ux[n] * ux[e] + vx[n] * uy[e]), R = signum(uy[n] * ux[e] + vy[n] * uy[e]), N = signum(ux[n] * vx[e] + vx[n] * vy[e]), M = signum(uy[n] * vx[e] + vy[n] * vy[e]), D = 0; D < 16; D++)\n        if (ux[D] === o && uy[D] === R && vx[D] === N && vy[D] === M) {\n          t.push(D);\n          break;\n        }\n  }\n  for (var n = 0; n < 16; n++) {\n    var L = new Matrix();\n    L.set(ux[n], uy[n], vx[n], vy[n], 0, 0), rotationMatrices.push(L);\n  }\n}\ninit();\nvar groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: function(n) {\n    return ux[n];\n  },\n  uY: function(n) {\n    return uy[n];\n  },\n  vX: function(n) {\n    return vx[n];\n  },\n  vY: function(n) {\n    return vy[n];\n  },\n  inv: function(n) {\n    return n & 8 ? n & 15 : -n & 7;\n  },\n  add: function(n, t) {\n    return rotationCayley[n][t];\n  },\n  sub: function(n, t) {\n    return rotationCayley[n][groupD8.inv(t)];\n  },\n  rotate180: function(n) {\n    return n ^ 4;\n  },\n  isVertical: function(n) {\n    return (n & 3) === 2;\n  },\n  byDirection: function(n, t) {\n    return Math.abs(n) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(n) ? n > 0 ? groupD8.E : groupD8.W : t > 0 ? n > 0 ? groupD8.SE : groupD8.SW : n > 0 ? groupD8.NE : groupD8.NW;\n  },\n  matrixAppendRotationInv: function(n, t, e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0);\n    var R = rotationMatrices[groupD8.inv(t)];\n    R.tx = e, R.ty = o, n.append(R);\n  }\n}, Transform = function() {\n  function n() {\n    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n  }\n  return n.prototype.onChange = function() {\n    this._localID++;\n  }, n.prototype.updateSkew = function() {\n    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n  }, n.prototype.updateLocalTransform = function() {\n    var t = this.localTransform;\n    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);\n  }, n.prototype.updateTransform = function(t) {\n    var e = this.localTransform;\n    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {\n      var o = t.worldTransform, R = this.worldTransform;\n      R.a = e.a * o.a + e.b * o.c, R.b = e.a * o.b + e.b * o.d, R.c = e.c * o.a + e.d * o.c, R.d = e.c * o.b + e.d * o.d, R.tx = e.tx * o.a + e.ty * o.c + o.tx, R.ty = e.tx * o.b + e.ty * o.d + o.ty, this._parentID = t._worldID, this._worldID++;\n    }\n  }, n.prototype.setFromMatrix = function(t) {\n    t.decompose(this), this._localID++;\n  }, Object.defineProperty(n.prototype, \"rotation\", {\n    get: function() {\n      return this._rotation;\n    },\n    set: function(t) {\n      this._rotation !== t && (this._rotation = t, this.updateSkew());\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.IDENTITY = new n(), n;\n}();\n/*!\n * @pixi/core - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/core is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.PREFER_ENV = isMobile$2.any ? ENV$5.WEBGL : ENV$5.WEBGL2;\nsettings$1.STRICT_TEXTURE_CACHE = !1;\nvar INSTALLED = [];\nfunction autoDetectResource(n, t) {\n  if (!n)\n    return null;\n  var e = \"\";\n  if (typeof n == \"string\") {\n    var o = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(n);\n    o && (e = o[1].toLowerCase());\n  }\n  for (var R = INSTALLED.length - 1; R >= 0; --R) {\n    var N = INSTALLED[R];\n    if (N.test && N.test(n, e))\n      return new N(n, t);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$q = function(n, t) {\n  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$q(n, t);\n};\nfunction __extends$q(n, t) {\n  extendStatics$q(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$8 = function() {\n  return __assign$8 = Object.assign || function(t) {\n    for (var e = arguments, o, R = 1, N = arguments.length; R < N; R++) {\n      o = e[R];\n      for (var M in o)\n        Object.prototype.hasOwnProperty.call(o, M) && (t[M] = o[M]);\n    }\n    return t;\n  }, __assign$8.apply(this, arguments);\n};\nfunction __rest$3(n, t) {\n  var e = {};\n  for (var o in n)\n    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);\n  if (n != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)\n      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);\n  return e;\n}\nvar Resource = function() {\n  function n(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner(\"setRealSize\"), this.onUpdate = new Runner(\"update\"), this.onError = new Runner(\"onError\");\n  }\n  return n.prototype.bind = function(t) {\n    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n  }, n.prototype.unbind = function(t) {\n    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);\n  }, n.prototype.resize = function(t, e) {\n    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));\n  }, Object.defineProperty(n.prototype, \"valid\", {\n    get: function() {\n      return !!this._width && !!this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.update = function() {\n    this.destroyed || this.onUpdate.emit();\n  }, n.prototype.load = function() {\n    return Promise.resolve(this);\n  }, Object.defineProperty(n.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.style = function(t, e, o) {\n    return !1;\n  }, n.prototype.dispose = function() {\n  }, n.prototype.destroy = function() {\n    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n  }, n.test = function(t, e) {\n    return !1;\n  }, n;\n}(), BufferResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this, N = o || {}, M = N.width, D = N.height;\n    if (!M || !D)\n      throw new Error(\"BufferResource width or height invalid\");\n    return R = n.call(this, M, D) || this, R.data = e, R;\n  }\n  return t.prototype.upload = function(e, o, R) {\n    var N = e.gl;\n    N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);\n    var M = o.realWidth, D = o.realHeight;\n    return R.width === M && R.height === D ? N.texSubImage2D(o.target, 0, 0, 0, M, D, o.format, R.type, this.data) : (R.width = M, R.height = D, N.texImage2D(o.target, 0, R.internalFormat, M, D, 0, o.format, R.type, this.data)), !0;\n  }, t.prototype.dispose = function() {\n    this.data = null;\n  }, t.test = function(e) {\n    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;\n  }, t;\n}(Resource), defaultBufferOptions = {\n  scaleMode: SCALE_MODES$5.NEAREST,\n  format: FORMATS$5.RGBA,\n  alphaMode: ALPHA_MODES$5.NPM\n}, BaseTexture = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    e === void 0 && (e = null), o === void 0 && (o = null);\n    var R = n.call(this) || this;\n    o = o || {};\n    var N = o.alphaMode, M = o.mipmap, D = o.anisotropicLevel, L = o.scaleMode, B = o.width, $ = o.height, k = o.wrapMode, U = o.format, z = o.type, X = o.target, V = o.resolution, W = o.resourceOptions;\n    return e && !(e instanceof Resource) && (e = autoDetectResource(e, W), e.internal = !0), R.resolution = V || settings$1.RESOLUTION, R.width = Math.round((B || 0) * R.resolution) / R.resolution, R.height = Math.round(($ || 0) * R.resolution) / R.resolution, R._mipmap = M !== void 0 ? M : settings$1.MIPMAP_TEXTURES, R.anisotropicLevel = D !== void 0 ? D : settings$1.ANISOTROPIC_LEVEL, R._wrapMode = k || settings$1.WRAP_MODE, R._scaleMode = L !== void 0 ? L : settings$1.SCALE_MODE, R.format = U || FORMATS$5.RGBA, R.type = z || TYPES$5.UNSIGNED_BYTE, R.target = X || TARGETS$5.TEXTURE_2D, R.alphaMode = N !== void 0 ? N : ALPHA_MODES$5.UNPACK, R.uid = uid(), R.touched = 0, R.isPowerOfTwo = !1, R._refreshPOT(), R._glTextures = {}, R.dirtyId = 0, R.dirtyStyleId = 0, R.cacheId = null, R.valid = B > 0 && $ > 0, R.textureCacheIds = [], R.destroyed = !1, R.resource = null, R._batchEnabled = 0, R._batchLocation = 0, R.parentTextureArray = null, R.setResource(e), R;\n  }\n  return Object.defineProperty(t.prototype, \"realWidth\", {\n    get: function() {\n      return Math.round(this.width * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"realHeight\", {\n    get: function() {\n      return Math.round(this.height * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mipmap\", {\n    get: function() {\n      return this._mipmap;\n    },\n    set: function(e) {\n      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scaleMode\", {\n    get: function() {\n      return this._scaleMode;\n    },\n    set: function(e) {\n      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"wrapMode\", {\n    get: function() {\n      return this._wrapMode;\n    },\n    set: function(e) {\n      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.setStyle = function(e, o) {\n    var R;\n    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, R = !0), o !== void 0 && o !== this.mipmap && (this.mipmap = o, R = !0), R && this.dirtyStyleId++, this;\n  }, t.prototype.setSize = function(e, o, R) {\n    return R = R || this.resolution, this.setRealSize(e * R, o * R, R);\n  }, t.prototype.setRealSize = function(e, o, R) {\n    return this.resolution = R || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(o) / this.resolution, this._refreshPOT(), this.update(), this;\n  }, t.prototype._refreshPOT = function() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  }, t.prototype.setResolution = function(e) {\n    var o = this.resolution;\n    return o === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * o) / e, this.height = Math.round(this.height * o) / e, this.emit(\"update\", this)), this._refreshPOT(), this);\n  }, t.prototype.setResource = function(e) {\n    if (this.resource === e)\n      return this;\n    if (this.resource)\n      throw new Error(\"Resource can be set only once\");\n    return e.bind(this), this.resource = e, this;\n  }, t.prototype.update = function() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n  }, t.prototype.onError = function(e) {\n    this.emit(\"error\", this, e);\n  }, t.prototype.destroy = function() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;\n  }, t.prototype.dispose = function() {\n    this.emit(\"dispose\", this);\n  }, t.prototype.castToBaseTexture = function() {\n    return this;\n  }, t.from = function(e, o, R) {\n    R === void 0 && (R = settings$1.STRICT_TEXTURE_CACHE);\n    var N = typeof e == \"string\", M = null;\n    if (N)\n      M = e;\n    else {\n      if (!e._pixiId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e._pixiId = D + \"_\" + uid();\n      }\n      M = e._pixiId;\n    }\n    var L = BaseTextureCache[M];\n    if (N && R && !L)\n      throw new Error('The cacheId \"' + M + '\" does not exist in BaseTextureCache.');\n    return L || (L = new t(e, o), L.cacheId = M, t.addToCache(L, M)), L;\n  }, t.fromBuffer = function(e, o, R, N) {\n    e = e || new Float32Array(o * R * 4);\n    var M = new BufferResource(e, { width: o, height: R }), D = e instanceof Float32Array ? TYPES$5.FLOAT : TYPES$5.UNSIGNED_BYTE;\n    return new t(M, Object.assign(defaultBufferOptions, N || { width: o, height: R, type: D }));\n  }, t.addToCache = function(e, o) {\n    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), BaseTextureCache[o] && console.warn(\"BaseTexture added to the cache with an id [\" + o + \"] that already had an entry\"), BaseTextureCache[o] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var o = BaseTextureCache[e];\n      if (o) {\n        var R = o.textureCacheIds.indexOf(e);\n        return R > -1 && o.textureCacheIds.splice(R, 1), delete BaseTextureCache[e], o;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var N = 0; N < e.textureCacheIds.length; ++N)\n        delete BaseTextureCache[e.textureCacheIds[N]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, t._globalBatch = 0, t;\n}(EventEmitter$5), AbstractMultiResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this, N = o || {}, M = N.width, D = N.height;\n    R = n.call(this, M, D) || this, R.items = [], R.itemDirtyIds = [];\n    for (var L = 0; L < e; L++) {\n      var B = new BaseTexture();\n      R.items.push(B), R.itemDirtyIds.push(-2);\n    }\n    return R.length = e, R._load = null, R.baseTexture = null, R;\n  }\n  return t.prototype.initFromArray = function(e, o) {\n    for (var R = 0; R < this.length; R++)\n      !e[R] || (e[R].castToBaseTexture ? this.addBaseTextureAt(e[R].castToBaseTexture(), R) : e[R] instanceof Resource ? this.addResourceAt(e[R], R) : this.addResourceAt(autoDetectResource(e[R], o), R));\n  }, t.prototype.dispose = function() {\n    for (var e = 0, o = this.length; e < o; e++)\n      this.items[e].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }, t.prototype.addResourceAt = function(e, o) {\n    if (!this.items[o])\n      throw new Error(\"Index \" + o + \" is out of bounds\");\n    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[o].setResource(e), this;\n  }, t.prototype.bind = function(e) {\n    if (this.baseTexture !== null)\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    n.prototype.bind.call(this, e);\n    for (var o = 0; o < this.length; o++)\n      this.items[o].parentTextureArray = e, this.items[o].on(\"update\", e.update, e);\n  }, t.prototype.unbind = function(e) {\n    n.prototype.unbind.call(this, e);\n    for (var o = 0; o < this.length; o++)\n      this.items[o].parentTextureArray = null, this.items[o].off(\"update\", e.update, e);\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var o = this.items.map(function(N) {\n      return N.resource;\n    }).filter(function(N) {\n      return N;\n    }), R = o.map(function(N) {\n      return N.load();\n    });\n    return this._load = Promise.all(R).then(function() {\n      var N = e.items[0], M = N.realWidth, D = N.realHeight;\n      return e.resize(M, D), Promise.resolve(e);\n    }), this._load;\n  }, t;\n}(Resource), ArrayResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this, N = o || {}, M = N.width, D = N.height, L, B;\n    return Array.isArray(e) ? (L = e, B = e.length) : B = e, R = n.call(this, B, { width: M, height: D }) || this, L && R.initFromArray(L, o), R;\n  }\n  return t.prototype.addBaseTextureAt = function(e, o) {\n    if (e.resource)\n      this.addResourceAt(e.resource, o);\n    else\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    return this;\n  }, t.prototype.bind = function(e) {\n    n.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_2D_ARRAY;\n  }, t.prototype.upload = function(e, o, R) {\n    var N = this, M = N.length, D = N.itemDirtyIds, L = N.items, B = e.gl;\n    R.dirtyId < 0 && B.texImage3D(B.TEXTURE_2D_ARRAY, 0, R.internalFormat, this._width, this._height, M, 0, o.format, R.type, null);\n    for (var $ = 0; $ < M; $++) {\n      var k = L[$];\n      D[$] < k.dirtyId && (D[$] = k.dirtyId, k.valid && B.texSubImage3D(\n        B.TEXTURE_2D_ARRAY,\n        0,\n        0,\n        0,\n        $,\n        k.resource.width,\n        k.resource.height,\n        1,\n        o.format,\n        R.type,\n        k.resource.source\n      ));\n    }\n    return !0;\n  }, t;\n}(AbstractMultiResource), BaseImageResource = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    var o = this, R = e, N = R.naturalWidth || R.videoWidth || R.width, M = R.naturalHeight || R.videoHeight || R.height;\n    return o = n.call(this, N, M) || this, o.source = e, o.noSubImage = !1, o;\n  }\n  return t.crossOrigin = function(e, o, R) {\n    R === void 0 && o.indexOf(\"data:\") !== 0 ? e.crossOrigin = determineCrossOrigin(o) : R !== !1 && (e.crossOrigin = typeof R == \"string\" ? R : \"anonymous\");\n  }, t.prototype.upload = function(e, o, R, N) {\n    var M = e.gl, D = o.realWidth, L = o.realHeight;\n    if (N = N || this.source, N instanceof HTMLImageElement) {\n      if (!N.complete || N.naturalWidth === 0)\n        return !1;\n    } else if (N instanceof HTMLVideoElement && N.readyState <= 1)\n      return !1;\n    return M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK), !this.noSubImage && o.target === M.TEXTURE_2D && R.width === D && R.height === L ? M.texSubImage2D(M.TEXTURE_2D, 0, 0, 0, o.format, R.type, N) : (R.width = D, R.height = L, M.texImage2D(o.target, 0, R.internalFormat, o.format, R.type, N)), !0;\n  }, t.prototype.update = function() {\n    if (!this.destroyed) {\n      var e = this.source, o = e.naturalWidth || e.videoWidth || e.width, R = e.naturalHeight || e.videoHeight || e.height;\n      this.resize(o, R), n.prototype.update.call(this);\n    }\n  }, t.prototype.dispose = function() {\n    this.source = null;\n  }, t;\n}(Resource), CanvasResource = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    return n.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    var o = globalThis.OffscreenCanvas;\n    return o && e instanceof o ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;\n  }, t;\n}(BaseImageResource), CubeResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this, N = o || {}, M = N.width, D = N.height, L = N.autoLoad, B = N.linkBaseTexture;\n    if (e && e.length !== t.SIDES)\n      throw new Error(\"Invalid length. Got \" + e.length + \", expected 6\");\n    R = n.call(this, 6, { width: M, height: D }) || this;\n    for (var $ = 0; $ < t.SIDES; $++)\n      R.items[$].target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + $;\n    return R.linkBaseTexture = B !== !1, e && R.initFromArray(e, o), L !== !1 && R.load(), R;\n  }\n  return t.prototype.bind = function(e) {\n    n.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_CUBE_MAP;\n  }, t.prototype.addBaseTextureAt = function(e, o, R) {\n    if (!this.items[o])\n      throw new Error(\"Index \" + o + \" is out of bounds\");\n    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)\n      if (e.resource)\n        this.addResourceAt(e.resource, o);\n      else\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n    else\n      e.target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + o, e.parentTextureArray = this.baseTexture, this.items[o] = e;\n    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[o] = e, this;\n  }, t.prototype.upload = function(e, o, R) {\n    for (var N = this.itemDirtyIds, M = 0; M < t.SIDES; M++) {\n      var D = this.items[M];\n      (N[M] < D.dirtyId || R.dirtyId < o.dirtyId) && (D.valid && D.resource ? (D.resource.upload(e, D, R), N[M] = D.dirtyId) : N[M] < -1 && (e.gl.texImage2D(D.target, 0, R.internalFormat, o.realWidth, o.realHeight, 0, o.format, R.type, null), N[M] = -1));\n    }\n    return !0;\n  }, t.test = function(e) {\n    return Array.isArray(e) && e.length === t.SIDES;\n  }, t.SIDES = 6, t;\n}(AbstractMultiResource), ImageResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this;\n    if (o = o || {}, !(e instanceof HTMLImageElement)) {\n      var N = new Image();\n      BaseImageResource.crossOrigin(N, e, o.crossorigin), N.src = e, e = N;\n    }\n    return R = n.call(this, e) || this, !e.complete && !!R._width && !!R._height && (R._width = 0, R._height = 0), R.url = e.src, R._process = null, R.preserveBitmap = !1, R.createBitmap = (o.createBitmap !== void 0 ? o.createBitmap : settings$1.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, R.alphaMode = typeof o.alphaMode == \"number\" ? o.alphaMode : null, R.bitmap = null, R._load = null, o.autoLoad !== !1 && R.load(), R;\n  }\n  return t.prototype.load = function(e) {\n    var o = this;\n    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(R, N) {\n      var M = o.source;\n      o.url = M.src;\n      var D = function() {\n        o.destroyed || (M.onload = null, M.onerror = null, o.resize(M.width, M.height), o._load = null, o.createBitmap ? R(o.process()) : R(o));\n      };\n      M.complete && M.src ? D() : (M.onload = D, M.onerror = function(L) {\n        N(L), o.onError.emit(L);\n      });\n    }), this._load);\n  }, t.prototype.process = function() {\n    var e = this, o = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    var R = globalThis.createImageBitmap, N = !o.crossOrigin || o.crossOrigin === \"anonymous\";\n    return this._process = fetch(o.src, {\n      mode: N ? \"cors\" : \"no-cors\"\n    }).then(function(M) {\n      return M.blob();\n    }).then(function(M) {\n      return R(M, 0, 0, o.width, o.height, {\n        premultiplyAlpha: e.alphaMode === ALPHA_MODES$5.UNPACK ? \"premultiply\" : \"none\"\n      });\n    }).then(function(M) {\n      return e.destroyed ? Promise.reject() : (e.bitmap = M, e.update(), e._process = null, Promise.resolve(e));\n    }), this._process;\n  }, t.prototype.upload = function(e, o, R) {\n    if (typeof this.alphaMode == \"number\" && (o.alphaMode = this.alphaMode), !this.createBitmap)\n      return n.prototype.upload.call(this, e, o, R);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (n.prototype.upload.call(this, e, o, R, this.bitmap), !this.preserveBitmap) {\n      var N = !0, M = o._glTextures;\n      for (var D in M) {\n        var L = M[D];\n        if (L !== R && L.dirtyId !== o.dirtyId) {\n          N = !1;\n          break;\n        }\n      }\n      N && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }, t.prototype.dispose = function() {\n    this.source.onload = null, this.source.onerror = null, n.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }, t.test = function(e) {\n    return typeof e == \"string\" || e instanceof HTMLImageElement;\n  }, t;\n}(BaseImageResource), SVGResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this;\n    return o = o || {}, R = n.call(this, document.createElement(\"canvas\")) || this, R._width = 0, R._height = 0, R.svg = e, R.scale = o.scale || 1, R._overrideWidth = o.width, R._overrideHeight = o.height, R._resolve = null, R._crossorigin = o.crossorigin, R._load = null, o.autoLoad !== !1 && R.load(), R;\n  }\n  return t.prototype.load = function() {\n    var e = this;\n    return this._load ? this._load : (this._load = new Promise(function(o) {\n      if (e._resolve = function() {\n        e.resize(e.source.width, e.source.height), o(e);\n      }, t.SVG_XML.test(e.svg.trim())) {\n        if (!btoa)\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        e.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(e.svg)));\n      }\n      e._loadSvg();\n    }), this._load);\n  }, t.prototype._loadSvg = function() {\n    var e = this, o = new Image();\n    BaseImageResource.crossOrigin(o, this.svg, this._crossorigin), o.src = this.svg, o.onerror = function(R) {\n      !e._resolve || (o.onerror = null, e.onError.emit(R));\n    }, o.onload = function() {\n      if (!!e._resolve) {\n        var R = o.width, N = o.height;\n        if (!R || !N)\n          throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n        var M = R * e.scale, D = N * e.scale;\n        (e._overrideWidth || e._overrideHeight) && (M = e._overrideWidth || e._overrideHeight / N * R, D = e._overrideHeight || e._overrideWidth / R * N), M = Math.round(M), D = Math.round(D);\n        var L = e.source;\n        L.width = M, L.height = D, L._pixiId = \"canvas_\" + uid(), L.getContext(\"2d\").drawImage(o, 0, 0, R, N, 0, 0, M, D), e._resolve(), e._resolve = null;\n      }\n    };\n  }, t.getSize = function(e) {\n    var o = t.SVG_SIZE.exec(e), R = {};\n    return o && (R[o[1]] = Math.round(parseFloat(o[3])), R[o[5]] = Math.round(parseFloat(o[7]))), R;\n  }, t.prototype.dispose = function() {\n    n.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;\n  }, t.test = function(e, o) {\n    return o === \"svg\" || typeof e == \"string\" && /^data:image\\/svg\\+xml(;(charset=utf8|utf8))?;base64/.test(e) || typeof e == \"string\" && t.SVG_XML.test(e);\n  }, t.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i, t;\n}(BaseImageResource), VideoResource = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = this;\n    if (o = o || {}, !(e instanceof HTMLVideoElement)) {\n      var N = document.createElement(\"video\");\n      N.setAttribute(\"preload\", \"auto\"), N.setAttribute(\"webkit-playsinline\", \"\"), N.setAttribute(\"playsinline\", \"\"), typeof e == \"string\" && (e = [e]);\n      var M = e[0].src || e[0];\n      BaseImageResource.crossOrigin(N, M, o.crossorigin);\n      for (var D = 0; D < e.length; ++D) {\n        var L = document.createElement(\"source\"), B = e[D], $ = B.src, k = B.mime;\n        $ = $ || e[D];\n        var U = $.split(\"?\").shift().toLowerCase(), z = U.slice(U.lastIndexOf(\".\") + 1);\n        k = k || t.MIME_TYPES[z] || \"video/\" + z, L.src = $, L.type = k, N.appendChild(L);\n      }\n      e = N;\n    }\n    return R = n.call(this, e) || this, R.noSubImage = !0, R._autoUpdate = !0, R._isConnectedToTicker = !1, R._updateFPS = o.updateFPS || 0, R._msToNextUpdate = 0, R.autoPlay = o.autoPlay !== !1, R._load = null, R._resolve = null, R._onCanPlay = R._onCanPlay.bind(R), R._onError = R._onError.bind(R), o.autoLoad !== !1 && R.load(), R;\n  }\n  return t.prototype.update = function(e) {\n    if (!this.destroyed) {\n      var o = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - o), (!this._updateFPS || this._msToNextUpdate <= 0) && (n.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var o = this.source;\n    return (o.readyState === o.HAVE_ENOUGH_DATA || o.readyState === o.HAVE_FUTURE_DATA) && o.width && o.height && (o.complete = !0), o.addEventListener(\"play\", this._onPlayStart.bind(this)), o.addEventListener(\"pause\", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (o.addEventListener(\"canplay\", this._onCanPlay), o.addEventListener(\"canplaythrough\", this._onCanPlay), o.addEventListener(\"error\", this._onError, !0)), this._load = new Promise(function(R) {\n      e.valid ? R(e) : (e._resolve = R, o.load());\n    }), this._load;\n  }, t.prototype._onError = function(e) {\n    this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(e);\n  }, t.prototype._isSourcePlaying = function() {\n    var e = this.source;\n    return e.currentTime > 0 && e.paused === !1 && e.ended === !1 && e.readyState > 2;\n  }, t.prototype._isSourceReady = function() {\n    var e = this.source;\n    return e.readyState === 3 || e.readyState === 4;\n  }, t.prototype._onPlayStart = function() {\n    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);\n  }, t.prototype._onPlayStop = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n  }, t.prototype._onCanPlay = function() {\n    var e = this.source;\n    e.removeEventListener(\"canplay\", this._onCanPlay), e.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    var o = this.valid;\n    this.resize(e.videoWidth, e.videoHeight), !o && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();\n  }, t.prototype.dispose = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n    var e = this.source;\n    e && (e.removeEventListener(\"error\", this._onError, !0), e.pause(), e.src = \"\", e.load()), n.prototype.dispose.call(this);\n  }, Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"updateFPS\", {\n    get: function() {\n      return this._updateFPS;\n    },\n    set: function(e) {\n      e !== this._updateFPS && (this._updateFPS = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.test = function(e, o) {\n    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(o) > -1;\n  }, t.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], t.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n  }, t;\n}(BaseImageResource), ImageBitmapResource = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    return n.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && e instanceof ImageBitmap;\n  }, t;\n}(BaseImageResource);\nINSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\nvar DepthResource = function(n) {\n  __extends$q(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  return t.prototype.upload = function(e, o, R) {\n    var N = e.gl;\n    N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);\n    var M = o.realWidth, D = o.realHeight;\n    return R.width === M && R.height === D ? N.texSubImage2D(o.target, 0, 0, 0, M, D, o.format, R.type, this.data) : (R.width = M, R.height = D, N.texImage2D(o.target, 0, R.internalFormat, M, D, 0, o.format, R.type, this.data)), !0;\n  }, t;\n}(BufferResource), Framebuffer = function() {\n  function n(t, e) {\n    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner(\"disposeFramebuffer\"), this.multisample = MSAA_QUALITY$5.NONE;\n  }\n  return Object.defineProperty(n.prototype, \"colorTexture\", {\n    get: function() {\n      return this.colorTextures[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.addColorTexture = function(t, e) {\n    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {\n      scaleMode: SCALE_MODES$5.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES$5.OFF,\n      width: this.width,\n      height: this.height\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, n.prototype.addDepthTexture = function(t) {\n    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: SCALE_MODES$5.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES$5.OFF,\n      format: FORMATS$5.DEPTH_COMPONENT,\n      type: TYPES$5.UNSIGNED_SHORT\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, n.prototype.enableDepth = function() {\n    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, n.prototype.enableStencil = function() {\n    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, n.prototype.resize = function(t, e) {\n    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {\n      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;\n      for (var o = 0; o < this.colorTextures.length; o++) {\n        var R = this.colorTextures[o], N = R.resolution;\n        R.setSize(t / N, e / N);\n      }\n      if (this.depthTexture) {\n        var N = this.depthTexture.resolution;\n        this.depthTexture.setSize(t / N, e / N);\n      }\n    }\n  }, n.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, n.prototype.destroyDepthTexture = function() {\n    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n  }, n;\n}(), BaseRenderTexture = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    e === void 0 && (e = {});\n    var o = this;\n    if (typeof e == \"number\") {\n      var R = arguments[0], N = arguments[1], M = arguments[2], D = arguments[3];\n      e = { width: R, height: N, scaleMode: M, resolution: D };\n    }\n    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY$5.NONE, o = n.call(this, null, e) || this, o.mipmap = MIPMAP_MODES$5.OFF, o.valid = !0, o.clearColor = [0, 0, 0, 0], o.framebuffer = new Framebuffer(o.realWidth, o.realHeight).addColorTexture(0, o), o.framebuffer.multisample = e.multisample, o.maskStack = [], o.filterStack = [{}], o;\n  }\n  return t.prototype.resize = function(e, o) {\n    this.framebuffer.resize(e * this.resolution, o * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }, t.prototype.dispose = function() {\n    this.framebuffer.dispose(), n.prototype.dispose.call(this);\n  }, t.prototype.destroy = function() {\n    n.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n  }, t;\n}(BaseTexture), TextureUvs = function() {\n  function n() {\n    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n  }\n  return n.prototype.set = function(t, e, o) {\n    var R = e.width, N = e.height;\n    if (o) {\n      var M = t.width / 2 / R, D = t.height / 2 / N, L = t.x / R + M, B = t.y / N + D;\n      o = groupD8.add(o, groupD8.NW), this.x0 = L + M * groupD8.uX(o), this.y0 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x1 = L + M * groupD8.uX(o), this.y1 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x2 = L + M * groupD8.uX(o), this.y2 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x3 = L + M * groupD8.uX(o), this.y3 = B + D * groupD8.uY(o);\n    } else\n      this.x0 = t.x / R, this.y0 = t.y / N, this.x1 = (t.x + t.width) / R, this.y1 = t.y / N, this.x2 = (t.x + t.width) / R, this.y2 = (t.y + t.height) / N, this.x3 = t.x / R, this.y3 = (t.y + t.height) / N;\n    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n  }, n.prototype.toString = function() {\n    return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n  }, n;\n}(), DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(n) {\n  n.destroy = function() {\n  }, n.on = function() {\n  }, n.once = function() {\n  }, n.emit = function() {\n  };\n}\nvar Texture = function(n) {\n  __extends$q(t, n);\n  function t(e, o, R, N, M, D) {\n    var L = n.call(this) || this;\n    if (L.noFrame = !1, o || (L.noFrame = !0, o = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), L.baseTexture = e, L._frame = o, L.trim = N, L.valid = !1, L._uvs = DEFAULT_UVS, L.uvMatrix = null, L.orig = R || o, L._rotate = Number(M || 0), M === !0)\n      L._rotate = 2;\n    else if (L._rotate % 2 !== 0)\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    return L.defaultAnchor = D ? new Point(D.x, D.y) : new Point(0, 0), L._updateID = 0, L.textureCacheIds = [], e.valid ? L.noFrame ? e.valid && L.onBaseTextureUpdated(e) : L.frame = o : e.once(\"loaded\", L.onBaseTextureUpdated, L), L.noFrame && e.on(\"update\", L.onBaseTextureUpdated, L), L;\n  }\n  return t.prototype.update = function() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }, t.prototype.onBaseTextureUpdated = function(e) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit(\"update\", this);\n  }, t.prototype.destroy = function(e) {\n    if (this.baseTexture) {\n      if (e) {\n        var o = this.baseTexture.resource;\n        o && o.url && TextureCache[o.url] && t.removeFromCache(o.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;\n  }, t.prototype.clone = function() {\n    var e = this._frame.clone(), o = this._frame === this.orig ? e : this.orig.clone(), R = new t(this.baseTexture, !this.noFrame && e, o, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n    return this.noFrame && (R._frame = e), R;\n  }, t.prototype.updateUvs = function() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }, t.from = function(e, o, R) {\n    o === void 0 && (o = {}), R === void 0 && (R = settings$1.STRICT_TEXTURE_CACHE);\n    var N = typeof e == \"string\", M = null;\n    if (N)\n      M = e;\n    else if (e instanceof BaseTexture) {\n      if (!e.cacheId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e.cacheId = D + \"-\" + uid(), BaseTexture.addToCache(e, e.cacheId);\n      }\n      M = e.cacheId;\n    } else {\n      if (!e._pixiId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e._pixiId = D + \"_\" + uid();\n      }\n      M = e._pixiId;\n    }\n    var L = TextureCache[M];\n    if (N && R && !L)\n      throw new Error('The cacheId \"' + M + '\" does not exist in TextureCache.');\n    return !L && !(e instanceof BaseTexture) ? (o.resolution || (o.resolution = getResolutionOfUrl(e)), L = new t(new BaseTexture(e, o)), L.baseTexture.cacheId = M, BaseTexture.addToCache(L.baseTexture, M), t.addToCache(L, M)) : !L && e instanceof BaseTexture && (L = new t(e), t.addToCache(L, M)), L;\n  }, t.fromURL = function(e, o) {\n    var R = Object.assign({ autoLoad: !1 }, o == null ? void 0 : o.resourceOptions), N = t.from(e, Object.assign({ resourceOptions: R }, o), !1), M = N.baseTexture.resource;\n    return N.baseTexture.valid ? Promise.resolve(N) : M.load().then(function() {\n      return Promise.resolve(N);\n    });\n  }, t.fromBuffer = function(e, o, R, N) {\n    return new t(BaseTexture.fromBuffer(e, o, R, N));\n  }, t.fromLoader = function(e, o, R, N) {\n    var M = new BaseTexture(e, Object.assign({\n      scaleMode: settings$1.SCALE_MODE,\n      resolution: getResolutionOfUrl(o)\n    }, N)), D = M.resource;\n    D instanceof ImageResource && (D.url = o);\n    var L = new t(M);\n    return R || (R = o), BaseTexture.addToCache(L.baseTexture, R), t.addToCache(L, R), R !== o && (BaseTexture.addToCache(L.baseTexture, o), t.addToCache(L, o)), L.baseTexture.valid ? Promise.resolve(L) : new Promise(function(B) {\n      L.baseTexture.once(\"loaded\", function() {\n        return B(L);\n      });\n    });\n  }, t.addToCache = function(e, o) {\n    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), TextureCache[o] && console.warn(\"Texture added to the cache with an id [\" + o + \"] that already had an entry\"), TextureCache[o] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var o = TextureCache[e];\n      if (o) {\n        var R = o.textureCacheIds.indexOf(e);\n        return R > -1 && o.textureCacheIds.splice(R, 1), delete TextureCache[e], o;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var N = 0; N < e.textureCacheIds.length; ++N)\n        TextureCache[e.textureCacheIds[N]] === e && delete TextureCache[e.textureCacheIds[N]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this.baseTexture.resolution;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"frame\", {\n    get: function() {\n      return this._frame;\n    },\n    set: function(e) {\n      this._frame = e, this.noFrame = !1;\n      var o = e.x, R = e.y, N = e.width, M = e.height, D = o + N > this.baseTexture.width, L = R + M > this.baseTexture.height;\n      if (D || L) {\n        var B = D && L ? \"and\" : \"or\", $ = \"X: \" + o + \" + \" + N + \" = \" + (o + N) + \" > \" + this.baseTexture.width, k = \"Y: \" + R + \" + \" + M + \" = \" + (R + M) + \" > \" + this.baseTexture.height;\n        throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + ($ + \" \" + B + \" \" + k));\n      }\n      this.valid = N && M && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotate\", {\n    get: function() {\n      return this._rotate;\n    },\n    set: function(e) {\n      this._rotate = e, this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.orig.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.orig.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.castToBaseTexture = function() {\n    return this.baseTexture;\n  }, Object.defineProperty(t, \"EMPTY\", {\n    get: function() {\n      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"WHITE\", {\n    get: function() {\n      if (!t._WHITE) {\n        var e = settings$1.ADAPTER.createCanvas(16, 16), o = e.getContext(\"2d\");\n        e.width = 16, e.height = 16, o.fillStyle = \"white\", o.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);\n      }\n      return t._WHITE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(EventEmitter$5), RenderTexture = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    var R = n.call(this, e, o) || this;\n    return R.valid = !0, R.filterFrame = null, R.filterPoolKey = null, R.updateUvs(), R;\n  }\n  return Object.defineProperty(t.prototype, \"framebuffer\", {\n    get: function() {\n      return this.baseTexture.framebuffer;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"multisample\", {\n    get: function() {\n      return this.framebuffer.multisample;\n    },\n    set: function(e) {\n      this.framebuffer.multisample = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, o, R) {\n    R === void 0 && (R = !0);\n    var N = this.baseTexture.resolution, M = Math.round(e * N) / N, D = Math.round(o * N) / N;\n    this.valid = M > 0 && D > 0, this._frame.width = this.orig.width = M, this._frame.height = this.orig.height = D, R && this.baseTexture.resize(M, D), this.updateUvs();\n  }, t.prototype.setResolution = function(e) {\n    var o = this.baseTexture;\n    o.resolution !== e && (o.setResolution(e), this.resize(o.width, o.height, !1));\n  }, t.create = function(e) {\n    for (var o = arguments, R = [], N = 1; N < arguments.length; N++)\n      R[N - 1] = o[N];\n    return typeof e == \"number\" && (deprecation$1(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\"), e = {\n      width: e,\n      height: R[0],\n      scaleMode: R[1],\n      resolution: R[2]\n    }), new t(new BaseRenderTexture(e));\n  }, t;\n}(Texture), RenderTexturePool = function() {\n  function n(t) {\n    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n  }\n  return n.prototype.createTexture = function(t, e, o) {\n    o === void 0 && (o = MSAA_QUALITY$5.NONE);\n    var R = new BaseRenderTexture(Object.assign({\n      width: t,\n      height: e,\n      resolution: 1,\n      multisample: o\n    }, this.textureOptions));\n    return new RenderTexture(R);\n  }, n.prototype.getOptimalTexture = function(t, e, o, R) {\n    o === void 0 && (o = 1), R === void 0 && (R = MSAA_QUALITY$5.NONE);\n    var N;\n    t = Math.ceil(t * o - 1e-6), e = Math.ceil(e * o - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), N = ((t & 65535) << 16 | e & 65535) >>> 0, R > 1 && (N += R * 4294967296)) : N = R > 1 ? -R : -1, this.texturePool[N] || (this.texturePool[N] = []);\n    var M = this.texturePool[N].pop();\n    return M || (M = this.createTexture(t, e, R)), M.filterPoolKey = N, M.setResolution(o), M;\n  }, n.prototype.getFilterTexture = function(t, e, o) {\n    var R = this.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);\n    return R.filterFrame = t.filterFrame, R;\n  }, n.prototype.returnTexture = function(t) {\n    var e = t.filterPoolKey;\n    t.filterFrame = null, this.texturePool[e].push(t);\n  }, n.prototype.returnFilterTexture = function(t) {\n    this.returnTexture(t);\n  }, n.prototype.clear = function(t) {\n    if (t = t !== !1, t)\n      for (var e in this.texturePool) {\n        var o = this.texturePool[e];\n        if (o)\n          for (var R = 0; R < o.length; R++)\n            o[R].destroy(!0);\n      }\n    this.texturePool = {};\n  }, n.prototype.setScreenSize = function(t) {\n    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {\n      this.enableFullScreen = t.width > 0 && t.height > 0;\n      for (var e in this.texturePool)\n        if (Number(e) < 0) {\n          var o = this.texturePool[e];\n          if (o)\n            for (var R = 0; R < o.length; R++)\n              o[R].destroy(!0);\n          this.texturePool[e] = [];\n        }\n      this._pixelsWidth = t.width, this._pixelsHeight = t.height;\n    }\n  }, n.SCREEN_KEY = -1, n;\n}(), Attribute = function() {\n  function n(t, e, o, R, N, M, D) {\n    e === void 0 && (e = 0), o === void 0 && (o = !1), R === void 0 && (R = TYPES$5.FLOAT), this.buffer = t, this.size = e, this.normalized = o, this.type = R, this.stride = N, this.start = M, this.instance = D;\n  }\n  return n.prototype.destroy = function() {\n    this.buffer = null;\n  }, n.from = function(t, e, o, R, N) {\n    return new n(t, e, o, R, N);\n  }, n;\n}(), UID$4 = 0, Buffer$1 = function() {\n  function n(t, e, o) {\n    e === void 0 && (e = !0), o === void 0 && (o = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = o, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner(\"disposeBuffer\");\n  }\n  return n.prototype.update = function(t) {\n    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;\n  }, n.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, n.prototype.destroy = function() {\n    this.dispose(), this.data = null;\n  }, Object.defineProperty(n.prototype, \"index\", {\n    get: function() {\n      return this.type === BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;\n    },\n    set: function(t) {\n      this.type = t ? BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$5.ARRAY_BUFFER;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.from = function(t) {\n    return t instanceof Array && (t = new Float32Array(t)), new n(t);\n  }, n;\n}(), map$1 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(n, t) {\n  for (var e = 0, o = 0, R = {}, N = 0; N < n.length; N++)\n    o += t[N], e += n[N].length;\n  for (var M = new ArrayBuffer(e * 4), D = null, L = 0, N = 0; N < n.length; N++) {\n    var B = t[N], $ = n[N], k = getBufferType($);\n    R[k] || (R[k] = new map$1[k](M)), D = R[k];\n    for (var U = 0; U < $.length; U++) {\n      var z = (U / B | 0) * o + L, X = U % B;\n      D[z + X] = $[U];\n    }\n    L += B;\n  }\n  return new Float32Array(M);\n}\nvar byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n}, Geometry = function() {\n  function n(t, e) {\n    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner(\"disposeGeometry\"), this.refCount = 0;\n  }\n  return n.prototype.addAttribute = function(t, e, o, R, N, M, D, L) {\n    if (o === void 0 && (o = 0), R === void 0 && (R = !1), L === void 0 && (L = !1), !e)\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));\n    var B = t.split(\"|\");\n    if (B.length > 1) {\n      for (var $ = 0; $ < B.length; $++)\n        this.addAttribute(B[$], e, o, R, N);\n      return this;\n    }\n    var k = this.buffers.indexOf(e);\n    return k === -1 && (this.buffers.push(e), k = this.buffers.length - 1), this.attributes[t] = new Attribute(k, o, R, N, M, D, L), this.instanced = this.instanced || L, this;\n  }, n.prototype.getAttribute = function(t) {\n    return this.attributes[t];\n  }, n.prototype.getBuffer = function(t) {\n    return this.buffers[this.getAttribute(t).buffer];\n  }, n.prototype.addIndex = function(t) {\n    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;\n  }, n.prototype.getIndex = function() {\n    return this.indexBuffer;\n  }, n.prototype.interleave = function() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    var t = [], e = [], o = new Buffer$1(), R;\n    for (R in this.attributes) {\n      var N = this.attributes[R], M = this.buffers[N.buffer];\n      t.push(M.data), e.push(N.size * byteSizeMap$1[N.type] / 4), N.buffer = 0;\n    }\n    for (o.data = interleaveTypedArrays(t, e), R = 0; R < this.buffers.length; R++)\n      this.buffers[R] !== this.indexBuffer && this.buffers[R].destroy();\n    return this.buffers = [o], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }, n.prototype.getSize = function() {\n    for (var t in this.attributes) {\n      var e = this.attributes[t], o = this.buffers[e.buffer];\n      return o.data.length / (e.stride / 4 || e.size);\n    }\n    return 0;\n  }, n.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, n.prototype.destroy = function() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }, n.prototype.clone = function() {\n    for (var t = new n(), e = 0; e < this.buffers.length; e++)\n      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));\n    for (var e in this.attributes) {\n      var o = this.attributes[e];\n      t.attributes[e] = new Attribute(o.buffer, o.size, o.normalized, o.type, o.stride, o.start, o.instance);\n    }\n    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER), t;\n  }, n.merge = function(t) {\n    for (var e = new n(), o = [], R = [], N = [], M, D = 0; D < t.length; D++) {\n      M = t[D];\n      for (var L = 0; L < M.buffers.length; L++)\n        R[L] = R[L] || 0, R[L] += M.buffers[L].data.length, N[L] = 0;\n    }\n    for (var D = 0; D < M.buffers.length; D++)\n      o[D] = new map$2[getBufferType(M.buffers[D].data)](R[D]), e.buffers[D] = new Buffer$1(o[D]);\n    for (var D = 0; D < t.length; D++) {\n      M = t[D];\n      for (var L = 0; L < M.buffers.length; L++)\n        o[L].set(M.buffers[L].data, N[L]), N[L] += M.buffers[L].data.length;\n    }\n    if (e.attributes = M.attributes, M.indexBuffer) {\n      e.indexBuffer = e.buffers[M.buffers.indexOf(M.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;\n      for (var B = 0, $ = 0, k = 0, U = 0, D = 0; D < M.buffers.length; D++)\n        if (M.buffers[D] !== M.indexBuffer) {\n          U = D;\n          break;\n        }\n      for (var D in M.attributes) {\n        var z = M.attributes[D];\n        (z.buffer | 0) === U && ($ += z.size * byteSizeMap$1[z.type] / 4);\n      }\n      for (var D = 0; D < t.length; D++) {\n        for (var X = t[D].indexBuffer.data, L = 0; L < X.length; L++)\n          e.indexBuffer.data[L + k] += B;\n        B += t[D].buffers[U].data.length / $, k += X.length;\n      }\n    }\n    return e;\n  }, n;\n}(), Quad = function(n) {\n  __extends$q(t, n);\n  function t() {\n    var e = n.call(this) || this;\n    return e.addAttribute(\"aVertexPosition\", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]), e;\n  }\n  return t;\n}(Geometry), QuadUv = function(n) {\n  __extends$q(t, n);\n  function t() {\n    var e = n.call(this) || this;\n    return e.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]), e.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute(\"aVertexPosition\", e.vertexBuffer).addAttribute(\"aTextureCoord\", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;\n  }\n  return t.prototype.map = function(e, o) {\n    var R = 0, N = 0;\n    return this.uvs[0] = R, this.uvs[1] = N, this.uvs[2] = R + o.width / e.width, this.uvs[3] = N, this.uvs[4] = R + o.width / e.width, this.uvs[5] = N + o.height / e.height, this.uvs[6] = R, this.uvs[7] = N + o.height / e.height, R = o.x, N = o.y, this.vertices[0] = R, this.vertices[1] = N, this.vertices[2] = R + o.width, this.vertices[3] = N, this.vertices[4] = R + o.width, this.vertices[5] = N + o.height, this.vertices[6] = R, this.vertices[7] = N + o.height, this.invalidate(), this;\n  }, t.prototype.invalidate = function() {\n    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n  }, t;\n}(Geometry), UID$2 = 0, UniformGroup = function() {\n  function n(t, e, o) {\n    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!o, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !0));\n  }\n  return n.prototype.update = function() {\n    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n  }, n.prototype.add = function(t, e, o) {\n    if (!this.ubo)\n      this.uniforms[t] = new n(e, o);\n    else\n      throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n  }, n.from = function(t, e, o) {\n    return new n(t, e, o);\n  }, n.uboFrom = function(t, e) {\n    return new n(t, e != null ? e : !0, !0);\n  }, n;\n}(), FilterState = function() {\n  function n() {\n    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY$5.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;\n  }\n  return n.prototype.clear = function() {\n    this.target = null, this.filters = null, this.renderTexture = null;\n  }, n;\n}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {\n  function n(t) {\n    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  return n.prototype.push = function(t, e) {\n    for (var o, R, N = this.renderer, M = this.defaultFilterStack, D = this.statePool.pop() || new FilterState(), L = this.renderer.renderTexture, B = e[0].resolution, $ = e[0].multisample, k = e[0].padding, U = e[0].autoFit, z = (o = e[0].legacy) !== null && o !== void 0 ? o : !0, X = 1; X < e.length; X++) {\n      var V = e[X];\n      B = Math.min(B, V.resolution), $ = Math.min($, V.multisample), k = this.useMaxPadding ? Math.max(k, V.padding) : k + V.padding, U = U && V.autoFit, z = z || ((R = V.legacy) !== null && R !== void 0 ? R : !0);\n    }\n    M.length === 1 && (this.defaultFilterStack[0].renderTexture = L.current), M.push(D), D.resolution = B, D.multisample = $, D.legacy = z, D.target = t, D.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), D.sourceFrame.pad(k);\n    var W = this.tempRect.copyFrom(L.sourceFrame);\n    N.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(N.projection.transform).invert(), W), U ? (D.sourceFrame.fit(W), (D.sourceFrame.width <= 0 || D.sourceFrame.height <= 0) && (D.sourceFrame.width = 0, D.sourceFrame.height = 0)) : D.sourceFrame.intersects(W) || (D.sourceFrame.width = 0, D.sourceFrame.height = 0), this.roundFrame(D.sourceFrame, L.current ? L.current.resolution : N.resolution, L.sourceFrame, L.destinationFrame, N.projection.transform), D.renderTexture = this.getOptimalFilterTexture(D.sourceFrame.width, D.sourceFrame.height, B, $), D.filters = e, D.destinationFrame.width = D.renderTexture.width, D.destinationFrame.height = D.renderTexture.height;\n    var Y = this.tempRect;\n    Y.x = 0, Y.y = 0, Y.width = D.sourceFrame.width, Y.height = D.sourceFrame.height, D.renderTexture.filterFrame = D.sourceFrame, D.bindingSourceFrame.copyFrom(L.sourceFrame), D.bindingDestinationFrame.copyFrom(L.destinationFrame), D.transform = N.projection.transform, N.projection.transform = null, L.bind(D.renderTexture, D.sourceFrame, Y), N.framebuffer.clear(0, 0, 0, 0);\n  }, n.prototype.pop = function() {\n    var t = this.defaultFilterStack, e = t.pop(), o = e.filters;\n    this.activeState = e;\n    var R = this.globalUniforms.uniforms;\n    R.outputFrame = e.sourceFrame, R.resolution = e.resolution;\n    var N = R.inputSize, M = R.inputPixel, D = R.inputClamp;\n    if (N[0] = e.destinationFrame.width, N[1] = e.destinationFrame.height, N[2] = 1 / N[0], N[3] = 1 / N[1], M[0] = Math.round(N[0] * e.resolution), M[1] = Math.round(N[1] * e.resolution), M[2] = 1 / M[0], M[3] = 1 / M[1], D[0] = 0.5 * M[2], D[1] = 0.5 * M[3], D[2] = e.sourceFrame.width * N[2] - 0.5 * M[2], D[3] = e.sourceFrame.height * N[3] - 0.5 * M[3], e.legacy) {\n      var L = R.filterArea;\n      L[0] = e.destinationFrame.width, L[1] = e.destinationFrame.height, L[2] = e.sourceFrame.x, L[3] = e.sourceFrame.y, R.filterClamp = R.inputClamp;\n    }\n    this.globalUniforms.update();\n    var B = t[t.length - 1];\n    if (this.renderer.framebuffer.blit(), o.length === 1)\n      o[0].apply(this, e.renderTexture, B.renderTexture, CLEAR_MODES$5.BLEND, e), this.returnFilterTexture(e.renderTexture);\n    else {\n      var $ = e.renderTexture, k = this.getOptimalFilterTexture($.width, $.height, e.resolution);\n      k.filterFrame = $.filterFrame;\n      var U = 0;\n      for (U = 0; U < o.length - 1; ++U) {\n        U === 1 && e.multisample > 1 && (k = this.getOptimalFilterTexture($.width, $.height, e.resolution), k.filterFrame = $.filterFrame), o[U].apply(this, $, k, CLEAR_MODES$5.CLEAR, e);\n        var z = $;\n        $ = k, k = z;\n      }\n      o[U].apply(this, $, B.renderTexture, CLEAR_MODES$5.BLEND, e), U > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture($), this.returnFilterTexture(k);\n    }\n    e.clear(), this.statePool.push(e);\n  }, n.prototype.bindAndClear = function(t, e) {\n    e === void 0 && (e = CLEAR_MODES$5.CLEAR);\n    var o = this.renderer, R = o.renderTexture, N = o.state;\n    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {\n      var M = this.tempRect;\n      M.x = 0, M.y = 0, M.width = t.filterFrame.width, M.height = t.filterFrame.height, R.bind(t, t.filterFrame, M);\n    } else\n      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? R.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    var D = N.stateId & 1 || this.forceClear;\n    (e === CLEAR_MODES$5.CLEAR || e === CLEAR_MODES$5.BLIT && D) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }, n.prototype.applyFilter = function(t, e, o, R) {\n    var N = this.renderer;\n    N.state.set(t.state), this.bindAndClear(o, R), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, N.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), N.geometry.bind(this.quadUv), N.geometry.draw(DRAW_MODES$5.TRIANGLES)) : (N.geometry.bind(this.quad), N.geometry.draw(DRAW_MODES$5.TRIANGLE_STRIP));\n  }, n.prototype.calculateSpriteMatrix = function(t, e) {\n    var o = this.activeState, R = o.sourceFrame, N = o.destinationFrame, M = e._texture.orig, D = t.set(N.width, 0, 0, N.height, R.x, R.y), L = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return L.invert(), D.prepend(L), D.scale(1 / M.width, 1 / M.height), D.translate(e.anchor.x, e.anchor.y), D;\n  }, n.prototype.destroy = function() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }, n.prototype.getOptimalFilterTexture = function(t, e, o, R) {\n    return o === void 0 && (o = 1), R === void 0 && (R = MSAA_QUALITY$5.NONE), this.texturePool.getOptimalTexture(t, e, o, R);\n  }, n.prototype.getFilterTexture = function(t, e, o) {\n    if (typeof t == \"number\") {\n      var R = t;\n      t = e, e = R;\n    }\n    t = t || this.activeState.renderTexture;\n    var N = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);\n    return N.filterFrame = t.filterFrame, N;\n  }, n.prototype.returnFilterTexture = function(t) {\n    this.texturePool.returnTexture(t);\n  }, n.prototype.emptyPool = function() {\n    this.texturePool.clear(!0);\n  }, n.prototype.resize = function() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }, n.prototype.transformAABB = function(t, e) {\n    var o = tempPoints[0], R = tempPoints[1], N = tempPoints[2], M = tempPoints[3];\n    o.set(e.left, e.top), R.set(e.left, e.bottom), N.set(e.right, e.top), M.set(e.right, e.bottom), t.apply(o, o), t.apply(R, R), t.apply(N, N), t.apply(M, M);\n    var D = Math.min(o.x, R.x, N.x, M.x), L = Math.min(o.y, R.y, N.y, M.y), B = Math.max(o.x, R.x, N.x, M.x), $ = Math.max(o.y, R.y, N.y, M.y);\n    e.x = D, e.y = L, e.width = B - D, e.height = $ - L;\n  }, n.prototype.roundFrame = function(t, e, o, R, N) {\n    if (!(t.width <= 0 || t.height <= 0 || o.width <= 0 || o.height <= 0)) {\n      if (N) {\n        var M = N.a, D = N.b, L = N.c, B = N.d;\n        if ((Math.abs(D) > 1e-4 || Math.abs(L) > 1e-4) && (Math.abs(M) > 1e-4 || Math.abs(B) > 1e-4))\n          return;\n      }\n      N = N ? tempMatrix$2.copyFrom(N) : tempMatrix$2.identity(), N.translate(-o.x, -o.y).scale(R.width / o.width, R.height / o.height).translate(R.x, R.y), this.transformAABB(N, t), t.ceil(e), this.transformAABB(N.invert(), t);\n    }\n  }, n;\n}(), ObjectRenderer = function() {\n  function n(t) {\n    this.renderer = t;\n  }\n  return n.prototype.flush = function() {\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n.prototype.start = function() {\n  }, n.prototype.stop = function() {\n    this.flush();\n  }, n.prototype.render = function(t) {\n  }, n;\n}(), BatchSystem = function() {\n  function n(t) {\n    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;\n  }\n  return n.prototype.setObjectRenderer = function(t) {\n    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());\n  }, n.prototype.flush = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, n.prototype.reset = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, n.prototype.copyBoundTextures = function(t, e) {\n    for (var o = this.renderer.texture.boundTextures, R = e - 1; R >= 0; --R)\n      t[R] = o[R] || null, t[R] && (t[R]._batchLocation = R);\n  }, n.prototype.boundArray = function(t, e, o, R) {\n    for (var N = t.elements, M = t.ids, D = t.count, L = 0, B = 0; B < D; B++) {\n      var $ = N[B], k = $._batchLocation;\n      if (k >= 0 && k < R && e[k] === $) {\n        M[B] = k;\n        continue;\n      }\n      for (; L < R; ) {\n        var U = e[L];\n        if (U && U._batchEnabled === o && U._batchLocation === L) {\n          L++;\n          continue;\n        }\n        M[B] = L, $._batchLocation = L, e[L] = $;\n        break;\n      }\n    }\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {\n  function n(t) {\n    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n      uint32Indices: !1\n    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), t.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1);\n  }\n  return Object.defineProperty(n.prototype, \"isLost\", {\n    get: function() {\n      return !this.gl || this.gl.isContextLost();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.contextChange = function(t) {\n    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension(\"WEBGL_lose_context\") && t.getExtension(\"WEBGL_lose_context\").restoreContext();\n  }, n.prototype.initFromContext = function(t) {\n    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);\n  }, n.prototype.initFromOptions = function(t) {\n    var e = this.createContext(this.renderer.view, t);\n    this.initFromContext(e);\n  }, n.prototype.createContext = function(t, e) {\n    var o;\n    if (settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (o = t.getContext(\"webgl2\", e)), o)\n      this.webGLVersion = 2;\n    else if (this.webGLVersion = 1, o = t.getContext(\"webgl\", e) || t.getContext(\"experimental-webgl\", e), !o)\n      throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n    return this.gl = o, this.getExtensions(), this.gl;\n  }, n.prototype.getExtensions = function() {\n    var t = this.gl, e = {\n      anisotropicFiltering: t.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      s3tc: t.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: t.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      etc: t.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: t.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: t.getExtension(\"WEBGL_compressed_texture_pvrtc\") || t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: t.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: t.getExtension(\"WEBGL_compressed_texture_astc\")\n    };\n    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {\n      drawBuffers: t.getExtension(\"WEBGL_draw_buffers\"),\n      depthTexture: t.getExtension(\"WEBGL_depth_texture\"),\n      loseContext: t.getExtension(\"WEBGL_lose_context\"),\n      vertexArrayObject: t.getExtension(\"OES_vertex_array_object\") || t.getExtension(\"MOZ_OES_vertex_array_object\") || t.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n      uint32ElementIndex: t.getExtension(\"OES_element_index_uint\"),\n      floatTexture: t.getExtension(\"OES_texture_float\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      textureHalfFloat: t.getExtension(\"OES_texture_half_float\"),\n      textureHalfFloatLinear: t.getExtension(\"OES_texture_half_float_linear\")\n    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {\n      colorBufferFloat: t.getExtension(\"EXT_color_buffer_float\")\n    });\n  }, n.prototype.handleContextLost = function(t) {\n    t.preventDefault();\n  }, n.prototype.handleContextRestored = function() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }, n.prototype.destroy = function() {\n    var t = this.renderer.view;\n    this.renderer = null, t.removeEventListener(\"webglcontextlost\", this.handleContextLost), t.removeEventListener(\"webglcontextrestored\", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n  }, n.prototype.postrender = function() {\n    this.renderer.renderingToScreen && this.gl.flush();\n  }, n.prototype.validateContext = function(t) {\n    var e = t.getContextAttributes(), o = \"WebGL2RenderingContext\" in globalThis && t instanceof globalThis.WebGL2RenderingContext;\n    o && (this.webGLVersion = 2), e && !e.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    var R = o || !!t.getExtension(\"OES_element_index_uint\");\n    this.supports.uint32Indices = R, R || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n  }, n;\n}(), GLFramebuffer = function() {\n  function n(t) {\n    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY$5.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n  }\n  return n;\n}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {\n  function n(t) {\n    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;\n  }\n  return n.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {\n      var e = this.renderer.context.extensions.drawBuffers, o = this.renderer.context.extensions.depthTexture;\n      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (e = null, o = null), e ? t.drawBuffers = function(R) {\n        return e.drawBuffersWEBGL(R);\n      } : (this.hasMRT = !1, t.drawBuffers = function() {\n      }), o || (this.writeDepthTexture = !1);\n    } else\n      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);\n  }, n.prototype.bind = function(t, e, o) {\n    o === void 0 && (o = 0);\n    var R = this.gl;\n    if (t) {\n      var N = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);\n      this.current !== t && (this.current = t, R.bindFramebuffer(R.FRAMEBUFFER, N.framebuffer)), N.mipLevel !== o && (t.dirtyId++, t.dirtyFormat++, N.mipLevel = o), N.dirtyId !== t.dirtyId && (N.dirtyId = t.dirtyId, N.dirtyFormat !== t.dirtyFormat ? (N.dirtyFormat = t.dirtyFormat, N.dirtySize = t.dirtySize, this.updateFramebuffer(t, o)) : N.dirtySize !== t.dirtySize && (N.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));\n      for (var M = 0; M < t.colorTextures.length; M++) {\n        var D = t.colorTextures[M];\n        this.renderer.texture.unbind(D.parentTextureArray || D);\n      }\n      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {\n        var L = e.width >> o, B = e.height >> o, $ = L / e.width;\n        this.setViewport(e.x * $, e.y * $, L, B);\n      } else {\n        var L = t.width >> o, B = t.height >> o;\n        this.setViewport(0, 0, L, B);\n      }\n    } else\n      this.current && (this.current = null, R.bindFramebuffer(R.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n  }, n.prototype.setViewport = function(t, e, o, R) {\n    var N = this.viewport;\n    t = Math.round(t), e = Math.round(e), o = Math.round(o), R = Math.round(R), (N.width !== o || N.height !== R || N.x !== t || N.y !== e) && (N.x = t, N.y = e, N.width = o, N.height = R, this.gl.viewport(t, e, o, R));\n  }, Object.defineProperty(n.prototype, \"size\", {\n    get: function() {\n      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.clear = function(t, e, o, R, N) {\n    N === void 0 && (N = BUFFER_BITS$5.COLOR | BUFFER_BITS$5.DEPTH);\n    var M = this.gl;\n    M.clearColor(t, e, o, R), M.clear(N);\n  }, n.prototype.initFramebuffer = function(t) {\n    var e = this.gl, o = new GLFramebuffer(e.createFramebuffer());\n    return o.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = o, this.managedFramebuffers.push(t), t.disposeRunner.add(this), o;\n  }, n.prototype.resizeFramebuffer = function(t) {\n    var e = this.gl, o = t.glFramebuffers[this.CONTEXT_UID];\n    o.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, o.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.RGBA8, t.width, t.height)), o.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, o.stencil), o.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));\n    var R = t.colorTextures, N = R.length;\n    e.drawBuffers || (N = Math.min(N, 1));\n    for (var M = 0; M < N; M++) {\n      var D = R[M], L = D.parentTextureArray || D;\n      this.renderer.texture.bind(L, 0);\n    }\n    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);\n  }, n.prototype.updateFramebuffer = function(t, e) {\n    var o = this.gl, R = t.glFramebuffers[this.CONTEXT_UID], N = t.colorTextures, M = N.length;\n    o.drawBuffers || (M = Math.min(M, 1)), R.multisample > 1 && this.canMultisampleFramebuffer(t) ? (R.msaaBuffer = R.msaaBuffer || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, R.msaaBuffer), o.renderbufferStorageMultisample(o.RENDERBUFFER, R.multisample, o.RGBA8, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.RENDERBUFFER, R.msaaBuffer)) : R.msaaBuffer && (o.deleteRenderbuffer(R.msaaBuffer), R.msaaBuffer = null, R.blitFramebuffer && (R.blitFramebuffer.dispose(), R.blitFramebuffer = null));\n    for (var D = [], L = 0; L < M; L++) {\n      var B = N[L], $ = B.parentTextureArray || B;\n      this.renderer.texture.bind($, 0), !(L === 0 && R.msaaBuffer) && (o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + L, B.target, $._glTextures[this.CONTEXT_UID].texture, e), D.push(o.COLOR_ATTACHMENT0 + L));\n    }\n    if (D.length > 1 && o.drawBuffers(D), t.depthTexture) {\n      var k = this.writeDepthTexture;\n      if (k) {\n        var U = t.depthTexture;\n        this.renderer.texture.bind(U, 0), o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.TEXTURE_2D, U._glTextures[this.CONTEXT_UID].texture, e);\n      }\n    }\n    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (R.stencil = R.stencil || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, R.stencil), R.msaaBuffer ? o.renderbufferStorageMultisample(o.RENDERBUFFER, R.multisample, o.DEPTH24_STENCIL8, t.width, t.height) : o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, R.stencil)) : R.stencil && (o.deleteRenderbuffer(R.stencil), R.stencil = null);\n  }, n.prototype.canMultisampleFramebuffer = function(t) {\n    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;\n  }, n.prototype.detectSamples = function(t) {\n    var e = this.msaaSamples, o = MSAA_QUALITY$5.NONE;\n    if (t <= 1 || e === null)\n      return o;\n    for (var R = 0; R < e.length; R++)\n      if (e[R] <= t) {\n        o = e[R];\n        break;\n      }\n    return o === 1 && (o = MSAA_QUALITY$5.NONE), o;\n  }, n.prototype.blit = function(t, e, o) {\n    var R = this, N = R.current, M = R.renderer, D = R.gl, L = R.CONTEXT_UID;\n    if (M.context.webGLVersion === 2 && !!N) {\n      var B = N.glFramebuffers[L];\n      if (!!B) {\n        if (!t) {\n          if (!B.msaaBuffer)\n            return;\n          var $ = N.colorTextures[0];\n          if (!$)\n            return;\n          B.blitFramebuffer || (B.blitFramebuffer = new Framebuffer(N.width, N.height), B.blitFramebuffer.addColorTexture(0, $)), t = B.blitFramebuffer, t.colorTextures[0] !== $ && (t.colorTextures[0] = $, t.dirtyId++, t.dirtyFormat++), (t.width !== N.width || t.height !== N.height) && (t.width = N.width, t.height = N.height, t.dirtyId++, t.dirtySize++);\n        }\n        e || (e = tempRectangle, e.width = N.width, e.height = N.height), o || (o = e);\n        var k = e.width === o.width && e.height === o.height;\n        this.bind(t), D.bindFramebuffer(D.READ_FRAMEBUFFER, B.framebuffer), D.blitFramebuffer(e.left, e.top, e.right, e.bottom, o.left, o.top, o.right, o.bottom, D.COLOR_BUFFER_BIT, k ? D.NEAREST : D.LINEAR);\n      }\n    }\n  }, n.prototype.disposeFramebuffer = function(t, e) {\n    var o = t.glFramebuffers[this.CONTEXT_UID], R = this.gl;\n    if (!!o) {\n      delete t.glFramebuffers[this.CONTEXT_UID];\n      var N = this.managedFramebuffers.indexOf(t);\n      N >= 0 && this.managedFramebuffers.splice(N, 1), t.disposeRunner.remove(this), e || (R.deleteFramebuffer(o.framebuffer), o.msaaBuffer && R.deleteRenderbuffer(o.msaaBuffer), o.stencil && R.deleteRenderbuffer(o.stencil)), o.blitFramebuffer && o.blitFramebuffer.dispose();\n    }\n  }, n.prototype.disposeAll = function(t) {\n    var e = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (var o = 0; o < e.length; o++)\n      this.disposeFramebuffer(e[o], t);\n  }, n.prototype.forceStencil = function() {\n    var t = this.current;\n    if (!!t) {\n      var e = t.glFramebuffers[this.CONTEXT_UID];\n      if (!(!e || e.stencil)) {\n        t.stencil = !0;\n        var o = t.width, R = t.height, N = this.gl, M = N.createRenderbuffer();\n        N.bindRenderbuffer(N.RENDERBUFFER, M), e.msaaBuffer ? N.renderbufferStorageMultisample(N.RENDERBUFFER, e.multisample, N.DEPTH24_STENCIL8, o, R) : N.renderbufferStorage(N.RENDERBUFFER, N.DEPTH_STENCIL, o, R), e.stencil = M, N.framebufferRenderbuffer(N.FRAMEBUFFER, N.DEPTH_STENCIL_ATTACHMENT, N.RENDERBUFFER, M);\n      }\n    }\n  }, n.prototype.reset = function() {\n    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {\n  function n(t) {\n    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n  }\n  return n.prototype.contextChange = function() {\n    this.disposeAll(!0);\n    var t = this.gl = this.renderer.gl, e = this.renderer.context;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {\n      var o = this.renderer.context.extensions.vertexArrayObject;\n      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (o = null), o ? (t.createVertexArray = function() {\n        return o.createVertexArrayOES();\n      }, t.bindVertexArray = function(N) {\n        return o.bindVertexArrayOES(N);\n      }, t.deleteVertexArray = function(N) {\n        return o.deleteVertexArrayOES(N);\n      }) : (this.hasVao = !1, t.createVertexArray = function() {\n        return null;\n      }, t.bindVertexArray = function() {\n        return null;\n      }, t.deleteVertexArray = function() {\n        return null;\n      });\n    }\n    if (e.webGLVersion !== 2) {\n      var R = t.getExtension(\"ANGLE_instanced_arrays\");\n      R ? (t.vertexAttribDivisor = function(N, M) {\n        return R.vertexAttribDivisorANGLE(N, M);\n      }, t.drawElementsInstanced = function(N, M, D, L, B) {\n        return R.drawElementsInstancedANGLE(N, M, D, L, B);\n      }, t.drawArraysInstanced = function(N, M, D, L) {\n        return R.drawArraysInstancedANGLE(N, M, D, L);\n      }) : this.hasInstance = !1;\n    }\n    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;\n  }, n.prototype.bind = function(t, e) {\n    e = e || this.renderer.shader.shader;\n    var o = this.gl, R = t.glVertexArrayObjects[this.CONTEXT_UID], N = !1;\n    R || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = R = {}, N = !0);\n    var M = R[e.program.id] || this.initGeometryVao(t, e, N);\n    this._activeGeometry = t, this._activeVao !== M && (this._activeVao = M, this.hasVao ? o.bindVertexArray(M) : this.activateVao(t, e.program)), this.updateBuffers();\n  }, n.prototype.reset = function() {\n    this.unbind();\n  }, n.prototype.updateBuffers = function() {\n    for (var t = this._activeGeometry, e = this.renderer.buffer, o = 0; o < t.buffers.length; o++) {\n      var R = t.buffers[o];\n      e.update(R);\n    }\n  }, n.prototype.checkCompatibility = function(t, e) {\n    var o = t.attributes, R = e.attributeData;\n    for (var N in R)\n      if (!o[N])\n        throw new Error('shader and geometry incompatible, geometry missing the \"' + N + '\" attribute');\n  }, n.prototype.getSignature = function(t, e) {\n    var o = t.attributes, R = e.attributeData, N = [\"g\", t.id];\n    for (var M in o)\n      R[M] && N.push(M, R[M].location);\n    return N.join(\"-\");\n  }, n.prototype.initGeometryVao = function(t, e, o) {\n    o === void 0 && (o = !0);\n    var R = this.gl, N = this.CONTEXT_UID, M = this.renderer.buffer, D = e.program;\n    D.glPrograms[N] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, D);\n    var L = this.getSignature(t, D), B = t.glVertexArrayObjects[this.CONTEXT_UID], $ = B[L];\n    if ($)\n      return B[D.id] = $, $;\n    var k = t.buffers, U = t.attributes, z = {}, X = {};\n    for (var V in k)\n      z[V] = 0, X[V] = 0;\n    for (var V in U)\n      !U[V].size && D.attributeData[V] ? U[V].size = D.attributeData[V].size : U[V].size || console.warn(\"PIXI Geometry attribute '\" + V + \"' size cannot be determined (likely the bound shader does not have the attribute)\"), z[U[V].buffer] += U[V].size * byteSizeMap[U[V].type];\n    for (var V in U) {\n      var W = U[V], Y = W.size;\n      W.stride === void 0 && (z[W.buffer] === Y * byteSizeMap[W.type] ? W.stride = 0 : W.stride = z[W.buffer]), W.start === void 0 && (W.start = X[W.buffer], X[W.buffer] += Y * byteSizeMap[W.type]);\n    }\n    $ = R.createVertexArray(), R.bindVertexArray($);\n    for (var q = 0; q < k.length; q++) {\n      var Z = k[q];\n      M.bind(Z), o && Z._glBuffers[N].refCount++;\n    }\n    return this.activateVao(t, D), this._activeVao = $, B[D.id] = $, B[L] = $, $;\n  }, n.prototype.disposeGeometry = function(t, e) {\n    var o;\n    if (!!this.managedGeometries[t.id]) {\n      delete this.managedGeometries[t.id];\n      var R = t.glVertexArrayObjects[this.CONTEXT_UID], N = this.gl, M = t.buffers, D = (o = this.renderer) === null || o === void 0 ? void 0 : o.buffer;\n      if (t.disposeRunner.remove(this), !!R) {\n        if (D)\n          for (var L = 0; L < M.length; L++) {\n            var B = M[L]._glBuffers[this.CONTEXT_UID];\n            B && (B.refCount--, B.refCount === 0 && !e && D.dispose(M[L], e));\n          }\n        if (!e) {\n          for (var $ in R)\n            if ($[0] === \"g\") {\n              var k = R[$];\n              this._activeVao === k && this.unbind(), N.deleteVertexArray(k);\n            }\n        }\n        delete t.glVertexArrayObjects[this.CONTEXT_UID];\n      }\n    }\n  }, n.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedGeometries), o = 0; o < e.length; o++)\n      this.disposeGeometry(this.managedGeometries[e[o]], t);\n  }, n.prototype.activateVao = function(t, e) {\n    var o = this.gl, R = this.CONTEXT_UID, N = this.renderer.buffer, M = t.buffers, D = t.attributes;\n    t.indexBuffer && N.bind(t.indexBuffer);\n    var L = null;\n    for (var B in D) {\n      var $ = D[B], k = M[$.buffer], U = k._glBuffers[R];\n      if (e.attributeData[B]) {\n        L !== U && (N.bind(k), L = U);\n        var z = e.attributeData[B].location;\n        if (o.enableVertexAttribArray(z), o.vertexAttribPointer(z, $.size, $.type || o.FLOAT, $.normalized, $.stride, $.start), $.instance)\n          if (this.hasInstance)\n            o.vertexAttribDivisor(z, 1);\n          else\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n      }\n    }\n  }, n.prototype.draw = function(t, e, o, R) {\n    var N = this.gl, M = this._activeGeometry;\n    if (M.indexBuffer) {\n      var D = M.indexBuffer.data.BYTES_PER_ELEMENT, L = D === 2 ? N.UNSIGNED_SHORT : N.UNSIGNED_INT;\n      D === 2 || D === 4 && this.canUseUInt32ElementIndex ? M.instanced ? N.drawElementsInstanced(t, e || M.indexBuffer.data.length, L, (o || 0) * D, R || 1) : N.drawElements(t, e || M.indexBuffer.data.length, L, (o || 0) * D) : console.warn(\"unsupported index buffer type: uint32\");\n    } else\n      M.instanced ? N.drawArraysInstanced(t, o, e || M.getSize(), R || 1) : N.drawArrays(t, o, e || M.getSize());\n    return this;\n  }, n.prototype.unbind = function() {\n    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), MaskData = function() {\n  function n(t) {\n    t === void 0 && (t = null), this.type = MASK_TYPES$5.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings$1.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  return Object.defineProperty(n.prototype, \"filter\", {\n    get: function() {\n      return this._filters ? this._filters[0] : null;\n    },\n    set: function(t) {\n      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.reset = function() {\n    this.pooled && (this.maskObject = null, this.type = MASK_TYPES$5.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }, n.prototype.copyCountersOrReset = function(t) {\n    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }, n;\n}();\nfunction compileShader(n, t, e) {\n  var o = n.createShader(t);\n  return n.shaderSource(o, e), n.compileShader(o), o;\n}\nfunction logPrettyShaderError(n, t) {\n  var e = n.getShaderSource(t).split(`\n`).map(function(B, $) {\n    return $ + \": \" + B;\n  }), o = n.getShaderInfoLog(t), R = o.split(`\n`), N = {}, M = R.map(function(B) {\n    return parseFloat(B.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function(B) {\n    return B && !N[B] ? (N[B] = !0, !0) : !1;\n  }), D = [\"\"];\n  M.forEach(function(B) {\n    e[B - 1] = \"%c\" + e[B - 1] + \"%c\", D.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var L = e.join(`\n`);\n  D[0] = L, console.error(o), console.groupCollapsed(\"click to view full shader code\"), console.warn.apply(console, D), console.groupEnd();\n}\nfunction logProgramError(n, t, e, o) {\n  n.getProgramParameter(t, n.LINK_STATUS) || (n.getShaderParameter(e, n.COMPILE_STATUS) || logPrettyShaderError(n, e), n.getShaderParameter(o, n.COMPILE_STATUS) || logPrettyShaderError(n, o), console.error(\"PixiJS Error: Could not initialize shader.\"), n.getProgramInfoLog(t) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", n.getProgramInfoLog(t)));\n}\nfunction booleanArray(n) {\n  for (var t = new Array(n), e = 0; e < t.length; e++)\n    t[e] = !1;\n  return t;\n}\nfunction defaultValue(n, t) {\n  switch (n) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * t);\n    case \"vec3\":\n      return new Float32Array(3 * t);\n    case \"vec4\":\n      return new Float32Array(4 * t);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * t);\n    case \"ivec3\":\n      return new Int32Array(3 * t);\n    case \"ivec4\":\n      return new Int32Array(4 * t);\n    case \"uvec2\":\n      return new Uint32Array(2 * t);\n    case \"uvec3\":\n      return new Uint32Array(3 * t);\n    case \"uvec4\":\n      return new Uint32Array(4 * t);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return booleanArray(2 * t);\n    case \"bvec3\":\n      return booleanArray(3 * t);\n    case \"bvec4\":\n      return booleanArray(4 * t);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar unknownContext = {}, context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context && context.isContextLost()) {\n    var n = settings$1.ADAPTER.createCanvas(), t = void 0;\n    settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (t = n.getContext(\"webgl2\", {})), t || (t = n.getContext(\"webgl\", {}) || n.getContext(\"experimental-webgl\", {}), t ? t.getExtension(\"WEBGL_draw_buffers\") : t = null), context = t;\n  }\n  return context;\n}\nvar maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION$5.MEDIUM;\n    var n = getTestContext();\n    if (n && n.getShaderPrecisionFormat) {\n      var t = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT);\n      maxFragmentPrecision = t.precision ? PRECISION$5.HIGH : PRECISION$5.MEDIUM;\n    }\n  }\n  return maxFragmentPrecision;\n}\nfunction setPrecision(n, t, e) {\n  if (n.substring(0, 9) !== \"precision\") {\n    var o = t;\n    return t === PRECISION$5.HIGH && e !== PRECISION$5.HIGH && (o = PRECISION$5.MEDIUM), \"precision \" + o + ` float;\n` + n;\n  } else if (e !== PRECISION$5.HIGH && n.substring(0, 15) === \"precision highp\")\n    return n.replace(\"precision highp\", \"precision mediump\");\n  return n;\n}\nvar GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(n) {\n  return GLSL_TO_SIZE[n];\n}\nvar GL_TABLE = null, GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(n, t) {\n  if (!GL_TABLE) {\n    var e = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (var o = 0; o < e.length; ++o) {\n      var R = e[o];\n      GL_TABLE[n[R]] = GL_TO_GLSL_TYPES[R];\n    }\n  }\n  return GL_TABLE[t];\n}\nvar uniformParsers = [\n  {\n    test: function(n) {\n      return n.type === \"float\" && n.size === 1;\n    },\n    code: function(n) {\n      return `\n            if(uv[\"` + n + '\"] !== ud[\"' + n + `\"].value)\n            {\n                ud[\"` + n + '\"].value = uv[\"' + n + `\"]\n                gl.uniform1f(ud[\"` + n + '\"].location, uv[\"' + n + `\"])\n            }\n            `;\n    }\n  },\n  {\n    test: function(n) {\n      return (n.type === \"sampler2D\" || n.type === \"samplerCube\" || n.type === \"sampler2DArray\") && n.size === 1 && !n.isArray;\n    },\n    code: function(n) {\n      return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"` + n + `\"], t);\n\n            if(ud[\"` + n + `\"].value !== t)\n            {\n                ud[\"` + n + `\"].value = t;\n                gl.uniform1i(ud[\"` + n + `\"].location, t);\n; // eslint-disable-line max-len\n            }`;\n    }\n  },\n  {\n    test: function(n, t) {\n      return n.type === \"mat3\" && n.size === 1 && t.a !== void 0;\n    },\n    code: function(n) {\n      return `\n            gl.uniformMatrix3fv(ud[\"` + n + '\"].location, false, uv[\"' + n + `\"].toArray(true));\n            `;\n    },\n    codeUbo: function(n) {\n      return `\n                var ` + n + \"_matrix = uv.\" + n + `.toArray(true);\n\n                data[offset] = ` + n + `_matrix[0];\n                data[offset+1] = ` + n + `_matrix[1];\n                data[offset+2] = ` + n + `_matrix[2];\n        \n                data[offset + 4] = ` + n + `_matrix[3];\n                data[offset + 5] = ` + n + `_matrix[4];\n                data[offset + 6] = ` + n + `_matrix[5];\n        \n                data[offset + 8] = ` + n + `_matrix[6];\n                data[offset + 9] = ` + n + `_matrix[7];\n                data[offset + 10] = ` + n + `_matrix[8];\n            `;\n    }\n  },\n  {\n    test: function(n, t) {\n      return n.type === \"vec2\" && n.size === 1 && t.x !== void 0;\n    },\n    code: function(n) {\n      return `\n                cv = ud[\"` + n + `\"].value;\n                v = uv[\"` + n + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"` + n + `\"].location, v.x, v.y);\n                }`;\n    },\n    codeUbo: function(n) {\n      return `\n                v = uv.` + n + `;\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `;\n    }\n  },\n  {\n    test: function(n) {\n      return n.type === \"vec2\" && n.size === 1;\n    },\n    code: function(n) {\n      return `\n                cv = ud[\"` + n + `\"].value;\n                v = uv[\"` + n + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"` + n + `\"].location, v[0], v[1]);\n                }\n            `;\n    }\n  },\n  {\n    test: function(n, t) {\n      return n.type === \"vec4\" && n.size === 1 && t.width !== void 0;\n    },\n    code: function(n) {\n      return `\n                cv = ud[\"` + n + `\"].value;\n                v = uv[\"` + n + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"` + n + `\"].location, v.x, v.y, v.width, v.height)\n                }`;\n    },\n    codeUbo: function(n) {\n      return `\n                    v = uv.` + n + `;\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `;\n    }\n  },\n  {\n    test: function(n) {\n      return n.type === \"vec4\" && n.size === 1;\n    },\n    code: function(n) {\n      return `\n                cv = ud[\"` + n + `\"].value;\n                v = uv[\"` + n + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"` + n + `\"].location, v[0], v[1], v[2], v[3])\n                }`;\n    }\n  }\n], GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: \"gl.uniform1i(location, v)\",\n  samplerCube: \"gl.uniform1i(location, v)\",\n  sampler2DArray: \"gl.uniform1i(location, v)\"\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(n, t) {\n  var e, o = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (var R in n.uniforms) {\n    var N = t[R];\n    if (!N) {\n      !((e = n.uniforms[R]) === null || e === void 0) && e.group && (n.uniforms[R].ubo ? o.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.` + R + \", '\" + R + `');\n                    `) : o.push(`\n                        renderer.shader.syncUniformGroup(uv.` + R + `, syncData);\n                    `));\n      continue;\n    }\n    for (var M = n.uniforms[R], D = !1, L = 0; L < uniformParsers.length; L++)\n      if (uniformParsers[L].test(N, M)) {\n        o.push(uniformParsers[L].code(R, M)), D = !0;\n        break;\n      }\n    if (!D) {\n      var B = N.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, $ = B[N.type].replace(\"location\", 'ud[\"' + R + '\"].location');\n      o.push(`\n            cu = ud[\"` + R + `\"];\n            cv = cu.value;\n            v = uv[\"` + R + `\"];\n            ` + $ + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", o.join(`\n`));\n}\nvar fragTemplate$1 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction generateIfTestSrc(n) {\n  for (var t = \"\", e = 0; e < n; ++e)\n    e > 0 && (t += `\nelse `), e < n - 1 && (t += \"if(test == \" + e + \".0){}\");\n  return t;\n}\nfunction checkMaxIfStatementsInShader(n, t) {\n  if (n === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {\n    var o = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(n));\n    if (t.shaderSource(e, o), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))\n      n = n / 2 | 0;\n    else\n      break;\n  }\n  return n;\n}\nvar unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == \"boolean\")\n    return unsafeEval;\n  try {\n    var n = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = n({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\nvar defaultFragment$2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`, defaultVertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`, UID$1 = 0, nameCache = {}, Program = function() {\n  function n(t, e, o) {\n    o === void 0 && (o = \"pixi-shader\"), this.id = UID$1++, this.vertexSrc = t || n.defaultVertexSrc, this.fragmentSrc = e || n.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== \"#version\" && (o = o.replace(/\\s+/g, \"-\"), nameCache[o] ? (nameCache[o]++, o += \"-\" + nameCache[o]) : nameCache[o] = 1, this.vertexSrc = \"#define SHADER_NAME \" + o + `\n` + this.vertexSrc, this.fragmentSrc = \"#define SHADER_NAME \" + o + `\n` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings$1.PRECISION_VERTEX, PRECISION$5.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings$1.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;\n  }\n  return Object.defineProperty(n, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$3;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.from = function(t, e, o) {\n    var R = t + e, N = ProgramCache[R];\n    return N || (ProgramCache[R] = N = new n(t, e, o)), N;\n  }, n;\n}(), Shader = function() {\n  function n(t, e) {\n    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({});\n  }\n  return n.prototype.checkUniformExists = function(t, e) {\n    if (e.uniforms[t])\n      return !0;\n    for (var o in e.uniforms) {\n      var R = e.uniforms[o];\n      if (R.group && this.checkUniformExists(t, R))\n        return !0;\n    }\n    return !1;\n  }, n.prototype.destroy = function() {\n    this.uniformGroup = null;\n  }, Object.defineProperty(n.prototype, \"uniforms\", {\n    get: function() {\n      return this.uniformGroup.uniforms;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.from = function(t, e, o) {\n    var R = Program.from(t, e);\n    return new n(R, o);\n  }, n;\n}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {\n  function n() {\n    this.data = 0, this.blendMode = BLEND_MODES$5.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n  }\n  return Object.defineProperty(n.prototype, \"blend\", {\n    get: function() {\n      return !!(this.data & 1 << BLEND$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"offsets\", {\n    get: function() {\n      return !!(this.data & 1 << OFFSET$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"culling\", {\n    get: function() {\n      return !!(this.data & 1 << CULLING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"depthTest\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_TEST$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"depthMask\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_MASK$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"clockwiseFrontFace\", {\n    get: function() {\n      return !!(this.data & 1 << WINDING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"blendMode\", {\n    get: function() {\n      return this._blendMode;\n    },\n    set: function(t) {\n      this.blend = t !== BLEND_MODES$5.NONE, this._blendMode = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"polygonOffset\", {\n    get: function() {\n      return this._polygonOffset;\n    },\n    set: function(t) {\n      this.offsets = !!t, this._polygonOffset = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.toString = function() {\n    return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n  }, n.for2d = function() {\n    var t = new n();\n    return t.depthTest = !1, t.blend = !0, t;\n  }, n;\n}(), defaultFragment$1 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`, defaultVertex$2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, Filter = function(n) {\n  __extends$q(t, n);\n  function t(e, o, R) {\n    var N = this, M = Program.from(e || t.defaultVertexSrc, o || t.defaultFragmentSrc);\n    return N = n.call(this, M, R) || this, N.padding = 0, N.resolution = settings$1.FILTER_RESOLUTION, N.multisample = settings$1.FILTER_MULTISAMPLE, N.enabled = !0, N.autoFit = !0, N.state = new State(), N;\n  }\n  return t.prototype.apply = function(e, o, R, N, M) {\n    e.applyFilter(this, o, R, N);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._resolution = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Shader), vertex$4 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`, fragment$7 = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`, tempMat$1 = new Matrix(), TextureMatrix = function() {\n  function n(t, e) {\n    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > \"u\" ? 0.5 : e, this.isSimple = !1;\n  }\n  return Object.defineProperty(n.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(t) {\n      this._texture = t, this._textureID = -1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.multiplyUvs = function(t, e) {\n    e === void 0 && (e = t);\n    for (var o = this.mapCoord, R = 0; R < t.length; R += 2) {\n      var N = t[R], M = t[R + 1];\n      e[R] = N * o.a + M * o.c + o.tx, e[R + 1] = N * o.b + M * o.d + o.ty;\n    }\n    return e;\n  }, n.prototype.update = function(t) {\n    var e = this._texture;\n    if (!e || !e.valid || !t && this._textureID === e._updateID)\n      return !1;\n    this._textureID = e._updateID, this._updateID++;\n    var o = e._uvs;\n    this.mapCoord.set(o.x1 - o.x0, o.y1 - o.y0, o.x3 - o.x0, o.y3 - o.y0, o.x0, o.y0);\n    var R = e.orig, N = e.trim;\n    N && (tempMat$1.set(R.width / N.width, 0, 0, R.height / N.height, -N.x / N.width, -N.y / N.height), this.mapCoord.append(tempMat$1));\n    var M = e.baseTexture, D = this.uClampFrame, L = this.clampMargin / M.resolution, B = this.clampOffset;\n    return D[0] = (e._frame.x + L + B) / M.width, D[1] = (e._frame.y + L + B) / M.height, D[2] = (e._frame.x + e._frame.width - L + B) / M.width, D[3] = (e._frame.y + e._frame.height - L + B) / M.height, this.uClampOffset[0] = B / M.realWidth, this.uClampOffset[1] = B / M.realHeight, this.isSimple = e._frame.width === M.width && e._frame.height === M.height && e.rotate === 0, !0;\n  }, n;\n}(), SpriteMaskFilter = function(n) {\n  __extends$q(t, n);\n  function t(e, o, R) {\n    var N = this, M = null;\n    return typeof e != \"string\" && o === void 0 && R === void 0 && (M = e, e = void 0, o = void 0, R = void 0), N = n.call(this, e || vertex$4, o || fragment$7, R) || this, N.maskSprite = M, N.maskMatrix = new Matrix(), N;\n  }\n  return Object.defineProperty(t.prototype, \"maskSprite\", {\n    get: function() {\n      return this._maskSprite;\n    },\n    set: function(e) {\n      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.apply = function(e, o, R, N) {\n    var M = this._maskSprite, D = M._texture;\n    !D.valid || (D.uvMatrix || (D.uvMatrix = new TextureMatrix(D, 0)), D.uvMatrix.update(), this.uniforms.npmAlpha = D.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = D, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, M).prepend(D.uvMatrix.mapCoord), this.uniforms.alpha = M.worldAlpha, this.uniforms.maskClamp = D.uvMatrix.uClampFrame, e.applyFilter(this, o, R, N));\n  }, t;\n}(Filter), MaskSystem = function() {\n  function n(t) {\n    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  return n.prototype.setMaskStack = function(t) {\n    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);\n  }, n.prototype.push = function(t, e) {\n    var o = e;\n    if (!o.isMaskData) {\n      var R = this.maskDataPool.pop() || new MaskData();\n      R.pooled = !0, R.maskObject = e, o = R;\n    }\n    var N = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (o.copyCountersOrReset(N), o._colorMask = N ? N._colorMask : 15, o.autoDetect && this.detect(o), o._target = t, o.type !== MASK_TYPES$5.SPRITE && this.maskStack.push(o), o.enabled)\n      switch (o.type) {\n        case MASK_TYPES$5.SCISSOR:\n          this.renderer.scissor.push(o);\n          break;\n        case MASK_TYPES$5.STENCIL:\n          this.renderer.stencil.push(o);\n          break;\n        case MASK_TYPES$5.SPRITE:\n          o.copyCountersOrReset(null), this.pushSpriteMask(o);\n          break;\n        case MASK_TYPES$5.COLOR:\n          this.pushColorMask(o);\n          break;\n      }\n    o.type === MASK_TYPES$5.SPRITE && this.maskStack.push(o);\n  }, n.prototype.pop = function(t) {\n    var e = this.maskStack.pop();\n    if (!(!e || e._target !== t)) {\n      if (e.enabled)\n        switch (e.type) {\n          case MASK_TYPES$5.SCISSOR:\n            this.renderer.scissor.pop(e);\n            break;\n          case MASK_TYPES$5.STENCIL:\n            this.renderer.stencil.pop(e.maskObject);\n            break;\n          case MASK_TYPES$5.SPRITE:\n            this.popSpriteMask(e);\n            break;\n          case MASK_TYPES$5.COLOR:\n            this.popColorMask(e);\n            break;\n        }\n      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {\n        var o = this.maskStack[this.maskStack.length - 1];\n        o.type === MASK_TYPES$5.SPRITE && o._filters && (o._filters[0].maskSprite = o.maskObject);\n      }\n    }\n  }, n.prototype.detect = function(t) {\n    var e = t.maskObject;\n    e ? e.isSprite ? t.type = MASK_TYPES$5.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES$5.SCISSOR : t.type = MASK_TYPES$5.STENCIL : t.type = MASK_TYPES$5.COLOR;\n  }, n.prototype.pushSpriteMask = function(t) {\n    var e, o, R = t.maskObject, N = t._target, M = t._filters;\n    M || (M = this.alphaMaskPool[this.alphaMaskIndex], M || (M = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));\n    var D = this.renderer, L = D.renderTexture, B, $;\n    if (L.current) {\n      var k = L.current;\n      B = t.resolution || k.resolution, $ = (e = t.multisample) !== null && e !== void 0 ? e : k.multisample;\n    } else\n      B = t.resolution || D.resolution, $ = (o = t.multisample) !== null && o !== void 0 ? o : D.multisample;\n    M[0].resolution = B, M[0].multisample = $, M[0].maskSprite = R;\n    var U = N.filterArea;\n    N.filterArea = R.getBounds(!0), D.filter.push(N, M), N.filterArea = U, t._filters || this.alphaMaskIndex++;\n  }, n.prototype.popSpriteMask = function(t) {\n    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }, n.prototype.pushColorMask = function(t) {\n    var e = t._colorMask, o = t._colorMask = e & t.colorMask;\n    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);\n  }, n.prototype.popColorMask = function(t) {\n    var e = t._colorMask, o = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), AbstractMaskSystem = function() {\n  function n(t) {\n    this.renderer = t, this.maskStack = [], this.glConst = 0;\n  }\n  return n.prototype.getStackLength = function() {\n    return this.maskStack.length;\n  }, n.prototype.setMaskStack = function(t) {\n    var e = this.renderer.gl, o = this.getStackLength();\n    this.maskStack = t;\n    var R = this.getStackLength();\n    R !== o && (R === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));\n  }, n.prototype._useCurrent = function() {\n  }, n.prototype.destroy = function() {\n    this.renderer = null, this.maskStack = null;\n  }, n;\n}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, o;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._scissorCounter : 0;\n  }, t.prototype.calcScissorRect = function(e) {\n    var o;\n    if (!e._scissorRectLocal) {\n      var R = e._scissorRect, N = e.maskObject, M = this.renderer, D = M.renderTexture, L = N.getBounds(!0, (o = rectPool.pop()) !== null && o !== void 0 ? o : new Rectangle());\n      this.roundFrameToPixels(L, D.current ? D.current.resolution : M.resolution, D.sourceFrame, D.destinationFrame, M.projection.transform), R && L.fit(R), e._scissorRectLocal = L;\n    }\n  }, t.isMatrixRotated = function(e) {\n    if (!e)\n      return !1;\n    var o = e.a, R = e.b, N = e.c, M = e.d;\n    return (Math.abs(R) > 1e-4 || Math.abs(N) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(M) > 1e-4);\n  }, t.prototype.testScissor = function(e) {\n    var o = e.maskObject;\n    if (!o.isFastRect || !o.isFastRect() || t.isMatrixRotated(o.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))\n      return !1;\n    this.calcScissorRect(e);\n    var R = e._scissorRectLocal;\n    return R.width > 0 && R.height > 0;\n  }, t.prototype.roundFrameToPixels = function(e, o, R, N, M) {\n    t.isMatrixRotated(M) || (M = M ? tempMatrix$1.copyFrom(M) : tempMatrix$1.identity(), M.translate(-R.x, -R.y).scale(N.width / R.width, N.height / R.height).translate(N.x, N.y), this.renderer.filter.transformAABB(M, e), e.fit(N), e.x = Math.round(e.x * o), e.y = Math.round(e.y * o), e.width = Math.round(e.width * o), e.height = Math.round(e.height * o));\n  }, t.prototype.push = function(e) {\n    e._scissorRectLocal || this.calcScissorRect(e);\n    var o = this.renderer.gl;\n    e._scissorRect || o.enable(o.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var o = this.renderer.gl;\n    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : o.disable(o.SCISSOR_TEST);\n  }, t.prototype._useCurrent = function() {\n    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, o;\n    this.renderer.renderTexture.current ? o = e.y : o = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, o, e.width, e.height);\n  }, t;\n}(AbstractMaskSystem), StencilSystem = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, o;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._stencilCounter : 0;\n  }, t.prototype.push = function(e) {\n    var o = e.maskObject, R = this.renderer.gl, N = e._stencilCounter;\n    N === 0 && (this.renderer.framebuffer.forceStencil(), R.clearStencil(0), R.clear(R.STENCIL_BUFFER_BIT), R.enable(R.STENCIL_TEST)), e._stencilCounter++;\n    var M = e._colorMask;\n    M !== 0 && (e._colorMask = 0, R.colorMask(!1, !1, !1, !1)), R.stencilFunc(R.EQUAL, N, 4294967295), R.stencilOp(R.KEEP, R.KEEP, R.INCR), o.renderable = !0, o.render(this.renderer), this.renderer.batch.flush(), o.renderable = !1, M !== 0 && (e._colorMask = M, R.colorMask((M & 1) !== 0, (M & 2) !== 0, (M & 4) !== 0, (M & 8) !== 0)), this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var o = this.renderer.gl;\n    if (this.getStackLength() === 0)\n      o.disable(o.STENCIL_TEST);\n    else {\n      var R = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, N = R ? R._colorMask : 15;\n      N !== 0 && (R._colorMask = 0, o.colorMask(!1, !1, !1, !1)), o.stencilOp(o.KEEP, o.KEEP, o.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, N !== 0 && (R._colorMask = N, o.colorMask((N & 1) !== 0, (N & 2) !== 0, (N & 4) !== 0, (N & 8) !== 0)), this._useCurrent();\n    }\n  }, t.prototype._useCurrent = function() {\n    var e = this.renderer.gl;\n    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);\n  }, t;\n}(AbstractMaskSystem), ProjectionSystem = function() {\n  function n(t) {\n    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;\n  }\n  return n.prototype.update = function(t, e, o, R) {\n    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, o, R), this.transform && this.projectionMatrix.append(this.transform);\n    var N = this.renderer;\n    N.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, N.globalUniforms.update(), N.shader.shader && N.shader.syncUniformGroup(N.shader.shader.uniforms.globals);\n  }, n.prototype.calculateProjection = function(t, e, o, R) {\n    var N = this.projectionMatrix, M = R ? -1 : 1;\n    N.identity(), N.a = 1 / e.width * 2, N.d = M * (1 / e.height * 2), N.tx = -1 - e.x * N.a, N.ty = -M - e.y * N.d;\n  }, n.prototype.setTransform = function(t) {\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {\n  function n(t) {\n    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();\n  }\n  return n.prototype.bind = function(t, e, o) {\n    t === void 0 && (t = null);\n    var R = this.renderer;\n    this.current = t;\n    var N, M, D;\n    t ? (N = t.baseTexture, D = N.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), o || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, o = tempRect2), M = N.framebuffer) : (D = R.resolution, e || (tempRect.width = R.screen.width, tempRect.height = R.screen.height, e = tempRect), o || (o = tempRect, o.width = e.width, o.height = e.height));\n    var L = this.viewportFrame;\n    L.x = o.x * D, L.y = o.y * D, L.width = o.width * D, L.height = o.height * D, t || (L.y = R.view.height - (L.y + L.height)), L.ceil(), this.renderer.framebuffer.bind(M, L), this.renderer.projection.update(o, e, D, !M), t ? this.renderer.mask.setMaskStack(N.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(o);\n  }, n.prototype.clear = function(t, e) {\n    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;\n    var o = this.destinationFrame, R = this.current ? this.current.baseTexture : this.renderer.screen, N = o.width !== R.width || o.height !== R.height;\n    if (N) {\n      var M = this.viewportFrame, D = M.x, L = M.y, B = M.width, $ = M.height;\n      D = Math.round(D), L = Math.round(L), B = Math.round(B), $ = Math.round($), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(D, L, B, $);\n    }\n    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), N && this.renderer.scissor.pop();\n  }, n.prototype.resize = function() {\n    this.bind(null);\n  }, n.prototype.reset = function() {\n    this.bind(null);\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}();\nfunction uboUpdate(n, t, e, o, R) {\n  e.buffer.update(R);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(n) {\n  for (var t = n.map(function(L) {\n    return {\n      data: L,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  }), e = 0, o = 0, R = 0, N = 0; N < t.length; N++) {\n    var M = t[N];\n    if (e = GLSL_TO_STD40_SIZE[M.data.type], M.data.size > 1 && (e = Math.max(e, 16) * M.data.size), M.dataLen = e, o % e !== 0 && o < 16) {\n      var D = o % e % 16;\n      o += D, R += D;\n    }\n    o + e > 16 ? (R = Math.ceil(R / 16) * 16, M.offset = R, R += e, o = e) : (M.offset = R, o += e, R += e);\n  }\n  return R = Math.ceil(R / 16) * 16, { uboElements: t, size: R };\n}\nfunction getUBOData(n, t) {\n  var e = [];\n  for (var o in n)\n    t[o] && e.push(t[o]);\n  return e.sort(function(R, N) {\n    return R.index - N.index;\n  }), e;\n}\nfunction generateUniformBufferSync(n, t) {\n  if (!n.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  for (var e = getUBOData(n.uniforms, t), o = createUBOElements(e), R = o.uboElements, N = o.size, M = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `], D = 0; D < R.length; D++) {\n    for (var L = R[D], B = n.uniforms[L.data.name], $ = L.data.name, k = !1, U = 0; U < uniformParsers.length; U++) {\n      var z = uniformParsers[U];\n      if (z.codeUbo && z.test(L.data, B)) {\n        M.push(\"offset = \" + L.offset / 4 + \";\", uniformParsers[U].codeUbo(L.data.name, B)), k = !0;\n        break;\n      }\n    }\n    if (!k)\n      if (L.data.size > 1) {\n        var X = mapSize(L.data.type), V = Math.max(GLSL_TO_STD40_SIZE[L.data.type] / 16, 1), W = X / V, Y = (4 - W % 4) % 4;\n        M.push(`\n                cv = ud.` + $ + `.value;\n                v = uv.` + $ + `;\n                offset = ` + L.offset / 4 + `;\n\n                t = 0;\n\n                for(var i=0; i < ` + L.data.size * V + `; i++)\n                {\n                    for(var j = 0; j < ` + W + `; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ` + Y + `;\n                }\n\n                `);\n      } else {\n        var q = UBO_TO_SINGLE_SETTERS[L.data.type];\n        M.push(`\n                cv = ud.` + $ + `.value;\n                v = uv.` + $ + `;\n                offset = ` + L.offset / 4 + `;\n                ` + q + `;\n                `);\n      }\n  }\n  return M.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size: N,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", M.join(`\n`))\n  };\n}\nvar GLProgram = function() {\n  function n(t, e) {\n    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n  }\n  return n.prototype.destroy = function() {\n    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n  }, n;\n}();\nfunction getAttributeData(n, t) {\n  for (var e = {}, o = t.getProgramParameter(n, t.ACTIVE_ATTRIBUTES), R = 0; R < o; R++) {\n    var N = t.getActiveAttrib(n, R);\n    if (N.name.indexOf(\"gl_\") !== 0) {\n      var M = mapType(t, N.type), D = {\n        type: M,\n        name: N.name,\n        size: mapSize(M),\n        location: t.getAttribLocation(n, N.name)\n      };\n      e[N.name] = D;\n    }\n  }\n  return e;\n}\nfunction getUniformData(n, t) {\n  for (var e = {}, o = t.getProgramParameter(n, t.ACTIVE_UNIFORMS), R = 0; R < o; R++) {\n    var N = t.getActiveUniform(n, R), M = N.name.replace(/\\[.*?\\]$/, \"\"), D = !!N.name.match(/\\[.*?\\]$/), L = mapType(t, N.type);\n    e[M] = {\n      name: M,\n      index: R,\n      type: L,\n      size: N.size,\n      isArray: D,\n      value: defaultValue(L, N.size)\n    };\n  }\n  return e;\n}\nfunction generateProgram(n, t) {\n  var e = compileShader(n, n.VERTEX_SHADER, t.vertexSrc), o = compileShader(n, n.FRAGMENT_SHADER, t.fragmentSrc), R = n.createProgram();\n  if (n.attachShader(R, e), n.attachShader(R, o), n.linkProgram(R), n.getProgramParameter(R, n.LINK_STATUS) || logProgramError(n, R, e, o), t.attributeData = getAttributeData(R, n), t.uniformData = getUniformData(R, n), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(t.vertexSrc)) {\n    var N = Object.keys(t.attributeData);\n    N.sort(function($, k) {\n      return $ > k ? 1 : -1;\n    });\n    for (var M = 0; M < N.length; M++)\n      t.attributeData[N[M]].location = M, n.bindAttribLocation(R, M, N[M]);\n    n.linkProgram(R);\n  }\n  n.deleteShader(e), n.deleteShader(o);\n  var D = {};\n  for (var M in t.uniformData) {\n    var L = t.uniformData[M];\n    D[M] = {\n      location: n.getUniformLocation(R, M),\n      value: defaultValue(L.type, L.size)\n    };\n  }\n  var B = new GLProgram(R, D);\n  return B;\n}\nvar UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {\n  function n(t) {\n    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;\n  }\n  return n.prototype.systemCheck = function() {\n    if (!unsafeEvalSupported())\n      throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n  }, n.prototype.contextChange = function(t) {\n    this.gl = t, this.reset();\n  }, n.prototype.bind = function(t, e) {\n    t.uniforms.globals = this.renderer.globalUniforms;\n    var o = t.program, R = o.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);\n    return this.shader = t, this.program !== o && (this.program = o, this.gl.useProgram(R.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), R;\n  }, n.prototype.setUniforms = function(t) {\n    var e = this.shader.program, o = e.glPrograms[this.renderer.CONTEXT_UID];\n    e.syncUniforms(o.uniformData, t, this.renderer);\n  }, n.prototype.syncUniformGroup = function(t, e) {\n    var o = this.getGlProgram();\n    (!t.static || t.dirtyId !== o.uniformDirtyGroups[t.id]) && (o.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, o, e));\n  }, n.prototype.syncUniforms = function(t, e, o) {\n    var R = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);\n    R(e.uniformData, t.uniforms, this.renderer, o);\n  }, n.prototype.createSyncGroups = function(t) {\n    var e = this.getSignature(t, this.shader.program.uniformData, \"u\");\n    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];\n  }, n.prototype.syncUniformBufferGroup = function(t, e) {\n    var o = this.getGlProgram();\n    if (!t.static || t.dirtyId !== 0 || !o.uniformGroups[t.id]) {\n      t.dirtyId = 0;\n      var R = o.uniformGroups[t.id] || this.createSyncBufferGroup(t, o, e);\n      t.buffer.update(), R(o.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(t.buffer, o.uniformBufferBindings[e]);\n  }, n.prototype.createSyncBufferGroup = function(t, e, o) {\n    var R = this.renderer.gl;\n    this.renderer.buffer.bind(t.buffer);\n    var N = this.gl.getUniformBlockIndex(e.program, o);\n    e.uniformBufferBindings[o] = this.shader.uniformBindCount, R.uniformBlockBinding(e.program, N, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n    var M = this.getSignature(t, this.shader.program.uniformData, \"ubo\"), D = this._uboCache[M];\n    if (D || (D = this._uboCache[M] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {\n      var L = new Float32Array(D.size / 4);\n      t.buffer.update(L);\n    }\n    return e.uniformGroups[t.id] = D.syncFunc, e.uniformGroups[t.id];\n  }, n.prototype.getSignature = function(t, e, o) {\n    var R = t.uniforms, N = [o + \"-\"];\n    for (var M in R)\n      N.push(M), e[M] && N.push(e[M].type);\n    return N.join(\"-\");\n  }, n.prototype.getGlProgram = function() {\n    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n  }, n.prototype.generateProgram = function(t) {\n    var e = this.gl, o = t.program, R = generateProgram(e, o);\n    return o.glPrograms[this.renderer.CONTEXT_UID] = R, R;\n  }, n.prototype.reset = function() {\n    this.program = null, this.shader = null;\n  }, n.prototype.destroy = function() {\n    this.renderer = null, this.destroyed = !0;\n  }, n;\n}();\nfunction mapWebGLBlendModesToPixi(n, t) {\n  return t === void 0 && (t = []), t[BLEND_MODES$5.NORMAL] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD] = [n.ONE, n.ONE], t[BLEND_MODES$5.MULTIPLY] = [n.DST_COLOR, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SCREEN] = [n.ONE, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.OVERLAY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DARKEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LIGHTEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_DODGE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_BURN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HARD_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SOFT_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DIFFERENCE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.EXCLUSION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HUE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SATURATION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LUMINOSITY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.NONE] = [0, 0], t[BLEND_MODES$5.NORMAL_NPM] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD_NPM] = [n.SRC_ALPHA, n.ONE, n.ONE, n.ONE], t[BLEND_MODES$5.SCREEN_NPM] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SRC_IN] = [n.DST_ALPHA, n.ZERO], t[BLEND_MODES$5.SRC_OUT] = [n.ONE_MINUS_DST_ALPHA, n.ZERO], t[BLEND_MODES$5.SRC_ATOP] = [n.DST_ALPHA, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_OVER] = [n.ONE_MINUS_DST_ALPHA, n.ONE], t[BLEND_MODES$5.DST_IN] = [n.ZERO, n.SRC_ALPHA], t[BLEND_MODES$5.DST_OUT] = [n.ZERO, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_ATOP] = [n.ONE_MINUS_DST_ALPHA, n.SRC_ALPHA], t[BLEND_MODES$5.XOR] = [n.ONE_MINUS_DST_ALPHA, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SUBTRACT] = [n.ONE, n.ONE, n.ONE, n.ONE, n.FUNC_REVERSE_SUBTRACT, n.FUNC_ADD], t;\n}\nvar BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {\n  function n() {\n    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES$5.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;\n  }\n  return n.prototype.contextChange = function(t) {\n    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();\n  }, n.prototype.set = function(t) {\n    if (t = t || this.defaultState, this.stateId !== t.data) {\n      for (var e = this.stateId ^ t.data, o = 0; e; )\n        e & 1 && this.map[o].call(this, !!(t.data & 1 << o)), e = e >> 1, o++;\n      this.stateId = t.data;\n    }\n    for (var o = 0; o < this.checks.length; o++)\n      this.checks[o](this, t);\n  }, n.prototype.forceState = function(t) {\n    t = t || this.defaultState;\n    for (var e = 0; e < this.map.length; e++)\n      this.map[e].call(this, !!(t.data & 1 << e));\n    for (var e = 0; e < this.checks.length; e++)\n      this.checks[e](this, t);\n    this.stateId = t.data;\n  }, n.prototype.setBlend = function(t) {\n    this.updateCheck(n.checkBlendMode, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }, n.prototype.setOffset = function(t) {\n    this.updateCheck(n.checkPolygonOffset, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }, n.prototype.setDepthTest = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }, n.prototype.setDepthMask = function(t) {\n    this.gl.depthMask(t);\n  }, n.prototype.setCullFace = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }, n.prototype.setFrontFace = function(t) {\n    this.gl.frontFace(this.gl[t ? \"CW\" : \"CCW\"]);\n  }, n.prototype.setBlendMode = function(t) {\n    if (t !== this.blendMode) {\n      this.blendMode = t;\n      var e = this.blendModes[t], o = this.gl;\n      e.length === 2 ? o.blendFunc(e[0], e[1]) : o.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, o.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, o.blendEquationSeparate(o.FUNC_ADD, o.FUNC_ADD));\n    }\n  }, n.prototype.setPolygonOffset = function(t, e) {\n    this.gl.polygonOffset(t, e);\n  }, n.prototype.reset = function() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n  }, n.prototype.updateCheck = function(t, e) {\n    var o = this.checks.indexOf(t);\n    e && o === -1 ? this.checks.push(t) : !e && o !== -1 && this.checks.splice(o, 1);\n  }, n.checkBlendMode = function(t, e) {\n    t.setBlendMode(e.blendMode);\n  }, n.checkPolygonOffset = function(t, e) {\n    t.setPolygonOffset(1, e.polygonOffset);\n  }, n.prototype.destroy = function() {\n    this.gl = null;\n  }, n;\n}(), TextureGCSystem = function() {\n  function n(t) {\n    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings$1.GC_MAX_IDLE, this.checkCountMax = settings$1.GC_MAX_CHECK_COUNT, this.mode = settings$1.GC_MODE;\n  }\n  return n.prototype.postrender = function() {\n    !this.renderer.renderingToScreen || (this.count++, this.mode !== GC_MODES$5.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n  }, n.prototype.run = function() {\n    for (var t = this.renderer.texture, e = t.managedTextures, o = !1, R = 0; R < e.length; R++) {\n      var N = e[R];\n      !N.framebuffer && this.count - N.touched > this.maxIdle && (t.destroyTexture(N, !0), e[R] = null, o = !0);\n    }\n    if (o) {\n      for (var M = 0, R = 0; R < e.length; R++)\n        e[R] !== null && (e[M++] = e[R]);\n      e.length = M;\n    }\n  }, n.prototype.unload = function(t) {\n    var e = this.renderer.texture, o = t._texture;\n    o && !o.framebuffer && e.destroyTexture(o);\n    for (var R = t.children.length - 1; R >= 0; R--)\n      this.unload(t.children[R]);\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}();\nfunction mapTypeAndFormatToInternalFormat(n) {\n  var t, e, o, R, N, M, D, L, B, $, k, U, z, X, V, W, Y, q, Z, K, Q, J, rt;\n  return \"WebGL2RenderingContext\" in globalThis && n instanceof globalThis.WebGL2RenderingContext ? rt = (t = {}, t[TYPES$5.UNSIGNED_BYTE] = (e = {}, e[FORMATS$5.RGBA] = n.RGBA8, e[FORMATS$5.RGB] = n.RGB8, e[FORMATS$5.RG] = n.RG8, e[FORMATS$5.RED] = n.R8, e[FORMATS$5.RGBA_INTEGER] = n.RGBA8UI, e[FORMATS$5.RGB_INTEGER] = n.RGB8UI, e[FORMATS$5.RG_INTEGER] = n.RG8UI, e[FORMATS$5.RED_INTEGER] = n.R8UI, e[FORMATS$5.ALPHA] = n.ALPHA, e[FORMATS$5.LUMINANCE] = n.LUMINANCE, e[FORMATS$5.LUMINANCE_ALPHA] = n.LUMINANCE_ALPHA, e), t[TYPES$5.BYTE] = (o = {}, o[FORMATS$5.RGBA] = n.RGBA8_SNORM, o[FORMATS$5.RGB] = n.RGB8_SNORM, o[FORMATS$5.RG] = n.RG8_SNORM, o[FORMATS$5.RED] = n.R8_SNORM, o[FORMATS$5.RGBA_INTEGER] = n.RGBA8I, o[FORMATS$5.RGB_INTEGER] = n.RGB8I, o[FORMATS$5.RG_INTEGER] = n.RG8I, o[FORMATS$5.RED_INTEGER] = n.R8I, o), t[TYPES$5.UNSIGNED_SHORT] = (R = {}, R[FORMATS$5.RGBA_INTEGER] = n.RGBA16UI, R[FORMATS$5.RGB_INTEGER] = n.RGB16UI, R[FORMATS$5.RG_INTEGER] = n.RG16UI, R[FORMATS$5.RED_INTEGER] = n.R16UI, R[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT16, R), t[TYPES$5.SHORT] = (N = {}, N[FORMATS$5.RGBA_INTEGER] = n.RGBA16I, N[FORMATS$5.RGB_INTEGER] = n.RGB16I, N[FORMATS$5.RG_INTEGER] = n.RG16I, N[FORMATS$5.RED_INTEGER] = n.R16I, N), t[TYPES$5.UNSIGNED_INT] = (M = {}, M[FORMATS$5.RGBA_INTEGER] = n.RGBA32UI, M[FORMATS$5.RGB_INTEGER] = n.RGB32UI, M[FORMATS$5.RG_INTEGER] = n.RG32UI, M[FORMATS$5.RED_INTEGER] = n.R32UI, M[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT24, M), t[TYPES$5.INT] = (D = {}, D[FORMATS$5.RGBA_INTEGER] = n.RGBA32I, D[FORMATS$5.RGB_INTEGER] = n.RGB32I, D[FORMATS$5.RG_INTEGER] = n.RG32I, D[FORMATS$5.RED_INTEGER] = n.R32I, D), t[TYPES$5.FLOAT] = (L = {}, L[FORMATS$5.RGBA] = n.RGBA32F, L[FORMATS$5.RGB] = n.RGB32F, L[FORMATS$5.RG] = n.RG32F, L[FORMATS$5.RED] = n.R32F, L[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT32F, L), t[TYPES$5.HALF_FLOAT] = (B = {}, B[FORMATS$5.RGBA] = n.RGBA16F, B[FORMATS$5.RGB] = n.RGB16F, B[FORMATS$5.RG] = n.RG16F, B[FORMATS$5.RED] = n.R16F, B), t[TYPES$5.UNSIGNED_SHORT_5_6_5] = ($ = {}, $[FORMATS$5.RGB] = n.RGB565, $), t[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (k = {}, k[FORMATS$5.RGBA] = n.RGBA4, k), t[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (U = {}, U[FORMATS$5.RGBA] = n.RGB5_A1, U), t[TYPES$5.UNSIGNED_INT_2_10_10_10_REV] = (z = {}, z[FORMATS$5.RGBA] = n.RGB10_A2, z[FORMATS$5.RGBA_INTEGER] = n.RGB10_A2UI, z), t[TYPES$5.UNSIGNED_INT_10F_11F_11F_REV] = (X = {}, X[FORMATS$5.RGB] = n.R11F_G11F_B10F, X), t[TYPES$5.UNSIGNED_INT_5_9_9_9_REV] = (V = {}, V[FORMATS$5.RGB] = n.RGB9_E5, V), t[TYPES$5.UNSIGNED_INT_24_8] = (W = {}, W[FORMATS$5.DEPTH_STENCIL] = n.DEPTH24_STENCIL8, W), t[TYPES$5.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Y = {}, Y[FORMATS$5.DEPTH_STENCIL] = n.DEPTH32F_STENCIL8, Y), t) : rt = (q = {}, q[TYPES$5.UNSIGNED_BYTE] = (Z = {}, Z[FORMATS$5.RGBA] = n.RGBA, Z[FORMATS$5.RGB] = n.RGB, Z[FORMATS$5.ALPHA] = n.ALPHA, Z[FORMATS$5.LUMINANCE] = n.LUMINANCE, Z[FORMATS$5.LUMINANCE_ALPHA] = n.LUMINANCE_ALPHA, Z), q[TYPES$5.UNSIGNED_SHORT_5_6_5] = (K = {}, K[FORMATS$5.RGB] = n.RGB, K), q[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (Q = {}, Q[FORMATS$5.RGBA] = n.RGBA, Q), q[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (J = {}, J[FORMATS$5.RGBA] = n.RGBA, J), q), rt;\n}\nvar GLTexture = function() {\n  function n(t) {\n    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES$5.UNSIGNED_BYTE, this.internalFormat = FORMATS$5.RGBA, this.samplerType = 0;\n  }\n  return n;\n}(), TextureSystem = function() {\n  function n(t) {\n    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  return n.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);\n    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = e;\n    for (var o = 0; o < e; o++)\n      this.boundTextures[o] = null;\n    this.emptyTextures = {};\n    var R = new GLTexture(t.createTexture());\n    t.bindTexture(t.TEXTURE_2D, R.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = R, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);\n    for (var o = 0; o < 6; o++)\n      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);\n    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);\n    for (var o = 0; o < this.boundTextures.length; o++)\n      this.bind(null, o);\n  }, n.prototype.bind = function(t, e) {\n    e === void 0 && (e = 0);\n    var o = this.gl;\n    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {\n      t.touched = this.renderer.textureGC.count;\n      var R = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);\n      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(t.target, R.texture)), R.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t;\n    } else\n      this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(o.TEXTURE_2D, this.emptyTextures[o.TEXTURE_2D].texture), this.boundTextures[e] = null;\n  }, n.prototype.reset = function() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (var t = 0; t < this.boundTextures.length; t++)\n      this.boundTextures[t] = this.unknownTexture;\n  }, n.prototype.unbind = function(t) {\n    var e = this, o = e.gl, R = e.boundTextures;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (var N = 0; N < R.length; N++)\n        R[N] === this.unknownTexture && this.bind(null, N);\n    }\n    for (var N = 0; N < R.length; N++)\n      R[N] === t && (this.currentLocation !== N && (o.activeTexture(o.TEXTURE0 + N), this.currentLocation = N), o.bindTexture(t.target, this.emptyTextures[t.target].texture), R[N] = null);\n  }, n.prototype.ensureSamplerType = function(t) {\n    var e = this, o = e.boundTextures, R = e.hasIntegerTextures, N = e.CONTEXT_UID;\n    if (!!R)\n      for (var M = t - 1; M >= 0; --M) {\n        var D = o[M];\n        if (D) {\n          var L = D._glTextures[N];\n          L.samplerType !== SAMPLER_TYPES$5.FLOAT && this.renderer.texture.unbind(D);\n        }\n      }\n  }, n.prototype.initTexture = function(t) {\n    var e = new GLTexture(this.gl.createTexture());\n    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on(\"dispose\", this.destroyTexture, this), e;\n  }, n.prototype.initTextureType = function(t, e) {\n    var o, R;\n    e.internalFormat = (R = (o = this.internalFormats[t.type]) === null || o === void 0 ? void 0 : o[t.format]) !== null && R !== void 0 ? R : t.format, this.webGLVersion === 2 && t.type === TYPES$5.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;\n  }, n.prototype.updateTexture = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    if (!!e) {\n      var o = this.renderer;\n      if (this.initTextureType(t, e), t.resource && t.resource.upload(o, t, e))\n        e.samplerType !== SAMPLER_TYPES$5.FLOAT && (this.hasIntegerTextures = !0);\n      else {\n        var R = t.realWidth, N = t.realHeight, M = o.gl;\n        (e.width !== R || e.height !== N || e.dirtyId < 0) && (e.width = R, e.height = N, M.texImage2D(t.target, 0, e.internalFormat, R, N, 0, t.format, e.type, null));\n      }\n      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;\n    }\n  }, n.prototype.destroyTexture = function(t, e) {\n    var o = this.gl;\n    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), o.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off(\"dispose\", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {\n      var R = this.managedTextures.indexOf(t);\n      R !== -1 && removeItems(this.managedTextures, R, 1);\n    }\n  }, n.prototype.updateTextureStyle = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    !e || ((t.mipmap === MIPMAP_MODES$5.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES$5.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);\n  }, n.prototype.setStyle = function(t, e) {\n    var o = this.gl;\n    if (e.mipmap && t.mipmap !== MIPMAP_MODES$5.ON_MANUAL && o.generateMipmap(t.target), o.texParameteri(t.target, o.TEXTURE_WRAP_S, e.wrapMode), o.texParameteri(t.target, o.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {\n      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR_MIPMAP_LINEAR : o.NEAREST_MIPMAP_NEAREST);\n      var R = this.renderer.context.extensions.anisotropicFiltering;\n      if (R && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES$5.LINEAR) {\n        var N = Math.min(t.anisotropicLevel, o.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        o.texParameterf(t.target, R.TEXTURE_MAX_ANISOTROPY_EXT, N);\n      }\n    } else\n      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);\n    o.texParameteri(t.target, o.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n;\n}(), tempMatrix = new Matrix(), AbstractRenderer = function(n) {\n  __extends$q(t, n);\n  function t(e, o) {\n    e === void 0 && (e = RENDERER_TYPE$5.UNKNOWN);\n    var R = n.call(this) || this;\n    return o = Object.assign({}, settings$1.RENDER_OPTIONS, o), R.options = o, R.type = e, R.screen = new Rectangle(0, 0, o.width, o.height), R.view = o.view || settings$1.ADAPTER.createCanvas(), R.resolution = o.resolution || settings$1.RESOLUTION, R.useContextAlpha = o.useContextAlpha, R.autoDensity = !!o.autoDensity, R.preserveDrawingBuffer = o.preserveDrawingBuffer, R.clearBeforeRender = o.clearBeforeRender, R._backgroundColor = 0, R._backgroundColorRgba = [0, 0, 0, 1], R._backgroundColorString = \"#000000\", R.backgroundColor = o.backgroundColor || R._backgroundColor, R.backgroundAlpha = o.backgroundAlpha, o.transparent !== void 0 && (deprecation$1(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\"), R.useContextAlpha = o.transparent, R.backgroundAlpha = o.transparent ? 0 : 1), R._lastObjectRendered = null, R.plugins = {}, R;\n  }\n  return t.prototype.initPlugins = function(e) {\n    for (var o in e)\n      this.plugins[o] = new e[o](this);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.view.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.view.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, o) {\n    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(o * this.resolution);\n    var R = this.view.width / this.resolution, N = this.view.height / this.resolution;\n    this.screen.width = R, this.screen.height = N, this.autoDensity && (this.view.style.width = R + \"px\", this.view.style.height = N + \"px\"), this.emit(\"resize\", R, N);\n  }, t.prototype.generateTexture = function(e, o, R, N) {\n    o === void 0 && (o = {}), typeof o == \"number\" && (deprecation$1(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\"), o = { scaleMode: o, resolution: R, region: N });\n    var M = o.region, D = __rest$3(o, [\"region\"]);\n    N = M || e.getLocalBounds(null, !0), N.width === 0 && (N.width = 1), N.height === 0 && (N.height = 1);\n    var L = RenderTexture.create(__assign$8({ width: N.width, height: N.height }, D));\n    return tempMatrix.tx = -N.x, tempMatrix.ty = -N.y, this.render(e, {\n      renderTexture: L,\n      clear: !1,\n      transform: tempMatrix,\n      skipUpdateTransform: !!e.parent\n    }), L;\n  }, t.prototype.destroy = function(e) {\n    for (var o in this.plugins)\n      this.plugins[o].destroy(), this.plugins[o] = null;\n    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);\n    var R = this;\n    R.plugins = null, R.type = RENDERER_TYPE$5.UNKNOWN, R.view = null, R.screen = null, R._tempDisplayObjectParent = null, R.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;\n  }, Object.defineProperty(t.prototype, \"backgroundColor\", {\n    get: function() {\n      return this._backgroundColor;\n    },\n    set: function(e) {\n      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"backgroundAlpha\", {\n    get: function() {\n      return this._backgroundColorRgba[3];\n    },\n    set: function(e) {\n      this._backgroundColorRgba[3] = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(EventEmitter$5), GLBuffer = function() {\n  function n(t) {\n    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n  }\n  return n;\n}(), BufferSystem = function() {\n  function n(t) {\n    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};\n  }\n  return n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n.prototype.contextChange = function() {\n    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }, n.prototype.bind = function(t) {\n    var e = this, o = e.gl, R = e.CONTEXT_UID, N = t._glBuffers[R] || this.createGLBuffer(t);\n    o.bindBuffer(t.type, N.buffer);\n  }, n.prototype.bindBufferBase = function(t, e) {\n    var o = this, R = o.gl, N = o.CONTEXT_UID;\n    if (this.boundBufferBases[e] !== t) {\n      var M = t._glBuffers[N] || this.createGLBuffer(t);\n      this.boundBufferBases[e] = t, R.bindBufferBase(R.UNIFORM_BUFFER, e, M.buffer);\n    }\n  }, n.prototype.bindBufferRange = function(t, e, o) {\n    var R = this, N = R.gl, M = R.CONTEXT_UID;\n    o = o || 0;\n    var D = t._glBuffers[M] || this.createGLBuffer(t);\n    N.bindBufferRange(N.UNIFORM_BUFFER, e || 0, D.buffer, o * 256, 256);\n  }, n.prototype.update = function(t) {\n    var e = this, o = e.gl, R = e.CONTEXT_UID, N = t._glBuffers[R];\n    if (t._updateID !== N.updateID)\n      if (N.updateID = t._updateID, o.bindBuffer(t.type, N.buffer), N.byteLength >= t.data.byteLength)\n        o.bufferSubData(t.type, 0, t.data);\n      else {\n        var M = t.static ? o.STATIC_DRAW : o.DYNAMIC_DRAW;\n        N.byteLength = t.data.byteLength, o.bufferData(t.type, t.data, M);\n      }\n  }, n.prototype.dispose = function(t, e) {\n    if (!!this.managedBuffers[t.id]) {\n      delete this.managedBuffers[t.id];\n      var o = t._glBuffers[this.CONTEXT_UID], R = this.gl;\n      t.disposeRunner.remove(this), o && (e || R.deleteBuffer(o.buffer), delete t._glBuffers[this.CONTEXT_UID]);\n    }\n  }, n.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedBuffers), o = 0; o < e.length; o++)\n      this.dispose(this.managedBuffers[e[o]], t);\n  }, n.prototype.createGLBuffer = function(t) {\n    var e = this, o = e.CONTEXT_UID, R = e.gl;\n    return t._glBuffers[o] = new GLBuffer(R.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[o];\n  }, n;\n}(), Renderer = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    var o = n.call(this, RENDERER_TYPE$5.WEBGL, e) || this;\n    return e = o.options, o.gl = null, o.CONTEXT_UID = 0, o.runners = {\n      destroy: new Runner(\"destroy\"),\n      contextChange: new Runner(\"contextChange\"),\n      reset: new Runner(\"reset\"),\n      update: new Runner(\"update\"),\n      postrender: new Runner(\"postrender\"),\n      prerender: new Runner(\"prerender\"),\n      resize: new Runner(\"resize\")\n    }, o.runners.contextChange.add(o), o.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, !0), o.addSystem(MaskSystem, \"mask\").addSystem(ContextSystem, \"context\").addSystem(StateSystem, \"state\").addSystem(ShaderSystem, \"shader\").addSystem(TextureSystem, \"texture\").addSystem(BufferSystem, \"buffer\").addSystem(GeometrySystem, \"geometry\").addSystem(FramebufferSystem, \"framebuffer\").addSystem(ScissorSystem, \"scissor\").addSystem(StencilSystem, \"stencil\").addSystem(ProjectionSystem, \"projection\").addSystem(TextureGCSystem, \"textureGC\").addSystem(FilterSystem, \"filter\").addSystem(RenderTextureSystem, \"renderTexture\").addSystem(BatchSystem, \"batch\"), o.initPlugins(t.__plugins), o.multisample = void 0, e.context ? o.context.initFromContext(e.context) : o.context.initFromOptions({\n      alpha: !!o.useContextAlpha,\n      antialias: e.antialias,\n      premultipliedAlpha: o.useContextAlpha && o.useContextAlpha !== \"notMultiplied\",\n      stencil: !0,\n      preserveDrawingBuffer: e.preserveDrawingBuffer,\n      powerPreference: o.options.powerPreference\n    }), o.renderingToScreen = !0, sayHello(o.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\"), o.resize(o.options.width, o.options.height), o;\n  }\n  return t.create = function(e) {\n    if (isWebGLSupported())\n      return new t(e);\n    throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n  }, t.prototype.contextChange = function() {\n    var e = this.gl, o;\n    if (this.context.webGLVersion === 1) {\n      var R = e.getParameter(e.FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, R);\n    } else {\n      var R = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, R);\n    }\n    o >= MSAA_QUALITY$5.HIGH ? this.multisample = MSAA_QUALITY$5.HIGH : o >= MSAA_QUALITY$5.MEDIUM ? this.multisample = MSAA_QUALITY$5.MEDIUM : o >= MSAA_QUALITY$5.LOW ? this.multisample = MSAA_QUALITY$5.LOW : this.multisample = MSAA_QUALITY$5.NONE;\n  }, t.prototype.addSystem = function(e, o) {\n    var R = new e(this);\n    if (this[o])\n      throw new Error('Whoops! The name \"' + o + '\" is already in use');\n    this[o] = R;\n    for (var N in this.runners)\n      this.runners[N].add(R);\n    return this;\n  }, t.prototype.render = function(e, o) {\n    var R, N, M, D;\n    if (o && (o instanceof RenderTexture ? (deprecation$1(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\"), R = o, N = arguments[2], M = arguments[3], D = arguments[4]) : (R = o.renderTexture, N = o.clear, M = o.transform, D = o.skipUpdateTransform)), this.renderingToScreen = !R, this.runners.prerender.emit(), this.emit(\"prerender\"), this.projection.transform = M, !this.context.isLost) {\n      if (R || (this._lastObjectRendered = e), !D) {\n        var L = e.enableTempParent();\n        e.updateTransform(), e.disableTempParent(L);\n      }\n      this.renderTexture.bind(R), this.batch.currentRenderer.start(), (N !== void 0 ? N : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), R && R.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit(\"postrender\");\n    }\n  }, t.prototype.generateTexture = function(e, o, R, N) {\n    o === void 0 && (o = {});\n    var M = n.prototype.generateTexture.call(this, e, o, R, N);\n    return this.framebuffer.blit(), M;\n  }, t.prototype.resize = function(e, o) {\n    n.prototype.resize.call(this, e, o), this.runners.resize.emit(this.screen.height, this.screen.width);\n  }, t.prototype.reset = function() {\n    return this.runners.reset.emit(), this;\n  }, t.prototype.clear = function() {\n    this.renderTexture.bind(), this.renderTexture.clear();\n  }, t.prototype.destroy = function(e) {\n    this.runners.destroy.emit();\n    for (var o in this.runners)\n      this.runners[o].destroy();\n    n.prototype.destroy.call(this, e), this.gl = null;\n  }, Object.defineProperty(t.prototype, \"extract\", {\n    get: function() {\n      return deprecation$1(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\"), this.plugins.extract;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.registerPlugin = function(e, o) {\n    deprecation$1(\"6.5.0\", \"Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.\"), extensions.add({\n      name: e,\n      type: ExtensionType.RendererPlugin,\n      ref: o\n    });\n  }, t.__plugins = {}, t;\n}(AbstractRenderer);\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nfunction autoDetectRenderer(n) {\n  return Renderer.create(n);\n}\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, BatchDrawCall = function() {\n  function n() {\n    this.texArray = null, this.blend = 0, this.type = DRAW_MODES$5.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n  }\n  return n;\n}(), BatchTextureArray = function() {\n  function n() {\n    this.elements = [], this.ids = [], this.count = 0;\n  }\n  return n.prototype.clear = function() {\n    for (var t = 0; t < this.count; t++)\n      this.elements[t] = null;\n    this.count = 0;\n  }, n;\n}(), ViewableBuffer = function() {\n  function n(t) {\n    typeof t == \"number\" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  return Object.defineProperty(n.prototype, \"int8View\", {\n    get: function() {\n      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"uint8View\", {\n    get: function() {\n      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"int16View\", {\n    get: function() {\n      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"uint16View\", {\n    get: function() {\n      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"int32View\", {\n    get: function() {\n      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.view = function(t) {\n    return this[t + \"View\"];\n  }, n.prototype.destroy = function() {\n    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n  }, n.sizeOf = function(t) {\n    switch (t) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(t + \" isn't a valid view type\");\n    }\n  }, n;\n}(), AbstractBatchRenderer = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return o.shaderGenerator = null, o.geometryClass = null, o.vertexSize = null, o.state = State.for2d(), o.size = settings$1.SPRITE_BATCH_SIZE * 4, o._vertexCount = 0, o._indexCount = 0, o._bufferedElements = [], o._bufferedTextures = [], o._bufferSize = 0, o._shader = null, o._packedGeometries = [], o._packedGeometryPoolSize = 2, o._flushId = 0, o._aBuffers = {}, o._iBuffers = {}, o.MAX_TEXTURES = 1, o.renderer.on(\"prerender\", o.onPrerender, o), e.runners.contextChange.add(o), o._dcIndex = 0, o._aIndex = 0, o._iIndex = 0, o._attributeBuffer = null, o._indexBuffer = null, o._tempBoundTextures = [], o;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer.gl;\n    settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings$1.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n    for (var o = 0; o < this._packedGeometryPoolSize; o++)\n      this._packedGeometries[o] = new this.geometryClass();\n    this.initFlushBuffers();\n  }, t.prototype.initFlushBuffers = function() {\n    for (var e = t._drawCallPool, o = t._textureArrayPool, R = this.size / 4, N = Math.floor(R / this.MAX_TEXTURES) + 1; e.length < R; )\n      e.push(new BatchDrawCall());\n    for (; o.length < N; )\n      o.push(new BatchTextureArray());\n    for (var M = 0; M < this.MAX_TEXTURES; M++)\n      this._tempBoundTextures[M] = null;\n  }, t.prototype.onPrerender = function() {\n    this._flushId = 0;\n  }, t.prototype.render = function(e) {\n    !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);\n  }, t.prototype.buildTexturesAndDrawCalls = function() {\n    var e = this, o = e._bufferedTextures, R = e.MAX_TEXTURES, N = t._textureArrayPool, M = this.renderer.batch, D = this._tempBoundTextures, L = this.renderer.textureGC.count, B = ++BaseTexture._globalBatch, $ = 0, k = N[0], U = 0;\n    M.copyBoundTextures(D, R);\n    for (var z = 0; z < this._bufferSize; ++z) {\n      var X = o[z];\n      o[z] = null, X._batchEnabled !== B && (k.count >= R && (M.boundArray(k, D, B, R), this.buildDrawCalls(k, U, z), U = z, k = N[++$], ++B), X._batchEnabled = B, X.touched = L, k.elements[k.count++] = X);\n    }\n    k.count > 0 && (M.boundArray(k, D, B, R), this.buildDrawCalls(k, U, this._bufferSize), ++$, ++B);\n    for (var z = 0; z < D.length; z++)\n      D[z] = null;\n    BaseTexture._globalBatch = B;\n  }, t.prototype.buildDrawCalls = function(e, o, R) {\n    var N = this, M = N._bufferedElements, D = N._attributeBuffer, L = N._indexBuffer, B = N.vertexSize, $ = t._drawCallPool, k = this._dcIndex, U = this._aIndex, z = this._iIndex, X = $[k];\n    X.start = this._iIndex, X.texArray = e;\n    for (var V = o; V < R; ++V) {\n      var W = M[V], Y = W._texture.baseTexture, q = premultiplyBlendMode[Y.alphaMode ? 1 : 0][W.blendMode];\n      M[V] = null, o < V && X.blend !== q && (X.size = z - X.start, o = V, X = $[++k], X.texArray = e, X.start = z), this.packInterleavedGeometry(W, D, L, U, z), U += W.vertexData.length / 2 * B, z += W.indices.length, X.blend = q;\n    }\n    o < R && (X.size = z - X.start, ++k), this._dcIndex = k, this._aIndex = U, this._iIndex = z;\n  }, t.prototype.bindAndClearTexArray = function(e) {\n    for (var o = this.renderer.texture, R = 0; R < e.count; R++)\n      o.bind(e.elements[R], e.ids[R]), e.elements[R] = null;\n    e.count = 0;\n  }, t.prototype.updateGeometry = function() {\n    var e = this, o = e._packedGeometries, R = e._attributeBuffer, N = e._indexBuffer;\n    settings$1.CAN_UPLOAD_SAME_BUFFER ? (o[this._flushId]._buffer.update(R.rawBinaryData), o[this._flushId]._indexBuffer.update(N), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, o[this._flushId] = new this.geometryClass()), o[this._flushId]._buffer.update(R.rawBinaryData), o[this._flushId]._indexBuffer.update(N), this.renderer.geometry.bind(o[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }, t.prototype.drawBatches = function() {\n    for (var e = this._dcIndex, o = this.renderer, R = o.gl, N = o.state, M = t._drawCallPool, D = null, L = 0; L < e; L++) {\n      var B = M[L], $ = B.texArray, k = B.type, U = B.size, z = B.start, X = B.blend;\n      D !== $ && (D = $, this.bindAndClearTexArray($)), this.state.blendMode = X, N.set(this.state), R.drawElements(k, U, R.UNSIGNED_SHORT, z * 2);\n    }\n  }, t.prototype.flush = function() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }, t.prototype.start = function() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings$1.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }, t.prototype.stop = function() {\n    this.flush();\n  }, t.prototype.destroy = function() {\n    for (var e = 0; e < this._packedGeometryPoolSize; e++)\n      this._packedGeometries[e] && this._packedGeometries[e].destroy();\n    this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), n.prototype.destroy.call(this);\n  }, t.prototype.getAttributeBuffer = function(e) {\n    var o = nextPow2(Math.ceil(e / 8)), R = log2(o), N = o * 8;\n    this._aBuffers.length <= R && (this._iBuffers.length = R + 1);\n    var M = this._aBuffers[N];\n    return M || (this._aBuffers[N] = M = new ViewableBuffer(N * this.vertexSize * 4)), M;\n  }, t.prototype.getIndexBuffer = function(e) {\n    var o = nextPow2(Math.ceil(e / 12)), R = log2(o), N = o * 12;\n    this._iBuffers.length <= R && (this._iBuffers.length = R + 1);\n    var M = this._iBuffers[R];\n    return M || (this._iBuffers[R] = M = new Uint16Array(N)), M;\n  }, t.prototype.packInterleavedGeometry = function(e, o, R, N, M) {\n    for (var D = o.uint32View, L = o.float32View, B = N / this.vertexSize, $ = e.uvs, k = e.indices, U = e.vertexData, z = e._texture.baseTexture._batchLocation, X = Math.min(e.worldAlpha, 1), V = X < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, X) : e._tintRGB + (X * 255 << 24), W = 0; W < U.length; W += 2)\n      L[N++] = U[W], L[N++] = U[W + 1], L[N++] = $[W], L[N++] = $[W + 1], D[N++] = V, L[N++] = z;\n    for (var W = 0; W < k.length; W++)\n      R[M++] = B + k[W];\n  }, t._drawCallPool = [], t._textureArrayPool = [], t;\n}(ObjectRenderer), BatchShaderGenerator = function() {\n  function n(t, e) {\n    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf(\"%count%\") < 0)\n      throw new Error('Fragment template must contain \"%count%\".');\n    if (e.indexOf(\"%forloop%\") < 0)\n      throw new Error('Fragment template must contain \"%forloop%\".');\n  }\n  return n.prototype.generateShader = function(t) {\n    if (!this.programCache[t]) {\n      for (var e = new Int32Array(t), o = 0; o < t; o++)\n        e[o] = o;\n      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);\n      var R = this.fragTemplate;\n      R = R.replace(/%count%/gi, \"\" + t), R = R.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, R);\n    }\n    var N = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[t]\n    };\n    return new Shader(this.programCache[t], N);\n  }, n.prototype.generateSampleSrc = function(t) {\n    var e = \"\";\n    e += `\n`, e += `\n`;\n    for (var o = 0; o < t; o++)\n      o > 0 && (e += `\nelse `), o < t - 1 && (e += \"if(vTextureId < \" + o + \".5)\"), e += `\n{`, e += `\n\tcolor = texture2D(uSamplers[` + o + \"], vTextureCoord);\", e += `\n}`;\n    return e += `\n`, e += `\n`, e;\n  }, n;\n}(), BatchGeometry = function(n) {\n  __extends$q(t, n);\n  function t(e) {\n    e === void 0 && (e = !1);\n    var o = n.call(this) || this;\n    return o._buffer = new Buffer$1(null, e, !1), o._indexBuffer = new Buffer$1(null, e, !0), o.addAttribute(\"aVertexPosition\", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute(\"aTextureCoord\", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute(\"aColor\", o._buffer, 4, !0, TYPES$5.UNSIGNED_BYTE).addAttribute(\"aTextureId\", o._buffer, 1, !0, TYPES$5.FLOAT).addIndex(o._indexBuffer), o;\n  }\n  return t;\n}(Geometry), defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`, defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`, BatchPluginFactory = function() {\n  function n() {\n  }\n  return n.create = function(t) {\n    var e = Object.assign({\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      geometryClass: BatchGeometry,\n      vertexSize: 6\n    }, t), o = e.vertex, R = e.fragment, N = e.vertexSize, M = e.geometryClass;\n    return function(D) {\n      __extends$q(L, D);\n      function L(B) {\n        var $ = D.call(this, B) || this;\n        return $.shaderGenerator = new BatchShaderGenerator(o, R), $.geometryClass = M, $.vertexSize = N, $;\n      }\n      return L;\n    }(AbstractBatchRenderer);\n  }, Object.defineProperty(n, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"defaultFragmentTemplate\", {\n    get: function() {\n      return defaultFragment;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}(), BatchRenderer = BatchPluginFactory.create();\nObject.assign(BatchRenderer, {\n  extension: {\n    name: \"batch\",\n    type: ExtensionType.RendererPlugin\n  }\n});\n/*!\n * @pixi/loaders - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar SignalBinding = function() {\n  function n(t, e, o) {\n    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = o, this._next = this._prev = this._owner = null;\n  }\n  return n.prototype.detach = function() {\n    return this._owner === null ? !1 : (this._owner.detach(this), !0);\n  }, n;\n}();\nfunction _addSignalBinding(n, t) {\n  return n._head ? (n._tail._next = t, t._prev = n._tail, n._tail = t) : (n._head = t, n._tail = t), t._owner = n, t;\n}\nvar Signal = function() {\n  function n() {\n    this._head = this._tail = void 0;\n  }\n  return n.prototype.handlers = function(t) {\n    t === void 0 && (t = !1);\n    var e = this._head;\n    if (t)\n      return !!e;\n    for (var o = []; e; )\n      o.push(e), e = e._next;\n    return o;\n  }, n.prototype.has = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n    return t._owner === this;\n  }, n.prototype.dispatch = function() {\n    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)\n      e[o] = t[o];\n    var R = this._head;\n    if (!R)\n      return !1;\n    for (; R; )\n      R._once && this.detach(R), R._fn.apply(R._thisArg, e), R = R._next;\n    return !0;\n  }, n.prototype.add = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !1, e));\n  }, n.prototype.once = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !0, e));\n  }, n.prototype.detach = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);\n  }, n.prototype.detachAll = function() {\n    var t = this._head;\n    if (!t)\n      return this;\n    for (this._head = this._tail = null; t; )\n      t._owner = null, t = t._next;\n    return this;\n  }, n;\n}();\nfunction parseUri(n, t) {\n  t = t || {};\n  for (var e = {\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, o = e.parser[t.strictMode ? \"strict\" : \"loose\"].exec(n), R = {}, N = 14; N--; )\n    R[e.key[N]] = o[N] || \"\";\n  return R[e.q.name] = {}, R[e.key[12]].replace(e.q.parser, function(M, D, L) {\n    D && (R[e.q.name][D] = L);\n  }), R;\n}\nvar useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;\nfunction _noop$1() {\n}\nfunction setExtMap(n, t, e) {\n  t && t.indexOf(\".\") === 0 && (t = t.substring(1)), t && (n[t] = e);\n}\nfunction reqType(n) {\n  return n.toString().replace(\"object \", \"\");\n}\nvar LoaderResource = function() {\n  function n(t, e, o) {\n    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != \"string\" || typeof e != \"string\")\n      throw new Error(\"Both name and url are required for constructing a resource.\");\n    o = o || {}, this._flags = 0, this._setFlag(n.STATUS_FLAGS.DATA_URL, e.indexOf(\"data:\") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = o.crossOrigin === !0 ? \"anonymous\" : o.crossOrigin, this.timeout = o.timeout || 0, this.loadType = o.loadType || this._determineLoadType(), this.xhrType = o.xhrType, this.metadata = o.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = n.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();\n  }\n  return n.setExtensionLoadType = function(t, e) {\n    setExtMap(n._loadTypeMap, t, e);\n  }, n.setExtensionXhrType = function(t, e) {\n    setExtMap(n._xhrTypeMap, t, e);\n  }, Object.defineProperty(n.prototype, \"isDataUrl\", {\n    get: function() {\n      return this._hasFlag(n.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"isComplete\", {\n    get: function() {\n      return this._hasFlag(n.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"isLoading\", {\n    get: function() {\n      return this._hasFlag(n.STATUS_FLAGS.LOADING);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.complete = function() {\n    this._clearEvents(), this._finish();\n  }, n.prototype.abort = function(t) {\n    if (!this.error) {\n      if (this.error = new Error(t), this._clearEvents(), this.xhr)\n        this.xhr.abort();\n      else if (this.xdr)\n        this.xdr.abort();\n      else if (this.data)\n        if (this.data.src)\n          this.data.src = n.EMPTY_GIF;\n        else\n          for (; this.data.firstChild; )\n            this.data.removeChild(this.data.firstChild);\n      this._finish();\n    }\n  }, n.prototype.load = function(t) {\n    var e = this;\n    if (!this.isLoading) {\n      if (this.isComplete) {\n        t && setTimeout(function() {\n          return t(e);\n        }, 1);\n        return;\n      } else\n        t && this.onComplete.once(t);\n      switch (this._setFlag(n.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != \"string\") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {\n        case n.LOAD_TYPE.IMAGE:\n          this.type = n.TYPE.IMAGE, this._loadElement(\"image\");\n          break;\n        case n.LOAD_TYPE.AUDIO:\n          this.type = n.TYPE.AUDIO, this._loadSourceElement(\"audio\");\n          break;\n        case n.LOAD_TYPE.VIDEO:\n          this.type = n.TYPE.VIDEO, this._loadSourceElement(\"video\");\n          break;\n        case n.LOAD_TYPE.XHR:\n        default:\n          typeof useXdr > \"u\" && (useXdr = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();\n          break;\n      }\n    }\n  }, n.prototype._hasFlag = function(t) {\n    return (this._flags & t) !== 0;\n  }, n.prototype._setFlag = function(t, e) {\n    this._flags = e ? this._flags | t : this._flags & ~t;\n  }, n.prototype._clearEvents = function() {\n    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener(\"error\", this._boundOnError, !1), this.data.removeEventListener(\"load\", this._boundComplete, !1), this.data.removeEventListener(\"progress\", this._boundOnProgress, !1), this.data.removeEventListener(\"canplaythrough\", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener(\"error\", this._boundXhrOnError, !1), this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, !1), this.xhr.removeEventListener(\"progress\", this._boundOnProgress, !1), this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));\n  }, n.prototype._finish = function() {\n    if (this.isComplete)\n      throw new Error(\"Complete called again for an already completed resource.\");\n    this._setFlag(n.STATUS_FLAGS.COMPLETE, !0), this._setFlag(n.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);\n  }, n.prototype._loadElement = function(t) {\n    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"image\" && typeof globalThis.Image < \"u\" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, n.prototype._loadSourceElement = function(t) {\n    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"audio\" && typeof globalThis.Audio < \"u\" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {\n      this.abort(\"Unsupported element: \" + t);\n      return;\n    }\n    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)\n      if (navigator.isCocoonJS)\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      else if (Array.isArray(this.url))\n        for (var e = this.metadata.mimeType, o = 0; o < this.url.length; ++o)\n          this.data.appendChild(this._createSource(t, this.url[o], Array.isArray(e) ? e[o] : e));\n      else {\n        var e = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));\n      }\n    this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.data.addEventListener(\"canplaythrough\", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, n.prototype._loadXhr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new XMLHttpRequest();\n    this.crossOrigin === \"use-credentials\" && (t.withCredentials = !0), t.open(\"GET\", this.url, !0), t.timeout = this.timeout, this.xhrType === n.XHR_RESPONSE_TYPE.JSON || this.xhrType === n.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = n.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener(\"error\", this._boundXhrOnError, !1), t.addEventListener(\"timeout\", this._boundXhrOnTimeout, !1), t.addEventListener(\"abort\", this._boundXhrOnAbort, !1), t.addEventListener(\"progress\", this._boundOnProgress, !1), t.addEventListener(\"load\", this._boundXhrOnLoad, !1), t.send();\n  }, n.prototype._loadXdr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new globalThis.XDomainRequest();\n    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open(\"GET\", this.url, !0), setTimeout(function() {\n      return t.send();\n    }, 1);\n  }, n.prototype._createSource = function(t, e, o) {\n    o || (o = t + \"/\" + this._getExtension(e));\n    var R = document.createElement(\"source\");\n    return R.src = e, R.type = o, R;\n  }, n.prototype._onError = function(t) {\n    this.abort(\"Failed to load element using: \" + t.target.nodeName);\n  }, n.prototype._onProgress = function(t) {\n    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);\n  }, n.prototype._onTimeout = function() {\n    this.abort(\"Load timed out.\");\n  }, n.prototype._xhrOnError = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request failed. Status: \" + t.status + ', text: \"' + t.statusText + '\"');\n  }, n.prototype._xhrOnTimeout = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request timed out.\");\n  }, n.prototype._xhrOnAbort = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request was aborted by the user.\");\n  }, n.prototype._xhrOnLoad = function() {\n    var t = this.xhr, e = \"\", o = typeof t.status > \"u\" ? STATUS_OK : t.status;\n    (t.responseType === \"\" || t.responseType === \"text\" || typeof t.responseType > \"u\") && (e = t.responseText), o === STATUS_NONE && (e.length > 0 || t.responseType === n.XHR_RESPONSE_TYPE.BUFFER) ? o = STATUS_OK : o === STATUS_IE_BUG_EMPTY && (o = STATUS_EMPTY);\n    var R = o / 100 | 0;\n    if (R === STATUS_TYPE_OK)\n      if (this.xhrType === n.XHR_RESPONSE_TYPE.TEXT)\n        this.data = e, this.type = n.TYPE.TEXT;\n      else if (this.xhrType === n.XHR_RESPONSE_TYPE.JSON)\n        try {\n          this.data = JSON.parse(e), this.type = n.TYPE.JSON;\n        } catch (D) {\n          this.abort(\"Error trying to parse loaded json: \" + D);\n          return;\n        }\n      else if (this.xhrType === n.XHR_RESPONSE_TYPE.DOCUMENT)\n        try {\n          if (globalThis.DOMParser) {\n            var N = new DOMParser();\n            this.data = N.parseFromString(e, \"text/xml\");\n          } else {\n            var M = document.createElement(\"div\");\n            M.innerHTML = e, this.data = M;\n          }\n          this.type = n.TYPE.XML;\n        } catch (D) {\n          this.abort(\"Error trying to parse loaded xml: \" + D);\n          return;\n        }\n      else\n        this.data = t.response || e;\n    else {\n      this.abort(\"[\" + t.status + \"] \" + t.statusText + \": \" + t.responseURL);\n      return;\n    }\n    this.complete();\n  }, n.prototype._determineCrossOrigin = function(t, e) {\n    if (t.indexOf(\"data:\") === 0)\n      return \"\";\n    if (globalThis.origin !== globalThis.location.origin)\n      return \"anonymous\";\n    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement(\"a\")), tempAnchor.href = t;\n    var o = parseUri(tempAnchor.href, { strictMode: !0 }), R = !o.port && e.port === \"\" || o.port === e.port, N = o.protocol ? o.protocol + \":\" : \"\";\n    return o.host !== e.hostname || !R || N !== e.protocol ? \"anonymous\" : \"\";\n  }, n.prototype._determineXhrType = function() {\n    return n._xhrTypeMap[this.extension] || n.XHR_RESPONSE_TYPE.TEXT;\n  }, n.prototype._determineLoadType = function() {\n    return n._loadTypeMap[this.extension] || n.LOAD_TYPE.XHR;\n  }, n.prototype._getExtension = function(t) {\n    t === void 0 && (t = this.url);\n    var e = \"\";\n    if (this.isDataUrl) {\n      var o = t.indexOf(\"/\");\n      e = t.substring(o + 1, t.indexOf(\";\", o));\n    } else {\n      var R = t.indexOf(\"?\"), N = t.indexOf(\"#\"), M = Math.min(R > -1 ? R : t.length, N > -1 ? N : t.length);\n      t = t.substring(0, M), e = t.substring(t.lastIndexOf(\".\") + 1);\n    }\n    return e.toLowerCase();\n  }, n.prototype._getMimeFromXhrType = function(t) {\n    switch (t) {\n      case n.XHR_RESPONSE_TYPE.BUFFER:\n        return \"application/octet-binary\";\n      case n.XHR_RESPONSE_TYPE.BLOB:\n        return \"application/blob\";\n      case n.XHR_RESPONSE_TYPE.DOCUMENT:\n        return \"application/xml\";\n      case n.XHR_RESPONSE_TYPE.JSON:\n        return \"application/json\";\n      case n.XHR_RESPONSE_TYPE.DEFAULT:\n      case n.XHR_RESPONSE_TYPE.TEXT:\n      default:\n        return \"text/plain\";\n    }\n  }, n;\n}();\n(function(n) {\n  (function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.DATA_URL = 1] = \"DATA_URL\", t[t.COMPLETE = 2] = \"COMPLETE\", t[t.LOADING = 4] = \"LOADING\";\n  })(n.STATUS_FLAGS || (n.STATUS_FLAGS = {})), function(t) {\n    t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.JSON = 1] = \"JSON\", t[t.XML = 2] = \"XML\", t[t.IMAGE = 3] = \"IMAGE\", t[t.AUDIO = 4] = \"AUDIO\", t[t.VIDEO = 5] = \"VIDEO\", t[t.TEXT = 6] = \"TEXT\";\n  }(n.TYPE || (n.TYPE = {})), function(t) {\n    t[t.XHR = 1] = \"XHR\", t[t.IMAGE = 2] = \"IMAGE\", t[t.AUDIO = 3] = \"AUDIO\", t[t.VIDEO = 4] = \"VIDEO\";\n  }(n.LOAD_TYPE || (n.LOAD_TYPE = {})), function(t) {\n    t.DEFAULT = \"text\", t.BUFFER = \"arraybuffer\", t.BLOB = \"blob\", t.DOCUMENT = \"document\", t.JSON = \"json\", t.TEXT = \"text\";\n  }(n.XHR_RESPONSE_TYPE || (n.XHR_RESPONSE_TYPE = {})), n._loadTypeMap = {\n    gif: n.LOAD_TYPE.IMAGE,\n    png: n.LOAD_TYPE.IMAGE,\n    bmp: n.LOAD_TYPE.IMAGE,\n    jpg: n.LOAD_TYPE.IMAGE,\n    jpeg: n.LOAD_TYPE.IMAGE,\n    tif: n.LOAD_TYPE.IMAGE,\n    tiff: n.LOAD_TYPE.IMAGE,\n    webp: n.LOAD_TYPE.IMAGE,\n    tga: n.LOAD_TYPE.IMAGE,\n    svg: n.LOAD_TYPE.IMAGE,\n    \"svg+xml\": n.LOAD_TYPE.IMAGE,\n    mp3: n.LOAD_TYPE.AUDIO,\n    ogg: n.LOAD_TYPE.AUDIO,\n    wav: n.LOAD_TYPE.AUDIO,\n    mp4: n.LOAD_TYPE.VIDEO,\n    webm: n.LOAD_TYPE.VIDEO\n  }, n._xhrTypeMap = {\n    xhtml: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx: n.XHR_RESPONSE_TYPE.DOCUMENT,\n    gif: n.XHR_RESPONSE_TYPE.BLOB,\n    png: n.XHR_RESPONSE_TYPE.BLOB,\n    bmp: n.XHR_RESPONSE_TYPE.BLOB,\n    jpg: n.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: n.XHR_RESPONSE_TYPE.BLOB,\n    tif: n.XHR_RESPONSE_TYPE.BLOB,\n    tiff: n.XHR_RESPONSE_TYPE.BLOB,\n    webp: n.XHR_RESPONSE_TYPE.BLOB,\n    tga: n.XHR_RESPONSE_TYPE.BLOB,\n    json: n.XHR_RESPONSE_TYPE.JSON,\n    text: n.XHR_RESPONSE_TYPE.TEXT,\n    txt: n.XHR_RESPONSE_TYPE.TEXT,\n    ttf: n.XHR_RESPONSE_TYPE.BUFFER,\n    otf: n.XHR_RESPONSE_TYPE.BUFFER\n  }, n.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(LoaderResource || (LoaderResource = {}));\nfunction _noop() {\n}\nfunction onlyOnce(n) {\n  return function() {\n    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)\n      o[R] = e[R];\n    if (n === null)\n      throw new Error(\"Callback was already called.\");\n    var N = n;\n    n = null, N.apply(this, o);\n  };\n}\nvar AsyncQueueItem = function() {\n  function n(t, e) {\n    this.data = t, this.callback = e;\n  }\n  return n;\n}(), AsyncQueue = function() {\n  function n(t, e) {\n    var o = this;\n    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(R, N, M) {\n      if (M && typeof M != \"function\")\n        throw new Error(\"task callback must be a function\");\n      if (o.started = !0, R == null && o.idle()) {\n        setTimeout(function() {\n          return o.drain();\n        }, 1);\n        return;\n      }\n      var D = new AsyncQueueItem(R, typeof M == \"function\" ? M : _noop);\n      N ? o._tasks.unshift(D) : o._tasks.push(D), setTimeout(o.process, 1);\n    }, this.process = function() {\n      for (; !o.paused && o.workers < o.concurrency && o._tasks.length; ) {\n        var R = o._tasks.shift();\n        o._tasks.length === 0 && o.empty(), o.workers += 1, o.workers === o.concurrency && o.saturated(), o._worker(R.data, onlyOnce(o._next(R)));\n      }\n    }, this._worker = t, e === 0)\n      throw new Error(\"Concurrency must not be zero\");\n    this.concurrency = e, this.buffer = e / 4;\n  }\n  return n.prototype._next = function(t) {\n    var e = this;\n    return function() {\n      for (var o = arguments, R = [], N = 0; N < arguments.length; N++)\n        R[N] = o[N];\n      e.workers -= 1, t.callback.apply(t, R), R[0] != null && e.error(R[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();\n    };\n  }, n.prototype.push = function(t, e) {\n    this._insert(t, !1, e);\n  }, n.prototype.kill = function() {\n    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];\n  }, n.prototype.unshift = function(t, e) {\n    this._insert(t, !0, e);\n  }, n.prototype.length = function() {\n    return this._tasks.length;\n  }, n.prototype.running = function() {\n    return this.workers;\n  }, n.prototype.idle = function() {\n    return this._tasks.length + this.workers === 0;\n  }, n.prototype.pause = function() {\n    this.paused !== !0 && (this.paused = !0);\n  }, n.prototype.resume = function() {\n    if (this.paused !== !1) {\n      this.paused = !1;\n      for (var t = 1; t <= this.concurrency; t++)\n        this.process();\n    }\n  }, n.eachSeries = function(t, e, o, R) {\n    var N = 0, M = t.length;\n    function D(L) {\n      if (L || N === M) {\n        o && o(L);\n        return;\n      }\n      R ? setTimeout(function() {\n        e(t[N++], D);\n      }, 1) : e(t[N++], D);\n    }\n    D();\n  }, n.queue = function(t, e) {\n    return new n(t, e);\n  }, n;\n}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\\w-]+)?$/, Loader = function() {\n  function n(t, e) {\n    var o = this;\n    t === void 0 && (t = \"\"), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = \"\", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(L, B) {\n      return o._loadResource(L, B);\n    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(L, B) {\n      return o._loadResource(L, B);\n    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();\n    for (var R = 0; R < n._plugins.length; ++R) {\n      var N = n._plugins[R], M = N.pre, D = N.use;\n      M && this.pre(M), D && this.use(D);\n    }\n    this._protected = !1;\n  }\n  return n.prototype._add = function(t, e, o, R) {\n    if (this.loading && (!o || !o.parentResource))\n      throw new Error(\"Cannot add resources while the loader is running.\");\n    if (this.resources[t])\n      throw new Error('Resource named \"' + t + '\" already exists.');\n    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, o), typeof R == \"function\" && this.resources[t].onAfterMiddleware.once(R), this.loading) {\n      for (var N = o.parentResource, M = [], D = 0; D < N.children.length; ++D)\n        N.children[D].isComplete || M.push(N.children[D]);\n      var L = N.progressChunk * (M.length + 1), B = L / (M.length + 2);\n      N.children.push(this.resources[t]), N.progressChunk = B;\n      for (var D = 0; D < M.length; ++D)\n        M[D].progressChunk = B;\n      this.resources[t].progressChunk = B;\n    }\n    return this._queue.push(this.resources[t]), this;\n  }, n.prototype.pre = function(t) {\n    return this._beforeMiddleware.push(t), this;\n  }, n.prototype.use = function(t) {\n    return this._afterMiddleware.push(t), this;\n  }, n.prototype.reset = function() {\n    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();\n    for (var t in this.resources) {\n      var e = this.resources[t];\n      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort(\"loader reset\");\n    }\n    return this.resources = {}, this;\n  }, n.prototype.load = function(t) {\n    if (deprecation$1(\"6.5.0\", \"@pixi/loaders is being replaced with @pixi/assets in the next major release.\"), typeof t == \"function\" && this.onComplete.once(t), this.loading)\n      return this;\n    if (this._queue.idle())\n      this._onStart(), this._onComplete();\n    else {\n      for (var e = this._queue._tasks.length, o = MAX_PROGRESS / e, R = 0; R < this._queue._tasks.length; ++R)\n        this._queue._tasks[R].data.progressChunk = o;\n      this._onStart(), this._queue.resume();\n    }\n    return this;\n  }, Object.defineProperty(n.prototype, \"concurrency\", {\n    get: function() {\n      return this._queue.concurrency;\n    },\n    set: function(t) {\n      this._queue.concurrency = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype._prepareUrl = function(t) {\n    var e = parseUri(t, { strictMode: !0 }), o;\n    if (e.protocol || !e.path || t.indexOf(\"//\") === 0 ? o = t : this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && t.charAt(0) !== \"/\" ? o = this.baseUrl + \"/\" + t : o = this.baseUrl + t, this.defaultQueryString) {\n      var R = rgxExtractUrlHash.exec(o)[0];\n      o = o.slice(0, o.length - R.length), o.indexOf(\"?\") !== -1 ? o += \"&\" + this.defaultQueryString : o += \"?\" + this.defaultQueryString, o += R;\n    }\n    return o;\n  }, n.prototype._loadResource = function(t, e) {\n    var o = this;\n    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(R, N) {\n      R.call(o, t, function() {\n        N(t.isComplete ? {} : null);\n      });\n    }, function() {\n      t.isComplete ? o._onLoad(t) : (t._onLoadBinding = t.onComplete.once(o._onLoad, o), t.load());\n    }, !0);\n  }, n.prototype._onStart = function() {\n    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);\n  }, n.prototype._onComplete = function() {\n    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);\n  }, n.prototype._onLoad = function(t) {\n    var e = this;\n    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(o, R) {\n      o.call(e, t, R);\n    }, function() {\n      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();\n    }, !0);\n  }, n.prototype.destroy = function() {\n    this._protected || this.reset();\n  }, Object.defineProperty(n, \"shared\", {\n    get: function() {\n      var t = n._shared;\n      return t || (t = new n(), t._protected = !0, n._shared = t), t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.registerPlugin = function(t) {\n    return deprecation$1(\"6.5.0\", \"Loader.registerPlugin() is deprecated, use extensions.add() instead.\"), extensions.add({\n      type: ExtensionType.Loader,\n      ref: t\n    }), n;\n  }, n._plugins = [], n;\n}();\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\nLoader.prototype.add = function(t, e, o, R) {\n  if (Array.isArray(t)) {\n    for (var N = 0; N < t.length; ++N)\n      this.add(t[N]);\n    return this;\n  }\n  if (typeof t == \"object\" && (o = t, R = e || o.callback || o.onComplete, e = o.url, t = o.name || o.key || o.url), typeof e != \"string\" && (R = o, o = e, e = t), typeof e != \"string\")\n    throw new Error(\"No url passed to add resource to loader.\");\n  return typeof o == \"function\" && (R = o, o = null), this._add(t, e, o, R);\n};\nvar AppLoaderPlugin = function() {\n  function n() {\n  }\n  return n.init = function(t) {\n    t = Object.assign({\n      sharedLoader: !1\n    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();\n  }, n.destroy = function() {\n    this.loader && (this.loader.destroy(), this.loader = null);\n  }, n.extension = ExtensionType.Application, n;\n}(), TextureLoader = function() {\n  function n() {\n  }\n  return n.add = function() {\n    LoaderResource.setExtensionLoadType(\"svg\", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType(\"svg\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, n.use = function(t, e) {\n    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === \"svg\")) {\n      var o = t.data, R = t.url, N = t.name, M = t.metadata;\n      Texture.fromLoader(o, R, N, M).then(function(D) {\n        t.texture = D, e();\n      }).catch(e);\n    } else\n      e();\n  }, n.extension = ExtensionType.Loader, n;\n}(), _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction encodeBinary(n) {\n  for (var t = \"\", e = 0; e < n.length; ) {\n    for (var o = [0, 0, 0], R = [0, 0, 0, 0], N = 0; N < o.length; ++N)\n      e < n.length ? o[N] = n.charCodeAt(e++) & 255 : o[N] = 0;\n    R[0] = o[0] >> 2, R[1] = (o[0] & 3) << 4 | o[1] >> 4, R[2] = (o[1] & 15) << 2 | o[2] >> 6, R[3] = o[2] & 63;\n    var M = e - (n.length - 1);\n    switch (M) {\n      case 2:\n        R[3] = 64, R[2] = 64;\n        break;\n      case 1:\n        R[3] = 64;\n        break;\n    }\n    for (var N = 0; N < R.length; ++N)\n      t += _keyStr.charAt(R[N]);\n  }\n  return t;\n}\nfunction parsing(n, t) {\n  if (!n.data) {\n    t();\n    return;\n  }\n  if (n.xhr && n.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof n.data == \"string\") {\n      var e = n.xhr.getResponseHeader(\"content-type\");\n      if (e && e.indexOf(\"image\") === 0) {\n        n.data = new Image(), n.data.src = \"data:\" + e + \";base64,\" + encodeBinary(n.xhr.responseText), n.type = LoaderResource.TYPE.IMAGE, n.data.onload = function() {\n          n.data.onload = null, t();\n        };\n        return;\n      }\n    } else if (n.data.type.indexOf(\"image\") === 0) {\n      var o = globalThis.URL || globalThis.webkitURL, R = o.createObjectURL(n.data);\n      n.blob = n.data, n.data = new Image(), n.data.src = R, n.type = LoaderResource.TYPE.IMAGE, n.data.onload = function() {\n        o.revokeObjectURL(R), n.data.onload = null, t();\n      };\n      return;\n    }\n  }\n  t();\n}\nvar ParsingLoader = function() {\n  function n() {\n  }\n  return n.extension = ExtensionType.Loader, n.use = parsing, n;\n}();\nextensions.add(TextureLoader, ParsingLoader);\n/*!\n * @pixi/sound - v4.2.0\n * https://github.com/pixijs/pixi-sound\n * Compiled Wed, 05 Jan 2022 14:56:00 UTC\n *\n * @pixi/sound is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar r;\nfunction s() {\n  return r;\n}\nvar u = function(n, t) {\n  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      Object.prototype.hasOwnProperty.call(o, R) && (e[R] = o[R]);\n  })(n, t);\n};\nfunction a(n, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  function e() {\n    this.constructor = n;\n  }\n  u(n, t), n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar c = function() {\n  return (c = Object.assign || function(n) {\n    for (var t, e = 1, o = arguments.length; e < o; e++)\n      for (var R in t = arguments[e])\n        Object.prototype.hasOwnProperty.call(t, R) && (n[R] = t[R]);\n    return n;\n  }).apply(this, arguments);\n}, l = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], p$1 = {};\nfunction h(n) {\n  var t = c({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, n || {}), e = document.createElement(\"audio\"), o = {}, R = /^no$/;\n  l.forEach(function(N) {\n    var M = e.canPlayType(\"audio/\".concat(N)).replace(R, \"\"), D = t[N] ? e.canPlayType(t[N]).replace(R, \"\") : \"\";\n    o[N] = !!M || !!D;\n  }), Object.assign(p$1, o);\n}\nh();\nvar f = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction d(n) {\n  var t = f, e = typeof n == \"string\" ? n : n.url;\n  if (!t.test(e))\n    return e;\n  for (var o = t.exec(e), R = o[2].split(\",\"), N = R[R.length - 1], M = 0, D = R.length; M < D; M++) {\n    var L = R[M];\n    if (p$1[L]) {\n      N = L;\n      break;\n    }\n  }\n  var B = e.replace(o[1], N);\n  if (typeof n != \"string\") {\n    var $ = n;\n    $.extension = N, $.url = B;\n  }\n  return B;\n}\nvar _ = function() {\n  function n() {\n  }\n  return n.add = function() {\n    n.setLegacy(s().useLegacy);\n  }, n.setLegacy = function(t) {\n    var e = l;\n    t ? e.forEach(function(o) {\n      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.AUDIO);\n    }) : e.forEach(function(o) {\n      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.XHR);\n    });\n  }, n.pre = function(t, e) {\n    d(t), e();\n  }, n.use = function(t, e) {\n    t.data && l.indexOf(t.extension) > -1 ? t.sound = s().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();\n  }, n;\n}(), y = 0, m = function(n) {\n  function t(e) {\n    var o = n.call(this) || this;\n    return o.id = y++, o.init(e), o;\n  }\n  return a(t, n), t.prototype.set = function(e, o) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = o;\n        break;\n      case \"volume\":\n        this.volume = o;\n        break;\n      case \"paused\":\n        this.paused = o;\n        break;\n      case \"loop\":\n        this.loop = o;\n        break;\n      case \"muted\":\n        this.muted = o;\n    }\n    return this;\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {\n    this._playing = !0;\n  }, t.prototype._onPause = function() {\n    this._playing = !1;\n  }, t.prototype.init = function(e) {\n    this._playing = !1, this._duration = e.source.duration;\n    var o = this._source = e.source.cloneNode(!1);\n    o.src = e.parent.url, o.onplay = this._onPlay.bind(this), o.onpause = this._onPause.bind(this), e.context.on(\"refresh\", this.refresh, this), e.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = e;\n  }, t.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, t.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    var e = this._media.context, o = this._media.parent;\n    this._source.loop = this._loop || o.loop;\n    var R = e.volume * (e.muted ? 0 : 1), N = o.volume * (o.muted ? 0 : 1), M = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = M * R * N, this._source.playbackRate = this._speed * e.speed * o.speed;\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, o = this._media.parent, R = this._paused || o.paused || e.paused;\n    R !== this._pausedReal && (this._pausedReal = R, R ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", R));\n  }, t.prototype.play = function(e) {\n    var o = this, R = e.start, N = e.end, M = e.speed, D = e.loop, L = e.volume, B = e.muted;\n    this._speed = M, this._volume = L, this._loop = !!D, this._muted = B, this.refresh(), this.loop && N !== null && (this.loop = !1), this._start = R, this._end = N || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      o._source && (o._source.currentTime = R, o._source.onloadedmetadata = null, o.emit(\"progress\", R, o._duration), Ticker.shared.add(o._onUpdate, o));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, t.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, t.prototype._onComplete = function() {\n    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t.prototype.destroy = function() {\n    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var e = this._source;\n    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, t.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, t.PADDING = 0.1, t;\n}(EventEmitter$5), g = function(n) {\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  return a(t, n), t.prototype.init = function(e) {\n    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);\n  }, t.prototype.create = function() {\n    return new m(this);\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(t.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {\n    var o = this._source, R = this.parent;\n    if (o.readyState !== 4)\n      if (R.url) {\n        o.src = R.url;\n        var N = function() {\n          L(), R.isLoaded = !0;\n          var $ = R.autoPlayStart();\n          e && e(null, R, $);\n        }, M = function() {\n          L(), e && e(new Error(\"Sound loading has been aborted\"));\n        }, D = function() {\n          L();\n          var $ = \"Failed to load audio element (code: \".concat(o.error.code, \")\");\n          e && e(new Error($));\n        }, L = function() {\n          o.removeEventListener(\"canplaythrough\", N), o.removeEventListener(\"load\", N), o.removeEventListener(\"abort\", M), o.removeEventListener(\"error\", D);\n        };\n        o.addEventListener(\"canplaythrough\", N, !1), o.addEventListener(\"load\", N, !1), o.addEventListener(\"abort\", M, !1), o.addEventListener(\"error\", D, !1), o.load();\n      } else\n        e(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      R.isLoaded = !0;\n      var B = R.autoPlayStart();\n      e && setTimeout(function() {\n        e(null, R, B);\n      }, 0);\n    }\n  }, t;\n}(EventEmitter$5), b = function() {\n  function n(t, e) {\n    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return n.prototype.play = function(t) {\n    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, n.prototype.destroy = function() {\n    this.parent = null;\n  }, n;\n}(), v = function() {\n  function n() {\n  }\n  return n.setParamValue = function(t, e) {\n    if (t.setValueAtTime) {\n      var o = s().context;\n      t.setValueAtTime(e, o.audioContext.currentTime);\n    } else\n      t.value = e;\n    return e;\n  }, n;\n}(), P = 0, x$1 = function(n) {\n  function t(e) {\n    var o = n.call(this) || this;\n    return o.id = P++, o._media = null, o._paused = !1, o._muted = !1, o._elapsed = 0, o.init(e), o;\n  }\n  return a(t, n), t.prototype.set = function(e, o) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = o;\n        break;\n      case \"volume\":\n        this.volume = o;\n        break;\n      case \"muted\":\n        this.muted = o;\n        break;\n      case \"loop\":\n        this.loop = o;\n        break;\n      case \"paused\":\n        this.paused = o;\n    }\n    return this;\n  }, t.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh(), this._update(!0);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(e) {\n    var o;\n    this._filters && ((o = this._filters) === null || o === void 0 || o.filter(function(R) {\n      return R;\n    }).forEach(function(R) {\n      return R.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    if (this._source) {\n      var e = this._media.context, o = this._media.parent;\n      this._source.loop = this._loop || o.loop;\n      var R = e.volume * (e.muted ? 0 : 1), N = o.volume * (o.muted ? 0 : 1), M = this._volume * (this._muted ? 0 : 1);\n      v.setParamValue(this._gain.gain, M * N * R), v.setParamValue(this._source.playbackRate, this._speed * o.speed * e.speed), this.applyFilters();\n    }\n  }, t.prototype.applyFilters = function() {\n    var e;\n    if (!((e = this._filters) === null || e === void 0) && e.length) {\n      this._source.disconnect();\n      var o = this._source;\n      this._filters.forEach(function(R) {\n        o.connect(R.destination), o = R;\n      }), o.connect(this._gain);\n    }\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, o = this._media.parent, R = this._paused || o.paused || e.paused;\n    R !== this._pausedReal && (this._pausedReal = R, R ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", R));\n  }, t.prototype.play = function(e) {\n    var o = e.start, R = e.end, N = e.speed, M = e.loop, D = e.volume, L = e.muted, B = e.filters;\n    this._paused = !1;\n    var $ = this._media.nodes.cloneBufferSource(), k = $.source, U = $.gain;\n    this._source = k, this._gain = U, this._speed = N, this._volume = D, this._loop = !!M, this._muted = L, this._filters = B, this.refresh();\n    var z = this._source.buffer.duration;\n    this._duration = z, this._end = R, this._lastUpdate = this._now(), this._elapsed = o, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = R, this._source.loopStart = o, this._source.start(0, o)) : R ? this._source.start(0, o, R - o) : this._source.start(0, o), this.emit(\"start\"), this._update(!0), this.enableTicker(!0);\n  }, t.prototype.enableTicker = function(e) {\n    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    var e;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(o) {\n      return o.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;\n  }, t.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, t.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, t.prototype._updateListener = function() {\n    this._update();\n  }, t.prototype._update = function(e) {\n    if (e === void 0 && (e = !1), this._source) {\n      var o = this._now(), R = o - this._lastUpdate;\n      if (R > 0 || e) {\n        var N = this._source.playbackRate.value;\n        this._elapsed += R * N, this._lastUpdate = o;\n        var M = this._duration, D = void 0;\n        if (this._source.loopStart) {\n          var L = this._source.loopEnd - this._source.loopStart;\n          D = (this._source.loopStart + this._elapsed % L) / M;\n        } else\n          D = this._elapsed % M / M;\n        this._progress = D, this.emit(\"progress\", this._progress, M);\n      }\n    }\n  }, t.prototype.init = function(e) {\n    this._media = e, e.context.events.on(\"refresh\", this.refresh, this), e.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, t.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n      this._source = null;\n    }\n  }, t.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t;\n}(EventEmitter$5), O = function() {\n  function n(t, e) {\n    this._output = e, this._input = t;\n  }\n  return Object.defineProperty(n.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(R) {\n      R && R.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t && t.length) {\n      this._filters = t.slice(0), this._input.disconnect();\n      var o = null;\n      t.forEach(function(R) {\n        o === null ? e._input.connect(R.destination) : o.connect(R.destination), o = R;\n      }), o.connect(this._output);\n    }\n  }, enumerable: !1, configurable: !0 }), n.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, n;\n}(), j = function(n) {\n  function t(e) {\n    var o = this, R = e.audioContext, N = R.createBufferSource(), M = R.createGain(), D = R.createAnalyser();\n    return N.connect(D), D.connect(M), M.connect(e.destination), (o = n.call(this, D, M) || this).context = e, o.bufferSource = N, o.gain = M, o.analyser = D, o;\n  }\n  return a(t, n), Object.defineProperty(t.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    n.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, t.prototype.cloneBufferSource = function() {\n    var e = this.bufferSource, o = this.context.audioContext.createBufferSource();\n    o.buffer = e.buffer, v.setParamValue(o.playbackRate, e.playbackRate.value), o.loop = e.loop;\n    var R = this.context.audioContext.createGain();\n    return o.connect(R), R.connect(this.destination), { source: o, gain: R };\n  }, Object.defineProperty(t.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;\n}(O), w = function() {\n  function n() {\n  }\n  return n.prototype.init = function(t) {\n    this.parent = t, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;\n  }, n.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch {\n    }\n    this._source = null, this.source = null;\n  }, n.prototype.create = function() {\n    return new x$1(this);\n  }, Object.defineProperty(n.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t) {\n    this._nodes.filters = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t) {\n    this._source.buffer = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: !1, configurable: !0 }), n.prototype.load = function(t) {\n    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error(\"sound.url or sound.source must be set\"));\n  }, n.prototype._loadUrl = function(t) {\n    var e = this, o = new XMLHttpRequest(), R = this.parent.url;\n    o.open(\"GET\", R, !0), o.responseType = \"arraybuffer\", o.onload = function() {\n      e.source = o.response, e._decode(o.response, t);\n    }, o.send();\n  }, n.prototype._decode = function(t, e) {\n    var o = this, R = function(N, M) {\n      if (N)\n        e && e(N);\n      else {\n        o.parent.isLoaded = !0, o.buffer = M;\n        var D = o.parent.autoPlayStart();\n        e && e(null, o.parent, D);\n      }\n    };\n    t instanceof AudioBuffer ? R(null, t) : this.parent.context.decode(t, R);\n  }, n;\n}(), A = function() {\n  function n(t, e) {\n    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var o = e.complete;\n    this._autoPlayOptions = o ? { complete: o } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return n.from = function(t) {\n    var e = {};\n    return typeof t == \"string\" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = c({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = d(e.url)), Object.freeze(e), new n(s().useLegacy ? new g() : new w(), e);\n  }, Object.defineProperty(n.prototype, \"context\", { get: function() {\n    return s().context;\n  }, enumerable: !1, configurable: !0 }), n.prototype.pause = function() {\n    return this.isPlaying = !1, this.paused = !0, this;\n  }, n.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;\n  }, Object.defineProperty(n.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t) {\n    this._paused = t, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t) {\n    this._speed = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t) {\n    this.media.filters = t;\n  }, enumerable: !1, configurable: !0 }), n.prototype.addSprites = function(t, e) {\n    if (typeof t == \"object\") {\n      var o = {};\n      for (var R in t)\n        o[R] = this.addSprites(R, t[R]);\n      return o;\n    }\n    var N = new b(this, e);\n    return this._sprites[t] = N, N;\n  }, n.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, n.prototype.removeSprites = function(t) {\n    if (t) {\n      var e = this._sprites[t];\n      e !== void 0 && (e.destroy(), delete this._sprites[t]);\n    } else\n      for (var o in this._sprites)\n        this.removeSprites(o);\n    return this;\n  }, Object.defineProperty(n.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: !1, configurable: !0 }), n.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = !1, this._autoPlayOptions = null, this;\n    this.isPlaying = !1;\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._instances[t].stop();\n    return this;\n  }, n.prototype.play = function(t, e) {\n    var o, R = this;\n    if (typeof t == \"string\" ? o = { sprite: M = t, loop: this.loop, complete: e } : typeof t == \"function\" ? (o = {}).complete = t : o = t, (o = c({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, o || {})).sprite) {\n      var N = o.sprite, M = this._sprites[N];\n      o.start = M.start + (o.start || 0), o.end = M.end, o.speed = M.speed || 1, o.loop = M.loop || o.loop, delete o.sprite;\n    }\n    if (o.offset && (o.start = o.offset), !this.isLoaded)\n      return new Promise(function(L, B) {\n        R.autoPlay = !0, R._autoPlayOptions = o, R._preload(function($, k, U) {\n          $ ? B($) : (o.loaded && o.loaded($, k, U), L(U));\n        });\n      });\n    (this.singleInstance || o.singleInstance) && this._removeInstances();\n    var D = this._createInstance();\n    return this._instances.push(D), this.isPlaying = !0, D.once(\"end\", function() {\n      o.complete && o.complete(R), R._onComplete(D);\n    }), D.once(\"stop\", function() {\n      R._onComplete(D);\n    }), D.play(o), D;\n  }, n.prototype.refresh = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refresh();\n  }, n.prototype.refreshPaused = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(n.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t) {\n    this._volume = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t) {\n    this._muted = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t) {\n    this._loop = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), n.prototype._preload = function(t) {\n    this.media.load(t);\n  }, Object.defineProperty(n.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: !1, configurable: !0 }), n.prototype.autoPlayStart = function() {\n    var t;\n    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;\n  }, n.prototype._removeInstances = function() {\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._poolInstance(this._instances[t]);\n    this._instances.length = 0;\n  }, n.prototype._onComplete = function(t) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t);\n  }, n.prototype._createInstance = function() {\n    if (n._pool.length > 0) {\n      var t = n._pool.pop();\n      return t.init(this.media), t;\n    }\n    return this.media.create();\n  }, n.prototype._poolInstance = function(t) {\n    t.destroy(), n._pool.indexOf(t) < 0 && n._pool.push(t);\n  }, n._pool = [], n;\n}(), F = function(n) {\n  function t() {\n    var e = n !== null && n.apply(this, arguments) || this;\n    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;\n  }\n  return a(t, n), t.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, t.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, t;\n}(EventEmitter$5), C = function(n) {\n  function t() {\n    var e = this, o = window, R = new t.AudioContext(), N = R.createDynamicsCompressor(), M = R.createAnalyser();\n    return M.connect(N), N.connect(R.destination), (e = n.call(this, M, N) || this)._ctx = R, e._offlineCtx = new t.OfflineAudioContext(1, 2, o.OfflineAudioContext ? R.sampleRate : 44100), e._unlocked = !1, e.compressor = N, e.analyser = M, e.events = new EventEmitter$5(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, R.state !== \"running\" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener(\"mousedown\", e._unlock, !0), document.addEventListener(\"touchstart\", e._unlock, !0), document.addEventListener(\"touchend\", e._unlock, !0)), e;\n  }\n  return a(t, n), t.prototype._unlock = function() {\n    this._unlocked || (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, !0), document.removeEventListener(\"touchend\", this._unlock, !0), document.removeEventListener(\"touchstart\", this._unlock, !0), this._unlocked = !0));\n  }, t.prototype.playEmptySound = function() {\n    var e = this._ctx.createBufferSource();\n    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === \"suspended\" && e.context.resume();\n  }, Object.defineProperty(t, \"AudioContext\", { get: function() {\n    var e = window;\n    return e.AudioContext || e.webkitAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, \"OfflineAudioContext\", { get: function() {\n    var e = window;\n    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    n.prototype.destroy.call(this);\n    var e = this._ctx;\n    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    e && this._ctx.state === \"running\" ? this._ctx.suspend() : e || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = e;\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, t.prototype.decode = function(e, o) {\n    var R = function(M) {\n      o(new Error(M.message || \"Unable to decode file\"));\n    }, N = this._offlineCtx.decodeAudioData(e, function(M) {\n      o(null, M);\n    }, R);\n    N && N.catch(R);\n  }, t;\n}(O), E = function() {\n  function n() {\n    this.init();\n  }\n  return n.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(n.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t) {\n    this.useLegacy || (this._context.filters = t);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"supported\", { get: function() {\n    return C.AudioContext !== null;\n  }, enumerable: !1, configurable: !0 }), n.prototype.add = function(t, e) {\n    if (typeof t == \"object\") {\n      var o = {};\n      for (var R in t) {\n        var N = this._getOptions(t[R], e);\n        o[R] = this.add(R, N);\n      }\n      return o;\n    }\n    if (e instanceof A)\n      return this._sounds[t] = e, e;\n    var M = this._getOptions(e), D = A.from(M);\n    return this._sounds[t] = D, D;\n  }, n.prototype._getOptions = function(t, e) {\n    var o;\n    return o = typeof t == \"string\" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, o = c(c({}, o), e || {});\n  }, Object.defineProperty(n.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t) {\n    _.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: !1, configurable: !0 }), n.prototype.remove = function(t) {\n    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;\n  }, Object.defineProperty(n.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t) {\n    this._context.volume = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t) {\n    this._context.speed = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), n.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, n.prototype.pauseAll = function() {\n    return this._context.paused = !0, this._context.refreshPaused(), this;\n  }, n.prototype.resumeAll = function() {\n    return this._context.paused = !1, this._context.refreshPaused(), this;\n  }, n.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, n.prototype.muteAll = function() {\n    return this._context.muted = !0, this._context.refresh(), this;\n  }, n.prototype.unmuteAll = function() {\n    return this._context.muted = !1, this._context.refresh(), this;\n  }, n.prototype.removeAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].destroy(), delete this._sounds[t];\n    return this;\n  }, n.prototype.stopAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].stop();\n    return this;\n  }, n.prototype.exists = function(t, e) {\n    return !!this._sounds[t];\n  }, n.prototype.find = function(t) {\n    return this.exists(t, !0), this._sounds[t];\n  }, n.prototype.play = function(t, e) {\n    return this.find(t).play(e);\n  }, n.prototype.stop = function(t) {\n    return this.find(t).stop();\n  }, n.prototype.pause = function(t) {\n    return this.find(t).pause();\n  }, n.prototype.resume = function(t) {\n    return this.find(t).resume();\n  }, n.prototype.volume = function(t, e) {\n    var o = this.find(t);\n    return e !== void 0 && (o.volume = e), o.volume;\n  }, n.prototype.speed = function(t, e) {\n    var o = this.find(t);\n    return e !== void 0 && (o.speed = e), o.speed;\n  }, n.prototype.duration = function(t) {\n    return this.find(t).duration;\n  }, n.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, n;\n}(), S = function() {\n  function n(t, e) {\n    this.init(t, e);\n  }\n  return n.prototype.init = function(t, e) {\n    this.destination = t, this.source = e || t;\n  }, n.prototype.connect = function(t) {\n    this.source.connect(t);\n  }, n.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, n.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, n;\n}();\n(function(n) {\n  function t(e, o, R, N, M, D, L, B, $, k) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), k === void 0 && (k = 0);\n    var U = this;\n    if (!s().useLegacy) {\n      var z = [{ f: t.F32, type: \"lowshelf\", gain: e }, { f: t.F64, type: \"peaking\", gain: o }, { f: t.F125, type: \"peaking\", gain: R }, { f: t.F250, type: \"peaking\", gain: N }, { f: t.F500, type: \"peaking\", gain: M }, { f: t.F1K, type: \"peaking\", gain: D }, { f: t.F2K, type: \"peaking\", gain: L }, { f: t.F4K, type: \"peaking\", gain: B }, { f: t.F8K, type: \"peaking\", gain: $ }, { f: t.F16K, type: \"highshelf\", gain: k }].map(function(W) {\n        var Y = s().context.audioContext.createBiquadFilter();\n        return Y.type = W.type, v.setParamValue(Y.Q, 1), Y.frequency.value = W.f, v.setParamValue(Y.gain, W.gain), Y;\n      });\n      (U = n.call(this, z[0], z[z.length - 1]) || this).bands = z, U.bandsMap = {};\n      for (var X = 0; X < U.bands.length; X++) {\n        var V = U.bands[X];\n        X > 0 && U.bands[X - 1].connect(V), U.bandsMap[V.frequency.value] = V;\n      }\n      return U;\n    }\n    U = n.call(this, null) || this;\n  }\n  return a(t, n), t.prototype.setGain = function(e, o) {\n    if (o === void 0 && (o = 0), !this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    v.setParamValue(this.bandsMap[e].gain, o);\n  }, t.prototype.getGain = function(e) {\n    if (!this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    return this.bandsMap[e].gain.value;\n  }, Object.defineProperty(t.prototype, \"f32\", { get: function() {\n    return this.getGain(t.F32);\n  }, set: function(e) {\n    this.setGain(t.F32, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f64\", { get: function() {\n    return this.getGain(t.F64);\n  }, set: function(e) {\n    this.setGain(t.F64, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f125\", { get: function() {\n    return this.getGain(t.F125);\n  }, set: function(e) {\n    this.setGain(t.F125, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f250\", { get: function() {\n    return this.getGain(t.F250);\n  }, set: function(e) {\n    this.setGain(t.F250, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f500\", { get: function() {\n    return this.getGain(t.F500);\n  }, set: function(e) {\n    this.setGain(t.F500, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f1k\", { get: function() {\n    return this.getGain(t.F1K);\n  }, set: function(e) {\n    this.setGain(t.F1K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f2k\", { get: function() {\n    return this.getGain(t.F2K);\n  }, set: function(e) {\n    this.setGain(t.F2K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f4k\", { get: function() {\n    return this.getGain(t.F4K);\n  }, set: function(e) {\n    this.setGain(t.F4K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f8k\", { get: function() {\n    return this.getGain(t.F8K);\n  }, set: function(e) {\n    this.setGain(t.F8K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f16k\", { get: function() {\n    return this.getGain(t.F16K);\n  }, set: function(e) {\n    this.setGain(t.F16K, e);\n  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {\n    this.bands.forEach(function(e) {\n      v.setParamValue(e.gain, 0);\n    });\n  }, t.prototype.destroy = function() {\n    this.bands.forEach(function(e) {\n      e.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;\n})(S), function(n) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var o = this;\n    if (!s().useLegacy) {\n      var R = s().context.audioContext.createWaveShaper();\n      return (o = n.call(this, R) || this)._distortion = R, o.amount = e, o;\n    }\n    o = n.call(this, null) || this;\n  }\n  return a(t, n), Object.defineProperty(t.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(e) {\n    this._amount = e;\n    for (var o, R = 1e3 * e, N = 44100, M = new Float32Array(N), D = Math.PI / 180, L = 0; L < N; ++L)\n      o = 2 * L / N - 1, M[L] = (3 + R) * o * 20 * D / (Math.PI + R * Math.abs(o));\n    this._distortion.curve = M, this._distortion.oversample = \"4x\";\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._distortion = null, n.prototype.destroy.call(this);\n  }, t;\n}(S), function(n) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var o = this;\n    if (!s().useLegacy) {\n      var R, N, M, D = s().context.audioContext;\n      return D.createStereoPanner ? M = R = D.createStereoPanner() : ((N = D.createPanner()).panningModel = \"equalpower\", M = N), (o = n.call(this, M) || this)._stereo = R, o._panner = N, o.pan = e, o;\n    }\n    o = n.call(this, null) || this;\n  }\n  return a(t, n), Object.defineProperty(t.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(e) {\n    this._pan = e, this._stereo ? v.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    n.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, t;\n}(S), function(n) {\n  function t(e, o, R) {\n    e === void 0 && (e = 3), o === void 0 && (o = 2), R === void 0 && (R = !1);\n    var N = this;\n    if (!s().useLegacy)\n      return (N = n.call(this, null) || this)._seconds = N._clamp(e, 1, 50), N._decay = N._clamp(o, 0, 100), N._reverse = R, N._rebuild(), N;\n    N = n.call(this, null) || this;\n  }\n  return a(t, n), t.prototype._clamp = function(e, o, R) {\n    return Math.min(R, Math.max(o, e));\n  }, Object.defineProperty(t.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(e) {\n    this._seconds = this._clamp(e, 1, 50), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(e) {\n    this._decay = this._clamp(e, 0, 100), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(e) {\n    this._reverse = e, this._rebuild();\n  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {\n    for (var e, o = s().context.audioContext, R = o.sampleRate, N = R * this._seconds, M = o.createBuffer(2, N, R), D = M.getChannelData(0), L = M.getChannelData(1), B = 0; B < N; B++)\n      e = this._reverse ? N - B : B, D[B] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay), L[B] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay);\n    var $ = s().context.audioContext.createConvolver();\n    $.buffer = M, this.init($);\n  }, t;\n}(S), function(n) {\n  function t() {\n    var e = this;\n    if (!s().useLegacy) {\n      var o = s().context.audioContext, R = o.createChannelSplitter(), N = o.createChannelMerger();\n      return N.connect(R), (e = n.call(this, N, R) || this)._merger = N, e;\n    }\n    e = n.call(this, null) || this;\n  }\n  return a(t, n), t.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, n.prototype.destroy.call(this);\n  }, t;\n}(S), function(n) {\n  function t() {\n    var e = this;\n    if (!s().useLegacy) {\n      var o = s().context.audioContext, R = o.createMediaStreamDestination(), N = o.createMediaStreamSource(R.stream);\n      return (e = n.call(this, R, N) || this)._stream = R.stream, e;\n    }\n    e = n.call(this, null) || this;\n  }\n  return a(t, n), Object.defineProperty(t.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._stream = null, n.prototype.destroy.call(this);\n  }, t;\n}(S), function(n) {\n  function t() {\n    if (!s().useLegacy) {\n      var e = s().context.audioContext, o = e.createBiquadFilter(), R = e.createBiquadFilter(), N = e.createBiquadFilter(), M = e.createBiquadFilter();\n      return o.type = \"lowpass\", v.setParamValue(o.frequency, 2e3), R.type = \"lowpass\", v.setParamValue(R.frequency, 2e3), N.type = \"highpass\", v.setParamValue(N.frequency, 500), M.type = \"highpass\", v.setParamValue(M.frequency, 500), o.connect(R), R.connect(N), N.connect(M), n.call(this, o, M) || this;\n    }\n    n.call(this, null);\n  }\n  return a(t, n), t;\n}(S);\nvar T = 0, G = { __proto__: null, playOnce: function(n, t) {\n  var e = \"alias\".concat(T++);\n  return s().add(e, { url: n, preload: !0, autoPlay: !0, loaded: function(o) {\n    o && (s().remove(e), t && t(o));\n  }, complete: function() {\n    s().remove(e), t && t(null);\n  } }), e;\n}, get PLAY_ID() {\n  return T;\n}, render: function(n, t) {\n  var e = document.createElement(\"canvas\");\n  t = c({ width: 512, height: 128, fill: \"black\" }, t || {}), e.width = t.width, e.height = t.height;\n  var o = BaseTexture.from(e);\n  if (!(n.media instanceof w))\n    return o;\n  var R = n.media, N = e.getContext(\"2d\");\n  N.fillStyle = t.fill;\n  for (var M = R.buffer.getChannelData(0), D = Math.ceil(M.length / t.width), L = t.height / 2, B = 0; B < t.width; B++) {\n    for (var $ = 1, k = -1, U = 0; U < D; U++) {\n      var z = M[B * D + U];\n      z < $ && ($ = z), z > k && (k = z);\n    }\n    N.fillRect(B, (1 + $) * L, 1, Math.max(1, (k - $) * L));\n  }\n  return o;\n}, resolveUrl: d, sineTone: function(n, t) {\n  n === void 0 && (n = 200), t === void 0 && (t = 1);\n  var e = A.from({ singleInstance: !0 });\n  if (!(e.media instanceof w))\n    return e;\n  for (var o = e.media, R = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), N = R.getChannelData(0), M = 0; M < N.length; M++) {\n    var D = n * (M / R.sampleRate) * Math.PI;\n    N[M] = 2 * Math.sin(D);\n  }\n  return o.buffer = R, e.isLoaded = !0, e;\n}, validateFormats: h, supported: p$1, extensions: l }, I = function(n) {\n  return r = n, n;\n}(new E());\nLoader.registerPlugin(_);\nfunction finallyConstructor(n) {\n  var t = this.constructor;\n  return this.then(\n    function(e) {\n      return t.resolve(n()).then(function() {\n        return e;\n      });\n    },\n    function(e) {\n      return t.resolve(n()).then(function() {\n        return t.reject(e);\n      });\n    }\n  );\n}\nfunction allSettled(n) {\n  var t = this;\n  return new t(function(e, o) {\n    if (!(n && typeof n.length < \"u\"))\n      return o(\n        new TypeError(\n          typeof n + \" \" + n + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"\n        )\n      );\n    var R = Array.prototype.slice.call(n);\n    if (R.length === 0)\n      return e([]);\n    var N = R.length;\n    function M(L, B) {\n      if (B && (typeof B == \"object\" || typeof B == \"function\")) {\n        var $ = B.then;\n        if (typeof $ == \"function\") {\n          $.call(\n            B,\n            function(k) {\n              M(L, k);\n            },\n            function(k) {\n              R[L] = { status: \"rejected\", reason: k }, --N === 0 && e(R);\n            }\n          );\n          return;\n        }\n      }\n      R[L] = { status: \"fulfilled\", value: B }, --N === 0 && e(R);\n    }\n    for (var D = 0; D < R.length; D++)\n      M(D, R[D]);\n  });\n}\nvar setTimeoutFunc = setTimeout;\nfunction isArray$1(n) {\n  return Boolean(n && typeof n.length < \"u\");\n}\nfunction noop() {\n}\nfunction bind$2(n, t) {\n  return function() {\n    n.apply(t, arguments);\n  };\n}\nfunction Promise$1(n) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof n != \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(n, this);\n}\nfunction handle(n, t) {\n  for (; n._state === 3; )\n    n = n._value;\n  if (n._state === 0) {\n    n._deferreds.push(t);\n    return;\n  }\n  n._handled = !0, Promise$1._immediateFn(function() {\n    var e = n._state === 1 ? t.onFulfilled : t.onRejected;\n    if (e === null) {\n      (n._state === 1 ? resolve : reject)(t.promise, n._value);\n      return;\n    }\n    var o;\n    try {\n      o = e(n._value);\n    } catch (R) {\n      reject(t.promise, R);\n      return;\n    }\n    resolve(t.promise, o);\n  });\n}\nfunction resolve(n, t) {\n  try {\n    if (t === n)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (t && (typeof t == \"object\" || typeof t == \"function\")) {\n      var e = t.then;\n      if (t instanceof Promise$1) {\n        n._state = 3, n._value = t, finale(n);\n        return;\n      } else if (typeof e == \"function\") {\n        doResolve(bind$2(e, t), n);\n        return;\n      }\n    }\n    n._state = 1, n._value = t, finale(n);\n  } catch (o) {\n    reject(n, o);\n  }\n}\nfunction reject(n, t) {\n  n._state = 2, n._value = t, finale(n);\n}\nfunction finale(n) {\n  n._state === 2 && n._deferreds.length === 0 && Promise$1._immediateFn(function() {\n    n._handled || Promise$1._unhandledRejectionFn(n._value);\n  });\n  for (var t = 0, e = n._deferreds.length; t < e; t++)\n    handle(n, n._deferreds[t]);\n  n._deferreds = null;\n}\nfunction Handler(n, t, e) {\n  this.onFulfilled = typeof n == \"function\" ? n : null, this.onRejected = typeof t == \"function\" ? t : null, this.promise = e;\n}\nfunction doResolve(n, t) {\n  var e = !1;\n  try {\n    n(\n      function(o) {\n        e || (e = !0, resolve(t, o));\n      },\n      function(o) {\n        e || (e = !0, reject(t, o));\n      }\n    );\n  } catch (o) {\n    if (e)\n      return;\n    e = !0, reject(t, o);\n  }\n}\nPromise$1.prototype.catch = function(n) {\n  return this.then(null, n);\n};\nPromise$1.prototype.then = function(n, t) {\n  var e = new this.constructor(noop);\n  return handle(this, new Handler(n, t, e)), e;\n};\nPromise$1.prototype.finally = finallyConstructor;\nPromise$1.all = function(n) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(n))\n      return e(new TypeError(\"Promise.all accepts an array\"));\n    var o = Array.prototype.slice.call(n);\n    if (o.length === 0)\n      return t([]);\n    var R = o.length;\n    function N(D, L) {\n      try {\n        if (L && (typeof L == \"object\" || typeof L == \"function\")) {\n          var B = L.then;\n          if (typeof B == \"function\") {\n            B.call(\n              L,\n              function($) {\n                N(D, $);\n              },\n              e\n            );\n            return;\n          }\n        }\n        o[D] = L, --R === 0 && t(o);\n      } catch ($) {\n        e($);\n      }\n    }\n    for (var M = 0; M < o.length; M++)\n      N(M, o[M]);\n  });\n};\nPromise$1.allSettled = allSettled;\nPromise$1.resolve = function(n) {\n  return n && typeof n == \"object\" && n.constructor === Promise$1 ? n : new Promise$1(function(t) {\n    t(n);\n  });\n};\nPromise$1.reject = function(n) {\n  return new Promise$1(function(t, e) {\n    e(n);\n  });\n};\nPromise$1.race = function(n) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(n))\n      return e(new TypeError(\"Promise.race accepts an array\"));\n    for (var o = 0, R = n.length; o < R; o++)\n      Promise$1.resolve(n[o]).then(t, e);\n  });\n};\nPromise$1._immediateFn = typeof setImmediate == \"function\" && function(n) {\n  setImmediate(n);\n} || function(n) {\n  setTimeoutFunc(n, 0);\n};\nPromise$1._unhandledRejectionFn = function(t) {\n  typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", t);\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(n) {\n  if (n == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(n);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var n = new String(\"abc\");\n    if (n[5] = \"de\", Object.getOwnPropertyNames(n)[0] === \"5\")\n      return !1;\n    for (var t = {}, e = 0; e < 10; e++)\n      t[\"_\" + String.fromCharCode(e)] = e;\n    var o = Object.getOwnPropertyNames(t).map(function(N) {\n      return t[N];\n    });\n    if (o.join(\"\") !== \"0123456789\")\n      return !1;\n    var R = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(N) {\n      R[N] = N;\n    }), Object.keys(Object.assign({}, R)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(n, t) {\n  for (var e, o = toObject(n), R, N = 1; N < arguments.length; N++) {\n    e = Object(arguments[N]);\n    for (var M in e)\n      hasOwnProperty$1.call(e, M) && (o[M] = e[M]);\n    if (getOwnPropertySymbols) {\n      R = getOwnPropertySymbols(e);\n      for (var D = 0; D < R.length; D++)\n        propIsEnumerable.call(e, R[D]) && (o[R[D]] = e[R[D]]);\n    }\n  }\n  return o;\n};\n/*!\n * @pixi/polyfill - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/polyfill is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ntypeof globalThis > \"u\" && (typeof self < \"u\" ? self.globalThis = self : typeof __webpack_require__.g < \"u\" && (__webpack_require__.g.globalThis = __webpack_require__.g));\nglobalThis.Promise || (globalThis.Promise = Promise$1);\nObject.assign || (Object.assign = objectAssign);\nvar ONE_FRAME_TIME = 16;\nDate.now && Date.prototype.getTime || (Date.now = function() {\n  return new Date().getTime();\n});\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var startTime_1 = Date.now();\n  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {\n    return Date.now() - startTime_1;\n  };\n}\nvar lastTime = Date.now(), vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {\n  var p = vendors[x];\n  globalThis.requestAnimationFrame = globalThis[p + \"RequestAnimationFrame\"], globalThis.cancelAnimationFrame = globalThis[p + \"CancelAnimationFrame\"] || globalThis[p + \"CancelRequestAnimationFrame\"];\n}\nglobalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(n) {\n  if (typeof n != \"function\")\n    throw new TypeError(n + \"is not a function\");\n  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;\n  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {\n    lastTime = Date.now(), n(performance.now());\n  }, e);\n});\nglobalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(n) {\n  return clearTimeout(n);\n});\nMath.sign || (Math.sign = function(t) {\n  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;\n});\nNumber.isInteger || (Number.isInteger = function(t) {\n  return typeof t == \"number\" && isFinite(t) && Math.floor(t) === t;\n});\nglobalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);\nglobalThis.Float32Array || (globalThis.Float32Array = Array);\nglobalThis.Uint32Array || (globalThis.Uint32Array = Array);\nglobalThis.Uint16Array || (globalThis.Uint16Array = Array);\nglobalThis.Uint8Array || (globalThis.Uint8Array = Array);\nglobalThis.Int32Array || (globalThis.Int32Array = Array);\n/*!\n * @pixi/display - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.SORTABLE_CHILDREN = !1;\nvar Bounds = function() {\n  function n() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n  }\n  return n.prototype.isEmpty = function() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }, n.prototype.clear = function() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n  }, n.prototype.getRectangle = function(t) {\n    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);\n  }, n.prototype.addPoint = function(t) {\n    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);\n  }, n.prototype.addPointMatrix = function(t, e) {\n    var o = t.a, R = t.b, N = t.c, M = t.d, D = t.tx, L = t.ty, B = o * e.x + N * e.y + D, $ = R * e.x + M * e.y + L;\n    this.minX = Math.min(this.minX, B), this.maxX = Math.max(this.maxX, B), this.minY = Math.min(this.minY, $), this.maxY = Math.max(this.maxY, $);\n  }, n.prototype.addQuad = function(t) {\n    var e = this.minX, o = this.minY, R = this.maxX, N = this.maxY, M = t[0], D = t[1];\n    e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[2], D = t[3], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[4], D = t[5], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[6], D = t[7], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, this.minX = e, this.minY = o, this.maxX = R, this.maxY = N;\n  }, n.prototype.addFrame = function(t, e, o, R, N) {\n    this.addFrameMatrix(t.worldTransform, e, o, R, N);\n  }, n.prototype.addFrameMatrix = function(t, e, o, R, N) {\n    var M = t.a, D = t.b, L = t.c, B = t.d, $ = t.tx, k = t.ty, U = this.minX, z = this.minY, X = this.maxX, V = this.maxY, W = M * e + L * o + $, Y = D * e + B * o + k;\n    U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * R + L * o + $, Y = D * R + B * o + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * e + L * N + $, Y = D * e + B * N + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * R + L * N + $, Y = D * R + B * N + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, this.minX = U, this.minY = z, this.maxX = X, this.maxY = V;\n  }, n.prototype.addVertexData = function(t, e, o) {\n    for (var R = this.minX, N = this.minY, M = this.maxX, D = this.maxY, L = e; L < o; L += 2) {\n      var B = t[L], $ = t[L + 1];\n      R = B < R ? B : R, N = $ < N ? $ : N, M = B > M ? B : M, D = $ > D ? $ : D;\n    }\n    this.minX = R, this.minY = N, this.maxX = M, this.maxY = D;\n  }, n.prototype.addVertices = function(t, e, o, R) {\n    this.addVerticesMatrix(t.worldTransform, e, o, R);\n  }, n.prototype.addVerticesMatrix = function(t, e, o, R, N, M) {\n    N === void 0 && (N = 0), M === void 0 && (M = N);\n    for (var D = t.a, L = t.b, B = t.c, $ = t.d, k = t.tx, U = t.ty, z = this.minX, X = this.minY, V = this.maxX, W = this.maxY, Y = o; Y < R; Y += 2) {\n      var q = e[Y], Z = e[Y + 1], K = D * q + B * Z + k, Q = $ * Z + L * q + U;\n      z = Math.min(z, K - N), V = Math.max(V, K + N), X = Math.min(X, Q - M), W = Math.max(W, Q + M);\n    }\n    this.minX = z, this.minY = X, this.maxX = V, this.maxY = W;\n  }, n.prototype.addBounds = function(t) {\n    var e = this.minX, o = this.minY, R = this.maxX, N = this.maxY;\n    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < o ? t.minY : o, this.maxX = t.maxX > R ? t.maxX : R, this.maxY = t.maxY > N ? t.maxY : N;\n  }, n.prototype.addBoundsMask = function(t, e) {\n    var o = t.minX > e.minX ? t.minX : e.minX, R = t.minY > e.minY ? t.minY : e.minY, N = t.maxX < e.maxX ? t.maxX : e.maxX, M = t.maxY < e.maxY ? t.maxY : e.maxY;\n    if (o <= N && R <= M) {\n      var D = this.minX, L = this.minY, B = this.maxX, $ = this.maxY;\n      this.minX = o < D ? o : D, this.minY = R < L ? R : L, this.maxX = N > B ? N : B, this.maxY = M > $ ? M : $;\n    }\n  }, n.prototype.addBoundsMatrix = function(t, e) {\n    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);\n  }, n.prototype.addBoundsArea = function(t, e) {\n    var o = t.minX > e.x ? t.minX : e.x, R = t.minY > e.y ? t.minY : e.y, N = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, M = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;\n    if (o <= N && R <= M) {\n      var D = this.minX, L = this.minY, B = this.maxX, $ = this.maxY;\n      this.minX = o < D ? o : D, this.minY = R < L ? R : L, this.maxX = N > B ? N : B, this.maxY = M > $ ? M : $;\n    }\n  }, n.prototype.pad = function(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);\n  }, n.prototype.addFramePad = function(t, e, o, R, N, M) {\n    t -= N, e -= M, o += N, R += M, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > o ? this.maxX : o, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > R ? this.maxY : R;\n  }, n;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$p = function(n, t) {\n  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$p(n, t);\n};\nfunction __extends$p(n, t) {\n  extendStatics$p(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar DisplayObject = function(n) {\n  __extends$p(t, n);\n  function t() {\n    var e = n.call(this) || this;\n    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;\n  }\n  return t.mixin = function(e) {\n    for (var o = Object.keys(e), R = 0; R < o.length; ++R) {\n      var N = o[R];\n      Object.defineProperty(t.prototype, N, Object.getOwnPropertyDescriptor(e, N));\n    }\n  }, Object.defineProperty(t.prototype, \"destroyed\", {\n    get: function() {\n      return this._destroyed;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._recursivePostUpdateTransform = function() {\n    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n  }, t.prototype.updateTransform = function() {\n    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }, t.prototype.getBounds = function(e, o) {\n    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), o || (this._boundsRect || (this._boundsRect = new Rectangle()), o = this._boundsRect), this._bounds.getRectangle(o);\n  }, t.prototype.getLocalBounds = function(e) {\n    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());\n    var o = this.transform, R = this.parent;\n    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;\n    var N = this._bounds, M = this._boundsID;\n    this._bounds = this._localBounds;\n    var D = this.getBounds(!1, e);\n    return this.parent = R, this.transform = o, this._bounds = N, this._bounds.updateID += this._boundsID - M, D;\n  }, t.prototype.toGlobal = function(e, o, R) {\n    return R === void 0 && (R = !1), R || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, o);\n  }, t.prototype.toLocal = function(e, o, R, N) {\n    return o && (e = o.toGlobal(e, R, N)), N || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, R);\n  }, t.prototype.setParent = function(e) {\n    if (!e || !e.addChild)\n      throw new Error(\"setParent: Argument must be a Container\");\n    return e.addChild(this), e;\n  }, t.prototype.setTransform = function(e, o, R, N, M, D, L, B, $) {\n    return e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 1), M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), this.position.x = e, this.position.y = o, this.scale.x = R || 1, this.scale.y = N || 1, this.rotation = M, this.skew.x = D, this.skew.y = L, this.pivot.x = B, this.pivot.y = $, this;\n  }, t.prototype.destroy = function(e) {\n    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit(\"destroyed\"), this.removeAllListeners();\n  }, Object.defineProperty(t.prototype, \"_tempDisplayObjectParent\", {\n    get: function() {\n      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.enableTempParent = function() {\n    var e = this.parent;\n    return this.parent = this._tempDisplayObjectParent, e;\n  }, t.prototype.disableTempParent = function(e) {\n    this.parent = e;\n  }, Object.defineProperty(t.prototype, \"x\", {\n    get: function() {\n      return this.position.x;\n    },\n    set: function(e) {\n      this.transform.position.x = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"y\", {\n    get: function() {\n      return this.position.y;\n    },\n    set: function(e) {\n      this.transform.position.y = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldTransform\", {\n    get: function() {\n      return this.transform.worldTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"localTransform\", {\n    get: function() {\n      return this.transform.localTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"position\", {\n    get: function() {\n      return this.transform.position;\n    },\n    set: function(e) {\n      this.transform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scale\", {\n    get: function() {\n      return this.transform.scale;\n    },\n    set: function(e) {\n      this.transform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"pivot\", {\n    get: function() {\n      return this.transform.pivot;\n    },\n    set: function(e) {\n      this.transform.pivot.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"skew\", {\n    get: function() {\n      return this.transform.skew;\n    },\n    set: function(e) {\n      this.transform.skew.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotation\", {\n    get: function() {\n      return this.transform.rotation;\n    },\n    set: function(e) {\n      this.transform.rotation = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"angle\", {\n    get: function() {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function(e) {\n      this.transform.rotation = e * DEG_TO_RAD;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"zIndex\", {\n    get: function() {\n      return this._zIndex;\n    },\n    set: function(e) {\n      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldVisible\", {\n    get: function() {\n      var e = this;\n      do {\n        if (!e.visible)\n          return !1;\n        e = e.parent;\n      } while (e);\n      return !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mask\", {\n    get: function() {\n      return this._mask;\n    },\n    set: function(e) {\n      if (this._mask !== e) {\n        if (this._mask) {\n          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          o && (o._maskRefCount--, o._maskRefCount === 0 && (o.renderable = !0, o.isMask = !1));\n        }\n        if (this._mask = e, this._mask) {\n          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          o && (o._maskRefCount === 0 && (o.renderable = !1, o.isMask = !0), o._maskRefCount++);\n        }\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(EventEmitter$5), TemporaryDisplayObject = function(n) {\n  __extends$p(t, n);\n  function t() {\n    var e = n !== null && n.apply(this, arguments) || this;\n    return e.sortDirty = null, e;\n  }\n  return t;\n}(DisplayObject);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$4;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$4 || (ENV$4 = {}));\nvar RENDERER_TYPE$4;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));\nvar BUFFER_BITS$4;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));\nvar BLEND_MODES$4;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));\nvar DRAW_MODES$4;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));\nvar FORMATS$4;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$4 || (FORMATS$4 = {}));\nvar TARGETS$4;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$4 || (TARGETS$4 = {}));\nvar TYPES$4;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$4 || (TYPES$4 = {}));\nvar SAMPLER_TYPES$4;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));\nvar SCALE_MODES$4;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));\nvar WRAP_MODES$4;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));\nvar MIPMAP_MODES$4;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));\nvar ALPHA_MODES$4;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));\nvar CLEAR_MODES$4;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));\nvar GC_MODES$4;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$4 || (GC_MODES$4 = {}));\nvar PRECISION$4;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$4 || (PRECISION$4 = {}));\nvar MASK_TYPES$4;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));\nvar COLOR_MASK_BITS$4;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$4 || (COLOR_MASK_BITS$4 = {}));\nvar MSAA_QUALITY$4;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));\nvar BUFFER_TYPE$4;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));\nfunction sortChildren(n, t) {\n  return n.zIndex === t.zIndex ? n._lastSortedIndex - t._lastSortedIndex : n.zIndex - t.zIndex;\n}\nvar Container = function(n) {\n  __extends$p(t, n);\n  function t() {\n    var e = n.call(this) || this;\n    return e.children = [], e.sortableChildren = settings$1.SORTABLE_CHILDREN, e.sortDirty = !1, e;\n  }\n  return t.prototype.onChildrenChange = function(e) {\n  }, t.prototype.addChild = function() {\n    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)\n      o[R] = e[R];\n    if (o.length > 1)\n      for (var N = 0; N < o.length; N++)\n        this.addChild(o[N]);\n    else {\n      var M = o[0];\n      M.parent && M.parent.removeChild(M), M.parent = this, this.sortDirty = !0, M.transform._parentID = -1, this.children.push(M), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit(\"childAdded\", M, this, this.children.length - 1), M.emit(\"added\", this);\n    }\n    return o[0];\n  }, t.prototype.addChildAt = function(e, o) {\n    if (o < 0 || o > this.children.length)\n      throw new Error(e + \"addChildAt: The index \" + o + \" supplied is out of bounds \" + this.children.length);\n    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(o, 0, e), this._boundsID++, this.onChildrenChange(o), e.emit(\"added\", this), this.emit(\"childAdded\", e, this, o), e;\n  }, t.prototype.swapChildren = function(e, o) {\n    if (e !== o) {\n      var R = this.getChildIndex(e), N = this.getChildIndex(o);\n      this.children[R] = o, this.children[N] = e, this.onChildrenChange(R < N ? R : N);\n    }\n  }, t.prototype.getChildIndex = function(e) {\n    var o = this.children.indexOf(e);\n    if (o === -1)\n      throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n    return o;\n  }, t.prototype.setChildIndex = function(e, o) {\n    if (o < 0 || o >= this.children.length)\n      throw new Error(\"The index \" + o + \" supplied is out of bounds \" + this.children.length);\n    var R = this.getChildIndex(e);\n    removeItems(this.children, R, 1), this.children.splice(o, 0, e), this.onChildrenChange(o);\n  }, t.prototype.getChildAt = function(e) {\n    if (e < 0 || e >= this.children.length)\n      throw new Error(\"getChildAt: Index (\" + e + \") does not exist.\");\n    return this.children[e];\n  }, t.prototype.removeChild = function() {\n    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)\n      o[R] = e[R];\n    if (o.length > 1)\n      for (var N = 0; N < o.length; N++)\n        this.removeChild(o[N]);\n    else {\n      var M = o[0], D = this.children.indexOf(M);\n      if (D === -1)\n        return null;\n      M.parent = null, M.transform._parentID = -1, removeItems(this.children, D, 1), this._boundsID++, this.onChildrenChange(D), M.emit(\"removed\", this), this.emit(\"childRemoved\", M, this, D);\n    }\n    return o[0];\n  }, t.prototype.removeChildAt = function(e) {\n    var o = this.getChildAt(e);\n    return o.parent = null, o.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), o.emit(\"removed\", this), this.emit(\"childRemoved\", o, this, e), o;\n  }, t.prototype.removeChildren = function(e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = this.children.length);\n    var R = e, N = o, M = N - R, D;\n    if (M > 0 && M <= N) {\n      D = this.children.splice(R, M);\n      for (var L = 0; L < D.length; ++L)\n        D[L].parent = null, D[L].transform && (D[L].transform._parentID = -1);\n      this._boundsID++, this.onChildrenChange(e);\n      for (var L = 0; L < D.length; ++L)\n        D[L].emit(\"removed\", this), this.emit(\"childRemoved\", D[L], this, L);\n      return D;\n    } else if (M === 0 && this.children.length === 0)\n      return [];\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  }, t.prototype.sortChildren = function() {\n    for (var e = !1, o = 0, R = this.children.length; o < R; ++o) {\n      var N = this.children[o];\n      N._lastSortedIndex = o, !e && N.zIndex !== 0 && (e = !0);\n    }\n    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var e = 0, o = this.children.length; e < o; ++e) {\n      var R = this.children[e];\n      R.visible && R.updateTransform();\n    }\n  }, t.prototype.calculateBounds = function() {\n    this._bounds.clear(), this._calculateBounds();\n    for (var e = 0; e < this.children.length; e++) {\n      var o = this.children[e];\n      if (!(!o.visible || !o.renderable))\n        if (o.calculateBounds(), o._mask) {\n          var R = o._mask.isMaskData ? o._mask.maskObject : o._mask;\n          R ? (R.calculateBounds(), this._bounds.addBoundsMask(o._bounds, R._bounds)) : this._bounds.addBounds(o._bounds);\n        } else\n          o.filterArea ? this._bounds.addBoundsArea(o._bounds, o.filterArea) : this._bounds.addBounds(o._bounds);\n    }\n    this._bounds.updateID = this._boundsID;\n  }, t.prototype.getLocalBounds = function(e, o) {\n    o === void 0 && (o = !1);\n    var R = n.prototype.getLocalBounds.call(this, e);\n    if (!o)\n      for (var N = 0, M = this.children.length; N < M; ++N) {\n        var D = this.children[N];\n        D.visible && D.updateTransform();\n      }\n    return R;\n  }, t.prototype._calculateBounds = function() {\n  }, t.prototype._renderWithCulling = function(e) {\n    var o = e.renderTexture.sourceFrame;\n    if (o.width > 0 && o.height > 0) {\n      var R, N;\n      if (this.cullArea ? (R = this.cullArea, N = this.worldTransform) : this._render !== t.prototype._render && (R = this.getBounds(!0)), R && o.intersects(R, N))\n        this._render(e);\n      else if (this.cullArea)\n        return;\n      for (var M = 0, D = this.children.length; M < D; ++M) {\n        var L = this.children[M], B = L.cullable;\n        L.cullable = B || !this.cullArea, L.render(e), L.cullable = B;\n      }\n    }\n  }, t.prototype.render = function(e) {\n    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n      if (this._mask || this.filters && this.filters.length)\n        this.renderAdvanced(e);\n      else if (this.cullable)\n        this._renderWithCulling(e);\n      else {\n        this._render(e);\n        for (var o = 0, R = this.children.length; o < R; ++o)\n          this.children[o].render(e);\n      }\n  }, t.prototype.renderAdvanced = function(e) {\n    var o = this.filters, R = this._mask;\n    if (o) {\n      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n      for (var N = 0; N < o.length; N++)\n        o[N].enabled && this._enabledFilters.push(o[N]);\n    }\n    var M = o && this._enabledFilters && this._enabledFilters.length || R && (!R.isMaskData || R.enabled && (R.autoDetect || R.type !== MASK_TYPES$4.NONE));\n    if (M && e.batch.flush(), o && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), R && e.mask.push(this, this._mask), this.cullable)\n      this._renderWithCulling(e);\n    else {\n      this._render(e);\n      for (var N = 0, D = this.children.length; N < D; ++N)\n        this.children[N].render(e);\n    }\n    M && e.batch.flush(), R && e.mask.pop(this), o && this._enabledFilters && this._enabledFilters.length && e.filter.pop();\n  }, t.prototype._render = function(e) {\n  }, t.prototype.destroy = function(e) {\n    n.prototype.destroy.call(this), this.sortDirty = !1;\n    var o = typeof e == \"boolean\" ? e : e && e.children, R = this.removeChildren(0, this.children.length);\n    if (o)\n      for (var N = 0; N < R.length; ++N)\n        R[N].destroy(e);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(e) {\n      var o = this.getLocalBounds().width;\n      o !== 0 ? this.scale.x = e / o : this.scale.x = 1, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(e) {\n      var o = this.getLocalBounds().height;\n      o !== 0 ? this.scale.y = e / o : this.scale.y = 1, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(DisplayObject);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n/*!\n * @pixi/accessibility - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/accessibility is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar accessibleTarget = {\n  accessible: !1,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: !1,\n  _accessibleDiv: null,\n  accessibleType: \"button\",\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: !0,\n  renderId: -1\n};\nDisplayObject.mixin(accessibleTarget);\nvar KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {\n  function n(t) {\n    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile$2.tablet || isMobile$2.phone) && this.createTouchHook();\n    var e = document.createElement(\"div\");\n    e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_TOUCH_POS_X + \"px\", e.style.left = DIV_TOUCH_POS_Y + \"px\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1);\n  }\n  return Object.defineProperty(n.prototype, \"isActive\", {\n    get: function() {\n      return this._isActive;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"isMobileAccessibility\", {\n    get: function() {\n      return this._isMobileAccessibility;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.createTouchHook = function() {\n    var t = this, e = document.createElement(\"button\");\n    e.style.width = DIV_HOOK_SIZE + \"px\", e.style.height = DIV_HOOK_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_HOOK_POS_X + \"px\", e.style.left = DIV_HOOK_POS_Y + \"px\", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = \"#FF0000\", e.title = \"select to enable accessibility for this content\", e.addEventListener(\"focus\", function() {\n      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();\n    }), document.body.appendChild(e), this._hookDiv = e;\n  }, n.prototype.destroyTouchHook = function() {\n    !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n  }, n.prototype.activate = function() {\n    var t;\n    this._isActive || (this._isActive = !0, globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.on(\"postrender\", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));\n  }, n.prototype.deactivate = function() {\n    var t;\n    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.off(\"postrender\", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));\n  }, n.prototype.updateAccessibleObjects = function(t) {\n    if (!(!t.visible || !t.accessibleChildren)) {\n      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);\n      var e = t.children;\n      if (e)\n        for (var o = 0; o < e.length; o++)\n          this.updateAccessibleObjects(e[o]);\n    }\n  }, n.prototype.update = function() {\n    var t = performance.now();\n    if (!(isMobile$2.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {\n      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n      var e = this.renderer.view.getBoundingClientRect(), o = e.left, R = e.top, N = e.width, M = e.height, D = this.renderer, L = D.width, B = D.height, $ = D.resolution, k = N / L * $, U = M / B * $, z = this.div;\n      z.style.left = o + \"px\", z.style.top = R + \"px\", z.style.width = L + \"px\", z.style.height = B + \"px\";\n      for (var X = 0; X < this.children.length; X++) {\n        var V = this.children[X];\n        if (V.renderId !== this.renderId)\n          V._accessibleActive = !1, removeItems(this.children, X, 1), this.div.removeChild(V._accessibleDiv), this.pool.push(V._accessibleDiv), V._accessibleDiv = null, X--;\n        else {\n          z = V._accessibleDiv;\n          var W = V.hitArea, Y = V.worldTransform;\n          V.hitArea ? (z.style.left = (Y.tx + W.x * Y.a) * k + \"px\", z.style.top = (Y.ty + W.y * Y.d) * U + \"px\", z.style.width = W.width * Y.a * k + \"px\", z.style.height = W.height * Y.d * U + \"px\") : (W = V.getBounds(), this.capHitArea(W), z.style.left = W.x * k + \"px\", z.style.top = W.y * U + \"px\", z.style.width = W.width * k + \"px\", z.style.height = W.height * U + \"px\", z.title !== V.accessibleTitle && V.accessibleTitle !== null && (z.title = V.accessibleTitle), z.getAttribute(\"aria-label\") !== V.accessibleHint && V.accessibleHint !== null && z.setAttribute(\"aria-label\", V.accessibleHint)), (V.accessibleTitle !== z.title || V.tabIndex !== z.tabIndex) && (z.title = V.accessibleTitle, z.tabIndex = V.tabIndex, this.debug && this.updateDebugHTML(z));\n        }\n      }\n      this.renderId++;\n    }\n  }, n.prototype.updateDebugHTML = function(t) {\n    t.innerHTML = \"type: \" + t.type + \"</br> title : \" + t.title + \"</br> tabIndex: \" + t.tabIndex;\n  }, n.prototype.capHitArea = function(t) {\n    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);\n    var e = this.renderer, o = e.width, R = e.height;\n    t.x + t.width > o && (t.width = o - t.x), t.y + t.height > R && (t.height = R - t.y);\n  }, n.prototype.addChild = function(t) {\n    var e = this.pool.pop();\n    e || (e = document.createElement(\"button\"), e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\", e.style.position = \"absolute\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = \"none\", navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1 ? e.setAttribute(\"aria-live\", \"off\") : e.setAttribute(\"aria-live\", \"polite\"), navigator.userAgent.match(/rv:.*Gecko\\//) ? e.setAttribute(\"aria-relevant\", \"additions\") : e.setAttribute(\"aria-relevant\", \"text\"), e.addEventListener(\"click\", this._onClick.bind(this)), e.addEventListener(\"focus\", this._onFocus.bind(this)), e.addEventListener(\"focusout\", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = \"displayObject \" + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute(\"aria-label\", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;\n  }, n.prototype._onClick = function(t) {\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;\n    e.dispatchEvent(o, \"click\", R), e.dispatchEvent(o, \"pointertap\", R), e.dispatchEvent(o, \"tap\", R);\n  }, n.prototype._onFocus = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"assertive\");\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;\n    e.dispatchEvent(o, \"mouseover\", R);\n  }, n.prototype._onFocusOut = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"polite\");\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;\n    e.dispatchEvent(o, \"mouseout\", R);\n  }, n.prototype._onKeyDown = function(t) {\n    t.keyCode === KEY_CODE_TAB && this.activate();\n  }, n.prototype._onMouseMove = function(t) {\n    t.movementX === 0 && t.movementY === 0 || this.deactivate();\n  }, n.prototype.destroy = function() {\n    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n  }, n.extension = {\n    name: \"accessibility\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, n;\n}();\n/*!\n * @pixi/interaction - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar InteractionData = function() {\n  function n() {\n    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;\n  }\n  return Object.defineProperty(n.prototype, \"pointerId\", {\n    get: function() {\n      return this.identifier;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.getLocalPosition = function(t, e, o) {\n    return t.worldTransform.applyInverse(o || this.global, e);\n  }, n.prototype.copyEvent = function(t) {\n    \"isPrimary\" in t && t.isPrimary && (this.isPrimary = !0), this.button = \"button\" in t && t.button;\n    var e = \"buttons\" in t && t.buttons;\n    this.buttons = Number.isInteger(e) ? e : \"which\" in t && t.which, this.width = \"width\" in t && t.width, this.height = \"height\" in t && t.height, this.tiltX = \"tiltX\" in t && t.tiltX, this.tiltY = \"tiltY\" in t && t.tiltY, this.pointerType = \"pointerType\" in t && t.pointerType, this.pressure = \"pressure\" in t && t.pressure, this.rotationAngle = \"rotationAngle\" in t && t.rotationAngle, this.twist = \"twist\" in t && t.twist || 0, this.tangentialPressure = \"tangentialPressure\" in t && t.tangentialPressure || 0;\n  }, n.prototype.reset = function() {\n    this.isPrimary = !1;\n  }, n;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$o = function(n, t) {\n  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$o(n, t);\n};\nfunction __extends$o(n, t) {\n  extendStatics$o(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar InteractionEvent = function() {\n  function n() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;\n  }\n  return n.prototype.stopPropagation = function() {\n    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;\n  }, n.prototype.reset = function() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;\n  }, n;\n}(), InteractionTrackingData = function() {\n  function n(t) {\n    this._pointerId = t, this._flags = n.FLAGS.NONE;\n  }\n  return n.prototype._doSet = function(t, e) {\n    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;\n  }, Object.defineProperty(n.prototype, \"pointerId\", {\n    get: function() {\n      return this._pointerId;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"flags\", {\n    get: function() {\n      return this._flags;\n    },\n    set: function(t) {\n      this._flags = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"none\", {\n    get: function() {\n      return this._flags === n.FLAGS.NONE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"over\", {\n    get: function() {\n      return (this._flags & n.FLAGS.OVER) !== 0;\n    },\n    set: function(t) {\n      this._doSet(n.FLAGS.OVER, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"rightDown\", {\n    get: function() {\n      return (this._flags & n.FLAGS.RIGHT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(n.FLAGS.RIGHT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"leftDown\", {\n    get: function() {\n      return (this._flags & n.FLAGS.LEFT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(n.FLAGS.LEFT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  }), n;\n}(), TreeSearch = function() {\n  function n() {\n    this._tempPoint = new Point();\n  }\n  return n.prototype.recursiveFindHit = function(t, e, o, R, N) {\n    var M;\n    if (!e || !e.visible)\n      return !1;\n    var D = t.data.global;\n    N = e.interactive || N;\n    var L = !1, B = N, $ = !0;\n    if (e.hitArea)\n      R && (e.worldTransform.applyInverse(D, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? L = !0 : (R = !1, $ = !1)), B = !1;\n    else if (e._mask && R) {\n      var k = e._mask.isMaskData ? e._mask.maskObject : e._mask;\n      k && !(!((M = k.containsPoint) === null || M === void 0) && M.call(k, D)) && (R = !1);\n    }\n    if ($ && e.interactiveChildren && e.children)\n      for (var U = e.children, z = U.length - 1; z >= 0; z--) {\n        var X = U[z], V = this.recursiveFindHit(t, X, o, R, B);\n        if (V) {\n          if (!X.parent)\n            continue;\n          B = !1, V && (t.target && (R = !1), L = !0);\n        }\n      }\n    return N && (R && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(D) && (L = !0), e.interactive && (L && !t.target && (t.target = e), o && o(t, e, !!L))), L;\n  }, n.prototype.findHit = function(t, e, o, R) {\n    this.recursiveFindHit(t, e, o, R, !1);\n  }, n;\n}(), interactiveTarget = {\n  interactive: !1,\n  interactiveChildren: !0,\n  hitArea: null,\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(n) {\n    n ? this.cursor = \"pointer\" : this.cursor === \"pointer\" && (this.cursor = null);\n  },\n  cursor: null,\n  get trackedPointers() {\n    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;\n  },\n  _trackedPointers: void 0\n};\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1, hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n}, InteractionManager = function(n) {\n  __extends$o(t, n);\n  function t(e, o) {\n    var R = n.call(this) || this;\n    return o = o || {}, R.renderer = e, R.autoPreventDefault = o.autoPreventDefault !== void 0 ? o.autoPreventDefault : !0, R.interactionFrequency = o.interactionFrequency || 10, R.mouse = new InteractionData(), R.mouse.identifier = MOUSE_POINTER_ID, R.mouse.global.set(-999999), R.activeInteractionData = {}, R.activeInteractionData[MOUSE_POINTER_ID] = R.mouse, R.interactionDataPool = [], R.eventData = new InteractionEvent(), R.interactionDOMElement = null, R.moveWhenInside = !1, R.eventsAdded = !1, R.tickerAdded = !1, R.mouseOverRenderer = !(\"PointerEvent\" in globalThis), R.supportsTouchEvents = \"ontouchstart\" in globalThis, R.supportsPointerEvents = !!globalThis.PointerEvent, R.onPointerUp = R.onPointerUp.bind(R), R.processPointerUp = R.processPointerUp.bind(R), R.onPointerCancel = R.onPointerCancel.bind(R), R.processPointerCancel = R.processPointerCancel.bind(R), R.onPointerDown = R.onPointerDown.bind(R), R.processPointerDown = R.processPointerDown.bind(R), R.onPointerMove = R.onPointerMove.bind(R), R.processPointerMove = R.processPointerMove.bind(R), R.onPointerOut = R.onPointerOut.bind(R), R.processPointerOverOut = R.processPointerOverOut.bind(R), R.onPointerOver = R.onPointerOver.bind(R), R.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    }, R.currentCursorMode = null, R.cursor = null, R.resolution = 1, R.delayedEvents = [], R.search = new TreeSearch(), R._tempDisplayObject = new TemporaryDisplayObject(), R._eventListenerOptions = { capture: !0, passive: !1 }, R._useSystemTicker = o.useSystemTicker !== void 0 ? o.useSystemTicker : !0, R.setTargetElement(R.renderer.view, R.renderer.resolution), R;\n  }\n  return Object.defineProperty(t.prototype, \"useSystemTicker\", {\n    get: function() {\n      return this._useSystemTicker;\n    },\n    set: function(e) {\n      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"lastObjectRendered\", {\n    get: function() {\n      return this.renderer._lastObjectRendered || this._tempDisplayObject;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.hitTest = function(e, o) {\n    return hitTestEvent.target = null, hitTestEvent.data.global = e, o || (o = this.lastObjectRendered), this.processInteractive(hitTestEvent, o, null, !0), hitTestEvent.target;\n  }, t.prototype.setTargetElement = function(e, o) {\n    o === void 0 && (o = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = o, this.addEvents(), this.addTickerListener();\n  }, t.prototype.addTickerListener = function() {\n    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);\n  }, t.prototype.removeTickerListener = function() {\n    !this.tickerAdded || (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n  }, t.prototype.addEvents = function() {\n    if (!(this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"none\", e.msTouchAction = \"none\") : this.supportsPointerEvents && (e.touchAction = \"none\"), this.supportsPointerEvents ? (globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;\n    }\n  }, t.prototype.removeEvents = function() {\n    if (!(!this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"\", e.msTouchAction = \"\") : this.supportsPointerEvents && (e.touchAction = \"\"), this.supportsPointerEvents ? (globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;\n    }\n  }, t.prototype.tickerUpdate = function(e) {\n    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n  }, t.prototype.update = function() {\n    if (!!this.interactionDOMElement) {\n      if (this._didMove) {\n        this._didMove = !1;\n        return;\n      }\n      this.cursor = null;\n      for (var e in this.activeInteractionData)\n        if (this.activeInteractionData.hasOwnProperty(e)) {\n          var o = this.activeInteractionData[e];\n          if (o.originalEvent && o.pointerType !== \"touch\") {\n            var R = this.configureInteractionEventForDOMEvent(this.eventData, o.originalEvent, o);\n            this.processInteractive(R, this.lastObjectRendered, this.processPointerOverOut, !0);\n          }\n        }\n      this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.setCursorMode = function(e) {\n    e = e || \"default\";\n    var o = !0;\n    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (o = !1), this.currentCursorMode !== e) {\n      this.currentCursorMode = e;\n      var R = this.cursorStyles[e];\n      if (R)\n        switch (typeof R) {\n          case \"string\":\n            o && (this.interactionDOMElement.style.cursor = R);\n            break;\n          case \"function\":\n            R(e);\n            break;\n          case \"object\":\n            o && Object.assign(this.interactionDOMElement.style, R);\n            break;\n        }\n      else\n        o && typeof e == \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);\n    }\n  }, t.prototype.dispatchEvent = function(e, o, R) {\n    (!R.stopPropagationHint || e === R.stopsPropagatingAt) && (R.currentTarget = e, R.type = o, e.emit(o, R), e[o] && e[o](R));\n  }, t.prototype.delayDispatchEvent = function(e, o, R) {\n    this.delayedEvents.push({ displayObject: e, eventString: o, eventData: R });\n  }, t.prototype.mapPositionToPoint = function(e, o, R) {\n    var N;\n    this.interactionDOMElement.parentElement ? N = this.interactionDOMElement.getBoundingClientRect() : N = {\n      x: 0,\n      y: 0,\n      width: this.interactionDOMElement.width,\n      height: this.interactionDOMElement.height,\n      left: 0,\n      top: 0\n    };\n    var M = 1 / this.resolution;\n    e.x = (o - N.left) * (this.interactionDOMElement.width / N.width) * M, e.y = (R - N.top) * (this.interactionDOMElement.height / N.height) * M;\n  }, t.prototype.processInteractive = function(e, o, R, N) {\n    var M = this.search.findHit(e, o, R, N), D = this.delayedEvents;\n    if (!D.length)\n      return M;\n    e.stopPropagationHint = !1;\n    var L = D.length;\n    this.delayedEvents = [];\n    for (var B = 0; B < L; B++) {\n      var $ = D[B], k = $.displayObject, U = $.eventString, z = $.eventData;\n      z.stopsPropagatingAt === k && (z.stopPropagationHint = !0), this.dispatchEvent(k, U, z);\n    }\n    return M;\n  }, t.prototype.onPointerDown = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e);\n      if (this.autoPreventDefault && o[0].isNormalized) {\n        var R = e.cancelable || !(\"cancelable\" in e);\n        R && e.preventDefault();\n      }\n      for (var N = o.length, M = 0; M < N; M++) {\n        var D = o[M], L = this.getInteractionDataForPointerId(D), B = this.configureInteractionEventForDOMEvent(this.eventData, D, L);\n        if (B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerDown, !0), this.emit(\"pointerdown\", B), D.pointerType === \"touch\")\n          this.emit(\"touchstart\", B);\n        else if (D.pointerType === \"mouse\" || D.pointerType === \"pen\") {\n          var $ = D.button === 2;\n          this.emit($ ? \"rightdown\" : \"mousedown\", this.eventData);\n        }\n      }\n    }\n  }, t.prototype.processPointerDown = function(e, o, R) {\n    var N = e.data, M = e.data.identifier;\n    if (R) {\n      if (o.trackedPointers[M] || (o.trackedPointers[M] = new InteractionTrackingData(M)), this.dispatchEvent(o, \"pointerdown\", e), N.pointerType === \"touch\")\n        this.dispatchEvent(o, \"touchstart\", e);\n      else if (N.pointerType === \"mouse\" || N.pointerType === \"pen\") {\n        var D = N.button === 2;\n        D ? o.trackedPointers[M].rightDown = !0 : o.trackedPointers[M].leftDown = !0, this.dispatchEvent(o, D ? \"rightdown\" : \"mousedown\", e);\n      }\n    }\n  }, t.prototype.onPointerComplete = function(e, o, R) {\n    var N = this.normalizeToPointerData(e), M = N.length, D = e.target;\n    e.composedPath && e.composedPath().length > 0 && (D = e.composedPath()[0]);\n    for (var L = D !== this.interactionDOMElement ? \"outside\" : \"\", B = 0; B < M; B++) {\n      var $ = N[B], k = this.getInteractionDataForPointerId($), U = this.configureInteractionEventForDOMEvent(this.eventData, $, k);\n      if (U.data.originalEvent = e, this.processInteractive(U, this.lastObjectRendered, R, o || !L), this.emit(o ? \"pointercancel\" : \"pointerup\" + L, U), $.pointerType === \"mouse\" || $.pointerType === \"pen\") {\n        var z = $.button === 2;\n        this.emit(z ? \"rightup\" + L : \"mouseup\" + L, U);\n      } else\n        $.pointerType === \"touch\" && (this.emit(o ? \"touchcancel\" : \"touchend\" + L, U), this.releaseInteractionDataForPointerId($.pointerId));\n    }\n  }, t.prototype.onPointerCancel = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !0, this.processPointerCancel);\n  }, t.prototype.processPointerCancel = function(e, o) {\n    var R = e.data, N = e.data.identifier;\n    o.trackedPointers[N] !== void 0 && (delete o.trackedPointers[N], this.dispatchEvent(o, \"pointercancel\", e), R.pointerType === \"touch\" && this.dispatchEvent(o, \"touchcancel\", e));\n  }, t.prototype.onPointerUp = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !1, this.processPointerUp);\n  }, t.prototype.processPointerUp = function(e, o, R) {\n    var N = e.data, M = e.data.identifier, D = o.trackedPointers[M], L = N.pointerType === \"touch\", B = N.pointerType === \"mouse\" || N.pointerType === \"pen\", $ = !1;\n    if (B) {\n      var k = N.button === 2, U = InteractionTrackingData.FLAGS, z = k ? U.RIGHT_DOWN : U.LEFT_DOWN, X = D !== void 0 && D.flags & z;\n      R ? (this.dispatchEvent(o, k ? \"rightup\" : \"mouseup\", e), X && (this.dispatchEvent(o, k ? \"rightclick\" : \"click\", e), $ = !0)) : X && this.dispatchEvent(o, k ? \"rightupoutside\" : \"mouseupoutside\", e), D && (k ? D.rightDown = !1 : D.leftDown = !1);\n    }\n    R ? (this.dispatchEvent(o, \"pointerup\", e), L && this.dispatchEvent(o, \"touchend\", e), D && ((!B || $) && this.dispatchEvent(o, \"pointertap\", e), L && (this.dispatchEvent(o, \"tap\", e), D.over = !1))) : D && (this.dispatchEvent(o, \"pointerupoutside\", e), L && this.dispatchEvent(o, \"touchendoutside\", e)), D && D.none && delete o.trackedPointers[M];\n  }, t.prototype.onPointerMove = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e);\n      (o[0].pointerType === \"mouse\" || o[0].pointerType === \"pen\") && (this._didMove = !0, this.cursor = null);\n      for (var R = o.length, N = 0; N < R; N++) {\n        var M = o[N], D = this.getInteractionDataForPointerId(M), L = this.configureInteractionEventForDOMEvent(this.eventData, M, D);\n        L.data.originalEvent = e, this.processInteractive(L, this.lastObjectRendered, this.processPointerMove, !0), this.emit(\"pointermove\", L), M.pointerType === \"touch\" && this.emit(\"touchmove\", L), (M.pointerType === \"mouse\" || M.pointerType === \"pen\") && this.emit(\"mousemove\", L);\n      }\n      o[0].pointerType === \"mouse\" && this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.processPointerMove = function(e, o, R) {\n    var N = e.data, M = N.pointerType === \"touch\", D = N.pointerType === \"mouse\" || N.pointerType === \"pen\";\n    D && this.processPointerOverOut(e, o, R), (!this.moveWhenInside || R) && (this.dispatchEvent(o, \"pointermove\", e), M && this.dispatchEvent(o, \"touchmove\", e), D && this.dispatchEvent(o, \"mousemove\", e));\n  }, t.prototype.onPointerOut = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e), R = o[0];\n      R.pointerType === \"mouse\" && (this.mouseOverRenderer = !1, this.setCursorMode(null));\n      var N = this.getInteractionDataForPointerId(R), M = this.configureInteractionEventForDOMEvent(this.eventData, R, N);\n      M.data.originalEvent = R, this.processInteractive(M, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit(\"pointerout\", M), R.pointerType === \"mouse\" || R.pointerType === \"pen\" ? this.emit(\"mouseout\", M) : this.releaseInteractionDataForPointerId(N.identifier);\n    }\n  }, t.prototype.processPointerOverOut = function(e, o, R) {\n    var N = e.data, M = e.data.identifier, D = N.pointerType === \"mouse\" || N.pointerType === \"pen\", L = o.trackedPointers[M];\n    R && !L && (L = o.trackedPointers[M] = new InteractionTrackingData(M)), L !== void 0 && (R && this.mouseOverRenderer ? (L.over || (L.over = !0, this.delayDispatchEvent(o, \"pointerover\", e), D && this.delayDispatchEvent(o, \"mouseover\", e)), D && this.cursor === null && (this.cursor = o.cursor)) : L.over && (L.over = !1, this.dispatchEvent(o, \"pointerout\", this.eventData), D && this.dispatchEvent(o, \"mouseout\", e), L.none && delete o.trackedPointers[M]));\n  }, t.prototype.onPointerOver = function(e) {\n    var o = this.normalizeToPointerData(e), R = o[0], N = this.getInteractionDataForPointerId(R), M = this.configureInteractionEventForDOMEvent(this.eventData, R, N);\n    M.data.originalEvent = R, R.pointerType === \"mouse\" && (this.mouseOverRenderer = !0), this.emit(\"pointerover\", M), (R.pointerType === \"mouse\" || R.pointerType === \"pen\") && this.emit(\"mouseover\", M);\n  }, t.prototype.getInteractionDataForPointerId = function(e) {\n    var o = e.pointerId, R;\n    return o === MOUSE_POINTER_ID || e.pointerType === \"mouse\" ? R = this.mouse : this.activeInteractionData[o] ? R = this.activeInteractionData[o] : (R = this.interactionDataPool.pop() || new InteractionData(), R.identifier = o, this.activeInteractionData[o] = R), R.copyEvent(e), R;\n  }, t.prototype.releaseInteractionDataForPointerId = function(e) {\n    var o = this.activeInteractionData[e];\n    o && (delete this.activeInteractionData[e], o.reset(), this.interactionDataPool.push(o));\n  }, t.prototype.configureInteractionEventForDOMEvent = function(e, o, R) {\n    return e.data = R, this.mapPositionToPoint(R.global, o.clientX, o.clientY), o.pointerType === \"touch\" && (o.globalX = R.global.x, o.globalY = R.global.y), R.originalEvent = o, e.reset(), e;\n  }, t.prototype.normalizeToPointerData = function(e) {\n    var o = [];\n    if (this.supportsTouchEvents && e instanceof TouchEvent)\n      for (var R = 0, N = e.changedTouches.length; R < N; R++) {\n        var M = e.changedTouches[R];\n        typeof M.button > \"u\" && (M.button = e.touches.length ? 1 : 0), typeof M.buttons > \"u\" && (M.buttons = e.touches.length ? 1 : 0), typeof M.isPrimary > \"u\" && (M.isPrimary = e.touches.length === 1 && e.type === \"touchstart\"), typeof M.width > \"u\" && (M.width = M.radiusX || 1), typeof M.height > \"u\" && (M.height = M.radiusY || 1), typeof M.tiltX > \"u\" && (M.tiltX = 0), typeof M.tiltY > \"u\" && (M.tiltY = 0), typeof M.pointerType > \"u\" && (M.pointerType = \"touch\"), typeof M.pointerId > \"u\" && (M.pointerId = M.identifier || 0), typeof M.pressure > \"u\" && (M.pressure = M.force || 0.5), typeof M.twist > \"u\" && (M.twist = 0), typeof M.tangentialPressure > \"u\" && (M.tangentialPressure = 0), typeof M.layerX > \"u\" && (M.layerX = M.offsetX = M.clientX), typeof M.layerY > \"u\" && (M.layerY = M.offsetY = M.clientY), M.isNormalized = !0, o.push(M);\n      }\n    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {\n      var D = e;\n      typeof D.isPrimary > \"u\" && (D.isPrimary = !0), typeof D.width > \"u\" && (D.width = 1), typeof D.height > \"u\" && (D.height = 1), typeof D.tiltX > \"u\" && (D.tiltX = 0), typeof D.tiltY > \"u\" && (D.tiltY = 0), typeof D.pointerType > \"u\" && (D.pointerType = \"mouse\"), typeof D.pointerId > \"u\" && (D.pointerId = MOUSE_POINTER_ID), typeof D.pressure > \"u\" && (D.pressure = 0.5), typeof D.twist > \"u\" && (D.twist = 0), typeof D.tangentialPressure > \"u\" && (D.tangentialPressure = 0), D.isNormalized = !0, o.push(D);\n    } else\n      o.push(e);\n    return o;\n  }, t.prototype.destroy = function() {\n    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;\n  }, t.extension = {\n    name: \"interaction\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, t;\n}(EventEmitter$5);\n/*!\n * @pixi/extract - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {\n  function n(t) {\n    this.renderer = t;\n  }\n  return n.prototype.image = function(t, e, o) {\n    var R = new Image();\n    return R.src = this.base64(t, e, o), R;\n  }, n.prototype.base64 = function(t, e, o) {\n    return this.canvas(t).toDataURL(e, o);\n  }, n.prototype.canvas = function(t, e) {\n    var o = this.renderer, R, N = !1, M, D = !1;\n    t && (t instanceof RenderTexture ? M = t : (M = this.renderer.generateTexture(t), D = !0)), M ? (R = M.baseTexture.resolution, e = e != null ? e : M.frame, N = !1, o.renderTexture.bind(M)) : (R = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), N = !0, o.renderTexture.bind(null));\n    var L = Math.round(e.width * R), B = Math.round(e.height * R), $ = new CanvasRenderTarget(L, B, 1), k = new Uint8Array(BYTES_PER_PIXEL * L * B), U = o.gl;\n    U.readPixels(Math.round(e.x * R), Math.round(e.y * R), L, B, U.RGBA, U.UNSIGNED_BYTE, k);\n    var z = $.context.getImageData(0, 0, L, B);\n    if (n.arrayPostDivide(k, z.data), $.context.putImageData(z, 0, 0), N) {\n      var X = new CanvasRenderTarget($.width, $.height, 1);\n      X.context.scale(1, -1), X.context.drawImage($.canvas, 0, -B), $.destroy(), $ = X;\n    }\n    return D && M.destroy(!0), $.canvas;\n  }, n.prototype.pixels = function(t, e) {\n    var o = this.renderer, R, N, M = !1;\n    t && (t instanceof RenderTexture ? N = t : (N = this.renderer.generateTexture(t), M = !0)), N ? (R = N.baseTexture.resolution, e = e != null ? e : N.frame, o.renderTexture.bind(N)) : (R = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), o.renderTexture.bind(null));\n    var D = Math.round(e.width * R), L = Math.round(e.height * R), B = new Uint8Array(BYTES_PER_PIXEL * D * L), $ = o.gl;\n    return $.readPixels(Math.round(e.x * R), Math.round(e.y * R), D, L, $.RGBA, $.UNSIGNED_BYTE, B), M && N.destroy(!0), n.arrayPostDivide(B, B), B;\n  }, n.prototype.destroy = function() {\n    this.renderer = null;\n  }, n.arrayPostDivide = function(t, e) {\n    for (var o = 0; o < t.length; o += 4) {\n      var R = e[o + 3] = t[o + 3];\n      R !== 0 ? (e[o] = Math.round(Math.min(t[o] * 255 / R, 255)), e[o + 1] = Math.round(Math.min(t[o + 1] * 255 / R, 255)), e[o + 2] = Math.round(Math.min(t[o + 2] * 255 / R, 255))) : (e[o] = t[o], e[o + 1] = t[o + 1], e[o + 2] = t[o + 2]);\n    }\n  }, n.extension = {\n    name: \"extract\",\n    type: ExtensionType.RendererPlugin\n  }, n;\n}();\n/*!\n * @pixi/compressed-textures - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/compressed-textures is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _a$2, INTERNAL_FORMATS;\n(function(n) {\n  n[n.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\", n[n.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\", n[n.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\", n[n.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\", n[n.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\", n[n.COMPRESSED_R11_EAC = 37488] = \"COMPRESSED_R11_EAC\", n[n.COMPRESSED_SIGNED_R11_EAC = 37489] = \"COMPRESSED_SIGNED_R11_EAC\", n[n.COMPRESSED_RG11_EAC = 37490] = \"COMPRESSED_RG11_EAC\", n[n.COMPRESSED_SIGNED_RG11_EAC = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\", n[n.COMPRESSED_RGB8_ETC2 = 37492] = \"COMPRESSED_RGB8_ETC2\", n[n.COMPRESSED_RGBA8_ETC2_EAC = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\", n[n.COMPRESSED_SRGB8_ETC2 = 37493] = \"COMPRESSED_SRGB8_ETC2\", n[n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\", n[n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\", n[n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\", n[n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\", n[n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\", n[n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\", n[n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\", n[n.COMPRESSED_RGB_ETC1_WEBGL = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\", n[n.COMPRESSED_RGB_ATC_WEBGL = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\", n[n.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\", n[n.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\";\n})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));\nvar INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$n = function(n, t) {\n  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$n(n, t);\n};\nfunction __extends$n(n, t) {\n  extendStatics$n(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction __awaiter(n, t, e, o) {\n  function R(N) {\n    return N instanceof e ? N : new e(function(M) {\n      M(N);\n    });\n  }\n  return new (e || (e = Promise))(function(N, M) {\n    function D($) {\n      try {\n        B(o.next($));\n      } catch (k) {\n        M(k);\n      }\n    }\n    function L($) {\n      try {\n        B(o.throw($));\n      } catch (k) {\n        M(k);\n      }\n    }\n    function B($) {\n      $.done ? N($.value) : R($.value).then(D, L);\n    }\n    B((o = o.apply(n, t || [])).next());\n  });\n}\nfunction __generator(n, t) {\n  var e = { label: 0, sent: function() {\n    if (N[0] & 1)\n      throw N[1];\n    return N[1];\n  }, trys: [], ops: [] }, o, R, N, M;\n  return M = { next: D(0), throw: D(1), return: D(2) }, typeof Symbol == \"function\" && (M[Symbol.iterator] = function() {\n    return this;\n  }), M;\n  function D(B) {\n    return function($) {\n      return L([B, $]);\n    };\n  }\n  function L(B) {\n    if (o)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; e; )\n      try {\n        if (o = 1, R && (N = B[0] & 2 ? R.return : B[0] ? R.throw || ((N = R.return) && N.call(R), 0) : R.next) && !(N = N.call(R, B[1])).done)\n          return N;\n        switch (R = 0, N && (B = [B[0] & 2, N.value]), B[0]) {\n          case 0:\n          case 1:\n            N = B;\n            break;\n          case 4:\n            return e.label++, { value: B[1], done: !1 };\n          case 5:\n            e.label++, R = B[1], B = [0];\n            continue;\n          case 7:\n            B = e.ops.pop(), e.trys.pop();\n            continue;\n          default:\n            if (N = e.trys, !(N = N.length > 0 && N[N.length - 1]) && (B[0] === 6 || B[0] === 2)) {\n              e = 0;\n              continue;\n            }\n            if (B[0] === 3 && (!N || B[1] > N[0] && B[1] < N[3])) {\n              e.label = B[1];\n              break;\n            }\n            if (B[0] === 6 && e.label < N[1]) {\n              e.label = N[1], N = B;\n              break;\n            }\n            if (N && e.label < N[2]) {\n              e.label = N[2], e.ops.push(B);\n              break;\n            }\n            N[2] && e.ops.pop(), e.trys.pop();\n            continue;\n        }\n        B = t.call(n, e);\n      } catch ($) {\n        B = [6, $], R = 0;\n      } finally {\n        o = N = 0;\n      }\n    if (B[0] & 5)\n      throw B[1];\n    return { value: B[0] ? B[1] : void 0, done: !0 };\n  }\n}\nvar BlobResource = function(n) {\n  __extends$n(t, n);\n  function t(e, o) {\n    o === void 0 && (o = { width: 1, height: 1, autoLoad: !0 });\n    var R = this, N, M;\n    return typeof e == \"string\" ? (N = e, M = new Uint8Array()) : (N = null, M = e), R = n.call(this, M, o) || this, R.origin = N, R.buffer = M ? new ViewableBuffer(M) : null, R.origin && o.autoLoad !== !1 && R.load(), M && M.length && (R.loaded = !0, R.onBlobLoaded(R.buffer.rawBinaryData)), R;\n  }\n  return t.prototype.onBlobLoaded = function(e) {\n  }, t.prototype.load = function() {\n    return __awaiter(this, void 0, Promise, function() {\n      var e, o, R;\n      return __generator(this, function(N) {\n        switch (N.label) {\n          case 0:\n            return [4, fetch(this.origin)];\n          case 1:\n            return e = N.sent(), [4, e.blob()];\n          case 2:\n            return o = N.sent(), [4, o.arrayBuffer()];\n          case 3:\n            return R = N.sent(), this.data = new Uint32Array(R), this.buffer = new ViewableBuffer(R), this.loaded = !0, this.onBlobLoaded(R), this.update(), [2, this];\n        }\n      });\n    });\n  }, t;\n}(BufferResource), CompressedTextureResource = function(n) {\n  __extends$n(t, n);\n  function t(e, o) {\n    var R = n.call(this, e, o) || this;\n    return R.format = o.format, R.levels = o.levels || 1, R._width = o.width, R._height = o.height, R._extension = t._formatToExtension(R.format), (o.levelBuffers || R.buffer) && (R._levelBuffers = o.levelBuffers || t._createLevelBuffers(\n      e instanceof Uint8Array ? e : R.buffer.uint8View,\n      R.format,\n      R.levels,\n      4,\n      4,\n      R.width,\n      R.height\n    )), R;\n  }\n  return t.prototype.upload = function(e, o, R) {\n    var N = e.gl, M = e.context.extensions[this._extension];\n    if (!M)\n      throw new Error(this._extension + \" textures are not supported on the current machine\");\n    if (!this._levelBuffers)\n      return !1;\n    for (var D = 0, L = this.levels; D < L; D++) {\n      var B = this._levelBuffers[D], $ = B.levelID, k = B.levelWidth, U = B.levelHeight, z = B.levelBuffer;\n      N.compressedTexImage2D(N.TEXTURE_2D, $, this.format, k, U, 0, z);\n    }\n    return !0;\n  }, t.prototype.onBlobLoaded = function() {\n    this._levelBuffers = t._createLevelBuffers(\n      this.buffer.uint8View,\n      this.format,\n      this.levels,\n      4,\n      4,\n      this.width,\n      this.height\n    );\n  }, t._formatToExtension = function(e) {\n    if (e >= 33776 && e <= 33779)\n      return \"s3tc\";\n    if (e >= 37488 && e <= 37497)\n      return \"etc\";\n    if (e >= 35840 && e <= 35843)\n      return \"pvrtc\";\n    if (e >= 36196)\n      return \"etc1\";\n    if (e >= 35986 && e <= 34798)\n      return \"atc\";\n    throw new Error(\"Invalid (compressed) texture format given!\");\n  }, t._createLevelBuffers = function(e, o, R, N, M, D, L) {\n    for (var B = new Array(R), $ = e.byteOffset, k = D, U = L, z = k + N - 1 & ~(N - 1), X = U + M - 1 & ~(M - 1), V = z * X * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o], W = 0; W < R; W++)\n      B[W] = {\n        levelID: W,\n        levelWidth: R > 1 ? k : z,\n        levelHeight: R > 1 ? U : X,\n        levelBuffer: new Uint8Array(e.buffer, $, V)\n      }, $ += V, k = k >> 1 || 1, U = U >> 1 || 1, z = k + N - 1 & ~(N - 1), X = U + M - 1 & ~(M - 1), V = z * X * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o];\n    return B;\n  }, t;\n}(BlobResource), CompressedTextureLoader = function() {\n  function n() {\n  }\n  return n.use = function(t, e) {\n    var o = t.data, R = this;\n    if (t.type === LoaderResource.TYPE.JSON && o && o.cacheID && o.textures) {\n      for (var N = o.textures, M = void 0, D = void 0, L = 0, B = N.length; L < B; L++) {\n        var $ = N[L], k = $.src, U = $.format;\n        if (U || (D = k), n.textureFormats[U]) {\n          M = k;\n          break;\n        }\n      }\n      if (M = M || D, !M) {\n        e(new Error(\"Cannot load compressed-textures in \" + t.url + \", make sure you provide a fallback\"));\n        return;\n      }\n      if (M === t.url) {\n        e(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n        return;\n      }\n      var z = {\n        crossOrigin: t.crossOrigin,\n        metadata: t.metadata.imageMetadata,\n        parentResource: t\n      }, X = url.resolve(t.url.replace(R.baseUrl, \"\"), M), V = o.cacheID;\n      R.add(V, X, z, function(W) {\n        if (W.error) {\n          e(W.error);\n          return;\n        }\n        var Y = W.texture, q = Y === void 0 ? null : Y, Z = W.textures, K = Z === void 0 ? {} : Z;\n        Object.assign(t, { texture: q, textures: K }), e();\n      });\n    } else\n      e();\n  }, Object.defineProperty(n, \"textureExtensions\", {\n    get: function() {\n      if (!n._textureExtensions) {\n        var t = document.createElement(\"canvas\"), e = t.getContext(\"webgl\");\n        if (!e)\n          return console.warn(\"WebGL not available for compressed textures. Silently failing.\"), {};\n        var o = {\n          s3tc: e.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n          s3tc_sRGB: e.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n          etc: e.getExtension(\"WEBGL_compressed_texture_etc\"),\n          etc1: e.getExtension(\"WEBGL_compressed_texture_etc1\"),\n          pvrtc: e.getExtension(\"WEBGL_compressed_texture_pvrtc\") || e.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n          atc: e.getExtension(\"WEBGL_compressed_texture_atc\"),\n          astc: e.getExtension(\"WEBGL_compressed_texture_astc\")\n        };\n        n._textureExtensions = o;\n      }\n      return n._textureExtensions;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"textureFormats\", {\n    get: function() {\n      if (!n._textureFormats) {\n        var t = n.textureExtensions;\n        n._textureFormats = {};\n        for (var e in t) {\n          var o = t[e];\n          !o || Object.assign(n._textureFormats, Object.getPrototypeOf(o));\n        }\n      }\n      return n._textureFormats;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.extension = ExtensionType.Loader, n;\n}();\nfunction registerCompressedTextures(n, t, e) {\n  var o = {\n    textures: {},\n    texture: null\n  };\n  if (!t)\n    return o;\n  var R = t.map(function(N) {\n    return new Texture(new BaseTexture(N, Object.assign({\n      mipmap: MIPMAP_MODES$5.OFF,\n      alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA\n    }, e)));\n  });\n  return R.forEach(function(N, M) {\n    var D = N.baseTexture, L = n + \"-\" + (M + 1);\n    BaseTexture.addToCache(D, L), Texture.addToCache(N, L), M === 0 && (BaseTexture.addToCache(D, n), Texture.addToCache(N, n), o.texture = N), o.textures[L] = N;\n  }), o;\n}\nvar _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, DXGI_FORMAT;\n(function(n) {\n  n[n.DXGI_FORMAT_UNKNOWN = 0] = \"DXGI_FORMAT_UNKNOWN\", n[n.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\", n[n.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\", n[n.DXGI_FORMAT_R32G32B32A32_UINT = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\", n[n.DXGI_FORMAT_R32G32B32A32_SINT = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\", n[n.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\", n[n.DXGI_FORMAT_R32G32B32_FLOAT = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\", n[n.DXGI_FORMAT_R32G32B32_UINT = 7] = \"DXGI_FORMAT_R32G32B32_UINT\", n[n.DXGI_FORMAT_R32G32B32_SINT = 8] = \"DXGI_FORMAT_R32G32B32_SINT\", n[n.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\", n[n.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\", n[n.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\", n[n.DXGI_FORMAT_R16G16B16A16_UINT = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\", n[n.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\", n[n.DXGI_FORMAT_R16G16B16A16_SINT = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\", n[n.DXGI_FORMAT_R32G32_TYPELESS = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\", n[n.DXGI_FORMAT_R32G32_FLOAT = 16] = \"DXGI_FORMAT_R32G32_FLOAT\", n[n.DXGI_FORMAT_R32G32_UINT = 17] = \"DXGI_FORMAT_R32G32_UINT\", n[n.DXGI_FORMAT_R32G32_SINT = 18] = \"DXGI_FORMAT_R32G32_SINT\", n[n.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\", n[n.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\", n[n.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\", n[n.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\", n[n.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\", n[n.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\", n[n.DXGI_FORMAT_R10G10B10A2_UINT = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\", n[n.DXGI_FORMAT_R11G11B10_FLOAT = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\", n[n.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\", n[n.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\", n[n.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\", n[n.DXGI_FORMAT_R8G8B8A8_UINT = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\", n[n.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\", n[n.DXGI_FORMAT_R8G8B8A8_SINT = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\", n[n.DXGI_FORMAT_R16G16_TYPELESS = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\", n[n.DXGI_FORMAT_R16G16_FLOAT = 34] = \"DXGI_FORMAT_R16G16_FLOAT\", n[n.DXGI_FORMAT_R16G16_UNORM = 35] = \"DXGI_FORMAT_R16G16_UNORM\", n[n.DXGI_FORMAT_R16G16_UINT = 36] = \"DXGI_FORMAT_R16G16_UINT\", n[n.DXGI_FORMAT_R16G16_SNORM = 37] = \"DXGI_FORMAT_R16G16_SNORM\", n[n.DXGI_FORMAT_R16G16_SINT = 38] = \"DXGI_FORMAT_R16G16_SINT\", n[n.DXGI_FORMAT_R32_TYPELESS = 39] = \"DXGI_FORMAT_R32_TYPELESS\", n[n.DXGI_FORMAT_D32_FLOAT = 40] = \"DXGI_FORMAT_D32_FLOAT\", n[n.DXGI_FORMAT_R32_FLOAT = 41] = \"DXGI_FORMAT_R32_FLOAT\", n[n.DXGI_FORMAT_R32_UINT = 42] = \"DXGI_FORMAT_R32_UINT\", n[n.DXGI_FORMAT_R32_SINT = 43] = \"DXGI_FORMAT_R32_SINT\", n[n.DXGI_FORMAT_R24G8_TYPELESS = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\", n[n.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\", n[n.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\", n[n.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\", n[n.DXGI_FORMAT_R8G8_TYPELESS = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\", n[n.DXGI_FORMAT_R8G8_UNORM = 49] = \"DXGI_FORMAT_R8G8_UNORM\", n[n.DXGI_FORMAT_R8G8_UINT = 50] = \"DXGI_FORMAT_R8G8_UINT\", n[n.DXGI_FORMAT_R8G8_SNORM = 51] = \"DXGI_FORMAT_R8G8_SNORM\", n[n.DXGI_FORMAT_R8G8_SINT = 52] = \"DXGI_FORMAT_R8G8_SINT\", n[n.DXGI_FORMAT_R16_TYPELESS = 53] = \"DXGI_FORMAT_R16_TYPELESS\", n[n.DXGI_FORMAT_R16_FLOAT = 54] = \"DXGI_FORMAT_R16_FLOAT\", n[n.DXGI_FORMAT_D16_UNORM = 55] = \"DXGI_FORMAT_D16_UNORM\", n[n.DXGI_FORMAT_R16_UNORM = 56] = \"DXGI_FORMAT_R16_UNORM\", n[n.DXGI_FORMAT_R16_UINT = 57] = \"DXGI_FORMAT_R16_UINT\", n[n.DXGI_FORMAT_R16_SNORM = 58] = \"DXGI_FORMAT_R16_SNORM\", n[n.DXGI_FORMAT_R16_SINT = 59] = \"DXGI_FORMAT_R16_SINT\", n[n.DXGI_FORMAT_R8_TYPELESS = 60] = \"DXGI_FORMAT_R8_TYPELESS\", n[n.DXGI_FORMAT_R8_UNORM = 61] = \"DXGI_FORMAT_R8_UNORM\", n[n.DXGI_FORMAT_R8_UINT = 62] = \"DXGI_FORMAT_R8_UINT\", n[n.DXGI_FORMAT_R8_SNORM = 63] = \"DXGI_FORMAT_R8_SNORM\", n[n.DXGI_FORMAT_R8_SINT = 64] = \"DXGI_FORMAT_R8_SINT\", n[n.DXGI_FORMAT_A8_UNORM = 65] = \"DXGI_FORMAT_A8_UNORM\", n[n.DXGI_FORMAT_R1_UNORM = 66] = \"DXGI_FORMAT_R1_UNORM\", n[n.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\", n[n.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\", n[n.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\", n[n.DXGI_FORMAT_BC1_TYPELESS = 70] = \"DXGI_FORMAT_BC1_TYPELESS\", n[n.DXGI_FORMAT_BC1_UNORM = 71] = \"DXGI_FORMAT_BC1_UNORM\", n[n.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\", n[n.DXGI_FORMAT_BC2_TYPELESS = 73] = \"DXGI_FORMAT_BC2_TYPELESS\", n[n.DXGI_FORMAT_BC2_UNORM = 74] = \"DXGI_FORMAT_BC2_UNORM\", n[n.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\", n[n.DXGI_FORMAT_BC3_TYPELESS = 76] = \"DXGI_FORMAT_BC3_TYPELESS\", n[n.DXGI_FORMAT_BC3_UNORM = 77] = \"DXGI_FORMAT_BC3_UNORM\", n[n.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\", n[n.DXGI_FORMAT_BC4_TYPELESS = 79] = \"DXGI_FORMAT_BC4_TYPELESS\", n[n.DXGI_FORMAT_BC4_UNORM = 80] = \"DXGI_FORMAT_BC4_UNORM\", n[n.DXGI_FORMAT_BC4_SNORM = 81] = \"DXGI_FORMAT_BC4_SNORM\", n[n.DXGI_FORMAT_BC5_TYPELESS = 82] = \"DXGI_FORMAT_BC5_TYPELESS\", n[n.DXGI_FORMAT_BC5_UNORM = 83] = \"DXGI_FORMAT_BC5_UNORM\", n[n.DXGI_FORMAT_BC5_SNORM = 84] = \"DXGI_FORMAT_BC5_SNORM\", n[n.DXGI_FORMAT_B5G6R5_UNORM = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\", n[n.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\", n[n.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\", n[n.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\", n[n.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\", n[n.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\", n[n.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\", n[n.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\", n[n.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\", n[n.DXGI_FORMAT_BC6H_TYPELESS = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\", n[n.DXGI_FORMAT_BC6H_UF16 = 95] = \"DXGI_FORMAT_BC6H_UF16\", n[n.DXGI_FORMAT_BC6H_SF16 = 96] = \"DXGI_FORMAT_BC6H_SF16\", n[n.DXGI_FORMAT_BC7_TYPELESS = 97] = \"DXGI_FORMAT_BC7_TYPELESS\", n[n.DXGI_FORMAT_BC7_UNORM = 98] = \"DXGI_FORMAT_BC7_UNORM\", n[n.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\", n[n.DXGI_FORMAT_AYUV = 100] = \"DXGI_FORMAT_AYUV\", n[n.DXGI_FORMAT_Y410 = 101] = \"DXGI_FORMAT_Y410\", n[n.DXGI_FORMAT_Y416 = 102] = \"DXGI_FORMAT_Y416\", n[n.DXGI_FORMAT_NV12 = 103] = \"DXGI_FORMAT_NV12\", n[n.DXGI_FORMAT_P010 = 104] = \"DXGI_FORMAT_P010\", n[n.DXGI_FORMAT_P016 = 105] = \"DXGI_FORMAT_P016\", n[n.DXGI_FORMAT_420_OPAQUE = 106] = \"DXGI_FORMAT_420_OPAQUE\", n[n.DXGI_FORMAT_YUY2 = 107] = \"DXGI_FORMAT_YUY2\", n[n.DXGI_FORMAT_Y210 = 108] = \"DXGI_FORMAT_Y210\", n[n.DXGI_FORMAT_Y216 = 109] = \"DXGI_FORMAT_Y216\", n[n.DXGI_FORMAT_NV11 = 110] = \"DXGI_FORMAT_NV11\", n[n.DXGI_FORMAT_AI44 = 111] = \"DXGI_FORMAT_AI44\", n[n.DXGI_FORMAT_IA44 = 112] = \"DXGI_FORMAT_IA44\", n[n.DXGI_FORMAT_P8 = 113] = \"DXGI_FORMAT_P8\", n[n.DXGI_FORMAT_A8P8 = 114] = \"DXGI_FORMAT_A8P8\", n[n.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\", n[n.DXGI_FORMAT_P208 = 116] = \"DXGI_FORMAT_P208\", n[n.DXGI_FORMAT_V208 = 117] = \"DXGI_FORMAT_V208\", n[n.DXGI_FORMAT_V408 = 118] = \"DXGI_FORMAT_V408\", n[n.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\", n[n.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\", n[n.DXGI_FORMAT_FORCE_UINT = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(DXGI_FORMAT || (DXGI_FORMAT = {}));\nvar D3D10_RESOURCE_DIMENSION;\n(function(n) {\n  n[n.DDS_DIMENSION_TEXTURE1D = 2] = \"DDS_DIMENSION_TEXTURE1D\", n[n.DDS_DIMENSION_TEXTURE2D = 3] = \"DDS_DIMENSION_TEXTURE2D\", n[n.DDS_DIMENSION_TEXTURE3D = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));\nvar PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);\nfunction parseDDS(n) {\n  var t = new Uint32Array(n), e = t[0];\n  if (e !== DDS_MAGIC)\n    throw new Error(\"Invalid DDS file magic word\");\n  var o = new Uint32Array(n, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), R = o[DDS_FIELDS.HEIGHT], N = o[DDS_FIELDS.WIDTH], M = o[DDS_FIELDS.MIPMAP_COUNT], D = new Uint32Array(n, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), L = D[PF_FLAGS];\n  if (L & DDPF_FOURCC) {\n    var B = D[DDS_PF_FIELDS.FOURCC];\n    if (B !== FOURCC_DX10) {\n      var $ = FOURCC_TO_FORMAT[B], k = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, U = new Uint8Array(n, k), z = new CompressedTextureResource(U, {\n        format: $,\n        width: N,\n        height: R,\n        levels: M\n      });\n      return [z];\n    }\n    var X = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint32Array(t.buffer, X, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), W = V[DDS_DX10_FIELDS.DXGI_FORMAT], Y = V[DDS_DX10_FIELDS.RESOURCE_DIMENSION], q = V[DDS_DX10_FIELDS.MISC_FLAG], Z = V[DDS_DX10_FIELDS.ARRAY_SIZE], K = DXGI_TO_FORMAT[W];\n    if (K === void 0)\n      throw new Error(\"DDSParser cannot parse texture data with DXGI format \" + W);\n    if (q === DDS_RESOURCE_MISC_TEXTURECUBE)\n      throw new Error(\"DDSParser does not support cubemap textures\");\n    if (Y === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n      throw new Error(\"DDSParser does not supported 3D texture data\");\n    var Q = new Array(), J = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (Z === 1)\n      Q.push(new Uint8Array(n, J));\n    else {\n      for (var rt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[K], tt = 0, nt = N, st = R, ut = 0; ut < M; ut++) {\n        var ct = Math.max(1, nt + 3 & -4), dt = Math.max(1, st + 3 & -4), Et = ct * dt * rt;\n        tt += Et, nt = nt >>> 1, st = st >>> 1;\n      }\n      for (var vt = J, ut = 0; ut < Z; ut++)\n        Q.push(new Uint8Array(n, vt, tt)), vt += tt;\n    }\n    return Q.map(function(_t) {\n      return new CompressedTextureResource(_t, {\n        format: K,\n        width: N,\n        height: R,\n        levels: M\n      });\n    });\n  }\n  throw L & DDPF_RGB ? new Error(\"DDSParser does not support uncompressed texture data.\") : L & DDPF_YUV ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : L & DDPF_LUMINANCE ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : L & DDPF_ALPHA ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nvar _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$5.UNSIGNED_BYTE] = 1, _a$3[TYPES$5.UNSIGNED_SHORT] = 2, _a$3[TYPES$5.INT] = 4, _a$3[TYPES$5.UNSIGNED_INT] = 4, _a$3[TYPES$5.FLOAT] = 4, _a$3[TYPES$5.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$5.RGBA] = 4, _b[FORMATS$5.RGB] = 3, _b[FORMATS$5.RG] = 2, _b[FORMATS$5.RED] = 1, _b[FORMATS$5.LUMINANCE] = 1, _b[FORMATS$5.LUMINANCE_ALPHA] = 2, _b[FORMATS$5.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_6_5] = 2, _c);\nfunction parseKTX(n, t, e) {\n  e === void 0 && (e = !1);\n  var o = new DataView(t);\n  if (!validate(n, o))\n    return null;\n  var R = o.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, N = o.getUint32(KTX_FIELDS.GL_TYPE, R), M = o.getUint32(KTX_FIELDS.GL_FORMAT, R), D = o.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, R), L = o.getUint32(KTX_FIELDS.PIXEL_WIDTH, R), B = o.getUint32(KTX_FIELDS.PIXEL_HEIGHT, R) || 1, $ = o.getUint32(KTX_FIELDS.PIXEL_DEPTH, R) || 1, k = o.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, R) || 1, U = o.getUint32(KTX_FIELDS.NUMBER_OF_FACES, R), z = o.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, R), X = o.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, R);\n  if (B === 0 || $ !== 1)\n    throw new Error(\"Only 2D textures are supported\");\n  if (U !== 1)\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  if (k !== 1)\n    throw new Error(\"WebGL does not support array textures\");\n  var V = 4, W = 4, Y = L + 3 & -4, q = B + 3 & -4, Z = new Array(k), K = L * B;\n  N === 0 && (K = Y * q);\n  var Q;\n  if (N !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[N] ? Q = TYPES_TO_BYTES_PER_COMPONENT[N] * FORMATS_TO_COMPONENTS[M] : Q = TYPES_TO_BYTES_PER_PIXEL[N] : Q = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[D], Q === void 0)\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  for (var J = e ? parseKvData(o, X, R) : null, rt = K * Q, tt = rt, nt = L, st = B, ut = Y, ct = q, dt = FILE_HEADER_SIZE + X, Et = 0; Et < z; Et++) {\n    for (var vt = o.getUint32(dt, R), _t = dt + 4, St = 0; St < k; St++) {\n      var Ft = Z[St];\n      Ft || (Ft = Z[St] = new Array(z)), Ft[Et] = {\n        levelID: Et,\n        levelWidth: z > 1 || N !== 0 ? nt : ut,\n        levelHeight: z > 1 || N !== 0 ? st : ct,\n        levelBuffer: new Uint8Array(t, _t, tt)\n      }, _t += tt;\n    }\n    dt += vt + 4, dt = dt % 4 !== 0 ? dt + 4 - dt % 4 : dt, nt = nt >> 1 || 1, st = st >> 1 || 1, ut = nt + V - 1 & ~(V - 1), ct = st + W - 1 & ~(W - 1), tt = ut * ct * Q;\n  }\n  return N !== 0 ? {\n    uncompressed: Z.map(function(mt) {\n      var ht = mt[0].levelBuffer, pt = !1;\n      return N === TYPES$5.FLOAT ? ht = new Float32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4) : N === TYPES$5.UNSIGNED_INT ? (pt = !0, ht = new Uint32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4)) : N === TYPES$5.INT && (pt = !0, ht = new Int32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4)), {\n        resource: new BufferResource(ht, {\n          width: mt[0].levelWidth,\n          height: mt[0].levelHeight\n        }),\n        type: N,\n        format: pt ? convertFormatToInteger(M) : M\n      };\n    }),\n    kvData: J\n  } : {\n    compressed: Z.map(function(mt) {\n      return new CompressedTextureResource(null, {\n        format: D,\n        width: L,\n        height: B,\n        levels: z,\n        levelBuffers: mt\n      });\n    }),\n    kvData: J\n  };\n}\nfunction validate(n, t) {\n  for (var e = 0; e < FILE_IDENTIFIER.length; e++)\n    if (t.getUint8(e) !== FILE_IDENTIFIER[e])\n      return console.error(n + \" is not a valid *.ktx file!\"), !1;\n  return !0;\n}\nfunction convertFormatToInteger(n) {\n  switch (n) {\n    case FORMATS$5.RGBA:\n      return FORMATS$5.RGBA_INTEGER;\n    case FORMATS$5.RGB:\n      return FORMATS$5.RGB_INTEGER;\n    case FORMATS$5.RG:\n      return FORMATS$5.RG_INTEGER;\n    case FORMATS$5.RED:\n      return FORMATS$5.RED_INTEGER;\n    default:\n      return n;\n  }\n}\nfunction parseKvData(n, t, e) {\n  for (var o = /* @__PURE__ */ new Map(), R = 0; R < t; ) {\n    var N = n.getUint32(FILE_HEADER_SIZE + R, e), M = FILE_HEADER_SIZE + R + 4, D = 3 - (N + 3) % 4;\n    if (N === 0 || N > t - R) {\n      console.error(\"KTXLoader: keyAndValueByteSize out of bounds\");\n      break;\n    }\n    for (var L = 0; L < N && n.getUint8(M + L) !== 0; L++)\n      ;\n    if (L === -1) {\n      console.error(\"KTXLoader: Failed to find null byte terminating kvData key\");\n      break;\n    }\n    var B = new TextDecoder().decode(new Uint8Array(n.buffer, M, L)), $ = new DataView(n.buffer, M + L + 1, N - L - 1);\n    o.set(B, $), R += 4 + N + D;\n  }\n  return o;\n}\nLoaderResource.setExtensionXhrType(\"dds\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar DDSLoader = function() {\n  function n() {\n  }\n  return n.use = function(t, e) {\n    if (t.extension === \"dds\" && t.data)\n      try {\n        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));\n      } catch (o) {\n        e(o);\n        return;\n      }\n    e();\n  }, n.extension = ExtensionType.Loader, n;\n}();\nLoaderResource.setExtensionXhrType(\"ktx\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar KTXLoader = function() {\n  function n() {\n  }\n  return n.use = function(t, e) {\n    if (t.extension === \"ktx\" && t.data)\n      try {\n        var o = t.name || t.url, R = parseKTX(o, t.data, this.loadKeyValueData), N = R.compressed, M = R.uncompressed, D = R.kvData;\n        if (N) {\n          var L = registerCompressedTextures(o, N, t.metadata);\n          if (D && L.textures)\n            for (var B in L.textures)\n              L.textures[B].baseTexture.ktxKeyValueData = D;\n          Object.assign(t, L);\n        } else if (M) {\n          var $ = {};\n          M.forEach(function(k, U) {\n            var z = new Texture(new BaseTexture(k.resource, {\n              mipmap: MIPMAP_MODES$5.OFF,\n              alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA,\n              type: k.type,\n              format: k.format\n            })), X = o + \"-\" + (U + 1);\n            D && (z.baseTexture.ktxKeyValueData = D), BaseTexture.addToCache(z.baseTexture, X), Texture.addToCache(z, X), U === 0 && ($[o] = z, BaseTexture.addToCache(z.baseTexture, o), Texture.addToCache(z, o)), $[X] = z;\n          }), Object.assign(t, { textures: $ });\n        }\n      } catch (k) {\n        e(k);\n        return;\n      }\n    e();\n  }, n.extension = ExtensionType.Loader, n.loadKeyValueData = !1, n;\n}();\n/*!\n * @pixi/particle-container - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/particle-container is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$m = function(n, t) {\n  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$m(n, t);\n};\nfunction __extends$m(n, t) {\n  extendStatics$m(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\n(function(n) {\n  __extends$m(t, n);\n  function t(e, o, R, N) {\n    e === void 0 && (e = 1500), R === void 0 && (R = 16384), N === void 0 && (N = !1);\n    var M = n.call(this) || this, D = 16384;\n    return R > D && (R = D), M._properties = [!1, !0, !1, !1, !1], M._maxSize = e, M._batchSize = R, M._buffers = null, M._bufferUpdateIDs = [], M._updateID = 0, M.interactiveChildren = !1, M.blendMode = BLEND_MODES$5.NORMAL, M.autoResize = N, M.roundPixels = !0, M.baseTexture = null, M.setProperties(o), M._tint = 0, M.tintRgb = new Float32Array(4), M.tint = 16777215, M;\n  }\n  return t.prototype.setProperties = function(e) {\n    e && (this._properties[0] = \"vertices\" in e || \"scale\" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = \"position\" in e ? !!e.position : this._properties[1], this._properties[2] = \"rotation\" in e ? !!e.rotation : this._properties[2], this._properties[3] = \"uvs\" in e ? !!e.uvs : this._properties[3], this._properties[4] = \"tint\" in e || \"alpha\" in e ? !!e.tint || !!e.alpha : this._properties[4]);\n  }, t.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, hex2rgb(e, this.tintRgb);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.render = function(e) {\n    var o = this;\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", function() {\n      return o.onChildrenChange(0);\n    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));\n  }, t.prototype.onChildrenChange = function(e) {\n    for (var o = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < o; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[o] = ++this._updateID;\n  }, t.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var e = 0; e < this._buffers.length; ++e)\n        this._buffers[e].destroy();\n      this._buffers = null;\n    }\n  }, t.prototype.destroy = function(e) {\n    n.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }, t;\n})(Container);\nvar ParticleBuffer = function() {\n  function n(t, e, o) {\n    this.geometry = new Geometry(), this.indexBuffer = null, this.size = o, this.dynamicProperties = [], this.staticProperties = [];\n    for (var R = 0; R < t.length; ++R) {\n      var N = t[R];\n      N = {\n        attributeName: N.attributeName,\n        size: N.size,\n        uploadFunction: N.uploadFunction,\n        type: N.type || TYPES$5.FLOAT,\n        offset: N.offset\n      }, e[R] ? this.dynamicProperties.push(N) : this.staticProperties.push(N);\n    }\n    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n  }\n  return n.prototype.initBuffers = function() {\n    var t = this.geometry, e = 0;\n    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;\n    for (var o = 0; o < this.dynamicProperties.length; ++o) {\n      var R = this.dynamicProperties[o];\n      R.offset = e, e += R.size, this.dynamicStride += R.size;\n    }\n    var N = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(N), this.dynamicDataUint32 = new Uint32Array(N), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);\n    var M = 0;\n    this.staticStride = 0;\n    for (var o = 0; o < this.staticProperties.length; ++o) {\n      var R = this.staticProperties[o];\n      R.offset = M, M += R.size, this.staticStride += R.size;\n    }\n    var D = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(D), this.staticDataUint32 = new Uint32Array(D), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);\n    for (var o = 0; o < this.dynamicProperties.length; ++o) {\n      var R = this.dynamicProperties[o];\n      t.addAttribute(R.attributeName, this.dynamicBuffer, 0, R.type === TYPES$5.UNSIGNED_BYTE, R.type, this.dynamicStride * 4, R.offset * 4);\n    }\n    for (var o = 0; o < this.staticProperties.length; ++o) {\n      var R = this.staticProperties[o];\n      t.addAttribute(R.attributeName, this.staticBuffer, 0, R.type === TYPES$5.UNSIGNED_BYTE, R.type, this.staticStride * 4, R.offset * 4);\n    }\n  }, n.prototype.uploadDynamic = function(t, e, o) {\n    for (var R = 0; R < this.dynamicProperties.length; R++) {\n      var N = this.dynamicProperties[R];\n      N.uploadFunction(t, e, o, N.type === TYPES$5.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, N.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  }, n.prototype.uploadStatic = function(t, e, o) {\n    for (var R = 0; R < this.staticProperties.length; R++) {\n      var N = this.staticProperties[R];\n      N.uploadFunction(t, e, o, N.type === TYPES$5.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, N.offset);\n    }\n    this.staticBuffer._updateID++;\n  }, n.prototype.destroy = function() {\n    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n  }, n;\n}(), fragment$6 = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`, vertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`, ParticleRenderer = function(n) {\n  __extends$m(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return o.shader = null, o.properties = null, o.tempMatrix = new Matrix(), o.properties = [\n      {\n        attributeName: \"aVertexPosition\",\n        size: 2,\n        uploadFunction: o.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: \"aPositionCoord\",\n        size: 2,\n        uploadFunction: o.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: \"aRotation\",\n        size: 1,\n        uploadFunction: o.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: \"aTextureCoord\",\n        size: 2,\n        uploadFunction: o.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: \"aColor\",\n        size: 1,\n        type: TYPES$5.UNSIGNED_BYTE,\n        uploadFunction: o.uploadTint,\n        offset: 0\n      }\n    ], o.shader = Shader.from(vertex$3, fragment$6, {}), o.state = State.for2d(), o;\n  }\n  return t.prototype.render = function(e) {\n    var o = e.children, R = e._maxSize, N = e._batchSize, M = this.renderer, D = o.length;\n    if (D !== 0) {\n      D > R && !e.autoResize && (D = R);\n      var L = e._buffers;\n      L || (L = e._buffers = this.generateBuffers(e));\n      var B = o[0]._texture.baseTexture, $ = B.alphaMode > 0;\n      this.state.blendMode = correctBlendMode(e.blendMode, $), M.state.set(this.state);\n      var k = M.gl, U = e.worldTransform.copyTo(this.tempMatrix);\n      U.prepend(M.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = U.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, $), this.shader.uniforms.uSampler = B, this.renderer.shader.bind(this.shader);\n      for (var z = !1, X = 0, V = 0; X < D; X += N, V += 1) {\n        var W = D - X;\n        W > N && (W = N), V >= L.length && L.push(this._generateOneMoreBuffer(e));\n        var Y = L[V];\n        Y.uploadDynamic(o, X, W);\n        var q = e._bufferUpdateIDs[V] || 0;\n        z = z || Y._updateID < q, z && (Y._updateID = e._updateID, Y.uploadStatic(o, X, W)), M.geometry.bind(Y.geometry), k.drawElements(k.TRIANGLES, W * 6, k.UNSIGNED_SHORT, 0);\n      }\n    }\n  }, t.prototype.generateBuffers = function(e) {\n    for (var o = [], R = e._maxSize, N = e._batchSize, M = e._properties, D = 0; D < R; D += N)\n      o.push(new ParticleBuffer(this.properties, M, N));\n    return o;\n  }, t.prototype._generateOneMoreBuffer = function(e) {\n    var o = e._batchSize, R = e._properties;\n    return new ParticleBuffer(this.properties, R, o);\n  }, t.prototype.uploadVertices = function(e, o, R, N, M, D) {\n    for (var L = 0, B = 0, $ = 0, k = 0, U = 0; U < R; ++U) {\n      var z = e[o + U], X = z._texture, V = z.scale.x, W = z.scale.y, Y = X.trim, q = X.orig;\n      Y ? (B = Y.x - z.anchor.x * q.width, L = B + Y.width, k = Y.y - z.anchor.y * q.height, $ = k + Y.height) : (L = q.width * (1 - z.anchor.x), B = q.width * -z.anchor.x, $ = q.height * (1 - z.anchor.y), k = q.height * -z.anchor.y), N[D] = B * V, N[D + 1] = k * W, N[D + M] = L * V, N[D + M + 1] = k * W, N[D + M * 2] = L * V, N[D + M * 2 + 1] = $ * W, N[D + M * 3] = B * V, N[D + M * 3 + 1] = $ * W, D += M * 4;\n    }\n  }, t.prototype.uploadPosition = function(e, o, R, N, M, D) {\n    for (var L = 0; L < R; L++) {\n      var B = e[o + L].position;\n      N[D] = B.x, N[D + 1] = B.y, N[D + M] = B.x, N[D + M + 1] = B.y, N[D + M * 2] = B.x, N[D + M * 2 + 1] = B.y, N[D + M * 3] = B.x, N[D + M * 3 + 1] = B.y, D += M * 4;\n    }\n  }, t.prototype.uploadRotation = function(e, o, R, N, M, D) {\n    for (var L = 0; L < R; L++) {\n      var B = e[o + L].rotation;\n      N[D] = B, N[D + M] = B, N[D + M * 2] = B, N[D + M * 3] = B, D += M * 4;\n    }\n  }, t.prototype.uploadUvs = function(e, o, R, N, M, D) {\n    for (var L = 0; L < R; ++L) {\n      var B = e[o + L]._texture._uvs;\n      B ? (N[D] = B.x0, N[D + 1] = B.y0, N[D + M] = B.x1, N[D + M + 1] = B.y1, N[D + M * 2] = B.x2, N[D + M * 2 + 1] = B.y2, N[D + M * 3] = B.x3, N[D + M * 3 + 1] = B.y3, D += M * 4) : (N[D] = 0, N[D + 1] = 0, N[D + M] = 0, N[D + M + 1] = 0, N[D + M * 2] = 0, N[D + M * 2 + 1] = 0, N[D + M * 3] = 0, N[D + M * 3 + 1] = 0, D += M * 4);\n    }\n  }, t.prototype.uploadTint = function(e, o, R, N, M, D) {\n    for (var L = 0; L < R; ++L) {\n      var B = e[o + L], $ = B._texture.baseTexture.alphaMode > 0, k = B.alpha, U = k < 1 && $ ? premultiplyTint(B._tintRGB, k) : B._tintRGB + (k * 255 << 24);\n      N[D] = U, N[D + M] = U, N[D + M * 2] = U, N[D + M * 3] = U, D += M * 4;\n    }\n  }, t.prototype.destroy = function() {\n    n.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n  }, t.extension = {\n    name: \"particle\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\n/*!\n * @pixi/graphics - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar LINE_JOIN;\n(function(n) {\n  n.MITER = \"miter\", n.BEVEL = \"bevel\", n.ROUND = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\nvar LINE_CAP;\n(function(n) {\n  n.BUTT = \"butt\", n.ROUND = \"round\", n.SQUARE = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\nvar GRAPHICS_CURVES = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(n, t) {\n    if (t === void 0 && (t = 20), !this.adaptive || !n || isNaN(n))\n      return t;\n    var e = Math.ceil(n / this.maxLength);\n    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;\n  }\n}, FillStyle = function() {\n  function n() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();\n  }\n  return n.prototype.clone = function() {\n    var t = new n();\n    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;\n  }, n.prototype.reset = function() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;\n  }, n.prototype.destroy = function() {\n    this.texture = null, this.matrix = null;\n  }, n;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$l = function(n, t) {\n  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$l(n, t);\n};\nfunction __extends$l(n, t) {\n  extendStatics$l(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction fixOrientation(n, t) {\n  var e, o;\n  t === void 0 && (t = !1);\n  var R = n.length;\n  if (!(R < 6)) {\n    for (var N = 0, M = 0, D = n[R - 2], L = n[R - 1]; M < R; M += 2) {\n      var B = n[M], $ = n[M + 1];\n      N += (B - D) * ($ + L), D = B, L = $;\n    }\n    if (!t && N > 0 || t && N <= 0)\n      for (var k = R / 2, M = k + k % 2; M < R; M += 2) {\n        var U = R - M - 2, z = R - M - 1, X = M, V = M + 1;\n        e = [n[X], n[U]], n[U] = e[0], n[X] = e[1], o = [n[V], n[z]], n[z] = o[0], n[V] = o[1];\n      }\n  }\n}\nvar buildPoly = {\n  build: function(n) {\n    n.points = n.shape.points.slice();\n  },\n  triangulate: function(n, t) {\n    var e = n.points, o = n.holes, R = t.points, N = t.indices;\n    if (e.length >= 6) {\n      fixOrientation(e, !1);\n      for (var M = [], D = 0; D < o.length; D++) {\n        var L = o[D];\n        fixOrientation(L.points, !0), M.push(e.length / 2), e = e.concat(L.points);\n      }\n      var B = earcut$1.exports(e, M, 2);\n      if (!B)\n        return;\n      for (var $ = R.length / 2, D = 0; D < B.length; D += 3)\n        N.push(B[D] + $), N.push(B[D + 1] + $), N.push(B[D + 2] + $);\n      for (var D = 0; D < e.length; D++)\n        R.push(e[D]);\n    }\n  }\n}, buildCircle = {\n  build: function(n) {\n    var t = n.points, e, o, R, N, M, D;\n    if (n.type === SHAPES.CIRC) {\n      var L = n.shape;\n      e = L.x, o = L.y, M = D = L.radius, R = N = 0;\n    } else if (n.type === SHAPES.ELIP) {\n      var B = n.shape;\n      e = B.x, o = B.y, M = B.width, D = B.height, R = N = 0;\n    } else {\n      var $ = n.shape, k = $.width / 2, U = $.height / 2;\n      e = $.x + k, o = $.y + U, M = D = Math.max(0, Math.min($.radius, Math.min(k, U))), R = k - M, N = U - D;\n    }\n    if (!(M >= 0 && D >= 0 && R >= 0 && N >= 0)) {\n      t.length = 0;\n      return;\n    }\n    var z = Math.ceil(2.3 * Math.sqrt(M + D)), X = z * 8 + (R ? 4 : 0) + (N ? 4 : 0);\n    if (t.length = X, X !== 0) {\n      if (z === 0) {\n        t.length = 8, t[0] = t[6] = e + R, t[1] = t[3] = o + N, t[2] = t[4] = e - R, t[5] = t[7] = o - N;\n        return;\n      }\n      var V = 0, W = z * 4 + (R ? 2 : 0) + 2, Y = W, q = X;\n      {\n        var Z = R + M, K = N, Q = e + Z, J = e - Z, rt = o + K;\n        if (t[V++] = Q, t[V++] = rt, t[--W] = rt, t[--W] = J, N) {\n          var tt = o - K;\n          t[Y++] = J, t[Y++] = tt, t[--q] = tt, t[--q] = Q;\n        }\n      }\n      for (var nt = 1; nt < z; nt++) {\n        var st = Math.PI / 2 * (nt / z), Z = R + Math.cos(st) * M, K = N + Math.sin(st) * D, Q = e + Z, J = e - Z, rt = o + K, tt = o - K;\n        t[V++] = Q, t[V++] = rt, t[--W] = rt, t[--W] = J, t[Y++] = J, t[Y++] = tt, t[--q] = tt, t[--q] = Q;\n      }\n      {\n        var Z = R, K = N + D, Q = e + Z, J = e - Z, rt = o + K, tt = o - K;\n        t[V++] = Q, t[V++] = rt, t[--q] = tt, t[--q] = Q, R && (t[V++] = J, t[V++] = rt, t[--q] = tt, t[--q] = J);\n      }\n    }\n  },\n  triangulate: function(n, t) {\n    var e = n.points, o = t.points, R = t.indices;\n    if (e.length !== 0) {\n      var N = o.length / 2, M = N, D, L;\n      if (n.type !== SHAPES.RREC) {\n        var B = n.shape;\n        D = B.x, L = B.y;\n      } else {\n        var $ = n.shape;\n        D = $.x + $.width / 2, L = $.y + $.height / 2;\n      }\n      var k = n.matrix;\n      o.push(n.matrix ? k.a * D + k.c * L + k.tx : D, n.matrix ? k.b * D + k.d * L + k.ty : L), N++, o.push(e[0], e[1]);\n      for (var U = 2; U < e.length; U += 2)\n        o.push(e[U], e[U + 1]), R.push(N++, M, N);\n      R.push(M + 1, M, N);\n    }\n  }\n}, buildRectangle = {\n  build: function(n) {\n    var t = n.shape, e = t.x, o = t.y, R = t.width, N = t.height, M = n.points;\n    M.length = 0, M.push(e, o, e + R, o, e + R, o + N, e, o + N);\n  },\n  triangulate: function(n, t) {\n    var e = n.points, o = t.points, R = o.length / 2;\n    o.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(R, R + 1, R + 2, R + 1, R + 2, R + 3);\n  }\n};\nfunction getPt(n, t, e) {\n  var o = t - n;\n  return n + o * e;\n}\nfunction quadraticBezierCurve(n, t, e, o, R, N, M) {\n  M === void 0 && (M = []);\n  for (var D = 20, L = M, B = 0, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 0, W = 0; V <= D; ++V)\n    W = V / D, B = getPt(n, e, W), $ = getPt(t, o, W), k = getPt(e, R, W), U = getPt(o, N, W), z = getPt(B, k, W), X = getPt($, U, W), !(V === 0 && L[L.length - 2] === z && L[L.length - 1] === X) && L.push(z, X);\n  return L;\n}\nvar buildRoundedRectangle = {\n  build: function(n) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(n);\n      return;\n    }\n    var t = n.shape, e = n.points, o = t.x, R = t.y, N = t.width, M = t.height, D = Math.max(0, Math.min(t.radius, Math.min(N, M) / 2));\n    e.length = 0, D ? (quadraticBezierCurve(o, R + D, o, R, o + D, R, e), quadraticBezierCurve(o + N - D, R, o + N, R, o + N, R + D, e), quadraticBezierCurve(o + N, R + M - D, o + N, R + M, o + N - D, R + M, e), quadraticBezierCurve(o + D, R + M, o, R + M, o, R + M - D, e)) : e.push(o, R, o + N, R, o + N, R + M, o, R + M);\n  },\n  triangulate: function(n, t) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(n, t);\n      return;\n    }\n    for (var e = n.points, o = t.points, R = t.indices, N = o.length / 2, M = earcut$1.exports(e, null, 2), D = 0, L = M.length; D < L; D += 3)\n      R.push(M[D] + N), R.push(M[D + 1] + N), R.push(M[D + 2] + N);\n    for (var D = 0, L = e.length; D < L; D++)\n      o.push(e[D], e[++D]);\n  }\n};\nfunction square(n, t, e, o, R, N, M, D) {\n  var L = n - e * R, B = t - o * R, $ = n + e * N, k = t + o * N, U, z;\n  M ? (U = o, z = -e) : (U = -o, z = e);\n  var X = L + U, V = B + z, W = $ + U, Y = k + z;\n  return D.push(X, V), D.push(W, Y), 2;\n}\nfunction round$1(n, t, e, o, R, N, M, D) {\n  var L = e - n, B = o - t, $ = Math.atan2(L, B), k = Math.atan2(R - n, N - t);\n  D && $ < k ? $ += Math.PI * 2 : !D && $ > k && (k += Math.PI * 2);\n  var U = $, z = k - $, X = Math.abs(z), V = Math.sqrt(L * L + B * B), W = (15 * X * Math.sqrt(V) / Math.PI >> 0) + 1, Y = z / W;\n  if (U += Y, D) {\n    M.push(n, t), M.push(e, o);\n    for (var q = 1, Z = U; q < W; q++, Z += Y)\n      M.push(n, t), M.push(n + Math.sin(Z) * V, t + Math.cos(Z) * V);\n    M.push(n, t), M.push(R, N);\n  } else {\n    M.push(e, o), M.push(n, t);\n    for (var q = 1, Z = U; q < W; q++, Z += Y)\n      M.push(n + Math.sin(Z) * V, t + Math.cos(Z) * V), M.push(n, t);\n    M.push(R, N), M.push(n, t);\n  }\n  return W * 2;\n}\nfunction buildNonNativeLine(n, t) {\n  var e = n.shape, o = n.points || e.points.slice(), R = t.closePointEps;\n  if (o.length !== 0) {\n    var N = n.lineStyle, M = new Point(o[0], o[1]), D = new Point(o[o.length - 2], o[o.length - 1]), L = e.type !== SHAPES.POLY || e.closeStroke, B = Math.abs(M.x - D.x) < R && Math.abs(M.y - D.y) < R;\n    if (L) {\n      o = o.slice(), B && (o.pop(), o.pop(), D.set(o[o.length - 2], o[o.length - 1]));\n      var $ = (M.x + D.x) * 0.5, k = (D.y + M.y) * 0.5;\n      o.unshift($, k), o.push($, k);\n    }\n    var U = t.points, z = o.length / 2, X = o.length, V = U.length / 2, W = N.width / 2, Y = W * W, q = N.miterLimit * N.miterLimit, Z = o[0], K = o[1], Q = o[2], J = o[3], rt = 0, tt = 0, nt = -(K - J), st = Z - Q, ut = 0, ct = 0, dt = Math.sqrt(nt * nt + st * st);\n    nt /= dt, st /= dt, nt *= W, st *= W;\n    var Et = N.alignment, vt = (1 - Et) * 2, _t = Et * 2;\n    L || (N.cap === LINE_CAP.ROUND ? X += round$1(Z - nt * (vt - _t) * 0.5, K - st * (vt - _t) * 0.5, Z - nt * vt, K - st * vt, Z + nt * _t, K + st * _t, U, !0) + 2 : N.cap === LINE_CAP.SQUARE && (X += square(Z, K, nt, st, vt, _t, !0, U))), U.push(Z - nt * vt, K - st * vt), U.push(Z + nt * _t, K + st * _t);\n    for (var St = 1; St < z - 1; ++St) {\n      Z = o[(St - 1) * 2], K = o[(St - 1) * 2 + 1], Q = o[St * 2], J = o[St * 2 + 1], rt = o[(St + 1) * 2], tt = o[(St + 1) * 2 + 1], nt = -(K - J), st = Z - Q, dt = Math.sqrt(nt * nt + st * st), nt /= dt, st /= dt, nt *= W, st *= W, ut = -(J - tt), ct = Q - rt, dt = Math.sqrt(ut * ut + ct * ct), ut /= dt, ct /= dt, ut *= W, ct *= W;\n      var Ft = Q - Z, mt = K - J, ht = Q - rt, pt = tt - J, xt = mt * ht - pt * Ft, At = xt < 0;\n      if (Math.abs(xt) < 0.1) {\n        U.push(Q - nt * vt, J - st * vt), U.push(Q + nt * _t, J + st * _t);\n        continue;\n      }\n      var Rt = (-nt + Z) * (-st + J) - (-nt + Q) * (-st + K), Lt = (-ut + rt) * (-ct + J) - (-ut + Q) * (-ct + tt), lt = (Ft * Lt - ht * Rt) / xt, $t = (pt * Rt - mt * Lt) / xt, Pt = (lt - Q) * (lt - Q) + ($t - J) * ($t - J), kt = Q + (lt - Q) * vt, Ot = J + ($t - J) * vt, gt = Q - (lt - Q) * _t, Gt = J - ($t - J) * _t, Tt = Math.min(Ft * Ft + mt * mt, ht * ht + pt * pt), bt = At ? vt : _t, wt = Tt + bt * bt * Y, Mt = Pt <= wt;\n      Mt ? N.join === LINE_JOIN.BEVEL || Pt / Y > q ? (At ? (U.push(kt, Ot), U.push(Q + nt * _t, J + st * _t), U.push(kt, Ot), U.push(Q + ut * _t, J + ct * _t)) : (U.push(Q - nt * vt, J - st * vt), U.push(gt, Gt), U.push(Q - ut * vt, J - ct * vt), U.push(gt, Gt)), X += 2) : N.join === LINE_JOIN.ROUND ? At ? (U.push(kt, Ot), U.push(Q + nt * _t, J + st * _t), X += round$1(Q, J, Q + nt * _t, J + st * _t, Q + ut * _t, J + ct * _t, U, !0) + 4, U.push(kt, Ot), U.push(Q + ut * _t, J + ct * _t)) : (U.push(Q - nt * vt, J - st * vt), U.push(gt, Gt), X += round$1(Q, J, Q - nt * vt, J - st * vt, Q - ut * vt, J - ct * vt, U, !1) + 4, U.push(Q - ut * vt, J - ct * vt), U.push(gt, Gt)) : (U.push(kt, Ot), U.push(gt, Gt)) : (U.push(Q - nt * vt, J - st * vt), U.push(Q + nt * _t, J + st * _t), N.join === LINE_JOIN.ROUND ? At ? X += round$1(Q, J, Q + nt * _t, J + st * _t, Q + ut * _t, J + ct * _t, U, !0) + 2 : X += round$1(Q, J, Q - nt * vt, J - st * vt, Q - ut * vt, J - ct * vt, U, !1) + 2 : N.join === LINE_JOIN.MITER && Pt / Y <= q && (At ? (U.push(gt, Gt), U.push(gt, Gt)) : (U.push(kt, Ot), U.push(kt, Ot)), X += 2), U.push(Q - ut * vt, J - ct * vt), U.push(Q + ut * _t, J + ct * _t), X += 2);\n    }\n    Z = o[(z - 2) * 2], K = o[(z - 2) * 2 + 1], Q = o[(z - 1) * 2], J = o[(z - 1) * 2 + 1], nt = -(K - J), st = Z - Q, dt = Math.sqrt(nt * nt + st * st), nt /= dt, st /= dt, nt *= W, st *= W, U.push(Q - nt * vt, J - st * vt), U.push(Q + nt * _t, J + st * _t), L || (N.cap === LINE_CAP.ROUND ? X += round$1(Q - nt * (vt - _t) * 0.5, J - st * (vt - _t) * 0.5, Q - nt * vt, J - st * vt, Q + nt * _t, J + st * _t, U, !1) + 2 : N.cap === LINE_CAP.SQUARE && (X += square(Q, J, nt, st, vt, _t, !1, U)));\n    for (var Ct = t.indices, Zt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, St = V; St < X + V - 2; ++St)\n      Z = U[St * 2], K = U[St * 2 + 1], Q = U[(St + 1) * 2], J = U[(St + 1) * 2 + 1], rt = U[(St + 2) * 2], tt = U[(St + 2) * 2 + 1], !(Math.abs(Z * (J - tt) + Q * (tt - K) + rt * (K - J)) < Zt) && Ct.push(St, St + 1, St + 2);\n  }\n}\nfunction buildNativeLine(n, t) {\n  var e = 0, o = n.shape, R = n.points || o.points, N = o.type !== SHAPES.POLY || o.closeStroke;\n  if (R.length !== 0) {\n    var M = t.points, D = t.indices, L = R.length / 2, B = M.length / 2, $ = B;\n    for (M.push(R[0], R[1]), e = 1; e < L; e++)\n      M.push(R[e * 2], R[e * 2 + 1]), D.push($, $ + 1), $++;\n    N && D.push($, B);\n  }\n}\nfunction buildLine(n, t) {\n  n.lineStyle.native ? buildNativeLine(n, t) : buildNonNativeLine(n, t);\n}\nvar ArcUtils = function() {\n  function n() {\n  }\n  return n.curveTo = function(t, e, o, R, N, M) {\n    var D = M[M.length - 2], L = M[M.length - 1], B = L - e, $ = D - t, k = R - e, U = o - t, z = Math.abs(B * U - $ * k);\n    if (z < 1e-8 || N === 0)\n      return (M[M.length - 2] !== t || M[M.length - 1] !== e) && M.push(t, e), null;\n    var X = B * B + $ * $, V = k * k + U * U, W = B * k + $ * U, Y = N * Math.sqrt(X) / z, q = N * Math.sqrt(V) / z, Z = Y * W / X, K = q * W / V, Q = Y * U + q * $, J = Y * k + q * B, rt = $ * (q + Z), tt = B * (q + Z), nt = U * (Y + K), st = k * (Y + K), ut = Math.atan2(tt - J, rt - Q), ct = Math.atan2(st - J, nt - Q);\n    return {\n      cx: Q + t,\n      cy: J + e,\n      radius: N,\n      startAngle: ut,\n      endAngle: ct,\n      anticlockwise: $ * k > U * B\n    };\n  }, n.arc = function(t, e, o, R, N, M, D, L, B) {\n    for (var $ = D - M, k = GRAPHICS_CURVES._segmentsCount(Math.abs($) * N, Math.ceil(Math.abs($) / PI_2) * 40), U = $ / (k * 2), z = U * 2, X = Math.cos(U), V = Math.sin(U), W = k - 1, Y = W % 1 / W, q = 0; q <= W; ++q) {\n      var Z = q + Y * q, K = U + M + z * Z, Q = Math.cos(K), J = -Math.sin(K);\n      B.push((X * Q + V * J) * N + o, (X * -J + V * Q) * N + R);\n    }\n  }, n;\n}(), BezierUtils = function() {\n  function n() {\n  }\n  return n.curveLength = function(t, e, o, R, N, M, D, L) {\n    for (var B = 10, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 0, W = 0, Y = 0, q = 0, Z = 0, K = 0, Q = t, J = e, rt = 1; rt <= B; ++rt)\n      k = rt / B, U = k * k, z = U * k, X = 1 - k, V = X * X, W = V * X, Y = W * t + 3 * V * k * o + 3 * X * U * N + z * D, q = W * e + 3 * V * k * R + 3 * X * U * M + z * L, Z = Q - Y, K = J - q, Q = Y, J = q, $ += Math.sqrt(Z * Z + K * K);\n    return $;\n  }, n.curveTo = function(t, e, o, R, N, M, D) {\n    var L = D[D.length - 2], B = D[D.length - 1];\n    D.length -= 2;\n    var $ = GRAPHICS_CURVES._segmentsCount(n.curveLength(L, B, t, e, o, R, N, M)), k = 0, U = 0, z = 0, X = 0, V = 0;\n    D.push(L, B);\n    for (var W = 1, Y = 0; W <= $; ++W)\n      Y = W / $, k = 1 - Y, U = k * k, z = U * k, X = Y * Y, V = X * Y, D.push(z * L + 3 * U * Y * t + 3 * k * X * o + V * N, z * B + 3 * U * Y * e + 3 * k * X * R + V * M);\n  }, n;\n}(), QuadraticUtils = function() {\n  function n() {\n  }\n  return n.curveLength = function(t, e, o, R, N, M) {\n    var D = t - 2 * o + N, L = e - 2 * R + M, B = 2 * o - 2 * t, $ = 2 * R - 2 * e, k = 4 * (D * D + L * L), U = 4 * (D * B + L * $), z = B * B + $ * $, X = 2 * Math.sqrt(k + U + z), V = Math.sqrt(k), W = 2 * k * V, Y = 2 * Math.sqrt(z), q = U / V;\n    return (W * X + V * U * (X - Y) + (4 * z * k - U * U) * Math.log((2 * V + q + X) / (q + Y))) / (4 * W);\n  }, n.curveTo = function(t, e, o, R, N) {\n    for (var M = N[N.length - 2], D = N[N.length - 1], L = GRAPHICS_CURVES._segmentsCount(n.curveLength(M, D, t, e, o, R)), B = 0, $ = 0, k = 1; k <= L; ++k) {\n      var U = k / L;\n      B = M + (t - M) * U, $ = D + (e - D) * U, N.push(B + (t + (o - t) * U - B) * U, $ + (e + (R - e) * U - $) * U);\n    }\n  }, n;\n}(), BatchPart = function() {\n  function n() {\n    this.reset();\n  }\n  return n.prototype.begin = function(t, e, o) {\n    this.reset(), this.style = t, this.start = e, this.attribStart = o;\n  }, n.prototype.end = function(t, e) {\n    this.attribSize = e - this.attribStart, this.size = t - this.start;\n  }, n.prototype.reset = function() {\n    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n  }, n;\n}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {\n  function n(t, e, o, R) {\n    e === void 0 && (e = null), o === void 0 && (o = null), R === void 0 && (R = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = o, this.fillStyle = e, this.matrix = R, this.type = t.type;\n  }\n  return n.prototype.clone = function() {\n    return new n(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  }, n.prototype.destroy = function() {\n    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n  }, n;\n}(), tmpPoint = new Point(), GraphicsGeometry = function(n) {\n  __extends$l(t, n);\n  function t() {\n    var e = n.call(this) || this;\n    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;\n  }\n  return Object.defineProperty(t.prototype, \"bounds\", {\n    get: function() {\n      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.invalidate = function() {\n    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n    for (var e = 0; e < this.drawCalls.length; e++)\n      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);\n    this.drawCalls.length = 0;\n    for (var e = 0; e < this.batches.length; e++) {\n      var o = this.batches[e];\n      o.reset(), BATCH_POOL.push(o);\n    }\n    this.batches.length = 0;\n  }, t.prototype.clear = function() {\n    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n  }, t.prototype.drawShape = function(e, o, R, N) {\n    o === void 0 && (o = null), R === void 0 && (R = null), N === void 0 && (N = null);\n    var M = new GraphicsData(e, o, R, N);\n    return this.graphicsData.push(M), this.dirty++, this;\n  }, t.prototype.drawHole = function(e, o) {\n    if (o === void 0 && (o = null), !this.graphicsData.length)\n      return null;\n    var R = new GraphicsData(e, null, null, o), N = this.graphicsData[this.graphicsData.length - 1];\n    return R.lineStyle = N.lineStyle, N.holes.push(R), this.dirty++, this;\n  }, t.prototype.destroy = function() {\n    n.prototype.destroy.call(this);\n    for (var e = 0; e < this.graphicsData.length; ++e)\n      this.graphicsData[e].destroy();\n    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n  }, t.prototype.containsPoint = function(e) {\n    for (var o = this.graphicsData, R = 0; R < o.length; ++R) {\n      var N = o[R];\n      if (!!N.fillStyle.visible && N.shape && (N.matrix ? N.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), N.shape.contains(tmpPoint.x, tmpPoint.y))) {\n        var M = !1;\n        if (N.holes)\n          for (var D = 0; D < N.holes.length; D++) {\n            var L = N.holes[D];\n            if (L.shape.contains(tmpPoint.x, tmpPoint.y)) {\n              M = !0;\n              break;\n            }\n          }\n        if (!M)\n          return !0;\n      }\n    }\n    return !1;\n  }, t.prototype.updateBatches = function() {\n    if (!this.graphicsData.length) {\n      this.batchable = !0;\n      return;\n    }\n    if (!!this.validateBatching()) {\n      this.cacheDirty = this.dirty;\n      var e = this.uvs, o = this.graphicsData, R = null, N = null;\n      this.batches.length > 0 && (R = this.batches[this.batches.length - 1], N = R.style);\n      for (var M = this.shapeIndex; M < o.length; M++) {\n        this.shapeIndex++;\n        var D = o[M], L = D.fillStyle, B = D.lineStyle, $ = FILL_COMMANDS[D.type];\n        $.build(D), D.matrix && this.transformPoints(D.points, D.matrix), (L.visible || B.visible) && this.processHoles(D.holes);\n        for (var k = 0; k < 2; k++) {\n          var U = k === 0 ? L : B;\n          if (!!U.visible) {\n            var z = U.texture.baseTexture, X = this.indices.length, V = this.points.length / 2;\n            z.wrapMode = WRAP_MODES$5.REPEAT, k === 0 ? this.processFill(D) : this.processLine(D);\n            var W = this.points.length / 2 - V;\n            W !== 0 && (R && !this._compareStyles(N, U) && (R.end(X, V), R = null), R || (R = BATCH_POOL.pop() || new BatchPart(), R.begin(U, X, V), this.batches.push(R), N = U), this.addUvs(this.points, e, U.texture, V, W, U.matrix));\n          }\n        }\n      }\n      var Y = this.indices.length, q = this.points.length / 2;\n      if (R && R.end(Y, q), this.batches.length === 0) {\n        this.batchable = !0;\n        return;\n      }\n      var Z = q > 65535;\n      this.indicesUint16 && this.indices.length === this.indicesUint16.length && Z === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = Z ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n    }\n  }, t.prototype._compareStyles = function(e, o) {\n    return !(!e || !o || e.texture.baseTexture !== o.texture.baseTexture || e.color + e.alpha !== o.color + o.alpha || !!e.native != !!o.native);\n  }, t.prototype.validateBatching = function() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n      return !1;\n    for (var e = 0, o = this.graphicsData.length; e < o; e++) {\n      var R = this.graphicsData[e], N = R.fillStyle, M = R.lineStyle;\n      if (N && !N.texture.baseTexture.valid || M && !M.texture.baseTexture.valid)\n        return !1;\n    }\n    return !0;\n  }, t.prototype.packBatches = function() {\n    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n    for (var e = this.batches, o = 0, R = e.length; o < R; o++)\n      for (var N = e[o], M = 0; M < N.size; M++) {\n        var D = N.start + M;\n        this.indicesUint16[D] = this.indicesUint16[D] - N.attribStart;\n      }\n  }, t.prototype.isBatchable = function() {\n    if (this.points.length > 65535 * 2)\n      return !1;\n    for (var e = this.batches, o = 0; o < e.length; o++)\n      if (e[o].style.native)\n        return !1;\n    return this.points.length < t.BATCHABLE_SIZE * 2;\n  }, t.prototype.buildDrawCalls = function() {\n    for (var e = ++BaseTexture._globalBatch, o = 0; o < this.drawCalls.length; o++)\n      this.drawCalls[o].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[o]);\n    this.drawCalls.length = 0;\n    var R = this.colors, N = this.textureIds, M = DRAW_CALL_POOL.pop();\n    M || (M = new BatchDrawCall(), M.texArray = new BatchTextureArray()), M.texArray.count = 0, M.start = 0, M.size = 0, M.type = DRAW_MODES$5.TRIANGLES;\n    var D = 0, L = null, B = 0, $ = !1, k = DRAW_MODES$5.TRIANGLES, U = 0;\n    this.drawCalls.push(M);\n    for (var o = 0; o < this.batches.length; o++) {\n      var z = this.batches[o], X = 8, V = z.style, W = V.texture.baseTexture;\n      $ !== !!V.native && ($ = !!V.native, k = $ ? DRAW_MODES$5.LINES : DRAW_MODES$5.TRIANGLES, L = null, D = X, e++), L !== W && (L = W, W._batchEnabled !== e && (D === X && (e++, D = 0, M.size > 0 && (M = DRAW_CALL_POOL.pop(), M || (M = new BatchDrawCall(), M.texArray = new BatchTextureArray()), this.drawCalls.push(M)), M.start = U, M.size = 0, M.texArray.count = 0, M.type = k), W.touched = 1, W._batchEnabled = e, W._batchLocation = D, W.wrapMode = WRAP_MODES$5.REPEAT, M.texArray.elements[M.texArray.count++] = W, D++)), M.size += z.size, U += z.size, B = W._batchLocation, this.addColors(R, V.color, V.alpha, z.attribSize, z.attribStart), this.addTextureIds(N, B, z.attribSize, z.attribStart);\n    }\n    BaseTexture._globalBatch = e, this.packAttributes();\n  }, t.prototype.packAttributes = function() {\n    for (var e = this.points, o = this.uvs, R = this.colors, N = this.textureIds, M = new ArrayBuffer(e.length * 3 * 4), D = new Float32Array(M), L = new Uint32Array(M), B = 0, $ = 0; $ < e.length / 2; $++)\n      D[B++] = e[$ * 2], D[B++] = e[$ * 2 + 1], D[B++] = o[$ * 2], D[B++] = o[$ * 2 + 1], L[B++] = R[$], D[B++] = N[$];\n    this._buffer.update(M), this._indexBuffer.update(this.indicesUint16);\n  }, t.prototype.processFill = function(e) {\n    if (e.holes.length)\n      buildPoly.triangulate(e, this);\n    else {\n      var o = FILL_COMMANDS[e.type];\n      o.triangulate(e, this);\n    }\n  }, t.prototype.processLine = function(e) {\n    buildLine(e, this);\n    for (var o = 0; o < e.holes.length; o++)\n      buildLine(e.holes[o], this);\n  }, t.prototype.processHoles = function(e) {\n    for (var o = 0; o < e.length; o++) {\n      var R = e[o], N = FILL_COMMANDS[R.type];\n      N.build(R), R.matrix && this.transformPoints(R.points, R.matrix);\n    }\n  }, t.prototype.calculateBounds = function() {\n    var e = this._bounds;\n    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);\n  }, t.prototype.transformPoints = function(e, o) {\n    for (var R = 0; R < e.length / 2; R++) {\n      var N = e[R * 2], M = e[R * 2 + 1];\n      e[R * 2] = o.a * N + o.c * M + o.tx, e[R * 2 + 1] = o.b * N + o.d * M + o.ty;\n    }\n  }, t.prototype.addColors = function(e, o, R, N, M) {\n    M === void 0 && (M = 0);\n    var D = (o >> 16) + (o & 65280) + ((o & 255) << 16), L = premultiplyTint(D, R);\n    e.length = Math.max(e.length, M + N);\n    for (var B = 0; B < N; B++)\n      e[M + B] = L;\n  }, t.prototype.addTextureIds = function(e, o, R, N) {\n    N === void 0 && (N = 0), e.length = Math.max(e.length, N + R);\n    for (var M = 0; M < R; M++)\n      e[N + M] = o;\n  }, t.prototype.addUvs = function(e, o, R, N, M, D) {\n    D === void 0 && (D = null);\n    for (var L = 0, B = o.length, $ = R.frame; L < M; ) {\n      var k = e[(N + L) * 2], U = e[(N + L) * 2 + 1];\n      if (D) {\n        var z = D.a * k + D.c * U + D.tx;\n        U = D.b * k + D.d * U + D.ty, k = z;\n      }\n      L++, o.push(k / $.width, U / $.height);\n    }\n    var X = R.baseTexture;\n    ($.width < X.width || $.height < X.height) && this.adjustUvs(o, R, B, M);\n  }, t.prototype.adjustUvs = function(e, o, R, N) {\n    for (var M = o.baseTexture, D = 1e-6, L = R + N * 2, B = o.frame, $ = B.width / M.width, k = B.height / M.height, U = B.x / B.width, z = B.y / B.height, X = Math.floor(e[R] + D), V = Math.floor(e[R + 1] + D), W = R + 2; W < L; W += 2)\n      X = Math.min(X, Math.floor(e[W] + D)), V = Math.min(V, Math.floor(e[W + 1] + D));\n    U -= X, z -= V;\n    for (var W = R; W < L; W += 2)\n      e[W] = (e[W] + U) * $, e[W + 1] = (e[W + 1] + z) * k;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(BatchGeometry), LineStyle = function(n) {\n  __extends$l(t, n);\n  function t() {\n    var e = n !== null && n.apply(this, arguments) || this;\n    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;\n  }\n  return t.prototype.clone = function() {\n    var e = new t();\n    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;\n  }, t.prototype.reset = function() {\n    n.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;\n  }, t;\n}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(n) {\n  __extends$l(t, n);\n  function t(e) {\n    e === void 0 && (e = null);\n    var o = n.call(this) || this;\n    return o.shader = null, o.pluginName = \"batch\", o.currentPath = null, o.batches = [], o.batchTint = -1, o.batchDirty = -1, o.vertexData = null, o._fillStyle = new FillStyle(), o._lineStyle = new LineStyle(), o._matrix = null, o._holeMode = !1, o.state = State.for2d(), o._geometry = e || new GraphicsGeometry(), o._geometry.refCount++, o._transformID = -1, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.clone = function() {\n    return this.finishPoly(), new t(this._geometry);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fill\", {\n    get: function() {\n      return this._fillStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"line\", {\n    get: function() {\n      return this._lineStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.lineStyle = function(e, o, R, N, M) {\n    return e === void 0 && (e = null), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 0.5), M === void 0 && (M = !1), typeof e == \"number\" && (e = { width: e, color: o, alpha: R, alignment: N, native: M }), this.lineTextureStyle(e);\n  }, t.prototype.lineTextureStyle = function(e) {\n    e = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: e && e.texture ? 16777215 : 0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: !1,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, e), this.currentPath && this.startPoly();\n    var o = e.width > 0 && e.alpha > 0;\n    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: o }, e)) : this._lineStyle.reset(), this;\n  }, t.prototype.startPoly = function() {\n    if (this.currentPath) {\n      var e = this.currentPath.points, o = this.currentPath.points.length;\n      o > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[o - 2], e[o - 1]));\n    } else\n      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n  }, t.prototype.finishPoly = function() {\n    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n  }, t.prototype.moveTo = function(e, o) {\n    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = o, this;\n  }, t.prototype.lineTo = function(e, o) {\n    this.currentPath || this.moveTo(0, 0);\n    var R = this.currentPath.points, N = R[R.length - 2], M = R[R.length - 1];\n    return (N !== e || M !== o) && R.push(e, o), this;\n  }, t.prototype._initCurve = function(e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, o]) : this.moveTo(e, o);\n  }, t.prototype.quadraticCurveTo = function(e, o, R, N) {\n    this._initCurve();\n    var M = this.currentPath.points;\n    return M.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, o, R, N, M), this;\n  }, t.prototype.bezierCurveTo = function(e, o, R, N, M, D) {\n    return this._initCurve(), BezierUtils.curveTo(e, o, R, N, M, D, this.currentPath.points), this;\n  }, t.prototype.arcTo = function(e, o, R, N, M) {\n    this._initCurve(e, o);\n    var D = this.currentPath.points, L = ArcUtils.curveTo(e, o, R, N, M, D);\n    if (L) {\n      var B = L.cx, $ = L.cy, k = L.radius, U = L.startAngle, z = L.endAngle, X = L.anticlockwise;\n      this.arc(B, $, k, U, z, X);\n    }\n    return this;\n  }, t.prototype.arc = function(e, o, R, N, M, D) {\n    if (D === void 0 && (D = !1), N === M)\n      return this;\n    !D && M <= N ? M += PI_2 : D && N <= M && (N += PI_2);\n    var L = M - N;\n    if (L === 0)\n      return this;\n    var B = e + Math.cos(N) * R, $ = o + Math.sin(N) * R, k = this._geometry.closePointEps, U = this.currentPath ? this.currentPath.points : null;\n    if (U) {\n      var z = Math.abs(U[U.length - 2] - B), X = Math.abs(U[U.length - 1] - $);\n      z < k && X < k || U.push(B, $);\n    } else\n      this.moveTo(B, $), U = this.currentPath.points;\n    return ArcUtils.arc(B, $, e, o, R, N, M, D, U), this;\n  }, t.prototype.beginFill = function(e, o) {\n    return e === void 0 && (e = 0), o === void 0 && (o = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: o });\n  }, t.prototype.beginTextureFill = function(e) {\n    e = Object.assign({\n      texture: Texture.WHITE,\n      color: 16777215,\n      alpha: 1,\n      matrix: null\n    }, e), this.currentPath && this.startPoly();\n    var o = e.alpha > 0;\n    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: o }, e)) : this._fillStyle.reset(), this;\n  }, t.prototype.endFill = function() {\n    return this.finishPoly(), this._fillStyle.reset(), this;\n  }, t.prototype.drawRect = function(e, o, R, N) {\n    return this.drawShape(new Rectangle(e, o, R, N));\n  }, t.prototype.drawRoundedRect = function(e, o, R, N, M) {\n    return this.drawShape(new RoundedRectangle(e, o, R, N, M));\n  }, t.prototype.drawCircle = function(e, o, R) {\n    return this.drawShape(new Circle(e, o, R));\n  }, t.prototype.drawEllipse = function(e, o, R, N) {\n    return this.drawShape(new Ellipse(e, o, R, N));\n  }, t.prototype.drawPolygon = function() {\n    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)\n      o[R] = e[R];\n    var N, M = !0, D = o[0];\n    D.points ? (M = D.closeStroke, N = D.points) : Array.isArray(o[0]) ? N = o[0] : N = o;\n    var L = new Polygon(N);\n    return L.closeStroke = M, this.drawShape(L), this;\n  }, t.prototype.drawShape = function(e) {\n    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;\n  }, t.prototype.clear = function() {\n    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n  }, t.prototype.isFastRect = function() {\n    var e = this._geometry.graphicsData;\n    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);\n  }, t.prototype._render = function(e) {\n    this.finishPoly();\n    var o = this._geometry;\n    o.updateBatches(), o.batchable ? (this.batchDirty !== o.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));\n  }, t.prototype._populateBatches = function() {\n    var e = this._geometry, o = this.blendMode, R = e.batches.length;\n    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = R, this.vertexData = new Float32Array(e.points);\n    for (var N = 0; N < R; N++) {\n      var M = e.batches[N], D = M.style.color, L = new Float32Array(this.vertexData.buffer, M.attribStart * 4 * 2, M.attribSize * 2), B = new Float32Array(e.uvsFloat32.buffer, M.attribStart * 4 * 2, M.attribSize * 2), $ = new Uint16Array(e.indicesUint16.buffer, M.start * 2, M.size), k = {\n        vertexData: L,\n        blendMode: o,\n        indices: $,\n        uvs: B,\n        _batchRGB: hex2rgb(D),\n        _tintRGB: D,\n        _texture: M.style.texture,\n        alpha: M.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[N] = k;\n    }\n  }, t.prototype._renderBatched = function(e) {\n    if (!!this.batches.length) {\n      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n      for (var o = 0, R = this.batches.length; o < R; o++) {\n        var N = this.batches[o];\n        N.worldAlpha = this.worldAlpha * N.alpha, e.plugins[this.pluginName].render(N);\n      }\n    }\n  }, t.prototype._renderDirect = function(e) {\n    var o = this._resolveDirectShader(e), R = this._geometry, N = this.tint, M = this.worldAlpha, D = o.uniforms, L = R.drawCalls;\n    D.translationMatrix = this.transform.worldTransform, D.tint[0] = (N >> 16 & 255) / 255 * M, D.tint[1] = (N >> 8 & 255) / 255 * M, D.tint[2] = (N & 255) / 255 * M, D.tint[3] = M, e.shader.bind(o), e.geometry.bind(R, o), e.state.set(this.state);\n    for (var B = 0, $ = L.length; B < $; B++)\n      this._renderDrawCallDirect(e, R.drawCalls[B]);\n  }, t.prototype._renderDrawCallDirect = function(e, o) {\n    for (var R = o.texArray, N = o.type, M = o.size, D = o.start, L = R.count, B = 0; B < L; B++)\n      e.texture.bind(R.elements[B], B);\n    e.geometry.draw(N, M, D);\n  }, t.prototype._resolveDirectShader = function(e) {\n    var o = this.shader, R = this.pluginName;\n    if (!o) {\n      if (!DEFAULT_SHADERS[R]) {\n        for (var N = e.plugins[R].MAX_TEXTURES, M = new Int32Array(N), D = 0; D < N; D++)\n          M[D] = D;\n        var L = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: M }, !0)\n        }, B = e.plugins[R]._shader.program;\n        DEFAULT_SHADERS[R] = new Shader(B, L);\n      }\n      o = DEFAULT_SHADERS[R];\n    }\n    return o;\n  }, t.prototype._calculateBounds = function() {\n    this.finishPoly();\n    var e = this._geometry;\n    if (!!e.graphicsData.length) {\n      var o = e.bounds, R = o.minX, N = o.minY, M = o.maxX, D = o.maxY;\n      this._bounds.addFrame(this.transform, R, N, M, D);\n    }\n  }, t.prototype.containsPoint = function(e) {\n    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);\n  }, t.prototype.calculateTints = function() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      for (var e = hex2rgb(this.tint, temp), o = 0; o < this.batches.length; o++) {\n        var R = this.batches[o], N = R._batchRGB, M = e[0] * N[0] * 255, D = e[1] * N[1] * 255, L = e[2] * N[2] * 255, B = (M << 16) + (D << 8) + (L | 0);\n        R._tintRGB = (B >> 16) + (B & 65280) + ((B & 255) << 16);\n      }\n    }\n  }, t.prototype.calculateVertices = function() {\n    var e = this.transform._worldID;\n    if (this._transformID !== e) {\n      this._transformID = e;\n      for (var o = this.transform.worldTransform, R = o.a, N = o.b, M = o.c, D = o.d, L = o.tx, B = o.ty, $ = this._geometry.points, k = this.vertexData, U = 0, z = 0; z < $.length; z += 2) {\n        var X = $[z], V = $[z + 1];\n        k[U++] = R * X + M * V + L, k[U++] = D * V + N * X + B;\n      }\n    }\n  }, t.prototype.closePath = function() {\n    var e = this.currentPath;\n    return e && (e.closeStroke = !0, this.finishPoly()), this;\n  }, t.prototype.setMatrix = function(e) {\n    return this._matrix = e, this;\n  }, t.prototype.beginHole = function() {\n    return this.finishPoly(), this._holeMode = !0, this;\n  }, t.prototype.endHole = function() {\n    return this.finishPoly(), this._holeMode = !1, this;\n  }, t.prototype.destroy = function(e) {\n    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, n.prototype.destroy.call(this, e);\n  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;\n}(Container);\n/*!\n * @pixi/sprite - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$k = function(n, t) {\n  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$k(n, t);\n};\nfunction __extends$k(n, t) {\n  extendStatics$k(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(n) {\n  __extends$k(t, n);\n  function t(e) {\n    var o = n.call(this) || this;\n    return o._anchor = new ObservablePoint(o._onAnchorUpdate, o, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), o._texture = null, o._width = 0, o._height = 0, o._tint = null, o._tintRGB = null, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o._cachedTint = 16777215, o.uvs = null, o.texture = e || Texture.EMPTY, o.vertexData = new Float32Array(8), o.vertexTrimmedData = null, o._transformID = -1, o._textureID = -1, o._transformTrimmedID = -1, o._textureTrimmedID = -1, o.indices = indices, o.pluginName = \"batch\", o.isSprite = !0, o._roundPixels = settings$1.ROUND_PIXELS, o;\n  }\n  return t.prototype._onTextureUpdate = function() {\n    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);\n  }, t.prototype._onAnchorUpdate = function() {\n    this._transformID = -1, this._transformTrimmedID = -1;\n  }, t.prototype.calculateVertices = function() {\n    var e = this._texture;\n    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {\n      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;\n      var o = this.transform.worldTransform, R = o.a, N = o.b, M = o.c, D = o.d, L = o.tx, B = o.ty, $ = this.vertexData, k = e.trim, U = e.orig, z = this._anchor, X = 0, V = 0, W = 0, Y = 0;\n      if (k ? (V = k.x - z._x * U.width, X = V + k.width, Y = k.y - z._y * U.height, W = Y + k.height) : (V = -z._x * U.width, X = V + U.width, Y = -z._y * U.height, W = Y + U.height), $[0] = R * V + M * Y + L, $[1] = D * Y + N * V + B, $[2] = R * X + M * Y + L, $[3] = D * Y + N * X + B, $[4] = R * X + M * W + L, $[5] = D * W + N * X + B, $[6] = R * V + M * W + L, $[7] = D * W + N * V + B, this._roundPixels)\n        for (var q = settings$1.RESOLUTION, Z = 0; Z < $.length; ++Z)\n          $[Z] = Math.round(($[Z] * q | 0) / q);\n    }\n  }, t.prototype.calculateTrimmedVertices = function() {\n    if (!this.vertexTrimmedData)\n      this.vertexTrimmedData = new Float32Array(8);\n    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n      return;\n    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n    var e = this._texture, o = this.vertexTrimmedData, R = e.orig, N = this._anchor, M = this.transform.worldTransform, D = M.a, L = M.b, B = M.c, $ = M.d, k = M.tx, U = M.ty, z = -N._x * R.width, X = z + R.width, V = -N._y * R.height, W = V + R.height;\n    o[0] = D * z + B * V + k, o[1] = $ * V + L * z + U, o[2] = D * X + B * V + k, o[3] = $ * V + L * X + U, o[4] = D * X + B * W + k, o[5] = $ * W + L * X + U, o[6] = D * z + B * W + k, o[7] = $ * W + L * z + U;\n  }, t.prototype._render = function(e) {\n    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);\n  }, t.prototype._calculateBounds = function() {\n    var e = this._texture.trim, o = this._texture.orig;\n    !e || e.width === o.width && e.height === o.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : n.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$2);\n    var o = this._texture.orig.width, R = this._texture.orig.height, N = -o * this.anchor.x, M = 0;\n    return tempPoint$2.x >= N && tempPoint$2.x < N + o && (M = -R * this.anchor.y, tempPoint$2.y >= M && tempPoint$2.y < M + R);\n  }, t.prototype.destroy = function(e) {\n    n.prototype.destroy.call(this, e), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null;\n    var o = typeof e == \"boolean\" ? e : e && e.texture;\n    if (o) {\n      var R = typeof e == \"boolean\" ? e : e && e.baseTexture;\n      this._texture.destroy(!!R);\n    }\n    this._texture = null;\n  }, t.from = function(e, o) {\n    var R = e instanceof Texture ? e : Texture.from(e, o);\n    return new t(R);\n  }, Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      var o = sign(this.scale.x) || 1;\n      this.scale.x = o * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      var o = sign(this.scale.y) || 1;\n      this.scale.y = o * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(e) {\n      this._texture !== e && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once(\"update\", this._onTextureUpdate, this)));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Container);\n/*!\n * @pixi/text - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$j = function(n, t) {\n  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$j(n, t);\n};\nfunction __extends$j(n, t) {\n  extendStatics$j(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar TEXT_GRADIENT;\n(function(n) {\n  n[n.LINEAR_VERTICAL = 0] = \"LINEAR_VERTICAL\", n[n.LINEAR_HORIZONTAL = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nvar defaultStyle = {\n  align: \"left\",\n  breakWords: !1,\n  dropShadow: !1,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: !1,\n  whiteSpace: \"pre\",\n  wordWrap: !1,\n  wordWrapWidth: 100,\n  leading: 0\n}, genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n], TextStyle = function() {\n  function n(t) {\n    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);\n  }\n  return n.prototype.clone = function() {\n    var t = {};\n    return deepCopyProperties(t, this, defaultStyle), new n(t);\n  }, n.prototype.reset = function() {\n    deepCopyProperties(this, defaultStyle, defaultStyle);\n  }, Object.defineProperty(n.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(t) {\n      this._align !== t && (this._align = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"breakWords\", {\n    get: function() {\n      return this._breakWords;\n    },\n    set: function(t) {\n      this._breakWords !== t && (this._breakWords = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadow\", {\n    get: function() {\n      return this._dropShadow;\n    },\n    set: function(t) {\n      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadowAlpha\", {\n    get: function() {\n      return this._dropShadowAlpha;\n    },\n    set: function(t) {\n      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadowAngle\", {\n    get: function() {\n      return this._dropShadowAngle;\n    },\n    set: function(t) {\n      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadowBlur\", {\n    get: function() {\n      return this._dropShadowBlur;\n    },\n    set: function(t) {\n      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadowColor\", {\n    get: function() {\n      return this._dropShadowColor;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"dropShadowDistance\", {\n    get: function() {\n      return this._dropShadowDistance;\n    },\n    set: function(t) {\n      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fill\", {\n    get: function() {\n      return this._fill;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._fill !== e && (this._fill = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fillGradientType\", {\n    get: function() {\n      return this._fillGradientType;\n    },\n    set: function(t) {\n      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fillGradientStops\", {\n    get: function() {\n      return this._fillGradientStops;\n    },\n    set: function(t) {\n      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fontFamily\", {\n    get: function() {\n      return this._fontFamily;\n    },\n    set: function(t) {\n      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(t) {\n      this._fontSize !== t && (this._fontSize = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fontStyle\", {\n    get: function() {\n      return this._fontStyle;\n    },\n    set: function(t) {\n      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fontVariant\", {\n    get: function() {\n      return this._fontVariant;\n    },\n    set: function(t) {\n      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"fontWeight\", {\n    get: function() {\n      return this._fontWeight;\n    },\n    set: function(t) {\n      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(t) {\n      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"lineHeight\", {\n    get: function() {\n      return this._lineHeight;\n    },\n    set: function(t) {\n      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"leading\", {\n    get: function() {\n      return this._leading;\n    },\n    set: function(t) {\n      this._leading !== t && (this._leading = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"lineJoin\", {\n    get: function() {\n      return this._lineJoin;\n    },\n    set: function(t) {\n      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"miterLimit\", {\n    get: function() {\n      return this._miterLimit;\n    },\n    set: function(t) {\n      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"padding\", {\n    get: function() {\n      return this._padding;\n    },\n    set: function(t) {\n      this._padding !== t && (this._padding = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"stroke\", {\n    get: function() {\n      return this._stroke;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._stroke !== e && (this._stroke = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"strokeThickness\", {\n    get: function() {\n      return this._strokeThickness;\n    },\n    set: function(t) {\n      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"textBaseline\", {\n    get: function() {\n      return this._textBaseline;\n    },\n    set: function(t) {\n      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"trim\", {\n    get: function() {\n      return this._trim;\n    },\n    set: function(t) {\n      this._trim !== t && (this._trim = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"whiteSpace\", {\n    get: function() {\n      return this._whiteSpace;\n    },\n    set: function(t) {\n      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"wordWrap\", {\n    get: function() {\n      return this._wordWrap;\n    },\n    set: function(t) {\n      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"wordWrapWidth\", {\n    get: function() {\n      return this._wordWrapWidth;\n    },\n    set: function(t) {\n      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.toFontString = function() {\n    var t = typeof this.fontSize == \"number\" ? this.fontSize + \"px\" : this.fontSize, e = this.fontFamily;\n    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(\",\"));\n    for (var o = e.length - 1; o >= 0; o--) {\n      var R = e[o].trim();\n      !/([\\\"\\'])[^\\'\\\"]+\\1/.test(R) && genericFontFamilies.indexOf(R) < 0 && (R = '\"' + R + '\"'), e[o] = R;\n    }\n    return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + t + \" \" + e.join(\",\");\n  }, n;\n}();\nfunction getSingleColor(n) {\n  return typeof n == \"number\" ? hex2string(n) : (typeof n == \"string\" && n.indexOf(\"0x\") === 0 && (n = n.replace(\"0x\", \"#\")), n);\n}\nfunction getColor(n) {\n  if (Array.isArray(n)) {\n    for (var t = 0; t < n.length; ++t)\n      n[t] = getSingleColor(n[t]);\n    return n;\n  } else\n    return getSingleColor(n);\n}\nfunction areArraysEqual(n, t) {\n  if (!Array.isArray(n) || !Array.isArray(t) || n.length !== t.length)\n    return !1;\n  for (var e = 0; e < n.length; ++e)\n    if (n[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction deepCopyProperties(n, t, e) {\n  for (var o in e)\n    Array.isArray(t[o]) ? n[o] = t[o].slice() : n[o] = t[o];\n}\nvar TextMetrics = function() {\n  function n(t, e, o, R, N, M, D, L, B) {\n    this.text = t, this.style = e, this.width = o, this.height = R, this.lines = N, this.lineWidths = M, this.lineHeight = D, this.maxLineWidth = L, this.fontProperties = B;\n  }\n  return n.measureText = function(t, e, o, R) {\n    R === void 0 && (R = n._canvas), o = o == null ? e.wordWrap : o;\n    var N = e.toFontString(), M = n.measureFont(N);\n    M.fontSize === 0 && (M.fontSize = e.fontSize, M.ascent = e.fontSize);\n    var D = R.getContext(\"2d\");\n    D.font = N;\n    for (var L = o ? n.wordWrap(t, e, R) : t, B = L.split(/(?:\\r\\n|\\r|\\n)/), $ = new Array(B.length), k = 0, U = 0; U < B.length; U++) {\n      var z = D.measureText(B[U]).width + (B[U].length - 1) * e.letterSpacing;\n      $[U] = z, k = Math.max(k, z);\n    }\n    var X = k + e.strokeThickness;\n    e.dropShadow && (X += e.dropShadowDistance);\n    var V = e.lineHeight || M.fontSize + e.strokeThickness, W = Math.max(V, M.fontSize + e.strokeThickness) + (B.length - 1) * (V + e.leading);\n    return e.dropShadow && (W += e.dropShadowDistance), new n(t, e, X, W, B, $, V + e.leading, k, M);\n  }, n.wordWrap = function(t, e, o) {\n    o === void 0 && (o = n._canvas);\n    for (var R = o.getContext(\"2d\"), N = 0, M = \"\", D = \"\", L = /* @__PURE__ */ Object.create(null), B = e.letterSpacing, $ = e.whiteSpace, k = n.collapseSpaces($), U = n.collapseNewlines($), z = !k, X = e.wordWrapWidth + B, V = n.tokenize(t), W = 0; W < V.length; W++) {\n      var Y = V[W];\n      if (n.isNewline(Y)) {\n        if (!U) {\n          D += n.addLine(M), z = !k, M = \"\", N = 0;\n          continue;\n        }\n        Y = \" \";\n      }\n      if (k) {\n        var q = n.isBreakingSpace(Y), Z = n.isBreakingSpace(M[M.length - 1]);\n        if (q && Z)\n          continue;\n      }\n      var K = n.getFromCache(Y, B, L, R);\n      if (K > X)\n        if (M !== \"\" && (D += n.addLine(M), M = \"\", N = 0), n.canBreakWords(Y, e.breakWords))\n          for (var Q = n.wordWrapSplit(Y), J = 0; J < Q.length; J++) {\n            for (var rt = Q[J], tt = 1; Q[J + tt]; ) {\n              var nt = Q[J + tt], st = rt[rt.length - 1];\n              if (!n.canBreakChars(st, nt, Y, J, e.breakWords))\n                rt += nt;\n              else\n                break;\n              tt++;\n            }\n            J += rt.length - 1;\n            var ut = n.getFromCache(rt, B, L, R);\n            ut + N > X && (D += n.addLine(M), z = !1, M = \"\", N = 0), M += rt, N += ut;\n          }\n        else {\n          M.length > 0 && (D += n.addLine(M), M = \"\", N = 0);\n          var ct = W === V.length - 1;\n          D += n.addLine(Y, !ct), z = !1, M = \"\", N = 0;\n        }\n      else\n        K + N > X && (z = !1, D += n.addLine(M), M = \"\", N = 0), (M.length > 0 || !n.isBreakingSpace(Y) || z) && (M += Y, N += K);\n    }\n    return D += n.addLine(M, !1), D;\n  }, n.addLine = function(t, e) {\n    return e === void 0 && (e = !0), t = n.trimRight(t), t = e ? t + `\n` : t, t;\n  }, n.getFromCache = function(t, e, o, R) {\n    var N = o[t];\n    if (typeof N != \"number\") {\n      var M = t.length * e;\n      N = R.measureText(t).width + M, o[t] = N;\n    }\n    return N;\n  }, n.collapseSpaces = function(t) {\n    return t === \"normal\" || t === \"pre-line\";\n  }, n.collapseNewlines = function(t) {\n    return t === \"normal\";\n  }, n.trimRight = function(t) {\n    if (typeof t != \"string\")\n      return \"\";\n    for (var e = t.length - 1; e >= 0; e--) {\n      var o = t[e];\n      if (!n.isBreakingSpace(o))\n        break;\n      t = t.slice(0, -1);\n    }\n    return t;\n  }, n.isNewline = function(t) {\n    return typeof t != \"string\" ? !1 : n._newlines.indexOf(t.charCodeAt(0)) >= 0;\n  }, n.isBreakingSpace = function(t, e) {\n    return typeof t != \"string\" ? !1 : n._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;\n  }, n.tokenize = function(t) {\n    var e = [], o = \"\";\n    if (typeof t != \"string\")\n      return e;\n    for (var R = 0; R < t.length; R++) {\n      var N = t[R], M = t[R + 1];\n      if (n.isBreakingSpace(N, M) || n.isNewline(N)) {\n        o !== \"\" && (e.push(o), o = \"\"), e.push(N);\n        continue;\n      }\n      o += N;\n    }\n    return o !== \"\" && e.push(o), e;\n  }, n.canBreakWords = function(t, e) {\n    return e;\n  }, n.canBreakChars = function(t, e, o, R, N) {\n    return !0;\n  }, n.wordWrapSplit = function(t) {\n    return t.split(\"\");\n  }, n.measureFont = function(t) {\n    if (n._fonts[t])\n      return n._fonts[t];\n    var e = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, o = n._canvas, R = n._context;\n    R.font = t;\n    var N = n.METRICS_STRING + n.BASELINE_SYMBOL, M = Math.ceil(R.measureText(N).width), D = Math.ceil(R.measureText(n.BASELINE_SYMBOL).width), L = Math.ceil(n.HEIGHT_MULTIPLIER * D);\n    D = D * n.BASELINE_MULTIPLIER | 0, o.width = M, o.height = L, R.fillStyle = \"#f00\", R.fillRect(0, 0, M, L), R.font = t, R.textBaseline = \"alphabetic\", R.fillStyle = \"#000\", R.fillText(N, 0, D);\n    var B = R.getImageData(0, 0, M, L).data, $ = B.length, k = M * 4, U = 0, z = 0, X = !1;\n    for (U = 0; U < D; ++U) {\n      for (var V = 0; V < k; V += 4)\n        if (B[z + V] !== 255) {\n          X = !0;\n          break;\n        }\n      if (!X)\n        z += k;\n      else\n        break;\n    }\n    for (e.ascent = D - U, z = $ - k, X = !1, U = L; U > D; --U) {\n      for (var V = 0; V < k; V += 4)\n        if (B[z + V] !== 255) {\n          X = !0;\n          break;\n        }\n      if (!X)\n        z -= k;\n      else\n        break;\n    }\n    return e.descent = U - D, e.fontSize = e.ascent + e.descent, n._fonts[t] = e, e;\n  }, n.clearMetrics = function(t) {\n    t === void 0 && (t = \"\"), t ? delete n._fonts[t] : n._fonts = {};\n  }, Object.defineProperty(n, \"_canvas\", {\n    get: function() {\n      if (!n.__canvas) {\n        var t = void 0;\n        try {\n          var e = new OffscreenCanvas(0, 0), o = e.getContext(\"2d\");\n          if (o && o.measureText)\n            return n.__canvas = e, e;\n          t = settings$1.ADAPTER.createCanvas();\n        } catch {\n          t = settings$1.ADAPTER.createCanvas();\n        }\n        t.width = t.height = 10, n.__canvas = t;\n      }\n      return n.__canvas;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n, \"_context\", {\n    get: function() {\n      return n.__context || (n.__context = n._canvas.getContext(\"2d\")), n.__context;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n}();\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, Text = function(n) {\n  __extends$j(t, n);\n  function t(e, o, R) {\n    var N = this, M = !1;\n    R || (R = settings$1.ADAPTER.createCanvas(), M = !0), R.width = 3, R.height = 3;\n    var D = Texture.from(R);\n    return D.orig = new Rectangle(), D.trim = new Rectangle(), N = n.call(this, D) || this, N._ownCanvas = M, N.canvas = R, N.context = R.getContext(\"2d\"), N._resolution = settings$1.RESOLUTION, N._autoResolution = !0, N._text = null, N._style = null, N._styleListener = null, N._font = \"\", N.text = e, N.style = o, N.localStyleID = -1, N;\n  }\n  return t.prototype.updateText = function(e) {\n    var o = this._style;\n    if (this.localStyleID !== o.styleID && (this.dirty = !0, this.localStyleID = o.styleID), !(!this.dirty && e)) {\n      this._font = this._style.toFontString();\n      var R = this.context, N = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), M = N.width, D = N.height, L = N.lines, B = N.lineHeight, $ = N.lineWidths, k = N.maxLineWidth, U = N.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, M) + o.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, D) + o.padding * 2) * this._resolution), R.scale(this._resolution, this._resolution), R.clearRect(0, 0, this.canvas.width, this.canvas.height), R.font = this._font, R.lineWidth = o.strokeThickness, R.textBaseline = o.textBaseline, R.lineJoin = o.lineJoin, R.miterLimit = o.miterLimit;\n      for (var z, X, V = o.dropShadow ? 2 : 1, W = 0; W < V; ++W) {\n        var Y = o.dropShadow && W === 0, q = Y ? Math.ceil(Math.max(1, D) + o.padding * 2) : 0, Z = q * this._resolution;\n        if (Y) {\n          R.fillStyle = \"black\", R.strokeStyle = \"black\";\n          var K = o.dropShadowColor, Q = hex2rgb(typeof K == \"number\" ? K : string2hex(K)), J = o.dropShadowBlur * this._resolution, rt = o.dropShadowDistance * this._resolution;\n          R.shadowColor = \"rgba(\" + Q[0] * 255 + \",\" + Q[1] * 255 + \",\" + Q[2] * 255 + \",\" + o.dropShadowAlpha + \")\", R.shadowBlur = J, R.shadowOffsetX = Math.cos(o.dropShadowAngle) * rt, R.shadowOffsetY = Math.sin(o.dropShadowAngle) * rt + Z;\n        } else\n          R.fillStyle = this._generateFillStyle(o, L, N), R.strokeStyle = o.stroke, R.shadowColor = \"black\", R.shadowBlur = 0, R.shadowOffsetX = 0, R.shadowOffsetY = 0;\n        var tt = (B - U.fontSize) / 2;\n        (!t.nextLineHeightBehavior || B - U.fontSize < 0) && (tt = 0);\n        for (var nt = 0; nt < L.length; nt++)\n          z = o.strokeThickness / 2, X = o.strokeThickness / 2 + nt * B + U.ascent + tt, o.align === \"right\" ? z += k - $[nt] : o.align === \"center\" && (z += (k - $[nt]) / 2), o.stroke && o.strokeThickness && this.drawLetterSpacing(L[nt], z + o.padding, X + o.padding - q, !0), o.fill && this.drawLetterSpacing(L[nt], z + o.padding, X + o.padding - q);\n      }\n      this.updateTexture();\n    }\n  }, t.prototype.drawLetterSpacing = function(e, o, R, N) {\n    N === void 0 && (N = !1);\n    var M = this._style, D = M.letterSpacing, L = t.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n    if (D === 0 || L) {\n      L && (this.context.letterSpacing = D, this.context.textLetterSpacing = D), N ? this.context.strokeText(e, o, R) : this.context.fillText(e, o, R);\n      return;\n    }\n    for (var B = o, $ = Array.from ? Array.from(e) : e.split(\"\"), k = this.context.measureText(e).width, U = 0, z = 0; z < $.length; ++z) {\n      var X = $[z];\n      N ? this.context.strokeText(X, B, R) : this.context.fillText(X, B, R);\n      for (var V = \"\", W = z + 1; W < $.length; ++W)\n        V += $[W];\n      U = this.context.measureText(V).width, B += k - U + D, k = U;\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.canvas;\n    if (this._style.trim) {\n      var o = trimCanvas(e);\n      o.data && (e.width = o.width, e.height = o.height, this.context.putImageData(o.data, 0, 0));\n    }\n    var R = this._texture, N = this._style, M = N.trim ? 0 : N.padding, D = R.baseTexture;\n    R.trim.width = R._frame.width = e.width / this._resolution, R.trim.height = R._frame.height = e.height / this._resolution, R.trim.x = -M, R.trim.y = -M, R.orig.width = R._frame.width - M * 2, R.orig.height = R._frame.height - M * 2, this._onTextureUpdate(), D.setRealSize(e.width, e.height, this._resolution), R.updateUvs(), this.dirty = !1;\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), n.prototype._render.call(this, e);\n  }, t.prototype.updateTransform = function() {\n    this.updateText(!0), n.prototype.updateTransform.call(this);\n  }, t.prototype.getBounds = function(e, o) {\n    return this.updateText(!0), this._textureID === -1 && (e = !1), n.prototype.getBounds.call(this, e, o);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.updateText(!0), n.prototype.getLocalBounds.call(this, e);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }, t.prototype._generateFillStyle = function(e, o, R) {\n    var N = e.fill;\n    if (Array.isArray(N)) {\n      if (N.length === 1)\n        return N[0];\n    } else\n      return N;\n    var M, D = e.dropShadow ? e.dropShadowDistance : 0, L = e.padding || 0, B = this.canvas.width / this._resolution - D - L * 2, $ = this.canvas.height / this._resolution - D - L * 2, k = N.slice(), U = e.fillGradientStops.slice();\n    if (!U.length)\n      for (var z = k.length + 1, X = 1; X < z; ++X)\n        U.push(X / z);\n    if (k.unshift(N[0]), U.unshift(0), k.push(N[N.length - 1]), U.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      M = this.context.createLinearGradient(B / 2, L, B / 2, $ + L);\n      for (var V = R.fontProperties.fontSize + e.strokeThickness, X = 0; X < o.length; X++) {\n        var W = R.lineHeight * (X - 1) + V, Y = R.lineHeight * X, q = Y;\n        X > 0 && W > Y && (q = (Y + W) / 2);\n        var Z = Y + V, K = R.lineHeight * (X + 1), Q = Z;\n        X + 1 < o.length && K < Z && (Q = (Z + K) / 2);\n        for (var J = (Q - q) / $, rt = 0; rt < k.length; rt++) {\n          var tt = 0;\n          typeof U[rt] == \"number\" ? tt = U[rt] : tt = rt / k.length;\n          var nt = Math.min(1, Math.max(0, q / $ + tt * J));\n          nt = Number(nt.toFixed(5)), M.addColorStop(nt, k[rt]);\n        }\n      }\n    } else {\n      M = this.context.createLinearGradient(L, $ / 2, B + L, $ / 2);\n      for (var st = k.length + 1, ut = 1, X = 0; X < k.length; X++) {\n        var ct = void 0;\n        typeof U[X] == \"number\" ? ct = U[X] : ct = ut / st, M.addColorStop(ct, k[X]), ut++;\n      }\n    }\n    return M;\n  }, t.prototype.destroy = function(e) {\n    typeof e == \"boolean\" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), n.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var o = sign(this.scale.x) || 1;\n      this.scale.x = o * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var o = sign(this.scale.y) || 1;\n      this.scale.y = o * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"style\", {\n    get: function() {\n      return this._style;\n    },\n    set: function(e) {\n      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e == null ? \"\" : e), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;\n}(Sprite);\n/*!\n * @pixi/prepare - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.UPLOADS_PER_FRAME = 4;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$i = function(n, t) {\n  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$i(n, t);\n};\nfunction __extends$i(n, t) {\n  extendStatics$i(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar CountLimiter = function() {\n  function n(t) {\n    this.maxItemsPerFrame = t, this.itemsLeft = 0;\n  }\n  return n.prototype.beginFrame = function() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }, n.prototype.allowedToUpload = function() {\n    return this.itemsLeft-- > 0;\n  }, n;\n}();\nfunction findMultipleBaseTextures(n, t) {\n  var e = !1;\n  if (n && n._textures && n._textures.length) {\n    for (var o = 0; o < n._textures.length; o++)\n      if (n._textures[o] instanceof Texture) {\n        var R = n._textures[o].baseTexture;\n        t.indexOf(R) === -1 && (t.push(R), e = !0);\n      }\n  }\n  return e;\n}\nfunction findBaseTexture(n, t) {\n  if (n.baseTexture instanceof BaseTexture) {\n    var e = n.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTexture(n, t) {\n  if (n._texture && n._texture instanceof Texture) {\n    var e = n._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction drawText(n, t) {\n  return t instanceof Text ? (t.updateText(!0), !0) : !1;\n}\nfunction calculateTextStyle(n, t) {\n  if (t instanceof TextStyle) {\n    var e = t.toFontString();\n    return TextMetrics.measureFont(e), !0;\n  }\n  return !1;\n}\nfunction findText(n, t) {\n  if (n instanceof Text) {\n    t.indexOf(n.style) === -1 && t.push(n.style), t.indexOf(n) === -1 && t.push(n);\n    var e = n._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTextStyle(n, t) {\n  return n instanceof TextStyle ? (t.indexOf(n) === -1 && t.push(n), !0) : !1;\n}\nvar BasePrepare = function() {\n  function n(t) {\n    var e = this;\n    this.limiter = new CountLimiter(settings$1.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {\n      !e.queue || e.prepareItems();\n    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);\n  }\n  return n.prototype.upload = function(t, e) {\n    var o = this;\n    return typeof t == \"function\" && (e = t, t = null), e && deprecation$1(\"6.5.0\", \"BasePrepare.upload callback is deprecated, use the return Promise instead.\"), new Promise(function(R) {\n      t && o.add(t);\n      var N = function() {\n        e == null || e(), R();\n      };\n      o.queue.length ? (o.completes.push(N), o.ticking || (o.ticking = !0, Ticker.system.addOnce(o.tick, o, UPDATE_PRIORITY.UTILITY))) : N();\n    });\n  }, n.prototype.tick = function() {\n    setTimeout(this.delayedTick, 0);\n  }, n.prototype.prepareItems = function() {\n    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n      var t = this.queue[0], e = !1;\n      if (t && !t._destroyed) {\n        for (var o = 0, R = this.uploadHooks.length; o < R; o++)\n          if (this.uploadHooks[o](this.uploadHookHelper, t)) {\n            this.queue.shift(), e = !0;\n            break;\n          }\n      }\n      e || this.queue.shift();\n    }\n    if (this.queue.length)\n      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n    else {\n      this.ticking = !1;\n      var N = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var o = 0, R = N.length; o < R; o++)\n        N[o]();\n    }\n  }, n.prototype.registerFindHook = function(t) {\n    return t && this.addHooks.push(t), this;\n  }, n.prototype.registerUploadHook = function(t) {\n    return t && this.uploadHooks.push(t), this;\n  }, n.prototype.add = function(t) {\n    for (var e = 0, o = this.addHooks.length; e < o && !this.addHooks[e](t, this.queue); e++)\n      ;\n    if (t instanceof Container)\n      for (var e = t.children.length - 1; e >= 0; e--)\n        this.add(t.children[e]);\n    return this;\n  }, n.prototype.destroy = function() {\n    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n  }, n;\n}();\nfunction uploadBaseTextures(n, t) {\n  return t instanceof BaseTexture ? (t._glTextures[n.CONTEXT_UID] || n.texture.bind(t), !0) : !1;\n}\nfunction uploadGraphics(n, t) {\n  if (!(t instanceof Graphics))\n    return !1;\n  var e = t.geometry;\n  t.finishPoly(), e.updateBatches();\n  for (var o = e.batches, R = 0; R < o.length; R++) {\n    var N = o[R].style.texture;\n    N && uploadBaseTextures(n, N.baseTexture);\n  }\n  return e.batchable || n.geometry.bind(e, t._resolveDirectShader(n)), !0;\n}\nfunction findGraphics(n, t) {\n  return n instanceof Graphics ? (t.push(n), !0) : !1;\n}\nvar Prepare = function(n) {\n  __extends$i(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return o.uploadHookHelper = o.renderer, o.registerFindHook(findGraphics), o.registerUploadHook(uploadBaseTextures), o.registerUploadHook(uploadGraphics), o;\n  }\n  return t.extension = {\n    name: \"prepare\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(BasePrepare);\n/*!\n * @pixi/spritesheet - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Spritesheet = function() {\n  function n(t, e, o) {\n    o === void 0 && (o = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;\n    var R = this.baseTexture.resource;\n    this.resolution = this._updateResolution(o || (R ? R.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n  }\n  return n.prototype._updateResolution = function(t) {\n    t === void 0 && (t = null);\n    var e = this.data.meta.scale, o = getResolutionOfUrl(t, null);\n    return o === null && (o = e !== void 0 ? parseFloat(e) : 1), o !== 1 && this.baseTexture.setResolution(o), o;\n  }, n.prototype.parse = function(t) {\n    var e = this;\n    return t && deprecation$1(\"6.5.0\", \"Spritesheet.parse callback is deprecated, use the return Promise instead.\"), new Promise(function(o) {\n      e._callback = function(R) {\n        t == null || t(R), o(R);\n      }, e._batchIndex = 0, e._frameKeys.length <= n.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();\n    });\n  }, n.prototype._processFrames = function(t) {\n    for (var e = t, o = n.BATCH_SIZE; e - t < o && e < this._frameKeys.length; ) {\n      var R = this._frameKeys[e], N = this._frames[R], M = N.frame;\n      if (M) {\n        var D = null, L = null, B = N.trimmed !== !1 && N.sourceSize ? N.sourceSize : N.frame, $ = new Rectangle(0, 0, Math.floor(B.w) / this.resolution, Math.floor(B.h) / this.resolution);\n        N.rotated ? D = new Rectangle(Math.floor(M.x) / this.resolution, Math.floor(M.y) / this.resolution, Math.floor(M.h) / this.resolution, Math.floor(M.w) / this.resolution) : D = new Rectangle(Math.floor(M.x) / this.resolution, Math.floor(M.y) / this.resolution, Math.floor(M.w) / this.resolution, Math.floor(M.h) / this.resolution), N.trimmed !== !1 && N.spriteSourceSize && (L = new Rectangle(Math.floor(N.spriteSourceSize.x) / this.resolution, Math.floor(N.spriteSourceSize.y) / this.resolution, Math.floor(M.w) / this.resolution, Math.floor(M.h) / this.resolution)), this.textures[R] = new Texture(this.baseTexture, D, $, L, N.rotated ? 2 : 0, N.anchor), Texture.addToCache(this.textures[R], R);\n      }\n      e++;\n    }\n  }, n.prototype._processAnimations = function() {\n    var t = this.data.animations || {};\n    for (var e in t) {\n      this.animations[e] = [];\n      for (var o = 0; o < t[e].length; o++) {\n        var R = t[e][o];\n        this.animations[e].push(this.textures[R]);\n      }\n    }\n  }, n.prototype._parseComplete = function() {\n    var t = this._callback;\n    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);\n  }, n.prototype._nextBatch = function() {\n    var t = this;\n    this._processFrames(this._batchIndex * n.BATCH_SIZE), this._batchIndex++, setTimeout(function() {\n      t._batchIndex * n.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());\n    }, 0);\n  }, n.prototype.destroy = function(t) {\n    var e;\n    t === void 0 && (t = !1);\n    for (var o in this.textures)\n      this.textures[o].destroy();\n    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n  }, n.BATCH_SIZE = 1e3, n;\n}(), SpritesheetLoader = function() {\n  function n() {\n  }\n  return n.use = function(t, e) {\n    var o, R, N = this, M = t.name + \"_image\";\n    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || N.resources[M]) {\n      e();\n      return;\n    }\n    var D = (R = (o = t.data) === null || o === void 0 ? void 0 : o.meta) === null || R === void 0 ? void 0 : R.related_multi_packs;\n    if (Array.isArray(D))\n      for (var L = function(X) {\n        if (typeof X != \"string\")\n          return \"continue\";\n        var V = X.replace(\".json\", \"\"), W = url.resolve(t.url.replace(N.baseUrl, \"\"), X);\n        if (N.resources[V] || Object.values(N.resources).some(function(q) {\n          return url.format(url.parse(q.url)) === W;\n        }))\n          return \"continue\";\n        var Y = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: t,\n          metadata: t.metadata\n        };\n        N.add(V, W, Y);\n      }, B = 0, $ = D; B < $.length; B++) {\n        var k = $[B];\n        L(k);\n      }\n    var U = {\n      crossOrigin: t.crossOrigin,\n      metadata: t.metadata.imageMetadata,\n      parentResource: t\n    }, z = n.getResourcePath(t, N.baseUrl);\n    N.add(M, z, U, function(V) {\n      if (V.error) {\n        e(V.error);\n        return;\n      }\n      var W = new Spritesheet(V.texture, t.data, t.url);\n      W.parse().then(function() {\n        t.spritesheet = W, t.textures = W.textures, e();\n      });\n    });\n  }, n.getResourcePath = function(t, e) {\n    return t.isDataUrl ? t.data.meta.image : url.resolve(t.url.replace(e, \"\"), t.data.meta.image);\n  }, n.extension = ExtensionType.Loader, n;\n}();\n/*!\n * @pixi/sprite-tiling - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$h = function(n, t) {\n  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$h(n, t);\n};\nfunction __extends$h(n, t) {\n  extendStatics$h(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$1 = new Point();\n(function(n) {\n  __extends$h(t, n);\n  function t(e, o, R) {\n    o === void 0 && (o = 100), R === void 0 && (R = 100);\n    var N = n.call(this, e) || this;\n    return N.tileTransform = new Transform(), N._width = o, N._height = R, N.uvMatrix = N.texture.uvMatrix || new TextureMatrix(e), N.pluginName = \"tilingSprite\", N.uvRespectAnchor = !1, N;\n  }\n  return Object.defineProperty(t.prototype, \"clampMargin\", {\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(e) {\n      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tileScale\", {\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(e) {\n      this.tileTransform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tilePosition\", {\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(e) {\n      this.tileTransform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._onTextureUpdate = function() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }, t.prototype._render = function(e) {\n    var o = this._texture;\n    !o || !o.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));\n  }, t.prototype._calculateBounds = function() {\n    var e = this._width * -this._anchor._x, o = this._height * -this._anchor._y, R = this._width * (1 - this._anchor._x), N = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, e, o, R, N);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : n.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$1);\n    var o = this._width, R = this._height, N = -o * this.anchor._x;\n    if (tempPoint$1.x >= N && tempPoint$1.x < N + o) {\n      var M = -R * this.anchor._y;\n      if (tempPoint$1.y >= M && tempPoint$1.y < M + R)\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    n.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;\n  }, t.from = function(e, o) {\n    var R = e instanceof Texture ? e : Texture.from(e, o);\n    return new t(R, o.width, o.height);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Sprite);\nvar fragmentSimpleSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`, gl1VertexSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl1FragmentSrc = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`, gl2VertexSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl2FragmentSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`, tempMat = new Matrix(), TilingSpriteRenderer = function(n) {\n  __extends$h(t, n);\n  function t(e) {\n    var o = n.call(this, e) || this;\n    return e.runners.contextChange.add(o), o.quad = new QuadUv(), o.state = State.for2d(), o;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer, o = { globals: e.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, o), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, o) : Shader.from(gl1VertexSrc, gl1FragmentSrc, o);\n  }, t.prototype.render = function(e) {\n    var o = this.renderer, R = this.quad, N = R.vertices;\n    N[0] = N[6] = e._width * -e.anchor.x, N[1] = N[3] = e._height * -e.anchor.y, N[2] = N[4] = e._width * (1 - e.anchor.x), N[5] = N[7] = e._height * (1 - e.anchor.y);\n    var M = e.uvRespectAnchor ? e.anchor.x : 0, D = e.uvRespectAnchor ? e.anchor.y : 0;\n    N = R.uvs, N[0] = N[6] = -M, N[1] = N[3] = -D, N[2] = N[4] = 1 - M, N[5] = N[7] = 1 - D, R.invalidate();\n    var L = e._texture, B = L.baseTexture, $ = B.alphaMode > 0, k = e.tileTransform.localTransform, U = e.uvMatrix, z = B.isPowerOfTwo && L.frame.width === B.width && L.frame.height === B.height;\n    z && (B._glTextures[o.CONTEXT_UID] ? z = B.wrapMode !== WRAP_MODES$5.CLAMP : B.wrapMode === WRAP_MODES$5.CLAMP && (B.wrapMode = WRAP_MODES$5.REPEAT));\n    var X = z ? this.simpleShader : this.shader, V = L.width, W = L.height, Y = e._width, q = e._height;\n    tempMat.set(k.a * V / Y, k.b * V / q, k.c * W / Y, k.d * W / q, k.tx / Y, k.ty / q), tempMat.invert(), z ? tempMat.prepend(U.mapCoord) : (X.uniforms.uMapCoord = U.mapCoord.toArray(!0), X.uniforms.uClampFrame = U.uClampFrame, X.uniforms.uClampOffset = U.uClampOffset), X.uniforms.uTransform = tempMat.toArray(!0), X.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, X.uniforms.uColor, $), X.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), X.uniforms.uSampler = L, o.shader.bind(X), o.geometry.bind(R), this.state.blendMode = correctBlendMode(e.blendMode, $), o.state.set(this.state), o.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }, t.extension = {\n    name: \"tilingSprite\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\n/*!\n * @pixi/mesh - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$g = function(n, t) {\n  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$g(n, t);\n};\nfunction __extends$g(n, t) {\n  extendStatics$g(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar MeshBatchUvs = function() {\n  function n(t, e) {\n    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n  }\n  return n.prototype.update = function(t) {\n    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {\n      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n      var e = this.uvBuffer.data;\n      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;\n    }\n  }, n;\n}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(n) {\n  __extends$g(t, n);\n  function t(e, o, R, N) {\n    N === void 0 && (N = DRAW_MODES$5.TRIANGLES);\n    var M = n.call(this) || this;\n    return M.geometry = e, M.shader = o, M.state = R || State.for2d(), M.drawMode = N, M.start = 0, M.size = 0, M.uvs = null, M.indices = null, M.vertexData = new Float32Array(1), M.vertexDirty = -1, M._transformID = -1, M._roundPixels = settings$1.ROUND_PIXELS, M.batchUvs = null, M;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    set: function(e) {\n      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"uvBuffer\", {\n    get: function() {\n      return this.geometry.buffers[1];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"verticesBuffer\", {\n    get: function() {\n      return this.geometry.buffers[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"material\", {\n    get: function() {\n      return this.shader;\n    },\n    set: function(e) {\n      this.shader = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function(e) {\n      this.shader.tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function(e) {\n      this.shader.texture = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    var o = this.geometry.buffers[0].data, R = this.shader;\n    R.batchable && this.drawMode === DRAW_MODES$5.TRIANGLES && o.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);\n  }, t.prototype._renderDefault = function(e) {\n    var o = this.shader;\n    o.alpha = this.worldAlpha, o.update && o.update(), e.batch.flush(), o.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(o), e.state.set(this.state), e.geometry.bind(this.geometry, o), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }, t.prototype._renderToBatch = function(e) {\n    var o = this.geometry, R = this.shader;\n    R.uvMatrix && (R.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = o.indexBuffer.data, this._tintRGB = R._tintRGB, this._texture = R.texture;\n    var N = this.material.pluginName;\n    e.batch.setObjectRenderer(e.plugins[N]), e.plugins[N].render(this);\n  }, t.prototype.calculateVertices = function() {\n    var e = this.geometry, o = e.buffers[0], R = o.data, N = o._updateID;\n    if (!(N === this.vertexDirty && this._transformID === this.transform._worldID)) {\n      this._transformID = this.transform._worldID, this.vertexData.length !== R.length && (this.vertexData = new Float32Array(R.length));\n      for (var M = this.transform.worldTransform, D = M.a, L = M.b, B = M.c, $ = M.d, k = M.tx, U = M.ty, z = this.vertexData, X = 0; X < z.length / 2; X++) {\n        var V = R[X * 2], W = R[X * 2 + 1];\n        z[X * 2] = D * V + B * W + k, z[X * 2 + 1] = L * V + $ * W + U;\n      }\n      if (this._roundPixels)\n        for (var Y = settings$1.RESOLUTION, X = 0; X < z.length; ++X)\n          z[X] = Math.round((z[X] * Y | 0) / Y);\n      this.vertexDirty = N;\n    }\n  }, t.prototype.calculateUvs = function() {\n    var e = this.geometry.buffers[1], o = this.shader;\n    o.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, o.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }, t.prototype.containsPoint = function(e) {\n    if (!this.getBounds().contains(e.x, e.y))\n      return !1;\n    this.worldTransform.applyInverse(e, tempPoint);\n    for (var o = this.geometry.getBuffer(\"aVertexPosition\").data, R = tempPolygon.points, N = this.geometry.getIndex().data, M = N.length, D = this.drawMode === 4 ? 3 : 1, L = 0; L + 2 < M; L += D) {\n      var B = N[L] * 2, $ = N[L + 1] * 2, k = N[L + 2] * 2;\n      if (R[0] = o[B], R[1] = o[B + 1], R[2] = o[$], R[3] = o[$ + 1], R[4] = o[k], R[5] = o[k + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    n.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(Container), fragment$5 = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`, vertex$2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`, MeshMaterial = function(n) {\n  __extends$g(t, n);\n  function t(e, o) {\n    var R = this, N = {\n      uSampler: e,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    return o = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: \"batch\"\n    }, o), o.uniforms && Object.assign(N, o.uniforms), R = n.call(this, o.program || Program.from(vertex$2, fragment$5), N) || this, R._colorDirty = !1, R.uvMatrix = new TextureMatrix(e), R.batchable = o.program === void 0, R.pluginName = o.pluginName, R.tint = o.tint, R.alpha = o.alpha, R;\n  }\n  return Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.uniforms.uSampler;\n    },\n    set: function(e) {\n      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this._alpha;\n    },\n    set: function(e) {\n      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.update = function() {\n    if (this._colorDirty) {\n      this._colorDirty = !1;\n      var e = this.texture.baseTexture;\n      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);\n    }\n    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n  }, t;\n}(Shader), MeshGeometry = function(n) {\n  __extends$g(t, n);\n  function t(e, o, R) {\n    var N = n.call(this) || this, M = new Buffer$1(e), D = new Buffer$1(o, !0), L = new Buffer$1(R, !0, !0);\n    return N.addAttribute(\"aVertexPosition\", M, 2, !1, TYPES$5.FLOAT).addAttribute(\"aTextureCoord\", D, 2, !1, TYPES$5.FLOAT).addIndex(L), N._updateId = -1, N;\n  }\n  return Object.defineProperty(t.prototype, \"vertexDirtyId\", {\n    get: function() {\n      return this.buffers[0]._updateID;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Geometry);\n/*!\n * @pixi/text-bitmap - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$f = function(n, t) {\n  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$f(n, t);\n};\nfunction __extends$f(n, t) {\n  extendStatics$f(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar BitmapFontData = function() {\n  function n() {\n    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n  }\n  return n;\n}(), TextFormat = function() {\n  function n() {\n  }\n  return n.test = function(t) {\n    return typeof t == \"string\" && t.indexOf(\"info face=\") === 0;\n  }, n.parse = function(t) {\n    var e = t.match(/^[a-z]+\\s+.+$/gm), o = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (var R in e) {\n      var N = e[R].match(/^[a-z]+/gm)[0], M = e[R].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm), D = {};\n      for (var L in M) {\n        var B = M[L].split(\"=\"), $ = B[0], k = B[1].replace(/\"/gm, \"\"), U = parseFloat(k), z = isNaN(U) ? k : U;\n        D[$] = z;\n      }\n      o[N].push(D);\n    }\n    var X = new BitmapFontData();\n    return o.info.forEach(function(V) {\n      return X.info.push({\n        face: V.face,\n        size: parseInt(V.size, 10)\n      });\n    }), o.common.forEach(function(V) {\n      return X.common.push({\n        lineHeight: parseInt(V.lineHeight, 10)\n      });\n    }), o.page.forEach(function(V) {\n      return X.page.push({\n        id: parseInt(V.id, 10),\n        file: V.file\n      });\n    }), o.char.forEach(function(V) {\n      return X.char.push({\n        id: parseInt(V.id, 10),\n        page: parseInt(V.page, 10),\n        x: parseInt(V.x, 10),\n        y: parseInt(V.y, 10),\n        width: parseInt(V.width, 10),\n        height: parseInt(V.height, 10),\n        xoffset: parseInt(V.xoffset, 10),\n        yoffset: parseInt(V.yoffset, 10),\n        xadvance: parseInt(V.xadvance, 10)\n      });\n    }), o.kerning.forEach(function(V) {\n      return X.kerning.push({\n        first: parseInt(V.first, 10),\n        second: parseInt(V.second, 10),\n        amount: parseInt(V.amount, 10)\n      });\n    }), o.distanceField.forEach(function(V) {\n      return X.distanceField.push({\n        distanceRange: parseInt(V.distanceRange, 10),\n        fieldType: V.fieldType\n      });\n    }), X;\n  }, n;\n}(), XMLFormat = function() {\n  function n() {\n  }\n  return n.test = function(t) {\n    return t instanceof XMLDocument && t.getElementsByTagName(\"page\").length && t.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  }, n.parse = function(t) {\n    for (var e = new BitmapFontData(), o = t.getElementsByTagName(\"info\"), R = t.getElementsByTagName(\"common\"), N = t.getElementsByTagName(\"page\"), M = t.getElementsByTagName(\"char\"), D = t.getElementsByTagName(\"kerning\"), L = t.getElementsByTagName(\"distanceField\"), B = 0; B < o.length; B++)\n      e.info.push({\n        face: o[B].getAttribute(\"face\"),\n        size: parseInt(o[B].getAttribute(\"size\"), 10)\n      });\n    for (var B = 0; B < R.length; B++)\n      e.common.push({\n        lineHeight: parseInt(R[B].getAttribute(\"lineHeight\"), 10)\n      });\n    for (var B = 0; B < N.length; B++)\n      e.page.push({\n        id: parseInt(N[B].getAttribute(\"id\"), 10) || 0,\n        file: N[B].getAttribute(\"file\")\n      });\n    for (var B = 0; B < M.length; B++) {\n      var $ = M[B];\n      e.char.push({\n        id: parseInt($.getAttribute(\"id\"), 10),\n        page: parseInt($.getAttribute(\"page\"), 10) || 0,\n        x: parseInt($.getAttribute(\"x\"), 10),\n        y: parseInt($.getAttribute(\"y\"), 10),\n        width: parseInt($.getAttribute(\"width\"), 10),\n        height: parseInt($.getAttribute(\"height\"), 10),\n        xoffset: parseInt($.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt($.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt($.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (var B = 0; B < D.length; B++)\n      e.kerning.push({\n        first: parseInt(D[B].getAttribute(\"first\"), 10),\n        second: parseInt(D[B].getAttribute(\"second\"), 10),\n        amount: parseInt(D[B].getAttribute(\"amount\"), 10)\n      });\n    for (var B = 0; B < L.length; B++)\n      e.distanceField.push({\n        fieldType: L[B].getAttribute(\"fieldType\"),\n        distanceRange: parseInt(L[B].getAttribute(\"distanceRange\"), 10)\n      });\n    return e;\n  }, n;\n}(), XMLStringFormat = function() {\n  function n() {\n  }\n  return n.test = function(t) {\n    if (typeof t == \"string\" && t.indexOf(\"<font>\") > -1) {\n      var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n      return XMLFormat.test(e);\n    }\n    return !1;\n  }, n.parse = function(t) {\n    var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n    return XMLFormat.parse(e);\n  }, n;\n}(), formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(n) {\n  for (var t = 0; t < formats.length; t++)\n    if (formats[t].test(n))\n      return formats[t];\n  return null;\n}\nfunction generateFillStyle(n, t, e, o, R, N) {\n  var M = e.fill;\n  if (Array.isArray(M)) {\n    if (M.length === 1)\n      return M[0];\n  } else\n    return M;\n  var D, L = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = n.width / o - L - B * 2, k = n.height / o - L - B * 2, U = M.slice(), z = e.fillGradientStops.slice();\n  if (!z.length)\n    for (var X = U.length + 1, V = 1; V < X; ++V)\n      z.push(V / X);\n  if (U.unshift(M[0]), z.unshift(0), U.push(M[M.length - 1]), z.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    D = t.createLinearGradient($ / 2, B, $ / 2, k + B);\n    for (var W = 0, Y = N.fontProperties.fontSize + e.strokeThickness, q = Y / k, V = 0; V < R.length; V++)\n      for (var Z = N.lineHeight * V, K = 0; K < U.length; K++) {\n        var Q = 0;\n        typeof z[K] == \"number\" ? Q = z[K] : Q = K / U.length;\n        var J = Z / k + Q * q, rt = Math.max(W, J);\n        rt = Math.min(rt, 1), D.addColorStop(rt, U[K]), W = rt;\n      }\n  } else {\n    D = t.createLinearGradient(B, k / 2, $ + B, k / 2);\n    for (var tt = U.length + 1, nt = 1, V = 0; V < U.length; V++) {\n      var st = void 0;\n      typeof z[V] == \"number\" ? st = z[V] : st = nt / tt, D.addColorStop(st, U[V]), nt++;\n    }\n  }\n  return D;\n}\nfunction drawGlyph(n, t, e, o, R, N, M) {\n  var D = e.text, L = e.fontProperties;\n  t.translate(o, R), t.scale(N, N);\n  var B = M.strokeThickness / 2, $ = -(M.strokeThickness / 2);\n  if (t.font = M.toFontString(), t.lineWidth = M.strokeThickness, t.textBaseline = M.textBaseline, t.lineJoin = M.lineJoin, t.miterLimit = M.miterLimit, t.fillStyle = generateFillStyle(n, t, M, N, [D], e), t.strokeStyle = M.stroke, M.dropShadow) {\n    var k = M.dropShadowColor, U = hex2rgb(typeof k == \"number\" ? k : string2hex(k)), z = M.dropShadowBlur * N, X = M.dropShadowDistance * N;\n    t.shadowColor = \"rgba(\" + U[0] * 255 + \",\" + U[1] * 255 + \",\" + U[2] * 255 + \",\" + M.dropShadowAlpha + \")\", t.shadowBlur = z, t.shadowOffsetX = Math.cos(M.dropShadowAngle) * X, t.shadowOffsetY = Math.sin(M.dropShadowAngle) * X;\n  } else\n    t.shadowColor = \"black\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;\n  M.stroke && M.strokeThickness && t.strokeText(D, B, $ + e.lineHeight - L.descent), M.fill && t.fillText(D, B, $ + e.lineHeight - L.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction splitTextToCharacters(n) {\n  return Array.from ? Array.from(n) : n.split(\"\");\n}\nfunction resolveCharacters(n) {\n  typeof n == \"string\" && (n = [n]);\n  for (var t = [], e = 0, o = n.length; e < o; e++) {\n    var R = n[e];\n    if (Array.isArray(R)) {\n      if (R.length !== 2)\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + R.length + \".\");\n      var N = R[0].charCodeAt(0), M = R[1].charCodeAt(0);\n      if (M < N)\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      for (var D = N, L = M; D <= L; D++)\n        t.push(String.fromCharCode(D));\n    } else\n      t.push.apply(t, splitTextToCharacters(R));\n  }\n  if (t.length === 0)\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  return t;\n}\nfunction extractCharCode(n) {\n  return n.codePointAt ? n.codePointAt(0) : n.charCodeAt(0);\n}\nvar BitmapFont = function() {\n  function n(t, e, o) {\n    var R, N, M = t.info[0], D = t.common[0], L = t.page[0], B = t.distanceField[0], $ = getResolutionOfUrl(L.file), k = {};\n    this._ownsTextures = o, this.font = M.face, this.size = M.size, this.lineHeight = D.lineHeight / $, this.chars = {}, this.pageTextures = k;\n    for (var U = 0; U < t.page.length; U++) {\n      var z = t.page[U], X = z.id, V = z.file;\n      k[X] = e instanceof Array ? e[U] : e[V], (B == null ? void 0 : B.fieldType) && B.fieldType !== \"none\" && (k[X].baseTexture.alphaMode = ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA);\n    }\n    for (var U = 0; U < t.char.length; U++) {\n      var W = t.char[U], X = W.id, Y = W.page, q = t.char[U], Z = q.x, K = q.y, Q = q.width, J = q.height, rt = q.xoffset, tt = q.yoffset, nt = q.xadvance;\n      Z /= $, K /= $, Q /= $, J /= $, rt /= $, tt /= $, nt /= $;\n      var st = new Rectangle(Z + k[Y].frame.x / $, K + k[Y].frame.y / $, Q, J);\n      this.chars[X] = {\n        xOffset: rt,\n        yOffset: tt,\n        xAdvance: nt,\n        kerning: {},\n        texture: new Texture(k[Y].baseTexture, st),\n        page: Y\n      };\n    }\n    for (var U = 0; U < t.kerning.length; U++) {\n      var ut = t.kerning[U], ct = ut.first, dt = ut.second, Et = ut.amount;\n      ct /= $, dt /= $, Et /= $, this.chars[dt] && (this.chars[dt].kerning[ct] = Et);\n    }\n    this.distanceFieldRange = B == null ? void 0 : B.distanceRange, this.distanceFieldType = (N = (R = B == null ? void 0 : B.fieldType) === null || R === void 0 ? void 0 : R.toLowerCase()) !== null && N !== void 0 ? N : \"none\";\n  }\n  return n.prototype.destroy = function() {\n    for (var t in this.chars)\n      this.chars[t].texture.destroy(), this.chars[t].texture = null;\n    for (var t in this.pageTextures)\n      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;\n    this.chars = null, this.pageTextures = null;\n  }, n.install = function(t, e, o) {\n    var R;\n    if (t instanceof BitmapFontData)\n      R = t;\n    else {\n      var N = autoDetectFormat(t);\n      if (!N)\n        throw new Error(\"Unrecognized data format for font.\");\n      R = N.parse(t);\n    }\n    e instanceof Texture && (e = [e]);\n    var M = new n(R, e, o);\n    return n.available[M.font] = M, M;\n  }, n.uninstall = function(t) {\n    var e = n.available[t];\n    if (!e)\n      throw new Error(\"No font found named '\" + t + \"'\");\n    e.destroy(), delete n.available[t];\n  }, n.from = function(t, e, o) {\n    if (!t)\n      throw new Error(\"[BitmapFont] Property `name` is required.\");\n    var R = Object.assign({}, n.defaultOptions, o), N = R.chars, M = R.padding, D = R.resolution, L = R.textureWidth, B = R.textureHeight, $ = resolveCharacters(N), k = e instanceof TextStyle ? e : new TextStyle(e), U = L, z = new BitmapFontData();\n    z.info[0] = {\n      face: k.fontFamily,\n      size: k.fontSize\n    }, z.common[0] = {\n      lineHeight: k.fontSize\n    };\n    for (var X = 0, V = 0, W, Y, q, Z = 0, K = [], Q = 0; Q < $.length; Q++) {\n      W || (W = settings$1.ADAPTER.createCanvas(), W.width = L, W.height = B, Y = W.getContext(\"2d\"), q = new BaseTexture(W, { resolution: D }), K.push(new Texture(q)), z.page.push({\n        id: K.length - 1,\n        file: \"\"\n      }));\n      var J = TextMetrics.measureText($[Q], k, !1, W), rt = J.width, tt = Math.ceil(J.height), nt = Math.ceil((k.fontStyle === \"italic\" ? 2 : 1) * rt);\n      if (V >= B - tt * D) {\n        if (V === 0)\n          throw new Error(\"[BitmapFont] textureHeight \" + B + \"px is \" + (\"too small for \" + k.fontSize + \"px fonts\"));\n        --Q, W = null, Y = null, q = null, V = 0, X = 0, Z = 0;\n        continue;\n      }\n      if (Z = Math.max(tt + J.fontProperties.descent, Z), nt * D + X >= U) {\n        --Q, V += Z * D, V = Math.ceil(V), X = 0, Z = 0;\n        continue;\n      }\n      drawGlyph(W, Y, J, X, V, D, k);\n      var st = extractCharCode(J.text);\n      z.char.push({\n        id: st,\n        page: K.length - 1,\n        x: X / D,\n        y: V / D,\n        width: nt,\n        height: tt,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: Math.ceil(rt - (k.dropShadow ? k.dropShadowDistance : 0) - (k.stroke ? k.strokeThickness : 0))\n      }), X += (nt + 2 * M) * D, X = Math.ceil(X);\n    }\n    for (var Q = 0, ut = $.length; Q < ut; Q++)\n      for (var ct = $[Q], dt = 0; dt < ut; dt++) {\n        var Et = $[dt], vt = Y.measureText(ct).width, _t = Y.measureText(Et).width, St = Y.measureText(ct + Et).width, Ft = St - (vt + _t);\n        Ft && z.kerning.push({\n          first: extractCharCode(ct),\n          second: extractCharCode(Et),\n          amount: Ft\n        });\n      }\n    var mt = new n(z, K, !0);\n    return n.available[t] !== void 0 && n.uninstall(t), n.available[t] = mt, mt;\n  }, n.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"], n.NUMERIC = [[\"0\", \"9\"]], n.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"], n.ASCII = [[\" \", \"~\"]], n.defaultOptions = {\n    resolution: 1,\n    textureWidth: 512,\n    textureHeight: 512,\n    padding: 4,\n    chars: n.ALPHANUMERIC\n  }, n.available = {}, n;\n}(), msdfFrag = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\n\\r\n}\\r\n`, msdfVert = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];\n(function(n) {\n  __extends$f(t, n);\n  function t(e, o) {\n    o === void 0 && (o = {});\n    var R = n.call(this) || this;\n    R._tint = 16777215;\n    var N = Object.assign({}, t.styleDefaults, o), M = N.align, D = N.tint, L = N.maxWidth, B = N.letterSpacing, $ = N.fontName, k = N.fontSize;\n    if (!BitmapFont.available[$])\n      throw new Error('Missing BitmapFont \"' + $ + '\"');\n    return R._activePagesMeshData = [], R._textWidth = 0, R._textHeight = 0, R._align = M, R._tint = D, R._fontName = $, R._fontSize = k || BitmapFont.available[$].size, R.text = e, R._maxWidth = L, R._maxLineHeight = 0, R._letterSpacing = B, R._anchor = new ObservablePoint(function() {\n      R.dirty = !0;\n    }, R, 0, 0), R._roundPixels = settings$1.ROUND_PIXELS, R.dirty = !0, R._resolution = settings$1.RESOLUTION, R._autoResolution = !0, R._textureCache = {}, R;\n  }\n  return t.prototype.updateText = function() {\n    for (var e, o = BitmapFont.available[this._fontName], R = this._fontSize / o.size, N = new Point(), M = [], D = [], L = [], B = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \", $ = splitTextToCharacters(B), k = this._maxWidth * o.size / this._fontSize, U = o.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, z = null, X = 0, V = 0, W = 0, Y = -1, q = 0, Z = 0, K = 0, Q = 0, J = 0; J < $.length; J++) {\n      var rt = $[J], tt = extractCharCode(rt);\n      if (/(?:\\s)/.test(rt) && (Y = J, q = X, Q++), rt === \"\\r\" || rt === `\n`) {\n        D.push(X), L.push(-1), V = Math.max(V, X), ++W, ++Z, N.x = 0, N.y += o.lineHeight, z = null, Q = 0;\n        continue;\n      }\n      var nt = o.chars[tt];\n      if (!!nt) {\n        z && nt.kerning[z] && (N.x += nt.kerning[z]);\n        var st = charRenderDataPool.pop() || {\n          texture: Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new Point()\n        };\n        st.texture = nt.texture, st.line = W, st.charCode = tt, st.position.x = N.x + nt.xOffset + this._letterSpacing / 2, st.position.y = N.y + nt.yOffset, st.prevSpaces = Q, M.push(st), X = st.position.x + Math.max(nt.xAdvance, nt.texture.orig.width), N.x += nt.xAdvance + this._letterSpacing, K = Math.max(K, nt.yOffset + nt.texture.height), z = tt, Y !== -1 && k > 0 && N.x > k && (++Z, removeItems(M, 1 + Y - Z, 1 + J - Y), J = Y, Y = -1, D.push(q), L.push(M.length > 0 ? M[M.length - 1].prevSpaces : 0), V = Math.max(V, q), W++, N.x = 0, N.y += o.lineHeight, z = null, Q = 0);\n      }\n    }\n    var ut = $[$.length - 1];\n    ut !== \"\\r\" && ut !== `\n` && (/(?:\\s)/.test(ut) && (X = q), D.push(X), V = Math.max(V, X), L.push(-1));\n    for (var ct = [], J = 0; J <= W; J++) {\n      var dt = 0;\n      this._align === \"right\" ? dt = V - D[J] : this._align === \"center\" ? dt = (V - D[J]) / 2 : this._align === \"justify\" && (dt = L[J] < 0 ? 0 : (V - D[J]) / L[J]), ct.push(dt);\n    }\n    for (var Et = M.length, vt = {}, _t = [], St = this._activePagesMeshData, J = 0; J < St.length; J++)\n      U.push(St[J]);\n    for (var J = 0; J < Et; J++) {\n      var Ft = M[J].texture, mt = Ft.baseTexture.uid;\n      if (!vt[mt]) {\n        var ht = U.pop();\n        if (!ht) {\n          var pt = new MeshGeometry(), xt = void 0, At = void 0;\n          o.distanceFieldType === \"none\" ? (xt = new MeshMaterial(Texture.EMPTY), At = BLEND_MODES$5.NORMAL) : (xt = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), At = BLEND_MODES$5.NORMAL_NPM);\n          var Rt = new Mesh(pt, xt);\n          Rt.blendMode = At, ht = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh: Rt,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        ht.index = 0, ht.indexCount = 0, ht.vertexCount = 0, ht.uvsCount = 0, ht.total = 0;\n        var Lt = this._textureCache;\n        Lt[mt] = Lt[mt] || new Texture(Ft.baseTexture), ht.mesh.texture = Lt[mt], ht.mesh.tint = this._tint, _t.push(ht), vt[mt] = ht;\n      }\n      vt[mt].total++;\n    }\n    for (var J = 0; J < St.length; J++)\n      _t.indexOf(St[J]) === -1 && this.removeChild(St[J].mesh);\n    for (var J = 0; J < _t.length; J++)\n      _t[J].mesh.parent !== this && this.addChild(_t[J].mesh);\n    this._activePagesMeshData = _t;\n    for (var J in vt) {\n      var ht = vt[J], lt = ht.total;\n      if (!(((e = ht.indices) === null || e === void 0 ? void 0 : e.length) > 6 * lt) || ht.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n        ht.vertices = new Float32Array(4 * 2 * lt), ht.uvs = new Float32Array(4 * 2 * lt), ht.indices = new Uint16Array(6 * lt);\n      else\n        for (var $t = ht.total, Pt = ht.vertices, kt = $t * 4 * 2; kt < Pt.length; kt++)\n          Pt[kt] = 0;\n      ht.mesh.size = 6 * lt;\n    }\n    for (var J = 0; J < Et; J++) {\n      var rt = M[J], Ot = rt.position.x + ct[rt.line] * (this._align === \"justify\" ? rt.prevSpaces : 1);\n      this._roundPixels && (Ot = Math.round(Ot));\n      var gt = Ot * R, Gt = rt.position.y * R, Ft = rt.texture, Tt = vt[Ft.baseTexture.uid], bt = Ft.frame, wt = Ft._uvs, Mt = Tt.index++;\n      Tt.indices[Mt * 6 + 0] = 0 + Mt * 4, Tt.indices[Mt * 6 + 1] = 1 + Mt * 4, Tt.indices[Mt * 6 + 2] = 2 + Mt * 4, Tt.indices[Mt * 6 + 3] = 0 + Mt * 4, Tt.indices[Mt * 6 + 4] = 2 + Mt * 4, Tt.indices[Mt * 6 + 5] = 3 + Mt * 4, Tt.vertices[Mt * 8 + 0] = gt, Tt.vertices[Mt * 8 + 1] = Gt, Tt.vertices[Mt * 8 + 2] = gt + bt.width * R, Tt.vertices[Mt * 8 + 3] = Gt, Tt.vertices[Mt * 8 + 4] = gt + bt.width * R, Tt.vertices[Mt * 8 + 5] = Gt + bt.height * R, Tt.vertices[Mt * 8 + 6] = gt, Tt.vertices[Mt * 8 + 7] = Gt + bt.height * R, Tt.uvs[Mt * 8 + 0] = wt.x0, Tt.uvs[Mt * 8 + 1] = wt.y0, Tt.uvs[Mt * 8 + 2] = wt.x1, Tt.uvs[Mt * 8 + 3] = wt.y1, Tt.uvs[Mt * 8 + 4] = wt.x2, Tt.uvs[Mt * 8 + 5] = wt.y2, Tt.uvs[Mt * 8 + 6] = wt.x3, Tt.uvs[Mt * 8 + 7] = wt.y3;\n    }\n    this._textWidth = V * R, this._textHeight = (N.y + o.lineHeight) * R;\n    for (var J in vt) {\n      var ht = vt[J];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        for (var Ct = 0, Zt = this._textWidth * this.anchor.x, Yt = this._textHeight * this.anchor.y, se = 0; se < ht.total; se++)\n          ht.vertices[Ct++] -= Zt, ht.vertices[Ct++] -= Yt, ht.vertices[Ct++] -= Zt, ht.vertices[Ct++] -= Yt, ht.vertices[Ct++] -= Zt, ht.vertices[Ct++] -= Yt, ht.vertices[Ct++] -= Zt, ht.vertices[Ct++] -= Yt;\n      this._maxLineHeight = K * R;\n      var ie = ht.mesh.geometry.getBuffer(\"aVertexPosition\"), Te = ht.mesh.geometry.getBuffer(\"aTextureCoord\"), ge = ht.mesh.geometry.getIndex();\n      ie.data = ht.vertices, Te.data = ht.uvs, ge.data = ht.indices, ie.update(), Te.update(), ge.update();\n    }\n    for (var J = 0; J < M.length; J++)\n      charRenderDataPool.push(M[J]);\n  }, t.prototype.updateTransform = function() {\n    this.validate(), this.containerUpdateTransform();\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);\n    var o = BitmapFont.available[this._fontName], R = o.distanceFieldRange, N = o.distanceFieldType, M = o.size;\n    if (N !== \"none\")\n      for (var D = this.worldTransform, L = D.a, B = D.b, $ = D.c, k = D.d, U = Math.sqrt(L * L + B * B), z = Math.sqrt($ * $ + k * k), X = (Math.abs(U) + Math.abs(z)) / 2, V = this._fontSize / M, W = 0, Y = this._activePagesMeshData; W < Y.length; W++) {\n        var q = Y[W];\n        q.mesh.shader.uniforms.uFWidth = X * R * V * this._resolution;\n      }\n    n.prototype._render.call(this, e);\n  }, t.prototype.getLocalBounds = function() {\n    return this.validate(), n.prototype.getLocalBounds.call(this);\n  }, t.prototype.validate = function() {\n    this.dirty && (this.updateText(), this.dirty = !1);\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      if (this._tint !== e) {\n        this._tint = e;\n        for (var o = 0; o < this._activePagesMeshData.length; o++)\n          this._activePagesMeshData[o].mesh.tint = e;\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(e) {\n      this._align !== e && (this._align = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontName\", {\n    get: function() {\n      return this._fontName;\n    },\n    set: function(e) {\n      if (!BitmapFont.available[e])\n        throw new Error('Missing BitmapFont \"' + e + '\"');\n      this._fontName !== e && (this._fontName = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(e) {\n      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      typeof e == \"number\" ? this._anchor.set(e) : this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e == null ? \"\" : e), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxWidth\", {\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(e) {\n      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxLineHeight\", {\n    get: function() {\n      return this.validate(), this._maxLineHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textWidth\", {\n    get: function() {\n      return this.validate(), this._textWidth;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(e) {\n      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textHeight\", {\n    get: function() {\n      return this.validate(), this._textHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.destroy = function(e) {\n    var o = this._textureCache;\n    for (var R in o) {\n      var N = o[R];\n      N.destroy(), delete o[R];\n    }\n    this._textureCache = null, n.prototype.destroy.call(this, e);\n  }, t.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  }, t;\n})(Container);\nvar BitmapFontLoader = function() {\n  function n() {\n  }\n  return n.add = function() {\n    LoaderResource.setExtensionXhrType(\"fnt\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, n.use = function(t, e) {\n    var o = autoDetectFormat(t.data);\n    if (!o) {\n      e();\n      return;\n    }\n    for (var R = n.getBaseUrl(this, t), N = o.parse(t.data), M = {}, D = function(V) {\n      M[V.metadata.pageFile] = V.texture, Object.keys(M).length === N.page.length && (t.bitmapFont = BitmapFont.install(N, M, !0), e());\n    }, L = 0; L < N.page.length; ++L) {\n      var B = N.page[L].file, $ = R + B, k = !1;\n      for (var U in this.resources) {\n        var z = this.resources[U];\n        if (z.url === $) {\n          z.metadata.pageFile = B, z.texture ? D(z) : z.onAfterMiddleware.add(D), k = !0;\n          break;\n        }\n      }\n      if (!k) {\n        var X = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.IMAGE,\n          metadata: Object.assign({ pageFile: B }, t.metadata.imageMetadata),\n          parentResource: t\n        };\n        this.add($, X, D);\n      }\n    }\n  }, n.getBaseUrl = function(t, e) {\n    var o = e.isDataUrl ? \"\" : n.dirname(e.url);\n    return e.isDataUrl && (o === \".\" && (o = \"\"), t.baseUrl && o && t.baseUrl.charAt(t.baseUrl.length - 1) === \"/\" && (o += \"/\")), o = o.replace(t.baseUrl, \"\"), o && o.charAt(o.length - 1) !== \"/\" && (o += \"/\"), o;\n  }, n.dirname = function(t) {\n    var e = t.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n    return e === t ? \".\" : e === \"\" ? \"/\" : e;\n  }, n.extension = ExtensionType.Loader, n;\n}();\n/*!\n * @pixi/filter-alpha - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-alpha is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$e = function(n, t) {\n  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$e(n, t);\n};\nfunction __extends$e(n, t) {\n  extendStatics$e(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$4 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n(function(n) {\n  __extends$e(t, n);\n  function t(e) {\n    e === void 0 && (e = 1);\n    var o = n.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;\n    return o.alpha = e, o;\n  }\n  return Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-blur - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$d = function(n, t) {\n  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$d(n, t);\n};\nfunction __extends$d(n, t) {\n  extendStatics$d(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(n, t) {\n  var e = Math.ceil(n / 2), o = vertTemplate, R = \"\", N;\n  t ? N = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\" : N = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  for (var M = 0; M < n; M++) {\n    var D = N.replace(\"%index%\", M.toString());\n    D = D.replace(\"%sampleIndex%\", M - (e - 1) + \".0\"), R += D, R += `\n`;\n  }\n  return o = o.replace(\"%blur%\", R), o = o.replace(\"%size%\", n.toString()), o;\n}\nvar GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, fragTemplate = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(`\n`);\nfunction generateBlurFragSource(n) {\n  for (var t = GAUSSIAN_VALUES[n], e = t.length, o = fragTemplate, R = \"\", N = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\", M, D = 0; D < n; D++) {\n    var L = N.replace(\"%index%\", D.toString());\n    M = D, D >= e && (M = n - D - 1), L = L.replace(\"%value%\", t[M].toString()), R += L, R += `\n`;\n  }\n  return o = o.replace(\"%blur%\", R), o = o.replace(\"%size%\", n.toString()), o;\n}\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$3;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$3 || (ENV$3 = {}));\nvar RENDERER_TYPE$3;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));\nvar BUFFER_BITS$3;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));\nvar BLEND_MODES$3;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));\nvar DRAW_MODES$3;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));\nvar FORMATS$3;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$3 || (FORMATS$3 = {}));\nvar TARGETS$3;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$3 || (TARGETS$3 = {}));\nvar TYPES$3;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$3 || (TYPES$3 = {}));\nvar SAMPLER_TYPES$3;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));\nvar SCALE_MODES$3;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));\nvar WRAP_MODES$3;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));\nvar MIPMAP_MODES$3;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));\nvar ALPHA_MODES$3;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));\nvar CLEAR_MODES$3;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));\nvar GC_MODES$3;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$3 || (GC_MODES$3 = {}));\nvar PRECISION$3;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$3 || (PRECISION$3 = {}));\nvar MASK_TYPES$3;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));\nvar COLOR_MASK_BITS$3;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$3 || (COLOR_MASK_BITS$3 = {}));\nvar MSAA_QUALITY$3;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));\nvar BUFFER_TYPE$3;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));\nvar BlurFilterPass = function(n) {\n  __extends$d(t, n);\n  function t(e, o, R, N, M) {\n    o === void 0 && (o = 8), R === void 0 && (R = 4), N === void 0 && (N = settings$1.FILTER_RESOLUTION), M === void 0 && (M = 5);\n    var D = this, L = generateBlurVertSource(M, e), B = generateBlurFragSource(M);\n    return D = n.call(\n      this,\n      L,\n      B\n    ) || this, D.horizontal = e, D.resolution = N, D._quality = 0, D.quality = R, D.blur = o, D;\n  }\n  return t.prototype.apply = function(e, o, R, N) {\n    if (R ? this.horizontal ? this.uniforms.strength = 1 / R.width * (R.width / o.width) : this.uniforms.strength = 1 / R.height * (R.height / o.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / o.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / o.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n      e.applyFilter(this, o, R, N);\n    else {\n      var M = e.getFilterTexture(), D = e.renderer, L = o, B = M;\n      this.state.blend = !1, e.applyFilter(this, L, B, CLEAR_MODES$3.CLEAR);\n      for (var $ = 1; $ < this.passes - 1; $++) {\n        e.bindAndClear(L, CLEAR_MODES$3.BLIT), this.uniforms.uSampler = B;\n        var k = B;\n        B = L, L = k, D.shader.bind(this), D.geometry.draw(5);\n      }\n      this.state.blend = !0, e.applyFilter(this, B, R, N), e.returnFilterTexture(M);\n    }\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.strength;\n    },\n    set: function(e) {\n      this.padding = 1 + Math.abs(e) * 2, this.strength = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this._quality;\n    },\n    set: function(e) {\n      this._quality = e, this.passes = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\n(function(n) {\n  __extends$d(t, n);\n  function t(e, o, R, N) {\n    e === void 0 && (e = 8), o === void 0 && (o = 4), R === void 0 && (R = settings$1.FILTER_RESOLUTION), N === void 0 && (N = 5);\n    var M = n.call(this) || this;\n    return M.blurXFilter = new BlurFilterPass(!0, e, o, R, N), M.blurYFilter = new BlurFilterPass(!1, e, o, R, N), M.resolution = R, M.quality = o, M.blur = e, M.repeatEdgePixels = !1, M;\n  }\n  return t.prototype.apply = function(e, o, R, N) {\n    var M = Math.abs(this.blurXFilter.strength), D = Math.abs(this.blurYFilter.strength);\n    if (M && D) {\n      var L = e.getFilterTexture();\n      this.blurXFilter.apply(e, o, L, CLEAR_MODES$3.CLEAR), this.blurYFilter.apply(e, L, R, N), e.returnFilterTexture(L);\n    } else\n      D ? this.blurYFilter.apply(e, o, R, N) : this.blurXFilter.apply(e, o, R, N);\n  }, t.prototype.updatePadding = function() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(e) {\n      this.blurXFilter.quality = this.blurYFilter.quality = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurX\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurY\", {\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(e) {\n      this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(e) {\n      this.blurYFilter.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"repeatEdgePixels\", {\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(e) {\n      this._repeatEdgePixels = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-color-matrix - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-color-matrix is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$c = function(n, t) {\n  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$c(n, t);\n};\nfunction __extends$c(n, t) {\n  extendStatics$c(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$3 = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`, ColorMatrixFilter = function(n) {\n  __extends$c(t, n);\n  function t() {\n    var e = this, o = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    return e = n.call(this, defaultFilterVertex, fragment$3, o) || this, e.alpha = 1, e;\n  }\n  return t.prototype._loadMatrix = function(e, o) {\n    o === void 0 && (o = !1);\n    var R = e;\n    o && (this._multiply(R, this.uniforms.m, e), R = this._colorMatrix(R)), this.uniforms.m = R;\n  }, t.prototype._multiply = function(e, o, R) {\n    return e[0] = o[0] * R[0] + o[1] * R[5] + o[2] * R[10] + o[3] * R[15], e[1] = o[0] * R[1] + o[1] * R[6] + o[2] * R[11] + o[3] * R[16], e[2] = o[0] * R[2] + o[1] * R[7] + o[2] * R[12] + o[3] * R[17], e[3] = o[0] * R[3] + o[1] * R[8] + o[2] * R[13] + o[3] * R[18], e[4] = o[0] * R[4] + o[1] * R[9] + o[2] * R[14] + o[3] * R[19] + o[4], e[5] = o[5] * R[0] + o[6] * R[5] + o[7] * R[10] + o[8] * R[15], e[6] = o[5] * R[1] + o[6] * R[6] + o[7] * R[11] + o[8] * R[16], e[7] = o[5] * R[2] + o[6] * R[7] + o[7] * R[12] + o[8] * R[17], e[8] = o[5] * R[3] + o[6] * R[8] + o[7] * R[13] + o[8] * R[18], e[9] = o[5] * R[4] + o[6] * R[9] + o[7] * R[14] + o[8] * R[19] + o[9], e[10] = o[10] * R[0] + o[11] * R[5] + o[12] * R[10] + o[13] * R[15], e[11] = o[10] * R[1] + o[11] * R[6] + o[12] * R[11] + o[13] * R[16], e[12] = o[10] * R[2] + o[11] * R[7] + o[12] * R[12] + o[13] * R[17], e[13] = o[10] * R[3] + o[11] * R[8] + o[12] * R[13] + o[13] * R[18], e[14] = o[10] * R[4] + o[11] * R[9] + o[12] * R[14] + o[13] * R[19] + o[14], e[15] = o[15] * R[0] + o[16] * R[5] + o[17] * R[10] + o[18] * R[15], e[16] = o[15] * R[1] + o[16] * R[6] + o[17] * R[11] + o[18] * R[16], e[17] = o[15] * R[2] + o[16] * R[7] + o[17] * R[12] + o[18] * R[17], e[18] = o[15] * R[3] + o[16] * R[8] + o[17] * R[13] + o[18] * R[18], e[19] = o[15] * R[4] + o[16] * R[9] + o[17] * R[14] + o[18] * R[19] + o[19], e;\n  }, t.prototype._colorMatrix = function(e) {\n    var o = new Float32Array(e);\n    return o[4] /= 255, o[9] /= 255, o[14] /= 255, o[19] /= 255, o;\n  }, t.prototype.brightness = function(e, o) {\n    var R = [\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(R, o);\n  }, t.prototype.tint = function(e, o) {\n    var R = e >> 16 & 255, N = e >> 8 & 255, M = e & 255, D = [\n      R / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      N / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      M / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(D, o);\n  }, t.prototype.greyscale = function(e, o) {\n    var R = [\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(R, o);\n  }, t.prototype.blackAndWhite = function(e) {\n    var o = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.hue = function(e, o) {\n    e = (e || 0) / 180 * Math.PI;\n    var R = Math.cos(e), N = Math.sin(e), M = Math.sqrt, D = 1 / 3, L = M(D), B = R + (1 - R) * D, $ = D * (1 - R) - L * N, k = D * (1 - R) + L * N, U = D * (1 - R) + L * N, z = R + D * (1 - R), X = D * (1 - R) - L * N, V = D * (1 - R) - L * N, W = D * (1 - R) + L * N, Y = R + D * (1 - R), q = [\n      B,\n      $,\n      k,\n      0,\n      0,\n      U,\n      z,\n      X,\n      0,\n      0,\n      V,\n      W,\n      Y,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(q, o);\n  }, t.prototype.contrast = function(e, o) {\n    var R = (e || 0) + 1, N = -0.5 * (R - 1), M = [\n      R,\n      0,\n      0,\n      0,\n      N,\n      0,\n      R,\n      0,\n      0,\n      N,\n      0,\n      0,\n      R,\n      0,\n      N,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(M, o);\n  }, t.prototype.saturate = function(e, o) {\n    e === void 0 && (e = 0);\n    var R = e * 2 / 3 + 1, N = (R - 1) * -0.5, M = [\n      R,\n      N,\n      N,\n      0,\n      0,\n      N,\n      R,\n      N,\n      0,\n      0,\n      N,\n      N,\n      R,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(M, o);\n  }, t.prototype.desaturate = function() {\n    this.saturate(-1);\n  }, t.prototype.negative = function(e) {\n    var o = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.sepia = function(e) {\n    var o = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.technicolor = function(e) {\n    var o = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.polaroid = function(e) {\n    var o = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.toBGR = function(e) {\n    var o = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.kodachrome = function(e) {\n    var o = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.browni = function(e) {\n    var o = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.vintage = function(e) {\n    var o = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.colorTone = function(e, o, R, N, M) {\n    e = e || 0.2, o = o || 0.15, R = R || 16770432, N = N || 3375104;\n    var D = (R >> 16 & 255) / 255, L = (R >> 8 & 255) / 255, B = (R & 255) / 255, $ = (N >> 16 & 255) / 255, k = (N >> 8 & 255) / 255, U = (N & 255) / 255, z = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      D,\n      L,\n      B,\n      e,\n      0,\n      $,\n      k,\n      U,\n      o,\n      0,\n      D - $,\n      L - k,\n      B - U,\n      0,\n      0\n    ];\n    this._loadMatrix(z, M);\n  }, t.prototype.night = function(e, o) {\n    e = e || 0.1;\n    var R = [\n      e * -2,\n      -e,\n      0,\n      0,\n      0,\n      -e,\n      0,\n      e,\n      0,\n      0,\n      0,\n      e,\n      e * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(R, o);\n  }, t.prototype.predator = function(e, o) {\n    var R = [\n      11.224130630493164 * e,\n      -4.794486999511719 * e,\n      -2.8746118545532227 * e,\n      0 * e,\n      0.40342438220977783 * e,\n      -3.6330697536468506 * e,\n      9.193157196044922 * e,\n      -2.951810836791992 * e,\n      0 * e,\n      -1.316135048866272 * e,\n      -3.2184197902679443 * e,\n      -4.2375030517578125 * e,\n      7.476448059082031 * e,\n      0 * e,\n      0.8044459223747253 * e,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(R, o);\n  }, t.prototype.lsd = function(e) {\n    var o = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.reset = function() {\n    var e = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(e, !1);\n  }, Object.defineProperty(t.prototype, \"matrix\", {\n    get: function() {\n      return this.uniforms.m;\n    },\n    set: function(e) {\n      this.uniforms.m = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n/*!\n * @pixi/filter-displacement - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$b = function(n, t) {\n  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$b(n, t);\n};\nfunction __extends$b(n, t) {\n  extendStatics$b(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$2 = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`, vertex$1 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n(function(n) {\n  __extends$b(t, n);\n  function t(e, o) {\n    var R = this, N = new Matrix();\n    return e.renderable = !1, R = n.call(this, vertex$1, fragment$2, {\n      mapSampler: e._texture,\n      filterMatrix: N,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this, R.maskSprite = e, R.maskMatrix = N, o == null && (o = 20), R.scale = new Point(o, o), R;\n  }\n  return t.prototype.apply = function(e, o, R, N) {\n    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    var M = this.maskSprite.worldTransform, D = Math.sqrt(M.a * M.a + M.b * M.b), L = Math.sqrt(M.c * M.c + M.d * M.d);\n    D !== 0 && L !== 0 && (this.uniforms.rotation[0] = M.a / D, this.uniforms.rotation[1] = M.b / D, this.uniforms.rotation[2] = M.c / L, this.uniforms.rotation[3] = M.d / L), e.applyFilter(this, o, R, N);\n  }, Object.defineProperty(t.prototype, \"map\", {\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(e) {\n      this.uniforms.mapSampler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-fxaa - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-fxaa is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$a = function(n, t) {\n  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$a(n, t);\n};\nfunction __extends$a(n, t) {\n  extendStatics$a(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertex = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`, fragment$1 = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(n) {\n  __extends$a(t, n);\n  function t() {\n    return n.call(this, vertex, fragment$1) || this;\n  }\n  return t;\n})(Filter);\n/*!\n * @pixi/filter-noise - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/filter-noise is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$9 = function(n, t) {\n  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$9(n, t);\n};\nfunction __extends$9(n, t) {\n  extendStatics$9(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n(function(n) {\n  __extends$9(t, n);\n  function t(e, o) {\n    e === void 0 && (e = 0.5), o === void 0 && (o = Math.random());\n    var R = n.call(this, defaultFilterVertex, fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    return R.noise = e, R.seed = o, R;\n  }\n  return Object.defineProperty(t.prototype, \"noise\", {\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(e) {\n      this.uniforms.uNoise = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"seed\", {\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(e) {\n      this.uniforms.uSeed = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/mixin-cache-as-bitmap - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$2;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$2 || (ENV$2 = {}));\nvar RENDERER_TYPE$2;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));\nvar BUFFER_BITS$2;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));\nvar BLEND_MODES$2;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));\nvar DRAW_MODES$2;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));\nvar FORMATS$2;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$2 || (FORMATS$2 = {}));\nvar TARGETS$2;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$2 || (TARGETS$2 = {}));\nvar TYPES$2;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$2 || (TYPES$2 = {}));\nvar SAMPLER_TYPES$2;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));\nvar SCALE_MODES$2;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));\nvar WRAP_MODES$2;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));\nvar MIPMAP_MODES$2;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));\nvar ALPHA_MODES$2;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));\nvar CLEAR_MODES$2;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));\nvar GC_MODES$2;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$2 || (GC_MODES$2 = {}));\nvar PRECISION$2;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$2 || (PRECISION$2 = {}));\nvar MASK_TYPES$2;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));\nvar COLOR_MASK_BITS$2;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$2 || (COLOR_MASK_BITS$2 = {}));\nvar MSAA_QUALITY$2;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));\nvar BUFFER_TYPE$2;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));\nvar _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY$2.NONE;\nvar CacheData = function() {\n  function n() {\n    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n  }\n  return n;\n}();\nObject.defineProperties(DisplayObject.prototype, {\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(n) {\n      n !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = n, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(n) {\n      n !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = n, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(n) {\n      if (this._cacheAsBitmap !== n) {\n        this._cacheAsBitmap = n;\n        var t;\n        n ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));\n};\nDisplayObject.prototype._initCachedDisplayObject = function(t) {\n  var e;\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var o = this.alpha;\n    this.alpha = 1, t.batch.flush();\n    var R = this.getLocalBounds(null, !0).clone();\n    if (this.filters && this.filters.length) {\n      var N = this.filters[0].padding;\n      R.pad(N);\n    }\n    R.ceil(settings$1.RESOLUTION);\n    var M = t.renderTexture.current, D = t.renderTexture.sourceFrame.clone(), L = t.renderTexture.destinationFrame.clone(), B = t.projection.transform, $ = RenderTexture.create({\n      width: R.width,\n      height: R.height,\n      resolution: this.cacheAsBitmapResolution || t.resolution,\n      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample\n    }), k = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = k, BaseTexture.addToCache($.baseTexture, k), Texture.addToCache($, k);\n    var U = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-R.x, -R.y);\n    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: $, clear: !0, transform: U, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = B, t.renderTexture.bind(M, D, L), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;\n    var z = new Sprite($);\n    z.transform.worldTransform = this.transform.worldTransform, z.anchor.x = -(R.x / R.width), z.anchor.y = -(R.y / R.height), z.alpha = o, z._bounds = this._bounds, this._cacheData.sprite = z, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = z.containsPoint.bind(z);\n  }\n};\nDisplayObject.prototype._renderCachedCanvas = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var e = this.getLocalBounds(null, !0), o = this.alpha;\n    this.alpha = 1;\n    var R = t.context, N = t._projTransform;\n    e.ceil(settings$1.RESOLUTION);\n    var M = RenderTexture.create({ width: e.width, height: e.height }), D = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = D, BaseTexture.addToCache(M.baseTexture, D), Texture.addToCache(M, D);\n    var L = _tempMatrix;\n    this.transform.localTransform.copyTo(L), L.invert(), L.tx -= e.x, L.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: M, clear: !0, transform: L, skipUpdateTransform: !1 }), t.context = R, t._projTransform = N, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;\n    var B = new Sprite(M);\n    B.transform.worldTransform = this.transform.worldTransform, B.anchor.x = -(e.x / e.width), B.anchor.y = -(e.y / e.height), B.alpha = o, B._bounds = this._bounds, this._cacheData.sprite = B, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = B.containsPoint.bind(B);\n  }\n};\nDisplayObject.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function(t) {\n  this.cacheAsBitmap = !1, this.destroy(t);\n};\n/*!\n * @pixi/mixin-get-child-by-name - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/mixin-get-child-by-name is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.name = null;\nContainer.prototype.getChildByName = function(t, e) {\n  for (var o = 0, R = this.children.length; o < R; o++)\n    if (this.children[o].name === t)\n      return this.children[o];\n  if (e)\n    for (var o = 0, R = this.children.length; o < R; o++) {\n      var N = this.children[o];\n      if (!!N.getChildByName) {\n        var M = N.getChildByName(t, !0);\n        if (M)\n          return M;\n      }\n    }\n  return null;\n};\n/*!\n * @pixi/mixin-get-global-position - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/mixin-get-global-position is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.getGlobalPosition = function(t, e) {\n  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;\n};\n/*!\n * @pixi/app - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/app is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ResizePlugin = function() {\n  function n() {\n  }\n  return n.init = function(t) {\n    var e = this;\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set: function(o) {\n          globalThis.removeEventListener(\"resize\", this.queueResize), this._resizeTo = o, o && (globalThis.addEventListener(\"resize\", this.queueResize), this.resize());\n        },\n        get: function() {\n          return this._resizeTo;\n        }\n      }\n    ), this.queueResize = function() {\n      !e._resizeTo || (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {\n        return e.resize();\n      }));\n    }, this.cancelResize = function() {\n      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);\n    }, this.resize = function() {\n      if (!!e._resizeTo) {\n        e.cancelResize();\n        var o, R;\n        if (e._resizeTo === globalThis.window)\n          o = globalThis.innerWidth, R = globalThis.innerHeight;\n        else {\n          var N = e._resizeTo, M = N.clientWidth, D = N.clientHeight;\n          o = M, R = D;\n        }\n        e.renderer.resize(o, R);\n      }\n    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;\n  }, n.destroy = function() {\n    globalThis.removeEventListener(\"resize\", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n  }, n.extension = ExtensionType.Application, n;\n}();\n/*!\n * @pixi/settings - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$1;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$1 || (ENV$1 = {}));\nvar RENDERER_TYPE$1;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));\nvar BUFFER_BITS$1;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));\nvar BLEND_MODES$1;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));\nvar DRAW_MODES$1;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));\nvar FORMATS$1;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$1 || (FORMATS$1 = {}));\nvar TARGETS$1;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$1 || (TARGETS$1 = {}));\nvar TYPES$1;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$1 || (TYPES$1 = {}));\nvar SAMPLER_TYPES$1;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));\nvar SCALE_MODES$1;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));\nvar WRAP_MODES$1;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));\nvar MIPMAP_MODES$1;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));\nvar ALPHA_MODES$1;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));\nvar CLEAR_MODES$1;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));\nvar GC_MODES$1;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$1 || (GC_MODES$1 = {}));\nvar PRECISION$1;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION$1 || (PRECISION$1 = {}));\nvar MASK_TYPES$1;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));\nvar COLOR_MASK_BITS$1;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$1 || (COLOR_MASK_BITS$1 = {}));\nvar MSAA_QUALITY$1;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));\nvar BUFFER_TYPE$1;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));\nvar BrowserAdapter = {\n  createCanvas: function(n, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = n, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var n;\n    return (n = document.baseURI) !== null && n !== void 0 ? n : window.location.href;\n  },\n  fetch: function(n, t) {\n    return fetch(n, t);\n  }\n}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13 = function(n) {\n  return typeof n < \"u\" && n.platform === \"MacIntel\" && typeof n.maxTouchPoints == \"number\" && n.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch(n) {\n  return function(t) {\n    return t.test(n);\n  };\n}\nfunction isMobile$1(n) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !n && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof n == \"string\" ? t.userAgent = n : n && n.userAgent && (t = {\n    userAgent: n.userAgent,\n    platform: n.platform,\n    maxTouchPoints: n.maxTouchPoints || 0\n  });\n  var e = t.userAgent, o = e.split(\"[FBAN\");\n  typeof o[1] < \"u\" && (e = o[0]), o = e.split(\"Twitter\"), typeof o[1] < \"u\" && (e = o[0]);\n  var R = createMatch(e), N = {\n    apple: {\n      phone: R(appleIphone) && !R(windowsPhone),\n      ipod: R(appleIpod),\n      tablet: !R(appleIphone) && (R(appleTablet) || isAppleTabletOnIos13(t)) && !R(windowsPhone),\n      universal: R(appleUniversal),\n      device: (R(appleIphone) || R(appleIpod) || R(appleTablet) || R(appleUniversal) || isAppleTabletOnIos13(t)) && !R(windowsPhone)\n    },\n    amazon: {\n      phone: R(amazonPhone),\n      tablet: !R(amazonPhone) && R(amazonTablet),\n      device: R(amazonPhone) || R(amazonTablet)\n    },\n    android: {\n      phone: !R(windowsPhone) && R(amazonPhone) || !R(windowsPhone) && R(androidPhone),\n      tablet: !R(windowsPhone) && !R(amazonPhone) && !R(androidPhone) && (R(amazonTablet) || R(androidTablet)),\n      device: !R(windowsPhone) && (R(amazonPhone) || R(amazonTablet) || R(androidPhone) || R(androidTablet)) || R(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: R(windowsPhone),\n      tablet: R(windowsTablet),\n      device: R(windowsPhone) || R(windowsTablet)\n    },\n    other: {\n      blackberry: R(otherBlackBerry),\n      blackberry10: R(otherBlackBerry10),\n      opera: R(otherOpera),\n      firefox: R(otherFirefox),\n      chrome: R(otherChrome),\n      device: R(otherBlackBerry) || R(otherBlackBerry10) || R(otherOpera) || R(otherFirefox) || R(otherChrome)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;\n}\nvar isMobile = isMobile$1(globalThis.navigator);\nfunction canUploadSameBuffer() {\n  return !isMobile.apple.device;\n}\nfunction maxRecommendedTextures(n) {\n  var t = !0;\n  if (isMobile.tablet || isMobile.phone) {\n    if (isMobile.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 11 && (t = !1);\n      }\n    }\n    if (isMobile.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? n : 4;\n}\nvar settings = {\n  ADAPTER: BrowserAdapter,\n  MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  GC_MODE: GC_MODES$1.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES$1.CLAMP,\n  SCALE_MODE: SCALE_MODES$1.LINEAR,\n  PRECISION_VERTEX: PRECISION$1.HIGH,\n  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$1.HIGH : PRECISION$1.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),\n  CREATE_IMAGE_BITMAP: !1,\n  ROUND_PIXELS: !1\n}, commonjsGlobal = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {};\nfunction createCommonjsModule(n, t, e) {\n  return e = {\n    path: t,\n    exports: {},\n    require: function(o, R) {\n      return commonjsRequire(o, R == null ? e.path : R);\n    }\n  }, n(e, e.exports), e.exports;\n}\nfunction commonjsRequire() {\n  throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\ncreateCommonjsModule(function(n) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function o() {\n  }\n  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));\n  function R(L, B, $) {\n    this.fn = L, this.context = B, this.once = $ || !1;\n  }\n  function N(L, B, $, k, U) {\n    if (typeof $ != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var z = new R($, k || L, U), X = e ? e + B : B;\n    return L._events[X] ? L._events[X].fn ? L._events[X] = [L._events[X], z] : L._events[X].push(z) : (L._events[X] = z, L._eventsCount++), L;\n  }\n  function M(L, B) {\n    --L._eventsCount === 0 ? L._events = new o() : delete L._events[B];\n  }\n  function D() {\n    this._events = new o(), this._eventsCount = 0;\n  }\n  D.prototype.eventNames = function() {\n    var B = [], $, k;\n    if (this._eventsCount === 0)\n      return B;\n    for (k in $ = this._events)\n      t.call($, k) && B.push(e ? k.slice(1) : k);\n    return Object.getOwnPropertySymbols ? B.concat(Object.getOwnPropertySymbols($)) : B;\n  }, D.prototype.listeners = function(B) {\n    var $ = e ? e + B : B, k = this._events[$];\n    if (!k)\n      return [];\n    if (k.fn)\n      return [k.fn];\n    for (var U = 0, z = k.length, X = new Array(z); U < z; U++)\n      X[U] = k[U].fn;\n    return X;\n  }, D.prototype.listenerCount = function(B) {\n    var $ = e ? e + B : B, k = this._events[$];\n    return k ? k.fn ? 1 : k.length : 0;\n  }, D.prototype.emit = function(B, $, k, U, z, X) {\n    var V = arguments, W = e ? e + B : B;\n    if (!this._events[W])\n      return !1;\n    var Y = this._events[W], q = arguments.length, Z, K;\n    if (Y.fn) {\n      switch (Y.once && this.removeListener(B, Y.fn, void 0, !0), q) {\n        case 1:\n          return Y.fn.call(Y.context), !0;\n        case 2:\n          return Y.fn.call(Y.context, $), !0;\n        case 3:\n          return Y.fn.call(Y.context, $, k), !0;\n        case 4:\n          return Y.fn.call(Y.context, $, k, U), !0;\n        case 5:\n          return Y.fn.call(Y.context, $, k, U, z), !0;\n        case 6:\n          return Y.fn.call(Y.context, $, k, U, z, X), !0;\n      }\n      for (K = 1, Z = new Array(q - 1); K < q; K++)\n        Z[K - 1] = V[K];\n      Y.fn.apply(Y.context, Z);\n    } else {\n      var Q = Y.length, J;\n      for (K = 0; K < Q; K++)\n        switch (Y[K].once && this.removeListener(B, Y[K].fn, void 0, !0), q) {\n          case 1:\n            Y[K].fn.call(Y[K].context);\n            break;\n          case 2:\n            Y[K].fn.call(Y[K].context, $);\n            break;\n          case 3:\n            Y[K].fn.call(Y[K].context, $, k);\n            break;\n          case 4:\n            Y[K].fn.call(Y[K].context, $, k, U);\n            break;\n          default:\n            if (!Z)\n              for (J = 1, Z = new Array(q - 1); J < q; J++)\n                Z[J - 1] = V[J];\n            Y[K].fn.apply(Y[K].context, Z);\n        }\n    }\n    return !0;\n  }, D.prototype.on = function(B, $, k) {\n    return N(this, B, $, k, !1);\n  }, D.prototype.once = function(B, $, k) {\n    return N(this, B, $, k, !0);\n  }, D.prototype.removeListener = function(B, $, k, U) {\n    var z = e ? e + B : B;\n    if (!this._events[z])\n      return this;\n    if (!$)\n      return M(this, z), this;\n    var X = this._events[z];\n    if (X.fn)\n      X.fn === $ && (!U || X.once) && (!k || X.context === k) && M(this, z);\n    else {\n      for (var V = 0, W = [], Y = X.length; V < Y; V++)\n        (X[V].fn !== $ || U && !X[V].once || k && X[V].context !== k) && W.push(X[V]);\n      W.length ? this._events[z] = W.length === 1 ? W[0] : W : M(this, z);\n    }\n    return this;\n  }, D.prototype.removeAllListeners = function(B) {\n    var $;\n    return B ? ($ = e ? e + B : B, this._events[$] && M(this, $)) : (this._events = new o(), this._eventsCount = 0), this;\n  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, n.exports = D;\n});\ncreateCommonjsModule(function(n, t) {\n  (function(e) {\n    var o = t && !t.nodeType && t, R = n && !n.nodeType && n, N = typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    (N.global === N || N.window === N || N.self === N) && (e = N);\n    var M, D = 2147483647, L = 36, B = 1, $ = 26, k = 38, U = 700, z = 72, X = 128, V = \"-\", W = /^xn--/, Y = /[^\\x20-\\x7E]/, q = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, Z = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, K = L - B, Q = Math.floor, J = String.fromCharCode, rt;\n    function tt(ht) {\n      throw RangeError(Z[ht]);\n    }\n    function nt(ht, pt) {\n      for (var xt = ht.length, At = []; xt--; )\n        At[xt] = pt(ht[xt]);\n      return At;\n    }\n    function st(ht, pt) {\n      var xt = ht.split(\"@\"), At = \"\";\n      xt.length > 1 && (At = xt[0] + \"@\", ht = xt[1]), ht = ht.replace(q, \".\");\n      var Rt = ht.split(\".\"), Lt = nt(Rt, pt).join(\".\");\n      return At + Lt;\n    }\n    function ut(ht) {\n      for (var pt = [], xt = 0, At = ht.length, Rt, Lt; xt < At; )\n        Rt = ht.charCodeAt(xt++), Rt >= 55296 && Rt <= 56319 && xt < At ? (Lt = ht.charCodeAt(xt++), (Lt & 64512) == 56320 ? pt.push(((Rt & 1023) << 10) + (Lt & 1023) + 65536) : (pt.push(Rt), xt--)) : pt.push(Rt);\n      return pt;\n    }\n    function ct(ht) {\n      return nt(ht, function(pt) {\n        var xt = \"\";\n        return pt > 65535 && (pt -= 65536, xt += J(pt >>> 10 & 1023 | 55296), pt = 56320 | pt & 1023), xt += J(pt), xt;\n      }).join(\"\");\n    }\n    function dt(ht) {\n      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : L;\n    }\n    function Et(ht, pt) {\n      return ht + 22 + 75 * (ht < 26) - ((pt != 0) << 5);\n    }\n    function vt(ht, pt, xt) {\n      var At = 0;\n      for (ht = xt ? Q(ht / U) : ht >> 1, ht += Q(ht / pt); ht > K * $ >> 1; At += L)\n        ht = Q(ht / K);\n      return Q(At + (K + 1) * ht / (ht + k));\n    }\n    function _t(ht) {\n      var pt = [], xt = ht.length, At, Rt = 0, Lt = X, lt = z, $t, Pt, kt, Ot, gt, Gt, Tt, bt, wt;\n      for ($t = ht.lastIndexOf(V), $t < 0 && ($t = 0), Pt = 0; Pt < $t; ++Pt)\n        ht.charCodeAt(Pt) >= 128 && tt(\"not-basic\"), pt.push(ht.charCodeAt(Pt));\n      for (kt = $t > 0 ? $t + 1 : 0; kt < xt; ) {\n        for (Ot = Rt, gt = 1, Gt = L; kt >= xt && tt(\"invalid-input\"), Tt = dt(ht.charCodeAt(kt++)), (Tt >= L || Tt > Q((D - Rt) / gt)) && tt(\"overflow\"), Rt += Tt * gt, bt = Gt <= lt ? B : Gt >= lt + $ ? $ : Gt - lt, !(Tt < bt); Gt += L)\n          wt = L - bt, gt > Q(D / wt) && tt(\"overflow\"), gt *= wt;\n        At = pt.length + 1, lt = vt(Rt - Ot, At, Ot == 0), Q(Rt / At) > D - Lt && tt(\"overflow\"), Lt += Q(Rt / At), Rt %= At, pt.splice(Rt++, 0, Lt);\n      }\n      return ct(pt);\n    }\n    function St(ht) {\n      var pt, xt, At, Rt, Lt, lt, $t, Pt, kt, Ot, gt, Gt = [], Tt, bt, wt, Mt;\n      for (ht = ut(ht), Tt = ht.length, pt = X, xt = 0, Lt = z, lt = 0; lt < Tt; ++lt)\n        gt = ht[lt], gt < 128 && Gt.push(J(gt));\n      for (At = Rt = Gt.length, Rt && Gt.push(V); At < Tt; ) {\n        for ($t = D, lt = 0; lt < Tt; ++lt)\n          gt = ht[lt], gt >= pt && gt < $t && ($t = gt);\n        for (bt = At + 1, $t - pt > Q((D - xt) / bt) && tt(\"overflow\"), xt += ($t - pt) * bt, pt = $t, lt = 0; lt < Tt; ++lt)\n          if (gt = ht[lt], gt < pt && ++xt > D && tt(\"overflow\"), gt == pt) {\n            for (Pt = xt, kt = L; Ot = kt <= Lt ? B : kt >= Lt + $ ? $ : kt - Lt, !(Pt < Ot); kt += L)\n              Mt = Pt - Ot, wt = L - Ot, Gt.push(\n                J(Et(Ot + Mt % wt, 0))\n              ), Pt = Q(Mt / wt);\n            Gt.push(J(Et(Pt, 0))), Lt = vt(xt, bt, At == Rt), xt = 0, ++At;\n          }\n        ++xt, ++pt;\n      }\n      return Gt.join(\"\");\n    }\n    function Ft(ht) {\n      return st(ht, function(pt) {\n        return W.test(pt) ? _t(pt.slice(4).toLowerCase()) : pt;\n      });\n    }\n    function mt(ht) {\n      return st(ht, function(pt) {\n        return Y.test(pt) ? \"xn--\" + St(pt) : pt;\n      });\n    }\n    if (M = {\n      version: \"1.3.2\",\n      ucs2: {\n        decode: ut,\n        encode: ct\n      },\n      decode: _t,\n      encode: St,\n      toASCII: mt,\n      toUnicode: Ft\n    }, o && R)\n      if (n.exports == o)\n        R.exports = M;\n      else\n        for (rt in M)\n          M.hasOwnProperty(rt) && (o[rt] = M[rt]);\n    else\n      e.punycode = M;\n  })(commonjsGlobal);\n});\nfunction hasOwnProperty(n, t) {\n  return Object.prototype.hasOwnProperty.call(n, t);\n}\nvar decode = function(n, t, e, o) {\n  t = t || \"&\", e = e || \"=\";\n  var R = {};\n  if (typeof n != \"string\" || n.length === 0)\n    return R;\n  var N = /\\+/g;\n  n = n.split(t);\n  var M = 1e3;\n  o && typeof o.maxKeys == \"number\" && (M = o.maxKeys);\n  var D = n.length;\n  M > 0 && D > M && (D = M);\n  for (var L = 0; L < D; ++L) {\n    var B = n[L].replace(N, \"%20\"), $ = B.indexOf(e), k, U, z, X;\n    $ >= 0 ? (k = B.substr(0, $), U = B.substr($ + 1)) : (k = B, U = \"\"), z = decodeURIComponent(k), X = decodeURIComponent(U), hasOwnProperty(R, z) ? Array.isArray(R[z]) ? R[z].push(X) : R[z] = [R[z], X] : R[z] = X;\n  }\n  return R;\n}, stringifyPrimitive = function(n) {\n  switch (typeof n) {\n    case \"string\":\n      return n;\n    case \"boolean\":\n      return n ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(n) ? n : \"\";\n    default:\n      return \"\";\n  }\n}, encode = function(n, t, e, o) {\n  return t = t || \"&\", e = e || \"=\", n === null && (n = void 0), typeof n == \"object\" ? Object.keys(n).map(function(R) {\n    var N = encodeURIComponent(stringifyPrimitive(R)) + e;\n    return Array.isArray(n[R]) ? n[R].map(function(M) {\n      return N + encodeURIComponent(stringifyPrimitive(M));\n    }).join(t) : N + encodeURIComponent(stringifyPrimitive(n[R]));\n  }).join(t) : o ? encodeURIComponent(stringifyPrimitive(o)) + e + encodeURIComponent(stringifyPrimitive(n)) : \"\";\n};\ncreateCommonjsModule(function(n, t) {\n  t.decode = t.parse = decode, t.encode = t.stringify = encode;\n});\n/*!\n * @pixi/constants - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV;\n(function(n) {\n  n[n.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", n[n.WEBGL = 1] = \"WEBGL\", n[n.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV || (ENV = {}));\nvar RENDERER_TYPE;\n(function(n) {\n  n[n.UNKNOWN = 0] = \"UNKNOWN\", n[n.WEBGL = 1] = \"WEBGL\", n[n.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE || (RENDERER_TYPE = {}));\nvar BUFFER_BITS;\n(function(n) {\n  n[n.COLOR = 16384] = \"COLOR\", n[n.DEPTH = 256] = \"DEPTH\", n[n.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS || (BUFFER_BITS = {}));\nvar BLEND_MODES;\n(function(n) {\n  n[n.NORMAL = 0] = \"NORMAL\", n[n.ADD = 1] = \"ADD\", n[n.MULTIPLY = 2] = \"MULTIPLY\", n[n.SCREEN = 3] = \"SCREEN\", n[n.OVERLAY = 4] = \"OVERLAY\", n[n.DARKEN = 5] = \"DARKEN\", n[n.LIGHTEN = 6] = \"LIGHTEN\", n[n.COLOR_DODGE = 7] = \"COLOR_DODGE\", n[n.COLOR_BURN = 8] = \"COLOR_BURN\", n[n.HARD_LIGHT = 9] = \"HARD_LIGHT\", n[n.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", n[n.DIFFERENCE = 11] = \"DIFFERENCE\", n[n.EXCLUSION = 12] = \"EXCLUSION\", n[n.HUE = 13] = \"HUE\", n[n.SATURATION = 14] = \"SATURATION\", n[n.COLOR = 15] = \"COLOR\", n[n.LUMINOSITY = 16] = \"LUMINOSITY\", n[n.NORMAL_NPM = 17] = \"NORMAL_NPM\", n[n.ADD_NPM = 18] = \"ADD_NPM\", n[n.SCREEN_NPM = 19] = \"SCREEN_NPM\", n[n.NONE = 20] = \"NONE\", n[n.SRC_OVER = 0] = \"SRC_OVER\", n[n.SRC_IN = 21] = \"SRC_IN\", n[n.SRC_OUT = 22] = \"SRC_OUT\", n[n.SRC_ATOP = 23] = \"SRC_ATOP\", n[n.DST_OVER = 24] = \"DST_OVER\", n[n.DST_IN = 25] = \"DST_IN\", n[n.DST_OUT = 26] = \"DST_OUT\", n[n.DST_ATOP = 27] = \"DST_ATOP\", n[n.ERASE = 26] = \"ERASE\", n[n.SUBTRACT = 28] = \"SUBTRACT\", n[n.XOR = 29] = \"XOR\";\n})(BLEND_MODES || (BLEND_MODES = {}));\nvar DRAW_MODES;\n(function(n) {\n  n[n.POINTS = 0] = \"POINTS\", n[n.LINES = 1] = \"LINES\", n[n.LINE_LOOP = 2] = \"LINE_LOOP\", n[n.LINE_STRIP = 3] = \"LINE_STRIP\", n[n.TRIANGLES = 4] = \"TRIANGLES\", n[n.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", n[n.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES || (DRAW_MODES = {}));\nvar FORMATS;\n(function(n) {\n  n[n.RGBA = 6408] = \"RGBA\", n[n.RGB = 6407] = \"RGB\", n[n.RG = 33319] = \"RG\", n[n.RED = 6403] = \"RED\", n[n.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", n[n.RGB_INTEGER = 36248] = \"RGB_INTEGER\", n[n.RG_INTEGER = 33320] = \"RG_INTEGER\", n[n.RED_INTEGER = 36244] = \"RED_INTEGER\", n[n.ALPHA = 6406] = \"ALPHA\", n[n.LUMINANCE = 6409] = \"LUMINANCE\", n[n.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", n[n.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", n[n.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS || (FORMATS = {}));\nvar TARGETS;\n(function(n) {\n  n[n.TEXTURE_2D = 3553] = \"TEXTURE_2D\", n[n.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", n[n.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS || (TARGETS = {}));\nvar TYPES;\n(function(n) {\n  n[n.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", n[n.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", n[n.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", n[n.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", n[n.BYTE = 5120] = \"BYTE\", n[n.SHORT = 5122] = \"SHORT\", n[n.INT = 5124] = \"INT\", n[n.FLOAT = 5126] = \"FLOAT\", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", n[n.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES || (TYPES = {}));\nvar SAMPLER_TYPES;\n(function(n) {\n  n[n.FLOAT = 0] = \"FLOAT\", n[n.INT = 1] = \"INT\", n[n.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));\nvar SCALE_MODES;\n(function(n) {\n  n[n.NEAREST = 0] = \"NEAREST\", n[n.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES || (SCALE_MODES = {}));\nvar WRAP_MODES;\n(function(n) {\n  n[n.CLAMP = 33071] = \"CLAMP\", n[n.REPEAT = 10497] = \"REPEAT\", n[n.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES || (WRAP_MODES = {}));\nvar MIPMAP_MODES;\n(function(n) {\n  n[n.OFF = 0] = \"OFF\", n[n.POW2 = 1] = \"POW2\", n[n.ON = 2] = \"ON\", n[n.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES || (MIPMAP_MODES = {}));\nvar ALPHA_MODES;\n(function(n) {\n  n[n.NPM = 0] = \"NPM\", n[n.UNPACK = 1] = \"UNPACK\", n[n.PMA = 2] = \"PMA\", n[n.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", n[n.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", n[n.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", n[n.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES || (ALPHA_MODES = {}));\nvar CLEAR_MODES;\n(function(n) {\n  n[n.NO = 0] = \"NO\", n[n.YES = 1] = \"YES\", n[n.AUTO = 2] = \"AUTO\", n[n.BLEND = 0] = \"BLEND\", n[n.CLEAR = 1] = \"CLEAR\", n[n.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES || (CLEAR_MODES = {}));\nvar GC_MODES;\n(function(n) {\n  n[n.AUTO = 0] = \"AUTO\", n[n.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES || (GC_MODES = {}));\nvar PRECISION;\n(function(n) {\n  n.LOW = \"lowp\", n.MEDIUM = \"mediump\", n.HIGH = \"highp\";\n})(PRECISION || (PRECISION = {}));\nvar MASK_TYPES;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.SCISSOR = 1] = \"SCISSOR\", n[n.STENCIL = 2] = \"STENCIL\", n[n.SPRITE = 3] = \"SPRITE\", n[n.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES || (MASK_TYPES = {}));\nvar COLOR_MASK_BITS;\n(function(n) {\n  n[n.RED = 1] = \"RED\", n[n.GREEN = 2] = \"GREEN\", n[n.BLUE = 4] = \"BLUE\", n[n.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));\nvar MSAA_QUALITY;\n(function(n) {\n  n[n.NONE = 0] = \"NONE\", n[n.LOW = 2] = \"LOW\", n[n.MEDIUM = 4] = \"MEDIUM\", n[n.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY || (MSAA_QUALITY = {}));\nvar BUFFER_TYPE;\n(function(n) {\n  n[n.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", n[n.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", n[n.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE || (BUFFER_TYPE = {}));\n/*!\n * @pixi/utils - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nfunction mapPremultipliedBlendModes() {\n  for (var n = [], t = [], e = 0; e < 32; e++)\n    n[e] = e, t[e] = e;\n  n[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, n[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, n[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  var o = [];\n  return o.push(t), o.push(n), o;\n}\nmapPremultipliedBlendModes();\nvar warnings = {};\nfunction deprecation(n, t, e) {\n  if (e === void 0 && (e = 3), !warnings[t]) {\n    var o = new Error().stack;\n    typeof o > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + n) : (o = o.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + n), console.warn(o), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + n), console.warn(o))), warnings[t] = !0;\n  }\n}\n(function() {\n  function n(t, e, o) {\n    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = o || settings.RESOLUTION, this.resize(t, e);\n  }\n  return n.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }, n.prototype.resize = function(t, e) {\n    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n  }, n.prototype.destroy = function() {\n    this.context = null, this.canvas = null;\n  }, Object.defineProperty(n.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(t) {\n      this.canvas.width = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(t) {\n      this.canvas.height = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n;\n})();\nvar Application = function() {\n  function n(t) {\n    var e = this;\n    this.stage = new Container(), t = Object.assign({\n      forceCanvas: !1\n    }, t), this.renderer = autoDetectRenderer(t), n._plugins.forEach(function(o) {\n      o.init.call(e, t);\n    });\n  }\n  return n.registerPlugin = function(t) {\n    deprecation(\"6.5.0\", \"Application.registerPlugin() is deprecated, use extensions.add()\"), extensions.add({\n      type: ExtensionType.Application,\n      ref: t\n    });\n  }, n.prototype.render = function() {\n    this.renderer.render(this.stage);\n  }, Object.defineProperty(n.prototype, \"view\", {\n    get: function() {\n      return this.renderer.view;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(n.prototype, \"screen\", {\n    get: function() {\n      return this.renderer.screen;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), n.prototype.destroy = function(t, e) {\n    var o = this, R = n._plugins.slice(0);\n    R.reverse(), R.forEach(function(N) {\n      N.destroy.call(o);\n    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;\n  }, n._plugins = [], n;\n}();\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ResizePlugin);\n/*!\n * @pixi/mesh-extras - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$8 = function(n, t) {\n  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$8(n, t);\n};\nfunction __extends$8(n, t) {\n  extendStatics$8(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar PlaneGeometry = function(n) {\n  __extends$8(t, n);\n  function t(e, o, R, N) {\n    e === void 0 && (e = 100), o === void 0 && (o = 100), R === void 0 && (R = 10), N === void 0 && (N = 10);\n    var M = n.call(this) || this;\n    return M.segWidth = R, M.segHeight = N, M.width = e, M.height = o, M.build(), M;\n  }\n  return t.prototype.build = function() {\n    for (var e = this.segWidth * this.segHeight, o = [], R = [], N = [], M = this.segWidth - 1, D = this.segHeight - 1, L = this.width / M, B = this.height / D, $ = 0; $ < e; $++) {\n      var k = $ % this.segWidth, U = $ / this.segWidth | 0;\n      o.push(k * L, U * B), R.push(k / M, U / D);\n    }\n    for (var z = M * D, $ = 0; $ < z; $++) {\n      var X = $ % M, V = $ / M | 0, W = V * this.segWidth + X, Y = V * this.segWidth + X + 1, q = (V + 1) * this.segWidth + X, Z = (V + 1) * this.segWidth + X + 1;\n      N.push(W, Y, q, Y, Z, q);\n    }\n    this.buffers[0].data = new Float32Array(o), this.buffers[1].data = new Float32Array(R), this.indexBuffer.data = new Uint16Array(N), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n  }, t;\n}(MeshGeometry), RopeGeometry = function(n) {\n  __extends$8(t, n);\n  function t(e, o, R) {\n    e === void 0 && (e = 200), R === void 0 && (R = 0);\n    var N = n.call(this, new Float32Array(o.length * 4), new Float32Array(o.length * 4), new Uint16Array((o.length - 1) * 6)) || this;\n    return N.points = o, N._width = e, N.textureScale = R, N.build(), N;\n  }\n  return Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.build = function() {\n    var e = this.points;\n    if (!!e) {\n      var o = this.getBuffer(\"aVertexPosition\"), R = this.getBuffer(\"aTextureCoord\"), N = this.getIndex();\n      if (!(e.length < 1)) {\n        o.data.length / 4 !== e.length && (o.data = new Float32Array(e.length * 4), R.data = new Float32Array(e.length * 4), N.data = new Uint16Array((e.length - 1) * 6));\n        var M = R.data, D = N.data;\n        M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1;\n        for (var L = 0, B = e[0], $ = this._width * this.textureScale, k = e.length, U = 0; U < k; U++) {\n          var z = U * 4;\n          if (this.textureScale > 0) {\n            var X = B.x - e[U].x, V = B.y - e[U].y, W = Math.sqrt(X * X + V * V);\n            B = e[U], L += W / $;\n          } else\n            L = U / (k - 1);\n          M[z] = L, M[z + 1] = 0, M[z + 2] = L, M[z + 3] = 1;\n        }\n        for (var Y = 0, U = 0; U < k - 1; U++) {\n          var z = U * 2;\n          D[Y++] = z, D[Y++] = z + 1, D[Y++] = z + 2, D[Y++] = z + 2, D[Y++] = z + 1, D[Y++] = z + 3;\n        }\n        R.update(), N.update(), this.updateVertices();\n      }\n    }\n  }, t.prototype.updateVertices = function() {\n    var e = this.points;\n    if (!(e.length < 1)) {\n      for (var o = e[0], R, N = 0, M = 0, D = this.buffers[0].data, L = e.length, B = 0; B < L; B++) {\n        var $ = e[B], k = B * 4;\n        B < e.length - 1 ? R = e[B + 1] : R = $, M = -(R.x - o.x), N = R.y - o.y;\n        var U = Math.sqrt(N * N + M * M), z = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n        N /= U, M /= U, N *= z, M *= z, D[k] = $.x + N, D[k + 1] = $.y + M, D[k + 2] = $.x - N, D[k + 3] = $.y - M, o = $;\n      }\n      this.buffers[0].update();\n    }\n  }, t.prototype.update = function() {\n    this.textureScale > 0 ? this.build() : this.updateVertices();\n  }, t;\n}(MeshGeometry);\n(function(n) {\n  __extends$8(t, n);\n  function t(e, o, R) {\n    R === void 0 && (R = 0);\n    var N = this, M = new RopeGeometry(e.height, o, R), D = new MeshMaterial(e);\n    return R > 0 && (e.baseTexture.wrapMode = WRAP_MODES$5.REPEAT), N = n.call(this, M, D) || this, N.autoUpdate = !0, N;\n  }\n  return t.prototype._render = function(e) {\n    var o = this.geometry;\n    (this.autoUpdate || o._width !== this.shader.texture.height) && (o._width = this.shader.texture.height, o.update()), n.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar SimplePlane = function(n) {\n  __extends$8(t, n);\n  function t(e, o, R) {\n    var N = this, M = new PlaneGeometry(e.width, e.height, o, R), D = new MeshMaterial(Texture.WHITE);\n    return N = n.call(this, M, D) || this, N.texture = e, N.autoResize = !0, N;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID;\n    var e = this.geometry, o = this.shader.texture, R = o.width, N = o.height;\n    this.autoResize && (e.width !== R || e.height !== N) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());\n  }, Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.shader.texture;\n    },\n    set: function(e) {\n      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once(\"update\", this.textureUpdated, this));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), n.prototype._render.call(this, e);\n  }, t.prototype.destroy = function(e) {\n    this.shader.texture.off(\"update\", this.textureUpdated, this), n.prototype.destroy.call(this, e);\n  }, t;\n}(Mesh);\n(function(n) {\n  __extends$8(t, n);\n  function t(e, o, R, N, M) {\n    e === void 0 && (e = Texture.EMPTY);\n    var D = this, L = new MeshGeometry(o, R, N);\n    L.getBuffer(\"aVertexPosition\").static = !1;\n    var B = new MeshMaterial(e);\n    return D = n.call(this, L, B, null, M) || this, D.autoUpdate = !0, D;\n  }\n  return Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this.autoUpdate && this.geometry.getBuffer(\"aVertexPosition\").update(), n.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n(function(n) {\n  __extends$8(t, n);\n  function t(e, o, R, N, M) {\n    o === void 0 && (o = DEFAULT_BORDER_SIZE), R === void 0 && (R = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE), M === void 0 && (M = DEFAULT_BORDER_SIZE);\n    var D = n.call(this, Texture.WHITE, 4, 4) || this;\n    return D._origWidth = e.orig.width, D._origHeight = e.orig.height, D._width = D._origWidth, D._height = D._origHeight, D._leftWidth = o, D._rightWidth = N, D._topHeight = R, D._bottomHeight = M, D.texture = e, D;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }, Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.updateHorizontalVertices = function() {\n    var e = this.vertices, o = this._getMinScale();\n    e[9] = e[11] = e[13] = e[15] = this._topHeight * o, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * o, e[25] = e[27] = e[29] = e[31] = this._height;\n  }, t.prototype.updateVerticalVertices = function() {\n    var e = this.vertices, o = this._getMinScale();\n    e[2] = e[10] = e[18] = e[26] = this._leftWidth * o, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * o, e[6] = e[14] = e[22] = e[30] = this._width;\n  }, t.prototype._getMinScale = function() {\n    var e = this._leftWidth + this._rightWidth, o = this._width > e ? 1 : this._width / e, R = this._topHeight + this._bottomHeight, N = this._height > R ? 1 : this._height / R, M = Math.min(o, N);\n    return M;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"leftWidth\", {\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(e) {\n      this._leftWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rightWidth\", {\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(e) {\n      this._rightWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"topHeight\", {\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(e) {\n      this._topHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"bottomHeight\", {\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(e) {\n      this._bottomHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._refresh = function() {\n    var e = this.texture, o = this.geometry.buffers[1].data;\n    this._origWidth = e.orig.width, this._origHeight = e.orig.height;\n    var R = 1 / this._origWidth, N = 1 / this._origHeight;\n    o[0] = o[8] = o[16] = o[24] = 0, o[1] = o[3] = o[5] = o[7] = 0, o[6] = o[14] = o[22] = o[30] = 1, o[25] = o[27] = o[29] = o[31] = 1, o[2] = o[10] = o[18] = o[26] = R * this._leftWidth, o[4] = o[12] = o[20] = o[28] = 1 - R * this._rightWidth, o[9] = o[11] = o[13] = o[15] = N * this._topHeight, o[17] = o[19] = o[21] = o[23] = 1 - N * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }, t;\n})(SimplePlane);\n/*!\n * @pixi/sprite-animated - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$7 = function(n, t) {\n  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$7(n, t);\n};\nfunction __extends$7(n, t) {\n  extendStatics$7(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar AnimatedSprite = function(n) {\n  __extends$7(t, n);\n  function t(e, o) {\n    o === void 0 && (o = !0);\n    var R = n.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;\n    return R._textures = null, R._durations = null, R._autoUpdate = o, R._isConnectedToTicker = !1, R.animationSpeed = 1, R.loop = !0, R.updateAnchor = !1, R.onComplete = null, R.onFrameChange = null, R.onLoop = null, R._currentTime = 0, R._playing = !1, R._previousFrame = null, R.textures = e, R;\n  }\n  return t.prototype.stop = function() {\n    !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n  }, t.prototype.play = function() {\n    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));\n  }, t.prototype.gotoAndStop = function(e) {\n    this.stop();\n    var o = this.currentFrame;\n    this._currentTime = e, o !== this.currentFrame && this.updateTexture();\n  }, t.prototype.gotoAndPlay = function(e) {\n    var o = this.currentFrame;\n    this._currentTime = e, o !== this.currentFrame && this.updateTexture(), this.play();\n  }, t.prototype.update = function(e) {\n    if (!!this._playing) {\n      var o = this.animationSpeed * e, R = this.currentFrame;\n      if (this._durations !== null) {\n        var N = this._currentTime % 1 * this._durations[this.currentFrame];\n        for (N += o / 60 * 1e3; N < 0; )\n          this._currentTime--, N += this._durations[this.currentFrame];\n        var M = Math.sign(this.animationSpeed * e);\n        for (this._currentTime = Math.floor(this._currentTime); N >= this._durations[this.currentFrame]; )\n          N -= this._durations[this.currentFrame] * M, this._currentTime += M;\n        this._currentTime += N / this._durations[this.currentFrame];\n      } else\n        this._currentTime += o;\n      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : R !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < R ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > R && this.onLoop()), this.updateTexture());\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.currentFrame;\n    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n  }, t.prototype.destroy = function(e) {\n    this.stop(), n.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n  }, t.fromFrames = function(e) {\n    for (var o = [], R = 0; R < e.length; ++R)\n      o.push(Texture.from(e[R]));\n    return new t(o);\n  }, t.fromImages = function(e) {\n    for (var o = [], R = 0; R < e.length; ++R)\n      o.push(Texture.from(e[R]));\n    return new t(o);\n  }, Object.defineProperty(t.prototype, \"totalFrames\", {\n    get: function() {\n      return this._textures.length;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textures\", {\n    get: function() {\n      return this._textures;\n    },\n    set: function(e) {\n      if (e[0] instanceof Texture)\n        this._textures = e, this._durations = null;\n      else {\n        this._textures = [], this._durations = [];\n        for (var o = 0; o < e.length; o++)\n          this._textures.push(e[o].texture), this._durations.push(e[o].time);\n      }\n      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"currentFrame\", {\n    get: function() {\n      var e = Math.floor(this._currentTime) % this._textures.length;\n      return e < 0 && (e += this._textures.length), e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"playing\", {\n    get: function() {\n      return this._playing;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Sprite);\n/*!\n * pixi.js - v6.5.1\n * Compiled Sun, 24 Jul 2022 20:56:21 UTC\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nextensions.add(\n  AccessibilityManager,\n  Extract,\n  InteractionManager,\n  ParticleRenderer,\n  Prepare,\n  BatchRenderer,\n  TilingSpriteRenderer,\n  BitmapFontLoader,\n  CompressedTextureLoader,\n  DDSLoader,\n  KTXLoader,\n  SpritesheetLoader,\n  TickerPlugin,\n  AppLoaderPlugin\n);\nvar ye, Ne, gi, Tu, ec, ns, jo, Su, rc, Cu, ic, Ba, ah, Qi, da, $a, oh, ss, as, Vo, tn, pa, ka, os, Xo, Iu, nc, Pr, fi, wu, sc, Ga, uh, en, va, Ru, ac, Ua, lh, Pu, oc, Au, uc, us, Wo;\nconst Ta = class {\n  constructor(t, e, o, R, N) {\n    it(this, Tu);\n    it(this, ns);\n    it(this, Su);\n    it(this, Cu);\n    it(this, Ba);\n    it(this, Qi);\n    it(this, $a);\n    it(this, as);\n    it(this, tn);\n    it(this, os);\n    it(this, Iu);\n    it(this, Pr);\n    it(this, wu);\n    it(this, Ga);\n    it(this, en);\n    it(this, Ru);\n    it(this, Ua);\n    it(this, Pu);\n    it(this, Au);\n    it(this, us);\n    it(this, ye, {});\n    it(this, Ne, {});\n    it(this, gi, void 0);\n    it(this, ka, () => {\n      I.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1)), et(this, ka, () => {\n      });\n    });\n    this.cfg = t, this.val = o, this.main = R, this.sys = N, e.volume = (M) => at(this, Tu, ec).call(this, M), e.fadebgm = (M) => at(this, Ba, ah).call(this, M), e.fadeoutbgm = (M) => at(this, Su, rc).call(this, M), e.fadeoutse = (M) => at(this, Cu, ic).call(this, M), e.fadese = (M) => at(this, Qi, da).call(this, M), e.playbgm = (M) => at(this, $a, oh).call(this, M), e.playse = (M) => at(this, as, Vo).call(this, M), e.stop_allse = () => at(this, os, Xo).call(this), e.stopbgm = (M) => at(this, Iu, nc).call(this, M), e.stopse = (M) => at(this, Pr, fi).call(this, M), e.wb = (M) => at(this, wu, sc).call(this, M), e.wf = (M) => at(this, Ga, uh).call(this, M), e.stopfadese = (M) => at(this, en, va).call(this, M), e.wl = (M) => at(this, Ru, ac).call(this, M), e.ws = (M) => at(this, Ua, lh).call(this, M), e.xchgbuf = (M) => at(this, Pu, oc).call(this, M), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\"), o.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(G.supported));\n  }\n  setEvtMng(t) {\n    et(this, gi, t);\n  }\n  setNoticeChgVolume(t, e) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (o, R) => t(I.volumeAll = Number(R))), this.val.defValTrg(\"sys:sn.sound.movie_volume\", (o, R) => e(Number(R))), this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1)), this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    I.removeAll();\n  }\n  loadAheadSnd(t) {\n    [t.clickse, t.enterse, t.leavese].forEach((e) => {\n      !e || I.exists(e) || at(this, tn, pa).call(this, \"\", e, { preload: !0, autoPlay: !1 });\n    });\n  }\n  playLoopFromSaveObj() {\n    const t = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    if (this.val.flush(), t === \"{}\") {\n      at(this, os, Xo).call(this);\n      return;\n    }\n    const e = [];\n    et(this, Ne, JSON.parse(t));\n    for (const o in H(this, Ne)) {\n      const R = \"save:const.sn.sound.\" + o + \".\", N = {\n        fn: String(this.val.getVal(R + \"fn\")),\n        buf: o,\n        join: !1,\n        loop: !0,\n        volume: Number(this.val.getVal(R + \"volume\")),\n        start_ms: Number(this.val.getVal(R + \"start_ms\")),\n        end_ms: Number(this.val.getVal(R + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(R + \"ret_ms\"))\n      };\n      e.push(() => {\n        N.buf === \"BGM\" ? at(this, $a, oh).call(this, N) : at(this, as, Vo).call(this, N);\n      });\n    }\n    at(this, os, Xo).call(this), e.forEach((o) => o());\n  }\n};\nlet SoundMng = Ta;\nye = new WeakMap(), Ne = new WeakMap(), gi = new WeakMap(), Tu = new WeakSet(), ec = function(t) {\n  const { buf: e = \"SE\" } = t, o = \"const.sn.sound.\" + e + \".volume\", R = at(this, ns, jo).call(this, t, 1);\n  return Number(this.val.getVal(\"sys:\" + o)) === R ? !1 : (this.val.setVal_Nochk(\"sys\", o, R), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal(\"save:\" + o)), at(this, Qi, da).call(this, t));\n}, ns = new WeakSet(), jo = function(t, e) {\n  const o = argChk_Num(t, \"volume\", e);\n  return o < 0 ? 0 : o > 1 ? 1 : o;\n}, Su = new WeakSet(), rc = function(t) {\n  return t.volume = 0, at(this, Ba, ah).call(this, t);\n}, Cu = new WeakSet(), ic = function(t) {\n  return t.volume = 0, at(this, Qi, da).call(this, t);\n}, Ba = new WeakSet(), ah = function(t) {\n  return t.buf = \"BGM\", at(this, Qi, da).call(this, t);\n}, Qi = new WeakSet(), da = function(t) {\n  at(this, en, va).call(this, t);\n  const { buf: e = \"SE\" } = t, o = H(this, ye)[e];\n  if (!(o != null && o.playing()) || !o.snd)\n    return !1;\n  const R = \"const.sn.sound.\" + e + \".volume\", N = at(this, ns, jo).call(this, t, NaN);\n  this.val.setVal_Nochk(\"save\", R, N);\n  const M = N * Number(this.val.getVal(\"sys:\" + R, 1)), D = argChk_Boolean(t, \"stop\", N === 0);\n  D && (at(this, us, Wo).call(this, e), this.val.setVal_Nochk(\"save\", \"const.sn.sound.\" + e + \".fn\", \"\")), this.val.flush();\n  const L = argChk_Num(t, \"time\", NaN), B = argChk_Num(t, \"delay\", 0);\n  if (L === 0 && B === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, gi).isSkippingByKeyDown())\n    return o.snd.volume = M, D && at(this, Pr, fi).call(this, t), !1;\n  const $ = argChk_Num(t, \"repeat\", 1);\n  return o.twFade = new Tween({ v: o.snd.volume }).to({ v: M }, L).delay(B).easing(CmnTween.ease(t.ease)).repeat($ === 0 ? 1 / 0 : $ - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onUpdate((k) => {\n    o.playing() && (o.snd.volume = k.v);\n  }).onComplete(() => {\n    const k = H(this, ye)[t.buf = o.now_buf];\n    !(k != null && k.twFade) || (delete k.twFade, D && at(this, Pr, fi).call(this, t), k.resumeFade && this.main.resume());\n  }).start(), !1;\n}, $a = new WeakSet(), oh = function(t) {\n  return t.buf = \"BGM\", t.canskip = !1, argChk_Boolean(t, \"loop\", !0), at(this, as, Vo).call(this, t);\n}, ss = new WeakMap(), as = new WeakSet(), Vo = function(t) {\n  const { buf: e = \"SE\", fn: o } = t;\n  if (at(this, Pr, fi).call(this, { buf: e }), !o)\n    throw `[playse] fn\\u306F\\u5FC5\\u9808\\u3067\\u3059 buf:${e}`;\n  if (argChk_Boolean(t, \"canskip\", !0) && H(this, gi).isSkippingByKeyDown())\n    return !1;\n  const R = argChk_Boolean(t, \"loop\", !1);\n  at(this, Au, uc).call(this, e, R);\n  const N = \"const.sn.sound.\" + e + \".\";\n  this.val.setVal_Nochk(\"save\", N + \"fn\", o);\n  const M = at(this, ns, jo).call(this, t, 1);\n  this.val.setVal_Nochk(\"save\", N + \"volume\", M);\n  const D = M * Number(this.val.getVal(\"sys:\" + N + \"volume\", 1)), L = argChk_Num(t, \"start_ms\", 0), B = argChk_Num(t, \"end_ms\", H(Ta, ss)), $ = argChk_Num(t, \"ret_ms\", 0);\n  if (L < 0)\n    throw `[playse] start_ms:${L} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if ($ < 0)\n    throw `[playse] ret_ms:${$} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if (B > 0) {\n    if (L >= B)\n      throw `[playse] start_ms:${L} >= end_ms:${B} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n    if ($ >= B)\n      throw `[playse] ret_ms:${$} >= end_ms:${B} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n  }\n  this.val.setVal_Nochk(\"save\", N + \"start_ms\", L), this.val.setVal_Nochk(\"save\", N + \"end_ms\", B), this.val.setVal_Nochk(\"save\", N + \"ret_ms\", $), this.val.flush();\n  const k = I.find(o), U = H(this, ye)[e] = {\n    now_buf: e,\n    snd: k,\n    loop: R,\n    start_ms: L,\n    end_ms: B,\n    ret_ms: $,\n    resume: !1,\n    playing: () => !0,\n    onend: () => {\n      const W = H(this, ye)[t.buf = U.now_buf];\n      !W || (delete H(this, ye)[t.buf], W.playing = () => !1, at(this, en, va).call(this, t), W.resume && this.main.resume());\n    }\n  }, z = {\n    loop: R,\n    volume: D,\n    speed: argChk_Num(t, \"speed\", 1),\n    sprites: {},\n    loaded: (W, Y) => {\n      if (W) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059a fn:${o} ${W}`, !1);\n        return;\n      }\n      if (!Y)\n        return;\n      const q = H(this, ye)[U.now_buf];\n      q && (q.snd = Y);\n    }\n  };\n  let X = \"\";\n  if (L > 0 || B < H(Ta, ss)) {\n    X = `${o};${L};${B};${$}`;\n    const W = z.sprites[X] = {\n      start: L / 1e3,\n      end: B / 1e3\n    };\n    z.preload = !0;\n    const Y = z.loaded;\n    z.loaded = (q, Z) => {\n      if (q) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059b fn:${o} ${q}`, !1);\n        return;\n      }\n      if (!Z)\n        return;\n      const K = Z.duration;\n      if (Y == null || Y(q, Z), W.end < 0) {\n        if (W.end += K, Z.removeSprites(X), Z.addSprites(X, W), W.start >= W.end)\n          throw `[playse] start_ms:${L} >= end_ms:${B}(${W.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n        if ($ >= W.end * 1e3)\n          throw `[playse] ret_ms:${$} >= end_ms:${B}(${W.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      }\n      if (W.start >= K)\n        throw `[playse] start_ms:${L} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${K} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      if (B !== H(Ta, ss) && W.end >= K)\n        throw `[playse] end_ms:${B} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${K} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      Z.play(X, z.complete);\n    };\n  } else\n    z.autoPlay = !0;\n  if (R ? $ !== 0 && (z.loop = !1, z.complete = (W) => {\n    const Y = W.duration, q = `${o};loop2;${B};${$}`, Z = {\n      preload: !0,\n      loop: !0,\n      volume: D,\n      speed: z.speed,\n      sprites: {},\n      loaded: (Q, J) => {\n        if (!J)\n          return;\n        const rt = H(this, ye)[U.now_buf];\n        rt && (rt.snd = J), J.play(q);\n      }\n    }, K = Z.sprites[q] = {\n      start: $ / 1e3,\n      end: B / 1e3\n    };\n    if (K.end < 0 && (K.end += Y, W.removeSprites(q), W.addSprites(q, K)), K.start >= Y)\n      throw `[playse] ret_ms:${$} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${Y} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n    at(this, tn, pa).call(this, e, o, Z);\n  }) : z.complete = () => {\n    var W;\n    return (W = H(this, ye)[U.now_buf]) == null ? void 0 : W.onend();\n  }, H(this, ka).call(this), k) {\n    if (k.volume = D, X)\n      at(this, tn, pa).call(this, e, o, z);\n    else if (k.isPlayable) {\n      const W = k.options.source;\n      !(W instanceof ArrayBuffer) || W.byteLength === 0 ? k.play(z) : U.snd = A.from({\n        ...z,\n        url: k.options.url,\n        source: W\n      });\n    }\n    return !1;\n  }\n  const V = argChk_Boolean(t, \"join\", !0);\n  if (V) {\n    const W = z.loaded;\n    z.loaded = (Y, q) => {\n      W == null || W(Y, q), this.main.resume();\n    };\n  }\n  return at(this, tn, pa).call(this, e, o, z), V;\n}, tn = new WeakSet(), pa = function(t, e, o) {\n  const R = this.cfg.searchPath(e, Config.EXT_SOUND);\n  if (R.slice(-4) !== \".bin\") {\n    o.url = R;\n    const N = A.from(o);\n    t && (H(this, ye)[t].snd = N), o.loop || I.add(e, N);\n    return;\n  }\n  new Loader().add({ name: e, url: R, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((N, M) => {\n    this.sys.dec(N.extension, N.data).then((D) => {\n      N.data = D, M == null || M();\n    }).catch((D) => this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${N.name} ${D}`, !1));\n  }).load((N, M) => {\n    var L;\n    o.source = (L = M[e]) == null ? void 0 : L.data;\n    const D = A.from(o);\n    t && (H(this, ye)[t].snd = D), o.loop || I.add(e, D);\n  });\n}, ka = new WeakMap(), os = new WeakSet(), Xo = function() {\n  for (const t in H(this, ye))\n    at(this, Pr, fi).call(this, { buf: t });\n  return et(this, ye, {}), I.stopAll(), !1;\n}, Iu = new WeakSet(), nc = function(t) {\n  return t.buf = \"BGM\", at(this, Pr, fi).call(this, t);\n}, Pr = new WeakSet(), fi = function(t) {\n  var R;\n  const { buf: e = \"SE\" } = t;\n  at(this, us, Wo).call(this, e);\n  const o = H(this, ye)[e];\n  return o && ((R = o.snd) == null || R.stop(), o.onend()), !1;\n}, wu = new WeakSet(), sc = function(t) {\n  return t.buf = \"BGM\", at(this, Ga, uh).call(this, t);\n}, Ga = new WeakSet(), uh = function(t) {\n  const { buf: e = \"SE\" } = t, o = H(this, ye)[e];\n  return !(o != null && o.twFade) || !o.playing() ? !1 : o.resumeFade = H(this, gi).waitEvent(\n    () => at(this, en, va).call(this, t),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, en = new WeakSet(), va = function(t) {\n  var o, R;\n  const { buf: e = \"SE\" } = t;\n  return (R = (o = H(this, ye)[e]) == null ? void 0 : o.twFade) == null || R.stop().end(), !1;\n}, Ru = new WeakSet(), ac = function(t) {\n  return t.buf = \"BGM\", at(this, Ua, lh).call(this, t);\n}, Ua = new WeakSet(), lh = function(t) {\n  const { buf: e = \"SE\" } = t, o = H(this, ye)[e];\n  return !(o != null && o.playing()) || o.loop ? !1 : o.resume = H(this, gi).waitEvent(\n    () => {\n      t.buf = o.now_buf, at(this, Pr, fi).call(this, t);\n      const R = H(this, ye)[t.buf];\n      !(R != null && R.playing()) || R.loop || R.onend();\n    },\n    argChk_Boolean(t, \"canskip\", !1),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, Pu = new WeakSet(), oc = function(t) {\n  const { buf: e = \"SE\", buf2: o = \"SE\" } = t;\n  if (e === o)\n    return !1;\n  const R = H(this, ye)[e];\n  R && (R.now_buf = o);\n  const N = H(this, ye)[o];\n  N && (N.now_buf = e), [H(this, ye)[e], H(this, ye)[o]] = [N, R];\n  const M = \"const.sn.sound.\" + e + \".\", D = Number(this.val.getVal(\"save:\" + M + \"volume\")), L = Number(this.val.getVal(\"save:\" + M + \"fn\")), B = \"const.sn.sound.\" + o + \".\", $ = Number(this.val.getVal(\"save:\" + B + \"volume\")), k = Number(this.val.getVal(\"save:\" + B + \"fn\"));\n  return this.val.setVal_Nochk(\"save\", M + \"volume\", $), this.val.setVal_Nochk(\"save\", B + \"volume\", D), this.val.setVal_Nochk(\"save\", M + \"fn\", k), this.val.setVal_Nochk(\"save\", B + \"fn\", L), e in H(this, Ne) == o in H(this, Ne) && (e in H(this, Ne) ? (delete H(this, Ne)[e], H(this, Ne)[o] = 0) : (delete H(this, Ne)[o], H(this, Ne)[e] = 0), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, Ne)))), this.val.flush(), !1;\n}, Au = new WeakSet(), uc = function(t, e) {\n  if (!e) {\n    at(this, us, Wo).call(this, t);\n    return;\n  }\n  H(this, Ne)[t] = 0, this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, Ne))), this.val.flush();\n}, us = new WeakSet(), Wo = function(t) {\n  delete H(this, Ne)[t], this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, Ne))), this.val.flush();\n}, it(SoundMng, ss, 999e3);\nvar oe;\nconst Lh = class {\n  constructor(t, e, o, R, N, M, D, L) {\n    it(this, oe, void 0);\n    this.cls = e, this.hArg = N, this.sys = M, this.val = D, this.ret = L, this.lay = (U) => this.getPage(U).lay(U), this.getPage = (U) => Lh.argChk_page(U, \"fore\") !== \"back\" ? H(this, oe).fore : H(this, oe).back;\n    const B = M.hFactoryCls[e];\n    if (!B)\n      throw `\\u5C5E\\u6027 class\\u3010${e}\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059`;\n    et(this, oe, { fore: B(), back: B() }), H(this, oe).fore.layname = H(this, oe).back.layname = t;\n    const $ = N[\":id_tag\"] = `layer:${t} cls:${e}`;\n    H(this, oe).fore.name = `${$} page:A`, H(this, oe).back.name = `${$} page:B`, o.addChild(this.fore.spLay), R.addChild(this.back.spLay), argChk_Boolean(N, \"visible\", !0), argChk_Boolean(N, \"visible\", !0), L.isWait = this.fore.lay(N) || this.back.lay(N);\n    const k = `const.sn.lay.${t}`;\n    D.setVal_Nochk(\"tmp\", k, !0), D.defTmp(k + \".fore.alpha\", () => H(this, oe).fore.alpha), D.defTmp(k + \".back.alpha\", () => H(this, oe).back.alpha), D.defTmp(k + \".fore.height\", () => H(this, oe).fore.height), D.defTmp(k + \".back.height\", () => H(this, oe).back.height), D.defTmp(k + \".fore.visible\", () => H(this, oe).fore.spLay.visible), D.defTmp(k + \".back.visible\", () => H(this, oe).back.spLay.visible), D.defTmp(k + \".fore.width\", () => H(this, oe).fore.width), D.defTmp(k + \".back.width\", () => H(this, oe).back.width), D.defTmp(k + \".fore.x\", () => H(this, oe).fore.x), D.defTmp(k + \".back.x\", () => H(this, oe).back.x), D.defTmp(k + \".fore.y\", () => H(this, oe).fore.y), D.defTmp(k + \".back.y\", () => H(this, oe).back.y);\n  }\n  destroy() {\n    H(this, oe).fore.destroy(), H(this, oe).back.destroy();\n  }\n  static argChk_page(t, e) {\n    var R;\n    const o = (R = t.page) != null ? R : e;\n    if (o === \"fore\" || o === \"back\")\n      return t.page = o;\n    throw Error(\"\\u5C5E\\u6027 page\\u3010\" + o + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\");\n  }\n  get fore() {\n    return H(this, oe).fore;\n  }\n  get back() {\n    return H(this, oe).back;\n  }\n  transPage(t) {\n    [H(this, oe).back, H(this, oe).fore] = [H(this, oe).fore, H(this, oe).back], H(this, oe).back.copy(H(this, oe).fore, t);\n  }\n};\nlet Pages = Lh;\noe = new WeakMap();\nvar Ou;\nconst Xi = class {\n  constructor() {\n    this.layname = \"\", this.name_ = \"\", this.spLay = new Sprite(Texture.EMPTY);\n  }\n  set name(t) {\n    this.name_ = t;\n  }\n  get name() {\n    return this.name_;\n  }\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(t) {\n    this.spLay.alpha = t;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(t) {\n    this.spLay.angle = t;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(t) {\n    this.spLay.scale.x = t;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(t) {\n    this.spLay.scale.y = t;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(t) {\n    this.spLay.x = t;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(t) {\n    this.spLay.y = t;\n  }\n  destroy() {\n  }\n  lay(t) {\n    return \"alpha\" in t && (this.spLay.alpha = argChk_Num(t, \"alpha\", 1)), Xi.setBlendmode(this.spLay, t), (\"pivot_x\" in t || \"pivot_y\" in t) && this.spLay.pivot.set(\n      argChk_Num(t, \"pivot_x\", this.spLay.pivot.x),\n      argChk_Num(t, \"pivot_y\", this.spLay.pivot.y)\n    ), \"rotation\" in t && (this.spLay.angle = argChk_Num(t, \"rotation\", 0)), (\"scale_x\" in t || \"scale_y\" in t) && this.spLay.scale.set(\n      argChk_Num(t, \"scale_x\", this.spLay.scale.x),\n      argChk_Num(t, \"scale_y\", this.spLay.scale.y)\n    ), \"visible\" in t && (this.spLay.visible = argChk_Boolean(t, \"visible\", !0)), !1;\n  }\n  static setBlendmode(t, e) {\n    const { blendmode: o } = e;\n    if (!o)\n      return;\n    const R = Xi.getBlendmodeNum(o), N = t;\n    N && (N.blendMode = R), t.children.forEach((M) => {\n      const D = M;\n      D && (D.blendMode = R);\n    });\n  }\n  static getBlendmodeNum(t) {\n    if (!t)\n      return BLEND_MODES$5.NORMAL;\n    const e = H(Xi, Ou)[t];\n    if (e !== void 0)\n      return e;\n    throw `${t} \\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044 blendmode \\u3067\\u3059`;\n  }\n  get containMovement() {\n    return !1;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(t) {\n    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES$5.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, \"filter\", !1) && (this.spLay.filters = []);\n  }\n  copy(t, e) {\n    const o = this.name_;\n    this.playback(t.record(), e), this.name = o;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(t, e) {\n    this.name = t.name, this.clearLay({ filter: \"true\" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;\n  }\n  snapshot(t, e) {\n    t.render(this.spLay, { clear: !1 }), e();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(t) {\n  }\n  makeDesignCastChildren(t) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(t, e, o, R = !1, N = !1) {\n    if (e.pos) {\n      Xi.setXYByPos(t, e.pos, o);\n      return;\n    }\n    const M = t.getBounds(), D = o.scale.x < 0 ? -o.scale.x : o.scale.x, L = D === 1 ? M.width : M.width * D, B = o.scale.y < 0 ? -o.scale.y : o.scale.y, $ = B === 1 ? M.height : M.height * B;\n    let k = o.x;\n    \"left\" in e ? (k = argChk_Num(e, \"left\", 0), k > -1 && k < 1 && (k *= CmnLib.stageW)) : \"center\" in e ? (k = argChk_Num(e, \"center\", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = k - (N ? L / 3 : L) / 2) : \"right\" in e ? (k = argChk_Num(e, \"right\", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = k - (N ? L / 3 : L)) : \"s_right\" in e && (k = argChk_Num(e, \"s_right\", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = CmnLib.stageW - k - (N ? L / 3 : L)), o.x = int(o.scale.x < 0 ? k + (N ? L / 3 : L) : k);\n    let U = o.y;\n    \"top\" in e ? (U = argChk_Num(e, \"top\", 0), U > -1 && U < 1 && (U *= CmnLib.stageH)) : \"middle\" in e ? (U = argChk_Num(e, \"middle\", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = U - $ / 2) : \"bottom\" in e ? (U = argChk_Num(e, \"bottom\", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = U - $) : \"s_bottom\" in e && (U = argChk_Num(e, \"s_bottom\", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = CmnLib.stageH - U - $), o.y = int(o.scale.y < 0 ? U + $ : U), R && !(\"left\" in e) && !(\"center\" in e) && !(\"right\" in e) && !(\"s_right\" in e) && !(\"top\" in e) && !(\"middle\" in e) && !(\"bottom\" in e) && !(\"s_bottom\" in e) && Xi.setXYByPos(t, \"c\", o);\n  }\n  static setXYByPos(t, e, o) {\n    if (e === \"stay\")\n      return;\n    if (t === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (o === void 0)\n      throw \"setXYByPos result === undefined\";\n    const R = t.getBounds(), N = o.scale.x < 0 ? -o.scale.x : o.scale.x, M = N === 1 ? R.width : R.width * N, D = o.scale.y < 0 ? -o.scale.y : o.scale.y, L = D === 1 ? R.height : R.height * D;\n    let B = 0;\n    !e || e === \"c\" ? B = CmnLib.stageW * 0.5 : e === \"r\" ? B = CmnLib.stageW - M * 0.5 : e === \"l\" ? B = M * 0.5 : B = int(e), o.x = int(B - M * 0.5), o.y = CmnLib.stageH - L, o.scale.x < 0 && (o.x += M), o.scale.y < 0 && (o.y += L);\n  }\n  static setXYCenter(t) {\n    const e = t.getBounds();\n    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;\n  }\n};\nlet Layer = Xi;\nOu = new WeakMap(), it(Layer, Ou, {\n  normal: BLEND_MODES$5.NORMAL,\n  add: BLEND_MODES$5.ADD,\n  multiply: BLEND_MODES$5.MULTIPLY,\n  screen: BLEND_MODES$5.SCREEN\n});\nvar _i;\nclass EventListenerCtn {\n  constructor() {\n    it(this, _i, []);\n  }\n  add(t, e, o, R = {}) {\n    if (t instanceof BaseTexture) {\n      switch (e) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          t.on(e, o, R), H(this, _i).push(() => t.off(e, o, R));\n          break;\n      }\n      return;\n    }\n    if (t instanceof EventEmitter$5) {\n      t.on(e, o, R), H(this, _i).push(() => t.off(e, o, R));\n      return;\n    }\n    t.addEventListener(e, o, R), H(this, _i).push(() => {\n      var N;\n      return t.removeEventListener(e, o, { capture: (N = R.capture) != null ? N : !1 });\n    });\n  }\n  clear() {\n    H(this, _i).forEach((t) => t()), et(this, _i, []);\n  }\n}\n_i = new WeakMap();\nfunction prefixNames(n) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  return t.map(function(o) {\n    return o.split(\" \").map(function(R) {\n      return R ? \"\" + n + R : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction prefixCSS(n, t) {\n  return t.replace(/([^}{]*){/gm, function(e, o) {\n    return o.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + n + \"$1\") + \"{\";\n  });\n}\nfunction ref(n, t) {\n  return function(e) {\n    e && (n[t] = e);\n  };\n}\nfunction refs(n, t, e) {\n  return function(o) {\n    o && (n[t][e] = o);\n  };\n}\nfunction Properties(n, t) {\n  return function(e) {\n    var o = e.prototype;\n    n.forEach(function(R) {\n      t(o, R);\n    });\n  };\n}\nfunction withMethods(n, t) {\n  return t === void 0 && (t = {}), function(e, o) {\n    n.forEach(function(R) {\n      var N = t[R] || R;\n      N in e || (e[N] = function() {\n        for (var M, D = [], L = 0; L < arguments.length; L++)\n          D[L] = arguments[L];\n        var B = (M = this[o])[R].apply(M, D);\n        return B === this[o] ? this : B;\n      });\n    });\n  };\n}\nvar PolyMap = /* @__PURE__ */ function() {\n  function n() {\n    this.keys = [], this.values = [];\n  }\n  var t = n.prototype;\n  return t.get = function(e) {\n    return this.values[this.keys.indexOf(e)];\n  }, t.set = function(e, o) {\n    var R = this.keys, N = this.values, M = R.indexOf(e), D = M === -1 ? R.length : M;\n    R[D] = e, N[D] = o;\n  }, n;\n}(), HashMap = /* @__PURE__ */ function() {\n  function n() {\n    this.object = {};\n  }\n  var t = n.prototype;\n  return t.get = function(e) {\n    return this.object[e];\n  }, t.set = function(e, o) {\n    this.object[e] = o;\n  }, n;\n}(), SUPPORT_MAP = typeof Map == \"function\", Link = /* @__PURE__ */ function() {\n  function n() {\n  }\n  var t = n.prototype;\n  return t.connect = function(e, o) {\n    this.prev = e, this.next = o, e && (e.next = this), o && (o.prev = this);\n  }, t.disconnect = function() {\n    var e = this.prev, o = this.next;\n    e && (e.next = o), o && (o.prev = e);\n  }, t.getIndex = function() {\n    for (var e = this, o = -1; e; )\n      e = e.prev, ++o;\n    return o;\n  }, n;\n}();\nfunction orderChanged(n, t) {\n  var e = [], o = [];\n  return n.forEach(function(R) {\n    var N = R[0], M = R[1], D = new Link();\n    e[N] = D, o[M] = D;\n  }), e.forEach(function(R, N) {\n    R.connect(e[N - 1]);\n  }), n.filter(function(R, N) {\n    return !t[N];\n  }).map(function(R, N) {\n    var M = R[0], D = R[1];\n    if (M === D)\n      return [0, 0];\n    var L = e[M], B = o[D - 1], $ = L.getIndex();\n    L.disconnect(), B ? L.connect(B, B.next) : L.connect(void 0, e[0]);\n    var k = L.getIndex();\n    return [$, k];\n  });\n}\nvar Result = /* @__PURE__ */ function() {\n  function n(e, o, R, N, M, D, L, B) {\n    this.prevList = e, this.list = o, this.added = R, this.removed = N, this.changed = M, this.maintained = D, this.changedBeforeAdded = L, this.fixed = B;\n  }\n  var t = n.prototype;\n  return Object.defineProperty(t, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(t, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), t.caculateOrdered = function() {\n    var e = orderChanged(this.changedBeforeAdded, this.fixed), o = this.changed, R = [];\n    this.cacheOrdered = e.filter(function(N, M) {\n      var D = N[0], L = N[1], B = o[M], $ = B[0], k = B[1];\n      if (D !== L)\n        return R.push([$, k]), !0;\n    }), this.cachePureChanged = R;\n  }, n;\n}();\nfunction diff$1(n, t, e) {\n  var o = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, R = e || function(q) {\n    return q;\n  }, N = [], M = [], D = [], L = n.map(R), B = t.map(R), $ = new o(), k = new o(), U = [], z = [], X = {}, V = [], W = 0, Y = 0;\n  return L.forEach(function(q, Z) {\n    $.set(q, Z);\n  }), B.forEach(function(q, Z) {\n    k.set(q, Z);\n  }), L.forEach(function(q, Z) {\n    var K = k.get(q);\n    typeof K > \"u\" ? (++Y, M.push(Z)) : X[K] = Y;\n  }), B.forEach(function(q, Z) {\n    var K = $.get(q);\n    typeof K > \"u\" ? (N.push(Z), ++W) : (D.push([K, Z]), Y = X[Z] || 0, U.push([K - Y, Z - W]), z.push(Z === K), K !== Z && V.push([K, Z]));\n  }), M.reverse(), new Result(n, t, N, M, V, D, U, z);\n}\nvar ListDiffer = /* @__PURE__ */ function() {\n  function n(e, o) {\n    e === void 0 && (e = []), this.findKeyCallback = o, this.list = [].slice.call(e);\n  }\n  var t = n.prototype;\n  return t.update = function(e) {\n    var o = [].slice.call(e), R = diff$1(this.list, o, this.findKeyCallback);\n    return this.list = o, R;\n  }, n;\n}(), FUNCTION$1 = \"function\", OBJECT = \"object\", STRING = \"string\", NUMBER = \"number\", UNDEFINED = \"undefined\", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {\n  cm: function(n) {\n    return n * 96 / 2.54;\n  },\n  mm: function(n) {\n    return n * 96 / 254;\n  },\n  in: function(n) {\n    return n * 96;\n  },\n  pt: function(n) {\n    return n * 96 / 72;\n  },\n  pc: function(n) {\n    return n * 96 / 6;\n  },\n  \"%\": function(n, t) {\n    return n * t / 100;\n  },\n  vw: function(n, t) {\n    return t === void 0 && (t = window.innerWidth), n / 100 * t;\n  },\n  vh: function(n, t) {\n    return t === void 0 && (t = window.innerHeight), n / 100 * t;\n  },\n  vmax: function(n, t) {\n    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), n / 100 * t;\n  },\n  vmin: function(n, t) {\n    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), n / 100 * t;\n  }\n};\nfunction dot(n, t, e, o) {\n  return (n * o + t * e) / (e + o);\n}\nfunction isUndefined(n) {\n  return typeof n === UNDEFINED;\n}\nfunction isObject$2(n) {\n  return n && typeof n === OBJECT;\n}\nfunction isArray(n) {\n  return Array.isArray(n);\n}\nfunction isString(n) {\n  return typeof n === STRING;\n}\nfunction isNumber(n) {\n  return typeof n === NUMBER;\n}\nfunction isFunction$3(n) {\n  return typeof n === FUNCTION$1;\n}\nfunction isEqualSeparator(n, t) {\n  var e = n === \"\" || n == \" \", o = t === \"\" || t == \" \";\n  return o && e || n === t;\n}\nfunction findOpen(n, t, e, o, R) {\n  var N = findIgnore(n, t, e);\n  return N ? e : findClose(n, t, e + 1, o, R);\n}\nfunction findIgnore(n, t, e) {\n  if (!n.ignore)\n    return null;\n  var o = t.slice(Math.max(e - 3, 0), e + 3).join(\"\");\n  return new RegExp(n.ignore).exec(o);\n}\nfunction findClose(n, t, e, o, R) {\n  for (var N = function(B) {\n    var $ = t[B].trim();\n    if ($ === n.close && !findIgnore(n, t, B))\n      return {\n        value: B\n      };\n    var k = B, U = find$1(R, function(z) {\n      var X = z.open;\n      return X === $;\n    });\n    if (U && (k = findOpen(U, t, B, o, R)), k === -1)\n      return M = B, \"break\";\n    B = k, M = B;\n  }, M, D = e; D < o; ++D) {\n    var L = N(D);\n    if (D = M, typeof L == \"object\")\n      return L.value;\n    if (L === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction splitText(n, t) {\n  var e = isString(t) ? {\n    separator: t\n  } : t, o = e.separator, R = o === void 0 ? \",\" : o, N = e.isSeparateFirst, M = e.isSeparateOnlyOpenClose, D = e.isSeparateOpenClose, L = D === void 0 ? M : D, B = e.openCloseCharacters, $ = B === void 0 ? OPEN_CLOSED_CHARACTERS : B, k = $.map(function(rt) {\n    var tt = rt.open, nt = rt.close;\n    return tt === nt ? tt : tt + \"|\" + nt;\n  }).join(\"|\"), U = \"(\\\\s*\" + R + \"\\\\s*|\" + k + \"|\\\\s+)\", z = new RegExp(U, \"g\"), X = n.split(z).filter(Boolean), V = X.length, W = [], Y = [];\n  function q() {\n    return Y.length ? (W.push(Y.join(\"\")), Y = [], !0) : !1;\n  }\n  for (var Z = function(rt) {\n    var tt = X[rt].trim(), nt = rt, st = find$1($, function(ct) {\n      var dt = ct.open;\n      return dt === tt;\n    }), ut = find$1($, function(ct) {\n      var dt = ct.close;\n      return dt === tt;\n    });\n    if (st) {\n      if (nt = findOpen(st, X, rt, V, $), nt !== -1 && L)\n        return q() && N || (W.push(X.slice(rt, nt + 1).join(\"\")), rt = nt, N) ? (K = rt, \"break\") : (K = rt, \"continue\");\n    } else {\n      if (ut && !findIgnore(ut, X, rt))\n        throw new Error(\"invalid format: \" + ut.close);\n      if (isEqualSeparator(tt, R) && !M)\n        return q(), N ? (K = rt, \"break\") : (K = rt, \"continue\");\n    }\n    nt === -1 && (nt = V - 1), Y.push(X.slice(rt, nt + 1).join(\"\")), rt = nt, K = rt;\n  }, K, Q = 0; Q < V; ++Q) {\n    var J = Z(Q);\n    if (Q = K, J === \"break\")\n      break;\n  }\n  return Y.length && W.push(Y.join(\"\")), W;\n}\nfunction splitSpace(n) {\n  return splitText(n, \"\");\n}\nfunction splitComma(n) {\n  return splitText(n, \",\");\n}\nfunction splitBracket(n) {\n  var t = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(n);\n  return !t || t.length < 4 ? {} : {\n    prefix: t[1],\n    value: t[2],\n    suffix: t[3]\n  };\n}\nfunction splitUnit(n) {\n  var t = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(n);\n  if (!t)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var e = t[1], o = t[2], R = t[3];\n  return {\n    prefix: e,\n    unit: R,\n    value: parseFloat(o)\n  };\n}\nfunction camelize(n) {\n  return n.replace(/[\\s-_]([a-z])/g, function(t, e) {\n    return e.toUpperCase();\n  });\n}\nfunction decamelize(n, t) {\n  return t === void 0 && (t = \"-\"), n.replace(/([a-z])([A-Z])/g, function(e, o, R) {\n    return \"\" + o + t + R.toLowerCase();\n  });\n}\nfunction now$1() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\nfunction findIndex(n, t, e) {\n  e === void 0 && (e = -1);\n  for (var o = n.length, R = 0; R < o; ++R)\n    if (t(n[R], R, n))\n      return R;\n  return e;\n}\nfunction find$1(n, t, e) {\n  var o = findIndex(n, t);\n  return o > -1 ? n[o] : e;\n}\nvar requestAnimationFrame$1 = /* @__PURE__ */ function() {\n  var n = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    var o = now$1(), R = window.setTimeout(function() {\n      e(o - n);\n    }, 1e3 / 60);\n    return R;\n  };\n}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {\n  var n = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return n ? n.bind(window) : function(t) {\n    clearTimeout(t);\n  };\n}();\nfunction getKeys(n) {\n  if (Object.keys)\n    return Object.keys(n);\n  var t = [];\n  for (var e in t)\n    t.push(e);\n  return t;\n}\nfunction convertUnitSize(n, t) {\n  var e = splitUnit(n), o = e.value, R = e.unit;\n  if (isObject$2(t)) {\n    var N = t[R];\n    if (N) {\n      if (isFunction$3(N))\n        return N(o);\n      if (DEFAULT_UNIT_PRESETS[R])\n        return DEFAULT_UNIT_PRESETS[R](o, N);\n    }\n  } else if (R === \"%\")\n    return o * t / 100;\n  return DEFAULT_UNIT_PRESETS[R] ? DEFAULT_UNIT_PRESETS[R](o) : o;\n}\nfunction between(n, t, e) {\n  return Math.max(t, Math.min(n, e));\n}\nfunction checkBoundSize(n, t, e, o) {\n  return o === void 0 && (o = n[0] / n[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / o, TINY_NUM$1)], [throttle(t[1] * o, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(R) {\n    return R.every(function(N, M) {\n      var D = t[M], L = throttle(D, TINY_NUM$1);\n      return e ? N <= D || N <= L : N >= D || N >= L;\n    });\n  })[0] || n;\n}\nfunction calculateBoundSize(n, t, e, o) {\n  if (!o)\n    return n.map(function(z, X) {\n      return between(z, t[X], e[X]);\n    });\n  var R = n[0], N = n[1], M = o === !0 ? R / N : o, D = checkBoundSize(n, t, !1, M), L = D[0], B = D[1], $ = checkBoundSize(n, e, !0, M), k = $[0], U = $[1];\n  return R < L || N < B ? (R = L, N = B) : (R > k || N > U) && (R = k, N = U), [R, N];\n}\nfunction sum(n) {\n  for (var t = n.length, e = 0, o = t - 1; o >= 0; --o)\n    e += n[o];\n  return e;\n}\nfunction average(n) {\n  for (var t = n.length, e = 0, o = t - 1; o >= 0; --o)\n    e += n[o];\n  return t ? e / t : 0;\n}\nfunction getRad$1(n, t) {\n  var e = t[0] - n[0], o = t[1] - n[1], R = Math.atan2(o, e);\n  return R >= 0 ? R : R + Math.PI * 2;\n}\nfunction getCenterPoint(n) {\n  return [0, 1].map(function(t) {\n    return average(n.map(function(e) {\n      return e[t];\n    }));\n  });\n}\nfunction getShapeDirection(n) {\n  var t = getCenterPoint(n), e = getRad$1(t, n[0]), o = getRad$1(t, n[1]);\n  return e < o && o - e < Math.PI || e > o && o - e < -Math.PI ? 1 : -1;\n}\nfunction getDist$2(n, t) {\n  return Math.sqrt(Math.pow((t ? t[0] : 0) - n[0], 2) + Math.pow((t ? t[1] : 0) - n[1], 2));\n}\nfunction throttle(n, t) {\n  if (!t)\n    return n;\n  var e = 1 / t;\n  return Math.round(n / t) / e;\n}\nfunction throttleArray(n, t) {\n  return n.forEach(function(e, o) {\n    n[o] = throttle(n[o], t);\n  }), n;\n}\nfunction hasClass(n, t) {\n  return n.classList ? n.classList.contains(t) : !!n.className.match(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\"));\n}\nfunction addClass(n, t) {\n  n.classList ? n.classList.add(t) : n.className += \" \" + t;\n}\nfunction removeClass(n, t) {\n  if (n.classList)\n    n.classList.remove(t);\n  else {\n    var e = new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\");\n    n.className = n.className.replace(e, \" \");\n  }\n}\nfunction addEvent(n, t, e, o) {\n  n.addEventListener(t, e, o);\n}\nfunction removeEvent(n, t, e, o) {\n  n.removeEventListener(t, e, o);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$6 = function(n, t) {\n  return extendStatics$6 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$6(n, t);\n};\nfunction __extends$6(n, t) {\n  extendStatics$6(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$7 = function() {\n  return __assign$7 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$7.apply(this, arguments);\n};\nfunction __rest$2(n, t) {\n  var e = {};\n  for (var o in n)\n    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);\n  if (n != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)\n      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);\n  return e;\n}\nfunction __spreadArrays$4() {\n  for (var n = 0, t = 0, e = arguments.length; t < e; t++)\n    n += arguments[t].length;\n  for (var o = Array(n), R = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)\n      o[R] = N[M];\n  return o;\n}\nfunction isDiff(n, t) {\n  if (n === t)\n    return !1;\n  for (var e in n)\n    if (!(e in t))\n      return !0;\n  for (var e in t)\n    if (n[e] !== t[e])\n      return !0;\n  return !1;\n}\nfunction diffObject(n, t) {\n  var e = Object.keys(n), o = Object.keys(t), R = diff$1(e, o, function(L) {\n    return L;\n  }), N = {}, M = {}, D = {};\n  return R.added.forEach(function(L) {\n    var B = o[L];\n    N[B] = t[B];\n  }), R.removed.forEach(function(L) {\n    var B = e[L];\n    M[B] = n[B];\n  }), R.maintained.forEach(function(L) {\n    var B = L[0], $ = e[B], k = [n[$], t[$]];\n    n[$] !== t[$] && (D[$] = k);\n  }), {\n    added: N,\n    removed: M,\n    changed: D\n  };\n}\nfunction executeHooks(n) {\n  n.forEach(function(t) {\n    t();\n  });\n}\nfunction fillKeys(n) {\n  var t = 0;\n  return n.map(function(e) {\n    return e == null ? \"$compat\" + ++t : \"\" + e;\n  });\n}\nfunction createProvider(n, t, e, o) {\n  if (isString(n) || isNumber(n))\n    return new TextProvider(\"text_\" + n, t, e, o, null, {});\n  var R = typeof n.type == \"string\" ? ElementProvider : n.type.prototype.render ? ComponentProvider : FunctionProvider;\n  return new R(n.type, t, e, o, n.ref, n.props);\n}\nfunction flat$1(n) {\n  var t = [];\n  return n.forEach(function(e) {\n    t = t.concat(isArray(e) ? flat$1(e) : e);\n  }), t;\n}\nfunction getAttributes(n) {\n  var t = n.className, e = __rest$2(n, [\"className\"]);\n  return t != null && (e.class = t), delete e.style, delete e.children, e;\n}\nfunction fillProps(n, t) {\n  if (!t)\n    return n;\n  for (var e in t)\n    isUndefined(n[e]) && (n[e] = t[e]);\n  return n;\n}\nfunction createElement(n, t) {\n  for (var e = [], o = 2; o < arguments.length; o++)\n    e[o - 2] = arguments[o];\n  var R = t || {}, N = R.key, M = R.ref, D = __rest$2(R, [\"key\", \"ref\"]);\n  return {\n    type: n,\n    key: N,\n    ref: M,\n    props: __assign$7(__assign$7({}, D), {\n      children: flat$1(e).filter(function(L) {\n        return L != null && L !== !1;\n      })\n    })\n  };\n}\nvar Provider = /* @__PURE__ */ function() {\n  function n(e, o, R, N, M, D) {\n    D === void 0 && (D = {}), this.type = e, this.key = o, this.index = R, this.container = N, this.ref = M, this.props = D, this._providers = [];\n  }\n  var t = n.prototype;\n  return t._should = function(e, o) {\n    return !0;\n  }, t._update = function(e, o, R, N) {\n    if (this.base && !isString(o) && !N && !this._should(o.props, R))\n      return !1;\n    this.original = o, this._setState(R);\n    var M = this.props;\n    return isString(o) || (this.props = o.props, this.ref = o.ref), this._render(e, this.base ? M : {}, R), !0;\n  }, t._mounted = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._setState = function(e) {\n  }, t._updated = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._destroy = function() {\n    var e = this.ref;\n    e && e(null);\n  }, n;\n}();\nfunction diffAttributes(n, t, e) {\n  var o = diffObject(n, t), R = o.added, N = o.removed, M = o.changed;\n  for (var D in R)\n    e.setAttribute(D, R[D]);\n  for (var D in M)\n    e.setAttribute(D, M[D][1]);\n  for (var D in N)\n    e.removeAttribute(D);\n}\nfunction diffEvents(n, t, e) {\n  var o = diffObject(n, t), R = o.added, N = o.removed, M = o.changed;\n  for (var D in N)\n    e.removeEventListener(D);\n  for (var D in R)\n    e.addEventListener(D, R[D]);\n  for (var D in M)\n    e.removeEventListener(D), e.addEventListener(D, M[D][1]);\n  for (var D in N)\n    e.removeEventListener(D);\n}\nfunction diffStyle(n, t, e) {\n  var o = e.style, R = diffObject(n, t), N = R.added, M = R.removed, D = R.changed;\n  for (var L in N) {\n    var B = decamelize(L, \"-\");\n    o.setProperty ? o.setProperty(B, N[L]) : o[B] = N[L];\n  }\n  for (var L in D) {\n    var B = decamelize(L, \"-\");\n    o.setProperty ? o.setProperty(B, D[L][1]) : o[B] = D[L][1];\n  }\n  for (var L in M) {\n    var B = decamelize(L, \"-\");\n    o.removeProperty ? o.removeProperty(B) : o[B] = \"\";\n  }\n}\nfunction splitProps(n) {\n  var t = {}, e = {};\n  for (var o in n)\n    o.indexOf(\"on\") === 0 ? e[o.replace(\"on\", \"\").toLowerCase()] = n[o] : t[o] = n[o];\n  return {\n    attributes: t,\n    events: e\n  };\n}\nvar TextProvider = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(o) {\n    var R = this, N = !this.base;\n    return N && (this.base = document.createTextNode(this.type.replace(\"text_\", \"\"))), o.push(function() {\n      N ? R._mounted() : R._updated();\n    }), !0;\n  }, e._unmount = function() {\n    this.base.parentNode.removeChild(this.base);\n  }, t;\n}(Provider), ElementProvider = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.events = {}, o._isSVG = !1, o;\n  }\n  var e = t.prototype;\n  return e.addEventListener = function(o, R) {\n    var N = this.events;\n    N[o] = function(M) {\n      M.nativeEvent = M, R(M);\n    }, this.base.addEventListener(o, N[o]);\n  }, e.removeEventListener = function(o) {\n    var R = this.events;\n    this.base.removeEventListener(o, R[o]), delete R[o];\n  }, e._should = function(o) {\n    return isDiff(this.props, o);\n  }, e._render = function(o, R) {\n    var N = this, M = !this.base;\n    if (M) {\n      var D = this._hasSVG();\n      this._isSVG = D;\n      var L = this.props.portalContainer;\n      if (!L) {\n        var B = this.type;\n        D ? L = document.createElementNS(\"http://www.w3.org/2000/svg\", B) : L = document.createElement(B);\n      }\n      this.base = L;\n    }\n    renderProviders(this, this._providers, this.props.children, o, null);\n    var $ = this.base, k = splitProps(R), U = k.attributes, z = k.events, X = splitProps(this.props), V = X.attributes, W = X.events;\n    return diffAttributes(getAttributes(U), getAttributes(V), $), diffEvents(z, W, this), diffStyle(R.style || {}, this.props.style || {}, $), o.push(function() {\n      M ? N._mounted() : N._updated();\n    }), !0;\n  }, e._unmount = function() {\n    var o = this.events, R = this.base;\n    for (var N in o)\n      R.removeEventListener(N, o[N]);\n    this._providers.forEach(function(M) {\n      M._unmount();\n    }), this.events = {}, this.props.portalContainer || R.parentNode.removeChild(R);\n  }, e._hasSVG = function() {\n    if (this._isSVG || this.type === \"svg\")\n      return !0;\n    var o = findContainerNode(this.container);\n    return o && \"ownerSVGElement\" in o;\n  }, t;\n}(Provider);\nfunction findContainerNode(n) {\n  if (!n)\n    return null;\n  var t = n.base;\n  return t instanceof Node ? t : findContainerNode(n.container);\n}\nfunction findDOMNode(n) {\n  if (!n)\n    return null;\n  if (n instanceof Node)\n    return n;\n  var t = n.$_provider._providers;\n  return t.length ? findDOMNode(t[0].base) : null;\n}\nvar FunctionProvider = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(o) {\n    var R = this.type(this.props);\n    return renderProviders(this, this._providers, R ? [R] : [], o), !0;\n  }, e._unmount = function() {\n    this._providers.forEach(function(o) {\n      o._unmount();\n    });\n  }, t;\n}(Provider), ContainerProvider = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t(o) {\n    var R = n.call(this, \"container\", \"container\", 0, null) || this;\n    return R.base = o, R;\n  }\n  var e = t.prototype;\n  return e._render = function() {\n    return !0;\n  }, e._unmount = function() {\n  }, t;\n}(Provider), ComponentProvider = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t(o, R, N, M, D, L) {\n    return L === void 0 && (L = {}), n.call(this, o, R, N, M, D, fillProps(L, o.defaultProps)) || this;\n  }\n  var e = t.prototype;\n  return e._should = function(o, R) {\n    return this.base.shouldComponentUpdate(fillProps(o, this.type.defaultProps), R || this.base.state);\n  }, e._render = function(o, R) {\n    var N = this;\n    this.props = fillProps(this.props, this.type.defaultProps);\n    var M = !this.base;\n    M ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;\n    var D = this.base, L = D.state, B = D.render();\n    B && B.props && !B.props.children.length && (B.props.children = this.props.children), renderProviders(this, this._providers, B ? [B] : [], o), o.push(function() {\n      M ? (N._mounted(), D.componentDidMount()) : (N._updated(), D.componentDidUpdate(R, L));\n    });\n  }, e._setState = function(o) {\n    var R = this.base;\n    !R || !o || (R.state = o);\n  }, e._unmount = function() {\n    this._providers.forEach(function(o) {\n      o._unmount();\n    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();\n  }, t;\n}(Provider), Component = /* @__PURE__ */ function() {\n  function n(e) {\n    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};\n  }\n  var t = n.prototype;\n  return t.shouldComponentUpdate = function(e, o) {\n    return !0;\n  }, t.render = function() {\n    return null;\n  }, t.setState = function(e, o, R) {\n    var N = this;\n    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$7(__assign$7({}, this.$_state), e), R ? this.$_setState(o, R) : this.$_timer = setTimeout(function() {\n      N.$_timer = 0, N.$_setState(o, R);\n    });\n  }, t.forceUpdate = function(e) {\n    this.setState({}, e, !0);\n  }, t.componentDidMount = function() {\n  }, t.componentDidUpdate = function(e, o) {\n  }, t.componentWillUnmount = function() {\n  }, t.$_setState = function(e, o) {\n    var R = [], N = this.$_provider, M = renderProviders(N.container, [N], [N.original], R, __assign$7(__assign$7({}, this.state), this.$_state), o);\n    M && (e && R.push(e), executeHooks(R));\n  }, n;\n}(), PureComponent = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.shouldComponentUpdate = function(o, R) {\n    return isDiff(this.props, o) || isDiff(this.state, R);\n  }, t;\n}(Component), _Portal = /* @__PURE__ */ function(n) {\n  __extends$6(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    var o = this.props, R = o.element, N = o.container;\n    this._portalProvider = new ContainerProvider(N), renderProvider(R, N, this._portalProvider);\n  }, e.componentDidUpdate = function() {\n    var o = this.props, R = o.element, N = o.container;\n    renderProvider(R, N, this._portalProvider);\n  }, e.componentWillUnmount = function() {\n    var o = this.props.container;\n    renderProvider(null, o, this._portalProvider), this._portalProvider = null;\n  }, t;\n}(PureComponent);\nfunction updateProvider(n, t, e) {\n  var o = [];\n  renderProviders(n, n._providers, t, o, e), executeHooks(o);\n}\nfunction getNextSibiling(n, t) {\n  for (var e = n._providers, o = e.length, R = t.index + 1; R < o; ++R) {\n    var N = findDOMNode(e[R].base);\n    if (N)\n      return N;\n  }\n  return null;\n}\nfunction diffProviders(n, t, e) {\n  var o = e.map(function(L) {\n    return isString(L) ? null : L.key;\n  }), R = fillKeys(t.map(function(L) {\n    return L.key;\n  })), N = fillKeys(o), M = diff$1(R, N, function(L) {\n    return L;\n  });\n  M.removed.forEach(function(L) {\n    t.splice(L, 1)[0]._unmount();\n  }), M.ordered.forEach(function(L) {\n    var B = L[0], $ = L[1], k = t.splice(B, 1)[0];\n    t.splice($, 0, k);\n    var U = findDOMNode(k.base), z = findDOMNode(t[$ + 1] && t[$ + 1].base);\n    U && U.parentNode.insertBefore(U, z);\n  }), M.added.forEach(function(L) {\n    t.splice(L, 0, createProvider(e[L], o[L], L, n));\n  });\n  var D = M.maintained.filter(function(L) {\n    L[0];\n    var B = L[1], $ = e[B], k = t[B], U = isString($) ? \"text_\" + $ : $.type;\n    return U !== k.type ? (k._unmount(), t.splice(B, 1, createProvider($, o[B], B, n)), !0) : (k.index = B, !1);\n  });\n  return __spreadArrays$4(M.added, D.map(function(L) {\n    L[0];\n    var B = L[1];\n    return B;\n  }));\n}\nfunction renderProviders(n, t, e, o, R, N) {\n  var M = diffProviders(n, t, e), D = t.filter(function(B, $) {\n    return B._update(o, e[$], R, N);\n  }), L = findContainerNode(n);\n  return L && M.reverse().forEach(function(B) {\n    var $ = t[B], k = findDOMNode($.base);\n    if (!!k && L !== k && !k.parentNode) {\n      var U = getNextSibiling(n, $);\n      L.insertBefore(k, U);\n    }\n  }), D.length > 0;\n}\nfunction renderProvider(n, t, e) {\n  e === void 0 && (e = t.__REACT_COMPAT__);\n  var o = !!e;\n  return e || (e = new ContainerProvider(t)), updateProvider(e, n ? [n] : []), o || (t.__REACT_COMPAT__ = e), e;\n}\nfunction render(n, t, e) {\n  var o = t.__REACT_COMPAT__;\n  n && !o && (t.innerHTML = \"\"), renderProvider(n, t, o), e && e();\n}\nfunction createPortal(n, t) {\n  return createElement(_Portal, {\n    element: n,\n    container: t\n  });\n}\nvar version = \"simple-1.1.0\";\nfunction some(n, t) {\n  for (var e = n.length, o = 0; o < e; ++o)\n    if (t(n[o], o))\n      return !0;\n  return !1;\n}\nfunction find(n, t) {\n  for (var e = n.length, o = 0; o < e; ++o)\n    if (t(n[o], o))\n      return n[o];\n  return null;\n}\nfunction getUserAgentString(n) {\n  var t = n;\n  if (typeof t > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    t = navigator.userAgent || \"\";\n  }\n  return t.toLowerCase();\n}\nfunction execRegExp(n, t) {\n  try {\n    return new RegExp(n, \"g\").exec(t);\n  } catch {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var n = navigator.userAgentData, t = n.brands || n.uaList;\n  return !!(t && t.length);\n}\nfunction findVersion(n, t) {\n  var e = execRegExp(\"(\" + n + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", t);\n  return e ? e[3] : \"\";\n}\nfunction convertVersion(n) {\n  return n.replace(/_/g, \".\");\n}\nfunction findPreset(n, t) {\n  var e = null, o = \"-1\";\n  return some(n, function(R) {\n    var N = execRegExp(\"(\" + R.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", t);\n    return !N || R.brand ? !1 : (e = R, o = N[3] || \"-1\", R.versionAlias ? o = R.versionAlias : R.versionTest && (o = findVersion(R.versionTest.toLowerCase(), t) || o), o = convertVersion(o), !0);\n  }), {\n    preset: e,\n    version: o\n  };\n}\nfunction findPresetBrand(n, t) {\n  var e = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return some(n, function(o) {\n    var R = findBrand(t, o);\n    return R ? (e.brand = o.id, e.version = o.versionAlias || R.version, e.version !== \"-1\") : !1;\n  }), e;\n}\nfunction findBrand(n, t) {\n  return find(n, function(e) {\n    var o = e.brand;\n    return execRegExp(\"\" + t.test, o.toLowerCase());\n  });\n}\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  test: \"webview\",\n  id: \"webview\"\n}], OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction isWebView(n) {\n  return !!findPreset(WEBVIEW_PRESETS, n).preset;\n}\nfunction getLegacyAgent(n) {\n  var t = getUserAgentString(n), e = !!/mobi/g.exec(t), o = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(t),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, R = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, N = findPreset(BROWSER_PRESETS, t), M = N.preset, D = N.version, L = findPreset(OS_PRESETS, t), B = L.preset, $ = L.version, k = findPreset(CHROMIUM_PRESETS, t);\n  if (o.chromium = !!k.preset, o.chromiumVersion = k.version, !o.chromium) {\n    var U = findPreset(WEBKIT_PRESETS, t);\n    o.webkit = !!U.preset, o.webkitVersion = U.version;\n  }\n  return B && (R.name = B.id, R.version = $, R.majorVersion = parseInt($, 10)), M && (o.name = M.id, o.version = D, o.webview && R.name === \"ios\" && o.name !== \"safari\" && (o.webview = !1)), o.majorVersion = parseInt(o.version, 10), {\n    browser: o,\n    os: R,\n    isMobile: e,\n    isHints: !1\n  };\n}\nfunction getClientHintsAgent(n) {\n  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), o = n && n.fullVersionList, R = t.mobile || !1, N = e[0], M = (n && n.platform || t.platform || navigator.platform).toLowerCase(), D = {\n    name: N.brand,\n    version: N.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())\n  }, L = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  D.webkit = !D.chromium && some(WEBKIT_PRESETS, function(X) {\n    return findBrand(e, X);\n  });\n  var B = findPresetBrand(CHROMIUM_PRESETS, e);\n  if (D.chromium = !!B.brand, D.chromiumVersion = B.version, !D.chromium) {\n    var $ = findPresetBrand(WEBKIT_PRESETS, e);\n    D.webkit = !!$.brand, D.webkitVersion = $.version;\n  }\n  var k = find(OS_PRESETS, function(X) {\n    return new RegExp(\"\" + X.test, \"g\").exec(M);\n  });\n  if (L.name = k ? k.id : \"\", n && (L.version = n.platformVersion), o && o.length) {\n    var U = findPresetBrand(BROWSER_PRESETS, o);\n    D.name = U.brand || D.name, D.version = U.version || D.version;\n  } else {\n    var z = findPresetBrand(BROWSER_PRESETS, e);\n    D.name = z.brand || D.name, D.version = z.brand && n ? n.uaFullVersion : z.version;\n  }\n  return D.webkit && (L.name = R ? \"ios\" : \"mac\"), L.name === \"ios\" && D.webview && (D.version = \"-1\"), L.version = convertVersion(L.version), D.version = convertVersion(D.version), L.majorVersion = parseInt(L.version, 10), D.majorVersion = parseInt(D.version, 10), {\n    browser: D,\n    os: L,\n    isMobile: R,\n    isHints: !0\n  };\n}\nfunction agent$1(n) {\n  return typeof n > \"u\" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(n);\n}\nfunction add(n, t, e, o, R, N) {\n  for (var M = 0; M < R; ++M) {\n    var D = e + M * R, L = o + M * R;\n    n[D] += n[L] * N, t[D] += t[L] * N;\n  }\n}\nfunction swap(n, t, e, o, R) {\n  for (var N = 0; N < R; ++N) {\n    var M = e + N * R, D = o + N * R, L = n[M], B = t[M];\n    n[M] = n[D], n[D] = L, t[M] = t[D], t[D] = B;\n  }\n}\nfunction divide(n, t, e, o, R) {\n  for (var N = 0; N < o; ++N) {\n    var M = e + N * o;\n    n[M] /= R, t[M] /= R;\n  }\n}\nfunction ignoreDimension(n, t, e) {\n  e === void 0 && (e = Math.sqrt(n.length));\n  for (var o = n.slice(), R = 0; R < e; ++R)\n    o[R * e + t - 1] = 0, o[(t - 1) * e + R] = 0;\n  return o[(t - 1) * (e + 1)] = 1, o;\n}\nfunction invert(n, t) {\n  t === void 0 && (t = Math.sqrt(n.length));\n  for (var e = n.slice(), o = createIdentityMatrix(t), R = 0; R < t; ++R) {\n    var N = t * R + R;\n    if (!throttle(e[N], TINY_NUM$1)) {\n      for (var M = R + 1; M < t; ++M)\n        if (e[t * R + M]) {\n          swap(e, o, R, M, t);\n          break;\n        }\n    }\n    if (!throttle(e[N], TINY_NUM$1))\n      return [];\n    divide(e, o, R, t, e[N]);\n    for (var M = 0; M < t; ++M) {\n      var D = M, L = M + R * t, B = e[L];\n      !throttle(B, TINY_NUM$1) || R === M || add(e, o, D, R, t, -B);\n    }\n  }\n  return o;\n}\nfunction transpose(n, t) {\n  t === void 0 && (t = Math.sqrt(n.length));\n  for (var e = [], o = 0; o < t; ++o)\n    for (var R = 0; R < t; ++R)\n      e[R * t + o] = n[t * o + R];\n  return e;\n}\nfunction getOrigin(n, t) {\n  t === void 0 && (t = Math.sqrt(n.length));\n  for (var e = [], o = n[t * t - 1], R = 0; R < t - 1; ++R)\n    e[R] = n[t * (t - 1) + R] / o;\n  return e[t - 1] = 0, e;\n}\nfunction fromTranslation(n, t) {\n  for (var e = createIdentityMatrix(t), o = 0; o < t - 1; ++o)\n    e[t * (t - 1) + o] = n[o] || 0;\n  return e;\n}\nfunction convertPositionMatrix(n, t) {\n  for (var e = n.slice(), o = n.length; o < t - 1; ++o)\n    e[o] = 0;\n  return e[t - 1] = 1, e;\n}\nfunction convertDimension(n, t, e) {\n  if (t === void 0 && (t = Math.sqrt(n.length)), t === e)\n    return n;\n  for (var o = createIdentityMatrix(e), R = Math.min(t, e), N = 0; N < R - 1; ++N) {\n    for (var M = 0; M < R - 1; ++M)\n      o[N * e + M] = n[N * t + M];\n    o[(N + 1) * e - 1] = n[(N + 1) * t - 1], o[(e - 1) * e + N] = n[(t - 1) * t + N];\n  }\n  return o[e * e - 1] = n[t * t - 1], o;\n}\nfunction multiplies(n) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  var o = createIdentityMatrix(n);\n  return t.forEach(function(R) {\n    o = multiply(o, R, n);\n  }), o;\n}\nfunction multiply(n, t, e) {\n  e === void 0 && (e = Math.sqrt(n.length));\n  var o = [], R = n.length / e, N = t.length / R;\n  if (R) {\n    if (!N)\n      return n;\n  } else\n    return t;\n  for (var M = 0; M < e; ++M)\n    for (var D = 0; D < N; ++D) {\n      o[D * e + M] = 0;\n      for (var L = 0; L < R; ++L)\n        o[D * e + M] += n[L * e + M] * t[D * R + L];\n    }\n  return o;\n}\nfunction plus(n, t) {\n  for (var e = Math.min(n.length, t.length), o = n.slice(), R = 0; R < e; ++R)\n    o[R] = o[R] + t[R];\n  return o;\n}\nfunction minus(n, t) {\n  for (var e = Math.min(n.length, t.length), o = n.slice(), R = 0; R < e; ++R)\n    o[R] = o[R] - t[R];\n  return o;\n}\nfunction convertCSStoMatrix(n, t) {\n  return t === void 0 && (t = n.length === 6), t ? [n[0], n[1], 0, n[2], n[3], 0, n[4], n[5], 1] : n;\n}\nfunction convertMatrixtoCSS(n, t) {\n  return t === void 0 && (t = n.length === 9), t ? [n[0], n[1], n[3], n[4], n[6], n[7]] : n;\n}\nfunction calculate(n, t, e) {\n  e === void 0 && (e = t.length);\n  var o = multiply(n, t, e), R = o[e - 1];\n  return o.map(function(N) {\n    return N / R;\n  });\n}\nfunction rotateX3d(n, t) {\n  return multiply(n, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateY3d(n, t) {\n  return multiply(n, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateZ3d(n, t) {\n  return multiply(n, createRotateMatrix(t, 4));\n}\nfunction scale3d(n, t) {\n  var e = t[0], o = e === void 0 ? 1 : e, R = t[1], N = R === void 0 ? 1 : R, M = t[2], D = M === void 0 ? 1 : M;\n  return multiply(n, [o, 0, 0, 0, 0, N, 0, 0, 0, 0, D, 0, 0, 0, 0, 1], 4);\n}\nfunction rotate(n, t) {\n  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(n, 3));\n}\nfunction translate3d(n, t) {\n  var e = t[0], o = e === void 0 ? 0 : e, R = t[1], N = R === void 0 ? 0 : R, M = t[2], D = M === void 0 ? 0 : M;\n  return multiply(n, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, o, N, D, 1], 4);\n}\nfunction matrix3d(n, t) {\n  return multiply(n, t, 4);\n}\nfunction createRotateMatrix(n, t) {\n  var e = Math.cos(n), o = Math.sin(n), R = createIdentityMatrix(t);\n  return R[0] = e, R[1] = o, R[t] = -o, R[t + 1] = e, R;\n}\nfunction createIdentityMatrix(n) {\n  for (var t = n * n, e = [], o = 0; o < t; ++o)\n    e[o] = o % (n + 1) ? 0 : 1;\n  return e;\n}\nfunction createScaleMatrix(n, t) {\n  for (var e = createIdentityMatrix(t), o = Math.min(n.length, t - 1), R = 0; R < o; ++R)\n    e[(t + 1) * R] = n[R];\n  return e;\n}\nfunction createOriginMatrix(n, t) {\n  for (var e = createIdentityMatrix(t), o = Math.min(n.length, t - 1), R = 0; R < o; ++R)\n    e[t * (t - 1) + R] = n[R];\n  return e;\n}\nfunction createWarpMatrix(n, t, e, o, R, N, M, D) {\n  var L = n[0], B = n[1], $ = t[0], k = t[1], U = e[0], z = e[1], X = o[0], V = o[1], W = R[0], Y = R[1], q = N[0], Z = N[1], K = M[0], Q = M[1], J = D[0], rt = D[1], tt = [L, 0, $, 0, U, 0, X, 0, B, 0, k, 0, z, 0, V, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, L, 0, $, 0, U, 0, X, 0, B, 0, k, 0, z, 0, V, 0, 1, 0, 1, 0, 1, 0, 1, -W * L, -Y * L, -q * $, -Z * $, -K * U, -Q * U, -J * X, -rt * X, -W * B, -Y * B, -q * k, -Z * k, -K * z, -Q * z, -J * V, -rt * V], nt = invert(tt, 8);\n  if (!nt.length)\n    return [];\n  var st = multiply(nt, [W, Y, q, Z, K, Q, J, rt], 8);\n  return st[8] = 1, convertDimension(transpose(st), 3, 4);\n}\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction parseMat(n) {\n  return toMat(parse(n));\n}\nfunction calculateMatrixDist(n, t) {\n  var e = calculate(n, [t[0], t[1] || 0, t[2] || 0, 1], 4), o = e[3] || 1;\n  return [e[0] / o, e[1] / o, e[2] / o];\n}\nfunction toMat(n) {\n  var t = createMatrix();\n  return n.forEach(function(e) {\n    var o = e.matrixFunction, R = e.functionValue;\n    !o || (t = o(t, R));\n  }), t;\n}\nfunction parse(n) {\n  var t = isArray(n) ? n : splitSpace(n);\n  return t.map(function(e) {\n    var o = splitBracket(e), R = o.prefix, N = o.value, M = null, D = R, L = \"\";\n    if (R === \"translate\" || R === \"translateX\" || R === \"translate3d\") {\n      var B = splitComma(N).map(function(st) {\n        return parseFloat(st);\n      }), $ = B[0], k = B[1], U = k === void 0 ? 0 : k, z = B[2], X = z === void 0 ? 0 : z;\n      M = translate3d, L = [$, U, X];\n    } else if (R === \"translateY\") {\n      var U = parseFloat(N);\n      M = translate3d, L = [0, U, 0];\n    } else if (R === \"translateZ\") {\n      var X = parseFloat(N);\n      M = translate3d, L = [0, 0, X];\n    } else if (R === \"scale\" || R === \"scale3d\") {\n      var V = splitComma(N).map(function(st) {\n        return parseFloat(st);\n      }), W = V[0], Y = V[1], q = Y === void 0 ? W : Y, Z = V[2], K = Z === void 0 ? 1 : Z;\n      M = scale3d, L = [W, q, K];\n    } else if (R === \"scaleX\") {\n      var W = parseFloat(N);\n      M = scale3d, L = [W, 1, 1];\n    } else if (R === \"scaleY\") {\n      var q = parseFloat(N);\n      M = scale3d, L = [1, q, 1];\n    } else if (R === \"scaleZ\") {\n      var K = parseFloat(N);\n      M = scale3d, L = [1, 1, K];\n    } else if (R === \"rotate\" || R === \"rotateZ\" || R === \"rotateX\" || R === \"rotateY\") {\n      var Q = splitUnit(N), J = Q.unit, rt = Q.value, tt = J === \"rad\" ? rt : rt * Math.PI / 180;\n      R === \"rotate\" || R === \"rotateZ\" ? (D = \"rotateZ\", M = rotateZ3d) : R === \"rotateX\" ? M = rotateX3d : R === \"rotateY\" && (M = rotateY3d), L = tt;\n    } else if (R === \"matrix3d\")\n      M = matrix3d, L = splitComma(N).map(function(st) {\n        return parseFloat(st);\n      });\n    else if (R === \"matrix\") {\n      var nt = splitComma(N).map(function(st) {\n        return parseFloat(st);\n      });\n      M = matrix3d, L = [nt[0], nt[1], 0, 0, nt[2], nt[3], 0, 0, 0, 0, 1, 0, nt[4], nt[5], 0, 1];\n    } else\n      D = \"\";\n    return {\n      name: R,\n      functionName: D,\n      value: N,\n      matrixFunction: M,\n      functionValue: L\n    };\n  });\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$5 = function(n, t) {\n  return extendStatics$5 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$5(n, t);\n};\nfunction __extends$5(n, t) {\n  extendStatics$5(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar findKeyCallback = typeof Map == \"function\" ? void 0 : function() {\n  var n = 0;\n  return function(t) {\n    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++n);\n  };\n}(), ChildrenDiffer = /* @__PURE__ */ function(n) {\n  __extends$5(t, n);\n  function t(e) {\n    return e === void 0 && (e = []), n.call(this, e, findKeyCallback) || this;\n  }\n  return t;\n}(ListDiffer);\nfunction diff(n, t) {\n  return diff$1(n, t, findKeyCallback);\n}\nconst ChildrenDiffer$1 = ChildrenDiffer;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$3() {\n  for (var n = 0, t = 0, e = arguments.length; t < e; t++)\n    n += arguments[t].length;\n  for (var o = Array(n), R = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)\n      o[R] = N[M];\n  return o;\n}\nfunction tinyThrottle(n) {\n  return throttle(n, TINY_NUM$1);\n}\nfunction isSameConstants(n, t) {\n  return n.every(function(e, o) {\n    return tinyThrottle(e - t[o]) === 0;\n  });\n}\nfunction isSamePoint(n, t) {\n  return !tinyThrottle(n[0] - t[0]) && !tinyThrottle(n[1] - t[1]);\n}\nfunction getAreaSize(n) {\n  return n.length < 3 ? 0 : Math.abs(sum(n.map(function(t, e) {\n    var o = n[e + 1] || n[0];\n    return t[0] * o[1] - o[0] * t[1];\n  }))) / 2;\n}\nfunction fitPoints(n, t) {\n  var e = t.width, o = t.height, R = t.left, N = t.top, M = getMinMaxs(n), D = M.minX, L = M.minY, B = M.maxX, $ = M.maxY, k = e / (B - D), U = o / ($ - L);\n  return n.map(function(z) {\n    return [R + (z[0] - D) * k, N + (z[1] - L) * U];\n  });\n}\nfunction getMinMaxs(n) {\n  var t = n.map(function(o) {\n    return o[0];\n  }), e = n.map(function(o) {\n    return o[1];\n  });\n  return {\n    minX: Math.min.apply(Math, t),\n    minY: Math.min.apply(Math, e),\n    maxX: Math.max.apply(Math, t),\n    maxY: Math.max.apply(Math, e)\n  };\n}\nfunction isInside(n, t, e) {\n  var o = n[0], R = n[1], N = getMinMaxs(t), M = N.minX, D = N.maxX, L = [[M, R], [D, R]], B = getLinearConstants(L[0], L[1]), $ = convertLines(t), k = [];\n  if ($.forEach(function(X) {\n    var V = getLinearConstants(X[0], X[1]), W = X[0];\n    if (isSameConstants(B, V))\n      k.push({\n        pos: n,\n        line: X,\n        type: \"line\"\n      });\n    else {\n      var Y = getPointsOnLines(getIntersectionPointsByConstants(B, V), [L, X]);\n      Y.forEach(function(q) {\n        X.some(function(Z) {\n          return isSamePoint(Z, q);\n        }) ? k.push({\n          pos: q,\n          line: X,\n          type: \"point\"\n        }) : tinyThrottle(W[1] - R) !== 0 && k.push({\n          pos: q,\n          line: X,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), !e && find$1(k, function(X) {\n    return X[0] === o;\n  }))\n    return !0;\n  var U = 0, z = {};\n  return k.forEach(function(X) {\n    var V = X.pos, W = X.type, Y = X.line;\n    if (!(V[0] > o))\n      if (W === \"intersection\")\n        ++U;\n      else {\n        if (W === \"line\")\n          return;\n        if (W === \"point\") {\n          var q = find$1(Y, function(Q) {\n            return Q[1] !== R;\n          }), Z = z[V[0]], K = q[1] > R ? 1 : -1;\n          Z ? Z !== K && ++U : z[V[0]] = K;\n        }\n      }\n  }), U % 2 === 1;\n}\nfunction getLinearConstants(n, t) {\n  var e = n[0], o = n[1], R = t[0], N = t[1], M = R - e, D = N - o;\n  Math.abs(M) < TINY_NUM$1 && (M = 0), Math.abs(D) < TINY_NUM$1 && (D = 0);\n  var L = 0, B = 0, $ = 0;\n  return M ? D ? (L = -D / M, B = 1, $ = -L * e - o) : (B = 1, $ = -o) : D && (L = -1, $ = e), [L, B, $];\n}\nfunction getIntersectionPointsByConstants(n, t) {\n  var e = n[0], o = n[1], R = n[2], N = t[0], M = t[1], D = t[2], L = e === 0 && N === 0, B = o === 0 && M === 0, $ = [];\n  if (L && B)\n    return [];\n  if (L) {\n    var k = -R / o, U = -D / M;\n    return k !== U ? [] : [[-1 / 0, k], [1 / 0, k]];\n  } else if (B) {\n    var z = -R / e, X = -D / N;\n    return z !== X ? [] : [[z, -1 / 0], [z, 1 / 0]];\n  } else if (e === 0) {\n    var V = -R / o, W = -(M * V + D) / N;\n    $ = [[W, V]];\n  } else if (N === 0) {\n    var V = -D / M, W = -(o * V + R) / e;\n    $ = [[W, V]];\n  } else if (o === 0) {\n    var W = -R / e, V = -(N * W + D) / M;\n    $ = [[W, V]];\n  } else if (M === 0) {\n    var W = -D / N, V = -(e * W + R) / o;\n    $ = [[W, V]];\n  } else {\n    var W = (o * D - M * R) / (M * e - o * N), V = -(e * W + R) / o;\n    $ = [[W, V]];\n  }\n  return $.map(function(Y) {\n    return [Y[0], Y[1]];\n  });\n}\nfunction getPointsOnLines(n, t) {\n  var e = t.map(function(k) {\n    return [0, 1].map(function(U) {\n      return [Math.min(k[0][U], k[1][U]), Math.max(k[0][U], k[1][U])];\n    });\n  }), o = [];\n  if (n.length === 2) {\n    var R = n[0], N = R[0], M = R[1];\n    if (tinyThrottle(N - n[1][0])) {\n      if (!tinyThrottle(M - n[1][1])) {\n        var B = Math.max.apply(Math, e.map(function(k) {\n          return k[0][0];\n        })), $ = Math.min.apply(Math, e.map(function(k) {\n          return k[0][1];\n        }));\n        if (tinyThrottle(B - $) > 0)\n          return [];\n        o = [[B, M], [$, M]];\n      }\n    } else {\n      var D = Math.max.apply(Math, e.map(function(k) {\n        return k[1][0];\n      })), L = Math.min.apply(Math, e.map(function(k) {\n        return k[1][1];\n      }));\n      if (tinyThrottle(D - L) > 0)\n        return [];\n      o = [[N, D], [N, L]];\n    }\n  }\n  return o.length || (o = n.filter(function(k) {\n    var U = k[0], z = k[1];\n    return e.every(function(X) {\n      return 0 <= tinyThrottle(U - X[0][0]) && 0 <= tinyThrottle(X[0][1] - U) && 0 <= tinyThrottle(z - X[1][0]) && 0 <= tinyThrottle(X[1][1] - z);\n    });\n  })), o.map(function(k) {\n    return [tinyThrottle(k[0]), tinyThrottle(k[1])];\n  });\n}\nfunction convertLines(n) {\n  return __spreadArrays$3(n.slice(1), [n[0]]).map(function(t, e) {\n    return [n[e], t];\n  });\n}\nfunction getOverlapPointInfos(n, t) {\n  var e = n.slice(), o = t.slice();\n  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(o) === -1 && o.reverse();\n  var R = convertLines(e), N = convertLines(o), M = R.map(function($) {\n    return getLinearConstants($[0], $[1]);\n  }), D = N.map(function($) {\n    return getLinearConstants($[0], $[1]);\n  }), L = [];\n  M.forEach(function($, k) {\n    var U = R[k], z = [];\n    D.forEach(function(X, V) {\n      var W = getIntersectionPointsByConstants($, X), Y = getPointsOnLines(W, [U, N[V]]);\n      z.push.apply(z, Y.map(function(q) {\n        return {\n          index1: k,\n          index2: V,\n          pos: q,\n          type: \"intersection\"\n        };\n      }));\n    }), z.sort(function(X, V) {\n      return getDist$2(U[0], X.pos) - getDist$2(U[0], V.pos);\n    }), L.push.apply(L, z), isInside(U[1], o) && L.push({\n      index1: k,\n      index2: -1,\n      pos: U[1],\n      type: \"inside\"\n    });\n  }), N.forEach(function($, k) {\n    if (!!isInside($[1], e)) {\n      var U = !1, z = findIndex(L, function(X) {\n        var V = X.index2;\n        return V === k ? (U = !0, !1) : !!U;\n      });\n      z === -1 && (U = !1, z = findIndex(L, function(X) {\n        var V = X.index1, W = X.index2;\n        return V === -1 && W + 1 === k ? (U = !0, !1) : !!U;\n      })), z === -1 ? L.push({\n        index1: -1,\n        index2: k,\n        pos: $[1],\n        type: \"inside\"\n      }) : L.splice(z, 0, {\n        index1: -1,\n        index2: k,\n        pos: $[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var B = {};\n  return L.filter(function($) {\n    var k = $.pos, U = k[0] + \"x\" + k[1];\n    return B[U] ? !1 : (B[U] = !0, !0);\n  });\n}\nfunction getOverlapPoints(n, t) {\n  var e = getOverlapPointInfos(n, t);\n  return e.map(function(o) {\n    var R = o.pos;\n    return R;\n  });\n}\nfunction getOverlapSize(n, t) {\n  var e = getOverlapPoints(n, t);\n  return getAreaSize(e);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$6 = function() {\n  return __assign$6 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$6.apply(this, arguments);\n};\nfunction __spreadArrays$2() {\n  for (var n = 0, t = 0, e = arguments.length; t < e; t++)\n    n += arguments[t].length;\n  for (var o = Array(n), R = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)\n      o[R] = N[M];\n  return o;\n}\nvar EventEmitter$3 = /* @__PURE__ */ function() {\n  function n() {\n    this._events = {};\n  }\n  var t = n.prototype;\n  return t.on = function(e, o) {\n    if (isObject$2(e))\n      for (var R in e)\n        this.on(R, e[R]);\n    else\n      this._addEvent(e, o, {});\n    return this;\n  }, t.off = function(e, o) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var R in e)\n        this.off(R);\n    else if (!o)\n      this._events[e] = [];\n    else {\n      var N = this._events[e];\n      if (N) {\n        var M = findIndex(N, function(D) {\n          return D.listener === o;\n        });\n        M > -1 && N.splice(M, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, o) {\n    var R = this;\n    return o && this._addEvent(e, o, {\n      once: !0\n    }), new Promise(function(N) {\n      R._addEvent(e, N, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, o) {\n    var R = this;\n    o === void 0 && (o = {});\n    var N = this._events[e];\n    if (!e || !N)\n      return !0;\n    var M = !1;\n    return o.eventType = e, o.stop = function() {\n      M = !0;\n    }, o.currentTarget = this, __spreadArrays$2(N).forEach(function(D) {\n      D.listener(o), D.once && R.off(e, D.listener);\n    }), !M;\n  }, t.trigger = function(e, o) {\n    return o === void 0 && (o = {}), this.emit(e, o);\n  }, t._addEvent = function(e, o, R) {\n    var N = this._events;\n    N[e] = N[e] || [];\n    var M = N[e];\n    M.push(__assign$6({\n      listener: o\n    }, R));\n  }, n;\n}();\nconst EventEmitter$4 = EventEmitter$3;\nvar FUNCTION = \"function\";\nfunction isFunction$2(n) {\n  return typeof n === FUNCTION;\n}\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$4 = function(n, t) {\n  return extendStatics$4 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$4(n, t);\n};\nfunction __extends$4(n, t) {\n  extendStatics$4(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$5 = function() {\n  return __assign$5 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$5.apply(this, arguments);\n};\nfunction getDefaultScrollPosition$1(n) {\n  var t = n.container;\n  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];\n}\nfunction getContainerElement(n) {\n  if (n) {\n    if (isFunction$2(n))\n      return n();\n    if (n instanceof Element)\n      return n;\n    if (\"current\" in n)\n      return n.current;\n    if (\"value\" in n)\n      return n.value;\n  } else\n    return null;\n}\nvar DragScroll = /* @__PURE__ */ function(n) {\n  __extends$4(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o._startRect = null, o._startPos = [], o._prevTime = 0, o._timer = 0, o._prevScrollPos = [0, 0], o._isWait = !1, o._flag = !1, o;\n  }\n  var e = t.prototype;\n  return e.dragStart = function(o, R) {\n    var N = getContainerElement(R.container);\n    if (!N) {\n      this._flag = !1;\n      return;\n    }\n    var M = 0, D = 0, L = 0, B = 0;\n    if (N === document.body)\n      L = window.innerWidth, B = window.innerHeight;\n    else {\n      var $ = N.getBoundingClientRect();\n      M = $.top, D = $.left, L = $.width, B = $.height;\n    }\n    this._flag = !0, this._startPos = [o.clientX, o.clientY], this._startRect = {\n      top: M,\n      left: D,\n      width: L,\n      height: B\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], R);\n  }, e.drag = function(o, R) {\n    if (!!this._flag) {\n      var N = o.clientX, M = o.clientY, D = R.threshold, L = D === void 0 ? 0 : D, B = this, $ = B._startRect, k = B._startPos, U = [0, 0];\n      return $.top > M - L ? (k[1] > $.top || M < k[1]) && (U[1] = -1) : $.top + $.height < M + L && (k[1] < $.top + $.height || M > k[1]) && (U[1] = 1), $.left > N - L ? (k[0] > $.left || N < k[0]) && (U[0] = -1) : $.left + $.width < N + L && (k[0] < $.left + $.width || N > k[0]) && (U[0] = 1), clearTimeout(this._timer), !U[0] && !U[1] ? !1 : this._continueDrag(__assign$5(__assign$5({}, R), {\n        direction: U,\n        inputEvent: o,\n        isDrag: !0\n      }));\n    }\n  }, e.checkScroll = function(o) {\n    var R = this;\n    if (this._isWait)\n      return !1;\n    var N = o.prevScrollPos, M = N === void 0 ? this._prevScrollPos : N, D = o.direction, L = o.throttleTime, B = L === void 0 ? 0 : L, $ = o.inputEvent, k = o.isDrag, U = this._getScrollPosition(D || [0, 0], o), z = U[0] - M[0], X = U[1] - M[1], V = D || [z ? Math.abs(z) / z : 0, X ? Math.abs(X) / X : 0];\n    return this._prevScrollPos = U, !z && !X ? !1 : (this.trigger(\"move\", {\n      offsetX: V[0] ? z : 0,\n      offsetY: V[1] ? X : 0,\n      inputEvent: $\n    }), B && k && (this._timer = window.setTimeout(function() {\n      R._continueDrag(o);\n    }, B)), !0);\n  }, e.dragEnd = function() {\n    clearTimeout(this._timer);\n  }, e._getScrollPosition = function(o, R) {\n    var N = R.container, M = R.getScrollPosition, D = M === void 0 ? getDefaultScrollPosition$1 : M;\n    return D({\n      container: getContainerElement(N),\n      direction: o\n    });\n  }, e._continueDrag = function(o) {\n    var R = this, N = o.container, M = o.direction, D = o.throttleTime, L = o.useScroll, B = o.isDrag, $ = o.inputEvent;\n    if (!(B && this._isWait)) {\n      var k = now(), U = Math.max(D + this._prevTime - k, 0);\n      if (U > 0)\n        return this._timer = window.setTimeout(function() {\n          R._continueDrag(o);\n        }, U), !1;\n      this._prevTime = k;\n      var z = this._getScrollPosition(M, o);\n      return this._prevScrollPos = z, B && (this._isWait = !0), this.trigger(\"scroll\", {\n        container: getContainerElement(N),\n        direction: M,\n        inputEvent: $\n      }), this._isWait = !1, L || this.checkScroll(__assign$5(__assign$5({}, o), {\n        prevScrollPos: z,\n        direction: M,\n        inputEvent: $\n      }));\n    }\n  }, t;\n}(EventEmitter$4);\nconst DragScroll$1 = DragScroll;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$3 = function(n, t) {\n  return extendStatics$3 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$3(n, t);\n};\nfunction __extends$3(n, t) {\n  extendStatics$3(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$4 = function() {\n  return __assign$4 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$4.apply(this, arguments);\n};\nfunction getRad(n, t) {\n  var e = t[0] - n[0], o = t[1] - n[1], R = Math.atan2(o, e);\n  return R >= 0 ? R : R + Math.PI * 2;\n}\nfunction getRotatiion(n) {\n  return getRad([n[0].clientX, n[0].clientY], [n[1].clientX, n[1].clientY]) / Math.PI * 180;\n}\nfunction isMultiTouch(n) {\n  return n.touches && n.touches.length >= 2;\n}\nfunction getEventClients(n) {\n  return n ? n.touches ? getClients(n.touches) : [getClient(n)] : [];\n}\nfunction isMouseEvent(n) {\n  return n && (n.type.indexOf(\"mouse\") > -1 || \"button\" in n || \"which\" in n);\n}\nfunction getPosition(n, t, e) {\n  var o = e.length, R = getAverageClient(n, o), N = R.clientX, M = R.clientY, D = R.originalClientX, L = R.originalClientY, B = getAverageClient(t, o), $ = B.clientX, k = B.clientY, U = getAverageClient(e, o), z = U.clientX, X = U.clientY, V = N - $, W = M - k, Y = N - z, q = M - X;\n  return {\n    clientX: D,\n    clientY: L,\n    deltaX: V,\n    deltaY: W,\n    distX: Y,\n    distY: q\n  };\n}\nfunction getDist$1(n) {\n  return Math.sqrt(Math.pow(n[0].clientX - n[1].clientX, 2) + Math.pow(n[0].clientY - n[1].clientY, 2));\n}\nfunction getClients(n) {\n  for (var t = Math.min(n.length, 2), e = [], o = 0; o < t; ++o)\n    e.push(getClient(n[o]));\n  return e;\n}\nfunction getClient(n) {\n  return {\n    clientX: n.clientX,\n    clientY: n.clientY\n  };\n}\nfunction getAverageClient(n, t) {\n  t === void 0 && (t = n.length);\n  for (var e = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, o = 0; o < t; ++o) {\n    var R = n[o];\n    e.originalClientX += \"originalClientX\" in R ? R.originalClientX : R.clientX, e.originalClientY += \"originalClientY\" in R ? R.originalClientY : R.clientY, e.clientX += R.clientX, e.clientY += R.clientY;\n  }\n  return t ? {\n    clientX: e.clientX / t,\n    clientY: e.clientY / t,\n    originalClientX: e.originalClientX / t,\n    originalClientY: e.originalClientY / t\n  } : e;\n}\nvar ClientStore = /* @__PURE__ */ function() {\n  function n(e) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;\n  }\n  var t = n.prototype;\n  return t.getAngle = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e);\n  }, t.getRotation = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e) - getRotatiion(this.startClients);\n  }, t.getPosition = function(e, o) {\n    e === void 0 && (e = this.prevClients);\n    var R = getPosition(e || this.prevClients, this.prevClients, this.startClients), N = R.deltaX, M = R.deltaY;\n    return this.movement += Math.sqrt(N * N + M * M), this.prevClients = e, R;\n  }, t.getPositions = function(e) {\n    e === void 0 && (e = this.prevClients);\n    var o = this.prevClients;\n    return this.startClients.map(function(R, N) {\n      return getPosition([e[N]], [o[N]], [R]);\n    });\n  }, t.getMovement = function(e) {\n    var o = this.movement;\n    if (!e)\n      return o;\n    var R = getAverageClient(e, this.length), N = getAverageClient(this.prevClients, this.length), M = R.clientX - N.clientX, D = R.clientY - N.clientY;\n    return Math.sqrt(M * M + D * D) + o;\n  }, t.getDistance = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e);\n  }, t.getScale = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e) / getDist$1(this.startClients);\n  }, t.move = function(e, o) {\n    this.startClients.forEach(function(R) {\n      R.clientX -= e, R.clientY -= o;\n    });\n  }, n;\n}(), INPUT_TAGNAMES = [\"textarea\", \"input\"], Gesto = /* @__PURE__ */ function(n) {\n  __extends$3(t, n);\n  function t(o, R) {\n    R === void 0 && (R = {});\n    var N = n.call(this) || this;\n    N.options = {}, N.flag = !1, N.pinchFlag = !1, N.datas = {}, N.isDrag = !1, N.isPinch = !1, N.isMouse = !1, N.isTouch = !1, N.clientStores = [], N.targets = [], N.prevTime = 0, N.doubleFlag = !1, N._dragFlag = !1, N._isMouseEvent = !1, N.onDragStart = function(U, z) {\n      if (z === void 0 && (z = !0), !(!N.flag && U.cancelable === !1)) {\n        var X = N.options, V = X.container, W = X.pinchOutside, Y = X.preventWheelClick, q = X.preventRightClick, Z = X.preventDefault, K = X.checkInput, Q = N.isTouch, J = !N.flag;\n        if (Y && (U.which === 2 || U.button === 1) || q && (U.which === 3 || U.button === 2))\n          return N.initDrag(), !1;\n        if (J) {\n          var rt = document.activeElement, tt = U.target, nt = tt.tagName.toLowerCase(), st = INPUT_TAGNAMES.indexOf(nt) > -1, ut = tt.isContentEditable;\n          if (st || ut) {\n            if (K || rt === tt || rt && ut && rt.isContentEditable && rt.contains(tt))\n              return !1;\n          } else if ((Z || U.type === \"touchstart\") && rt) {\n            var ct = rt.tagName;\n            (rt.isContentEditable || INPUT_TAGNAMES.indexOf(ct) > -1) && rt.blur();\n          }\n          N.clientStores = [new ClientStore(getEventClients(U))], N.flag = !0, N.isDrag = !1, N._dragFlag = !0, N.datas = {}, N.doubleFlag = now$1() - N.prevTime < 200, N._isMouseEvent = isMouseEvent(U);\n          var dt = N.emit(\"dragStart\", __assign$4(__assign$4({\n            datas: N.datas,\n            inputEvent: U,\n            isMouseEvent: N._isMouseEvent,\n            isTrusted: z,\n            isDouble: N.doubleFlag\n          }, N.getCurrentStore().getPosition()), {\n            preventDefault: function() {\n              U.preventDefault();\n            },\n            preventDrag: function() {\n              N._dragFlag = !1;\n            }\n          }));\n          dt === !1 && N.initDrag(), N.flag && Z && U.preventDefault();\n        }\n        if (!N.flag)\n          return !1;\n        var Et = 0;\n        if (J && Q && W && (Et = setTimeout(function() {\n          addEvent(V, \"touchstart\", N.onDragStart, {\n            passive: !1\n          });\n        })), !J && Q && W && removeEvent(V, \"touchstart\", N.onDragStart), N.flag && isMultiTouch(U)) {\n          if (clearTimeout(Et), J && U.touches.length !== U.changedTouches.length)\n            return;\n          N.pinchFlag || N.onPinchStart(U);\n        }\n      }\n    }, N.onDrag = function(U, z) {\n      if (!!N.flag) {\n        var X = getEventClients(U), V = N.moveClients(X, U, !1);\n        if (N._dragFlag) {\n          if (N.pinchFlag || V.deltaX || V.deltaY) {\n            var W = N.emit(\"drag\", __assign$4(__assign$4({}, V), {\n              isScroll: !!z,\n              inputEvent: U\n            }));\n            if (W === !1) {\n              N.stop();\n              return;\n            }\n          }\n          N.pinchFlag && N.onPinch(U, X);\n        }\n        N.getCurrentStore().getPosition(X, !0);\n      }\n    }, N.onDragEnd = function(U) {\n      if (!!N.flag) {\n        var z = N.options, X = z.pinchOutside, V = z.container;\n        N.isTouch && X && removeEvent(V, \"touchstart\", N.onDragStart), N.pinchFlag && N.onPinchEnd(U);\n        var W = U != null && U.touches ? getEventClients(U) : [], Y = W.length;\n        Y === 0 || !N.options.keepDragging ? N.flag = !1 : N._addStore(new ClientStore(W));\n        var q = N._getPosition(), Z = now$1(), K = !N.isDrag && N.doubleFlag;\n        N.prevTime = N.isDrag || K ? 0 : Z, N.flag || (N.emit(\"dragEnd\", __assign$4({\n          datas: N.datas,\n          isDouble: K,\n          isDrag: N.isDrag,\n          isClick: !N.isDrag,\n          isMouseEvent: N._isMouseEvent,\n          inputEvent: U\n        }, q)), N.clientStores = []);\n      }\n    }, N.onBlur = function() {\n      N.onDragEnd();\n    };\n    var M = [].concat(o);\n    N.options = __assign$4({\n      checkInput: !1,\n      container: M.length > 1 ? window : M[0],\n      preventRightClick: !0,\n      preventWheelClick: !0,\n      preventDefault: !0,\n      checkWindowBlur: !1,\n      keepDragging: !1,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, R);\n    var D = N.options, L = D.container, B = D.events, $ = D.checkWindowBlur;\n    if (N.isTouch = B.indexOf(\"touch\") > -1, N.isMouse = B.indexOf(\"mouse\") > -1, N.targets = M, N.isMouse && (M.forEach(function(U) {\n      addEvent(U, \"mousedown\", N.onDragStart);\n    }), addEvent(L, \"mousemove\", N.onDrag), addEvent(L, \"mouseup\", N.onDragEnd), addEvent(L, \"contextmenu\", N.onDragEnd)), $ && addEvent(window, \"blur\", N.onBlur), N.isTouch) {\n      var k = {\n        passive: !1\n      };\n      M.forEach(function(U) {\n        addEvent(U, \"touchstart\", N.onDragStart, k);\n      }), addEvent(L, \"touchmove\", N.onDrag, k), addEvent(L, \"touchend\", N.onDragEnd, k), addEvent(L, \"touchcancel\", N.onDragEnd, k);\n    }\n    return N;\n  }\n  var e = t.prototype;\n  return e.stop = function() {\n    this.isDrag = !1, this.flag = !1, this.clientStores = [], this.datas = {};\n  }, e.getMovement = function(o) {\n    return this.getCurrentStore().getMovement(o) + this.clientStores.slice(1).reduce(function(R, N) {\n      return R + N.movement;\n    }, 0);\n  }, e.isDragging = function() {\n    return this.isDrag;\n  }, e.isFlag = function() {\n    return this.flag;\n  }, e.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, e.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, e.isPinching = function() {\n    return this.isPinch;\n  }, e.scrollBy = function(o, R, N, M) {\n    M === void 0 && (M = !0), this.flag && (this.clientStores[0].move(o, R), M && this.onDrag(N, !0));\n  }, e.move = function(o, R) {\n    var N = o[0], M = o[1], D = this.getCurrentStore(), L = D.prevClients;\n    return this.moveClients(L.map(function(B) {\n      var $ = B.clientX, k = B.clientY;\n      return {\n        clientX: $ + N,\n        clientY: k + M,\n        originalClientX: $,\n        originalClientY: k\n      };\n    }), R, !0);\n  }, e.triggerDragStart = function(o) {\n    this.onDragStart(o, !1);\n  }, e.setEventDatas = function(o) {\n    var R = this.datas;\n    for (var N in o)\n      R[N] = o[N];\n    return this;\n  }, e.getCurrentEvent = function(o) {\n    return __assign$4(__assign$4({\n      datas: this.datas\n    }, this._getPosition()), {\n      movement: this.getMovement(),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      inputEvent: o\n    });\n  }, e.getEventDatas = function() {\n    return this.datas;\n  }, e.unset = function() {\n    var o = this, R = this.targets, N = this.options.container;\n    this.off(), removeEvent(window, \"blur\", this.onBlur), this.isMouse && (R.forEach(function(M) {\n      removeEvent(M, \"mousedown\", o.onDragStart);\n    }), removeEvent(N, \"mousemove\", this.onDrag), removeEvent(N, \"mouseup\", this.onDragEnd), removeEvent(N, \"contextmenu\", this.onDragEnd)), this.isTouch && (R.forEach(function(M) {\n      removeEvent(M, \"touchstart\", o.onDragStart);\n    }), removeEvent(N, \"touchstart\", this.onDragStart), removeEvent(N, \"touchmove\", this.onDrag), removeEvent(N, \"touchend\", this.onDragEnd), removeEvent(N, \"touchcancel\", this.onDragEnd));\n  }, e.onPinchStart = function(o) {\n    var R = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > R)) {\n      var N = new ClientStore(getEventClients(o));\n      this.pinchFlag = !0, this._addStore(N);\n      var M = this.emit(\"pinchStart\", __assign$4(__assign$4({\n        datas: this.datas,\n        angle: N.getAngle(),\n        touches: this.getCurrentStore().getPositions()\n      }, N.getPosition()), {\n        inputEvent: o\n      }));\n      M === !1 && (this.pinchFlag = !1);\n    }\n  }, e.onPinch = function(o, R) {\n    if (!(!this.flag || !this.pinchFlag || R.length < 2)) {\n      var N = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", __assign$4(__assign$4({\n        datas: this.datas,\n        movement: this.getMovement(R),\n        angle: N.getAngle(R),\n        rotation: N.getRotation(R),\n        touches: N.getPositions(R),\n        scale: N.getScale(R),\n        distance: N.getDistance(R)\n      }, N.getPosition(R)), {\n        inputEvent: o\n      }));\n    }\n  }, e.onPinchEnd = function(o) {\n    if (!!this.pinchFlag) {\n      var R = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var N = this.getCurrentStore();\n      this.emit(\"pinchEnd\", __assign$4(__assign$4({\n        datas: this.datas,\n        isPinch: R,\n        touches: N.getPositions()\n      }, N.getPosition()), {\n        inputEvent: o\n      }));\n    }\n  }, e.initDrag = function() {\n    this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1;\n  }, e.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, e.moveClients = function(o, R, N) {\n    var M = this._getPosition(o, N);\n    return (M.deltaX || M.deltaY) && (this.isDrag = !0), __assign$4(__assign$4({\n      datas: this.datas\n    }, M), {\n      movement: this.getMovement(o),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      isMouseEvent: this._isMouseEvent,\n      inputEvent: R\n    });\n  }, e._addStore = function(o) {\n    this.clientStores.splice(0, 0, o);\n  }, e._getPosition = function(o, R) {\n    var N = this.getCurrentStore(), M = N.getPosition(o, R), D = this.clientStores.slice(1).reduce(function($, k) {\n      var U = k.getPosition();\n      return $.distX += U.distX, $.distY += U.distY, $;\n    }, M), L = D.distX, B = D.distY;\n    return __assign$4(__assign$4({}, M), {\n      distX: L,\n      distY: B\n    });\n  }, t;\n}(EventEmitter$4);\nconst Gesto$1 = Gesto;\nfunction hash$2(n) {\n  for (var t = 5381, e = n.length; e; )\n    t = t * 33 ^ n.charCodeAt(--e);\n  return t >>> 0;\n}\nvar stringHash = hash$2;\nfunction getHash(n) {\n  return stringHash(n).toString(36);\n}\nfunction getShadowRoot(n) {\n  if (n && n.getRootNode) {\n    var t = n.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction replaceStyle(n, t, e) {\n  return e.original ? t : t.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(o, R) {\n    var N = R.trim();\n    return (N ? splitComma(N) : [\"\"]).map(function(M) {\n      var D = M.trim();\n      return D.indexOf(\"@\") === 0 ? D : D.indexOf(\":global\") > -1 ? D.replace(/\\:global/g, \"\") : D.indexOf(\":host\") > -1 ? \"\" + D.replace(/\\:host/g, \".\" + n) : D ? \".\" + n + \" \" + D : \".\" + n;\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(n, t, e, o) {\n  var R = document.createElement(\"style\");\n  return R.setAttribute(\"type\", \"text/css\"), R.setAttribute(\"data-styled-id\", n), e.nonce && R.setAttribute(\"nonce\", e.nonce), R.innerHTML = replaceStyle(n, t, e), (o || document.head || document.body).appendChild(R), R;\n}\nfunction styled$1(n) {\n  var t = \"rCS\" + getHash(n), e = 0, o;\n  return {\n    className: t,\n    inject: function(R, N) {\n      N === void 0 && (N = {});\n      var M = getShadowRoot(R), D = e === 0, L;\n      return (M || D) && (L = injectStyle(t, n, N, M)), D && (o = L), M || ++e, {\n        destroy: function() {\n          M ? (R.removeChild(L), L = null) : (e > 0 && --e, e === 0 && o && (o.parentNode.removeChild(o), o = null));\n        }\n      };\n    }\n  };\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$2 = function(n, t) {\n  return extendStatics$2 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics$2(n, t);\n};\nfunction __extends$2(n, t) {\n  extendStatics$2(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$3 = function() {\n  return __assign$3 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$3.apply(this, arguments);\n};\nfunction __rest$1(n, t) {\n  var e = {};\n  for (var o in n)\n    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);\n  if (n != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)\n      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);\n  return e;\n}\nvar StyledElement = /* @__PURE__ */ function(n) {\n  __extends$2(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.injectResult = null, o.tag = \"div\", o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this.props, R = o.className, N = R === void 0 ? \"\" : R;\n    o.cspNonce;\n    var M = o.portalContainer, D = __rest$1(o, [\"className\", \"cspNonce\", \"portalContainer\"]), L = this.injector.className, B = this.tag, $ = {};\n    return version.indexOf(\"simple\") > -1 && M && ($ = {\n      portalContainer: M\n    }), createElement(B, __assign$3({\n      ref: ref(this, \"element\"),\n      \"data-styled-id\": L,\n      className: N + \" \" + L\n    }, $, D));\n  }, e.componentDidMount = function() {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  }, e.componentWillUnmount = function() {\n    this.injectResult.destroy(), this.injectResult = null;\n  }, e.getElement = function() {\n    return this.element;\n  }, t;\n}(Component);\nfunction styled(n, t) {\n  var e = styled$1(t);\n  return /* @__PURE__ */ function(o) {\n    __extends$2(R, o);\n    function R() {\n      var N = o !== null && o.apply(this, arguments) || this;\n      return N.injector = e, N.tag = n, N;\n    }\n    return R;\n  }(StyledElement);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$1$1 = function() {\n  return __assign$1$1 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$1$1.apply(this, arguments);\n};\nfunction __spreadArrays$1() {\n  for (var n = 0, t = 0, e = arguments.length; t < e; t++)\n    n += arguments[t].length;\n  for (var o = Array(n), R = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)\n      o[R] = N[M];\n  return o;\n}\nvar EventEmitter$2 = /* @__PURE__ */ function() {\n  function n() {\n    this._events = {};\n  }\n  var t = n.prototype;\n  return t.on = function(e, o) {\n    if (isObject$2(e))\n      for (var R in e)\n        this.on(R, e[R]);\n    else\n      this._addEvent(e, o, {});\n    return this;\n  }, t.off = function(e, o) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var R in e)\n        this.off(R);\n    else if (!o)\n      this._events[e] = [];\n    else {\n      var N = this._events[e];\n      if (N) {\n        var M = findIndex(N, function(D) {\n          return D.listener === o;\n        });\n        M > -1 && N.splice(M, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, o) {\n    var R = this;\n    return o && this._addEvent(e, o, {\n      once: !0\n    }), new Promise(function(N) {\n      R._addEvent(e, N, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, o) {\n    var R = this;\n    o === void 0 && (o = {});\n    var N = this._events[e];\n    if (!e || !N)\n      return !0;\n    var M = !1;\n    return o.eventType = e, o.stop = function() {\n      M = !0;\n    }, o.currentTarget = this, __spreadArrays$1(N).forEach(function(D) {\n      D.listener(o), D.once && R.off(e, D.listener);\n    }), !M;\n  }, t.trigger = function(e, o) {\n    return o === void 0 && (o = {}), this.emit(e, o);\n  }, t._addEvent = function(e, o, R) {\n    var N = this._events;\n    N[e] = N[e] || [];\n    var M = N[e];\n    M.push(__assign$1$1({\n      listener: o\n    }, R));\n  }, n;\n}(), EventEmitter$1$1 = EventEmitter$2, extendStatics$1 = function(n, t) {\n  return extendStatics$1 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      Object.prototype.hasOwnProperty.call(o, R) && (e[R] = o[R]);\n  }, extendStatics$1(n, t);\n};\nfunction __extends$1(n, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  extendStatics$1(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$2 = function() {\n  return __assign$2 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$2.apply(this, arguments);\n};\nfunction __rest(n, t) {\n  var e = {};\n  for (var o in n)\n    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);\n  if (n != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)\n      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);\n  return e;\n}\nfunction __decorate$1(n, t, e, o) {\n  var R = arguments.length, N = R < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, M;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    N = Reflect.decorate(n, t, e, o);\n  else\n    for (var D = n.length - 1; D >= 0; D--)\n      (M = n[D]) && (N = (R < 3 ? M(N) : R > 3 ? M(t, e, N) : M(t, e)) || N);\n  return R > 3 && N && Object.defineProperty(t, e, N), N;\n}\nfunction __spreadArray(n, t, e) {\n  if (e || arguments.length === 2)\n    for (var o = 0, R = t.length, N; o < R; o++)\n      (N || !(o in t)) && (N || (N = Array.prototype.slice.call(t, 0, o)), N[o] = t[o]);\n  return n.concat(N || Array.prototype.slice.call(t));\n}\nfunction makeAble(n, t) {\n  var e;\n  return __assign$2({\n    events: {},\n    props: (e = {}, e[n] = Boolean, e),\n    name: n\n  }, t);\n}\nfunction getSVGCursor(n, t) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * n, 'px\" height=\"').concat(32 * n, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(n) {\n  var t = getSVGCursor(1, n), e = Math.round(n / 45) * 45 % 180, o = \"ns-resize\";\n  return e === 135 ? o = \"nwse-resize\" : e === 45 ? o = \"nesw-resize\" : e === 90 && (o = \"ew-resize\"), \"cursor:\".concat(o, \";cursor: url('\").concat(t, \"') 16 16, \").concat(o, \";\");\n}\nvar agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {\n  var n = typeof window > \"u\" ? {\n    userAgent: \"\"\n  } : window.navigator, t = /applewebkit\\/([^\\s]+)/g.exec(n.userAgent.toLowerCase());\n  return t ? parseFloat(t[1]) < 605 : !1;\n}(), IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = \"moveable-\", MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(n) {\n  return `\n.direction[data-rotation=\"`.concat(n, `\"] {\n\t`).concat(getCursorCSS(n), `\n}\n`);\n}).join(`\n`), `\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n`).concat(IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\", `\n`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"], DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"], DIRECTION_REGION_TO_DIRECTION = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, DIRECTION_INDEXES = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\"];\nfunction setCustomDrag(n, t, e, o, R, N) {\n  N === void 0 && (N = \"draggable\");\n  var M = t.gestos[N].move(e, n.inputEvent), D = M.originalDatas || M.datas, L = D[N] || (D[N] = {});\n  return __assign$2(__assign$2({}, R ? convertDragDist(t, M) : M), {\n    isPinch: !!o,\n    parentEvent: !0,\n    datas: L,\n    originalDatas: n.originalDatas\n  });\n}\nvar CustomGesto = /* @__PURE__ */ function() {\n  function n(e) {\n    var o;\n    e === void 0 && (e = \"draggable\"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {\n      draggable: {}\n    }, this.datas = (o = {}, o[e] = {}, o);\n  }\n  var t = n.prototype;\n  return t.dragStart = function(e, o) {\n    this.isDrag = !1, this.isFlag = !1;\n    var R = o.originalDatas;\n    return this.datas = R, R[this.ableName] || (R[this.ableName] = {}), __assign$2(__assign$2({}, this.move(e, o.inputEvent)), {\n      type: \"dragstart\"\n    });\n  }, t.drag = function(e, o) {\n    return this.move([e[0] - this.prevX, e[1] - this.prevY], o);\n  }, t.move = function(e, o) {\n    var R, N;\n    return this.isFlag ? (R = this.prevX + e[0], N = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0)) : (this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], R = e[0], N = e[1], this.isFlag = !0), this.prevX = R, this.prevY = N, {\n      type: \"drag\",\n      clientX: R,\n      clientY: N,\n      inputEvent: o,\n      isDrag: this.isDrag,\n      distX: R - this.startX,\n      distY: N - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }, n;\n}();\nfunction calculatePointerDist(n, t) {\n  var e = t.clientX, o = t.clientY, R = t.datas, N = n.state, M = N.moveableClientRect, D = N.rootMatrix, L = N.is3d, B = N.pos1, $ = M.left, k = M.top, U = L ? 4 : 3, z = minus(calculateInversePosition(D, [e - $, o - k], U), B), X = z[0], V = z[1], W = getDragDist({\n    datas: R,\n    distX: X,\n    distY: V\n  }), Y = W[0], q = W[1];\n  return [Y, q];\n}\nfunction setDragStart(n, t) {\n  var e = t.datas, o = n.state, R = o.allMatrix, N = o.beforeMatrix, M = o.is3d, D = o.left, L = o.top, B = o.origin, $ = o.offsetMatrix, k = o.targetMatrix, U = o.transformOrigin, z = M ? 4 : 3;\n  e.is3d = M, e.matrix = R, e.targetMatrix = k, e.beforeMatrix = N, e.offsetMatrix = $, e.transformOrigin = U, e.inverseMatrix = invert(R, z), e.inverseBeforeMatrix = invert(N, z), e.absoluteOrigin = convertPositionMatrix(plus([D, L], B), z), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, z), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, z);\n}\nfunction getTransformDirection(n) {\n  return calculateMoveablePosition(n.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction resolveTransformEvent(n, t) {\n  var e = n.datas, o = n.originalDatas.beforeRenderable, R = e.transformIndex, N = o.nextTransforms, M = N.length, D = o.nextTransformAppendedIndexes, L = 0;\n  R === -1 ? (L = N.length, e.transformIndex = L) : find$1(D, function(U) {\n    return U.index === R && U.functionName === t;\n  }) ? L = R : L = R + D.filter(function(U) {\n    return U.index < R;\n  }).length;\n  var B = convertTransformInfo(N, L), $ = B.targetFunction, k = t === \"rotate\" ? \"rotateZ\" : t;\n  e.beforeFunctionTexts = B.beforeFunctionTexts, e.afterFunctionTexts = B.afterFunctionTexts, e.beforeTransform = B.beforeFunctionMatrix, e.beforeTransform2 = B.beforeFunctionMatrix2, e.targetTansform = B.targetFunctionMatrix, e.afterTransform = B.afterFunctionMatrix, e.afterTransform2 = B.afterFunctionMatrix2, e.targetAllTransform = B.allFunctionMatrix, $.functionName === k ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : M > L && (e.isAppendTransform = !0, o.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], D, !0), [{\n    functionName: t,\n    index: L,\n    isAppend: !0\n  }], !1));\n}\nfunction convertTransformFormat(n, t, e) {\n  return \"\".concat(n.beforeFunctionTexts.join(\" \"), \" \").concat(n.isAppendTransform ? e : t, \" \").concat(n.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(n) {\n  var t = n.datas, e = n.distX, o = n.distY, R = getBeforeDragDist({\n    datas: t,\n    distX: e,\n    distY: o\n  }), N = R[0], M = R[1], D = getTransfromMatrix(t, fromTranslation([N, M], 4));\n  return calculate(D, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nfunction getTransfromMatrix(n, t, e) {\n  var o = n.beforeTransform, R = n.afterTransform, N = n.beforeTransform2, M = n.afterTransform2, D = n.targetAllTransform, L = e ? multiply(D, t, 4) : multiply(t, D, 4), B = multiply(invert(e ? N : o, 4), L, 4), $ = multiply(B, invert(e ? M : R, 4), 4);\n  return $;\n}\nfunction getBeforeDragDist(n) {\n  var t = n.datas, e = n.distX, o = n.distY, R = t.inverseBeforeMatrix, N = t.is3d, M = t.startDragBeforeDist, D = t.absoluteOrigin, L = N ? 4 : 3;\n  return minus(calculate(R, plus(D, [e, o]), L), M);\n}\nfunction getDragDist(n, t) {\n  var e = n.datas, o = n.distX, R = n.distY, N = e.inverseBeforeMatrix, M = e.inverseMatrix, D = e.is3d, L = e.startDragBeforeDist, B = e.startDragDist, $ = e.absoluteOrigin, k = D ? 4 : 3;\n  return minus(calculate(t ? N : M, plus($, [o, R]), k), t ? L : B);\n}\nfunction getInverseDragDist(n, t) {\n  var e = n.datas, o = n.distX, R = n.distY, N = e.beforeMatrix, M = e.matrix, D = e.is3d, L = e.startDragBeforeDist, B = e.startDragDist, $ = e.absoluteOrigin, k = D ? 4 : 3;\n  return minus(calculate(t ? N : M, plus(t ? L : B, [o, R]), k), $);\n}\nfunction calculateTransformOrigin(n, t, e, o, R, N) {\n  return o === void 0 && (o = t), R === void 0 && (R = e), N === void 0 && (N = [0, 0]), n ? n.map(function(M, D) {\n    var L = splitUnit(M), B = L.value, $ = L.unit, k = D ? R : o, U = D ? e : t;\n    if (M === \"%\" || isNaN(B)) {\n      var z = k ? N[D] / k : 0;\n      return U * z;\n    } else if ($ !== \"%\")\n      return B;\n    return U * B / 100;\n  }) : N;\n}\nfunction getPosIndexesByDirection(n) {\n  var t = [];\n  return n[1] >= 0 && (n[0] >= 0 && t.push(3), n[0] <= 0 && t.push(2)), n[1] <= 0 && (n[0] >= 0 && t.push(1), n[0] <= 0 && t.push(0)), t;\n}\nfunction getPosesByDirection(n, t) {\n  return getPosIndexesByDirection(t).map(function(e) {\n    return n[e];\n  });\n}\nfunction getPosByDirection(n, t) {\n  var e = (t[0] + 1) / 2, o = (t[1] + 1) / 2, R = [dot(n[0][0], n[1][0], e, 1 - e), dot(n[0][1], n[1][1], e, 1 - e)], N = [dot(n[2][0], n[3][0], e, 1 - e), dot(n[2][1], n[3][1], e, 1 - e)];\n  return [dot(R[0], N[0], o, 1 - o), dot(R[1], N[1], o, 1 - o)];\n}\nfunction getDist(n, t, e, o, R, N) {\n  var M = calculatePoses(t, e, o, R), D = getPosByDirection(M, N), L = n[0] - D[0], B = n[1] - D[1];\n  return [L, B];\n}\nfunction getNextMatrix(n, t, e, o) {\n  return multiply(n, getAbsoluteMatrix(t, o, e), o);\n}\nfunction getNextTransformMatrix(n, t, e) {\n  var o = n.transformOrigin, R = n.offsetMatrix, N = n.is3d, M = t.beforeTransform, D = t.afterTransform, L = N ? 4 : 3, B = parseMat([e]);\n  return getNextMatrix(R, convertDimension(multiply(multiply(M, B, 4), D, 4), 4, L), o, L);\n}\nfunction scaleMatrix(n, t) {\n  var e = n.transformOrigin, o = n.offsetMatrix, R = n.is3d, N = n.targetMatrix, M = R ? 4 : 3;\n  return getNextMatrix(o, multiply(N, createScaleMatrix(t, M), M), e, M);\n}\nfunction fillTransformStartEvent(n) {\n  var t = n.originalDatas.beforeRenderable;\n  return {\n    setTransform: function(e, o) {\n      o === void 0 && (o = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(n, o);\n    },\n    setTransformIndex: function(e) {\n      setTransformIndex(n, e);\n    }\n  };\n}\nfunction setDefaultTransformIndex(n, t) {\n  var e = n.originalDatas.beforeRenderable, o = e.startTransforms;\n  setTransformIndex(n, findIndex(o, function(R) {\n    return R.indexOf(\"\".concat(t, \"(\")) === 0;\n  }));\n}\nfunction setTransformIndex(n, t) {\n  var e = n.originalDatas.beforeRenderable, o = n.datas;\n  if (o.transformIndex = t, t !== -1) {\n    var R = e.startTransforms[t];\n    if (!!R) {\n      var N = parse([R]);\n      o.startValue = N[0].functionValue;\n    }\n  }\n}\nfunction fillOriginalTransform(n, t) {\n  var e = n.originalDatas.beforeRenderable;\n  e.nextTransforms = splitSpace(t);\n}\nfunction getNextTransforms(n) {\n  var t = n.originalDatas.beforeRenderable;\n  return t.nextTransforms;\n}\nfunction getNextTransformText(n) {\n  return getNextTransforms(n).join(\" \");\n}\nfunction fillTransformEvent(n, t, e, o, R) {\n  fillOriginalTransform(R, t);\n  var N = n.getAble(\"draggable\"), M = N && N.drag(n, setCustomDrag(R, n.state, e, o, !1)), D = M ? M.transform : t;\n  return __assign$2(__assign$2({\n    transform: t,\n    drag: M\n  }, fillCSSObject({\n    transform: D\n  })), {\n    afterTransform: D\n  });\n}\nfunction getTranslateDist(n, t, e, o, R) {\n  var N = n.state, M = N.left, D = N.top, L = n.props.groupable, B = getNextTransformMatrix(n.state, R, t), $ = L ? M : 0, k = L ? D : 0, U = getDirectionOffset(n, e, B), z = minus(o, U);\n  return minus(z, [$, k]);\n}\nfunction getScaleDist(n, t, e, o, R) {\n  var N = getTranslateDist(n, \"scale(\".concat(t.join(\", \"), \")\"), e, o, R);\n  return N;\n}\nfunction getOriginDirection(n) {\n  var t = n.state, e = t.width, o = t.height, R = t.transformOrigin;\n  return [-1 + R[0] / (e / 2), -1 + R[1] / (o / 2)];\n}\nfunction getDirectionOffset(n, t, e) {\n  e === void 0 && (e = n.state.allMatrix);\n  var o = n.state, R = o.width, N = o.height, M = o.is3d, D = M ? 4 : 3, L = [R / 2 * (1 + t[0]), N / 2 * (1 + t[1])];\n  return calculatePosition(e, L, D);\n}\nfunction getRotateDist(n, t, e) {\n  var o = e.fixedDirection, R = e.fixedPosition;\n  return getTranslateDist(n, \"rotate(\".concat(t, \"deg)\"), o, R, e);\n}\nfunction getResizeDist(n, t, e, o, R, N) {\n  var M = n.props.groupable, D = n.state, L = D.transformOrigin, B = D.offsetMatrix, $ = D.is3d, k = D.width, U = D.height, z = D.left, X = D.top, V = N.fixedDirection, W = N.nextTargetMatrix || D.targetMatrix, Y = $ ? 4 : 3, q = calculateTransformOrigin(R, t, e, k, U, L), Z = M ? z : 0, K = M ? X : 0, Q = getNextMatrix(B, W, q, Y), J = getDist(o, Q, t, e, Y, V);\n  return minus(J, [Z, K]);\n}\nfunction getAbsolutePosition(n, t) {\n  return getPosByDirection(getAbsolutePosesByState(n.state), t);\n}\nfunction multiply2(n, t) {\n  return [n[0] * t[0], n[1] * t[1]];\n}\nfunction prefix() {\n  for (var n = [], t = 0; t < arguments.length; t++)\n    n[t] = arguments[t];\n  return prefixNames.apply(void 0, __spreadArray([PREFIX], n, !1));\n}\nfunction defaultSync(n) {\n  n();\n}\nfunction getTransformMatrix(n) {\n  return !n || n === \"none\" ? [1, 0, 0, 1, 0, 0] : isObject$2(n) ? n : parseMat(n);\n}\nfunction getAbsoluteMatrix(n, t, e) {\n  return multiplies(t, createOriginMatrix(e, t), n, createOriginMatrix(e.map(function(o) {\n    return -o;\n  }), t));\n}\nfunction measureSVGSize(n, t, e) {\n  if (t === \"%\") {\n    var o = getSVGViewBox(n.ownerSVGElement);\n    return o[e ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction getBeforeTransformOrigin(n) {\n  var t = getTransformOrigin(getComputedStyle$2(n, \":before\"));\n  return t.map(function(e, o) {\n    var R = splitUnit(e), N = R.value, M = R.unit;\n    return N * measureSVGSize(n, M, o === 0);\n  });\n}\nfunction getTransformOrigin(n) {\n  var t = n.transformOrigin;\n  return t ? t.split(\" \") : [\"0\", \"0\"];\n}\nfunction getElementTransform(n, t) {\n  t === void 0 && (t = getComputedStyle$2(n));\n  var e = t.transform;\n  if (e && e !== \"none\")\n    return t.transform;\n  if (\"transform\" in n) {\n    var o = n.transform, R = o.baseVal;\n    if (!R)\n      return \"\";\n    var N = R.length;\n    if (!N)\n      return \"\";\n    for (var M = [], D = function(B) {\n      var $ = R[B].matrix;\n      M.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(k) {\n        return $[k];\n      }).join(\", \"), \")\"));\n    }, L = 0; L < N; ++L)\n      D(L);\n    return M.join(\" \");\n  }\n  return \"\";\n}\nfunction getOffsetInfo(n, t, e) {\n  for (var o, R = document.body, N = !n || e ? n : ((o = n == null ? void 0 : n.assignedSlot) === null || o === void 0 ? void 0 : o.parentElement) || n.parentElement, M = !1, D = n === t || N === t, L = \"relative\"; N && N !== R; ) {\n    t === N && (D = !0);\n    var B = getComputedStyle$2(N), $ = N.tagName.toLowerCase(), k = getElementTransform(N, B);\n    if (L = B.position, $ === \"svg\" || L !== \"static\" || k && k !== \"none\")\n      break;\n    var U = N.parentNode;\n    if (U && U.nodeType === 11) {\n      N = U.host, M = !0;\n      break;\n    }\n    N = U, L = \"relative\";\n  }\n  return {\n    isCustomElement: M,\n    isStatic: L === \"static\",\n    isEnd: D || !N || N === R,\n    offsetParent: N || R\n  };\n}\nfunction getOffsetPosInfo(n, t) {\n  var e, o = n.tagName.toLowerCase(), R = n.offsetLeft, N = n.offsetTop, M = isUndefined(R), D = !M, L, B;\n  return !D && o !== \"svg\" ? (L = IS_WEBKIT605 ? getBeforeTransformOrigin(n) : getTransformOrigin(t).map(function($) {\n    return parseFloat($);\n  }), B = L.slice(), D = !0, e = getSVGGraphicsOffset(n, L), R = e[0], N = e[1], L[0] = e[2], L[1] = e[3]) : (L = getTransformOrigin(t).map(function($) {\n    return parseFloat($);\n  }), B = L.slice()), {\n    tagName: o,\n    isSVG: M,\n    hasOffset: D,\n    offset: [R || 0, N || 0],\n    origin: L,\n    targetOrigin: B\n  };\n}\nfunction getBodyOffset(n, t, e) {\n  e === void 0 && (e = getComputedStyle$2(n));\n  var o = getComputedStyle$2(document.body), R = o.position;\n  if (!t && (!R || R === \"static\"))\n    return [0, 0];\n  var N = parseInt(o.marginLeft, 10), M = parseInt(o.marginTop, 10);\n  return e.position === \"absolute\" && ((e.top !== \"auto\" || e.bottom !== \"auto\") && (M = 0), (e.left !== \"auto\" || e.right !== \"auto\") && (N = 0)), [N, M];\n}\nfunction convert3DMatrixes(n) {\n  n.forEach(function(t) {\n    var e = t.matrix;\n    e && (t.matrix = convertDimension(e, 3, 4));\n  });\n}\nfunction getBodyScrollPos() {\n  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];\n}\nfunction getPositionFixedInfo(n) {\n  for (var t = n.parentElement, e = !1; t; ) {\n    var o = getComputedStyle$2(t).transform;\n    if (o && o !== \"none\") {\n      e = !0;\n      break;\n    }\n    if (t === document.body)\n      break;\n    t = t.parentElement;\n  }\n  return {\n    fixedContainer: t || document.body,\n    hasTransform: e\n  };\n}\nfunction getMatrixStackInfo(n, t, e) {\n  for (var o = n, R = [], N = !e && n === t || n === document.body, M = N, D = !1, L = 3, B, $, k, U = !1, z = getOffsetInfo(t, t, !0).offsetParent; o && !M; ) {\n    M = N;\n    var X = getComputedStyle$2(o), V = X.position, W = getElementTransform(o, X), Y = convertCSStoMatrix(getTransformMatrix(W)), q = V === \"fixed\", Z = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    q && (U = !0, Z = getPositionFixedInfo(o), z = Z.fixedContainer);\n    var K = Y.length;\n    !D && K === 16 && (D = !0, L = 4, convert3DMatrixes(R), k && (k = convertDimension(k, 3, 4))), D && K === 9 && (Y = convertDimension(Y, 3, 4));\n    var Q = getOffsetPosInfo(o, X), J = Q.tagName, rt = Q.hasOffset, tt = Q.isSVG, nt = Q.origin, st = Q.targetOrigin, ut = Q.offset, ct = ut[0], dt = ut[1];\n    J === \"svg\" && k ? (R.push({\n      type: \"target\",\n      target: o,\n      matrix: getSVGMatrix(o, L)\n    }), R.push({\n      type: \"offset\",\n      target: o,\n      matrix: createIdentityMatrix(L)\n    })) : J === \"g\" && n !== o && (ct = 0, dt = 0);\n    var Et = void 0, vt = !1, _t = !1;\n    if (q)\n      Et = Z.fixedContainer, vt = !0;\n    else {\n      var St = getOffsetInfo(o, t);\n      Et = St.offsetParent, vt = St.isEnd, _t = St.isStatic;\n    }\n    IS_WEBKIT && !IS_SAFARI_ABOVE15 && rt && !tt && _t && (V === \"relative\" || V === \"static\") && (ct -= Et.offsetLeft, dt -= Et.offsetTop, N = N || vt);\n    var Ft = 0, mt = 0, ht = 0, pt = 0;\n    if (q)\n      rt && Z.hasTransform && (ht = Et.clientLeft, pt = Et.clientTop);\n    else if (rt && z !== Et && (Ft = Et.clientLeft, mt = Et.clientTop), rt && Et === document.body) {\n      var xt = getBodyOffset(o, !1, X);\n      ct += xt[0], dt += xt[1];\n    }\n    if (R.push({\n      type: \"target\",\n      target: o,\n      matrix: getAbsoluteMatrix(Y, L, nt)\n    }), rt ? R.push({\n      type: \"offset\",\n      target: o,\n      matrix: createOriginMatrix([ct - o.scrollLeft + Ft - ht, dt - o.scrollTop + mt - pt], L)\n    }) : R.push({\n      type: \"offset\",\n      target: o,\n      origin: nt\n    }), k || (k = Y), B || (B = nt), $ || ($ = st), M || q)\n      break;\n    o = Et, N = vt, (!e || o === document.body) && (M = N);\n  }\n  return k || (k = createIdentityMatrix(L)), B || (B = [0, 0]), $ || ($ = [0, 0]), {\n    offsetContainer: z,\n    matrixes: R,\n    targetMatrix: k,\n    transformOrigin: B,\n    targetOrigin: $,\n    is3d: D,\n    hasFixed: U\n  };\n}\nfunction makeMatrixCSS(n, t) {\n  return t === void 0 && (t = n.length > 9), \"\".concat(t ? \"matrix3d\" : \"matrix\", \"(\").concat(convertMatrixtoCSS(n, !t).join(\",\"), \")\");\n}\nfunction getSVGViewBox(n) {\n  var t = n.clientWidth, e = n.clientHeight;\n  if (!n)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: t,\n      clientHeight: e\n    };\n  var o = n.viewBox, R = o && o.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: R.x,\n    y: R.y,\n    width: R.width || t,\n    height: R.height || e,\n    clientWidth: t,\n    clientHeight: e\n  };\n}\nfunction getSVGMatrix(n, t) {\n  var e = getSVGViewBox(n), o = e.width, R = e.height, N = e.clientWidth, M = e.clientHeight, D = N / o, L = M / R, B = n.preserveAspectRatio.baseVal, $ = B.align, k = B.meetOrSlice, U = [0, 0], z = [D, L], X = [0, 0];\n  if ($ !== 1) {\n    var V = ($ - 2) % 3, W = Math.floor(($ - 2) / 3);\n    U[0] = o * V / 2, U[1] = R * W / 2;\n    var Y = k === 2 ? Math.max(L, D) : Math.min(D, L);\n    z[0] = Y, z[1] = Y, X[0] = (N - o) / 2 * V, X[1] = (M - R) / 2 * W;\n  }\n  var q = createScaleMatrix(z, t);\n  return q[t * (t - 1)] = X[0], q[t * (t - 1) + 1] = X[1], getAbsoluteMatrix(q, t, U);\n}\nfunction getSVGGraphicsOffset(n, t) {\n  if (!n.getBBox || n.tagName.toLowerCase() === \"g\")\n    return [0, 0, 0, 0];\n  var e = n.getBBox(), o = getSVGViewBox(n.ownerSVGElement), R = e.x - o.x, N = e.y - o.y;\n  return [R, N, t[0] - R, t[1] - N];\n}\nfunction calculatePosition(n, t, e) {\n  return calculate(n, convertPositionMatrix(t, e), e);\n}\nfunction calculatePoses(n, t, e, o) {\n  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(R) {\n    return calculatePosition(n, R, o);\n  });\n}\nfunction getRect(n) {\n  var t = n.map(function(B) {\n    return B[0];\n  }), e = n.map(function(B) {\n    return B[1];\n  }), o = Math.min.apply(Math, t), R = Math.min.apply(Math, e), N = Math.max.apply(Math, t), M = Math.max.apply(Math, e), D = N - o, L = M - R;\n  return {\n    left: o,\n    top: R,\n    right: N,\n    bottom: M,\n    width: D,\n    height: L\n  };\n}\nfunction calculateRect(n, t, e, o) {\n  var R = calculatePoses(n, t, e, o);\n  return getRect(R);\n}\nfunction getSVGOffset(n, t, e, o, R) {\n  var N, M = n.target, D = n.origin, L = t.matrix, B = getSize(M), $ = B.offsetWidth, k = B.offsetHeight, U = e.getBoundingClientRect(), z = [0, 0];\n  e === document.body && (z = getBodyOffset(M, !0));\n  for (var X = M.getBoundingClientRect(), V = X.left - U.left + e.scrollLeft - (e.clientLeft || 0) + z[0], W = X.top - U.top + e.scrollTop - (e.clientTop || 0) + z[1], Y = X.width, q = X.height, Z = multiplies(o, R, L), K = calculateRect(Z, $, k, o), Q = K.left, J = K.top, rt = K.width, tt = K.height, nt = calculatePosition(Z, D, o), st = minus(nt, [Q, J]), ut = [V + st[0] * Y / rt, W + st[1] * q / tt], ct = [0, 0], dt = 0; ++dt < 10; ) {\n    var Et = invert(R, o);\n    N = minus(calculatePosition(Et, ut, o), calculatePosition(Et, nt, o)), ct[0] = N[0], ct[1] = N[1];\n    var vt = multiplies(o, R, createOriginMatrix(ct, o), L), _t = calculateRect(vt, $, k, o), St = _t.left, Ft = _t.top, mt = St - V, ht = Ft - W;\n    if (Math.abs(mt) < 2 && Math.abs(ht) < 2)\n      break;\n    ut[0] -= mt, ut[1] -= ht;\n  }\n  return ct.map(function(pt) {\n    return Math.round(pt);\n  });\n}\nfunction calculateMoveableClientPositions(n, t, e) {\n  var o = n.length === 16, R = o ? 4 : 3, N = t.map(function(L) {\n    return calculatePosition(n, L, R);\n  }), M = e.left, D = e.top;\n  return N.map(function(L) {\n    return [L[0] + M, L[1] + D];\n  });\n}\nfunction calculateMoveablePosition(n, t, e, o) {\n  var R = n.length === 16, N = R ? 4 : 3, M = calculatePoses(n, e, o, N), D = M[0], L = D[0], B = D[1], $ = M[1], k = $[0], U = $[1], z = M[2], X = z[0], V = z[1], W = M[3], Y = W[0], q = W[1], Z = calculatePosition(n, t, N), K = Z[0], Q = Z[1], J = Math.min(L, k, X, Y), rt = Math.min(B, U, V, q), tt = Math.max(L, k, X, Y), nt = Math.max(B, U, V, q);\n  L = L - J || 0, k = k - J || 0, X = X - J || 0, Y = Y - J || 0, B = B - rt || 0, U = U - rt || 0, V = V - rt || 0, q = q - rt || 0, K = K - J || 0, Q = Q - rt || 0;\n  var st = getShapeDirection(M);\n  return {\n    left: J,\n    top: rt,\n    right: tt,\n    bottom: nt,\n    origin: [K, Q],\n    pos1: [L, B],\n    pos2: [k, U],\n    pos3: [X, V],\n    pos4: [Y, q],\n    direction: st\n  };\n}\nfunction getDistSize(n) {\n  return Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n}\nfunction getDiagonalSize(n, t) {\n  return getDistSize([t[0] - n[0], t[1] - n[1]]);\n}\nfunction getLineStyle(n, t, e, o) {\n  e === void 0 && (e = 1), o === void 0 && (o = getRad$1(n, t));\n  var R = getDiagonalSize(n, t);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(n[0], \"px, \").concat(n[1], \"px) rotate(\").concat(o, \"rad) scaleY(\").concat(e, \")\"),\n    width: \"\".concat(R, \"px\")\n  };\n}\nfunction getControlTransform(n, t) {\n  for (var e = [], o = 2; o < arguments.length; o++)\n    e[o - 2] = arguments[o];\n  var R = e.length, N = e.reduce(function(D, L) {\n    return D + L[0];\n  }, 0) / R, M = e.reduce(function(D, L) {\n    return D + L[1];\n  }, 0) / R;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(N, \"px, \").concat(M, \"px) rotate(\").concat(n, \"rad) scale(\").concat(t, \")\")\n  };\n}\nfunction getProps(n, t) {\n  var e = n[t];\n  return isObject$2(e) ? __assign$2(__assign$2({}, n), e) : n;\n}\nfunction getSize(n, t) {\n  t === void 0 && (t = n ? getComputedStyle$2(n) : null);\n  var e = n && !isUndefined(n.offsetWidth), o = 0, R = 0, N = 0, M = 0, D = 0, L = 0, B = 0, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 1 / 0, W = 1 / 0, Y = 1 / 0, q = 1 / 0, Z = !1;\n  if (n)\n    if (!e && n.tagName.toLowerCase() !== \"svg\") {\n      var K = n.getBBox();\n      Z = !0, o = K.width, R = K.height, D = o, L = R, B = o, $ = R, N = o, M = R;\n    } else {\n      var Q = n.style, J = t.boxSizing === \"border-box\", rt = parseFloat(t.borderLeftWidth) || 0, tt = parseFloat(t.borderRightWidth) || 0, nt = parseFloat(t.borderTopWidth) || 0, st = parseFloat(t.borderBottomWidth) || 0, ut = parseFloat(t.paddingLeft) || 0, ct = parseFloat(t.paddingRight) || 0, dt = parseFloat(t.paddingTop) || 0, Et = parseFloat(t.paddingBottom) || 0, vt = ut + ct, _t = dt + Et, St = rt + tt, Ft = nt + st, mt = vt + St, ht = _t + Ft;\n      k = Math.max(vt, convertUnitSize(t.minWidth, 0)), U = Math.max(_t, convertUnitSize(t.minHeight, 0)), V = convertUnitSize(t.maxWidth, 0), W = convertUnitSize(t.maxHeight, 0), isNaN(V) && (V = 1 / 0, W = 1 / 0);\n      var pt = convertUnitSize(Q.width, 0), xt = convertUnitSize(Q.height, 0), At = parseFloat(t.width), Rt = parseFloat(t.height);\n      D = parseFloat(t.width), L = parseFloat(t.height), B = Math.abs(At - pt) < 1 ? between(k, pt || parseFloat(t.width), V) : At, $ = Math.abs(Rt - xt) < 1 ? between(U, xt || parseFloat(t.height), W) : Rt, o = B, R = $, N = B, M = $, J ? (Y = V, q = W, z = k, X = U, B = o - mt, $ = R - ht) : (Y = V + mt, q = W + ht, z = k + mt, X = U + ht, o = B + mt, R = $ + ht), N = B + vt, M = $ + _t;\n    }\n  return {\n    svg: Z,\n    offsetWidth: o,\n    offsetHeight: R,\n    clientWidth: N,\n    clientHeight: M,\n    contentWidth: B,\n    contentHeight: $,\n    cssWidth: D,\n    cssHeight: L,\n    minWidth: k,\n    minHeight: U,\n    maxWidth: V,\n    maxHeight: W,\n    minOffsetWidth: z,\n    minOffsetHeight: X,\n    maxOffsetWidth: Y,\n    maxOffsetHeight: q\n  };\n}\nfunction getRotationRad(n, t) {\n  return getRad$1(t > 0 ? n[0] : n[1], t > 0 ? n[1] : n[0]);\n}\nfunction resetClientRect() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction getClientRect(n, t) {\n  var e, o = 0, R = 0, N = 0, M = 0;\n  if (n)\n    if (n === document.body || n === document.documentElement) {\n      N = window.innerWidth, M = window.innerHeight;\n      var D = getBodyScrollPos();\n      e = [-D[0], -D[1]], o = e[0], R = e[1];\n    } else {\n      var L = n.getBoundingClientRect();\n      o = L.left, R = L.top, N = L.width, M = L.height;\n    }\n  var B = {\n    left: o,\n    top: R,\n    width: N,\n    height: M,\n    right: o + N,\n    bottom: R + M\n  };\n  return n && t && (B.clientLeft = n.clientLeft, B.clientTop = n.clientTop, B.clientWidth = n.clientWidth, B.clientHeight = n.clientHeight, B.scrollWidth = n.scrollWidth, B.scrollHeight = n.scrollHeight, B.overflow = getComputedStyle$2(n).overflow !== \"visible\"), B;\n}\nfunction getDirection(n) {\n  if (!!n) {\n    var t = n.getAttribute(\"data-direction\");\n    if (!!t) {\n      var e = [0, 0];\n      return t.indexOf(\"w\") > -1 && (e[0] = -1), t.indexOf(\"e\") > -1 && (e[0] = 1), t.indexOf(\"n\") > -1 && (e[1] = -1), t.indexOf(\"s\") > -1 && (e[1] = 1), e;\n    }\n  }\n}\nfunction getAbsolutePoses(n, t) {\n  return [plus(t, n[0]), plus(t, n[1]), plus(t, n[2]), plus(t, n[3])];\n}\nfunction getAbsolutePosesByState(n) {\n  var t = n.left, e = n.top, o = n.pos1, R = n.pos2, N = n.pos3, M = n.pos4;\n  return getAbsolutePoses([o, R, N, M], [t, e]);\n}\nfunction roundSign(n) {\n  return Math.round(n % 1 === -0.5 ? n - 1 : n);\n}\nfunction unset(n, t) {\n  var e;\n  (e = n[t]) === null || e === void 0 || e.unset(), n[t] = null;\n}\nfunction fillCSSObject(n) {\n  return {\n    style: n,\n    cssText: getKeys(n).map(function(t) {\n      return \"\".concat(t, \": \").concat(n[t], \";\");\n    }).join(\"\")\n  };\n}\nfunction fillAfterTransform(n, t) {\n  var e = t.afterTransform || t.transform;\n  return __assign$2(__assign$2({}, fillCSSObject(__assign$2(__assign$2(__assign$2({}, n.style), t.style), {\n    transform: e\n  }))), {\n    afterTransform: e,\n    transform: n.transform\n  });\n}\nfunction fillParams(n, t, e, o) {\n  var R = t.datas;\n  R.datas || (R.datas = {});\n  var N = __assign$2(__assign$2({}, e), {\n    target: n.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: n,\n    moveable: n,\n    datas: R.datas\n  });\n  return R.isStartEvent ? o || (R.lastEvent = N) : R.isStartEvent = !0, N;\n}\nfunction fillEndParams(n, t, e) {\n  var o = t.datas, R = \"isDrag\" in e ? e.isDrag : t.isDrag;\n  return o.datas || (o.datas = {}), __assign$2(__assign$2({\n    isDrag: R\n  }, e), {\n    moveable: n,\n    target: n.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: n,\n    lastEvent: o.lastEvent,\n    isDouble: t.isDouble,\n    datas: o.datas\n  });\n}\nfunction catchEvent(n, t, e) {\n  n._emitter.on(t, e);\n}\nfunction triggerEvent(n, t, e, o) {\n  return n.triggerEvent(t, e, o);\n}\nfunction getComputedStyle$2(n, t) {\n  return window.getComputedStyle(n, t);\n}\nfunction filterAbles(n, t, e) {\n  var o = {}, R = {};\n  return n.filter(function(N) {\n    var M = N.name;\n    if (o[M] || !t.some(function(D) {\n      return N[D];\n    }))\n      return !1;\n    if (!e && N.ableGroup) {\n      if (R[N.ableGroup])\n        return !1;\n      R[N.ableGroup] = !0;\n    }\n    return o[M] = !0, !0;\n  });\n}\nfunction equals(n, t) {\n  return n === t || n == null && t == null;\n}\nfunction selectValue() {\n  for (var n = [], t = 0; t < arguments.length; t++)\n    n[t] = arguments[t];\n  for (var e = n.length - 1, o = 0; o < e; ++o) {\n    var R = n[o];\n    if (!isUndefined(R))\n      return R;\n  }\n  return n[e];\n}\nfunction groupBy(n, t) {\n  var e = [], o = [];\n  return n.forEach(function(R, N) {\n    var M = t(R, N, n), D = o.indexOf(M), L = e[D] || [];\n    D === -1 && (o.push(M), e.push(L)), L.push(R);\n  }), e;\n}\nfunction groupByMap(n, t) {\n  var e = [], o = {};\n  return n.forEach(function(R, N) {\n    var M = t(R, N, n), D = o[M];\n    D || (D = [], o[M] = D, e.push(D)), D.push(R);\n  }), e;\n}\nfunction flat(n) {\n  return n.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction maxOffset() {\n  for (var n = [], t = 0; t < arguments.length; t++)\n    n[t] = arguments[t];\n  return n.sort(function(e, o) {\n    return Math.abs(o) - Math.abs(e);\n  }), n[0];\n}\nfunction calculateInversePosition(n, t, e) {\n  return calculate(invert(n, e), convertPositionMatrix(t, e), e);\n}\nfunction convertDragDist(n, t) {\n  var e, o = n.is3d, R = n.rootMatrix, N = o ? 4 : 3;\n  return e = calculateInversePosition(R, [t.distX, t.distY], N), t.distX = e[0], t.distY = e[1], t;\n}\nfunction calculatePadding(n, t, e, o, R) {\n  return minus(calculatePosition(n, plus(e, t), R), o);\n}\nfunction convertCSSSize(n, t, e) {\n  return e ? \"\".concat(n / t * 100, \"%\") : \"\".concat(n, \"px\");\n}\nfunction getTinyDist(n) {\n  return Math.abs(n) <= TINY_NUM ? 0 : n;\n}\nfunction getDirectionCondition(n, t) {\n  return t === void 0 && (t = [n]), function(e, o) {\n    if (o.isRequest)\n      return t.some(function(N) {\n        return o.requestAble === N;\n      }) ? o.parentDirection : !1;\n    var R = o.inputEvent.target;\n    return hasClass(R, prefix(\"direction\")) && (!n || hasClass(R, prefix(n)));\n  };\n}\nfunction invertObject(n) {\n  var t = {};\n  for (var e in n)\n    t[n[e]] = e;\n  return t;\n}\nfunction convertTransformInfo(n, t) {\n  var e = n.slice(0, t < 0 ? void 0 : t), o = n.slice(0, t < 0 ? void 0 : t + 1), R = n[t] || \"\", N = t < 0 ? [] : n.slice(t), M = t < 0 ? [] : n.slice(t + 1), D = parse(e), L = parse(o), B = parse([R]), $ = parse(N), k = parse(M), U = toMat(D), z = toMat(L), X = toMat($), V = toMat(k), W = multiply(U, X, 4);\n  return {\n    transforms: n,\n    beforeFunctionMatrix: U,\n    beforeFunctionMatrix2: z,\n    targetFunctionMatrix: toMat(B),\n    afterFunctionMatrix: X,\n    afterFunctionMatrix2: V,\n    allFunctionMatrix: W,\n    beforeFunctions: D,\n    beforeFunctions2: L,\n    targetFunction: B[0],\n    afterFunctions: $,\n    afterFunctions2: k,\n    beforeFunctionTexts: e,\n    beforeFunctionTexts2: o,\n    targetFunctionText: R,\n    afterFunctionTexts: N,\n    afterFunctionTexts2: M\n  };\n}\nfunction isArrayFormat(n) {\n  return !n || !isObject$2(n) || n instanceof Element ? !1 : isArray(n) || \"length\" in n;\n}\nfunction getRefTarget(n, t) {\n  return n ? isString(n) ? t ? document.querySelector(n) : n : isFunction$3(n) ? n() : \"current\" in n ? n.current : n : null;\n}\nfunction getRefTargets(n, t) {\n  if (!n)\n    return [];\n  var e = isArrayFormat(n) ? [].slice.call(n) : [n];\n  return e.reduce(function(o, R) {\n    return isString(R) && t ? __spreadArray(__spreadArray([], o, !0), [].slice.call(document.querySelectorAll(R)), !0) : (o.push(getRefTarget(R, t)), o);\n  }, []);\n}\nfunction getElementTargets(n, t) {\n  var e = [];\n  return n.forEach(function(o) {\n    if (!!o) {\n      if (isString(o)) {\n        t[o] && e.push.apply(e, t[o]);\n        return;\n      }\n      e.push(o);\n    }\n  }), e;\n}\nfunction getAbsoluteRotation(n, t, e) {\n  var o = getRad$1(n, t) / Math.PI * 180;\n  return o = e >= 0 ? o : 180 - o, o = o >= 0 ? o : 360 + o, o;\n}\nfunction getDragDistByState(n, t) {\n  var e = n.rootMatrix, o = n.is3d, R = o ? 4 : 3, N = invert(e, R);\n  return o || (N = convertDimension(N, 3, 4)), N[12] = 0, N[13] = 0, N[14] = 0, calculateMatrixDist(N, t);\n}\nfunction getSizeDistByDist(n, t, e, o, R) {\n  var N = n[0], M = n[1], D = 0, L = 0;\n  if (R && N && M) {\n    var B = getRad$1([0, 0], t), $ = getRad$1([0, 0], o), k = getDistSize(t), U = Math.cos(B - $) * k;\n    if (!o[0])\n      L = U, D = L * e;\n    else if (!o[1])\n      D = U, L = D / e;\n    else {\n      var z = o[0] * 2 * N, X = o[1] * 2 * M, V = getDistSize([z + t[0], X + t[1]]) - getDistSize([z, X]), W = getRad$1([0, 0], [e, 1]);\n      D = Math.cos(W) * V, L = Math.sin(W) * V;\n    }\n  } else\n    D = o[0] * t[0], L = o[1] * t[1];\n  return [D, L];\n}\nfunction getOffsetSizeDist(n, t, e, o) {\n  var R, N = e.ratio, M = e.startOffsetWidth, D = e.startOffsetHeight, L = 0, B = 0, $ = o.distX, k = o.distY, U = o.parentDistance, z = o.parentDist, X = o.parentScale, V = e.fixedDirection, W = [0, 1].map(function(J) {\n    return Math.abs(n[J] - V[J]);\n  }), Y = [0, 1].map(function(J) {\n    var rt = W[J];\n    return rt !== 0 && (rt = 2 / rt), rt;\n  });\n  if (z)\n    L = z[0], B = z[1], t && (L ? B || (B = L / N) : L = B * N);\n  else if (X)\n    L = (X[0] - 1) * M, B = (X[1] - 1) * D;\n  else if (U) {\n    var q = M * W[0], Z = D * W[1], K = getDistSize([q, Z]);\n    L = U / K * q * Y[0], B = U / K * Z * Y[1];\n  } else {\n    var Q = getDragDist({\n      datas: e,\n      distX: $,\n      distY: k\n    });\n    Q = Y.map(function(J, rt) {\n      return Q[rt] * J;\n    }), R = getSizeDistByDist([M, D], Q, N, n, t), L = R[0], B = R[1];\n  }\n  return {\n    distWidth: L,\n    distHeight: B\n  };\n}\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function() {\n    return !0;\n  },\n  pinchStart: function(n, t) {\n    var e = t.datas, o = t.targets, R = t.angle, N = t.originalDatas, M = n.props, D = M.pinchable, L = M.ables;\n    if (!D)\n      return !1;\n    var B = \"onPinch\".concat(o ? \"Group\" : \"\", \"Start\"), $ = \"drag\".concat(o ? \"Group\" : \"\", \"ControlStart\"), k = (D === !0 ? n.controlAbles : L.filter(function(V) {\n      return D.indexOf(V.name) > -1;\n    })).filter(function(V) {\n      return V.canPinch && V[$];\n    }), U = fillParams(n, t, {});\n    o && (U.targets = o);\n    var z = triggerEvent(n, B, U);\n    e.isPinch = z !== !1, e.ables = k;\n    var X = e.isPinch;\n    return X ? (k.forEach(function(V) {\n      if (N[V.name] = N[V.name] || {}, !!V[$]) {\n        var W = __assign$2(__assign$2({}, t), {\n          datas: N[V.name],\n          parentRotate: R,\n          isPinch: !0\n        });\n        V[$](n, W);\n      }\n    }), n.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: [0, 0]\n    }, X) : !1;\n  },\n  pinch: function(n, t) {\n    var e = t.datas, o = t.scale, R = t.distance, N = t.originalDatas, M = t.inputEvent, D = t.targets, L = t.angle;\n    if (!!e.isPinch) {\n      var B = R * (1 - 1 / o), $ = fillParams(n, t, {});\n      D && ($.targets = D);\n      var k = \"onPinch\".concat(D ? \"Group\" : \"\");\n      triggerEvent(n, k, $);\n      var U = e.ables, z = \"drag\".concat(D ? \"Group\" : \"\", \"Control\");\n      return U.forEach(function(X) {\n        !X[z] || X[z](n, __assign$2(__assign$2({}, t), {\n          datas: N[X.name],\n          inputEvent: M,\n          parentDistance: B,\n          parentRotate: L,\n          isPinch: !0\n        }));\n      }), $;\n    }\n  },\n  pinchEnd: function(n, t) {\n    var e = t.datas, o = t.isPinch, R = t.inputEvent, N = t.targets, M = t.originalDatas;\n    if (!!e.isPinch) {\n      var D = \"onPinch\".concat(N ? \"Group\" : \"\", \"End\"), L = fillEndParams(n, t, {\n        isDrag: o\n      });\n      N && (L.targets = N), triggerEvent(n, D, L);\n      var B = e.ables, $ = \"drag\".concat(N ? \"Group\" : \"\", \"ControlEnd\");\n      return B.forEach(function(k) {\n        !k[$] || k[$](n, __assign$2(__assign$2({}, t), {\n          isDrag: o,\n          datas: M[k.name],\n          inputEvent: R,\n          isPinch: !0\n        }));\n      }), o;\n    }\n  },\n  pinchGroupStart: function(n, t) {\n    return this.pinchStart(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  pinchGroup: function(n, t) {\n    return this.pinch(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  pinchGroupEnd: function(n, t) {\n    return this.pinchEnd(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  }\n});\nfunction fillChildEvents(n, t, e) {\n  var o = e.originalDatas;\n  o.groupable = o.groupable || {};\n  var R = o.groupable;\n  R.childDatas = R.childDatas || [];\n  var N = R.childDatas;\n  return n.moveables.map(function(M, D) {\n    return N[D] = N[D] || {}, N[D][t] = N[D][t] || {}, __assign$2(__assign$2({}, e), {\n      datas: N[D][t],\n      originalDatas: N[D]\n    });\n  });\n}\nfunction triggerChildGesto(n, t, e, o, R, N, M) {\n  var D = !!e.match(/Start$/g), L = !!e.match(/End$/g), B = R.isPinch, $ = R.datas, k = fillChildEvents(n, t.name, R), U = n.moveables, z = k.map(function(X, V) {\n    var W = U[V], Y = W.state, q = Y.gestos, Z = X;\n    if (D)\n      Z = new CustomGesto(M).dragStart(o, X);\n    else {\n      if (q[M] || (q[M] = $.childGestos[V]), !q[M])\n        return;\n      Z = setCustomDrag(X, Y, o, B, N, M);\n    }\n    var K = t[e](W, __assign$2(__assign$2({}, Z), {\n      parentFlag: !0\n    }));\n    return L && (q[M] = null), K;\n  });\n  return D && ($.childGestos = U.map(function(X) {\n    return X.state.gestos[M];\n  })), z;\n}\nfunction triggerChildAbles(n, t, e, o, R, N) {\n  R === void 0 && (R = function($, k) {\n    return k;\n  });\n  var M = !!e.match(/End$/g), D = fillChildEvents(n, t.name, o), L = n.moveables, B = D.map(function($, k) {\n    var U = L[k], z = $;\n    z = R(U, $);\n    var X = t[e](U, __assign$2(__assign$2({}, z), {\n      parentFlag: !0\n    }));\n    return X && N && N(U, $, X, k), M && (U.state.gestos = {}), X;\n  });\n  return B;\n}\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"], HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"], VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction hasGuidelines(n, t) {\n  var e = n.props, o = e.snappable, R = e.bounds, N = e.innerBounds, M = e.verticalGuidelines, D = e.horizontalGuidelines, L = e.snapGridWidth, B = e.snapGridHeight, $ = n.state, k = $.guidelines, U = $.enableSnap;\n  return !o || !U || t && o !== !0 && o.indexOf(t) < 0 ? !1 : !!(L || B || R || N || k && k.length || M && M.length || D && D.length);\n}\nfunction getSnapDirections(n) {\n  return n === !1 ? {} : n === !0 || !n ? {\n    left: !0,\n    right: !0,\n    top: !0,\n    bottom: !0\n  } : n;\n}\nfunction mapSnapDirectionPoses(n, t) {\n  var e = getSnapDirections(n), o = {};\n  for (var R in e)\n    R in t && e[R] && (o[R] = t[R]);\n  return o;\n}\nfunction splitSnapDirectionPoses(n, t) {\n  var e = mapSnapDirectionPoses(n, t), o = HORIZONTAL_NAMES.filter(function(N) {\n    return N in e;\n  }), R = VERTICAL_NAMES.filter(function(N) {\n    return N in e;\n  });\n  return {\n    horizontal: o.map(function(N) {\n      return e[N];\n    }),\n    vertical: R.map(function(N) {\n      return e[N];\n    })\n  };\n}\nfunction getGapGuidelines(n, t, e) {\n  var o = n.state.elementRects, R = [];\n  return [[\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(N) {\n    var M = N[0], D = N[1], L = N[2], B = t[D.start], $ = t[D.end], k = t[D.center], U = t[L.start], z = t[L.end];\n    function X(Y) {\n      var q = Y.rect;\n      return q[D.end] < B + e ? B - q[D.end] : $ - e < q[D.start] ? q[D.start] - $ : -1;\n    }\n    var V = o.filter(function(Y) {\n      var q = Y.rect;\n      return q[L.start] > z || q[L.end] < U ? !1 : X(Y) > 0;\n    }).sort(function(Y, q) {\n      return X(Y) - X(q);\n    }), W = [];\n    V.forEach(function(Y) {\n      V.forEach(function(q) {\n        if (Y !== q) {\n          var Z = Y.rect, K = q.rect, Q = Z[L.start], J = Z[L.end], rt = K[L.start], tt = K[L.end];\n          Q > tt || rt > J || W.push([Y, q]);\n        }\n      });\n    }), W.forEach(function(Y) {\n      var q = Y[0], Z = Y[1], K = q.rect, Q = Z.rect, J = K[D.start], rt = K[D.end], tt = Q[D.start], nt = Q[D.end], st = 0, ut = 0, ct = !1, dt = !1, Et = !1;\n      if (rt <= B && $ <= tt) {\n        if (dt = !0, st = (tt - rt - ($ - B)) / 2, ut = rt + st + ($ - B) / 2, Math.abs(ut - k) > e)\n          return;\n      } else if (rt < tt && nt < B + e) {\n        if (ct = !0, st = tt - rt, ut = nt + st, Math.abs(ut - B) > e)\n          return;\n      } else if (rt < tt && $ - e < J) {\n        if (Et = !0, st = tt - rt, ut = J - st, Math.abs(ut - $) > e)\n          return;\n      } else\n        return;\n      !st || R.push({\n        type: M,\n        pos: M === \"vertical\" ? [ut, 0] : [0, ut],\n        element: Z.element,\n        size: 0,\n        className: Z.className,\n        isStart: ct,\n        isCenter: dt,\n        isEnd: Et,\n        gap: st,\n        hide: !0,\n        gapRects: [q, Z]\n      });\n    });\n  }), R;\n}\nfunction getDefaultGuidelines(n, t, e, o, R, N, M) {\n  R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  });\n  var D = [], L = M.left, B = M.top, $ = M.bottom, k = M.right, U = e + k - L, z = o + $ - B;\n  return n && n.forEach(function(X) {\n    var V = isObject$2(X) ? X : {\n      pos: X\n    };\n    D.push({\n      type: \"horizontal\",\n      pos: [L, throttle(V.pos - N + B, 0.1)],\n      size: U,\n      className: V.className\n    });\n  }), t && t.forEach(function(X) {\n    var V = isObject$2(X) ? X : {\n      pos: X\n    };\n    D.push({\n      type: \"vertical\",\n      pos: [throttle(V.pos - R + L, 0.1), B],\n      size: z,\n      className: V.className\n    });\n  }), D;\n}\nfunction calculateContainerPos(n, t, e) {\n  var o = calculatePosition(n, [t.clientLeft, t.clientTop], e);\n  return [t.left + o[0], t.top + o[1]];\n}\nfunction getSnapElementRects(n, t) {\n  if (!t.length)\n    return [];\n  var e = n.state, o = e.containerClientRect, R = e.targetClientRect, N = R.top, M = R.left, D = e.rootMatrix, L = e.is3d, B = L ? 4 : 3, $ = calculateContainerPos(D, o, B), k = $[0], U = $[1], z = getAbsolutePosesByState(e), X = getMinMaxs(z), V = X.minX, W = X.minY, Y = minus([V, W], calculateInversePosition(D, [M - k, N - U], B)).map(function(K) {\n    return roundSign(K);\n  }), q = Y[0], Z = Y[1];\n  return t.map(function(K) {\n    var Q = K.element.getBoundingClientRect(), J = Q.left - k, rt = Q.top - U, tt = rt + Q.height, nt = J + Q.width, st = calculateInversePosition(D, [J, rt], B), ut = st[0], ct = st[1], dt = calculateInversePosition(D, [nt, tt], B), Et = dt[0], vt = dt[1];\n    return __assign$2(__assign$2({}, K), {\n      rect: {\n        left: ut + q,\n        right: Et + q,\n        top: ct + Z,\n        bottom: vt + Z,\n        center: (ut + Et) / 2 + q,\n        middle: (ct + vt) / 2 + Z\n      }\n    });\n  });\n}\nfunction getElementGuidelines(n) {\n  var t = n.state, e = n.props.elementGuidelines, o = e === void 0 ? [] : e;\n  if (!o.length)\n    return t.elementRects = [], [];\n  var R = (t.elementRects || []).filter(function(U) {\n    return !U.refresh;\n  }), N = o.map(function(U) {\n    return isObject$2(U) && \"element\" in U ? U : {\n      element: getRefTarget(U, !0)\n    };\n  }).filter(function(U) {\n    return U.element;\n  }), M = diff(R.map(function(U) {\n    return U.element;\n  }), N.map(function(U) {\n    return U.element;\n  })), D = M.maintained, L = M.added, B = [];\n  D.forEach(function(U) {\n    var z = U[0], X = U[1];\n    B[X] = R[z];\n  }), getSnapElementRects(n, L.map(function(U) {\n    return N[U];\n  })).map(function(U, z) {\n    B[L[z]] = U;\n  }), t.elementRects = B;\n  var $ = getSnapDirections(n.props.elementSnapDirections), k = [];\n  return B.forEach(function(U) {\n    var z = U.element, X = U.top, V = X === void 0 ? $.top : X, W = U.left, Y = W === void 0 ? $.left : W, q = U.right, Z = q === void 0 ? $.right : q, K = U.bottom, Q = K === void 0 ? $.bottom : K, J = U.center, rt = J === void 0 ? $.center : J, tt = U.middle, nt = tt === void 0 ? $.middle : tt, st = U.className, ut = U.rect, ct = splitSnapDirectionPoses({\n      top: V,\n      right: Z,\n      left: Y,\n      bottom: Q,\n      center: rt,\n      middle: nt\n    }, ut), dt = ct.horizontal, Et = ct.vertical, vt = ut.top, _t = ut.left, St = ut.right - _t, Ft = ut.bottom - vt, mt = [St, Ft];\n    Et.forEach(function(ht) {\n      k.push({\n        type: \"vertical\",\n        element: z,\n        pos: [throttle(ht, 0.1), vt],\n        size: Ft,\n        sizes: mt,\n        className: st,\n        elementRect: U\n      });\n    }), dt.forEach(function(ht) {\n      k.push({\n        type: \"horizontal\",\n        element: z,\n        pos: [_t, throttle(ht, 0.1)],\n        size: St,\n        sizes: mt,\n        className: st,\n        elementRect: U\n      });\n    });\n  }), k;\n}\nfunction getTotalGuidelines(n) {\n  var t = n.state, e = t.snapOffset, o = t.containerClientRect, R = o.overflow, N = o.scrollHeight, M = o.scrollWidth, D = o.clientHeight, L = o.clientWidth, B = o.clientLeft, $ = o.clientTop, k = n.props, U = k.snapGap, z = U === void 0 ? !0 : U, X = k.verticalGuidelines, V = k.horizontalGuidelines, W = k.snapThreshold, Y = W === void 0 ? 5 : W, q = k.snapGridWidth, Z = q === void 0 ? 0 : q, K = k.snapGridHeight, Q = K === void 0 ? 0 : K, J = getElementGuidelines(n), rt = __spreadArray([], J, !0);\n  if (z) {\n    var tt = getRect(getAbsolutePosesByState(n.state)), nt = tt.top, st = tt.left, ut = tt.bottom, ct = tt.right;\n    rt.push.apply(rt, getGapGuidelines(n, {\n      top: nt,\n      left: st,\n      bottom: ut,\n      right: ct,\n      center: (st + ct) / 2,\n      middle: (nt + ut) / 2\n    }, Y));\n  }\n  return rt.push.apply(rt, getGridGuidelines(Z, Q, R ? M : L, R ? N : D, B, $)), rt.push.apply(rt, getDefaultGuidelines(V || !1, X || !1, R ? M : L, R ? N : D, B, $, e)), rt;\n}\nfunction getGridGuidelines(n, t, e, o, R, N) {\n  R === void 0 && (R = 0), N === void 0 && (N = 0);\n  var M = [];\n  if (t)\n    for (var D = 0; D <= o; D += t)\n      M.push({\n        type: \"horizontal\",\n        pos: [0, throttle(D - N, 0.1)],\n        size: e,\n        hide: !0\n      });\n  if (n)\n    for (var D = 0; D <= e; D += n)\n      M.push({\n        type: \"vertical\",\n        pos: [throttle(D - R, 0.1), 0],\n        size: o,\n        hide: !0\n      });\n  return M;\n}\nfunction solveLineConstants(n) {\n  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];\n  Math.abs(o) < TINY_NUM$1 && (o = 0), Math.abs(R) < TINY_NUM$1 && (R = 0);\n  var N = 0, M = 0, D = 0;\n  return o ? R ? (N = -R / o, M = 1, D = N * t[0] - t[1]) : (M = 1, D = -t[1]) : (N = -1, D = t[0]), [N, M, D].map(function(L) {\n    return throttle(L, TINY_NUM$1);\n  });\n}\nfunction checkMoveableSnapPoses(n, t, e, o) {\n  var R = n.props, N = selectValue(o, R.snapThreshold, 5);\n  return checkSnapPoses(n.state.guidelines, t, e, N);\n}\nfunction checkSnapPoses(n, t, e, o) {\n  return {\n    vertical: checkSnap(n, \"vertical\", t, o),\n    horizontal: checkSnap(n, \"horizontal\", e, o)\n  };\n}\nfunction checkSnapKeepRatio(n, t, e) {\n  var o = e[0], R = e[1], N = t[0], M = t[1], D = minus(e, t), L = D[0], B = D[1], $ = B > 0, k = L > 0;\n  L = getTinyDist(L), B = getTinyDist(B);\n  var U = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, z = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (L === 0 && B === 0)\n    return {\n      vertical: U,\n      horizontal: z\n    };\n  var X = checkMoveableSnapPoses(n, L ? [o] : [], B ? [R] : []), V = X.vertical, W = X.horizontal;\n  V.posInfos.filter(function(Et) {\n    var vt = Et.pos;\n    return k ? vt >= N : vt <= N;\n  }), W.posInfos.filter(function(Et) {\n    var vt = Et.pos;\n    return $ ? vt >= M : vt <= M;\n  }), V.isSnap = V.posInfos.length > 0, W.isSnap = W.posInfos.length > 0;\n  var Y = getNearestSnapGuidelineInfo(V), q = Y.isSnap, Z = Y.guideline, K = getNearestSnapGuidelineInfo(W), Q = K.isSnap, J = K.guideline, rt = Q ? J.pos[1] : 0, tt = q ? Z.pos[0] : 0;\n  if (L === 0)\n    Q && (z.isSnap = !0, z.pos = J.pos[1], z.offset = R - z.pos);\n  else if (B === 0)\n    q && (U.isSnap = !0, U.pos = tt, U.offset = o - tt);\n  else {\n    var nt = B / L, st = e[1] - nt * o, ut = 0, ct = 0, dt = !1;\n    q ? (ct = tt, ut = nt * ct + st, dt = !0) : Q && (ut = rt, ct = (ut - st) / nt, dt = !0), dt && (U.isSnap = !0, U.pos = ct, U.offset = o - ct, z.isSnap = !0, z.pos = ut, z.offset = R - ut);\n  }\n  return {\n    vertical: U,\n    horizontal: z\n  };\n}\nfunction checkSnaps(n, t, e) {\n  var o = splitSnapDirectionPoses(n.props.snapDirections, t);\n  return checkMoveableSnapPoses(n, o.vertical, o.horizontal, e);\n}\nfunction getNearestSnapGuidelineInfo(n) {\n  var t = n.isSnap;\n  if (!t)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  var e = n.posInfos[0], o = e.guidelineInfos[0], R = o.offset, N = o.dist, M = o.guideline;\n  return {\n    isSnap: t,\n    offset: R,\n    dist: N,\n    pos: e.pos,\n    guideline: M\n  };\n}\nfunction checkSnap(n, t, e, o) {\n  if (!n || !n.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      posInfos: []\n    };\n  var R = t === \"vertical\", N = R ? 0 : 1, M = e.map(function(L, B) {\n    var $ = n.map(function(k) {\n      var U = k.pos, z = L - U[N];\n      return {\n        offset: z,\n        dist: Math.abs(z),\n        guideline: k\n      };\n    }).filter(function(k) {\n      var U = k.guideline, z = k.dist, X = U.type;\n      return !(X !== t || z > o);\n    }).sort(function(k, U) {\n      return k.dist - U.dist;\n    });\n    return {\n      pos: L,\n      index: B,\n      guidelineInfos: $\n    };\n  }).filter(function(L) {\n    return L.guidelineInfos.length > 0;\n  }).sort(function(L, B) {\n    return L.guidelineInfos[0].dist - B.guidelineInfos[0].dist;\n  }), D = M.length > 0;\n  return {\n    isSnap: D,\n    index: D ? M[0].index : -1,\n    posInfos: M\n  };\n}\nfunction getSnapInfosByDirection(n, t, e) {\n  var o = [];\n  if (e[0] && e[1])\n    o = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(M) {\n      return getPosByDirection(t, M);\n    });\n  else if (!e[0] && !e[1])\n    for (var R = [t[0], t[1], t[3], t[2], t[0]], N = 0; N < 4; ++N)\n      o.push(R[N]), o.push([(R[N][0] + R[N + 1][0]) / 2, (R[N][1] + R[N + 1][1]) / 2]);\n  else\n    n.props.keepRatio ? o = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(M) {\n      return getPosByDirection(t, M);\n    }) : (o = getPosesByDirection(t, e), o.length > 1 && o.push([(o[0][0] + o[1][0]) / 2, (o[0][1] + o[1][1]) / 2]));\n  return checkMoveableSnapPoses(n, o.map(function(M) {\n    return M[0];\n  }), o.map(function(M) {\n    return M[1];\n  }), 1);\n}\nfunction checkSnapBoundPriority(n, t) {\n  var e = Math.abs(n.offset), o = Math.abs(t.offset);\n  return n.isBound && t.isBound ? o - e : n.isBound ? -1 : t.isBound ? 1 : n.isSnap && t.isSnap ? o - e : n.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : o < TINY_NUM ? -1 : e - o;\n}\nfunction getNearOffsetInfo(n, t) {\n  return n.slice().sort(function(e, o) {\n    var R = e.sign[t], N = o.sign[t], M = e.offset[t], D = o.offset[t];\n    if (R) {\n      if (!N)\n        return -1;\n    } else\n      return 1;\n    return checkSnapBoundPriority({\n      isBound: e.isBound,\n      isSnap: e.isSnap,\n      offset: M\n    }, {\n      isBound: o.isBound,\n      isSnap: o.isSnap,\n      offset: D\n    });\n  })[0];\n}\nfunction getCheckSnapDirections(n, t, e) {\n  var o = [];\n  if (e)\n    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? o.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : o.push([t, [n[0], -n[1]]], [t, [-n[0], n[1]]]), o.push([t, n]);\n  else if (n[0] && n[1] || !n[0] && !n[1]) {\n    var R = n[0] ? n : [1, 1];\n    [1, -1].forEach(function(M) {\n      [1, -1].forEach(function(D) {\n        var L = [M * R[0], D * R[1]];\n        t[0] === L[0] && t[1] === L[1] || o.push([t, L]);\n      });\n    });\n  } else if (n[0]) {\n    var N = Math.abs(t[0]) === 1 ? [1] : [1, -1];\n    N.forEach(function(M) {\n      o.push([[t[0], -1], [M * n[0], -1]], [[t[0], 0], [M * n[0], 0]], [[t[0], 1], [M * n[0], 1]]);\n    });\n  } else if (n[1]) {\n    var N = Math.abs(t[1]) === 1 ? [1] : [1, -1];\n    N.forEach(function(D) {\n      o.push([[-1, t[1]], [-1, D * n[1]]], [[0, t[1]], [0, D * n[1]]], [[1, t[1]], [1, D * n[1]]]);\n    });\n  }\n  return o;\n}\nfunction isStartLine(n, t) {\n  var e = average([t[0][0], t[1][0]]), o = average([t[0][1], t[1][1]]);\n  return {\n    vertical: e <= n[0],\n    horizontal: o <= n[1]\n  };\n}\nfunction hitTestLine(n, t) {\n  var e = t[0], o = t[1], R = o[0] - e[0], N = o[1] - e[1];\n  Math.abs(R) < TINY_NUM && (R = 0), Math.abs(N) < TINY_NUM && (N = 0);\n  var M, D;\n  if (!R)\n    M = e[0], D = n[0];\n  else if (!N)\n    M = e[1], D = n[1];\n  else {\n    var L = N / R;\n    M = L * (n[0] - e[0]) + e[1], D = n[1];\n  }\n  return M - D;\n}\nfunction isSameStartLine(n, t, e, o) {\n  return o === void 0 && (o = TINY_NUM), n.every(function(R) {\n    var N = hitTestLine(R, t), M = N <= 0;\n    return M === e || Math.abs(N) <= o;\n  });\n}\nfunction checkInnerBoundDot(n, t, e, o, R) {\n  return R === void 0 && (R = 0), o && t - R <= n || !o && n <= e + R ? {\n    isBound: !0,\n    offset: o ? t - n : e - n\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction checkInnerBound(n, t) {\n  var e = t.line, o = t.centerSign, R = t.verticalSign, N = t.horizontalSign, M = t.lineConstants, D = n.props.innerBounds;\n  if (!D)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var L = D.left, B = D.top, $ = D.width, k = D.height, U = [[L, B], [L, B + k]], z = [[L, B], [L + $, B]], X = [[L + $, B], [L + $, B + k]], V = [[L, B + k], [L + $, B + k]];\n  if (isSameStartLine([[L, B], [L + $, B], [L, B + k], [L + $, B + k]], e, o))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var W = checkLineBoundCollision(e, M, z, R), Y = checkLineBoundCollision(e, M, V, R), q = checkLineBoundCollision(e, M, U, N), Z = checkLineBoundCollision(e, M, X, N), K = W.isBound && Y.isBound, Q = W.isBound || Y.isBound, J = q.isBound && Z.isBound, rt = q.isBound || Z.isBound, tt = maxOffset(W.offset, Y.offset), nt = maxOffset(q.offset, Z.offset), st = [0, 0], ut = !1, ct = !1;\n  return Math.abs(nt) < Math.abs(tt) ? (st = [tt, 0], ut = Q, ct = K) : (st = [0, nt], ut = rt, ct = J), {\n    isAllBound: ct,\n    isVerticalBound: Q,\n    isHorizontalBound: rt,\n    isBound: ut,\n    offset: st\n  };\n}\nfunction checkLineBoundCollision(n, t, e, o, R, N) {\n  var M = t[0], D = t[1], L = n[0], B = e[0], $ = e[1], k = getTinyDist($[1] - B[1]), U = getTinyDist($[0] - B[0]), z = D, X = M, V = -M / D;\n  if (U) {\n    if (!k) {\n      if (N && !z)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (X) {\n        var Z = (B[1] - L[1]) / V + L[0];\n        return checkInnerBoundDot(Z, B[0], $[0], o, R);\n      } else {\n        var Y = B[1] - L[1], q = Math.abs(Y) <= (R || 0);\n        return {\n          isBound: q,\n          offset: q ? Y : 0\n        };\n      }\n    }\n  } else {\n    if (N && !X)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (z) {\n      var W = V * (B[0] - L[0]) + L[1];\n      return checkInnerBoundDot(W, B[1], $[1], o, R);\n    } else {\n      var Y = B[0] - L[0], q = Math.abs(Y) <= (R || 0);\n      return {\n        isBound: q,\n        offset: q ? Y : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction getInnerBoundInfo(n, t, e) {\n  return t.map(function(o) {\n    var R = checkInnerBound(n, o), N = R.isBound, M = R.offset, D = R.isVerticalBound, L = R.isHorizontalBound, B = o.multiple, $ = getDragDist({\n      datas: e,\n      distX: M[0],\n      distY: M[1]\n    }).map(function(k, U) {\n      return k * (B[U] ? 2 / B[U] : 0);\n    });\n    return {\n      sign: B,\n      isBound: N,\n      isVerticalBound: D,\n      isHorizontalBound: L,\n      isSnap: !1,\n      offset: $\n    };\n  });\n}\nfunction getInnerBoundDragInfo(n, t, e) {\n  var o, R = getCheckInnerBoundLineInfos(n, t, [0, 0], !1).map(function(U) {\n    return __assign$2(__assign$2({}, U), {\n      multiple: U.multiple.map(function(z) {\n        return Math.abs(z) * 2;\n      })\n    });\n  }), N = getInnerBoundInfo(n, R, e), M = getNearOffsetInfo(N, 0), D = getNearOffsetInfo(N, 1), L = 0, B = 0, $ = M.isVerticalBound || D.isVerticalBound, k = M.isHorizontalBound || D.isHorizontalBound;\n  return ($ || k) && (o = getInverseDragDist({\n    datas: e,\n    distX: -M.offset[0],\n    distY: -D.offset[1]\n  }), L = o[0], B = o[1]), {\n    vertical: {\n      isBound: $,\n      offset: L\n    },\n    horizontal: {\n      isBound: k,\n      offset: B\n    }\n  };\n}\nfunction getCheckSnapLineDirections(n, t) {\n  var e = [], o = n[0], R = n[1];\n  return o && R ? e.push([[0, R * 2], n, [-o, R]], [[o * 2, 0], n, [o, -R]]) : o ? (e.push([[o * 2, 0], [o, 1], [o, -1]]), t && e.push([[0, -1], [o, -1], [-o, -1]], [[0, 1], [o, 1], [-o, 1]])) : R ? (e.push([[0, R * 2], [1, R], [-1, R]]), t && e.push([[-1, 0], [-1, R], [-1, -R]], [[1, 0], [1, R], [1, -R]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;\n}\nfunction getCheckInnerBoundLineInfos(n, t, e, o) {\n  var R = n.state, N = R.allMatrix, M = R.is3d, D = calculatePoses(N, 100, 100, M ? 4 : 3), L = getPosByDirection(D, [0, 0]);\n  return getCheckSnapLineDirections(e, o).map(function(B) {\n    var $ = B[0], k = B[1], U = B[2], z = [getPosByDirection(D, k), getPosByDirection(D, U)], X = solveLineConstants(z), V = isStartLine(L, z), W = V.vertical, Y = V.horizontal, q = hitTestLine(L, z) <= 0;\n    return {\n      multiple: $,\n      centerSign: q,\n      verticalSign: W,\n      horizontalSign: Y,\n      lineConstants: X,\n      line: [getPosByDirection(t, k), getPosByDirection(t, U)]\n    };\n  });\n}\nfunction isBoundRotate$1(n, t, e, o) {\n  var R = o ? n.map(function(N) {\n    return rotate(N, o);\n  }) : n;\n  return [[R[0], R[1]], [R[1], R[3]], [R[3], R[2]], [R[2], R[0]]].some(function(N) {\n    var M = hitTestLine(e, N) <= 0;\n    return !isSameStartLine(t, N, M);\n  });\n}\nfunction getDistPointLine(n) {\n  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];\n  if (!o)\n    return Math.abs(t[0]);\n  if (!R)\n    return Math.abs(t[1]);\n  var N = R / o;\n  return Math.abs((-N * t[0] + t[1]) / Math.sqrt(Math.pow(N, 2) + 1));\n}\nfunction solveReverseLine(n) {\n  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];\n  if (!o)\n    return [t[0], 0];\n  if (!R)\n    return [0, t[1]];\n  var N = R / o, M = -N * t[0] + t[1];\n  return [-M / (N + 1 / N), M / (N * N + 1)];\n}\nfunction checkRotateInnerBounds(n, t, e, o, R) {\n  var N = n.props.innerBounds, M = R * Math.PI / 180;\n  if (!N)\n    return [];\n  var D = N.left, L = N.top, B = N.width, $ = N.height, k = D - o[0], U = D + B - o[0], z = L - o[1], X = L + $ - o[1], V = [[k, z], [U, z], [k, X], [U, X]], W = getPosByDirection(e, [0, 0]);\n  if (!isBoundRotate$1(e, V, W, 0))\n    return [];\n  var Y = [], q = V.map(function(Z) {\n    return [getDistSize(Z), getRad$1([0, 0], Z)];\n  });\n  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(Z) {\n    var K = getRad$1([0, 0], solveReverseLine(Z)), Q = getDistPointLine(Z);\n    Y.push.apply(Y, q.filter(function(J) {\n      var rt = J[0];\n      return rt && Q <= rt;\n    }).map(function(J) {\n      var rt = J[0], tt = J[1], nt = Math.acos(rt ? Q / rt : 0), st = tt + nt, ut = tt - nt;\n      return [M + st - K, M + ut - K];\n    }).reduce(function(J, rt) {\n      return J.push.apply(J, rt), J;\n    }, []).filter(function(J) {\n      return !isBoundRotate$1(t, V, W, J);\n    }).map(function(J) {\n      return throttle(J * 180 / Math.PI, TINY_NUM);\n    }));\n  }), Y;\n}\nfunction checkInnerBoundPoses(n) {\n  var t = n.props.innerBounds;\n  if (!t)\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  var e = n.getRect(), o = e.pos1, R = e.pos2, N = e.pos3, M = e.pos4, D = [o, R, N, M], L = getPosByDirection(D, [0, 0]), B = t.left, $ = t.top, k = t.width, U = t.height, z = [[B, $], [B, $ + U]], X = [[B, $], [B + k, $]], V = [[B + k, $], [B + k, $ + U]], W = [[B, $ + U], [B + k, $ + U]], Y = getCheckInnerBoundLineInfos(n, D, [0, 0], !1), q = [], Z = [], K = {\n    top: !1,\n    bottom: !1,\n    left: !1,\n    right: !1\n  };\n  return Y.forEach(function(Q) {\n    var J = Q.line, rt = Q.lineConstants, tt = isStartLine(L, J), nt = tt.horizontal, st = tt.vertical, ut = checkLineBoundCollision(J, rt, X, st, 1, !0), ct = checkLineBoundCollision(J, rt, W, st, 1, !0), dt = checkLineBoundCollision(J, rt, z, nt, 1, !0), Et = checkLineBoundCollision(J, rt, V, nt, 1, !0);\n    ut.isBound && !K.top && (q.push($), K.top = !0), ct.isBound && !K.bottom && (q.push($ + U), K.bottom = !0), dt.isBound && !K.left && (Z.push(B), K.left = !0), Et.isBound && !K.right && (Z.push(B + k), K.right = !0);\n  }), {\n    horizontal: q,\n    vertical: Z\n  };\n}\nfunction checkBoundPoses(n, t, e) {\n  var o = n || {}, R = o.position, N = R === void 0 ? \"client\" : R, M = o.left, D = M === void 0 ? -1 / 0 : M, L = o.top, B = L === void 0 ? -1 / 0 : L, $ = o.right, k = $ === void 0 ? 1 / 0 : $, U = o.bottom, z = U === void 0 ? 1 / 0 : U, X = {\n    position: N,\n    left: D,\n    top: B,\n    right: k,\n    bottom: z\n  };\n  return {\n    vertical: checkBounds(X, t, !0),\n    horizontal: checkBounds(X, e, !1)\n  };\n}\nfunction getBounds(n, t) {\n  var e = n.state, o = e.containerClientRect, R = o.clientHeight, N = o.clientWidth, M = o.clientLeft, D = o.clientTop, L = e.snapOffset, B = L.left, $ = L.top, k = L.right, U = L.bottom, z = t || n.props.bounds || {}, X = z.position || \"client\", V = X === \"css\", W = z.left, Y = W === void 0 ? -1 / 0 : W, q = z.top, Z = q === void 0 ? -1 / 0 : q, K = z.right, Q = K === void 0 ? V ? -1 / 0 : 1 / 0 : K, J = z.bottom, rt = J === void 0 ? V ? -1 / 0 : 1 / 0 : J;\n  return V && (Q = N + k - B - Q, rt = R + U - $ - rt), {\n    left: Y + B - M,\n    right: Q + B - M,\n    top: Z + $ - D,\n    bottom: rt + $ - D\n  };\n}\nfunction checkBoundKeepRatio(n, t, e) {\n  var o = getBounds(n), R = o.left, N = o.top, M = o.right, D = o.bottom, L = e[0], B = e[1], $ = minus(e, t), k = $[0], U = $[1];\n  Math.abs(k) < TINY_NUM && (k = 0), Math.abs(U) < TINY_NUM && (U = 0);\n  var z = U > 0, X = k > 0, V = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, W = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (k === 0 && U === 0)\n    return {\n      vertical: V,\n      horizontal: W\n    };\n  if (k === 0)\n    z ? D < B && (W.pos = D, W.offset = B - D) : N > B && (W.pos = N, W.offset = B - N);\n  else if (U === 0)\n    X ? M < L && (V.pos = M, V.offset = L - M) : R > L && (V.pos = R, V.offset = L - R);\n  else {\n    var Y = U / k, q = e[1] - Y * L, Z = 0, K = 0, Q = !1;\n    X && M <= L ? (Z = Y * M + q, K = M, Q = !0) : !X && L <= R && (Z = Y * R + q, K = R, Q = !0), Q && (Z < N || Z > D) && (Q = !1), Q || (z && D <= B ? (Z = D, K = (Z - q) / Y, Q = !0) : !z && B <= N && (Z = N, K = (Z - q) / Y, Q = !0)), Q && (V.isBound = !0, V.pos = K, V.offset = L - K, W.isBound = !0, W.pos = Z, W.offset = B - Z);\n  }\n  return {\n    vertical: V,\n    horizontal: W\n  };\n}\nfunction checkBounds(n, t, e) {\n  var o = n[e ? \"left\" : \"top\"], R = n[e ? \"right\" : \"bottom\"], N = Math.min.apply(Math, t), M = Math.max.apply(Math, t), D = [];\n  return o + 1 > N && D.push({\n    isBound: !0,\n    offset: N - o,\n    pos: o\n  }), R - 1 < M && D.push({\n    isBound: !0,\n    offset: M - R,\n    pos: R\n  }), D.length || D.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), D.sort(function(L, B) {\n    return Math.abs(B.offset) - Math.abs(L.offset);\n  });\n}\nfunction isBoundRotate(n, t, e) {\n  var o = e ? n.map(function(R) {\n    return rotate(R, e);\n  }) : n;\n  return o.some(function(R) {\n    return R[0] < t.left && Math.abs(R[0] - t.left) > 0.1 || R[0] > t.right && Math.abs(R[0] - t.right) > 0.1 || R[1] < t.top && Math.abs(R[1] - t.top) > 0.1 || R[1] > t.bottom && Math.abs(R[1] - t.bottom) > 0.1;\n  });\n}\nfunction boundRotate(n, t, e) {\n  var o = getDistSize(n), R = Math.sqrt(o * o - t * t) || 0;\n  return [R, -R].sort(function(N, M) {\n    return Math.abs(N - n[e ? 0 : 1]) - Math.abs(M - n[e ? 0 : 1]);\n  }).map(function(N) {\n    return getRad$1([0, 0], e ? [N, t] : [t, N]);\n  });\n}\nfunction checkRotateBounds(n, t, e, o, R) {\n  if (!n.props.bounds)\n    return [];\n  var N = R * Math.PI / 180, M = getBounds(n), D = M.left, L = M.top, B = M.right, $ = M.bottom, k = D - o[0], U = B - o[0], z = L - o[1], X = $ - o[1], V = {\n    left: k,\n    top: z,\n    right: U,\n    bottom: X\n  };\n  if (!isBoundRotate(e, V, 0))\n    return [];\n  var W = [];\n  return [[k, 0], [U, 0], [z, 1], [X, 1]].forEach(function(Y) {\n    var q = Y[0], Z = Y[1];\n    e.forEach(function(K) {\n      var Q = getRad$1([0, 0], K);\n      W.push.apply(W, boundRotate(K, q, Z).map(function(J) {\n        return N + J - Q;\n      }).filter(function(J) {\n        return !isBoundRotate(t, V, J);\n      }).map(function(J) {\n        return throttle(J * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  }), W;\n}\nfunction renderGuideline(n, t) {\n  var e, o = n.direction, R = n.classNames, N = n.size, M = n.pos, D = n.zoom, L = n.key, B = o === \"horizontal\", $ = B ? \"Y\" : \"X\";\n  return t.createElement(\"div\", {\n    key: L,\n    className: R.join(\" \"),\n    style: (e = {}, e[B ? \"width\" : \"height\"] = \"\".concat(N), e.transform = \"translate(\".concat(M[0], \", \").concat(M[1], \") translate\").concat($, \"(-50%) scale\").concat($, \"(\").concat(D, \")\"), e)\n  });\n}\nfunction renderInnerGuideline(n, t) {\n  return renderGuideline(__assign$2(__assign$2({}, n), {\n    classNames: __spreadArray([prefix(\"line\", \"guideline\", n.direction)], n.classNames, !0).filter(function(e) {\n      return e;\n    }),\n    size: n.size || \"\".concat(n.sizeValue, \"px\"),\n    pos: n.pos || n.posValue.map(function(e) {\n      return \"\".concat(throttle(e, 0.1), \"px\");\n    })\n  }), t);\n}\nfunction renderSnapPoses(n, t, e, o, R, N, M, D) {\n  var L = n.props.zoom;\n  return e.map(function(B, $) {\n    var k = B.type, U = B.pos, z = [0, 0];\n    return z[M] = o, z[M ? 0 : 1] = -R + U, renderInnerGuideline({\n      key: \"\".concat(t, \"TargetGuideline\").concat($),\n      classNames: [prefix(\"target\", \"bold\", k)],\n      posValue: z,\n      sizeValue: N,\n      zoom: L,\n      direction: t\n    }, D);\n  });\n}\nfunction renderGuidelines(n, t, e, o, R, N) {\n  var M = n.props, D = M.zoom, L = M.isDisplayInnerSnapDigit, B = t === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, $ = R[B.start], k = R[B.end];\n  return e.filter(function(U) {\n    var z = U.hide, X = U.elementRect;\n    if (z)\n      return !1;\n    if (L && X) {\n      var V = X.rect;\n      if (V[B.start] <= $ && k <= V[B.end])\n        return !1;\n    }\n    return !0;\n  }).map(function(U, z) {\n    var X = U.pos, V = U.size, W = U.element, Y = U.className, q = [-o[0] + X[0], -o[1] + X[1]];\n    return renderInnerGuideline({\n      key: \"\".concat(t, \"-default-guideline-\").concat(z),\n      classNames: W ? [prefix(\"bold\"), Y] : [Y],\n      direction: t,\n      posValue: q,\n      sizeValue: V,\n      zoom: D\n    }, N);\n  });\n}\nfunction renderDigitLine(n, t, e, o, R, N, M, D) {\n  var L, B = n.props, $ = B.snapDigit, k = $ === void 0 ? 0 : $, U = B.isDisplaySnapDigit, z = U === void 0 ? !0 : U, X = B.snapDistFormat, V = X === void 0 ? function(Q, J) {\n    return Q;\n  } : X, W = B.zoom, Y = t === \"horizontal\" ? \"X\" : \"Y\", q = t === \"vertical\" ? \"height\" : \"width\", Z = Math.abs(R), K = z ? parseFloat(Z.toFixed(k)) : 0;\n  return D.createElement(\"div\", {\n    key: \"\".concat(t, \"-\").concat(e, \"-guideline-\").concat(o),\n    className: prefix(\"guideline-group\", t),\n    style: (L = {\n      left: \"\".concat(N[0], \"px\"),\n      top: \"\".concat(N[1], \"px\")\n    }, L[q] = \"\".concat(Z, \"px\"), L)\n  }, renderInnerGuideline({\n    direction: t,\n    classNames: [prefix(e), M],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: Z,\n    zoom: W\n  }, D), D.createElement(\"div\", {\n    className: prefix(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(Y, \"(-50%) scale(\").concat(W, \")\")\n    }\n  }, K > 0 ? V(K, t) : \"\"));\n}\nfunction groupByElementGuidelines(n, t, e, o) {\n  var R = n === \"vertical\" ? 0 : 1, N = n === \"vertical\" ? 1 : 0, M = R ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, D = e[M.start], L = e[M.end];\n  return groupBy(t, function(B) {\n    return B.pos[R];\n  }).map(function(B) {\n    var $ = [], k = [], U = [];\n    return B.forEach(function(z) {\n      var X, V, W = z.element, Y = z.elementRect.rect;\n      if (Y[M.end] < D)\n        $.push(z);\n      else if (L < Y[M.start])\n        k.push(z);\n      else if (Y[M.start] <= D && L <= Y[M.end] && o) {\n        var q = z.pos, Z = {\n          element: W,\n          rect: __assign$2(__assign$2({}, Y), (X = {}, X[M.end] = Y[M.start], X))\n        }, K = {\n          element: W,\n          rect: __assign$2(__assign$2({}, Y), (V = {}, V[M.start] = Y[M.end], V))\n        }, Q = [0, 0], J = [0, 0];\n        Q[R] = q[R], Q[N] = q[N], J[R] = q[R], J[N] = q[N] + z.size, $.push({\n          type: n,\n          pos: Q,\n          size: 0,\n          elementRect: Z\n        }), k.push({\n          type: n,\n          pos: J,\n          size: 0,\n          elementRect: K\n        });\n      }\n    }), $.sort(function(z, X) {\n      return X.pos[N] - z.pos[N];\n    }), k.sort(function(z, X) {\n      return z.pos[N] - X.pos[N];\n    }), {\n      total: B,\n      start: $,\n      end: k,\n      inner: U\n    };\n  });\n}\nfunction renderDashedGuidelines(n, t, e, o, R) {\n  var N = n.props.isDisplayInnerSnapDigit, M = [];\n  return [\"vertical\", \"horizontal\"].forEach(function(D) {\n    var L = t.filter(function(W) {\n      return W.type === D;\n    }), B = D === \"vertical\" ? 1 : 0, $ = B ? 0 : 1, k = groupByElementGuidelines(D, L, o, N), U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, z = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, X = o[U.start], V = o[U.end];\n    k.forEach(function(W) {\n      var Y = W.total, q = W.start, Z = W.end, K = W.inner, Q = e[$] + Y[0].pos[$] - o[z.start], J = o;\n      q.forEach(function(rt) {\n        var tt = rt.elementRect.rect, nt = J[U.start] - tt[U.end];\n        if (nt > 0) {\n          var st = [0, 0];\n          st[B] = e[B] + J[U.start] - X - nt, st[$] = Q, M.push(renderDigitLine(n, D, \"dashed\", M.length, nt, st, rt.className, R));\n        }\n        J = tt;\n      }), J = o, Z.forEach(function(rt) {\n        var tt = rt.elementRect.rect, nt = tt[U.start] - J[U.end];\n        if (nt > 0) {\n          var st = [0, 0];\n          st[B] = e[B] + J[U.end] - X, st[$] = Q, M.push(renderDigitLine(n, D, \"dashed\", M.length, nt, st, rt.className, R));\n        }\n        J = tt;\n      }), K.forEach(function(rt) {\n        var tt = rt.elementRect.rect, nt = X - tt[U.start], st = tt[U.end] - V, ut = [0, 0], ct = [0, 0];\n        ut[B] = e[B] - nt, ut[$] = Q, ct[B] = e[B] + V - X, ct[$] = Q, M.push(renderDigitLine(n, D, \"dashed\", M.length, nt, ut, rt.className, R)), M.push(renderDigitLine(n, D, \"dashed\", M.length, st, ct, rt.className, R));\n      });\n    });\n  }), M;\n}\nfunction renderGapGuidelines(n, t, e, o, R) {\n  var N = [];\n  return [\"horizontal\", \"vertical\"].forEach(function(M) {\n    var D = t.filter(function(W) {\n      return W.type === M;\n    }), L = M === \"vertical\" ? 0 : 1, B = L ? 0 : 1, $ = L ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, k = L ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = o[$.start], z = o[$.end], X = o[k.start], V = o[k.end];\n    D.forEach(function(W) {\n      var Y = W.gap, q = W.gapRects, Z = W.className, K = Math.max.apply(Math, __spreadArray([X], q.map(function(rt) {\n        var tt = rt.rect;\n        return tt[k.start];\n      }), !1)), Q = Math.min.apply(Math, __spreadArray([V], q.map(function(rt) {\n        var tt = rt.rect;\n        return tt[k.end];\n      }), !1)), J = (K + Q) / 2;\n      K === Q || J === (X + V) / 2 || q.forEach(function(rt) {\n        var tt = rt.rect, nt = [e[0], e[1]];\n        if (tt[$.end] < U)\n          nt[L] += tt[$.end] - U;\n        else if (z < tt[$.start])\n          nt[L] += tt[$.start] - U - Y;\n        else\n          return;\n        nt[B] += J - X, N.push(renderDigitLine(n, L ? \"vertical\" : \"horizontal\", \"gap\", N.length, Y, nt, Z, R));\n      });\n    });\n  }), N;\n}\nfunction solveEquation(n, t, e, o) {\n  var R = t[0] - n[0], N = t[1] - n[1];\n  if (Math.abs(R) < TINY_NUM$1 && (R = 0), Math.abs(N) < TINY_NUM$1 && (N = 0), !R)\n    return o ? [0, 0] : [0, e];\n  if (!N)\n    return o ? [e, 0] : [0, 0];\n  var M = N / R, D = n[1] - M * n[0];\n  if (o) {\n    var L = M * (t[0] + e) + D;\n    return [e, L - t[1]];\n  } else {\n    var B = (t[1] + e - D) / M;\n    return [B - t[0], e];\n  }\n}\nfunction solveNextOffset(n, t, e, o, R) {\n  var N = solveEquation(n, t, e, o);\n  if (!N)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  var M = getDist$2(n, t), D = getDist$2(N, n), L = getDist$2(N, t), B = D > M || L > M, $ = getDragDist({\n    datas: R,\n    distX: N[0],\n    distY: N[1]\n  }), k = $[0], U = $[1];\n  return {\n    offset: [k, U],\n    isOutside: B\n  };\n}\nfunction getSnapBound(n, t) {\n  return n.isBound ? n.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;\n}\nfunction checkThrottleDragRotate(n, t, e, o, R) {\n  var N = t[0], M = t[1], D = e[0], L = e[1], B = o[0], $ = o[1], k = R[0], U = R[1], z = -k, X = -U;\n  if (n && N && M) {\n    z = 0, X = 0;\n    var V = [];\n    if (D && L ? V.push([0, U], [k, 0]) : D ? V.push([k, 0]) : L ? V.push([0, U]) : B && $ ? V.push([0, U], [k, 0]) : B ? V.push([k, 0]) : $ && V.push([0, U]), V.length) {\n      V.sort(function(Z, K) {\n        return getDistSize(minus([N, M], Z)) - getDistSize(minus([N, M], K));\n      });\n      var W = V[0];\n      if (W[0] && Math.abs(N) > TINY_NUM$1)\n        z = -W[0], X = M * Math.abs(N + z) / Math.abs(N) - M;\n      else if (W[1] && Math.abs(M) > TINY_NUM$1) {\n        var Y = M;\n        X = -W[1], z = N * Math.abs(M + X) / Math.abs(Y) - N;\n      }\n      if (n && L && D)\n        if (Math.abs(z) > TINY_NUM$1 && Math.abs(z) < Math.abs(k)) {\n          var q = Math.abs(k) / Math.abs(z);\n          z *= q, X *= q;\n        } else if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(U)) {\n          var q = Math.abs(U) / Math.abs(X);\n          z *= q, X *= q;\n        } else\n          z = maxOffset(-k, z), X = maxOffset(-U, X);\n    }\n  } else\n    z = N || D ? -k : 0, X = M || L ? -U : 0;\n  return [z, X];\n}\nfunction checkSnapBoundsDrag(n, t, e, o, R, N) {\n  if (!hasGuidelines(n, \"draggable\"))\n    return [{\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }, {\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }];\n  var M = getAbsolutePoses(N.absolutePoses, [t, e]), D = getRect(M), L = D.left, B = D.right, $ = D.top, k = D.bottom, U = {\n    horizontal: M.map(function(Et) {\n      return Et[1];\n    }),\n    vertical: M.map(function(Et) {\n      return Et[0];\n    })\n  }, z = getSnapDirections(n.props.snapDirections), X = splitSnapDirectionPoses(z, {\n    left: L,\n    right: B,\n    top: $,\n    bottom: k,\n    center: (L + B) / 2,\n    middle: ($ + k) / 2\n  }), V = checkMoveableSnapBounds(n, R, X, U), W = V.vertical, Y = V.horizontal, q = getInnerBoundDragInfo(n, M, N), Z = q.vertical, K = q.horizontal, Q = W.isSnap, J = Y.isSnap, rt = W.isBound || Z.isBound, tt = Y.isBound || K.isBound, nt = maxOffset(W.offset, Z.offset), st = maxOffset(Y.offset, K.offset), ut = checkThrottleDragRotate(o, [t, e], [rt, tt], [Q, J], [nt, st]), ct = ut[0], dt = ut[1];\n  return [{\n    isBound: rt,\n    isSnap: Q,\n    offset: ct\n  }, {\n    isBound: tt,\n    isSnap: J,\n    offset: dt\n  }];\n}\nfunction checkMoveableSnapBounds(n, t, e, o) {\n  o === void 0 && (o = e);\n  var R = checkBoundPoses(getBounds(n), o.vertical, o.horizontal), N = R.horizontal, M = R.vertical, D = t ? {\n    horizontal: {\n      isSnap: !1,\n      index: -1\n    },\n    vertical: {\n      isSnap: !1,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(n, e.vertical, e.horizontal), L = D.horizontal, B = D.vertical, $ = getSnapBound(N[0], L), k = getSnapBound(M[0], B), U = Math.abs($), z = Math.abs(k);\n  return {\n    horizontal: {\n      isBound: N[0].isBound,\n      isSnap: L.isSnap,\n      snapIndex: L.index,\n      offset: $,\n      dist: U,\n      bounds: N,\n      snap: L\n    },\n    vertical: {\n      isBound: M[0].isBound,\n      isSnap: B.isSnap,\n      snapIndex: B.index,\n      offset: k,\n      dist: z,\n      bounds: M,\n      snap: B\n    }\n  };\n}\nfunction checkSnapBounds(n, t, e, o, R) {\n  var N = checkBoundPoses(t, e, o), M = N.horizontal, D = N.vertical, L = checkSnapPoses(n, e, o, R), B = L.horizontal, $ = L.vertical, k = getSnapBound(M[0], B), U = getSnapBound(D[0], $), z = Math.abs(k), X = Math.abs(U);\n  return {\n    horizontal: {\n      isBound: M[0].isBound,\n      isSnap: B.isSnap,\n      snapIndex: B.index,\n      offset: k,\n      dist: z,\n      bounds: M,\n      snap: B\n    },\n    vertical: {\n      isBound: D[0].isBound,\n      isSnap: $.isSnap,\n      snapIndex: $.index,\n      offset: U,\n      dist: X,\n      bounds: D,\n      snap: $\n    }\n  };\n}\nfunction checkSnapRightLine(n, t, e, o) {\n  var R = getRad$1(n, t) / Math.PI * 180, N = e.vertical, M = N.isBound, D = N.isSnap, L = N.dist, B = e.horizontal, $ = B.isBound, k = B.isSnap, U = B.dist, z = R % 180, X = z < 3 || z > 177, V = z > 87 && z < 93;\n  return U < L && (M || D && !V && (!o || !X)) ? \"vertical\" : $ || k && !X && (!o || !V) ? \"horizontal\" : \"\";\n}\nfunction getSnapBoundInfo(n, t, e, o, R, N) {\n  return e.map(function(M) {\n    var D = M[0], L = M[1], B = getPosByDirection(t, D), $ = getPosByDirection(t, L), k = o ? checkSnapBoundsKeepRatio(n, B, $, R) : checkMoveableSnapBounds(n, R, {\n      vertical: [$[0]],\n      horizontal: [$[1]]\n    }), U = k.horizontal, z = U.offset, X = U.isBound, V = U.isSnap, W = k.vertical, Y = W.offset, q = W.isBound, Z = W.isSnap, K = minus(L, D);\n    if (!Y && !z)\n      return {\n        isBound: q || X,\n        isSnap: Z || V,\n        sign: K,\n        offset: [0, 0]\n      };\n    var Q = checkSnapRightLine(B, $, k, o);\n    if (!Q)\n      return {\n        sign: K,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    var J = Q === \"vertical\", rt = [0, 0];\n    return !o && Math.abs(L[0]) === 1 && Math.abs(L[1]) === 1 && D[0] !== L[0] && D[1] !== L[1] ? rt = getDragDist({\n      datas: N,\n      distX: -Y,\n      distY: -z\n    }) : rt = solveNextOffset(B, $, -(J ? Y : z), J, N).offset, rt = rt.map(function(tt, nt) {\n      return tt * (K[nt] ? 2 / K[nt] : 0);\n    }), {\n      sign: K,\n      isBound: J ? q : X,\n      isSnap: J ? Z : V,\n      offset: rt\n    };\n  });\n}\nfunction getSnapBoundOffset(n, t) {\n  return n.isBound ? n.offset : t.isSnap ? t.offset : 0;\n}\nfunction checkSnapBoundsKeepRatio(n, t, e, o) {\n  var R = checkBoundKeepRatio(n, t, e), N = R.horizontal, M = R.vertical, D = o ? {\n    horizontal: {\n      isSnap: !1\n    },\n    vertical: {\n      isSnap: !1\n    }\n  } : checkSnapKeepRatio(n, t, e), L = D.horizontal, B = D.vertical, $ = getSnapBoundOffset(N, L), k = getSnapBoundOffset(M, B), U = Math.abs($), z = Math.abs(k);\n  return {\n    horizontal: {\n      isBound: N.isBound,\n      isSnap: L.isSnap,\n      offset: $,\n      dist: U\n    },\n    vertical: {\n      isBound: M.isBound,\n      isSnap: B.isSnap,\n      offset: k,\n      dist: z\n    }\n  };\n}\nfunction checkMaxBounds(n, t, e, o, R) {\n  var N = [-e[0], -e[1]], M = n.state, D = M.width, L = M.height, B = n.props.bounds, $ = 1 / 0, k = 1 / 0;\n  if (B) {\n    var U = [[e[0], -e[1]], [-e[0], e[1]]], z = B.left, X = z === void 0 ? -1 / 0 : z, V = B.top, W = V === void 0 ? -1 / 0 : V, Y = B.right, q = Y === void 0 ? 1 / 0 : Y, Z = B.bottom, K = Z === void 0 ? 1 / 0 : Z;\n    U.forEach(function(Q) {\n      var J = Q[0] !== N[0], rt = Q[1] !== N[1], tt = getPosByDirection(t, Q), nt = getRad$1(o, tt) * 360 / Math.PI;\n      if (rt) {\n        var st = tt.slice();\n        (Math.abs(nt - 360) < 2 || Math.abs(nt - 180) < 2) && (st[1] = o[1]);\n        var ut = solveNextOffset(o, st, (o[1] < tt[1] ? K : W) - tt[1], !1, R), ct = ut.offset, dt = ct[1], Et = ut.isOutside;\n        isNaN(dt) || (k = L + (Et ? 1 : -1) * Math.abs(dt));\n      }\n      if (J) {\n        var st = tt.slice();\n        (Math.abs(nt - 90) < 2 || Math.abs(nt - 270) < 2) && (st[0] = o[0]);\n        var vt = solveNextOffset(o, st, (o[0] < tt[0] ? q : X) - tt[0], !0, R), _t = vt.offset[0], St = vt.isOutside;\n        isNaN(_t) || ($ = D + (St ? 1 : -1) * Math.abs(_t));\n      }\n    });\n  }\n  return {\n    maxWidth: $,\n    maxHeight: k\n  };\n}\nfunction snapStart(n) {\n  var t = n.state;\n  if (!(t.guidelines && t.guidelines.length)) {\n    var e = n.state.container, o = n.props.snapContainer || e, R = t.containerClientRect, N = {\n      left: 0,\n      top: 0,\n      bottom: 0,\n      right: 0\n    };\n    if (e !== o) {\n      var M = getRefTarget(o, !0);\n      if (M) {\n        var D = getClientRect(M), L = getDragDistByState(t, [D.left - R.left, D.top - R.top]), B = getDragDistByState(t, [D.right - R.right, D.bottom - R.bottom]);\n        N.left = throttle(L[0], 1e-5), N.top = throttle(L[1], 1e-5), N.right = throttle(B[0], 1e-5), N.bottom = throttle(B[1], 1e-5);\n      }\n    }\n    t.snapOffset = N, t.guidelines = getTotalGuidelines(n), t.enableSnap = !0;\n  }\n}\nfunction getNextFixedPoses(n, t, e, o, R, N) {\n  var M = calculatePoses(n, t, e, N ? 4 : 3), D = getPosByDirection(M, o);\n  return getAbsolutePoses(M, minus(R, D));\n}\nfunction getSizeOffsetInfo(n, t, e, o, R, N) {\n  var M = N.fixedDirection, D = getCheckSnapDirections(e, M, o), L = getCheckInnerBoundLineInfos(n, t, e, o), B = __spreadArray(__spreadArray([], getSnapBoundInfo(n, t, D, o, R, N), !0), getInnerBoundInfo(n, L, N), !0), $ = getNearOffsetInfo(B, 0), k = getNearOffsetInfo(B, 1);\n  return {\n    width: {\n      isBound: $.isBound,\n      offset: $.offset[0]\n    },\n    height: {\n      isBound: k.isBound,\n      offset: k.offset[1]\n    }\n  };\n}\nfunction recheckSizeByTwoDirection(n, t, e, o, R, N, M, D, L) {\n  var B = getPosByDirection(t, M), $ = checkMoveableSnapBounds(n, D, {\n    vertical: [B[0]],\n    horizontal: [B[1]]\n  }), k = $.horizontal.offset, U = $.vertical.offset;\n  if (U || k) {\n    var z = getDragDist({\n      datas: L,\n      distX: -U,\n      distY: -k\n    }), X = z[0], V = z[1], W = Math.min(R || 1 / 0, e + M[0] * X), Y = Math.min(N || 1 / 0, o + M[1] * V);\n    return [W - e, Y - o];\n  }\n  return [0, 0];\n}\nfunction checkSizeDist(n, t, e, o, R, N, M, D) {\n  for (var L = getAbsolutePosesByState(n.state), B = n.props.keepRatio, $ = 0, k = 0, U = 0; U < 2; ++U) {\n    var z = t($, k), X = getSizeOffsetInfo(n, z, R, B, M, D), V = X.width, W = X.height, Y = V.isBound, q = W.isBound, Z = V.offset, K = W.offset;\n    if (U === 1 && (Y || (Z = 0), q || (K = 0)), U === 0 && M && !Y && !q)\n      return [0, 0];\n    if (B) {\n      var Q = Math.abs(Z) * (e ? 1 / e : 1), J = Math.abs(K) * (o ? 1 / o : 1), rt = Y && q ? Q < J : q || !Y && Q < J;\n      rt ? Z = e * K / o : K = o * Z / e;\n    }\n    $ += Z, k += K;\n  }\n  if (R[0] && R[1]) {\n    var tt = checkMaxBounds(n, L, R, N, D), nt = tt.maxWidth, st = tt.maxHeight, ut = recheckSizeByTwoDirection(n, t($, k).map(function(Et) {\n      return Et.map(function(vt) {\n        return throttle(vt, FLOAT_POINT_NUM);\n      });\n    }), e + $, o + k, nt, st, R, M, D), Z = ut[0], K = ut[1];\n    $ += Z, k += K;\n  }\n  return [$, k];\n}\nfunction checkSnapRotate(n, t, e, o) {\n  if (!hasGuidelines(n, \"rotatable\"))\n    return o;\n  var R = t.pos1, N = t.pos2, M = t.pos3, D = t.pos4, L = o * Math.PI / 180, B = [R, N, M, D].map(function(U) {\n    return minus(U, e);\n  }), $ = B.map(function(U) {\n    return rotate(U, L);\n  }), k = __spreadArray(__spreadArray([], checkRotateBounds(n, B, $, e, o), !0), checkRotateInnerBounds(n, B, $, e, o), !0);\n  return k.sort(function(U, z) {\n    return Math.abs(U - o) - Math.abs(z - o);\n  }), k.length ? k[0] : o;\n}\nfunction checkSnapResize(n, t, e, o, R, N, M) {\n  if (!hasGuidelines(n, \"resizable\"))\n    return [0, 0];\n  var D = M.fixedDirection, L = M.nextAllMatrix, B = n.state, $ = B.allMatrix, k = B.is3d;\n  return checkSizeDist(n, function(U, z) {\n    return getNextFixedPoses(L || $, t + U, e + z, D, R, k);\n  }, t, e, o, R, N, M);\n}\nfunction checkSnapScale(n, t, e, o, R) {\n  if (!hasGuidelines(n, \"scalable\"))\n    return [0, 0];\n  var N = R.startOffsetWidth, M = R.startOffsetHeight, D = R.fixedPosition, L = R.fixedDirection, B = R.is3d, $ = checkSizeDist(n, function(k, U) {\n    return getNextFixedPoses(scaleMatrix(R, plus(t, [k / N, U / M])), N, M, L, D, B);\n  }, N, M, e, D, o, R);\n  return [$[0] / N, $[1] / M];\n}\nfunction startCheckSnapDrag(n, t) {\n  t.absolutePoses = getAbsolutePosesByState(n.state);\n}\nfunction getSnapGuidelines(n) {\n  var t = [];\n  return n.forEach(function(e) {\n    e.guidelineInfos.forEach(function(o) {\n      var R = o.guideline;\n      t.indexOf(R) > -1 || t.push(R);\n    });\n  }), t;\n}\nfunction addBoundGuidelines(n, t, e, o, R, N) {\n  var M = checkBoundPoses(getBounds(n, N), t, e), D = M.vertical, L = M.horizontal;\n  D.forEach(function(U) {\n    U.isBound && o.push({\n      type: \"bounds\",\n      pos: U.pos\n    });\n  }), L.forEach(function(U) {\n    U.isBound && R.push({\n      type: \"bounds\",\n      pos: U.pos\n    });\n  });\n  var B = checkInnerBoundPoses(n), $ = B.vertical, k = B.horizontal;\n  $.forEach(function(U) {\n    findIndex(o, function(z) {\n      var X = z.type, V = z.pos;\n      return X === \"bounds\" && V === U;\n    }) >= 0 || o.push({\n      type: \"bounds\",\n      pos: U\n    });\n  }), k.forEach(function(U) {\n    findIndex(R, function(z) {\n      var X = z.type, V = z.pos;\n      return X === \"bounds\" && V === U;\n    }) >= 0 || R.push({\n      type: \"bounds\",\n      pos: U\n    });\n  });\n}\nvar directionCondition$2 = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]), Snappable = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapDirections: [Boolean, Object],\n    elementSnapDirections: [Boolean, Object],\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [`:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`],\n  render: function(n, t) {\n    var e = n.state, o = e.top, R = e.left, N = e.pos1, M = e.pos2, D = e.pos3, L = e.pos4, B = e.snapRenderInfo;\n    if (!B || !hasGuidelines(n, \"\"))\n      return [];\n    e.guidelines = getTotalGuidelines(n);\n    var $ = Math.min(N[0], M[0], D[0], L[0]), k = Math.min(N[1], M[1], D[1], L[1]), U = B.externalPoses || [], z = getAbsolutePosesByState(n.state), X = [], V = [], W = [], Y = [], q = [], Z = getRect(z), K = Z.width, Q = Z.height, J = Z.top, rt = Z.left, tt = Z.bottom, nt = Z.right, st = {\n      left: rt,\n      right: nt,\n      top: J,\n      bottom: tt,\n      center: (rt + nt) / 2,\n      middle: (J + tt) / 2\n    }, ut = U.length > 0, ct = ut ? getRect(U) : {};\n    if (!B.request) {\n      if (B.direction && q.push(getSnapInfosByDirection(n, z, B.direction)), B.snap) {\n        var dt = getRect(z);\n        B.center && (dt.middle = (dt.top + dt.bottom) / 2, dt.center = (dt.left + dt.right) / 2), q.push(checkSnaps(n, dt, 1));\n      }\n      ut && (B.center && (ct.middle = (ct.top + ct.bottom) / 2, ct.center = (ct.left + ct.right) / 2), q.push(checkSnaps(n, ct, 1))), q.forEach(function(St) {\n        var Ft = St.vertical.posInfos, mt = St.horizontal.posInfos;\n        X.push.apply(X, Ft.filter(function(ht) {\n          var pt = ht.guidelineInfos;\n          return pt.some(function(xt) {\n            var At = xt.guideline;\n            return !At.hide;\n          });\n        }).map(function(ht) {\n          return {\n            type: \"snap\",\n            pos: ht.pos\n          };\n        })), V.push.apply(V, mt.filter(function(ht) {\n          var pt = ht.guidelineInfos;\n          return pt.some(function(xt) {\n            var At = xt.guideline;\n            return !At.hide;\n          });\n        }).map(function(ht) {\n          return {\n            type: \"snap\",\n            pos: ht.pos\n          };\n        })), W.push.apply(W, getSnapGuidelines(Ft)), Y.push.apply(Y, getSnapGuidelines(mt));\n      });\n    }\n    addBoundGuidelines(n, [rt, nt], [J, tt], X, V), ut && addBoundGuidelines(n, [ct.left, ct.right], [ct.top, ct.bottom], X, V, B.externalBounds);\n    var Et = __spreadArray(__spreadArray([], W, !0), Y, !0), vt = Et.filter(function(St) {\n      return St.element && !St.gapRects;\n    }), _t = Et.filter(function(St) {\n      return St.gapRects;\n    });\n    return triggerEvent(n, \"onSnap\", {\n      guidelines: Et.filter(function(St) {\n        var Ft = St.element;\n        return !Ft;\n      }),\n      elements: vt,\n      gaps: _t\n    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(n, vt, [$, k], st, t), !0), renderGapGuidelines(n, _t, [$, k], st, t), !0), renderGuidelines(n, \"horizontal\", Y, [R, o], st, t), !0), renderGuidelines(n, \"vertical\", W, [R, o], st, t), !0), renderSnapPoses(n, \"horizontal\", V, $, o, K, 0, t), !0), renderSnapPoses(n, \"vertical\", X, k, R, Q, 1, t), !0);\n  },\n  dragStart: function(n, t) {\n    n.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, snapStart(n);\n  },\n  drag: function(n) {\n    var t = n.state;\n    t.guidelines = getTotalGuidelines(n);\n  },\n  pinchStart: function(n) {\n    this.unset(n);\n  },\n  dragEnd: function(n) {\n    this.unset(n);\n  },\n  dragControlCondition: function(n, t) {\n    if (directionCondition$2(n, t) || dragControlCondition(n, t))\n      return !0;\n    if (!t.isRequest && t.inputEvent)\n      return hasClass(t.inputEvent.target, prefix(\"snap-control\"));\n  },\n  dragControlStart: function(n) {\n    n.state.snapRenderInfo = null, snapStart(n);\n  },\n  dragControl: function(n) {\n    this.drag(n);\n  },\n  dragControlEnd: function(n) {\n    this.unset(n);\n  },\n  dragGroupStart: function(n, t) {\n    this.dragStart(n, t);\n  },\n  dragGroup: function(n) {\n    this.drag(n);\n  },\n  dragGroupEnd: function(n) {\n    this.unset(n);\n  },\n  dragGroupControlStart: function(n) {\n    n.state.snapRenderInfo = null, snapStart(n);\n  },\n  dragGroupControl: function(n) {\n    this.drag(n);\n  },\n  dragGroupControlEnd: function(n) {\n    this.unset(n);\n  },\n  unset: function(n) {\n    var t = n.state;\n    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];\n  }\n};\nfunction renderDirectionControlsByInfos(n, t, e, o) {\n  var R = n.state, N = R.renderPoses, M = R.rotation, D = R.direction, L = getProps(n.props, t).zoom, B = D > 0 ? 1 : -1, $ = M / Math.PI * 180, k = {}, U = n.renderState;\n  U.renderDirectionMap || (U.renderDirectionMap = {});\n  var z = U.renderDirectionMap;\n  return e.forEach(function(X) {\n    var V = X.dir;\n    k[V] = !0;\n  }), e.map(function(X) {\n    var V = X.data, W = X.classNames, Y = X.dir, q = DIRECTION_INDEXES[Y];\n    if (!q || !k[Y])\n      return null;\n    z[Y] = !0;\n    var Z = (throttle($, 15) + B * DIRECTION_ROTATIONS[Y] + 720) % 180, K = {};\n    return getKeys(V).forEach(function(Q) {\n      K[\"data-\".concat(Q)] = V[Q];\n    }), o.createElement(\"div\", __assign$2({\n      className: prefix.apply(void 0, __spreadArray([\"control\", \"direction\", Y, t], W, !1)),\n      \"data-rotation\": Z,\n      \"data-direction\": Y\n    }, K, {\n      key: \"direction-\".concat(Y),\n      style: getControlTransform.apply(void 0, __spreadArray([M, L], q.map(function(Q) {\n        return N[Q];\n      }), !1))\n    }));\n  });\n}\nfunction renderDirectionControls(n, t, e, o) {\n  var R = getProps(n.props, e).renderDirections, N = R === void 0 ? t : R;\n  if (!N)\n    return [];\n  var M = N === !0 ? DIRECTIONS : N;\n  return renderDirectionControlsByInfos(n, e, M.map(function(D) {\n    return {\n      data: {},\n      classNames: [],\n      dir: D\n    };\n  }), o);\n}\nfunction renderAroundControls(n, t) {\n  var e = n.renderState;\n  e.renderDirectionMap || (e.renderDirectionMap = {});\n  var o = n.state, R = o.renderPoses, N = o.rotation, M = o.direction, D = e.renderDirectionMap, L = n.props.zoom, B = M > 0 ? 1 : -1, $ = N / Math.PI * 180;\n  return getKeys(D).map(function(k) {\n    var U = DIRECTION_INDEXES[k];\n    if (!U)\n      return null;\n    var z = (throttle($, 15) + B * DIRECTION_ROTATIONS[k] + 720) % 180;\n    return t.createElement(\"div\", {\n      className: prefix(\"around-control\"),\n      \"data-rotation\": z,\n      \"data-direction\": k,\n      key: \"direction-around-\".concat(k),\n      style: getControlTransform.apply(void 0, __spreadArray([N, L], U.map(function(X) {\n        return R[X];\n      }), !1))\n    });\n  });\n}\nfunction renderLine(n, t, e, o, R, N) {\n  for (var M = [], D = 6; D < arguments.length; D++)\n    M[D - 6] = arguments[D];\n  var L = getRad$1(e, o), B = t ? throttle(L / Math.PI * 180, 15) % 180 : -1;\n  return n.createElement(\"div\", {\n    key: \"line\".concat(N),\n    className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", t ? \"edge\" : \"\", t], M, !1)),\n    \"data-rotation\": B,\n    \"data-line-index\": N,\n    \"data-direction\": t,\n    style: getLineStyle(e, o, R, L)\n  });\n}\nfunction renderEdgeLines(n, t, e, o, R) {\n  var N = e === !0 ? DIRECTIONS4 : e;\n  return N.map(function(M, D) {\n    var L = DIRECTION_INDEXES[M], B = L[0], $ = L[1];\n    if ($ != null)\n      return renderLine(n, M, o[B], o[$], R, \"\".concat(t, \"Edge\").concat(D), t);\n  }).filter(Boolean);\n}\nfunction getRenderDirections(n) {\n  return function(t, e) {\n    var o = getProps(t.props, n).edge;\n    return o && (o === !0 || o.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, n, o, t.state.renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, n, e), !0) : renderAllDirections(t, n, e);\n  };\n}\nfunction renderAllDirections(n, t, e) {\n  return renderDirectionControls(n, DIRECTIONS, t, e);\n}\nfunction renderDiagonalDirections(n, t, e) {\n  return renderDirectionControls(n, [\"nw\", \"ne\", \"sw\", \"se\"], t, e);\n}\nfunction setRotateStartInfo(n, t, e, o, R) {\n  var N = n.state, M = N.is3d ? 4 : 3, D = t.origin, L = calculatePosition(n.state.rootMatrix, minus([D[0], D[1]], [N.left, N.top]), M), B = plus([R.left, R.top], L);\n  t.startAbsoluteOrigin = B, t.prevDeg = getRad$1(B, [e, o]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(B, [e, o]);\n}\nfunction getAbsoluteDist(n, t, e) {\n  var o = e.defaultDeg, R = e.prevDeg, N = R % 360, M = Math.floor(R / 360);\n  N < 0 && (N += 360), N > n && N > 270 && n < 90 ? ++M : N < n && N < 90 && n > 270 && --M;\n  var D = t * (M * 360 + n - o);\n  return e.prevDeg = o + D, D;\n}\nfunction getAbsoluteDistByClient(n, t, e, o) {\n  return getAbsoluteDist(getRad$1(o.startAbsoluteOrigin, [n, t]) / Math.PI * 180, e, o);\n}\nfunction getRotateInfo(n, t, e, o, R, N) {\n  var M = n.props.throttleRotate, D = M === void 0 ? 0 : M, L = o, B = e.prevSnapDeg;\n  N && (L = checkSnapRotate(n, t, e.origin, L));\n  var $ = throttle(R + L, D), k = $ - R;\n  return e.prevSnapDeg = k, [k - B, L, $];\n}\nfunction getRotationPositions(n, t, e) {\n  var o = t[0], R = t[1], N = t[2], M = t[3];\n  if (n !== \"none\") {\n    var D = (n || \"top\").split(\"-\"), L = D[0], B = D[1], $ = [o, R];\n    L === \"left\" ? $ = [N, o] : L === \"right\" ? $ = [R, M] : L === \"bottom\" && ($ = [M, N]);\n    var k = [($[0][0] + $[1][0]) / 2, ($[0][1] + $[1][1]) / 2], U = getRotationRad($, e);\n    if (B) {\n      var z = B === \"top\" || B === \"left\", X = L === \"bottom\" || L === \"left\";\n      k = $[z && !X || !z && X ? 0 : 1];\n    }\n    return [k, U];\n  }\n}\nfunction dragControlCondition(n, t) {\n  if (t.isRequest)\n    return t.requestAble === \"rotatable\";\n  var e = t.inputEvent.target;\n  if (hasClass(e, prefix(\"rotation-control\")) || hasClass(e, prefix(\"around-control\")) || hasClass(e, prefix(\"control\")) && hasClass(e, prefix(\"rotatable\")))\n    return !0;\n  var o = n.props.rotationTarget;\n  return o ? getRefTargets(o, !0).some(function(R) {\n    return R ? e === R || e.contains(R) : !1;\n  }) : !1;\n}\nvar directionCSS = DIRECTIONS.map(function(n) {\n  var t = \"\", e = \"\", o = \"center\", R = \"center\";\n  return n.indexOf(\"n\") > -1 && (t = \"top: -20px;\", R = \"bottom\"), n.indexOf(\"s\") > -1 && (t = \"top: 0px;\", R = \"top\"), n.indexOf(\"w\") > -1 && (e = \"left: -20px;\", o = \"right\"), n.indexOf(\"e\") > -1 && (e = \"left: 0px;\", o = \"left\"), '.around-control[data-direction*=\"'.concat(n, `\"] {\n        `).concat(e).concat(t, `\n        transform-origin: `).concat(o, \" \").concat(R, `;\n    }`);\n}).join(`\n`), css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n.rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n`.concat(directionCSS, `\n`), Rotatable = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object,\n    rotateAroundControls: Boolean,\n    edge: Boolean,\n    resolveAblesWithRotatable: Object\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onBeforeRotate: \"beforeRotate\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onBeforeRotateGroup: \"beforeRotateGroup\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [css],\n  render: function(n, t) {\n    var e = getProps(n.props, \"rotatable\"), o = e.rotatable, R = e.rotationPosition, N = e.zoom, M = e.renderDirections, D = e.rotateAroundControls, L = e.resolveAblesWithRotatable, B = n.state, $ = B.renderPoses, k = B.direction;\n    if (!o)\n      return null;\n    var U = getRotationPositions(R, $, k), z = [];\n    if (U) {\n      var X = U[0], V = U[1];\n      z.push(t.createElement(\"div\", {\n        key: \"rotation\",\n        className: prefix(\"rotation\"),\n        style: {\n          transform: \"translate(-50%) translate(\".concat(X[0], \"px, \").concat(X[1], \"px) rotate(\").concat(V, \"rad)\")\n        }\n      }, t.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(N, \")\")\n        }\n      }), t.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(N, \")\")\n        }\n      })));\n    }\n    if (M) {\n      var W = getKeys(L || {}), Y = {};\n      W.forEach(function(Z) {\n        L[Z].forEach(function(K) {\n          Y[K] = Z;\n        });\n      });\n      var q = [];\n      isArray(M) && (q = M.map(function(Z) {\n        var K = Y[Z];\n        return {\n          data: K ? {\n            resolve: K\n          } : {},\n          classNames: K ? [\"move\"] : [],\n          dir: Z\n        };\n      })), z.push.apply(z, renderDirectionControlsByInfos(n, \"rotatable\", q, t));\n    }\n    return D && z.push.apply(z, renderAroundControls(n, t)), z;\n  },\n  dragControlCondition,\n  dragControlStart: function(n, t) {\n    var e, o, R = t.datas, N = t.clientX, M = t.clientY, D = t.parentRotate, L = t.parentFlag, B = t.isPinch, $ = t.isRequest, k = n.state, U = k.target, z = k.left, X = k.top, V = k.direction, W = k.beforeDirection, Y = k.targetTransform, q = k.moveableClientRect, Z = k.offsetMatrix, K = k.targetMatrix, Q = k.allMatrix, J = k.width, rt = k.height;\n    if (!$ && !U)\n      return !1;\n    var tt = n.getRect();\n    R.rect = tt, R.transform = Y, R.left = z, R.top = X;\n    var nt = function(lt) {\n      R.fixedDirection = lt, R.fixedPosition = getDirectionOffset(n, lt), ht && ht.setFixedDirection(lt);\n    }, st = N, ut = M;\n    if ($ || B || L) {\n      var ct = D || 0;\n      R.beforeInfo = {\n        origin: tt.beforeOrigin,\n        prevDeg: ct,\n        defaultDeg: ct,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, R.afterInfo = __assign$2(__assign$2({}, R.beforeInfo), {\n        origin: tt.origin\n      }), R.absoluteInfo = __assign$2(__assign$2({}, R.beforeInfo), {\n        origin: tt.origin,\n        startValue: ct\n      });\n    } else {\n      var dt = (o = t.inputEvent) === null || o === void 0 ? void 0 : o.target;\n      if (dt) {\n        var Et = dt.getAttribute(\"data-direction\") || \"\", vt = DIRECTION_REGION_TO_DIRECTION[Et];\n        if (vt) {\n          R.isControl = !0, R.isAroundControl = hasClass(dt, prefix(\"around-control\")), R.controlDirection = vt;\n          var _t = dt.getAttribute(\"data-resolve\");\n          _t && (R.resolveAble = _t);\n          var St = calculateMoveableClientPositions(k.rootMatrix, k.renderPoses, q);\n          e = getPosByDirection(St, vt), st = e[0], ut = e[1];\n        }\n      }\n      R.beforeInfo = {\n        origin: tt.beforeOrigin\n      }, R.afterInfo = {\n        origin: tt.origin\n      }, R.absoluteInfo = {\n        origin: tt.origin,\n        startValue: tt.rotation\n      };\n      var Ft = nt;\n      nt = function(lt) {\n        var $t = k.is3d ? 4 : 3, Pt = getPosByDirection([[0, 0], [J, 0], [0, rt], [J, rt]], lt), kt = plus(getOrigin(K, $t), Pt), Ot = kt[0], gt = kt[1], Gt = calculate(Z, convertPositionMatrix([Ot, gt], $t)), Tt = calculate(Q, convertPositionMatrix([Pt[0], Pt[1]], $t));\n        Ft(lt), R.beforeInfo.origin = Gt, R.afterInfo.origin = Tt, R.absoluteInfo.origin = Tt, setRotateStartInfo(n, R.beforeInfo, st, ut, q), setRotateStartInfo(n, R.afterInfo, st, ut, q), setRotateStartInfo(n, R.absoluteInfo, st, ut, q);\n      };\n    }\n    R.startClientX = st, R.startClientY = ut, R.direction = V, R.beforeDirection = W, R.startValue = 0, R.datas = {}, setDefaultTransformIndex(t, \"rotate\");\n    var mt = !1, ht = !1;\n    if (R.isControl && R.resolveAble) {\n      var pt = R.resolveAble;\n      if (pt === \"resizable\") {\n        var xt = n.getAble(\"resizable\");\n        ht = xt ? xt.dragControlStart(n, __assign$2(__assign$2({}, new CustomGesto(\"resizable\").dragStart([0, 0], t)), {\n          parentDirection: R.controlDirection,\n          parentFixedDirection: R.fixedDirection\n        })) : !1;\n      }\n    }\n    if (!ht) {\n      var At = n.getAble(\"draggable\");\n      mt = At ? At.dragStart(n, new CustomGesto().dragStart([0, 0], t)) : !1;\n    }\n    nt(getOriginDirection(n));\n    var Rt = fillParams(n, t, __assign$2(__assign$2({\n      set: function(lt) {\n        R.startValue = lt * Math.PI / 180;\n      },\n      setFixedDirection: nt\n    }, fillTransformStartEvent(t)), {\n      dragStart: mt,\n      resizeStart: ht\n    })), Lt = triggerEvent(n, \"onRotateStart\", Rt);\n    return R.isRotate = Lt !== !1, k.snapRenderInfo = {\n      request: t.isRequest\n    }, R.isRotate ? Rt : !1;\n  },\n  dragControl: function(n, t) {\n    var e, o, R, N = t.datas, M = t.distX, D = t.distY, L = t.parentRotate, B = t.parentFlag, $ = t.isPinch, k = t.groupDelta, U = N.beforeDirection, z = N.beforeInfo, X = N.afterInfo, V = N.absoluteInfo, W = N.isRotate, Y = N.startValue, q = N.rect, Z = N.startClientX, K = N.startClientY;\n    if (!!W) {\n      resolveTransformEvent(t, \"rotate\");\n      var Q = getTransformDirection(t), J = U * Q, rt = n.props.parentMoveable, tt = 0, nt, st, ut = 0, ct, dt, Et = 0, vt, _t, St = 180 / Math.PI * Y, Ft = V.startValue, mt = !1, ht = Z + M, pt = K + D;\n      if (!B && \"parentDist\" in t) {\n        var xt = t.parentDist;\n        nt = xt, ct = xt, vt = xt;\n      } else\n        $ || B ? (nt = getAbsoluteDist(L, U, z), ct = getAbsoluteDist(L, J, X), vt = getAbsoluteDist(L, J, V)) : (nt = getAbsoluteDistByClient(ht, pt, U, z), ct = getAbsoluteDistByClient(ht, pt, J, X), vt = getAbsoluteDistByClient(ht, pt, J, V), mt = !0);\n      if (st = St + nt, dt = St + ct, _t = Ft + vt, triggerEvent(n, \"onBeforeRotate\", fillParams(n, t, {\n        beforeRotation: st,\n        rotation: dt,\n        absoluteRotation: _t,\n        setRotation: function(Gt) {\n          ct = Gt - St, nt = ct, vt = ct;\n        }\n      }, !0)), e = getRotateInfo(n, q, z, nt, St, mt), tt = e[0], nt = e[1], st = e[2], o = getRotateInfo(n, q, X, ct, St, mt), ut = o[0], ct = o[1], dt = o[2], R = getRotateInfo(n, q, V, vt, Ft, mt), Et = R[0], vt = R[1], _t = R[2], !(!Et && !ut && !tt && !rt)) {\n        var At = convertTransformFormat(N, \"rotate(\".concat(dt, \"deg)\"), \"rotate(\".concat(ct, \"deg)\")), Rt = getRotateDist(n, ct, N), Lt = minus(plus(k || [0, 0], Rt), N.prevInverseDist || [0, 0]);\n        N.prevInverseDist = Rt, N.requestValue = null;\n        var lt = fillTransformEvent(n, At, Lt, $, t), $t = lt, Pt = getDist$2([ht, pt], V.startAbsoluteOrigin) - V.startDist, kt = void 0;\n        if (N.resolveAble === \"resizable\") {\n          var Ot = n.getAble(\"resizable\").dragControl(n, __assign$2(__assign$2({}, setCustomDrag(t, n.state, [t.deltaX, t.deltaY], !!$, !1, \"resizable\")), {\n            resolveMatrix: !0,\n            parentDistance: Pt\n          }));\n          Ot && (kt = Ot, $t = fillAfterTransform($t, Ot));\n        }\n        var gt = fillParams(n, t, __assign$2(__assign$2({\n          delta: ut,\n          dist: ct,\n          rotate: dt,\n          rotation: dt,\n          beforeDist: nt,\n          beforeDelta: tt,\n          beforeRotate: st,\n          beforeRotation: st,\n          absoluteDist: vt,\n          absoluteDelta: Et,\n          absoluteRotate: _t,\n          absoluteRotation: _t,\n          isPinch: !!$,\n          resize: kt\n        }, lt), $t));\n        return triggerEvent(n, \"onRotate\", gt), gt;\n      }\n    }\n  },\n  dragControlAfter: function(n, t) {\n    t.datas.requestValue;\n  },\n  dragControlEnd: function(n, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      e.isRotate = !1;\n      var o = fillEndParams(n, t, {});\n      return triggerEvent(n, \"onRotateEnd\", o), o;\n    }\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function(n, t) {\n    var e = t.datas, o = n.state, R = o.left, N = o.top, M = o.beforeOrigin, D = this.dragControlStart(n, t);\n    if (!D)\n      return !1;\n    D.set(e.beforeDirection * n.rotation);\n    var L = triggerChildAbles(n, this, \"dragControlStart\", t, function(k, U) {\n      var z = k.state, X = z.left, V = z.top, W = z.beforeOrigin, Y = plus(minus([X, V], [R, N]), minus(W, M));\n      return U.datas.groupClient = Y, __assign$2(__assign$2({}, U), {\n        parentRotate: 0\n      });\n    }), B = __assign$2(__assign$2({}, D), {\n      targets: n.props.targets,\n      events: L\n    }), $ = triggerEvent(n, \"onRotateGroupStart\", B);\n    return e.isRotate = $ !== !1, e.isRotate ? D : !1;\n  },\n  dragGroupControl: function(n, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      catchEvent(n, \"onBeforeRotate\", function($) {\n        triggerEvent(n, \"onBeforeRotateGroup\", fillParams(n, t, __assign$2(__assign$2({}, $), {\n          targets: n.props.targets\n        }), !0));\n      });\n      var o = this.dragControl(n, t);\n      if (!!o) {\n        var R = e.beforeDirection, N = o.beforeDist, M = o.beforeDelta, D = M / 180 * Math.PI, L = triggerChildAbles(n, this, \"dragControl\", t, function($, k) {\n          var U = k.datas.groupClient, z = U[0], X = U[1], V = rotate([z, X], D * R), W = V[0], Y = V[1], q = [W - z, Y - X];\n          return k.datas.groupClient = [W, Y], __assign$2(__assign$2({}, k), {\n            parentRotate: N,\n            groupDelta: q\n          });\n        });\n        n.rotation = R * o.beforeRotation;\n        var B = __assign$2({\n          targets: n.props.targets,\n          events: L,\n          set: function($) {\n            n.rotation = $;\n          },\n          setGroupRotation: function($) {\n            n.rotation = $;\n          }\n        }, o);\n        return triggerEvent(n, \"onRotateGroup\", B), B;\n      }\n    }\n  },\n  dragGroupControlEnd: function(n, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isRotate) {\n      this.dragControlEnd(n, t);\n      var R = triggerChildAbles(n, this, \"dragControlEnd\", t), N = fillEndParams(n, t, {\n        targets: n.props.targets,\n        events: R\n      });\n      return triggerEvent(n, \"onRotateGroupEnd\", N), e;\n    }\n  },\n  request: function(n) {\n    var t = {}, e = 0, o = n.getRotation();\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(R) {\n        return \"deltaRotate\" in R ? e += R.deltaRotate : \"rotate\" in R && (e = R.rotate - o), {\n          datas: t,\n          parentDist: e\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  render: function(n, t) {\n    var e = n.props, o = e.throttleDragRotate, R = e.zoom, N = n.state, M = N.dragInfo, D = N.beforeOrigin;\n    if (!o || !M)\n      return [];\n    var L = M.dist;\n    if (!L[0] && !L[1])\n      return [];\n    var B = getDistSize(L), $ = getRad$1(L, [0, 0]);\n    return [t.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat(B, \"px\"),\n        transform: \"translate(\".concat(D[0], \"px, \").concat(D[1], \"px) rotate(\").concat($, \"rad) scaleY(\").concat(R, \")\")\n      }\n    })];\n  },\n  dragStart: function(n, t) {\n    var e = t.datas, o = t.parentEvent, R = t.parentGesto, N = n.state, M = N.target, D = N.gestos;\n    if (D.draggable)\n      return !1;\n    D.draggable = R || n.targetGesto;\n    var L = getComputedStyle$2(M);\n    e.datas = {}, e.left = parseFloat(L.left || \"\") || 0, e.top = parseFloat(L.top || \"\") || 0, e.bottom = parseFloat(L.bottom || \"\") || 0, e.right = parseFloat(L.right || \"\") || 0, e.startValue = [0, 0], setDragStart(n, t), setDefaultTransformIndex(t, \"translate\"), startCheckSnapDrag(n, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];\n    var B = fillParams(n, t, __assign$2({\n      set: function(k) {\n        e.startValue = k;\n      }\n    }, fillTransformStartEvent(t))), $ = o || triggerEvent(n, \"onDragStart\", B);\n    return $ !== !1 ? (e.isDrag = !0, n.state.dragInfo = {\n      startRect: n.getRect(),\n      dist: [0, 0]\n    }) : (D.draggable = null, e.isPinch = !1), e.isDrag ? B : !1;\n  },\n  drag: function(n, t) {\n    if (!!t) {\n      resolveTransformEvent(t, \"translate\");\n      var e = t.datas, o = t.parentEvent, R = t.parentFlag, N = t.isPinch, M = t.isRequest, D = t.deltaOffset, L = t.distX, B = t.distY, $ = e.isDrag, k = e.prevDist, U = e.prevBeforeDist, z = e.startValue;\n      if (!!$) {\n        D && (L += D[0], B += D[1]);\n        var X = n.props, V = X.parentMoveable, W = o ? 0 : X.throttleDrag || 0, Y = o ? 0 : X.throttleDragRotate || 0, q = !1, Z = 0;\n        if (!o && Y > 0 && (L || B)) {\n          var K = X.startDragRotate || 0, Q = throttle(K + getRad$1([0, 0], [L, B]) * 180 / Math.PI, Y) - K, J = B * Math.abs(Math.cos((Q - 90) / 180 * Math.PI)), rt = L * Math.abs(Math.cos(Q / 180 * Math.PI)), tt = getDistSize([rt, J]);\n          Z = Q * Math.PI / 180, L = tt * Math.cos(Z), B = tt * Math.sin(Z);\n        }\n        if (!N && !o && !R && (!Y || L || B)) {\n          var nt = checkSnapBoundsDrag(n, L, B, Y, M || D, e), st = nt[0], ut = nt[1], ct = st.isSnap, dt = st.isBound, Et = st.offset, vt = ut.isSnap, _t = ut.isBound, St = ut.offset;\n          q = ct || vt || dt || _t, L += Et, B += St;\n        }\n        var Ft = plus(getBeforeDragDist({\n          datas: e,\n          distX: L,\n          distY: B\n        }), z), mt = plus(getTransformDist({\n          datas: e,\n          distX: L,\n          distY: B\n        }), z);\n        !Y && !q && (throttleArray(mt, W), throttleArray(Ft, W)), throttleArray(mt, TINY_NUM), throttleArray(Ft, TINY_NUM);\n        var ht = minus(Ft, z), pt = minus(mt, z), xt = minus(pt, k), At = minus(ht, U);\n        e.prevDist = pt, e.prevBeforeDist = ht, e.passDelta = xt, e.passDist = pt;\n        var Rt = e.left + ht[0], Lt = e.top + ht[1], lt = e.right - ht[0], $t = e.bottom - ht[1], Pt = convertTransformFormat(e, \"translate(\".concat(mt[0], \"px, \").concat(mt[1], \"px)\"), \"translate(\".concat(pt[0], \"px, \").concat(pt[1], \"px)\"));\n        if (fillOriginalTransform(t, Pt), n.state.dragInfo.dist = o ? [0, 0] : pt, !(!o && !V && xt.every(function(Tt) {\n          return !Tt;\n        }) && At.some(function(Tt) {\n          return !Tt;\n        }))) {\n          var kt = n.state, Ot = kt.width, gt = kt.height, Gt = fillParams(n, t, __assign$2({\n            transform: Pt,\n            dist: pt,\n            delta: xt,\n            translate: mt,\n            beforeDist: ht,\n            beforeDelta: At,\n            beforeTranslate: Ft,\n            left: Rt,\n            top: Lt,\n            right: lt,\n            bottom: $t,\n            width: Ot,\n            height: gt,\n            isPinch: N\n          }, fillCSSObject({\n            style: Pt\n          })));\n          return !o && triggerEvent(n, \"onDrag\", Gt), Gt;\n        }\n      }\n    }\n  },\n  dragAfter: function(n, t) {\n    var e = t.datas, o = e.deltaOffset;\n    return o[0] || o[1] ? (e.deltaOffset = [0, 0], this.drag(n, __assign$2(__assign$2({}, t), {\n      deltaOffset: o\n    }))) : !1;\n  },\n  dragEnd: function(n, t) {\n    var e = t.parentEvent, o = t.datas;\n    if (n.state.dragInfo = null, !!o.isDrag) {\n      o.isDrag = !1;\n      var R = fillEndParams(n, t, {});\n      return !e && triggerEvent(n, \"onDragEnd\", R), R;\n    }\n  },\n  dragGroupStart: function(n, t) {\n    var e = t.datas, o = t.clientX, R = t.clientY, N = this.dragStart(n, t);\n    if (!N)\n      return !1;\n    var M = triggerChildGesto(n, this, \"dragStart\", [o || 0, R || 0], t, !1, \"draggable\"), D = __assign$2(__assign$2({}, N), {\n      targets: n.props.targets,\n      events: M\n    }), L = triggerEvent(n, \"onDragGroupStart\", D);\n    return e.isDrag = L !== !1, e.isDrag ? N : !1;\n  },\n  dragGroup: function(n, t) {\n    var e = t.datas;\n    if (!!e.isDrag) {\n      var o = this.drag(n, t), R = t.datas.passDelta, N = triggerChildGesto(n, this, \"drag\", R, t, !1, \"draggable\");\n      if (!!o) {\n        var M = __assign$2({\n          targets: n.props.targets,\n          events: N\n        }, o);\n        return triggerEvent(n, \"onDragGroup\", M), M;\n      }\n    }\n  },\n  dragGroupEnd: function(n, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isDrag) {\n      this.dragEnd(n, t);\n      var R = triggerChildGesto(n, this, \"dragEnd\", [0, 0], t, !1, \"draggable\");\n      return triggerEvent(n, \"onDragGroupEnd\", fillEndParams(n, t, {\n        targets: n.props.targets,\n        events: R\n      })), e;\n    }\n  },\n  request: function(n) {\n    var t = {}, e = n.getRect(), o = 0, R = 0;\n    return {\n      isControl: !1,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(N) {\n        return \"x\" in N ? o = N.x - e.left : \"deltaX\" in N && (o += N.deltaX), \"y\" in N ? R = N.y - e.top : \"deltaY\" in N && (R += N.deltaY), {\n          datas: t,\n          distX: o,\n          distY: R\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(n) {\n    n.state.dragInfo = null;\n  }\n}, directionCondition$1 = getDirectionCondition(\"resizable\"), Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean,\n    resizeFormat: Function,\n    keepRatioFinally: Boolean,\n    edge: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onBeforeResize: \"beforeResize\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onBeforeResizeGroup: \"beforeResizeGroup\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: getRenderDirections(\"resizable\"),\n  dragControlCondition: directionCondition$1,\n  dragControlStart: function(n, t) {\n    var e, o = t.inputEvent, R = t.isPinch, N = t.isGroup, M = t.parentDirection, D = t.parentGesto, L = t.datas, B = t.parentFixedDirection, $ = t.parentEvent, k = M || (R ? [0, 0] : getDirection(o.target)), U = n.state, z = U.target, X = U.width, V = U.height, W = U.gestos;\n    if (!k || !z || W.resizable)\n      return !1;\n    W.resizable = D || n.controlGesto, !R && setDragStart(n, t), L.datas = {}, L.direction = k, L.startOffsetWidth = X, L.startOffsetHeight = V, L.prevWidth = 0, L.prevHeight = 0, L.minSize = [0, 0], L.startWidth = U.cssWidth, L.startHeight = U.cssHeight, L.maxSize = [1 / 0, 1 / 0], N || (L.minSize = [U.minOffsetWidth, U.minOffsetHeight], L.maxSize = [U.maxOffsetWidth, U.maxOffsetHeight]);\n    var Y = n.props.transformOrigin || \"% %\";\n    L.transformOrigin = Y && isString(Y) ? Y.split(\" \") : Y, L.startOffsetMatrix = U.offsetMatrix, L.startTransformOrigin = U.transformOrigin, L.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !k[0] && !k[1] || k[0] || !k[1];\n    function q(tt) {\n      L.ratio = tt && isFinite(tt) ? tt : 0;\n    }\n    L.startPositions = getAbsolutePosesByState(n.state);\n    function Z(tt) {\n      L.fixedDirection = tt, L.fixedPosition = getPosByDirection(L.startPositions, tt);\n    }\n    function K(tt) {\n      L.minSize = [convertUnitSize(\"\".concat(tt[0]), 0) || 0, convertUnitSize(\"\".concat(tt[1]), 0) || 0];\n    }\n    function Q(tt) {\n      var nt = [tt[0] || 1 / 0, tt[1] || 1 / 0];\n      (!isNumber(nt[0]) || isFinite(nt[0])) && (nt[0] = convertUnitSize(\"\".concat(nt[0]), 0) || 1 / 0), (!isNumber(nt[1]) || isFinite(nt[1])) && (nt[1] = convertUnitSize(\"\".concat(nt[1]), 0) || 1 / 0), L.maxSize = nt;\n    }\n    q(X / V), Z(B || [-k[0], -k[1]]), L.setFixedDirection = Z, L.setMin = K, L.setMax = Q;\n    var J = fillParams(n, t, {\n      direction: k,\n      startRatio: L.ratio,\n      set: function(tt) {\n        var nt = tt[0], st = tt[1];\n        L.startWidth = nt, L.startHeight = st;\n      },\n      setMin: K,\n      setMax: Q,\n      setRatio: q,\n      setFixedDirection: Z,\n      setOrigin: function(tt) {\n        L.transformOrigin = tt;\n      },\n      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))\n    }), rt = $ || triggerEvent(n, \"onResizeStart\", J);\n    return rt !== !1 && (L.isResize = !0, n.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: k\n    }), L.isResize ? J : !1;\n  },\n  dragControl: function(n, t) {\n    var e, o = t.datas, R = t.parentFlag, N = t.isPinch, M = t.parentKeepRatio, D = t.dragClient, L = t.parentDist, B = t.isRequest, $ = t.isGroup, k = t.parentEvent, U = t.resolveMatrix, z = o.isResize, X = o.transformOrigin, V = o.startWidth, W = o.startHeight, Y = o.prevWidth, q = o.prevHeight, Z = o.minSize, K = o.maxSize, Q = o.ratio, J = o.startOffsetWidth, rt = o.startOffsetHeight, tt = o.isWidth;\n    if (!z)\n      return;\n    if (U) {\n      var nt = n.state.is3d, st = o.startOffsetMatrix, ut = o.startTransformOrigin, ct = nt ? 4 : 3, dt = parseMat(getNextTransforms(t)), Et = Math.sqrt(dt.length);\n      ct !== Et && (dt = convertDimension(dt, Et, ct));\n      var vt = getNextMatrix(st, dt, ut, ct), _t = calculatePoses(vt, J, rt, ct);\n      o.startPositions = _t, o.nextTargetMatrix = dt, o.nextAllMatrix = vt;\n    }\n    var St = getProps(n.props, \"resizable\"), Ft = St.resizeFormat, mt = St.throttleResize, ht = mt === void 0 ? R ? 0 : 1 : mt, pt = St.parentMoveable, xt = St.keepRatioFinally, At = o.direction, Rt = At, Lt = 0, lt = 0;\n    !At[0] && !At[1] && (Rt = [1, 1]);\n    var $t = Q && (M != null ? M : St.keepRatio) || !1;\n    function Pt() {\n      var ie = o.fixedDirection, Te = getOffsetSizeDist(Rt, $t, o, t);\n      Lt = Te.distWidth, lt = Te.distHeight;\n      var ge = Rt[0] - ie[0] || $t ? Math.max(J + Lt, TINY_NUM) : J, Fe = Rt[1] - ie[1] || $t ? Math.max(rt + lt, TINY_NUM) : rt;\n      return $t && J && rt && (tt ? Fe = ge / Q : ge = Fe * Q), [ge, Fe];\n    }\n    var kt = Pt(), Ot = kt[0], gt = kt[1];\n    k || (o.setFixedDirection(o.fixedDirection), triggerEvent(n, \"onBeforeResize\", fillParams(n, t, {\n      setFixedDirection: function(ie) {\n        var Te;\n        return o.setFixedDirection(ie), Te = Pt(), Ot = Te[0], gt = Te[1], [Ot, gt];\n      },\n      boundingWidth: Ot,\n      boundingHeight: gt,\n      setSize: function(ie) {\n        Ot = ie[0], gt = ie[1];\n      }\n    }, !0)));\n    var Gt = D;\n    D || (!R && N ? Gt = getAbsolutePosition(n, [0, 0]) : Gt = o.fixedPosition);\n    var Tt = [0, 0];\n    N || (Tt = checkSnapResize(n, Ot, gt, At, Gt, B, o)), L && (!L[0] && (Tt[0] = 0), !L[1] && (Tt[1] = 0));\n    function bt() {\n      var ie;\n      Ft && (ie = Ft([Ot, gt]), Ot = ie[0], gt = ie[1]), Ot = throttle(Ot, ht), gt = throttle(gt, ht);\n    }\n    if ($t) {\n      Rt[0] && Rt[1] && Tt[0] && Tt[1] && (Math.abs(Tt[0]) > Math.abs(Tt[1]) ? Tt[1] = 0 : Tt[0] = 0);\n      var wt = !Tt[0] && !Tt[1];\n      wt && bt(), Rt[0] && !Rt[1] || Tt[0] && !Tt[1] || wt && tt ? (Ot += Tt[0], gt = Ot / Q) : (!Rt[0] && Rt[1] || !Tt[0] && Tt[1] || wt && !tt) && (gt += Tt[1], Ot = gt * Q);\n    } else\n      Ot += Tt[0], gt += Tt[1], Ot = Math.max(0, Ot), gt = Math.max(0, gt);\n    e = calculateBoundSize([Ot, gt], Z, K, $t ? Q : !1), Ot = e[0], gt = e[1], bt(), $t && ($ || xt) && (tt ? gt = Ot / Q : Ot = gt * Q), Lt = Ot - J, lt = gt - rt;\n    var Mt = [Lt - Y, lt - q];\n    o.prevWidth = Lt, o.prevHeight = lt;\n    var Ct = getResizeDist(n, Ot, gt, Gt, X, o);\n    if (!(!pt && Mt.every(function(ie) {\n      return !ie;\n    }) && Ct.every(function(ie) {\n      return !ie;\n    }))) {\n      var Zt = Draggable.drag(n, setCustomDrag(t, n.state, Ct, !!N, !1, \"draggable\")), Yt = Zt.transform, se = fillParams(n, t, __assign$2({\n        width: V + Lt,\n        height: W + lt,\n        offsetWidth: Math.round(Ot),\n        offsetHeight: Math.round(gt),\n        startRatio: Q,\n        boundingWidth: Ot,\n        boundingHeight: gt,\n        direction: At,\n        dist: [Lt, lt],\n        delta: Mt,\n        isPinch: !!N,\n        drag: Zt\n      }, fillAfterTransform({\n        style: {\n          width: \"\".concat(Ot, \"px\"),\n          height: \"\".concat(gt, \"px\")\n        },\n        transform: Yt\n      }, Zt)));\n      return !k && triggerEvent(n, \"onResize\", se), se;\n    }\n  },\n  dragControlAfter: function(n, t) {\n    var e = t.datas, o = e.isResize, R = e.startOffsetWidth, N = e.startOffsetHeight, M = e.prevWidth, D = e.prevHeight;\n    if (!!o) {\n      var L = n.state, B = L.width, $ = L.height, k = B - (R + M), U = $ - (N + D), z = Math.abs(k) > 3, X = Math.abs(U) > 3;\n      if (z && (e.startWidth += k, e.startOffsetWidth += k, e.prevWidth += k), X && (e.startHeight += U, e.startOffsetHeight += U, e.prevHeight += U), z || X)\n        return this.dragControl(n, t);\n    }\n  },\n  dragControlEnd: function(n, t) {\n    var e = t.datas, o = t.parentEvent;\n    if (!!e.isResize) {\n      e.isResize = !1;\n      var R = fillEndParams(n, t, {});\n      return !o && triggerEvent(n, \"onResizeEnd\", R), R;\n    }\n  },\n  dragGroupControlCondition: directionCondition$1,\n  dragGroupControlStart: function(n, t) {\n    var e = t.datas, o = this.dragControlStart(n, __assign$2(__assign$2({}, t), {\n      isGroup: !0\n    }));\n    if (!o)\n      return !1;\n    var R = fillChildEvents(n, \"resizable\", t);\n    function N(X, V) {\n      var W = e.fixedDirection, Y = e.fixedPosition, q = V.datas.startPositions || getAbsolutePosesByState(X.state), Z = getPosByDirection(q, W), K = calculate(createRotateMatrix(-n.rotation / 180 * Math.PI, 3), [Z[0] - Y[0], Z[1] - Y[1], 1], 3), Q = K[0], J = K[1];\n      return V.datas.originalX = Q, V.datas.originalY = J, V;\n    }\n    var M = e.startOffsetWidth, D = e.startOffsetHeight;\n    function L() {\n      var X = e.minSize;\n      R.forEach(function(V) {\n        var W = V.datas, Y = W.minSize, q = W.startOffsetWidth, Z = W.startOffsetHeight, K = M * (q ? Y[0] / q : 0), Q = D * (Z ? Y[1] / Z : 0);\n        X[0] = Math.max(X[0], K), X[1] = Math.max(X[1], Q);\n      });\n    }\n    function B() {\n      var X = e.maxSize;\n      R.forEach(function(V) {\n        var W = V.datas, Y = W.maxSize, q = W.startOffsetWidth, Z = W.startOffsetHeight, K = M * (q ? Y[0] / q : 0), Q = D * (Z ? Y[1] / Z : 0);\n        X[0] = Math.min(X[0], K), X[1] = Math.min(X[1], Q);\n      });\n    }\n    var $ = triggerChildAbles(n, this, \"dragControlStart\", t, function(X, V) {\n      return N(X, V);\n    });\n    L(), B();\n    var k = function(X) {\n      o.setFixedDirection(X), $.forEach(function(V, W) {\n        V.setFixedDirection(X), N(V.moveable, R[W]);\n      });\n    };\n    e.setFixedDirection = k;\n    var U = __assign$2(__assign$2({}, o), {\n      targets: n.props.targets,\n      events: $.map(function(X) {\n        return __assign$2(__assign$2({}, X), {\n          setMin: function(V) {\n            X.setMin(V), L();\n          },\n          setMax: function(V) {\n            X.setMax(V), B();\n          }\n        });\n      }),\n      setFixedDirection: k,\n      setMin: function(X) {\n        o.setMin(X), L();\n      },\n      setMax: function(X) {\n        o.setMax(X), B();\n      }\n    }), z = triggerEvent(n, \"onResizeGroupStart\", U);\n    return e.isResize = z !== !1, e.isResize ? o : !1;\n  },\n  dragGroupControl: function(n, t) {\n    var e = t.datas;\n    if (!!e.isResize) {\n      var o = getProps(n.props, \"resizable\");\n      catchEvent(n, \"onBeforeResize\", function(z) {\n        triggerEvent(n, \"onBeforeResizeGroup\", fillParams(n, t, __assign$2(__assign$2({}, z), {\n          targets: o.targets\n        }), !0));\n      });\n      var R = this.dragControl(n, __assign$2(__assign$2({}, t), {\n        isGroup: !0\n      }));\n      if (!!R) {\n        var N = R.boundingWidth, M = R.boundingHeight, D = R.dist, L = o.keepRatio, B = [N / (N - D[0]), M / (M - D[1])], $ = e.fixedPosition, k = triggerChildAbles(n, this, \"dragControl\", t, function(z, X) {\n          var V = calculate(createRotateMatrix(n.rotation / 180 * Math.PI, 3), [X.datas.originalX * B[0], X.datas.originalY * B[1], 1], 3), W = V[0], Y = V[1];\n          return __assign$2(__assign$2({}, X), {\n            parentDist: null,\n            parentScale: B,\n            dragClient: plus($, [W, Y]),\n            parentKeepRatio: L\n          });\n        }), U = __assign$2({\n          targets: o.targets,\n          events: k\n        }, R);\n        return triggerEvent(n, \"onResizeGroup\", U), U;\n      }\n    }\n  },\n  dragGroupControlEnd: function(n, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isResize) {\n      this.dragControlEnd(n, t);\n      var R = triggerChildAbles(n, this, \"dragControlEnd\", t), N = fillEndParams(n, t, {\n        targets: n.props.targets,\n        events: R\n      });\n      return triggerEvent(n, \"onResizeGroupEnd\", N), e;\n    }\n  },\n  request: function(n) {\n    var t = {}, e = 0, o = 0, R = n.getRect();\n    return {\n      isControl: !0,\n      requestStart: function(N) {\n        var M;\n        return {\n          datas: t,\n          parentDirection: N.direction || [1, 1],\n          parentIsWidth: (M = N == null ? void 0 : N.horizontal) !== null && M !== void 0 ? M : !0\n        };\n      },\n      request: function(N) {\n        return \"offsetWidth\" in N ? e = N.offsetWidth - R.offsetWidth : \"deltaWidth\" in N && (e += N.deltaWidth), \"offsetHeight\" in N ? o = N.offsetHeight - R.offsetHeight : \"deltaHeight\" in N && (o += N.deltaHeight), {\n          datas: t,\n          parentDist: [e, o],\n          parentKeepRatio: N.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, directionCondition = getDirectionCondition(\"scalable\"), Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean,\n    edge: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onBeforeScale: \"beforeScale\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onBeforeScaleGroup: \"beforeScaleGroup\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: getRenderDirections(\"scalable\"),\n  dragControlCondition: directionCondition,\n  dragControlStart: function(n, t) {\n    var e = t.datas, o = t.isPinch, R = t.inputEvent, N = t.parentDirection, M = N || (o ? [0, 0] : getDirection(R.target)), D = n.state, L = D.width, B = D.height, $ = D.targetTransform, k = D.target, U = D.pos1, z = D.pos2, X = D.pos4;\n    if (!M || !k)\n      return !1;\n    o || setDragStart(n, t), e.datas = {}, e.transform = $, e.prevDist = [1, 1], e.direction = M, e.startOffsetWidth = L, e.startOffsetHeight = B, e.startValue = [1, 1];\n    var V = getDist$2(U, z), W = getDist$2(z, X), Y = !M[0] && !M[1] || M[0] || !M[1];\n    e.scaleWidth = V, e.scaleHeight = W, e.scaleXRatio = V / L, e.scaleYRatio = W / B, setDefaultTransformIndex(t, \"scale\"), e.isWidth = Y;\n    function q(J) {\n      e.ratio = J && isFinite(J) ? J : 0;\n    }\n    e.startPositions = getAbsolutePosesByState(n.state);\n    function Z(J) {\n      e.fixedDirection = J, e.fixedPosition = getPosByDirection(e.startPositions, J);\n    }\n    e.setFixedDirection = Z, q(getDist$2(U, z) / getDist$2(z, X)), Z([-M[0], -M[1]]);\n    var K = fillParams(n, t, __assign$2(__assign$2({\n      direction: M,\n      set: function(J) {\n        e.startValue = J;\n      },\n      setRatio: q,\n      setFixedDirection: Z\n    }, fillTransformStartEvent(t)), {\n      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))\n    })), Q = triggerEvent(n, \"onScaleStart\", K);\n    return Q !== !1 && (e.isScale = !0, n.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: M\n    }), e.isScale ? K : !1;\n  },\n  dragControl: function(n, t) {\n    resolveTransformEvent(t, \"scale\");\n    var e = t.datas, o = t.parentKeepRatio, R = t.parentFlag, N = t.isPinch, M = t.dragClient, D = t.isRequest, L = e.prevDist, B = e.direction, $ = e.startOffsetWidth, k = e.startOffsetHeight, U = e.isScale, z = e.startValue, X = e.isWidth, V = e.ratio;\n    if (!U)\n      return !1;\n    var W = n.props, Y = W.throttleScale, q = W.parentMoveable, Z = B;\n    !B[0] && !B[1] && (Z = [1, 1]);\n    var K = V && (o != null ? o : W.keepRatio) || !1, Q = n.state;\n    function J() {\n      var pt = getOffsetSizeDist(Z, K, e, t), xt = pt.distWidth, At = pt.distHeight, Rt = ($ + xt) / $, Lt = (k + At) / k;\n      return Rt = Z[0] || K ? Rt * z[0] : z[0], Lt = Z[1] || K ? Lt * z[1] : z[1], Rt === 0 && (Rt = (L[0] > 0 ? 1 : -1) * MIN_SCALE), Lt === 0 && (Lt = (L[1] > 0 ? 1 : -1) * MIN_SCALE), [Rt, Lt];\n    }\n    var rt = J();\n    if (!N && n.props.groupable) {\n      var tt = Q.snapRenderInfo || {}, nt = tt.direction;\n      isArray(nt) && (nt[0] || nt[1]) && (Q.snapRenderInfo = {\n        direction: B,\n        request: t.isRequest\n      });\n    }\n    triggerEvent(n, \"onBeforeScale\", fillParams(n, t, {\n      scale: rt,\n      setFixedDirection: function(pt) {\n        return e.setFixedDirection(pt), rt = J(), rt;\n      },\n      setScale: function(pt) {\n        rt = pt;\n      }\n    }, !0));\n    var st = [rt[0] / z[0], rt[1] / z[1]], ut = M, ct = [0, 0];\n    if (M || (!R && N ? ut = getAbsolutePosition(n, [0, 0]) : ut = e.fixedPosition), N || (ct = checkSnapScale(n, st, B, D, e)), K) {\n      Z[0] && Z[1] && ct[0] && ct[1] && (Math.abs(ct[0] * $) > Math.abs(ct[1] * k) ? ct[1] = 0 : ct[0] = 0);\n      var dt = !ct[0] && !ct[1];\n      if (dt && (X ? st[0] = throttle(st[0] * z[0], Y) / z[0] : st[1] = throttle(st[1] * z[1], Y) / z[1]), Z[0] && !Z[1] || ct[0] && !ct[1] || dt && X) {\n        st[0] += ct[0];\n        var Et = $ * st[0] * z[0] / V;\n        st[1] = Et / k / z[1];\n      } else if (!Z[0] && Z[1] || !ct[0] && ct[1] || dt && !X) {\n        st[1] += ct[1];\n        var vt = k * st[1] * z[1] * V;\n        st[0] = vt / $ / z[0];\n      }\n    } else\n      st[0] += ct[0], st[1] += ct[1], ct[0] || (st[0] = throttle(st[0] * z[0], Y) / z[0]), ct[1] || (st[1] = throttle(st[1] * z[1], Y) / z[1]);\n    st[0] === 0 && (st[0] = (L[0] > 0 ? 1 : -1) * MIN_SCALE), st[1] === 0 && (st[1] = (L[1] > 0 ? 1 : -1) * MIN_SCALE);\n    var _t = [st[0] / L[0], st[1] / L[1]];\n    rt = multiply2(st, z);\n    var St = getScaleDist(n, st, e.fixedDirection, ut, e), Ft = minus(St, e.prevInverseDist || [0, 0]);\n    if (e.prevDist = st, e.prevInverseDist = St, rt[0] === L[0] && rt[1] === L[1] && Ft.every(function(pt) {\n      return !pt;\n    }) && !q)\n      return !1;\n    var mt = convertTransformFormat(e, \"scale(\".concat(rt.join(\", \"), \")\"), \"scale(\".concat(st.join(\", \"), \")\")), ht = fillParams(n, t, __assign$2({\n      offsetWidth: $,\n      offsetHeight: k,\n      direction: B,\n      scale: rt,\n      dist: st,\n      delta: _t,\n      isPinch: !!N\n    }, fillTransformEvent(n, mt, Ft, N, t)));\n    return triggerEvent(n, \"onScale\", ht), ht;\n  },\n  dragControlEnd: function(n, t) {\n    var e = t.datas, o = t.isDrag;\n    return e.isScale ? (e.isScale = !1, triggerEvent(n, \"onScaleEnd\", fillEndParams(n, t, {})), o) : !1;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(n, t) {\n    var e = t.datas, o = this.dragControlStart(n, t);\n    if (!o)\n      return !1;\n    var R = fillChildEvents(n, \"resizable\", t);\n    function N($, k) {\n      var U = e.fixedDirection, z = e.fixedPosition, X = k.datas.startPositions || getAbsolutePosesByState($.state), V = getPosByDirection(X, U), W = calculate(createRotateMatrix(-n.rotation / 180 * Math.PI, 3), [V[0] - z[0], V[1] - z[1], 1], 3), Y = W[0], q = W[1];\n      return k.datas.originalX = Y, k.datas.originalY = q, k;\n    }\n    e.moveableScale = n.scale;\n    var M = triggerChildAbles(n, this, \"dragControlStart\", t, function($, k) {\n      return N($, k);\n    }), D = function($) {\n      o.setFixedDirection($), M.forEach(function(k, U) {\n        k.setFixedDirection($), N(k.moveable, R[U]);\n      });\n    };\n    e.setFixedDirection = D;\n    var L = __assign$2(__assign$2({}, o), {\n      targets: n.props.targets,\n      events: M,\n      setFixedDirection: D\n    }), B = triggerEvent(n, \"onScaleGroupStart\", L);\n    return e.isScale = B !== !1, e.isScale ? L : !1;\n  },\n  dragGroupControl: function(n, t) {\n    var e = t.datas;\n    if (!!e.isScale) {\n      catchEvent(n, \"onBeforeScale\", function(k) {\n        triggerEvent(n, \"onBeforeScaleGroup\", fillParams(n, t, __assign$2(__assign$2({}, k), {\n          targets: n.props.targets\n        }), !0));\n      });\n      var o = this.dragControl(n, t);\n      if (!!o) {\n        var R = e.moveableScale;\n        n.scale = [o.scale[0] * R[0], o.scale[1] * R[1]];\n        var N = n.props.keepRatio, M = o.dist, D = o.scale, L = e.fixedPosition, B = triggerChildAbles(n, this, \"dragControl\", t, function(k, U) {\n          var z = calculate(createRotateMatrix(n.rotation / 180 * Math.PI, 3), [U.datas.originalX * M[0], U.datas.originalY * M[1], 1], 3), X = z[0], V = z[1];\n          return __assign$2(__assign$2({}, U), {\n            parentDist: null,\n            parentScale: D,\n            parentKeepRatio: N,\n            dragClient: plus(L, [X, V])\n          });\n        }), $ = __assign$2({\n          targets: n.props.targets,\n          events: B\n        }, o);\n        return triggerEvent(n, \"onScaleGroup\", $), $;\n      }\n    }\n  },\n  dragGroupControlEnd: function(n, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isScale) {\n      this.dragControlEnd(n, t);\n      var R = triggerChildAbles(n, this, \"dragControlEnd\", t), N = fillEndParams(n, t, {\n        targets: n.props.targets,\n        events: R\n      });\n      return triggerEvent(n, \"onScaleGroupEnd\", N), e;\n    }\n  },\n  request: function() {\n    var n = {}, t = 0, e = 0;\n    return {\n      isControl: !0,\n      requestStart: function(o) {\n        return {\n          datas: n,\n          parentDirection: o.direction || [1, 1]\n        };\n      },\n      request: function(o) {\n        return t += o.deltaWidth, e += o.deltaHeight, {\n          datas: n,\n          parentDist: [t, e],\n          parentKeepRatio: o.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: n,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction getMiddleLinePos(n, t) {\n  return n.map(function(e, o) {\n    return dot(e, t[o], 1, 2);\n  });\n}\nfunction getTriangleRad(n, t, e) {\n  var o = getRad$1(n, t), R = getRad$1(n, e), N = R - o;\n  return N >= 0 ? N : N + 2 * Math.PI;\n}\nfunction isValidPos(n, t) {\n  var e = getTriangleRad(n[0], n[1], n[2]), o = getTriangleRad(t[0], t[1], t[2]), R = Math.PI;\n  return !(e >= R && o <= R || e <= R && o >= R);\n}\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array,\n    edge: Boolean\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  render: function(n, t) {\n    var e = n.props, o = e.resizable, R = e.scalable, N = e.warpable, M = e.zoom;\n    if (o || R || !N)\n      return [];\n    var D = n.state, L = D.pos1, B = D.pos2, $ = D.pos3, k = D.pos4, U = getMiddleLinePos(L, B), z = getMiddleLinePos(B, L), X = getMiddleLinePos(L, $), V = getMiddleLinePos($, L), W = getMiddleLinePos($, k), Y = getMiddleLinePos(k, $), q = getMiddleLinePos(B, k), Z = getMiddleLinePos(k, B);\n    return __spreadArray([t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(U, W, M)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(z, Y, M)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(X, q, M)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(V, Z, M)\n    })], renderAllDirections(n, \"warpable\", t), !0);\n  },\n  dragControlCondition: function(n, t) {\n    if (t.isRequest)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"warpable\"));\n  },\n  dragControlStart: function(n, t) {\n    var e = t.datas, o = t.inputEvent, R = n.props.target, N = o.target, M = getDirection(N);\n    if (!M || !R)\n      return !1;\n    var D = n.state, L = D.transformOrigin, B = D.is3d, $ = D.targetTransform, k = D.targetMatrix, U = D.width, z = D.height, X = D.left, V = D.top;\n    e.datas = {}, e.targetTransform = $, e.warpTargetMatrix = B ? k : convertDimension(k, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = M, e.left = X, e.top = V, e.poses = [[0, 0], [U, 0], [0, z], [U, z]].map(function(q) {\n      return minus(q, L);\n    }), e.nextPoses = e.poses.map(function(q) {\n      var Z = q[0], K = q[1];\n      return calculate(e.warpTargetMatrix, [Z, K, 0, 1], 4);\n    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(D), e.posIndexes = getPosIndexesByDirection(M), setDragStart(n, t), setDefaultTransformIndex(t, \"matrix3d\"), D.snapRenderInfo = {\n      request: t.isRequest,\n      direction: M\n    };\n    var W = fillParams(n, t, __assign$2({\n      set: function(q) {\n        e.startValue = q;\n      }\n    }, fillTransformStartEvent(t))), Y = triggerEvent(n, \"onWarpStart\", W);\n    return Y !== !1 && (e.isWarp = !0), e.isWarp;\n  },\n  dragControl: function(n, t) {\n    var e = t.datas, o = t.isRequest, R = t.distX, N = t.distY, M = e.targetInverseMatrix, D = e.prevMatrix, L = e.isWarp, B = e.startValue, $ = e.poses, k = e.posIndexes, U = e.absolutePoses;\n    if (!L)\n      return !1;\n    if (resolveTransformEvent(t, \"matrix3d\"), hasGuidelines(n, \"warpable\")) {\n      var z = k.map(function(nt) {\n        return U[nt];\n      });\n      z.length > 1 && z.push([(z[0][0] + z[1][0]) / 2, (z[0][1] + z[1][1]) / 2]);\n      var X = checkMoveableSnapBounds(n, o, {\n        horizontal: z.map(function(nt) {\n          return nt[1] + N;\n        }),\n        vertical: z.map(function(nt) {\n          return nt[0] + R;\n        })\n      }), V = X.horizontal, W = X.vertical;\n      N -= V.offset, R -= W.offset;\n    }\n    var Y = getDragDist({\n      datas: e,\n      distX: R,\n      distY: N\n    }, !0), q = e.nextPoses.slice();\n    if (k.forEach(function(nt) {\n      q[nt] = plus(q[nt], Y);\n    }), !NEARBY_POS.every(function(nt) {\n      return isValidPos(nt.map(function(st) {\n        return $[st];\n      }), nt.map(function(st) {\n        return q[st];\n      }));\n    }))\n      return !1;\n    var Z = createWarpMatrix($[0], $[2], $[1], $[3], q[0], q[2], q[1], q[3]);\n    if (!Z.length)\n      return !1;\n    var K = multiply(M, Z, 4), Q = getTransfromMatrix(e, K, !0), J = multiply(invert(D, 4), Q, 4);\n    e.prevMatrix = Q;\n    var rt = multiply(B, Q, 4), tt = convertTransformFormat(e, \"matrix3d(\".concat(rt.join(\", \"), \")\"), \"matrix3d(\".concat(Q.join(\", \"), \")\"));\n    return fillOriginalTransform(t, tt), triggerEvent(n, \"onWarp\", fillParams(n, t, {\n      delta: J,\n      matrix: rt,\n      dist: Q,\n      multiply,\n      transform: tt\n    })), !0;\n  },\n  dragControlEnd: function(n, t) {\n    var e = t.datas, o = t.isDrag;\n    return e.isWarp ? (e.isWarp = !1, triggerEvent(n, \"onWarpEnd\", fillEndParams(n, t, {})), o) : !1;\n  }\n}, AREA_PIECES = /* @__PURE__ */ prefix(\"area-pieces\"), AREA_PIECE = /* @__PURE__ */ prefix(\"area-piece\"), AVOID = /* @__PURE__ */ prefix(\"avoid\");\nfunction restoreStyle(n) {\n  var t = n.areaElement;\n  if (!!t) {\n    var e = n.state, o = e.width, R = e.height;\n    removeClass(t, AVOID), t.style.cssText += \"left: 0px; top: 0px; width: \".concat(o, \"px; height: \").concat(R, \"px\");\n  }\n}\nfunction renderPieces(n) {\n  return n.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, n.createElement(\"div\", {\n    className: AREA_PIECE\n  }), n.createElement(\"div\", {\n    className: AREA_PIECE\n  }), n.createElement(\"div\", {\n    className: AREA_PIECE\n  }), n.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function(n, t) {\n    var e = n.props, o = e.target, R = e.dragArea, N = e.groupable, M = e.passDragArea, D = n.state, L = D.width, B = D.height, $ = D.renderPoses, k = M ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (N)\n      return [t.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(n, \"areaElement\"),\n        className: k\n      }), renderPieces(t)];\n    if (!o || !R)\n      return [];\n    var U = createWarpMatrix([0, 0], [L, 0], [0, B], [L, B], $[0], $[1], $[2], $[3]), z = U.length ? makeMatrixCSS(U, !0) : \"none\";\n    return [t.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(n, \"areaElement\"),\n      className: k,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(L, \"px\"),\n        height: \"\".concat(B, \"px\"),\n        transformOrigin: \"0 0\",\n        transform: z\n      }\n    }), renderPieces(t)];\n  },\n  dragStart: function(n, t) {\n    var e = t.datas, o = t.clientX, R = t.clientY, N = t.inputEvent;\n    if (!N)\n      return !1;\n    e.isDragArea = !1;\n    var M = n.areaElement, D = n.state, L = D.moveableClientRect, B = D.renderPoses, $ = D.rootMatrix, k = D.is3d, U = L.left, z = L.top, X = getRect(B), V = X.left, W = X.top, Y = X.width, q = X.height, Z = k ? 4 : 3, K = calculateInversePosition($, [o - U, R - z], Z), Q = K[0], J = K[1];\n    Q -= V, J -= W;\n    var rt = [{\n      left: V,\n      top: W,\n      width: Y,\n      height: J - 10\n    }, {\n      left: V,\n      top: W,\n      width: Q - 10,\n      height: q\n    }, {\n      left: V,\n      top: W + J + 10,\n      width: Y,\n      height: q - J - 10\n    }, {\n      left: V + Q + 10,\n      top: W,\n      width: Y - Q - 10,\n      height: q\n    }], tt = [].slice.call(M.nextElementSibling.children);\n    rt.forEach(function(nt, st) {\n      tt[st].style.cssText = \"left: \".concat(nt.left, \"px;top: \").concat(nt.top, \"px; width: \").concat(nt.width, \"px; height: \").concat(nt.height, \"px;\");\n    }), addClass(M, AVOID), D.disableNativeEvent = !0;\n  },\n  drag: function(n, t) {\n    var e = t.datas, o = t.inputEvent;\n    if (this.enableNativeEvent(n), !o)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, restoreStyle(n));\n  },\n  dragEnd: function(n, t) {\n    this.enableNativeEvent(n);\n    var e = t.inputEvent, o = t.datas;\n    if (!e)\n      return !1;\n    o.isDragArea || restoreStyle(n);\n  },\n  dragGroupStart: function(n, t) {\n    return this.dragStart(n, t);\n  },\n  dragGroup: function(n, t) {\n    return this.drag(n, t);\n  },\n  dragGroupEnd: function(n, t) {\n    return this.dragEnd(n, t);\n  },\n  unset: function(n) {\n    restoreStyle(n), n.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent: function(n) {\n    var t = n.state;\n    t.disableNativeEvent && requestAnimationFrame$1(function() {\n      t.disableNativeEvent = !1;\n    });\n  }\n}, Origin = makeAble(\"origin\", {\n  render: function(n, t) {\n    var e = n.props.zoom, o = n.state, R = o.beforeOrigin, N = o.rotation;\n    return [t.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(N, e, R),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction getDefaultScrollPosition(n) {\n  var t = n.scrollContainer;\n  return [t.scrollLeft, t.scrollTop];\n}\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragRelation: \"strong\",\n  dragStart: function(n, t) {\n    var e = n.props, o = e.scrollContainer, R = o === void 0 ? n.getContainer() : o, N = new DragScroll$1(), M = getRefTarget(R, !0);\n    t.datas.dragScroll = N;\n    var D = t.isControl ? \"controlGesto\" : \"targetGesto\", L = t.targets;\n    N.on(\"scroll\", function(B) {\n      var $ = B.container, k = B.direction, U = fillParams(n, t, {\n        scrollContainer: $,\n        direction: k\n      }), z = L ? \"onScrollGroup\" : \"onScroll\";\n      L && (U.targets = L), triggerEvent(n, z, U);\n    }).on(\"move\", function(B) {\n      var $ = B.offsetX, k = B.offsetY;\n      n[D].scrollBy($, k, t.inputEvent, !1);\n    }), N.dragStart(t, {\n      container: M\n    });\n  },\n  checkScroll: function(n, t) {\n    var e = t.datas.dragScroll;\n    if (!!e) {\n      var o = n.props, R = o.scrollContainer, N = R === void 0 ? n.getContainer() : R, M = o.scrollThreshold, D = M === void 0 ? 0 : M, L = o.getScrollPosition, B = L === void 0 ? getDefaultScrollPosition : L;\n      return e.drag(t, {\n        container: N,\n        threshold: D,\n        getScrollPosition: function($) {\n          return B({\n            scrollContainer: $.container,\n            direction: $.direction\n          });\n        }\n      }), !0;\n    }\n  },\n  drag: function(n, t) {\n    return this.checkScroll(n, t);\n  },\n  dragEnd: function(n, t) {\n    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;\n  },\n  dragControlStart: function(n, t) {\n    return this.dragStart(n, __assign$2(__assign$2({}, t), {\n      isControl: !0\n    }));\n  },\n  dragControl: function(n, t) {\n    return this.drag(n, t);\n  },\n  dragControlEnd: function(n, t) {\n    return this.dragEnd(n, t);\n  },\n  dragGroupStart: function(n, t) {\n    return this.dragStart(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  dragGroup: function(n, t) {\n    return this.drag(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  dragGroupEnd: function(n, t) {\n    return this.dragEnd(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  dragGroupControlStart: function(n, t) {\n    return this.dragStart(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets,\n      isControl: !0\n    }));\n  },\n  dragGroupContro: function(n, t) {\n    return this.drag(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  },\n  dragGroupControEnd: function(n, t) {\n    return this.dragEnd(n, __assign$2(__assign$2({}, t), {\n      targets: n.props.targets\n    }));\n  }\n}, Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    useResizeObserver: Boolean,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Object,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    hideDefaultLines: Boolean,\n    props: Object,\n    flushSync: Function\n  },\n  events: {}\n}, Padding = makeAble(\"padding\", {\n  render: function(n, t) {\n    var e = n.props;\n    if (e.dragArea)\n      return [];\n    var o = e.padding || {}, R = o.left, N = R === void 0 ? 0 : R, M = o.top, D = M === void 0 ? 0 : M, L = o.right, B = L === void 0 ? 0 : L, $ = o.bottom, k = $ === void 0 ? 0 : $, U = n.state, z = U.renderPoses, X = U.pos1, V = U.pos2, W = U.pos3, Y = U.pos4, q = [X, V, W, Y], Z = [];\n    return N > 0 && Z.push([0, 2]), D > 0 && Z.push([0, 1]), B > 0 && Z.push([1, 3]), k > 0 && Z.push([2, 3]), Z.map(function(K, Q) {\n      var J = K[0], rt = K[1], tt = q[J], nt = q[rt], st = z[J], ut = z[rt], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], tt, nt, st, ut);\n      if (!!ct.length)\n        return t.createElement(\"div\", {\n          key: \"padding\".concat(Q),\n          className: prefix(\"padding\"),\n          style: {\n            transform: makeMatrixCSS(ct, !0)\n          }\n        });\n    });\n  }\n}), RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction calculateRatio(n, t) {\n  var e = n[0] + n[1], o = e > t ? t / e : 1;\n  return n[0] *= o, n[1] = t - n[1] * o, n;\n}\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\nfunction getRadiusStyles(n, t, e, o, R, N, M, D, L) {\n  N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = o), L === void 0 && (L = R);\n  var B = [], $ = !1, k = n.map(function(U, z) {\n    var X = t[z], V = X.horizontal, W = X.vertical;\n    if (W && !$ && ($ = !0, B.push(\"/\")), $) {\n      var Y = Math.max(0, W === 1 ? U[1] - M : L - U[1]);\n      return B.push(convertCSSSize(Y, R, e)), Y;\n    } else {\n      var Y = Math.max(0, V === 1 ? U[0] - N : D - U[0]);\n      return B.push(convertCSSSize(Y, o, e)), Y;\n    }\n  });\n  return {\n    styles: B,\n    raws: k\n  };\n}\nfunction getRadiusRange(n) {\n  for (var t = [0, 0], e = [0, 0], o = n.length, R = 0; R < o; ++R) {\n    var N = n[R];\n    !N.sub || (N.horizontal && (t[1] === 0 && (t[0] = R), t[1] = R - t[0] + 1, e[0] = R + 1), N.vertical && (e[1] === 0 && (e[0] = R), e[1] = R - e[0] + 1));\n  }\n  return {\n    horizontalRange: t,\n    verticalRange: e\n  };\n}\nfunction getRadiusValues(n, t, e, o, R, N) {\n  var M, D, L, B;\n  N === void 0 && (N = [0, 0]);\n  var $ = n.indexOf(\"/\"), k = ($ > -1 ? n.slice(0, $) : n).length, U = n.slice(0, k), z = n.slice(k + 1), X = U[0], V = X === void 0 ? \"0px\" : X, W = U[1], Y = W === void 0 ? V : W, q = U[2], Z = q === void 0 ? V : q, K = U[3], Q = K === void 0 ? Y : K, J = z[0], rt = J === void 0 ? V : J, tt = z[1], nt = tt === void 0 ? rt : tt, st = z[2], ut = st === void 0 ? rt : st, ct = z[3], dt = ct === void 0 ? nt : ct, Et = [V, Y, Z, Q].map(function(ht) {\n    return convertUnitSize(ht, t);\n  }), vt = [rt, nt, ut, dt].map(function(ht) {\n    return convertUnitSize(ht, e);\n  }), _t = Et.slice(), St = vt.slice();\n  M = calculateRatio([_t[0], _t[1]], t), _t[0] = M[0], _t[1] = M[1], D = calculateRatio([_t[3], _t[2]], t), _t[3] = D[0], _t[2] = D[1], L = calculateRatio([St[0], St[3]], e), St[0] = L[0], St[3] = L[1], B = calculateRatio([St[1], St[2]], e), St[1] = B[0], St[2] = B[1];\n  var Ft = _t.slice(0, Math.max(N[0], U.length)), mt = St.slice(0, Math.max(N[1], z.length));\n  return __spreadArray(__spreadArray([], Ft.map(function(ht, pt) {\n    var xt = RADIUS_DIRECTIONS[pt];\n    return {\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[pt],\n      vertical: 0,\n      pos: [o + ht, R + (VERTICAL_RADIUS_DIRECTIONS[pt] === -1 ? e : 0)],\n      sub: !0,\n      raw: Et[pt],\n      direction: xt\n    };\n  }), !0), mt.map(function(ht, pt) {\n    var xt = RADIUS_DIRECTIONS[pt];\n    return {\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[pt],\n      pos: [o + (HORIZONTAL_RADIUS_DIRECTIONS[pt] === -1 ? t : 0), R + ht],\n      sub: !0,\n      raw: vt[pt],\n      direction: xt\n    };\n  }), !0);\n}\nfunction removeRadiusPos(n, t, e, o, R) {\n  R === void 0 && (R = t.length);\n  var N = getRadiusRange(n.slice(o)), M = N.horizontalRange, D = N.verticalRange, L = e - o, B = 0;\n  if (L === 0)\n    B = R;\n  else if (L > 0 && L < M[1])\n    B = M[1] - L;\n  else if (L >= D[0])\n    B = D[0] + D[1] - L;\n  else\n    return;\n  n.splice(e, B), t.splice(e, B);\n}\nfunction addRadiusPos(n, t, e, o, R, N, M, D, L, B, $) {\n  B === void 0 && (B = 0), $ === void 0 && ($ = 0);\n  var k = getRadiusRange(n.slice(e)), U = k.horizontalRange, z = k.verticalRange;\n  if (o > -1)\n    for (var X = HORIZONTAL_RADIUS_DIRECTIONS[o] === 1 ? N - B : D - N, V = U[1]; V <= o; ++V) {\n      var W = VERTICAL_RADIUS_DIRECTIONS[V] === 1 ? $ : L, Y = 0;\n      if (o === V ? Y = N : V === 0 ? Y = B + X : HORIZONTAL_RADIUS_DIRECTIONS[V] === -1 && (Y = D - (t[e][0] - B)), n.splice(e + V, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[V],\n        vertical: 0,\n        pos: [Y, W]\n      }), t.splice(e + V, 0, [Y, W]), V === 0)\n        break;\n    }\n  else if (R > -1) {\n    var q = VERTICAL_RADIUS_DIRECTIONS[R] === 1 ? M - $ : L - M;\n    if (U[1] === 0 && z[1] === 0) {\n      var Z = [B + q, $];\n      n.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: Z\n      }), t.push(Z);\n    }\n    for (var K = z[0], V = z[1]; V <= R; ++V) {\n      var Y = HORIZONTAL_RADIUS_DIRECTIONS[V] === 1 ? B : D, W = 0;\n      if (R === V ? W = M : V === 0 ? W = $ + q : VERTICAL_RADIUS_DIRECTIONS[V] === 1 ? W = t[e + K][1] : VERTICAL_RADIUS_DIRECTIONS[V] === -1 && (W = L - (t[e + K][1] - $)), n.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[V],\n        pos: [Y, W]\n      }), t.push([Y, W]), V === 0)\n        break;\n    }\n  }\n}\nfunction splitRadiusPoses(n, t) {\n  t === void 0 && (t = n.map(function(R) {\n    return R.raw;\n  }));\n  var e = n.map(function(R, N) {\n    return R.horizontal ? t[N] : null;\n  }).filter(function(R) {\n    return R != null;\n  }), o = n.map(function(R, N) {\n    return R.vertical ? t[N] : null;\n  }).filter(function(R) {\n    return R != null;\n  });\n  return {\n    horizontals: e,\n    verticals: o\n  };\n}\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]], CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction getClipStyles(n, t, e) {\n  var o = n.props.clipRelative, R = n.state, N = R.width, M = R.height, D = t, L = D.type, B = D.poses, $ = L === \"rect\", k = L === \"circle\";\n  if (L === \"polygon\")\n    return e.map(function(J) {\n      return \"\".concat(convertCSSSize(J[0], N, o), \" \").concat(convertCSSSize(J[1], M, o));\n    });\n  if ($ || L === \"inset\") {\n    var U = e[1][1], z = e[3][0], X = e[7][0], V = e[5][1];\n    if ($)\n      return [U, z, V, X].map(function(J) {\n        return \"\".concat(J, \"px\");\n      });\n    var W = [U, N - z, M - V, X].map(function(J, rt) {\n      return convertCSSSize(J, rt % 2 ? N : M, o);\n    });\n    if (e.length > 8) {\n      var Y = minus(e[4], e[0]), q = Y[0], Z = Y[1];\n      W.push.apply(W, __spreadArray([\"round\"], getRadiusStyles(e.slice(8), B.slice(8), o, q, Z, X, U, z, V).styles, !1));\n    }\n    return W;\n  } else if (k || L === \"ellipse\") {\n    var K = e[0], Q = convertCSSSize(Math.abs(e[1][1] - K[1]), k ? Math.sqrt((N * N + M * M) / 2) : M, o), W = k ? [Q] : [convertCSSSize(Math.abs(e[2][0] - K[0]), N, o), Q];\n    return W.push(\"at\", convertCSSSize(K[0], N, o), convertCSSSize(K[1], M, o)), W;\n  }\n}\nfunction getRectPoses(n, t, e, o) {\n  var R = [o, (o + t) / 2, t], N = [n, (n + e) / 2, e];\n  return CLIP_RECT_DIRECTIONS.map(function(M) {\n    var D = M[0], L = M[1], B = M[2], $ = R[D + 1], k = N[L + 1];\n    return {\n      vertical: Math.abs(L),\n      horizontal: Math.abs(D),\n      direction: B,\n      pos: [$, k]\n    };\n  });\n}\nfunction getControlSize(n) {\n  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];\n  return n.forEach(function(o) {\n    var R = o.pos;\n    t[0] = Math.min(t[0], R[0]), t[1] = Math.max(t[1], R[0]), e[0] = Math.min(e[0], R[1]), e[1] = Math.max(e[1], R[1]);\n  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];\n}\nfunction moveControlPos(n, t, e, o, R) {\n  var N = n[t], M = N.direction, D = N.sub, L = n.map(function() {\n    return [0, 0];\n  }), B = M ? M.split(\"\") : [];\n  if (o && t < 8) {\n    var $ = B.filter(function(dt) {\n      return dt === \"w\" || dt === \"e\";\n    }), k = B.filter(function(dt) {\n      return dt === \"n\" || dt === \"s\";\n    }), U = $[0], z = k[0];\n    L[t] = e;\n    var X = getControlSize(n), V = X[0], W = X[1], Y = V && W ? V / W : 0;\n    if (Y && R) {\n      var q = (t + 4) % 8, Z = n[q].pos, K = [0, 0];\n      M.indexOf(\"w\") > -1 ? K[0] = -1 : M.indexOf(\"e\") > -1 && (K[0] = 1), M.indexOf(\"n\") > -1 ? K[1] = -1 : M.indexOf(\"s\") > -1 && (K[1] = 1);\n      var Q = getSizeDistByDist([V, W], e, Y, K, !0), J = V + Q[0], rt = W + Q[1], tt = Z[1], nt = Z[1], st = Z[0], ut = Z[0];\n      K[0] === -1 ? st = ut - J : K[0] === 1 ? ut = st + J : (st = st - J / 2, ut = ut + J / 2), K[1] === -1 ? tt = nt - rt : (K[1] === 1 || (tt = nt - rt / 2), nt = tt + rt);\n      var ct = getRectPoses(tt, ut, nt, st);\n      n.forEach(function(dt, Et) {\n        L[Et][0] = ct[Et].pos[0] - dt.pos[0], L[Et][1] = ct[Et].pos[1] - dt.pos[1];\n      });\n    } else\n      n.forEach(function(dt, Et) {\n        var vt = dt.direction;\n        !vt || (vt.indexOf(U) > -1 && (L[Et][0] = e[0]), vt.indexOf(z) > -1 && (L[Et][1] = e[1]));\n      }), U && (L[1][0] = e[0] / 2, L[5][0] = e[0] / 2), z && (L[3][1] = e[1] / 2, L[7][1] = e[1] / 2);\n  } else\n    M && !D ? B.forEach(function(dt) {\n      var Et = dt === \"n\" || dt === \"s\";\n      n.forEach(function(vt, _t) {\n        var St = vt.direction, Ft = vt.horizontal, mt = vt.vertical;\n        !St || St.indexOf(dt) === -1 || (L[_t] = [Et || !Ft ? 0 : e[0], !Et || !mt ? 0 : e[1]]);\n      });\n    }) : L[t] = e;\n  return L;\n}\nfunction getClipPath(n, t, e, o, R) {\n  var N, M, D, L, B, $, k, U = R;\n  if (!U) {\n    var z = getComputedStyle$2(n), X = z.clipPath;\n    U = X !== \"none\" ? X : z.clip;\n  }\n  if (!((!U || U === \"none\" || U === \"auto\") && (U = o, !U))) {\n    var V = splitBracket(U), W = V.prefix, Y = W === void 0 ? U : W, q = V.value, Z = q === void 0 ? \"\" : q, K = Y === \"circle\", Q = \" \";\n    if (Y === \"polygon\") {\n      var J = splitComma(Z || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n      Q = \",\";\n      var rt = J.map(function(Ct) {\n        var Zt = Ct.split(\" \"), Yt = Zt[0], se = Zt[1];\n        return {\n          vertical: 1,\n          horizontal: 1,\n          pos: [convertUnitSize(Yt, t), convertUnitSize(se, e)]\n        };\n      });\n      return {\n        type: Y,\n        clipText: U,\n        poses: rt,\n        splitter: Q\n      };\n    } else if (K || Y === \"ellipse\") {\n      var tt = \"\", nt = \"\", st = 0, ut = 0, J = splitSpace(Z);\n      if (K) {\n        var ct = \"\";\n        N = J[0], ct = N === void 0 ? \"50%\" : N, M = J[2], tt = M === void 0 ? \"50%\" : M, D = J[3], nt = D === void 0 ? \"50%\" : D, st = convertUnitSize(ct, Math.sqrt((t * t + e * e) / 2)), ut = st;\n      } else {\n        var dt = \"\", Et = \"\";\n        L = J[0], dt = L === void 0 ? \"50%\" : L, B = J[1], Et = B === void 0 ? \"50%\" : B, $ = J[3], tt = $ === void 0 ? \"50%\" : $, k = J[4], nt = k === void 0 ? \"50%\" : k, st = convertUnitSize(dt, t), ut = convertUnitSize(Et, e);\n      }\n      var vt = [convertUnitSize(tt, t), convertUnitSize(nt, e)], rt = __spreadArray([{\n        vertical: 1,\n        horizontal: 1,\n        pos: vt,\n        direction: \"nesw\"\n      }], CLIP_DIRECTIONS.slice(0, K ? 1 : 2).map(function(Yt) {\n        return {\n          vertical: Math.abs(Yt[1]),\n          horizontal: Yt[0],\n          direction: Yt[2],\n          sub: !0,\n          pos: [vt[0] + Yt[0] * st, vt[1] + Yt[1] * ut]\n        };\n      }), !0);\n      return {\n        type: Y,\n        clipText: U,\n        radiusX: st,\n        radiusY: ut,\n        left: vt[0] - st,\n        top: vt[1] - ut,\n        poses: rt,\n        splitter: Q\n      };\n    } else if (Y === \"inset\") {\n      var J = splitSpace(Z || \"0 0 0 0\"), _t = J.indexOf(\"round\"), St = (_t > -1 ? J.slice(0, _t) : J).length, Ft = J.slice(St + 1), mt = J.slice(0, St), ht = mt[0], pt = mt[1], xt = pt === void 0 ? ht : pt, At = mt[2], Rt = At === void 0 ? ht : At, Lt = mt[3], lt = Lt === void 0 ? xt : Lt, $t = [ht, Rt].map(function(Yt) {\n        return convertUnitSize(Yt, e);\n      }), Pt = $t[0], kt = $t[1], Ot = [lt, xt].map(function(Yt) {\n        return convertUnitSize(Yt, t);\n      }), gt = Ot[0], Gt = Ot[1], Tt = t - Gt, bt = e - kt, wt = getRadiusValues(Ft, Tt - gt, bt - Pt, gt, Pt), rt = __spreadArray(__spreadArray([], getRectPoses(Pt, Tt, bt, gt), !0), wt, !0);\n      return {\n        type: \"inset\",\n        clipText: U,\n        poses: rt,\n        top: Pt,\n        left: gt,\n        right: Tt,\n        bottom: bt,\n        radius: Ft,\n        splitter: Q\n      };\n    } else if (Y === \"rect\") {\n      var J = splitComma(Z || \"0px, \".concat(t, \"px, \").concat(e, \"px, 0px\"));\n      Q = \",\";\n      var Mt = J.map(function(ge) {\n        var Fe = splitUnit(ge).value;\n        return Fe;\n      }), Pt = Mt[0], Gt = Mt[1], kt = Mt[2], gt = Mt[3], rt = getRectPoses(Pt, Gt, kt, gt);\n      return {\n        type: \"rect\",\n        clipText: U,\n        poses: rt,\n        top: Pt,\n        right: Gt,\n        bottom: kt,\n        left: gt,\n        values: J,\n        splitter: Q\n      };\n    }\n  }\n}\nfunction addClipPath(n, t) {\n  var e = calculatePointerDist(n, t), o = e[0], R = e[1], N = t.datas, M = N.clipPath, D = N.clipIndex, L = M, B = L.type, $ = L.poses, k = L.splitter, U = $.map(function(Y) {\n    return Y.pos;\n  });\n  if (B === \"polygon\")\n    U.splice(D, 0, [o, R]);\n  else if (B === \"inset\") {\n    var z = HORIZONTAL_RADIUS_ORDER.indexOf(D), X = VERTICAL_RADIUS_ORDER.indexOf(D), V = $.length;\n    if (addRadiusPos($, U, 8, z, X, o, R, U[4][0], U[4][1], U[0][0], U[0][1]), V === $.length)\n      return;\n  } else\n    return;\n  var W = getClipStyles(n, M, U);\n  triggerEvent(n, \"onClip\", fillParams(n, t, {\n    clipEventType: \"added\",\n    clipType: B,\n    poses: U,\n    clipStyles: W,\n    clipStyle: \"\".concat(B, \"(\").concat(W.join(k), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nfunction removeClipPath(n, t) {\n  var e = t.datas, o = e.clipPath, R = e.clipIndex, N = o, M = N.type, D = N.poses, L = N.splitter, B = D.map(function(U) {\n    return U.pos;\n  }), $ = B.length;\n  if (M === \"polygon\")\n    D.splice(R, 1), B.splice(R, 1);\n  else if (M === \"inset\") {\n    if (R < 8 || (removeRadiusPos(D, B, R, 8, $), $ === D.length))\n      return;\n  } else\n    return;\n  var k = getClipStyles(n, o, B);\n  triggerEvent(n, \"onClip\", fillParams(n, t, {\n    clipEventType: \"removed\",\n    clipType: M,\n    poses: B,\n    clipStyles: k,\n    clipStyle: \"\".concat(M, \"(\").concat(k.join(L), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    keepRatio: Boolean,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [`.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`, `:host {\n    --bounds-color: #d66;\n}`, `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`, `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`],\n  render: function(n, t) {\n    var e = n.props, o = e.customClipPath, R = e.defaultClipPath, N = e.clipArea, M = e.zoom, D = n.state, L = D.target, B = D.width, $ = D.height, k = D.allMatrix, U = D.is3d, z = D.left, X = D.top, V = D.pos1, W = D.pos2, Y = D.pos3, q = D.pos4, Z = D.clipPathState, K = D.snapBoundInfos, Q = D.rotation;\n    if (!L)\n      return [];\n    var J = getClipPath(L, B, $, R || \"inset\", Z || o);\n    if (!J)\n      return [];\n    var rt = U ? 4 : 3, tt = J.type, nt = J.poses, st = nt.map(function(bt) {\n      var wt = calculatePosition(k, bt.pos, rt);\n      return [wt[0] - z, wt[1] - X];\n    }), ut = [], ct = [], dt = tt === \"rect\", Et = tt === \"inset\", vt = tt === \"polygon\";\n    if (dt || Et || vt) {\n      var _t = Et ? st.slice(0, 8) : st;\n      ct = _t.map(function(bt, wt) {\n        var Mt = wt === 0 ? _t[_t.length - 1] : _t[wt - 1], Ct = getRad$1(Mt, bt), Zt = getDiagonalSize(Mt, bt);\n        return t.createElement(\"div\", {\n          key: \"clipLine\".concat(wt),\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": wt,\n          style: {\n            width: \"\".concat(Zt, \"px\"),\n            transform: \"translate(\".concat(Mt[0], \"px, \").concat(Mt[1], \"px) rotate(\").concat(Ct, \"rad) scaleY(\").concat(M, \")\")\n          }\n        });\n      });\n    }\n    if (ut = st.map(function(bt, wt) {\n      return t.createElement(\"div\", {\n        key: \"clipControl\".concat(wt),\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": wt,\n        style: {\n          transform: \"translate(\".concat(bt[0], \"px, \").concat(bt[1], \"px) rotate(\").concat(Q, \"rad) scale(\").concat(M, \")\")\n        }\n      });\n    }), Et && ut.push.apply(ut, st.slice(8).map(function(bt, wt) {\n      return t.createElement(\"div\", {\n        key: \"clipRadiusControl\".concat(wt),\n        className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n        \"data-clip-index\": 8 + wt,\n        style: {\n          transform: \"translate(\".concat(bt[0], \"px, \").concat(bt[1], \"px) rotate(\").concat(Q, \"rad) scale(\").concat(M, \")\")\n        }\n      });\n    })), tt === \"circle\" || tt === \"ellipse\") {\n      var St = J.left, Ft = J.top, mt = J.radiusX, ht = J.radiusY, pt = minus(calculatePosition(k, [St, Ft], rt), calculatePosition(k, [0, 0], rt)), xt = pt[0], At = pt[1], Rt = \"none\";\n      if (!N) {\n        for (var Lt = Math.max(10, mt / 5, ht / 5), lt = [], $t = 0; $t <= Lt; ++$t) {\n          var Pt = Math.PI * 2 / Lt * $t;\n          lt.push([mt + (mt - M) * Math.cos(Pt), ht + (ht - M) * Math.sin(Pt)]);\n        }\n        lt.push([mt, -2]), lt.push([-2, -2]), lt.push([-2, ht * 2 + 2]), lt.push([mt * 2 + 2, ht * 2 + 2]), lt.push([mt * 2 + 2, -2]), lt.push([mt, -2]), Rt = \"polygon(\".concat(lt.map(function(bt) {\n          return \"\".concat(bt[0], \"px \").concat(bt[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      ut.push(t.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(mt * 2, \"px\"),\n          height: \"\".concat(ht * 2, \"px\"),\n          clipPath: Rt,\n          transform: \"translate(\".concat(-z + xt, \"px, \").concat(-X + At, \"px) \").concat(makeMatrixCSS(k))\n        }\n      }));\n    }\n    if (N) {\n      var kt = getRect(__spreadArray([V, W, Y, q], st, !0)), Ot = kt.width, gt = kt.height, Gt = kt.left, Tt = kt.top;\n      if (vt || dt || Et) {\n        var lt = Et ? st.slice(0, 8) : st;\n        ut.push(t.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(Ot, \"px\"),\n            height: \"\".concat(gt, \"px\"),\n            transform: \"translate(\".concat(Gt, \"px, \").concat(Tt, \"px)\"),\n            clipPath: \"polygon(\".concat(lt.map(function(wt) {\n              return \"\".concat(wt[0] - Gt, \"px \").concat(wt[1] - Tt, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    return K && [\"vertical\", \"horizontal\"].forEach(function(bt) {\n      var wt = K[bt], Mt = bt === \"horizontal\";\n      wt.isSnap && ct.push.apply(ct, wt.snap.posInfos.map(function(Ct, Zt) {\n        var Yt = Ct.pos, se = minus(calculatePosition(k, Mt ? [0, Yt] : [Yt, 0], rt), [z, X]), ie = minus(calculatePosition(k, Mt ? [B, Yt] : [Yt, $], rt), [z, X]);\n        return renderLine(t, \"\", se, ie, M, \"clip\".concat(bt, \"snap\").concat(Zt), \"guideline\");\n      })), wt.isBound && ct.push.apply(ct, wt.bounds.map(function(Ct, Zt) {\n        var Yt = Ct.pos, se = minus(calculatePosition(k, Mt ? [0, Yt] : [Yt, 0], rt), [z, X]), ie = minus(calculatePosition(k, Mt ? [B, Yt] : [Yt, $], rt), [z, X]);\n        return renderLine(t, \"\", se, ie, M, \"clip\".concat(bt, \"bounds\").concat(Zt), \"guideline\", \"bounds\", \"bold\");\n      }));\n    }), __spreadArray(__spreadArray([], ut, !0), ct, !0);\n  },\n  dragControlCondition: function(n, t) {\n    return t.inputEvent && (t.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(n, t) {\n    var e = n.props, o = e.dragWithClip, R = o === void 0 ? !0 : o;\n    return R ? !1 : this.dragControlStart(n, t);\n  },\n  drag: function(n, t) {\n    return this.dragControl(n, __assign$2(__assign$2({}, t), {\n      isDragTarget: !0\n    }));\n  },\n  dragEnd: function(n, t) {\n    return this.dragControlEnd(n, t);\n  },\n  dragControlStart: function(n, t) {\n    var e = n.state, o = n.props, R = o.defaultClipPath, N = o.customClipPath, M = e.target, D = e.width, L = e.height, B = t.inputEvent ? t.inputEvent.target : null, $ = B && B.getAttribute(\"class\") || \"\", k = t.datas, U = getClipPath(M, D, L, R || \"inset\", N);\n    if (!U)\n      return !1;\n    var z = U.clipText, X = U.type, V = U.poses, W = triggerEvent(n, \"onClipStart\", fillParams(n, t, {\n      clipType: X,\n      clipStyle: z,\n      poses: V.map(function(Y) {\n        return Y.pos;\n      })\n    }));\n    return W === !1 ? (k.isClipStart = !1, !1) : (k.isControl = $ && $.indexOf(\"clip-control\") > -1, k.isLine = $.indexOf(\"clip-line\") > -1, k.isArea = $.indexOf(\"clip-area\") > -1 || $.indexOf(\"clip-ellipse\") > -1, k.clipIndex = B ? parseInt(B.getAttribute(\"data-clip-index\"), 10) : -1, k.clipPath = U, k.isClipStart = !0, e.clipPathState = z, setDragStart(n, t), !0);\n  },\n  dragControl: function(n, t) {\n    var e, o = t.datas, R = t.originalDatas, N = t.isDragTarget;\n    if (!o.isClipStart)\n      return !1;\n    var M = o, D = M.isControl, L = M.isLine, B = M.isArea, $ = M.clipIndex, k = M.clipPath;\n    if (!k)\n      return !1;\n    var U = getProps(n.props, \"clippable\"), z = U.keepRatio, X = 0, V = 0, W = R.draggable, Y = getDragDist(t);\n    N && W ? (e = W.prevBeforeDist, X = e[0], V = e[1]) : (X = Y[0], V = Y[1]);\n    var q = [X, V], Z = n.state, K = Z.width, Q = Z.height, J = !B && !D && !L, rt = k.type, tt = k.poses, nt = k.splitter, st = tt.map(function(ot) {\n      return ot.pos;\n    });\n    J && (X = -X, V = -V);\n    var ut = !D || tt[$].direction === \"nesw\", ct = rt === \"inset\" || rt === \"rect\", dt = tt.map(function() {\n      return [0, 0];\n    });\n    if (D && !ut) {\n      var Et = tt[$], vt = Et.horizontal, _t = Et.vertical, St = [X * Math.abs(vt), V * Math.abs(_t)];\n      dt = moveControlPos(tt, $, St, ct, z);\n    } else\n      ut && (dt = st.map(function() {\n        return [X, V];\n      }));\n    var Ft = st.map(function(ot, ft) {\n      return plus(ot, dt[ft]);\n    }), mt = __spreadArray([], Ft, !0);\n    Z.snapBoundInfos = null;\n    var ht = k.type === \"circle\", pt = k.type === \"ellipse\";\n    if (ht || pt) {\n      var xt = getRect(Ft), At = Math.abs(xt.bottom - xt.top), Rt = Math.abs(pt ? xt.right - xt.left : At), Lt = Ft[0][1] + At, lt = Ft[0][0] - Rt, $t = Ft[0][0] + Rt;\n      ht && (mt.push([$t, xt.bottom]), dt.push([1, 0])), mt.push([xt.left, Lt]), dt.push([0, 1]), mt.push([lt, xt.bottom]), dt.push([1, 0]);\n    }\n    var Pt = getDefaultGuidelines((U.clipHorizontalGuidelines || []).map(function(ot) {\n      return convertUnitSize(\"\".concat(ot), Q);\n    }), (U.clipVerticalGuidelines || []).map(function(ot) {\n      return convertUnitSize(\"\".concat(ot), K);\n    }), K, Q), kt = [], Ot = [];\n    if (ht || pt)\n      kt = [mt[4][0], mt[2][0]], Ot = [mt[1][1], mt[3][1]];\n    else if (ct) {\n      var gt = [mt[0], mt[2], mt[4], mt[6]], Gt = [dt[0], dt[2], dt[4], dt[6]];\n      kt = gt.filter(function(ot, ft) {\n        return Gt[ft][0];\n      }).map(function(ot) {\n        return ot[0];\n      }), Ot = gt.filter(function(ot, ft) {\n        return Gt[ft][1];\n      }).map(function(ot) {\n        return ot[1];\n      });\n    } else\n      kt = mt.filter(function(ot, ft) {\n        return dt[ft][0];\n      }).map(function(ot) {\n        return ot[0];\n      }), Ot = mt.filter(function(ot, ft) {\n        return dt[ft][1];\n      }).map(function(ot) {\n        return ot[1];\n      });\n    var Tt = [0, 0], bt = checkSnapBounds(Pt, U.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: K,\n      bottom: Q\n    }, kt, Ot, 5), wt = bt.horizontal, Mt = bt.vertical, Ct = wt.offset, Zt = Mt.offset;\n    if (wt.isBound && (Tt[1] += Ct), Mt.isBound && (Tt[0] += Zt), (pt || ht) && dt[0][0] === 0 && dt[0][1] === 0) {\n      var xt = getRect(Ft), Yt = xt.bottom - xt.top, se = pt ? xt.right - xt.left : Yt, ie = Mt.isBound ? Math.abs(Zt) : Mt.snapIndex === 0 ? -Zt : Zt, Te = wt.isBound ? Math.abs(Ct) : wt.snapIndex === 0 ? -Ct : Ct;\n      se -= ie, Yt -= Te, ht && (Yt = checkSnapBoundPriority(Mt, wt) > 0 ? Yt : se, se = Yt);\n      var ge = mt[0];\n      mt[1][1] = ge[1] - Yt, mt[2][0] = ge[0] + se, mt[3][1] = ge[1] + Yt, mt[4][0] = ge[0] - se;\n    } else if (ct && z && D) {\n      var Fe = getControlSize(tt), xe = Fe[0], de = Fe[1], ae = xe && de ? xe / de : 0, Jt = tt[$], Pe = Jt.direction || \"\", ha = mt[1][1], Lt = mt[5][1], lt = mt[7][0], $t = mt[3][0];\n      Ct <= Zt ? Ct = Zt / ae : Zt = Ct * ae, Pe.indexOf(\"w\") > -1 ? lt -= Zt : Pe.indexOf(\"e\") > -1 ? $t -= Zt : (lt += Zt / 2, $t -= Zt / 2), Pe.indexOf(\"n\") > -1 ? ha -= Ct : Pe.indexOf(\"s\") > -1 ? Lt -= Ct : (ha += Ct / 2, Lt -= Ct / 2);\n      var Jl = getRectPoses(ha, $t, Lt, lt);\n      mt.forEach(function(It, Nt) {\n        var Dt;\n        Dt = Jl[Nt].pos, It[0] = Dt[0], It[1] = Dt[1];\n      });\n    } else\n      mt.forEach(function(ot, ft) {\n        var yt = dt[ft];\n        yt[0] && (ot[0] -= Zt), yt[1] && (ot[1] -= Ct);\n      });\n    var Bo = getClipStyles(n, k, Ft), ca = \"\".concat(rt, \"(\").concat(Bo.join(nt), \")\");\n    if (Z.clipPathState = ca, ht || pt)\n      kt = [mt[4][0], mt[2][0]], Ot = [mt[1][1], mt[3][1]];\n    else if (ct) {\n      var gt = [mt[0], mt[2], mt[4], mt[6]];\n      kt = gt.map(function(ft) {\n        return ft[0];\n      }), Ot = gt.map(function(ft) {\n        return ft[1];\n      });\n    } else\n      kt = mt.map(function(ot) {\n        return ot[0];\n      }), Ot = mt.map(function(ot) {\n        return ot[1];\n      });\n    if (Z.snapBoundInfos = checkSnapBounds(Pt, U.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: K,\n      bottom: Q\n    }, kt, Ot, 1), W) {\n      var $o = Z.is3d, ko = Z.allMatrix, Go = $o ? 4 : 3, fa = Tt;\n      N && (fa = [q[0] + Tt[0] - Y[0], q[1] + Tt[1] - Y[1]]), W.deltaOffset = multiply(ko, [fa[0], fa[1], 0, 0], Go);\n    }\n    return triggerEvent(n, \"onClip\", fillParams(n, t, {\n      clipEventType: \"changed\",\n      clipType: rt,\n      poses: Ft,\n      clipStyle: ca,\n      clipStyles: Bo,\n      distX: X,\n      distY: V\n    })), !0;\n  },\n  dragControlEnd: function(n, t) {\n    this.unset(n);\n    var e = t.isDrag, o = t.datas, R = t.isDouble, N = o.isLine, M = o.isClipStart, D = o.isControl;\n    return M ? (triggerEvent(n, \"onClipEnd\", fillEndParams(n, t, {})), R && (D ? removeClipPath(n, t) : N && addClipPath(n, t)), R || e) : !1;\n  },\n  unset: function(n) {\n    n.state.clipPathState = \"\", n.state.snapBoundInfos = null;\n  }\n}, OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [`:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`],\n  dragControlCondition: function(n, t) {\n    return t.isRequest ? t.requestAble === \"originDraggable\" : hasClass(t.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function(n, t) {\n    var e = t.datas;\n    setDragStart(n, t);\n    var o = fillParams(n, t, {\n      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))\n    }), R = triggerEvent(n, \"onDragOriginStart\", o);\n    return e.startOrigin = n.state.transformOrigin, e.startTargetOrigin = n.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, R === !1 ? (e.isDragOrigin = !1, !1) : o;\n  },\n  dragControl: function(n, t) {\n    var e = t.datas, o = t.isPinch, R = t.isRequest;\n    if (!e.isDragOrigin)\n      return !1;\n    var N = getDragDist(t), M = N[0], D = N[1], L = n.state, B = L.width, $ = L.height, k = L.offsetMatrix, U = L.targetMatrix, z = L.is3d, X = n.props.originRelative, V = X === void 0 ? !0 : X, W = z ? 4 : 3, Y = [M, D];\n    if (R) {\n      var q = t.distOrigin;\n      (q[0] || q[1]) && (Y = q);\n    }\n    var Z = plus(e.startOrigin, Y), K = plus(e.startTargetOrigin, Y), Q = minus(Y, e.prevOrigin), J = getNextMatrix(k, U, Z, W), rt = n.getRect(), tt = getRect(calculatePoses(J, B, $, W)), nt = [rt.left - tt.left, rt.top - tt.top];\n    e.prevOrigin = Y;\n    var st = [convertCSSSize(K[0], B, V), convertCSSSize(K[1], $, V)].join(\" \"), ut = fillParams(n, t, {\n      width: B,\n      height: $,\n      origin: Z,\n      dist: Y,\n      delta: Q,\n      transformOrigin: st,\n      drag: Draggable.drag(n, setCustomDrag(t, n.state, nt, !!o, !1))\n    });\n    return triggerEvent(n, \"onDragOrigin\", ut), ut;\n  },\n  dragControlEnd: function(n, t) {\n    var e = t.datas;\n    return e.isDragOrigin ? (triggerEvent(n, \"onDragOriginEnd\", fillEndParams(n, t, {})), !0) : !1;\n  },\n  dragGroupControlCondition: function(n, t) {\n    return this.dragControlCondition(n, t);\n  },\n  dragGroupControlStart: function(n, t) {\n    var e = this.dragControlStart(n, t);\n    return !!e;\n  },\n  dragGroupControl: function(n, t) {\n    var e = this.dragControl(n, t);\n    return e ? (n.transformOrigin = e.transformOrigin, !0) : !1;\n  },\n  request: function(n) {\n    var t = {}, e = n.getRect(), o = 0, R = 0, N = e.transformOrigin, M = [0, 0];\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(D) {\n        return \"deltaOrigin\" in D ? (M[0] += D.deltaOrigin[0], M[1] += D.deltaOrigin[1]) : \"origin\" in D ? (M[0] = D.origin[0] - N[0], M[1] = D.origin[1] - N[1]) : (\"x\" in D ? o = D.x - e.left : \"deltaX\" in D && (o += D.deltaX), \"y\" in D ? R = D.y - e.top : \"deltaY\" in D && (R += D.deltaY)), {\n          datas: t,\n          distX: o,\n          distY: R,\n          distOrigin: M\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction addBorderRadius(n, t, e, o, R, N, M) {\n  var D = splitRadiusPoses(n), L = D.horizontals, B = D.verticals, $ = L.length, k = B.length, U = -1, z = -1;\n  e === 0 ? $ === 0 ? U = 0 : $ === 1 && (U = 1) : e === 3 && ($ <= 2 ? U = 2 : $ <= 3 && (U = 3)), e === 2 ? k === 0 ? z = 0 : k < 4 && (z = 3) : e === 1 && (k <= 1 ? z = 1 : k <= 2 && (z = 2)), addRadiusPos(n, t, 0, U, z, o, R, N, M);\n}\nfunction getBorderRadius(n, t, e, o, R) {\n  o === void 0 && (o = [0, 0]);\n  var N, M = [];\n  if (R)\n    N = R;\n  else {\n    var D = getComputedStyle$2(n);\n    N = D && D.borderRadius || \"\";\n  }\n  return !N || !R && N === \"0px\" ? M = [] : M = splitSpace(N), getRadiusValues(M, t, e, 0, 0, o);\n}\nfunction triggerRoundEvent(n, t, e, o, R, N) {\n  var M = n.state, D = M.width, L = M.height, B = getRadiusStyles(N, R, n.props.roundRelative, D, L), $ = B.raws, k = B.styles, U = splitRadiusPoses(R, $), z = U.horizontals, X = U.verticals, V = k.join(\" \");\n  M.borderRadiusState = V, triggerEvent(n, \"onRound\", fillParams(n, t, {\n    horizontals: z,\n    verticals: X,\n    borderRadius: V,\n    width: D,\n    height: L,\n    delta: o,\n    dist: e\n  }));\n}\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\"\n  },\n  css: [`.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`, `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`],\n  render: function(n, t) {\n    var e = n.state, o = e.target, R = e.width, N = e.height, M = e.allMatrix, D = e.is3d, L = e.left, B = e.top, $ = e.borderRadiusState, k = n.props, U = k.minRoundControls, z = U === void 0 ? [0, 0] : U, X = k.maxRoundControls, V = X === void 0 ? [4, 4] : X, W = k.zoom;\n    if (!o)\n      return null;\n    var Y = D ? 4 : 3, q = getBorderRadius(o, R, N, z, $);\n    if (!q)\n      return null;\n    var Z = 0, K = 0;\n    return q.map(function(Q, J) {\n      K += Math.abs(Q.horizontal), Z += Math.abs(Q.vertical);\n      var rt = minus(calculatePosition(M, Q.pos, Y), [L, B]), tt = Q.vertical ? Z <= V[1] : K <= V[0];\n      return t.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(J),\n        className: prefix(\"control\", \"border-radius\"),\n        \"data-radius-index\": J,\n        style: {\n          display: tt ? \"block\" : \"none\",\n          transform: \"translate(\".concat(rt[0], \"px, \").concat(rt[1], \"px) scale(\").concat(W, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(n, t) {\n    if (!t.inputEvent || t.isRequest)\n      return !1;\n    var e = t.inputEvent.target.getAttribute(\"class\") || \"\";\n    return e.indexOf(\"border-radius\") > -1 || e.indexOf(\"moveable-line\") > -1 && e.indexOf(\"moveable-direction\") > -1;\n  },\n  dragControlStart: function(n, t) {\n    var e = t.inputEvent, o = t.datas, R = e.target, N = R.getAttribute(\"class\") || \"\", M = N.indexOf(\"border-radius\") > -1, D = N.indexOf(\"moveable-line\") > -1 && N.indexOf(\"moveable-direction\") > -1, L = M ? parseInt(R.getAttribute(\"data-radius-index\"), 10) : -1, B = D ? parseInt(R.getAttribute(\"data-line-index\"), 10) : -1;\n    if (!M && !D)\n      return !1;\n    var $ = triggerEvent(n, \"onRoundStart\", fillParams(n, t, {}));\n    if ($ === !1)\n      return !1;\n    o.lineIndex = B, o.controlIndex = L, o.isControl = M, o.isLine = D, setDragStart(n, t);\n    var k = n.props, U = k.roundRelative, z = k.minRoundControls, X = z === void 0 ? [0, 0] : z, V = n.state, W = V.target, Y = V.width, q = V.height;\n    o.isRound = !0, o.prevDist = [0, 0];\n    var Z = getBorderRadius(W, Y, q, X) || [];\n    return o.controlPoses = Z, V.borderRadiusState = getRadiusStyles(Z.map(function(K) {\n      return K.pos;\n    }), Z, U, Y, q).styles.join(\" \"), !0;\n  },\n  dragControl: function(n, t) {\n    var e = t.datas;\n    if (!e.isRound || !e.isControl || !e.controlPoses.length)\n      return !1;\n    var o = e.controlIndex, R = e.controlPoses, N = getDragDist(t), M = N[0], D = N[1], L = [M, D], B = minus(L, e.prevDist), $ = n.props.maxRoundControls, k = $ === void 0 ? [4, 4] : $, U = n.state, z = U.width, X = U.height, V = R[o], W = V.vertical, Y = V.horizontal, q = R.map(function(K) {\n      var Q = K.horizontal, J = K.vertical, rt = [Q * Y * L[0], J * W * L[1]];\n      if (Q) {\n        if (k[0] === 1)\n          return rt;\n        if (k[0] < 4 && Q !== Y)\n          return rt;\n      } else {\n        if (k[1] === 0)\n          return rt[1] = J * Y * L[0] / z * X, rt;\n        if (W) {\n          if (k[1] === 1)\n            return rt;\n          if (k[1] < 4 && J !== W)\n            return rt;\n        }\n      }\n      return [0, 0];\n    });\n    q[o] = L;\n    var Z = R.map(function(K, Q) {\n      return plus(K.pos, q[Q]);\n    });\n    return e.prevDist = [M, D], triggerRoundEvent(n, t, L, B, R, Z), !0;\n  },\n  dragControlEnd: function(n, t) {\n    var e = n.state;\n    e.borderRadiusState = \"\";\n    var o = t.datas, R = t.isDouble;\n    if (!o.isRound)\n      return !1;\n    var N = e.width, M = e.height, D = o.isControl, L = o.controlIndex, B = o.isLine, $ = o.lineIndex, k = o.controlPoses, U = k.map(function(Z) {\n      return Z.pos;\n    }), z = U.length, X = n.props.roundClickable, V = X === void 0 ? !0 : X;\n    if (R && V) {\n      if (D)\n        removeRadiusPos(k, U, L, 0);\n      else if (B) {\n        var W = calculatePointerDist(n, t), Y = W[0], q = W[1];\n        addBorderRadius(k, U, $, Y, q, N, M);\n      }\n      z !== k.length && triggerRoundEvent(n, t, [0, 0], [0, 0], k, U);\n    }\n    return triggerEvent(n, \"onRoundEnd\", fillEndParams(n, t, {})), e.borderRadiusState = \"\", !0;\n  },\n  unset: function(n) {\n    n.state.borderRadiusState = \"\";\n  }\n};\nfunction isIdentityMatrix(n, t) {\n  var e = t ? 4 : 3, o = createIdentityMatrix(e), R = \"matrix\".concat(t ? \"3d\" : \"\", \"(\").concat(o.join(\",\"), \")\");\n  return n === R || n === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  setTransform: function(n, t) {\n    var e = n.state, o = e.is3d, R = e.target, N = e.targetMatrix, M = R == null ? void 0 : R.style.transform, D = o ? \"matrix3d(\".concat(N.join(\",\"), \")\") : \"matrix(\".concat(convertMatrixtoCSS(N, !0), \")\"), L = !M || M === \"none\" ? D : M;\n    t.datas.startTransforms = isIdentityMatrix(L, o) ? [] : splitSpace(L);\n  },\n  resetTransform: function(n) {\n    n.datas.nextTransforms = n.datas.startTransforms, n.datas.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(n, t) {\n    return fillParams(n, t, {\n      setTransform: function(e) {\n        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);\n      },\n      isPinch: !!t.isPinch\n    });\n  },\n  fillDragParams: function(n, t) {\n    return fillParams(n, t, {\n      isPinch: !!t.isPinch\n    });\n  },\n  dragStart: function(n, t) {\n    this.setTransform(n, t), triggerEvent(n, \"onBeforeRenderStart\", this.fillDragStartParams(n, t));\n  },\n  drag: function(n, t) {\n    this.resetTransform(t), triggerEvent(n, \"onBeforeRender\", fillParams(n, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  dragEnd: function(n, t) {\n    triggerEvent(n, \"onBeforeRenderEnd\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    }));\n  },\n  dragGroupStart: function(n, t) {\n    var e = this;\n    this.dragStart(n, t);\n    var o = fillChildEvents(n, \"beforeRenderable\", t), R = n.moveables, N = o.map(function(M, D) {\n      var L = R[D];\n      return e.setTransform(L, M), e.fillDragStartParams(L, M);\n    });\n    triggerEvent(n, \"onBeforeRenderGroupStart\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      targets: n.props.targets,\n      setTransform: function() {\n      },\n      events: N\n    }));\n  },\n  dragGroup: function(n, t) {\n    var e = this;\n    this.drag(n, t);\n    var o = fillChildEvents(n, \"beforeRenderable\", t), R = n.moveables, N = o.map(function(M, D) {\n      var L = R[D];\n      return e.resetTransform(M), e.fillDragParams(L, M);\n    });\n    triggerEvent(n, \"onBeforeRenderGroup\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      targets: n.props.targets,\n      events: N\n    }));\n  },\n  dragGroupEnd: function(n, t) {\n    this.dragEnd(n, t), triggerEvent(n, \"onBeforeRenderGroupEnd\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: n.props.targets\n    }));\n  },\n  dragControlStart: function(n, t) {\n    return this.dragStart(n, t);\n  },\n  dragControl: function(n, t) {\n    return this.drag(n, t);\n  },\n  dragControlEnd: function(n, t) {\n    return this.dragEnd(n, t);\n  },\n  dragGroupControlStart: function(n, t) {\n    return this.dragGroupStart(n, t);\n  },\n  dragGroupControl: function(n, t) {\n    return this.dragGroup(n, t);\n  },\n  dragGroupControlEnd: function(n, t) {\n    return this.dragGroupEnd(n, t);\n  }\n}, Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  dragStart: function(n, t) {\n    triggerEvent(n, \"onRenderStart\", fillParams(n, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  drag: function(n, t) {\n    triggerEvent(n, \"onRender\", this.fillDragParams(n, t));\n  },\n  dragAfter: function(n, t) {\n    if (t.resultCount)\n      return this.drag(n, t);\n  },\n  dragEnd: function(n, t) {\n    triggerEvent(n, \"onRenderEnd\", this.fillDragEndParams(n, t));\n  },\n  dragGroupStart: function(n, t) {\n    triggerEvent(n, \"onRenderGroupStart\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      targets: n.props.targets\n    }));\n  },\n  dragGroup: function(n, t) {\n    var e = this, o = fillChildEvents(n, \"beforeRenderable\", t), R = n.moveables, N = o.map(function(M, D) {\n      var L = R[D];\n      return e.fillDragParams(L, M);\n    });\n    triggerEvent(n, \"onRenderGroup\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      targets: n.props.targets,\n      transform: getNextTransformText(t),\n      events: N\n    }));\n  },\n  dragGroupEnd: function(n, t) {\n    var e = this, o = fillChildEvents(n, \"beforeRenderable\", t), R = n.moveables, N = o.map(function(M, D) {\n      var L = R[D];\n      return e.fillDragEndParams(L, M);\n    });\n    triggerEvent(n, \"onRenderGroupEnd\", fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: n.props.targets,\n      events: N\n    }));\n  },\n  dragControlStart: function(n, t) {\n    return this.dragStart(n, t);\n  },\n  dragControl: function(n, t) {\n    return this.drag(n, t);\n  },\n  dragControlAfter: function(n, t) {\n    return this.dragAfter(n, t);\n  },\n  dragControlEnd: function(n, t) {\n    return this.dragEnd(n, t);\n  },\n  dragGroupControlStart: function(n, t) {\n    return this.dragGroupStart(n, t);\n  },\n  dragGroupControl: function(n, t) {\n    return this.dragGroup(n, t);\n  },\n  dragGroupControlEnd: function(n, t) {\n    return this.dragGroupEnd(n, t);\n  },\n  fillDragParams: function(n, t) {\n    return fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      transform: getNextTransformText(t)\n    });\n  },\n  fillDragEndParams: function(n, t) {\n    return fillParams(n, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    });\n  }\n};\nfunction triggerAble(n, t, e, o, R, N, M) {\n  var D = R === \"Start\", L = n.state.target, B = N.isRequest;\n  if (!L || D && o.indexOf(\"Control\") > -1 && !B && n.areaElement === N.inputEvent.target)\n    return !1;\n  var $ = \"\".concat(e).concat(o).concat(R), k = \"\".concat(e).concat(o, \"Condition\"), U = R === \"End\", z = R === \"After\", X = D && (!n.targetGesto || !n.controlGesto || !n.targetGesto.isFlag() || !n.controlGesto.isFlag());\n  X && n.updateRect(R, !0, !1), R === \"\" && !B && convertDragDist(n.state, N);\n  var V = __spreadArray([], n[t], !0);\n  if (B) {\n    var W = N.requestAble;\n    V.some(function(st) {\n      return st.name === W;\n    }) || V.push.apply(V, n.props.ables.filter(function(st) {\n      return st.name === W;\n    }));\n  }\n  if (!V.length)\n    return !1;\n  var Y = __spreadArray(__spreadArray([BeforeRenderable], V, !0), [Renderable], !1).filter(function(st) {\n    return st[$];\n  }), q = N.datas;\n  X && Y.forEach(function(st) {\n    st.unset && st.unset(n);\n  });\n  var Z = N.inputEvent, K;\n  U && Z && (K = document.elementFromPoint(N.clientX, N.clientY) || Z.target);\n  var Q = 0, J = Y.filter(function(st) {\n    var ut = st.name, ct = q[ut] || (q[ut] = {});\n    if (D && (ct.isEventStart = !st[k] || st[k](n, N)), ct.isEventStart) {\n      var dt = st[$](n, __assign$2(__assign$2({}, N), {\n        resultCount: Q,\n        datas: ct,\n        originalDatas: q,\n        inputTarget: K\n      }));\n      return n._emitter.off(), D && dt === !1 && (ct.isEventStart = !1), Q += dt ? 1 : 0, dt;\n    }\n    return !1;\n  }), rt = J.length, tt = !1;\n  if (D && Y.length && !rt && (tt = Y.filter(function(st) {\n    var ut = st.name, ct = q[ut];\n    return ct.isEventStart ? st.dragRelation === \"strong\" ? (ct.isEventStart = !1, !1) : !0 : !1;\n  }).length === 0), (U || tt) && (n.state.gestos = {}, n.moveables && n.moveables.forEach(function(st) {\n    st.state.gestos = {};\n  })), X && tt && Y.forEach(function(st) {\n    st.unset && st.unset(n);\n  }), D && !B && rt && (N == null || N.preventDefault()), n.isUnmounted || tt)\n    return !1;\n  if (!D && rt && !M || U) {\n    var nt = n.props.flushSync || defaultSync;\n    nt(function() {\n      n.updateRect(U ? R : \"\", !0, !1), n.forceUpdate();\n    });\n  }\n  return !D && !U && !z && rt && !M && triggerAble(n, t, e, o, R + \"After\", N), !0;\n}\nfunction getTargetAbleGesto(n, t, e) {\n  var o = n.controlBox.getElement(), R = [];\n  R.push(o), (!n.props.dragArea || n.props.dragTarget) && R.push(t);\n  var N = function(M) {\n    var D = M.inputEvent.target, L = n.areaElement;\n    return D === L || !n.isMoveableElement(D) && !n.controlBox.getElement().contains(D) || hasClass(D, \"moveable-area\") || hasClass(D, \"moveable-padding\");\n  };\n  return getAbleGesto(n, R, \"targetAbles\", e, {\n    dragStart: N,\n    pinchStart: N\n  });\n}\nfunction getAbleGesto(n, t, e, o, R) {\n  R === void 0 && (R = {});\n  var N = n.props, M = N.pinchOutside, D = N.pinchThreshold, L = {\n    preventDefault: !1,\n    preventRightClick: !0,\n    preventWheelClick: !0,\n    container: window,\n    pinchThreshold: D,\n    pinchOutside: M\n  }, B = new Gesto$1(t, L), $ = o === \"Control\";\n  return [\"drag\", \"pinch\"].forEach(function(k) {\n    [\"Start\", \"\", \"End\"].forEach(function(U) {\n      B.on(\"\".concat(k).concat(U), function(z) {\n        var X, V = z.eventType;\n        if (R[V] && !R[V](z)) {\n          z.stop();\n          return;\n        }\n        var W = triggerAble(n, e, k, o, U, z);\n        W ? U === \"Start\" && $ && ((X = z == null ? void 0 : z.inputEvent) === null || X === void 0 || X.stopPropagation()) : z.stop();\n      });\n    });\n  }), B;\n}\nvar EventManager = /* @__PURE__ */ function() {\n  function n(e, o, R) {\n    var N = this;\n    this.target = e, this.moveable = o, this.eventName = R, this.ables = [], this._onEvent = function(M) {\n      var D = N.eventName, L = N.moveable;\n      L.state.disableNativeEvent || N.ables.forEach(function(B) {\n        B[D](L, {\n          inputEvent: M\n        });\n      });\n    }, e.addEventListener(R.toLowerCase(), this._onEvent);\n  }\n  var t = n.prototype;\n  return t.setAbles = function(e) {\n    this.ables = e;\n  }, t.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;\n  }, n;\n}();\nfunction calculateMatrixStack(n, t, e, o) {\n  var R;\n  e === void 0 && (e = t);\n  var N = getMatrixStackInfo(n, t), M = N.matrixes, D = N.is3d, L = N.targetMatrix, B = N.transformOrigin, $ = N.targetOrigin, k = N.offsetContainer, U = N.hasFixed, z = getMatrixStackInfo(k, e, !0), X = z.matrixes, V = z.is3d, W = z.offsetContainer, Y = o || V || D, q = Y ? 4 : 3, Z = n.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in n, K = L, Q = createIdentityMatrix(q), J = createIdentityMatrix(q), rt = createIdentityMatrix(q), tt = createIdentityMatrix(q), nt = M.length;\n  X.reverse(), M.reverse(), !D && Y && (K = convertDimension(K, 3, 4), convert3DMatrixes(M)), !V && Y && convert3DMatrixes(X), X.forEach(function(vt) {\n    J = multiply(J, vt.matrix, q);\n  });\n  var st = e || document.body, ut = ((R = X[0]) === null || R === void 0 ? void 0 : R.target) || getOffsetInfo(st, st, !0).offsetParent, ct = X.slice(1).reduce(function(vt, _t) {\n    return multiply(vt, _t.matrix, q);\n  }, createIdentityMatrix(q));\n  M.forEach(function(vt, _t) {\n    if (nt - 2 === _t && (rt = Q.slice()), nt - 1 === _t && (tt = Q.slice()), !vt.matrix) {\n      var St = M[_t + 1], Ft = getSVGOffset(vt, St, ut, q, multiply(ct, Q, q));\n      vt.matrix = createOriginMatrix(Ft, q);\n    }\n    Q = multiply(Q, vt.matrix, q);\n  });\n  var dt = !Z && D;\n  K || (K = createIdentityMatrix(dt ? 4 : 3));\n  var Et = makeMatrixCSS(Z && K.length === 16 ? convertDimension(K, 4, 3) : K, dt);\n  return J = ignoreDimension(J, q, q), {\n    hasFixed: U,\n    rootMatrix: J,\n    beforeMatrix: rt,\n    offsetMatrix: tt,\n    allMatrix: Q,\n    targetMatrix: K,\n    targetTransform: Et,\n    transformOrigin: B,\n    targetOrigin: $,\n    is3d: Y,\n    offsetContainer: k,\n    offsetRootContainer: W\n  };\n}\nfunction calculateElementInfo(n, t, e, o) {\n  e === void 0 && (e = t);\n  var R = 0, N = 0, M = 0, D = {}, L = getSize(n);\n  if (n && (R = L.offsetWidth, N = L.offsetHeight), n) {\n    var B = calculateMatrixStack(n, t, e, o), $ = calculateMoveablePosition(B.allMatrix, B.transformOrigin, R, N);\n    D = __assign$2(__assign$2({}, B), $);\n    var k = calculateMoveablePosition(B.allMatrix, [50, 50], 100, 100);\n    M = getRotationRad([k.pos1, k.pos2], k.direction);\n  }\n  var U = o ? 4 : 3;\n  return __assign$2(__assign$2(__assign$2({\n    width: R,\n    height: N,\n    rotation: M\n  }, L), {\n    rootMatrix: createIdentityMatrix(U),\n    beforeMatrix: createIdentityMatrix(U),\n    offsetMatrix: createIdentityMatrix(U),\n    allMatrix: createIdentityMatrix(U),\n    targetMatrix: createIdentityMatrix(U),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!o,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null\n  }), D);\n}\nfunction getMoveableTargetInfo(n, t, e, o, R) {\n  var N = 1, M = [0, 0], D = resetClientRect(), L = resetClientRect(), B = resetClientRect(), $ = resetClientRect(), k = calculateElementInfo(t, e, R, !0);\n  if (t) {\n    var U = k.is3d ? 4 : 3, z = calculateMoveablePosition(k.offsetMatrix, plus(k.transformOrigin, getOrigin(k.targetMatrix, U)), k.width, k.height);\n    N = z.direction, M = plus(z.origin, [z.left - k.left, z.top - k.top]), D = getClientRect(t);\n    var X = getOffsetInfo(o, o, !0).offsetParent || k.offsetRootContainer;\n    B = getClientRect(X, !0), $ = getClientRect(k.offsetRootContainer), n && (L = getClientRect(n));\n  }\n  return __assign$2({\n    targetClientRect: D,\n    containerClientRect: B,\n    moveableClientRect: L,\n    rootContainerClientRect: $,\n    beforeDirection: N,\n    beforeOrigin: M,\n    originalBeforeOrigin: M,\n    target: t\n  }, k);\n}\nvar MoveableManager$1 = /* @__PURE__ */ function(n) {\n  __extends$1(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.state = __assign$2({\n      container: null,\n      gestos: {},\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: !1\n    }, getMoveableTargetInfo(null)), o.renderState = {}, o.enabledAbles = [], o.targetAbles = [], o.controlAbles = [], o.rotation = 0, o.scale = [1, 1], o.isUnmounted = !1, o.events = {\n      mouseEnter: null,\n      mouseLeave: null\n    }, o._emitter = new EventEmitter$1$1(), o._prevTarget = null, o._prevDragArea = !1, o._observer = null, o._observerId = 0, o.onPreventClick = function(R) {\n      R.stopPropagation(), R.preventDefault();\n    }, o.checkUpdateRect = function() {\n      if (!o.isDragging()) {\n        var R = o.props.parentMoveable;\n        if (R) {\n          R.checkUpdateRect();\n          return;\n        }\n        cancelAnimationFrame$1(o._observerId), o._observerId = requestAnimationFrame$1(function() {\n          o.isDragging() || o.updateRect();\n        });\n      }\n    }, o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this.props, R = this.state, N = o.parentPosition, M = o.className, D = o.target, L = o.zoom, B = o.cspNonce, $ = o.translateZ, k = o.cssStyled, U = o.portalContainer;\n    this.checkUpdate(), this.updateRenderPoses();\n    var z = N || {\n      left: 0,\n      top: 0\n    }, X = z.left, V = z.top, W = R.left, Y = R.top, q = R.target, Z = R.direction, K = R.hasFixed, Q = o.targets, J = (Q && Q.length || D) && q, rt = this.isDragging(), tt = {};\n    return this.getEnabledAbles().forEach(function(nt) {\n      tt[\"data-able-\".concat(nt.name.toLowerCase())] = !0;\n    }), createElement(k, __assign$2({\n      cspNonce: B,\n      ref: ref(this, \"controlBox\"),\n      className: \"\".concat(prefix(\"control-box\", Z === -1 ? \"reverse\" : \"\", rt ? \"dragging\" : \"\"), \" \").concat(M)\n    }, tt, {\n      onClick: this.onPreventClick,\n      portalContainer: U,\n      style: {\n        position: K ? \"fixed\" : \"absolute\",\n        display: J ? \"block\" : \"none\",\n        transform: \"translate3d(\".concat(W - X, \"px, \").concat(Y - V, \"px, \").concat($, \")\"),\n        \"--zoom\": L,\n        \"--zoompx\": \"\".concat(L, \"px\")\n      }\n    }), this.renderAbles(), this._renderLines());\n  }, e.componentDidMount = function() {\n    this.isUnmounted = !1, this.controlBox.getElement();\n    var o = this.props, R = o.parentMoveable, N = o.container, M = o.wrapperMoveable;\n    this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), !N && !R && !M && this.updateRect(\"\", !1, !0), this.updateCheckInput(), this._updateObserver(this.props);\n  }, e.componentDidUpdate = function(o) {\n    this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(o);\n  }, e.componentWillUnmount = function() {\n    this.isUnmounted = !0, this._emitter.off(), unset(this, \"targetGesto\"), unset(this, \"controlGesto\");\n    var o = this.events;\n    for (var R in o) {\n      var N = o[R];\n      N && N.destroy();\n    }\n  }, e.getAble = function(o) {\n    var R = this.props.ables || [];\n    return find$1(R, function(N) {\n      return N.name === o;\n    });\n  }, e.getContainer = function() {\n    var o = this.props, R = o.parentMoveable, N = o.wrapperMoveable, M = o.container;\n    return M || N && N.getContainer() || R && R.getContainer() || this.controlBox.getElement().parentElement;\n  }, e.isMoveableElement = function(o) {\n    return o && (o.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n  }, e.dragStart = function(o) {\n    var R = this.targetGesto;\n    return R && !R.isFlag() && R.triggerDragStart(o), this;\n  }, e.hitTest = function(o) {\n    var R = this.state, N = R.target, M = R.pos1, D = R.pos2, L = R.pos3, B = R.pos4, $ = R.targetClientRect;\n    if (!N)\n      return 0;\n    var k;\n    if (o instanceof Element) {\n      var U = o.getBoundingClientRect();\n      k = {\n        left: U.left,\n        top: U.top,\n        width: U.width,\n        height: U.height\n      };\n    } else\n      k = __assign$2({\n        width: 0,\n        height: 0\n      }, o);\n    var z = k.left, X = k.top, V = k.width, W = k.height, Y = fitPoints([M, D, B, L], $), q = getOverlapSize(Y, [[z, X], [z + V, X], [z + V, X + W], [z, X + W]]), Z = getAreaSize(Y);\n    return !q || !Z ? 0 : Math.min(100, q / Z * 100);\n  }, e.isInside = function(o, R) {\n    var N = this.state, M = N.target, D = N.pos1, L = N.pos2, B = N.pos3, $ = N.pos4, k = N.targetClientRect;\n    return M ? isInside([o, R], fitPoints([D, L, $, B], k)) : !1;\n  }, e.updateRect = function(o, R, N) {\n    N === void 0 && (N = !0);\n    var M = this.props, D = M.parentMoveable, L = this.state, B = L.target || this.props.target, $ = this.getContainer(), k = D ? D.props.rootContainer : M.rootContainer;\n    this.updateState(getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), B, $, $, k || $), D ? !1 : N);\n  }, e.isDragging = function() {\n    return (this.targetGesto ? this.targetGesto.isFlag() : !1) || (this.controlGesto ? this.controlGesto.isFlag() : !1);\n  }, e.updateTarget = function(o) {\n    this.updateRect(o, !0);\n  }, e.getRect = function() {\n    var o = this.state, R = getAbsolutePosesByState(this.state), N = R[0], M = R[1], D = R[2], L = R[3], B = getRect(R), $ = o.width, k = o.height, U = B.width, z = B.height, X = B.left, V = B.top, W = [o.left, o.top], Y = plus(W, o.origin), q = plus(W, o.beforeOrigin), Z = o.transformOrigin;\n    return {\n      width: U,\n      height: z,\n      left: X,\n      top: V,\n      pos1: N,\n      pos2: M,\n      pos3: D,\n      pos4: L,\n      offsetWidth: $,\n      offsetHeight: k,\n      beforeOrigin: q,\n      origin: Y,\n      transformOrigin: Z,\n      rotation: this.getRotation()\n    };\n  }, e.getManager = function() {\n    return this;\n  }, e.getRotation = function() {\n    var o = this.state, R = o.pos1, N = o.pos2, M = o.direction;\n    return getAbsoluteRotation(R, N, M);\n  }, e.request = function(o, R, N) {\n    R === void 0 && (R = {});\n    var M = this.props, D = M.ables, L = M.groupable, B = D.filter(function(W) {\n      return W.name === o;\n    })[0];\n    if (this.isDragging() || !B || !B.request)\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    var $ = this, k = B.request(this), U = N || R.isInstant, z = k.isControl ? \"controlAbles\" : \"targetAbles\", X = \"\".concat(L ? \"Group\" : \"\").concat(k.isControl ? \"Control\" : \"\"), V = {\n      request: function(W) {\n        return triggerAble($, z, \"drag\", X, \"\", __assign$2(__assign$2({}, k.request(W)), {\n          requestAble: o,\n          isRequest: !0\n        }), U), this;\n      },\n      requestEnd: function() {\n        return triggerAble($, z, \"drag\", X, \"End\", __assign$2(__assign$2({}, k.requestEnd()), {\n          requestAble: o,\n          isRequest: !0\n        }), U), this;\n      }\n    };\n    return triggerAble($, z, \"drag\", X, \"Start\", __assign$2(__assign$2({}, k.requestStart(R)), {\n      requestAble: o,\n      isRequest: !0\n    }), U), U ? V.request(R).requestEnd() : V;\n  }, e.destroy = function() {\n    this.componentWillUnmount();\n  }, e.updateRenderPoses = function() {\n    var o = this.state, R = this.props, N = o.originalBeforeOrigin, M = o.transformOrigin, D = o.allMatrix, L = o.is3d, B = o.pos1, $ = o.pos2, k = o.pos3, U = o.pos4, z = o.left, X = o.top, V = R.padding || {}, W = V.left, Y = W === void 0 ? 0 : W, q = V.top, Z = q === void 0 ? 0 : q, K = V.bottom, Q = K === void 0 ? 0 : K, J = V.right, rt = J === void 0 ? 0 : J, tt = L ? 4 : 3, nt = R.groupable ? N : plus(N, [z, X]);\n    o.renderPoses = [plus(B, calculatePadding(D, [-Y, -Z], M, nt, tt)), plus($, calculatePadding(D, [rt, -Z], M, nt, tt)), plus(k, calculatePadding(D, [-Y, Q], M, nt, tt)), plus(U, calculatePadding(D, [rt, Q], M, nt, tt))];\n  }, e.checkUpdate = function() {\n    var o = this.props, R = o.target, N = o.container, M = o.parentMoveable, D = this.state, L = D.target, B = D.container;\n    if (!(!L && !R)) {\n      this.updateAbles();\n      var $ = !equals(L, R) || !equals(B, N);\n      if (!!$) {\n        var k = N || this.controlBox;\n        k && this.unsetAbles(), this.updateState({\n          target: R,\n          container: N\n        }), !M && k && this.updateRect(\"End\", !1, !1);\n      }\n    }\n  }, e.triggerEvent = function(o, R) {\n    this._emitter.trigger(o, R);\n    var N = this.props[o];\n    return N && N(R);\n  }, e.useCSS = function(o, R) {\n    var N = this.props.customStyledMap, M = o + R;\n    return N[M] || (N[M] = styled(o, R)), N[M];\n  }, e.unsetAbles = function() {\n    var o = this;\n    this.targetAbles.forEach(function(R) {\n      R.unset && R.unset(o);\n    });\n  }, e.updateAbles = function(o, R) {\n    o === void 0 && (o = this.props.ables), R === void 0 && (R = \"\");\n    var N = this.props, M = N.triggerAblesSimultaneously, D = o.filter(function(z) {\n      return z && (z.always && N[z.name] !== !1 || N[z.name]);\n    }), L = \"drag\".concat(R, \"Start\"), B = \"pinch\".concat(R, \"Start\"), $ = \"drag\".concat(R, \"ControlStart\"), k = filterAbles(D, [L, B], M), U = filterAbles(D, [$], M);\n    this.enabledAbles = D, this.targetAbles = k, this.controlAbles = U;\n  }, e.updateState = function(o, R) {\n    if (R) {\n      if (this.isUnmounted)\n        return;\n      this.setState(o);\n    } else {\n      var N = this.state;\n      for (var M in o)\n        N[M] = o[M];\n    }\n  }, e.getEnabledAbles = function() {\n    var o = this.props, R = o.ables;\n    return R.filter(function(N) {\n      return N && o[N.name];\n    });\n  }, e.renderAbles = function() {\n    var o = this, R = this.props, N = R.triggerAblesSimultaneously, M = {\n      createElement\n    };\n    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], N).map(function(D) {\n      var L = D.render;\n      return L(o, M) || [];\n    })).filter(function(D) {\n      return D;\n    }), function(D) {\n      var L = D.key;\n      return L;\n    }).map(function(D) {\n      return D[0];\n    });\n  }, e.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }, e._updateObserver = function(o) {\n    var R, N = this.props, M = N.target;\n    if (!window.ResizeObserver || !M || !N.useResizeObserver) {\n      (R = this._observer) === null || R === void 0 || R.disconnect();\n      return;\n    }\n    if (!(o.target === M && this._observer)) {\n      var D = new ResizeObserver(this.checkUpdateRect);\n      D.observe(M, {\n        box: \"border-box\"\n      }), this._observer = D;\n    }\n  }, e._updateEvents = function() {\n    var o = this.controlBox.getElement(), R = this.targetAbles.length, N = this.controlAbles.length, M = this.props, D = M.dragTarget || M.target, L = !R && this.targetGesto || this._isTargetChanged(!0);\n    L && (unset(this, \"targetGesto\"), this.updateState({\n      gesto: null\n    })), N || unset(this, \"controlGesto\"), D && R && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, D, \"\")), !this.controlGesto && N && (this.controlGesto = getAbleGesto(this, o, \"controlAbles\", \"Control\"));\n  }, e._updateTargets = function() {\n    var o = this.props;\n    this._prevTarget = o.dragTarget || o.target, this._prevDragArea = o.dragArea;\n  }, e._renderLines = function() {\n    var o = this.props, R = o, N = R.zoom, M = R.hideDefaultLines, D = R.hideChildMoveableDefaultLines, L = R.parentMoveable;\n    if (M || L && D)\n      return [];\n    var B = this.state.renderPoses, $ = {\n      createElement\n    };\n    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(k, U) {\n      var z = k[0], X = k[1];\n      return renderLine($, \"\", B[z], B[X], N, U);\n    });\n  }, e._isTargetChanged = function(o) {\n    var R = this.props, N = R.dragTarget || R.target, M = this._prevTarget, D = this._prevDragArea, L = R.dragArea, B = !L && M !== N, $ = (o || L) && D !== L;\n    return B || $;\n  }, e._updateNativeEvents = function() {\n    var o = this, R = this.props, N = R.dragArea ? this.areaElement : this.state.target, M = this.events, D = getKeys(M);\n    if (this._isTargetChanged())\n      for (var L in M) {\n        var B = M[L];\n        B && B.destroy(), M[L] = null;\n      }\n    if (!!N) {\n      var $ = this.enabledAbles;\n      D.forEach(function(k) {\n        var U = filterAbles($, [k]), z = U.length > 0, X = M[k];\n        if (!z) {\n          X && (X.destroy(), M[k] = null);\n          return;\n        }\n        X || (X = new EventManager(N, o, k), M[k] = X), X.setAbles(U);\n      });\n    }\n  }, t.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: !0,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    parentPosition: null,\n    portalContainer: null,\n    useResizeObserver: !1,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: !1,\n    passDragArea: !1,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: !1,\n    padding: {},\n    pinchOutside: !0,\n    checkInput: !1,\n    groupable: !1,\n    hideDefaultLines: !1,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    flushSync: defaultSync\n  }, t;\n}(PureComponent), Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean,\n    hideChildMoveableDefaultLines: Boolean\n  },\n  events: {},\n  render: function(n, t) {\n    var e = n.props.targets || [];\n    n.moveables = [];\n    var o = n.state, R = o.left, N = o.top, M = {\n      left: R,\n      top: N\n    }, D = n.props;\n    return e.map(function(L, B) {\n      return t.createElement(MoveableManager$1, {\n        key: \"moveable\" + B,\n        ref: refs(n, \"moveables\", B),\n        target: L,\n        origin: !1,\n        cssStyled: D.cssStyled,\n        customStyledMap: D.customStyledMap,\n        useResizeObserver: D.useResizeObserver,\n        hideChildMoveableDefaultLines: D.hideChildMoveableDefaultLines,\n        parentMoveable: n,\n        parentPosition: M\n      });\n    });\n  }\n}, Clickable = makeAble(\"clickable\", {\n  props: {\n    clickable: Boolean,\n    preventClickDefault: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: !0,\n  dragRelation: \"weak\",\n  dragStart: function(n, t) {\n    t.isRequest || addEvent(window, \"click\", n.onPreventClick, !0);\n  },\n  dragControlStart: function(n, t) {\n    this.dragStart(n, t);\n  },\n  dragGroupStart: function(n, t) {\n    this.dragStart(n, t), t.datas.inputTarget = t.inputEvent && t.inputEvent.target;\n  },\n  dragEnd: function(n, t) {\n    this.endEvent(n);\n    var e = n.state.target, o = t.inputEvent, R = t.inputTarget, N = n.isMoveableElement(R), M = !N && n.controlBox.getElement().contains(R);\n    if ((!n.props.preventClickDefault && !t.isDrag || M) && this.unset(n), !(!o || !R || t.isDrag || n.isMoveableElement(R) || M)) {\n      var D = e.contains(R);\n      triggerEvent(n, \"onClick\", fillParams(n, t, {\n        isDouble: t.isDouble,\n        inputTarget: R,\n        isTarget: e === R,\n        containsTarget: D\n      }));\n    }\n  },\n  dragGroupEnd: function(n, t) {\n    this.endEvent(n);\n    var e = t.inputEvent, o = t.inputTarget;\n    if (!(!e || !o || t.isDrag || n.isMoveableElement(o) || t.datas.inputTarget === o)) {\n      var R = n.props.targets, N = R.indexOf(o), M = N > -1, D = !1;\n      N === -1 && (N = findIndex(R, function(L) {\n        return L.contains(o);\n      }), D = N > -1), triggerEvent(n, \"onClickGroup\", fillParams(n, t, {\n        isDouble: t.isDouble,\n        targets: R,\n        inputTarget: o,\n        targetIndex: N,\n        isTarget: M,\n        containsTarget: D\n      }));\n    }\n  },\n  dragControlEnd: function(n, t) {\n    this.dragEnd(n, t);\n  },\n  dragGroupControlEnd: function(n, t) {\n    this.dragEnd(n, t);\n  },\n  endEvent: function(n) {\n    var t = this;\n    requestAnimationFrame$1(function() {\n      t.unset(n);\n    });\n  },\n  unset: function(n) {\n    removeEvent(window, \"click\", n.onPreventClick, !0);\n  }\n});\nfunction getDraggableEvent(n) {\n  var t = n.originalDatas.draggable;\n  return t || (n.originalDatas.draggable = {}, t = n.originalDatas.draggable), __assign$2(__assign$2({}, n), {\n    datas: t\n  });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  css: [`.edge.edgeDraggable.line {\n    cursor: move;\n}`],\n  render: function(n, t) {\n    var e = n.props, o = e.edgeDraggable;\n    return o ? renderEdgeLines(t, \"edgeDraggable\", o, n.state.renderPoses, e.zoom) : [];\n  },\n  dragControlCondition: function(n, t) {\n    if (!n.props.edgeDraggable || !t.inputEvent)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"edge\")) && hasClass(e, prefix(\"edgeDraggable\"));\n  },\n  dragControlStart: function(n, t) {\n    return n.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, Draggable.dragStart(n, getDraggableEvent(t));\n  },\n  dragControl: function(n, t) {\n    return Draggable.drag(n, getDraggableEvent(t));\n  },\n  dragControlEnd: function(n, t) {\n    return Draggable.dragEnd(n, getDraggableEvent(t));\n  },\n  dragGroupControlCondition: function(n, t) {\n    if (!n.props.edgeDraggable || !t.inputEvent)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"line\"));\n  },\n  dragGroupControlStart: function(n, t) {\n    return Draggable.dragGroupStart(n, getDraggableEvent(t));\n  },\n  dragGroupControl: function(n, t) {\n    return Draggable.dragGroup(n, getDraggableEvent(t));\n  },\n  dragGroupControlEnd: function(n, t) {\n    return Draggable.dragGroupEnd(n, getDraggableEvent(t));\n  },\n  unset: function(n) {\n    return Draggable.unset(n);\n  }\n}), IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean\n  },\n  events: {}\n}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(n, t) {\n  return __assign$2(__assign$2({}, n), \"events\" in t ? t.events : {});\n}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(n, t) {\n  return __assign$2(__assign$2({}, n), t.props);\n}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nfunction getMaxPos(n, t) {\n  return Math.max.apply(Math, n.map(function(e) {\n    var o = e[0], R = e[1], N = e[2], M = e[3];\n    return Math.max(o[t], R[t], N[t], M[t]);\n  }));\n}\nfunction getMinPos(n, t) {\n  return Math.min.apply(Math, n.map(function(e) {\n    var o = e[0], R = e[1], N = e[2], M = e[3];\n    return Math.min(o[t], R[t], N[t], M[t]);\n  }));\n}\nfunction getGroupRect(n, t) {\n  if (!n.length)\n    return [0, 0, 0, 0];\n  var e = n.map(function(V) {\n    var W = V.state;\n    return getAbsolutePosesByState(W);\n  }), o = MAX_NUM, R = MAX_NUM, N = 0, M = 0, D = throttle(t, TINY_NUM);\n  if (D % 90) {\n    var L = D / 180 * Math.PI, B = Math.tan(L), $ = -1 / B, k = [MIN_NUM, MAX_NUM], U = [MIN_NUM, MAX_NUM];\n    e.forEach(function(V) {\n      V.forEach(function(W) {\n        var Y = W[1] - B * W[0], q = W[1] - $ * W[0];\n        k[0] = Math.max(k[0], Y), k[1] = Math.min(k[1], Y), U[0] = Math.max(U[0], q), U[1] = Math.min(U[1], q);\n      });\n    }), k.forEach(function(V) {\n      U.forEach(function(W) {\n        var Y = (W - V) / (B - $), q = B * Y + V;\n        o = Math.min(o, Y), R = Math.min(R, q);\n      });\n    });\n    var z = e.map(function(V) {\n      var W = V[0], Y = V[1], q = V[2], Z = V[3];\n      return [rotate(W, -L), rotate(Y, -L), rotate(q, -L), rotate(Z, -L)];\n    });\n    N = getMaxPos(z, 0) - getMinPos(z, 0), M = getMaxPos(z, 1) - getMinPos(z, 1);\n  } else if (o = getMinPos(e, 0), R = getMinPos(e, 1), N = getMaxPos(e, 0) - o, M = getMaxPos(e, 1) - R, D % 180) {\n    var X = N;\n    N = M, M = X;\n  }\n  return [o, R, N, M];\n}\nvar MoveableGroup = /* @__PURE__ */ function(n) {\n  __extends$1(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.differ = new ChildrenDiffer$1(), o.moveables = [], o.transformOrigin = \"50% 50%\", o;\n  }\n  var e = t.prototype;\n  return e.checkUpdate = function() {\n    this.updateAbles();\n  }, e.updateRect = function(o, R, N) {\n    if (N === void 0 && (N = !0), !!this.controlBox) {\n      this.moveables.forEach(function(dt) {\n        dt.updateRect(o, !1, !1);\n      });\n      var M = this.state, D = this.props, L = M.target || D.target;\n      (!R || o !== \"\" && D.updateGroup) && (this.rotation = D.defaultGroupRotate, this.transformOrigin = D.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]);\n      var B = this.rotation, $ = this.scale, k = getGroupRect(this.moveables, B), U = k[0], z = k[1], X = k[2], V = k[3], W = \"rotate(\".concat(B, \"deg) scale(\").concat($[0] >= 0 ? 1 : -1, \", \").concat($[1] >= 0 ? 1 : -1, \")\");\n      L.style.cssText += \"left:0px;top:0px; transform-origin: \".concat(this.transformOrigin, \"; width:\").concat(X, \"px; height:\").concat(V, \"px;\") + \"transform:\".concat(W), M.width = X, M.height = V;\n      var Y = this.getContainer(), q = getMoveableTargetInfo(this.controlBox.getElement(), L, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || Y), Z = [q.left, q.top], K = getAbsolutePosesByState(q), Q = K[0], J = K[1], rt = K[2], tt = K[3], nt = getMinMaxs([Q, J, rt, tt]), st = [nt.minX, nt.minY];\n      q.pos1 = minus(Q, st), q.pos2 = minus(J, st), q.pos3 = minus(rt, st), q.pos4 = minus(tt, st), q.left = U - q.left + st[0], q.top = z - q.top + st[1], q.origin = minus(plus(Z, q.origin), st), q.beforeOrigin = minus(plus(Z, q.beforeOrigin), st), q.originalBeforeOrigin = plus(Z, q.originalBeforeOrigin);\n      var ut = q.targetClientRect, ct = $[0] * $[1] > 0 ? 1 : -1;\n      ut.top += q.top - M.top, ut.left += q.left - M.left, L.style.transform = \"translate(\".concat(-st[0], \"px, \").concat(-st[1], \"px) \").concat(W), this.updateState(__assign$2(__assign$2({}, q), {\n        direction: ct,\n        beforeDirection: ct\n      }), N);\n    }\n  }, e.getRect = function() {\n    return __assign$2(__assign$2({}, n.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(o) {\n        return o.getRect();\n      })\n    });\n  }, e.triggerEvent = function(o, R, N) {\n    if (N || o.indexOf(\"Group\") > -1)\n      return n.prototype.triggerEvent.call(this, o, R);\n    this._emitter.trigger(o, R);\n  }, e.updateAbles = function() {\n    n.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), \"Group\");\n  }, e._updateTargets = function() {\n    n.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;\n  }, e._updateEvents = function() {\n    var o = this.state, R = this.props, N = this._prevTarget, M = R.dragTarget || this.areaElement;\n    N !== M && (unset(this, \"targetGesto\"), unset(this, \"controlGesto\"), o.target = null), o.target || (o.target = this.areaElement, this.controlBox.getElement().style.display = \"block\"), o.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, M, \"Group\")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\")));\n    var D = !equals(o.container, R.container);\n    D && (o.container = R.container);\n    var L = this.differ.update(R.targets), B = L.added, $ = L.changed, k = L.removed;\n    (D || B.length || $.length || k.length) && this.updateRect();\n  }, e._updateObserver = function() {\n  }, t.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: !0,\n    dragArea: !0,\n    keepRatio: !0,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  }), t;\n}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(n) {\n  __extends$1(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.moveables = [], o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this, R = this.props, N = R.cspNonce, M = R.cssStyled, D = R.targets;\n    return createElement(M, {\n      cspNonce: N,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, D.map(function(L, B) {\n      return createElement(MoveableManager$1, __assign$2({\n        key: \"moveable\" + B,\n        ref: refs(o, \"moveables\", B)\n      }, o.props, {\n        target: L,\n        wrapperMoveable: o\n      }));\n    }));\n  }, e.componentDidUpdate = function() {\n  }, e.updateRect = function(o, R, N) {\n    N === void 0 && (N = !0), this.moveables.forEach(function(M) {\n      M.updateRect(o, R, N);\n    });\n  }, e.getRect = function() {\n    return __assign$2(__assign$2({}, n.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(o) {\n        return o.getRect();\n      })\n    });\n  }, e.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  }, e.dragStart = function() {\n    return this;\n  }, e.hitTest = function() {\n    return 0;\n  }, e.isInside = function() {\n    return !1;\n  }, e.isDragging = function() {\n    return !1;\n  }, e.updateRenderPoses = function() {\n  }, e.checkUpdate = function() {\n  }, e.triggerEvent = function() {\n  }, e.updateAbles = function() {\n  }, e._updateEvents = function() {\n  }, e._updateObserver = function() {\n  }, t;\n}(MoveableManager$1), InitialMoveable = /* @__PURE__ */ function(n) {\n  __extends$1(t, n);\n  function t() {\n    var o = n !== null && n.apply(this, arguments) || this;\n    return o.refTargets = [], o.selectorMap = {}, o;\n  }\n  var e = t.prototype;\n  return t.makeStyled = function() {\n    var o = {}, R = this.getTotalAbles();\n    R.forEach(function(M) {\n      var D = M.css;\n      !D || D.forEach(function(L) {\n        o[L] = !0;\n      });\n    });\n    var N = getKeys(o).join(`\n`);\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + N));\n  }, t.getTotalAbles = function() {\n    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);\n  }, e.render = function() {\n    var o = this.constructor;\n    o.defaultStyled || o.makeStyled();\n    var R = this.props, N = R.ables, M = R.props, D = __rest(R, [\"ables\", \"props\"]), L = this._updateRefs(!0), B = getElementTargets(L, this.selectorMap), $ = B.length > 1, k = o.getTotalAbles(), U = __spreadArray(__spreadArray([], k, !0), N || [], !0), z = __assign$2(__assign$2(__assign$2({}, D), M || {}), {\n      ables: U,\n      cssStyled: o.defaultStyled,\n      customStyledMap: o.customStyledMap\n    });\n    return $ ? D.individualGroupable ? createElement(MoveableIndividualGroup, __assign$2({\n      key: \"individual-group\",\n      ref: ref(this, \"moveable\")\n    }, z, {\n      target: null,\n      targets: B\n    })) : createElement(MoveableGroup, __assign$2({\n      key: \"group\",\n      ref: ref(this, \"moveable\")\n    }, z, {\n      target: null,\n      targets: B\n    })) : createElement(MoveableManager$1, __assign$2({\n      key: \"single\",\n      ref: ref(this, \"moveable\")\n    }, z, {\n      target: B[0]\n    }));\n  }, e.componentDidMount = function() {\n    this._updateRefs();\n  }, e.componentDidUpdate = function() {\n    this._updateRefs();\n  }, e.componentWillUnmount = function() {\n    this.selectorMap = {}, this.refTargets = [];\n  }, e.getManager = function() {\n    return this.moveable;\n  }, e._updateRefs = function(o) {\n    var R = this.refTargets, N = getRefTargets(this.props.target || this.props.targets), M = typeof document < \"u\", D = R.length !== N.length || R.some(function($, k) {\n      var U = N[k];\n      return !$ && !U ? !1 : $ !== U;\n    }), L = this.selectorMap, B = {};\n    return this.refTargets.forEach(function($) {\n      if (isString($)) {\n        var k = L[$];\n        k ? B[$] = L[$] : M && (D = !0, B[$] = [].slice.call(document.querySelectorAll($)));\n      }\n    }), this.refTargets = N, this.selectorMap = B, !o && D && this.forceUpdate(), N;\n  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, \"moveable\", void 0), t;\n}(PureComponent), Moveable$1 = /* @__PURE__ */ function(n) {\n  __extends$1(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  return t.defaultAbles = MOVEABLE_ABLES, t;\n}(InitialMoveable), Moveable$2 = Moveable$1;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(n, t) {\n  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var R in o)\n      o.hasOwnProperty(R) && (e[R] = o[R]);\n  }, extendStatics(n, t);\n};\nfunction __extends(n, t) {\n  extendStatics(n, t);\n  function e() {\n    this.constructor = n;\n  }\n  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$1 = function() {\n  return __assign$1 = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign$1.apply(this, arguments);\n};\nfunction __decorate(n, t, e, o) {\n  var R = arguments.length, N = R < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, M;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    N = Reflect.decorate(n, t, e, o);\n  else\n    for (var D = n.length - 1; D >= 0; D--)\n      (M = n[D]) && (N = (R < 3 ? M(N) : R > 3 ? M(t, e, N) : M(t, e)) || N);\n  return R > 3 && N && Object.defineProperty(t, e, N), N;\n}\nvar InnerMoveable = /* @__PURE__ */ function(n) {\n  __extends(t, n);\n  function t(o) {\n    var R = n.call(this, o) || this;\n    return R.state = {}, R.state = R.props, R;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    return createPortal(createElement(Moveable$2, __assign$1({\n      ref: ref(this, \"moveable\")\n    }, this.state)), this.state.parentElement);\n  }, t;\n}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign = function() {\n  return __assign = Object.assign || function(t) {\n    for (var e, o = 1, R = arguments.length; o < R; o++) {\n      e = arguments[o];\n      for (var N in e)\n        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);\n    }\n    return t;\n  }, __assign.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var n = 0, t = 0, e = arguments.length; t < e; t++)\n    n += arguments[t].length;\n  for (var o = Array(n), R = 0, t = 0; t < e; t++)\n    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)\n      o[R] = N[M];\n  return o;\n}\nvar EventEmitter = /* @__PURE__ */ function() {\n  function n() {\n    this._events = {};\n  }\n  var t = n.prototype;\n  return t.on = function(e, o) {\n    if (isObject$2(e))\n      for (var R in e)\n        this.on(R, e[R]);\n    else\n      this._addEvent(e, o, {});\n    return this;\n  }, t.off = function(e, o) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var R in e)\n        this.off(R);\n    else if (!o)\n      this._events[e] = [];\n    else {\n      var N = this._events[e];\n      if (N) {\n        var M = findIndex(N, function(D) {\n          return D.listener === o;\n        });\n        M > -1 && N.splice(M, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, o) {\n    var R = this;\n    return o && this._addEvent(e, o, {\n      once: !0\n    }), new Promise(function(N) {\n      R._addEvent(e, N, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, o) {\n    var R = this;\n    o === void 0 && (o = {});\n    var N = this._events[e];\n    if (!e || !N)\n      return !0;\n    var M = !1;\n    return o.eventType = e, o.stop = function() {\n      M = !0;\n    }, o.currentTarget = this, __spreadArrays(N).forEach(function(D) {\n      D.listener(o), D.once && R.off(e, D.listener);\n    }), !M;\n  }, t.trigger = function(e, o) {\n    return o === void 0 && (o = {}), this.emit(e, o);\n  }, t._addEvent = function(e, o, R) {\n    var N = this._events;\n    N[e] = N[e] || [];\n    var M = N[e];\n    M.push(__assign({\n      listener: o\n    }, R));\n  }, n;\n}(), EventEmitter$1 = EventEmitter, MoveableManager = /* @__PURE__ */ function(n) {\n  __extends(t, n);\n  function t(o, R) {\n    R === void 0 && (R = {});\n    var N = n.call(this) || this;\n    N.tempElement = document.createElement(\"div\");\n    var M = __assign$1({}, R), D = {};\n    EVENTS.forEach(function(B) {\n      D[camelize(\"on \".concat(B))] = function($) {\n        return N.trigger(B, $);\n      };\n    }), render(createElement(InnerMoveable, __assign$1({\n      ref: ref(N, \"innerMoveable\"),\n      parentElement: o\n    }, M, D)), N.tempElement);\n    var L = M.target;\n    return isArray(L) && L.length > 1 && N.updateRect(), N;\n  }\n  var e = t.prototype;\n  return e.setState = function(o, R) {\n    this.innerMoveable.setState(o, R);\n  }, e.forceUpdate = function(o) {\n    this.innerMoveable.forceUpdate(o);\n  }, e.dragStart = function(o) {\n    var R = this.innerMoveable;\n    R.$_timer && this.forceUpdate(), this.getMoveable().dragStart(o);\n  }, e.destroy = function() {\n    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;\n  }, e.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  }, t = __decorate([Properties(METHODS, function(o, R) {\n    o[R] || (o[R] = function() {\n      for (var N = [], M = 0; M < arguments.length; M++)\n        N[M] = arguments[M];\n      var D = this.getMoveable();\n      if (!(!D || !D[R]))\n        return D[R].apply(D, N);\n    });\n  }), Properties(PROPERTIES, function(o, R) {\n    Object.defineProperty(o, R, {\n      get: function() {\n        return this.getMoveable().props[R];\n      },\n      set: function(N) {\n        var M;\n        this.setState((M = {}, M[R] = N, M));\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  })], t), t;\n}(EventEmitter$1), Moveable = /* @__PURE__ */ function(n) {\n  __extends(t, n);\n  function t() {\n    return n !== null && n.apply(this, arguments) || this;\n  }\n  return t;\n}(MoveableManager), __accessCheck$2 = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet$2 = (n, t, e) => (__accessCheck$2(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd$2 = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet$2 = (n, t, e, o) => (__accessCheck$2(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), __privateWrapper = (n, t, e, o) => ({\n  set _(R) {\n    __privateSet$2(n, t, R, e);\n  },\n  get _() {\n    return __privateGet$2(n, t, o);\n  }\n}), __privateMethod$2 = (n, t, e) => (__accessCheck$2(n, t, \"access private method\"), e), _divDesignRoot, _scrItr, _alzTagArg, _cfg$1, _ID_DESIGNMODE, _cntDesignCast, _hId2dc, _aDC, _resizeDiv, resizeDiv_fn;\nconst _DesignCast = class {\n  constructor(n, t = !1) {\n    this.bg_col = n, this.isLay = t, __privateAdd$2(this, _resizeDiv), this.hArg = {}, this.id_tag = \"\", this.hDesignArg = {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0\n    }, this.fncLay = () => {\n    }, this.mov = void 0, this.div = void 0, this.lx = 0, this.ly = 0, this.rect = Rectangle.EMPTY, this.pivot = new Point(0, 0), this.scale = new Point(1, 1), this.rotation = 0, this.oldFn = () => \"\", this.rotatable = !0;\n  }\n  static init(n, t, e, o, R, N, M) {\n    n.view.insertAdjacentHTML(\"beforebegin\", `<div id=\"${__privateGet$2(_DesignCast, _ID_DESIGNMODE)}\" style=\"width: ${CmnLib.stageW * _DesignCast.sys.cvsScale}px; height: ${CmnLib.stageH * t.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`), __privateSet$2(_DesignCast, _divDesignRoot, document.getElementById(__privateGet$2(_DesignCast, _ID_DESIGNMODE))), _DesignCast.divHint.classList.add(\"sn_design_hint\"), n.view.parentElement.appendChild(_DesignCast.divHint), _DesignCast.sys = t, __privateSet$2(_DesignCast, _scrItr, e), _DesignCast.prpPrs = o, __privateSet$2(_DesignCast, _alzTagArg, R), __privateSet$2(_DesignCast, _cfg$1, N), _DesignCast.hPages = M, addStyle(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(n, t, e, o) {\n    _DesignCast.divHint.innerHTML = n;\n    const R = window.getComputedStyle(_DesignCast.divHint), N = parseFloat(R.width), M = parseFloat(R.height);\n    _DesignCast.divHint.style.cssText = `display: block; left: ${Math.max(10, o.lx + t - N)}px;\n\t\ttop: ${Math.max(10, o.ly + e - M - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const n = __privateGet$2(_DesignCast, _divDesignRoot).style;\n    n.width = `${CmnLib.stageW * _DesignCast.sys.cvsScale}px`, n.height = `${CmnLib.stageH * _DesignCast.sys.cvsScale}px`;\n  }\n  destroy() {\n    var n;\n    this.div = void 0, (n = this.mov) == null || n.destroy(), this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(n) {\n    var e, o;\n    if (!this.includeDesignArg(n))\n      return;\n    this.id_tag || (this.id_tag = (e = n[\":id_tag\"]) != null ? e : \"\"), this.hArg = n;\n    const t = (o = n[\":id_dc\"]) != null ? o : this.id_tag;\n    __privateGet$2(_DesignCast, _hId2dc)[t] = this;\n  }\n  includeDesignArg(n) {\n    for (const t in n)\n      if (t in this.hDesignArg)\n        return !0;\n    return !1;\n  }\n  getRect() {\n    return Rectangle.EMPTY;\n  }\n  cnvPosArg(n, t) {\n    return {};\n  }\n  cnvSizeArg(n, t) {\n    return {};\n  }\n  setPos(n, t) {\n  }\n  setSize(n, t) {\n  }\n  setOther(n) {\n  }\n  adopt(n) {\n    this.child = n, n.parent = this;\n  }\n  static enterMode() {\n    _DesignCast.leaveMode(), __privateGet$2(_DesignCast, _divDesignRoot).style.display = \"inline\", __privateSet$2(_DesignCast, _cntDesignCast, 0), __privateSet$2(_DesignCast, _hId2dc, {});\n  }\n  static allHide() {\n    __privateGet$2(_DesignCast, _aDC).forEach((n) => n.visible = !1);\n  }\n  set visible(n) {\n    !this.div || !this.mov || (this.div.style.display = n ? \"inline\" : \"none\", this.mov.updateTarget());\n  }\n  static leaveMode() {\n    __privateGet$2(_DesignCast, _divDesignRoot).textContent = \"\", __privateGet$2(_DesignCast, _divDesignRoot).style.display = \"none\", __privateGet$2(_DesignCast, _aDC).forEach((n) => n.destroy()), __privateSet$2(_DesignCast, _aDC, []);\n  }\n  cvsResize() {\n    var n;\n    __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (n = this.mov) == null || n.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    var D, L;\n    const n = (D = this.hArg[\":id_dc\"]) != null ? D : this.id_tag;\n    __privateGet$2(_DesignCast, _hId2dc)[n] = this;\n    const t = this.div = document.createElement(\"div\");\n    t.id = __privateGet$2(_DesignCast, _ID_DESIGNMODE) + \"_\" + ++__privateWrapper(_DesignCast, _cntDesignCast)._, t.classList.add(\"sn_design_cast\"), t.dataset.id_dc = n, t.style.backgroundColor = `${this.bg_col}`, t.style.display = \"none\", this.rect = this.getRect(), __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (this.parent && (L = document.querySelector(\n      `[data-id_dc=\"${this.parent.id_tag}\"]`\n    )) != null ? L : __privateGet$2(_DesignCast, _divDesignRoot)).appendChild(t);\n    const e = {\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    }, o = () => {\n      e.aPos = [NaN, NaN], e.roDeg = this.rotation;\n      const B = this.pivot.x * _DesignCast.sys.cvsScale, $ = this.pivot.y * _DesignCast.sys.cvsScale;\n      e.trOrg = `${B}px ${$}px`, e.origin = [B, $], Object.assign(this.mov, {\n        verticalGuidelines: [],\n        horizontalGuidelines: []\n      });\n    }, R = (B) => {\n      _DesignCast.sys.send2Dbg(\"_changeCast\", {\n        ...B,\n        \":id_tag\": this.id_tag\n      }), _DesignCast.divHint.style.display = \"none\";\n    }, N = () => {\n      const [B, $] = e.aPos;\n      if (isNaN(B)) {\n        _DesignCast.divHint.style.display = \"none\";\n        return;\n      }\n      const k = int(this.rect.x += B / _DesignCast.sys.cvsScale + this.pivot.x), U = int(this.rect.y += $ / _DesignCast.sys.cvsScale + this.pivot.y);\n      this.setPos(k, U);\n      const z = uint(this.rect.width), X = uint(this.rect.height);\n      this.setSize(z, X), R({\n        ...this.cnvPosArg(k, U),\n        ...this.cnvSizeArg(z, X)\n      });\n    };\n    let M;\n    this.mov = new Moveable(document.body, {\n      target: t,\n      draggable: !0,\n      resizable: !0,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: !0\n    }).on(\"dragStart\", (B) => {\n      var k;\n      o(), this.onDragStart();\n      const $ = (k = this.child) == null ? void 0 : k.mov;\n      $ && (M = $.target, $.isInside(B.clientX, B.clientY) && ($.target = void 0));\n    }).on(\"drag\", (B) => {\n      e.aPos = B.beforeTranslate, this.procDragHint(B, B.left, B.top);\n    }).on(\"dragEnd\", () => {\n      var B, $;\n      N(), (B = this.child) != null && B.mov && (this.child.mov.target = M), ($ = this.parent) != null && $.mov && (this.parent.mov.target = this.parent.div);\n    }).on(\"resizeStart\", o).on(\"resize\", (B) => {\n      t.style.width = `${B.width}px`, t.style.height = `${B.height}px`, e.aPos = B.drag.beforeTranslate, this.rect.width = B.width / _DesignCast.sys.cvsScale, this.rect.height = B.height / _DesignCast.sys.cvsScale, this.procResizeHint(B, B.drag.left, B.drag.top);\n    }).on(\"resizeEnd\", N).on(\"rotateStart\", (B) => {\n      o(), B.set(e.roDeg);\n    }).on(\"rotate\", (B) => {\n      e.roDeg = B.beforeRotate, _DesignCast.setHint(int(e.roDeg) + \"\\u5EA6\", B.drag.left, B.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = e.roDeg, this.setOther({}), R({ rotation: int(e.roDeg) });\n    }).on(\"dragOriginStart\", () => o).on(\"dragOrigin\", (B) => {\n      e.trOrg = B.transformOrigin, e.origin = B.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [B, $] = e.origin;\n      e.trOrg = `${B}px ${$}px`;\n      const k = this.pivot.x = B / _DesignCast.sys.cvsScale, U = this.pivot.y = $ / _DesignCast.sys.cvsScale;\n      this.setOther({});\n      const z = int(this.rect.x + k), X = int(this.rect.y + U);\n      this.setPos(z, X), R({\n        ...this.cnvPosArg(z, X),\n        pivot_x: int(k),\n        pivot_y: int(U)\n      });\n    }).on(\"render\", () => {\n      const { aPos: B, roDeg: $, trOrg: k } = e;\n      t.style.transformOrigin = k, t.style.transform = `translate(${B[0]}px, ${B[1]}px) rotate(${$}deg)`;\n    }), __privateGet$2(_DesignCast, _aDC).push(this), t.addEventListener(\"dragenter\", () => t.classList.add(\"drag_border\")), t.addEventListener(\"dragover\", (B) => {\n      B.stopPropagation(), B.preventDefault(), B.dataTransfer && (B.dataTransfer.dropEffect = \"copy\");\n    }), t.addEventListener(\"dragleave\", () => t.classList.remove(\"drag_border\")), t.addEventListener(\"drop\", (B) => {\n      B.stopPropagation(), B.preventDefault(), t.classList.remove(\"drag_border\");\n      const $ = B.dataTransfer;\n      if (!$ || $.files.length === 0)\n        return;\n      const k = $.files[0], U = {\n        \":id_tag\": this.id_tag,\n        fn: getFn(k.name),\n        ext: getExt(k.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: __privateGet$2(_DesignCast, _cfg$1).searchPath(this.oldFn(), Config.EXT_SPRITE)\n      };\n      k.arrayBuffer().then((z) => {\n        U.buf = z;\n        try {\n          U.url = __privateGet$2(_DesignCast, _scrItr).cnvPath4Dbg(\n            __privateGet$2(_DesignCast, _cfg$1).searchPath(k.name, Config.EXT_SPRITE)\n          );\n        } catch {\n        }\n        _DesignCast.sys.send2Dbg(\"_dropFile\", U);\n      }).catch((z) => console.error(\"drop2dc %o\", z));\n    }), t.addEventListener(\"dblclick\", (B) => {\n      B.preventDefault(), _DesignCast.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(n, t, e) {\n    const [o, R] = n.beforeTranslate;\n    _DesignCast.setHint(\n      `(${int(this.rect.x + o / _DesignCast.sys.cvsScale)}, ${int(this.rect.y + R / _DesignCast.sys.cvsScale)})`,\n      t,\n      e,\n      this\n    );\n  }\n  procResizeHint(n, t, e) {\n    _DesignCast.setHint(\n      `(${int(n.drag.left)}, ${int(n.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,\n      t,\n      e,\n      this\n    );\n  }\n  static replaceToken(n) {\n    var B, $, k, U, z, X, V, W, Y, q, Z;\n    const e = n[\":id_tag\"], o = __privateGet$2(_DesignCast, _hId2dc)[e];\n    if (!document.querySelector(`div[data-id_dc='${e}']`) || !o)\n      return;\n    const N = n[\":token\"];\n    __privateGet$2(_DesignCast, _scrItr).replace(n[\":idx_tkn\"], N);\n    const [M, D] = tagToken2Name_Args(N);\n    o.child && (o.child.hArg[\":token\"] = o.hArg[\":token\"]), __privateGet$2(_DesignCast, _alzTagArg).go(D);\n    const L = __privateGet$2(_DesignCast, _alzTagArg).hPrm;\n    if (\"pivot_x\" in L || \"pivot_y\" in L) {\n      const K = Number(_DesignCast.prpPrs.getValAmpersand((B = L.pivot_x.val) != null ? B : \"0\")), Q = Number(_DesignCast.prpPrs.getValAmpersand(($ = L.pivot_y.val) != null ? $ : \"0\"));\n      (isNaN(K) || isNaN(Q)) && DebugMng.myTrace(`pivot_x\\u304Bpivot_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${n[\":path\"].slice(13)} ln:${n[\":ln\"]})\n${N}`, \"F\"), o.pivot.set(K, Q);\n    }\n    if (\"left\" in L || \"top\" in L || \"x\" in L || \"y\" in L) {\n      const K = int(_DesignCast.prpPrs.getValAmpersand((U = (k = L.left.val) != null ? k : L.x.val) != null ? U : \"0\")), Q = int(_DesignCast.prpPrs.getValAmpersand((X = (z = L.top.val) != null ? z : L.y.val) != null ? X : \"0\"));\n      (isNaN(K) || isNaN(Q)) && DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${n[\":path\"].slice(13)} ln:${n[\":ln\"]})\n${N}`, \"F\"), o.rect.x = K - o.pivot.x, o.rect.y = Q - o.pivot.y, o.setPos(K, Q);\n    }\n    if (\"width\" in L || \"height\" in L) {\n      const K = int(_DesignCast.prpPrs.getValAmpersand((V = L.width.val) != null ? V : \"0\")), Q = int(_DesignCast.prpPrs.getValAmpersand((W = L.height.val) != null ? W : \"0\"));\n      (isNaN(K) || isNaN(Q)) && DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${n[\":path\"].slice(13)} ln:${n[\":ln\"]})\n${N}`, \"F\"), o.rect.width = K, o.rect.height = Q, o.setSize(K, Q);\n    }\n    if (\"scale_x\" in L || \"scale_y\" in L) {\n      const K = Number(_DesignCast.prpPrs.getValAmpersand((Y = L.scale_x.val) != null ? Y : \"0\")), Q = Number(_DesignCast.prpPrs.getValAmpersand((q = L.scale_y.val) != null ? q : \"0\"));\n      (isNaN(K) || isNaN(Q)) && DebugMng.myTrace(`scale_x\\u304Bscale_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${n[\":path\"].slice(13)} ln:${n[\":ln\"]})\n${N}`, \"F\"), o.scale.set(K, Q);\n    }\n    if (\"rotation\" in L) {\n      const K = Number(_DesignCast.prpPrs.getValAmpersand((Z = L.rotation.val) != null ? Z : \"0\"));\n      isNaN(K) && DebugMng.myTrace(`rotation\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${n[\":path\"].slice(13)} ln:${n[\":ln\"]})\n${N}`, \"F\"), o.rotation = K;\n    }\n    o.setOther(L), o.cvsResize();\n  }\n};\nlet DesignCast = _DesignCast;\n_divDesignRoot = /* @__PURE__ */ new WeakMap();\n_scrItr = /* @__PURE__ */ new WeakMap();\n_alzTagArg = /* @__PURE__ */ new WeakMap();\n_cfg$1 = /* @__PURE__ */ new WeakMap();\n_ID_DESIGNMODE = /* @__PURE__ */ new WeakMap();\n_cntDesignCast = /* @__PURE__ */ new WeakMap();\n_hId2dc = /* @__PURE__ */ new WeakMap();\n_aDC = /* @__PURE__ */ new WeakMap();\n_resizeDiv = /* @__PURE__ */ new WeakSet();\nresizeDiv_fn = function() {\n  this.fncLay(), this.div && Object.assign(this.div.style, {\n    left: `${this.lx + this.rect.x * _DesignCast.sys.cvsScale}px`,\n    top: `${this.ly + this.rect.y * _DesignCast.sys.cvsScale}px`,\n    width: `${this.rect.width * _DesignCast.sys.cvsScale}px`,\n    height: `${this.rect.height * _DesignCast.sys.cvsScale}px`,\n    transformOrigin: `${this.pivot.x * _DesignCast.sys.cvsScale}px ${this.pivot.y * _DesignCast.sys.cvsScale}px`,\n    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n  });\n};\n__privateAdd$2(DesignCast, _divDesignRoot, void 0);\n__privateAdd$2(DesignCast, _scrItr, void 0);\n__privateAdd$2(DesignCast, _alzTagArg, void 0);\n__privateAdd$2(DesignCast, _cfg$1, void 0);\nDesignCast.divHint = document.createElement(\"div\");\n__privateAdd$2(DesignCast, _ID_DESIGNMODE, \"DesignMode\");\n__privateAdd$2(DesignCast, _cntDesignCast, 0);\n__privateAdd$2(DesignCast, _hId2dc, {});\n__privateAdd$2(DesignCast, _aDC, []);\nvar mi;\nclass GrpLayDesignCast extends DesignCast {\n  constructor(e, o) {\n    super(\"#29e\", !0);\n    it(this, mi, void 0);\n    this.spLay = e, this.gl = o, this.oldFn = () => {\n      var R;\n      return (R = this.hArg.fn) != null ? R : \"\";\n    };\n  }\n  setSp(e) {\n    et(this, mi, e);\n  }\n  getRect() {\n    var e, o, R, N;\n    return new Rectangle(this.spLay.x, this.spLay.y, (o = (e = H(this, mi)) == null ? void 0 : e.width) != null ? o : 0, (N = (R = H(this, mi)) == null ? void 0 : R.height) != null ? N : 0);\n  }\n  cnvPosArg(e, o) {\n    return { left: e, top: o };\n  }\n  cnvSizeArg(e, o) {\n    return { width: e, height: o };\n  }\n  setPos(e, o) {\n    this.spLay.x = e, this.spLay.y = o;\n  }\n  setSize(e, o) {\n    H(this, mi).width = e, H(this, mi).height = o;\n  }\n  setOther(e) {\n    var o;\n    if (\"fn\" in e) {\n      const R = DesignCast.prpPrs.getValAmpersand((o = e.fn.val) != null ? o : \"\");\n      this.gl.lay({ fn: R });\n    }\n    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nmi = new WeakMap();\nclass TxtLayDesignCast extends DesignCast {\n  constructor(t, e) {\n    super(\"#29e\", !0), this.spLay = t, this.ts = e, this.hDesignArg = {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0,\n      pl: 0,\n      pr: 0,\n      pt: 0,\n      pb: 0\n    };\n  }\n  getRect() {\n    const t = this.ts.infTL;\n    return new Rectangle(this.spLay.x, this.spLay.y, t.$width, t.$height);\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.spLay.position.set(t, e), this.ts.lay(this.cnvPosArg(t, e));\n  }\n  setSize(t, e) {\n    this.ts.lay(this.cnvSizeArg(t, e));\n  }\n  setOther(t) {\n    var e;\n    (e = this.child) == null || e.setOther(t), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nvar Ha, hh;\nclass TxtLayPadDesignCast extends DesignCast {\n  constructor(e) {\n    super(\"#9e2\");\n    it(this, Ha);\n    this.ts = e, this.rotatable = !1;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(\n      e.pad_left,\n      e.pad_top,\n      e.$width - e.pad_left - e.pad_right,\n      e.$height - e.pad_top - e.pad_bottom\n    );\n  }\n  cnvPosArg(e, o) {\n    return { pl: e, pt: o };\n  }\n  cnvSizeArg(e, o) {\n    const R = this.ts.infTL;\n    return {\n      pr: R.$width - R.pad_left - e,\n      pb: R.$height - R.pad_top - o\n    };\n  }\n  setPos(e, o) {\n    this.ts.lay(this.cnvPosArg(e, o));\n  }\n  setSize(e, o) {\n    this.ts.lay({ ...this.cnvSizeArg(e, o), \":redraw\": !0 });\n  }\n  setOther(e) {\n    var R, N, M, D, L, B, $, k;\n    const o = this.ts.infTL;\n    if ((\"pl\" in e || \"pt\" in e) && (this.setPos(\n      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        (N = (R = e.pl) == null ? void 0 : R.val) != null ? N : `${o.pad_left}`\n      )),\n      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        (D = (M = e.pt) == null ? void 0 : M.val) != null ? D : `${o.pad_top}`\n      ))\n    ), this.cvsResize()), \"pr\" in e || \"pb\" in e) {\n      this.ts.lay({\n        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          (B = (L = e.pr) == null ? void 0 : L.val) != null ? B : `${o.pad_right}`\n        )),\n        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          (k = ($ = e.pb) == null ? void 0 : $.val) != null ? k : `${o.pad_bottom}`\n        ))\n      });\n      const U = this.getRect();\n      this.setSize(\n        this.rect.width = U.width,\n        this.rect.height = U.height\n      ), this.cvsResize();\n    }\n  }\n  procDragHint(e, o, R) {\n    const [N, M] = e.beforeTranslate;\n    at(this, Ha, hh).call(this, o, R, N, M);\n  }\n  procResizeHint(e, o, R) {\n    const [N, M] = e.drag.beforeTranslate;\n    at(this, Ha, hh).call(this, o, R, N, M);\n  }\n}\nHa = new WeakSet(), hh = function(e, o, R, N) {\n  const M = this.rect.x, D = this.rect.y, L = this.rect.width, B = this.rect.height, $ = this.ts.infTL, k = int(M + R / DesignCast.sys.cvsScale), U = int(D + N / DesignCast.sys.cvsScale), z = int($.$width - k - L), X = int($.$height - U - B), V = (W) => \"&nbsp;\".repeat(W);\n  DesignCast.setHint(\n    V(5 + 5 + 1) + `\\u4E0A\\u5E45=${U}<br/>\n\t\t\t\\u5DE6\\u5E45=${k + V(1 + 3 + 5 + 1)}\\u53F3\\u5E45=${z}<br/>` + V(5) + `\\u5185\\u5074 ${int(L)} x ${int(B)}<br/>` + V(5 + 5) + `\\u4E0B\\u5E45=${X}`,\n    e,\n    o,\n    this\n  );\n};\nclass BtnDesignCast extends DesignCast {\n  constructor(t, e) {\n    super(\"#e92\"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x), this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y), this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x), this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y), this.rotation = argChk_Num(e, \"rotation\", this.rotation), this.sethArg(e);\n  }\n  sethArg(t) {\n    var o;\n    super.sethArg(t);\n    const e = (o = this.hArg.layer) != null ? o : \"\";\n    this.fncLay = !this.parent && !this.child && e ? () => {\n      const R = DesignCast.hPages[e].fore;\n      this.lx = R.x * DesignCast.sys.cvsScale, this.ly = R.y * DesignCast.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.btn.x = t, this.btn.y = e;\n  }\n  setOther(t) {\n    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n    const t = this.btn.parent.children.filter((e) => e !== this.btn);\n    Object.assign(this.mov, {\n      verticalGuidelines: t.map((e) => this.lx + e.x * DesignCast.sys.cvsScale),\n      horizontalGuidelines: t.map((e) => this.ly + e.y * DesignCast.sys.cvsScale)\n    });\n  }\n}\nclass TxtBtnDesignCast extends BtnDesignCast {\n  constructor(t, e, o) {\n    super(t, e), this.txt = o, this.oldFn = () => {\n      var R;\n      return (R = this.hArg.b_pic) != null ? R : \"\";\n    }, argChk_Boolean(e, \"design\", !0) || (this.setPos = () => {\n    }, this.setSize = () => {\n    });\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(t, e) {\n    this.txt.width = t, this.txt.height = e;\n  }\n  setOther(t) {\n    var e;\n    if (super.setOther(t), \"b_pic\" in t) {\n      const o = DesignCast.prpPrs.getValAmpersand((e = t.b_pic.val) != null ? e : \"\");\n      this.btn.update_b_pic(o, this.txt);\n    }\n  }\n}\nvar Yr;\nclass PicBtnDesignCast extends BtnDesignCast {\n  constructor(e, o) {\n    super(e, o);\n    it(this, Yr, void 0);\n    this.oldFn = () => {\n      var R;\n      return (R = this.hArg.pic) != null ? R : \"\";\n    };\n  }\n  setSp(e) {\n    et(this, Yr, e);\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, H(this, Yr).width, H(this, Yr).height);\n  }\n  setSize(e, o) {\n    H(this, Yr).width = e, H(this, Yr).height = o;\n  }\n  setOther(e) {\n    var o;\n    if (super.setOther(e), \"pic\" in e) {\n      const R = DesignCast.prpPrs.getValAmpersand((o = e.pic.val) != null ? o : \"\");\n      this.btn.update_pic(R, H(this, Yr));\n    }\n  }\n}\nYr = new WeakMap();\nvar __accessCheck$1 = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet$1 = (n, t, e) => (__accessCheck$1(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd$1 = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet$1 = (n, t, e, o) => (__accessCheck$1(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod$1 = (n, t, e) => (__accessCheck$1(n, t, \"access private method\"), e), _elc, _hFace, _main, _cfg, _appPixi, _sys, _glbVol, _movVol, _evtMng, _idc$1, _csvFn, _sBkFn, _sBkFace, _width, _height, _dec2cache, _sortAFrameName, sortAFrameName_fn, _dec2cache4Cripto, dec2cache4Cripto_fn, _mkSprite, mkSprite_fn, _rtTsy, _spTsy, _fncRender, _hAEncImg, _hEncImgOUrl;\nconst _GrpLayer = class extends Layer {\n  constructor() {\n    super(), __privateAdd$1(this, _idc$1, new GrpLayDesignCast(this.spLay, this)), __privateAdd$1(this, _csvFn, \"\"), __privateAdd$1(this, _sBkFn, \"\"), __privateAdd$1(this, _sBkFace, \"\"), this.lay = (n) => this.laySub(n, (t) => {\n      t && __privateGet$1(_GrpLayer, _main).resume();\n    }), __privateAdd$1(this, _width, 0), __privateAdd$1(this, _height, 0), __privateAdd$1(this, _rtTsy, void 0), __privateAdd$1(this, _spTsy, void 0), __privateAdd$1(this, _fncRender, () => {\n    }), this.record = () => Object.assign(super.record(), {\n      sBkFn: __privateGet$1(this, _sBkFn),\n      sBkFace: __privateGet$1(this, _sBkFace),\n      idc_hArg: __privateGet$1(this, _idc$1).gethArg()\n    }), this.dump = () => super.dump() + `, \"pic\":\"${__privateGet$1(this, _csvFn)}\"`, CmnLib.isDbg && (this.setSp = (n) => __privateGet$1(this, _idc$1).setSp(n), this.cvsResize = () => {\n      super.cvsResize(), __privateGet$1(this, _idc$1).cvsResize();\n    });\n  }\n  static init(n, t, e, o, R) {\n    __privateSet$1(_GrpLayer, _main, n), __privateSet$1(_GrpLayer, _cfg, t), __privateSet$1(_GrpLayer, _appPixi, e), __privateSet$1(_GrpLayer, _sys, o);\n    const N = () => {\n      const M = __privateGet$1(_GrpLayer, _glbVol) * __privateGet$1(_GrpLayer, _movVol);\n      for (const D in _GrpLayer.hFn2VElm)\n        _GrpLayer.hFn2VElm[D].volume = M;\n    };\n    R.setNoticeChgVolume(\n      (M) => {\n        __privateSet$1(_GrpLayer, _glbVol, M), N();\n      },\n      (M) => {\n        __privateSet$1(_GrpLayer, _movVol, M), N();\n      }\n    ), __privateGet$1(_GrpLayer, _sys).crypto && __privateSet$1(_GrpLayer, _dec2cache, __privateMethod$1(_GrpLayer, _dec2cache4Cripto, dec2cache4Cripto_fn));\n  }\n  static setEvtMng(n) {\n    __privateSet$1(_GrpLayer, _evtMng, n);\n  }\n  static destroy() {\n    __privateGet$1(_GrpLayer, _elc).clear(), __privateSet$1(_GrpLayer, _hFace, {}), _GrpLayer.hFn2ResAniSpr = {}, _GrpLayer.hFn2VElm = {};\n  }\n  setSp(n) {\n  }\n  laySub(n, t) {\n    const { fn: e, face: o = \"\" } = n;\n    if (__privateGet$1(this, _idc$1).sethArg(n), !e)\n      return super.lay(n), this.spLay.children.length > 0 && this.setPos(n), __privateSet$1(this, _sBkFn, \"\"), __privateSet$1(this, _csvFn, __privateSet$1(this, _sBkFace, o)), t(!1), !1;\n    const R = \"fn\" in n, N = \"face\" in n;\n    this.clearLay({ filter: \"true\" }), R && __privateSet$1(this, _sBkFn, e), N && __privateSet$1(this, _sBkFace, o), super.lay(n), n.dx = 0, n.dy = 0;\n    const M = _GrpLayer.csv2Sprites(\n      __privateSet$1(this, _csvFn, e + (o ? \",\" + o : \"\")),\n      this.spLay,\n      (D) => {\n        (\"width\" in n || \"height\" in n) && (D.width = argChk_Num(n, \"width\", 0), D.height = argChk_Num(n, \"height\", 0)), __privateSet$1(this, _width, D.width), __privateSet$1(this, _height, D.height), Layer.setXY(D, n, this.spLay, !0), this.setSp(D);\n      },\n      (D) => {\n        Layer.setBlendmode(this.spLay, n), t(D);\n      }\n    );\n    return M || t(!1), M;\n  }\n  get width() {\n    return __privateGet$1(this, _width);\n  }\n  get height() {\n    return __privateGet$1(this, _height);\n  }\n  static csv2Sprites(n, t, e, o = () => {\n  }) {\n    let R = !1;\n    if (n.slice(0, 5) === \"data:\") {\n      const L = () => {\n        const B = Sprite.from(n);\n        t == null || t.addChild(B), e(B), o(R);\n      };\n      return n in TextureCache ? L() : (R = !0, new Loader().add(n, n).load(L)), R;\n    }\n    const N = [], M = new Loader();\n    n.split(\",\").forEach((L, B) => {\n      if (!L)\n        throw \"face\\u5C5E\\u6027\\u306B\\u7A7A\\u8981\\u7D20\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059\";\n      const $ = __privateGet$1(_GrpLayer, _hFace)[L] || {\n        fn: L,\n        dx: 0,\n        dy: 0,\n        blendmode: BLEND_MODES$5.NORMAL\n      }, k = B === 0 ? e : (X) => {\n        X.x = $.dx, X.y = $.dy, X.blendMode = $.blendmode;\n      };\n      if (N.push({ fn: $.fn, fnc: k }), $.fn in _GrpLayer.hFn2ResAniSpr || $.fn in TextureCache || $.fn in Loader.shared.resources)\n        return;\n      R = !0;\n      const U = __privateGet$1(_GrpLayer, _cfg).searchPath($.fn, Config.EXT_SPRITE), z = __privateGet$1(this, _sys).crypto ? { xhrType: U.slice(-5) === \".json\" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};\n      M.add({ ...z, name: $.fn, url: U });\n    });\n    const D = (L) => {\n      var B;\n      for (const $ of N) {\n        const k = __privateMethod$1(B = _GrpLayer, _mkSprite, mkSprite_fn).call(B, $.fn, L);\n        k.name = $.fn, t == null || t.addChild(k), $.fnc(k);\n      }\n      o(R);\n    };\n    return R ? M.use((L, B) => {\n      __privateGet$1(this, _sys).dec(L.extension, L.data).then(($) => {\n        var k;\n        return __privateGet$1(k = _GrpLayer, _dec2cache).call(k, $, L, () => B == null ? void 0 : B());\n      }).catch(($) => __privateGet$1(this, _main).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${L.name} ${$}`, !1));\n    }).load((L, B) => D(B)) : D({}), R;\n  }\n  static wv(n) {\n    const { fn: t } = n;\n    if (!t)\n      throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const e = _GrpLayer.hFn2VElm[t];\n    if (!e || e.loop)\n      return !1;\n    if (e.ended)\n      return delete _GrpLayer.hFn2VElm[t], !1;\n    const o = () => {\n      e.removeEventListener(\"ended\", o), delete _GrpLayer.hFn2VElm[t], __privateGet$1(this, _main).resume();\n    };\n    return e.addEventListener(\"ended\", o, { once: !0, passive: !0 }), __privateGet$1(_GrpLayer, _evtMng).waitEvent(\n      () => {\n        e.pause(), o();\n      },\n      argChk_Boolean(n, \"canskip\", !0),\n      argChk_Boolean(n, \"global\", !1)\n    );\n  }\n  renderStart() {\n    __privateSet$1(this, _rtTsy, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), __privateSet$1(this, _spTsy, new Sprite(__privateGet$1(this, _rtTsy))), __privateGet$1(this, _spTsy).visible = !1, this.spLay.addChildAt(__privateGet$1(this, _spTsy), 0), __privateGet$1(this, _spTsy).position.set(-this.spLay.x, -this.spLay.y);\n    let n = () => {\n      const t = this.spLay.alpha;\n      this.spLay.alpha = 1, this.spLay.children.forEach((e) => e.visible = !0), __privateGet$1(this, _spTsy).visible = !1, __privateGet$1(_GrpLayer, _appPixi).renderer.render(this.spLay, { renderTexture: __privateGet$1(this, _rtTsy) }), this.spLay.alpha = t, this.spLay.children.forEach((e) => e.visible = !1);\n    };\n    if (!this.containMovement) {\n      let t = n;\n      n = () => {\n        n = () => {\n        }, t();\n      };\n    }\n    __privateSet$1(this, _fncRender, () => {\n      n(), __privateGet$1(this, _spTsy).visible = !0;\n    }), __privateGet$1(_GrpLayer, _appPixi).ticker.add(__privateGet$1(this, _fncRender));\n  }\n  renderEnd() {\n    __privateGet$1(_GrpLayer, _appPixi).ticker.remove(__privateGet$1(this, _fncRender)), this.spLay.removeChild(__privateGet$1(this, _spTsy)), this.spLay.children.forEach((n) => n.visible = !0), __privateGet$1(this, _spTsy).destroy(!0);\n  }\n  static loadPic2Img(n, t, e) {\n    const o = __privateGet$1(this, _hEncImgOUrl)[n];\n    if (o) {\n      t.src = o;\n      return;\n    }\n    const R = __privateGet$1(this, _hAEncImg)[n];\n    if (R) {\n      R.push(t);\n      return;\n    }\n    __privateGet$1(this, _hAEncImg)[n] = [t];\n    const N = __privateGet$1(_GrpLayer, _cfg).searchPath(n, Config.EXT_SPRITE), M = new Loader().add({ name: n, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });\n    __privateGet$1(_GrpLayer, _sys).crypto && M.use((D, L) => {\n      __privateGet$1(_GrpLayer, _sys).dec(D.extension, D.data).then((B) => {\n        if (D.extension !== \"bin\") {\n          L == null || L();\n          return;\n        }\n        D.data = B, B instanceof HTMLImageElement && (D.type = LoaderResource.TYPE.IMAGE), L == null || L();\n      }).catch((B) => __privateGet$1(_GrpLayer, _main).errScript(`GrpLayer loadPic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${D.name} ${B}`, !1));\n    }), M.load((D, L) => {\n      for (const B in L) {\n        const $ = __privateGet$1(this, _hEncImgOUrl)[B] = L[B].data.src;\n        __privateGet$1(this, _hAEncImg)[B].forEach((k) => {\n          k.src = $, e && (k.onload = () => e(k));\n        }), delete __privateGet$1(this, _hAEncImg)[B];\n      }\n    });\n  }\n  setPos(n) {\n    Layer.setXY(\n      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],\n      n,\n      this.spLay,\n      !0\n    );\n  }\n  static add_face(n) {\n    const { name: t } = n;\n    if (!t)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (t in __privateGet$1(_GrpLayer, _hFace))\n      throw \"\\u4E00\\u3064\\u306Ename\\uFF08\" + t + \"\\uFF09\\u306B\\u5BFE\\u3057\\u3066\\u540C\\u3058\\u753B\\u50CF\\u3092\\u8907\\u6570\\u5272\\u308A\\u5F53\\u3066\\u3089\\u308C\\u307E\\u305B\\u3093\";\n    const { fn: e = t } = n;\n    return __privateGet$1(_GrpLayer, _hFace)[t] = {\n      fn: e,\n      dx: argChk_Num(n, \"dx\", 0),\n      dy: argChk_Num(n, \"dy\", 0),\n      blendmode: Layer.getBlendmodeNum(n.blendmode || \"\")\n    }, !1;\n  }\n  static clearFace2Name() {\n    __privateSet$1(_GrpLayer, _hFace, {});\n  }\n  get containMovement() {\n    if (__privateGet$1(this, _csvFn) === \"\")\n      return !1;\n    const n = this.spLay.children;\n    return __privateGet$1(this, _csvFn).split(\",\").some(\n      (t, e) => n[e] instanceof AnimatedSprite || _GrpLayer.hFn2VElm[t]\n    );\n  }\n  clearLay(n) {\n    super.clearLay(n);\n    for (const t of this.spLay.removeChildren())\n      t.destroy();\n    __privateSet$1(this, _sBkFn, \"\"), __privateSet$1(this, _sBkFace, \"\"), __privateSet$1(this, _csvFn, \"\");\n  }\n  playback(n, t) {\n    if (super.playback(n, t), n.sBkFn === \"\" && n.sBkFace === \"\") {\n      __privateSet$1(this, _sBkFn, n.sBkFn), __privateSet$1(this, _sBkFace, n.sBkFace), __privateGet$1(this, _idc$1).sethArg(n.idc_hArg);\n      return;\n    }\n    t.push(new Promise((e) => this.laySub(\n      { fn: n.sBkFn, face: n.sBkFace, left: n.x, top: n.y, alpha: n.alpha, blendmode: n.blendMode, rotation: n.rotation, scale_x: n.scale_x, scale_y: n.scale_y },\n      (o) => {\n        this.spLay.position.set(n.x, n.y), e();\n      }\n    )));\n  }\n  makeDesignCast(n) {\n    !this.spLay.visible || n(__privateGet$1(this, _idc$1));\n  }\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    __privateGet$1(this, _idc$1).visible = !0;\n  }\n};\nlet GrpLayer = _GrpLayer;\n_elc = /* @__PURE__ */ new WeakMap();\n_hFace = /* @__PURE__ */ new WeakMap();\n_main = /* @__PURE__ */ new WeakMap();\n_cfg = /* @__PURE__ */ new WeakMap();\n_appPixi = /* @__PURE__ */ new WeakMap();\n_sys = /* @__PURE__ */ new WeakMap();\n_glbVol = /* @__PURE__ */ new WeakMap();\n_movVol = /* @__PURE__ */ new WeakMap();\n_evtMng = /* @__PURE__ */ new WeakMap();\n_idc$1 = /* @__PURE__ */ new WeakMap();\n_csvFn = /* @__PURE__ */ new WeakMap();\n_sBkFn = /* @__PURE__ */ new WeakMap();\n_sBkFace = /* @__PURE__ */ new WeakMap();\n_width = /* @__PURE__ */ new WeakMap();\n_height = /* @__PURE__ */ new WeakMap();\n_dec2cache = /* @__PURE__ */ new WeakMap();\n_sortAFrameName = /* @__PURE__ */ new WeakSet();\nsortAFrameName_fn = function(n) {\n  const t = /([^\\d]+)\\d+\\.(\\w+)/.exec(n[0]);\n  if (!t)\n    return;\n  const e = t[1].length, o = -t[2].length - 1;\n  n.sort(\n    (R, N) => int(R.slice(e, o)) > int(N.slice(e, o)) ? 1 : -1\n  );\n};\n_dec2cache4Cripto = /* @__PURE__ */ new WeakSet();\ndec2cache4Cripto_fn = function(n, t, e) {\n  var M;\n  if (t.data = n, t.extension === \"bin\" && (n instanceof HTMLImageElement ? (t.texture = Texture.fromLoader(n, t.url, t.name), t.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(n.src)) : n instanceof HTMLVideoElement && (n.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = n, t.type = LoaderResource.TYPE.VIDEO, URL.revokeObjectURL(n.src))), t.extension !== \"json\") {\n    e();\n    return;\n  }\n  if (typeof n != \"string\") {\n    e();\n    return;\n  }\n  const o = t.data = JSON.parse(n);\n  if (t.type = LoaderResource.TYPE.JSON, !((M = o.meta) != null && M.image)) {\n    e();\n    return;\n  }\n  const R = getFn(o.meta.image), N = __privateGet$1(_GrpLayer, _cfg).searchPath(R, Config.EXT_SPRITE);\n  new Loader().use((D, L) => {\n    __privateGet$1(this, _sys).dec(D.extension, D.data).then((B) => {\n      D.data = B, B instanceof HTMLImageElement && (D.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(B.src)), L == null || L();\n    }).catch((B) => __privateGet$1(this, _main).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 dec2res4Cripto fn:${D.name} ${B}`, !1));\n  }).add({ name: R, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((D, L) => {\n    var B;\n    for (const $ in D.resources) {\n      const k = Texture.from(D.resources[$].data).baseTexture, U = Object.values(o.frames);\n      __privateMethod$1(B = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(B, U), _GrpLayer.hFn2ResAniSpr[t.name] = {\n        aTex: U.map((z) => new Texture(\n          k,\n          new Rectangle(\n            z.frame.x,\n            z.frame.y,\n            z.frame.w,\n            z.frame.h\n          )\n        )),\n        meta: o.meta\n      };\n    }\n    e();\n  });\n};\n_mkSprite = /* @__PURE__ */ new WeakSet();\nmkSprite_fn = function(n, t) {\n  var o;\n  const e = _GrpLayer.hFn2ResAniSpr[n];\n  if (e) {\n    const R = new AnimatedSprite(e.aTex);\n    return R.animationSpeed = (o = e.meta.animationSpeed) != null ? o : 1, R.play(), R;\n  }\n  return n in TextureCache ? Sprite.from(n) : n in _GrpLayer.hFn2VElm ? Sprite.from(_GrpLayer.hFn2VElm[n]) : n in t ? new Sprite(t[n].texture) : new Sprite();\n};\n_rtTsy = /* @__PURE__ */ new WeakMap();\n_spTsy = /* @__PURE__ */ new WeakMap();\n_fncRender = /* @__PURE__ */ new WeakMap();\n_hAEncImg = /* @__PURE__ */ new WeakMap();\n_hEncImgOUrl = /* @__PURE__ */ new WeakMap();\n__privateAdd$1(GrpLayer, _sortAFrameName);\n__privateAdd$1(GrpLayer, _dec2cache4Cripto);\n__privateAdd$1(GrpLayer, _mkSprite);\n__privateAdd$1(GrpLayer, _elc, new EventListenerCtn());\n__privateAdd$1(GrpLayer, _hFace, {});\n__privateAdd$1(GrpLayer, _main, void 0);\n__privateAdd$1(GrpLayer, _cfg, void 0);\n__privateAdd$1(GrpLayer, _appPixi, void 0);\n__privateAdd$1(GrpLayer, _sys, void 0);\n__privateAdd$1(GrpLayer, _glbVol, 1);\n__privateAdd$1(GrpLayer, _movVol, 1);\n__privateAdd$1(GrpLayer, _evtMng, void 0);\nGrpLayer.hFn2ResAniSpr = {};\n__privateAdd$1(GrpLayer, _dec2cache, (n, t, e) => {\n  var o;\n  switch (t.type) {\n    case LoaderResource.TYPE.JSON:\n      const R = t.spritesheet._frameKeys;\n      __privateMethod$1(o = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(o, R), _GrpLayer.hFn2ResAniSpr[t.name] = {\n        aTex: R.map((M) => Texture.from(M)),\n        meta: t.data.meta\n      };\n      break;\n    case LoaderResource.TYPE.VIDEO:\n      const N = t.data;\n      N.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = N;\n  }\n  e();\n});\nGrpLayer.hFn2VElm = {};\n__privateAdd$1(GrpLayer, _hAEncImg, {});\n__privateAdd$1(GrpLayer, _hEncImgOUrl, {});\nvar ls, za, hs, ne, Ar, qr, tr, yi, Ht, Zr, _r, mr, cs, Yo, yr, Or, ja, fs, Va, Nu, lc, rn, ds, nn, sn, an, un, ps, Mu, Kr, Xa, ch, vs, Jr, Wa, Qr, Nr, Ya, qa, fh, bi, ln, Za, dh, lr;\nconst Xt = class extends Container {\n  constructor(e, o, R) {\n    super();\n    it(this, cs);\n    it(this, Nu);\n    it(this, Xa);\n    it(this, qa);\n    it(this, Za);\n    it(this, ne, document.createElement(\"span\"));\n    it(this, Ar, new Container());\n    it(this, qr, new Graphics());\n    it(this, tr, new TxtLayDesignCast(this.spLay, this));\n    it(this, yi, new TxtLayPadDesignCast(this));\n    it(this, Ht, {\n      fontsize: 24,\n      $width: 0,\n      $height: 0,\n      pad_left: 0,\n      pad_right: 0,\n      pad_top: 0,\n      pad_bottom: 0\n    });\n    it(this, Zr, !1);\n    it(this, _r, 0);\n    it(this, mr, 0);\n    it(this, yr, 0);\n    it(this, Or, !1);\n    it(this, ja, 0);\n    it(this, fs, 0);\n    it(this, rn, void 0);\n    it(this, ds, []);\n    it(this, nn, []);\n    it(this, sn, 0);\n    it(this, Mu, /animation\\-duration: (?<ms>\\d+)ms;/);\n    it(this, Kr, () => {\n    });\n    it(this, vs, !1);\n    it(this, Ya, 0);\n    it(this, bi, \"Quadratic.Out\");\n    it(this, ln, \"Quadratic.Out\");\n    it(this, lr, void 0);\n    this.spLay = e, this.canFocus = o, this.sys = R, H(this, ne).classList.add(\"sn_tx\"), H(this, ne).style.position = \"absolute\", H(Xt, za).view.parentElement.appendChild(H(this, ne)), this.addChild(H(this, Ar)), this.addChild(H(this, qr)), H(this, qr).name = \"grpDbgMasume\", H(this, tr).adopt(H(this, yi));\n  }\n  static init(e, o) {\n    et(Xt, ls, e), et(Xt, za, o), et(Xt, an, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), et(Xt, un, /[［（｛〈「『【〔“〝]/), et(Xt, ps, /[─‥…]/);\n  }\n  static setEvtMng(e) {\n    et(Xt, hs, e);\n  }\n  static destroy() {\n    et(Xt, Va, {\n      backgroundColor: 0,\n      borderBottomWidth: 0,\n      borderLeftWidth: 0,\n      borderRightWidth: 0,\n      borderTopWidth: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0,\n      marginTop: 0\n    }), et(Xt, Jr, /* @__PURE__ */ Object.create(null)), et(Xt, Qr, /* @__PURE__ */ Object.create(null)), et(Xt, Nr, new Container());\n  }\n  lay(e) {\n    var R, N, M, D, L, B, $, k;\n    const o = H(this, ne).style;\n    if (e.style) {\n      const U = document.createElement(\"span\");\n      U.style.cssText = e.style;\n      const z = U.style.length;\n      for (let X = 0; X < z; ++X) {\n        const V = U.style[X];\n        if (V in H(Xt, Va)) {\n          DebugMng.myTrace(`${V}\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093`, \"W\");\n          continue;\n        }\n        o[V] = U.style[V];\n      }\n      !U.style.opacity && \"alpha\" in e && (o.opacity = String(this.spLay.alpha));\n    } else\n      \"alpha\" in e && (o.opacity = String(this.spLay.alpha));\n    if (\"width\" in e && (o.width = ((R = e.width) != null ? R : \"0\") + \"px\"), \"height\" in e && (o.height = ((N = e.height) != null ? N : \"0\") + \"px\"), \"pl\" in e && (o.paddingLeft = ((M = e.pl) != null ? M : \"0\") + \"px\"), \"pr\" in e && (o.paddingRight = ((D = e.pr) != null ? D : \"0\") + \"px\"), \"pt\" in e && (o.paddingTop = ((L = e.pt) != null ? L : \"0\") + \"px\"), \"pb\" in e && (o.paddingBottom = ((B = e.pb) != null ? B : \"0\") + \"px\"), \"kinsoku_sol\" in e && et(Xt, an, new RegExp(`[${e.kinsoku_sol}]`)), \"kinsoku_eol\" in e && et(Xt, un, new RegExp(`[${e.kinsoku_eol}]`)), \"kinsoku_dns\" in e && et(Xt, ps, new RegExp(`[${e.kinsoku_dns}]`)), at(this, cs, Yo).call(this), H(this, tr).sethArg(e), et(this, yr, this.spLay.position.x), o.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), o.display = this.spLay.visible ? \"inline\" : \"none\", o.textShadow = (k = ($ = e.filter) != null ? $ : o.textShadow) != null ? k : \"\", et(this, Zr, argChk_Boolean(e, \"break_fixed\", H(this, Zr))), et(this, _r, argChk_Num(e, \"break_fixed_left\", H(this, _r))), et(this, mr, argChk_Num(e, \"break_fixed_top\", H(this, mr))), \":redraw\" in e && H(this, sn) > 0) {\n      const U = [\n        H(this, ne).innerHTML.replace(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>\\u3000</span>`\n      ];\n      at(this, Za, dh).call(this), this.goTxt(U);\n    }\n  }\n  cvsResize() {\n    const e = H(this, ne).style;\n    e.left = `${this.sys.ofsLeft4elm + H(this, yr) * this.sys.cvsScale}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * this.sys.cvsScale}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * this.sys.cvsScale}, ${this.spLay.scale.y * this.sys.cvsScale})`, H(this, tr).cvsResize(), H(this, yi).cvsResize();\n  }\n  get tategaki() {\n    return H(this, Or);\n  }\n  get infTL() {\n    return H(this, Ht);\n  }\n  get getWidth() {\n    return H(this, Ht).$width;\n  }\n  get getHeight() {\n    return H(this, Ht).$height;\n  }\n  setSize(e, o) {\n    H(this, Ht).$width = e, H(this, Ht).$height = o, H(this, ne).style.width = H(this, Ht).$width + \"px\", H(this, ne).style.height = H(this, Ht).$height + \"px\";\n  }\n  goTxt(e) {\n    var W, Y, q, Z, K, Q;\n    H(Xt, Nr).visible = !1;\n    const o = H(this, nn).length;\n    o === 0 ? (H(Xt, ls).oCfg.debug.masume && (CmnLib.debugLog && console.log(`\\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${H(this, Ht).pad_left} pr:${H(this, Ht).pad_right} pt:${H(this, Ht).pad_top} pb:${H(this, Ht).pad_bottom} w:${H(this, Ht).$width} h:${H(this, Ht).$height}`), H(this, qr).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-H(this, Ht).pad_left, -H(this, Ht).pad_top, H(this, Ht).$width, H(this, Ht).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(\n      0,\n      0,\n      H(this, Ht).$width - H(this, Ht).pad_left - H(this, Ht).pad_right,\n      H(this, Ht).$height - H(this, Ht).pad_top - H(this, Ht).pad_bottom\n    ).endFill()), H(this, ne).innerHTML = [...e].join(\"\").replaceAll(/[\\n\\t]/g, \"\")) : H(this, ne).insertAdjacentHTML(\"beforeend\", e.slice(H(this, sn)).join(\"\").replaceAll(/[\\n\\t]/g, \"\")), et(this, sn, e.length);\n    let R = 0, N = 2;\n    do {\n      const J = et(this, nn, at(this, qa, fh).call(this, H(this, ne)));\n      if (R = J.length, this.sys.cvsScale !== 1) {\n        const tt = this.sys.ofsPadLeft_Dom2PIXI + parseFloat(H(this, ne).style.left) * (1 - this.sys.cvsScale), nt = this.sys.ofsPadTop_Dom2PIXI + parseFloat(H(this, ne).style.top) * (1 - this.sys.cvsScale);\n        for (let st = 0; st < R; ++st) {\n          const ut = J[st].rect;\n          ut.x -= tt, ut.y -= nt, ut.x /= this.sys.cvsScale, ut.y /= this.sys.cvsScale, ut.width /= this.sys.cvsScale, ut.height /= this.sys.cvsScale;\n        }\n      }\n      if (R < 2)\n        break;\n      let rt = -1 / 0;\n      for (; N < R; ++N) {\n        const tt = J[N];\n        if (tt.elm.outerHTML.slice(0, 3) === \"<rt\")\n          continue;\n        const nt = this.tategaki ? tt.rect.y : tt.rect.x;\n        if (rt <= nt) {\n          rt = nt;\n          continue;\n        }\n        rt = -1 / 0;\n        const st = N;\n        if (H(Xt, ps).test(J[N - 1].ch) && J[N - 1].ch === tt.ch)\n          --N;\n        else {\n          if (H(Xt, un).test(J[N - 1].ch))\n            --N;\n          else if (H(Xt, an).test(tt.ch))\n            for (; N > 0 && H(Xt, an).test(J[--N].ch); )\n              ;\n          else\n            continue;\n          for (; N > 0 && H(Xt, un).test(J[N - 1].ch); )\n            --N;\n        }\n        const ut = J[N].elm.parentElement, ct = document.createElement(\"br\");\n        if (ut.classList.contains(\"sn_tx\"))\n          ut.insertBefore(ct, J[N].elm);\n        else {\n          const dt = ut.parentElement;\n          dt.classList.contains(\"sn_ch\") ? dt.parentElement.insertBefore(ct, dt) : dt.insertBefore(ct, ut);\n        }\n        N += 2, N < st && (N = st), R = -1;\n        break;\n      }\n    } while (R < 0);\n    const M = CmnLib.debugLog ? (J, rt) => console.log(`\\u{1F34C} masume ch:${J.ch} x:${rt.x} y:${rt.y} w:${rt.width} h:${rt.height}`) : () => {\n    }, D = H(Xt, ls).oCfg.debug.masume ? (J, rt) => {\n      M(J, rt), H(this, qr).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(rt.x, rt.y, rt.width, rt.height).endFill();\n    } : () => {\n    }, L = CmnTween.ease(H(this, bi)), B = H(this, ne).getBoundingClientRect(), $ = B.left + globalThis.scrollX + H(this, Ht).pad_left, k = B.top + globalThis.scrollY + H(this, Ht).pad_top;\n    let U = new Rectangle();\n    for (let J = o; J < R; ++J) {\n      const rt = H(this, nn)[J], tt = rt.rect, nt = JSON.parse((W = rt.arg) != null ? W : '{\"delay\": 0}'), st = JSON.parse((Y = rt.add) != null ? Y : \"{}\"), ut = H(Xt, Jr)[st.ch_in_style];\n      if (tt.x -= $, tt.y -= k, D(rt, tt), ut && (H(this, Or) ? (tt.x += (tt.width - tt.height) / 2, tt.width = tt.height) : (tt.y += (tt.height - tt.width) / 2, tt.height = tt.width), U = tt), rt.cmd === \"grp\") {\n        const ct = new Container();\n        H(this, Ar).addChild(ct), GrpLayer.csv2Sprites(nt.pic, ct, (dt) => {\n          at(this, Xa, ch).call(this, ct, nt, st, tt, L, ut != null ? ut : {}), ct.parent || ct.removeChild(dt);\n        });\n      }\n      if (rt.lnk) {\n        const ct = rt.elm.parentElement.closest(\"[data-arg]\"), dt = JSON.parse((q = ct.dataset.arg) != null ? q : \"{}\");\n        dt.key = `lnk=[${J}] ` + this.name;\n        const Et = new Sprite();\n        at(this, Xa, ch).call(this, Et, dt, st, tt, L, ut != null ? ut : {});\n        const vt = (Z = dt.style) != null ? Z : \"\", _t = vt + ((K = dt.style_hover) != null ? K : \"\"), St = vt + ((Q = dt.style_clicked) != null ? Q : \"\"), Ft = ct.style.cssText, mt = (pt) => {\n          !pt || (ct.style.cssText = Ft + pt);\n        };\n        ct.querySelectorAll(\".sn_ch\").forEach((pt) => pt.dataset.st_bk = pt.style.cssText), H(Xt, hs).button(\n          dt,\n          Et,\n          () => mt(vt),\n          () => this.canFocus() ? (mt(_t), !0) : !1,\n          () => mt(St)\n        ), H(this, Ar).addChild(Et);\n      }\n    }\n    const z = H(this, ne).querySelectorAll(\"span.sn_ch\");\n    z.forEach((J) => J.className = J.className.replace(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\")), et(this, vs, !0), et(this, Kr, () => {\n      et(this, vs, !1), z.forEach((J) => J.className = J.className.replace(/ go_ch_in_[^\\s\"]+/g, \"\")), o !== R && (et(this, _r, U.x + (H(this, Or) ? 0 : U.width)), et(this, mr, U.y + (H(this, Or) ? U.height : 0))), H(Xt, Nr).position.set(\n        H(this, _r),\n        H(this, mr)\n      ), H(Xt, Nr).visible = !0, et(this, Kr, () => {\n      });\n    });\n    const X = z.length;\n    if (X === 0) {\n      H(this, Kr).call(this);\n      return;\n    }\n    let V;\n    for (let J = X - 1; J >= 0; --J) {\n      const rt = z[J];\n      if (rt.className === \"sn_ch\")\n        break;\n      const tt = rt.getAttribute(\"style\");\n      if (!tt) {\n        V = rt;\n        break;\n      }\n      const nt = tt.match(H(this, Mu)), st = nt == null ? void 0 : nt.groups;\n      if (!st || Number(st.ms) > 0) {\n        V = rt;\n        break;\n      }\n    }\n    if (!V) {\n      H(this, Kr).call(this);\n      return;\n    }\n    V.addEventListener(\"animationend\", H(this, Kr), { once: !0, passive: !0 });\n  }\n  skipChIn() {\n    let e = H(this, vs);\n    return H(this, Kr).call(this), H(this, ds).forEach((o) => {\n      o.tw && (o.tw.stop().end(), e = !0);\n    }), et(this, ds, []), e;\n  }\n  static initChStyle() {\n    et(Xt, Jr, /* @__PURE__ */ Object.create(null)), et(Xt, Qr, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(e) {\n    return H(Xt, Jr)[e];\n  }\n  static ch_in_style(e) {\n    var M, D, L;\n    const { name: o } = e;\n    if (!o)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (H(Xt, Wa).test(o))\n      throw `name\\u3010${o}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (o in H(Xt, Jr))\n      throw `name\\u3010${o}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const R = String((M = e.x) != null ? M : \"=0\"), N = String((D = e.y) != null ? D : \"=0\");\n    return H(Xt, Jr)[o] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: R,\n      y: N,\n      nx: parseFloat(R.charAt(0) === \"=\" ? R.slice(1) : R),\n      ny: parseFloat(N.charAt(0) === \"=\" ? N.slice(1) : N),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !0),\n      ease: (L = e.ease) != null ? L : \"ease-out\"\n    };\n  }\n  static getChOutStyle(e) {\n    return H(Xt, Qr)[e];\n  }\n  static ch_out_style(e) {\n    var M, D, L;\n    const { name: o } = e;\n    if (!o)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (H(Xt, Wa).test(o))\n      throw `name\\u3010${o}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (o in H(Xt, Qr))\n      throw `name\\u3010${o}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const R = String((M = e.x) != null ? M : \"=0\"), N = String((D = e.y) != null ? D : \"=0\");\n    return H(Xt, Qr)[o] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: R,\n      y: N,\n      nx: parseFloat(R.charAt(0) === \"=\" ? R.slice(1) : R),\n      ny: parseFloat(N.charAt(0) === \"=\" ? N.slice(1) : N),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !1),\n      ease: (L = e.ease) != null ? L : \"ease-out\"\n    };\n  }\n  dispBreak(e) {\n    const o = H(Xt, Nr);\n    o.visible = !1, this.addChild(o), GrpLayer.csv2Sprites(e, o, (R) => {\n      o.parent || o.removeChild(R);\n    });\n  }\n  static delBreak() {\n    const e = H(Xt, Nr);\n    e.parent && (e.parent.removeChild(e), e.removeChildren()), et(Xt, Nr, new Container());\n  }\n  reNew() {\n    var o;\n    at(this, Za, dh).call(this);\n    const e = new Xt(this.spLay, () => this.canFocus(), this.sys);\n    return et(e, Ht, H(this, Ht)), H(e, ne).style.cssText = H(this, ne).style.cssText, et(e, yr, H(this, yr)), e.name = this.name, at(o = e, cs, Yo).call(o), H(e, tr).sethArg(H(this, tr).gethArg()), et(e, rn, H(this, rn)), et(e, bi, H(this, bi)), et(e, ln, H(this, ln)), et(e, Zr, H(this, Zr)), et(e, _r, H(this, _r)), et(e, mr, H(this, mr)), this.destroy(), e;\n  }\n  record() {\n    return {\n      infTL: H(this, Ht),\n      cssText: H(this, ne).style.cssText,\n      left: H(this, yr),\n      idc_hArg: H(this, tr).gethArg(),\n      ch_filter: H(this, rn),\n      fi_easing: H(this, bi),\n      fo_easing: H(this, ln),\n      break_fixed: H(this, Zr),\n      break_fixed_left: H(this, _r),\n      break_fixed_top: H(this, mr)\n    };\n  }\n  playback(e) {\n    var o, R, N;\n    et(this, Ht, e.infTL), this.position.set(H(this, Ht).pad_left, H(this, Ht).pad_top), H(this, ne).style.cssText = e.cssText, et(this, yr, e.left), at(this, cs, Yo).call(this), H(this, tr).sethArg(e.idc_hArg), et(this, rn, e.ch_filter), et(this, bi, e.fi_easing), et(this, ln, e.fo_easing), et(this, Zr, (o = e.break_fixed) != null ? o : !1), et(this, _r, (R = e.break_fixed_left) != null ? R : 0), et(this, mr, (N = e.break_fixed_top) != null ? N : 0);\n  }\n  snapshot(e, o) {\n    at(this, Nu, lc).call(this, (R) => {\n      et(this, lr, new Sprite(R)), H(this, Or) && (H(this, lr).x += CmnLib.stageW - (H(this, yr) + H(this, Ht).$width)), H(this, lr).y -= H(this, fs), H(this, lr).texture.frame = new Rectangle(0, 0, H(this, Ht).$width - H(this, yr), H(this, Ht).$height), H(this, Ar).addChild(H(this, lr)), e.render(H(this, lr), void 0, !1), o();\n    }, !1);\n  }\n  snapshot_end() {\n    H(this, lr) && (H(this, Ar).removeChild(H(this, lr)), et(this, lr, void 0));\n  }\n  makeDesignCast(e) {\n    e(H(this, tr));\n    const o = H(this, tr).gethArg();\n    H(this, yi).sethArg({ ...o, \":id_dc\": o[\":id_tag\"] + \"_pad\" }), e(H(this, yi));\n  }\n  showDesignCast() {\n    H(this, tr).visible = !0, H(this, yi).visible = !0;\n  }\n  dump() {\n    const e = [], o = H(this, ne).style, R = o.length;\n    for (let N = 0; N < R; ++N) {\n      const M = o[N];\n      e.push(`\"${M}\":\"${o[M].replace(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${H(this, ne).textContent.replace(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${e.join(\",\")}}`;\n  }\n  destroy() {\n    Xt.delBreak(), H(this, ne).parentElement.removeChild(H(this, ne)), this.removeChild(H(this, Ar)), this.removeChild(H(this, qr)), super.destroy();\n  }\n};\nlet TxtStage = Xt;\nls = new WeakMap(), za = new WeakMap(), hs = new WeakMap(), ne = new WeakMap(), Ar = new WeakMap(), qr = new WeakMap(), tr = new WeakMap(), yi = new WeakMap(), Ht = new WeakMap(), Zr = new WeakMap(), _r = new WeakMap(), mr = new WeakMap(), cs = new WeakSet(), Yo = function() {\n  var N;\n  const e = H(this, ne).style, o = parseFloat(e.fontSize || \"0\");\n  H(this, Ht).fontsize = o, H(this, Ht).pad_left = parseFloat(e.paddingLeft || \"0\"), H(this, Ht).pad_right = parseFloat(e.paddingRight || \"0\"), H(this, Ht).pad_top = parseFloat(e.paddingTop || \"0\"), H(this, Ht).pad_bottom = parseFloat(e.paddingBottom || \"0\"), H(this, Ht).$width = parseFloat(e.width || \"0\"), H(this, Ht).$height = parseFloat(e.height || \"0\"), this.position.set(H(this, Ht).pad_left, H(this, Ht).pad_top), et(this, Or, e.writingMode === \"vertical-rl\"), et(this, ja, 0), et(this, fs, 0);\n  const R = (N = e.lineHeight) != null ? N : \"0\";\n  et(this, Ya, H(this, Or) ? 0 : (R.slice(-2) === \"px\" ? parseFloat(R) : o * parseFloat(R) - o) / 2);\n}, yr = new WeakMap(), Or = new WeakMap(), ja = new WeakMap(), fs = new WeakMap(), Va = new WeakMap(), Nu = new WeakSet(), lc = function(e, o = !0) {\n  const R = {\n    escape: (W) => W.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (W) => {\n      const Y = B(W).toLowerCase();\n      return N()[Y] || \"\";\n    },\n    dataAsUrl: z,\n    isDataUrl: $,\n    resolveUrl: k,\n    getAndEncode: U,\n    asArray: (W) => {\n      const Y = [], q = W.length;\n      for (let Z = 0; Z < q; ++Z)\n        Y.push(W[Z]);\n      return Y;\n    }\n  };\n  function N() {\n    const W = \"application/font-woff\", Y = \"image/jpeg\";\n    return {\n      woff: W,\n      woff2: W,\n      ttf: \"application/font-truetype\",\n      eot: \"application/vnd.ms-fontobject\",\n      png: \"image/png\",\n      jpg: Y,\n      jpeg: Y,\n      gif: \"image/gif\",\n      tiff: \"image/tiff\",\n      svg: \"image/svg+xml\"\n    };\n  }\n  const M = X(), D = V();\n  function L(W) {\n    return D.resolveAll().then((Y) => {\n      const q = document.createElement(\"style\");\n      return W.appendChild(q), q.appendChild(document.createTextNode(Y)), W;\n    });\n  }\n  function B(W) {\n    var q;\n    const Y = /\\.([^\\.\\/]*?)$/g.exec(W);\n    return (q = Y == null ? void 0 : Y[1]) != null ? q : \"\";\n  }\n  function $(W) {\n    return W.search(/^(data:)/) !== -1;\n  }\n  function k(W, Y) {\n    const q = document.implementation.createHTMLDocument(), Z = q.createElement(\"base\");\n    q.head.appendChild(Z);\n    const K = q.createElement(\"a\");\n    return q.body.appendChild(K), Z.href = Y, K.href = W, K.href;\n  }\n  function U(W) {\n    let Y = 3e4;\n    return new Promise(function(q) {\n      const Z = new XMLHttpRequest();\n      Z.onreadystatechange = K, Z.ontimeout = Q, Z.responseType = \"blob\", Z.timeout = Y, Z.open(\"GET\", W, !0), Z.send();\n      function K() {\n        if (Z.readyState !== 4)\n          return;\n        if (Z.status !== 200) {\n          J(\"cannot fetch resource: \" + W + \", status: \" + Z.status);\n          return;\n        }\n        const rt = new FileReader();\n        rt.onloadend = function() {\n          const tt = rt.result.toString().split(/,/)[1];\n          q(tt);\n        }, rt.readAsDataURL(Z.response);\n      }\n      function Q() {\n        J(\"timeout of \" + Y + \"ms occured while fetching resource: \" + W);\n      }\n      function J(rt) {\n        console.error(rt), q(\"\");\n      }\n    });\n  }\n  function z(W, Y) {\n    return \"data:\" + Y + \";base64,\" + W;\n  }\n  function X() {\n    const W = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll: K,\n      shouldProcess: Y\n    };\n    function Y(Q) {\n      return Q.search(W) !== -1;\n    }\n    function q(Q) {\n      const J = [];\n      let rt;\n      for (; rt = W.exec(Q); )\n        J.push(rt[1]);\n      return J.filter(function(tt) {\n        return !R.isDataUrl(tt);\n      });\n    }\n    function Z(Q, J, rt, tt) {\n      return Promise.resolve(J).then((st) => rt ? R.resolveUrl(st, rt) : st).then(tt || R.getAndEncode).then((st) => R.dataAsUrl(st, R.mimeType(J))).then((st) => Q.replace(nt(J), \"$1\" + st + \"$3\"));\n      function nt(st) {\n        return new RegExp(`(url\\\\(['\"]?)(` + R.escape(st) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function K(Q, J, rt) {\n      if (tt())\n        return Promise.resolve(Q);\n      return Promise.resolve(Q).then(q).then((nt) => {\n        let st = Promise.resolve(Q);\n        for (const ut of nt)\n          st = st.then((ct) => Z(ct, ut, J, rt));\n        return st;\n      });\n      function tt() {\n        return !Y(Q);\n      }\n    }\n  }\n  function V() {\n    return {\n      resolveAll: W,\n      impl: { readAll: Y }\n    };\n    function W() {\n      return Y().then((q) => Promise.allSettled(\n        q.map((Z) => Z.resolve())\n      )).then((q) => q.join(`\n`));\n    }\n    function Y() {\n      return Promise.resolve(R.asArray(document.styleSheets)).then(Z).then(q).then((Q) => Q.map(K));\n      function q(Q) {\n        return Q.filter((J) => J.type === CSSRule.FONT_FACE_RULE).filter((J) => M.shouldProcess(J.style.getPropertyValue(\"src\")));\n      }\n      function Z(Q) {\n        const J = [];\n        for (const rt of Q)\n          try {\n            if (rt.href)\n              continue;\n            R.asArray(rt.cssRules || []).forEach(J.push.bind(J));\n          } catch (tt) {\n            console.error(\"Error while reading CSS rules from \" + rt.href, tt.toString());\n          }\n        return J;\n      }\n      function K(Q) {\n        return {\n          resolve: function() {\n            const rt = (Q.parentStyleSheet || {}).href;\n            return M.inlineAll(Q.cssText, rt);\n          },\n          src: function() {\n            return Q.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(H(this, ne)).then((W) => {\n    const Y = W.cloneNode(!0);\n    return Y.style.padding = \"0px\", Y.style.paddingRight = H(this, ja) + \"px\", Y.style.paddingTop = H(this, fs) + \"px\", Y.style.left = \"0px\", Y.style.top = \"0px\", Y.style.width = H(this, Ht).$width - H(this, Ht).pad_left - H(this, Ht).pad_right + \"px\", Y.style.height = H(this, Ht).$height - H(this, Ht).pad_top - H(this, Ht).pad_bottom + \"px\", H(this, ne).hidden = o, Y;\n  }).then(L).then((W) => {\n    W.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const Y = new Image();\n    return Y.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${H(this, Ht).$width}px\" height=\"${H(this, Ht).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(W).replaceAll(\"#\", \"%23\").replaceAll(`\n`, \"%0A\")}</foreignObject></svg>`, new Promise((q) => Y.onload = () => q(Y));\n  }).then((W) => new Promise((Y) => setTimeout(() => Y(W), 100))).then((W) => {\n    const Y = document.createElement(\"canvas\");\n    Y.width = H(this, Ht).$width, Y.height = H(this, Ht).$height, Y.getContext(\"2d\").drawImage(W, 0, 0), Y.toBlob((q) => {\n      if (!q)\n        return;\n      const Z = URL.createObjectURL(q);\n      Texture.from(Z).once(\"update\", (K) => {\n        e(K), URL.revokeObjectURL(Z);\n      });\n    });\n  }).catch((W) => DebugMng.myTrace(`goTxt() = ${W}`));\n}, rn = new WeakMap(), ds = new WeakMap(), nn = new WeakMap(), sn = new WeakMap(), an = new WeakMap(), un = new WeakMap(), ps = new WeakMap(), Mu = new WeakMap(), Kr = new WeakMap(), Xa = new WeakSet(), ch = function(e, o, R, N, M, D) {\n  var B, $, k;\n  e.alpha = 0, o.x && (N.x = o.x.charAt(0) === \"=\" ? N.x + parseInt(o.x.slice(1)) : parseInt(o.x)), o.y && (N.y = o.y.charAt(0) === \"=\" ? N.y + parseInt(o.y.slice(1)) : parseInt(o.y)), o.width && (N.width = parseInt(o.width)), o.height && (N.height = parseInt(o.height)), o.wait && (D.wait = parseInt(o.wait)), e.width = N.width, e.height = N.height, D.x ? e.position.set(\n    D.x.charAt(0) === \"=\" ? N.x + e.width * D.nx : D.nx,\n    D.y.charAt(0) === \"=\" ? N.y + e.height * D.ny : D.ny\n  ) : e.position.set(N.x, N.y);\n  const L = {\n    sp: e,\n    tw: new Tween(e).to({ alpha: 1, x: N.x, y: N.y, width: N.width, height: N.height, angle: 0 }, (B = D.wait) != null ? B : 0).easing(M).delay((($ = R.wait) != null ? $ : 0) + ((k = o.delay) != null ? k : 0)).onComplete(() => {\n      L.tw = void 0;\n    }).start()\n  };\n  H(this, ds).push(L);\n}, vs = new WeakMap(), Jr = new WeakMap(), Wa = new WeakMap(), Qr = new WeakMap(), Nr = new WeakMap(), Ya = new WeakMap(), qa = new WeakSet(), fh = function(e) {\n  var D, L, B, $;\n  const o = [];\n  if (e.nodeType !== e.TEXT_NODE)\n    return e.childNodes.forEach((k) => o.push(at(this, qa, fh).call(this, k))), o.flat();\n  const R = e.ownerDocument.createRange();\n  R.selectNodeContents(e);\n  let N = 0;\n  const M = R.endOffset;\n  for (; N < M; ) {\n    R.setStart(e, N), R.setEnd(e, ++N);\n    const k = R.getBoundingClientRect(), U = R.startContainer.parentElement;\n    if (!U)\n      throw \"fn:TxtStage.ts pe null\";\n    const z = R.toString(), X = {\n      ch: z,\n      rect: new Rectangle(\n        k.left + globalThis.scrollX,\n        k.top + globalThis.scrollY,\n        k.width,\n        k.height + (\"gjqy\".includes(z) ? H(this, Ya) : 0)\n      ),\n      elm: U,\n      cmd: (D = U.getAttribute(\"data-cmd\")) != null ? D : void 0,\n      arg: (L = U.getAttribute(\"data-arg\")) != null ? L : void 0,\n      add: (B = U.getAttribute(\"data-add\")) != null ? B : void 0,\n      lnk: ($ = U.getAttribute(\"data-lnk\")) != null ? $ : void 0\n    };\n    o.push(X);\n  }\n  return R.detach(), o;\n}, bi = new WeakMap(), ln = new WeakMap(), Za = new WeakSet(), dh = function() {\n  var M;\n  H(this, qr).clear(), et(this, nn, []), et(this, sn, 0), this.skipChIn();\n  const e = H(this, ne).cloneNode(!0);\n  e.textContent = \"\";\n  const o = H(this, ne);\n  o.parentElement.insertBefore(e, o);\n  let R = 0;\n  o.querySelectorAll(\"span.sn_ch\").forEach((D) => {\n    var $, k, U, z, X, V;\n    const L = JSON.parse(\n      (V = (X = (k = D == null ? void 0 : D.getAttribute(\"data-add\")) != null ? k : ($ = D == null ? void 0 : D.children[0]) == null ? void 0 : $.getAttribute(\"data-add\")) != null ? X : (z = (U = D == null ? void 0 : D.children[0]) == null ? void 0 : U.children[0]) == null ? void 0 : z.getAttribute(\"data-add\")) != null ? V : \"{}\"\n    );\n    if (!L.ch_out_style)\n      return;\n    const B = H(Xt, Qr)[L.ch_out_style];\n    if (!!B) {\n      if (B.wait === 0) {\n        D.style.display = \"none\";\n        return;\n      }\n      R += B.wait, B.join || (D.style.animationDelay = \"0ms\"), D.classList.add(`go_ch_out_${L.ch_out_style}`);\n    }\n  });\n  const N = () => {\n    o.parentElement.removeChild(o), H(this, Ar).removeChildren().forEach((D) => {\n      D instanceof Container && H(Xt, hs).unButton(D), D.destroy();\n    });\n  };\n  R === 0 ? (H(this, ne).textContent = \"\", N()) : (M = o.lastElementChild) == null || M.addEventListener(\"animationend\", N, { once: !0, passive: !0 }), et(this, ne, e);\n}, lr = new WeakMap(), it(TxtStage, ls, void 0), it(TxtStage, za, void 0), it(TxtStage, hs, void 0), it(TxtStage, Va, {\n  backgroundColor: 0,\n  borderBottomWidth: 0,\n  borderLeftWidth: 0,\n  borderRightWidth: 0,\n  borderTopWidth: 0,\n  marginBottom: 0,\n  marginLeft: 0,\n  marginRight: 0,\n  marginTop: 0\n}), it(TxtStage, an, void 0), it(TxtStage, un, void 0), it(TxtStage, ps, void 0), it(TxtStage, Jr, /* @__PURE__ */ Object.create(null)), it(TxtStage, Wa, /[\\s\\.,]/), it(TxtStage, Qr, /* @__PURE__ */ Object.create(null)), it(TxtStage, Nr, new Container());\nvar __accessCheck = (n, t, e) => {\n  if (!t.has(n))\n    throw TypeError(\"Cannot \" + e);\n}, __privateGet = (n, t, e) => (__accessCheck(n, t, \"read from private field\"), e ? e.call(n) : t.get(n)), __privateAdd = (n, t, e) => {\n  if (t.has(n))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(n) : t.set(n, e);\n}, __privateSet = (n, t, e, o) => (__accessCheck(n, t, \"write to private field\"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod = (n, t, e) => (__accessCheck(n, t, \"access private method\"), e), _procMasume4txt, _procMasume4pic, _rctBtnTxt, _idc, _sp_b_pic, _sp_pic, _loaded_b_pic, loaded_b_pic_fn, _normal, _hover, _clicked, _loaded_pic, loaded_pic_fn;\nconst _Button = class extends Container {\n  constructor(n, t, e, o) {\n    var z, X, V;\n    var R;\n    super(), this.hArg = n, this.evtMng = t, this.resolve = e, this.canFocus = o, __privateAdd(this, _loaded_b_pic), __privateAdd(this, _loaded_pic), this.getBtnBounds = () => __privateGet(this, _rctBtnTxt), __privateAdd(this, _rctBtnTxt, new Rectangle()), __privateAdd(this, _idc, void 0), __privateAdd(this, _sp_b_pic, void 0), __privateAdd(this, _sp_pic, void 0), __privateAdd(this, _normal, () => {\n    }), __privateAdd(this, _hover, () => !1), __privateAdd(this, _clicked, () => {\n    }), CmnLib.isDbg && (this.makeDesignCast = (W) => W(__privateGet(this, _idc)), this.cvsResize = () => __privateGet(this, _idc).cvsResize());\n    let N = {\n      x: this.x = uint((z = n.left) != null ? z : 0),\n      y: this.y = uint((X = n.top) != null ? X : 0),\n      rotation: this.angle = argChk_Num(n, \"rotation\", this.angle),\n      pivot_x: this.pivot.x = argChk_Num(n, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = argChk_Num(n, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = argChk_Num(n, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = argChk_Num(n, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    const M = N.enabled = argChk_Boolean(n, \"enabled\", !0);\n    if (this.getBtnBounds = () => (__privateGet(this, _rctBtnTxt).x = N.x, __privateGet(this, _rctBtnTxt).y = N.y, __privateGet(this, _rctBtnTxt)), n.pic) {\n      N.type = \"pic\", __privateSet(this, _idc, new PicBtnDesignCast(this, n)), M && this.evtMng.button(this.hArg, this, () => __privateGet(this, _normal).call(this), () => __privateGet(this, _hover).call(this), () => __privateGet(this, _clicked).call(this)), GrpLayer.csv2Sprites(\n        n.pic,\n        this,\n        (W) => {\n          __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, W, N), __privateGet(this, _rctBtnTxt).width = W.width * N.scale_x, __privateGet(this, _rctBtnTxt).height = W.height * N.scale_y;\n        },\n        (W) => {\n          W && e();\n        }\n      ) || e();\n      return;\n    }\n    if (!n.text)\n      throw \"text\\u307E\\u305F\\u306Fpic\\u5C5E\\u6027\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const D = argChk_Num(n, \"height\", 30), L = new TextStyle({\n      align: \"center\",\n      dropShadow: !0,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: \"black\",\n      fontFamily: _Button.fontFamily,\n      fontSize: D,\n      padding: 5\n    });\n    if (n.style)\n      try {\n        const W = JSON.parse(n.style);\n        for (const Y in W)\n          L[Y] = W[Y];\n      } catch (W) {\n        throw new Error(mesErrJSON(n, \"style\", W.message));\n      }\n    const B = new Text((V = n.text) != null ? V : \"\", L);\n    B.alpha = argChk_Num(n, \"alpha\", B.alpha), B.width = argChk_Num(n, \"width\", 100), B.height = n.height = D, this.setText = (W) => B.text = W, N.type = \"text\", N = { ...N, ...L }, N.alpha = B.alpha, N.text = B.text, N.width = B.width, N.height = B.height, __privateSet(this, _idc, new TxtBtnDesignCast(this, n, B));\n    let $ = !1;\n    if (n.b_pic && (N.b_pic = n.b_pic, $ = GrpLayer.csv2Sprites(\n      n.b_pic,\n      this,\n      (W) => {\n        __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, W, B), N.width = this.width, N.height = this.height;\n      },\n      (W) => {\n        Layer.setBlendmode(this, n), W && e();\n      }\n    )), B.name = JSON.stringify(N), this.addChild(B), __privateGet(this, _rctBtnTxt).width = B.width, __privateGet(this, _rctBtnTxt).height = B.height, N.width = this.width, N.height = this.height, n.b_pic || Layer.setBlendmode(this, n), __privateGet(R = _Button, _procMasume4txt).call(R, this, B), !M) {\n      $ || e();\n      return;\n    }\n    const k = L.clone();\n    if (n.style_hover)\n      try {\n        const W = JSON.parse(n.style_hover);\n        for (const Y in W)\n          k[Y] = W[Y];\n      } catch (W) {\n        throw new Error(mesErrJSON(n, \"style_hover\", W.message));\n      }\n    else\n      k.fill = \"white\";\n    const U = k.clone();\n    if (n.style_clicked)\n      try {\n        const W = JSON.parse(n.style_clicked);\n        for (const Y in W)\n          U[Y] = W[Y];\n      } catch (W) {\n        throw new Error(mesErrJSON(n, \"style_clicked\", W.message));\n      }\n    else\n      U.dropShadow = !1;\n    t.button(n, this, () => B.style = L, () => o() ? (B.style = k, !0) : !1, () => B.style = U), $ || e();\n  }\n  static init(n) {\n    !n.oCfg.debug.masume || (__privateSet(_Button, _procMasume4txt, (t, e) => t.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, e.width, e.height).endFill()\n    )), __privateSet(_Button, _procMasume4pic, (t, e, o, R) => t.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, o, R).endFill()\n    )));\n  }\n  setText(n) {\n  }\n  destroy(n) {\n    this.evtMng.unButton(this), super.destroy();\n  }\n  makeDesignCast(n) {\n  }\n  showDesignCast() {\n    __privateGet(this, _idc).visible = !0;\n  }\n  cvsResize() {\n  }\n  update_b_pic(n, t) {\n    var o;\n    const e = JSON.parse((o = t.name) != null ? o : \"{}\");\n    __privateGet(this, _sp_b_pic) && this.removeChild(__privateGet(this, _sp_b_pic)), this.hArg.b_pic = e.b_pic = n, t.name = JSON.stringify(e), n && GrpLayer.csv2Sprites(\n      n,\n      this,\n      (R) => __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, R, t),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n  update_pic(n, t) {\n    var o;\n    const e = JSON.parse((o = t.name) != null ? o : \"{}\");\n    __privateGet(this, _sp_pic) && this.removeChild(__privateGet(this, _sp_pic)), this.hArg.pic = e.pic = n, t.name = JSON.stringify(e), n && GrpLayer.csv2Sprites(\n      n,\n      this,\n      (R) => __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, R, e),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n};\nlet Button = _Button;\n_procMasume4txt = /* @__PURE__ */ new WeakMap();\n_procMasume4pic = /* @__PURE__ */ new WeakMap();\n_rctBtnTxt = /* @__PURE__ */ new WeakMap();\n_idc = /* @__PURE__ */ new WeakMap();\n_sp_b_pic = /* @__PURE__ */ new WeakMap();\n_sp_pic = /* @__PURE__ */ new WeakMap();\n_loaded_b_pic = /* @__PURE__ */ new WeakSet();\nloaded_b_pic_fn = function(n, t) {\n  __privateSet(this, _sp_b_pic, n), this.setChildIndex(n, 0), n.alpha = t.alpha, n.setTransform(\n    t.x,\n    t.y,\n    1,\n    1,\n    t.rotation,\n    0,\n    0,\n    (n.width - t.width) / 2,\n    (n.height - t.height) / 2\n  ), n.name = t.name;\n};\n_normal = /* @__PURE__ */ new WeakMap();\n_hover = /* @__PURE__ */ new WeakMap();\n_clicked = /* @__PURE__ */ new WeakMap();\n_loaded_pic = /* @__PURE__ */ new WeakSet();\nloaded_pic_fn = function(n, t) {\n  var e;\n  __privateSet(this, _sp_pic, n), t.alpha = n.alpha = argChk_Num(this.hArg, \"alpha\", n.alpha), __privateGet(this, _idc).setSp(n);\n  const o = n.width / 3, R = n.height, N = n.texture.baseTexture, M = new Texture(N, new Rectangle(0, 0, o, R)), D = new Texture(N, new Rectangle(o, 0, o, R)), L = new Texture(N, new Rectangle(o * 2, 0, o, R)), B = () => n.texture = M;\n  B(), __privateSet(this, _normal, B), __privateSet(this, _hover, () => this.canFocus() ? (n.texture = L, !0) : !1), __privateSet(this, _clicked, () => n.texture = D), \"width\" in this.hArg ? (t.width = uint(this.hArg.width), this.scale.x *= t.width / o) : t.width = o, \"height\" in this.hArg ? (t.height = uint(this.hArg.height), this.scale.y *= t.height / o) : t.height = o, n.name = JSON.stringify(t), __privateGet(e = _Button, _procMasume4pic).call(e, this, n, o, R);\n};\nButton.fontFamily = \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif\";\n__privateAdd(Button, _procMasume4txt, (n, t) => {\n});\n__privateAdd(Button, _procMasume4pic, (n, t, e, o) => {\n});\nvar gs, br, _s, Ka, Ja, ph, Qa, vh, to, ms, eo, ti, hn, Du, hc, Mr, er, hr, ue, Er, te, ys, ke, bs, qo, xr, cn, Es, Zo, Dr, ro, gh, io, _h, Ei, fn, dn, xs, Ts, ei, rr, Lu, cc, Xe, Ss, Cs, Ko, xi, kn, Lr, ir, nr, Fr, Is, Jo, Ti, Gn, Si;\nconst qt = class extends Layer {\n  constructor() {\n    super();\n    it(this, bs);\n    it(this, Es);\n    it(this, ro);\n    it(this, io);\n    it(this, Lu);\n    it(this, Cs);\n    it(this, xi);\n    it(this, Is);\n    it(this, Ti);\n    it(this, Mr, void 0);\n    it(this, er, void 0);\n    it(this, hr, void 0);\n    it(this, ue, void 0);\n    it(this, Er, void 0);\n    it(this, te, void 0);\n    it(this, ys, void 0);\n    it(this, ke, void 0);\n    it(this, xr, void 0);\n    it(this, cn, void 0);\n    it(this, Dr, void 0);\n    it(this, Ei, void 0);\n    it(this, fn, void 0);\n    it(this, dn, void 0);\n    it(this, xs, void 0);\n    it(this, ei, void 0);\n    it(this, rr, void 0);\n    it(this, Xe, void 0);\n    it(this, Ss, void 0);\n    it(this, Lr, void 0);\n    it(this, ir, void 0);\n    it(this, nr, void 0);\n    it(this, Fr, void 0);\n    it(this, Si, void 0);\n    et(this, Mr, 0), et(this, er, 0), et(this, hr, !1), et(this, ue, void 0), et(this, Er, \"\"), et(this, te, new TxtStage(this.spLay, () => this.canFocus(), H(qt, eo))), et(this, ys, new RubySpliter()), et(this, ke, new Container()), et(this, xr, \"\"), et(this, cn, !0), et(this, Dr, \"\"), et(this, Ei, \"\"), et(this, fn, (o) => \"\"), et(this, dn, \"\"), et(this, xs, new RegExp(\"[\\u3000]\")), this.isCur = !1, et(this, ei, () => \"\"), et(this, rr, \"\"), et(this, Xe, !1), et(this, Ss, (o, R) => {\n      var B, $, k, U, z, X, V, W, Y, q;\n      H(qt, gs).oCfg.debug.putCh && console.log(`\\u{1F58A} \\u6587\\u5B57\\u8868\\u793A text:\\`${o}\\` ruby:\\`${R}\\` name:\\`${this.name_}\\``);\n      const N = R.split(\"\\uFF5C\");\n      let M = \"\";\n      const [D, L] = N;\n      switch (N.length) {\n        case 1:\n          if (et(this, Xe, !0), o === `\n`) {\n            H(this, ir) ? (et(this, ir, !1), M = \"<ruby>\\u3000<rt>\\u3000</rt></ruby><br/>\") : M = \"<br/>\";\n            break;\n          }\n          H(this, ir) && (et(this, ir, !1), R === \"\" && (R = \"\\u3000\")), M = at(this, Cs, Ko).call(this, o, R, H(this, rr));\n          break;\n        case 2:\n          switch (D) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              et(this, ir, !1), et(this, Xe, !0), M = at(this, Cs, Ko).call(this, o, L, D);\n              break;\n            case \"gotxt\":\n              at(this, Ti, Gn).call(this), this.isCur && H(B = qt, _s).call(B, H(this, nr).join(\"\").replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, \"\").replace(/style='(anim\\S+ \\S+?;\\s*)+/g, \"style='\").replace(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replace(/class='sn_ch .+?'/g, \"class='sn_ch'\").replaceAll(\"class='offrec'\", \"style='display: none;'\").replaceAll(\"`\", \"\\\\`\")), H(this, Xe) && (H(this, te).goTxt(H(this, nr)), et(this, Xe, !1), et(this, Lr, 0));\n              return;\n            case \"add\":\n              {\n                const Z = JSON.parse(L), { cl: K, sty: Q } = at(this, xi, kn).call(this, !0, Z.wait);\n                H(this, nr).push(`<span${K} style='display: inline;${(k = ($ = H(this, Fr).at(-1)) == null ? void 0 : $.o.style) != null ? k : \"\"}${(U = Z.style) != null ? U : \"\"}${Q}'>`), delete Z.style, at(this, Is, Jo).call(this, Z);\n              }\n              return;\n            case \"add_close\":\n              H(this, nr).push(\"</span>\"), at(this, Ti, Gn).call(this);\n              return;\n            case \"grp\":\n              et(this, Xe, !0);\n              {\n                const Z = JSON.parse(L);\n                if (Z.delay = H(this, Lr), (z = Z.id) != null || (Z.id = H(this, nr).length), Z.id === \"break\") {\n                  H(this, te).dispBreak(Z.pic);\n                  return;\n                }\n                (X = Z.style) != null || (Z.style = \"\");\n                const { cl: K, sty: Q, lnk: J } = at(this, xi, kn).call(this, !0, Z.wait);\n                M = `<span data-cmd='grp' data-id='${Z.id}'${K} style='${Q} ${(V = Z.style) != null ? V : \"\"}'${J} data-arg='${JSON.stringify(Z)}' data-add='{\"ch_in_style\":\"${H(this, xr)}\", \"ch_out_style\":\"${H(this, Dr)}\"}'>\\u3000</span>`, H(this, ir) && (et(this, ir, !1), M = `<ruby>${M}<rt>\\u3000</rt></ruby>`);\n              }\n              break;\n            case \"tcy\":\n              et(this, ir, !1), et(this, Xe, !0);\n              {\n                H(qt, br).doRecLog() && et(this, Si, H(this, Si) + (o + (R ? `\\u300A${R}\\u300B` : \"\")));\n                const Z = JSON.parse(L), { t: K, r: Q = \"\" } = Z, J = CmnLib.isSafari ? Q.replace(/[A-Za-z0-9]/g, (ut) => String.fromCharCode(ut.charCodeAt(0) + 65248)) : Q, rt = this.mkStyle_r_align(K, J, H(this, rr)), { cl: tt, sty: nt, lnk: st } = at(this, xi, kn).call(this, !0, Z.wait);\n                M = `<span${tt} style='${nt}${H(this, fn).call(this, K)} ${(W = Z.style) != null ? W : \"\"}'${st}><ruby><span style='\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;\n\t\t\t\t' data-add='{\"ch_in_style\":\"${H(this, xr)}\", \"ch_out_style\":\"${H(this, Dr)}\"}'>${K}</span>\n\t\t\t\t<rt${rt}>${J}</rt></ruby></span>`;\n              }\n              break;\n            case \"del\":\n              TxtStage.delBreak();\n              return;\n            case \"span\":\n              at(this, Ti, Gn).call(this), et(this, Xe, !0);\n              {\n                const Z = JSON.parse(L);\n                Z.style && at(this, Is, Jo).call(this, Z);\n              }\n              return;\n            case \"link\":\n              at(this, Ti, Gn).call(this), et(this, Xe, !0);\n              {\n                const Z = JSON.parse(L);\n                Z[\":link\"] = \" data-lnk='@'\";\n                const { cl: K, sty: Q } = at(this, xi, kn).call(this, !1, Z.wait);\n                H(this, nr).push(`<span data-arg='${L}'${K} style='display: inline; ${Q} ${(Y = Z.style) != null ? Y : \"\"}' data-add='{\"ch_in_style\":\"${H(this, xr)}\", \"ch_out_style\":\"${H(this, Dr)}\"}'}>`), delete Z.style, at(this, Is, Jo).call(this, Z);\n              }\n              return;\n            case \"endlink\":\n              et(this, Xe, !0), H(this, nr).push(\"</span>\"), at(this, Ti, Gn).call(this);\n              return;\n            default:\n              et(this, Xe, !0), M = at(this, Cs, Ko).call(this, o, R, H(this, rr));\n          }\n          break;\n      }\n      H(this, nr).push(H(q = qt, Ts).call(q, M));\n    }), et(this, Lr, 0), et(this, ir, !0), et(this, nr, []), et(this, Fr, []), this.click = () => !this.spLay.interactiveChildren || !this.spLay.visible ? !0 : H(this, te).skipChIn(), et(this, Si, \"\"), this.addButton = (o) => new Promise((R) => {\n      o.key = `btn=[${H(this, ke).children.length}] ` + this.name_, o[\":id_tag\"] = o.key.slice(0, -7), argChk_Boolean(o, \"hint_tate\", H(this, te).tategaki);\n      const N = new Button(o, H(qt, ms), () => R(), () => this.canFocus());\n      N.name = JSON.stringify(o).replaceAll('\"', \"'\"), H(this, ke).addChild(N);\n    }), this.record = () => Object.assign(super.record(), {\n      enabled: this.enabled,\n      r_align: H(this, rr),\n      b_do: H(this, ue) === void 0 ? void 0 : H(this, ue) instanceof Sprite ? \"Sprite\" : \"Graphics\",\n      b_pic: H(this, Er),\n      b_color: H(this, Mr),\n      b_alpha: H(this, er),\n      b_alpha_isfixed: H(this, hr),\n      ffs: H(this, Ei),\n      txs: H(this, te).record(),\n      strNoFFS: H(this, dn),\n      btns: H(this, ke).children.map((o) => o.name)\n    }), this.spLay.addChild(H(this, te)), H(this, ys).init(H(this, Ss)), this.spLay.addChild(H(this, ke)), H(this, ke).name = \"cntBtn\";\n    const e = 16;\n    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(e, o, R, N, M, D) {\n    var B, $;\n    et(qt, gs, e), TxtStage.init(e, D), et(qt, br, R), et(qt, _s, N), et(qt, Ka, M), R.setDoRecProc(qt.chgDoRec), o.autowc = (k) => {\n      var U;\n      return at(U = qt, Du, hc).call(U, k);\n    }, o.autowc({ enabled: !1, text: \"\", time: 0 }), o.ch_in_style = (k) => {\n      var U;\n      return at(U = qt, Ja, ph).call(U, k);\n    }, o.ch_out_style = (k) => {\n      var U;\n      return at(U = qt, Qa, vh).call(U, k);\n    }, TxtStage.initChStyle(), initStyle();\n    let L = \"\";\n    e.matchPath(\".+\", Config.EXT_FONT).forEach((k) => {\n      for (const U in k)\n        L += `\n@font-face {\n\tfont-family: '${k[U]}';\n\tsrc: url('${H(this, gs).searchPath(k[U], Config.EXT_FONT)}');\n}\n`;\n    }), L += `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`, addStyle(L), at(B = qt, Ja, ph).call(B, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !0,\n      ease: \"ease-out\"\n    }), at($ = qt, Qa, vh).call($, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !1,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(e, o, R) {\n    et(qt, to, e), et(qt, ms, o), et(qt, eo, R), TxtStage.setEvtMng(o);\n  }\n  destroy() {\n    H(this, ue) && (this.spLay.removeChild(H(this, ue)).destroy(), et(this, ue, void 0)), this.clearText(), H(this, te).destroy();\n  }\n  static destroy() {\n    et(qt, ti, !1), et(qt, hn, {}), et(qt, Ts, (e) => e);\n  }\n  set name(e) {\n    this.name_ = e, H(this, te).name = e;\n  }\n  get name() {\n    return this.name_;\n  }\n  cvsResize() {\n    H(this, te).cvsResize();\n  }\n  cvsResizeChildren() {\n    H(this, ke).children.forEach((e) => e.cvsResize());\n  }\n  lay(e) {\n    var o;\n    return super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[\":id_tag\"] = this.name_.slice(0, -7), RubySpliter.setting(e), at(this, io, _h).call(this, e), H(this, te).lay(e), \"r_align\" in e && et(this, rr, (o = e.r_align) != null ? o : \"\"), et(this, ei, CmnLib.isSafari ? H(this, te).tategaki ? (R, N) => `text-align: start; height: ${N}em; padding-top: ${R}; padding-bottom: ${R};` : (R, N) => `text-align: start; width: ${N}em; padding-left: ${R}; padding-right: ${R};` : H(this, te).tategaki ? (R) => `text-align: justify; text-align-last: justify; padding-top: ${R}; padding-bottom: ${R};` : (R) => `text-align: justify; text-align-last: justify; padding-left: ${R}; padding-right: ${R};`), CmnLib.isFirefox && (this.mkStyle_r_align = at(this, Lu, cc)), \"alpha\" in e && H(this, ke).children.forEach((R) => R.alpha = this.spLay.alpha), at(this, bs, qo).call(this, e), at(this, Es, Zo).call(this, e), at(this, ro, gh).call(this, e, (R) => {\n      R && H(qt, to).resume();\n    });\n  }\n  get width() {\n    return H(this, te).getWidth;\n  }\n  get height() {\n    return H(this, te).getHeight;\n  }\n  chgBackAlpha(e) {\n    const o = H(this, hr) ? H(this, er) : e * H(this, er);\n    H(this, ue) instanceof Graphics && (H(this, ue) && (this.spLay.removeChild(H(this, ue)), H(this, ue).destroy()), this.spLay.addChildAt(\n      et(this, ue, new Graphics()).beginFill(H(this, Mr)).lineStyle(void 0).drawRect(0, 0, H(this, te).getWidth, H(this, te).getHeight).endFill(),\n      0\n    ), H(this, ue).name = \"back(color)\"), H(this, ue) && (H(this, ue).visible = o > 0, H(this, ue).alpha = o);\n  }\n  static chgDoRec(e) {\n    et(qt, Ts, e ? (o) => o : (o) => `<span class='offrec'>${o}</span>`);\n  }\n  mkStyle_r_align(e, o, R) {\n    if (!R)\n      return \"\";\n    const N = e.length * 2;\n    if (N - o.length < 0)\n      return ` style='text-align: ${R};'`;\n    let M = \"\";\n    switch (R) {\n      case \"justify\":\n        M = H(this, ei).call(this, \"0\", N);\n        break;\n      case \"121\":\n        M = H(this, ei).call(this, `calc(${(N - o.length) / (o.length * 2)}em)`, N);\n        break;\n      case \"even\":\n        M = H(this, ei).call(this, `calc(${(N - o.length) / (o.length + 1)}em)`, N);\n        break;\n      case \"1ruby\":\n        M = H(this, ei).call(this, \"1em\", N);\n        break;\n      default:\n        M = `text-align: ${R};`;\n    }\n    return ` style='${M}'`;\n  }\n  tagCh(e) {\n    H(this, ys).putTxt(e);\n  }\n  clearText() {\n    var e;\n    this.spLay.addChild(et(this, te, H(this, te).reNew())), et(this, Lr, 0), et(this, ir, !0), et(this, nr, []), et(this, Si, \"\"), H(e = qt, _s).call(e, \"\", !0);\n  }\n  get pageText() {\n    return H(this, Si).replace(\"\\u300A\\u3000\\u300B\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var e, o;\n    return ((e = this.spLay.interactiveChildren) != null ? e : !1) && this.spLay.visible && H(o = qt, Ka).call(o, this);\n  }\n  clearLay(e) {\n    super.clearLay(e), this.clearText(), H(this, ke).removeChildren().forEach((o) => o.destroy());\n  }\n  playback(e, o) {\n    super.playback(e, o), this.enabled = e.enabled, et(this, rr, e.r_align), this.cvsResize(), at(this, io, _h).call(this, e), H(this, te).playback(e.txs), et(this, er, e.b_alpha), et(this, hr, e.b_alpha_isfixed), o.push(new Promise((N) => {\n      at(this, ro, gh).call(this, e.b_do ? e.b_do === \"Sprite\" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: \"\" }, (M) => {\n        M && N();\n      }) || N();\n    }));\n    const R = e.btns;\n    o = o.concat(R.map((N) => this.addButton(JSON.parse(N.replaceAll(\"'\", '\"')))));\n  }\n  snapshot(e, o) {\n    e.render(this.spLay, { clear: !1 }), H(this, te).snapshot(e, o);\n  }\n  snapshot_end() {\n    H(this, te).snapshot_end();\n  }\n  makeDesignCast(e) {\n    !this.spLay.visible || H(this, te).makeDesignCast(e);\n  }\n  makeDesignCastChildren(e) {\n    !this.spLay.visible || H(this, ke).children.forEach((o) => o.makeDesignCast(e));\n  }\n  showDesignCast() {\n    H(this, te).showDesignCast();\n  }\n  showDesignCastChildren() {\n    H(this, ke).children.forEach((e) => e.showDesignCast());\n  }\n  dump() {\n    return H(this, Ss).call(this, \"\", \"gotxt\\uFF5C\"), super.dump() + `, \"enabled\":\"${this.enabled}\", ${H(this, te).dump()}, \"b_pic\":\"${H(this, Er)}\", \"b_color\":\"${H(this, Mr)}\", \"b_alpha\":${H(this, er)}, \"b_alpha_isfixed\":\"${H(this, hr)}\", \"width\":${H(this, te).getWidth}, \"height\":${H(this, te).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Sprite ? \"Sprite\" : e instanceof Graphics ? \"Graphics\" : e instanceof Container ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${H(this, ke).children.map((e) => {\n      var o;\n      return (o = e.children[0].name) != null ? o : \"{}\";\n    }).join(\",\")}]`;\n  }\n};\nlet TxtLayer = qt;\ngs = new WeakMap(), br = new WeakMap(), _s = new WeakMap(), Ka = new WeakMap(), Ja = new WeakSet(), ph = function(e) {\n  const o = TxtStage.ch_in_style(e), R = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`, N = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`, { name: M } = e;\n  return addStyle(`\n.sn_ch_in_${M} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${M} {\n\topacity: ${o.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${M} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes sn_ch_in_${M} {\n\tfrom {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${R}, ${N});}\n\tto {opacity: 1; transform: none;}\n}\n`), !1;\n}, Qa = new WeakSet(), vh = function(e) {\n  const o = TxtStage.ch_out_style(e), R = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`, N = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`, { name: M } = e;\n  return addStyle(`\n.go_ch_out_${M} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${M} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes go_ch_out_${M} {\n\tto {\n\t\topacity: ${o.alpha};\n\t\ttransform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${R}, ${N});\n\t}\n`), !1;\n}, to = new WeakMap(), ms = new WeakMap(), eo = new WeakMap(), ti = new WeakMap(), hn = new WeakMap(), Du = new WeakSet(), hc = function(e) {\n  et(qt, ti, argChk_Boolean(e, \"enabled\", H(qt, ti))), H(qt, br).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", H(qt, ti));\n  const { text: o } = e;\n  if (\"text\" in e != \"time\" in e)\n    throw \"[autowc] text\\u3068time\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u5FC5\\u9808\\u3067\\u3059\";\n  if (H(qt, br).setVal_Nochk(\"save\", \"const.sn.autowc.text\", o), !o)\n    return H(qt, br).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\"), !1;\n  const R = o.length;\n  if (H(qt, ti) && R === 0)\n    throw '[autowc] enabled === false \\u304B\\u3064 text === \"\" \\u306F\\u8A31\\u3055\\u308C\\u307E\\u305B\\u3093';\n  const N = String(e.time).split(\",\");\n  if (N.length !== R)\n    throw \"[autowc] text\\u6587\\u5B57\\u6570\\u3068time\\u306B\\u8A18\\u8FF0\\u3055\\u308C\\u305F\\u5F85\\u3061\\u6642\\u9593\\uFF08\\u30B3\\u30F3\\u30DE\\u533A\\u5207\\u308A\\uFF09\\u306F\\u540C\\u6570\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  return et(qt, hn, {}), N.forEach((M, D) => H(qt, hn)[o[D]] = uint(M)), H(qt, br).setVal_Nochk(\"save\", \"const.sn.autowc.time\", e.time), !1;\n}, Mr = new WeakMap(), er = new WeakMap(), hr = new WeakMap(), ue = new WeakMap(), Er = new WeakMap(), te = new WeakMap(), ys = new WeakMap(), ke = new WeakMap(), bs = new WeakSet(), qo = function(e) {\n  const { in_style: o } = e;\n  if (!o)\n    return;\n  const R = TxtStage.getChInStyle(o);\n  if (!R)\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044in_style\\u3010${o}\\u3011\\u3067\\u3059`;\n  et(this, xr, o), et(this, cn, R.join);\n}, xr = new WeakMap(), cn = new WeakMap(), Es = new WeakSet(), Zo = function(e) {\n  const { out_style: o } = e;\n  if (!o)\n    return;\n  if (!TxtStage.getChOutStyle(o))\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044out_style\\u3010${o}\\u3011\\u3067\\u3059`;\n  et(this, Dr, o);\n}, Dr = new WeakMap(), ro = new WeakSet(), gh = function(e, o) {\n  if (\"back_clear\" in e)\n    return argChk_Boolean(e, \"back_clear\", !1) && (et(this, Mr, 0), et(this, er, 0), et(this, hr, !1), et(this, Er, \"\")), o(!1), !1;\n  et(this, er, argChk_Num(e, \"b_alpha\", H(this, er))), et(this, hr, argChk_Boolean(e, \"b_alpha_isfixed\", H(this, hr)));\n  const R = (H(this, hr) ? 1 : Number(H(qt, br).getVal(\"sys:TextLayer.Back.Alpha\"))) * H(this, er);\n  if (e.b_pic) {\n    if (H(this, Er) !== e.b_pic)\n      return et(this, Er, e.b_pic), H(this, ue) && (this.spLay.removeChild(H(this, ue)), H(this, ue).destroy()), GrpLayer.csv2Sprites(H(this, Er), this.spLay, (N) => {\n        et(this, ue, N), N.name = \"back(pic)\", N.visible = R > 0, N.alpha = R, H(this, te).setSize(N.width, N.height), this.spLay.setChildIndex(N, 0), o(!0);\n      });\n  } else\n    \"b_color\" in e && (et(this, Mr, argChk_Color(e, \"b_color\", 0)), H(this, ue) && (this.spLay.removeChild(H(this, ue)), H(this, ue).destroy()), et(this, Er, \"\"), this.spLay.addChildAt(\n      et(this, ue, new Graphics()).beginFill(H(this, Mr)).lineStyle(void 0).drawRect(0, 0, H(this, te).getWidth, H(this, te).getHeight).endFill(),\n      0\n    ), H(this, ue).name = \"back(color)\");\n  return H(this, ue) && (H(this, ue).visible = R > 0, H(this, ue).alpha = R), o(!1), !1;\n}, io = new WeakSet(), _h = function(e) {\n  var o, R;\n  \"noffs\" in e && (et(this, dn, (o = e.noffs) != null ? o : \"\"), et(this, xs, new RegExp(`[\\u3000${H(this, dn)}]`))), \"ffs\" in e && ((R = H(this, Ei)) != null || et(this, Ei, \"\"), et(this, fn, H(this, Ei) === \"\" ? () => \"\" : (N) => H(this, xs).test(N) ? \"\" : ` font-feature-settings: ${H(this, Ei)};`));\n}, Ei = new WeakMap(), fn = new WeakMap(), dn = new WeakMap(), xs = new WeakMap(), Ts = new WeakMap(), ei = new WeakMap(), rr = new WeakMap(), Lu = new WeakSet(), cc = function(e, o, R) {\n  if (!R)\n    return \"\";\n  const N = e.length * 2;\n  if (N - o.length < 0)\n    return ` style='text-align: ${R};'`;\n  let M = \"\";\n  switch (R) {\n    case \"left\":\n      M = \"ruby-align: start;\";\n      break;\n    case \"center\":\n      M = \"ruby-align: center;\";\n      break;\n    case \"right\":\n      M = \"ruby-align: start;\";\n      break;\n    case \"justify\":\n      M = \"ruby-align: space-between;\";\n      break;\n    case \"121\":\n      M = \"ruby-align: space-around;\";\n      break;\n    case \"even\":\n      const D = (N - o.length) / (o.length + 1);\n      M = \"ruby-align: space-between; \" + (H(this, te).tategaki ? `padding-top: ${D}em; padding-bottom: ${D}em;` : `padding-left: ${D}em; padding-right: ${D}em;`);\n      break;\n    case \"1ruby\":\n      M = \"ruby-align: space-between; \" + (H(this, te).tategaki ? \"padding-top: 1em; padding-bottom: 1em;\" : \"padding-left: 1em; padding-right: 1em;\");\n      break;\n    default:\n      M = `text-align: ${R};`;\n  }\n  return ` style='${M}'`;\n}, Xe = new WeakMap(), Ss = new WeakMap(), Cs = new WeakSet(), Ko = function(e, o, R) {\n  e === \" \" && (e = \"&nbsp;\"), H(qt, br).doRecLog() && et(this, Si, H(this, Si) + (e + (o ? `\\u300A${o}\\u300B` : \"\")));\n  const { cl: N, sty: M, lnk: D } = at(this, xi, kn).call(this, !0, null, e), L = `${D} data-add='{\"ch_in_style\":\"${H(this, xr)}\", \"ch_out_style\":\"${H(this, Dr)}\"}'`;\n  return `<span${N} style='${M}${H(this, fn).call(this, e)}'${o ? \"\" : L}>${o ? `<ruby${L}>${e}<rt${this.mkStyle_r_align(e, o, R)}>${o}</rt></ruby>` : e}</span>`;\n}, xi = new WeakSet(), kn = function(e, o, R = `\n`) {\n  var D, L, B, $, k, U, z, X;\n  const N = (D = H(this, Fr).at(0)) == null ? void 0 : D.o.wait, M = H(this, cn) ? ((L = o != null ? o : N) != null ? L : H(qt, ti)) ? (B = H(qt, hn)[R.charAt(0)]) != null ? B : 0 : LayerMng.msecChWait : 0;\n  return H(qt, ms).isSkippingByKeyDown() ? et(this, Lr, 0) : e && H(this, cn) && et(this, Lr, H(this, Lr) + M), {\n    cl: ` class='sn_ch${M > 0 ? ` sn_ch_in_${H(this, xr)}` : \"\"}'`,\n    sty: `animation-delay: ${H(this, Lr)}ms;${(U = (k = ($ = H(this, Fr).at(-1)) == null ? void 0 : $.o) == null ? void 0 : k.style) != null ? U : \"\"}`,\n    lnk: (X = (z = H(this, Fr).at(0)) == null ? void 0 : z.o[\":link\"]) != null ? X : \"\"\n  };\n}, Lr = new WeakMap(), ir = new WeakMap(), nr = new WeakMap(), Fr = new WeakMap(), Is = new WeakSet(), Jo = function(e) {\n  H(this, Fr).push({\n    o: e,\n    r_align: H(this, rr),\n    ch_in_style: H(this, xr),\n    ch_out_style: H(this, Dr)\n  }), \"r_align\" in e && et(this, rr, e.r_align), at(this, bs, qo).call(this, e), at(this, Es, Zo).call(this, e);\n}, Ti = new WeakSet(), Gn = function() {\n  const e = H(this, Fr).pop();\n  !e || (et(this, rr, e.r_align), at(this, bs, qo).call(this, { in_style: e.ch_in_style }), at(this, Es, Zo).call(this, { out_style: e.ch_out_style }));\n}, Si = new WeakMap(), it(TxtLayer, Ja), it(TxtLayer, Qa), it(TxtLayer, Du), it(TxtLayer, gs, void 0), it(TxtLayer, br, void 0), it(TxtLayer, _s, void 0), it(TxtLayer, Ka, void 0), it(TxtLayer, to, void 0), it(TxtLayer, ms, void 0), it(TxtLayer, eo, void 0), it(TxtLayer, ti, !1), it(TxtLayer, hn, {}), it(TxtLayer, Ts, (e) => e);\nvar ws, ri, Fu, fc, Rs, Ps, Qo, Bu, dc, $u, pc, no, ku, vc, Gu, gc;\nclass FrameMng {\n  constructor(t, e, o, R, N, M, D) {\n    it(this, Fu);\n    it(this, Ps);\n    it(this, Bu);\n    it(this, $u);\n    it(this, ku);\n    it(this, Gu);\n    it(this, ws, void 0);\n    it(this, ri, /* @__PURE__ */ Object.create(null));\n    it(this, Rs, {});\n    it(this, no, 1);\n    this.cfg = t, this.appPixi = o, this.val = R, this.main = N, this.sys = M, this.hTwInf = D, e.add_frame = (L) => at(this, Fu, fc).call(this, L), e.let_frame = (L) => at(this, Bu, dc).call(this, L), e.set_frame = (L) => at(this, $u, pc).call(this, L), e.frame = (L) => at(this, ku, vc).call(this, L), e.tsy_frame = (L) => at(this, Gu, gc).call(this, L);\n  }\n  setEvtMng(t) {\n    et(this, ws, t);\n  }\n  destroy() {\n    for (const t in H(this, ri)) {\n      const e = H(this, ri)[t];\n      e.parentElement.removeChild(e);\n    }\n    et(this, ri, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(t) {\n    return H(this, Rs)[t];\n  }\n  cvsResize() {\n    for (const t in H(this, ri)) {\n      const e = H(this, ri)[t], o = \"const.sn.frm.\" + t, R = Number(this.val.getVal(o + \".x\")), N = Number(this.val.getVal(o + \".y\")), M = Number(this.val.getVal(o + \".width\")), D = Number(this.val.getVal(o + \".height\"));\n      e.style.left = `${this.sys.ofsLeft4elm + R * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + N * this.sys.cvsScale}px`, e.width = String(M * this.sys.cvsScale), e.height = String(D * this.sys.cvsScale);\n    }\n  }\n}\nws = new WeakMap(), ri = new WeakMap(), Fu = new WeakSet(), fc = function(t) {\n  const { id: e, src: o, alpha: R = 1, scale_x: N = 1, scale_y: M = 1, rotate: D = 0 } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!o)\n    throw \"src\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const L = \"const.sn.frm.\" + e;\n  if (this.val.getVal(`tmp:${L}`))\n    throw `frame\\u3010${e}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  const B = argChk_Boolean(t, \"visible\", !0), $ = t.b_color ? ` background-color: ${t.b_color};` : \"\", k = at(this, Ps, Qo).call(this, t);\n  this.appPixi.view.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${e}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${R}; position: absolute; left:${this.sys.ofsLeft4elm + k.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + k.y * this.sys.cvsScale}px; z-index: 1; ${$} border: 0px; overflow: hidden; display: ${B ? \"inline\" : \"none\"}; transform: scale(${N}, ${M}) rotate(${D}deg);\" width=\"${k.width * this.sys.cvsScale}\" height=\"${k.height * this.sys.cvsScale}\"></iframe>`);\n  const U = this.cfg.searchPath(o, Config.EXT_HTML), z = new Loader().add({ name: o, url: U, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });\n  return this.sys.crypto && z.use((X, V) => {\n    try {\n      X.data = this.sys.decStr(X.extension, X.data);\n    } catch (W) {\n      this.main.errScript(`[add_frame]Html \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 src:${X.name} ${W}`, !1);\n    }\n    V == null || V();\n  }), z.load((X, V) => {\n    var Y;\n    const W = document.getElementById(e);\n    H(this, ri)[e] = W, H(this, Rs)[e] = !1, W.srcdoc = String((Y = V[o]) == null ? void 0 : Y.data).replace(\"sn_repRes();\", \"\").replace(\n      /\\s(?:src|href)=([\"'])(\\S+)\\1/g,\n      (q, Z, K) => K.slice(0, 3) === \"../\" ? this.sys.cur + K.slice(4) : q.replace(Z, Z + U.slice(0, U.lastIndexOf(\"/\") + 1))\n    ), W.onload = () => {\n      var Z;\n      this.val.setVal_Nochk(\"tmp\", L, !0), this.val.setVal_Nochk(\"tmp\", L + \".alpha\", R), this.val.setVal_Nochk(\"tmp\", L + \".x\", k.x), this.val.setVal_Nochk(\"tmp\", L + \".y\", k.y), this.val.setVal_Nochk(\"tmp\", L + \".scale_x\", N), this.val.setVal_Nochk(\"tmp\", L + \".scale_y\", M), this.val.setVal_Nochk(\"tmp\", L + \".rotate\", D), this.val.setVal_Nochk(\"tmp\", L + \".width\", k.width), this.val.setVal_Nochk(\"tmp\", L + \".height\", k.height), this.val.setVal_Nochk(\"tmp\", L + \".visible\", B);\n      const q = W.contentWindow;\n      H(this, ws).resvFlameEvent(q), (Z = q.sn_repRes) == null || Z.call(q, (K) => {\n        var Q;\n        return GrpLayer.loadPic2Img((Q = K.dataset.src) != null ? Q : \"\", K);\n      }), this.main.resume();\n    };\n  }), !0;\n}, Rs = new WeakMap(), Ps = new WeakSet(), Qo = function(t) {\n  const e = { ...t }, o = this.sys.resolution;\n  return new DOMRect(\n    argChk_Num(e, \"x\", 0) * o,\n    argChk_Num(e, \"y\", 0) * o,\n    argChk_Num(e, \"width\", CmnLib.stageW) * o,\n    argChk_Num(e, \"height\", CmnLib.stageH) * o\n  );\n}, Bu = new WeakSet(), dc = function(t) {\n  const { id: e, var_name: o } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const R = document.getElementById(e);\n  if (!R)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const N = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${N}`))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!o)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const M = R.contentWindow;\n  if (!M.hasOwnProperty(o))\n    throw `frame\\u3010${e}\\u3011\\u306B\\u5909\\u6570/\\u95A2\\u6570\\u3010${o}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u5909\\u6570\\u306F var\\u4ED8\\u304D\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044`;\n  const D = M[o];\n  return this.val.setVal_Nochk(\n    \"tmp\",\n    N + \".\" + o,\n    argChk_Boolean(t, \"function\", !1) ? D() : D\n  ), !1;\n}, $u = new WeakSet(), pc = function(t) {\n  const { id: e, var_name: o, text: R } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const N = document.getElementById(e);\n  if (!N)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const M = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${M}`))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!o)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!R)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  this.val.setVal_Nochk(\"tmp\", M + \".\" + o, R);\n  const D = N.contentWindow;\n  return D[o] = R, !1;\n}, no = new WeakMap(), ku = new WeakSet(), vc = function(t) {\n  const { id: e } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = document.getElementById(e);\n  if (!o)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const R = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(\"tmp:\" + R))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const N = o.style;\n  if (argChk_Boolean(t, \"float\", !1) ? N.zIndex = `${++Re(this, no)._}` : \"index\" in t ? N.zIndex = `${argChk_Num(t, \"index\", 0)}` : t.dive && (N.zIndex = `-${++Re(this, no)._}`), \"alpha\" in t) {\n    const D = N.opacity = String(t.alpha);\n    this.val.setVal_Nochk(\"tmp\", R + \".alpha\", D);\n  }\n  const M = at(this, Ps, Qo).call(this, t);\n  if ((\"x\" in t || \"y\" in t) && (N.left = `${this.sys.ofsLeft4elm + M.x * this.sys.cvsScale}px`, N.top = `${this.sys.ofsTop4elm + M.y * this.sys.cvsScale}px`, this.val.setVal_Nochk(\"tmp\", R + \".x\", M.x), this.val.setVal_Nochk(\"tmp\", R + \".y\", M.y)), \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) {\n    const D = argChk_Num(t, \"scale_x\", 1), L = argChk_Num(t, \"scale_y\", 1), B = argChk_Num(t, \"rotate\", 0);\n    N.transform = `scale(${D}, ${L}) rotate(${B}deg)`, this.val.setVal_Nochk(\"tmp\", R + \".scale_x\", D), this.val.setVal_Nochk(\"tmp\", R + \".scale_y\", L), this.val.setVal_Nochk(\"tmp\", R + \".rotate\", B);\n  }\n  if (\"width\" in t && (o.width = String(M.width * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", R + \".width\", M.width)), \"height\" in t && (o.height = String(M.height * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", R + \".height\", M.height)), \"visible\" in t) {\n    const D = argChk_Boolean(t, \"visible\", !0);\n    N.display = D ? \"inline\" : \"none\", this.val.setVal_Nochk(\"tmp\", R + \".visible\", D);\n  }\n  if (\"b_color\" in t && (N.backgroundColor = t.b_color), \"disabled\" in t) {\n    const D = H(this, Rs)[e] = argChk_Boolean(t, \"disabled\", !0);\n    o.contentDocument.body.querySelectorAll(\"input,select\").forEach((B) => B.disabled = D);\n  }\n  return !1;\n}, Gu = new WeakSet(), gc = function(t) {\n  var W;\n  const { id: e } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = document.getElementById(e);\n  if (!o)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const R = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${R}`, 0))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const N = {};\n  \"alpha\" in t && (N.a = o.style.opacity), (\"x\" in t || \"y\" in t || \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) && (N.x = Number(this.val.getVal(`tmp:${R}.x`)), N.y = Number(this.val.getVal(`tmp:${R}.y`)), N.sx = Number(this.val.getVal(`tmp:${R}.scale_x`)), N.sy = Number(this.val.getVal(`tmp:${R}.scale_y`)), N.r = Number(this.val.getVal(`tmp:${R}.rotate`))), \"width\" in t && (N.w = this.val.getVal(`tmp:${R}.width`)), \"height\" in t && (N.h = this.val.getVal(`tmp:${R}.height`));\n  const M = cnvTweenArg(t, N), D = {}, L = argChk_Num(t, \"repeat\", 1);\n  let B = () => {\n  };\n  \"alpha\" in t && (D.a = argChk_Num(M, \"alpha\", 0), B = () => {\n    o.style.opacity = N.a, this.val.setVal_Nochk(\"tmp\", \"alpha\", N.a);\n  });\n  let $ = () => {\n  };\n  const k = at(this, Ps, Qo).call(this, M);\n  (\"x\" in t || \"y\" in t || \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) && (D.x = k.x, D.y = k.y, D.sx = argChk_Num(M, \"scale_x\", 1), D.sy = argChk_Num(M, \"scale_y\", 1), D.r = argChk_Num(M, \"rotate\", 0), $ = () => {\n    o.style.left = this.sys.ofsLeft4elm + N.x * this.sys.cvsScale + \"px\", o.style.top = this.sys.ofsTop4elm + N.y * this.sys.cvsScale + \"px\", o.style.transform = `scale(${N.sx}, ${N.sy}) rotate(${N.r}deg)`, this.val.setVal_Nochk(\"tmp\", R + \".x\", N.x), this.val.setVal_Nochk(\"tmp\", R + \".y\", N.y), this.val.setVal_Nochk(\"tmp\", R + \".scale_x\", N.sx), this.val.setVal_Nochk(\"tmp\", R + \".scale_y\", N.sy), this.val.setVal_Nochk(\"tmp\", R + \".rotate\", N.r);\n  });\n  let U = () => {\n  };\n  \"width\" in t && (D.w = k.width, U = () => {\n    o.width = N.w * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", R + \".width\", N.w);\n  });\n  let z = () => {\n  };\n  \"height\" in t && (D.h = k.height, z = () => {\n    o.height = N.h * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", R + \".height\", N.h);\n  }), this.appPixi.stage.interactive = !1;\n  const X = `frm\n${t.id}`, V = new Tween(N).to(D, argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, ws).isSkippingByKeyDown()) ? 0 : 1)).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(t.ease)).repeat(L === 0 ? 1 / 0 : L - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onUpdate(() => {\n    B(), $(), U(), z();\n  }).onComplete(() => {\n    var q, Z;\n    this.appPixi.stage.interactive = !0;\n    const Y = this.hTwInf[X];\n    !Y || (delete this.hTwInf[X], (q = Y.tw) == null || q.stop(), Y.resume && this.main.resume(), (Z = Y.onEnd) == null || Z.call(Y));\n  });\n  if (\"chain\" in t) {\n    const Y = this.hTwInf[(W = t.chain) != null ? W : \"\"];\n    if (!Y || !Y.tw)\n      throw `${t.chain}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete Y.onEnd, Y.tw.chain(V);\n  } else\n    V.start();\n  return this.hTwInf[X] = { tw: V, resume: !1 }, !1;\n};\nvar Tr, ee, ve, Ci, pn, As, Os, Ns, vn, so, mh, ii, Br, Uu, mc, sr, Hu, yc, zu, bc, ju, Ec, Kt, Sr, Cr, Ms, Vu, xc, Ds, tu, Xu, Tc, ao, Ls, oo, Ii, wi, $r, Ce, Ri, Wu, Sc, Ie, Ge, Je, Yu, Cc, qu, Ic, Zu, wc, gn, ga, Ku, Rc, We, Ju, Pc, Qu, Ac, tl, Oc, el, Nc, rl, Mc, Pi, Ai, Un, cr, il, Dc, Fs, nl, Lc, kr, Oi, Ni, Hn, Ir, wr, sl, Fc, al, Bc, ol, $c, ul, kc, ll, Gc, hl, Uc, cl, Hc, fl, zc, dl, jc, pl, Vc, vl, Xc, gl, Wc, _l, Yc, ml, qc, yl, Zc;\nconst Wi = class {\n  constructor(t, e, o, R, N, M, D, L, B, $) {\n    it(this, so);\n    it(this, Uu);\n    it(this, Hu);\n    it(this, zu);\n    it(this, ju);\n    it(this, Vu);\n    it(this, Ds);\n    it(this, Xu);\n    it(this, Wu);\n    it(this, Ge);\n    it(this, Yu);\n    it(this, qu);\n    it(this, Zu);\n    it(this, gn);\n    it(this, Ku);\n    it(this, Ju);\n    it(this, Qu);\n    it(this, tl);\n    it(this, el);\n    it(this, rl);\n    it(this, Ai);\n    it(this, il);\n    it(this, nl);\n    it(this, Ni);\n    it(this, sl);\n    it(this, al);\n    it(this, ol);\n    it(this, ul);\n    it(this, ll);\n    it(this, hl);\n    it(this, cl);\n    it(this, fl);\n    it(this, dl);\n    it(this, pl);\n    it(this, vl);\n    it(this, gl);\n    it(this, _l);\n    it(this, ml);\n    it(this, yl);\n    it(this, Tr, void 0);\n    it(this, ee, void 0);\n    it(this, ve, void 0);\n    it(this, Ci, void 0);\n    it(this, pn, void 0);\n    it(this, As, void 0);\n    it(this, Os, void 0);\n    it(this, Ns, void 0);\n    it(this, vn, void 0);\n    it(this, ii, void 0);\n    it(this, Br, void 0);\n    it(this, sr, void 0);\n    it(this, Kt, void 0);\n    it(this, Sr, void 0);\n    it(this, Cr, void 0);\n    it(this, Ms, void 0);\n    it(this, ao, void 0);\n    it(this, Ls, void 0);\n    it(this, oo, void 0);\n    it(this, Ii, void 0);\n    it(this, wi, void 0);\n    it(this, $r, void 0);\n    it(this, Ce, void 0);\n    it(this, Ri, void 0);\n    it(this, Ie, void 0);\n    it(this, We, void 0);\n    it(this, cr, void 0);\n    it(this, Fs, void 0);\n    it(this, kr, void 0);\n    it(this, Oi, void 0);\n    it(this, Ir, void 0);\n    it(this, wr, void 0);\n    this.cfg = t, this.hTag = e, this.appPixi = o, this.val = R, this.main = N, this.scrItr = M, this.sys = D, this.sndMng = L, this.alzTagArg = B, this.prpPrs = $, et(this, ee, new Container()), et(this, ve, new Container()), et(this, As, () => update()), et(this, Os, {\n      attach: (V) => (DesignCast.leaveMode(), !1),\n      continue: (V) => (DesignCast.leaveMode(), !1),\n      disconnect: (V) => (DesignCast.leaveMode(), !1),\n      _enterDesign: (V) => (DesignCast.enterMode(), H(this, Sr).forEach((W) => {\n        const Y = H(this, Kt)[W].fore;\n        Y.makeDesignCastChildren((q) => q.make()), Y.makeDesignCast((q) => q.make());\n      }), at(this, so, mh).call(this, H(this, Cr)), !1),\n      _replaceToken: (V, W) => (DesignCast.replaceToken(W), !1),\n      _selectNode: (V, W) => (at(this, so, mh).call(this, W.node), !1)\n    }), et(this, Ns, \"\"), et(this, vn, \"\"), this.getFrmDisabled = (V) => H(this, Ci).getFrmDisabled(V), et(this, ii, void 0), et(this, sr, (V, W = this.currentTxtlayForeNeedErr, Y = !0) => W.tagCh(\"\\uFF5C\\u3000\\u300A\" + V + \"\\u300B\")), this.goTxt = () => {\n    }, this.breakLine = () => {\n    }, this.breakPage = () => {\n    }, et(this, Kt, {}), et(this, Sr, []), et(this, Cr, \"\"), et(this, Ms, \"\"), et(this, ao, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`), et(this, Ls, {\n      rule: Texture.EMPTY,\n      vague: 0,\n      tick: 0\n    }), et(this, oo, new Filter(void 0, H(this, ao), H(this, Ls))), et(this, Ii, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), et(this, wi, new Sprite(H(this, Ii))), et(this, $r, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), et(this, Ce, new Sprite(H(this, $r))), et(this, Ri, []), et(this, Ie, { tw: void 0, resume: !1 }), et(this, We, {}), et(this, cr, (V) => {\n      throw H(this, Oi).call(this), 0;\n    }), et(this, Fs, (V) => {\n      throw H(this, Oi).call(this), 0;\n    }), et(this, Oi, () => {\n      throw \"\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u6587\\u5B57\\u8868\\u793A\\u3084\\u64CD\\u4F5C\\u3059\\u308B\\u524D\\u306B\\u3001[add_lay layer=\\uFF08\\u30EC\\u30A4\\u30E4\\u540D\\uFF09 class=txt]\\u3067\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u3092\\u8FFD\\u52A0\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n    }), et(this, Ir, { text: \"\" }), et(this, wr, []);\n    const k = () => {\n      D.cvsResize(), this.cvsResizeDesign(), H(this, vn) ? H(this, Sr).forEach(\n        (V) => H(this, Kt)[V].fore.cvsResizeChildren()\n      ) : H(this, Sr).forEach(\n        (V) => H(this, Kt)[V].fore.cvsResize()\n      ), H(this, Ci).cvsResize(), H(this, Br).cvsResize();\n    };\n    if (CmnLib.isMobile)\n      globalThis.addEventListener(\"orientationchange\", k, { passive: !0 });\n    else {\n      let V;\n      globalThis.addEventListener(\"resize\", () => {\n        V || (V = setTimeout(() => {\n          V = void 0, k();\n        }, 1e3 / 60 * 10));\n      }, { passive: !0 });\n    }\n    D.cvsResize(), TxtLayer.init(t, e, R, (V) => this.recText(V), (V) => H(this, Kt)[V.layname].fore === V, o), GrpLayer.init(N, t, o, D, L), Button.init(t), et(this, Ci, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, N, this.sys, H(this, We))), D.hFactoryCls.grp = () => new GrpLayer(), D.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (V) => at(this, zu, bc).call(this, V), e.snapshot = (V) => at(this, Hu, yc).call(this, V), e.add_lay = (V) => at(this, ju, Ec).call(this, V), e.clear_lay = (V) => at(this, Xu, Tc).call(this, V), e.finish_trans = () => at(this, gn, ga).call(this), e.lay = (V) => at(this, Vu, xc).call(this, V), e.trans = (V) => at(this, Wu, Sc).call(this, V), e.wt = (V) => at(this, Zu, wc).call(this, V), e.quake = (V) => at(this, Ku, Rc).call(this, V), e.stop_quake = (V) => e.finish_trans(V), e.wq = (V) => e.wt(V), e.pause_tsy = (V) => at(this, el, Nc).call(this, V), e.resume_tsy = (V) => at(this, rl, Mc).call(this, V), e.stop_tsy = (V) => at(this, tl, Oc).call(this, V), e.tsy = (V) => at(this, Ju, Pc).call(this, V), e.wait_tsy = (V) => at(this, Qu, Ac).call(this, V), e.ch = (V) => at(this, Ai, Un).call(this, V), e.clear_text = (V) => at(this, sl, Fc).call(this, V), e.current = (V) => H(this, Fs).call(this, V), e.endlink = (V) => at(this, al, Bc).call(this, V), e.er = (V) => at(this, ol, $c).call(this, V), e.graph = (V) => at(this, ul, kc).call(this, V), e.link = (V) => at(this, ll, Gc).call(this, V), e.r = (V) => at(this, hl, Uc).call(this, V), e.rec_ch = (V) => at(this, fl, zc).call(this, V), e.rec_r = () => at(this, cl, Hc).call(this), e.reset_rec = (V) => at(this, dl, jc).call(this, V), e.ruby2 = (V) => at(this, pl, Vc).call(this, V), e.span = (V) => at(this, vl, Xc).call(this, V), e.tcy = (V) => at(this, gl, Wc).call(this, V), e.add_face = (V) => GrpLayer.add_face(V), e.wv = (V) => GrpLayer.wv(V), e.dump_lay = (V) => at(this, _l, Yc).call(this, V), e.enable_event = (V) => at(this, ml, qc).call(this, V), e.button = (V) => at(this, yl, Zc).call(this, V), t.existsBreakline && (this.breakLine = () => H(this, sr).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakline\"}')), t.existsBreakpage && (this.breakPage = () => H(this, sr).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakpage\"}')), et(this, pn, parseColor(String(t.oCfg.init.bg_color)));\n    const U = new Graphics();\n    U.beginFill(H(this, pn), 1).lineStyle(0, H(this, pn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), H(this, ee).addChild(U.clone()), H(this, ve).addChild(U), H(this, ve).visible = !1, et(this, Tr, this.appPixi.stage), H(this, Tr).addChild(H(this, ve)), H(this, Tr).addChild(H(this, ee)), H(this, Tr).addChild(H(this, wi)), H(this, Tr).addChild(H(this, Ce)), this.appPixi.ticker.add(H(this, As));\n    const z = (V, W) => {\n      at(this, Uu, mc).call(this, Number(W));\n    };\n    z(\"\", R.getVal(\"sys:TextLayer.Back.Alpha\", 1)), R.defValTrg(\"sys:TextLayer.Back.Alpha\", z);\n    const X = (V, W) => Button.fontFamily = W;\n    X(\"\", R.getVal(\"tmp:sn.button.fontFamily\", Button.fontFamily)), R.defValTrg(\"tmp:sn.button.fontFamily\", X), R.defTmp(\"const.sn.log.json\", () => JSON.stringify(\n      H(this, Ir).text ? [...H(this, wr), H(this, Ir)] : H(this, wr)\n    )), R.defTmp(\"const.sn.last_page_text\", () => {\n      var V, W;\n      return (W = (V = this.currentTxtlayFore) == null ? void 0 : V.pageText) != null ? W : \"\";\n    }), CmnLib.isDbg && (DesignCast.init(this.appPixi, D, M, $, B, this.cfg, H(this, Kt)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), D.addHook((V, W) => {\n      var Y, q;\n      !((q = (Y = H(this, Os))[V]) != null && q.call(Y, V, W)) || delete H(this, Os)[V];\n    }));\n  }\n  cvsResizeDesign() {\n  }\n  cover(t, e = 0) {\n    H(this, ii) && (H(this, Tr).removeChild(H(this, ii)), H(this, ii).destroy(), et(this, ii, void 0)), t && H(this, Tr).addChild(\n      et(this, ii, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()\n    );\n  }\n  setEvtMng(t) {\n    et(this, Br, t), H(this, Ci).setEvtMng(t), GrpLayer.setEvtMng(t);\n  }\n  before_destroy() {\n    for (const t in H(this, Kt))\n      H(this, Kt)[t].destroy();\n  }\n  destroy() {\n    GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), H(this, Ci).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(H(this, As)), et(Wi, Pi, 10);\n  }\n  stopAllTw() {\n    et(this, We, {}), removeAll();\n  }\n  clearBreak() {\n    !this.currentTxtlayFore || (this.clearBreak = () => H(this, sr).call(this, \"del\\uFF5Cbreak\"), this.clearBreak());\n  }\n  clickTxtLay() {\n    if (!this.currentTxtlayFore)\n      return;\n    const t = at(this, Ge, Je).call(this), e = t.length;\n    for (let o = 0; o < e; ++o) {\n      const R = t[o], N = H(this, Kt)[R];\n      if (!(N.fore instanceof TxtLayer))\n        continue;\n      if (!N.fore.click())\n        break;\n    }\n  }\n  static get msecChWait() {\n    return H(Wi, Pi);\n  }\n  static set msecChWait(t) {\n    et(Wi, Pi, t);\n  }\n  setNormalChWait() {\n    et(Wi, Pi, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    return H(this, Oi).call(this), this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    if (!!H(this, kr))\n      return H(this, kr).fore;\n  }\n  recText(t, e = !1) {\n    const o = H(this, Ir);\n    if (e) {\n      o.text && (o.text = String(o.text).replaceAll(\"</span><span class='sn_ch'>\", \"\"), H(this, wr).push(o) > this.cfg.oCfg.log.max_len && et(this, wr, H(this, wr).slice(-this.cfg.oCfg.log.max_len))), et(this, Ir, { text: \"\" });\n      return;\n    }\n    o.text = t.replace(/\\\\`/, \"`\"), this.val.setVal_Nochk(\n      \"save\",\n      \"const.sn.sLog\",\n      String(this.val.getVal(\"const.sn.log.json\"))\n    );\n  }\n  record() {\n    const t = {};\n    return H(this, Sr).forEach((e) => {\n      const o = H(this, Kt)[e];\n      t[e] = {\n        cls: o.cls,\n        fore: o.fore.record(),\n        back: o.back.record()\n      };\n    }), t;\n  }\n  playback(t, e) {\n    var M, D;\n    et(this, wr, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\")))), et(this, Ir, { text: \"\" });\n    const o = [], R = [];\n    for (const L in t) {\n      const B = t[L];\n      R.push({ layer: L, idx: B.fore.idx });\n      const $ = (D = (M = H(this, Kt))[L]) != null ? D : M[L] = new Pages(L, B.cls, H(this, ee), H(this, ve), {}, this.sys, this.val, { isWait: !1 });\n      $.fore.playback(B.fore, o), $.back.playback(B.back, o);\n    }\n    const N = H(this, ee).children.length;\n    Promise.allSettled(o).then(() => {\n      R.sort(function(L, B) {\n        return L.idx < B.idx ? -1 : L.idx > B.idx ? 1 : 0;\n      }), R.forEach((L) => {\n        const B = H(this, Kt)[L.layer];\n        if (!B)\n          return;\n        const $ = N > L.idx ? L.idx : N - 1;\n        H(this, ee).setChildIndex(B.fore.spLay, $), H(this, ve).setChildIndex(B.back.spLay, $);\n      }), e();\n    }).catch((L) => console.error(\"fn:LayerMng.ts playback e:%o\", L));\n  }\n};\nlet LayerMng = Wi;\nTr = new WeakMap(), ee = new WeakMap(), ve = new WeakMap(), Ci = new WeakMap(), pn = new WeakMap(), As = new WeakMap(), Os = new WeakMap(), Ns = new WeakMap(), vn = new WeakMap(), so = new WeakSet(), mh = function(t) {\n  [Re(this, Ns)._, this.vn = \"\"] = t.split(\"/\");\n  const e = H(this, Kt)[H(this, Ns)];\n  !e || (DesignCast.allHide(), H(this, vn) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());\n}, ii = new WeakMap(), Br = new WeakMap(), Uu = new WeakSet(), mc = function(t) {\n  at(this, Ge, Je).call(this).forEach((e) => {\n    const o = H(this, Kt)[e];\n    if (!(o.fore instanceof TxtLayer))\n      return;\n    o.fore.chgBackAlpha(t), o.back.chgBackAlpha(t);\n  });\n}, sr = new WeakMap(), Hu = new WeakSet(), yc = function(t) {\n  const e = t.fn ? t.fn.slice(0, 10) === \"userdata:/\" ? t.fn : `downloads:/${t.fn + getDateStr(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${getDateStr(\"-\", \"_\", \"\", \"_\")}.png`, o = this.cfg.searchPath(e);\n  if (this.sys.canCapturePage(o))\n    return !1;\n  const R = getExt(o), N = argChk_Color(t, \"b_color\", H(this, pn)), M = autoDetectRenderer({\n    width: argChk_Num(t, \"width\", CmnLib.stageW),\n    height: argChk_Num(t, \"height\", CmnLib.stageH),\n    backgroundAlpha: N > 16777216 && R === \"png\" ? 0 : 1,\n    antialias: argChk_Boolean(t, \"smoothing\", !1),\n    preserveDrawingBuffer: !0,\n    backgroundColor: N & 16777215,\n    autoDensity: !0\n  }), D = [], L = t.page !== \"back\" ? \"fore\" : \"back\";\n  return H(this, Ie).tw ? D.push(new Promise((B) => {\n    H(this, ve).visible = !0, H(this, Ri).forEach(($) => M.render($, { clear: !1 })), H(this, ve).visible = !1, H(this, wi).visible = !0, H(this, ee).filters = H(this, Ce).filters, H(this, ee).visible = !0, M.render(H(this, ee), { clear: !1 }), H(this, ee).visible = !1, H(this, ee).filters = [], B();\n  })) : at(this, Ge, Je).call(this, t.layer).forEach((B) => D.push(new Promise(\n    ($) => H(this, Kt)[B][L].snapshot(M, () => $())\n  ))), Promise.allSettled(D).then(async () => {\n    const B = RenderTexture.create({ width: M.width, height: M.height, transform: !0 });\n    M.render(H(this, Tr), { renderTexture: B }), await this.sys.savePic(\n      o,\n      M.plugins.extract.base64(Sprite.from(B))\n    ), H(this, Ie).tw || at(this, Ge, Je).call(this, t.layer).forEach(($) => H(this, Kt)[$][L].snapshot_end()), M.destroy(!0);\n  }), !1;\n}, zu = new WeakSet(), bc = function(t) {\n  const { fn: e } = t;\n  if (!e)\n    throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = argChk_Boolean(t, \"join\", !0);\n  switch (getExt(e)) {\n    case \"css\":\n      (async () => {\n        const R = await fetch(e);\n        if (!R.ok)\n          throw new Error(\"Network response was not ok.\");\n        addStyle(await R.text()), o && this.main.resume();\n      })();\n      break;\n    default:\n      throw \"\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3067\\u3059\";\n  }\n  return o;\n}, ju = new WeakSet(), Ec = function(t) {\n  const { layer: e, class: o } = t;\n  if (!e)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (e in H(this, Kt))\n    throw `layer\\u3010${e}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  if (!o)\n    throw \"cls\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const R = { isWait: !1 };\n  switch (H(this, Kt)[e] = new Pages(e, o, H(this, ee), H(this, ve), t, this.sys, this.val, R), H(this, Sr).push(e), o) {\n    case \"txt\":\n      H(this, Cr) || (et(this, Oi, () => {\n      }), et(this, cr, at(this, il, Dc)), et(this, Fs, at(this, nl, Lc)), this.hTag.current({ layer: e }), this.goTxt = () => {\n        this.val.getVal(\"sn.skip.enabled\") ? et(Wi, Pi, 0) : this.setNormalChWait(), at(this, Ge, Je).call(this).forEach((N) => {\n          const M = H(this, Kt)[N];\n          M.fore instanceof TxtLayer && H(this, sr).call(this, \"gotxt\\uFF5C\", M.fore, !1);\n        });\n      }), this.val.setVal_Nochk(\n        \"save\",\n        \"const.sn.layer.\" + (e != null ? e : H(this, Cr)) + \".enabled\",\n        !0\n      );\n      break;\n    case \"grp\":\n      if (H(this, Ms))\n        break;\n      et(this, Ms, e);\n      break;\n  }\n  return this.scrItr.recodeDesign(t), R.isWait;\n}, Kt = new WeakMap(), Sr = new WeakMap(), Cr = new WeakMap(), Ms = new WeakMap(), Vu = new WeakSet(), xc = function(t) {\n  const e = at(this, Ni, Hn).call(this, t), o = H(this, Kt)[e], R = o.back.spLay, N = o.fore.spLay;\n  if (argChk_Boolean(t, \"float\", !1))\n    H(this, ve).setChildIndex(R, H(this, ve).children.length - 1), H(this, ee).setChildIndex(N, H(this, ee).children.length - 1), at(this, Ds, tu).call(this);\n  else if (t.index)\n    argChk_Num(t, \"index\", 0) && (H(this, ve).setChildIndex(R, t.index), H(this, ee).setChildIndex(N, t.index), at(this, Ds, tu).call(this));\n  else if (t.dive) {\n    const { dive: M } = t;\n    let D = 0;\n    if (e === M)\n      throw \"[lay] \\u5C5E\\u6027 layer\\u3068dive\\u304C\\u540C\\u3058\\u3010\" + M + \"\\u3011\\u3067\\u3059\";\n    const L = H(this, Kt)[M];\n    if (!L)\n      throw \"[lay] \\u5C5E\\u6027 dive\\u3010\" + M + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n    const B = L.back, $ = L.fore, k = H(this, ve).getChildIndex(B.spLay), U = H(this, ee).getChildIndex($.spLay);\n    D = k < U ? k : U, D > H(this, ve).getChildIndex(R) && --D, H(this, ee).setChildIndex(N, D), H(this, ve).setChildIndex(R, D), at(this, Ds, tu).call(this);\n  }\n  return t[\":id_tag\"] = o.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), o.lay(t);\n}, Ds = new WeakSet(), tu = function() {\n  et(this, Sr, at(this, qu, Ic).call(this));\n}, Xu = new WeakSet(), Tc = function(t) {\n  return at(this, Yu, Cc).call(this, t, (e) => {\n    const o = H(this, Kt)[at(this, Ni, Hn).call(this, { layer: e })];\n    t.page === \"both\" ? (o.fore.clearLay(t), o.back.clearLay(t)) : o.getPage(t).clearLay(t);\n  }), !1;\n}, ao = new WeakMap(), Ls = new WeakMap(), oo = new WeakMap(), Ii = new WeakMap(), wi = new WeakMap(), $r = new WeakMap(), Ce = new WeakMap(), Ri = new WeakMap(), Wu = new WeakSet(), Sc = function(t) {\n  at(this, gn, ga).call(this);\n  const e = CmnTween.ease(t.ease);\n  et(this, Ri, []);\n  const o = {}, R = [];\n  at(this, Ge, Je).call(this, t.layer).forEach((z) => {\n    o[z] = !0, R.push(H(this, Kt)[z].fore);\n  });\n  const N = [];\n  at(this, Ge, Je).call(this).forEach((z) => {\n    const X = H(this, Kt)[z][o[z] ? \"back\" : \"fore\"];\n    H(this, Ri).push(X.spLay), N.push(X);\n  }), H(this, Ii).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ve), { renderTexture: H(this, Ii) });\n  let M = () => {\n    H(this, ve).visible = !0, H(this, Ri).forEach((z) => {\n      this.appPixi.renderer.render(z, { renderTexture: H(this, Ii), clear: !1 });\n    }), H(this, ve).visible = !1;\n  };\n  if (!N.some((z) => z.containMovement)) {\n    let z = M;\n    M = () => {\n      M = () => {\n      }, z();\n    };\n  }\n  H(this, $r).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ee), { renderTexture: H(this, $r) });\n  let D = () => {\n    H(this, ee).visible = !0, this.appPixi.renderer.render(H(this, ee), { renderTexture: H(this, $r) }), H(this, ee).visible = !1;\n  };\n  if (!R.some((z) => z.containMovement)) {\n    let z = D;\n    D = () => {\n      D = () => {\n      }, z();\n    };\n  }\n  const L = () => {\n    M(), H(this, wi).visible = !0, D(), H(this, Ce).visible = !0;\n  };\n  H(this, Ce).alpha = 1;\n  const B = () => {\n    var X;\n    this.appPixi.ticker && this.appPixi.ticker.remove(L), [Re(this, ee)._, Re(this, ve)._] = [H(this, ve), H(this, ee)];\n    const z = [];\n    for (const V in H(this, Kt)) {\n      const W = H(this, Kt)[V];\n      if (o[V]) {\n        W.transPage(z);\n        continue;\n      }\n      const Y = H(this, ee).getChildIndex(W.back.spLay);\n      H(this, ee).removeChild(W.back.spLay), H(this, ve).removeChild(W.fore.spLay), H(this, ee).addChildAt(W.fore.spLay, Y), H(this, ve).addChildAt(W.back.spLay, Y);\n    }\n    Promise.allSettled(z), H(this, ee).visible = !0, H(this, ve).visible = !1, H(this, wi).visible = !1, H(this, Ce).visible = !1, (X = H(this, Ie).tw) == null || X.stop(), H(this, Ie).resume && this.main.resume(), et(this, Ie, { tw: void 0, resume: !1 });\n  };\n  et(this, Ie, { tw: void 0, resume: !1 });\n  const $ = argChk_Num(t, \"time\", 0);\n  if ($ === 0 || H(this, Br).isSkippingByKeyDown())\n    return B(), !1;\n  const k = \"glsl\" in t;\n  if (!k && !(\"rule\" in t))\n    return H(this, Ce).filters = [], H(this, Ie).tw = new Tween(H(this, Ce)).to({ alpha: 0 }, $).delay(argChk_Num(t, \"delay\", 0)).easing(e).onComplete(B).start(), this.appPixi.ticker.add(L), !1;\n  const U = k ? new Filter(void 0, t.glsl, H(this, Ls)) : H(this, oo);\n  if (U.uniforms.vague = argChk_Num(t, \"vague\", 0.04), U.uniforms.tick = 0, H(this, Ie).tw = new Tween(U.uniforms).to({ tick: 1 }, $).delay(argChk_Num(t, \"delay\", 0)).easing(e).onComplete(B), H(this, Ce).filters = [U], k)\n    return H(this, Ie).tw.start(), this.appPixi.ticker.add(L), !1;\n  if (!t.rule)\n    throw \"rule\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return GrpLayer.csv2Sprites(t.rule, void 0, (z) => {\n    var X;\n    U.uniforms.rule = z.texture, z.destroy(), (X = H(this, Ie).tw) == null || X.start(), this.appPixi.ticker.add(L);\n  }), !1;\n}, Ie = new WeakMap(), Ge = new WeakSet(), Je = function(t = \"\") {\n  return t ? t.split(\",\") : H(this, Sr);\n}, Yu = new WeakSet(), Cc = function(t, e) {\n  const o = at(this, Ge, Je).call(this, t.layer);\n  return o.forEach((R) => {\n    if (!R)\n      return;\n    const N = H(this, Kt)[R];\n    if (!N)\n      throw \"\\u5B58\\u5728\\u3057\\u306A\\u3044layer\\u3010\" + R + \"\\u3011\\u3067\\u3059\";\n    e(R, N);\n  }), o;\n}, qu = new WeakSet(), Ic = function(t = \"\") {\n  return at(this, Ge, Je).call(this, t).sort((e, o) => {\n    const R = H(this, ee).getChildIndex(H(this, Kt)[e].fore.spLay), N = H(this, ee).getChildIndex(H(this, Kt)[o].fore.spLay);\n    return R < N ? -1 : R > N ? 1 : 0;\n  });\n}, Zu = new WeakSet(), wc = function(t) {\n  return H(this, Ie).tw ? (H(this, Ie).resume = !0, H(this, Br).waitLimitedEvent(t, () => at(this, gn, ga).call(this))) : !1;\n}, gn = new WeakSet(), ga = function() {\n  var t;\n  return (t = H(this, Ie).tw) == null || t.end(), !1;\n}, Ku = new WeakSet(), Rc = function(t) {\n  at(this, gn, ga).call(this);\n  const e = argChk_Num(t, \"time\", NaN);\n  if (e === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, Br).isSkippingByKeyDown())\n    return !1;\n  const o = [];\n  at(this, Ge, Je).call(this, t.layer).forEach((k) => {\n    o.push(H(this, Kt)[k].fore.spLay);\n  }), H(this, $r).resize(CmnLib.stageW, CmnLib.stageH);\n  const R = () => {\n    H(this, ee).visible = !0, o.forEach(\n      (k) => this.appPixi.renderer.render(k, { renderTexture: H(this, $r), clear: !1 })\n    ), H(this, ee).visible = !1;\n  };\n  H(this, Ce).visible = !0, H(this, Ce).alpha = 1;\n  const N = uint(argChk_Num(t, \"hmax\", 10)), M = uint(argChk_Num(t, \"vmax\", 10)), D = N === 0 ? () => {\n  } : () => H(this, Ce).x = Math.round(Math.random() * N * 2) - N, L = M === 0 ? () => {\n  } : () => H(this, Ce).y = Math.round(Math.random() * M * 2) - M;\n  H(this, Ce).filters = [];\n  const B = argChk_Num(t, \"repeat\", 1), $ = new Tween(H(this, Ce)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(t.ease)).onUpdate(() => {\n    D(), L();\n  }).repeat(B === 0 ? 1 / 0 : B - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onComplete(() => {\n    var k, U;\n    (k = this.appPixi.ticker) == null || k.remove(R), H(this, ee).visible = !0, H(this, Ce).visible = !1, H(this, Ce).x = 0, H(this, Ce).y = 0, (U = H(this, Ie).tw) == null || U.stop(), H(this, Ie).resume && this.main.resume(), et(this, Ie, { tw: void 0, resume: !1 });\n  }).start();\n  return et(this, Ie, { tw: $, resume: !1 }), this.appPixi.ticker.add(R), !1;\n}, We = new WeakMap(), Ju = new WeakSet(), Pc = function(t) {\n  var U, z;\n  if (!t.layer)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = at(this, Ni, Hn).call(this, t);\n  let o = H(this, Kt)[e].fore, R = () => {\n  };\n  const N = H(this, Br).isSkippingByKeyDown();\n  !N && \"render\" in t && (o.renderStart(), R = () => o.renderEnd());\n  const M = cnvTweenArg(t, o), D = argChk_Num(t, \"repeat\", 1), L = (U = t.name) != null ? U : t.layer, B = new Tween(o).to(M, argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || N) ? 0 : 1)).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(t.ease)).repeat(D === 0 ? 1 / 0 : D - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onComplete(() => {\n    var V, W;\n    const X = H(this, We)[L];\n    !X || (R(), delete H(this, We)[L], (V = X.tw) == null || V.stop(), X.resume && this.main.resume(), (W = X.onEnd) == null || W.call(X));\n  });\n  if (\"chain\" in t) {\n    const X = H(this, We)[(z = t.chain) != null ? z : \"\"];\n    if (!(X != null && X.tw))\n      throw `${t.chain}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete X.onEnd, X.tw.chain(B);\n  } else\n    B.start();\n  const $ = argChk_Boolean(t, \"arrive\", !1), k = argChk_Boolean(t, \"backlay\", !1);\n  return H(this, We)[L] = { tw: B, resume: !1, onEnd: () => {\n    if ($ && Object.assign(o, M), k) {\n      const X = H(this, Kt)[e].back.spLay;\n      for (const V in hMemberCnt)\n        X[V] = o[V];\n    }\n  } }, !1;\n}, Qu = new WeakSet(), Ac = function(t) {\n  var R;\n  const e = \"id\" in t ? `frm\n${t.id}` : (R = t.name) != null ? R : t.layer;\n  if (!e)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  const o = H(this, We)[e];\n  return o != null && o.tw ? o.resume = H(this, Br).waitEvent(\n    () => {\n      var N;\n      return (N = o.tw) == null ? void 0 : N.end();\n    },\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ) : !1;\n}, tl = new WeakSet(), Oc = function(t) {\n  var o, R, N;\n  const e = \"id\" in t ? `frm\n${t.id}` : (o = t.name) != null ? o : t.layer;\n  if (!e)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.end(), !1;\n}, el = new WeakSet(), Nc = function(t) {\n  var o, R, N;\n  const e = \"id\" in t ? `frm\n${t.id}` : (o = t.name) != null ? o : t.layer;\n  if (!e)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.pause(), !1;\n}, rl = new WeakSet(), Mc = function(t) {\n  var o, R, N;\n  const e = \"id\" in t ? `frm\n${t.id}` : (o = t.name) != null ? o : t.layer;\n  if (!e)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.resume(), !1;\n}, Pi = new WeakMap(), Ai = new WeakSet(), Un = function(t) {\n  const { text: e } = t;\n  if (!e)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = H(this, cr).call(this, t);\n  delete t.text, this.val.getVal(\"tmp:sn.skip.enabled\") ? t.wait = 0 : \"wait\" in t && argChk_Num(t, \"wait\", NaN), H(this, sr).call(this, \"add\\uFF5C\" + JSON.stringify(t), o);\n  const R = argChk_Boolean(t, \"record\", !0), N = this.val.doRecLog();\n  return R || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", R), o.tagCh(e.replaceAll(\"[r]\", `\n`)), R || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", N), H(this, sr).call(this, \"add_close\\uFF5C\", o), !1;\n}, cr = new WeakMap(), il = new WeakSet(), Dc = function(t) {\n  const e = at(this, Ni, Hn).call(this, t, H(this, Cr)), R = H(this, Kt)[e].getPage(t);\n  if (!(R instanceof TxtLayer))\n    throw e + \"\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return R;\n}, Fs = new WeakMap(), nl = new WeakSet(), Lc = function(t) {\n  const { layer: e } = t;\n  if (!e)\n    throw \"[current] layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (et(this, kr, H(this, Kt)[e]), !(H(this, kr).getPage(t) instanceof TxtLayer))\n    throw `${e}\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  return this.recText(\"\", !0), et(this, Cr, e), this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", e), at(this, Ge, Je).call(this).forEach((o) => {\n    const R = H(this, Kt)[o];\n    R.fore instanceof TxtLayer && (R.fore.isCur = R.back.isCur = o === e);\n  }), !1;\n}, kr = new WeakMap(), Oi = new WeakMap(), Ni = new WeakSet(), Hn = function(t, e = \"\") {\n  var R;\n  const o = (R = t.layer) != null ? R : e;\n  if (o.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (!(o in H(this, Kt)))\n    throw \"\\u5C5E\\u6027 layer\\u3010\" + o + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return t.layer = o;\n}, Ir = new WeakMap(), wr = new WeakMap(), sl = new WeakSet(), Fc = function(t) {\n  const e = H(this, cr).call(this, t);\n  return t.layer === H(this, Cr) && t.page === \"fore\" && this.recText(\"\", !0), e.clearText(), !1;\n}, al = new WeakSet(), Bc = function(t) {\n  return H(this, sr).call(this, \"endlink\\uFF5C\", H(this, cr).call(this, t)), !1;\n}, ol = new WeakSet(), $c = function(t) {\n  return argChk_Boolean(t, \"rec_page_break\", !0) && this.recText(\"\", !0), H(this, kr) && (H(this, kr).fore.clearLay(t), H(this, kr).back.clearLay(t)), !1;\n}, ul = new WeakSet(), kc = function(t) {\n  if (!t.pic)\n    throw \"[graph] pic\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return t.text = \"\\uFF5C\\u3000\\u300Agrp\\uFF5C\" + JSON.stringify(t) + \"\\u300B\", at(this, Ai, Un).call(this, t);\n}, ll = new WeakSet(), Gc = function(t) {\n  var e, o, R;\n  return (e = t.style) != null || (t.style = \"background-color: rgba(255,0,0,0.5);\"), (o = t.style_hover) != null || (t.style_hover = \"background-color: rgba(255,0,0,0.9);\"), (R = t.style_clicked) != null || (t.style_clicked = t.style), H(this, sr).call(this, \"link\\uFF5C\" + JSON.stringify(t), H(this, cr).call(this, t)), !1;\n}, hl = new WeakSet(), Uc = function(t) {\n  return t.text = `\n`, at(this, Ai, Un).call(this, t);\n}, cl = new WeakSet(), Hc = function() {\n  return this.recText(`\n`), !1;\n}, fl = new WeakSet(), zc = function(t) {\n  var e;\n  return et(this, Ir, t), this.recText((e = t.text) != null ? e : \"\"), !1;\n}, dl = new WeakSet(), jc = function(t) {\n  var e;\n  return et(this, wr, []), et(this, Ir, { text: (e = t.text) != null ? e : \"\" }), this.val.setVal_Nochk(\n    \"save\",\n    \"const.sn.sLog\",\n    t.text ? `[{text:\"${t.text}\"}]` : \"[]\"\n  ), !1;\n}, pl = new WeakSet(), Vc = function(t) {\n  const { t: e, r: o } = t;\n  if (!e)\n    throw \"[ruby2] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!o)\n    throw \"[ruby2] r\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return t.text = \"\\uFF5C\" + e + \"\\u300A\" + o + \"\\u300B\", at(this, Ai, Un).call(this, t);\n}, vl = new WeakSet(), Xc = function(t) {\n  return H(this, sr).call(this, \"span\\uFF5C\" + JSON.stringify(t), H(this, cr).call(this, t)), !1;\n}, gl = new WeakSet(), Wc = function(t) {\n  if (!t.t)\n    throw \"[tcy] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return t.text = \"\\uFF5C\\u3000\\u300Atcy\\uFF5C\" + JSON.stringify(t) + \"\\u300B\", at(this, Ai, Un).call(this, t);\n}, _l = new WeakSet(), Yc = function(t) {\n  return console.group(\"\\u{1F95F} [dump_lay]\"), at(this, Ge, Je).call(this, t.layer).forEach((e) => {\n    const o = H(this, Kt)[e];\n    try {\n      console.info(\n        `%c${o.fore.name.slice(0, -7)} %o`,\n        `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`,\n        JSON.parse(`{\"back\":{${o.back.dump()}}, \"fore\":{${o.fore.dump()}}}`)\n      );\n    } catch (R) {\n      console.error(\"dump_lay err:%o\", R), console.error(`   back:${o.back.dump()}`), console.error(`   fore:${o.fore.dump()}`);\n    }\n  }), console.groupEnd(), !1;\n}, ml = new WeakSet(), qc = function(t) {\n  const e = at(this, Ni, Hn).call(this, t, H(this, Cr)), o = argChk_Boolean(t, \"enabled\", !0);\n  return H(this, cr).call(this, t).enabled = o, this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + e + \".enabled\", o), !1;\n}, yl = new WeakSet(), Zc = function(t) {\n  var e, o, R;\n  return Pages.argChk_page(t, \"back\"), (e = t.clicksebuf) != null || (t.clicksebuf = \"SYS\"), (o = t.entersebuf) != null || (t.entersebuf = \"SYS\"), (R = t.leavesebuf) != null || (t.leavesebuf = \"SYS\"), t.fn || (t.fn = this.scrItr.scriptFn), H(this, cr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;\n}, it(LayerMng, Pi, 10);\nvar me, ce, bl, Kc, uo, _n, ma;\nclass FocusMng {\n  constructor() {\n    it(this, bl);\n    it(this, _n);\n    it(this, me, []);\n    it(this, ce, -1);\n    it(this, uo, CmnLib.debugLog ? (t) => console.log(`\\u{1F47E} <FocusMng idx:${t} btn:%o`, H(this, me)[t].btn) : () => {\n    });\n  }\n  destroy() {\n    et(this, me, []), et(this, ce, -1);\n  }\n  add(t, e, o) {\n    var D;\n    if (H(this, me).findIndex((L) => L.btn === t) >= 0)\n      return;\n    if (t instanceof Container) {\n      t.on(\"pointerdown\", () => {\n        for (let L = H(this, me).length - 1; L >= 0; --L)\n          if (H(this, me)[L].btn === t) {\n            et(this, ce, L);\n            return;\n          }\n        et(this, ce, -1);\n      }), H(this, me).push({ btn: t, on: e, off: o });\n      return;\n    }\n    t.addEventListener(\"focus\", () => {\n      for (let L = H(this, me).length - 1; L >= 0; --L)\n        if (H(this, me)[L].btn === t) {\n          et(this, ce, L);\n          return;\n        }\n      et(this, ce, -1);\n    });\n    let R = (L) => {\n    }, N = t.localName === \"button\" || t.localName === \"a\" ? (L) => !L.isTrusted && L.key === \"Enter\" : (L) => L.key === \"Enter\";\n    const M = t;\n    switch ((D = M.type) != null ? D : \"\") {\n      case \"checkbox\":\n        R = () => M.checked = !M.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (R = (L) => at(this, bl, Kc).call(this, t, L.key), N = () => !1);\n        break;\n      case \"range\":\n        R = (L) => {\n          L.isTrusted || (L.key === \"ArrowUp\" ? M.stepUp() : M.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        R = (L) => {\n          var $;\n          if (L.isTrusted)\n            return;\n          let B = (($ = M.selectionStart) != null ? $ : 0) + (L.key === \"ArrowUp\" ? -1 : 1);\n          B < 0 && (B = 0), M.setSelectionRange(B, B);\n        };\n        break;\n    }\n    t.addEventListener(\"keydown\", (L) => {\n      if (!(L.key !== \"ArrowUp\" && L.key !== \"ArrowDown\" && L.key !== \"Enter\")) {\n        if (L.stopPropagation(), L.stopImmediatePropagation(), N(L)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        R(L);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), H(this, me).push({ btn: t, on: e, off: o });\n  }\n  remove(t) {\n    const e = H(this, me).findIndex((o) => o.btn === t);\n    e < 0 || (H(this, me).splice(e, 1), H(this, me).length === 0 ? et(this, ce, -1) : e <= H(this, ce) && --Re(this, ce)._);\n  }\n  isFocus(t) {\n    return H(this, ce) < 0 ? !1 : H(this, me)[H(this, ce)].btn === t;\n  }\n  prev() {\n    at(this, _n, ma).call(this);\n    const t = H(this, me).length;\n    if (t !== 0) {\n      --Re(this, ce)._ < 0 && et(this, ce, t - 1);\n      for (let e = t; e >= 1; --e) {\n        const o = (H(this, ce) + e) % t;\n        if (H(this, me)[o].on()) {\n          et(this, ce, o), H(this, uo).call(this, o);\n          return;\n        }\n      }\n      et(this, ce, -1);\n    }\n  }\n  next() {\n    at(this, _n, ma).call(this);\n    const t = H(this, me).length;\n    if (t !== 0) {\n      ++Re(this, ce)._ >= t && et(this, ce, 0);\n      for (let e = 0; e < t; ++e) {\n        const o = (H(this, ce) + e) % t;\n        if (H(this, me)[o].on()) {\n          et(this, ce, o), H(this, uo).call(this, o);\n          return;\n        }\n      }\n      et(this, ce, -1);\n    }\n  }\n  getFocus() {\n    if (H(this, ce) < 0)\n      return;\n    at(this, _n, ma).call(this), H(this, ce) >= H(this, me).length && et(this, ce, 0);\n    const t = H(this, me)[H(this, ce)];\n    return t.on() ? t.btn : void 0;\n  }\n  blur() {\n    at(this, _n, ma).call(this), et(this, ce, -1), globalThis.focus();\n  }\n}\nme = new WeakMap(), ce = new WeakMap(), bl = new WeakSet(), Kc = function(t, e) {\n  const o = t.querySelectorAll(\"input[type]\"), R = o.length;\n  for (let N = 0; N < R; ++N)\n    if (!!o[N].checked) {\n      o[(N + R + (e === \"ArrowUp\" ? -1 : 1)) % R].checked = !0;\n      break;\n    }\n}, uo = new WeakMap(), _n = new WeakSet(), ma = function() {\n  for (let t = H(this, me).length - 1; t >= 0; --t) {\n    const e = H(this, me)[t];\n    !(e.btn instanceof Container) || e.btn.parent ? e.off() : H(this, me).splice(t, 1);\n  }\n};\nvar top = \"top\", bottom = \"bottom\", right = \"right\", left = \"left\", auto = \"auto\", basePlacements = [top, bottom, right, left], start = \"start\", end = \"end\", clippingParents = \"clippingParents\", viewport = \"viewport\", popper = \"popper\", reference = \"reference\", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(n, t) {\n  return n.concat([t + \"-\" + start, t + \"-\" + end]);\n}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(n, t) {\n  return n.concat([t, t + \"-\" + start, t + \"-\" + end]);\n}, []), beforeRead = \"beforeRead\", read$6 = \"read\", afterRead = \"afterRead\", beforeMain = \"beforeMain\", main$1 = \"main\", afterMain = \"afterMain\", beforeWrite = \"beforeWrite\", write$6 = \"write\", afterWrite = \"afterWrite\", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];\nfunction getNodeName(n) {\n  return n ? (n.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(n) {\n  if (n == null)\n    return window;\n  if (n.toString() !== \"[object Window]\") {\n    var t = n.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return n;\n}\nfunction isElement(n) {\n  var t = getWindow(n).Element;\n  return n instanceof t || n instanceof Element;\n}\nfunction isHTMLElement(n) {\n  var t = getWindow(n).HTMLElement;\n  return n instanceof t || n instanceof HTMLElement;\n}\nfunction isShadowRoot(n) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = getWindow(n).ShadowRoot;\n  return n instanceof t || n instanceof ShadowRoot;\n}\nfunction applyStyles(n) {\n  var t = n.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var o = t.styles[e] || {}, R = t.attributes[e] || {}, N = t.elements[e];\n    !isHTMLElement(N) || !getNodeName(N) || (Object.assign(N.style, o), Object.keys(R).forEach(function(M) {\n      var D = R[M];\n      D === !1 ? N.removeAttribute(M) : N.setAttribute(M, D === !0 ? \"\" : D);\n    }));\n  });\n}\nfunction effect$2(n) {\n  var t = n.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(o) {\n      var R = t.elements[o], N = t.attributes[o] || {}, M = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : e[o]), D = M.reduce(function(L, B) {\n        return L[B] = \"\", L;\n      }, {});\n      !isHTMLElement(R) || !getNodeName(R) || (Object.assign(R.style, D), Object.keys(N).forEach(function(L) {\n        R.removeAttribute(L);\n      }));\n    });\n  };\n}\nconst applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(n) {\n  return n.split(\"-\")[0];\n}\nvar max = Math.max, min = Math.min, round = Math.round;\nfunction getBoundingClientRect(n, t) {\n  t === void 0 && (t = !1);\n  var e = n.getBoundingClientRect(), o = 1, R = 1;\n  if (isHTMLElement(n) && t) {\n    var N = n.offsetHeight, M = n.offsetWidth;\n    M > 0 && (o = round(e.width) / M || 1), N > 0 && (R = round(e.height) / N || 1);\n  }\n  return {\n    width: e.width / o,\n    height: e.height / R,\n    top: e.top / R,\n    right: e.right / o,\n    bottom: e.bottom / R,\n    left: e.left / o,\n    x: e.left / o,\n    y: e.top / R\n  };\n}\nfunction getLayoutRect(n) {\n  var t = getBoundingClientRect(n), e = n.offsetWidth, o = n.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {\n    x: n.offsetLeft,\n    y: n.offsetTop,\n    width: e,\n    height: o\n  };\n}\nfunction contains(n, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (n.contains(t))\n    return !0;\n  if (e && isShadowRoot(e)) {\n    var o = t;\n    do {\n      if (o && n.isSameNode(o))\n        return !0;\n      o = o.parentNode || o.host;\n    } while (o);\n  }\n  return !1;\n}\nfunction getComputedStyle$1(n) {\n  return getWindow(n).getComputedStyle(n);\n}\nfunction isTableElement(n) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(n)) >= 0;\n}\nfunction getDocumentElement(n) {\n  return ((isElement(n) ? n.ownerDocument : n.document) || window.document).documentElement;\n}\nfunction getParentNode(n) {\n  return getNodeName(n) === \"html\" ? n : n.assignedSlot || n.parentNode || (isShadowRoot(n) ? n.host : null) || getDocumentElement(n);\n}\nfunction getTrueOffsetParent(n) {\n  return !isHTMLElement(n) || getComputedStyle$1(n).position === \"fixed\" ? null : n.offsetParent;\n}\nfunction getContainingBlock(n) {\n  var t = navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1, e = navigator.userAgent.indexOf(\"Trident\") !== -1;\n  if (e && isHTMLElement(n)) {\n    var o = getComputedStyle$1(n);\n    if (o.position === \"fixed\")\n      return null;\n  }\n  var R = getParentNode(n);\n  for (isShadowRoot(R) && (R = R.host); isHTMLElement(R) && [\"html\", \"body\"].indexOf(getNodeName(R)) < 0; ) {\n    var N = getComputedStyle$1(R);\n    if (N.transform !== \"none\" || N.perspective !== \"none\" || N.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(N.willChange) !== -1 || t && N.willChange === \"filter\" || t && N.filter && N.filter !== \"none\")\n      return R;\n    R = R.parentNode;\n  }\n  return null;\n}\nfunction getOffsetParent(n) {\n  for (var t = getWindow(n), e = getTrueOffsetParent(n); e && isTableElement(e) && getComputedStyle$1(e).position === \"static\"; )\n    e = getTrueOffsetParent(e);\n  return e && (getNodeName(e) === \"html\" || getNodeName(e) === \"body\" && getComputedStyle$1(e).position === \"static\") ? t : e || getContainingBlock(n) || t;\n}\nfunction getMainAxisFromPlacement(n) {\n  return [\"top\", \"bottom\"].indexOf(n) >= 0 ? \"x\" : \"y\";\n}\nfunction within(n, t, e) {\n  return max(n, min(t, e));\n}\nfunction withinMaxClamp(n, t, e) {\n  var o = within(n, t, e);\n  return o > e ? e : o;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(n) {\n  return Object.assign({}, getFreshSideObject(), n);\n}\nfunction expandToHashMap(n, t) {\n  return t.reduce(function(e, o) {\n    return e[o] = n, e;\n  }, {});\n}\nvar toPaddingObject = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, mergePaddingObject(typeof t != \"number\" ? t : expandToHashMap(t, basePlacements));\n};\nfunction arrow(n) {\n  var t, e = n.state, o = n.name, R = n.options, N = e.elements.arrow, M = e.modifiersData.popperOffsets, D = getBasePlacement(e.placement), L = getMainAxisFromPlacement(D), B = [left, right].indexOf(D) >= 0, $ = B ? \"height\" : \"width\";\n  if (!(!N || !M)) {\n    var k = toPaddingObject(R.padding, e), U = getLayoutRect(N), z = L === \"y\" ? top : left, X = L === \"y\" ? bottom : right, V = e.rects.reference[$] + e.rects.reference[L] - M[L] - e.rects.popper[$], W = M[L] - e.rects.reference[L], Y = getOffsetParent(N), q = Y ? L === \"y\" ? Y.clientHeight || 0 : Y.clientWidth || 0 : 0, Z = V / 2 - W / 2, K = k[z], Q = q - U[$] - k[X], J = q / 2 - U[$] / 2 + Z, rt = within(K, J, Q), tt = L;\n    e.modifiersData[o] = (t = {}, t[tt] = rt, t.centerOffset = rt - J, t);\n  }\n}\nfunction effect$1(n) {\n  var t = n.state, e = n.options, o = e.element, R = o === void 0 ? \"[data-popper-arrow]\" : o;\n  if (R != null && !(typeof R == \"string\" && (R = t.elements.popper.querySelector(R), !R))) {\n    if ( true && (isHTMLElement(R) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !contains(t.elements.popper, R)) {\n       true && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = R;\n  }\n}\nconst arrow$1 = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(n) {\n  return n.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(n) {\n  var t = n.x, e = n.y, o = window, R = o.devicePixelRatio || 1;\n  return {\n    x: round(t * R) / R || 0,\n    y: round(e * R) / R || 0\n  };\n}\nfunction mapToStyles(n) {\n  var t, e = n.popper, o = n.popperRect, R = n.placement, N = n.variation, M = n.offsets, D = n.position, L = n.gpuAcceleration, B = n.adaptive, $ = n.roundOffsets, k = n.isFixed, U = M.x, z = U === void 0 ? 0 : U, X = M.y, V = X === void 0 ? 0 : X, W = typeof $ == \"function\" ? $({\n    x: z,\n    y: V\n  }) : {\n    x: z,\n    y: V\n  };\n  z = W.x, V = W.y;\n  var Y = M.hasOwnProperty(\"x\"), q = M.hasOwnProperty(\"y\"), Z = left, K = top, Q = window;\n  if (B) {\n    var J = getOffsetParent(e), rt = \"clientHeight\", tt = \"clientWidth\";\n    if (J === getWindow(e) && (J = getDocumentElement(e), getComputedStyle$1(J).position !== \"static\" && D === \"absolute\" && (rt = \"scrollHeight\", tt = \"scrollWidth\")), J = J, R === top || (R === left || R === right) && N === end) {\n      K = bottom;\n      var nt = k && J === Q && Q.visualViewport ? Q.visualViewport.height : J[rt];\n      V -= nt - o.height, V *= L ? 1 : -1;\n    }\n    if (R === left || (R === top || R === bottom) && N === end) {\n      Z = right;\n      var st = k && J === Q && Q.visualViewport ? Q.visualViewport.width : J[tt];\n      z -= st - o.width, z *= L ? 1 : -1;\n    }\n  }\n  var ut = Object.assign({\n    position: D\n  }, B && unsetSides), ct = $ === !0 ? roundOffsetsByDPR({\n    x: z,\n    y: V\n  }) : {\n    x: z,\n    y: V\n  };\n  if (z = ct.x, V = ct.y, L) {\n    var dt;\n    return Object.assign({}, ut, (dt = {}, dt[K] = q ? \"0\" : \"\", dt[Z] = Y ? \"0\" : \"\", dt.transform = (Q.devicePixelRatio || 1) <= 1 ? \"translate(\" + z + \"px, \" + V + \"px)\" : \"translate3d(\" + z + \"px, \" + V + \"px, 0)\", dt));\n  }\n  return Object.assign({}, ut, (t = {}, t[K] = q ? V + \"px\" : \"\", t[Z] = Y ? z + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction computeStyles(n) {\n  var t = n.state, e = n.options, o = e.gpuAcceleration, R = o === void 0 ? !0 : o, N = e.adaptive, M = N === void 0 ? !0 : N, D = e.roundOffsets, L = D === void 0 ? !0 : D;\n  if (true) {\n    var B = getComputedStyle$1(t.elements.popper).transitionProperty || \"\";\n    M && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(k) {\n      return B.indexOf(k) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var $ = {\n    placement: getBasePlacement(t.placement),\n    variation: getVariation(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: R,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, $, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: M,\n    roundOffsets: L\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, $, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: L\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: !0\n};\nfunction effect(n) {\n  var t = n.state, e = n.instance, o = n.options, R = o.scroll, N = R === void 0 ? !0 : R, M = o.resize, D = M === void 0 ? !0 : M, L = getWindow(t.elements.popper), B = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return N && B.forEach(function($) {\n    $.addEventListener(\"scroll\", e.update, passive);\n  }), D && L.addEventListener(\"resize\", e.update, passive), function() {\n    N && B.forEach(function($) {\n      $.removeEventListener(\"scroll\", e.update, passive);\n    }), D && L.removeEventListener(\"resize\", e.update, passive);\n  };\n}\nconst eventListeners = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(n) {\n  return n.replace(/left|right|bottom|top/g, function(t) {\n    return hash$1[t];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(n) {\n  return n.replace(/start|end/g, function(t) {\n    return hash[t];\n  });\n}\nfunction getWindowScroll(n) {\n  var t = getWindow(n), e = t.pageXOffset, o = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: o\n  };\n}\nfunction getWindowScrollBarX(n) {\n  return getBoundingClientRect(getDocumentElement(n)).left + getWindowScroll(n).scrollLeft;\n}\nfunction getViewportRect(n) {\n  var t = getWindow(n), e = getDocumentElement(n), o = t.visualViewport, R = e.clientWidth, N = e.clientHeight, M = 0, D = 0;\n  return o && (R = o.width, N = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (M = o.offsetLeft, D = o.offsetTop)), {\n    width: R,\n    height: N,\n    x: M + getWindowScrollBarX(n),\n    y: D\n  };\n}\nfunction getDocumentRect(n) {\n  var t, e = getDocumentElement(n), o = getWindowScroll(n), R = (t = n.ownerDocument) == null ? void 0 : t.body, N = max(e.scrollWidth, e.clientWidth, R ? R.scrollWidth : 0, R ? R.clientWidth : 0), M = max(e.scrollHeight, e.clientHeight, R ? R.scrollHeight : 0, R ? R.clientHeight : 0), D = -o.scrollLeft + getWindowScrollBarX(n), L = -o.scrollTop;\n  return getComputedStyle$1(R || e).direction === \"rtl\" && (D += max(e.clientWidth, R ? R.clientWidth : 0) - N), {\n    width: N,\n    height: M,\n    x: D,\n    y: L\n  };\n}\nfunction isScrollParent(n) {\n  var t = getComputedStyle$1(n), e = t.overflow, o = t.overflowX, R = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + R + o);\n}\nfunction getScrollParent(n) {\n  return [\"html\", \"body\", \"#document\"].indexOf(getNodeName(n)) >= 0 ? n.ownerDocument.body : isHTMLElement(n) && isScrollParent(n) ? n : getScrollParent(getParentNode(n));\n}\nfunction listScrollParents(n, t) {\n  var e;\n  t === void 0 && (t = []);\n  var o = getScrollParent(n), R = o === ((e = n.ownerDocument) == null ? void 0 : e.body), N = getWindow(o), M = R ? [N].concat(N.visualViewport || [], isScrollParent(o) ? o : []) : o, D = t.concat(M);\n  return R ? D : D.concat(listScrollParents(getParentNode(M)));\n}\nfunction rectToClientRect(n) {\n  return Object.assign({}, n, {\n    left: n.x,\n    top: n.y,\n    right: n.x + n.width,\n    bottom: n.y + n.height\n  });\n}\nfunction getInnerBoundingClientRect(n) {\n  var t = getBoundingClientRect(n);\n  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;\n}\nfunction getClientRectFromMixedType(n, t) {\n  return t === viewport ? rectToClientRect(getViewportRect(n)) : isElement(t) ? getInnerBoundingClientRect(t) : rectToClientRect(getDocumentRect(getDocumentElement(n)));\n}\nfunction getClippingParents(n) {\n  var t = listScrollParents(getParentNode(n)), e = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(n).position) >= 0, o = e && isHTMLElement(n) ? getOffsetParent(n) : n;\n  return isElement(o) ? t.filter(function(R) {\n    return isElement(R) && contains(R, o) && getNodeName(R) !== \"body\";\n  }) : [];\n}\nfunction getClippingRect(n, t, e) {\n  var o = t === \"clippingParents\" ? getClippingParents(n) : [].concat(t), R = [].concat(o, [e]), N = R[0], M = R.reduce(function(D, L) {\n    var B = getClientRectFromMixedType(n, L);\n    return D.top = max(B.top, D.top), D.right = min(B.right, D.right), D.bottom = min(B.bottom, D.bottom), D.left = max(B.left, D.left), D;\n  }, getClientRectFromMixedType(n, N));\n  return M.width = M.right - M.left, M.height = M.bottom - M.top, M.x = M.left, M.y = M.top, M;\n}\nfunction computeOffsets(n) {\n  var t = n.reference, e = n.element, o = n.placement, R = o ? getBasePlacement(o) : null, N = o ? getVariation(o) : null, M = t.x + t.width / 2 - e.width / 2, D = t.y + t.height / 2 - e.height / 2, L;\n  switch (R) {\n    case top:\n      L = {\n        x: M,\n        y: t.y - e.height\n      };\n      break;\n    case bottom:\n      L = {\n        x: M,\n        y: t.y + t.height\n      };\n      break;\n    case right:\n      L = {\n        x: t.x + t.width,\n        y: D\n      };\n      break;\n    case left:\n      L = {\n        x: t.x - e.width,\n        y: D\n      };\n      break;\n    default:\n      L = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var B = R ? getMainAxisFromPlacement(R) : null;\n  if (B != null) {\n    var $ = B === \"y\" ? \"height\" : \"width\";\n    switch (N) {\n      case start:\n        L[B] = L[B] - (t[$] / 2 - e[$] / 2);\n        break;\n      case end:\n        L[B] = L[B] + (t[$] / 2 - e[$] / 2);\n        break;\n    }\n  }\n  return L;\n}\nfunction detectOverflow(n, t) {\n  t === void 0 && (t = {});\n  var e = t, o = e.placement, R = o === void 0 ? n.placement : o, N = e.boundary, M = N === void 0 ? clippingParents : N, D = e.rootBoundary, L = D === void 0 ? viewport : D, B = e.elementContext, $ = B === void 0 ? popper : B, k = e.altBoundary, U = k === void 0 ? !1 : k, z = e.padding, X = z === void 0 ? 0 : z, V = mergePaddingObject(typeof X != \"number\" ? X : expandToHashMap(X, basePlacements)), W = $ === popper ? reference : popper, Y = n.rects.popper, q = n.elements[U ? W : $], Z = getClippingRect(isElement(q) ? q : q.contextElement || getDocumentElement(n.elements.popper), M, L), K = getBoundingClientRect(n.elements.reference), Q = computeOffsets({\n    reference: K,\n    element: Y,\n    strategy: \"absolute\",\n    placement: R\n  }), J = rectToClientRect(Object.assign({}, Y, Q)), rt = $ === popper ? J : K, tt = {\n    top: Z.top - rt.top + V.top,\n    bottom: rt.bottom - Z.bottom + V.bottom,\n    left: Z.left - rt.left + V.left,\n    right: rt.right - Z.right + V.right\n  }, nt = n.modifiersData.offset;\n  if ($ === popper && nt) {\n    var st = nt[R];\n    Object.keys(tt).forEach(function(ut) {\n      var ct = [right, bottom].indexOf(ut) >= 0 ? 1 : -1, dt = [top, bottom].indexOf(ut) >= 0 ? \"y\" : \"x\";\n      tt[ut] += st[dt] * ct;\n    });\n  }\n  return tt;\n}\nfunction computeAutoPlacement(n, t) {\n  t === void 0 && (t = {});\n  var e = t, o = e.placement, R = e.boundary, N = e.rootBoundary, M = e.padding, D = e.flipVariations, L = e.allowedAutoPlacements, B = L === void 0 ? placements : L, $ = getVariation(o), k = $ ? D ? variationPlacements : variationPlacements.filter(function(X) {\n    return getVariation(X) === $;\n  }) : basePlacements, U = k.filter(function(X) {\n    return B.indexOf(X) >= 0;\n  });\n  U.length === 0 && (U = k,  true && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var z = U.reduce(function(X, V) {\n    return X[V] = detectOverflow(n, {\n      placement: V,\n      boundary: R,\n      rootBoundary: N,\n      padding: M\n    })[getBasePlacement(V)], X;\n  }, {});\n  return Object.keys(z).sort(function(X, V) {\n    return z[X] - z[V];\n  });\n}\nfunction getExpandedFallbackPlacements(n) {\n  if (getBasePlacement(n) === auto)\n    return [];\n  var t = getOppositePlacement(n);\n  return [getOppositeVariationPlacement(n), t, getOppositeVariationPlacement(t)];\n}\nfunction flip(n) {\n  var t = n.state, e = n.options, o = n.name;\n  if (!t.modifiersData[o]._skip) {\n    for (var R = e.mainAxis, N = R === void 0 ? !0 : R, M = e.altAxis, D = M === void 0 ? !0 : M, L = e.fallbackPlacements, B = e.padding, $ = e.boundary, k = e.rootBoundary, U = e.altBoundary, z = e.flipVariations, X = z === void 0 ? !0 : z, V = e.allowedAutoPlacements, W = t.options.placement, Y = getBasePlacement(W), q = Y === W, Z = L || (q || !X ? [getOppositePlacement(W)] : getExpandedFallbackPlacements(W)), K = [W].concat(Z).reduce(function(Rt, Lt) {\n      return Rt.concat(getBasePlacement(Lt) === auto ? computeAutoPlacement(t, {\n        placement: Lt,\n        boundary: $,\n        rootBoundary: k,\n        padding: B,\n        flipVariations: X,\n        allowedAutoPlacements: V\n      }) : Lt);\n    }, []), Q = t.rects.reference, J = t.rects.popper, rt = /* @__PURE__ */ new Map(), tt = !0, nt = K[0], st = 0; st < K.length; st++) {\n      var ut = K[st], ct = getBasePlacement(ut), dt = getVariation(ut) === start, Et = [top, bottom].indexOf(ct) >= 0, vt = Et ? \"width\" : \"height\", _t = detectOverflow(t, {\n        placement: ut,\n        boundary: $,\n        rootBoundary: k,\n        altBoundary: U,\n        padding: B\n      }), St = Et ? dt ? right : left : dt ? bottom : top;\n      Q[vt] > J[vt] && (St = getOppositePlacement(St));\n      var Ft = getOppositePlacement(St), mt = [];\n      if (N && mt.push(_t[ct] <= 0), D && mt.push(_t[St] <= 0, _t[Ft] <= 0), mt.every(function(Rt) {\n        return Rt;\n      })) {\n        nt = ut, tt = !1;\n        break;\n      }\n      rt.set(ut, mt);\n    }\n    if (tt)\n      for (var ht = X ? 3 : 1, pt = function(Lt) {\n        var lt = K.find(function($t) {\n          var Pt = rt.get($t);\n          if (Pt)\n            return Pt.slice(0, Lt).every(function(kt) {\n              return kt;\n            });\n        });\n        if (lt)\n          return nt = lt, \"break\";\n      }, xt = ht; xt > 0; xt--) {\n        var At = pt(xt);\n        if (At === \"break\")\n          break;\n      }\n    t.placement !== nt && (t.modifiersData[o]._skip = !0, t.placement = nt, t.reset = !0);\n  }\n}\nconst flip$1 = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction getSideOffsets(n, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: n.top - t.height - e.y,\n    right: n.right - t.width + e.x,\n    bottom: n.bottom - t.height + e.y,\n    left: n.left - t.width - e.x\n  };\n}\nfunction isAnySideFullyClipped(n) {\n  return [top, right, bottom, left].some(function(t) {\n    return n[t] >= 0;\n  });\n}\nfunction hide(n) {\n  var t = n.state, e = n.name, o = t.rects.reference, R = t.rects.popper, N = t.modifiersData.preventOverflow, M = detectOverflow(t, {\n    elementContext: \"reference\"\n  }), D = detectOverflow(t, {\n    altBoundary: !0\n  }), L = getSideOffsets(M, o), B = getSideOffsets(D, R, N), $ = isAnySideFullyClipped(L), k = isAnySideFullyClipped(B);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: L,\n    popperEscapeOffsets: B,\n    isReferenceHidden: $,\n    hasPopperEscaped: k\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": $,\n    \"data-popper-escaped\": k\n  });\n}\nconst hide$1 = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(n, t, e) {\n  var o = getBasePlacement(n), R = [left, top].indexOf(o) >= 0 ? -1 : 1, N = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: n\n  })) : e, M = N[0], D = N[1];\n  return M = M || 0, D = (D || 0) * R, [left, right].indexOf(o) >= 0 ? {\n    x: D,\n    y: M\n  } : {\n    x: M,\n    y: D\n  };\n}\nfunction offset(n) {\n  var t = n.state, e = n.options, o = n.name, R = e.offset, N = R === void 0 ? [0, 0] : R, M = placements.reduce(function($, k) {\n    return $[k] = distanceAndSkiddingToXY(k, t.rects, N), $;\n  }, {}), D = M[t.placement], L = D.x, B = D.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += L, t.modifiersData.popperOffsets.y += B), t.modifiersData[o] = M;\n}\nconst offset$1 = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(n) {\n  var t = n.state, e = n.name;\n  t.modifiersData[e] = computeOffsets({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(n) {\n  return n === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(n) {\n  var t = n.state, e = n.options, o = n.name, R = e.mainAxis, N = R === void 0 ? !0 : R, M = e.altAxis, D = M === void 0 ? !1 : M, L = e.boundary, B = e.rootBoundary, $ = e.altBoundary, k = e.padding, U = e.tether, z = U === void 0 ? !0 : U, X = e.tetherOffset, V = X === void 0 ? 0 : X, W = detectOverflow(t, {\n    boundary: L,\n    rootBoundary: B,\n    padding: k,\n    altBoundary: $\n  }), Y = getBasePlacement(t.placement), q = getVariation(t.placement), Z = !q, K = getMainAxisFromPlacement(Y), Q = getAltAxis(K), J = t.modifiersData.popperOffsets, rt = t.rects.reference, tt = t.rects.popper, nt = typeof V == \"function\" ? V(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : V, st = typeof nt == \"number\" ? {\n    mainAxis: nt,\n    altAxis: nt\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, nt), ut = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {\n    x: 0,\n    y: 0\n  };\n  if (!!J) {\n    if (N) {\n      var dt, Et = K === \"y\" ? top : left, vt = K === \"y\" ? bottom : right, _t = K === \"y\" ? \"height\" : \"width\", St = J[K], Ft = St + W[Et], mt = St - W[vt], ht = z ? -tt[_t] / 2 : 0, pt = q === start ? rt[_t] : tt[_t], xt = q === start ? -tt[_t] : -rt[_t], At = t.elements.arrow, Rt = z && At ? getLayoutRect(At) : {\n        width: 0,\n        height: 0\n      }, Lt = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject(), lt = Lt[Et], $t = Lt[vt], Pt = within(0, rt[_t], Rt[_t]), kt = Z ? rt[_t] / 2 - ht - Pt - lt - st.mainAxis : pt - Pt - lt - st.mainAxis, Ot = Z ? -rt[_t] / 2 + ht + Pt + $t + st.mainAxis : xt + Pt + $t + st.mainAxis, gt = t.elements.arrow && getOffsetParent(t.elements.arrow), Gt = gt ? K === \"y\" ? gt.clientTop || 0 : gt.clientLeft || 0 : 0, Tt = (dt = ut == null ? void 0 : ut[K]) != null ? dt : 0, bt = St + kt - Tt - Gt, wt = St + Ot - Tt, Mt = within(z ? min(Ft, bt) : Ft, St, z ? max(mt, wt) : mt);\n      J[K] = Mt, ct[K] = Mt - St;\n    }\n    if (D) {\n      var Ct, Zt = K === \"x\" ? top : left, Yt = K === \"x\" ? bottom : right, se = J[Q], ie = Q === \"y\" ? \"height\" : \"width\", Te = se + W[Zt], ge = se - W[Yt], Fe = [top, left].indexOf(Y) !== -1, xe = (Ct = ut == null ? void 0 : ut[Q]) != null ? Ct : 0, de = Fe ? Te : se - rt[ie] - tt[ie] - xe + st.altAxis, ae = Fe ? se + rt[ie] + tt[ie] - xe - st.altAxis : ge, Jt = z && Fe ? withinMaxClamp(de, se, ae) : within(z ? de : Te, se, z ? ae : ge);\n      J[Q] = Jt, ct[Q] = Jt - se;\n    }\n    t.modifiersData[o] = ct;\n  }\n}\nconst preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(n) {\n  return {\n    scrollLeft: n.scrollLeft,\n    scrollTop: n.scrollTop\n  };\n}\nfunction getNodeScroll(n) {\n  return n === getWindow(n) || !isHTMLElement(n) ? getWindowScroll(n) : getHTMLElementScroll(n);\n}\nfunction isElementScaled(n) {\n  var t = n.getBoundingClientRect(), e = round(t.width) / n.offsetWidth || 1, o = round(t.height) / n.offsetHeight || 1;\n  return e !== 1 || o !== 1;\n}\nfunction getCompositeRect(n, t, e) {\n  e === void 0 && (e = !1);\n  var o = isHTMLElement(t), R = isHTMLElement(t) && isElementScaled(t), N = getDocumentElement(t), M = getBoundingClientRect(n, R), D = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, L = {\n    x: 0,\n    y: 0\n  };\n  return (o || !o && !e) && ((getNodeName(t) !== \"body\" || isScrollParent(N)) && (D = getNodeScroll(t)), isHTMLElement(t) ? (L = getBoundingClientRect(t, !0), L.x += t.clientLeft, L.y += t.clientTop) : N && (L.x = getWindowScrollBarX(N))), {\n    x: M.left + D.scrollLeft - L.x,\n    y: M.top + D.scrollTop - L.y,\n    width: M.width,\n    height: M.height\n  };\n}\nfunction order(n) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), o = [];\n  n.forEach(function(N) {\n    t.set(N.name, N);\n  });\n  function R(N) {\n    e.add(N.name);\n    var M = [].concat(N.requires || [], N.requiresIfExists || []);\n    M.forEach(function(D) {\n      if (!e.has(D)) {\n        var L = t.get(D);\n        L && R(L);\n      }\n    }), o.push(N);\n  }\n  return n.forEach(function(N) {\n    e.has(N.name) || R(N);\n  }), o;\n}\nfunction orderModifiers(n) {\n  var t = order(n);\n  return modifierPhases.reduce(function(e, o) {\n    return e.concat(t.filter(function(R) {\n      return R.phase === o;\n    }));\n  }, []);\n}\nfunction debounce(n) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(n());\n      });\n    })), t;\n  };\n}\nfunction format(n) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)\n    e[o - 1] = arguments[o];\n  return [].concat(e).reduce(function(R, N) {\n    return R.replace(/%s/, N);\n  }, n);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction validateModifiers(n) {\n  n.forEach(function(t) {\n    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, o, R) {\n      return R.indexOf(e) === o;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(o) {\n            return '\"' + o + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(o) {\n        n.find(function(R) {\n          return R.name === o;\n        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), o, o));\n      });\n    });\n  });\n}\nfunction uniqueBy(n, t) {\n  var e = /* @__PURE__ */ new Set();\n  return n.filter(function(o) {\n    var R = t(o);\n    if (!e.has(R))\n      return e.add(R), !0;\n  });\n}\nfunction mergeByName(n) {\n  var t = n.reduce(function(e, o) {\n    var R = e[o.name];\n    return e[o.name] = R ? Object.assign({}, R, o, {\n      options: Object.assign({}, R.options, o.options),\n      data: Object.assign({}, R.data, o.data)\n    }) : o, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)\n    t[e] = arguments[e];\n  return !t.some(function(o) {\n    return !(o && typeof o.getBoundingClientRect == \"function\");\n  });\n}\nfunction popperGenerator(n) {\n  n === void 0 && (n = {});\n  var t = n, e = t.defaultModifiers, o = e === void 0 ? [] : e, R = t.defaultOptions, N = R === void 0 ? DEFAULT_OPTIONS : R;\n  return function(D, L, B) {\n    B === void 0 && (B = N);\n    var $ = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, N),\n      modifiersData: {},\n      elements: {\n        reference: D,\n        popper: L\n      },\n      attributes: {},\n      styles: {}\n    }, k = [], U = !1, z = {\n      state: $,\n      setOptions: function(Y) {\n        var q = typeof Y == \"function\" ? Y($.options) : Y;\n        V(), $.options = Object.assign({}, N, $.options, q), $.scrollParents = {\n          reference: isElement(D) ? listScrollParents(D) : D.contextElement ? listScrollParents(D.contextElement) : [],\n          popper: listScrollParents(L)\n        };\n        var Z = orderModifiers(mergeByName([].concat(o, $.options.modifiers)));\n        if ($.orderedModifiers = Z.filter(function(ut) {\n          return ut.enabled;\n        }), \"development\" !== \"production\") {\n          var K = uniqueBy([].concat(Z, $.options.modifiers), function(ut) {\n            var ct = ut.name;\n            return ct;\n          });\n          if (validateModifiers(K), getBasePlacement($.options.placement) === auto) {\n            var Q = $.orderedModifiers.find(function(ut) {\n              var ct = ut.name;\n              return ct === \"flip\";\n            });\n            Q || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var J = getComputedStyle$1(L), rt = J.marginTop, tt = J.marginRight, nt = J.marginBottom, st = J.marginLeft;\n          [rt, tt, nt, st].some(function(ut) {\n            return parseFloat(ut);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return X(), z.update();\n      },\n      forceUpdate: function() {\n        if (!U) {\n          var Y = $.elements, q = Y.reference, Z = Y.popper;\n          if (!areValidElements(q, Z)) {\n             true && console.error(INVALID_ELEMENT_ERROR);\n            return;\n          }\n          $.rects = {\n            reference: getCompositeRect(q, getOffsetParent(Z), $.options.strategy === \"fixed\"),\n            popper: getLayoutRect(Z)\n          }, $.reset = !1, $.placement = $.options.placement, $.orderedModifiers.forEach(function(ut) {\n            return $.modifiersData[ut.name] = Object.assign({}, ut.data);\n          });\n          for (var K = 0, Q = 0; Q < $.orderedModifiers.length; Q++) {\n            if ( true && (K += 1, K > 100)) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n            if ($.reset === !0) {\n              $.reset = !1, Q = -1;\n              continue;\n            }\n            var J = $.orderedModifiers[Q], rt = J.fn, tt = J.options, nt = tt === void 0 ? {} : tt, st = J.name;\n            typeof rt == \"function\" && ($ = rt({\n              state: $,\n              options: nt,\n              name: st,\n              instance: z\n            }) || $);\n          }\n        }\n      },\n      update: debounce(function() {\n        return new Promise(function(W) {\n          z.forceUpdate(), W($);\n        });\n      }),\n      destroy: function() {\n        V(), U = !0;\n      }\n    };\n    if (!areValidElements(D, L))\n      return  true && console.error(INVALID_ELEMENT_ERROR), z;\n    z.setOptions(B).then(function(W) {\n      !U && B.onFirstUpdate && B.onFirstUpdate(W);\n    });\n    function X() {\n      $.orderedModifiers.forEach(function(W) {\n        var Y = W.name, q = W.options, Z = q === void 0 ? {} : q, K = W.effect;\n        if (typeof K == \"function\") {\n          var Q = K({\n            state: $,\n            name: Y,\n            instance: z,\n            options: Z\n          }), J = function() {\n          };\n          k.push(Q || J);\n        }\n      });\n    }\n    function V() {\n      k.forEach(function(W) {\n        return W();\n      }), k = [];\n    }\n    return z;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\");\nvar Gr, Mi, Me, lo, ho, yh, co, bh, fo, Eh, Bs, $s, po, xh, be, fr, ni, si, vo, Di, zn, go, _o, Ue, ks, Gs, mo, El, Jc, yo, mn, xl, Qc, bo, Th, Tl, tf, Eo, Sh, yn, ya, bn, Sl, ef, Cl, rf, dr, Il, nf, wl, sf, Us, eu, Hs, Rl, af, He;\nclass EventMng {\n  constructor(t, e, o, R, N, M, D, L, B) {\n    it(this, ho);\n    it(this, co);\n    it(this, fo);\n    it(this, po);\n    it(this, Di);\n    it(this, El);\n    it(this, xl);\n    it(this, bo);\n    it(this, Tl);\n    it(this, Eo);\n    it(this, yn);\n    it(this, Sl);\n    it(this, Cl);\n    it(this, Il);\n    it(this, wl);\n    it(this, Us);\n    it(this, Rl);\n    it(this, Gr, new EventListenerCtn());\n    it(this, Mi, new GamepadListener({\n      analog: !1,\n      deadZone: 0.3\n    }));\n    it(this, Me, new FocusMng());\n    it(this, lo, (t) => {\n    });\n    it(this, Bs, !1);\n    it(this, $s, !1);\n    it(this, be, {});\n    it(this, fr, {});\n    it(this, ni, !1);\n    it(this, si, !1);\n    it(this, vo, (t) => {\n      var e;\n      return (e = H(this, be)[t]) != null ? e : H(this, fr)[t];\n    });\n    it(this, go, () => {\n      et(this, go, () => {\n      }), this.scrItr.firstWait();\n    });\n    it(this, _o, {\n      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n    });\n    it(this, Ue, void 0);\n    it(this, ks, void 0);\n    it(this, Gs, void 0);\n    it(this, mo, {\n      placement: \"bottom\",\n      fallbackPlacements: [\"top\", \"bottom\"]\n    });\n    it(this, yo, (t, e) => {\n    });\n    it(this, mn, new EventListenerCtn());\n    it(this, bn, () => this.layMng.goTxt());\n    it(this, dr, () => !1);\n    it(this, Hs, () => {\n    });\n    it(this, He, {\n      Alt: 0,\n      Meta: 0,\n      Control: 0,\n      ArrowDown: 0,\n      End: 0,\n      Enter: 0,\n      Escape: 0,\n      \" \": 0,\n      GoBack: 0\n    });\n    var X;\n    if (this.cfg = t, this.hTag = e, this.appPixi = o, this.main = R, this.layMng = N, this.val = M, this.sndMng = D, this.scrItr = L, this.sys = B, e.clear_event = (V) => at(this, xl, Qc).call(this, V), e.event = (V) => at(this, Tl, tf).call(this, V), e.l = (V) => at(this, Sl, ef).call(this, V), e.p = (V) => at(this, Cl, rf).call(this, V), e.s = () => (this.scrItr.recodePage(), at(this, Di, zn).call(this, () => {\n    }, !1, !0), !0), e.set_cancel_skip = () => at(this, Il, nf).call(this), e.set_focus = (V) => at(this, wl, sf).call(this, V), e.wait = (V) => at(this, Us, eu).call(this, V), e.waitclick = () => at(this, Rl, af).call(this), D.setEvtMng(this), L.setOtherObj(this, N), TxtLayer.setEvtMng(R, this, B), N.setEvtMng(this), B.setFire((V, W) => this.fire(V, W)), CmnLib.isDbg) {\n      const V = {\n        pause: () => {\n          if (et(this, ni, !0), !H(this, si))\n            return;\n          const W = {};\n          this.scrItr.recodeDesign(W), this.sys.callHook(\"_enterDesign\", W), this.sys.send2Dbg(\"_enterDesign\", W);\n        },\n        stopOnBreakpoint: () => et(this, ni, !0),\n        stopOnDataBreakpoint: () => et(this, ni, !0),\n        continue: () => et(this, ni, !1),\n        disconnect: () => et(this, ni, !1)\n      };\n      V.attach = V.stopOnEntry = V.stopOnStep = V.stopOnStepIn = V.stopOnStepOut = V.stopOnBackstep = V.pause, B.addHook((W) => {\n        var Y;\n        return (Y = V[W]) == null ? void 0 : Y.call(V);\n      });\n    }\n    addStyle(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`), (X = o.view.parentElement) == null || X.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), et(this, Ue, document.querySelector(\".sn_hint\")), et(this, ks, H(this, Ue).querySelector(\"span\")), et(this, Gs, createPopper(H(this, _o), H(this, Ue))), H(this, Ue).hidden = !0, o.stage.interactive = !0, CmnLib.isMobile ? o.stage.on(\"pointerdown\", (V) => this.fire(\"click\", V)) : H(this, Gr).add(o.stage, \"pointerdown\", (V) => {\n      switch (V.data.button) {\n        case 0:\n          this.fire(\"click\", V);\n          break;\n        case 1:\n          this.fire(\"middleclick\", V);\n          break;\n      }\n    }), H(this, Gr).add(window, \"keydown\", (V) => at(this, ho, yh).call(this, V)), H(this, Gr).add(o.view, \"contextmenu\", (V) => at(this, co, bh).call(this, V));\n    const $ = (V) => {\n      CmnLib.isDarkMode = V.matches, M.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", CmnLib.isDarkMode);\n    }, k = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    $(k), k.addEventListener(\"change\", (V) => {\n      $(V), this.fire(\"sn:chgDarkMode\", V);\n    }), \"WheelEvent\" in window && (H(this, Gr).add(o.view, \"wheel\", (V) => at(this, fo, Eh).call(this, V), { passive: !0 }), et(this, lo, (V) => V.addEventListener(\"wheel\", (W) => at(this, fo, Eh).call(this, W), { passive: !0 })), et(this, yo, (V, W) => V.add(o.view, \"wheel\", (Y) => {\n      Y.isComposing || Y.deltaY <= 0 || (Y.stopPropagation(), W());\n    }))), CmnLib.debugLog && (H(this, Mi).on(\"gamepad:connected\", (V) => console.log(`\\u{1F47A}<'gamepad:connected' index:${V.detail.index} id:${V.detail.gamepad.id}`)), H(this, Mi).on(\"gamepad:disconnected\", (V) => console.log(`\\u{1F47A}<'gamepad:disconnected' index:${V.detail.index} id:${V.detail.gamepad.id}`)));\n    const U = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      \"\",\n      \"ArrowDown\",\n      \"\"\n    ], z = [0, 0];\n    H(this, Mi).on(\"gamepad:axis\", (V) => {\n      if (!document.hasFocus() || V.detail.stick !== 0)\n        return;\n      z[V.detail.axis] = V.detail.value;\n      const W = (z[1] + 1) * 3 + (z[0] + 1), Y = U[W];\n      if (!Y)\n        return;\n      const q = H(this, Me).getFocus();\n      (!q || q instanceof Container ? globalThis : q).dispatchEvent(new KeyboardEvent(\"keydown\", { key: Y, bubbles: !0 })), !(!q || q instanceof Container) && q.getAttribute(\"type\") === \"range\" && q.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n    }), H(this, Mi).on(\"gamepad:button\", (V) => {\n      if (!(!document.hasFocus() || V.detail.value === 0))\n        if (V.detail.button % 2 === 0) {\n          const W = H(this, Me).getFocus();\n          (!W || W instanceof Container ? globalThis : W).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n        } else\n          o.view.dispatchEvent(new Event(\"contextmenu\"));\n    }), H(this, Mi).start(), H(this, Gr).add(window, \"keyup\", (V) => {\n      V.isComposing || V.key in H(this, He) && (H(this, He)[V.key] = 0);\n    }), M.defTmp(\"const.sn.key.alternate\", () => H(this, He).Alt > 0), M.defTmp(\"const.sn.key.command\", () => H(this, He).Meta > 0), M.defTmp(\"const.sn.key.control\", () => H(this, He).Control > 0), M.defTmp(\"const.sn.key.end\", () => H(this, He).End > 0), M.defTmp(\"const.sn.key.escape\", () => H(this, He).Escape > 0), M.defTmp(\"const.sn.key.back\", () => H(this, He).GoBack > 0);\n  }\n  resvFlameEvent(t) {\n    t.addEventListener(\"keydown\", (e) => at(this, ho, yh).call(this, e)), t.addEventListener(\"contextmenu\", (e) => at(this, co, bh).call(this, e)), H(this, lo).call(this, t);\n  }\n  destroy() {\n    H(this, Me).destroy(), H(this, Gr).clear();\n  }\n  fire(t, e) {\n    var N;\n    if (H(this, dr).call(this) || !H(this, si) || H(this, ni))\n      return;\n    const o = t.toLowerCase();\n    if (CmnLib.debugLog && console.log(`\\u{1F47A} fire<(key:\\`${o}\\` type:${e.type} e:%o)`, { ...e }), o === \"enter\") {\n      const M = H(this, Me).getFocus();\n      if (M instanceof Container) {\n        M.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const R = H(this, vo).call(this, o);\n    if (!R) {\n      o.slice(0, 5) === \"swipe\" && globalThis.scrollBy(\n        -e.deltaX,\n        -e.deltaY\n      );\n      return;\n    }\n    o.slice(-5) !== \"wheel\" && ((N = e.preventDefault) == null || N.call(e)), e.stopPropagation(), o.slice(0, 4) !== \"dom=\" && this.layMng.clickTxtLay(), et(this, si, !1), R(e), H(this, Ue).hidden = !0;\n  }\n  popLocalEvts() {\n    const t = H(this, be);\n    return et(this, be, {}), t;\n  }\n  pushLocalEvts(t) {\n    et(this, be, t);\n  }\n  waitEvent(t, e = !0, o = !1) {\n    if (e && o)\n      throw \"canskip\\u3068global\\u3092\\u540C\\u6642\\u306Btrue\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\";\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku)\n        return t(), !1;\n      H(this, dr).call(this);\n    }\n    return at(this, Di, zn).call(this, t, e, o), !0;\n  }\n  unButton(t) {\n    H(this, Me).remove(t);\n  }\n  button(t, e, o, R, N) {\n    var U, z;\n    !t.fn && !t.label && this.main.errScript(\"fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\"), e.interactive = e.buttonMode = !0;\n    const M = (z = (U = t.key) == null ? void 0 : U.toLowerCase()) != null ? z : \" \";\n    t.fn || (t.fn = this.scrItr.scriptFn);\n    const D = argChk_Boolean(t, \"global\", !1);\n    D ? H(this, fr)[M] = () => this.main.resumeByJumpOrCall(t) : H(this, be)[M] = () => this.main.resumeByJumpOrCall(t);\n    const L = e;\n    L.on(\"pointerdown\", (X) => this.fire(M, X));\n    const B = t.hint ? () => at(this, El, Jc).call(this, t, e) : () => {\n    }, $ = () => {\n      o(), H(this, Ue).hidden = !0;\n    }, k = () => (B(), R());\n    if (L.on(\"pointerover\", k), L.on(\"pointerout\", () => {\n      H(this, Me).isFocus(e) ? k() : $();\n    }), L.on(\"pointerdown\", N), L.on(\n      \"pointerup\",\n      CmnLib.isMobile ? $ : () => {\n        H(this, Me).isFocus(e) ? k() : $();\n      }\n    ), H(this, Me).add(e, k, $), t.clickse && (this.cfg.searchPath(t.clickse, Config.EXT_SOUND), L.on(\"pointerdown\", () => {\n      const X = { fn: t.clickse, join: !1 };\n      t.clicksebuf && (X.buf = t.clicksebuf), this.hTag.playse(X);\n    })), t.enterse && (this.cfg.searchPath(t.enterse, Config.EXT_SOUND), L.on(\"pointerover\", () => {\n      const X = { fn: t.enterse, join: !1 };\n      t.entersebuf && (X.buf = t.entersebuf), this.hTag.playse(X);\n    })), t.leavese && (this.cfg.searchPath(t.leavese, Config.EXT_SOUND), L.on(\"pointerout\", () => {\n      const X = { fn: t.leavese, join: !1 };\n      t.leavesebuf && (X.buf = t.leavesebuf), this.hTag.playse(X);\n    })), t.onenter) {\n      const X = M + t.onenter.toLowerCase(), V = { fn: t.fn, label: t.onenter, call: !0, key: X };\n      D ? H(this, fr)[X] = () => this.main.resumeByJumpOrCall(V) : H(this, be)[X] = () => this.main.resumeByJumpOrCall(V), L.on(\"pointerover\", (W) => this.fire(X, W));\n    }\n    if (t.onleave) {\n      const X = M + t.onleave.toLowerCase(), V = { fn: t.fn, label: t.onleave, call: !0, key: X };\n      D ? H(this, fr)[X] = () => this.main.resumeByJumpOrCall(V) : H(this, be)[X] = () => this.main.resumeByJumpOrCall(V), L.on(\"pointerout\", (W) => this.fire(X, W));\n    }\n    this.sndMng.loadAheadSnd(t);\n  }\n  cvsResize() {\n    H(this, Ue).hidden = !0;\n  }\n  waitLimitedEvent(t, e) {\n    H(this, bn).call(this), this.val.saveKidoku();\n    const o = () => {\n      H(this, mn).clear(), e();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n        H(this, dr).call(this);\n      else\n        return o(), !1;\n    return argChk_Boolean(t, \"canskip\", !0) && (H(this, mn).add(window, \"pointerdown\", (R) => {\n      R.stopPropagation(), o();\n    }), H(this, mn).add(window, \"keydown\", (R) => {\n      R.isComposing || (R.stopPropagation(), o());\n    }), H(this, yo).call(this, H(this, mn), o)), !0;\n  }\n  isSkippingByKeyDown() {\n    if (this.scrItr.skip4page)\n      return !0;\n    for (const t in H(this, He))\n      if (H(this, He)[t] === 2)\n        return !0;\n    return !1;\n  }\n}\nGr = new WeakMap(), Mi = new WeakMap(), Me = new WeakMap(), lo = new WeakMap(), ho = new WeakSet(), yh = function(t) {\n  if (t.isComposing)\n    return;\n  t.key in H(this, He) && (H(this, He)[t.key] = t.repeat ? 2 : 1);\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + t.key;\n  this.fire(e, t);\n}, co = new WeakSet(), bh = function(t) {\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(e, t), t.preventDefault();\n}, fo = new WeakSet(), Eh = function(t) {\n  if (t.isComposing)\n    return;\n  if (H(this, Bs)) {\n    et(this, $s, !0);\n    return;\n  }\n  et(this, Bs, !0), at(this, po, xh).call(this);\n  const e = (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\") + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(e, t);\n}, Bs = new WeakMap(), $s = new WeakMap(), po = new WeakSet(), xh = function() {\n  setTimeout(() => {\n    if (H(this, $s)) {\n      et(this, $s, !1), at(this, po, xh).call(this);\n      return;\n    }\n    et(this, Bs, !1);\n  }, 250);\n}, be = new WeakMap(), fr = new WeakMap(), ni = new WeakMap(), si = new WeakMap(), vo = new WeakMap(), Di = new WeakSet(), zn = function(t, e = !0, o = !0) {\n  if (H(this, bn).call(this), this.val.saveKidoku(), e ? H(this, be).click = H(this, be).enter = H(this, be).arrowdown = H(this, be)[\"wheel.y>0\"] = t : (delete H(this, be).click, delete H(this, be).enter, delete H(this, be).arrowdown, delete H(this, be)[\"wheel.y>0\"]), et(this, vo, o ? (R) => {\n    var N;\n    return (N = H(this, be)[R]) != null ? N : H(this, fr)[R];\n  } : (R) => H(this, be)[R]), et(this, si, !0), H(this, go).call(this), CmnLib.debugLog) {\n    const R = /* @__PURE__ */ Object.create(null);\n    R.local = Object.keys(H(this, be)), R.global = Object.keys(H(this, fr)), console.log(\"\\u{1F38D} wait event... %o\", R);\n  }\n}, go = new WeakMap(), _o = new WeakMap(), Ue = new WeakMap(), ks = new WeakMap(), Gs = new WeakMap(), mo = new WeakMap(), El = new WeakSet(), Jc = function(t, e) {\n  var N, M;\n  const o = e instanceof Button ? e.getBtnBounds() : e.getBounds();\n  if (!(t[\":\\u30BF\\u30B0\\u540D\"] === \"link\")) {\n    const D = e.parent.parent;\n    o.x += D.x, o.y += D.y;\n  }\n  if (!t.hint) {\n    H(this, Ue).hidden = !0;\n    return;\n  }\n  H(this, Ue).style.cssText = `position:${H(this, Ue).style.position}; transform:${H(this, Ue).style.transform};` + ((N = t.hint_style) != null ? N : \"\"), H(this, ks).style.cssText = \"\", H(this, ks).textContent = (M = t.hint) != null ? M : \"\";\n  try {\n    const D = t.hint_opt ? { ...H(this, mo), ...JSON.parse(t.hint_opt) } : H(this, mo);\n    H(this, Gs).setOptions(D);\n  } catch (D) {\n    console.error(mesErrJSON(t, \"hint_opt\", D.message));\n  }\n  H(this, _o).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + o.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + o.y * this.sys.cvsScale,\n    width: o.width,\n    height: o.height\n  }), H(this, Gs).update(), H(this, Ue).hidden = !1;\n}, yo = new WeakMap(), mn = new WeakMap(), xl = new WeakSet(), Qc = function(t) {\n  const e = argChk_Boolean(t, \"global\", !1), o = e ? H(this, fr) : H(this, be);\n  for (const R in o)\n    at(this, bo, Th).call(this, R, o[R]);\n  return e ? et(this, fr, {}) : et(this, be, {}), et(this, si, !1), !1;\n}, bo = new WeakSet(), Th = function(t, e) {\n  t.slice(0, 4) === \"dom=\" && at(this, yn, ya).call(this, t).el.forEach((o) => o.removeEventListener(\"click\", e));\n}, Tl = new WeakSet(), tf = function(t) {\n  var M, D;\n  const e = t.key;\n  if (!e)\n    throw \"key\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = e.toLowerCase(), R = argChk_Boolean(t, \"call\", !1), N = argChk_Boolean(t, \"global\", !1) ? H(this, fr) : H(this, be);\n  if (argChk_Boolean(t, \"del\", !1)) {\n    if (t.fn || t.label || R)\n      throw \"fn/label/call\\u3068del\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\";\n    return at(this, bo, Th).call(this, e, N[o]), delete N[o], !1;\n  }\n  if ((M = t.fn) != null || (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === \"dom=\") {\n    const L = at(this, yn, ya).call(this, e);\n    if (L.el.length === 0) {\n      if (argChk_Boolean(t, \"need_err\", !0))\n        throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${L.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n      return !1;\n    }\n    let B = [\"click\", \"keydown\"];\n    switch ((D = L.el[0].type) != null ? D : \"\") {\n      case \"checkbox\":\n        B = [\"input\"];\n        break;\n      case \"range\":\n        B = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        B = [\"input\", \"change\"];\n        break;\n    }\n    B.forEach((k, U) => L.el.forEach((z) => {\n      H(this, Gr).add(z, k, (X) => {\n        if (!H(this, si) || this.layMng.getFrmDisabled(L.id) || k === \"keydown\" && X.key !== \"Enter\")\n          return;\n        const V = z.dataset;\n        for (const W in V)\n          V.hasOwnProperty(W) && this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${W}`, V[W]);\n        this.fire(e, X);\n      }), U === 0 && H(this, Me).add(\n        z,\n        () => at(this, Eo, Sh).call(this, z) ? (z.focus(), !0) : !1,\n        () => {\n        }\n      );\n    }));\n  }\n  return N[o] = () => this.main.resumeByJumpOrCall(t), !1;\n}, Eo = new WeakSet(), Sh = function(t) {\n  if (t.offsetParent === null)\n    return !1;\n  let e = t;\n  do {\n    if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || (e == null ? void 0 : e.disabled))\n      return !1;\n    e = e.parentElement;\n  } while (e !== null);\n  return !0;\n}, yn = new WeakSet(), ya = function(t) {\n  const e = t.indexOf(\":\");\n  let o = \"\";\n  if (e >= 0) {\n    const R = t.slice(4, e), N = `const.sn.frm.${R}`;\n    if (!this.val.getVal(`tmp:${N}`, 0))\n      throw `HTML\\u3010${R}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n    const D = document.getElementById(R).contentWindow;\n    return o = t.slice(e + 1), { el: D.document.querySelectorAll(o), id: R, sel: o };\n  }\n  return o = t.slice(4), { el: document.querySelectorAll(o), id: \"\", sel: o };\n}, bn = new WeakMap(), Sl = new WeakSet(), ef = function(t) {\n  if (this.scrItr.skip4page)\n    return !1;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\"))\n    return H(this, bn).call(this), !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      H(this, dr).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return !1;\n  }\n  return this.val.getVal(\"tmp:sn.auto.enabled\") ? at(this, Us, eu).call(this, {\n    time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n  }) : (argChk_Boolean(t, \"visible\", !0) && this.layMng.breakLine(), at(this, Di, zn).call(this, () => this.main.resume()), !0);\n}, Cl = new WeakSet(), rf = function(t) {\n  if (this.scrItr.recodePage(), this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      H(this, dr).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\")\n      return H(this, bn).call(this), !1;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return at(this, Us, eu).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  argChk_Boolean(t, \"visible\", !0) && this.layMng.breakPage();\n  const e = () => {\n    this.sndMng.clearCache(), this.main.resume();\n  };\n  return at(this, Di, zn).call(this, argChk_Boolean(t, \"er\", !1) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(t), e();\n  } : e), !0;\n}, dr = new WeakMap(), Il = new WeakSet(), nf = function() {\n  return et(this, dr, () => (et(this, dr, () => !1), this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", !0), this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", !1), this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", !1), this.layMng.setNormalChWait(), H(this, Hs).call(this), !0)), !1;\n}, wl = new WeakSet(), sf = function(t) {\n  const { add: e, del: o, to: R } = t;\n  if ((e == null ? void 0 : e.slice(0, 4)) === \"dom=\") {\n    const N = at(this, yn, ya).call(this, e);\n    if (N.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${N.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    return N.el.forEach((M) => H(this, Me).add(\n      M,\n      () => at(this, Eo, Sh).call(this, M) ? (M.focus(), !0) : !1,\n      () => {\n      }\n    )), !1;\n  }\n  if ((o == null ? void 0 : o.slice(0, 4)) === \"dom=\") {\n    const N = at(this, yn, ya).call(this, o);\n    if (N.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${N.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    return N.el.forEach((M) => H(this, Me).remove(M)), !1;\n  }\n  if (!R)\n    throw \"[set_focus] add \\u304B to \\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  switch (R) {\n    case \"null\":\n      H(this, Me).blur();\n      break;\n    case \"next\":\n      H(this, Me).next();\n      break;\n    case \"prev\":\n      H(this, Me).prev();\n      break;\n  }\n  return !1;\n}, Us = new WeakSet(), eu = function(t) {\n  const e = argChk_Num(t, \"time\", NaN);\n  if (this.scrItr.skip4page)\n    return !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n    return !this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku && H(this, dr).call(this), !1;\n  this.val.getVal(\"tmp:sn.auto.enabled\") && et(this, Hs, () => {\n    this.scrItr.subIdxToken(), o.end();\n  });\n  const o = new Tween({}).to({}, e).onComplete(() => {\n    et(this, Hs, () => {\n    }), o.stop(), this.main.resume();\n  }).start();\n  return this.waitEvent(\n    () => o.end(),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, Hs = new WeakMap(), Rl = new WeakSet(), af = function() {\n  return this.scrItr.skip4page ? !1 : ((this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\")) && H(this, dr).call(this), at(this, Di, zn).call(this, () => this.main.resume()), !0);\n}, He = new WeakMap();\nclass CallStack {\n  constructor(t = \"\", e = 0, o = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    this.fn = t, this.idx = e, this.csArg = o, this.toString = () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`;\n  }\n}\nvar Vt, Qt, Ut, he, le, ai, xo, Ch, Li, En, Pl, oi, To, Ih, So, wh, zs, Fi, jn, xn, ba, Tn, ui, Ee, Al, of, Sn, Ea, Ol, uf, js, Vs, ar, Nl, lf, Ml, hf, li, Vi, Dl, cf, Bi, $i, Xs, Ws, Ys, Ye, Ll, ff, Fl, df, Bl, pf, Co, Rh, $l, vf, kl, gf, Gl, _f, Io, Ph, qs, Cn, xa, ki, Gi, Vn, wo, Ah, Zs, Ro, Oh, Po, Ao, Ks, Ui, Js, Ul, mf, ze, Hl, yf, Oo, Nh, No, Mo, Do, zl, bf, Ur, Lo, Mh, jl, Ef, Vl, xf, Xl, Tf, Qs, In, Wl, Sf, ta, ru, wn, Yl, Cf, pr, ql, If, ea, iu, Zl, wf, vr, Ae;\nconst Qe = class {\n  constructor(t, e, o, R, N, M, D, L, B) {\n    it(this, xo);\n    it(this, To);\n    it(this, So);\n    it(this, Fi);\n    it(this, xn);\n    it(this, Al);\n    it(this, Sn);\n    it(this, Ol);\n    it(this, Nl);\n    it(this, Ml);\n    it(this, li);\n    it(this, Dl);\n    it(this, Ll);\n    it(this, Fl);\n    it(this, Bl);\n    it(this, Co);\n    it(this, $l);\n    it(this, kl);\n    it(this, Gl);\n    it(this, Io);\n    it(this, Cn);\n    it(this, Gi);\n    it(this, wo);\n    it(this, Ro);\n    it(this, Ul);\n    it(this, Hl);\n    it(this, Oo);\n    it(this, zl);\n    it(this, Lo);\n    it(this, jl);\n    it(this, Vl);\n    it(this, Xl);\n    it(this, Wl);\n    it(this, ta);\n    it(this, Yl);\n    it(this, ql);\n    it(this, ea);\n    it(this, Zl);\n    it(this, Vt, void 0);\n    it(this, Qt, void 0);\n    it(this, Ut, void 0);\n    it(this, he, void 0);\n    it(this, le, void 0);\n    it(this, ai, void 0);\n    it(this, Li, void 0);\n    it(this, En, void 0);\n    it(this, oi, void 0);\n    it(this, zs, void 0);\n    it(this, Ee, void 0);\n    it(this, js, void 0);\n    it(this, Vs, void 0);\n    it(this, ar, void 0);\n    it(this, Bi, void 0);\n    it(this, $i, void 0);\n    it(this, Xs, void 0);\n    it(this, Ws, void 0);\n    it(this, Ys, void 0);\n    it(this, Ye, void 0);\n    it(this, qs, void 0);\n    it(this, ki, void 0);\n    it(this, Zs, void 0);\n    it(this, Po, void 0);\n    it(this, Ao, void 0);\n    it(this, Ks, void 0);\n    it(this, Ui, void 0);\n    it(this, Js, void 0);\n    it(this, ze, void 0);\n    it(this, No, void 0);\n    it(this, Mo, void 0);\n    it(this, Do, void 0);\n    it(this, Ur, void 0);\n    it(this, Qs, void 0);\n    it(this, In, void 0);\n    it(this, wn, void 0);\n    it(this, pr, void 0);\n    it(this, vr, void 0);\n    it(this, Ae, void 0);\n    if (this.cfg = t, this.hTag = e, this.main = o, this.val = R, this.alzTagArg = N, this.runAnalyze = M, this.prpPrs = D, this.sndMng = L, this.sys = B, et(this, Vt, { aToken: [\"\"], len: 1, aLNum: [1] }), et(this, Qt, \"\"), et(this, Ut, 0), et(this, he, 0), this.addLineNum = ($) => et(this, he, H(this, he) + $), et(this, le, []), et(this, ai, new Grammar()), this.firstWait = () => {\n    }, et(this, Li, {\n      disconnect: () => {\n        et(Qe, Tn, {}), et(Qe, ui, {}), this.isBreak = () => !1, H(this, Li).continue({}), et(this, Ee, 0);\n      },\n      restart: () => this.isBreak = () => !1,\n      add_break: ($) => at(this, xo, Ch).call(this, $.fn, $.o),\n      data_break: ($) => {\n        H(this, Ee) === 0 && (et(this, Ee, 1), this.main.setLoop(!1, `\\u5909\\u6570 ${$.dataId}\\u3010${$.old_v}\\u3011\\u2192\\u3010${$.new_v}\\u3011\\u30C7\\u30FC\\u30BF\\u30D6\\u30EC\\u30FC\\u30AF`), this.sys.callHook(\"stopOnDataBreakpoint\", {}), this.sys.send2Dbg(\"stopOnDataBreakpoint\", {}));\n      },\n      set_func_break: ($) => {\n        et(Qe, ui, {}), $.a.forEach((k) => H(Qe, ui)[k.name] = 1), this.sys.send2Dbg($.ri, {});\n      },\n      stack: ($) => this.sys.send2Dbg($.ri, { a: at(this, Ol, uf).call(this) }),\n      eval: ($) => {\n        this.sys.send2Dbg($.ri, { v: this.prpPrs.parse($.txt) });\n      },\n      continue: () => {\n        at(this, xn, ba).call(this) || (et(this, Ut, H(this, Ut) - H(this, Fi, jn)), et(this, Ee, 3), this.main.setLoop(!0), this.main.resume());\n      },\n      stepover: ($) => at(this, To, Ih).call(this, $),\n      stepin: () => {\n        if (at(this, xn, ba).call(this))\n          return;\n        const $ = H(this, Vt).aToken[H(this, Ut) - H(this, Fi, jn)];\n        this.sys.callHook(`stopOnStep${H(this, In).test($) ? \"In\" : \"\"}`, {}), et(this, Ut, H(this, Ut) - H(this, Fi, jn)), et(this, Ee, H(this, Ee) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();\n      },\n      stepout: ($) => {\n        at(this, xn, ba).call(this) || (H(this, le).length > 0 ? at(this, So, wh).call(this, !0) : at(this, To, Ih).call(this, $));\n      },\n      pause: () => {\n        et(this, Ee, 4), this.main.setLoop(!1, \"\\u4E00\\u6642\\u505C\\u6B62\"), this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        et(this, Ee, 4), this.main.setLoop(!1, \"\\u4E00\\u6642\\u505C\\u6B62\"), this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    }), et(this, En, ($) => this.cfg.searchPath($, Config.EXT_SCRIPT)), et(this, oi, ($) => (this.sys.pathBaseCnvSnPath4Dbg + H(this, En).call(this, $)).replace(H(Qe, Pl), `$1/prj/$2/${H(this, Qt)}$3`)), this.cnvPath4Dbg = ($) => this.sys.pathBaseCnvSnPath4Dbg + $.replace(\"/crypto_prj/\", \"/prj/\"), et(this, zs, 0), et(this, Ee, 0), this.isBreak = ($) => !1, et(this, js, ($) => {\n    }), et(this, Bi, () => {\n    }), et(this, $i, () => {\n    }), et(this, Xs, \"\"), et(this, Ws, {}), this.noticeBreak = ($) => {\n    }, et(this, Ys, 5), et(this, Ye, [-1]), et(this, qs, \"\"), et(this, ki, \"\"), this.nextToken = () => \"\", et(this, Zs, ($) => {\n    }), et(this, Po, /(\\*{2,})(.*)/), et(this, Ao, /\\[macro\\s/), et(this, Ks, /\\[endmacro[\\s\\]]/), et(this, Ui, /^\\[let_ml\\s/g), et(this, Js, /^\\[endlet_ml\\s*]/g), et(this, ze, /* @__PURE__ */ Object.create(null)), et(this, No, /^\\[(call|loadplugin)\\s/), et(this, Mo, /\\bfn\\s*=\\s*[^\\s\\]]+/), et(this, Do, () => {\n      for (let $ = H(this, Vt).len - 1; $ >= 0; --$) {\n        const k = H(this, Vt).aToken[$];\n        if (!H(this, No).test(k))\n          continue;\n        const [U, z] = tagToken2Name_Args(k);\n        this.alzTagArg.go(z);\n        const X = this.alzTagArg.hPrm.fn;\n        if (!X)\n          continue;\n        const V = X.val;\n        if (!V || V.slice(-1) !== \"*\")\n          continue;\n        const W = U === \"loadplugin\" ? \"css\" : \"sn\", Y = this.cfg.matchPath(\"^\" + V.slice(0, -1) + \".*\", W);\n        H(this, Vt).aToken.splice($, 1, \"\t\", \"; \" + k), H(this, Vt).aLNum.splice($, 1, NaN, NaN);\n        for (const q of Y) {\n          const Z = k.replace(\n            H(this, Mo),\n            \"fn=\" + decodeURIComponent(getFn(q[W]))\n          );\n          H(this, Vt).aToken.splice($, 0, Z), H(this, Vt).aLNum.splice($, 0, NaN);\n        }\n      }\n      H(this, Vt).len = H(this, Vt).aToken.length;\n    }), et(this, Ur, !1), et(this, Qs, \"call\"), et(this, In, /\\[(call)\\b/), et(this, wn, !1), et(this, pr, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    }), et(this, vr, []), et(this, Ae, -1), e.let_ml = ($) => at(this, Nl, lf).call(this, $), e.dump_stack = () => at(this, Ml, hf).call(this), e.dump_script = ($) => at(this, Dl, cf).call(this, $), e.else = e.elsif = e.endif = () => at(this, Ll, ff).call(this), e.if = ($) => at(this, Fl, df).call(this, $), e.call = ($) => at(this, Bl, pf).call(this, $), e.jump = ($) => at(this, $l, vf).call(this, $), e.page = ($) => at(this, kl, gf).call(this, $), e.pop_stack = ($) => at(this, Gl, _f).call(this, $), e.return = () => at(this, Io, Ph).call(this), e.bracket2macro = ($) => at(this, jl, Ef).call(this, $), e.char2macro = ($) => at(this, Vl, xf).call(this, $), e.endmacro = () => at(this, Io, Ph).call(this), e.macro = ($) => at(this, Xl, Tf).call(this, $), e.load = ($) => at(this, Wl, Sf).call(this, $), e.reload_script = ($) => at(this, Yl, Cf).call(this, $), e.record_place = () => at(this, ql, If).call(this), e.save = ($) => at(this, Zl, wf).call(this, $), t.oCfg.debug.token && et(this, Zs, ($) => console.log(`\\u{1F331} \\u30C8\\u30FC\\u30AF\\u30F3 fn:${H(this, Qt)} idx:${H(this, Ut)} ln:${H(this, he)} token\\u3010${$}\\u3011`)), R.defTmp(\"const.sn.vctCallStk.length\", () => H(this, le).length), H(this, ai).setEscape(t.oCfg.init.escape), CmnLib.isDbg) {\n      B.addHook((k, U) => {\n        var z, X;\n        return (X = (z = H(this, Li))[k]) == null ? void 0 : X.call(z, U);\n      }), this.isBreak = at(this, Al, of);\n      const $ = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        }, this.sys.send2Dbg(\"hi\", {});\n      }, H(this, Li).auth = (k) => {\n        const U = k.hBreakpoint.hFn2hLineBP;\n        for (const z in U)\n          at(this, xo, Ch).call(this, z, U[z]);\n        if (et(Qe, ui, {}), k.hBreakpoint.aFunc.forEach((z) => H(Qe, ui)[z.name] = 1), k.stopOnEntry) {\n          for (; ; ) {\n            let z = this.nextToken();\n            if (!z)\n              break;\n            const X = z.charCodeAt(0);\n            if (X === 91 || X === 38 || X === 42 && z.length === 1)\n              break;\n            X === 10 && et(this, he, H(this, he) + z.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {}), this.analyzeInit = $, this.analyzeInit();\n        } else\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          }, this.analyzeInit = $, this.analyzeInit();\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    t.oCfg.debug.tag && et(this, js, ($) => console.log(`\\u{1F332} \\u30BF\\u30B0\\u89E3\\u6790 fn:${H(this, Qt)} idx:${H(this, Ut)} ln:${H(this, he)} [${$} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return H(this, Qt);\n  }\n  subIdxToken() {\n    --Re(this, Ut)._;\n  }\n  get lineNum() {\n    return H(this, he);\n  }\n  destroy() {\n    this.isBreak = () => !1;\n  }\n  \\u30BF\\u30B0\\u89E3\\u6790(t) {\n    const [e, o] = tagToken2Name_Args(t), R = this.hTag[e];\n    if (!R)\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u3010${e}\\u3011\\u3067\\u3059`;\n    this.alzTagArg.go(o), H(this, js).call(this, e);\n    const N = this.alzTagArg.hPrm;\n    if (N.cond) {\n      const L = N.cond.val;\n      if (!L || L.charAt(0) === \"&\")\n        throw \"\\u5C5E\\u6027cond\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n      const B = this.prpPrs.parse(L), $ = String(B);\n      if ($ === \"null\" || $ === \"undefined\" || !B)\n        return !1;\n    }\n    let M = {};\n    const D = H(this, le).length;\n    if (this.alzTagArg.isKomeParam) {\n      if (D === 0)\n        throw \"\\u5C5E\\u6027\\u300C*\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u306E\\u307F\\u6709\\u52B9\\u3067\\u3059\";\n      M = { ...H(this, le)[H(this, le).length - 1].csArg };\n    }\n    M[\":\\u30BF\\u30B0\\u540D\"] = e;\n    for (const L in N) {\n      let B = N[L].val;\n      if ((B == null ? void 0 : B.charAt(0)) === \"%\") {\n        if (D === 0)\n          throw \"\\u5C5E\\u6027\\u300C%\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u5B9A\\u7FA9\\u5185\\u3067\\u306E\\u307F\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\uFF08\\u305D\\u306E\\u30DE\\u30AF\\u30ED\\u306E\\u5F15\\u6570\\u3092\\u793A\\u3059\\u7C21\\u7565\\u6587\\u6CD5\\u3067\\u3042\\u308B\\u305F\\u3081\\uFF09\";\n        const k = H(this, le)[H(this, le).length - 1].csArg[B.slice(1)];\n        if (k) {\n          M[L] = k;\n          continue;\n        }\n        if (B = N[L].def, B === void 0 || B === \"null\")\n          continue;\n      }\n      if (B = this.prpPrs.getValAmpersand(B != null ? B : \"\"), B !== \"undefined\") {\n        M[L] = B;\n        continue;\n      }\n      const $ = N[L].def;\n      $ !== void 0 && (B = this.prpPrs.getValAmpersand($), B !== \"undefined\" && (M[L] = B));\n    }\n    return R(M);\n  }\n  setOtherObj(t, e) {\n    et(this, Vs, t), et(this, ar, e);\n  }\n  dumpErrForeLine() {\n    var M;\n    if (H(this, Ut) === 0) {\n      console.group(`\\u{1F95F} Error line (from 0 rows before) fn:${H(this, Qt)}`), console.groupEnd();\n      return;\n    }\n    let t = \"\";\n    for (let D = H(this, Ut) - 1; D >= 0 && (t = H(this, Vt).aToken[D] + t, !(((M = t.match(/\\n/g)) != null ? M : []).length >= H(this, Ys))); --D)\n      ;\n    const e = t.split(`\n`).slice(-H(this, Ys)), o = e.length;\n    console.group(`\\u{1F95F} Error line (from ${o} rows before) fn:${H(this, Qt)}`);\n    const R = String(H(this, he)).length, N = at(this, li, Vi).call(this, H(this, Vt), H(this, Ut));\n    for (let D = 0; D < o; ++D) {\n      const L = H(this, he) - o + D + 1, B = `${String(L).padStart(R, \" \")}: %c`, $ = e[D], k = $.length > 75 ? $.slice(0, 75) + \"\\u2026\" : $;\n      D === o - 1 ? console.info(\n        B + k.slice(0, N.col_s) + \"%c\" + k.slice(N.col_s),\n        \"color: black; background-color: skyblue;\",\n        \"color: black; background-color: pink;\"\n      ) : console.info(B + k, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const t = at(this, Ul, mf).call(this, H(this, Vt), Boolean(this.val.getVal(\"mp:const.sn.macro.name\")), H(this, he), H(this, ki), H(this, Ut));\n    et(this, Ut, t.idx), et(this, he, t.ln), this.runAnalyze();\n  }\n  get isKidoku() {\n    return H(this, Ur);\n  }\n  get isNextKidoku() {\n    let t = H(this, Qt), e = H(this, Ut), o = H(this, Vt).len;\n    if (H(this, le).length > 0) {\n      const N = H(this, le)[0];\n      t = N.fn, e = N.idx;\n      const M = H(this, ze)[t];\n      M && (o = M.len);\n    }\n    const R = this.val.getAreaKidoku(t);\n    return !R || e === o ? !1 : R.search(e);\n  }\n  get normalWait() {\n    return H(this, Ur) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return H(this, wn);\n  }\n  recodePage() {\n    if (et(this, wn, !1), !this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: t, idx: e } = at(this, ea, iu).call(this), o = e - 1, R = o + \":\" + t, N = H(this, vr).findIndex((D) => D.key === R);\n    if (N > -1) {\n      et(this, Ae, N);\n      return;\n    }\n    const M = {\n      key: R,\n      fn: t,\n      idx: o,\n      retFn: t,\n      retIdx: 0,\n      retMark: { ...H(this, pr) }\n    };\n    if (H(this, Ae) >= 0) {\n      const D = H(this, vr)[H(this, Ae)];\n      M.retFn = D.fn, M.retIdx = D.idx + 1;\n    }\n    ++Re(this, Ae)._ === H(this, vr).length ? H(this, vr).push(M) : H(this, vr)[H(this, Ae)] = M;\n  }\n  recodeDesign(t) {\n    let e = \"\", o = 0;\n    const R = H(this, le).length;\n    if (t.design_unit && R > 0) {\n      const D = H(this, le)[0];\n      e = D.fn, o = D.idx;\n    } else\n      e = H(this, Qt), o = H(this, Ut);\n    t[\":path\"] = H(this, oi).call(this, e);\n    const N = at(this, li, Vi).call(this, H(this, ze)[e], o);\n    t[\":ln\"] = N.ln, t[\":col_s\"] = N.col_s, t[\":col_e\"] = N.col_e;\n    const M = o - 1;\n    t[\":idx_tkn\"] = M, t[\":token\"] = H(this, ze)[e].aToken[M], this.sys.send2Dbg(\"_recodeDesign\", t);\n  }\n  replace(t, e) {\n    H(this, Vt).aToken[t] = e;\n  }\n};\nlet ScriptIterator = Qe;\nVt = new WeakMap(), Qt = new WeakMap(), Ut = new WeakMap(), he = new WeakMap(), le = new WeakMap(), ai = new WeakMap(), xo = new WeakSet(), Ch = function(t, e) {\n  H(Qe, Tn)[H(this, oi).call(this, t)] = e;\n}, Li = new WeakMap(), En = new WeakMap(), Pl = new WeakMap(), oi = new WeakMap(), To = new WeakSet(), Ih = function(t) {\n  if (at(this, xn, ba).call(this))\n    return;\n  const e = H(this, Vt).aToken[H(this, Ut) - H(this, Fi, jn)];\n  H(this, In).test(e) ? at(this, So, wh).call(this, !1) : (this.sys.callHook(\"stopOnStep\", {}), H(this, Li).stepin(t));\n}, So = new WeakSet(), wh = function(t) {\n  this.sys.callHook(`stopOnStep${t ? \"Out\" : \"\"}`, {}), et(this, zs, H(this, le).length - (t ? 1 : 0)), et(this, Ut, H(this, Ut) - H(this, Fi, jn)), et(this, Ee, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();\n}, zs = new WeakMap(), Fi = new WeakSet(), jn = function() {\n  return H(this, Ee) === 2 || H(this, Ee) === 4 ? 1 : 0;\n}, xn = new WeakSet(), ba = function() {\n  return H(this, Ut) < H(this, Vt).len ? !1 : (this.sys.callHook(\"stopOnEntry\", {}), this.main.setLoop(!1, \"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\"), !0);\n}, Tn = new WeakMap(), ui = new WeakMap(), Ee = new WeakMap(), Al = new WeakSet(), of = function(t) {\n  switch (H(this, Ee)) {\n    case 6:\n      at(this, Sn, Ea).call(this), et(this, Ee, 7);\n      break;\n    case 7:\n      if (H(this, le).length !== H(this, zs))\n        break;\n      return et(this, Ee, 4), this.main.setLoop(!1, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 5:\n      at(this, Sn, Ea).call(this), et(this, Ee, 4);\n      break;\n    case 4:\n      return at(this, Sn, Ea).call(this), this.main.setLoop(!1, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 3:\n      at(this, Sn, Ea).call(this), et(this, Ee, 0);\n      break;\n    default:\n      if (tagToken2Name(t) in H(Qe, ui))\n        return et(this, Ee, 2), this.main.setLoop(!1, `\\u95A2\\u6570 ${t} \\u30D6\\u30EC\\u30FC\\u30AF`), this.sys.callHook(\"stopOnBreakpoint\", {}), this.sys.send2Dbg(\"stopOnBreakpoint\", {}), !0;\n      {\n        const e = H(Qe, Tn)[H(this, oi).call(this, H(this, Qt))];\n        if (!e)\n          break;\n        const o = e[H(this, he)];\n        if (!o)\n          break;\n        if (o.condition) {\n          if (!this.prpPrs.parse(o.condition))\n            break;\n        } else if (\"hitCondition\" in o && --o.hitCondition > 0)\n          break;\n        const R = H(this, Ee) === 0;\n        et(this, Ee, 2), this.main.setLoop(!1, R ? (o.condition ? \"\\u6761\\u4EF6\" : \"\\u30D2\\u30C3\\u30C8\\u30AB\\u30A6\\u30F3\\u30C8\") + \"\\u30D6\\u30EC\\u30FC\\u30AF\" : \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\");\n        const N = R ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(N, {}), this.sys.send2Dbg(N, {});\n      }\n      return !0;\n  }\n  return !1;\n}, Sn = new WeakSet(), Ea = function() {\n  var e;\n  const t = (e = H(Qe, Tn)[getFn(H(this, Qt))]) == null ? void 0 : e[H(this, he)];\n  t != null && t.hitCondition && --t.hitCondition;\n}, Ol = new WeakSet(), uf = function() {\n  var $, k;\n  const t = H(this, Ee) === 3 ? 1 : 0, e = H(this, Vt).aToken[H(this, Ut) - 1 + t], o = H(this, oi).call(this, H(this, Qt)), R = tagToken2Name(e), N = R ? `[${R}]` : e, M = ($ = this.val.getVal(\"mp:const.sn.macro\")) != null ? $ : \"{}\";\n  if (H(this, Ut) === 0)\n    return [{ fn: o, ln: 1, col: 1, nm: N, ma: M }];\n  const D = at(this, li, Vi).call(this, H(this, Vt), H(this, Ut)), L = [{ fn: o, ln: D.ln, col: D.col_s + 1, nm: N, ma: M }], B = H(this, le).length;\n  if (B === 0)\n    return L;\n  for (let U = B - 1; U >= 0; --U) {\n    const z = H(this, le)[U], X = H(this, ze)[z.fn], V = X.aToken[z.idx - 1], W = at(this, li, Vi).call(this, X, z.idx), Y = tagToken2Name(V);\n    L.push({\n      fn: H(this, oi).call(this, z.fn),\n      ln: W.ln,\n      col: W.col_s + 1,\n      nm: Y ? `[${Y}]` : V,\n      ma: (k = z.csArg[\":hMp\"][\"const.sn.macro\"]) != null ? k : \"{}\"\n    });\n  }\n  return L;\n}, js = new WeakMap(), Vs = new WeakMap(), ar = new WeakMap(), Nl = new WeakSet(), lf = function(t) {\n  var N;\n  const { name: e } = t;\n  if (!e)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let o = \"\";\n  const R = H(this, Vt).len;\n  for (; H(this, Ut) < R && (o = H(this, Vt).aToken[H(this, Ut)], o === \"\"); ++Re(this, Ut)._)\n    ;\n  return t.text = o, t.cast = \"str\", this.hTag.let(t), et(this, Ut, H(this, Ut) + 2), et(this, he, H(this, he) + ((N = o.match(/\\n/g)) != null ? N : []).length), !1;\n}, Ml = new WeakSet(), hf = function() {\n  var R;\n  if (H(this, Ut) === 0)\n    return console.group(`\\u{1F95F} [dump_stack] \\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${H(this, Qt)} line:${1} col:${0}`), console.groupEnd(), !1;\n  const t = at(this, li, Vi).call(this, H(this, Vt), H(this, Ut)), e = `\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${H(this, Qt)} line:${t.ln} col:${t.col_s + 1}`;\n  console.group(`\\u{1F95F} [dump_stack] ${e}`);\n  const o = H(this, le).length;\n  if (o > 0) {\n    console.info(e);\n    for (let N = o - 1; N >= 0; --N) {\n      const M = H(this, le)[N], D = M.csArg[\":hMp\"], L = D ? D[\":\\u30BF\\u30B0\\u540D\"] : void 0, B = (R = M.csArg[\":\\u30BF\\u30B0\\u540D\"]) != null ? R : \"\", $ = at(this, li, Vi).call(this, H(this, ze)[M.fn], M.idx);\n      console.info(\n        `${o - N}\\u3064\\u524D\\u306E\\u30B3\\u30FC\\u30EB\\u5143 fn:${M.fn} line:${$.ln} col:${$.col_s + 1}` + (L ? \"\\uFF08[\" + L + \"]\\u30DE\\u30AF\\u30ED\\u5185\\uFF09\" : \" \") + `\\u3067 [${B} ...]\\u3092\\u30B3\\u30FC\\u30EB`\n      );\n    }\n  }\n  return console.groupEnd(), !1;\n}, li = new WeakSet(), Vi = function(t, e) {\n  const o = { ln: 1, col_s: 0, col_e: 0 };\n  if (!t)\n    return o;\n  let R = e - 1;\n  const N = o.ln = t.aLNum[R];\n  for (; t.aLNum[R] === N; ) {\n    if (t.aToken[R].charAt(0) !== `\n`) {\n      const M = t.aToken[R].length;\n      o.col_e > 0 && (o.col_s += M), o.col_e += M;\n    }\n    if (--R < 0)\n      break;\n  }\n  return o;\n}, Dl = new WeakSet(), cf = function(t) {\n  const { set_fnc: e, break_fnc: o } = t;\n  if (!e)\n    throw \"set_fnc\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (et(this, Bi, globalThis[e]), !H(this, Bi)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${e}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    return et(this, Bi, () => {\n    }), !1;\n  }\n  if (this.noticeBreak = (R) => {\n    var N;\n    H(this, Xs) !== H(this, Qt) && (et(this, Xs, H(this, Qt)), H(this, Bi).call(this, H(this, Ws)[H(this, Qt)] = (N = H(this, Ws)[H(this, Qt)]) != null ? N : H(this, Vt).aToken.join(\"\"))), H(this, $i).call(this, H(this, he), R);\n  }, this.noticeBreak(!0), !o)\n    return !1;\n  if (et(this, $i, globalThis[o]), !H(this, $i)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${o}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    et(this, $i, () => {\n    });\n  }\n  return !1;\n}, Bi = new WeakMap(), $i = new WeakMap(), Xs = new WeakMap(), Ws = new WeakMap(), Ys = new WeakMap(), Ye = new WeakMap(), Ll = new WeakSet(), ff = function() {\n  if (H(this, Ye)[0] === -1)\n    throw \"if\\u30D6\\u30ED\\u30C3\\u30AF\\u5185\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return et(this, Ut, H(this, Ye)[0]), H(this, Ye).shift(), !1;\n}, Fl = new WeakSet(), df = function(t) {\n  var L;\n  const { exp: e } = t;\n  if (!e)\n    throw \"exp\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e.charAt(0) === \"&\")\n    throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  let o = 0, R = this.prpPrs.parse(e) ? H(this, Ut) : -1;\n  const N = H(this, Vt).aLNum[H(this, Ut)];\n  let M = H(this, he) - (N || 0);\n  const D = H(this, Vt).len;\n  for (; H(this, Ut) < D; ++Re(this, Ut)._) {\n    const B = H(this, Vt).aLNum[H(this, Ut)];\n    H(this, Vt).aLNum[H(this, Ut)] = (B || 0) + M;\n    const $ = H(this, Vt).aToken[H(this, Ut)];\n    if (!$)\n      continue;\n    const k = $.charCodeAt(0);\n    if (k === 10) {\n      et(this, he, H(this, he) + $.length);\n      continue;\n    }\n    if (k !== 91)\n      continue;\n    const [U, z] = tagToken2Name_Args($);\n    if (!(U in this.hTag))\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0[${U}]\\u3067\\u3059`;\n    switch (this.alzTagArg.go(z), U) {\n      case \"if\":\n        ++o;\n        break;\n      case \"elsif\":\n        if (o > 0 || R > -1)\n          break;\n        const X = (L = this.alzTagArg.hPrm.exp.val) != null ? L : \"\";\n        if (X.charAt(0) === \"&\")\n          throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n        this.prpPrs.parse(X) && (R = H(this, Ut) + 1);\n        break;\n      case \"else\":\n        if (o > 0)\n          break;\n        R === -1 && (R = H(this, Ut) + 1);\n        break;\n      case \"endif\":\n        if (o > 0) {\n          --o;\n          break;\n        }\n        return R === -1 ? (++Re(this, Ut)._, H(this, Vt).aLNum[H(this, Ut)] += M) : (H(this, Ye).unshift(H(this, Ut) + 1), et(this, Ut, R), et(this, he, H(this, Vt).aLNum[H(this, Ut)])), !1;\n    }\n  }\n  throw \"[endif]\\u304C\\u306A\\u3044\\u307E\\u307E\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\";\n}, Bl = new WeakSet(), pf = function(t) {\n  argChk_Boolean(t, \"count\", !1) || at(this, Lo, Mh).call(this);\n  const { fn: e } = t;\n  return e && H(this, En).call(this, e), at(this, Co, Rh).call(this, { \":hEvt1Time\": H(this, Vs).popLocalEvts(), \":hMp\": this.val.cloneMp() }), argChk_Boolean(t, \"clear_local_event\", !1) && this.hTag.clear_event({}), at(this, Gi, Vn).call(this, e, t.label), !0;\n}, Co = new WeakSet(), Rh = function(t) {\n  H(this, Vt).aLNum[H(this, Ut)] = H(this, he), H(this, qs) || (t[\":resvToken\"] = \"\", at(this, Cn, xa).call(this)), H(this, le).push(new CallStack(H(this, Qt), H(this, Ut), t)), H(this, Ye).unshift(-1);\n}, $l = new WeakSet(), vf = function(t) {\n  return argChk_Boolean(t, \"count\", !0) || at(this, Lo, Mh).call(this), H(this, Ye)[0] = -1, at(this, Gi, Vn).call(this, t.fn, t.label), !0;\n}, kl = new WeakSet(), gf = function(t) {\n  if (H(this, Ae) === -1)\n    return !1;\n  if (argChk_Boolean(t, \"clear\", !1))\n    return et(this, vr, []), et(this, Ae, -1), !1;\n  const { to: e } = t;\n  if (!e)\n    throw \"clear\\u304Bto\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = H(this, Ae);\n  switch (e) {\n    case \"prev\":\n      H(this, Ae) > 0 && --Re(this, Ae)._;\n      break;\n    case \"next\":\n      const D = H(this, vr).length;\n      H(this, Ae) < D - 1 && ++Re(this, Ae)._;\n      break;\n    default:\n      throw `\\u5C5E\\u6027to\\u300C${e}\\u300D\\u306F\\u7570\\u5E38\\u3067\\u3059`;\n  }\n  if (o === H(this, Ae))\n    return !1;\n  const R = H(this, vr)[H(this, Ae)], { fn: N, idx: M } = at(this, ea, iu).call(this);\n  return R.key === M + \":\" + N ? !1 : at(this, ta, ru).call(this, { fn: R.retFn, index: R.retIdx }, R.retMark);\n}, Gl = new WeakSet(), _f = function(t) {\n  if (argChk_Boolean(t, \"clear\", !1))\n    et(this, le, []);\n  else if (!H(this, le).pop())\n    throw \"[pop_stack] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  return at(this, Cn, xa).call(this), et(this, Ye, [-1]), this.val.setMp({}), !1;\n}, Io = new WeakSet(), Ph = function() {\n  const t = H(this, le).pop();\n  if (!t)\n    throw \"[return] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  const e = t.csArg;\n  H(this, Ye).shift();\n  const o = e[\":hMp\"];\n  o && this.val.setMp(o);\n  const R = e[\":resvToken\"];\n  return R ? this.nextToken = () => (at(this, Cn, xa).call(this), R) : at(this, Cn, xa).call(this), e[\":hEvt1Time\"] && H(this, Vs).pushLocalEvts(e[\":hEvt1Time\"]), t.fn in H(this, ze) ? (at(this, Oo, Nh).call(this, t), !1) : (at(this, Gi, Vn).call(this, t.fn, \"\", t.idx), !0);\n}, qs = new WeakMap(), Cn = new WeakSet(), xa = function() {\n  et(this, qs, \"\"), this.nextToken = at(this, wo, Ah);\n}, ki = new WeakMap(), Gi = new WeakSet(), Vn = function(t = \"\", e = \"\", o = 0) {\n  if (!t && !e && this.main.errScript(\"[jump\\u7CFB] fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\"), e ? (e.charAt(0) !== \"*\" && this.main.errScript(\"[jump\\u7CFB] label\\u306F*\\u3067\\u59CB\\u307E\\u308A\\u307E\\u3059\"), et(this, ki, e), H(this, ki).slice(0, 2) !== \"**\" && et(this, Ut, o)) : (et(this, ki, \"\"), et(this, Ut, o)), !t) {\n    this.analyzeInit();\n    return;\n  }\n  const R = H(this, En).call(this, t);\n  if (t === H(this, Qt)) {\n    this.analyzeInit();\n    return;\n  }\n  et(this, Qt, t);\n  const N = H(this, ze)[H(this, Qt)];\n  if (N) {\n    et(this, Vt, N), this.analyzeInit();\n    return;\n  }\n  new Loader().add({ name: H(this, Qt), url: R }).use((M, D) => {\n    try {\n      M.data = this.sys.decStr(M.extension, M.data);\n    } catch (L) {\n      this.main.errScript(`[jump\\u7CFB]sn\\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${M.name} ${L}`, !1);\n    }\n    D == null || D();\n  }).load((M, D) => {\n    this.nextToken = at(this, wo, Ah), et(this, he, 1), at(this, Hl, yf).call(this, D[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());\n  }), this.main.stop();\n}, wo = new WeakSet(), Ah = function() {\n  var e, o;\n  if (at(this, Ro, Oh).call(this))\n    return \"\";\n  at(this, zl, bf).call(this), (e = H(this, Vt).aLNum)[o = H(this, Ut)] || (e[o] = H(this, he));\n  const t = H(this, Vt).aToken[H(this, Ut)];\n  return H(this, Zs).call(this, t), ++Re(this, Ut)._, t;\n}, Zs = new WeakMap(), Ro = new WeakSet(), Oh = function() {\n  return H(this, Ut) < H(this, Vt).len ? !1 : (this.main.errScript(\"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\"), !0);\n}, Po = new WeakMap(), Ao = new WeakMap(), Ks = new WeakMap(), Ui = new WeakMap(), Js = new WeakMap(), Ul = new WeakSet(), mf = function(t, e, o, R, N) {\n  var $, k, U, z, X;\n  const M = t.aToken.length;\n  if (!R) {\n    if (at(this, Ro, Oh).call(this))\n      return { idx: N, ln: o };\n    if (t.aLNum[N])\n      o = t.aLNum[N];\n    else {\n      o = 1;\n      for (let V = 0; V < N; ++V) {\n        ($ = t.aLNum)[V] || ($[V] = o);\n        const W = t.aToken[V];\n        W.charCodeAt(0) === 10 ? o += W.length : o += ((k = W.match(/\\n/g)) != null ? k : []).length;\n      }\n      t.aLNum[N] = o;\n    }\n    return { idx: N, ln: o };\n  }\n  t.aLNum[0] = 1;\n  const D = R.match(H(this, Po));\n  if (D) {\n    R = D[1];\n    let V = N;\n    switch (D[2]) {\n      case \"before\":\n        for (; t.aToken[--V] !== R; )\n          V === 0 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \" + o + \"\\u884C\\u76EE\\u4EE5\\u524D\\u3067\" + (e ? \"\\u30DE\\u30AF\\u30ED\\u5185\\u306B\" : \"\") + \"\\u30E9\\u30D9\\u30EB\\u3010\" + R + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\"), e && t.aToken[V].search(H(this, Ao)) > -1 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + R + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        return { idx: V + 1, ln: t.aLNum[V] };\n      case \"after\":\n        for (; t.aToken[++V] !== R; )\n          V === M && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + o + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + R + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\"), t.aToken[V].search(H(this, Ks)) > -1 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + o + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + R + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        return { idx: V + 1, ln: t.aLNum[V] };\n      default:\n        DebugMng.myTrace(\"[jump\\u7CFB] \\u7121\\u540D\\u30E9\\u30D9\\u30EB\\u6307\\u5B9A\\u3010label=\" + R + \"\\u3011\\u304C\\u9593\\u9055\\u3063\\u3066\\u3044\\u307E\\u3059\", \"ET\");\n    }\n  }\n  o = 1;\n  const L = new RegExp(\n    \"^\" + R.replaceAll(\"*\", \"\\\\*\") + \"(?:\\\\s|;|\\\\[|$)\"\n  );\n  let B = !1;\n  for (let V = 0; V < M; ++V) {\n    (U = t.aLNum)[V] || (U[V] = o);\n    const W = t.aToken[V];\n    if (B) {\n      H(this, Js).lastIndex = 0, H(this, Js).test(W) ? B = !1 : o += ((z = W.match(/\\n/g)) != null ? z : []).length;\n      continue;\n    }\n    const Y = W.charCodeAt(0);\n    if (Y === 10) {\n      o += W.length;\n      continue;\n    }\n    if (Y === 42) {\n      if (W.search(L) > -1)\n        return { idx: V + 1, ln: o };\n      continue;\n    }\n    Y === 91 && (o += ((X = W.match(/\\n/g)) != null ? X : []).length, H(this, Ui).lastIndex = 0, H(this, Ui).test(W) && (B = !0));\n  }\n  throw B ? \"[let_ml]\\u306E\\u7D42\\u7AEF\\u30FB[endlet_ml]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\" : (DebugMng.myTrace(`[jump\\u7CFB] \\u30E9\\u30D9\\u30EB\\u3010${R}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`, \"ET\"), \"Dummy\");\n}, ze = new WeakMap(), Hl = new WeakSet(), yf = function(t) {\n  const e = H(this, ai).matchToken(t.replace(/(\\r\\n|\\r)/g, `\n`));\n  for (let R = e.length - 1; R >= 0; --R) {\n    const N = e[R];\n    if (H(this, Ui).lastIndex = 0, H(this, Ui).test(N)) {\n      const M = N.indexOf(\"]\") + 1;\n      if (M === 0)\n        throw \"[let_ml]\\u3067\\u9589\\u3058\\u308B\\u3010]\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n      const D = N.slice(0, M), L = N.slice(M);\n      e.splice(R, 1, D, L);\n    }\n  }\n  et(this, Vt, { aToken: e, len: e.length, aLNum: [] });\n  let o = \"\";\n  try {\n    o = \"ScriptIterator.replaceScriptChar2macro\", H(this, ai).replaceScr_C2M_And_let_ml(H(this, Vt)), o = \"ScriptIterator.replaceScript_Wildcard\", H(this, Do).call(this);\n  } catch (R) {\n    if (R instanceof Error) {\n      const N = R;\n      o += `\\u4F8B\\u5916 mes=${N.message}(${N.name})`;\n    } else\n      o = R;\n    this.main.errScript(o, !1);\n  }\n  H(this, ze)[H(this, Qt)] = H(this, Vt), this.val.loadScrWork(H(this, Qt));\n}, Oo = new WeakSet(), Nh = function(t) {\n  et(this, Qt, t.fn), et(this, Ut, t.idx);\n  const e = H(this, ze)[H(this, Qt)];\n  e && et(this, Vt, e), et(this, he, H(this, Vt).aLNum[t.idx]);\n}, No = new WeakMap(), Mo = new WeakMap(), Do = new WeakMap(), zl = new WeakSet(), bf = function() {\n  const t = this.val.getAreaKidoku(H(this, Qt));\n  if (!t)\n    throw `recordKidoku fn:'${H(this, Qt)}' (areas === null)`;\n  if (H(this, le).length > 0) {\n    t.record(H(this, Ut));\n    return;\n  }\n  et(this, Ur, t.search(H(this, Ut))), this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", H(this, Ur)), !H(this, Ur) && t.record(H(this, Ut));\n}, Ur = new WeakMap(), Lo = new WeakSet(), Mh = function() {\n  var t;\n  (t = this.val.getAreaKidoku(H(this, Qt))) == null || t.erase(H(this, Ut)), et(this, Ur, !1);\n}, jl = new WeakSet(), Ef = function(t) {\n  return H(this, ai).bracket2macro(t, H(this, Vt), H(this, Ut)), !1;\n}, Vl = new WeakSet(), xf = function(t) {\n  return H(this, ai).char2macro(t, this.hTag, H(this, Vt), H(this, Ut)), !1;\n}, Xl = new WeakSet(), Tf = function(t) {\n  var N, M, D;\n  const { name: e } = t;\n  if (!e)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e in this.hTag)\n    throw `[${e}]\\u306F\\u30BF\\u30B0\\u304B\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30DE\\u30AF\\u30ED\\u3067\\u3059`;\n  const o = H(this, he), R = new CallStack(H(this, Qt), H(this, Ut));\n  for (et(this, Qs, H(this, Qs) + (\"|\" + e)), et(this, In, new RegExp(`\\\\[(${H(this, Qs)})\\\\b`)), this.hTag[e] = (L) => (L.design_unit = t.design_unit, at(this, Co, Rh).call(this, { ...L, \":hMp\": this.val.cloneMp() }), this.val.setMp(L), this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(t)), this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", H(this, Qt)), et(this, he, o), at(this, Oo, Nh).call(this, R), !1); H(this, Ut) < H(this, Vt).len; ++Re(this, Ut)._) {\n    (N = H(this, Vt).aLNum)[M = H(this, Ut)] || (N[M] = H(this, he));\n    const L = H(this, Vt).aToken[H(this, Ut)];\n    if (L.search(H(this, Ks)) > -1)\n      return ++Re(this, Ut)._, !1;\n    const B = L.charCodeAt(0);\n    B === 10 ? et(this, he, H(this, he) + L.length) : B === 91 && et(this, he, H(this, he) + ((D = L.match(/\\n/g)) != null ? D : []).length);\n  }\n  throw `\\u30DE\\u30AF\\u30ED[${e}]\\u5B9A\\u7FA9\\u306E\\u7D42\\u7AEF\\u30FB[endmacro]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`;\n}, Qs = new WeakMap(), In = new WeakMap(), Wl = new WeakSet(), Sf = function(t) {\n  if (!(\"place\" in t))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.place);\n  if (\"fn\" in t != \"label\" in t)\n    throw \"fn\\u3068label\\u306F\\u30BB\\u30C3\\u30C8\\u3067\\u6307\\u5B9A\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  const o = this.val.getMark(e);\n  if (!o)\n    throw `place\\u3010${e}\\u3011\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  return at(this, ta, ru).call(this, t, o);\n}, ta = new WeakSet(), ru = function(t, e, o = !0) {\n  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), H(this, ar).recText(\"\", !0), o && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, \"do_rec\", !0) && et(this, pr, {\n    hSave: this.val.cloneSave(),\n    hPages: { ...e.hPages },\n    aIfStk: [...e.aIfStk]\n  });\n  const R = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(R);\n  const N = String(this.val.getVal(\"save:const.sn.scriptFn\")), M = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  return et(this, Ye, [...H(this, pr).aIfStk]), et(this, le, []), H(this, ar).cover(!0), H(this, ar).stopAllTw(), \"index\" in t ? (H(this, ar).playback(H(this, pr).hPages, () => {\n    var D, L;\n    H(this, ar).cover(!1), et(this, wn, !0), at(this, Gi, Vn).call(this, (D = t.fn) != null ? D : N, \"\", (L = t.index) != null ? L : M);\n  }), !0) : (delete H(this, ze)[N], H(this, ar).playback(\n    H(this, pr).hPages,\n    \"label\" in t ? () => {\n      H(this, ar).cover(!1), et(this, Qt, N), et(this, Ut, M), this.hTag.call({ fn: t.fn, label: t.label });\n    } : () => {\n      H(this, ar).cover(!1), at(this, Gi, Vn).call(this, N, \"\", M);\n    }\n  ), !0);\n}, wn = new WeakMap(), Yl = new WeakSet(), Cf = function(t) {\n  const e = this.val.getMark(0);\n  return delete H(this, ze)[getFn(e.hSave[\"const.sn.scriptFn\"])], t.do_rec = !1, at(this, ta, ru).call(this, t, e, !1);\n}, pr = new WeakMap(), ql = new WeakSet(), If = function() {\n  if (this.main.isDestroyed())\n    return !1;\n  const { fn: t, idx: e } = at(this, ea, iu).call(this);\n  return this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", t), this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", e), et(this, pr, {\n    hSave: this.val.cloneSave(),\n    hPages: H(this, ar).record(),\n    aIfStk: H(this, Ye).slice(H(this, le).length)\n  }), !1;\n}, ea = new WeakSet(), iu = function() {\n  if (H(this, le).length === 0)\n    return {\n      fn: H(this, Qt),\n      idx: H(this, Ut)\n    };\n  const e = H(this, le)[0];\n  return {\n    fn: e.fn,\n    idx: e.idx\n  };\n}, Zl = new WeakSet(), wf = function(t) {\n  var R;\n  if (!(\"place\" in t))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.place);\n  delete t[\":\\u30BF\\u30B0\\u540D\"], delete t.place, t.text = ((R = t.text) != null ? R : \"\").replace(/^(<br\\/>)+/, \"\"), H(this, pr).json = t, this.val.setMark(e, H(this, pr));\n  const o = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  return e === o && this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", o + 1), !1;\n}, vr = new WeakMap(), Ae = new WeakMap(), it(ScriptIterator, Pl, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/), it(ScriptIterator, Tn, {}), it(ScriptIterator, ui, {});\nvar qe, Ze, De, gr, hi, Rn, Le, Fo, ci, ra, Hi, ia, na, Pn, Kl, Rf, sa, aa, An, oa, nu, zi, On;\nclass Main {\n  constructor(t) {\n    it(this, Kl);\n    it(this, oa);\n    it(this, qe, void 0);\n    it(this, Ze, void 0);\n    it(this, De, void 0);\n    it(this, gr, void 0);\n    it(this, hi, void 0);\n    it(this, Rn, void 0);\n    it(this, Le, void 0);\n    it(this, Fo, void 0);\n    it(this, ci, void 0);\n    it(this, ra, void 0);\n    it(this, Hi, void 0);\n    it(this, ia, void 0);\n    it(this, na, void 0);\n    it(this, Pn, void 0);\n    it(this, sa, void 0);\n    it(this, aa, void 0);\n    it(this, An, void 0);\n    it(this, zi, void 0);\n    it(this, On, void 0);\n    this.sys = t, et(this, De, /* @__PURE__ */ Object.create(null)), et(this, Hi, () => {\n    }), et(this, ia, new AnalyzeTagArg()), et(this, na, !1), et(this, Pn, \"skynovel\"), et(this, sa, () => H(this, Hi).call(this)), et(this, aa, (e = at(this, oa, nu)) => {\n      H(this, zi) || (H(this, ci).clearBreak(), et(this, Hi, e), this.resume = (o = at(this, oa, nu)) => {\n        et(this, Hi, o);\n      }, H(this, Le).noticeBreak(!1));\n    }), this.resume = H(this, aa), this.stop = () => {\n      et(this, Hi, () => {\n      }), this.resume = H(this, aa), H(this, Le).noticeBreak(!0);\n    }, et(this, An, !0), et(this, zi, !1), this.isDestroyed = () => H(this, zi), skipHello(), Config.generate(t).then((e) => et(this, qe, e)).then(() => at(this, Kl, Rf).call(this)).catch((e) => console.error(\"load err fn:prj.json e:%o\", e));\n  }\n  errScript(t, e = !0) {\n    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log(\"\\u{1F35C} SKYNovel err!\"), e)\n      throw t;\n  }\n  resumeByJumpOrCall(t) {\n    var e, o;\n    if (t.url) {\n      globalThis.open(t.url);\n      return;\n    }\n    H(this, gr).setVal_Nochk(\"tmp\", \"sn.eventArg\", (e = t.arg) != null ? e : \"\"), H(this, gr).setVal_Nochk(\"tmp\", \"sn.eventLabel\", (o = t.label) != null ? o : \"\"), argChk_Boolean(t, \"call\", !1) ? (H(this, Le).subIdxToken(), this.resume(() => H(this, De).call(t))) : (H(this, De).clear_event({}), this.resume(() => H(this, De).jump(t)));\n  }\n  setLoop(t, e = \"\") {\n    et(this, An, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}\\u4E2D` : \"\");\n  }\n  fire(t, e) {\n    H(this, ra).fire(t, e);\n  }\n  async destroy(t = 0) {\n    H(this, zi) || (et(this, zi, !0), H(this, na) && (this.stop(), et(this, An, !1), H(this, ci).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), et(this, De, {}), H(this, ra).destroy(), H(this, Le).destroy(), H(this, ci).destroy(), H(this, Fo).destroy(), H(this, Ze).ticker.remove(H(this, sa)), H(this, On) && H(this, Ze) && H(this, Ze).view.parentNode.appendChild(H(this, On)), clearTextureCache(), H(this, Ze).destroy(!0)));\n  }\n}\nqe = new WeakMap(), Ze = new WeakMap(), De = new WeakMap(), gr = new WeakMap(), hi = new WeakMap(), Rn = new WeakMap(), Le = new WeakMap(), Fo = new WeakMap(), ci = new WeakMap(), ra = new WeakMap(), Hi = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), Pn = new WeakMap(), Kl = new WeakSet(), Rf = async function() {\n  var R, N, M;\n  const t = (R = document.createElement(\"canvas\")) == null ? void 0 : R.getContext(\"2d\");\n  if (!t)\n    throw \"argChk_Color err\";\n  CmnLib.cc4ColorName = t;\n  const e = {\n    width: H(this, qe).oCfg.window.width,\n    height: H(this, qe).oCfg.window.height,\n    backgroundColor: parseColor(String(H(this, qe).oCfg.init.bg_color)),\n    resolution: (N = globalThis.devicePixelRatio) != null ? N : 1,\n    autoResize: !0\n  }, o = document.getElementById(H(this, Pn));\n  o && (et(this, On, o.cloneNode(!0)), H(this, On).id = H(this, Pn), e.view = o), et(this, Ze, new Application(e)), o || (document.body.appendChild(H(this, Ze).view), H(this, Ze).view.id = H(this, Pn)), et(this, gr, new Variable(H(this, qe), H(this, De))), et(this, hi, new PropParser(H(this, gr), (M = H(this, qe).oCfg.init.escape) != null ? M : \"\\\\\")), await Promise.allSettled(this.sys.init(H(this, De), H(this, Ze), H(this, gr), this)), H(this, De).title({ text: H(this, qe).oCfg.book.title || \"SKYNovel\" }), et(this, Rn, new SoundMng(H(this, qe), H(this, De), H(this, gr), this, this.sys)), et(this, Le, new ScriptIterator(H(this, qe), H(this, De), this, H(this, gr), H(this, ia), () => at(this, oa, nu).call(this), H(this, hi), H(this, Rn), this.sys)), et(this, Fo, new DebugMng(this.sys, H(this, De), H(this, Le))), et(this, ci, new LayerMng(H(this, qe), H(this, De), H(this, Ze), H(this, gr), this, H(this, Le), this.sys, H(this, Rn), H(this, ia), H(this, hi))), et(this, ra, new EventMng(H(this, qe), H(this, De), H(this, Ze), this, H(this, ci), H(this, gr), H(this, Rn), H(this, Le), this.sys)), H(this, Ze).ticker.add(H(this, sa)), this.resumeByJumpOrCall({ fn: \"main\" }), et(this, na, !0);\n}, sa = new WeakMap(), aa = new WeakMap(), An = new WeakMap(), oa = new WeakSet(), nu = function() {\n  var t;\n  for (; H(this, An); ) {\n    let e = H(this, Le).nextToken();\n    if (!e)\n      break;\n    const o = e.charCodeAt(0);\n    if (o !== 9) {\n      if (o === 10) {\n        H(this, Le).addLineNum(e.length);\n        continue;\n      }\n      if (o === 91) {\n        if (H(this, Le).isBreak(e))\n          return;\n        try {\n          const R = ((t = e.match(/\\n/g)) != null ? t : []).length;\n          if (R > 0 && H(this, Le).addLineNum(R), H(this, Le).\\u30BF\\u30B0\\u89E3\\u6790(e)) {\n            this.stop();\n            break;\n          }\n          continue;\n        } catch (R) {\n          if (R instanceof Error) {\n            const N = R;\n            let M = `\\u30BF\\u30B0\\u89E3\\u6790\\u4E2D\\u4F8B\\u5916 mes=${N.message}(${N.name})`;\n            M = `[${tagToken2Name(e)}]` + M, this.errScript(M, !1);\n          } else\n            this.errScript(String(R), !1);\n          return;\n        }\n      }\n      if (o === 38)\n        try {\n          if (e.slice(-1) !== \"&\") {\n            if (H(this, Le).isBreak(e))\n              return;\n            const R = splitAmpersand(e.slice(1));\n            R.name = H(this, hi).getValAmpersand(R.name), R.text = String(H(this, hi).parse(R.text)), H(this, De).let(R);\n            continue;\n          }\n          if (e.charAt(1) === \"&\")\n            throw new Error(\"\\u300C&\\u8868\\u793A&\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\");\n          e = String(H(this, hi).parse(e.slice(1, -1)));\n        } catch (R) {\n          this.errScript(\n            R instanceof Error ? `& \\u5909\\u6570\\u64CD\\u4F5C\\u30FB\\u8868\\u793A mes=${R.message}(${R.name})` : R,\n            !1\n          );\n          return;\n        }\n      else {\n        if (o === 59)\n          continue;\n        if (o === 42 && e.length > 1)\n          continue;\n      }\n      try {\n        H(this, ci).currentTxtlayForeNeedErr.tagCh(e);\n      } catch (R) {\n        this.errScript(\n          R instanceof Error ? `\\u6587\\u5B57\\u8868\\u793A mes=${R.message}(${R.name})` : R,\n          !1\n        );\n        return;\n      }\n    }\n  }\n}, zi = new WeakMap(), On = new WeakMap();\nvar assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < \"u\" ? window : commonjsGlobal$1, util$6 = {\n  assign,\n  create: create$1,\n  trim: trim$1,\n  bind: bind$1,\n  slice: slice$1,\n  each: each$7,\n  map,\n  pluck: pluck$1,\n  isList: isList$1,\n  isFunction: isFunction$1,\n  isObject: isObject$1,\n  Global: Global$5\n};\nfunction make_assign() {\n  return Object.assign ? Object.assign : function(t, e, o, R) {\n    for (var N = 1; N < arguments.length; N++)\n      each$7(Object(arguments[N]), function(M, D) {\n        t[D] = M;\n      });\n    return t;\n  };\n}\nfunction make_create() {\n  if (Object.create)\n    return function(t, e, o, R) {\n      var N = slice$1(arguments, 1);\n      return assign.apply(this, [Object.create(t)].concat(N));\n    };\n  {\n    let n = function() {\n    };\n    return function(e, o, R, N) {\n      var M = slice$1(arguments, 1);\n      return n.prototype = e, assign.apply(this, [new n()].concat(M));\n    };\n  }\n}\nfunction make_trim() {\n  return String.prototype.trim ? function(t) {\n    return String.prototype.trim.call(t);\n  } : function(t) {\n    return t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n}\nfunction bind$1(n, t) {\n  return function() {\n    return t.apply(n, Array.prototype.slice.call(arguments, 0));\n  };\n}\nfunction slice$1(n, t) {\n  return Array.prototype.slice.call(n, t || 0);\n}\nfunction each$7(n, t) {\n  pluck$1(n, function(e, o) {\n    return t(e, o), !1;\n  });\n}\nfunction map(n, t) {\n  var e = isList$1(n) ? [] : {};\n  return pluck$1(n, function(o, R) {\n    return e[R] = t(o, R), !1;\n  }), e;\n}\nfunction pluck$1(n, t) {\n  if (isList$1(n)) {\n    for (var e = 0; e < n.length; e++)\n      if (t(n[e], e))\n        return n[e];\n  } else\n    for (var o in n)\n      if (n.hasOwnProperty(o) && t(n[o], o))\n        return n[o];\n}\nfunction isList$1(n) {\n  return n != null && typeof n != \"function\" && typeof n.length == \"number\";\n}\nfunction isFunction$1(n) {\n  return n && {}.toString.call(n) === \"[object Function]\";\n}\nfunction isObject$1(n) {\n  return n && {}.toString.call(n) === \"[object Object]\";\n}\nvar util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {\n  createStore\n}, storeAPI = {\n  version: \"2.0.12\",\n  enabled: !1,\n  get: function(n, t) {\n    var e = this.storage.read(this._namespacePrefix + n);\n    return this._deserialize(e, t);\n  },\n  set: function(n, t) {\n    return t === void 0 ? this.remove(n) : (this.storage.write(this._namespacePrefix + n, this._serialize(t)), t);\n  },\n  remove: function(n) {\n    this.storage.remove(this._namespacePrefix + n);\n  },\n  each: function(n) {\n    var t = this;\n    this.storage.each(function(e, o) {\n      n.call(t, t._deserialize(e), (o || \"\").replace(t._namespaceRegexp, \"\"));\n    });\n  },\n  clearAll: function() {\n    this.storage.clearAll();\n  },\n  hasNamespace: function(n) {\n    return this._namespacePrefix == \"__storejs_\" + n + \"_\";\n  },\n  createStore: function() {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function(n) {\n    this._addPlugin(n);\n  },\n  namespace: function(n) {\n    return createStore(this.storage, this.plugins, n);\n  }\n};\nfunction _warn() {\n  var n = typeof console > \"u\" ? null : console;\n  if (!!n) {\n    var t = n.warn ? n.warn : n.log;\n    t.apply(n, arguments);\n  }\n}\nfunction createStore(n, t, e) {\n  e || (e = \"\"), n && !isList(n) && (n = [n]), t && !isList(t) && (t = [t]);\n  var o = e ? \"__storejs_\" + e + \"_\" : \"\", R = e ? new RegExp(\"^\" + o) : null, N = /^[a-zA-Z0-9_\\-]*$/;\n  if (!N.test(e))\n    throw new Error(\"store.js namespaces can only have alphanumerics + underscores and dashes\");\n  var M = {\n    _namespacePrefix: o,\n    _namespaceRegexp: R,\n    _testStorage: function(L) {\n      try {\n        var B = \"__storejs__test__\";\n        L.write(B, B);\n        var $ = L.read(B) === B;\n        return L.remove(B), $;\n      } catch {\n        return !1;\n      }\n    },\n    _assignPluginFnProp: function(L, B) {\n      var $ = this[B];\n      this[B] = function() {\n        var U = slice(arguments, 0), z = this;\n        function X() {\n          if (!!$)\n            return each$6(arguments, function(W, Y) {\n              U[Y] = W;\n            }), $.apply(z, U);\n        }\n        var V = [X].concat(U);\n        return L.apply(z, V);\n      };\n    },\n    _serialize: function(L) {\n      return JSON.stringify(L);\n    },\n    _deserialize: function(L, B) {\n      if (!L)\n        return B;\n      var $ = \"\";\n      try {\n        $ = JSON.parse(L);\n      } catch {\n        $ = L;\n      }\n      return $ !== void 0 ? $ : B;\n    },\n    _addStorage: function(L) {\n      this.enabled || this._testStorage(L) && (this.storage = L, this.enabled = !0);\n    },\n    _addPlugin: function(L) {\n      var B = this;\n      if (isList(L)) {\n        each$6(L, function(U) {\n          B._addPlugin(U);\n        });\n        return;\n      }\n      var $ = pluck(this.plugins, function(U) {\n        return L === U;\n      });\n      if (!$) {\n        if (this.plugins.push(L), !isFunction(L))\n          throw new Error(\"Plugins must be function values that return objects\");\n        var k = L.call(this);\n        if (!isObject(k))\n          throw new Error(\"Plugins must return an object of function properties\");\n        each$6(k, function(U, z) {\n          if (!isFunction(U))\n            throw new Error(\"Bad plugin property: \" + z + \" from plugin \" + L.name + \". Plugins should only return functions.\");\n          B._assignPluginFnProp(U, z);\n        });\n      }\n    },\n    addStorage: function(L) {\n      _warn(\"store.addStorage(storage) is deprecated. Use createStore([storages])\"), this._addStorage(L);\n    }\n  }, D = create(M, storeAPI, {\n    plugins: []\n  });\n  return D.raw = {}, each$6(D, function(L, B) {\n    isFunction(L) && (D.raw[B] = bind(D, L));\n  }), each$6(n, function(L) {\n    D._addStorage(L);\n  }), each$6(t, function(L) {\n    D._addPlugin(L);\n  }), D;\n}\nvar util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {\n  name: \"localStorage\",\n  read: read$5,\n  write: write$5,\n  each: each$5,\n  remove: remove$5,\n  clearAll: clearAll$5\n};\nfunction localStorage() {\n  return Global$4.localStorage;\n}\nfunction read$5(n) {\n  return localStorage().getItem(n);\n}\nfunction write$5(n, t) {\n  return localStorage().setItem(n, t);\n}\nfunction each$5(n) {\n  for (var t = localStorage().length - 1; t >= 0; t--) {\n    var e = localStorage().key(t);\n    n(read$5(e), e);\n  }\n}\nfunction remove$5(n) {\n  return localStorage().removeItem(n);\n}\nfunction clearAll$5() {\n  return localStorage().clear();\n}\nvar util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {\n  name: \"oldFF-globalStorage\",\n  read: read$4,\n  write: write$4,\n  each: each$4,\n  remove: remove$4,\n  clearAll: clearAll$4\n}, globalStorage = Global$3.globalStorage;\nfunction read$4(n) {\n  return globalStorage[n];\n}\nfunction write$4(n, t) {\n  globalStorage[n] = t;\n}\nfunction each$4(n) {\n  for (var t = globalStorage.length - 1; t >= 0; t--) {\n    var e = globalStorage.key(t);\n    n(globalStorage[e], e);\n  }\n}\nfunction remove$4(n) {\n  return globalStorage.removeItem(n);\n}\nfunction clearAll$4() {\n  each$4(function(n, t) {\n    delete globalStorage[n];\n  });\n}\nvar util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {\n  name: \"oldIE-userDataStorage\",\n  write: write$3,\n  read: read$3,\n  each: each$3,\n  remove: remove$3,\n  clearAll: clearAll$3\n}, storageName = \"storejs\", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : \"\").match(/ (MSIE 8|MSIE 9|MSIE 10)\\./);\nfunction write$3(n, t) {\n  if (!disable) {\n    var e = fixKey(n);\n    _withStorageEl(function(o) {\n      o.setAttribute(e, t), o.save(storageName);\n    });\n  }\n}\nfunction read$3(n) {\n  if (!disable) {\n    var t = fixKey(n), e = null;\n    return _withStorageEl(function(o) {\n      e = o.getAttribute(t);\n    }), e;\n  }\n}\nfunction each$3(n) {\n  _withStorageEl(function(t) {\n    for (var e = t.XMLDocument.documentElement.attributes, o = e.length - 1; o >= 0; o--) {\n      var R = e[o];\n      n(t.getAttribute(R.name), R.name);\n    }\n  });\n}\nfunction remove$3(n) {\n  var t = fixKey(n);\n  _withStorageEl(function(e) {\n    e.removeAttribute(t), e.save(storageName);\n  });\n}\nfunction clearAll$3() {\n  _withStorageEl(function(n) {\n    var t = n.XMLDocument.documentElement.attributes;\n    n.load(storageName);\n    for (var e = t.length - 1; e >= 0; e--)\n      n.removeAttribute(t[e].name);\n    n.save(storageName);\n  });\n}\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\");\nfunction fixKey(n) {\n  return n.replace(/^\\d/, \"___$&\").replace(forbiddenCharsRegex, \"___\");\n}\nfunction _makeIEStorageElFunction() {\n  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)\n    return null;\n  var n = \"script\", t, e, o;\n  try {\n    e = new ActiveXObject(\"htmlfile\"), e.open(), e.write(\"<\" + n + \">document.w=window</\" + n + '><iframe src=\"/favicon.ico\"></iframe>'), e.close(), t = e.w.frames[0].document, o = t.createElement(\"div\");\n  } catch {\n    o = doc$1.createElement(\"div\"), t = doc$1.body;\n  }\n  return function(R) {\n    var N = [].slice.call(arguments, 0);\n    N.unshift(o), t.appendChild(o), o.addBehavior(\"#default#userData\"), o.load(storageName), R.apply(this, N), t.removeChild(o);\n  };\n}\nvar util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {\n  name: \"cookieStorage\",\n  read: read$2,\n  write: write$2,\n  each: each$2,\n  remove: remove$2,\n  clearAll: clearAll$2\n}, doc = Global$1.document;\nfunction read$2(n) {\n  if (!n || !_has(n))\n    return null;\n  var t = \"(?:^|.*;\\\\s*)\" + escape(n).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\";\n  return unescape(doc.cookie.replace(new RegExp(t), \"$1\"));\n}\nfunction each$2(n) {\n  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)\n    if (!!trim(t[e])) {\n      var o = t[e].split(\"=\"), R = unescape(o[0]), N = unescape(o[1]);\n      n(N, R);\n    }\n}\nfunction write$2(n, t) {\n  !n || (doc.cookie = escape(n) + \"=\" + escape(t) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\");\n}\nfunction remove$2(n) {\n  !n || !_has(n) || (doc.cookie = escape(n) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\");\n}\nfunction clearAll$2() {\n  each$2(function(n, t) {\n    remove$2(t);\n  });\n}\nfunction _has(n) {\n  return new RegExp(\"(?:^|;\\\\s*)\" + escape(n).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\").test(doc.cookie);\n}\nvar util = util$6, Global = util.Global, sessionStorage_1 = {\n  name: \"sessionStorage\",\n  read: read$1,\n  write: write$1,\n  each: each$1,\n  remove: remove$1,\n  clearAll: clearAll$1\n};\nfunction sessionStorage$1() {\n  return Global.sessionStorage;\n}\nfunction read$1(n) {\n  return sessionStorage$1().getItem(n);\n}\nfunction write$1(n, t) {\n  return sessionStorage$1().setItem(n, t);\n}\nfunction each$1(n) {\n  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {\n    var e = sessionStorage$1().key(t);\n    n(read$1(e), e);\n  }\n}\nfunction remove$1(n) {\n  return sessionStorage$1().removeItem(n);\n}\nfunction clearAll$1() {\n  return sessionStorage$1().clear();\n}\nvar memoryStorage_1 = {\n  name: \"memoryStorage\",\n  read,\n  write,\n  each,\n  remove,\n  clearAll\n}, memoryStorage = {};\nfunction read(n) {\n  return memoryStorage[n];\n}\nfunction write(n, t) {\n  memoryStorage[n] = t;\n}\nfunction each(n) {\n  for (var t in memoryStorage)\n    memoryStorage.hasOwnProperty(t) && n(memoryStorage[t], t);\n}\nfunction remove(n) {\n  delete memoryStorage[n];\n}\nfunction clearAll(n) {\n  memoryStorage = {};\n}\nvar all = [\n  localStorage_1,\n  oldFFGlobalStorage,\n  oldIEUserDataStorage,\n  cookieStorage,\n  sessionStorage_1,\n  memoryStorage_1\n], json2$1 = {}, hasRequiredJson2;\nfunction requireJson2() {\n  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != \"object\" && (JSON = {}), function() {\n    var rx_one = /^[\\],:{}\\s]*$/, rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, rx_four = /(?:^|:|,)(?:\\s*\\[)+/g, rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g, rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    function f(n) {\n      return n < 10 ? \"0\" + n : n;\n    }\n    function this_value() {\n      return this.valueOf();\n    }\n    typeof Date.prototype.toJSON != \"function\" && (Date.prototype.toJSON = function() {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);\n    var gap, indent, meta, rep;\n    function quote(n) {\n      return rx_escapable.lastIndex = 0, rx_escapable.test(n) ? '\"' + n.replace(rx_escapable, function(t) {\n        var e = meta[t];\n        return typeof e == \"string\" ? e : \"\\\\u\" + (\"0000\" + t.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + n + '\"';\n    }\n    function str(n, t) {\n      var e, o, R, N, M = gap, D, L = t[n];\n      switch (L && typeof L == \"object\" && typeof L.toJSON == \"function\" && (L = L.toJSON(n)), typeof rep == \"function\" && (L = rep.call(t, n, L)), typeof L) {\n        case \"string\":\n          return quote(L);\n        case \"number\":\n          return isFinite(L) ? String(L) : \"null\";\n        case \"boolean\":\n        case \"null\":\n          return String(L);\n        case \"object\":\n          if (!L)\n            return \"null\";\n          if (gap += indent, D = [], Object.prototype.toString.apply(L) === \"[object Array]\") {\n            for (N = L.length, e = 0; e < N; e += 1)\n              D[e] = str(e, L) || \"null\";\n            return R = D.length === 0 ? \"[]\" : gap ? `[\n` + gap + D.join(`,\n` + gap) + `\n` + M + \"]\" : \"[\" + D.join(\",\") + \"]\", gap = M, R;\n          }\n          if (rep && typeof rep == \"object\")\n            for (N = rep.length, e = 0; e < N; e += 1)\n              typeof rep[e] == \"string\" && (o = rep[e], R = str(o, L), R && D.push(quote(o) + (gap ? \": \" : \":\") + R));\n          else\n            for (o in L)\n              Object.prototype.hasOwnProperty.call(L, o) && (R = str(o, L), R && D.push(quote(o) + (gap ? \": \" : \":\") + R));\n          return R = D.length === 0 ? \"{}\" : gap ? `{\n` + gap + D.join(`,\n` + gap) + `\n` + M + \"}\" : \"{\" + D.join(\",\") + \"}\", gap = M, R;\n      }\n    }\n    typeof JSON.stringify != \"function\" && (meta = {\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    }, JSON.stringify = function(n, t, e) {\n      var o;\n      if (gap = \"\", indent = \"\", typeof e == \"number\")\n        for (o = 0; o < e; o += 1)\n          indent += \" \";\n      else\n        typeof e == \"string\" && (indent = e);\n      if (rep = t, t && typeof t != \"function\" && (typeof t != \"object\" || typeof t.length != \"number\"))\n        throw new Error(\"JSON.stringify\");\n      return str(\"\", { \"\": n });\n    }), typeof JSON.parse != \"function\" && (JSON.parse = function(text, reviver) {\n      var j;\n      function walk(n, t) {\n        var e, o, R = n[t];\n        if (R && typeof R == \"object\")\n          for (e in R)\n            Object.prototype.hasOwnProperty.call(R, e) && (o = walk(R, e), o !== void 0 ? R[e] = o : delete R[e]);\n        return reviver.call(n, t, R);\n      }\n      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(n) {\n        return \"\\\\u\" + (\"0000\" + n.charCodeAt(0).toString(16)).slice(-4);\n      })), rx_one.test(\n        text.replace(rx_two, \"@\").replace(rx_three, \"]\").replace(rx_four, \"\")\n      ))\n        return j = eval(\"(\" + text + \")\"), typeof reviver == \"function\" ? walk({ \"\": j }, \"\") : j;\n      throw new SyntaxError(\"JSON.parse\");\n    });\n  }()), json2$1;\n}\nvar json2 = json2Plugin;\nfunction json2Plugin() {\n  return requireJson2(), {};\n}\nvar engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);\n/*!\ndevtools-detect\nhttps://github.com/sindresorhus/devtools-detect\nBy Sindre Sorhus\nMIT License\n*/\nconst devtools = {\n  isOpen: !1,\n  orientation: void 0\n}, threshold = 160, emitEvent = (n, t) => {\n  globalThis.dispatchEvent(new globalThis.CustomEvent(\"devtoolschange\", {\n    detail: {\n      isOpen: n,\n      orientation: t\n    }\n  }));\n}, main = ({ emitEvents: n = !0 } = {}) => {\n  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, o = t ? \"vertical\" : \"horizontal\";\n  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== o) && n && emitEvent(!0, o), devtools.isOpen = !0, devtools.orientation = o) : (devtools.isOpen && n && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);\n};\nmain({ emitEvents: !1 });\nsetInterval(main, 500);\nvar Nn, ua, Hr, la;\nclass SysWeb extends SysBase {\n  constructor(e = {}, o = { cur: \"prj/\", crypto: !1, dip: \"\" }) {\n    super(e, o);\n    it(this, Nn, void 0);\n    it(this, ua, void 0);\n    it(this, Hr, void 0);\n    it(this, la, void 0);\n    et(this, Nn, \"\"), et(this, ua, \":\"), this.run = async () => {\n      H(this, Hr) && (H(this, Hr).destroy(10), await new Promise((M) => setTimeout(M, 10))), et(this, Hr, new Main(this));\n    }, et(this, Hr, void 0), this.pathBaseCnvSnPath4Dbg = \"${pathbase}/\", this._export = () => ((async () => {\n      const N = JSON.stringify({\n        sys: this.data.sys,\n        mark: this.data.mark,\n        kidoku: this.data.kidoku\n      }), M = this.crypto ? await this.enc(N) : N, D = new Blob([M], { type: \"text/json\" }), L = document.createElement(\"a\");\n      L.href = URL.createObjectURL(D), L.download = (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + getDateStr(\"-\", \"_\", \"\") + \".swpd\", L.click(), CmnLib.debugLog && console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A8\\u30AF\\u30B9\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\"), setTimeout(() => this.fire(\"sn:exported\", new Event(\"click\")), 10);\n    })(), !1), this._import = () => (new Promise((N, M) => {\n      const D = document.createElement(\"input\");\n      D.type = \"file\", D.accept = \".swpd, text/plain\", D.onchange = () => {\n        D.files ? N(D.files[0].path) : M();\n      }, D.click();\n    }).then((N) => new Promise((M) => {\n      const D = new FileReader();\n      D.readAsText(N), D.onload = () => M(D.result);\n    })).then(async (N) => {\n      const M = JSON.parse(this.crypto ? this.decStr(\"json\", N) : N);\n      if (!M.sys || !M.mark || !M.kidoku)\n        throw new Error(\"\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059\");\n      if (M.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {\n        console.error(`\\u5225\\u306E\\u30B2\\u30FC\\u30E0\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u540D=${M.sys[SysBase.VALNM_CFG_NS]}\\u3011\\u306E\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059`);\n        return;\n      }\n      this.data.sys = M.sys, this.data.mark = M.mark, this.data.kidoku = M.kidoku, this.flush(), this.val.updateData(M), CmnLib.debugLog && console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A4\\u30F3\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\"), this.fire(\"sn:imported\", new Event(\"click\"));\n    }).catch((N) => console.error(`\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059 ${N.message}`)), !1), this.navigate_to = (N) => {\n      const { url: M } = N;\n      if (!M)\n        throw \"[navigate_to] url\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      return globalThis.open(M, \"_blank\"), !1;\n    }, et(this, la, {});\n    const R = o.cur.split(\"/\");\n    et(this, Nn, R.length > 2 ? R.slice(0, -2).join(\"/\") + \"/\" : \"\"), globalThis.onload = async () => this.loaded(e, o);\n  }\n  async loaded(e, o) {\n    await super.loaded(e, o), document.querySelectorAll(\"[data-prj]\").forEach((D) => {\n      const L = D.attributes.getNamedItem(\"data-prj\");\n      L && D.addEventListener(\"click\", () => this.runSN(L.value), { passive: !0 });\n    }), document.querySelectorAll(\"[data-reload]\").forEach(\n      (D) => D.addEventListener(\"click\", () => this.run(), { passive: !0 })\n    ), o.dip && (CmnLib.hDip = JSON.parse(o.dip));\n    const R = new URLSearchParams(location.search), N = R.get(\"dip\");\n    if (N && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(N.replaceAll(\"%2C\", \",\")) }), !argChk_Boolean(CmnLib.hDip, \"oninit_run\", !0))\n      return;\n    argChk_Boolean(CmnLib.hDip, \"dbg\", !1) && (CmnLib.isDbg = !0, this.fetch = (D) => fetch(D, { mode: \"cors\" })), this.extPort = argChk_Num(CmnLib.hDip, \"port\", this.extPort);\n    const M = R.get(\"cur\");\n    M && (o.cur = H(this, Nn) + M + \"/\"), this.run();\n  }\n  runSN(e) {\n    this.arg.cur = H(this, Nn) + e + \"/\", H(this, ua) !== this.arg.cur && (et(this, ua, this.arg.cur), this.run());\n  }\n  stop() {\n    !H(this, Hr) || (H(this, Hr).destroy(), et(this, Hr, void 0));\n  }\n  async loadPath(e, o) {\n    await super.loadPath(e, o);\n    const R = this.arg.cur + \"path.json\", N = await fetch(R);\n    if (!N.ok)\n      throw Error(N.statusText);\n    const M = await N.text(), D = JSON.parse(this.decStr(R, M));\n    for (const L in D) {\n      const B = e[L] = D[L];\n      for (const $ in B)\n        $ !== \":cnt\" && (B[$] = this.arg.cur + B[$]);\n    }\n  }\n  initVal(e, o, R) {\n    const N = encodeURIComponent(document.location.hostname);\n    o[\"const.sn.isDebugger\"] = N === \"localhost\" || N === \"127.0.0.1\";\n    const M = this.cfg.getNs();\n    this.flush = this.crypto ? async () => {\n      store_legacy.set(M + \"sys_\", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(M + \"mark_\", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(M + \"kidoku_\", this.enc(JSON.stringify(this.data.kidoku)));\n    } : () => {\n      store_legacy.set(M + \"sys\", this.data.sys), store_legacy.set(M + \"mark\", this.data.mark), store_legacy.set(M + \"kidoku\", this.data.kidoku);\n    };\n    const D = M + (this.arg.crypto ? \"sys_\" : \"sys\");\n    if (o[\"const.sn.isFirstBoot\"] = store_legacy.get(D) === void 0) {\n      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), R(this.data);\n      return;\n    }\n    if (!this.crypto) {\n      this.data.sys = store_legacy.get(M + \"sys\"), this.data.mark = store_legacy.get(M + \"mark\"), this.data.kidoku = store_legacy.get(M + \"kidoku\"), R(this.data);\n      return;\n    }\n    let L = \"\";\n    try {\n      L = \"sys\", this.data.sys = JSON.parse(this.decStr(\"json\", store_legacy.get(M + \"sys_\"))), L += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), L = \"mark\", this.data.mark = JSON.parse(this.decStr(\"json\", store_legacy.get(M + \"mark_\"))), L = \"kidoku\", this.data.kidoku = JSON.parse(this.decStr(\"json\", store_legacy.get(M + \"kidoku_\")));\n    } catch (B) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${L}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, B);\n    }\n    R(this.data);\n  }\n  init(e, o, R, N) {\n    super.init(e, o, R, N);\n    const M = o.view.parentElement;\n    if (\"requestFullscreen\" in document.body)\n      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : M.requestFullscreen(), document.addEventListener(\"fullscreenchange\", () => this.isFullScr = Boolean(document.fullscreenElement));\n    else {\n      const D = document;\n      this.tglFlscr_sub = () => this.isFullScr ? D.webkitCancelFullScreen() : M.webkitRequestFullscreen(), document.addEventListener(\"fullscreenchange\", () => this.isFullScr = Boolean(D.webkitFullscreenElement));\n    }\n    return this.cfg.oCfg.debug.devtool || window.addEventListener(\"devtoolschange\", (D) => {\n      !D.detail.isOpen || (console.error(\"DevTool\\u306F\\u7981\\u6B62\\u3055\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u8A31\\u53EF\\u3059\\u308B\\u5834\\u5408\\u306F\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u8A2D\\u5B9A\\u3011\\u306E\\u3010devtool\\u3011\\u3092ON\\u306B\\u3002\"), N.destroy());\n    }, { once: !0, passive: !0 }), [];\n  }\n  cvsResize() {\n    if (super.cvsResize(), this.isFullScr) {\n      const e = this.appPixi.view.style;\n      e.width = e.height = \"\";\n    }\n  }\n  titleSub(e) {\n    document.title = e, document.querySelectorAll(\"[data-title]\").forEach((o) => o.textContent = e);\n  }\n  async savePic(e, o) {\n    const R = document.createElement(\"a\");\n    R.href = o, R.download = e, R.click(), CmnLib.debugLog && console.log(\"\\u753B\\u50CF\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30C0\\u30A6\\u30F3\\u30ED\\u30FC\\u30C9\\u3057\\u307E\\u3059\");\n  }\n  async appendFile(e, o, R) {\n    var L;\n    const N = ((L = H(this, la)[e]) != null ? L : \"\") + o;\n    H(this, la)[e] = N;\n    const M = new Blob([N], { type: \"text/json\" }), D = document.createElement(\"a\");\n    D.href = URL.createObjectURL(M), D.download = e, D.click();\n  }\n}\nNn = new WeakMap(), ua = new WeakMap(), Hr = new WeakMap(), la = new WeakMap();\n\n//# sourceMappingURL=web.js.map\n\n\n//# sourceURL=webpack://gallery/./node_modules/@famibee/skynovel/dist/web.js?");

/***/ })

}]);