"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel"],{

/***/ "./node_modules/@famibee/skynovel/dist/web.js":
/*!****************************************************!*\
  !*** ./node_modules/@famibee/skynovel/dist/web.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ CmnLib),\n/* harmony export */   \"Layer\": () => (/* binding */ Layer),\n/* harmony export */   \"SysWeb\": () => (/* binding */ SysWeb),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ argChk_Boolean),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ argChk_Num)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;\nvar __spreadValues = (a2, b2) => {\n  for (var prop in b2 || (b2 = {}))\n    if (__hasOwnProp.call(b2, prop))\n      __defNormalProp(a2, prop, b2[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b2)) {\n      if (__propIsEnum.call(b2, prop))\n        __defNormalProp(a2, prop, b2[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));\nvar __accessCheck2 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet2 = (obj, member, getter) => {\n  __accessCheck2(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd2 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet2 = (obj, member, value2, setter) => {\n  __accessCheck2(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar __privateWrapper2 = (obj, member, setter, getter) => {\n  return {\n    set _(value2) {\n      __privateSet2(obj, member, value2, setter);\n    },\n    get _() {\n      return __privateGet2(obj, member, getter);\n    }\n  };\n};\nvar __privateMethod2 = (obj, member, method) => {\n  __accessCheck2(obj, member, \"access private method\");\n  return method;\n};\nvar _a2, _b2, _c2, _d, _sesame, _putCh, _REG_RUBY, _REG_CANTC2M, _REGC2M, _regStrC2M, _regStrC2M4not, _hC2M, _REG_TAGARG, _hPrm, _isKomeParam, _parser, _calc, calc_fn, _hFnc, _fncSub_ChkNum, fncSub_ChkNum_fn, _REG_EMBEDVAR, _procEmbedVar, procEmbedVar_fn, _REG_VAL, _getValName_B2D, getValName_B2D_fn, _hScopes, _hSave, _hTmp, _sys2, _data, _hSys, _hAreaKidoku, _callHook, _hProcDbgRes, _set_data_break, set_data_break_fn, _flush, _doRecProc, _copybookmark, copybookmark_fn, _erasebookmark, erasebookmark_fn, _let, let_fn, _let_abs, let_abs_fn, _let_char_at, let_char_at_fn, _let_index_of, let_index_of_fn, _let_length, let_length_fn, _let_replace, let_replace_fn, _let_round, let_round_fn, _let_search, let_search_fn, _let_substr, let_substr_fn, _clearsysvar, clearsysvar_fn, _clearvar, clearvar_fn, _setVal, _hSetEvent, _castAuto, castAuto_fn, _REG_NUMERICLITERAL, _dump_val, _doRecLog, _hValTrg, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn, _runFirst_sys_an_tagCh_msecWait, runFirst_sys_an_tagCh_msecWait_fn, _runFirst_sys_an_tagCh_msecWait_Kidoku, runFirst_sys_an_tagCh_msecWait_Kidoku_fn, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn, _runFirst_Bool_hSaveVal_true, runFirst_Bool_hSaveVal_true_fn, _runFirst_Bool_hTmp_true, runFirst_Bool_hTmp_true_fn, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn, _hEase, _hSndBuf, _hLP, _evtMng2, _volume, volume_fn, _getVol, getVol_fn, _fadeoutbgm, fadeoutbgm_fn, _fadeoutse, fadeoutse_fn, _fadebgm, fadebgm_fn, _fadese, fadese_fn, _playbgm, playbgm_fn, _MAX_END_MS, _playse, playse_fn, _playseSub, playseSub_fn, _initVol, _stop_allse, stop_allse_fn, _stopbgm, stopbgm_fn, _stopse, stopse_fn, _wb, wb_fn, _wf, wf_fn, _stopfadese, stopfadese_fn, _wl, wl_fn, _ws, ws_fn, _xchgbuf, xchgbuf_fn, _addLoopPlay, addLoopPlay_fn, _delLoopPlay, delLoopPlay_fn, _pg, _hBlendmode, _vctEvt, _sp, _procHint, procHint_fn, _sp2, _cfg2, _appPixi2, _evtMng3, _htmTxt, _cntTxt, _grpDbgMasume, _idc2, _idcCh, _infTL, _break_fixed, _break_fixed_left, _break_fixed_top, _lay_sub, lay_sub_fn, _left, _isTategaki, _padTx4x, _padTx4y, _hWarning, _htm2tx, htm2tx_fn, _ch_filter, _aSpTw, _aRect, _lenHtmTxt, _reg\\u884C\\u982D\\u7981\\u5247, _reg\\u884C\\u672B\\u7981\\u5247, _reg\\u5206\\u5272\\u7981\\u6B62, _REGDS, _fncEndChIn, _spWork, spWork_fn, _isChInIng, _hChInStyle, _REG_NG_CHSTYLE_NAME_CHR, _hChOutStyle, _cntBreak, _lh_half, _getChRects, getChRects_fn, _fi_easing, _fo_easing, _clearText, clearText_fn, _sss, _cfg3, _val, _recText, _isPageFore, _ch_in_style, ch_in_style_fn, _ch_out_style, ch_out_style_fn, _main2, _evtMng4, _sys3, _doAutoWc, _hAutoWc, _autowc, autowc_fn, _b_color, _b_alpha, _b_alpha_isfixed, _b_do, _b_pic, _txs, _rbSpl, _cntBtn, _set_ch_in, set_ch_in_fn, _$ch_in_style, _ch_in_join, _set_ch_out, set_ch_out_fn, _$ch_out_style, _drawBack, drawBack_fn, _setFfs, setFfs_fn, _ffs, _fncFFSStyle, _fncFFSSpan, _strNoFFS, _regNoFFS, _rec, _rec_bk, _class_offrec, _ruby_pd, _r_align, _mkStyle_r_align4ff, mkStyle_r_align4ff_fn, _needGoTxt, _putCh2, _tagCh_sub, tagCh_sub_fn, _cumDelay, _firstCh, _aSpan, _aSpan_bk, _aSpan_link, _hSpanBk, _beginSpan, beginSpan_fn, _autoCloseSpan, autoCloseSpan_fn, _page_text, _evtMng5, _hIfrm, _add_frame, add_frame_fn, _hDisabled, _rect, rect_fn, _let_frame, let_frame_fn, _set_frame, set_frame_fn, _zIdx, _frame, frame_fn, _tsy_frame, tsy_frame_fn, _stage, _fore, _back, _frmMng, _bg_color, _fncTicker, _hProcDbgRes2, _modeLn, _modeLnSub, _selectNode, selectNode_fn, _grpCover, _evtMng6, _foreachRedrawTxtLayBack, foreachRedrawTxtLayBack_fn, _cmdTxt, _snapshot, snapshot_fn, _loadplugin, loadplugin_fn, _add_lay, add_lay_fn, _hPages, _aLayName, _curTxtlay, _firstGrplay, _lay, lay_fn, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn, _clear_lay, clear_lay_fn, _srcRuleTransFragment, _ufRuleTrans, _fltRule, _rtTransBack, _spTransBack, _rtTransFore, _spTransFore, _aBackTransAfter, _trans, trans_fn, _tiTrans, _getLayers, getLayers_fn, _foreachLayers, foreachLayers_fn, _sortLayers, sortLayers_fn, _wt, wt_fn, _finish_trans, finish_trans_fn, _quake, quake_fn, _hTwInf, _tsy, tsy_fn, _wait_tsy, wait_tsy_fn, _stop_tsy, stop_tsy_fn, _pause_tsy, pause_tsy_fn, _resume_tsy, resume_tsy_fn, _msecChWait, _ch, ch_fn, _getTxtLayer, _$getTxtLayer, $getTxtLayer_fn, _current, _$current, $current_fn, _pgTxtlay, _chkTxtLay, _argChk_layer, argChk_layer_fn, _oLastPage, _aTxtLog, _clear_text, clear_text_fn, _endlink, endlink_fn, _er, er_fn, _graph, graph_fn, _link, link_fn, _r, r_fn, _rec_r, rec_r_fn, _rec_ch, rec_ch_fn, _reset_rec, reset_rec_fn, _ruby2, ruby2_fn, _span, span_fn, _tcy, tcy_fn, _dump_lay, dump_lay_fn, _enable_event, enable_event_fn, _button, button_fn, _aBtn, _idx, _radio_next, radio_next_fn, _logFocus, _allOff, allOff_fn, _elc2, _gamepad, _fcs, _resvFlameEvent4Wheel, _ev_keydown, ev_keydown_fn, _ev_contextmenu, ev_contextmenu_fn, _ev_wheel, ev_wheel_fn, _wheeling, _extend_wheel, _ev_wheel_waitstop, ev_wheel_waitstop_fn, _hLocalEvt2Fnc, _hGlobalEvt2Fnc, _isDbgBreak, _isWait, _getEvt2Fnc, _waitEventBase, waitEventBase_fn, _firstWait, _elmV, _elmHint, _spanHint, _popper, _oHintOpt, _dispHint, dispHint_fn, _procWheel4wle, _elcWLE, _clear_event, clear_event_fn, _clear_eventer, clear_eventer_fn, _event, event_fn, _canFocus, canFocus_fn, _getHtmlElmList, getHtmlElmList_fn, _goTxt, _l, l_fn, _p, p_fn, _stopSkip, _set_cancel_skip, set_cancel_skip_fn, _set_focus, set_focus_fn, _wait, wait_fn, _cancelWait, _waitclick, waitclick_fn, _hDownKeys, _script, _scriptFn, _idxToken, _lineNum, _aCallStk, _grm, _regBreakPoint, regBreakPoint_fn, _hHook2, _cnvSnPath, _REG4CODE_FN, _cnvSnPath4Dbg, _go_stepover, go_stepover_fn, _go_stepout, go_stepout_fn, _csDepth_macro_esc, _idxDx4Dbg, idxDx4Dbg_get, _isIdxOverLast, isIdxOverLast_fn, _hFn2hLineBP, _hFuncBP, _breakState, _isBreak_base, isBreak_base_fn, _subHitCondition, subHitCondition_fn, _aStack, aStack_fn, _procDebugtag, _evtMng7, _layMng, _let_ml, let_ml_fn, _dump_stack, dump_stack_fn, _cnvIdx2lineCol, cnvIdx2lineCol_fn, _dump_script, dump_script_fn, _fncSet, _fncBreak, _fnLastBreak, _hScrCache4Dump, _dumpErrLine, _aIfStk, _endif, endif_fn, _if, if_fn, _call, call_fn, _callSub, callSub_fn, _jump, jump_fn, _page, page_fn, _pop_stack, pop_stack_fn, _return, return_fn, _resvToken, _clearResvToken, clearResvToken_fn, _skipLabel, _jumpWork, jumpWork_fn, _nextToken_Proc, nextToken_Proc_fn, _dbgToken, _errOverScr, errOverScr_fn, _REG_NONAME_LABEL, _REG_TOKEN_MACRO_BEGIN, _REG_TOKEN_MACRO_END, _REG_TAG_LET_ML, _REG_TAG_ENDLET_ML, _seekScript, seekScript_fn, _hScript, _resolveScript, resolveScript_fn, _jump_light, jump_light_fn, _REG_WILDCARD, _REG_WILDCARD2, _replaceScript_Wildcard, _recordKidoku, recordKidoku_fn, _isKidoku, _eraseKidoku, eraseKidoku_fn, _bracket2macro, bracket2macro_fn, _char2macro, char2macro_fn, _macro, macro_fn, _strStepin, _REGSTEPIN, _load, load_fn, _loadFromMark, loadFromMark_fn, _skip4page, _reload_script, reload_script_fn, _mark, _record_place, record_place_fn, _nowScrIdx, nowScrIdx_fn, _save, save_fn, _aPageLog, _posAPageLog, _cfg4, _appPixi3, _hTag2, _val2, _prpPrs, _sndMng, _scrItr2, _dbgMng, _layMng2, _evtMng8, _fncNext, _alzTagArg2, _inited, _SN_ID, _init, init_fn, _fncTicker2, _fncresume, _isLoop, _runAnalyze, runAnalyze_fn, _destroyed, _clone_cvs, _path_base, _now_prj, _main3, _hAppendFile;\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : {};\nvar platform$1 = { exports: {} };\n/*!\n * Platform.js v1.3.6\n * Copyright 2014-2020 Benjamin Tan\n * Copyright 2011-2013 John-David Dalton\n * Available under MIT license\n */\n(function(module, exports) {\n  (function() {\n    var objectTypes = {\n      \"function\": true,\n      \"object\": true\n    };\n    var root = objectTypes[typeof window] && window || this;\n    var freeExports = exports;\n    var freeModule = module && !module.nodeType && module;\n    var freeGlobal = freeExports && freeModule && typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n      root = freeGlobal;\n    }\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n    var reOpera = /\\bOpera/;\n    var objectProto = Object.prototype;\n    var hasOwnProperty2 = objectProto.hasOwnProperty;\n    var toString2 = objectProto.toString;\n    function capitalize(string) {\n      string = String(string);\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n    function cleanupOS(os, pattern, label) {\n      var data = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\\d.]+$/.exec(os)])) {\n        os = \"Windows \" + data;\n      }\n      os = String(os);\n      if (pattern && label) {\n        os = os.replace(RegExp(pattern, \"i\"), label);\n      }\n      os = format2(os.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]);\n      return os;\n    }\n    function each2(object, callback) {\n      var index = -1, length2 = object ? object.length : 0;\n      if (typeof length2 == \"number\" && length2 > -1 && length2 <= maxSafeInteger) {\n        while (++index < length2) {\n          callback(object[index], index, object);\n        }\n      } else {\n        forOwn(object, callback);\n      }\n    }\n    function format2(string) {\n      string = trim2(string);\n      return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);\n    }\n    function forOwn(object, callback) {\n      for (var key in object) {\n        if (hasOwnProperty2.call(object, key)) {\n          callback(object[key], key, object);\n        }\n      }\n    }\n    function getClassOf(value2) {\n      return value2 == null ? capitalize(value2) : toString2.call(value2).slice(8, -1);\n    }\n    function isHostType(object, property) {\n      var type = object != null ? typeof object[property] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == \"object\" ? !!object[property] : true);\n    }\n    function qualify(string) {\n      return String(string).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function reduce(array, callback) {\n      var accumulator = null;\n      each2(array, function(value2, index) {\n        accumulator = callback(accumulator, value2, index, array);\n      });\n      return accumulator;\n    }\n    function trim2(string) {\n      return String(string).replace(/^ +| +$/g, \"\");\n    }\n    function parse2(ua) {\n      var context2 = root;\n      var isCustomContext = ua && typeof ua == \"object\" && getClassOf(ua) != \"String\";\n      if (isCustomContext) {\n        context2 = ua;\n        ua = null;\n      }\n      var nav = context2.navigator || {};\n      var userAgent = nav.userAgent || \"\";\n      ua || (ua = userAgent);\n      var likeChrome = isCustomContext ? !!nav.likeChrome : /\\bChrome\\b/.test(ua) && !/internal|\\n/i.test(toString2.toString());\n      var objectClass = \"Object\", airRuntimeClass = isCustomContext ? objectClass : \"ScriptBridgingProxyObject\", enviroClass = isCustomContext ? objectClass : \"Environment\", javaClass = isCustomContext && context2.java ? \"JavaPackage\" : getClassOf(context2.java), phantomClass = isCustomContext ? objectClass : \"RuntimeObject\";\n      var java = /\\bJava/.test(javaClass) && context2.java;\n      var rhino = java && getClassOf(context2.environment) == enviroClass;\n      var alpha = java ? \"a\" : \"\\u03B1\";\n      var beta = java ? \"b\" : \"\\u03B2\";\n      var doc2 = context2.document || {};\n      var opera = context2.operamini || context2.opera;\n      var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera[\"[[Class]]\"] : getClassOf(opera)) ? operaClass : opera = null;\n      var data;\n      var arch = ua;\n      var description = [];\n      var prerelease = null;\n      var useFeatures = ua == userAgent;\n      var version2 = useFeatures && opera && typeof opera.version == \"function\" && opera.version();\n      var isSpecialCasedOS;\n      var layout = getLayout([\n        { \"label\": \"EdgeHTML\", \"pattern\": \"Edge\" },\n        \"Trident\",\n        { \"label\": \"WebKit\", \"pattern\": \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]);\n      var name = getName([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { \"label\": \"Microsoft Edge\", \"pattern\": \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { \"label\": \"Samsung Internet\", \"pattern\": \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { \"label\": \"Silk\", \"pattern\": \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { \"label\": \"SRWare Iron\", \"pattern\": \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { \"label\": \"Yandex Browser\", \"pattern\": \"YaBrowser\" },\n        { \"label\": \"UC Browser\", \"pattern\": \"UCBrowser\" },\n        \"Opera Mini\",\n        { \"label\": \"Opera Mini\", \"pattern\": \"OPiOS\" },\n        \"Opera\",\n        { \"label\": \"Opera\", \"pattern\": \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { \"label\": \"Chrome\", \"pattern\": \"(?:HeadlessChrome)\" },\n        { \"label\": \"Chrome Mobile\", \"pattern\": \"(?:CriOS|CrMo)\" },\n        { \"label\": \"Firefox\", \"pattern\": \"(?:Firefox|Minefield)\" },\n        { \"label\": \"Firefox for iOS\", \"pattern\": \"FxiOS\" },\n        { \"label\": \"IE\", \"pattern\": \"IEMobile\" },\n        { \"label\": \"IE\", \"pattern\": \"MSIE\" },\n        \"Safari\"\n      ]);\n      var product = getProduct([\n        { \"label\": \"BlackBerry\", \"pattern\": \"BB10\" },\n        \"BlackBerry\",\n        { \"label\": \"Galaxy S\", \"pattern\": \"GT-I9000\" },\n        { \"label\": \"Galaxy S2\", \"pattern\": \"GT-I9100\" },\n        { \"label\": \"Galaxy S3\", \"pattern\": \"GT-I9300\" },\n        { \"label\": \"Galaxy S4\", \"pattern\": \"GT-I9500\" },\n        { \"label\": \"Galaxy S5\", \"pattern\": \"SM-G900\" },\n        { \"label\": \"Galaxy S6\", \"pattern\": \"SM-G920\" },\n        { \"label\": \"Galaxy S6 Edge\", \"pattern\": \"SM-G925\" },\n        { \"label\": \"Galaxy S7\", \"pattern\": \"SM-G930\" },\n        { \"label\": \"Galaxy S7 Edge\", \"pattern\": \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { \"label\": \"Kindle Fire\", \"pattern\": \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { \"label\": \"Wii U\", \"pattern\": \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { \"label\": \"Xbox 360\", \"pattern\": \"Xbox\" },\n        \"Xoom\"\n      ]);\n      var manufacturer = getManufacturer({\n        \"Apple\": { \"iPad\": 1, \"iPhone\": 1, \"iPod\": 1 },\n        \"Alcatel\": {},\n        \"Archos\": {},\n        \"Amazon\": { \"Kindle\": 1, \"Kindle Fire\": 1 },\n        \"Asus\": { \"Transformer\": 1 },\n        \"Barnes & Noble\": { \"Nook\": 1 },\n        \"BlackBerry\": { \"PlayBook\": 1 },\n        \"Google\": { \"Google TV\": 1, \"Nexus\": 1 },\n        \"HP\": { \"TouchPad\": 1 },\n        \"HTC\": {},\n        \"Huawei\": {},\n        \"Lenovo\": {},\n        \"LG\": {},\n        \"Microsoft\": { \"Xbox\": 1, \"Xbox One\": 1 },\n        \"Motorola\": { \"Xoom\": 1 },\n        \"Nintendo\": { \"Wii U\": 1, \"Wii\": 1 },\n        \"Nokia\": { \"Lumia\": 1 },\n        \"Oppo\": {},\n        \"Samsung\": { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        \"Sony\": { \"PlayStation\": 1, \"PlayStation Vita\": 1 },\n        \"Xiaomi\": { \"Mi\": 1, \"Redmi\": 1 }\n      });\n      var os = getOS([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { \"label\": \"Chrome OS\", \"pattern\": \"CrOS\" },\n        \"Debian\",\n        { \"label\": \"DragonFly BSD\", \"pattern\": \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function getLayout(guesses) {\n        return reduce(guesses, function(result, guess) {\n          return result || RegExp(\"\\\\b\" + (guess.pattern || qualify(guess)) + \"\\\\b\", \"i\").exec(ua) && (guess.label || guess);\n        });\n      }\n      function getManufacturer(guesses) {\n        return reduce(guesses, function(result, value2, key) {\n          return result || (value2[product] || value2[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(product)] || RegExp(\"\\\\b\" + qualify(key) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(ua)) && key;\n        });\n      }\n      function getName(guesses) {\n        return reduce(guesses, function(result, guess) {\n          return result || RegExp(\"\\\\b\" + (guess.pattern || qualify(guess)) + \"\\\\b\", \"i\").exec(ua) && (guess.label || guess);\n        });\n      }\n      function getOS(guesses) {\n        return reduce(guesses, function(result, guess) {\n          var pattern = guess.pattern || qualify(guess);\n          if (!result && (result = RegExp(\"\\\\b\" + pattern + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(ua))) {\n            result = cleanupOS(result, pattern, guess.label || guess);\n          }\n          return result;\n        });\n      }\n      function getProduct(guesses) {\n        return reduce(guesses, function(result, guess) {\n          var pattern = guess.pattern || qualify(guess);\n          if (!result && (result = RegExp(\"\\\\b\" + pattern + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(ua) || RegExp(\"\\\\b\" + pattern + \" *\\\\w+-[\\\\w]*\", \"i\").exec(ua) || RegExp(\"\\\\b\" + pattern + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(ua))) {\n            if ((result = String(guess.label && !RegExp(pattern, \"i\").test(guess.label) ? guess.label : result).split(\"/\"))[1] && !/[\\d.]+/.test(result[0])) {\n              result[0] += \" \" + result[1];\n            }\n            guess = guess.label || guess;\n            result = format2(result[0].replace(RegExp(pattern, \"i\"), guess).replace(RegExp(\"; *(?:\" + guess + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + guess + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"));\n          }\n          return result;\n        });\n      }\n      function getVersion(patterns) {\n        return reduce(patterns, function(result, pattern) {\n          return result || (RegExp(pattern + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(ua) || 0)[1] || null;\n        });\n      }\n      function toStringPlatform() {\n        return this.description || \"\";\n      }\n      layout && (layout = [layout]);\n      if (/\\bAndroid\\b/.test(os) && !product && (data = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(ua))) {\n        product = trim2(data[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null;\n      }\n      if (manufacturer && !product) {\n        product = getProduct([manufacturer]);\n      } else if (manufacturer && product) {\n        product = product.replace(RegExp(\"^(\" + qualify(manufacturer) + \")[-_.\\\\s]\", \"i\"), manufacturer + \" \").replace(RegExp(\"^(\" + qualify(manufacturer) + \")[-_.]?(\\\\w)\", \"i\"), manufacturer + \" $2\");\n      }\n      if (data = /\\bGoogle TV\\b/.exec(product)) {\n        product = data[0];\n      }\n      if (/\\bSimulator\\b/i.test(ua)) {\n        product = (product ? product + \" \" : \"\") + \"Simulator\";\n      }\n      if (name == \"Opera Mini\" && /\\bOPiOS\\b/.test(ua)) {\n        description.push(\"running in Turbo/Uncompressed mode\");\n      }\n      if (name == \"IE\" && /\\blike iPhone OS\\b/.test(ua)) {\n        data = parse2(ua.replace(/like iPhone OS/, \"\"));\n        manufacturer = data.manufacturer;\n        product = data.product;\n      } else if (/^iP/.test(product)) {\n        name || (name = \"Safari\");\n        os = \"iOS\" + ((data = / OS ([\\d_]+)/i.exec(ua)) ? \" \" + data[1].replace(/_/g, \".\") : \"\");\n      } else if (name == \"Konqueror\" && /^Linux\\b/i.test(os)) {\n        os = \"Kubuntu\";\n      } else if (manufacturer && manufacturer != \"Google\" && (/Chrome/.test(name) && !/\\bMobile Safari\\b/i.test(ua) || /\\bVita\\b/.test(product)) || /\\bAndroid\\b/.test(os) && /^Chrome/.test(name) && /\\bVersion\\//i.test(ua)) {\n        name = \"Android Browser\";\n        os = /\\bAndroid\\b/.test(os) ? os : \"Android\";\n      } else if (name == \"Silk\") {\n        if (!/\\bMobi/i.test(ua)) {\n          os = \"Android\";\n          description.unshift(\"desktop mode\");\n        }\n        if (/Accelerated *= *true/i.test(ua)) {\n          description.unshift(\"accelerated\");\n        }\n      } else if (name == \"UC Browser\" && /\\bUCWEB\\b/.test(ua)) {\n        description.push(\"speed mode\");\n      } else if (name == \"PaleMoon\" && (data = /\\bFirefox\\/([\\d.]+)\\b/.exec(ua))) {\n        description.push(\"identifying as Firefox \" + data[1]);\n      } else if (name == \"Firefox\" && (data = /\\b(Mobile|Tablet|TV)\\b/i.exec(ua))) {\n        os || (os = \"Firefox OS\");\n        product || (product = data[1]);\n      } else if (!name || (data = !/\\bMinefield\\b/i.test(ua) && /\\b(?:Firefox|Safari)\\b/.exec(name))) {\n        if (name && !product && /[\\/,]|^[^(]+?\\)/.test(ua.slice(ua.indexOf(data + \"/\") + 8))) {\n          name = null;\n        }\n        if ((data = product || manufacturer || os) && (product || manufacturer || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(os))) {\n          name = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(os) ? os : data) + \" Browser\";\n        }\n      } else if (name == \"Electron\" && (data = (/\\bChrome\\/([\\d.]+)\\b/.exec(ua) || 0)[1])) {\n        description.push(\"Chromium \" + data);\n      }\n      if (!version2) {\n        version2 = getVersion([\n          \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n          \"Version\",\n          qualify(name),\n          \"(?:Firefox|Minefield|NetFront)\"\n        ]);\n      }\n      if (data = layout == \"iCab\" && parseFloat(version2) > 3 && \"WebKit\" || /\\bOpera\\b/.test(name) && (/\\bOPR\\b/.test(ua) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && \"WebKit\" || !layout && /\\bMSIE\\b/i.test(ua) && (os == \"Mac OS\" ? \"Tasman\" : \"Trident\") || layout == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(name) && \"NetFront\") {\n        layout = [data];\n      }\n      if (name == \"IE\" && (data = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(ua) || 0)[1])) {\n        name += \" Mobile\";\n        os = \"Windows Phone \" + (/\\+$/.test(data) ? data : data + \".x\");\n        description.unshift(\"desktop mode\");\n      } else if (/\\bWPDesktop\\b/i.test(ua)) {\n        name = \"IE Mobile\";\n        os = \"Windows Phone 8.x\";\n        description.unshift(\"desktop mode\");\n        version2 || (version2 = (/\\brv:([\\d.]+)/.exec(ua) || 0)[1]);\n      } else if (name != \"IE\" && layout == \"Trident\" && (data = /\\brv:([\\d.]+)/.exec(ua))) {\n        if (name) {\n          description.push(\"identifying as \" + name + (version2 ? \" \" + version2 : \"\"));\n        }\n        name = \"IE\";\n        version2 = data[1];\n      }\n      if (useFeatures) {\n        if (isHostType(context2, \"global\")) {\n          if (java) {\n            data = java.lang.System;\n            arch = data.getProperty(\"os.arch\");\n            os = os || data.getProperty(\"os.name\") + \" \" + data.getProperty(\"os.version\");\n          }\n          if (rhino) {\n            try {\n              version2 = context2.require(\"ringo/engine\").version.join(\".\");\n              name = \"RingoJS\";\n            } catch (e) {\n              if ((data = context2.system) && data.global.system == context2.system) {\n                name = \"Narwhal\";\n                os || (os = data[0].os || null);\n              }\n            }\n            if (!name) {\n              name = \"Rhino\";\n            }\n          } else if (typeof context2.process == \"object\" && !context2.process.browser && (data = context2.process)) {\n            if (typeof data.versions == \"object\") {\n              if (typeof data.versions.electron == \"string\") {\n                description.push(\"Node \" + data.versions.node);\n                name = \"Electron\";\n                version2 = data.versions.electron;\n              } else if (typeof data.versions.nw == \"string\") {\n                description.push(\"Chromium \" + version2, \"Node \" + data.versions.node);\n                name = \"NW.js\";\n                version2 = data.versions.nw;\n              }\n            }\n            if (!name) {\n              name = \"Node.js\";\n              arch = data.arch;\n              os = data.platform;\n              version2 = /[\\d.]+/.exec(data.version);\n              version2 = version2 ? version2[0] : null;\n            }\n          }\n        } else if (getClassOf(data = context2.runtime) == airRuntimeClass) {\n          name = \"Adobe AIR\";\n          os = data.flash.system.Capabilities.os;\n        } else if (getClassOf(data = context2.phantom) == phantomClass) {\n          name = \"PhantomJS\";\n          version2 = (data = data.version || null) && data.major + \".\" + data.minor + \".\" + data.patch;\n        } else if (typeof doc2.documentMode == \"number\" && (data = /\\bTrident\\/(\\d+)/i.exec(ua))) {\n          version2 = [version2, doc2.documentMode];\n          if ((data = +data[1] + 4) != version2[1]) {\n            description.push(\"IE \" + version2[1] + \" mode\");\n            layout && (layout[1] = \"\");\n            version2[1] = data;\n          }\n          version2 = name == \"IE\" ? String(version2[1].toFixed(1)) : version2[0];\n        } else if (typeof doc2.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(name)) {\n          description.push(\"masking as \" + name + \" \" + version2);\n          name = \"IE\";\n          version2 = \"11.0\";\n          layout = [\"Trident\"];\n          os = \"Windows\";\n        }\n        os = os && format2(os);\n      }\n      if (version2 && (data = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(version2) || /(?:alpha|beta)(?: ?\\d)?/i.exec(ua + \";\" + (useFeatures && nav.appMinorVersion)) || /\\bMinefield\\b/i.test(ua) && \"a\")) {\n        prerelease = /b/i.test(data) ? \"beta\" : \"alpha\";\n        version2 = version2.replace(RegExp(data + \"\\\\+?$\"), \"\") + (prerelease == \"beta\" ? beta : alpha) + (/\\d+\\+?/.exec(data) || \"\");\n      }\n      if (name == \"Fennec\" || name == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(os)) {\n        name = \"Firefox Mobile\";\n      } else if (name == \"Maxthon\" && version2) {\n        version2 = version2.replace(/\\.[\\d.]+/, \".x\");\n      } else if (/\\bXbox\\b/i.test(product)) {\n        if (product == \"Xbox 360\") {\n          os = null;\n        }\n        if (product == \"Xbox 360\" && /\\bIEMobile\\b/.test(ua)) {\n          description.unshift(\"mobile mode\");\n        }\n      } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == \"Windows CE\" || /Mobi/i.test(ua))) {\n        name += \" Mobile\";\n      } else if (name == \"IE\" && useFeatures) {\n        try {\n          if (context2.external === null) {\n            description.unshift(\"platform preview\");\n          }\n        } catch (e) {\n          description.unshift(\"embedded\");\n        }\n      } else if ((/\\bBlackBerry\\b/.test(product) || /\\bBB10\\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(ua) || 0)[1] || version2)) {\n        data = [data, /BB10/.test(ua)];\n        os = (data[1] ? (product = null, manufacturer = \"BlackBerry\") : \"Device Software\") + \" \" + data[0];\n        version2 = null;\n      } else if (this != forOwn && product != \"Wii\" && (useFeatures && opera || /Opera/.test(name) && /\\b(?:MSIE|Firefox)\\b/i.test(ua) || name == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(os) || name == \"IE\" && (os && !/^Win/.test(os) && version2 > 5.5 || /\\bWindows XP\\b/.test(os) && version2 > 8 || version2 == 8 && !/\\bTrident\\b/.test(ua))) && !reOpera.test(data = parse2.call(forOwn, ua.replace(reOpera, \"\") + \";\")) && data.name) {\n        data = \"ing as \" + data.name + ((data = data.version) ? \" \" + data : \"\");\n        if (reOpera.test(name)) {\n          if (/\\bIE\\b/.test(data) && os == \"Mac OS\") {\n            os = null;\n          }\n          data = \"identify\" + data;\n        } else {\n          data = \"mask\" + data;\n          if (operaClass) {\n            name = format2(operaClass.replace(/([a-z])([A-Z])/g, \"$1 $2\"));\n          } else {\n            name = \"Opera\";\n          }\n          if (/\\bIE\\b/.test(data)) {\n            os = null;\n          }\n          if (!useFeatures) {\n            version2 = null;\n          }\n        }\n        layout = [\"Presto\"];\n        description.push(data);\n      }\n      if (data = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(ua) || 0)[1]) {\n        data = [parseFloat(data.replace(/\\.(\\d)$/, \".0$1\")), data];\n        if (name == \"Safari\" && data[1].slice(-1) == \"+\") {\n          name = \"WebKit Nightly\";\n          prerelease = \"alpha\";\n          version2 = data[1].slice(0, -1);\n        } else if (version2 == data[1] || version2 == (data[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(ua) || 0)[1])) {\n          version2 = null;\n        }\n        data[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(ua) || 0)[1];\n        if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == \"WebKit\") {\n          layout = [\"Blink\"];\n        }\n        if (!useFeatures || !likeChrome && !data[1]) {\n          layout && (layout[1] = \"like Safari\");\n          data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? \"4+\" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : \"12\");\n        } else {\n          layout && (layout[1] = \"like Chrome\");\n          data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? \"13+\" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? \"21+\" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != \"Blink\" ? \"27\" : \"28\");\n        }\n        layout && (layout[1] += \" \" + (data += typeof data == \"number\" ? \".x\" : /[.+]/.test(data) ? \"\" : \"+\"));\n        if (name == \"Safari\" && (!version2 || parseInt(version2) > 45)) {\n          version2 = data;\n        } else if (name == \"Chrome\" && /\\bHeadlessChrome/i.test(ua)) {\n          description.unshift(\"headless\");\n        }\n      }\n      if (name == \"Opera\" && (data = /\\bzbov|zvav$/.exec(os))) {\n        name += \" \";\n        description.unshift(\"desktop mode\");\n        if (data == \"zvav\") {\n          name += \"Mini\";\n          version2 = null;\n        } else {\n          name += \"Mobile\";\n        }\n        os = os.replace(RegExp(\" *\" + data + \"$\"), \"\");\n      } else if (name == \"Safari\" && /\\bChrome\\b/.exec(layout && layout[1])) {\n        description.unshift(\"desktop mode\");\n        name = \"Chrome Mobile\";\n        version2 = null;\n        if (/\\bOS X\\b/.test(os)) {\n          manufacturer = \"Apple\";\n          os = \"iOS 4.3+\";\n        } else {\n          os = null;\n        }\n      } else if (/\\bSRWare Iron\\b/.test(name) && !version2) {\n        version2 = getVersion(\"Chrome\");\n      }\n      if (version2 && version2.indexOf(data = /[\\d.]+$/.exec(os)) == 0 && ua.indexOf(\"/\" + data + \"-\") > -1) {\n        os = trim2(os.replace(data, \"\"));\n      }\n      if (os && os.indexOf(name) != -1 && !RegExp(name + \" OS\").test(os)) {\n        os = os.replace(RegExp(\" *\" + qualify(name) + \" *\"), \"\");\n      }\n      if (layout && !/\\b(?:Avant|Nook)\\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != \"Safari\" && /^iOS/.test(os) && /\\bSafari\\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {\n        (data = layout[layout.length - 1]) && description.push(data);\n      }\n      if (description.length) {\n        description = [\"(\" + description.join(\"; \") + \")\"];\n      }\n      if (manufacturer && product && product.indexOf(manufacturer) < 0) {\n        description.push(\"on \" + manufacturer);\n      }\n      if (product) {\n        description.push((/^on /.test(description[description.length - 1]) ? \"\" : \"on \") + product);\n      }\n      if (os) {\n        data = / ([\\d.+]+)$/.exec(os);\n        isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == \"/\";\n        os = {\n          \"architecture\": 32,\n          \"family\": data && !isSpecialCasedOS ? os.replace(data[0], \"\") : os,\n          \"version\": data ? data[1] : null,\n          \"toString\": function() {\n            var version3 = this.version;\n            return this.family + (version3 && !isSpecialCasedOS ? \" \" + version3 : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n          }\n        };\n      }\n      if ((data = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec(arch)) && !/\\bi686\\b/i.test(arch)) {\n        if (os) {\n          os.architecture = 64;\n          os.family = os.family.replace(RegExp(\" *\" + data), \"\");\n        }\n        if (name && (/\\bWOW64\\b/i.test(ua) || useFeatures && /\\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\\bWin64; x64\\b/i.test(ua))) {\n          description.unshift(\"32-bit\");\n        }\n      } else if (os && /^OS X/.test(os.family) && name == \"Chrome\" && parseFloat(version2) >= 39) {\n        os.architecture = 64;\n      }\n      ua || (ua = null);\n      var platform3 = {};\n      platform3.description = ua;\n      platform3.layout = layout && layout[0];\n      platform3.manufacturer = manufacturer;\n      platform3.name = name;\n      platform3.prerelease = prerelease;\n      platform3.product = product;\n      platform3.ua = ua;\n      platform3.version = name && version2;\n      platform3.os = os || {\n        \"architecture\": null,\n        \"family\": null,\n        \"version\": null,\n        \"toString\": function() {\n          return \"null\";\n        }\n      };\n      platform3.parse = parse2;\n      platform3.toString = toStringPlatform;\n      if (platform3.version) {\n        description.unshift(version2);\n      }\n      if (platform3.name) {\n        description.unshift(name);\n      }\n      if (os && name && !(os == String(os).split(\" \")[0] && (os == name.split(\" \")[0] || product))) {\n        description.push(product ? \"(\" + os + \")\" : \"on \" + os);\n      }\n      if (description.length) {\n        platform3.description = description.join(\" \");\n      }\n      return platform3;\n    }\n    var platform2 = parse2();\n    if (freeExports && freeModule) {\n      forOwn(platform2, function(value2, key) {\n        freeExports[key] = value2;\n      });\n    } else {\n      root.platform = platform2;\n    }\n  }).call(commonjsGlobal);\n})(platform$1, platform$1.exports);\nvar platform = platform$1.exports;\nfunction int(o) {\n  return parseInt(String(o), 10);\n}\nfunction uint(o) {\n  const v2 = parseInt(String(o), 10);\n  return v2 < 0 ? -v2 : v2;\n}\nif (!(\"toInt\" in String.prototype)) {\n  String.prototype.toInt = function() {\n    return int(this);\n  };\n}\nif (!(\"toUint\" in String.prototype)) {\n  String.prototype.toUint = function() {\n    const v2 = int(this);\n    return v2 < 0 ? -v2 : v2;\n  };\n}\nfunction getDateStr(spl_dd = \"/\", spl_dt = \" \", spl_tt = \":\", spl_ms = \"\") {\n  const now2 = new Date();\n  return now2.getFullYear() + spl_dd + String(100 + now2.getMonth() + 1).slice(1, 3) + spl_dd + String(100 + now2.getDate()).slice(1, 3) + spl_dt + String(100 + now2.getHours()).slice(1, 3) + spl_tt + String(100 + now2.getMinutes()).slice(1, 3) + (spl_ms === \"\" ? \"\" : spl_ms + String(now2.getMilliseconds()));\n}\nconst hMemberCnt = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction cnvTweenArg(hArg, lay) {\n  const hTo = {};\n  for (const nm in hMemberCnt) {\n    if (!(nm in hArg))\n      continue;\n    const v2 = String(hArg[nm]);\n    const a2 = (v2.charAt(0) === \"=\" ? v2.slice(1) : v2).split(\",\");\n    const a0 = hTo[nm] = parseFloat(a2[0]);\n    if (a2.length > 1)\n      hTo[nm] += Math.round(Math.random() * (parseFloat(a2[1]) - a0 + 1));\n    if (v2.charAt(0) === \"=\")\n      hTo[nm] += parseFloat(lay[nm]);\n  }\n  return hTo;\n}\nconst css_key4del = \"/* SKYNovel */\";\nfunction initStyle() {\n  const he = document.getElementsByTagName(\"head\")[0];\n  const len = he.children.length;\n  for (let i2 = len - 1; i2 >= 0; --i2) {\n    const v2 = he.children[i2];\n    if (!(v2 instanceof HTMLStyleElement))\n      continue;\n    if (v2.innerText.slice(0, 14) !== css_key4del)\n      continue;\n    he.removeChild(v2);\n  }\n}\nfunction addStyle(style) {\n  const gs = document.createElement(\"style\");\n  gs.innerHTML = css_key4del + style;\n  document.getElementsByTagName(\"head\")[0].appendChild(gs);\n}\nfunction argChk_Num(hash2, name2, def) {\n  const v2 = hash2[name2];\n  if (!(name2 in hash2)) {\n    if (isNaN(def))\n      throw `[${hash2[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${name2} \\u306F\\u5FC5\\u9808\\u3067\\u3059`;\n    hash2[name2] = def;\n    return def;\n  }\n  const n = String(v2).slice(0, 2) === \"0x\" ? parseInt(v2) : parseFloat(v2);\n  if (isNaN(n))\n    throw `[${hash2[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${name2} \\u306E\\u5024\\u3010${v2}\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  return hash2[name2] = n;\n}\nfunction argChk_Boolean(hash2, name2, def) {\n  if (!(name2 in hash2))\n    return hash2[name2] = def;\n  const v2 = hash2[name2];\n  if (v2 === null)\n    return false;\n  const v22 = String(v2);\n  return hash2[name2] = v22 === \"false\" ? false : Boolean(v22);\n}\nfunction parseColor(v2) {\n  if (v2.charAt(0) === \"#\")\n    return parseInt(v2.slice(1), 16);\n  const n = Number(v2);\n  if (!isNaN(n))\n    return n;\n  if (v2 === \"black\")\n    return 0;\n  CmnLib.cc4ColorName.fillStyle = v2;\n  const cc = CmnLib.cc4ColorName.fillStyle;\n  if (cc === \"#000000\")\n    throw `\\u8272\\u540D\\u524D ${v2} \\u304C\\u7570\\u5E38\\u3067\\u3059`;\n  return parseInt(cc.slice(1), 16);\n}\nfunction argChk_Color(hash2, name2, def) {\n  const v2 = hash2[name2];\n  if (!v2)\n    return hash2[name2] = def;\n  return hash2[name2] = parseColor(String(v2));\n}\nconst REG_ERRMES_JSON = /JSON at position (\\d+)$/;\nfunction mesErrJSON(hArg, nm = \"\", mes = \"\") {\n  var _a3;\n  const col = ((_a3 = mes.match(REG_ERRMES_JSON)) != null ? _a3 : [\"\", \"\"])[1];\n  return `[${hArg[\":\\u30BF\\u30B0\\u540D\"]}] ${nm} \\u5C5E\\u6027\\u306E\\u89E3\\u6790\\u30A8\\u30E9\\u30FC : ${mes}\n${hArg[nm]}${col ? `\n${\"^\".padStart(Number(col))}` : ``}`;\n}\nconst REG_FN = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction getFn(p2) {\n  var _a3;\n  return ((_a3 = p2.match(REG_FN)) != null ? _a3 : [\"\"])[0];\n}\nconst REG_EXT = /\\.([^\\.]+)$/;\nfunction getExt(p2) {\n  var _a3;\n  return ((_a3 = p2.match(REG_EXT)) != null ? _a3 : [\"\", \"\"])[1];\n}\nclass CmnLib {\n}\nCmnLib.stageW = 0;\nCmnLib.stageH = 0;\nCmnLib.debugLog = false;\nCmnLib.isSafari = platform$1.exports.name === \"Safari\";\nCmnLib.isFirefox = platform$1.exports.name === \"Firefox\";\nCmnLib.isMac = new RegExp(\"OS X\").test((_b2 = (_a2 = platform$1.exports.os) == null ? void 0 : _a2.family) != null ? _b2 : \"\");\nCmnLib.isMobile = !new RegExp(\"(Windows|OS X)\").test((_d = (_c2 = platform$1.exports.os) == null ? void 0 : _c2.family) != null ? _d : \"\");\nCmnLib.hDip = {};\nCmnLib.isDbg = false;\nCmnLib.isPackaged = false;\nCmnLib.isDarkMode = false;\nconst PACKET_TYPES = /* @__PURE__ */ Object.create(null);\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\nObject.keys(PACKET_TYPES).forEach((key) => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nconst withNativeBlob$1 = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\nconst withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\nconst isView$1 = (obj) => {\n  return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n  if (withNativeBlob$1 && data instanceof Blob) {\n    if (supportsBinary) {\n      return callback(data);\n    } else {\n      return encodeBlobAsBase64(data, callback);\n    }\n  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {\n    if (supportsBinary) {\n      return callback(data);\n    } else {\n      return encodeBlobAsBase64(new Blob([data]), callback);\n    }\n  }\n  return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n  const fileReader = new FileReader();\n  fileReader.onload = function() {\n    const content = fileReader.result.split(\",\")[1];\n    callback(\"b\" + content);\n  };\n  return fileReader.readAsDataURL(data);\n};\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst lookup$1 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (let i2 = 0; i2 < chars.length; i2++) {\n  lookup$1[chars.charCodeAt(i2)] = i2;\n}\nconst decode$2 = (base64) => {\n  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup$1[base64.charCodeAt(i2)];\n    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];\n    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];\n    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];\n    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\nconst withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n  const type = encodedPacket.charAt(0);\n  if (type === \"b\") {\n    return {\n      type: \"message\",\n      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n    };\n  }\n  const packetType = PACKET_TYPES_REVERSE[type];\n  if (!packetType) {\n    return ERROR_PACKET;\n  }\n  return encodedPacket.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[type],\n    data: encodedPacket.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[type]\n  };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n  if (withNativeArrayBuffer$1) {\n    const decoded = decode$2(data);\n    return mapBinary(decoded, binaryType);\n  } else {\n    return { base64: true, data };\n  }\n};\nconst mapBinary = (data, binaryType) => {\n  switch (binaryType) {\n    case \"blob\":\n      return data instanceof ArrayBuffer ? new Blob([data]) : data;\n    case \"arraybuffer\":\n    default:\n      return data;\n  }\n};\nconst SEPARATOR = String.fromCharCode(30);\nconst encodePayload = (packets, callback) => {\n  const length2 = packets.length;\n  const encodedPackets = new Array(length2);\n  let count = 0;\n  packets.forEach((packet, i2) => {\n    encodePacket(packet, false, (encodedPacket) => {\n      encodedPackets[i2] = encodedPacket;\n      if (++count === length2) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n  const encodedPackets = encodedPayload.split(SEPARATOR);\n  const packets = [];\n  for (let i2 = 0; i2 < encodedPackets.length; i2++) {\n    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);\n    packets.push(decodedPacket);\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n  return packets;\n};\nconst protocol$1 = 4;\nfunction Emitter(obj) {\n  if (obj)\n    return mixin(obj);\n}\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\nEmitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn2) {\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn2);\n  return this;\n};\nEmitter.prototype.once = function(event, fn2) {\n  function on2() {\n    this.off(event, on2);\n    fn2.apply(this, arguments);\n  }\n  on2.fn = fn2;\n  this.on(event, on2);\n  return this;\n};\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn2) {\n  this._callbacks = this._callbacks || {};\n  if (arguments.length == 0) {\n    this._callbacks = {};\n    return this;\n  }\n  var callbacks = this._callbacks[\"$\" + event];\n  if (!callbacks)\n    return this;\n  if (arguments.length == 1) {\n    delete this._callbacks[\"$\" + event];\n    return this;\n  }\n  var cb;\n  for (var i2 = 0; i2 < callbacks.length; i2++) {\n    cb = callbacks[i2];\n    if (cb === fn2 || cb.fn === fn2) {\n      callbacks.splice(i2, 1);\n      break;\n    }\n  }\n  if (callbacks.length === 0) {\n    delete this._callbacks[\"$\" + event];\n  }\n  return this;\n};\nEmitter.prototype.emit = function(event) {\n  this._callbacks = this._callbacks || {};\n  var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n  for (var i2 = 1; i2 < arguments.length; i2++) {\n    args[i2 - 1] = arguments[i2];\n  }\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {\n      callbacks[i2].apply(this, args);\n    }\n  }\n  return this;\n};\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\nEmitter.prototype.listeners = function(event) {\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[\"$\" + event] || [];\n};\nEmitter.prototype.hasListeners = function(event) {\n  return !!this.listeners(event).length;\n};\nconst globalThisShim = (() => {\n  if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else {\n    return Function(\"return this\")();\n  }\n})();\nfunction pick(obj, ...attr) {\n  return attr.reduce((acc, k) => {\n    if (obj.hasOwnProperty(k)) {\n      acc[k] = obj[k];\n    }\n    return acc;\n  }, {});\n}\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n  if (opts.useNativeTimers) {\n    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);\n    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);\n  } else {\n    obj.setTimeoutFn = setTimeout.bind(globalThisShim);\n    obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);\n  }\n}\nconst BASE64_OVERHEAD = 1.33;\nfunction byteLength(obj) {\n  if (typeof obj === \"string\") {\n    return utf8Length(obj);\n  }\n  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str2) {\n  let c2 = 0, length2 = 0;\n  for (let i2 = 0, l2 = str2.length; i2 < l2; i2++) {\n    c2 = str2.charCodeAt(i2);\n    if (c2 < 128) {\n      length2 += 1;\n    } else if (c2 < 2048) {\n      length2 += 2;\n    } else if (c2 < 55296 || c2 >= 57344) {\n      length2 += 3;\n    } else {\n      i2++;\n      length2 += 4;\n    }\n  }\n  return length2;\n}\nclass TransportError extends Error {\n  constructor(reason, description, context2) {\n    super(reason);\n    this.description = description;\n    this.context = context2;\n    this.type = \"TransportError\";\n  }\n}\nclass Transport extends Emitter {\n  constructor(opts) {\n    super();\n    this.writable = false;\n    installTimerFunctions(this, opts);\n    this.opts = opts;\n    this.query = opts.query;\n    this.readyState = \"\";\n    this.socket = opts.socket;\n  }\n  onError(reason, description, context2) {\n    super.emitReserved(\"error\", new TransportError(reason, description, context2));\n    return this;\n  }\n  open() {\n    if (this.readyState === \"closed\" || this.readyState === \"\") {\n      this.readyState = \"opening\";\n      this.doOpen();\n    }\n    return this;\n  }\n  close() {\n    if (this.readyState === \"opening\" || this.readyState === \"open\") {\n      this.doClose();\n      this.onClose();\n    }\n    return this;\n  }\n  send(packets) {\n    if (this.readyState === \"open\") {\n      this.write(packets);\n    }\n  }\n  onOpen() {\n    this.readyState = \"open\";\n    this.writable = true;\n    super.emitReserved(\"open\");\n  }\n  onData(data) {\n    const packet = decodePacket(data, this.socket.binaryType);\n    this.onPacket(packet);\n  }\n  onPacket(packet) {\n    super.emitReserved(\"packet\", packet);\n  }\n  onClose(details) {\n    this.readyState = \"closed\";\n    super.emitReserved(\"close\", details);\n  }\n}\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map$3 = {};\nlet seed = 0, i = 0, prev;\nfunction encode$2(num) {\n  let encoded = \"\";\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n  return encoded;\n}\nfunction yeast() {\n  const now2 = encode$2(+new Date());\n  if (now2 !== prev)\n    return seed = 0, prev = now2;\n  return now2 + \".\" + encode$2(seed++);\n}\nfor (; i < length; i++)\n  map$3[alphabet[i]] = i;\nfunction encode$1(obj) {\n  let str2 = \"\";\n  for (let i2 in obj) {\n    if (obj.hasOwnProperty(i2)) {\n      if (str2.length)\n        str2 += \"&\";\n      str2 += encodeURIComponent(i2) + \"=\" + encodeURIComponent(obj[i2]);\n    }\n  }\n  return str2;\n}\nfunction decode$1(qs) {\n  let qry = {};\n  let pairs = qs.split(\"&\");\n  for (let i2 = 0, l2 = pairs.length; i2 < l2; i2++) {\n    let pair = pairs[i2].split(\"=\");\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n}\nlet value = false;\ntry {\n  value = typeof XMLHttpRequest !== \"undefined\" && \"withCredentials\" in new XMLHttpRequest();\n} catch (err) {\n}\nconst hasCORS = value;\nfunction XHR(opts) {\n  const xdomain = opts.xdomain;\n  try {\n    if (typeof XMLHttpRequest !== \"undefined\" && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) {\n  }\n  if (!xdomain) {\n    try {\n      return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch (e) {\n    }\n  }\n}\nfunction empty() {\n}\nconst hasXHR2 = function() {\n  const xhr = new XHR({\n    xdomain: false\n  });\n  return xhr.responseType != null;\n}();\nclass Polling extends Transport {\n  constructor(opts) {\n    super(opts);\n    this.polling = false;\n    if (typeof location !== \"undefined\") {\n      const isSSL = location.protocol === \"https:\";\n      let port = location.port;\n      if (!port) {\n        port = isSSL ? \"443\" : \"80\";\n      }\n      this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n      this.xs = opts.secure !== isSSL;\n    }\n    const forceBase64 = opts && opts.forceBase64;\n    this.supportsBinary = hasXHR2 && !forceBase64;\n  }\n  get name() {\n    return \"polling\";\n  }\n  doOpen() {\n    this.poll();\n  }\n  pause(onPause) {\n    this.readyState = \"pausing\";\n    const pause = () => {\n      this.readyState = \"paused\";\n      onPause();\n    };\n    if (this.polling || !this.writable) {\n      let total = 0;\n      if (this.polling) {\n        total++;\n        this.once(\"pollComplete\", function() {\n          --total || pause();\n        });\n      }\n      if (!this.writable) {\n        total++;\n        this.once(\"drain\", function() {\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n  poll() {\n    this.polling = true;\n    this.doPoll();\n    this.emitReserved(\"poll\");\n  }\n  onData(data) {\n    const callback = (packet) => {\n      if (this.readyState === \"opening\" && packet.type === \"open\") {\n        this.onOpen();\n      }\n      if (packet.type === \"close\") {\n        this.onClose({ description: \"transport closed by the server\" });\n        return false;\n      }\n      this.onPacket(packet);\n    };\n    decodePayload(data, this.socket.binaryType).forEach(callback);\n    if (this.readyState !== \"closed\") {\n      this.polling = false;\n      this.emitReserved(\"pollComplete\");\n      if (this.readyState === \"open\") {\n        this.poll();\n      }\n    }\n  }\n  doClose() {\n    const close = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    if (this.readyState === \"open\") {\n      close();\n    } else {\n      this.once(\"open\", close);\n    }\n  }\n  write(packets) {\n    this.writable = false;\n    encodePayload(packets, (data) => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emitReserved(\"drain\");\n      });\n    });\n  }\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\";\n    if (this.opts.timestampRequests !== false) {\n      query[this.opts.timestampParam] = yeast();\n    }\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    }\n    if (this.opts.port && (schema === \"https\" && Number(this.opts.port) !== 443 || schema === \"http\" && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    }\n    const encodedQuery = encode$1(query);\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n  }\n  request(opts = {}) {\n    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n    return new Request(this.uri(), opts);\n  }\n  doWrite(data, fn2) {\n    const req = this.request({\n      method: \"POST\",\n      data\n    });\n    req.on(\"success\", fn2);\n    req.on(\"error\", (xhrStatus, context2) => {\n      this.onError(\"xhr post error\", xhrStatus, context2);\n    });\n  }\n  doPoll() {\n    const req = this.request();\n    req.on(\"data\", this.onData.bind(this));\n    req.on(\"error\", (xhrStatus, context2) => {\n      this.onError(\"xhr poll error\", xhrStatus, context2);\n    });\n    this.pollXhr = req;\n  }\n}\nclass Request extends Emitter {\n  constructor(uri, opts) {\n    super();\n    installTimerFunctions(this, opts);\n    this.opts = opts;\n    this.method = opts.method || \"GET\";\n    this.uri = uri;\n    this.async = opts.async !== false;\n    this.data = opts.data !== void 0 ? opts.data : null;\n    this.create();\n  }\n  create() {\n    const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    opts.xdomain = !!this.opts.xd;\n    opts.xscheme = !!this.opts.xs;\n    const xhr = this.xhr = new XHR(opts);\n    try {\n      xhr.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n          for (let i2 in this.opts.extraHeaders) {\n            if (this.opts.extraHeaders.hasOwnProperty(i2)) {\n              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);\n            }\n          }\n        }\n      } catch (e) {\n      }\n      if (this.method === \"POST\") {\n        try {\n          xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch (e) {\n        }\n      }\n      try {\n        xhr.setRequestHeader(\"Accept\", \"*/*\");\n      } catch (e) {\n      }\n      if (\"withCredentials\" in xhr) {\n        xhr.withCredentials = this.opts.withCredentials;\n      }\n      if (this.opts.requestTimeout) {\n        xhr.timeout = this.opts.requestTimeout;\n      }\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState !== 4)\n          return;\n        if (xhr.status === 200 || xhr.status === 1223) {\n          this.onLoad();\n        } else {\n          this.setTimeoutFn(() => {\n            this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n          }, 0);\n        }\n      };\n      xhr.send(this.data);\n    } catch (e) {\n      this.setTimeoutFn(() => {\n        this.onError(e);\n      }, 0);\n      return;\n    }\n    if (typeof document !== \"undefined\") {\n      this.index = Request.requestsCount++;\n      Request.requests[this.index] = this;\n    }\n  }\n  onError(err) {\n    this.emitReserved(\"error\", err, this.xhr);\n    this.cleanup(true);\n  }\n  cleanup(fromError) {\n    if (typeof this.xhr === \"undefined\" || this.xhr === null) {\n      return;\n    }\n    this.xhr.onreadystatechange = empty;\n    if (fromError) {\n      try {\n        this.xhr.abort();\n      } catch (e) {\n      }\n    }\n    if (typeof document !== \"undefined\") {\n      delete Request.requests[this.index];\n    }\n    this.xhr = null;\n  }\n  onLoad() {\n    const data = this.xhr.responseText;\n    if (data !== null) {\n      this.emitReserved(\"data\", data);\n      this.emitReserved(\"success\");\n      this.cleanup();\n    }\n  }\n  abort() {\n    this.cleanup();\n  }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\nif (typeof document !== \"undefined\") {\n  if (typeof attachEvent === \"function\") {\n    attachEvent(\"onunload\", unloadHandler);\n  } else if (typeof addEventListener === \"function\") {\n    const terminationEvent = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(terminationEvent, unloadHandler, false);\n  }\n}\nfunction unloadHandler() {\n  for (let i2 in Request.requests) {\n    if (Request.requests.hasOwnProperty(i2)) {\n      Request.requests[i2].abort();\n    }\n  }\n}\nconst nextTick = (() => {\n  const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n  if (isPromiseAvailable) {\n    return (cb) => Promise.resolve().then(cb);\n  } else {\n    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n  }\n})();\nconst WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;\nconst usingBrowserWebSocket = true;\nconst defaultBinaryType = \"arraybuffer\";\nconst isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n  constructor(opts) {\n    super(opts);\n    this.supportsBinary = !opts.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check()) {\n      return;\n    }\n    const uri = this.uri();\n    const protocols = this.opts.protocols;\n    const opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    if (this.opts.extraHeaders) {\n      opts.headers = this.opts.extraHeaders;\n    }\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n    } catch (err) {\n      return this.emitReserved(\"error\", err);\n    }\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;\n    this.addEventListeners();\n  }\n  addEventListeners() {\n    this.ws.onopen = () => {\n      if (this.opts.autoUnref) {\n        this.ws._socket.unref();\n      }\n      this.onOpen();\n    };\n    this.ws.onclose = (closeEvent) => this.onClose({\n      description: \"websocket connection closed\",\n      context: closeEvent\n    });\n    this.ws.onmessage = (ev) => this.onData(ev.data);\n    this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n  }\n  write(packets) {\n    this.writable = false;\n    for (let i2 = 0; i2 < packets.length; i2++) {\n      const packet = packets[i2];\n      const lastPacket = i2 === packets.length - 1;\n      encodePacket(packet, this.supportsBinary, (data) => {\n        const opts = {};\n        try {\n          if (usingBrowserWebSocket) {\n            this.ws.send(data);\n          }\n        } catch (e) {\n        }\n        if (lastPacket) {\n          nextTick(() => {\n            this.writable = true;\n            this.emitReserved(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  doClose() {\n    if (typeof this.ws !== \"undefined\") {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"wss\" : \"ws\";\n    let port = \"\";\n    if (this.opts.port && (schema === \"wss\" && Number(this.opts.port) !== 443 || schema === \"ws\" && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    }\n    if (this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    }\n    if (!this.supportsBinary) {\n      query.b64 = 1;\n    }\n    const encodedQuery = encode$1(query);\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n  }\n  check() {\n    return !!WebSocket;\n  }\n}\nconst transports = {\n  websocket: WS,\n  polling: Polling\n};\nconst re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction parse$2(str2) {\n  const src = str2, b2 = str2.indexOf(\"[\"), e = str2.indexOf(\"]\");\n  if (b2 != -1 && e != -1) {\n    str2 = str2.substring(0, b2) + str2.substring(b2, e).replace(/:/g, \";\") + str2.substring(e, str2.length);\n  }\n  let m2 = re.exec(str2 || \"\"), uri = {}, i2 = 14;\n  while (i2--) {\n    uri[parts[i2]] = m2[i2] || \"\";\n  }\n  if (b2 != -1 && e != -1) {\n    uri.source = src;\n    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\");\n    uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\");\n    uri.ipv6uri = true;\n  }\n  uri.pathNames = pathNames(uri, uri[\"path\"]);\n  uri.queryKey = queryKey(uri, uri[\"query\"]);\n  return uri;\n}\nfunction pathNames(obj, path) {\n  const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n  if (path.substr(0, 1) == \"/\" || path.length === 0) {\n    names.splice(0, 1);\n  }\n  if (path.substr(path.length - 1, 1) == \"/\") {\n    names.splice(names.length - 1, 1);\n  }\n  return names;\n}\nfunction queryKey(uri, query) {\n  const data = {};\n  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {\n    if ($1) {\n      data[$1] = $2;\n    }\n  });\n  return data;\n}\nclass Socket$1 extends Emitter {\n  constructor(uri, opts = {}) {\n    super();\n    if (uri && typeof uri === \"object\") {\n      opts = uri;\n      uri = null;\n    }\n    if (uri) {\n      uri = parse$2(uri);\n      opts.hostname = uri.host;\n      opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n      opts.port = uri.port;\n      if (uri.query)\n        opts.query = uri.query;\n    } else if (opts.host) {\n      opts.hostname = parse$2(opts.host).host;\n    }\n    installTimerFunctions(this, opts);\n    this.secure = opts.secure != null ? opts.secure : typeof location !== \"undefined\" && location.protocol === \"https:\";\n    if (opts.hostname && !opts.port) {\n      opts.port = this.secure ? \"443\" : \"80\";\n    }\n    this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n    this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : this.secure ? \"443\" : \"80\");\n    this.transports = opts.transports || [\"polling\", \"websocket\"];\n    this.readyState = \"\";\n    this.writeBuffer = [];\n    this.prevBufferLen = 0;\n    this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: false,\n      withCredentials: false,\n      upgrade: true,\n      timestampParam: \"t\",\n      rememberUpgrade: false,\n      rejectUnauthorized: true,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: true\n    }, opts);\n    this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n    if (typeof this.opts.query === \"string\") {\n      this.opts.query = decode$1(this.opts.query);\n    }\n    this.id = null;\n    this.upgrades = null;\n    this.pingInterval = null;\n    this.pingTimeout = null;\n    this.pingTimeoutTimer = null;\n    if (typeof addEventListener === \"function\") {\n      if (this.opts.closeOnBeforeunload) {\n        addEventListener(\"beforeunload\", () => {\n          if (this.transport) {\n            this.transport.removeAllListeners();\n            this.transport.close();\n          }\n        }, false);\n      }\n      if (this.hostname !== \"localhost\") {\n        this.offlineEventListener = () => {\n          this.onClose(\"transport close\", {\n            description: \"network connection lost\"\n          });\n        };\n        addEventListener(\"offline\", this.offlineEventListener, false);\n      }\n    }\n    this.open();\n  }\n  createTransport(name) {\n    const query = Object.assign({}, this.opts.query);\n    query.EIO = protocol$1;\n    query.transport = name;\n    if (this.id)\n      query.sid = this.id;\n    const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n      query,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new transports[name](opts);\n  }\n  open() {\n    let transport;\n    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n      transport = \"websocket\";\n    } else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else {\n      transport = this.transports[0];\n    }\n    this.readyState = \"opening\";\n    try {\n      transport = this.createTransport(transport);\n    } catch (e) {\n      this.transports.shift();\n      this.open();\n      return;\n    }\n    transport.open();\n    this.setTransport(transport);\n  }\n  setTransport(transport) {\n    if (this.transport) {\n      this.transport.removeAllListeners();\n    }\n    this.transport = transport;\n    transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n  }\n  probe(name) {\n    let transport = this.createTransport(name);\n    let failed = false;\n    Socket$1.priorWebsocketSuccess = false;\n    const onTransportOpen = () => {\n      if (failed)\n        return;\n      transport.send([{ type: \"ping\", data: \"probe\" }]);\n      transport.once(\"packet\", (msg) => {\n        if (failed)\n          return;\n        if (msg.type === \"pong\" && msg.data === \"probe\") {\n          this.upgrading = true;\n          this.emitReserved(\"upgrading\", transport);\n          if (!transport)\n            return;\n          Socket$1.priorWebsocketSuccess = transport.name === \"websocket\";\n          this.transport.pause(() => {\n            if (failed)\n              return;\n            if (this.readyState === \"closed\")\n              return;\n            cleanup();\n            this.setTransport(transport);\n            transport.send([{ type: \"upgrade\" }]);\n            this.emitReserved(\"upgrade\", transport);\n            transport = null;\n            this.upgrading = false;\n            this.flush();\n          });\n        } else {\n          const err = new Error(\"probe error\");\n          err.transport = transport.name;\n          this.emitReserved(\"upgradeError\", err);\n        }\n      });\n    };\n    function freezeTransport() {\n      if (failed)\n        return;\n      failed = true;\n      cleanup();\n      transport.close();\n      transport = null;\n    }\n    const onerror = (err) => {\n      const error = new Error(\"probe error: \" + err);\n      error.transport = transport.name;\n      freezeTransport();\n      this.emitReserved(\"upgradeError\", error);\n    };\n    function onTransportClose() {\n      onerror(\"transport closed\");\n    }\n    function onclose() {\n      onerror(\"socket closed\");\n    }\n    function onupgrade(to) {\n      if (transport && to.name !== transport.name) {\n        freezeTransport();\n      }\n    }\n    const cleanup = () => {\n      transport.removeListener(\"open\", onTransportOpen);\n      transport.removeListener(\"error\", onerror);\n      transport.removeListener(\"close\", onTransportClose);\n      this.off(\"close\", onclose);\n      this.off(\"upgrading\", onupgrade);\n    };\n    transport.once(\"open\", onTransportOpen);\n    transport.once(\"error\", onerror);\n    transport.once(\"close\", onTransportClose);\n    this.once(\"close\", onclose);\n    this.once(\"upgrading\", onupgrade);\n    transport.open();\n  }\n  onOpen() {\n    this.readyState = \"open\";\n    Socket$1.priorWebsocketSuccess = this.transport.name === \"websocket\";\n    this.emitReserved(\"open\");\n    this.flush();\n    if (this.readyState === \"open\" && this.opts.upgrade && this.transport.pause) {\n      let i2 = 0;\n      const l2 = this.upgrades.length;\n      for (; i2 < l2; i2++) {\n        this.probe(this.upgrades[i2]);\n      }\n    }\n  }\n  onPacket(packet) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") {\n      this.emitReserved(\"packet\", packet);\n      this.emitReserved(\"heartbeat\");\n      switch (packet.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(packet.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout();\n          this.sendPacket(\"pong\");\n          this.emitReserved(\"ping\");\n          this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const err = new Error(\"server error\");\n          err.code = packet.data;\n          this.onError(err);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", packet.data);\n          this.emitReserved(\"message\", packet.data);\n          break;\n      }\n    }\n  }\n  onHandshake(data) {\n    this.emitReserved(\"handshake\", data);\n    this.id = data.sid;\n    this.transport.query.sid = data.sid;\n    this.upgrades = this.filterUpgrades(data.upgrades);\n    this.pingInterval = data.pingInterval;\n    this.pingTimeout = data.pingTimeout;\n    this.maxPayload = data.maxPayload;\n    this.onOpen();\n    if (this.readyState === \"closed\")\n      return;\n    this.resetPingTimeout();\n  }\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout);\n    if (this.opts.autoUnref) {\n      this.pingTimeoutTimer.unref();\n    }\n  }\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen);\n    this.prevBufferLen = 0;\n    if (this.writeBuffer.length === 0) {\n      this.emitReserved(\"drain\");\n    } else {\n      this.flush();\n    }\n  }\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const packets = this.getWritablePackets();\n      this.transport.send(packets);\n      this.prevBufferLen = packets.length;\n      this.emitReserved(\"flush\");\n    }\n  }\n  getWritablePackets() {\n    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n    if (!shouldCheckPayloadSize) {\n      return this.writeBuffer;\n    }\n    let payloadSize = 1;\n    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {\n      const data = this.writeBuffer[i2].data;\n      if (data) {\n        payloadSize += byteLength(data);\n      }\n      if (i2 > 0 && payloadSize > this.maxPayload) {\n        return this.writeBuffer.slice(0, i2);\n      }\n      payloadSize += 2;\n    }\n    return this.writeBuffer;\n  }\n  write(msg, options, fn2) {\n    this.sendPacket(\"message\", msg, options, fn2);\n    return this;\n  }\n  send(msg, options, fn2) {\n    this.sendPacket(\"message\", msg, options, fn2);\n    return this;\n  }\n  sendPacket(type, data, options, fn2) {\n    if (typeof data === \"function\") {\n      fn2 = data;\n      data = void 0;\n    }\n    if (typeof options === \"function\") {\n      fn2 = options;\n      options = null;\n    }\n    if (this.readyState === \"closing\" || this.readyState === \"closed\") {\n      return;\n    }\n    options = options || {};\n    options.compress = options.compress !== false;\n    const packet = {\n      type,\n      data,\n      options\n    };\n    this.emitReserved(\"packetCreate\", packet);\n    this.writeBuffer.push(packet);\n    if (fn2)\n      this.once(\"flush\", fn2);\n    this.flush();\n  }\n  close() {\n    const close = () => {\n      this.onClose(\"forced close\");\n      this.transport.close();\n    };\n    const cleanupAndClose = () => {\n      this.off(\"upgrade\", cleanupAndClose);\n      this.off(\"upgradeError\", cleanupAndClose);\n      close();\n    };\n    const waitForUpgrade = () => {\n      this.once(\"upgrade\", cleanupAndClose);\n      this.once(\"upgradeError\", cleanupAndClose);\n    };\n    if (this.readyState === \"opening\" || this.readyState === \"open\") {\n      this.readyState = \"closing\";\n      if (this.writeBuffer.length) {\n        this.once(\"drain\", () => {\n          if (this.upgrading) {\n            waitForUpgrade();\n          } else {\n            close();\n          }\n        });\n      } else if (this.upgrading) {\n        waitForUpgrade();\n      } else {\n        close();\n      }\n    }\n    return this;\n  }\n  onError(err) {\n    Socket$1.priorWebsocketSuccess = false;\n    this.emitReserved(\"error\", err);\n    this.onClose(\"transport error\", err);\n  }\n  onClose(reason, description) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") {\n      this.clearTimeoutFn(this.pingTimeoutTimer);\n      this.transport.removeAllListeners(\"close\");\n      this.transport.close();\n      this.transport.removeAllListeners();\n      if (typeof removeEventListener === \"function\") {\n        removeEventListener(\"offline\", this.offlineEventListener, false);\n      }\n      this.readyState = \"closed\";\n      this.id = null;\n      this.emitReserved(\"close\", reason, description);\n      this.writeBuffer = [];\n      this.prevBufferLen = 0;\n    }\n  }\n  filterUpgrades(upgrades) {\n    const filteredUpgrades = [];\n    let i2 = 0;\n    const j2 = upgrades.length;\n    for (; i2 < j2; i2++) {\n      if (~this.transports.indexOf(upgrades[i2]))\n        filteredUpgrades.push(upgrades[i2]);\n    }\n    return filteredUpgrades;\n  }\n}\nSocket$1.protocol = protocol$1;\nfunction url$1(uri, path = \"\", loc) {\n  let obj = uri;\n  loc = loc || typeof location !== \"undefined\" && location;\n  if (uri == null)\n    uri = loc.protocol + \"//\" + loc.host;\n  if (typeof uri === \"string\") {\n    if (uri.charAt(0) === \"/\") {\n      if (uri.charAt(1) === \"/\") {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      if (typeof loc !== \"undefined\") {\n        uri = loc.protocol + \"//\" + uri;\n      } else {\n        uri = \"https://\" + uri;\n      }\n    }\n    obj = parse$2(uri);\n  }\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = \"80\";\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = \"443\";\n    }\n  }\n  obj.path = obj.path || \"/\";\n  const ipv6 = obj.host.indexOf(\":\") !== -1;\n  const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n  obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n  obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n  return obj;\n}\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n  return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\nconst withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\nfunction isBinary(obj) {\n  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n}\nfunction hasBinary(obj, toJSON) {\n  if (!obj || typeof obj !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(obj)) {\n    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {\n      if (hasBinary(obj[i2])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (isBinary(obj)) {\n    return true;\n  }\n  if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n    return hasBinary(obj.toJSON(), true);\n  }\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction deconstructPacket(packet) {\n  const buffers = [];\n  const packetData = packet.data;\n  const pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length;\n  return { packet: pack, buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n  if (!data)\n    return data;\n  if (isBinary(data)) {\n    const placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i2 = 0; i2 < data.length; i2++) {\n      newData[i2] = _deconstructPacket(data[i2], buffers);\n    }\n    return newData;\n  } else if (typeof data === \"object\" && !(data instanceof Date)) {\n    const newData = {};\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        newData[key] = _deconstructPacket(data[key], buffers);\n      }\n    }\n    return newData;\n  }\n  return data;\n}\nfunction reconstructPacket(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = void 0;\n  return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n  if (!data)\n    return data;\n  if (data && data._placeholder) {\n    return buffers[data.num];\n  } else if (Array.isArray(data)) {\n    for (let i2 = 0; i2 < data.length; i2++) {\n      data[i2] = _reconstructPacket(data[i2], buffers);\n    }\n  } else if (typeof data === \"object\") {\n    for (const key in data) {\n      if (Object.prototype.hasOwnProperty.call(data, key)) {\n        data[key] = _reconstructPacket(data[key], buffers);\n      }\n    }\n  }\n  return data;\n}\nconst protocol = 5;\nvar PacketType;\n(function(PacketType2) {\n  PacketType2[PacketType2[\"CONNECT\"] = 0] = \"CONNECT\";\n  PacketType2[PacketType2[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n  PacketType2[PacketType2[\"EVENT\"] = 2] = \"EVENT\";\n  PacketType2[PacketType2[\"ACK\"] = 3] = \"ACK\";\n  PacketType2[PacketType2[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n  PacketType2[PacketType2[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n  PacketType2[PacketType2[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\nclass Encoder {\n  constructor(replacer) {\n    this.replacer = replacer;\n  }\n  encode(obj) {\n    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n      if (hasBinary(obj)) {\n        obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;\n        return this.encodeAsBinary(obj);\n      }\n    }\n    return [this.encodeAsString(obj)];\n  }\n  encodeAsString(obj) {\n    let str2 = \"\" + obj.type;\n    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n      str2 += obj.attachments + \"-\";\n    }\n    if (obj.nsp && obj.nsp !== \"/\") {\n      str2 += obj.nsp + \",\";\n    }\n    if (obj.id != null) {\n      str2 += obj.id;\n    }\n    if (obj.data != null) {\n      str2 += JSON.stringify(obj.data, this.replacer);\n    }\n    return str2;\n  }\n  encodeAsBinary(obj) {\n    const deconstruction = deconstructPacket(obj);\n    const pack = this.encodeAsString(deconstruction.packet);\n    const buffers = deconstruction.buffers;\n    buffers.unshift(pack);\n    return buffers;\n  }\n}\nclass Decoder extends Emitter {\n  constructor(reviver2) {\n    super();\n    this.reviver = reviver2;\n  }\n  add(obj) {\n    let packet;\n    if (typeof obj === \"string\") {\n      packet = this.decodeString(obj);\n      if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {\n        this.reconstructor = new BinaryReconstructor(packet);\n        if (packet.attachments === 0) {\n          super.emitReserved(\"decoded\", packet);\n        }\n      } else {\n        super.emitReserved(\"decoded\", packet);\n      }\n    } else if (isBinary(obj) || obj.base64) {\n      if (!this.reconstructor) {\n        throw new Error(\"got binary data when not reconstructing a packet\");\n      } else {\n        packet = this.reconstructor.takeBinaryData(obj);\n        if (packet) {\n          this.reconstructor = null;\n          super.emitReserved(\"decoded\", packet);\n        }\n      }\n    } else {\n      throw new Error(\"Unknown type: \" + obj);\n    }\n  }\n  decodeString(str2) {\n    let i2 = 0;\n    const p2 = {\n      type: Number(str2.charAt(0))\n    };\n    if (PacketType[p2.type] === void 0) {\n      throw new Error(\"unknown packet type \" + p2.type);\n    }\n    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {\n      const start2 = i2 + 1;\n      while (str2.charAt(++i2) !== \"-\" && i2 != str2.length) {\n      }\n      const buf = str2.substring(start2, i2);\n      if (buf != Number(buf) || str2.charAt(i2) !== \"-\") {\n        throw new Error(\"Illegal attachments\");\n      }\n      p2.attachments = Number(buf);\n    }\n    if (str2.charAt(i2 + 1) === \"/\") {\n      const start2 = i2 + 1;\n      while (++i2) {\n        const c2 = str2.charAt(i2);\n        if (c2 === \",\")\n          break;\n        if (i2 === str2.length)\n          break;\n      }\n      p2.nsp = str2.substring(start2, i2);\n    } else {\n      p2.nsp = \"/\";\n    }\n    const next = str2.charAt(i2 + 1);\n    if (next !== \"\" && Number(next) == next) {\n      const start2 = i2 + 1;\n      while (++i2) {\n        const c2 = str2.charAt(i2);\n        if (c2 == null || Number(c2) != c2) {\n          --i2;\n          break;\n        }\n        if (i2 === str2.length)\n          break;\n      }\n      p2.id = Number(str2.substring(start2, i2 + 1));\n    }\n    if (str2.charAt(++i2)) {\n      const payload = this.tryParse(str2.substr(i2));\n      if (Decoder.isPayloadValid(p2.type, payload)) {\n        p2.data = payload;\n      } else {\n        throw new Error(\"invalid payload\");\n      }\n    }\n    return p2;\n  }\n  tryParse(str2) {\n    try {\n      return JSON.parse(str2, this.reviver);\n    } catch (e) {\n      return false;\n    }\n  }\n  static isPayloadValid(type, payload) {\n    switch (type) {\n      case PacketType.CONNECT:\n        return typeof payload === \"object\";\n      case PacketType.DISCONNECT:\n        return payload === void 0;\n      case PacketType.CONNECT_ERROR:\n        return typeof payload === \"string\" || typeof payload === \"object\";\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(payload) && payload.length > 0;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(payload);\n    }\n  }\n  destroy() {\n    if (this.reconstructor) {\n      this.reconstructor.finishedReconstruction();\n    }\n  }\n}\nclass BinaryReconstructor {\n  constructor(packet) {\n    this.packet = packet;\n    this.buffers = [];\n    this.reconPack = packet;\n  }\n  takeBinaryData(binData) {\n    this.buffers.push(binData);\n    if (this.buffers.length === this.reconPack.attachments) {\n      const packet = reconstructPacket(this.reconPack, this.buffers);\n      this.finishedReconstruction();\n      return packet;\n    }\n    return null;\n  }\n  finishedReconstruction() {\n    this.reconPack = null;\n    this.buffers = [];\n  }\n}\nvar parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  protocol,\n  get PacketType() {\n    return PacketType;\n  },\n  Encoder,\n  Decoder\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction on(obj, ev, fn2) {\n  obj.on(ev, fn2);\n  return function subDestroy() {\n    obj.off(ev, fn2);\n  };\n}\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nclass Socket extends Emitter {\n  constructor(io, nsp, opts) {\n    super();\n    this.connected = false;\n    this.receiveBuffer = [];\n    this.sendBuffer = [];\n    this.ids = 0;\n    this.acks = {};\n    this.flags = {};\n    this.io = io;\n    this.nsp = nsp;\n    if (opts && opts.auth) {\n      this.auth = opts.auth;\n    }\n    if (this.io._autoConnect)\n      this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs)\n      return;\n    const io = this.io;\n    this.subs = [\n      on(io, \"open\", this.onopen.bind(this)),\n      on(io, \"packet\", this.onpacket.bind(this)),\n      on(io, \"error\", this.onerror.bind(this)),\n      on(io, \"close\", this.onclose.bind(this))\n    ];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    if (this.connected)\n      return this;\n    this.subEvents();\n    if (!this.io[\"_reconnecting\"])\n      this.io.open();\n    if (this.io._readyState === \"open\")\n      this.onopen();\n    return this;\n  }\n  open() {\n    return this.connect();\n  }\n  send(...args) {\n    args.unshift(\"message\");\n    this.emit.apply(this, args);\n    return this;\n  }\n  emit(ev, ...args) {\n    if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n      throw new Error('\"' + ev + '\" is a reserved event name');\n    }\n    args.unshift(ev);\n    const packet = {\n      type: PacketType.EVENT,\n      data: args\n    };\n    packet.options = {};\n    packet.options.compress = this.flags.compress !== false;\n    if (typeof args[args.length - 1] === \"function\") {\n      const id = this.ids++;\n      const ack = args.pop();\n      this._registerAckCallback(id, ack);\n      packet.id = id;\n    }\n    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n    if (discardPacket)\n      ;\n    else if (this.connected) {\n      this.notifyOutgoingListeners(packet);\n      this.packet(packet);\n    } else {\n      this.sendBuffer.push(packet);\n    }\n    this.flags = {};\n    return this;\n  }\n  _registerAckCallback(id, ack) {\n    const timeout = this.flags.timeout;\n    if (timeout === void 0) {\n      this.acks[id] = ack;\n      return;\n    }\n    const timer = this.io.setTimeoutFn(() => {\n      delete this.acks[id];\n      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {\n        if (this.sendBuffer[i2].id === id) {\n          this.sendBuffer.splice(i2, 1);\n        }\n      }\n      ack.call(this, new Error(\"operation has timed out\"));\n    }, timeout);\n    this.acks[id] = (...args) => {\n      this.io.clearTimeoutFn(timer);\n      ack.apply(this, [null, ...args]);\n    };\n  }\n  packet(packet) {\n    packet.nsp = this.nsp;\n    this.io._packet(packet);\n  }\n  onopen() {\n    if (typeof this.auth == \"function\") {\n      this.auth((data) => {\n        this.packet({ type: PacketType.CONNECT, data });\n      });\n    } else {\n      this.packet({ type: PacketType.CONNECT, data: this.auth });\n    }\n  }\n  onerror(err) {\n    if (!this.connected) {\n      this.emitReserved(\"connect_error\", err);\n    }\n  }\n  onclose(reason, description) {\n    this.connected = false;\n    delete this.id;\n    this.emitReserved(\"disconnect\", reason, description);\n  }\n  onpacket(packet) {\n    const sameNamespace = packet.nsp === this.nsp;\n    if (!sameNamespace)\n      return;\n    switch (packet.type) {\n      case PacketType.CONNECT:\n        if (packet.data && packet.data.sid) {\n          const id = packet.data.sid;\n          this.onconnect(id);\n        } else {\n          this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n        }\n        break;\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n      case PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n      case PacketType.CONNECT_ERROR:\n        this.destroy();\n        const err = new Error(packet.data.message);\n        err.data = packet.data.data;\n        this.emitReserved(\"connect_error\", err);\n        break;\n    }\n  }\n  onevent(packet) {\n    const args = packet.data || [];\n    if (packet.id != null) {\n      args.push(this.ack(packet.id));\n    }\n    if (this.connected) {\n      this.emitEvent(args);\n    } else {\n      this.receiveBuffer.push(Object.freeze(args));\n    }\n  }\n  emitEvent(args) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n    super.emit.apply(this, args);\n  }\n  ack(id) {\n    const self2 = this;\n    let sent = false;\n    return function(...args) {\n      if (sent)\n        return;\n      sent = true;\n      self2.packet({\n        type: PacketType.ACK,\n        id,\n        data: args\n      });\n    };\n  }\n  onack(packet) {\n    const ack = this.acks[packet.id];\n    if (typeof ack === \"function\") {\n      ack.apply(this, packet.data);\n      delete this.acks[packet.id];\n    }\n  }\n  onconnect(id) {\n    this.id = id;\n    this.connected = true;\n    this.emitBuffered();\n    this.emitReserved(\"connect\");\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach((args) => this.emitEvent(args));\n    this.receiveBuffer = [];\n    this.sendBuffer.forEach((packet) => {\n      this.notifyOutgoingListeners(packet);\n      this.packet(packet);\n    });\n    this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy();\n    this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    if (this.subs) {\n      this.subs.forEach((subDestroy) => subDestroy());\n      this.subs = void 0;\n    }\n    this.io[\"_destroy\"](this);\n  }\n  disconnect() {\n    if (this.connected) {\n      this.packet({ type: PacketType.DISCONNECT });\n    }\n    this.destroy();\n    if (this.connected) {\n      this.onclose(\"io client disconnect\");\n    }\n    return this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  timeout(timeout) {\n    this.flags.timeout = timeout;\n    return this;\n  }\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.push(listener);\n    return this;\n  }\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.unshift(listener);\n    return this;\n  }\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyListeners;\n      for (let i2 = 0; i2 < listeners.length; i2++) {\n        if (listener === listeners[i2]) {\n          listeners.splice(i2, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.push(listener);\n    return this;\n  }\n  prependAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.unshift(listener);\n    return this;\n  }\n  offAnyOutgoing(listener) {\n    if (!this._anyOutgoingListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyOutgoingListeners;\n      for (let i2 = 0; i2 < listeners.length; i2++) {\n        if (listener === listeners[i2]) {\n          listeners.splice(i2, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyOutgoingListeners = [];\n    }\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(packet) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const listeners = this._anyOutgoingListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, packet.data);\n      }\n    }\n  }\n}\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 1e4;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\nBackoff.prototype.duration = function() {\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand = Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\nBackoff.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function(min2) {\n  this.ms = min2;\n};\nBackoff.prototype.setMax = function(max2) {\n  this.max = max2;\n};\nBackoff.prototype.setJitter = function(jitter) {\n  this.jitter = jitter;\n};\nclass Manager extends Emitter {\n  constructor(uri, opts) {\n    var _a3;\n    super();\n    this.nsps = {};\n    this.subs = [];\n    if (uri && typeof uri === \"object\") {\n      opts = uri;\n      uri = void 0;\n    }\n    opts = opts || {};\n    opts.path = opts.path || \"/socket.io\";\n    this.opts = opts;\n    installTimerFunctions(this, opts);\n    this.reconnection(opts.reconnection !== false);\n    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n    this.reconnectionDelay(opts.reconnectionDelay || 1e3);\n    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);\n    this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);\n    this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    });\n    this.timeout(opts.timeout == null ? 2e4 : opts.timeout);\n    this._readyState = \"closed\";\n    this.uri = uri;\n    const _parser2 = opts.parser || parser;\n    this.encoder = new _parser2.Encoder();\n    this.decoder = new _parser2.Decoder();\n    this._autoConnect = opts.autoConnect !== false;\n    if (this._autoConnect)\n      this.open();\n  }\n  reconnection(v2) {\n    if (!arguments.length)\n      return this._reconnection;\n    this._reconnection = !!v2;\n    return this;\n  }\n  reconnectionAttempts(v2) {\n    if (v2 === void 0)\n      return this._reconnectionAttempts;\n    this._reconnectionAttempts = v2;\n    return this;\n  }\n  reconnectionDelay(v2) {\n    var _a3;\n    if (v2 === void 0)\n      return this._reconnectionDelay;\n    this._reconnectionDelay = v2;\n    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v2);\n    return this;\n  }\n  randomizationFactor(v2) {\n    var _a3;\n    if (v2 === void 0)\n      return this._randomizationFactor;\n    this._randomizationFactor = v2;\n    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v2);\n    return this;\n  }\n  reconnectionDelayMax(v2) {\n    var _a3;\n    if (v2 === void 0)\n      return this._reconnectionDelayMax;\n    this._reconnectionDelayMax = v2;\n    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v2);\n    return this;\n  }\n  timeout(v2) {\n    if (!arguments.length)\n      return this._timeout;\n    this._timeout = v2;\n    return this;\n  }\n  maybeReconnectOnOpen() {\n    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n      this.reconnect();\n    }\n  }\n  open(fn2) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Socket$1(this.uri, this.opts);\n    const socket = this.engine;\n    const self2 = this;\n    this._readyState = \"opening\";\n    this.skipReconnect = false;\n    const openSubDestroy = on(socket, \"open\", function() {\n      self2.onopen();\n      fn2 && fn2();\n    });\n    const errorSub = on(socket, \"error\", (err) => {\n      self2.cleanup();\n      self2._readyState = \"closed\";\n      this.emitReserved(\"error\", err);\n      if (fn2) {\n        fn2(err);\n      } else {\n        self2.maybeReconnectOnOpen();\n      }\n    });\n    if (this._timeout !== false) {\n      const timeout = this._timeout;\n      if (timeout === 0) {\n        openSubDestroy();\n      }\n      const timer = this.setTimeoutFn(() => {\n        openSubDestroy();\n        socket.close();\n        socket.emit(\"error\", new Error(\"timeout\"));\n      }, timeout);\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n    this.subs.push(openSubDestroy);\n    this.subs.push(errorSub);\n    return this;\n  }\n  connect(fn2) {\n    return this.open(fn2);\n  }\n  onopen() {\n    this.cleanup();\n    this._readyState = \"open\";\n    this.emitReserved(\"open\");\n    const socket = this.engine;\n    this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(data) {\n    this.decoder.add(data);\n  }\n  ondecoded(packet) {\n    this.emitReserved(\"packet\", packet);\n  }\n  onerror(err) {\n    this.emitReserved(\"error\", err);\n  }\n  socket(nsp, opts) {\n    let socket = this.nsps[nsp];\n    if (!socket) {\n      socket = new Socket(this, nsp, opts);\n      this.nsps[nsp] = socket;\n    }\n    return socket;\n  }\n  _destroy(socket) {\n    const nsps = Object.keys(this.nsps);\n    for (const nsp of nsps) {\n      const socket2 = this.nsps[nsp];\n      if (socket2.active) {\n        return;\n      }\n    }\n    this._close();\n  }\n  _packet(packet) {\n    const encodedPackets = this.encoder.encode(packet);\n    for (let i2 = 0; i2 < encodedPackets.length; i2++) {\n      this.engine.write(encodedPackets[i2], packet.options);\n    }\n  }\n  cleanup() {\n    this.subs.forEach((subDestroy) => subDestroy());\n    this.subs.length = 0;\n    this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = true;\n    this._reconnecting = false;\n    this.onclose(\"forced close\");\n    if (this.engine)\n      this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(reason, description) {\n    this.cleanup();\n    this.backoff.reset();\n    this._readyState = \"closed\";\n    this.emitReserved(\"close\", reason, description);\n    if (this._reconnection && !this.skipReconnect) {\n      this.reconnect();\n    }\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const self2 = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts) {\n      this.backoff.reset();\n      this.emitReserved(\"reconnect_failed\");\n      this._reconnecting = false;\n    } else {\n      const delay = this.backoff.duration();\n      this._reconnecting = true;\n      const timer = this.setTimeoutFn(() => {\n        if (self2.skipReconnect)\n          return;\n        this.emitReserved(\"reconnect_attempt\", self2.backoff.attempts);\n        if (self2.skipReconnect)\n          return;\n        self2.open((err) => {\n          if (err) {\n            self2._reconnecting = false;\n            self2.reconnect();\n            this.emitReserved(\"reconnect_error\", err);\n          } else {\n            self2.onreconnect();\n          }\n        });\n      }, delay);\n      if (this.opts.autoUnref) {\n        timer.unref();\n      }\n      this.subs.push(function subDestroy() {\n        clearTimeout(timer);\n      });\n    }\n  }\n  onreconnect() {\n    const attempt = this.backoff.attempts;\n    this._reconnecting = false;\n    this.backoff.reset();\n    this.emitReserved(\"reconnect\", attempt);\n  }\n}\nconst cache = {};\nfunction lookup(uri, opts) {\n  if (typeof uri === \"object\") {\n    opts = uri;\n    uri = void 0;\n  }\n  opts = opts || {};\n  const parsed = url$1(uri, opts.path || \"/socket.io\");\n  const source = parsed.source;\n  const id = parsed.id;\n  const path = parsed.path;\n  const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n  const newConnection = opts.forceNew || opts[\"force new connection\"] || opts.multiplex === false || sameNamespace;\n  let io;\n  if (newConnection) {\n    io = new Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      cache[id] = new Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.queryKey;\n  }\n  return io.socket(parsed.path, opts);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\nvar __accessCheck$5 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$5 = (obj, member, getter) => {\n  __accessCheck$5(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$5 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet$5 = (obj, member, value2, setter) => {\n  __accessCheck$5(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar _cvsWidth, _cvsHeight, _cvsScale, _ofsLeft4elm, _ofsTop4elm, _ofsPadLeft_Dom2PIXI, _ofsPadTop_Dom2PIXI, _sk, _hHook, _hToastDat, _aFncHook, _main_title, _tglFlscr, _info_title, _preFromPlg, _hN2Ext, _genImage, _genVideo;\nconst _SysBase = class {\n  constructor(hPlg = {}, arg) {\n    this.hPlg = hPlg;\n    this.arg = arg;\n    this.hFactoryCls = {};\n    this.fetch = (url2) => fetch(url2);\n    this.resolution = 1;\n    this.data = { sys: {}, mark: {}, kidoku: {} };\n    __privateAdd$5(this, _cvsWidth, 0);\n    __privateAdd$5(this, _cvsHeight, 0);\n    __privateAdd$5(this, _cvsScale, 1);\n    __privateAdd$5(this, _ofsLeft4elm, 0);\n    __privateAdd$5(this, _ofsTop4elm, 0);\n    __privateAdd$5(this, _ofsPadLeft_Dom2PIXI, 0);\n    __privateAdd$5(this, _ofsPadTop_Dom2PIXI, 0);\n    this.isFullScr = false;\n    this.extPort = 3776;\n    __privateAdd$5(this, _sk, void 0);\n    __privateAdd$5(this, _hHook, {\n      auth: (o) => {\n        if (o.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"\\u63A5\\u7D9A\");\n      },\n      continue: () => this.toast(\"\\u518D\\u751F\"),\n      disconnect: () => this.toast(\"\\u5207\\u65AD\"),\n      restart: (o) => {\n        var _a3;\n        this.send2Dbg((_a3 = o == null ? void 0 : o.ri) != null ? _a3 : \"\", {});\n        this.end();\n        this.run();\n      },\n      pause: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnEntry: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnDataBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnStep: () => this.toast(\"\\u4E00\\u6B69\\u9032\\u3080\"),\n      stopOnStepIn: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3\"),\n      stopOnStepOut: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8\"),\n      stopOnBackstep: () => this.toast(\"\\u4E00\\u6B69\\u623B\\u308B\"),\n      _addPath: (o) => this.cfg.addPath(o.fn, o.o)\n    });\n    this.pathBaseCnvSnPath4Dbg = \"\";\n    __privateAdd$5(this, _aFncHook, []);\n    this.callHook = (_type, _o) => {\n    };\n    this.send2Dbg = (type, o) => {\n      var _a3;\n      (_a3 = __privateGet$5(this, _sk)) == null ? void 0 : _a3.emit(\"data\", type, o);\n    };\n    this.copyBMFolder = (_from, _to) => {\n    };\n    this.eraseBMFolder = (_place) => {\n    };\n    this.close = () => false;\n    this._export = () => false;\n    this._import = () => false;\n    this.navigate_to = () => false;\n    this.title = (hArg) => {\n      const { text: text2 } = hArg;\n      if (!text2)\n        throw \"[title] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      __privateSet$5(this, _main_title, text2);\n      this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title));\n      return false;\n    };\n    __privateAdd$5(this, _main_title, \"\");\n    __privateAdd$5(this, _tglFlscr, (hArg) => {\n      if (!hArg.key) {\n        this.tglFlscr_sub();\n        return false;\n      }\n      const key = hArg.key.toLowerCase();\n      document.addEventListener(\"keydown\", (e) => {\n        const key2 = (e.altKey ? e.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (e.ctrlKey ? e.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (e.shiftKey ? e.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + e.key.toLowerCase();\n        if (key2 !== key)\n          return;\n        e.stopPropagation();\n        this.tglFlscr_sub();\n      }, { passive: true });\n      return false;\n    });\n    this.update_check = () => false;\n    this.window = () => false;\n    __privateAdd$5(this, _info_title, \"\");\n    __privateAdd$5(this, _preFromPlg, (_ext, d2) => {\n      return { ret: d2.toString(), ext_num: 0 };\n    });\n    __privateAdd$5(this, _hN2Ext, {\n      1: { ext: \"jpeg\", fnc: (bl) => __privateGet$5(this, _genImage).call(this, bl), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (bl) => __privateGet$5(this, _genImage).call(this, bl), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (bl) => __privateGet$5(this, _genImage).call(this, bl), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (bl) => __privateGet$5(this, _genImage).call(this, bl), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (bl) => bl.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (bl) => __privateGet$5(this, _genVideo).call(this, bl), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (bl) => __privateGet$5(this, _genVideo).call(this, bl), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (bl) => __privateGet$5(this, _genVideo).call(this, bl), mime: \"video/ogv\" }\n    });\n    __privateAdd$5(this, _genImage, (bl) => new Promise((rs, rj) => {\n      const img = new Image();\n      img.onload = () => rs(img);\n      img.onerror = (e) => rj(e);\n      img.src = URL.createObjectURL(bl);\n    }));\n    __privateAdd$5(this, _genVideo, (bl) => new Promise((rs, rj) => {\n      const v2 = document.createElement(\"video\");\n      v2.addEventListener(\"error\", () => {\n        var _a3, _b3;\n        return rj((_b3 = (_a3 = v2 == null ? void 0 : v2.error) == null ? void 0 : _a3.message) != null ? _b3 : \"\");\n      });\n      v2.addEventListener(\"canplay\", () => rs(v2));\n      v2.src = URL.createObjectURL(bl);\n    }));\n    this.enc = (d2) => d2;\n    this.stk = () => \"\";\n    this.hash = (_data2) => \"\";\n    this.isApp = false;\n    this.$path_downloads = \"\";\n    this.$path_userdata = \"\";\n    this.canCapturePage = (_fn) => false;\n  }\n  async loaded(hPlg, _arg) {\n    const fncPre = hPlg.snsys_pre;\n    delete hPlg.snsys_pre;\n    return fncPre == null ? void 0 : fncPre.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (fnc) => __privateSet$5(this, _preFromPlg, fnc),\n      setEnc: (fnc) => this.enc = fnc,\n      getStK: (fnc) => this.stk = fnc,\n      getHash: (fnc) => this.hash = fnc\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  async loadPath(_hPathFn2Exts, cfg) {\n    this.cfg = cfg;\n  }\n  initVal(_data2, _hTmp2, _comp) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(hTag, appPixi, val, main2) {\n    this.val = val;\n    this.appPixi = appPixi;\n    let mes = \"\";\n    try {\n      this.val.setSys(this);\n      mes = \"sys\";\n      mes += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1));\n      mes = \"kidoku\";\n      this.val.saveKidoku();\n    } catch (e) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${mes}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, e);\n    }\n    hTag.close = (o) => this.close(o);\n    hTag.export = (o) => this._export(o);\n    hTag.import = (o) => this._import(o);\n    hTag.navigate_to = (o) => this.navigate_to(o);\n    hTag.title = (o) => this.title(o);\n    hTag.toggle_full_screen = (o) => __privateGet$5(this, _tglFlscr).call(this, o);\n    hTag.update_check = (o) => this.update_check(o);\n    hTag.window = (o) => this.window(o);\n    val.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp);\n    val.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => CmnLib.isDbg);\n    val.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => CmnLib.isPackaged);\n    this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr);\n    val.setVal_Nochk(\"sys\", _SysBase.VALNM_CFG_NS, this.cfg.oCfg.save_ns);\n    val.flush();\n    if (CmnLib.isDbg)\n      this.attach_debug(main2);\n    this.hFactoryCls = {};\n    const a2 = [];\n    for (const nm in this.hPlg)\n      a2.push(this.hPlg[nm].init({\n        addTag: (name, tag_fnc) => {\n          if (hTag[name])\n            throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30BF\\u30B0[${name}]\\u3067\\u3059`;\n          hTag[name] = tag_fnc;\n        },\n        addLayCls: (cls, fnc) => {\n          if (this.hFactoryCls[cls])\n            throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30EC\\u30A4\\u30E4cls\\u3010${cls}\\u3011\\u3067\\u3059`;\n          this.hFactoryCls[cls] = fnc;\n        },\n        searchPath: (fn2, extptn = \"\") => this.cfg.searchPath(fn2, extptn),\n        getVal: val.getVal,\n        resume: () => main2.resume(),\n        render: (dsp, renderTexture, clear = false) => this.appPixi.renderer.render(dsp, { renderTexture, clear }),\n        setDec: (fnc) => __privateSet$5(this, _preFromPlg, fnc),\n        setEnc: (fnc) => this.enc = fnc,\n        getStK: (fnc) => this.stk = fnc,\n        getHash: (fnc) => this.hash = fnc\n      }));\n    return a2;\n  }\n  get cvsWidth() {\n    return __privateGet$5(this, _cvsWidth);\n  }\n  get cvsHeight() {\n    return __privateGet$5(this, _cvsHeight);\n  }\n  get cvsScale() {\n    return __privateGet$5(this, _cvsScale);\n  }\n  get ofsLeft4elm() {\n    return __privateGet$5(this, _ofsLeft4elm);\n  }\n  get ofsTop4elm() {\n    return __privateGet$5(this, _ofsTop4elm);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return __privateGet$5(this, _ofsPadLeft_Dom2PIXI);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return __privateGet$5(this, _ofsPadTop_Dom2PIXI);\n  }\n  cvsResize() {\n    var _a3, _b3;\n    let w2 = globalThis.innerWidth;\n    let h2 = globalThis.innerHeight;\n    const cvs = this.appPixi.view;\n    const isGallery = cvs.parentElement !== document.body;\n    if (isGallery) {\n      const st = globalThis.getComputedStyle(cvs);\n      w2 = parseFloat(st.width);\n      h2 = parseFloat(st.height);\n    }\n    if (CmnLib.isMobile) {\n      const angle = (_b3 = (_a3 = screen.orientation) == null ? void 0 : _a3.angle) != null ? _b3 : 0;\n      const isP = angle % 180 === 0;\n      if (isP && w2 > h2 || !isP && w2 < h2)\n        [w2, h2] = [h2, w2];\n    }\n    const cr = cvs.getBoundingClientRect();\n    if (argChk_Boolean(CmnLib.hDip, \"expanding\", true) || isGallery || CmnLib.stageW > w2 || CmnLib.stageH > h2) {\n      if (CmnLib.stageW / CmnLib.stageH <= w2 / h2) {\n        __privateSet$5(this, _cvsHeight, h2);\n        __privateSet$5(this, _cvsWidth, CmnLib.stageW / CmnLib.stageH * h2);\n      } else {\n        __privateSet$5(this, _cvsWidth, w2);\n        __privateSet$5(this, _cvsHeight, CmnLib.stageH / CmnLib.stageW * w2);\n      }\n      __privateSet$5(this, _cvsScale, __privateGet$5(this, _cvsWidth) / CmnLib.stageW);\n      if (isGallery) {\n        __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0);\n        __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);\n      } else {\n        const sc = 1 - __privateGet$5(this, _cvsScale);\n        if (CmnLib.isMobile) {\n          __privateSet$5(this, _ofsPadLeft_Dom2PIXI, (w2 - __privateGet$5(this, _cvsWidth)) / 2 * sc);\n          __privateSet$5(this, _ofsPadTop_Dom2PIXI, (h2 - __privateGet$5(this, _cvsHeight)) / 2 * sc);\n        } else {\n          __privateSet$5(this, _ofsPadLeft_Dom2PIXI, cr.left * sc);\n          __privateSet$5(this, _ofsPadTop_Dom2PIXI, cr.top * sc);\n        }\n      }\n    } else {\n      __privateSet$5(this, _cvsWidth, CmnLib.stageW);\n      __privateSet$5(this, _cvsHeight, CmnLib.stageH);\n      __privateSet$5(this, _cvsScale, 1);\n      __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0);\n      __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);\n    }\n    const ps = cvs.parentElement.style;\n    if (!isGallery) {\n      ps.position = \"relative\";\n      ps.width = `${__privateGet$5(this, _cvsWidth)}px`;\n      ps.height = `${__privateGet$5(this, _cvsHeight)}px`;\n    }\n    const s2 = cvs.style;\n    s2.width = ps.width;\n    s2.height = ps.height;\n    __privateSet$5(this, _ofsLeft4elm, cr.left);\n    __privateSet$5(this, _ofsTop4elm, cr.top);\n    if (this.isFullScr) {\n      __privateSet$5(this, _ofsLeft4elm, __privateGet$5(this, _ofsLeft4elm) + (w2 - __privateGet$5(this, _cvsWidth)) / 2);\n      __privateSet$5(this, _ofsTop4elm, __privateGet$5(this, _ofsTop4elm) + (h2 - __privateGet$5(this, _cvsHeight)) / 2);\n    }\n  }\n  attach_debug(main2) {\n    this.attach_debug = () => {\n    };\n    const gs = document.createElement(\"style\");\n    gs.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`;\n    document.getElementsByTagName(\"head\")[0].appendChild(gs);\n    this.addHook((type, o) => {\n      var _a3, _b3;\n      return (_b3 = (_a3 = __privateGet$5(this, _hHook))[type]) == null ? void 0 : _b3.call(_a3, o);\n    });\n    __privateSet$5(this, _sk, lookup(`http://localhost:${this.extPort}`));\n    __privateGet$5(this, _sk).on(\"data\", (type, o) => {\n      this.callHook(type, o);\n    }).on(\"disconnect\", () => main2.setLoop(true));\n    this.callHook = (type, o) => __privateGet$5(this, _aFncHook).forEach((fnc) => fnc(type, o));\n  }\n  end() {\n    var _a3;\n    (_a3 = __privateGet$5(this, _sk)) == null ? void 0 : _a3.disconnect();\n    __privateSet$5(this, _sk, void 0);\n  }\n  toast(nm) {\n    var _a3, _b3, _c3;\n    const p2 = document.body;\n    p2.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach((v2) => p2.removeChild(v2));\n    const img = document.createElement(\"img\");\n    const td = __privateGet$5(_SysBase, _hToastDat)[nm];\n    img.src = `data:image/svg+xml;base64,${td.dat}`;\n    const size = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * __privateGet$5(this, _cvsScale);\n    img.width = img.height = size;\n    img.style.cssText = `position: absolute;\nleft: ${(CmnLib.stageW - size) / 2 * __privateGet$5(this, _cvsScale) + size * ((_a3 = td.dx) != null ? _a3 : 0)}px;\ntop: ${(CmnLib.stageH - size) / 2 * __privateGet$5(this, _cvsScale) + size * ((_b3 = td.dy) != null ? _b3 : 0)}px;`;\n    img.classList.add(\"sn_toast\", (_c3 = td.ease) != null ? _c3 : \"sn_BounceInOut\");\n    if (!td.ease)\n      img.addEventListener(\"animationend\", () => p2.removeChild(img), { once: true, passive: true });\n    p2.insertBefore(img, this.appPixi.view);\n  }\n  setFire(fire) {\n    this.fire = fire;\n  }\n  addHook(fnc) {\n    __privateGet$5(this, _aFncHook).push(fnc);\n  }\n  titleSub(_txt) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(txt) {\n    __privateSet$5(this, _info_title, txt);\n    this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title));\n  }\n  decStr(ext, d2) {\n    return __privateGet$5(this, _preFromPlg).call(this, ext, d2).ret;\n  }\n  async dec(ext, d2) {\n    const { ret, ext_num } = __privateGet$5(this, _preFromPlg).call(this, ext, d2);\n    const fm = __privateGet$5(this, _hN2Ext)[ext_num];\n    return (fm == null ? void 0 : fm.fnc) ? await fm.fnc(new Blob([ret], { type: fm.mime })) : ret;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  async savePic(_fn, _data_url) {\n  }\n  async appendFile(_path, _data2, _callback) {\n  }\n  async ensureFileSync(_path) {\n  }\n};\nlet SysBase = _SysBase;\n_cvsWidth = /* @__PURE__ */ new WeakMap();\n_cvsHeight = /* @__PURE__ */ new WeakMap();\n_cvsScale = /* @__PURE__ */ new WeakMap();\n_ofsLeft4elm = /* @__PURE__ */ new WeakMap();\n_ofsTop4elm = /* @__PURE__ */ new WeakMap();\n_ofsPadLeft_Dom2PIXI = /* @__PURE__ */ new WeakMap();\n_ofsPadTop_Dom2PIXI = /* @__PURE__ */ new WeakMap();\n_sk = /* @__PURE__ */ new WeakMap();\n_hHook = /* @__PURE__ */ new WeakMap();\n_hToastDat = /* @__PURE__ */ new WeakMap();\n_aFncHook = /* @__PURE__ */ new WeakMap();\n_main_title = /* @__PURE__ */ new WeakMap();\n_tglFlscr = /* @__PURE__ */ new WeakMap();\n_info_title = /* @__PURE__ */ new WeakMap();\n_preFromPlg = /* @__PURE__ */ new WeakMap();\n_hN2Ext = /* @__PURE__ */ new WeakMap();\n_genImage = /* @__PURE__ */ new WeakMap();\n_genVideo = /* @__PURE__ */ new WeakMap();\nSysBase.VALNM_CFG_NS = \"const.sn.cfg.ns\";\n__privateAdd$5(SysBase, _hToastDat, {\n  \"\\u63A5\\u7D9A\": { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  \"\\u5207\\u65AD\": { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  \"\\u518D\\u751F\": { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \"\\u4E00\\u6642\\u505C\\u6B62\": { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \"\\u6CE8\\u610F\": { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \"\\u4E00\\u6B69\\u9032\\u3080\": { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \"\\u4E00\\u6B69\\u623B\\u308B\": { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3\": { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8\": { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nvar __accessCheck$4 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$4 = (obj, member, getter) => {\n  __accessCheck$4(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$4 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet$4 = (obj, member, value2, setter) => {\n  __accessCheck$4(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar _existsBreakline, _existsBreakpage, _REG_PATH;\nconst _Config = class {\n  constructor(sys) {\n    this.sys = sys;\n    this.oCfg = {\n      save_ns: \"\",\n      window: {\n        width: 300,\n        height: 300\n      },\n      book: {\n        title: \"\",\n        creator: \"\",\n        cre_url: \"\",\n        publisher: \"\",\n        pub_url: \"\",\n        detail: \"\",\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      init: {\n        bg_color: \"#000000\",\n        tagch_msecwait: 10,\n        auto_msecpagewait: 3500,\n        escape: \"\"\n      },\n      debug: {\n        devtool: false,\n        token: false,\n        tag: false,\n        putCh: false,\n        debugLog: false,\n        baseTx: false,\n        masume: false,\n        variable: false\n      },\n      code: {},\n      debuger_token: \"\"\n    };\n    this.userFnTail = \"\";\n    this.hPathFn2Exts = {};\n    __privateAdd$4(this, _existsBreakline, false);\n    __privateAdd$4(this, _existsBreakpage, false);\n    __privateAdd$4(this, _REG_PATH, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n  }\n  static async generate(sys) {\n    const c2 = new _Config(sys);\n    const fn2 = sys.cur + \"prj.json\";\n    const src = await (await sys.fetch(fn2)).text();\n    const oJs = JSON.parse(sys.decStr(fn2, src));\n    await c2.load(oJs);\n    return c2;\n  }\n  async load(oCfg) {\n    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;\n    this.oCfg.save_ns = (_a3 = oCfg == null ? void 0 : oCfg.save_ns) != null ? _a3 : this.oCfg.save_ns;\n    CmnLib.stageW = this.oCfg.window.width = Number((_c3 = (_b3 = oCfg == null ? void 0 : oCfg.window) == null ? void 0 : _b3.width) != null ? _c3 : this.oCfg.window.width);\n    CmnLib.stageH = this.oCfg.window.height = Number((_e = (_d2 = oCfg == null ? void 0 : oCfg.window) == null ? void 0 : _d2.height) != null ? _e : this.oCfg.window.height);\n    this.oCfg.book = __spreadValues(__spreadValues({}, this.oCfg.book), oCfg.book);\n    this.oCfg.log.max_len = (_h = (_g = (_f = oCfg.log) == null ? void 0 : _f.max_len) == null ? void 0 : _g.max_len) != null ? _h : this.oCfg.log.max_len;\n    this.oCfg.init = __spreadValues(__spreadValues({}, this.oCfg.init), oCfg.init);\n    this.oCfg.debug = __spreadValues(__spreadValues({}, this.oCfg.debug), oCfg.debug);\n    CmnLib.debugLog = this.oCfg.debug.debugLog;\n    this.oCfg.debuger_token = oCfg.debuger_token;\n    await this.sys.loadPath(this.hPathFn2Exts, this);\n    __privateSet$4(this, _existsBreakline, this.matchPath(\"^breakline$\", _Config.EXT_SPRITE).length > 0);\n    __privateSet$4(this, _existsBreakpage, this.matchPath(\"^breakpage$\", _Config.EXT_SPRITE).length > 0);\n    if (this.sys.crypto)\n      for (const nm in this.hPathFn2Exts) {\n        const o = this.hPathFn2Exts[nm];\n        for (const ext in o) {\n          if (ext.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const hp = o[ext].slice(o[ext].lastIndexOf(\"/\") + 1);\n          const fn2 = o[ext.slice(0, -10)];\n          const res = await this.sys.fetch(fn2);\n          const src = await res.text();\n          const hf = this.sys.hash(src);\n          if (hp !== hf)\n            throw `\\u30D5\\u30A1\\u30A4\\u30EB\\u6539\\u7AC4\\u30A8\\u30E9\\u30FC\\u3067\\u3059 fn:${fn2}`;\n        }\n      }\n  }\n  get existsBreakline() {\n    return __privateGet$4(this, _existsBreakline);\n  }\n  get existsBreakpage() {\n    return __privateGet$4(this, _existsBreakpage);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  searchPath(path, extptn = \"\") {\n    if (!path)\n      throw \"[searchPath] fn\\u304C\\u7A7A\\u3067\\u3059\";\n    if (path.slice(0, 7) === \"http://\")\n      return path;\n    if (path.slice(0, 11) === \"downloads:/\") {\n      const fp = this.sys.path_downloads + path.slice(11);\n      this.sys.ensureFileSync(fp);\n      return fp;\n    }\n    if (path.slice(0, 10) === \"userdata:/\") {\n      const fp = this.sys.path_userdata + \"storage/\" + path.slice(10);\n      this.sys.ensureFileSync(fp);\n      return fp;\n    }\n    const a2 = path.match(__privateGet$4(this, _REG_PATH));\n    let fn2 = a2 ? a2[1] : path;\n    const ext = a2 ? a2[2] : \"\";\n    if (this.userFnTail) {\n      const utn = fn2 + \"@@\" + this.userFnTail;\n      if (utn in this.hPathFn2Exts) {\n        if (extptn === \"\")\n          fn2 = utn;\n        else\n          for (let e3 in this.hPathFn2Exts[utn]) {\n            if (`|${extptn}|`.indexOf(`|${e3}|`) === -1)\n              continue;\n            fn2 = utn;\n            break;\n          }\n      }\n    }\n    const h_exts = this.hPathFn2Exts[fn2];\n    if (!h_exts)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${path}\\u3011\\u3067\\u3059`;\n    let ret = \"\";\n    if (!ext) {\n      const hcnt = int(h_exts[\":cnt\"]);\n      if (extptn === \"\") {\n        if (hcnt > 1)\n          throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${path}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${extptn}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n        return path;\n      }\n      const search_exts = `|${extptn}|`;\n      if (hcnt > 1) {\n        let cnt = 0;\n        for (const e2 in h_exts) {\n          if (search_exts.indexOf(`|${e2}|`) === -1)\n            continue;\n          if (++cnt > 1)\n            throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${path}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${extptn}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n        }\n      }\n      for (let e in h_exts) {\n        if (search_exts.indexOf(`|${e}|`) > -1)\n          return h_exts[e];\n      }\n      throw `\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${extptn}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3059\\u308B\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${path}\\u3011`;\n    }\n    if (extptn !== \"\" && `|${extptn}|`.indexOf(`|${ext}|`) === -1) {\n      throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u62E1\\u5F35\\u5B50\\u3010${ext}\\u3011\\u306F\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${extptn}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${path}\\u3011`;\n    }\n    ret = h_exts[ext];\n    if (!ret)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3010${ext}\\u3011\\u3067\\u3059\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${path}\\u3011\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${extptn}\\u3011`;\n    return ret;\n  }\n  matchPath(fnptn, extptn = \"\") {\n    const aRet = [];\n    const regPtn = new RegExp(fnptn);\n    const regExt = new RegExp(extptn);\n    for (let fn2 in this.hPathFn2Exts) {\n      if (fn2.search(regPtn) === -1)\n        continue;\n      const h_exts = this.hPathFn2Exts[fn2];\n      if (extptn === \"\") {\n        aRet.push(h_exts);\n        continue;\n      }\n      const o = {};\n      let isa = false;\n      for (const ext in h_exts) {\n        if (ext.search(regExt) === -1)\n          continue;\n        o[ext] = fn2;\n        isa = true;\n      }\n      if (isa)\n        aRet.push(o);\n    }\n    return aRet;\n  }\n  addPath(fn2, h_exts) {\n    const o = {};\n    for (const ext in h_exts) {\n      o[ext] = (ext.charAt(0) === \":\" ? `` : this.sys.cur) + h_exts[ext];\n    }\n    this.hPathFn2Exts[fn2] = o;\n  }\n};\nlet Config = _Config;\n_existsBreakline = /* @__PURE__ */ new WeakMap();\n_existsBreakpage = /* @__PURE__ */ new WeakMap();\n_REG_PATH = /* @__PURE__ */ new WeakMap();\nConfig.EXT_SPRITE = \"png|jpg|jpeg|json|svg|webp|mp4|webm\";\nConfig.EXT_SCRIPT = \"sn|ssn\";\nConfig.EXT_FONT = \"woff2|woff|otf|ttf\";\nConfig.EXT_SOUND = \"mp3|m4a|ogg|aac|flac|wav\";\nConfig.EXT_HTML = \"htm|html\";\nconst _RubySpliter = class {\n  constructor() {\n    __privateAdd2(this, _putCh, () => {\n    });\n  }\n  static setting(hArg) {\n    if (hArg.sesame)\n      __privateSet2(_RubySpliter, _sesame, hArg.sesame);\n  }\n  static getSesame() {\n    return __privateGet2(_RubySpliter, _sesame);\n  }\n  static destroy() {\n    __privateSet2(_RubySpliter, _sesame, \"\\u30FD\");\n  }\n  init(putCh) {\n    __privateSet2(this, _putCh, putCh);\n  }\n  static setEscape(ce) {\n    __privateSet2(_RubySpliter, _REG_RUBY, new RegExp(`${ce ? `(?<ce>\\\\${ce}\\\\S)|` : \"\"}\\uFF5C(?<str>[^\\u300A\\\\n]+)\\u300A(?<ruby>[^\\u300B\\\\n]+)\\u300B|(?:(?<kan>[\\u2E80-\\u2FDF\\u3005\\u3007\\u303B\\u3400-\\u9FFF\\u8C48-\\uFAFF]+[\\u3041-\\u30FF]*|[^\\u3000\\uFF5C\\u300A\\u300B\\\\n])\\u300A(?<kan_ruby>[^\\u300B\\\\n]+)\\u300B)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^\\u3000\\uFF5C\\u300A\\u300B]+(?=\\uFF5C)|[^\\u3000\\uFF5C\\u300A\\u300B]*[\\u3041-\\u30FF](?=[\\u2E80-\\u2FDF\\u3005\\u3007\\u303B\\u3400-\\u9FFF\\u8C48-\\uFAFF]+\\u300A)|.)`, \"gs\"));\n  }\n  putTxt(text2) {\n    var _a3;\n    let e = null;\n    while (e = __privateGet2(_RubySpliter, _REG_RUBY).exec(text2)) {\n      const g2 = e == null ? void 0 : e.groups;\n      if (!g2)\n        continue;\n      const ruby = g2.ruby;\n      if (ruby) {\n        this.putTxtRb(g2.str, ruby);\n        continue;\n      }\n      const kan_ruby = g2.kan_ruby;\n      if (kan_ruby) {\n        this.putTxtRb(g2.kan, kan_ruby);\n        continue;\n      }\n      if (g2.ce) {\n        __privateGet2(this, _putCh).call(this, g2.ce.slice(1), \"\");\n        continue;\n      }\n      Array.from((_a3 = g2.txt) != null ? _a3 : \"\").forEach((v2) => __privateGet2(this, _putCh).call(this, v2, \"\"));\n    }\n  }\n  putTxtRb(text2, ruby) {\n    const a2 = Array.from(text2);\n    const len = a2.length;\n    if (ruby.charAt(0) === \"*\" && ruby.length <= 2) {\n      const rb_ses = \"center\\uFF5C\" + (ruby === \"*\" ? __privateGet2(_RubySpliter, _sesame) : ruby.charAt(1));\n      for (let i2 = 0; i2 < len; ++i2)\n        __privateGet2(this, _putCh).call(this, a2[i2], rb_ses);\n      return;\n    }\n    if (len === 1 || ruby.indexOf(\" \") === -1) {\n      __privateGet2(this, _putCh).call(this, text2, ruby.replaceAll(\"\t\", \" \"));\n      return;\n    }\n    const aR = ruby.split(\" \");\n    const lenR = aR.length;\n    const len_max = lenR > len ? lenR : len;\n    for (let i2 = 0; i2 < len_max; ++i2) {\n      __privateGet2(this, _putCh).call(this, i2 < len ? a2[i2] : \"\", i2 < lenR ? aR[i2].replaceAll(\"\t\", \" \") : \"\");\n    }\n  }\n};\nlet RubySpliter = _RubySpliter;\n_sesame = new WeakMap();\n_putCh = new WeakMap();\n_REG_RUBY = new WeakMap();\n__privateAdd2(RubySpliter, _sesame, \"\\u30FD\");\n__privateAdd2(RubySpliter, _REG_RUBY, void 0);\nconst REG_TAG = /(?<name>[^\\s;\\]]+)/;\nfunction tagToken2Name_Args(token) {\n  const e = REG_TAG.exec(token.slice(1, -1));\n  const g2 = e == null ? void 0 : e.groups;\n  if (!g2)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${token}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  const nm = g2.name;\n  return [nm, token.slice(1 + nm.length, -1)];\n}\nfunction tagToken2Name(token) {\n  const e = REG_TAG.exec(token.slice(1));\n  const g2 = e == null ? void 0 : e.groups;\n  if (!g2)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${token}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  return g2.name;\n}\nfunction splitAmpersand(token) {\n  const equa = token.replaceAll(\"==\", \"\\uFF1D\").replaceAll(\"!=\", \"\\u2260\").split(\"=\");\n  const cnt_equa = equa.length;\n  if (cnt_equa < 2 || cnt_equa > 3)\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C=\\u300D\\u6307\\u5B9A\\u304C\\u4E00\\u3064\\u304B\\u4E8C\\u3064\\u5FC5\\u8981\\u3067\\u3059\";\n  if (equa[1].charAt(0) === \"&\")\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  return {\n    name: equa[0].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    text: equa[1].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    cast: cnt_equa === 3 ? equa[2].trim() : void 0\n  };\n}\nclass Grammar {\n  constructor() {\n    __privateAdd2(this, _REG_CANTC2M, void 0);\n    __privateAdd2(this, _REGC2M, void 0);\n    __privateAdd2(this, _regStrC2M, void 0);\n    __privateAdd2(this, _regStrC2M4not, void 0);\n    __privateAdd2(this, _hC2M, void 0);\n    __privateSet2(this, _REGC2M, new RegExp(\"\"));\n    __privateSet2(this, _regStrC2M, \"\");\n    __privateSet2(this, _regStrC2M4not, \"\");\n    this.replaceScr_C2M_And_let_ml = (scr, start_idx = 0) => {\n      if (!__privateGet2(this, _hC2M))\n        return;\n      for (let i2 = scr.len - 1; i2 >= start_idx; --i2) {\n        const token = scr.aToken[i2];\n        if (this.REG_TOKEN_NOTXT.test(token.charAt(0)))\n          continue;\n        const lnum = scr.aLNum[i2];\n        const a2 = token.match(__privateGet2(this, _REGC2M));\n        if (!a2)\n          continue;\n        let del = 1;\n        for (let j2 = a2.length - 1; j2 >= 0; --j2) {\n          let ch = a2[j2];\n          const macro = __privateGet2(this, _hC2M)[ch.charAt(0)];\n          if (macro) {\n            ch = macro + (macro.slice(-1) === \"]\" ? \"\" : `'${ch.slice(1, -1)}']`);\n          }\n          scr.aToken.splice(i2, del, ch);\n          scr.aLNum.splice(i2, del, lnum);\n          del = 0;\n        }\n      }\n      scr.len = scr.aToken.length;\n    };\n    this.setEscape(\"\");\n  }\n  setEscape(ce) {\n    if (__privateGet2(this, _hC2M) && ce in __privateGet2(this, _hC2M))\n      throw \"[\\u30A8\\u30B9\\u30B1\\u30FC\\u30D7\\u6587\\u5B57] char\\u3010\" + ce + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    const ces = ce != null ? ce : \"\\\\\";\n    this.REG_TOKEN = new RegExp((ce ? `\\\\${ce}\\\\S|` : \"\") + `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:[^\"'#;\\\\]]+|` + (ces ? `(?:\"(?:\\\\${ces}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${ces}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${ces}[\"'#\\\\n]|[^#])*\\\\#)` : `([\"'#]).*?\\\\1`) + `|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^;\\\\n\\\\t&]+|^\\\\*\\\\w+|[^\\\\n\\\\t\\\\[;${ce ? `\\\\${ce}` : \"\"}]+`, \"gs\");\n    RubySpliter.setEscape(ce);\n    __privateSet2(this, _REG_CANTC2M, new RegExp(`[\\\\w\\\\s;[\\\\]*=&\\uFF5C\\u300A\\u300B${ce ? `\\\\${ce}` : \"\"}]`));\n    this.REG_TOKEN_NOTXT = new RegExp(`[\\\\n\\\\t;\\\\[*&${ce ? `\\\\${ce}` : \"\"}]`);\n  }\n  matchToken(txt) {\n    var _a3;\n    return (_a3 = txt.match(this.REG_TOKEN)) != null ? _a3 : [];\n  }\n  bracket2macro(hArg, script, idxToken) {\n    var _a3;\n    const { name, text: text2 } = hArg;\n    if (!name)\n      throw \"[bracket2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!text2)\n      throw \"[bracket2macro] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (text2.length !== 2)\n      throw \"[bracket2macro] text\\u306F\\u62EC\\u5F27\\u306E\\u524D\\u5F8C\\u3092\\u793A\\u3059\\u4E8C\\u6587\\u5B57\\u3092\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\";\n    (_a3 = __privateGet2(this, _hC2M)) != null ? _a3 : __privateSet2(this, _hC2M, {});\n    const op = text2.charAt(0);\n    const cl = text2.charAt(1);\n    if (op in __privateGet2(this, _hC2M))\n      throw \"[bracket2macro] text\\u3010\" + op + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (cl in __privateGet2(this, _hC2M))\n      throw \"[bracket2macro] text\\u3010\" + cl + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (__privateGet2(this, _REG_CANTC2M).test(op))\n      throw \"[bracket2macro] text\\u3010\" + op + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (__privateGet2(this, _REG_CANTC2M).test(cl))\n      throw \"[bracket2macro] text\\u3010\" + cl + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    __privateGet2(this, _hC2M)[cl] = \"0\";\n    __privateGet2(this, _hC2M)[op] = `[${name} text=`;\n    this.addC2M(`\\\\${op}[^\\\\${cl}]*\\\\${cl}`, `\\\\${op}\\\\${cl}`);\n    this.replaceScr_C2M_And_let_ml(script, idxToken);\n  }\n  char2macro(hArg, hTag, script, idxToken) {\n    var _a3;\n    const { char, name } = hArg;\n    if (!char)\n      throw \"[char2macro] char\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    (_a3 = __privateGet2(this, _hC2M)) != null ? _a3 : __privateSet2(this, _hC2M, {});\n    if (char in __privateGet2(this, _hC2M))\n      throw \"[char2macro] char\\u3010\" + char + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (__privateGet2(this, _REG_CANTC2M).test(char))\n      throw \"[char2macro] char\\u3010\" + char + \"\\u3011\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (!name)\n      throw \"[char2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!(name in hTag))\n      throw `[char2macro] \\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u53C8\\u306F\\u30DE\\u30AF\\u30ED[${name}]\\u3067\\u3059`;\n    __privateGet2(this, _hC2M)[char] = `[${name}]`;\n    this.addC2M(`\\\\${char}`, `\\\\${char}`);\n    this.replaceScr_C2M_And_let_ml(script, idxToken);\n  }\n  addC2M(a2, b2) {\n    __privateSet2(this, _regStrC2M, __privateGet2(this, _regStrC2M) + `${a2}|`);\n    __privateSet2(this, _regStrC2M4not, __privateGet2(this, _regStrC2M4not) + `${b2}`);\n    __privateSet2(this, _REGC2M, new RegExp(`(${__privateGet2(this, _regStrC2M)}[^${__privateGet2(this, _regStrC2M4not)}]+)`, \"g\"));\n  }\n}\n_REG_CANTC2M = new WeakMap();\n_REGC2M = new WeakMap();\n_regStrC2M = new WeakMap();\n_regStrC2M4not = new WeakMap();\n_hC2M = new WeakMap();\nclass AnalyzeTagArg {\n  constructor() {\n    __privateAdd2(this, _REG_TAGARG, /;[^\\n]*|(?<key>\\w+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    __privateAdd2(this, _hPrm, {});\n    __privateAdd2(this, _isKomeParam, false);\n  }\n  go(args) {\n    var _a3, _b3;\n    __privateSet2(this, _hPrm, {});\n    __privateSet2(this, _isKomeParam, false);\n    if (!args)\n      return;\n    let e = null;\n    while (e = __privateGet2(this, _REG_TAGARG).exec(args)) {\n      const g2 = e == null ? void 0 : e.groups;\n      if (!g2)\n        continue;\n      if (g2.key)\n        __privateGet2(this, _hPrm)[g2.key] = {\n          val: (_a3 = g2.val) != null ? _a3 : g2.val2,\n          def: (_b3 = g2.def) != null ? _b3 : g2.def2\n        };\n      else if (g2.literal) {\n        if (g2.literal === \"*\")\n          __privateSet2(this, _isKomeParam, true);\n        else\n          __privateGet2(this, _hPrm)[g2.literal] = { val: \"1\" };\n      }\n    }\n  }\n  get hPrm() {\n    return __privateGet2(this, _hPrm);\n  }\n  get isKomeParam() {\n    return __privateGet2(this, _isKomeParam);\n  }\n}\n_REG_TAGARG = new WeakMap();\n_hPrm = new WeakMap();\n_isKomeParam = new WeakMap();\nvar parsimmon_umd_min = { exports: {} };\n(function(module, exports) {\n  !function(n, t) {\n    module.exports = t();\n  }(typeof self != \"undefined\" ? self : commonjsGlobal, function() {\n    return function(n) {\n      var t = {};\n      function r2(e) {\n        if (t[e])\n          return t[e].exports;\n        var u2 = t[e] = { i: e, l: false, exports: {} };\n        return n[e].call(u2.exports, u2, u2.exports, r2), u2.l = true, u2.exports;\n      }\n      return r2.m = n, r2.c = t, r2.d = function(n2, t2, e) {\n        r2.o(n2, t2) || Object.defineProperty(n2, t2, { configurable: false, enumerable: true, get: e });\n      }, r2.r = function(n2) {\n        Object.defineProperty(n2, \"__esModule\", { value: true });\n      }, r2.n = function(n2) {\n        var t2 = n2 && n2.__esModule ? function() {\n          return n2.default;\n        } : function() {\n          return n2;\n        };\n        return r2.d(t2, \"a\", t2), t2;\n      }, r2.o = function(n2, t2) {\n        return Object.prototype.hasOwnProperty.call(n2, t2);\n      }, r2.p = \"\", r2(r2.s = 0);\n    }([function(n, t, r2) {\n      function e(n2) {\n        if (!(this instanceof e))\n          return new e(n2);\n        this._ = n2;\n      }\n      var u2 = e.prototype;\n      function o(n2, t2) {\n        for (var r3 = 0; r3 < n2; r3++)\n          t2(r3);\n      }\n      function i2(n2, t2, r3) {\n        return function(n3, t3) {\n          o(t3.length, function(r4) {\n            n3(t3[r4], r4, t3);\n          });\n        }(function(r4, e2, u3) {\n          t2 = n2(t2, r4, e2, u3);\n        }, r3), t2;\n      }\n      function a2(n2, t2) {\n        return i2(function(t3, r3, e2, u3) {\n          return t3.concat([n2(r3, e2, u3)]);\n        }, [], t2);\n      }\n      function f2(n2, t2) {\n        var r3 = { v: 0, buf: t2 };\n        return o(n2, function() {\n          var n3;\n          r3 = { v: r3.v << 1 | (n3 = r3.buf, n3[0] >> 7), buf: function(n4) {\n            var t3 = i2(function(n5, t4, r4, e2) {\n              return n5.concat(r4 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r4));\n            }, [], n4);\n            return Buffer.from(a2(function(n5) {\n              return (n5 << 1 & 65535) >> 8;\n            }, t3));\n          }(r3.buf) };\n        }), r3;\n      }\n      function c2() {\n        return typeof Buffer != \"undefined\";\n      }\n      function s2() {\n        if (!c2())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function l2(n2) {\n        s2();\n        var t2 = i2(function(n3, t3) {\n          return n3 + t3;\n        }, 0, n2);\n        if (t2 % 8 != 0)\n          throw new Error(\"The bits [\" + n2.join(\", \") + \"] add up to \" + t2 + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var r3, u3 = t2 / 8, o2 = (r3 = function(n3) {\n          return n3 > 48;\n        }, i2(function(n3, t3) {\n          return n3 || (r3(t3) ? t3 : n3);\n        }, null, n2));\n        if (o2)\n          throw new Error(o2 + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new e(function(t3, r4) {\n          var e2 = u3 + r4;\n          return e2 > t3.length ? x2(r4, u3.toString() + \" bytes\") : b2(e2, i2(function(n3, t4) {\n            var r5 = f2(t4, n3.buf);\n            return { coll: n3.coll.concat(r5.v), buf: r5.buf };\n          }, { coll: [], buf: t3.slice(r4, e2) }, n2).coll);\n        });\n      }\n      function h2(n2, t2) {\n        return new e(function(r3, e2) {\n          return s2(), e2 + t2 > r3.length ? x2(e2, t2 + \" bytes for \" + n2) : b2(e2 + t2, r3.slice(e2, e2 + t2));\n        });\n      }\n      function p2(n2, t2) {\n        if (typeof (r3 = t2) != \"number\" || Math.floor(r3) !== r3 || t2 < 0 || t2 > 6)\n          throw new Error(n2 + \" requires integer length in range [0, 6].\");\n        var r3;\n      }\n      function d2(n2) {\n        return p2(\"uintBE\", n2), h2(\"uintBE(\" + n2 + \")\", n2).map(function(t2) {\n          return t2.readUIntBE(0, n2);\n        });\n      }\n      function v2(n2) {\n        return p2(\"uintLE\", n2), h2(\"uintLE(\" + n2 + \")\", n2).map(function(t2) {\n          return t2.readUIntLE(0, n2);\n        });\n      }\n      function g2(n2) {\n        return p2(\"intBE\", n2), h2(\"intBE(\" + n2 + \")\", n2).map(function(t2) {\n          return t2.readIntBE(0, n2);\n        });\n      }\n      function m2(n2) {\n        return p2(\"intLE\", n2), h2(\"intLE(\" + n2 + \")\", n2).map(function(t2) {\n          return t2.readIntLE(0, n2);\n        });\n      }\n      function y2(n2) {\n        return n2 instanceof e;\n      }\n      function E2(n2) {\n        return {}.toString.call(n2) === \"[object Array]\";\n      }\n      function w2(n2) {\n        return c2() && Buffer.isBuffer(n2);\n      }\n      function b2(n2, t2) {\n        return { status: true, index: n2, value: t2, furthest: -1, expected: [] };\n      }\n      function x2(n2, t2) {\n        return E2(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n2, expected: t2 };\n      }\n      function B(n2, t2) {\n        if (!t2)\n          return n2;\n        if (n2.furthest > t2.furthest)\n          return n2;\n        var r3 = n2.furthest === t2.furthest ? function(n3, t3) {\n          if (function() {\n            if (e._supportsSet !== void 0)\n              return e._supportsSet;\n            var n4 = typeof Set != \"undefined\";\n            return e._supportsSet = n4, n4;\n          }() && Array.from) {\n            for (var r4 = new Set(n3), u3 = 0; u3 < t3.length; u3++)\n              r4.add(t3[u3]);\n            var o2 = Array.from(r4);\n            return o2.sort(), o2;\n          }\n          for (var i3 = {}, a3 = 0; a3 < n3.length; a3++)\n            i3[n3[a3]] = true;\n          for (var f3 = 0; f3 < t3.length; f3++)\n            i3[t3[f3]] = true;\n          var c3 = [];\n          for (var s3 in i3)\n            ({}).hasOwnProperty.call(i3, s3) && c3.push(s3);\n          return c3.sort(), c3;\n        }(n2.expected, t2.expected) : t2.expected;\n        return { status: n2.status, index: n2.index, value: n2.value, furthest: t2.furthest, expected: r3 };\n      }\n      var j2 = {};\n      function S2(n2, t2) {\n        if (w2(n2))\n          return { offset: t2, line: -1, column: -1 };\n        n2 in j2 || (j2[n2] = {});\n        for (var r3 = j2[n2], e2 = 0, u3 = 0, o2 = 0, i3 = t2; i3 >= 0; ) {\n          if (i3 in r3) {\n            e2 = r3[i3].line, o2 === 0 && (o2 = r3[i3].lineStart);\n            break;\n          }\n          (n2.charAt(i3) === \"\\n\" || n2.charAt(i3) === \"\\r\" && n2.charAt(i3 + 1) !== \"\\n\") && (u3++, o2 === 0 && (o2 = i3 + 1)), i3--;\n        }\n        var a3 = e2 + u3, f3 = t2 - o2;\n        return r3[t2] = { line: a3, lineStart: o2 }, { offset: t2, line: a3 + 1, column: f3 + 1 };\n      }\n      function _2(n2) {\n        if (!y2(n2))\n          throw new Error(\"not a parser: \" + n2);\n      }\n      function L(n2, t2) {\n        return typeof n2 == \"string\" ? n2.charAt(t2) : n2[t2];\n      }\n      function O2(n2) {\n        if (typeof n2 != \"number\")\n          throw new Error(\"not a number: \" + n2);\n      }\n      function k(n2) {\n        if (typeof n2 != \"function\")\n          throw new Error(\"not a function: \" + n2);\n      }\n      function P2(n2) {\n        if (typeof n2 != \"string\")\n          throw new Error(\"not a string: \" + n2);\n      }\n      var q = 2, A2 = 3, I2 = 8, F2 = 5 * I2, M = 4 * I2, z = \"  \";\n      function R(n2, t2) {\n        return new Array(t2 + 1).join(n2);\n      }\n      function U(n2, t2, r3) {\n        var e2 = t2 - n2.length;\n        return e2 <= 0 ? n2 : R(r3, e2) + n2;\n      }\n      function W(n2, t2, r3, e2) {\n        return { from: n2 - t2 > 0 ? n2 - t2 : 0, to: n2 + r3 > e2 ? e2 : n2 + r3 };\n      }\n      function D(n2, t2) {\n        var r3, e2, u3, o2, f3, c3 = t2.index, s3 = c3.offset, l3 = 1;\n        if (s3 === n2.length)\n          return \"Got the end of the input\";\n        if (w2(n2)) {\n          var h3 = s3 - s3 % I2, p3 = s3 - h3, d3 = W(h3, F2, M + I2, n2.length), v3 = a2(function(n3) {\n            return a2(function(n4) {\n              return U(n4.toString(16), 2, \"0\");\n            }, n3);\n          }, function(n3, t3) {\n            var r4 = n3.length, e3 = [], u4 = 0;\n            if (r4 <= t3)\n              return [n3.slice()];\n            for (var o3 = 0; o3 < r4; o3++)\n              e3[u4] || e3.push([]), e3[u4].push(n3[o3]), (o3 + 1) % t3 == 0 && u4++;\n            return e3;\n          }(n2.slice(d3.from, d3.to).toJSON().data, I2));\n          o2 = function(n3) {\n            return n3.from === 0 && n3.to === 1 ? { from: n3.from, to: n3.to } : { from: n3.from / I2, to: Math.floor(n3.to / I2) };\n          }(d3), e2 = h3 / I2, r3 = 3 * p3, p3 >= 4 && (r3 += 1), l3 = 2, u3 = a2(function(n3) {\n            return n3.length <= 4 ? n3.join(\" \") : n3.slice(0, 4).join(\" \") + \"  \" + n3.slice(4).join(\" \");\n          }, v3), (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2);\n        } else {\n          var g3 = n2.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          r3 = c3.column - 1, e2 = c3.line - 1, o2 = W(e2, q, A2, g3.length), u3 = g3.slice(o2.from, o2.to), f3 = o2.to.toString().length;\n        }\n        var m3 = e2 - o2.from;\n        return w2(n2) && (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2), i2(function(t3, e3, u4) {\n          var i3, a3 = u4 === m3, c4 = a3 ? \"> \" : z;\n          return i3 = w2(n2) ? U((8 * (o2.from + u4)).toString(16), f3, \"0\") : U((o2.from + u4 + 1).toString(), f3, \" \"), [].concat(t3, [c4 + i3 + \" | \" + e3], a3 ? [z + R(\" \", f3) + \" | \" + U(\"\", r3, \" \") + R(\"^\", l3)] : []);\n        }, [], u3).join(\"\\n\");\n      }\n      function N(n2, t2) {\n        return [\"\\n\", \"-- PARSING FAILED \" + R(\"-\", 50), \"\\n\\n\", D(n2, t2), \"\\n\\n\", (r3 = t2.expected, r3.length === 1 ? \"Expected:\\n\\n\" + r3[0] : \"Expected one of the following: \\n\\n\" + r3.join(\", \")), \"\\n\"].join(\"\");\n        var r3;\n      }\n      function G2(n2) {\n        return n2.flags !== void 0 ? n2.flags : [n2.global ? \"g\" : \"\", n2.ignoreCase ? \"i\" : \"\", n2.multiline ? \"m\" : \"\", n2.unicode ? \"u\" : \"\", n2.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function C2() {\n        for (var n2 = [].slice.call(arguments), t2 = n2.length, r3 = 0; r3 < t2; r3 += 1)\n          _2(n2[r3]);\n        return e(function(r4, e2) {\n          for (var u3, o2 = new Array(t2), i3 = 0; i3 < t2; i3 += 1) {\n            if (!(u3 = B(n2[i3]._(r4, e2), u3)).status)\n              return u3;\n            o2[i3] = u3.value, e2 = u3.index;\n          }\n          return B(b2(e2, o2), u3);\n        });\n      }\n      function J() {\n        var n2 = [].slice.call(arguments);\n        if (n2.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var t2 = n2.pop();\n        return k(t2), C2.apply(null, n2).map(function(n3) {\n          return t2.apply(null, n3);\n        });\n      }\n      function T2() {\n        var n2 = [].slice.call(arguments), t2 = n2.length;\n        if (t2 === 0)\n          return Y(\"zero alternates\");\n        for (var r3 = 0; r3 < t2; r3 += 1)\n          _2(n2[r3]);\n        return e(function(t3, r4) {\n          for (var e2, u3 = 0; u3 < n2.length; u3 += 1)\n            if ((e2 = B(n2[u3]._(t3, r4), e2)).status)\n              return e2;\n          return e2;\n        });\n      }\n      function V(n2, t2) {\n        return H(n2, t2).or(X([]));\n      }\n      function H(n2, t2) {\n        return _2(n2), _2(t2), J(n2, t2.then(n2).many(), function(n3, t3) {\n          return [n3].concat(t3);\n        });\n      }\n      function K(n2) {\n        P2(n2);\n        var t2 = \"'\" + n2 + \"'\";\n        return e(function(r3, e2) {\n          var u3 = e2 + n2.length, o2 = r3.slice(e2, u3);\n          return o2 === n2 ? b2(u3, o2) : x2(e2, t2);\n        });\n      }\n      function Q(n2, t2) {\n        !function(n3) {\n          if (!(n3 instanceof RegExp))\n            throw new Error(\"not a regexp: \" + n3);\n          for (var t3 = G2(n3), r4 = 0; r4 < t3.length; r4++) {\n            var e2 = t3.charAt(r4);\n            if (e2 !== \"i\" && e2 !== \"m\" && e2 !== \"u\" && e2 !== \"s\")\n              throw new Error('unsupported regexp flag \"' + e2 + '\": ' + n3);\n          }\n        }(n2), arguments.length >= 2 ? O2(t2) : t2 = 0;\n        var r3 = function(n3) {\n          return RegExp(\"^(?:\" + n3.source + \")\", G2(n3));\n        }(n2), u3 = \"\" + n2;\n        return e(function(n3, e2) {\n          var o2 = r3.exec(n3.slice(e2));\n          if (o2) {\n            if (0 <= t2 && t2 <= o2.length) {\n              var i3 = o2[0], a3 = o2[t2];\n              return b2(e2 + i3.length, a3);\n            }\n            return x2(e2, \"valid match group (0 to \" + o2.length + \") in \" + u3);\n          }\n          return x2(e2, u3);\n        });\n      }\n      function X(n2) {\n        return e(function(t2, r3) {\n          return b2(r3, n2);\n        });\n      }\n      function Y(n2) {\n        return e(function(t2, r3) {\n          return x2(r3, n2);\n        });\n      }\n      function Z(n2) {\n        if (y2(n2))\n          return e(function(t2, r3) {\n            var e2 = n2._(t2, r3);\n            return e2.index = r3, e2.value = \"\", e2;\n          });\n        if (typeof n2 == \"string\")\n          return Z(K(n2));\n        if (n2 instanceof RegExp)\n          return Z(Q(n2));\n        throw new Error(\"not a string, regexp, or parser: \" + n2);\n      }\n      function $(n2) {\n        return _2(n2), e(function(t2, r3) {\n          var e2 = n2._(t2, r3), u3 = t2.slice(r3, e2.index);\n          return e2.status ? x2(r3, 'not \"' + u3 + '\"') : b2(r3, null);\n        });\n      }\n      function nn(n2) {\n        return k(n2), e(function(t2, r3) {\n          var e2 = L(t2, r3);\n          return r3 < t2.length && n2(e2) ? b2(r3 + 1, e2) : x2(r3, \"a character/byte matching \" + n2);\n        });\n      }\n      function tn(n2, t2) {\n        arguments.length < 2 && (t2 = n2, n2 = void 0);\n        var r3 = e(function(n3, e2) {\n          return r3._ = t2()._, r3._(n3, e2);\n        });\n        return n2 ? r3.desc(n2) : r3;\n      }\n      function rn() {\n        return Y(\"fantasy-land/empty\");\n      }\n      u2.parse = function(n2) {\n        if (typeof n2 != \"string\" && !w2(n2))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var t2, r3 = this.skip(an)._(n2, 0);\n        return t2 = r3.status ? { status: true, value: r3.value } : { status: false, index: S2(n2, r3.furthest), expected: r3.expected }, delete j2[n2], t2;\n      }, u2.tryParse = function(n2) {\n        var t2 = this.parse(n2);\n        if (t2.status)\n          return t2.value;\n        var r3 = N(n2, t2), e2 = new Error(r3);\n        throw e2.type = \"ParsimmonError\", e2.result = t2, e2;\n      }, u2.assert = function(n2, t2) {\n        return this.chain(function(r3) {\n          return n2(r3) ? X(r3) : Y(t2);\n        });\n      }, u2.or = function(n2) {\n        return T2(this, n2);\n      }, u2.trim = function(n2) {\n        return this.wrap(n2, n2);\n      }, u2.wrap = function(n2, t2) {\n        return J(n2, this, t2, function(n3, t3) {\n          return t3;\n        });\n      }, u2.thru = function(n2) {\n        return n2(this);\n      }, u2.then = function(n2) {\n        return _2(n2), C2(this, n2).map(function(n3) {\n          return n3[1];\n        });\n      }, u2.many = function() {\n        var n2 = this;\n        return e(function(t2, r3) {\n          for (var e2 = [], u3 = void 0; ; ) {\n            if (!(u3 = B(n2._(t2, r3), u3)).status)\n              return B(b2(r3, e2), u3);\n            if (r3 === u3.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            r3 = u3.index, e2.push(u3.value);\n          }\n        });\n      }, u2.tieWith = function(n2) {\n        return P2(n2), this.map(function(t2) {\n          if (function(n3) {\n            if (!E2(n3))\n              throw new Error(\"not an array: \" + n3);\n          }(t2), t2.length) {\n            P2(t2[0]);\n            for (var r3 = t2[0], e2 = 1; e2 < t2.length; e2++)\n              P2(t2[e2]), r3 += n2 + t2[e2];\n            return r3;\n          }\n          return \"\";\n        });\n      }, u2.tie = function() {\n        return this.tieWith(\"\");\n      }, u2.times = function(n2, t2) {\n        var r3 = this;\n        return arguments.length < 2 && (t2 = n2), O2(n2), O2(t2), e(function(e2, u3) {\n          for (var o2 = [], i3 = void 0, a3 = void 0, f3 = 0; f3 < n2; f3 += 1) {\n            if (a3 = B(i3 = r3._(e2, u3), a3), !i3.status)\n              return a3;\n            u3 = i3.index, o2.push(i3.value);\n          }\n          for (; f3 < t2 && (a3 = B(i3 = r3._(e2, u3), a3), i3.status); f3 += 1)\n            u3 = i3.index, o2.push(i3.value);\n          return B(b2(u3, o2), a3);\n        });\n      }, u2.result = function(n2) {\n        return this.map(function() {\n          return n2;\n        });\n      }, u2.atMost = function(n2) {\n        return this.times(0, n2);\n      }, u2.atLeast = function(n2) {\n        return J(this.times(n2), this.many(), function(n3, t2) {\n          return n3.concat(t2);\n        });\n      }, u2.map = function(n2) {\n        k(n2);\n        var t2 = this;\n        return e(function(r3, e2) {\n          var u3 = t2._(r3, e2);\n          return u3.status ? B(b2(u3.index, n2(u3.value)), u3) : u3;\n        });\n      }, u2.contramap = function(n2) {\n        k(n2);\n        var t2 = this;\n        return e(function(r3, e2) {\n          var u3 = t2.parse(n2(r3.slice(e2)));\n          return u3.status ? b2(e2 + r3.length, u3.value) : u3;\n        });\n      }, u2.promap = function(n2, t2) {\n        return k(n2), k(t2), this.contramap(n2).map(t2);\n      }, u2.skip = function(n2) {\n        return C2(this, n2).map(function(n3) {\n          return n3[0];\n        });\n      }, u2.mark = function() {\n        return J(en, this, en, function(n2, t2, r3) {\n          return { start: n2, value: t2, end: r3 };\n        });\n      }, u2.node = function(n2) {\n        return J(en, this, en, function(t2, r3, e2) {\n          return { name: n2, value: r3, start: t2, end: e2 };\n        });\n      }, u2.sepBy = function(n2) {\n        return V(this, n2);\n      }, u2.sepBy1 = function(n2) {\n        return H(this, n2);\n      }, u2.lookahead = function(n2) {\n        return this.skip(Z(n2));\n      }, u2.notFollowedBy = function(n2) {\n        return this.skip($(n2));\n      }, u2.desc = function(n2) {\n        E2(n2) || (n2 = [n2]);\n        var t2 = this;\n        return e(function(r3, e2) {\n          var u3 = t2._(r3, e2);\n          return u3.status || (u3.expected = n2), u3;\n        });\n      }, u2.fallback = function(n2) {\n        return this.or(X(n2));\n      }, u2.ap = function(n2) {\n        return J(n2, this, function(n3, t2) {\n          return n3(t2);\n        });\n      }, u2.chain = function(n2) {\n        var t2 = this;\n        return e(function(r3, e2) {\n          var u3 = t2._(r3, e2);\n          return u3.status ? B(n2(u3.value)._(r3, u3.index), u3) : u3;\n        });\n      }, u2.concat = u2.or, u2.empty = rn, u2.of = X, u2[\"fantasy-land/ap\"] = u2.ap, u2[\"fantasy-land/chain\"] = u2.chain, u2[\"fantasy-land/concat\"] = u2.concat, u2[\"fantasy-land/empty\"] = u2.empty, u2[\"fantasy-land/of\"] = u2.of, u2[\"fantasy-land/map\"] = u2.map;\n      var en = e(function(n2, t2) {\n        return b2(t2, S2(n2, t2));\n      }), un = e(function(n2, t2) {\n        return t2 >= n2.length ? x2(t2, \"any character/byte\") : b2(t2 + 1, L(n2, t2));\n      }), on2 = e(function(n2, t2) {\n        return b2(n2.length, n2.slice(t2));\n      }), an = e(function(n2, t2) {\n        return t2 < n2.length ? x2(t2, \"EOF\") : b2(t2, null);\n      }), fn2 = Q(/[0-9]/).desc(\"a digit\"), cn = Q(/[0-9]*/).desc(\"optional digits\"), sn = Q(/[a-z]/i).desc(\"a letter\"), ln = Q(/[a-z]*/i).desc(\"optional letters\"), hn = Q(/\\s*/).desc(\"optional whitespace\"), pn = Q(/\\s+/).desc(\"whitespace\"), dn = K(\"\\r\"), vn = K(\"\\n\"), gn = K(\"\\r\\n\"), mn = T2(gn, vn, dn).desc(\"newline\"), yn = T2(mn, an);\n      e.all = on2, e.alt = T2, e.any = un, e.cr = dn, e.createLanguage = function(n2) {\n        var t2 = {};\n        for (var r3 in n2)\n          ({}).hasOwnProperty.call(n2, r3) && function(r4) {\n            t2[r4] = tn(function() {\n              return n2[r4](t2);\n            });\n          }(r3);\n        return t2;\n      }, e.crlf = gn, e.custom = function(n2) {\n        return e(n2(b2, x2));\n      }, e.digit = fn2, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y2, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x2, e.makeSuccess = b2, e.newline = mn, e.noneOf = function(n2) {\n        return nn(function(t2) {\n          return n2.indexOf(t2) < 0;\n        }).desc(\"none of '\" + n2 + \"'\");\n      }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n2) {\n        for (var t2 = n2.split(\"\"), r3 = 0; r3 < t2.length; r3++)\n          t2[r3] = \"'\" + t2[r3] + \"'\";\n        return nn(function(t3) {\n          return n2.indexOf(t3) >= 0;\n        }).desc(t2);\n      }, e.optWhitespace = hn, e.Parser = e, e.range = function(n2, t2) {\n        return nn(function(r3) {\n          return n2 <= r3 && r3 <= t2;\n        }).desc(n2 + \"-\" + t2);\n      }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C2, e.seqMap = J, e.seqObj = function() {\n        for (var n2, t2 = {}, r3 = 0, u3 = (n2 = arguments, Array.prototype.slice.call(n2)), o2 = u3.length, i3 = 0; i3 < o2; i3 += 1) {\n          var a3 = u3[i3];\n          if (!y2(a3)) {\n            if (E2(a3) && a3.length === 2 && typeof a3[0] == \"string\" && y2(a3[1])) {\n              var f3 = a3[0];\n              if (Object.prototype.hasOwnProperty.call(t2, f3))\n                throw new Error(\"seqObj: duplicate key \" + f3);\n              t2[f3] = true, r3++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (r3 === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return e(function(n3, t3) {\n          for (var r4, e2 = {}, i4 = 0; i4 < o2; i4 += 1) {\n            var a4, f4;\n            if (E2(u3[i4]) ? (a4 = u3[i4][0], f4 = u3[i4][1]) : (a4 = null, f4 = u3[i4]), !(r4 = B(f4._(n3, t3), r4)).status)\n              return r4;\n            a4 && (e2[a4] = r4.value), t3 = r4.index;\n          }\n          return B(b2(t3, e2), r4);\n        });\n      }, e.string = K, e.succeed = X, e.takeWhile = function(n2) {\n        return k(n2), e(function(t2, r3) {\n          for (var e2 = r3; e2 < t2.length && n2(L(t2, e2)); )\n            e2++;\n          return b2(e2, t2.slice(r3, e2));\n        });\n      }, e.test = nn, e.whitespace = pn, e[\"fantasy-land/empty\"] = rn, e[\"fantasy-land/of\"] = X, e.Binary = { bitSeq: l2, bitSeqObj: function(n2) {\n        s2();\n        var t2 = {}, r3 = 0, e2 = a2(function(n3) {\n          if (E2(n3)) {\n            var e3 = n3;\n            if (e3.length !== 2)\n              throw new Error(\"[\" + e3.join(\", \") + \"] should be length 2, got length \" + e3.length);\n            if (P2(e3[0]), O2(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + e3[0]);\n            return t2[e3[0]] = true, r3++, e3;\n          }\n          return O2(n3), [null, n3];\n        }, n2);\n        if (r3 < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + n2.join(\", \") + \"]\");\n        var u3 = a2(function(n3) {\n          return n3[0];\n        }, e2);\n        return l2(a2(function(n3) {\n          return n3[1];\n        }, e2)).map(function(n3) {\n          return i2(function(n4, t3) {\n            return t3[0] !== null && (n4[t3[0]] = t3[1]), n4;\n          }, {}, a2(function(t3, r4) {\n            return [t3, n3[r4]];\n          }, u3));\n        });\n      }, byte: function(n2) {\n        if (s2(), O2(n2), n2 > 255)\n          throw new Error(\"Value specified to byte constructor (\" + n2 + \"=0x\" + n2.toString(16) + \") is larger in value than a single byte.\");\n        var t2 = (n2 > 15 ? \"0x\" : \"0x0\") + n2.toString(16);\n        return e(function(r3, e2) {\n          var u3 = L(r3, e2);\n          return u3 === n2 ? b2(e2 + 1, u3) : x2(e2, t2);\n        });\n      }, buffer: function(n2) {\n        return h2(\"buffer\", n2).map(function(n3) {\n          return Buffer.from(n3);\n        });\n      }, encodedString: function(n2, t2) {\n        return h2(\"string\", t2).map(function(t3) {\n          return t3.toString(n2);\n        });\n      }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v2, uint8LE: v2(1), uint16LE: v2(2), uint32LE: v2(4), intBE: g2, int8BE: g2(1), int16BE: g2(2), int32BE: g2(4), intLE: m2, int8LE: m2(1), int16LE: m2(2), int32LE: m2(4), floatBE: h2(\"floatBE\", 4).map(function(n2) {\n        return n2.readFloatBE(0);\n      }), floatLE: h2(\"floatLE\", 4).map(function(n2) {\n        return n2.readFloatLE(0);\n      }), doubleBE: h2(\"doubleBE\", 8).map(function(n2) {\n        return n2.readDoubleBE(0);\n      }), doubleLE: h2(\"doubleLE\", 8).map(function(n2) {\n        return n2.readDoubleLE(0);\n      }) }, n.exports = e;\n    }]);\n  });\n})(parsimmon_umd_min);\nconst _PropParser = class {\n  constructor(val, ce = \"\\\\\") {\n    __privateAdd2(this, _calc);\n    __privateAdd2(this, _fncSub_ChkNum);\n    __privateAdd2(this, _procEmbedVar);\n    __privateAdd2(this, _parser, void 0);\n    __privateAdd2(this, _hFnc, void 0);\n    __privateAdd2(this, _REG_EMBEDVAR, void 0);\n    this.val = val;\n    __privateSet2(this, _parser, null);\n    __privateSet2(this, _hFnc, {\n      \"!num!\": (a2) => a2.shift(),\n      \"!str!\": (a2) => __privateMethod2(this, _procEmbedVar, procEmbedVar_fn).call(this, a2.shift()),\n      \"!bool!\": (a2) => a2.shift(),\n      \"!\": (a2) => {\n        const b2 = a2.shift();\n        return b2[0] === \"!bool!\" ? !Boolean(b2[1]) : !(String(__privateMethod2(this, _calc, calc_fn).call(this, b2)) === \"true\");\n      },\n      \"~\": (a2) => ~Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"**\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) ** Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"*\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) * Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"/\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) / Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"\\xA5\": (a2) => Math.floor(__privateGet2(this, _hFnc)[\"/\"](a2)),\n      \"%\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) % Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"+\": (a2) => {\n        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        if (Object.prototype.toString.call(b2) === \"[object String]\" || Object.prototype.toString.call(c2) === \"[object String]\") {\n          return String(b2) + String(c2);\n        }\n        return Number(b2) + Number(c2);\n      },\n      \"-\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) - Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"int\": (a2) => int(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),\n      \"parseInt\": (a2) => int(__privateGet2(this, _hFnc)[\"Number\"](a2)),\n      \"Number\": (a2) => {\n        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        if (Object.prototype.toString.call(b2) !== \"[object String]\")\n          return Number(b2);\n        return __privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, __privateGet2(this, _parser).parse(String(b2)).value);\n      },\n      \"ceil\": (a2) => Math.ceil(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),\n      \"floor\": (a2) => Math.floor(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),\n      \"round\": (a2) => Math.round(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),\n      \"isNaN\": (a2) => isNaN(Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift()))),\n      \"<<\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) << Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \">>\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >> Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \">>>\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >>> Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"<\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) < Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"<=\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) <= Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \">\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) > Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \">=\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >= Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"==\": (a2) => {\n        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        if (b2 == null && c2 == null && (!b2 || !c2))\n          return b2 == c2;\n        return String(b2) === String(c2);\n      },\n      \"!=\": (a2) => !__privateGet2(this, _hFnc)[\"==\"](a2),\n      \"===\": (a2) => {\n        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());\n        if (Object.prototype.toString.call(b2) != Object.prototype.toString.call(c2))\n          return false;\n        return String(b2) === String(c2);\n      },\n      \"!==\": (a2) => !__privateGet2(this, _hFnc)[\"===\"](a2),\n      \"&\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) & Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"^\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) ^ Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"|\": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) | Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),\n      \"&&\": (a2) => String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === \"true\" && String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === \"true\",\n      \"||\": (a2) => String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === \"true\" || String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === \"true\",\n      \"?\": (a2) => {\n        const b2 = a2.shift();\n        let cond = false;\n        if (b2[0] === \"!bool!\") {\n          cond = Boolean(b2[1]);\n        } else {\n          const cond2 = String(__privateMethod2(this, _calc, calc_fn).call(this, b2));\n          cond = cond2 !== \"true\" && cond2 !== \"false\" ? int(cond2) !== 0 : cond2 === \"true\";\n        }\n        const elm2 = a2.shift();\n        if (elm2[0] !== \":\")\n          throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002: \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n        return __privateMethod2(this, _calc, calc_fn).call(this, elm2[cond ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002? \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n      }\n    });\n    __privateSet2(this, _REG_EMBEDVAR, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g);\n    this.getValAmpersand = (val2) => val2.charAt(0) === \"&\" ? String(this.parse(val2.slice(1))) : val2;\n    function ope(a2) {\n      const ps = [];\n      a2.forEach((v2) => ps.push((v2 instanceof RegExp ? parsimmon_umd_min.exports.regex(v2) : parsimmon_umd_min.exports.string(v2)).trim(parsimmon_umd_min.exports.optWhitespace)));\n      return parsimmon_umd_min.exports.alt.apply(null, ps);\n    }\n    function PREFIX2(operatorsParser, nextParser) {\n      const parser2 = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(operatorsParser, parser2).or(nextParser));\n      return parser2;\n    }\n    function BINARY_RIGHT(operatorsParser, nextParser) {\n      let parser2 = parsimmon_umd_min.exports.lazy(() => nextParser.chain((next) => parsimmon_umd_min.exports.seq(operatorsParser, parsimmon_umd_min.exports.of(next), parser2).or(parsimmon_umd_min.exports.of(next))));\n      return parser2;\n    }\n    function BINARY_LEFT(operatorsParser, nextParser) {\n      return parsimmon_umd_min.exports.seqMap(nextParser, parsimmon_umd_min.exports.seq(operatorsParser, nextParser).many(), (first, rest) => rest.reduce((acc, ch) => [ch[0], acc, ch[1]], first));\n    }\n    const Num = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/), parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)).map(Number), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)).map((n) => int(n))).map((str2) => [\"!num!\", str2]).desc(\"number\");\n    const NullLiteral = parsimmon_umd_min.exports.string(\"null\").map(() => [\"!str!\", null]);\n    const BooleanLiteral = parsimmon_umd_min.exports.regex(/(true|false)/).map((b2) => [\"!bool!\", b2 === \"true\"]).desc(\"boolean\");\n    const StringLiteral = parsimmon_umd_min.exports.regex(new RegExp(`(?:\"(?:\\\\${ce}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${ce}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${ce}[\"'#\\\\n]|[^#])*\\\\#)`)).map((b2) => [\"!str!\", b2.slice(1, -1).replaceAll(ce, \"\")]).desc(\"string\");\n    const REG_BRACKETS = /\\[[^\\]]+\\]/g;\n    const VarLiteral = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((b2) => {\n      const s2 = String(b2).replace(REG_BRACKETS, (v2) => \".\" + this.parse(v2.slice(1, -1)));\n      if (s2.charAt(0) === \"-\") {\n        const val3 = this.val.getVal(s2.slice(1));\n        if (val3 == null || String(val3) === \"null\")\n          throw Error(\"(PropParser)\\u6570\\u5024\\u4EE5\\u5916\\u306B-\\u7B26\\u53F7\\u304C\\u3064\\u3044\\u3066\\u3044\\u307E\\u3059\");\n        return [\"!num!\", -Number(val3)];\n      }\n      const val2 = this.val.getVal(s2);\n      if (val2 == null)\n        return [\"!str!\", val2];\n      if (typeof val2 === \"boolean\")\n        return [\"!bool!\", val2];\n      return Object.prototype.toString.call(val2) === \"[object String]\" ? [\"!str!\", String(val2)] : [\"!num!\", Number(val2)];\n    }).desc(\"string\");\n    const Basic = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.string(\"(\").then(__privateGet2(this, _parser)).skip(parsimmon_umd_min.exports.string(\")\")).or(Num).or(NullLiteral).or(BooleanLiteral).or(StringLiteral).or(VarLiteral));\n    const table = [\n      { type: PREFIX2, ops: ope([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      { type: PREFIX2, ops: ope([/(!(?!=)|~)/]) },\n      { type: BINARY_RIGHT, ops: ope([\"**\"]) },\n      { type: BINARY_LEFT, ops: ope([\"*\", \"/\", \"\\xA5\", \"%\"]) },\n      { type: BINARY_LEFT, ops: ope([\"+\", \"-\"]) },\n      { type: BINARY_LEFT, ops: ope([/(>>>|<<|>>)/]) },\n      { type: BINARY_LEFT, ops: ope([/(<=|<|>=|>)/]) },\n      { type: BINARY_LEFT, ops: ope([/(===|!==|==|!=)/]) },\n      { type: BINARY_LEFT, ops: ope([/&(?!&)/]) },\n      { type: BINARY_LEFT, ops: ope([\"^\"]) },\n      { type: BINARY_LEFT, ops: ope([/\\|(?!\\|)/]) },\n      { type: BINARY_LEFT, ops: ope([\"&&\"]) },\n      { type: BINARY_LEFT, ops: ope([\"||\"]) },\n      { type: BINARY_RIGHT, ops: ope([\":\"]) },\n      { type: BINARY_RIGHT, ops: ope([\"?\"]) }\n    ];\n    const tableParser = table.reduce((acc, level) => level.type(level.ops, acc), Basic);\n    __privateSet2(this, _parser, tableParser.trim(parsimmon_umd_min.exports.optWhitespace));\n  }\n  parse(s2) {\n    const p2 = __privateGet2(this, _parser).parse(s2);\n    if (!p2.status)\n      throw Error(\"(PropParser)\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3010\" + s2 + \"\\u3011\");\n    const a2 = p2.value;\n    if (a2[0] === \"!str!\")\n      return __privateMethod2(this, _procEmbedVar, procEmbedVar_fn).call(this, a2[1]);\n    return __privateMethod2(this, _calc, calc_fn).call(this, a2);\n  }\n  static getValName(arg_name) {\n    var _a3, _b3;\n    const e = __privateGet2(this, _REG_VAL).exec(arg_name.trim());\n    const g2 = e == null ? void 0 : e.groups;\n    if (!g2)\n      return void 0;\n    return {\n      scope: g2.scope || \"tmp\",\n      name: __privateMethod2(_a3 = _PropParser, _getValName_B2D, getValName_B2D_fn).call(_a3, g2.name),\n      at: (_b3 = g2.at) != null ? _b3 : \"\"\n    };\n  }\n};\nlet PropParser = _PropParser;\n_parser = new WeakMap();\n_calc = new WeakSet();\ncalc_fn = function(a2) {\n  const elm = a2.shift();\n  if (elm instanceof Array)\n    return __privateMethod2(this, _calc, calc_fn).call(this, elm);\n  const fnc = __privateGet2(this, _hFnc)[elm];\n  return fnc ? fnc(a2) : Object(null);\n};\n_hFnc = new WeakMap();\n_fncSub_ChkNum = new WeakSet();\nfncSub_ChkNum_fn = function(v2) {\n  const b2 = __privateMethod2(this, _calc, calc_fn).call(this, v2);\n  if (Object.prototype.toString.call(b2) !== \"[object Number]\")\n    throw Error(\"(PropParser)\\u5F15\\u6570\\u3010\" + b2 + \"\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\");\n  return Number(b2);\n};\n_REG_EMBEDVAR = new WeakMap();\n_procEmbedVar = new WeakSet();\nprocEmbedVar_fn = function(b2) {\n  if (b2 == null)\n    return b2;\n  return String(b2).replace(__privateGet2(this, _REG_EMBEDVAR), (v2) => {\n    return v2.charAt(0) === \"$\" ? this.val.getVal(v2.slice(1)) : this.parse(v2.slice(2, -1));\n  });\n};\n_REG_VAL = new WeakMap();\n_getValName_B2D = new WeakSet();\ngetValName_B2D_fn = function(str2) {\n  let i2 = 0, e = 0;\n  while (true) {\n    i2 = str2.indexOf('[\"');\n    if (i2 < 0) {\n      i2 = str2.indexOf(\"['\");\n      if (i2 < 0)\n        break;\n      e = str2.indexOf(\"']\", i2 + 2);\n    } else {\n      e = str2.indexOf('\"]', i2 + 2);\n    }\n    if (e < 0)\n      break;\n    str2 = str2.slice(0, i2) + \".\" + str2.slice(i2 + 2, e) + str2.slice(e + 2);\n    i2 = e - 2;\n  }\n  return str2;\n};\n__privateAdd2(PropParser, _getValName_B2D);\n__privateAdd2(PropParser, _REG_VAL, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar __accessCheck$3 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$3 = (obj, member, getter) => {\n  __accessCheck$3(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$3 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet$3 = (obj, member, value2, setter) => {\n  __accessCheck$3(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar __privateMethod$3 = (obj, member, method) => {\n  __accessCheck$3(obj, member, \"access private method\");\n  return method;\n};\nvar _scrItr$1, _hTag, _title, _spnDbg, _first, _log, log_fn, _trace, trace_fn, _st_trace, st_trace_fn, _dspDbg, dspDbg_fn;\nconst _DebugMng = class {\n  constructor(sys, hTag, scrItr) {\n    this.sys = sys;\n    __privateAdd$3(this, _log);\n    __privateAdd$3(this, _trace);\n    __privateAdd$3(this, _first, true);\n    __privateSet$3(_DebugMng, _scrItr$1, scrItr);\n    __privateSet$3(_DebugMng, _hTag, hTag);\n    __privateSet$3(_DebugMng, _title, hTag.title);\n    _DebugMng.myTrace = __privateMethod$3(_DebugMng, _st_trace, st_trace_fn);\n    hTag.log = (o) => __privateMethod$3(this, _log, log_fn).call(this, o);\n    hTag.trace = (o) => __privateMethod$3(this, _trace, trace_fn).call(this, o);\n    __privateSet$3(_DebugMng, _spnDbg, document.createElement(\"span\"));\n    __privateGet$3(_DebugMng, _spnDbg).hidden = true;\n    __privateGet$3(_DebugMng, _spnDbg).textContent = \"\";\n    __privateGet$3(_DebugMng, _spnDbg).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`;\n    document.body.appendChild(__privateGet$3(_DebugMng, _spnDbg));\n  }\n  destroy() {\n    __privateSet$3(_DebugMng, _title, () => false);\n    document.body.removeChild(__privateGet$3(_DebugMng, _spnDbg));\n    _DebugMng.myTrace = _DebugMng.trace_beforeNew;\n  }\n  static trace_beforeNew(txt, lvl = \"E\") {\n    let mes = `{${lvl}} ` + txt;\n    let sty = \"\";\n    switch (lvl) {\n      case \"D\":\n        sty = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        sty = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        sty = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw mes;\n      case \"E\":\n        console.error(\"%c\" + mes, \"color:#FF3300;\");\n        return;\n      default:\n        sty = \"color:black;\";\n        mes = \" \" + mes;\n    }\n    console.info(\"%c\" + mes, sty);\n  }\n};\nlet DebugMng = _DebugMng;\n_scrItr$1 = /* @__PURE__ */ new WeakMap();\n_hTag = /* @__PURE__ */ new WeakMap();\n_title = /* @__PURE__ */ new WeakMap();\n_spnDbg = /* @__PURE__ */ new WeakMap();\n_first = /* @__PURE__ */ new WeakMap();\n_log = /* @__PURE__ */ new WeakSet();\nlog_fn = function(hArg) {\n  let dat = \"\";\n  if (__privateGet$3(this, _first)) {\n    __privateSet$3(this, _first, false);\n    dat = `== ${platform.description} ==\n`;\n  }\n  this.sys.appendFile(this.sys.path_downloads + \"log.txt\", `${dat}--- ${getDateStr(\"-\", \"_\", \"\")} [fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}] prj:${this.sys.cur}\n${hArg.text || `(text is ${hArg.text})`}\n`, (err) => {\n    if (err)\n      console.log(err);\n  });\n  return false;\n};\n_trace = /* @__PURE__ */ new WeakSet();\ntrace_fn = function(hArg) {\n  _DebugMng.myTrace(hArg.text || `(text is ${hArg.text})`, \"I\");\n  return false;\n};\n_st_trace = /* @__PURE__ */ new WeakSet();\nst_trace_fn = function(txt, lvl = \"E\") {\n  var _a3, _b3;\n  let mes = `{${lvl}} `;\n  if (__privateGet$3(_DebugMng, _scrItr$1) && __privateGet$3(_DebugMng, _scrItr$1).lineNum > 0)\n    mes += `(fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}) `;\n  mes += txt;\n  __privateMethod$3(_a3 = _DebugMng, _dspDbg, dspDbg_fn).call(_a3, mes, lvl);\n  let sty = \"\";\n  switch (lvl) {\n    case \"D\":\n      sty = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      sty = \"color:#F80;\";\n      break;\n    case \"F\":\n      sty = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      __privateGet$3(_b3 = _DebugMng, _title).call(_b3, { text: txt });\n      __privateGet$3(this, _hTag).dump_lay({});\n      __privateGet$3(this, _hTag).dump_val({});\n      __privateGet$3(_DebugMng, _scrItr$1).dumpErrForeLine();\n      __privateGet$3(this, _hTag).dump_stack({});\n      if (lvl === \"ET\")\n        throw mes;\n      console.error(\"%c\" + mes, \"color:#F30;\");\n      return;\n    default:\n      sty = \"\";\n      mes = \" \" + mes;\n  }\n  console.info(\"%c\" + mes, sty);\n};\n_dspDbg = /* @__PURE__ */ new WeakSet();\ndspDbg_fn = function(mes, lvl) {\n  let sty = \"\";\n  switch (lvl) {\n    case \"D\":\n      sty = \"color:#05A;\";\n      break;\n    case \"W\":\n      sty = \"color:#F80;\";\n      break;\n    case \"F\":\n      sty = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      sty = \"color:#F30;\";\n      break;\n    default:\n      sty = \"\";\n  }\n  __privateGet$3(_DebugMng, _spnDbg).innerHTML += `<span style='${sty}'>${mes}</span><br/>`;\n  __privateGet$3(_DebugMng, _spnDbg).hidden = false;\n};\n__privateAdd$3(DebugMng, _st_trace);\n__privateAdd$3(DebugMng, _dspDbg);\n__privateAdd$3(DebugMng, _scrItr$1, void 0);\n__privateAdd$3(DebugMng, _hTag, void 0);\n__privateAdd$3(DebugMng, _title, void 0);\n__privateAdd$3(DebugMng, _spnDbg, void 0);\nDebugMng.myTrace = _DebugMng.trace_beforeNew;\nclass Areas {\n  constructor() {\n    this.hAreas = {};\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(idx) {\n    for (const begin in this.hAreas) {\n      if (idx < parseInt(begin))\n        continue;\n      if (idx <= this.hAreas[begin])\n        return true;\n    }\n    return false;\n  }\n  record(idx) {\n    if (this.search(idx))\n      return;\n    for (const begin in this.hAreas) {\n      if (this.hAreas[begin] + 1 === idx) {\n        if (idx + 1 in this.hAreas) {\n          this.hAreas[begin] = this.hAreas[idx + 1];\n          delete this.hAreas[idx + 1];\n        } else {\n          this.hAreas[begin] = idx;\n        }\n        return;\n      }\n    }\n    if (idx + 1 in this.hAreas) {\n      this.hAreas[idx] = this.hAreas[idx + 1];\n      delete this.hAreas[idx + 1];\n      return;\n    }\n    this.hAreas[idx] = idx;\n  }\n  erase(idx) {\n    if (!this.search(idx))\n      return;\n    if (idx in this.hAreas) {\n      if (this.hAreas[idx] > idx)\n        this.hAreas[idx + 1] = this.hAreas[idx];\n      delete this.hAreas[idx];\n      return;\n    }\n    for (const begin in this.hAreas) {\n      if (idx < parseInt(begin))\n        continue;\n      if (this.hAreas[begin] < idx)\n        continue;\n      if (this.hAreas[begin] === idx) {\n        this.hAreas[begin] = idx - 1;\n        return;\n      }\n      this.hAreas[idx + 1] = this.hAreas[begin];\n      this.hAreas[begin] = idx - 1;\n      return;\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  toString() {\n    let ret = \"\";\n    const aBegin = [];\n    for (const begin in this.hAreas)\n      aBegin.push(parseInt(begin));\n    aBegin.sort(function(x2, y2) {\n      return x2 - y2;\n    });\n    aBegin.forEach((v2) => {\n      ret += \",\" + v2 + (v2 === this.hAreas[v2]) ? \"\" : 0;\n    });\n    if (ret !== \"\")\n      ret = ret.slice(1);\n    return ret;\n  }\n}\nconst _Variable = class {\n  constructor(cfg, hTag) {\n    __privateAdd2(this, _set_data_break);\n    __privateAdd2(this, _copybookmark);\n    __privateAdd2(this, _erasebookmark);\n    __privateAdd2(this, _let);\n    __privateAdd2(this, _let_abs);\n    __privateAdd2(this, _let_char_at);\n    __privateAdd2(this, _let_index_of);\n    __privateAdd2(this, _let_length);\n    __privateAdd2(this, _let_replace);\n    __privateAdd2(this, _let_round);\n    __privateAdd2(this, _let_search);\n    __privateAdd2(this, _let_substr);\n    __privateAdd2(this, _clearsysvar);\n    __privateAdd2(this, _clearvar);\n    __privateAdd2(this, _castAuto);\n    __privateAdd2(this, _runFirst_Bool_hSysVal_true);\n    __privateAdd2(this, _runFirst_sys_an_tagCh_msecWait);\n    __privateAdd2(this, _runFirst_sys_an_tagCh_msecWait_Kidoku);\n    __privateAdd2(this, _runFirst_sys_an_auto_msecPageWait);\n    __privateAdd2(this, _runFirst_sys_an_auto_msecLineWait);\n    __privateAdd2(this, _runFirst_Bool_hSaveVal_true);\n    __privateAdd2(this, _runFirst_Bool_hTmp_true);\n    __privateAdd2(this, _runFirst_Bool_hTmp_false);\n    __privateAdd2(this, _hScopes, void 0);\n    __privateAdd2(this, _hSave, void 0);\n    __privateAdd2(this, _hTmp, void 0);\n    __privateAdd2(this, _sys2, void 0);\n    __privateAdd2(this, _data, void 0);\n    __privateAdd2(this, _hSys, void 0);\n    __privateAdd2(this, _hAreaKidoku, void 0);\n    __privateAdd2(this, _callHook, void 0);\n    __privateAdd2(this, _hProcDbgRes, void 0);\n    __privateAdd2(this, _flush, void 0);\n    __privateAdd2(this, _doRecProc, void 0);\n    __privateAdd2(this, _setVal, void 0);\n    __privateAdd2(this, _REG_NUMERICLITERAL, void 0);\n    __privateAdd2(this, _dump_val, void 0);\n    __privateAdd2(this, _doRecLog, void 0);\n    __privateAdd2(this, _hValTrg, void 0);\n    var _a3;\n    this.cfg = cfg;\n    __privateSet2(this, _hScopes, { sys: {}, save: {}, tmp: {}, mp: {} });\n    __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save);\n    __privateSet2(this, _hTmp, __privateGet2(this, _hScopes).tmp);\n    __privateSet2(this, _data, { sys: {}, mark: {}, kidoku: {} });\n    __privateSet2(this, _hAreaKidoku, {});\n    __privateSet2(this, _hProcDbgRes, {\n      auth: (_2, o) => __privateMethod2(this, _set_data_break, set_data_break_fn).call(this, o.hBreakpoint.aData),\n      var: (_2, o) => {\n        var _a4;\n        return __privateGet2(this, _sys2).send2Dbg(o.ri, { v: (_a4 = __privateGet2(this, _hScopes)[o.scope]) != null ? _a4 : {} });\n      },\n      set_var: (_2, o) => {\n        try {\n          __privateGet2(this, _setVal).call(this, o.nm, o.val);\n          __privateGet2(this, _sys2).send2Dbg(o.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (_2, o) => {\n        __privateMethod2(this, _set_data_break, set_data_break_fn).call(this, o.a);\n        __privateGet2(this, _sys2).send2Dbg(o.ri, {});\n      },\n      disconnect: (_2) => __privateSet2(_Variable, _hSetEvent, {})\n    });\n    __privateSet2(this, _flush, () => {\n    });\n    __privateSet2(this, _doRecProc, (_doRec) => {\n    });\n    this.getMark = (place) => __privateGet2(this, _data).mark[place];\n    this.getAreaKidoku = (fn2) => __privateGet2(this, _hAreaKidoku)[fn2];\n    __privateSet2(this, _setVal, (arg_name, val, autocast = true) => {\n      if (!arg_name)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      if (val == null)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\\uFF08\\u7A7A\\u6587\\u5B57\\u306FOK\\uFF09\";\n      const o = PropParser.getValName(arg_name);\n      if (o === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + arg_name + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const hScope = __privateGet2(this, _hScopes)[o.scope];\n      if (!hScope)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] scope\\u304C\\u7570\\u5E38\\u3010\" + o.scope + \"\\u3011\\u3067\\u3059\";\n      const nm = o[\"name\"];\n      if (nm.slice(0, 6) === \"const.\" && nm in hScope) {\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] \\u5909\\u6570\\u3010\" + nm + \"\\u3011\\u306F\\u66F8\\u304D\\u63DB\\u3048\\u4E0D\\u53EF\\u3067\\u3059\";\n      }\n      this.setVal_Nochk(o.scope, nm, val, autocast);\n    });\n    this.getVal = (arg_name, def) => {\n      if (!arg_name)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      const o = PropParser.getValName(arg_name);\n      if (o === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + arg_name + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const hScope = __privateGet2(this, _hScopes)[o[\"scope\"]];\n      if (!hScope)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] scope\\u304C\\u7570\\u5E38\\u3010\" + o[\"scope\"] + \"\\u3011\\u3067\\u3059\";\n      const val_name = o[\"name\"];\n      let val = hScope[val_name];\n      if (!(val_name in hScope)) {\n        val = def;\n        let nm = \"\";\n        const aNm = val_name.split(\".\");\n        const len = aNm.length;\n        for (let i2 = 0; i2 < len; ++i2, nm += \".\") {\n          nm += aNm[i2];\n          if (!(nm in hScope))\n            continue;\n          let v2 = JSON.parse(hScope[nm]);\n          if (Object.prototype.toString.call(v2) !== \"[object Object]\") {\n            if (i2 + 1 === len) {\n              val = v2;\n              break;\n            }\n            continue;\n          }\n          let j2 = i2;\n          while (++j2 < len) {\n            if (!(aNm[j2] in v2)) {\n              val = def;\n              break;\n            }\n            v2 = v2[aNm[j2]];\n            if (Object.prototype.toString.call(v2) !== \"[object Object]\" || j2 + 1 === len) {\n              val = v2;\n              break;\n            }\n          }\n          if (val instanceof Object)\n            val = JSON.stringify(val);\n          break;\n        }\n      }\n      if (val instanceof Function)\n        val = val();\n      return o[\"at\"] === \"@str\" ? val : __privateMethod2(this, _castAuto, castAuto_fn).call(this, val);\n    };\n    __privateSet2(this, _REG_NUMERICLITERAL, /^-?[\\d\\.]+$/);\n    __privateSet2(this, _dump_val, () => {\n      const val = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let scope in val) {\n        const hVal = __privateGet2(this, _hScopes)[scope];\n        const hRet = val[scope];\n        for (let key in hVal) {\n          const v2 = hVal[key];\n          if (Object.prototype.toString.call(v2) === \"[object Function]\") {\n            hRet[key] = v2();\n          } else\n            hRet[key] = v2;\n        }\n      }\n      console.info(\"\\u{1F95F} [dump_val]\", val);\n      return false;\n    });\n    __privateSet2(this, _doRecLog, false);\n    __privateSet2(this, _hValTrg, {\n      \"sys:sn.tagCh.doWait\": (name) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name),\n      \"sys:sn.tagCh.doWait_Kidoku\": (name) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name),\n      \"sys:sn.tagCh.msecWait\": (name) => __privateMethod2(this, _runFirst_sys_an_tagCh_msecWait, runFirst_sys_an_tagCh_msecWait_fn).call(this, name),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (name) => __privateMethod2(this, _runFirst_sys_an_tagCh_msecWait_Kidoku, runFirst_sys_an_tagCh_msecWait_Kidoku_fn).call(this, name),\n      \"sys:sn.tagCh.canskip\": (name) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name),\n      \"sys:sn.auto.msecPageWait\": (name) => __privateMethod2(this, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn).call(this, name),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (name) => __privateMethod2(this, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn).call(this, name),\n      \"sys:sn.auto.msecLineWait\": (name) => __privateMethod2(this, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn).call(this, name),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (name) => __privateMethod2(this, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn).call(this, name),\n      \"save:sn.doRecLog\": (name) => {\n        __privateGet2(this, _doRecProc).call(this, __privateSet2(this, _doRecLog, __privateMethod2(this, _runFirst_Bool_hSaveVal_true, runFirst_Bool_hSaveVal_true_fn).call(this, name)));\n      },\n      \"save:sn.userFnTail\": (_name, val) => this.cfg.userFnTail = val,\n      \"tmp:sn.tagL.enabled\": (name) => __privateMethod2(this, _runFirst_Bool_hTmp_true, runFirst_Bool_hTmp_true_fn).call(this, name),\n      \"tmp:sn.skip.all\": (name) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name),\n      \"tmp:sn.skip.enabled\": (name) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name),\n      \"tmp:sn.auto.enabled\": (name) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    });\n    hTag.let = (o) => __privateMethod2(this, _let, let_fn).call(this, o);\n    hTag.let_abs = (o) => __privateMethod2(this, _let_abs, let_abs_fn).call(this, o);\n    hTag.let_char_at = (o) => __privateMethod2(this, _let_char_at, let_char_at_fn).call(this, o);\n    hTag.let_index_of = (o) => __privateMethod2(this, _let_index_of, let_index_of_fn).call(this, o);\n    hTag.let_length = (o) => __privateMethod2(this, _let_length, let_length_fn).call(this, o);\n    hTag.let_replace = (o) => __privateMethod2(this, _let_replace, let_replace_fn).call(this, o);\n    hTag.let_round = (o) => __privateMethod2(this, _let_round, let_round_fn).call(this, o);\n    hTag.let_search = (o) => __privateMethod2(this, _let_search, let_search_fn).call(this, o);\n    hTag.let_substr = (o) => __privateMethod2(this, _let_substr, let_substr_fn).call(this, o);\n    hTag.clearsysvar = () => __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);\n    hTag.clearvar = () => __privateMethod2(this, _clearvar, clearvar_fn).call(this);\n    hTag.dump_val = () => __privateGet2(this, _dump_val).call(this);\n    hTag.copybookmark = (o) => __privateMethod2(this, _copybookmark, copybookmark_fn).call(this, o);\n    hTag.erasebookmark = (o) => __privateMethod2(this, _erasebookmark, erasebookmark_fn).call(this, o);\n    __privateGet2(this, _hSave)[\"sn.userFnTail\"] = \"\";\n    this.defTmp(\"const.sn.bookmark.json\", () => {\n      const a2 = [];\n      Object.keys(__privateGet2(this, _data).mark).sort().forEach((k) => {\n        const o = __spreadValues({}, __privateGet2(this, _data).mark[k].json);\n        o.place = k;\n        a2.push(o);\n      });\n      return JSON.stringify(a2);\n    });\n    __privateGet2(this, _hTmp)[\"const.sn.isFirstBoot\"] = true;\n    __privateGet2(this, _hTmp)[\"sn.tagL.enabled\"] = true;\n    __privateGet2(this, _hTmp)[\"sn.skip.all\"] = false;\n    __privateGet2(this, _hTmp)[\"sn.skip.enabled\"] = false;\n    __privateGet2(this, _hTmp)[\"sn.auto.enabled\"] = false;\n    __privateGet2(this, _hTmp)[\"const.sn.last_page_text\"] = \"\";\n    __privateGet2(this, _hTmp)[\"const.sn.displayState\"] = false;\n    __privateGet2(this, _hTmp)[\"const.Date.getTime\"] = () => new Date().getTime();\n    __privateGet2(this, _hTmp)[\"const.Date.getDateStr\"] = () => getDateStr();\n    __privateGet2(this, _hTmp)[\"const.sn.platform\"] = JSON.stringify(platform);\n    __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);\n    __privateMethod2(this, _clearvar, clearvar_fn).call(this);\n    __privateGet2(this, _hTmp)[\"const.sn.config.window.width\"] = cfg.oCfg.window.width;\n    __privateGet2(this, _hTmp)[\"const.sn.config.window.height\"] = cfg.oCfg.window.height;\n    __privateGet2(this, _hTmp)[\"const.sn.config.book.title\"] = cfg.oCfg.book.title;\n    __privateGet2(this, _hTmp)[\"const.sn.config.book.version\"] = cfg.oCfg.book.version;\n    __privateGet2(this, _hTmp)[\"const.sn.Math.PI\"] = Math.PI;\n    if (typeof window === \"undefined\")\n      return;\n    const win = window;\n    const ac = (_a3 = win[\"AudioContext\"]) != null ? _a3 : win[\"webkitAudioContext\"];\n    __privateGet2(this, _hTmp)[\"const.sn.needClick2Play\"] = () => new ac().state === \"suspended\";\n  }\n  setSys(sys) {\n    __privateSet2(this, _sys2, sys);\n    sys.initVal(__privateGet2(this, _data), __privateGet2(this, _hTmp), (data) => {\n      this.updateData(data);\n      sessionStorage.clear();\n      const ns = this.cfg.getNs();\n      __privateSet2(this, _flush, this.cfg.oCfg.debug.variable ? () => {\n        const oSys = {};\n        Object.keys(__privateGet2(this, _hSys)).forEach((k) => {\n          const v2 = __privateGet2(this, _hSys)[k];\n          oSys[\"sys:\" + k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"sys\"] = JSON.stringify(oSys);\n        const oSave = {};\n        Object.keys(__privateGet2(this, _hSave)).forEach((k) => {\n          const v2 = __privateGet2(this, _hSave)[k];\n          oSave[\"save:\" + k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"save\"] = JSON.stringify(oSave);\n        const oTmp = {};\n        Object.keys(__privateGet2(this, _hTmp)).forEach((k) => {\n          const v2 = __privateGet2(this, _hTmp)[k];\n          oTmp[k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"tmp\"] = JSON.stringify(oTmp);\n        const oMp = {};\n        Object.keys(__privateGet2(this, _hScopes).mp).forEach((k) => {\n          const v2 = __privateGet2(this, _hScopes).mp[k];\n          oMp[k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"mp\"] = JSON.stringify(oMp);\n        const oMark = {};\n        Object.keys(__privateGet2(this, _data).mark).forEach((k) => {\n          const v2 = __privateGet2(this, _data).mark[k];\n          oMark[k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"mark\"] = JSON.stringify(oMark);\n        const oKidoku = {};\n        Object.keys(__privateGet2(this, _data).kidoku).forEach((k) => {\n          const v2 = __privateGet2(this, _data).kidoku[k];\n          oKidoku[k] = v2 instanceof Function ? v2() : v2;\n        });\n        sessionStorage[ns + \"kidoku\"] = JSON.stringify(oKidoku);\n        sys.flush();\n      } : () => sys.flush());\n      __privateSet2(this, _callHook, (type, o) => sys.callHook(type, o));\n      sys.addHook((type, o) => {\n        var _a3, _b3;\n        return (_b3 = (_a3 = __privateGet2(this, _hProcDbgRes))[type]) == null ? void 0 : _b3.call(_a3, type, o);\n      });\n      const tm = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      if (__privateGet2(this, _hTmp)[\"const.sn.isFirstBoot\"] || tm === -1)\n        __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);\n    });\n  }\n  updateData(data) {\n    __privateSet2(this, _data, data);\n    __privateSet2(this, _hSys, __privateGet2(this, _hScopes).sys = __privateGet2(this, _data).sys);\n    __privateSet2(this, _hAreaKidoku, {});\n    for (const fn2 in __privateGet2(this, _data).kidoku) {\n      const areas = new Areas();\n      areas.hAreas = __spreadValues({}, __privateGet2(this, _data).kidoku[fn2]);\n      __privateGet2(this, _hAreaKidoku)[fn2] = areas;\n    }\n  }\n  flush() {\n    __privateGet2(this, _flush).call(this);\n  }\n  setDoRecProc(fnc) {\n    __privateSet2(this, _doRecProc, fnc);\n  }\n  defTmp(name, fnc) {\n    __privateGet2(this, _hTmp)[name] = fnc;\n  }\n  cloneMp() {\n    return __spreadValues({}, __privateGet2(this, _hScopes).mp);\n  }\n  setMp(mp) {\n    __privateGet2(this, _hScopes).mp = mp;\n  }\n  setMark(place, mark) {\n    __privateGet2(this, _data).mark[place] = mark;\n    this.flush();\n  }\n  cloneSave() {\n    return __spreadValues({}, __privateGet2(this, _hScopes).save);\n  }\n  mark2save(mark) {\n    var _a3;\n    __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save = __spreadValues({}, mark.hSave));\n    __privateSet2(this, _doRecLog, (_a3 = __privateGet2(this, _hSave)[\"sn.doRecLog\"]) != null ? _a3 : false);\n  }\n  loadScrWork(fn2) {\n    if (!(fn2 in __privateGet2(this, _hAreaKidoku)))\n      __privateGet2(this, _hAreaKidoku)[fn2] = new Areas();\n  }\n  saveKidoku() {\n    for (const fn2 in __privateGet2(this, _hAreaKidoku)) {\n      __privateGet2(this, _data).kidoku[fn2] = __spreadValues({}, __privateGet2(this, _hAreaKidoku)[fn2].hAreas);\n    }\n    this.flush();\n  }\n  setVal_Nochk(scope, nm, val, autocast = false) {\n    var _a3, _b3;\n    const hScope = __privateGet2(this, _hScopes)[scope];\n    if (autocast)\n      val = __privateMethod2(this, _castAuto, castAuto_fn).call(this, val);\n    const fullnm = scope + \":\" + nm;\n    if (fullnm in __privateGet2(_Variable, _hSetEvent)) {\n      const old_v = hScope[nm];\n      const new_v = val;\n      if (old_v != new_v)\n        __privateGet2(this, _callHook).call(this, \"data_break\", {\n          dataId: fullnm,\n          old_v,\n          new_v\n        });\n    }\n    hScope[nm] = val;\n    (_b3 = (_a3 = __privateGet2(this, _hValTrg))[fullnm]) == null ? void 0 : _b3.call(_a3, nm, val);\n  }\n  doRecLog() {\n    return __privateGet2(this, _doRecLog);\n  }\n  defValTrg(name, fnc) {\n    __privateGet2(this, _hValTrg)[name] = fnc;\n  }\n};\nlet Variable = _Variable;\n_hScopes = new WeakMap();\n_hSave = new WeakMap();\n_hTmp = new WeakMap();\n_sys2 = new WeakMap();\n_data = new WeakMap();\n_hSys = new WeakMap();\n_hAreaKidoku = new WeakMap();\n_callHook = new WeakMap();\n_hProcDbgRes = new WeakMap();\n_set_data_break = new WeakSet();\nset_data_break_fn = function(a2) {\n  __privateSet2(_Variable, _hSetEvent, {});\n  a2.forEach((v2) => __privateGet2(_Variable, _hSetEvent)[v2.dataId] = 1);\n};\n_flush = new WeakMap();\n_doRecProc = new WeakMap();\n_copybookmark = new WeakSet();\ncopybookmark_fn = function(hArg) {\n  if (!(\"from\" in hArg))\n    throw \"from\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!(\"to\" in hArg))\n    throw \"to\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const from = Number(hArg.from);\n  const to = Number(hArg.to);\n  if (from === to)\n    return false;\n  if (!(from in __privateGet2(this, _data).mark))\n    throw `from:${from} \\u306E\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  this.setMark(to, __spreadValues({}, __privateGet2(this, _data).mark[from]));\n  __privateGet2(this, _sys2).copyBMFolder(from, to);\n  return false;\n};\n_erasebookmark = new WeakSet();\nerasebookmark_fn = function(hArg) {\n  const { place } = hArg;\n  if (!place)\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  delete __privateGet2(this, _data).mark[place];\n  this.flush();\n  __privateGet2(this, _sys2).eraseBMFolder(place);\n  return false;\n};\n_let = new WeakSet();\nlet_fn = function(hArg) {\n  if (!hArg.name)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let autocast = true;\n  if (hArg.cast) {\n    switch (hArg.cast) {\n      case \"num\":\n        argChk_Num(hArg, \"text\", NaN);\n        break;\n      case \"int\":\n        hArg.text = String(int(argChk_Num(hArg, \"text\", NaN)));\n        break;\n      case \"uint\":\n        hArg.text = String(uint(argChk_Num(hArg, \"text\", NaN)));\n        break;\n      case \"bool\":\n        argChk_Boolean(hArg, \"text\", false);\n        break;\n      case \"str\":\n        autocast = false;\n        break;\n      default:\n        throw \"cast\\u3010\" + hArg.cast + \"\\u3011\\u306F\\u672A\\u5B9A\\u7FA9\\u3067\\u3059\";\n    }\n  }\n  __privateGet2(this, _setVal).call(this, hArg.name, hArg.text, autocast);\n  return false;\n};\n_let_abs = new WeakSet();\nlet_abs_fn = function(hArg) {\n  const n = argChk_Num(hArg, \"text\", 0);\n  hArg.text = String(n < 0 ? -n : n);\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_char_at = new WeakSet();\nlet_char_at_fn = function(hArg) {\n  var _a3;\n  hArg.text = ((_a3 = hArg.text) != null ? _a3 : \"\").charAt(argChk_Num(hArg, \"pos\", 0));\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_index_of = new WeakSet();\nlet_index_of_fn = function(hArg) {\n  var _a3;\n  const { val } = hArg;\n  if (!val)\n    throw \"val\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const start2 = argChk_Num(hArg, \"start\", 0);\n  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : \"\").indexOf(val, start2));\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_length = new WeakSet();\nlet_length_fn = function(hArg) {\n  var _a3;\n  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : \"\").length);\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_replace = new WeakSet();\nlet_replace_fn = function(hArg) {\n  var _a3;\n  if (!hArg.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags } = hArg;\n  const reg = !flags ? new RegExp(hArg.reg) : new RegExp(hArg.reg, flags);\n  hArg.text = String((_a3 = hArg.text) != null ? _a3 : \"\").replace(reg, String(hArg.val));\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_round = new WeakSet();\nlet_round_fn = function(hArg) {\n  const n = argChk_Num(hArg, \"text\", 0);\n  hArg.text = String(Math.round(n));\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_search = new WeakSet();\nlet_search_fn = function(hArg) {\n  var _a3;\n  if (!hArg.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags } = hArg;\n  const reg = !flags ? new RegExp(hArg.reg) : new RegExp(hArg.reg, flags);\n  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : \"\").search(reg));\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_let_substr = new WeakSet();\nlet_substr_fn = function(hArg) {\n  var _a3, _b3;\n  const i2 = argChk_Num(hArg, \"pos\", 0);\n  hArg.text = hArg.len !== \"all\" ? ((_a3 = hArg.text) != null ? _a3 : \"\").slice(i2, i2 + int(argChk_Num(hArg, \"len\", 1))) : ((_b3 = hArg.text) != null ? _b3 : \"\").slice(i2);\n  __privateMethod2(this, _let, let_fn).call(this, hArg);\n  return false;\n};\n_clearsysvar = new WeakSet();\nclearsysvar_fn = function() {\n  var _a3, _b3;\n  const sys = __privateSet2(this, _hSys, __privateGet2(this, _hScopes)[\"sys\"] = __privateGet2(this, _data).sys = {});\n  const is_nw = typeof process !== \"undefined\";\n  if (is_nw)\n    ;\n  else {\n    this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0);\n    this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0);\n  }\n  this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", true);\n  this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", true);\n  this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait);\n  this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait);\n  this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", true);\n  this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\");\n  this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", argChk_Num(sys, \"sn.auto.msecPageWait\", (_a3 = this.cfg.oCfg.init.auto_msecpagewait) != null ? _a3 : 3500));\n  this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", argChk_Num(sys, \"sn.auto.msecPageWait\", (_b3 = this.cfg.oCfg.init.auto_msecpagewait) != null ? _b3 : 3500));\n  this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500);\n  this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500);\n  this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1);\n  this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1);\n  this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const fn2 in __privateGet2(this, _data).kidoku) {\n    __privateGet2(this, _data).kidoku[fn2].hAreas = {};\n    __privateGet2(this, _hAreaKidoku)[fn2].clear();\n  }\n  this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5);\n  __privateGet2(this, _hScopes)[\"mark\"] = __privateGet2(this, _data).mark = {};\n  this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1);\n  this.flush();\n  return false;\n};\n_clearvar = new WeakSet();\nclearvar_fn = function() {\n  var _a3, _b3, _c3;\n  const mesLayer = (_a3 = __privateGet2(this, _hSave)[\"const.sn.mesLayer\"]) != null ? _a3 : \"\";\n  const doRecLog = (_b3 = __privateGet2(this, _hSave)[\"sn.doRecLog\"]) != null ? _b3 : false;\n  const sLog = (_c3 = __privateGet2(this, _hSave)[\"const.sn.sLog\"]) != null ? _c3 : \"[]\";\n  __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save = {});\n  this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", mesLayer);\n  this.setVal_Nochk(\"save\", \"sn.doRecLog\", doRecLog);\n  this.setVal_Nochk(\"save\", \"const.sn.sLog\", sLog);\n  return false;\n};\n_setVal = new WeakMap();\n_hSetEvent = new WeakMap();\n_castAuto = new WeakSet();\ncastAuto_fn = function(val) {\n  const s_val = val;\n  if (s_val === \"true\")\n    return true;\n  if (s_val === \"false\")\n    return false;\n  if (s_val === \"null\")\n    return null;\n  if (s_val === \"undefined\")\n    return void 0;\n  if (__privateGet2(this, _REG_NUMERICLITERAL).test(s_val))\n    return parseFloat(s_val);\n  return val;\n};\n_REG_NUMERICLITERAL = new WeakMap();\n_dump_val = new WeakMap();\n_doRecLog = new WeakMap();\n_hValTrg = new WeakMap();\n_runFirst_Bool_hSysVal_true = new WeakSet();\nrunFirst_Bool_hSysVal_true_fn = function(name) {\n  argChk_Boolean(__privateGet2(this, _hSys), name, true);\n};\n_runFirst_sys_an_tagCh_msecWait = new WeakSet();\nrunFirst_sys_an_tagCh_msecWait_fn = function(name) {\n  argChk_Num(__privateGet2(this, _hSys), name, 10);\n  if (__privateGet2(this, _hSys)[\"sn.tagCh.doWait\"])\n    ;\n};\n_runFirst_sys_an_tagCh_msecWait_Kidoku = new WeakSet();\nrunFirst_sys_an_tagCh_msecWait_Kidoku_fn = function(name) {\n  argChk_Num(__privateGet2(this, _hSys), name, this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait);\n  if (__privateGet2(this, _hSys)[\"sn.tagCh.doWait_Kidoku\"])\n    ;\n};\n_runFirst_sys_an_auto_msecPageWait = new WeakSet();\nrunFirst_sys_an_auto_msecPageWait_fn = function(name) {\n  argChk_Num(__privateGet2(this, _hSys), name, this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait);\n};\n_runFirst_sys_an_auto_msecLineWait = new WeakSet();\nrunFirst_sys_an_auto_msecLineWait_fn = function(name) {\n  argChk_Num(__privateGet2(this, _hSys), name, 500);\n};\n_runFirst_Bool_hSaveVal_true = new WeakSet();\nrunFirst_Bool_hSaveVal_true_fn = function(name) {\n  return argChk_Boolean(__privateGet2(this, _hSave), name, true);\n};\n_runFirst_Bool_hTmp_true = new WeakSet();\nrunFirst_Bool_hTmp_true_fn = function(name) {\n  argChk_Boolean(__privateGet2(this, _hTmp), name, true);\n};\n_runFirst_Bool_hTmp_false = new WeakSet();\nrunFirst_Bool_hTmp_false_fn = function(name) {\n  argChk_Boolean(__privateGet2(this, _hTmp), name, false);\n};\n__privateAdd2(Variable, _hSetEvent, {});\nvar Easing = {\n  Linear: {\n    None: function(amount) {\n      return amount;\n    }\n  },\n  Quadratic: {\n    In: function(amount) {\n      return amount * amount;\n    },\n    Out: function(amount) {\n      return amount * (2 - amount);\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 * amount * amount;\n      }\n      return -0.5 * (--amount * (amount - 2) - 1);\n    }\n  },\n  Cubic: {\n    In: function(amount) {\n      return amount * amount * amount;\n    },\n    Out: function(amount) {\n      return --amount * amount * amount + 1;\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 * amount * amount * amount;\n      }\n      return 0.5 * ((amount -= 2) * amount * amount + 2);\n    }\n  },\n  Quartic: {\n    In: function(amount) {\n      return amount * amount * amount * amount;\n    },\n    Out: function(amount) {\n      return 1 - --amount * amount * amount * amount;\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 * amount * amount * amount * amount;\n      }\n      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n    }\n  },\n  Quintic: {\n    In: function(amount) {\n      return amount * amount * amount * amount * amount;\n    },\n    Out: function(amount) {\n      return --amount * amount * amount * amount * amount + 1;\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return 0.5 * amount * amount * amount * amount * amount;\n      }\n      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n    }\n  },\n  Sinusoidal: {\n    In: function(amount) {\n      return 1 - Math.cos(amount * Math.PI / 2);\n    },\n    Out: function(amount) {\n      return Math.sin(amount * Math.PI / 2);\n    },\n    InOut: function(amount) {\n      return 0.5 * (1 - Math.cos(Math.PI * amount));\n    }\n  },\n  Exponential: {\n    In: function(amount) {\n      return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n    },\n    Out: function(amount) {\n      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n    },\n    InOut: function(amount) {\n      if (amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n        return 1;\n      }\n      if ((amount *= 2) < 1) {\n        return 0.5 * Math.pow(1024, amount - 1);\n      }\n      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n    }\n  },\n  Circular: {\n    In: function(amount) {\n      return 1 - Math.sqrt(1 - amount * amount);\n    },\n    Out: function(amount) {\n      return Math.sqrt(1 - --amount * amount);\n    },\n    InOut: function(amount) {\n      if ((amount *= 2) < 1) {\n        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n      }\n      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n    }\n  },\n  Elastic: {\n    In: function(amount) {\n      if (amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n        return 1;\n      }\n      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n    },\n    Out: function(amount) {\n      if (amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n        return 1;\n      }\n      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(amount) {\n      if (amount === 0) {\n        return 0;\n      }\n      if (amount === 1) {\n        return 1;\n      }\n      amount *= 2;\n      if (amount < 1) {\n        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);\n      }\n      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;\n    }\n  },\n  Back: {\n    In: function(amount) {\n      var s2 = 1.70158;\n      return amount * amount * ((s2 + 1) * amount - s2);\n    },\n    Out: function(amount) {\n      var s2 = 1.70158;\n      return --amount * amount * ((s2 + 1) * amount + s2) + 1;\n    },\n    InOut: function(amount) {\n      var s2 = 1.70158 * 1.525;\n      if ((amount *= 2) < 1) {\n        return 0.5 * (amount * amount * ((s2 + 1) * amount - s2));\n      }\n      return 0.5 * ((amount -= 2) * amount * ((s2 + 1) * amount + s2) + 2);\n    }\n  },\n  Bounce: {\n    In: function(amount) {\n      return 1 - Easing.Bounce.Out(1 - amount);\n    },\n    Out: function(amount) {\n      if (amount < 1 / 2.75) {\n        return 7.5625 * amount * amount;\n      } else if (amount < 2 / 2.75) {\n        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n      } else if (amount < 2.5 / 2.75) {\n        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n      } else {\n        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n      }\n    },\n    InOut: function(amount) {\n      if (amount < 0.5) {\n        return Easing.Bounce.In(amount * 2) * 0.5;\n      }\n      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n    }\n  }\n};\nvar now$1;\nif (typeof self === \"undefined\" && typeof process !== \"undefined\" && process.hrtime) {\n  now$1 = function() {\n    var time = process.hrtime();\n    return time[0] * 1e3 + time[1] / 1e6;\n  };\n} else if (typeof self !== \"undefined\" && self.performance !== void 0 && self.performance.now !== void 0) {\n  now$1 = self.performance.now.bind(self.performance);\n} else if (Date.now !== void 0) {\n  now$1 = Date.now;\n} else {\n  now$1 = function() {\n    return new Date().getTime();\n  };\n}\nvar now$1$1 = now$1;\nvar Group = function() {\n  function Group2() {\n    this._tweens = {};\n    this._tweensAddedDuringUpdate = {};\n  }\n  Group2.prototype.getAll = function() {\n    var _this = this;\n    return Object.keys(this._tweens).map(function(tweenId) {\n      return _this._tweens[tweenId];\n    });\n  };\n  Group2.prototype.removeAll = function() {\n    this._tweens = {};\n  };\n  Group2.prototype.add = function(tween) {\n    this._tweens[tween.getId()] = tween;\n    this._tweensAddedDuringUpdate[tween.getId()] = tween;\n  };\n  Group2.prototype.remove = function(tween) {\n    delete this._tweens[tween.getId()];\n    delete this._tweensAddedDuringUpdate[tween.getId()];\n  };\n  Group2.prototype.update = function(time, preserve) {\n    if (time === void 0) {\n      time = now$1$1();\n    }\n    if (preserve === void 0) {\n      preserve = false;\n    }\n    var tweenIds = Object.keys(this._tweens);\n    if (tweenIds.length === 0) {\n      return false;\n    }\n    while (tweenIds.length > 0) {\n      this._tweensAddedDuringUpdate = {};\n      for (var i2 = 0; i2 < tweenIds.length; i2++) {\n        var tween = this._tweens[tweenIds[i2]];\n        var autoStart = !preserve;\n        if (tween && tween.update(time, autoStart) === false && !preserve) {\n          delete this._tweens[tweenIds[i2]];\n        }\n      }\n      tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n    }\n    return true;\n  };\n  return Group2;\n}();\nvar Interpolation = {\n  Linear: function(v2, k) {\n    var m2 = v2.length - 1;\n    var f2 = m2 * k;\n    var i2 = Math.floor(f2);\n    var fn2 = Interpolation.Utils.Linear;\n    if (k < 0) {\n      return fn2(v2[0], v2[1], f2);\n    }\n    if (k > 1) {\n      return fn2(v2[m2], v2[m2 - 1], m2 - f2);\n    }\n    return fn2(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);\n  },\n  Bezier: function(v2, k) {\n    var b2 = 0;\n    var n = v2.length - 1;\n    var pw = Math.pow;\n    var bn = Interpolation.Utils.Bernstein;\n    for (var i2 = 0; i2 <= n; i2++) {\n      b2 += pw(1 - k, n - i2) * pw(k, i2) * v2[i2] * bn(n, i2);\n    }\n    return b2;\n  },\n  CatmullRom: function(v2, k) {\n    var m2 = v2.length - 1;\n    var f2 = m2 * k;\n    var i2 = Math.floor(f2);\n    var fn2 = Interpolation.Utils.CatmullRom;\n    if (v2[0] === v2[m2]) {\n      if (k < 0) {\n        i2 = Math.floor(f2 = m2 * (1 + k));\n      }\n      return fn2(v2[(i2 - 1 + m2) % m2], v2[i2], v2[(i2 + 1) % m2], v2[(i2 + 2) % m2], f2 - i2);\n    } else {\n      if (k < 0) {\n        return v2[0] - (fn2(v2[0], v2[0], v2[1], v2[1], -f2) - v2[0]);\n      }\n      if (k > 1) {\n        return v2[m2] - (fn2(v2[m2], v2[m2], v2[m2 - 1], v2[m2 - 1], f2 - m2) - v2[m2]);\n      }\n      return fn2(v2[i2 ? i2 - 1 : 0], v2[i2], v2[m2 < i2 + 1 ? m2 : i2 + 1], v2[m2 < i2 + 2 ? m2 : i2 + 2], f2 - i2);\n    }\n  },\n  Utils: {\n    Linear: function(p0, p1, t) {\n      return (p1 - p0) * t + p0;\n    },\n    Bernstein: function(n, i2) {\n      var fc = Interpolation.Utils.Factorial;\n      return fc(n) / fc(i2) / fc(n - i2);\n    },\n    Factorial: function() {\n      var a2 = [1];\n      return function(n) {\n        var s2 = 1;\n        if (a2[n]) {\n          return a2[n];\n        }\n        for (var i2 = n; i2 > 1; i2--) {\n          s2 *= i2;\n        }\n        a2[n] = s2;\n        return s2;\n      };\n    }(),\n    CatmullRom: function(p0, p1, p2, p3, t) {\n      var v0 = (p2 - p0) * 0.5;\n      var v1 = (p3 - p1) * 0.5;\n      var t2 = t * t;\n      var t3 = t * t2;\n      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n  }\n};\nvar Sequence = function() {\n  function Sequence2() {\n  }\n  Sequence2.nextId = function() {\n    return Sequence2._nextId++;\n  };\n  Sequence2._nextId = 0;\n  return Sequence2;\n}();\nvar mainGroup = new Group();\nvar Tween = function() {\n  function Tween2(_object, _group) {\n    if (_group === void 0) {\n      _group = mainGroup;\n    }\n    this._object = _object;\n    this._group = _group;\n    this._isPaused = false;\n    this._pauseStart = 0;\n    this._valuesStart = {};\n    this._valuesEnd = {};\n    this._valuesStartRepeat = {};\n    this._duration = 1e3;\n    this._initialRepeat = 0;\n    this._repeat = 0;\n    this._yoyo = false;\n    this._isPlaying = false;\n    this._reversed = false;\n    this._delayTime = 0;\n    this._startTime = 0;\n    this._easingFunction = Easing.Linear.None;\n    this._interpolationFunction = Interpolation.Linear;\n    this._chainedTweens = [];\n    this._onStartCallbackFired = false;\n    this._id = Sequence.nextId();\n    this._isChainStopped = false;\n    this._goToEnd = false;\n  }\n  Tween2.prototype.getId = function() {\n    return this._id;\n  };\n  Tween2.prototype.isPlaying = function() {\n    return this._isPlaying;\n  };\n  Tween2.prototype.isPaused = function() {\n    return this._isPaused;\n  };\n  Tween2.prototype.to = function(properties, duration) {\n    this._valuesEnd = Object.create(properties);\n    if (duration !== void 0) {\n      this._duration = duration;\n    }\n    return this;\n  };\n  Tween2.prototype.duration = function(d2) {\n    this._duration = d2;\n    return this;\n  };\n  Tween2.prototype.start = function(time) {\n    if (this._isPlaying) {\n      return this;\n    }\n    this._group && this._group.add(this);\n    this._repeat = this._initialRepeat;\n    if (this._reversed) {\n      this._reversed = false;\n      for (var property in this._valuesStartRepeat) {\n        this._swapEndStartRepeatValues(property);\n        this._valuesStart[property] = this._valuesStartRepeat[property];\n      }\n    }\n    this._isPlaying = true;\n    this._isPaused = false;\n    this._onStartCallbackFired = false;\n    this._isChainStopped = false;\n    this._startTime = time !== void 0 ? typeof time === \"string\" ? now$1$1() + parseFloat(time) : time : now$1$1();\n    this._startTime += this._delayTime;\n    this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);\n    return this;\n  };\n  Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {\n    for (var property in _valuesEnd) {\n      var startValue = _object[property];\n      var startValueIsArray = Array.isArray(startValue);\n      var propType = startValueIsArray ? \"array\" : typeof startValue;\n      var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);\n      if (propType === \"undefined\" || propType === \"function\") {\n        continue;\n      }\n      if (isInterpolationList) {\n        var endValues = _valuesEnd[property];\n        if (endValues.length === 0) {\n          continue;\n        }\n        endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));\n        _valuesEnd[property] = [startValue].concat(endValues);\n      }\n      if ((propType === \"object\" || startValueIsArray) && startValue && !isInterpolationList) {\n        _valuesStart[property] = startValueIsArray ? [] : {};\n        for (var prop in startValue) {\n          _valuesStart[property][prop] = startValue[prop];\n        }\n        _valuesStartRepeat[property] = startValueIsArray ? [] : {};\n        this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);\n      } else {\n        if (typeof _valuesStart[property] === \"undefined\") {\n          _valuesStart[property] = startValue;\n        }\n        if (!startValueIsArray) {\n          _valuesStart[property] *= 1;\n        }\n        if (isInterpolationList) {\n          _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();\n        } else {\n          _valuesStartRepeat[property] = _valuesStart[property] || 0;\n        }\n      }\n    }\n  };\n  Tween2.prototype.stop = function() {\n    if (!this._isChainStopped) {\n      this._isChainStopped = true;\n      this.stopChainedTweens();\n    }\n    if (!this._isPlaying) {\n      return this;\n    }\n    this._group && this._group.remove(this);\n    this._isPlaying = false;\n    this._isPaused = false;\n    if (this._onStopCallback) {\n      this._onStopCallback(this._object);\n    }\n    return this;\n  };\n  Tween2.prototype.end = function() {\n    this._goToEnd = true;\n    this.update(Infinity);\n    return this;\n  };\n  Tween2.prototype.pause = function(time) {\n    if (time === void 0) {\n      time = now$1$1();\n    }\n    if (this._isPaused || !this._isPlaying) {\n      return this;\n    }\n    this._isPaused = true;\n    this._pauseStart = time;\n    this._group && this._group.remove(this);\n    return this;\n  };\n  Tween2.prototype.resume = function(time) {\n    if (time === void 0) {\n      time = now$1$1();\n    }\n    if (!this._isPaused || !this._isPlaying) {\n      return this;\n    }\n    this._isPaused = false;\n    this._startTime += time - this._pauseStart;\n    this._pauseStart = 0;\n    this._group && this._group.add(this);\n    return this;\n  };\n  Tween2.prototype.stopChainedTweens = function() {\n    for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {\n      this._chainedTweens[i2].stop();\n    }\n    return this;\n  };\n  Tween2.prototype.group = function(group) {\n    this._group = group;\n    return this;\n  };\n  Tween2.prototype.delay = function(amount) {\n    this._delayTime = amount;\n    return this;\n  };\n  Tween2.prototype.repeat = function(times) {\n    this._initialRepeat = times;\n    this._repeat = times;\n    return this;\n  };\n  Tween2.prototype.repeatDelay = function(amount) {\n    this._repeatDelayTime = amount;\n    return this;\n  };\n  Tween2.prototype.yoyo = function(yoyo) {\n    this._yoyo = yoyo;\n    return this;\n  };\n  Tween2.prototype.easing = function(easingFunction) {\n    this._easingFunction = easingFunction;\n    return this;\n  };\n  Tween2.prototype.interpolation = function(interpolationFunction) {\n    this._interpolationFunction = interpolationFunction;\n    return this;\n  };\n  Tween2.prototype.chain = function() {\n    var tweens = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      tweens[_i] = arguments[_i];\n    }\n    this._chainedTweens = tweens;\n    return this;\n  };\n  Tween2.prototype.onStart = function(callback) {\n    this._onStartCallback = callback;\n    return this;\n  };\n  Tween2.prototype.onUpdate = function(callback) {\n    this._onUpdateCallback = callback;\n    return this;\n  };\n  Tween2.prototype.onRepeat = function(callback) {\n    this._onRepeatCallback = callback;\n    return this;\n  };\n  Tween2.prototype.onComplete = function(callback) {\n    this._onCompleteCallback = callback;\n    return this;\n  };\n  Tween2.prototype.onStop = function(callback) {\n    this._onStopCallback = callback;\n    return this;\n  };\n  Tween2.prototype.update = function(time, autoStart) {\n    if (time === void 0) {\n      time = now$1$1();\n    }\n    if (autoStart === void 0) {\n      autoStart = true;\n    }\n    if (this._isPaused)\n      return true;\n    var property;\n    var elapsed;\n    var endTime = this._startTime + this._duration;\n    if (!this._goToEnd && !this._isPlaying) {\n      if (time > endTime)\n        return false;\n      if (autoStart)\n        this.start(time);\n    }\n    this._goToEnd = false;\n    if (time < this._startTime) {\n      return true;\n    }\n    if (this._onStartCallbackFired === false) {\n      if (this._onStartCallback) {\n        this._onStartCallback(this._object);\n      }\n      this._onStartCallbackFired = true;\n    }\n    elapsed = (time - this._startTime) / this._duration;\n    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n    var value2 = this._easingFunction(elapsed);\n    this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value2);\n    if (this._onUpdateCallback) {\n      this._onUpdateCallback(this._object, elapsed);\n    }\n    if (elapsed === 1) {\n      if (this._repeat > 0) {\n        if (isFinite(this._repeat)) {\n          this._repeat--;\n        }\n        for (property in this._valuesStartRepeat) {\n          if (!this._yoyo && typeof this._valuesEnd[property] === \"string\") {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n          }\n          if (this._yoyo) {\n            this._swapEndStartRepeatValues(property);\n          }\n          this._valuesStart[property] = this._valuesStartRepeat[property];\n        }\n        if (this._yoyo) {\n          this._reversed = !this._reversed;\n        }\n        if (this._repeatDelayTime !== void 0) {\n          this._startTime = time + this._repeatDelayTime;\n        } else {\n          this._startTime = time + this._delayTime;\n        }\n        if (this._onRepeatCallback) {\n          this._onRepeatCallback(this._object);\n        }\n        return true;\n      } else {\n        if (this._onCompleteCallback) {\n          this._onCompleteCallback(this._object);\n        }\n        for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {\n          this._chainedTweens[i2].start(this._startTime + this._duration);\n        }\n        this._isPlaying = false;\n        return false;\n      }\n    }\n    return true;\n  };\n  Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value2) {\n    for (var property in _valuesEnd) {\n      if (_valuesStart[property] === void 0) {\n        continue;\n      }\n      var start2 = _valuesStart[property] || 0;\n      var end2 = _valuesEnd[property];\n      var startIsArray = Array.isArray(_object[property]);\n      var endIsArray = Array.isArray(end2);\n      var isInterpolationList = !startIsArray && endIsArray;\n      if (isInterpolationList) {\n        _object[property] = this._interpolationFunction(end2, value2);\n      } else if (typeof end2 === \"object\" && end2) {\n        this._updateProperties(_object[property], start2, end2, value2);\n      } else {\n        end2 = this._handleRelativeValue(start2, end2);\n        if (typeof end2 === \"number\") {\n          _object[property] = start2 + (end2 - start2) * value2;\n        }\n      }\n    }\n  };\n  Tween2.prototype._handleRelativeValue = function(start2, end2) {\n    if (typeof end2 !== \"string\") {\n      return end2;\n    }\n    if (end2.charAt(0) === \"+\" || end2.charAt(0) === \"-\") {\n      return start2 + parseFloat(end2);\n    } else {\n      return parseFloat(end2);\n    }\n  };\n  Tween2.prototype._swapEndStartRepeatValues = function(property) {\n    var tmp = this._valuesStartRepeat[property];\n    var endValue = this._valuesEnd[property];\n    if (typeof endValue === \"string\") {\n      this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);\n    } else {\n      this._valuesStartRepeat[property] = this._valuesEnd[property];\n    }\n    this._valuesEnd[property] = tmp;\n  };\n  return Tween2;\n}();\nSequence.nextId;\nvar TWEEN = mainGroup;\nTWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nTWEEN.add.bind(TWEEN);\nTWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN);\nconst _CmnTween = class {\n  static ease(nm) {\n    if (!nm)\n      return (k) => Easing.Linear.None(k);\n    if (!(nm in __privateGet2(_CmnTween, _hEase)))\n      throw \"\\u7570\\u5E38\\u306Aease\\u6307\\u5B9A\\u3067\\u3059\";\n    return __privateGet2(_CmnTween, _hEase)[nm];\n  }\n};\nlet CmnTween = _CmnTween;\n_hEase = new WeakMap();\n__privateAdd2(CmnTween, _hEase, {\n  \"Back.In\": (k) => Easing.Back.In(k),\n  \"Back.InOut\": (k) => Easing.Back.InOut(k),\n  \"Back.Out\": (k) => Easing.Back.Out(k),\n  \"Bounce.In\": (k) => Easing.Bounce.In(k),\n  \"Bounce.InOut\": (k) => Easing.Bounce.InOut(k),\n  \"Bounce.Out\": (k) => Easing.Bounce.Out(k),\n  \"Circular.In\": (k) => Easing.Circular.In(k),\n  \"Circular.InOut\": (k) => Easing.Circular.InOut(k),\n  \"Circular.Out\": (k) => Easing.Circular.Out(k),\n  \"Cubic.In\": (k) => Easing.Cubic.In(k),\n  \"Cubic.InOut\": (k) => Easing.Cubic.InOut(k),\n  \"Cubic.Out\": (k) => Easing.Cubic.Out(k),\n  \"Elastic.In\": (k) => Easing.Elastic.In(k),\n  \"Elastic.InOut\": (k) => Easing.Elastic.InOut(k),\n  \"Elastic.Out\": (k) => Easing.Elastic.Out(k),\n  \"Exponential.In\": (k) => Easing.Exponential.In(k),\n  \"Exponential.InOut\": (k) => Easing.Exponential.InOut(k),\n  \"Exponential.Out\": (k) => Easing.Exponential.Out(k),\n  \"Linear.None\": (k) => Easing.Linear.None(k),\n  \"Quadratic.In\": (k) => Easing.Quadratic.In(k),\n  \"Quadratic.InOut\": (k) => Easing.Quadratic.InOut(k),\n  \"Quadratic.Out\": (k) => Easing.Quadratic.Out(k),\n  \"Quartic.In\": (k) => Easing.Quartic.In(k),\n  \"Quartic.InOut\": (k) => Easing.Quartic.InOut(k),\n  \"Quartic.Out\": (k) => Easing.Quartic.Out(k),\n  \"Quintic.In\": (k) => Easing.Quintic.In(k),\n  \"Quintic.InOut\": (k) => Easing.Quintic.InOut(k),\n  \"Quintic.Out\": (k) => Easing.Quintic.Out(k),\n  \"Sinusoidal.In\": (k) => Easing.Sinusoidal.In(k),\n  \"Sinusoidal.InOut\": (k) => Easing.Sinusoidal.InOut(k),\n  \"Sinusoidal.Out\": (k) => Easing.Sinusoidal.Out(k)\n});\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function(navigator2) {\n  return typeof navigator2 !== \"undefined\" && navigator2.platform === \"MacIntel\" && typeof navigator2.maxTouchPoints === \"number\" && navigator2.maxTouchPoints > 1 && typeof MSStream === \"undefined\";\n};\nfunction createMatch(userAgent) {\n  return function(regex) {\n    return regex.test(userAgent);\n  };\n}\nfunction isMobile$1(param) {\n  var nav = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  if (!param && typeof navigator !== \"undefined\") {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0\n    };\n  } else if (typeof param === \"string\") {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0\n    };\n  }\n  var userAgent = nav.userAgent;\n  var tmp = userAgent.split(\"[FBAN\");\n  if (typeof tmp[1] !== \"undefined\") {\n    userAgent = tmp[0];\n  }\n  tmp = userAgent.split(\"Twitter\");\n  if (typeof tmp[1] !== \"undefined\") {\n    userAgent = tmp[0];\n  }\n  var match = createMatch(userAgent);\n  var result = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),\n      universal: match(appleUniversal),\n      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet)\n    },\n    android: {\n      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),\n      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),\n      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet)\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)\n    },\n    any: false,\n    phone: false,\n    tablet: false\n  };\n  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;\n  result.phone = result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;\n  return result;\n}\n/*!\n * @pixi/settings - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar isMobile = isMobile$1(globalThis.navigator);\nfunction maxRecommendedTextures(max2) {\n  var allowMax = true;\n  if (isMobile.tablet || isMobile.phone) {\n    if (isMobile.apple.device) {\n      var match = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (match) {\n        var majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 11) {\n          allowMax = false;\n        }\n      }\n    }\n    if (isMobile.android.device) {\n      var match = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (match) {\n        var majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 7) {\n          allowMax = false;\n        }\n      }\n    }\n  }\n  return allowMax ? max2 : 4;\n}\nfunction canUploadSameBuffer() {\n  return !isMobile.apple.device;\n}\n/*!\n * @pixi/constants - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$4;\n(function(ENV2) {\n  ENV2[ENV2[\"WEBGL_LEGACY\"] = 0] = \"WEBGL_LEGACY\";\n  ENV2[ENV2[\"WEBGL\"] = 1] = \"WEBGL\";\n  ENV2[ENV2[\"WEBGL2\"] = 2] = \"WEBGL2\";\n})(ENV$4 || (ENV$4 = {}));\nvar RENDERER_TYPE$4;\n(function(RENDERER_TYPE2) {\n  RENDERER_TYPE2[RENDERER_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"CANVAS\"] = 2] = \"CANVAS\";\n})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));\nvar BUFFER_BITS$4;\n(function(BUFFER_BITS2) {\n  BUFFER_BITS2[BUFFER_BITS2[\"COLOR\"] = 16384] = \"COLOR\";\n  BUFFER_BITS2[BUFFER_BITS2[\"DEPTH\"] = 256] = \"DEPTH\";\n  BUFFER_BITS2[BUFFER_BITS2[\"STENCIL\"] = 1024] = \"STENCIL\";\n})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));\nvar BLEND_MODES$4;\n(function(BLEND_MODES2) {\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL\"] = 0] = \"NORMAL\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD\"] = 1] = \"ADD\";\n  BLEND_MODES2[BLEND_MODES2[\"MULTIPLY\"] = 2] = \"MULTIPLY\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN\"] = 3] = \"SCREEN\";\n  BLEND_MODES2[BLEND_MODES2[\"OVERLAY\"] = 4] = \"OVERLAY\";\n  BLEND_MODES2[BLEND_MODES2[\"DARKEN\"] = 5] = \"DARKEN\";\n  BLEND_MODES2[BLEND_MODES2[\"LIGHTEN\"] = 6] = \"LIGHTEN\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_DODGE\"] = 7] = \"COLOR_DODGE\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_BURN\"] = 8] = \"COLOR_BURN\";\n  BLEND_MODES2[BLEND_MODES2[\"HARD_LIGHT\"] = 9] = \"HARD_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"SOFT_LIGHT\"] = 10] = \"SOFT_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"DIFFERENCE\"] = 11] = \"DIFFERENCE\";\n  BLEND_MODES2[BLEND_MODES2[\"EXCLUSION\"] = 12] = \"EXCLUSION\";\n  BLEND_MODES2[BLEND_MODES2[\"HUE\"] = 13] = \"HUE\";\n  BLEND_MODES2[BLEND_MODES2[\"SATURATION\"] = 14] = \"SATURATION\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR\"] = 15] = \"COLOR\";\n  BLEND_MODES2[BLEND_MODES2[\"LUMINOSITY\"] = 16] = \"LUMINOSITY\";\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL_NPM\"] = 17] = \"NORMAL_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD_NPM\"] = 18] = \"ADD_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN_NPM\"] = 19] = \"SCREEN_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"NONE\"] = 20] = \"NONE\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OVER\"] = 0] = \"SRC_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_IN\"] = 21] = \"SRC_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OUT\"] = 22] = \"SRC_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_ATOP\"] = 23] = \"SRC_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OVER\"] = 24] = \"DST_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_IN\"] = 25] = \"DST_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OUT\"] = 26] = \"DST_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_ATOP\"] = 27] = \"DST_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"ERASE\"] = 26] = \"ERASE\";\n  BLEND_MODES2[BLEND_MODES2[\"SUBTRACT\"] = 28] = \"SUBTRACT\";\n  BLEND_MODES2[BLEND_MODES2[\"XOR\"] = 29] = \"XOR\";\n})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));\nvar DRAW_MODES$4;\n(function(DRAW_MODES2) {\n  DRAW_MODES2[DRAW_MODES2[\"POINTS\"] = 0] = \"POINTS\";\n  DRAW_MODES2[DRAW_MODES2[\"LINES\"] = 1] = \"LINES\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));\nvar FORMATS$4;\n(function(FORMATS2) {\n  FORMATS2[FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  FORMATS2[FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  FORMATS2[FORMATS2[\"RG\"] = 33319] = \"RG\";\n  FORMATS2[FORMATS2[\"RED\"] = 6403] = \"RED\";\n  FORMATS2[FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  FORMATS2[FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  FORMATS2[FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  FORMATS2[FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  FORMATS2[FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  FORMATS2[FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  FORMATS2[FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  FORMATS2[FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  FORMATS2[FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$4 || (FORMATS$4 = {}));\nvar TARGETS$4;\n(function(TARGETS2) {\n  TARGETS2[TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  TARGETS2[TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$4 || (TARGETS$4 = {}));\nvar TYPES$4;\n(function(TYPES2) {\n  TYPES2[TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  TYPES2[TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  TYPES2[TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  TYPES2[TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  TYPES2[TYPES2[\"INT\"] = 5124] = \"INT\";\n  TYPES2[TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  TYPES2[TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  TYPES2[TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n})(TYPES$4 || (TYPES$4 = {}));\nvar SAMPLER_TYPES$4;\n(function(SAMPLER_TYPES2) {\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"FLOAT\"] = 0] = \"FLOAT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"INT\"] = 1] = \"INT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"UINT\"] = 2] = \"UINT\";\n})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));\nvar SCALE_MODES$4;\n(function(SCALE_MODES2) {\n  SCALE_MODES2[SCALE_MODES2[\"NEAREST\"] = 0] = \"NEAREST\";\n  SCALE_MODES2[SCALE_MODES2[\"LINEAR\"] = 1] = \"LINEAR\";\n})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));\nvar WRAP_MODES$4;\n(function(WRAP_MODES2) {\n  WRAP_MODES2[WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  WRAP_MODES2[WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  WRAP_MODES2[WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));\nvar MIPMAP_MODES$4;\n(function(MIPMAP_MODES2) {\n  MIPMAP_MODES2[MIPMAP_MODES2[\"OFF\"] = 0] = \"OFF\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"POW2\"] = 1] = \"POW2\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON\"] = 2] = \"ON\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON_MANUAL\"] = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));\nvar ALPHA_MODES$4;\n(function(ALPHA_MODES2) {\n  ALPHA_MODES2[ALPHA_MODES2[\"NPM\"] = 0] = \"NPM\";\n  ALPHA_MODES2[ALPHA_MODES2[\"UNPACK\"] = 1] = \"UNPACK\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PMA\"] = 2] = \"PMA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"NO_PREMULTIPLIED_ALPHA\"] = 0] = \"NO_PREMULTIPLIED_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ON_UPLOAD\"] = 1] = \"PREMULTIPLY_ON_UPLOAD\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ALPHA\"] = 2] = \"PREMULTIPLY_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLIED_ALPHA\"] = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));\nvar CLEAR_MODES$4;\n(function(CLEAR_MODES2) {\n  CLEAR_MODES2[CLEAR_MODES2[\"NO\"] = 0] = \"NO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"YES\"] = 1] = \"YES\";\n  CLEAR_MODES2[CLEAR_MODES2[\"AUTO\"] = 2] = \"AUTO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLEND\"] = 0] = \"BLEND\";\n  CLEAR_MODES2[CLEAR_MODES2[\"CLEAR\"] = 1] = \"CLEAR\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLIT\"] = 2] = \"BLIT\";\n})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));\nvar GC_MODES$4;\n(function(GC_MODES2) {\n  GC_MODES2[GC_MODES2[\"AUTO\"] = 0] = \"AUTO\";\n  GC_MODES2[GC_MODES2[\"MANUAL\"] = 1] = \"MANUAL\";\n})(GC_MODES$4 || (GC_MODES$4 = {}));\nvar PRECISION$4;\n(function(PRECISION2) {\n  PRECISION2[\"LOW\"] = \"lowp\";\n  PRECISION2[\"MEDIUM\"] = \"mediump\";\n  PRECISION2[\"HIGH\"] = \"highp\";\n})(PRECISION$4 || (PRECISION$4 = {}));\nvar MASK_TYPES$4;\n(function(MASK_TYPES2) {\n  MASK_TYPES2[MASK_TYPES2[\"NONE\"] = 0] = \"NONE\";\n  MASK_TYPES2[MASK_TYPES2[\"SCISSOR\"] = 1] = \"SCISSOR\";\n  MASK_TYPES2[MASK_TYPES2[\"STENCIL\"] = 2] = \"STENCIL\";\n  MASK_TYPES2[MASK_TYPES2[\"SPRITE\"] = 3] = \"SPRITE\";\n})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));\nvar MSAA_QUALITY$4;\n(function(MSAA_QUALITY2) {\n  MSAA_QUALITY2[MSAA_QUALITY2[\"NONE\"] = 0] = \"NONE\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"LOW\"] = 2] = \"LOW\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"MEDIUM\"] = 4] = \"MEDIUM\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"HIGH\"] = 8] = \"HIGH\";\n})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));\nvar BUFFER_TYPE$4;\n(function(BUFFER_TYPE2) {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));\nvar settings = {\n  MIPMAP_TEXTURES: MIPMAP_MODES$4.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY$4.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: false,\n    autoDensity: false,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: true,\n    clearBeforeRender: true,\n    preserveDrawingBuffer: false,\n    width: 800,\n    height: 600,\n    legacy: false\n  },\n  GC_MODE: GC_MODES$4.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES$4.CLAMP,\n  SCALE_MODE: SCALE_MODES$4.LINEAR,\n  PRECISION_VERTEX: PRECISION$4.HIGH,\n  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$4.HIGH : PRECISION$4.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),\n  CREATE_IMAGE_BITMAP: false,\n  ROUND_PIXELS: false\n};\n/*!\n * @pixi/constants - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$3;\n(function(ENV2) {\n  ENV2[ENV2[\"WEBGL_LEGACY\"] = 0] = \"WEBGL_LEGACY\";\n  ENV2[ENV2[\"WEBGL\"] = 1] = \"WEBGL\";\n  ENV2[ENV2[\"WEBGL2\"] = 2] = \"WEBGL2\";\n})(ENV$3 || (ENV$3 = {}));\nvar RENDERER_TYPE$3;\n(function(RENDERER_TYPE2) {\n  RENDERER_TYPE2[RENDERER_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"CANVAS\"] = 2] = \"CANVAS\";\n})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));\nvar BUFFER_BITS$3;\n(function(BUFFER_BITS2) {\n  BUFFER_BITS2[BUFFER_BITS2[\"COLOR\"] = 16384] = \"COLOR\";\n  BUFFER_BITS2[BUFFER_BITS2[\"DEPTH\"] = 256] = \"DEPTH\";\n  BUFFER_BITS2[BUFFER_BITS2[\"STENCIL\"] = 1024] = \"STENCIL\";\n})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));\nvar BLEND_MODES$3;\n(function(BLEND_MODES2) {\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL\"] = 0] = \"NORMAL\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD\"] = 1] = \"ADD\";\n  BLEND_MODES2[BLEND_MODES2[\"MULTIPLY\"] = 2] = \"MULTIPLY\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN\"] = 3] = \"SCREEN\";\n  BLEND_MODES2[BLEND_MODES2[\"OVERLAY\"] = 4] = \"OVERLAY\";\n  BLEND_MODES2[BLEND_MODES2[\"DARKEN\"] = 5] = \"DARKEN\";\n  BLEND_MODES2[BLEND_MODES2[\"LIGHTEN\"] = 6] = \"LIGHTEN\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_DODGE\"] = 7] = \"COLOR_DODGE\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_BURN\"] = 8] = \"COLOR_BURN\";\n  BLEND_MODES2[BLEND_MODES2[\"HARD_LIGHT\"] = 9] = \"HARD_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"SOFT_LIGHT\"] = 10] = \"SOFT_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"DIFFERENCE\"] = 11] = \"DIFFERENCE\";\n  BLEND_MODES2[BLEND_MODES2[\"EXCLUSION\"] = 12] = \"EXCLUSION\";\n  BLEND_MODES2[BLEND_MODES2[\"HUE\"] = 13] = \"HUE\";\n  BLEND_MODES2[BLEND_MODES2[\"SATURATION\"] = 14] = \"SATURATION\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR\"] = 15] = \"COLOR\";\n  BLEND_MODES2[BLEND_MODES2[\"LUMINOSITY\"] = 16] = \"LUMINOSITY\";\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL_NPM\"] = 17] = \"NORMAL_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD_NPM\"] = 18] = \"ADD_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN_NPM\"] = 19] = \"SCREEN_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"NONE\"] = 20] = \"NONE\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OVER\"] = 0] = \"SRC_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_IN\"] = 21] = \"SRC_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OUT\"] = 22] = \"SRC_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_ATOP\"] = 23] = \"SRC_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OVER\"] = 24] = \"DST_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_IN\"] = 25] = \"DST_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OUT\"] = 26] = \"DST_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_ATOP\"] = 27] = \"DST_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"ERASE\"] = 26] = \"ERASE\";\n  BLEND_MODES2[BLEND_MODES2[\"SUBTRACT\"] = 28] = \"SUBTRACT\";\n  BLEND_MODES2[BLEND_MODES2[\"XOR\"] = 29] = \"XOR\";\n})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));\nvar DRAW_MODES$3;\n(function(DRAW_MODES2) {\n  DRAW_MODES2[DRAW_MODES2[\"POINTS\"] = 0] = \"POINTS\";\n  DRAW_MODES2[DRAW_MODES2[\"LINES\"] = 1] = \"LINES\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));\nvar FORMATS$3;\n(function(FORMATS2) {\n  FORMATS2[FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  FORMATS2[FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  FORMATS2[FORMATS2[\"RG\"] = 33319] = \"RG\";\n  FORMATS2[FORMATS2[\"RED\"] = 6403] = \"RED\";\n  FORMATS2[FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  FORMATS2[FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  FORMATS2[FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  FORMATS2[FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  FORMATS2[FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  FORMATS2[FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  FORMATS2[FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  FORMATS2[FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  FORMATS2[FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$3 || (FORMATS$3 = {}));\nvar TARGETS$3;\n(function(TARGETS2) {\n  TARGETS2[TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  TARGETS2[TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$3 || (TARGETS$3 = {}));\nvar TYPES$3;\n(function(TYPES2) {\n  TYPES2[TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  TYPES2[TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  TYPES2[TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  TYPES2[TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  TYPES2[TYPES2[\"INT\"] = 5124] = \"INT\";\n  TYPES2[TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  TYPES2[TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  TYPES2[TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n})(TYPES$3 || (TYPES$3 = {}));\nvar SAMPLER_TYPES$3;\n(function(SAMPLER_TYPES2) {\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"FLOAT\"] = 0] = \"FLOAT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"INT\"] = 1] = \"INT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"UINT\"] = 2] = \"UINT\";\n})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));\nvar SCALE_MODES$3;\n(function(SCALE_MODES2) {\n  SCALE_MODES2[SCALE_MODES2[\"NEAREST\"] = 0] = \"NEAREST\";\n  SCALE_MODES2[SCALE_MODES2[\"LINEAR\"] = 1] = \"LINEAR\";\n})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));\nvar WRAP_MODES$3;\n(function(WRAP_MODES2) {\n  WRAP_MODES2[WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  WRAP_MODES2[WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  WRAP_MODES2[WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));\nvar MIPMAP_MODES$3;\n(function(MIPMAP_MODES2) {\n  MIPMAP_MODES2[MIPMAP_MODES2[\"OFF\"] = 0] = \"OFF\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"POW2\"] = 1] = \"POW2\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON\"] = 2] = \"ON\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON_MANUAL\"] = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));\nvar ALPHA_MODES$3;\n(function(ALPHA_MODES2) {\n  ALPHA_MODES2[ALPHA_MODES2[\"NPM\"] = 0] = \"NPM\";\n  ALPHA_MODES2[ALPHA_MODES2[\"UNPACK\"] = 1] = \"UNPACK\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PMA\"] = 2] = \"PMA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"NO_PREMULTIPLIED_ALPHA\"] = 0] = \"NO_PREMULTIPLIED_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ON_UPLOAD\"] = 1] = \"PREMULTIPLY_ON_UPLOAD\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ALPHA\"] = 2] = \"PREMULTIPLY_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLIED_ALPHA\"] = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));\nvar CLEAR_MODES$3;\n(function(CLEAR_MODES2) {\n  CLEAR_MODES2[CLEAR_MODES2[\"NO\"] = 0] = \"NO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"YES\"] = 1] = \"YES\";\n  CLEAR_MODES2[CLEAR_MODES2[\"AUTO\"] = 2] = \"AUTO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLEND\"] = 0] = \"BLEND\";\n  CLEAR_MODES2[CLEAR_MODES2[\"CLEAR\"] = 1] = \"CLEAR\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLIT\"] = 2] = \"BLIT\";\n})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));\nvar GC_MODES$3;\n(function(GC_MODES2) {\n  GC_MODES2[GC_MODES2[\"AUTO\"] = 0] = \"AUTO\";\n  GC_MODES2[GC_MODES2[\"MANUAL\"] = 1] = \"MANUAL\";\n})(GC_MODES$3 || (GC_MODES$3 = {}));\nvar PRECISION$3;\n(function(PRECISION2) {\n  PRECISION2[\"LOW\"] = \"lowp\";\n  PRECISION2[\"MEDIUM\"] = \"mediump\";\n  PRECISION2[\"HIGH\"] = \"highp\";\n})(PRECISION$3 || (PRECISION$3 = {}));\nvar MASK_TYPES$3;\n(function(MASK_TYPES2) {\n  MASK_TYPES2[MASK_TYPES2[\"NONE\"] = 0] = \"NONE\";\n  MASK_TYPES2[MASK_TYPES2[\"SCISSOR\"] = 1] = \"SCISSOR\";\n  MASK_TYPES2[MASK_TYPES2[\"STENCIL\"] = 2] = \"STENCIL\";\n  MASK_TYPES2[MASK_TYPES2[\"SPRITE\"] = 3] = \"SPRITE\";\n})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));\nvar MSAA_QUALITY$3;\n(function(MSAA_QUALITY2) {\n  MSAA_QUALITY2[MSAA_QUALITY2[\"NONE\"] = 0] = \"NONE\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"LOW\"] = 2] = \"LOW\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"MEDIUM\"] = 4] = \"MEDIUM\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"HIGH\"] = 8] = \"HIGH\";\n})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));\nvar BUFFER_TYPE$3;\n(function(BUFFER_TYPE2) {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));\nvar eventemitter3 = { exports: {} };\n(function(module) {\n  var has = Object.prototype.hasOwnProperty, prefix2 = \"~\";\n  function Events() {\n  }\n  if (Object.create) {\n    Events.prototype = /* @__PURE__ */ Object.create(null);\n    if (!new Events().__proto__)\n      prefix2 = false;\n  }\n  function EE(fn2, context2, once) {\n    this.fn = fn2;\n    this.context = context2;\n    this.once = once || false;\n  }\n  function addListener(emitter, event, fn2, context2, once) {\n    if (typeof fn2 !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn2, context2 || emitter, once), evt = prefix2 ? prefix2 + event : event;\n    if (!emitter._events[evt])\n      emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn)\n      emitter._events[evt].push(listener);\n    else\n      emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0)\n      emitter._events = new Events();\n    else\n      delete emitter._events[evt];\n  }\n  function EventEmitter2() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n  EventEmitter2.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0)\n      return names;\n    for (name in events = this._events) {\n      if (has.call(events, name))\n        names.push(prefix2 ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n  };\n  EventEmitter2.prototype.listeners = function listeners(event) {\n    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];\n    if (!handlers)\n      return [];\n    if (handlers.fn)\n      return [handlers.fn];\n    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {\n      ee[i2] = handlers[i2].fn;\n    }\n    return ee;\n  };\n  EventEmitter2.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];\n    if (!listeners)\n      return 0;\n    if (listeners.fn)\n      return 1;\n    return listeners.length;\n  };\n  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix2 ? prefix2 + event : event;\n    if (!this._events[evt])\n      return false;\n    var listeners = this._events[evt], len = arguments.length, args, i2;\n    if (listeners.fn) {\n      if (listeners.once)\n        this.removeListener(event, listeners.fn, void 0, true);\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {\n        args[i2 - 1] = arguments[i2];\n      }\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length2 = listeners.length, j2;\n      for (i2 = 0; i2 < length2; i2++) {\n        if (listeners[i2].once)\n          this.removeListener(event, listeners[i2].fn, void 0, true);\n        switch (len) {\n          case 1:\n            listeners[i2].fn.call(listeners[i2].context);\n            break;\n          case 2:\n            listeners[i2].fn.call(listeners[i2].context, a1);\n            break;\n          case 3:\n            listeners[i2].fn.call(listeners[i2].context, a1, a2);\n            break;\n          case 4:\n            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);\n            break;\n          default:\n            if (!args)\n              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {\n                args[j2 - 1] = arguments[j2];\n              }\n            listeners[i2].fn.apply(listeners[i2].context, args);\n        }\n      }\n    }\n    return true;\n  };\n  EventEmitter2.prototype.on = function on2(event, fn2, context2) {\n    return addListener(this, event, fn2, context2, false);\n  };\n  EventEmitter2.prototype.once = function once(event, fn2, context2) {\n    return addListener(this, event, fn2, context2, true);\n  };\n  EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context2, once) {\n    var evt = prefix2 ? prefix2 + event : event;\n    if (!this._events[evt])\n      return this;\n    if (!fn2) {\n      clearEvent(this, evt);\n      return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n      if (listeners.fn === fn2 && (!once || listeners.once) && (!context2 || listeners.context === context2)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {\n        if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {\n          events.push(listeners[i2]);\n        }\n      }\n      if (events.length)\n        this._events[evt] = events.length === 1 ? events[0] : events;\n      else\n        clearEvent(this, evt);\n    }\n    return this;\n  };\n  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n      evt = prefix2 ? prefix2 + event : event;\n      if (this._events[evt])\n        clearEvent(this, evt);\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n    return this;\n  };\n  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;\n  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;\n  EventEmitter2.prefixed = prefix2;\n  EventEmitter2.EventEmitter = EventEmitter2;\n  {\n    module.exports = EventEmitter2;\n  }\n})(eventemitter3);\nvar EventEmitter$4 = eventemitter3.exports;\nvar earcut$2 = { exports: {} };\nearcut$2.exports = earcut;\nearcut$2.exports.default = earcut;\nfunction earcut(data, holeIndices, dim) {\n  dim = dim || 2;\n  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev)\n    return triangles;\n  var minX, minY, maxX, maxY, x2, y2, invSize;\n  if (hasHoles)\n    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n  if (data.length > 80 * dim) {\n    minX = maxX = data[0];\n    minY = maxY = data[1];\n    for (var i2 = dim; i2 < outerLen; i2 += dim) {\n      x2 = data[i2];\n      y2 = data[i2 + 1];\n      if (x2 < minX)\n        minX = x2;\n      if (y2 < minY)\n        minY = y2;\n      if (x2 > maxX)\n        maxX = x2;\n      if (y2 > maxY)\n        maxY = y2;\n    }\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n  return triangles;\n}\nfunction linkedList(data, start2, end2, dim, clockwise) {\n  var i2, last;\n  if (clockwise === signedArea(data, start2, end2, dim) > 0) {\n    for (i2 = start2; i2 < end2; i2 += dim)\n      last = insertNode(i2, data[i2], data[i2 + 1], last);\n  } else {\n    for (i2 = end2 - dim; i2 >= start2; i2 -= dim)\n      last = insertNode(i2, data[i2], data[i2 + 1], last);\n  }\n  if (last && equals$1(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\nfunction filterPoints(start2, end2) {\n  if (!start2)\n    return start2;\n  if (!end2)\n    end2 = start2;\n  var p2 = start2, again;\n  do {\n    again = false;\n    if (!p2.steiner && (equals$1(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {\n      removeNode(p2);\n      p2 = end2 = p2.prev;\n      if (p2 === p2.next)\n        break;\n      again = true;\n    } else {\n      p2 = p2.next;\n    }\n  } while (again || p2 !== end2);\n  return end2;\n}\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear)\n    return;\n  if (!pass && invSize)\n    indexCurve(ear, minX, minY, invSize);\n  var stop = ear, prev2, next;\n  while (ear.prev !== ear.next) {\n    prev2 = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev2.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\nfunction isEar(ear) {\n  var a2 = ear.prev, b2 = ear, c2 = ear.next;\n  if (area(a2, b2, c2) >= 0)\n    return false;\n  var p2 = ear.next.next;\n  while (p2 !== ear.prev) {\n    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)\n      return false;\n    p2 = p2.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  var a2 = ear.prev, b2 = ear, c2 = ear.next;\n  if (area(a2, b2, c2) >= 0)\n    return false;\n  var minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;\n  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  var p2 = ear.prevZ, n = ear.nextZ;\n  while (p2 && p2.z >= minZ && n && n.z <= maxZ) {\n    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)\n      return false;\n    p2 = p2.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)\n      return false;\n    n = n.nextZ;\n  }\n  while (p2 && p2.z >= minZ) {\n    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)\n      return false;\n    p2 = p2.prevZ;\n  }\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)\n      return false;\n    n = n.nextZ;\n  }\n  return true;\n}\nfunction cureLocalIntersections(start2, triangles, dim) {\n  var p2 = start2;\n  do {\n    var a2 = p2.prev, b2 = p2.next.next;\n    if (!equals$1(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {\n      triangles.push(a2.i / dim);\n      triangles.push(p2.i / dim);\n      triangles.push(b2.i / dim);\n      removeNode(p2);\n      removeNode(p2.next);\n      p2 = start2 = b2;\n    }\n    p2 = p2.next;\n  } while (p2 !== start2);\n  return filterPoints(p2);\n}\nfunction splitEarcut(start2, triangles, dim, minX, minY, invSize) {\n  var a2 = start2;\n  do {\n    var b2 = a2.next.next;\n    while (b2 !== a2.prev) {\n      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {\n        var c2 = splitPolygon(a2, b2);\n        a2 = filterPoints(a2, a2.next);\n        c2 = filterPoints(c2, c2.next);\n        earcutLinked(a2, triangles, dim, minX, minY, invSize);\n        earcutLinked(c2, triangles, dim, minX, minY, invSize);\n        return;\n      }\n      b2 = b2.next;\n    }\n    a2 = a2.next;\n  } while (a2 !== start2);\n}\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  var queue = [], i2, len, start2, end2, list;\n  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {\n    start2 = holeIndices[i2] * dim;\n    end2 = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;\n    list = linkedList(data, start2, end2, dim, false);\n    if (list === list.next)\n      list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n  for (i2 = 0; i2 < queue.length; i2++) {\n    outerNode = eliminateHole(queue[i2], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n  return outerNode;\n}\nfunction compareX(a2, b2) {\n  return a2.x - b2.x;\n}\nfunction eliminateHole(hole, outerNode) {\n  var bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  var bridgeReverse = splitPolygon(bridge, hole);\n  var filteredBridge = filterPoints(bridge, bridge.next);\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return outerNode === bridge ? filteredBridge : outerNode;\n}\nfunction findHoleBridge(hole, outerNode) {\n  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;\n  do {\n    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {\n      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);\n      if (x2 <= hx && x2 > qx) {\n        qx = x2;\n        if (x2 === hx) {\n          if (hy === p2.y)\n            return p2;\n          if (hy === p2.next.y)\n            return p2.next;\n        }\n        m2 = p2.x < p2.next.x ? p2 : p2.next;\n      }\n    }\n    p2 = p2.next;\n  } while (p2 !== outerNode);\n  if (!m2)\n    return null;\n  if (hx === qx)\n    return m2;\n  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;\n  p2 = m2;\n  do {\n    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {\n      tan2 = Math.abs(hy - p2.y) / (hx - p2.x);\n      if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {\n        m2 = p2;\n        tanMin = tan2;\n      }\n    }\n    p2 = p2.next;\n  } while (p2 !== stop);\n  return m2;\n}\nfunction sectorContainsSector(m2, p2) {\n  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;\n}\nfunction indexCurve(start2, minX, minY, invSize) {\n  var p2 = start2;\n  do {\n    if (p2.z === null)\n      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);\n    p2.prevZ = p2.prev;\n    p2.nextZ = p2.next;\n    p2 = p2.next;\n  } while (p2 !== start2);\n  p2.prevZ.nextZ = null;\n  p2.prevZ = null;\n  sortLinked(p2);\n}\nfunction sortLinked(list) {\n  var i2, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n  do {\n    p2 = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p2) {\n      numMerges++;\n      q = p2;\n      pSize = 0;\n      for (i2 = 0; i2 < inSize; i2++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q)\n          break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {\n          e = p2;\n          p2 = p2.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail)\n          tail.nextZ = e;\n        else\n          list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p2 = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\nfunction zOrder(x2, y2, minX, minY, invSize) {\n  x2 = 32767 * (x2 - minX) * invSize;\n  y2 = 32767 * (y2 - minY) * invSize;\n  x2 = (x2 | x2 << 8) & 16711935;\n  x2 = (x2 | x2 << 4) & 252645135;\n  x2 = (x2 | x2 << 2) & 858993459;\n  x2 = (x2 | x2 << 1) & 1431655765;\n  y2 = (y2 | y2 << 8) & 16711935;\n  y2 = (y2 | y2 << 4) & 252645135;\n  y2 = (y2 | y2 << 2) & 858993459;\n  y2 = (y2 | y2 << 1) & 1431655765;\n  return x2 | y2 << 1;\n}\nfunction getLeftmost(start2) {\n  var p2 = start2, leftmost = start2;\n  do {\n    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)\n      leftmost = p2;\n    p2 = p2.next;\n  } while (p2 !== start2);\n  return leftmost;\n}\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\nfunction isValidDiagonal(a2, b2) {\n  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals$1(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);\n}\nfunction area(p2, q, r2) {\n  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);\n}\nfunction equals$1(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\nfunction intersects(p1, q1, p2, q2) {\n  var o1 = sign$1(area(p1, q1, p2));\n  var o2 = sign$1(area(p1, q1, q2));\n  var o3 = sign$1(area(p2, q2, p1));\n  var o4 = sign$1(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4)\n    return true;\n  if (o1 === 0 && onSegment(p1, p2, q1))\n    return true;\n  if (o2 === 0 && onSegment(p1, q2, q1))\n    return true;\n  if (o3 === 0 && onSegment(p2, p1, q2))\n    return true;\n  if (o4 === 0 && onSegment(p2, q1, q2))\n    return true;\n  return false;\n}\nfunction onSegment(p2, q, r2) {\n  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);\n}\nfunction sign$1(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(a2, b2) {\n  var p2 = a2;\n  do {\n    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))\n      return true;\n    p2 = p2.next;\n  } while (p2 !== a2);\n  return false;\n}\nfunction locallyInside(a2, b2) {\n  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;\n}\nfunction middleInside(a2, b2) {\n  var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;\n  do {\n    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)\n      inside = !inside;\n    p2 = p2.next;\n  } while (p2 !== a2);\n  return inside;\n}\nfunction splitPolygon(a2, b2) {\n  var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;\n  a2.next = b2;\n  b2.prev = a2;\n  a22.next = an;\n  an.prev = a22;\n  b22.next = a22;\n  a22.prev = b22;\n  bp.next = b22;\n  b22.prev = bp;\n  return b22;\n}\nfunction insertNode(i2, x2, y2, last) {\n  var p2 = new Node$1(i2, x2, y2);\n  if (!last) {\n    p2.prev = p2;\n    p2.next = p2;\n  } else {\n    p2.next = last.next;\n    p2.prev = last;\n    last.next.prev = p2;\n    last.next = p2;\n  }\n  return p2;\n}\nfunction removeNode(p2) {\n  p2.next.prev = p2.prev;\n  p2.prev.next = p2.next;\n  if (p2.prevZ)\n    p2.prevZ.nextZ = p2.nextZ;\n  if (p2.nextZ)\n    p2.nextZ.prevZ = p2.prevZ;\n}\nfunction Node$1(i2, x2, y2) {\n  this.i = i2;\n  this.x = x2;\n  this.y = y2;\n  this.prev = null;\n  this.next = null;\n  this.z = null;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}\nearcut.deviation = function(data, holeIndices, dim, triangles) {\n  var hasHoles = holeIndices && holeIndices.length;\n  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n  if (hasHoles) {\n    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {\n      var start2 = holeIndices[i2] * dim;\n      var end2 = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;\n      polygonArea -= Math.abs(signedArea(data, start2, end2, dim));\n    }\n  }\n  var trianglesArea = 0;\n  for (i2 = 0; i2 < triangles.length; i2 += 3) {\n    var a2 = triangles[i2] * dim;\n    var b2 = triangles[i2 + 1] * dim;\n    var c2 = triangles[i2 + 2] * dim;\n    trianglesArea += Math.abs((data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1]));\n  }\n  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction signedArea(data, start2, end2, dim) {\n  var sum2 = 0;\n  for (var i2 = start2, j2 = end2 - dim; i2 < end2; i2 += dim) {\n    sum2 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);\n    j2 = i2;\n  }\n  return sum2;\n}\nearcut.flatten = function(data) {\n  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;\n  for (var i2 = 0; i2 < data.length; i2++) {\n    for (var j2 = 0; j2 < data[i2].length; j2++) {\n      for (var d2 = 0; d2 < dim; d2++)\n        result.vertices.push(data[i2][j2][d2]);\n    }\n    if (i2 > 0) {\n      holeIndex += data[i2 - 1].length;\n      result.holes.push(holeIndex);\n    }\n  }\n  return result;\n};\nvar earcut$1 = earcut$2.exports;\nvar punycode$1 = { exports: {} };\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n(function(module, exports) {\n  (function(root) {\n    var freeExports = exports && !exports.nodeType && exports;\n    var freeModule = module && !module.nodeType && module;\n    var freeGlobal = typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n      root = freeGlobal;\n    }\n    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = \"-\", regexPunycode = /^xn--/, regexNonASCII = /[^\\x20-\\x7E]/, regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, errors = {\n      \"overflow\": \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;\n    function error(type) {\n      throw RangeError(errors[type]);\n    }\n    function map2(array, fn2) {\n      var length2 = array.length;\n      var result = [];\n      while (length2--) {\n        result[length2] = fn2(array[length2]);\n      }\n      return result;\n    }\n    function mapDomain(string, fn2) {\n      var parts2 = string.split(\"@\");\n      var result = \"\";\n      if (parts2.length > 1) {\n        result = parts2[0] + \"@\";\n        string = parts2[1];\n      }\n      string = string.replace(regexSeparators, \".\");\n      var labels = string.split(\".\");\n      var encoded = map2(labels, fn2).join(\".\");\n      return result + encoded;\n    }\n    function ucs2decode(string) {\n      var output = [], counter = 0, length2 = string.length, value2, extra;\n      while (counter < length2) {\n        value2 = string.charCodeAt(counter++);\n        if (value2 >= 55296 && value2 <= 56319 && counter < length2) {\n          extra = string.charCodeAt(counter++);\n          if ((extra & 64512) == 56320) {\n            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);\n          } else {\n            output.push(value2);\n            counter--;\n          }\n        } else {\n          output.push(value2);\n        }\n      }\n      return output;\n    }\n    function ucs2encode(array) {\n      return map2(array, function(value2) {\n        var output = \"\";\n        if (value2 > 65535) {\n          value2 -= 65536;\n          output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);\n          value2 = 56320 | value2 & 1023;\n        }\n        output += stringFromCharCode(value2);\n        return output;\n      }).join(\"\");\n    }\n    function basicToDigit(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n      return base;\n    }\n    function digitToBasic(digit, flag) {\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n    function adapt(delta, numPoints, firstTime) {\n      var k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n      for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n    function decode2(input) {\n      var output = [], inputLength = input.length, out, i2 = 0, n = initialN, bias = initialBias, basic, j2, index, oldi, w2, k, digit, t, baseMinusT;\n      basic = input.lastIndexOf(delimiter);\n      if (basic < 0) {\n        basic = 0;\n      }\n      for (j2 = 0; j2 < basic; ++j2) {\n        if (input.charCodeAt(j2) >= 128) {\n          error(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j2));\n      }\n      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        for (oldi = i2, w2 = 1, k = base; ; k += base) {\n          if (index >= inputLength) {\n            error(\"invalid-input\");\n          }\n          digit = basicToDigit(input.charCodeAt(index++));\n          if (digit >= base || digit > floor((maxInt - i2) / w2)) {\n            error(\"overflow\");\n          }\n          i2 += digit * w2;\n          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (digit < t) {\n            break;\n          }\n          baseMinusT = base - t;\n          if (w2 > floor(maxInt / baseMinusT)) {\n            error(\"overflow\");\n          }\n          w2 *= baseMinusT;\n        }\n        out = output.length + 1;\n        bias = adapt(i2 - oldi, out, oldi == 0);\n        if (floor(i2 / out) > maxInt - n) {\n          error(\"overflow\");\n        }\n        n += floor(i2 / out);\n        i2 %= out;\n        output.splice(i2++, 0, n);\n      }\n      return ucs2encode(output);\n    }\n    function encode2(input) {\n      var n, delta, handledCPCount, basicLength, bias, j2, m2, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;\n      input = ucs2decode(input);\n      inputLength = input.length;\n      n = initialN;\n      delta = 0;\n      bias = initialBias;\n      for (j2 = 0; j2 < inputLength; ++j2) {\n        currentValue = input[j2];\n        if (currentValue < 128) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n      handledCPCount = basicLength = output.length;\n      if (basicLength) {\n        output.push(delimiter);\n      }\n      while (handledCPCount < inputLength) {\n        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {\n          currentValue = input[j2];\n          if (currentValue >= n && currentValue < m2) {\n            m2 = currentValue;\n          }\n        }\n        handledCPCountPlusOne = handledCPCount + 1;\n        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error(\"overflow\");\n        }\n        delta += (m2 - n) * handledCPCountPlusOne;\n        n = m2;\n        for (j2 = 0; j2 < inputLength; ++j2) {\n          currentValue = input[j2];\n          if (currentValue < n && ++delta > maxInt) {\n            error(\"overflow\");\n          }\n          if (currentValue == n) {\n            for (q = delta, k = base; ; k += base) {\n              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n              if (q < t) {\n                break;\n              }\n              qMinusT = q - t;\n              baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n        ++delta;\n        ++n;\n      }\n      return output.join(\"\");\n    }\n    function toUnicode(input) {\n      return mapDomain(input, function(string) {\n        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;\n      });\n    }\n    function toASCII(input) {\n      return mapDomain(input, function(string) {\n        return regexNonASCII.test(string) ? \"xn--\" + encode2(string) : string;\n      });\n    }\n    punycode2 = {\n      \"version\": \"1.3.2\",\n      \"ucs2\": {\n        \"decode\": ucs2decode,\n        \"encode\": ucs2encode\n      },\n      \"decode\": decode2,\n      \"encode\": encode2,\n      \"toASCII\": toASCII,\n      \"toUnicode\": toUnicode\n    };\n    if (freeExports && freeModule) {\n      if (module.exports == freeExports) {\n        freeModule.exports = punycode2;\n      } else {\n        for (key in punycode2) {\n          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);\n        }\n      }\n    } else {\n      root.punycode = punycode2;\n    }\n  })(commonjsGlobal);\n})(punycode$1, punycode$1.exports);\nvar util$8 = {\n  isString: function(arg) {\n    return typeof arg === \"string\";\n  },\n  isObject: function(arg) {\n    return typeof arg === \"object\" && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\nvar querystring$1 = {};\nfunction hasOwnProperty$1(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nvar decode = function(qs, sep, eq, options) {\n  sep = sep || \"&\";\n  eq = eq || \"=\";\n  var obj = {};\n  if (typeof qs !== \"string\" || qs.length === 0) {\n    return obj;\n  }\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n  var maxKeys = 1e3;\n  if (options && typeof options.maxKeys === \"number\") {\n    maxKeys = options.maxKeys;\n  }\n  var len = qs.length;\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n  for (var i2 = 0; i2 < len; ++i2) {\n    var x2 = qs[i2].replace(regexp, \"%20\"), idx = x2.indexOf(eq), kstr, vstr, k, v2;\n    if (idx >= 0) {\n      kstr = x2.substr(0, idx);\n      vstr = x2.substr(idx + 1);\n    } else {\n      kstr = x2;\n      vstr = \"\";\n    }\n    k = decodeURIComponent(kstr);\n    v2 = decodeURIComponent(vstr);\n    if (!hasOwnProperty$1(obj, k)) {\n      obj[k] = v2;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v2);\n    } else {\n      obj[k] = [obj[k], v2];\n    }\n  }\n  return obj;\n};\nvar stringifyPrimitive = function(v2) {\n  switch (typeof v2) {\n    case \"string\":\n      return v2;\n    case \"boolean\":\n      return v2 ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(v2) ? v2 : \"\";\n    default:\n      return \"\";\n  }\n};\nvar encode = function(obj, sep, eq, name) {\n  sep = sep || \"&\";\n  eq = eq || \"=\";\n  if (obj === null) {\n    obj = void 0;\n  }\n  if (typeof obj === \"object\") {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v2) {\n          return ks + encodeURIComponent(stringifyPrimitive(v2));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n  if (!name)\n    return \"\";\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n};\nquerystring$1.decode = querystring$1.parse = decode;\nquerystring$1.encode = querystring$1.stringify = encode;\nvar punycode = punycode$1.exports;\nvar util$7 = util$8;\nvar parse$1 = urlParse;\nvar resolve$1 = urlResolve;\nvar format = urlFormat;\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  \"javascript\": true,\n  \"javascript:\": true\n}, hostlessProtocol = {\n  \"javascript\": true,\n  \"javascript:\": true\n}, slashedProtocol = {\n  \"http\": true,\n  \"https\": true,\n  \"ftp\": true,\n  \"gopher\": true,\n  \"file\": true,\n  \"http:\": true,\n  \"https:\": true,\n  \"ftp:\": true,\n  \"gopher:\": true,\n  \"file:\": true\n}, querystring = querystring$1;\nfunction urlParse(url2, parseQueryString, slashesDenoteHost) {\n  if (url2 && util$7.isObject(url2) && url2 instanceof Url)\n    return url2;\n  var u2 = new Url();\n  u2.parse(url2, parseQueryString, slashesDenoteHost);\n  return u2;\n}\nUrl.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {\n  if (!util$7.isString(url2)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url2);\n  }\n  var queryIndex = url2.indexOf(\"?\"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf(\"#\") ? \"?\" : \"#\", uSplit = url2.split(splitter), slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \"/\");\n  url2 = uSplit.join(splitter);\n  var rest = url2;\n  rest = rest.trim();\n  if (!slashesDenoteHost && url2.split(\"#\").length === 1) {\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = \"\";\n        this.query = {};\n      }\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === \"//\";\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    var hostEnd = -1;\n    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {\n      var hec = rest.indexOf(hostEndingChars[i2]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    var auth, atSign;\n    if (hostEnd === -1) {\n      atSign = rest.lastIndexOf(\"@\");\n    } else {\n      atSign = rest.lastIndexOf(\"@\", hostEnd);\n    }\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n    hostEnd = -1;\n    for (var i2 = 0; i2 < nonHostChars.length; i2++) {\n      var hec = rest.indexOf(nonHostChars[i2]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n    this.parseHost();\n    this.hostname = this.hostname || \"\";\n    var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {\n        var part = hostparts[i2];\n        if (!part)\n          continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \"\";\n          for (var j2 = 0, k = part.length; j2 < k; j2++) {\n            if (part.charCodeAt(j2) > 127) {\n              newpart += \"x\";\n            } else {\n              newpart += part[j2];\n            }\n          }\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i2);\n            var notHost = hostparts.slice(i2 + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = \"/\" + notHost.join(\".\") + rest;\n            }\n            this.hostname = validParts.join(\".\");\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \"\";\n    } else {\n      this.hostname = this.hostname.toLowerCase();\n    }\n    if (!ipv6Hostname) {\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n    var p2 = this.port ? \":\" + this.port : \"\";\n    var h2 = this.hostname || \"\";\n    this.host = h2 + p2;\n    this.href += this.host;\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== \"/\") {\n        rest = \"/\" + rest;\n      }\n    }\n  }\n  if (!unsafeProtocol[lowerProto]) {\n    for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {\n      var ae = autoEscape[i2];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n  var hash2 = rest.indexOf(\"#\");\n  if (hash2 !== -1) {\n    this.hash = rest.substr(hash2);\n    rest = rest.slice(0, hash2);\n  }\n  var qm = rest.indexOf(\"?\");\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    this.search = \"\";\n    this.query = {};\n  }\n  if (rest)\n    this.pathname = rest;\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = \"/\";\n  }\n  if (this.pathname || this.search) {\n    var p2 = this.pathname || \"\";\n    var s2 = this.search || \"\";\n    this.path = p2 + s2;\n  }\n  this.href = this.format();\n  return this;\n};\nfunction urlFormat(obj) {\n  if (util$7.isString(obj))\n    obj = urlParse(obj);\n  if (!(obj instanceof Url))\n    return Url.prototype.format.call(obj);\n  return obj.format();\n}\nUrl.prototype.format = function() {\n  var auth = this.auth || \"\";\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \":\");\n    auth += \"@\";\n  }\n  var protocol2 = this.protocol || \"\", pathname = this.pathname || \"\", hash2 = this.hash || \"\", host = false, query = \"\";\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(\":\") === -1 ? this.hostname : \"[\" + this.hostname + \"]\");\n    if (this.port) {\n      host += \":\" + this.port;\n    }\n  }\n  if (this.query && util$7.isObject(this.query) && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n  var search = this.search || query && \"?\" + query || \"\";\n  if (protocol2 && protocol2.substr(-1) !== \":\")\n    protocol2 += \":\";\n  if (this.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {\n    host = \"//\" + (host || \"\");\n    if (pathname && pathname.charAt(0) !== \"/\")\n      pathname = \"/\" + pathname;\n  } else if (!host) {\n    host = \"\";\n  }\n  if (hash2 && hash2.charAt(0) !== \"#\")\n    hash2 = \"#\" + hash2;\n  if (search && search.charAt(0) !== \"?\")\n    search = \"?\" + search;\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\"#\", \"%23\");\n  return protocol2 + host + pathname + search + hash2;\n};\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\nUrl.prototype.resolveObject = function(relative) {\n  if (util$7.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n  result.hash = relative.hash;\n  if (relative.href === \"\") {\n    result.href = result.format();\n    return result;\n  }\n  if (relative.slashes && !relative.protocol) {\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \"protocol\")\n        result[rkey] = relative[rkey];\n    }\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = \"/\";\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v2 = 0; v2 < keys.length; v2++) {\n        var k = keys[v2];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \"\").split(\"/\");\n      while (relPath.length && !(relative.host = relPath.shift()))\n        ;\n      if (!relative.host)\n        relative.host = \"\";\n      if (!relative.hostname)\n        relative.hostname = \"\";\n      if (relPath[0] !== \"\")\n        relPath.unshift(\"\");\n      if (relPath.length < 2)\n        relPath.unshift(\"\");\n      result.pathname = relPath.join(\"/\");\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || \"\";\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    if (result.pathname || result.search) {\n      var p2 = result.pathname || \"\";\n      var s2 = result.search || \"\";\n      result.path = p2 + s2;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \"/\", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \"/\", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split(\"/\") || [], relPath = relative.pathname && relative.pathname.split(\"/\") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];\n  if (psychotic) {\n    result.hostname = \"\";\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === \"\")\n        srcPath[0] = result.host;\n      else\n        srcPath.unshift(result.host);\n    }\n    result.host = \"\";\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === \"\")\n          relPath[0] = relative.host;\n        else\n          relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \"\" || srcPath[0] === \"\");\n  }\n  if (isRelAbs) {\n    result.host = relative.host || relative.host === \"\" ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === \"\" ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n  } else if (relPath.length) {\n    if (!srcPath)\n      srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util$7.isNullOrUndefined(relative.search)) {\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      var authInHost = result.host && result.host.indexOf(\"@\") > 0 ? result.host.split(\"@\") : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    if (!util$7.isNull(result.pathname) || !util$7.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : \"\") + (result.search ? result.search : \"\");\n    }\n    result.href = result.format();\n    return result;\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    if (result.search) {\n      result.path = \"/\" + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \".\" || last === \"..\") || last === \"\";\n  var up = 0;\n  for (var i2 = srcPath.length; i2 >= 0; i2--) {\n    last = srcPath[i2];\n    if (last === \".\") {\n      srcPath.splice(i2, 1);\n    } else if (last === \"..\") {\n      srcPath.splice(i2, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i2, 1);\n      up--;\n    }\n  }\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift(\"..\");\n    }\n  }\n  if (mustEndAbs && srcPath[0] !== \"\" && (!srcPath[0] || srcPath[0].charAt(0) !== \"/\")) {\n    srcPath.unshift(\"\");\n  }\n  if (hasTrailingSlash && srcPath.join(\"/\").substr(-1) !== \"/\") {\n    srcPath.push(\"\");\n  }\n  var isAbsolute = srcPath[0] === \"\" || srcPath[0] && srcPath[0].charAt(0) === \"/\";\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? \"\" : srcPath.length ? srcPath.shift() : \"\";\n    var authInHost = result.host && result.host.indexOf(\"@\") > 0 ? result.host.split(\"@\") : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\"\");\n  }\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join(\"/\");\n  }\n  if (!util$7.isNull(result.pathname) || !util$7.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : \"\") + (result.search ? result.search : \"\");\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== \":\") {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host)\n    this.hostname = host;\n};\n/*!\n * @pixi/utils - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar url = {\n  parse: parse$1,\n  format,\n  resolve: resolve$1\n};\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\nvar saidHello = false;\nvar VERSION = \"6.3.2\";\nfunction skipHello() {\n  saidHello = true;\n}\nfunction sayHello(type) {\n  var _a3;\n  if (saidHello) {\n    return;\n  }\n  if (navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    var args = [\n      \"\\n %c %c %c PixiJS \" + VERSION + \" - \\u2730 \" + type + \" \\u2730  %c  %c  http://www.pixijs.com/  %c %c \\u2665%c\\u2665%c\\u2665 \\n\\n\",\n      \"background: #ff66a5; padding:5px 0;\",\n      \"background: #ff66a5; padding:5px 0;\",\n      \"color: #ff66a5; background: #030307; padding:5px 0;\",\n      \"background: #ff66a5; padding:5px 0;\",\n      \"background: #ffc3dc; padding:5px 0;\",\n      \"background: #ff66a5; padding:5px 0;\",\n      \"color: #ff2424; background: #fff; padding:5px 0;\",\n      \"color: #ff2424; background: #fff; padding:5px 0;\",\n      \"color: #ff2424; background: #fff; padding:5px 0;\"\n    ];\n    (_a3 = globalThis.console).log.apply(_a3, args);\n  } else if (globalThis.console) {\n    globalThis.console.log(\"PixiJS \" + VERSION + \" - \" + type + \" - http://www.pixijs.com/\");\n  }\n  saidHello = true;\n}\nvar supported;\nfunction isWebGLSupported() {\n  if (typeof supported === \"undefined\") {\n    supported = function supported2() {\n      var contextOptions = {\n        stencil: true,\n        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n      };\n      try {\n        if (!globalThis.WebGLRenderingContext) {\n          return false;\n        }\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\", contextOptions) || canvas.getContext(\"experimental-webgl\", contextOptions);\n        var success = !!(gl && gl.getContextAttributes().stencil);\n        if (gl) {\n          var loseContext = gl.getExtension(\"WEBGL_lose_context\");\n          if (loseContext) {\n            loseContext.loseContext();\n          }\n        }\n        gl = null;\n        return success;\n      } catch (e) {\n        return false;\n      }\n    }();\n  }\n  return supported;\n}\nvar aliceblue = \"#f0f8ff\";\nvar antiquewhite = \"#faebd7\";\nvar aqua = \"#00ffff\";\nvar aquamarine = \"#7fffd4\";\nvar azure = \"#f0ffff\";\nvar beige = \"#f5f5dc\";\nvar bisque = \"#ffe4c4\";\nvar black = \"#000000\";\nvar blanchedalmond = \"#ffebcd\";\nvar blue = \"#0000ff\";\nvar blueviolet = \"#8a2be2\";\nvar brown = \"#a52a2a\";\nvar burlywood = \"#deb887\";\nvar cadetblue = \"#5f9ea0\";\nvar chartreuse = \"#7fff00\";\nvar chocolate = \"#d2691e\";\nvar coral = \"#ff7f50\";\nvar cornflowerblue = \"#6495ed\";\nvar cornsilk = \"#fff8dc\";\nvar crimson = \"#dc143c\";\nvar cyan = \"#00ffff\";\nvar darkblue = \"#00008b\";\nvar darkcyan = \"#008b8b\";\nvar darkgoldenrod = \"#b8860b\";\nvar darkgray = \"#a9a9a9\";\nvar darkgreen = \"#006400\";\nvar darkgrey = \"#a9a9a9\";\nvar darkkhaki = \"#bdb76b\";\nvar darkmagenta = \"#8b008b\";\nvar darkolivegreen = \"#556b2f\";\nvar darkorange = \"#ff8c00\";\nvar darkorchid = \"#9932cc\";\nvar darkred = \"#8b0000\";\nvar darksalmon = \"#e9967a\";\nvar darkseagreen = \"#8fbc8f\";\nvar darkslateblue = \"#483d8b\";\nvar darkslategray = \"#2f4f4f\";\nvar darkslategrey = \"#2f4f4f\";\nvar darkturquoise = \"#00ced1\";\nvar darkviolet = \"#9400d3\";\nvar deeppink = \"#ff1493\";\nvar deepskyblue = \"#00bfff\";\nvar dimgray = \"#696969\";\nvar dimgrey = \"#696969\";\nvar dodgerblue = \"#1e90ff\";\nvar firebrick = \"#b22222\";\nvar floralwhite = \"#fffaf0\";\nvar forestgreen = \"#228b22\";\nvar fuchsia = \"#ff00ff\";\nvar gainsboro = \"#dcdcdc\";\nvar ghostwhite = \"#f8f8ff\";\nvar goldenrod = \"#daa520\";\nvar gold = \"#ffd700\";\nvar gray = \"#808080\";\nvar green = \"#008000\";\nvar greenyellow = \"#adff2f\";\nvar grey = \"#808080\";\nvar honeydew = \"#f0fff0\";\nvar hotpink = \"#ff69b4\";\nvar indianred = \"#cd5c5c\";\nvar indigo = \"#4b0082\";\nvar ivory = \"#fffff0\";\nvar khaki = \"#f0e68c\";\nvar lavenderblush = \"#fff0f5\";\nvar lavender = \"#e6e6fa\";\nvar lawngreen = \"#7cfc00\";\nvar lemonchiffon = \"#fffacd\";\nvar lightblue = \"#add8e6\";\nvar lightcoral = \"#f08080\";\nvar lightcyan = \"#e0ffff\";\nvar lightgoldenrodyellow = \"#fafad2\";\nvar lightgray = \"#d3d3d3\";\nvar lightgreen = \"#90ee90\";\nvar lightgrey = \"#d3d3d3\";\nvar lightpink = \"#ffb6c1\";\nvar lightsalmon = \"#ffa07a\";\nvar lightseagreen = \"#20b2aa\";\nvar lightskyblue = \"#87cefa\";\nvar lightslategray = \"#778899\";\nvar lightslategrey = \"#778899\";\nvar lightsteelblue = \"#b0c4de\";\nvar lightyellow = \"#ffffe0\";\nvar lime = \"#00ff00\";\nvar limegreen = \"#32cd32\";\nvar linen = \"#faf0e6\";\nvar magenta = \"#ff00ff\";\nvar maroon = \"#800000\";\nvar mediumaquamarine = \"#66cdaa\";\nvar mediumblue = \"#0000cd\";\nvar mediumorchid = \"#ba55d3\";\nvar mediumpurple = \"#9370db\";\nvar mediumseagreen = \"#3cb371\";\nvar mediumslateblue = \"#7b68ee\";\nvar mediumspringgreen = \"#00fa9a\";\nvar mediumturquoise = \"#48d1cc\";\nvar mediumvioletred = \"#c71585\";\nvar midnightblue = \"#191970\";\nvar mintcream = \"#f5fffa\";\nvar mistyrose = \"#ffe4e1\";\nvar moccasin = \"#ffe4b5\";\nvar navajowhite = \"#ffdead\";\nvar navy = \"#000080\";\nvar oldlace = \"#fdf5e6\";\nvar olive = \"#808000\";\nvar olivedrab = \"#6b8e23\";\nvar orange = \"#ffa500\";\nvar orangered = \"#ff4500\";\nvar orchid = \"#da70d6\";\nvar palegoldenrod = \"#eee8aa\";\nvar palegreen = \"#98fb98\";\nvar paleturquoise = \"#afeeee\";\nvar palevioletred = \"#db7093\";\nvar papayawhip = \"#ffefd5\";\nvar peachpuff = \"#ffdab9\";\nvar peru = \"#cd853f\";\nvar pink = \"#ffc0cb\";\nvar plum = \"#dda0dd\";\nvar powderblue = \"#b0e0e6\";\nvar purple = \"#800080\";\nvar rebeccapurple = \"#663399\";\nvar red = \"#ff0000\";\nvar rosybrown = \"#bc8f8f\";\nvar royalblue = \"#4169e1\";\nvar saddlebrown = \"#8b4513\";\nvar salmon = \"#fa8072\";\nvar sandybrown = \"#f4a460\";\nvar seagreen = \"#2e8b57\";\nvar seashell = \"#fff5ee\";\nvar sienna = \"#a0522d\";\nvar silver = \"#c0c0c0\";\nvar skyblue = \"#87ceeb\";\nvar slateblue = \"#6a5acd\";\nvar slategray = \"#708090\";\nvar slategrey = \"#708090\";\nvar snow = \"#fffafa\";\nvar springgreen = \"#00ff7f\";\nvar steelblue = \"#4682b4\";\nvar tan = \"#d2b48c\";\nvar teal = \"#008080\";\nvar thistle = \"#d8bfd8\";\nvar tomato = \"#ff6347\";\nvar turquoise = \"#40e0d0\";\nvar violet = \"#ee82ee\";\nvar wheat = \"#f5deb3\";\nvar white = \"#ffffff\";\nvar whitesmoke = \"#f5f5f5\";\nvar yellow = \"#ffff00\";\nvar yellowgreen = \"#9acd32\";\nvar cssColorNames = {\n  aliceblue,\n  antiquewhite,\n  aqua,\n  aquamarine,\n  azure,\n  beige,\n  bisque,\n  black,\n  blanchedalmond,\n  blue,\n  blueviolet,\n  brown,\n  burlywood,\n  cadetblue,\n  chartreuse,\n  chocolate,\n  coral,\n  cornflowerblue,\n  cornsilk,\n  crimson,\n  cyan,\n  darkblue,\n  darkcyan,\n  darkgoldenrod,\n  darkgray,\n  darkgreen,\n  darkgrey,\n  darkkhaki,\n  darkmagenta,\n  darkolivegreen,\n  darkorange,\n  darkorchid,\n  darkred,\n  darksalmon,\n  darkseagreen,\n  darkslateblue,\n  darkslategray,\n  darkslategrey,\n  darkturquoise,\n  darkviolet,\n  deeppink,\n  deepskyblue,\n  dimgray,\n  dimgrey,\n  dodgerblue,\n  firebrick,\n  floralwhite,\n  forestgreen,\n  fuchsia,\n  gainsboro,\n  ghostwhite,\n  goldenrod,\n  gold,\n  gray,\n  green,\n  greenyellow,\n  grey,\n  honeydew,\n  hotpink,\n  indianred,\n  indigo,\n  ivory,\n  khaki,\n  lavenderblush,\n  lavender,\n  lawngreen,\n  lemonchiffon,\n  lightblue,\n  lightcoral,\n  lightcyan,\n  lightgoldenrodyellow,\n  lightgray,\n  lightgreen,\n  lightgrey,\n  lightpink,\n  lightsalmon,\n  lightseagreen,\n  lightskyblue,\n  lightslategray,\n  lightslategrey,\n  lightsteelblue,\n  lightyellow,\n  lime,\n  limegreen,\n  linen,\n  magenta,\n  maroon,\n  mediumaquamarine,\n  mediumblue,\n  mediumorchid,\n  mediumpurple,\n  mediumseagreen,\n  mediumslateblue,\n  mediumspringgreen,\n  mediumturquoise,\n  mediumvioletred,\n  midnightblue,\n  mintcream,\n  mistyrose,\n  moccasin,\n  navajowhite,\n  navy,\n  oldlace,\n  olive,\n  olivedrab,\n  orange,\n  orangered,\n  orchid,\n  palegoldenrod,\n  palegreen,\n  paleturquoise,\n  palevioletred,\n  papayawhip,\n  peachpuff,\n  peru,\n  pink,\n  plum,\n  powderblue,\n  purple,\n  rebeccapurple,\n  red,\n  rosybrown,\n  royalblue,\n  saddlebrown,\n  salmon,\n  sandybrown,\n  seagreen,\n  seashell,\n  sienna,\n  silver,\n  skyblue,\n  slateblue,\n  slategray,\n  slategrey,\n  snow,\n  springgreen,\n  steelblue,\n  tan,\n  teal,\n  thistle,\n  tomato,\n  turquoise,\n  violet,\n  wheat,\n  white,\n  whitesmoke,\n  yellow,\n  yellowgreen\n};\nfunction hex2rgb(hex, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  out[0] = (hex >> 16 & 255) / 255;\n  out[1] = (hex >> 8 & 255) / 255;\n  out[2] = (hex & 255) / 255;\n  return out;\n}\nfunction hex2string(hex) {\n  var hexString = hex.toString(16);\n  hexString = \"000000\".substring(0, 6 - hexString.length) + hexString;\n  return \"#\" + hexString;\n}\nfunction string2hex(string) {\n  if (typeof string === \"string\") {\n    string = cssColorNames[string.toLowerCase()] || string;\n    if (string[0] === \"#\") {\n      string = string.slice(1);\n    }\n  }\n  return parseInt(string, 16);\n}\nfunction mapPremultipliedBlendModes() {\n  var pm = [];\n  var npm = [];\n  for (var i2 = 0; i2 < 32; i2++) {\n    pm[i2] = i2;\n    npm[i2] = i2;\n  }\n  pm[BLEND_MODES$3.NORMAL_NPM] = BLEND_MODES$3.NORMAL;\n  pm[BLEND_MODES$3.ADD_NPM] = BLEND_MODES$3.ADD;\n  pm[BLEND_MODES$3.SCREEN_NPM] = BLEND_MODES$3.SCREEN;\n  npm[BLEND_MODES$3.NORMAL] = BLEND_MODES$3.NORMAL_NPM;\n  npm[BLEND_MODES$3.ADD] = BLEND_MODES$3.ADD_NPM;\n  npm[BLEND_MODES$3.SCREEN] = BLEND_MODES$3.SCREEN_NPM;\n  var array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  if (premultiply || premultiply === void 0) {\n    out[0] = rgb[0] * alpha;\n    out[1] = rgb[1] * alpha;\n    out[2] = rgb[2] * alpha;\n  } else {\n    out[0] = rgb[0];\n    out[1] = rgb[1];\n    out[2] = rgb[2];\n  }\n  out[3] = alpha;\n  return out;\n}\nfunction premultiplyTint(tint, alpha) {\n  if (alpha === 1) {\n    return (alpha * 255 << 24) + tint;\n  }\n  if (alpha === 0) {\n    return 0;\n  }\n  var R = tint >> 16 & 255;\n  var G2 = tint >> 8 & 255;\n  var B = tint & 255;\n  R = R * alpha + 0.5 | 0;\n  G2 = G2 * alpha + 0.5 | 0;\n  B = B * alpha + 0.5 | 0;\n  return (alpha * 255 << 24) + (R << 16) + (G2 << 8) + B;\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  out[0] = (tint >> 16 & 255) / 255;\n  out[1] = (tint >> 8 & 255) / 255;\n  out[2] = (tint & 255) / 255;\n  if (premultiply || premultiply === void 0) {\n    out[0] *= alpha;\n    out[1] *= alpha;\n    out[2] *= alpha;\n  }\n  out[3] = alpha;\n  return out;\n}\nfunction createIndicesForQuads(size, outBuffer) {\n  if (outBuffer === void 0) {\n    outBuffer = null;\n  }\n  var totalIndices = size * 6;\n  outBuffer = outBuffer || new Uint16Array(totalIndices);\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(\"Out buffer length is incorrect, got \" + outBuffer.length + \" and expected \" + totalIndices);\n  }\n  for (var i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {\n    outBuffer[i2 + 0] = j2 + 0;\n    outBuffer[i2 + 1] = j2 + 1;\n    outBuffer[i2 + 2] = j2 + 2;\n    outBuffer[i2 + 3] = j2 + 0;\n    outBuffer[i2 + 4] = j2 + 2;\n    outBuffer[i2 + 5] = j2 + 3;\n  }\n  return outBuffer;\n}\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4) {\n    if (array instanceof Float32Array) {\n      return \"Float32Array\";\n    } else if (array instanceof Uint32Array) {\n      return \"Uint32Array\";\n    }\n    return \"Int32Array\";\n  } else if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array) {\n      return \"Uint16Array\";\n    }\n  } else if (array.BYTES_PER_ELEMENT === 1) {\n    if (array instanceof Uint8Array) {\n      return \"Uint8Array\";\n    }\n  }\n  return null;\n}\nfunction nextPow2(v2) {\n  v2 += v2 === 0 ? 1 : 0;\n  --v2;\n  v2 |= v2 >>> 1;\n  v2 |= v2 >>> 2;\n  v2 |= v2 >>> 4;\n  v2 |= v2 >>> 8;\n  v2 |= v2 >>> 16;\n  return v2 + 1;\n}\nfunction isPow2(v2) {\n  return !(v2 & v2 - 1) && !!v2;\n}\nfunction log2(v2) {\n  var r2 = (v2 > 65535 ? 1 : 0) << 4;\n  v2 >>>= r2;\n  var shift = (v2 > 255 ? 1 : 0) << 3;\n  v2 >>>= shift;\n  r2 |= shift;\n  shift = (v2 > 15 ? 1 : 0) << 2;\n  v2 >>>= shift;\n  r2 |= shift;\n  shift = (v2 > 3 ? 1 : 0) << 1;\n  v2 >>>= shift;\n  r2 |= shift;\n  return r2 | v2 >> 1;\n}\nfunction removeItems(arr, startIdx, removeCount) {\n  var length2 = arr.length;\n  var i2;\n  if (startIdx >= length2 || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;\n  var len = length2 - removeCount;\n  for (i2 = startIdx; i2 < len; ++i2) {\n    arr[i2] = arr[i2 + removeCount];\n  }\n  arr.length = len;\n}\nfunction sign(n) {\n  if (n === 0) {\n    return 0;\n  }\n  return n < 0 ? -1 : 1;\n}\nvar nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nvar warnings = {};\nfunction deprecation(version2, message, ignoreDepth) {\n  if (ignoreDepth === void 0) {\n    ignoreDepth = 3;\n  }\n  if (warnings[message]) {\n    return;\n  }\n  var stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", message + \"\\nDeprecated since v\" + version2);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", message + \"\\nDeprecated since v\" + version2);\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", message + \"\\nDeprecated since v\" + version2);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\nvar ProgramCache = {};\nvar TextureCache = /* @__PURE__ */ Object.create(null);\nvar BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction clearTextureCache() {\n  var key;\n  for (key in TextureCache) {\n    delete TextureCache[key];\n  }\n  for (key in BaseTextureCache) {\n    delete BaseTextureCache[key];\n  }\n}\nvar CanvasRenderTarget = function() {\n  function CanvasRenderTarget2(width, height, resolution) {\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n    this.resolution = resolution || settings.RESOLUTION;\n    this.resize(width, height);\n  }\n  CanvasRenderTarget2.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  };\n  CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {\n    this.canvas.width = Math.round(desiredWidth * this.resolution);\n    this.canvas.height = Math.round(desiredHeight * this.resolution);\n  };\n  CanvasRenderTarget2.prototype.destroy = function() {\n    this.context = null;\n    this.canvas = null;\n  };\n  Object.defineProperty(CanvasRenderTarget2.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(val) {\n      this.canvas.width = Math.round(val);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CanvasRenderTarget2.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(val) {\n      this.canvas.height = Math.round(val);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return CanvasRenderTarget2;\n}();\nfunction trimCanvas(canvas) {\n  var width = canvas.width;\n  var height = canvas.height;\n  var context2 = canvas.getContext(\"2d\");\n  var imageData = context2.getImageData(0, 0, width, height);\n  var pixels = imageData.data;\n  var len = pixels.length;\n  var bound = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  };\n  var data = null;\n  var i2;\n  var x2;\n  var y2;\n  for (i2 = 0; i2 < len; i2 += 4) {\n    if (pixels[i2 + 3] !== 0) {\n      x2 = i2 / 4 % width;\n      y2 = ~~(i2 / 4 / width);\n      if (bound.top === null) {\n        bound.top = y2;\n      }\n      if (bound.left === null) {\n        bound.left = x2;\n      } else if (x2 < bound.left) {\n        bound.left = x2;\n      }\n      if (bound.right === null) {\n        bound.right = x2 + 1;\n      } else if (bound.right < x2) {\n        bound.right = x2 + 1;\n      }\n      if (bound.bottom === null) {\n        bound.bottom = y2;\n      } else if (bound.bottom < y2) {\n        bound.bottom = y2;\n      }\n    }\n  }\n  if (bound.top !== null) {\n    width = bound.right - bound.left;\n    height = bound.bottom - bound.top + 1;\n    data = context2.getImageData(bound.left, bound.top, width, height);\n  }\n  return {\n    height,\n    width,\n    data\n  };\n}\nvar tempAnchor$1;\nfunction determineCrossOrigin(url$12, loc) {\n  if (loc === void 0) {\n    loc = globalThis.location;\n  }\n  if (url$12.indexOf(\"data:\") === 0) {\n    return \"\";\n  }\n  loc = loc || globalThis.location;\n  if (!tempAnchor$1) {\n    tempAnchor$1 = document.createElement(\"a\");\n  }\n  tempAnchor$1.href = url$12;\n  var parsedUrl = url.parse(tempAnchor$1.href);\n  var samePort = !parsedUrl.port && loc.port === \"\" || parsedUrl.port === loc.port;\n  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nfunction getResolutionOfUrl(url2, defaultValue2) {\n  var resolution = settings.RETINA_PREFIX.exec(url2);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue2 !== void 0 ? defaultValue2 : 1;\n}\n/*!\n * @pixi/runner - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/runner is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Runner = function() {\n  function Runner2(name) {\n    this.items = [];\n    this._name = name;\n    this._aliasCount = 0;\n  }\n  Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {\n    if (arguments.length > 8) {\n      throw new Error(\"max arguments reached\");\n    }\n    var _a3 = this, name = _a3.name, items = _a3.items;\n    this._aliasCount++;\n    for (var i2 = 0, len = items.length; i2 < len; i2++) {\n      items[i2][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    if (items === this.items) {\n      this._aliasCount--;\n    }\n    return this;\n  };\n  Runner2.prototype.ensureNonAliasedItems = function() {\n    if (this._aliasCount > 0 && this.items.length > 1) {\n      this._aliasCount = 0;\n      this.items = this.items.slice(0);\n    }\n  };\n  Runner2.prototype.add = function(item) {\n    if (item[this._name]) {\n      this.ensureNonAliasedItems();\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  };\n  Runner2.prototype.remove = function(item) {\n    var index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.ensureNonAliasedItems();\n      this.items.splice(index, 1);\n    }\n    return this;\n  };\n  Runner2.prototype.contains = function(item) {\n    return this.items.indexOf(item) !== -1;\n  };\n  Runner2.prototype.removeAll = function() {\n    this.ensureNonAliasedItems();\n    this.items.length = 0;\n    return this;\n  };\n  Runner2.prototype.destroy = function() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  };\n  Object.defineProperty(Runner2.prototype, \"empty\", {\n    get: function() {\n      return this.items.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Runner2.prototype, \"name\", {\n    get: function() {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Runner2;\n}();\nObject.defineProperties(Runner.prototype, {\n  dispatch: { value: Runner.prototype.emit },\n  run: { value: Runner.prototype.emit }\n});\n/*!\n * @pixi/ticker - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/ticker is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.TARGET_FPMS = 0.06;\nvar UPDATE_PRIORITY;\n(function(UPDATE_PRIORITY2) {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));\nvar TickerListener = function() {\n  function TickerListener2(fn2, context2, priority, once) {\n    if (context2 === void 0) {\n      context2 = null;\n    }\n    if (priority === void 0) {\n      priority = 0;\n    }\n    if (once === void 0) {\n      once = false;\n    }\n    this.next = null;\n    this.previous = null;\n    this._destroyed = false;\n    this.fn = fn2;\n    this.context = context2;\n    this.priority = priority;\n    this.once = once;\n  }\n  TickerListener2.prototype.match = function(fn2, context2) {\n    if (context2 === void 0) {\n      context2 = null;\n    }\n    return this.fn === fn2 && this.context === context2;\n  };\n  TickerListener2.prototype.emit = function(deltaTime) {\n    if (this.fn) {\n      if (this.context) {\n        this.fn.call(this.context, deltaTime);\n      } else {\n        this.fn(deltaTime);\n      }\n    }\n    var redirect = this.next;\n    if (this.once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  };\n  TickerListener2.prototype.connect = function(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  };\n  TickerListener2.prototype.destroy = function(hard) {\n    if (hard === void 0) {\n      hard = false;\n    }\n    this._destroyed = true;\n    this.fn = null;\n    this.context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    var redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  };\n  return TickerListener2;\n}();\nvar Ticker = function() {\n  function Ticker2() {\n    var _this = this;\n    this.autoStart = false;\n    this.deltaTime = 1;\n    this.lastTime = -1;\n    this.speed = 1;\n    this.started = false;\n    this._requestId = null;\n    this._maxElapsedMS = 100;\n    this._minElapsedMS = 0;\n    this._protected = false;\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / settings.TARGET_FPMS;\n    this.elapsedMS = 1 / settings.TARGET_FPMS;\n    this._tick = function(time) {\n      _this._requestId = null;\n      if (_this.started) {\n        _this.update(time);\n        if (_this.started && _this._requestId === null && _this._head.next) {\n          _this._requestId = requestAnimationFrame(_this._tick);\n        }\n      }\n    };\n  }\n  Ticker2.prototype._requestIfNeeded = function() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  };\n  Ticker2.prototype._cancelIfNeeded = function() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  };\n  Ticker2.prototype._startIfPossible = function() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  };\n  Ticker2.prototype.add = function(fn2, context2, priority) {\n    if (priority === void 0) {\n      priority = UPDATE_PRIORITY.NORMAL;\n    }\n    return this._addListener(new TickerListener(fn2, context2, priority));\n  };\n  Ticker2.prototype.addOnce = function(fn2, context2, priority) {\n    if (priority === void 0) {\n      priority = UPDATE_PRIORITY.NORMAL;\n    }\n    return this._addListener(new TickerListener(fn2, context2, priority, true));\n  };\n  Ticker2.prototype._addListener = function(listener) {\n    var current = this._head.next;\n    var previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  };\n  Ticker2.prototype.remove = function(fn2, context2) {\n    var listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn2, context2)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  };\n  Object.defineProperty(Ticker2.prototype, \"count\", {\n    get: function() {\n      if (!this._head) {\n        return 0;\n      }\n      var count = 0;\n      var current = this._head;\n      while (current = current.next) {\n        count++;\n      }\n      return count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Ticker2.prototype.start = function() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  };\n  Ticker2.prototype.stop = function() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  };\n  Ticker2.prototype.destroy = function() {\n    if (!this._protected) {\n      this.stop();\n      var listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  };\n  Ticker2.prototype.update = function(currentTime) {\n    if (currentTime === void 0) {\n      currentTime = performance.now();\n    }\n    var elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        var delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * settings.TARGET_FPMS;\n      var head = this._head;\n      var listener = head.next;\n      while (listener) {\n        listener = listener.emit(this.deltaTime);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  };\n  Object.defineProperty(Ticker2.prototype, \"FPS\", {\n    get: function() {\n      return 1e3 / this.elapsedMS;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Ticker2.prototype, \"minFPS\", {\n    get: function() {\n      return 1e3 / this._maxElapsedMS;\n    },\n    set: function(fps) {\n      var minFPS = Math.min(this.maxFPS, fps);\n      var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);\n      this._maxElapsedMS = 1 / minFPMS;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Ticker2.prototype, \"maxFPS\", {\n    get: function() {\n      if (this._minElapsedMS) {\n        return Math.round(1e3 / this._minElapsedMS);\n      }\n      return 0;\n    },\n    set: function(fps) {\n      if (fps === 0) {\n        this._minElapsedMS = 0;\n      } else {\n        var maxFPS = Math.max(this.minFPS, fps);\n        this._minElapsedMS = 1 / (maxFPS / 1e3);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Ticker2, \"shared\", {\n    get: function() {\n      if (!Ticker2._shared) {\n        var shared = Ticker2._shared = new Ticker2();\n        shared.autoStart = true;\n        shared._protected = true;\n      }\n      return Ticker2._shared;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Ticker2, \"system\", {\n    get: function() {\n      if (!Ticker2._system) {\n        var system = Ticker2._system = new Ticker2();\n        system.autoStart = true;\n        system._protected = true;\n      }\n      return Ticker2._system;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Ticker2;\n}();\nvar TickerPlugin = function() {\n  function TickerPlugin2() {\n  }\n  TickerPlugin2.init = function(options) {\n    var _this = this;\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(this, \"ticker\", {\n      set: function(ticker) {\n        if (this._ticker) {\n          this._ticker.remove(this.render, this);\n        }\n        this._ticker = ticker;\n        if (ticker) {\n          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n        }\n      },\n      get: function() {\n        return this._ticker;\n      }\n    });\n    this.stop = function() {\n      _this._ticker.stop();\n    };\n    this.start = function() {\n      _this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  };\n  TickerPlugin2.destroy = function() {\n    if (this._ticker) {\n      var oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  };\n  return TickerPlugin2;\n}();\n/*!\n * @pixi/math - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar PI_2 = Math.PI * 2;\nvar RAD_TO_DEG = 180 / Math.PI;\nvar DEG_TO_RAD = Math.PI / 180;\nvar SHAPES;\n(function(SHAPES2) {\n  SHAPES2[SHAPES2[\"POLY\"] = 0] = \"POLY\";\n  SHAPES2[SHAPES2[\"RECT\"] = 1] = \"RECT\";\n  SHAPES2[SHAPES2[\"CIRC\"] = 2] = \"CIRC\";\n  SHAPES2[SHAPES2[\"ELIP\"] = 3] = \"ELIP\";\n  SHAPES2[SHAPES2[\"RREC\"] = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\nvar Point = function() {\n  function Point2(x2, y2) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    this.x = 0;\n    this.y = 0;\n    this.x = x2;\n    this.y = y2;\n  }\n  Point2.prototype.clone = function() {\n    return new Point2(this.x, this.y);\n  };\n  Point2.prototype.copyFrom = function(p2) {\n    this.set(p2.x, p2.y);\n    return this;\n  };\n  Point2.prototype.copyTo = function(p2) {\n    p2.set(this.x, this.y);\n    return p2;\n  };\n  Point2.prototype.equals = function(p2) {\n    return p2.x === this.x && p2.y === this.y;\n  };\n  Point2.prototype.set = function(x2, y2) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = x2;\n    }\n    this.x = x2;\n    this.y = y2;\n    return this;\n  };\n  Point2.prototype.toString = function() {\n    return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n  };\n  return Point2;\n}();\nvar tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];\nvar Rectangle = function() {\n  function Rectangle2(x2, y2, width, height) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (width === void 0) {\n      width = 0;\n    }\n    if (height === void 0) {\n      height = 0;\n    }\n    this.x = Number(x2);\n    this.y = Number(y2);\n    this.width = Number(width);\n    this.height = Number(height);\n    this.type = SHAPES.RECT;\n  }\n  Object.defineProperty(Rectangle2.prototype, \"left\", {\n    get: function() {\n      return this.x;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle2.prototype, \"right\", {\n    get: function() {\n      return this.x + this.width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle2.prototype, \"top\", {\n    get: function() {\n      return this.y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle2.prototype, \"bottom\", {\n    get: function() {\n      return this.y + this.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle2, \"EMPTY\", {\n    get: function() {\n      return new Rectangle2(0, 0, 0, 0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Rectangle2.prototype.clone = function() {\n    return new Rectangle2(this.x, this.y, this.width, this.height);\n  };\n  Rectangle2.prototype.copyFrom = function(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  };\n  Rectangle2.prototype.copyTo = function(rectangle) {\n    rectangle.x = this.x;\n    rectangle.y = this.y;\n    rectangle.width = this.width;\n    rectangle.height = this.height;\n    return rectangle;\n  };\n  Rectangle2.prototype.contains = function(x2, y2) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x2 >= this.x && x2 < this.x + this.width) {\n      if (y2 >= this.y && y2 < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Rectangle2.prototype.intersects = function(other, transform) {\n    if (!transform) {\n      var x0_1 = this.x < other.x ? other.x : this.x;\n      var x1_1 = this.right > other.right ? other.right : this.right;\n      if (x1_1 <= x0_1) {\n        return false;\n      }\n      var y0_1 = this.y < other.y ? other.y : this.y;\n      var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y1_1 > y0_1;\n    }\n    var x0 = this.left;\n    var x1 = this.right;\n    var y0 = this.top;\n    var y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    var lt = tempPoints$1[0].set(other.left, other.top);\n    var lb = tempPoints$1[1].set(other.left, other.bottom);\n    var rt = tempPoints$1[2].set(other.right, other.top);\n    var rb = tempPoints$1[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    var s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s2 === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    var nx = s2 * (lb.y - lt.y);\n    var ny = s2 * (lt.x - lb.x);\n    var n00 = nx * x0 + ny * y0;\n    var n10 = nx * x1 + ny * y0;\n    var n01 = nx * x0 + ny * y1;\n    var n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    var mx = s2 * (lt.y - rt.y);\n    var my = s2 * (rt.x - lt.x);\n    var m00 = mx * x0 + my * y0;\n    var m10 = mx * x1 + my * y0;\n    var m01 = mx * x0 + my * y1;\n    var m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  };\n  Rectangle2.prototype.pad = function(paddingX, paddingY) {\n    if (paddingX === void 0) {\n      paddingX = 0;\n    }\n    if (paddingY === void 0) {\n      paddingY = paddingX;\n    }\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  };\n  Rectangle2.prototype.fit = function(rectangle) {\n    var x1 = Math.max(this.x, rectangle.x);\n    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    var y1 = Math.max(this.y, rectangle.y);\n    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  };\n  Rectangle2.prototype.ceil = function(resolution, eps) {\n    if (resolution === void 0) {\n      resolution = 1;\n    }\n    if (eps === void 0) {\n      eps = 1e-3;\n    }\n    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  };\n  Rectangle2.prototype.enlarge = function(rectangle) {\n    var x1 = Math.min(this.x, rectangle.x);\n    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    var y1 = Math.min(this.y, rectangle.y);\n    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  };\n  Rectangle2.prototype.toString = function() {\n    return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  };\n  return Rectangle2;\n}();\nvar Circle = function() {\n  function Circle2(x2, y2, radius) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (radius === void 0) {\n      radius = 0;\n    }\n    this.x = x2;\n    this.y = y2;\n    this.radius = radius;\n    this.type = SHAPES.CIRC;\n  }\n  Circle2.prototype.clone = function() {\n    return new Circle2(this.x, this.y, this.radius);\n  };\n  Circle2.prototype.contains = function(x2, y2) {\n    if (this.radius <= 0) {\n      return false;\n    }\n    var r2 = this.radius * this.radius;\n    var dx = this.x - x2;\n    var dy = this.y - y2;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  };\n  Circle2.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  };\n  Circle2.prototype.toString = function() {\n    return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n  };\n  return Circle2;\n}();\nvar Ellipse = function() {\n  function Ellipse2(x2, y2, halfWidth, halfHeight) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (halfWidth === void 0) {\n      halfWidth = 0;\n    }\n    if (halfHeight === void 0) {\n      halfHeight = 0;\n    }\n    this.x = x2;\n    this.y = y2;\n    this.width = halfWidth;\n    this.height = halfHeight;\n    this.type = SHAPES.ELIP;\n  }\n  Ellipse2.prototype.clone = function() {\n    return new Ellipse2(this.x, this.y, this.width, this.height);\n  };\n  Ellipse2.prototype.contains = function(x2, y2) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    var normx = (x2 - this.x) / this.width;\n    var normy = (y2 - this.y) / this.height;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  };\n  Ellipse2.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  };\n  Ellipse2.prototype.toString = function() {\n    return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  };\n  return Ellipse2;\n}();\nvar Polygon = function() {\n  function Polygon2() {\n    var arguments$1 = arguments;\n    var points = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      points[_i] = arguments$1[_i];\n    }\n    var flat2 = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat2[0] !== \"number\") {\n      var p2 = [];\n      for (var i2 = 0, il = flat2.length; i2 < il; i2++) {\n        p2.push(flat2[i2].x, flat2[i2].y);\n      }\n      flat2 = p2;\n    }\n    this.points = flat2;\n    this.type = SHAPES.POLY;\n    this.closeStroke = true;\n  }\n  Polygon2.prototype.clone = function() {\n    var points = this.points.slice();\n    var polygon = new Polygon2(points);\n    polygon.closeStroke = this.closeStroke;\n    return polygon;\n  };\n  Polygon2.prototype.contains = function(x2, y2) {\n    var inside = false;\n    var length2 = this.points.length / 2;\n    for (var i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {\n      var xi = this.points[i2 * 2];\n      var yi = this.points[i2 * 2 + 1];\n      var xj = this.points[j2 * 2];\n      var yj = this.points[j2 * 2 + 1];\n      var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  };\n  Polygon2.prototype.toString = function() {\n    return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(pointsDesc, currentPoint) {\n      return pointsDesc + \", \" + currentPoint;\n    }, \"\") + \"]\");\n  };\n  return Polygon2;\n}();\nvar RoundedRectangle = function() {\n  function RoundedRectangle2(x2, y2, width, height, radius) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (width === void 0) {\n      width = 0;\n    }\n    if (height === void 0) {\n      height = 0;\n    }\n    if (radius === void 0) {\n      radius = 20;\n    }\n    this.x = x2;\n    this.y = y2;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n    this.type = SHAPES.RREC;\n  }\n  RoundedRectangle2.prototype.clone = function() {\n    return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);\n  };\n  RoundedRectangle2.prototype.contains = function(x2, y2) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x2 >= this.x && x2 <= this.x + this.width) {\n      if (y2 >= this.y && y2 <= this.y + this.height) {\n        var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {\n          return true;\n        }\n        var dx = x2 - (this.x + radius);\n        var dy = y2 - (this.y + radius);\n        var radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x2 - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y2 - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x2 - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  RoundedRectangle2.prototype.toString = function() {\n    return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n  };\n  return RoundedRectangle2;\n}();\nvar ObservablePoint = function() {\n  function ObservablePoint2(cb, scope, x2, y2) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    this._x = x2;\n    this._y = y2;\n    this.cb = cb;\n    this.scope = scope;\n  }\n  ObservablePoint2.prototype.clone = function(cb, scope) {\n    if (cb === void 0) {\n      cb = this.cb;\n    }\n    if (scope === void 0) {\n      scope = this.scope;\n    }\n    return new ObservablePoint2(cb, scope, this._x, this._y);\n  };\n  ObservablePoint2.prototype.set = function(x2, y2) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = x2;\n    }\n    if (this._x !== x2 || this._y !== y2) {\n      this._x = x2;\n      this._y = y2;\n      this.cb.call(this.scope);\n    }\n    return this;\n  };\n  ObservablePoint2.prototype.copyFrom = function(p2) {\n    if (this._x !== p2.x || this._y !== p2.y) {\n      this._x = p2.x;\n      this._y = p2.y;\n      this.cb.call(this.scope);\n    }\n    return this;\n  };\n  ObservablePoint2.prototype.copyTo = function(p2) {\n    p2.set(this._x, this._y);\n    return p2;\n  };\n  ObservablePoint2.prototype.equals = function(p2) {\n    return p2.x === this._x && p2.y === this._y;\n  };\n  ObservablePoint2.prototype.toString = function() {\n    return \"[@pixi/math:ObservablePoint x=\" + 0 + \" y=\" + 0 + \" scope=\" + this.scope + \"]\";\n  };\n  Object.defineProperty(ObservablePoint2.prototype, \"x\", {\n    get: function() {\n      return this._x;\n    },\n    set: function(value2) {\n      if (this._x !== value2) {\n        this._x = value2;\n        this.cb.call(this.scope);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ObservablePoint2.prototype, \"y\", {\n    get: function() {\n      return this._y;\n    },\n    set: function(value2) {\n      if (this._y !== value2) {\n        this._y = value2;\n        this.cb.call(this.scope);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ObservablePoint2;\n}();\nvar Matrix = function() {\n  function Matrix2(a2, b2, c2, d2, tx, ty) {\n    if (a2 === void 0) {\n      a2 = 1;\n    }\n    if (b2 === void 0) {\n      b2 = 0;\n    }\n    if (c2 === void 0) {\n      c2 = 0;\n    }\n    if (d2 === void 0) {\n      d2 = 1;\n    }\n    if (tx === void 0) {\n      tx = 0;\n    }\n    if (ty === void 0) {\n      ty = 0;\n    }\n    this.array = null;\n    this.a = a2;\n    this.b = b2;\n    this.c = c2;\n    this.d = d2;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  Matrix2.prototype.fromArray = function(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  };\n  Matrix2.prototype.set = function(a2, b2, c2, d2, tx, ty) {\n    this.a = a2;\n    this.b = b2;\n    this.c = c2;\n    this.d = d2;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  };\n  Matrix2.prototype.toArray = function(transpose2, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    var array = out || this.array;\n    if (transpose2) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  };\n  Matrix2.prototype.apply = function(pos, newPos) {\n    newPos = newPos || new Point();\n    var x2 = pos.x;\n    var y2 = pos.y;\n    newPos.x = this.a * x2 + this.c * y2 + this.tx;\n    newPos.y = this.b * x2 + this.d * y2 + this.ty;\n    return newPos;\n  };\n  Matrix2.prototype.applyInverse = function(pos, newPos) {\n    newPos = newPos || new Point();\n    var id = 1 / (this.a * this.d + this.c * -this.b);\n    var x2 = pos.x;\n    var y2 = pos.y;\n    newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;\n    return newPos;\n  };\n  Matrix2.prototype.translate = function(x2, y2) {\n    this.tx += x2;\n    this.ty += y2;\n    return this;\n  };\n  Matrix2.prototype.scale = function(x2, y2) {\n    this.a *= x2;\n    this.d *= y2;\n    this.c *= x2;\n    this.b *= y2;\n    this.tx *= x2;\n    this.ty *= y2;\n    return this;\n  };\n  Matrix2.prototype.rotate = function(angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var a1 = this.a;\n    var c1 = this.c;\n    var tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  };\n  Matrix2.prototype.append = function(matrix) {\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  };\n  Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x2 - (pivotX * this.a + pivotY * this.c);\n    this.ty = y2 - (pivotX * this.b + pivotY * this.d);\n    return this;\n  };\n  Matrix2.prototype.prepend = function(matrix) {\n    var tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      var a1 = this.a;\n      var c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  };\n  Matrix2.prototype.decompose = function(transform) {\n    var a2 = this.a;\n    var b2 = this.b;\n    var c2 = this.c;\n    var d2 = this.d;\n    var pivot = transform.pivot;\n    var skewX = -Math.atan2(-c2, d2);\n    var skewY = Math.atan2(b2, a2);\n    var delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);\n    transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);\n    transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);\n    transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);\n    return transform;\n  };\n  Matrix2.prototype.invert = function() {\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n    var tx1 = this.tx;\n    var n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  };\n  Matrix2.prototype.identity = function() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  };\n  Matrix2.prototype.clone = function() {\n    var matrix = new Matrix2();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  };\n  Matrix2.prototype.copyTo = function(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  };\n  Matrix2.prototype.copyFrom = function(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  };\n  Matrix2.prototype.toString = function() {\n    return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n  };\n  Object.defineProperty(Matrix2, \"IDENTITY\", {\n    get: function() {\n      return new Matrix2();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Matrix2, \"TEMP_MATRIX\", {\n    get: function() {\n      return new Matrix2();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Matrix2;\n}();\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nvar rotationCayley = [];\nvar rotationMatrices = [];\nvar signum = Math.sign;\nfunction init() {\n  for (var i2 = 0; i2 < 16; i2++) {\n    var row = [];\n    rotationCayley.push(row);\n    for (var j2 = 0; j2 < 16; j2++) {\n      var _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);\n      var _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);\n      var _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);\n      var _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);\n      for (var k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (var i2 = 0; i2 < 16; i2++) {\n    var mat = new Matrix();\n    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nvar groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: function(ind) {\n    return ux[ind];\n  },\n  uY: function(ind) {\n    return uy[ind];\n  },\n  vX: function(ind) {\n    return vx[ind];\n  },\n  vY: function(ind) {\n    return vy[ind];\n  },\n  inv: function(rotation) {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  add: function(rotationSecond, rotationFirst) {\n    return rotationCayley[rotationSecond][rotationFirst];\n  },\n  sub: function(rotationSecond, rotationFirst) {\n    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];\n  },\n  rotate180: function(rotation) {\n    return rotation ^ 4;\n  },\n  isVertical: function(rotation) {\n    return (rotation & 3) === 2;\n  },\n  byDirection: function(dx, dy) {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {\n    if (tx === void 0) {\n      tx = 0;\n    }\n    if (ty === void 0) {\n      ty = 0;\n    }\n    var mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\nvar Transform = function() {\n  function Transform2() {\n    this.worldTransform = new Matrix();\n    this.localTransform = new Matrix();\n    this.position = new ObservablePoint(this.onChange, this, 0, 0);\n    this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n    this._rotation = 0;\n    this._cx = 1;\n    this._sx = 0;\n    this._cy = 0;\n    this._sy = 1;\n    this._localID = 0;\n    this._currentLocalID = 0;\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n  Transform2.prototype.onChange = function() {\n    this._localID++;\n  };\n  Transform2.prototype.updateSkew = function() {\n    this._cx = Math.cos(this._rotation + this.skew.y);\n    this._sx = Math.sin(this._rotation + this.skew.y);\n    this._cy = -Math.sin(this._rotation - this.skew.x);\n    this._sy = Math.cos(this._rotation - this.skew.x);\n    this._localID++;\n  };\n  Transform2.prototype.toString = function() {\n    return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n  };\n  Transform2.prototype.updateLocalTransform = function() {\n    var lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n  };\n  Transform2.prototype.updateTransform = function(parentTransform) {\n    var lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n    if (this._parentID !== parentTransform._worldID) {\n      var pt = parentTransform.worldTransform;\n      var wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c;\n      wt.b = lt.a * pt.b + lt.b * pt.d;\n      wt.c = lt.c * pt.a + lt.d * pt.c;\n      wt.d = lt.c * pt.b + lt.d * pt.d;\n      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n      this._parentID = parentTransform._worldID;\n      this._worldID++;\n    }\n  };\n  Transform2.prototype.setFromMatrix = function(matrix) {\n    matrix.decompose(this);\n    this._localID++;\n  };\n  Object.defineProperty(Transform2.prototype, \"rotation\", {\n    get: function() {\n      return this._rotation;\n    },\n    set: function(value2) {\n      if (this._rotation !== value2) {\n        this._rotation = value2;\n        this.updateSkew();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Transform2.IDENTITY = new Transform2();\n  return Transform2;\n}();\n/*!\n * @pixi/core - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/core is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.PREFER_ENV = isMobile.any ? ENV$3.WEBGL : ENV$3.WEBGL2;\nsettings.STRICT_TEXTURE_CACHE = false;\nvar INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source) {\n    return null;\n  }\n  var extension = \"\";\n  if (typeof source === \"string\") {\n    var result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    if (result) {\n      extension = result[1].toLowerCase();\n    }\n  }\n  for (var i2 = INSTALLED.length - 1; i2 >= 0; --i2) {\n    var ResourcePlugin = INSTALLED[i2];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {\n      return new ResourcePlugin(source, options);\n    }\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$q = function(d2, b2) {\n  extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$q(d2, b2);\n};\nfunction __extends$q(d2, b2) {\n  extendStatics$q(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$8 = function() {\n  __assign$8 = Object.assign || function __assign2(t) {\n    var arguments$1 = arguments;\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments$1[i2];\n      for (var p2 in s2) {\n        if (Object.prototype.hasOwnProperty.call(s2, p2)) {\n          t[p2] = s2[p2];\n        }\n      }\n    }\n    return t;\n  };\n  return __assign$8.apply(this, arguments);\n};\nfunction __rest$3(s2, e) {\n  var t = {};\n  for (var p2 in s2) {\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0) {\n      t[p2] = s2[p2];\n    }\n  }\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\") {\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e.indexOf(p2[i2]) < 0) {\n        t[p2[i2]] = s2[p2[i2]];\n      }\n    }\n  }\n  return t;\n}\nvar Resource = function() {\n  function Resource2(width, height) {\n    if (width === void 0) {\n      width = 0;\n    }\n    if (height === void 0) {\n      height = 0;\n    }\n    this._width = width;\n    this._height = height;\n    this.destroyed = false;\n    this.internal = false;\n    this.onResize = new Runner(\"setRealSize\");\n    this.onUpdate = new Runner(\"update\");\n    this.onError = new Runner(\"onError\");\n  }\n  Resource2.prototype.bind = function(baseTexture) {\n    this.onResize.add(baseTexture);\n    this.onUpdate.add(baseTexture);\n    this.onError.add(baseTexture);\n    if (this._width || this._height) {\n      this.onResize.emit(this._width, this._height);\n    }\n  };\n  Resource2.prototype.unbind = function(baseTexture) {\n    this.onResize.remove(baseTexture);\n    this.onUpdate.remove(baseTexture);\n    this.onError.remove(baseTexture);\n  };\n  Resource2.prototype.resize = function(width, height) {\n    if (width !== this._width || height !== this._height) {\n      this._width = width;\n      this._height = height;\n      this.onResize.emit(width, height);\n    }\n  };\n  Object.defineProperty(Resource2.prototype, \"valid\", {\n    get: function() {\n      return !!this._width && !!this._height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Resource2.prototype.update = function() {\n    if (!this.destroyed) {\n      this.onUpdate.emit();\n    }\n  };\n  Resource2.prototype.load = function() {\n    return Promise.resolve(this);\n  };\n  Object.defineProperty(Resource2.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Resource2.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {\n    return false;\n  };\n  Resource2.prototype.dispose = function() {\n  };\n  Resource2.prototype.destroy = function() {\n    if (!this.destroyed) {\n      this.destroyed = true;\n      this.dispose();\n      this.onError.removeAll();\n      this.onError = null;\n      this.onResize.removeAll();\n      this.onResize = null;\n      this.onUpdate.removeAll();\n      this.onUpdate = null;\n    }\n  };\n  Resource2.test = function(_source, _extension) {\n    return false;\n  };\n  return Resource2;\n}();\nvar BufferResource = function(_super) {\n  __extends$q(BufferResource2, _super);\n  function BufferResource2(source, options) {\n    var _this = this;\n    var _a3 = options || {}, width = _a3.width, height = _a3.height;\n    if (!width || !height) {\n      throw new Error(\"BufferResource width or height invalid\");\n    }\n    _this = _super.call(this, width, height) || this;\n    _this.data = source;\n    return _this;\n  }\n  BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {\n    var gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);\n    var width = baseTexture.realWidth;\n    var height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  };\n  BufferResource2.prototype.dispose = function() {\n    this.data = null;\n  };\n  BufferResource2.test = function(source) {\n    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;\n  };\n  return BufferResource2;\n}(Resource);\nvar defaultBufferOptions = {\n  scaleMode: SCALE_MODES$3.NEAREST,\n  format: FORMATS$3.RGBA,\n  alphaMode: ALPHA_MODES$3.NPM\n};\nvar BaseTexture = function(_super) {\n  __extends$q(BaseTexture2, _super);\n  function BaseTexture2(resource, options) {\n    if (resource === void 0) {\n      resource = null;\n    }\n    if (options === void 0) {\n      options = null;\n    }\n    var _this = _super.call(this) || this;\n    options = options || {};\n    var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;\n    if (resource && !(resource instanceof Resource)) {\n      resource = autoDetectResource(resource, resourceOptions);\n      resource.internal = true;\n    }\n    _this.resolution = resolution || settings.RESOLUTION;\n    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;\n    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;\n    _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;\n    _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;\n    _this._wrapMode = wrapMode || settings.WRAP_MODE;\n    _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;\n    _this.format = format2 || FORMATS$3.RGBA;\n    _this.type = type || TYPES$3.UNSIGNED_BYTE;\n    _this.target = target || TARGETS$3.TEXTURE_2D;\n    _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$3.UNPACK;\n    _this.uid = uid();\n    _this.touched = 0;\n    _this.isPowerOfTwo = false;\n    _this._refreshPOT();\n    _this._glTextures = {};\n    _this.dirtyId = 0;\n    _this.dirtyStyleId = 0;\n    _this.cacheId = null;\n    _this.valid = width > 0 && height > 0;\n    _this.textureCacheIds = [];\n    _this.destroyed = false;\n    _this.resource = null;\n    _this._batchEnabled = 0;\n    _this._batchLocation = 0;\n    _this.parentTextureArray = null;\n    _this.setResource(resource);\n    return _this;\n  }\n  Object.defineProperty(BaseTexture2.prototype, \"realWidth\", {\n    get: function() {\n      return Math.round(this.width * this.resolution);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture2.prototype, \"realHeight\", {\n    get: function() {\n      return Math.round(this.height * this.resolution);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture2.prototype, \"mipmap\", {\n    get: function() {\n      return this._mipmap;\n    },\n    set: function(value2) {\n      if (this._mipmap !== value2) {\n        this._mipmap = value2;\n        this.dirtyStyleId++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture2.prototype, \"scaleMode\", {\n    get: function() {\n      return this._scaleMode;\n    },\n    set: function(value2) {\n      if (this._scaleMode !== value2) {\n        this._scaleMode = value2;\n        this.dirtyStyleId++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture2.prototype, \"wrapMode\", {\n    get: function() {\n      return this._wrapMode;\n    },\n    set: function(value2) {\n      if (this._wrapMode !== value2) {\n        this._wrapMode = value2;\n        this.dirtyStyleId++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {\n    var dirty;\n    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {\n      this.scaleMode = scaleMode;\n      dirty = true;\n    }\n    if (mipmap !== void 0 && mipmap !== this.mipmap) {\n      this.mipmap = mipmap;\n      dirty = true;\n    }\n    if (dirty) {\n      this.dirtyStyleId++;\n    }\n    return this;\n  };\n  BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {\n    resolution = resolution || this.resolution;\n    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  };\n  BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {\n    this.resolution = resolution || this.resolution;\n    this.width = Math.round(realWidth) / this.resolution;\n    this.height = Math.round(realHeight) / this.resolution;\n    this._refreshPOT();\n    this.update();\n    return this;\n  };\n  BaseTexture2.prototype._refreshPOT = function() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  };\n  BaseTexture2.prototype.setResolution = function(resolution) {\n    var oldResolution = this.resolution;\n    if (oldResolution === resolution) {\n      return this;\n    }\n    this.resolution = resolution;\n    if (this.valid) {\n      this.width = Math.round(this.width * oldResolution) / resolution;\n      this.height = Math.round(this.height * oldResolution) / resolution;\n      this.emit(\"update\", this);\n    }\n    this._refreshPOT();\n    return this;\n  };\n  BaseTexture2.prototype.setResource = function(resource) {\n    if (this.resource === resource) {\n      return this;\n    }\n    if (this.resource) {\n      throw new Error(\"Resource can be set only once\");\n    }\n    resource.bind(this);\n    this.resource = resource;\n    return this;\n  };\n  BaseTexture2.prototype.update = function() {\n    if (!this.valid) {\n      if (this.width > 0 && this.height > 0) {\n        this.valid = true;\n        this.emit(\"loaded\", this);\n        this.emit(\"update\", this);\n      }\n    } else {\n      this.dirtyId++;\n      this.dirtyStyleId++;\n      this.emit(\"update\", this);\n    }\n  };\n  BaseTexture2.prototype.onError = function(event) {\n    this.emit(\"error\", this, event);\n  };\n  BaseTexture2.prototype.destroy = function() {\n    if (this.resource) {\n      this.resource.unbind(this);\n      if (this.resource.internal) {\n        this.resource.destroy();\n      }\n      this.resource = null;\n    }\n    if (this.cacheId) {\n      delete BaseTextureCache[this.cacheId];\n      delete TextureCache[this.cacheId];\n      this.cacheId = null;\n    }\n    this.dispose();\n    BaseTexture2.removeFromCache(this);\n    this.textureCacheIds = null;\n    this.destroyed = true;\n  };\n  BaseTexture2.prototype.dispose = function() {\n    this.emit(\"dispose\", this);\n  };\n  BaseTexture2.prototype.castToBaseTexture = function() {\n    return this;\n  };\n  BaseTexture2.from = function(source, options, strict) {\n    if (strict === void 0) {\n      strict = settings.STRICT_TEXTURE_CACHE;\n    }\n    var isFrame = typeof source === \"string\";\n    var cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else {\n      if (!source._pixiId) {\n        var prefix2 = options && options.pixiIdPrefix || \"pixiid\";\n        source._pixiId = prefix2 + \"_\" + uid();\n      }\n      cacheId = source._pixiId;\n    }\n    var baseTexture = BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture) {\n      throw new Error('The cacheId \"' + cacheId + '\" does not exist in BaseTextureCache.');\n    }\n    if (!baseTexture) {\n      baseTexture = new BaseTexture2(source, options);\n      baseTexture.cacheId = cacheId;\n      BaseTexture2.addToCache(baseTexture, cacheId);\n    }\n    return baseTexture;\n  };\n  BaseTexture2.fromBuffer = function(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    var resource = new BufferResource(buffer, { width, height });\n    var type = buffer instanceof Float32Array ? TYPES$3.FLOAT : TYPES$3.UNSIGNED_BYTE;\n    return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width, height, type }));\n  };\n  BaseTexture2.addToCache = function(baseTexture, id) {\n    if (id) {\n      if (baseTexture.textureCacheIds.indexOf(id) === -1) {\n        baseTexture.textureCacheIds.push(id);\n      }\n      if (BaseTextureCache[id]) {\n        console.warn(\"BaseTexture added to the cache with an id [\" + id + \"] that already had an entry\");\n      }\n      BaseTextureCache[id] = baseTexture;\n    }\n  };\n  BaseTexture2.removeFromCache = function(baseTexture) {\n    if (typeof baseTexture === \"string\") {\n      var baseTextureFromCache = BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        if (index > -1) {\n          baseTextureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete BaseTextureCache[baseTexture];\n        return baseTextureFromCache;\n      }\n    } else if (baseTexture && baseTexture.textureCacheIds) {\n      for (var i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {\n        delete BaseTextureCache[baseTexture.textureCacheIds[i2]];\n      }\n      baseTexture.textureCacheIds.length = 0;\n      return baseTexture;\n    }\n    return null;\n  };\n  BaseTexture2._globalBatch = 0;\n  return BaseTexture2;\n}(EventEmitter$4);\nvar AbstractMultiResource = function(_super) {\n  __extends$q(AbstractMultiResource2, _super);\n  function AbstractMultiResource2(length2, options) {\n    var _this = this;\n    var _a3 = options || {}, width = _a3.width, height = _a3.height;\n    _this = _super.call(this, width, height) || this;\n    _this.items = [];\n    _this.itemDirtyIds = [];\n    for (var i2 = 0; i2 < length2; i2++) {\n      var partTexture = new BaseTexture();\n      _this.items.push(partTexture);\n      _this.itemDirtyIds.push(-2);\n    }\n    _this.length = length2;\n    _this._load = null;\n    _this.baseTexture = null;\n    return _this;\n  }\n  AbstractMultiResource2.prototype.initFromArray = function(resources, options) {\n    for (var i2 = 0; i2 < this.length; i2++) {\n      if (!resources[i2]) {\n        continue;\n      }\n      if (resources[i2].castToBaseTexture) {\n        this.addBaseTextureAt(resources[i2].castToBaseTexture(), i2);\n      } else if (resources[i2] instanceof Resource) {\n        this.addResourceAt(resources[i2], i2);\n      } else {\n        this.addResourceAt(autoDetectResource(resources[i2], options), i2);\n      }\n    }\n  };\n  AbstractMultiResource2.prototype.dispose = function() {\n    for (var i2 = 0, len = this.length; i2 < len; i2++) {\n      this.items[i2].destroy();\n    }\n    this.items = null;\n    this.itemDirtyIds = null;\n    this._load = null;\n  };\n  AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {\n    if (!this.items[index]) {\n      throw new Error(\"Index \" + index + \" is out of bounds\");\n    }\n    if (resource.valid && !this.valid) {\n      this.resize(resource.width, resource.height);\n    }\n    this.items[index].setResource(resource);\n    return this;\n  };\n  AbstractMultiResource2.prototype.bind = function(baseTexture) {\n    if (this.baseTexture !== null) {\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    }\n    _super.prototype.bind.call(this, baseTexture);\n    for (var i2 = 0; i2 < this.length; i2++) {\n      this.items[i2].parentTextureArray = baseTexture;\n      this.items[i2].on(\"update\", baseTexture.update, baseTexture);\n    }\n  };\n  AbstractMultiResource2.prototype.unbind = function(baseTexture) {\n    _super.prototype.unbind.call(this, baseTexture);\n    for (var i2 = 0; i2 < this.length; i2++) {\n      this.items[i2].parentTextureArray = null;\n      this.items[i2].off(\"update\", baseTexture.update, baseTexture);\n    }\n  };\n  AbstractMultiResource2.prototype.load = function() {\n    var _this = this;\n    if (this._load) {\n      return this._load;\n    }\n    var resources = this.items.map(function(item) {\n      return item.resource;\n    }).filter(function(item) {\n      return item;\n    });\n    var promises = resources.map(function(item) {\n      return item.load();\n    });\n    this._load = Promise.all(promises).then(function() {\n      var _a3 = _this.items[0], realWidth = _a3.realWidth, realHeight = _a3.realHeight;\n      _this.resize(realWidth, realHeight);\n      return Promise.resolve(_this);\n    });\n    return this._load;\n  };\n  return AbstractMultiResource2;\n}(Resource);\nvar ArrayResource = function(_super) {\n  __extends$q(ArrayResource2, _super);\n  function ArrayResource2(source, options) {\n    var _this = this;\n    var _a3 = options || {}, width = _a3.width, height = _a3.height;\n    var urls;\n    var length2;\n    if (Array.isArray(source)) {\n      urls = source;\n      length2 = source.length;\n    } else {\n      length2 = source;\n    }\n    _this = _super.call(this, length2, { width, height }) || this;\n    if (urls) {\n      _this.initFromArray(urls, options);\n    }\n    return _this;\n  }\n  ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {\n    if (baseTexture.resource) {\n      this.addResourceAt(baseTexture.resource, index);\n    } else {\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    }\n    return this;\n  };\n  ArrayResource2.prototype.bind = function(baseTexture) {\n    _super.prototype.bind.call(this, baseTexture);\n    baseTexture.target = TARGETS$3.TEXTURE_2D_ARRAY;\n  };\n  ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {\n    var _a3 = this, length2 = _a3.length, itemDirtyIds = _a3.itemDirtyIds, items = _a3.items;\n    var gl = renderer.gl;\n    if (glTexture.dirtyId < 0) {\n      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length2, 0, texture.format, glTexture.type, null);\n    }\n    for (var i2 = 0; i2 < length2; i2++) {\n      var item = items[i2];\n      if (itemDirtyIds[i2] < item.dirtyId) {\n        itemDirtyIds[i2] = item.dirtyId;\n        if (item.valid) {\n          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i2, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);\n        }\n      }\n    }\n    return true;\n  };\n  return ArrayResource2;\n}(AbstractMultiResource);\nvar BaseImageResource = function(_super) {\n  __extends$q(BaseImageResource2, _super);\n  function BaseImageResource2(source) {\n    var _this = this;\n    var sourceAny = source;\n    var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;\n    var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n    _this = _super.call(this, width, height) || this;\n    _this.source = source;\n    _this.noSubImage = false;\n    return _this;\n  }\n  BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {\n    if (crossorigin === void 0 && url2.indexOf(\"data:\") !== 0) {\n      element.crossOrigin = determineCrossOrigin(url2);\n    } else if (crossorigin !== false) {\n      element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n    }\n  };\n  BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {\n    var gl = renderer.gl;\n    var width = baseTexture.realWidth;\n    var height = baseTexture.realHeight;\n    source = source || this.source;\n    if (source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0) {\n        return false;\n      }\n    } else if (source instanceof HTMLVideoElement) {\n      if (source.readyState <= 1) {\n        return false;\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);\n    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n    }\n    return true;\n  };\n  BaseImageResource2.prototype.update = function() {\n    if (this.destroyed) {\n      return;\n    }\n    var source = this.source;\n    var width = source.naturalWidth || source.videoWidth || source.width;\n    var height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height);\n    _super.prototype.update.call(this);\n  };\n  BaseImageResource2.prototype.dispose = function() {\n    this.source = null;\n  };\n  return BaseImageResource2;\n}(Resource);\nvar CanvasResource = function(_super) {\n  __extends$q(CanvasResource2, _super);\n  function CanvasResource2(source) {\n    return _super.call(this, source) || this;\n  }\n  CanvasResource2.test = function(source) {\n    var OffscreenCanvas2 = globalThis.OffscreenCanvas;\n    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {\n      return true;\n    }\n    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;\n  };\n  return CanvasResource2;\n}(BaseImageResource);\nvar CubeResource = function(_super) {\n  __extends$q(CubeResource2, _super);\n  function CubeResource2(source, options) {\n    var _this = this;\n    var _a3 = options || {}, width = _a3.width, height = _a3.height, autoLoad = _a3.autoLoad, linkBaseTexture = _a3.linkBaseTexture;\n    if (source && source.length !== CubeResource2.SIDES) {\n      throw new Error(\"Invalid length. Got \" + source.length + \", expected 6\");\n    }\n    _this = _super.call(this, 6, { width, height }) || this;\n    for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {\n      _this.items[i2].target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + i2;\n    }\n    _this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      _this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  CubeResource2.prototype.bind = function(baseTexture) {\n    _super.prototype.bind.call(this, baseTexture);\n    baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP;\n  };\n  CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {\n    if (!this.items[index]) {\n      throw new Error(\"Index \" + index + \" is out of bounds\");\n    }\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n      }\n    } else {\n      baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n      baseTexture.parentTextureArray = this.baseTexture;\n      this.items[index] = baseTexture;\n    }\n    if (baseTexture.valid && !this.valid) {\n      this.resize(baseTexture.realWidth, baseTexture.realHeight);\n    }\n    this.items[index] = baseTexture;\n    return this;\n  };\n  CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {\n    var dirty = this.itemDirtyIds;\n    for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {\n      var side = this.items[i2];\n      if (dirty[i2] < side.dirtyId) {\n        if (side.valid && side.resource) {\n          side.resource.upload(renderer, side, glTexture);\n          dirty[i2] = side.dirtyId;\n        } else if (dirty[i2] < -1) {\n          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n          dirty[i2] = -1;\n        }\n      }\n    }\n    return true;\n  };\n  CubeResource2.test = function(source) {\n    return Array.isArray(source) && source.length === CubeResource2.SIDES;\n  };\n  CubeResource2.SIDES = 6;\n  return CubeResource2;\n}(AbstractMultiResource);\nvar ImageResource = function(_super) {\n  __extends$q(ImageResource2, _super);\n  function ImageResource2(source, options) {\n    var _this = this;\n    options = options || {};\n    if (!(source instanceof HTMLImageElement)) {\n      var imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    _this = _super.call(this, source) || this;\n    if (!source.complete && !!_this._width && !!_this._height) {\n      _this._width = 0;\n      _this._height = 0;\n    }\n    _this.url = source.src;\n    _this._process = null;\n    _this.preserveBitmap = false;\n    _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    _this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    _this.bitmap = null;\n    _this._load = null;\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  ImageResource2.prototype.load = function(createBitmap) {\n    var _this = this;\n    if (this._load) {\n      return this._load;\n    }\n    if (createBitmap !== void 0) {\n      this.createBitmap = createBitmap;\n    }\n    this._load = new Promise(function(resolve2, reject2) {\n      var source = _this.source;\n      _this.url = source.src;\n      var completed = function() {\n        if (_this.destroyed) {\n          return;\n        }\n        source.onload = null;\n        source.onerror = null;\n        _this.resize(source.width, source.height);\n        _this._load = null;\n        if (_this.createBitmap) {\n          resolve2(_this.process());\n        } else {\n          resolve2(_this);\n        }\n      };\n      if (source.complete && source.src) {\n        completed();\n      } else {\n        source.onload = completed;\n        source.onerror = function(event) {\n          reject2(event);\n          _this.onError.emit(event);\n        };\n      }\n    });\n    return this._load;\n  };\n  ImageResource2.prototype.process = function() {\n    var _this = this;\n    var source = this.source;\n    if (this._process !== null) {\n      return this._process;\n    }\n    if (this.bitmap !== null || !globalThis.createImageBitmap) {\n      return Promise.resolve(this);\n    }\n    var createImageBitmap = globalThis.createImageBitmap;\n    var cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n    this._process = fetch(source.src, {\n      mode: cors ? \"cors\" : \"no-cors\"\n    }).then(function(r2) {\n      return r2.blob();\n    }).then(function(blob) {\n      return createImageBitmap(blob, 0, 0, source.width, source.height, {\n        premultiplyAlpha: _this.alphaMode === ALPHA_MODES$3.UNPACK ? \"premultiply\" : \"none\"\n      });\n    }).then(function(bitmap) {\n      if (_this.destroyed) {\n        return Promise.reject();\n      }\n      _this.bitmap = bitmap;\n      _this.update();\n      _this._process = null;\n      return Promise.resolve(_this);\n    });\n    return this._process;\n  };\n  ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode === \"number\") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    if (!this.createBitmap) {\n      return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);\n    }\n    if (!this.bitmap) {\n      this.process();\n      if (!this.bitmap) {\n        return false;\n      }\n    }\n    _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);\n    if (!this.preserveBitmap) {\n      var flag = true;\n      var glTextures = baseTexture._glTextures;\n      for (var key in glTextures) {\n        var otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        if (this.bitmap.close) {\n          this.bitmap.close();\n        }\n        this.bitmap = null;\n      }\n    }\n    return true;\n  };\n  ImageResource2.prototype.dispose = function() {\n    this.source.onload = null;\n    this.source.onerror = null;\n    _super.prototype.dispose.call(this);\n    if (this.bitmap) {\n      this.bitmap.close();\n      this.bitmap = null;\n    }\n    this._process = null;\n    this._load = null;\n  };\n  ImageResource2.test = function(source) {\n    return typeof source === \"string\" || source instanceof HTMLImageElement;\n  };\n  return ImageResource2;\n}(BaseImageResource);\nvar SVGResource = function(_super) {\n  __extends$q(SVGResource2, _super);\n  function SVGResource2(sourceBase64, options) {\n    var _this = this;\n    options = options || {};\n    _this = _super.call(this, document.createElement(\"canvas\")) || this;\n    _this._width = 0;\n    _this._height = 0;\n    _this.svg = sourceBase64;\n    _this.scale = options.scale || 1;\n    _this._overrideWidth = options.width;\n    _this._overrideHeight = options.height;\n    _this._resolve = null;\n    _this._crossorigin = options.crossorigin;\n    _this._load = null;\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  SVGResource2.prototype.load = function() {\n    var _this = this;\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(function(resolve2) {\n      _this._resolve = function() {\n        _this.resize(_this.source.width, _this.source.height);\n        resolve2(_this);\n      };\n      if (SVGResource2.SVG_XML.test(_this.svg.trim())) {\n        if (!btoa) {\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        }\n        _this.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(_this.svg)));\n      }\n      _this._loadSvg();\n    });\n    return this._load;\n  };\n  SVGResource2.prototype._loadSvg = function() {\n    var _this = this;\n    var tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n    tempImage.src = this.svg;\n    tempImage.onerror = function(event) {\n      if (!_this._resolve) {\n        return;\n      }\n      tempImage.onerror = null;\n      _this.onError.emit(event);\n    };\n    tempImage.onload = function() {\n      if (!_this._resolve) {\n        return;\n      }\n      var svgWidth = tempImage.width;\n      var svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) {\n        throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n      }\n      var width = svgWidth * _this.scale;\n      var height = svgHeight * _this.scale;\n      if (_this._overrideWidth || _this._overrideHeight) {\n        width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;\n        height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;\n      }\n      width = Math.round(width);\n      height = Math.round(height);\n      var canvas = _this.source;\n      canvas.width = width;\n      canvas.height = height;\n      canvas._pixiId = \"canvas_\" + uid();\n      canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n      _this._resolve();\n      _this._resolve = null;\n    };\n  };\n  SVGResource2.getSize = function(svgString) {\n    var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);\n    var size = {};\n    if (sizeMatch) {\n      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n    }\n    return size;\n  };\n  SVGResource2.prototype.dispose = function() {\n    _super.prototype.dispose.call(this);\n    this._resolve = null;\n    this._crossorigin = null;\n  };\n  SVGResource2.test = function(source, extension) {\n    return extension === \"svg\" || typeof source === \"string\" && /^data:image\\/svg\\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === \"string\" && SVGResource2.SVG_XML.test(source);\n  };\n  SVGResource2.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\n  SVGResource2.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\n  return SVGResource2;\n}(BaseImageResource);\nvar VideoResource = function(_super) {\n  __extends$q(VideoResource2, _super);\n  function VideoResource2(source, options) {\n    var _this = this;\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      var videoElement = document.createElement(\"video\");\n      videoElement.setAttribute(\"preload\", \"auto\");\n      videoElement.setAttribute(\"webkit-playsinline\", \"\");\n      videoElement.setAttribute(\"playsinline\", \"\");\n      if (typeof source === \"string\") {\n        source = [source];\n      }\n      var firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (var i2 = 0; i2 < source.length; ++i2) {\n        var sourceElement = document.createElement(\"source\");\n        var _a3 = source[i2], src = _a3.src, mime = _a3.mime;\n        src = src || source[i2];\n        var baseSrc = src.split(\"?\").shift().toLowerCase();\n        var ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n        mime = mime || VideoResource2.MIME_TYPES[ext] || \"video/\" + ext;\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    _this = _super.call(this, source) || this;\n    _this.noSubImage = true;\n    _this._autoUpdate = true;\n    _this._isConnectedToTicker = false;\n    _this._updateFPS = options.updateFPS || 0;\n    _this._msToNextUpdate = 0;\n    _this.autoPlay = options.autoPlay !== false;\n    _this._load = null;\n    _this._resolve = null;\n    _this._onCanPlay = _this._onCanPlay.bind(_this);\n    _this._onError = _this._onError.bind(_this);\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  VideoResource2.prototype.update = function(_deltaTime) {\n    if (!this.destroyed) {\n      var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      if (!this._updateFPS || this._msToNextUpdate <= 0) {\n        _super.prototype.update.call(this);\n        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n      }\n    }\n  };\n  VideoResource2.prototype.load = function() {\n    var _this = this;\n    if (this._load) {\n      return this._load;\n    }\n    var source = this.source;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart.bind(this));\n    source.addEventListener(\"pause\", this._onPlayStop.bind(this));\n    if (!this._isSourceReady()) {\n      source.addEventListener(\"canplay\", this._onCanPlay);\n      source.addEventListener(\"canplaythrough\", this._onCanPlay);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._onCanPlay();\n    }\n    this._load = new Promise(function(resolve2) {\n      if (_this.valid) {\n        resolve2(_this);\n      } else {\n        _this._resolve = resolve2;\n        source.load();\n      }\n    });\n    return this._load;\n  };\n  VideoResource2.prototype._onError = function(event) {\n    this.source.removeEventListener(\"error\", this._onError, true);\n    this.onError.emit(event);\n  };\n  VideoResource2.prototype._isSourcePlaying = function() {\n    var source = this.source;\n    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;\n  };\n  VideoResource2.prototype._isSourceReady = function() {\n    var source = this.source;\n    return source.readyState === 3 || source.readyState === 4;\n  };\n  VideoResource2.prototype._onPlayStart = function() {\n    if (!this.valid) {\n      this._onCanPlay();\n    }\n    if (this.autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this);\n      this._isConnectedToTicker = true;\n    }\n  };\n  VideoResource2.prototype._onPlayStop = function() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  };\n  VideoResource2.prototype._onCanPlay = function() {\n    var source = this.source;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    var valid = this.valid;\n    this.resize(source.videoWidth, source.videoHeight);\n    if (!valid && this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      source.play();\n    }\n  };\n  VideoResource2.prototype.dispose = function() {\n    if (this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n    var source = this.source;\n    if (source) {\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    _super.prototype.dispose.call(this);\n  };\n  Object.defineProperty(VideoResource2.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(value2) {\n      if (value2 !== this._autoUpdate) {\n        this._autoUpdate = value2;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n          Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VideoResource2.prototype, \"updateFPS\", {\n    get: function() {\n      return this._updateFPS;\n    },\n    set: function(value2) {\n      if (value2 !== this._updateFPS) {\n        this._updateFPS = value2;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  VideoResource2.test = function(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;\n  };\n  VideoResource2.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"];\n  VideoResource2.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n  };\n  return VideoResource2;\n}(BaseImageResource);\nvar ImageBitmapResource = function(_super) {\n  __extends$q(ImageBitmapResource2, _super);\n  function ImageBitmapResource2(source) {\n    return _super.call(this, source) || this;\n  }\n  ImageBitmapResource2.test = function(source) {\n    return !!globalThis.createImageBitmap && source instanceof ImageBitmap;\n  };\n  return ImageBitmapResource2;\n}(BaseImageResource);\nINSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\nvar DepthResource = function(_super) {\n  __extends$q(DepthResource2, _super);\n  function DepthResource2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {\n    var gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);\n    var width = baseTexture.realWidth;\n    var height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  };\n  return DepthResource2;\n}(BufferResource);\nvar Framebuffer = function() {\n  function Framebuffer2(width, height) {\n    this.width = Math.round(width || 100);\n    this.height = Math.round(height || 100);\n    this.stencil = false;\n    this.depth = false;\n    this.dirtyId = 0;\n    this.dirtyFormat = 0;\n    this.dirtySize = 0;\n    this.depthTexture = null;\n    this.colorTextures = [];\n    this.glFramebuffers = {};\n    this.disposeRunner = new Runner(\"disposeFramebuffer\");\n    this.multisample = MSAA_QUALITY$3.NONE;\n  }\n  Object.defineProperty(Framebuffer2.prototype, \"colorTexture\", {\n    get: function() {\n      return this.colorTextures[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Framebuffer2.prototype.addColorTexture = function(index, texture) {\n    if (index === void 0) {\n      index = 0;\n    }\n    this.colorTextures[index] = texture || new BaseTexture(null, {\n      scaleMode: SCALE_MODES$3.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES$3.OFF,\n      width: this.width,\n      height: this.height\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  };\n  Framebuffer2.prototype.addDepthTexture = function(texture) {\n    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: SCALE_MODES$3.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES$3.OFF,\n      format: FORMATS$3.DEPTH_COMPONENT,\n      type: TYPES$3.UNSIGNED_SHORT\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  };\n  Framebuffer2.prototype.enableDepth = function() {\n    this.depth = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  };\n  Framebuffer2.prototype.enableStencil = function() {\n    this.stencil = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  };\n  Framebuffer2.prototype.resize = function(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width === this.width && height === this.height) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dirtyId++;\n    this.dirtySize++;\n    for (var i2 = 0; i2 < this.colorTextures.length; i2++) {\n      var texture = this.colorTextures[i2];\n      var resolution = texture.resolution;\n      texture.setSize(width / resolution, height / resolution);\n    }\n    if (this.depthTexture) {\n      var resolution = this.depthTexture.resolution;\n      this.depthTexture.setSize(width / resolution, height / resolution);\n    }\n  };\n  Framebuffer2.prototype.dispose = function() {\n    this.disposeRunner.emit(this, false);\n  };\n  Framebuffer2.prototype.destroyDepthTexture = function() {\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n      this.depthTexture = null;\n      ++this.dirtyId;\n      ++this.dirtyFormat;\n    }\n  };\n  return Framebuffer2;\n}();\nvar BaseRenderTexture = function(_super) {\n  __extends$q(BaseRenderTexture2, _super);\n  function BaseRenderTexture2(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = this;\n    if (typeof options === \"number\") {\n      var width = arguments[0];\n      var height = arguments[1];\n      var scaleMode = arguments[2];\n      var resolution = arguments[3];\n      options = { width, height, scaleMode, resolution };\n    }\n    options.width = options.width || 100;\n    options.height = options.height || 100;\n    options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY$3.NONE;\n    _this = _super.call(this, null, options) || this;\n    _this.mipmap = MIPMAP_MODES$3.OFF;\n    _this.valid = true;\n    _this.clearColor = [0, 0, 0, 0];\n    _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);\n    _this.framebuffer.multisample = options.multisample;\n    _this.maskStack = [];\n    _this.filterStack = [{}];\n    return _this;\n  }\n  BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {\n    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);\n    this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  };\n  BaseRenderTexture2.prototype.dispose = function() {\n    this.framebuffer.dispose();\n    _super.prototype.dispose.call(this);\n  };\n  BaseRenderTexture2.prototype.destroy = function() {\n    _super.prototype.destroy.call(this);\n    this.framebuffer.destroyDepthTexture();\n    this.framebuffer = null;\n  };\n  return BaseRenderTexture2;\n}(BaseTexture);\nvar TextureUvs = function() {\n  function TextureUvs2() {\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsFloat32 = new Float32Array(8);\n  }\n  TextureUvs2.prototype.set = function(frame, baseFrame, rotate2) {\n    var tw = baseFrame.width;\n    var th = baseFrame.height;\n    if (rotate2) {\n      var w2 = frame.width / 2 / tw;\n      var h2 = frame.height / 2 / th;\n      var cX = frame.x / tw + w2;\n      var cY = frame.y / th + h2;\n      rotate2 = groupD8.add(rotate2, groupD8.NW);\n      this.x0 = cX + w2 * groupD8.uX(rotate2);\n      this.y0 = cY + h2 * groupD8.uY(rotate2);\n      rotate2 = groupD8.add(rotate2, 2);\n      this.x1 = cX + w2 * groupD8.uX(rotate2);\n      this.y1 = cY + h2 * groupD8.uY(rotate2);\n      rotate2 = groupD8.add(rotate2, 2);\n      this.x2 = cX + w2 * groupD8.uX(rotate2);\n      this.y2 = cY + h2 * groupD8.uY(rotate2);\n      rotate2 = groupD8.add(rotate2, 2);\n      this.x3 = cX + w2 * groupD8.uX(rotate2);\n      this.y3 = cY + h2 * groupD8.uY(rotate2);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n    this.uvsFloat32[0] = this.x0;\n    this.uvsFloat32[1] = this.y0;\n    this.uvsFloat32[2] = this.x1;\n    this.uvsFloat32[3] = this.y1;\n    this.uvsFloat32[4] = this.x2;\n    this.uvsFloat32[5] = this.y2;\n    this.uvsFloat32[6] = this.x3;\n    this.uvsFloat32[7] = this.y3;\n  };\n  TextureUvs2.prototype.toString = function() {\n    return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n  };\n  return TextureUvs2;\n}();\nvar DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {\n  };\n  tex.on = function _emptyOn() {\n  };\n  tex.once = function _emptyOnce() {\n  };\n  tex.emit = function _emptyEmit() {\n  };\n}\nvar Texture = function(_super) {\n  __extends$q(Texture2, _super);\n  function Texture2(baseTexture, frame, orig, trim2, rotate2, anchor) {\n    var _this = _super.call(this) || this;\n    _this.noFrame = false;\n    if (!frame) {\n      _this.noFrame = true;\n      frame = new Rectangle(0, 0, 1, 1);\n    }\n    if (baseTexture instanceof Texture2) {\n      baseTexture = baseTexture.baseTexture;\n    }\n    _this.baseTexture = baseTexture;\n    _this._frame = frame;\n    _this.trim = trim2;\n    _this.valid = false;\n    _this._uvs = DEFAULT_UVS;\n    _this.uvMatrix = null;\n    _this.orig = orig || frame;\n    _this._rotate = Number(rotate2 || 0);\n    if (rotate2 === true) {\n      _this._rotate = 2;\n    } else if (_this._rotate % 2 !== 0) {\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    }\n    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n    _this._updateID = 0;\n    _this.textureCacheIds = [];\n    if (!baseTexture.valid) {\n      baseTexture.once(\"loaded\", _this.onBaseTextureUpdated, _this);\n    } else if (_this.noFrame) {\n      if (baseTexture.valid) {\n        _this.onBaseTextureUpdated(baseTexture);\n      }\n    } else {\n      _this.frame = frame;\n    }\n    if (_this.noFrame) {\n      baseTexture.on(\"update\", _this.onBaseTextureUpdated, _this);\n    }\n    return _this;\n  }\n  Texture2.prototype.update = function() {\n    if (this.baseTexture.resource) {\n      this.baseTexture.resource.update();\n    }\n  };\n  Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid) {\n        return;\n      }\n      this._frame.width = baseTexture.width;\n      this._frame.height = baseTexture.height;\n      this.valid = true;\n      this.updateUvs();\n    } else {\n      this.frame = this._frame;\n    }\n    this.emit(\"update\", this);\n  };\n  Texture2.prototype.destroy = function(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        var resource = this.baseTexture.resource;\n        if (resource && resource.url && TextureCache[resource.url]) {\n          Texture2.removeFromCache(resource.url);\n        }\n        this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this);\n      this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this);\n      this.baseTexture = null;\n    }\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.orig = null;\n    this.valid = false;\n    Texture2.removeFromCache(this);\n    this.textureCacheIds = null;\n  };\n  Texture2.prototype.clone = function() {\n    var clonedFrame = this._frame.clone();\n    var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();\n    var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n    if (this.noFrame) {\n      clonedTexture._frame = clonedFrame;\n    }\n    return clonedTexture;\n  };\n  Texture2.prototype.updateUvs = function() {\n    if (this._uvs === DEFAULT_UVS) {\n      this._uvs = new TextureUvs();\n    }\n    this._uvs.set(this._frame, this.baseTexture, this.rotate);\n    this._updateID++;\n  };\n  Texture2.from = function(source, options, strict) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (strict === void 0) {\n      strict = settings.STRICT_TEXTURE_CACHE;\n    }\n    var isFrame = typeof source === \"string\";\n    var cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else if (source instanceof BaseTexture) {\n      if (!source.cacheId) {\n        var prefix2 = options && options.pixiIdPrefix || \"pixiid\";\n        source.cacheId = prefix2 + \"-\" + uid();\n        BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        var prefix2 = options && options.pixiIdPrefix || \"pixiid\";\n        source._pixiId = prefix2 + \"_\" + uid();\n      }\n      cacheId = source._pixiId;\n    }\n    var texture = TextureCache[cacheId];\n    if (isFrame && strict && !texture) {\n      throw new Error('The cacheId \"' + cacheId + '\" does not exist in TextureCache.');\n    }\n    if (!texture && !(source instanceof BaseTexture)) {\n      if (!options.resolution) {\n        options.resolution = getResolutionOfUrl(source);\n      }\n      texture = new Texture2(new BaseTexture(source, options));\n      texture.baseTexture.cacheId = cacheId;\n      BaseTexture.addToCache(texture.baseTexture, cacheId);\n      Texture2.addToCache(texture, cacheId);\n    } else if (!texture && source instanceof BaseTexture) {\n      texture = new Texture2(source);\n      Texture2.addToCache(texture, cacheId);\n    }\n    return texture;\n  };\n  Texture2.fromURL = function(url2, options) {\n    var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);\n    var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);\n    var resource = texture.baseTexture.resource;\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return resource.load().then(function() {\n      return Promise.resolve(texture);\n    });\n  };\n  Texture2.fromBuffer = function(buffer, width, height, options) {\n    return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));\n  };\n  Texture2.fromLoader = function(source, imageUrl, name, options) {\n    var baseTexture = new BaseTexture(source, Object.assign({\n      scaleMode: settings.SCALE_MODE,\n      resolution: getResolutionOfUrl(imageUrl)\n    }, options));\n    var resource = baseTexture.resource;\n    if (resource instanceof ImageResource) {\n      resource.url = imageUrl;\n    }\n    var texture = new Texture2(baseTexture);\n    if (!name) {\n      name = imageUrl;\n    }\n    BaseTexture.addToCache(texture.baseTexture, name);\n    Texture2.addToCache(texture, name);\n    if (name !== imageUrl) {\n      BaseTexture.addToCache(texture.baseTexture, imageUrl);\n      Texture2.addToCache(texture, imageUrl);\n    }\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return new Promise(function(resolve2) {\n      texture.baseTexture.once(\"loaded\", function() {\n        return resolve2(texture);\n      });\n    });\n  };\n  Texture2.addToCache = function(texture, id) {\n    if (id) {\n      if (texture.textureCacheIds.indexOf(id) === -1) {\n        texture.textureCacheIds.push(id);\n      }\n      if (TextureCache[id]) {\n        console.warn(\"Texture added to the cache with an id [\" + id + \"] that already had an entry\");\n      }\n      TextureCache[id] = texture;\n    }\n  };\n  Texture2.removeFromCache = function(texture) {\n    if (typeof texture === \"string\") {\n      var textureFromCache = TextureCache[texture];\n      if (textureFromCache) {\n        var index = textureFromCache.textureCacheIds.indexOf(texture);\n        if (index > -1) {\n          textureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete TextureCache[texture];\n        return textureFromCache;\n      }\n    } else if (texture && texture.textureCacheIds) {\n      for (var i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {\n        if (TextureCache[texture.textureCacheIds[i2]] === texture) {\n          delete TextureCache[texture.textureCacheIds[i2]];\n        }\n      }\n      texture.textureCacheIds.length = 0;\n      return texture;\n    }\n    return null;\n  };\n  Object.defineProperty(Texture2.prototype, \"resolution\", {\n    get: function() {\n      return this.baseTexture.resolution;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture2.prototype, \"frame\", {\n    get: function() {\n      return this._frame;\n    },\n    set: function(frame) {\n      this._frame = frame;\n      this.noFrame = false;\n      var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;\n      var xNotFit = x2 + width > this.baseTexture.width;\n      var yNotFit = y2 + height > this.baseTexture.height;\n      if (xNotFit || yNotFit) {\n        var relationship = xNotFit && yNotFit ? \"and\" : \"or\";\n        var errorX = \"X: \" + x2 + \" + \" + width + \" = \" + (x2 + width) + \" > \" + this.baseTexture.width;\n        var errorY = \"Y: \" + y2 + \" + \" + height + \" = \" + (y2 + height) + \" > \" + this.baseTexture.height;\n        throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + (errorX + \" \" + relationship + \" \" + errorY));\n      }\n      this.valid = width && height && this.baseTexture.valid;\n      if (!this.trim && !this.rotate) {\n        this.orig = frame;\n      }\n      if (this.valid) {\n        this.updateUvs();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture2.prototype, \"rotate\", {\n    get: function() {\n      return this._rotate;\n    },\n    set: function(rotate2) {\n      this._rotate = rotate2;\n      if (this.valid) {\n        this.updateUvs();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture2.prototype, \"width\", {\n    get: function() {\n      return this.orig.width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture2.prototype, \"height\", {\n    get: function() {\n      return this.orig.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Texture2.prototype.castToBaseTexture = function() {\n    return this.baseTexture;\n  };\n  Object.defineProperty(Texture2, \"EMPTY\", {\n    get: function() {\n      if (!Texture2._EMPTY) {\n        Texture2._EMPTY = new Texture2(new BaseTexture());\n        removeAllHandlers(Texture2._EMPTY);\n        removeAllHandlers(Texture2._EMPTY.baseTexture);\n      }\n      return Texture2._EMPTY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Texture2, \"WHITE\", {\n    get: function() {\n      if (!Texture2._WHITE) {\n        var canvas = document.createElement(\"canvas\");\n        var context2 = canvas.getContext(\"2d\");\n        canvas.width = 16;\n        canvas.height = 16;\n        context2.fillStyle = \"white\";\n        context2.fillRect(0, 0, 16, 16);\n        Texture2._WHITE = new Texture2(new BaseTexture(new CanvasResource(canvas)));\n        removeAllHandlers(Texture2._WHITE);\n        removeAllHandlers(Texture2._WHITE.baseTexture);\n      }\n      return Texture2._WHITE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Texture2;\n}(EventEmitter$4);\nvar RenderTexture = function(_super) {\n  __extends$q(RenderTexture2, _super);\n  function RenderTexture2(baseRenderTexture, frame) {\n    var _this = _super.call(this, baseRenderTexture, frame) || this;\n    _this.valid = true;\n    _this.filterFrame = null;\n    _this.filterPoolKey = null;\n    _this.updateUvs();\n    return _this;\n  }\n  Object.defineProperty(RenderTexture2.prototype, \"framebuffer\", {\n    get: function() {\n      return this.baseTexture.framebuffer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTexture2.prototype, \"multisample\", {\n    get: function() {\n      return this.framebuffer.multisample;\n    },\n    set: function(value2) {\n      this.framebuffer.multisample = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {\n    if (resizeBaseTexture === void 0) {\n      resizeBaseTexture = true;\n    }\n    var resolution = this.baseTexture.resolution;\n    var width = Math.round(desiredWidth * resolution) / resolution;\n    var height = Math.round(desiredHeight * resolution) / resolution;\n    this.valid = width > 0 && height > 0;\n    this._frame.width = this.orig.width = width;\n    this._frame.height = this.orig.height = height;\n    if (resizeBaseTexture) {\n      this.baseTexture.resize(width, height);\n    }\n    this.updateUvs();\n  };\n  RenderTexture2.prototype.setResolution = function(resolution) {\n    var baseTexture = this.baseTexture;\n    if (baseTexture.resolution === resolution) {\n      return;\n    }\n    baseTexture.setResolution(resolution);\n    this.resize(baseTexture.width, baseTexture.height, false);\n  };\n  RenderTexture2.create = function(options) {\n    var arguments$1 = arguments;\n    var rest = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments$1[_i];\n    }\n    if (typeof options === \"number\") {\n      deprecation(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\");\n      options = {\n        width: options,\n        height: rest[0],\n        scaleMode: rest[1],\n        resolution: rest[2]\n      };\n    }\n    return new RenderTexture2(new BaseRenderTexture(options));\n  };\n  return RenderTexture2;\n}(Texture);\nvar RenderTexturePool = function() {\n  function RenderTexturePool2(textureOptions) {\n    this.texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n    this._pixelsWidth = 0;\n    this._pixelsHeight = 0;\n  }\n  RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {\n    if (multisample === void 0) {\n      multisample = MSAA_QUALITY$3.NONE;\n    }\n    var baseRenderTexture = new BaseRenderTexture(Object.assign({\n      width: realWidth,\n      height: realHeight,\n      resolution: 1,\n      multisample\n    }, this.textureOptions));\n    return new RenderTexture(baseRenderTexture);\n  };\n  RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {\n    if (resolution === void 0) {\n      resolution = 1;\n    }\n    if (multisample === void 0) {\n      multisample = MSAA_QUALITY$3.NONE;\n    }\n    var key;\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {\n      minWidth = nextPow2(minWidth);\n      minHeight = nextPow2(minHeight);\n      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;\n      if (multisample > 1) {\n        key += multisample * 4294967296;\n      }\n    } else {\n      key = multisample > 1 ? -multisample : -1;\n    }\n    if (!this.texturePool[key]) {\n      this.texturePool[key] = [];\n    }\n    var renderTexture = this.texturePool[key].pop();\n    if (!renderTexture) {\n      renderTexture = this.createTexture(minWidth, minHeight, multisample);\n    }\n    renderTexture.filterPoolKey = key;\n    renderTexture.setResolution(resolution);\n    return renderTexture;\n  };\n  RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {\n    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  };\n  RenderTexturePool2.prototype.returnTexture = function(renderTexture) {\n    var key = renderTexture.filterPoolKey;\n    renderTexture.filterFrame = null;\n    this.texturePool[key].push(renderTexture);\n  };\n  RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {\n    this.returnTexture(renderTexture);\n  };\n  RenderTexturePool2.prototype.clear = function(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (var i2 in this.texturePool) {\n        var textures = this.texturePool[i2];\n        if (textures) {\n          for (var j2 = 0; j2 < textures.length; j2++) {\n            textures[j2].destroy(true);\n          }\n        }\n      }\n    }\n    this.texturePool = {};\n  };\n  RenderTexturePool2.prototype.setScreenSize = function(size) {\n    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {\n      return;\n    }\n    this.enableFullScreen = size.width > 0 && size.height > 0;\n    for (var i2 in this.texturePool) {\n      if (!(Number(i2) < 0)) {\n        continue;\n      }\n      var textures = this.texturePool[i2];\n      if (textures) {\n        for (var j2 = 0; j2 < textures.length; j2++) {\n          textures[j2].destroy(true);\n        }\n      }\n      this.texturePool[i2] = [];\n    }\n    this._pixelsWidth = size.width;\n    this._pixelsHeight = size.height;\n  };\n  RenderTexturePool2.SCREEN_KEY = -1;\n  return RenderTexturePool2;\n}();\nvar Attribute = function() {\n  function Attribute2(buffer, size, normalized, type, stride, start2, instance) {\n    if (size === void 0) {\n      size = 0;\n    }\n    if (normalized === void 0) {\n      normalized = false;\n    }\n    if (type === void 0) {\n      type = TYPES$3.FLOAT;\n    }\n    this.buffer = buffer;\n    this.size = size;\n    this.normalized = normalized;\n    this.type = type;\n    this.stride = stride;\n    this.start = start2;\n    this.instance = instance;\n  }\n  Attribute2.prototype.destroy = function() {\n    this.buffer = null;\n  };\n  Attribute2.from = function(buffer, size, normalized, type, stride) {\n    return new Attribute2(buffer, size, normalized, type, stride);\n  };\n  return Attribute2;\n}();\nvar UID$4 = 0;\nvar Buffer$1 = function() {\n  function Buffer2(data, _static, index) {\n    if (_static === void 0) {\n      _static = true;\n    }\n    if (index === void 0) {\n      index = false;\n    }\n    this.data = data || new Float32Array(1);\n    this._glBuffers = {};\n    this._updateID = 0;\n    this.index = index;\n    this.static = _static;\n    this.id = UID$4++;\n    this.disposeRunner = new Runner(\"disposeBuffer\");\n  }\n  Buffer2.prototype.update = function(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this.data = data || this.data;\n    this._updateID++;\n  };\n  Buffer2.prototype.dispose = function() {\n    this.disposeRunner.emit(this, false);\n  };\n  Buffer2.prototype.destroy = function() {\n    this.dispose();\n    this.data = null;\n  };\n  Object.defineProperty(Buffer2.prototype, \"index\", {\n    get: function() {\n      return this.type === BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;\n    },\n    set: function(value2) {\n      this.type = value2 ? BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$3.ARRAY_BUFFER;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Buffer2.from = function(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    return new Buffer2(data);\n  };\n  return Buffer2;\n}();\nvar map$1 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  var outSize = 0;\n  var stride = 0;\n  var views = {};\n  for (var i2 = 0; i2 < arrays.length; i2++) {\n    stride += sizes[i2];\n    outSize += arrays[i2].length;\n  }\n  var buffer = new ArrayBuffer(outSize * 4);\n  var out = null;\n  var littleOffset = 0;\n  for (var i2 = 0; i2 < arrays.length; i2++) {\n    var size = sizes[i2];\n    var array = arrays[i2];\n    var type = getBufferType(array);\n    if (!views[type]) {\n      views[type] = new map$1[type](buffer);\n    }\n    out = views[type];\n    for (var j2 = 0; j2 < array.length; j2++) {\n      var indexStart = (j2 / size | 0) * stride + littleOffset;\n      var index = j2 % size;\n      out[indexStart + index] = array[j2];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\nvar byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };\nvar UID$3 = 0;\nvar map$2 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nvar Geometry = function() {\n  function Geometry2(buffers, attributes) {\n    if (buffers === void 0) {\n      buffers = [];\n    }\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    this.buffers = buffers;\n    this.indexBuffer = null;\n    this.attributes = attributes;\n    this.glVertexArrayObjects = {};\n    this.id = UID$3++;\n    this.instanced = false;\n    this.instanceCount = 1;\n    this.disposeRunner = new Runner(\"disposeGeometry\");\n    this.refCount = 0;\n  }\n  Geometry2.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start2, instance) {\n    if (size === void 0) {\n      size = 0;\n    }\n    if (normalized === void 0) {\n      normalized = false;\n    }\n    if (instance === void 0) {\n      instance = false;\n    }\n    if (!buffer) {\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    }\n    if (!(buffer instanceof Buffer$1)) {\n      if (buffer instanceof Array) {\n        buffer = new Float32Array(buffer);\n      }\n      buffer = new Buffer$1(buffer);\n    }\n    var ids = id.split(\"|\");\n    if (ids.length > 1) {\n      for (var i2 = 0; i2 < ids.length; i2++) {\n        this.addAttribute(ids[i2], buffer, size, normalized, type);\n      }\n      return this;\n    }\n    var bufferIndex = this.buffers.indexOf(buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(buffer);\n      bufferIndex = this.buffers.length - 1;\n    }\n    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start2, instance);\n    this.instanced = this.instanced || instance;\n    return this;\n  };\n  Geometry2.prototype.getAttribute = function(id) {\n    return this.attributes[id];\n  };\n  Geometry2.prototype.getBuffer = function(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  };\n  Geometry2.prototype.addIndex = function(buffer) {\n    if (!(buffer instanceof Buffer$1)) {\n      if (buffer instanceof Array) {\n        buffer = new Uint16Array(buffer);\n      }\n      buffer = new Buffer$1(buffer);\n    }\n    buffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;\n    this.indexBuffer = buffer;\n    if (this.buffers.indexOf(buffer) === -1) {\n      this.buffers.push(buffer);\n    }\n    return this;\n  };\n  Geometry2.prototype.getIndex = function() {\n    return this.indexBuffer;\n  };\n  Geometry2.prototype.interleave = function() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {\n      return this;\n    }\n    var arrays = [];\n    var sizes = [];\n    var interleavedBuffer = new Buffer$1();\n    var i2;\n    for (i2 in this.attributes) {\n      var attribute = this.attributes[i2];\n      var buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data);\n      sizes.push(attribute.size * byteSizeMap$1[attribute.type] / 4);\n      attribute.buffer = 0;\n    }\n    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n    for (i2 = 0; i2 < this.buffers.length; i2++) {\n      if (this.buffers[i2] !== this.indexBuffer) {\n        this.buffers[i2].destroy();\n      }\n    }\n    this.buffers = [interleavedBuffer];\n    if (this.indexBuffer) {\n      this.buffers.push(this.indexBuffer);\n    }\n    return this;\n  };\n  Geometry2.prototype.getSize = function() {\n    for (var i2 in this.attributes) {\n      var attribute = this.attributes[i2];\n      var buffer = this.buffers[attribute.buffer];\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  };\n  Geometry2.prototype.dispose = function() {\n    this.disposeRunner.emit(this, false);\n  };\n  Geometry2.prototype.destroy = function() {\n    this.dispose();\n    this.buffers = null;\n    this.indexBuffer = null;\n    this.attributes = null;\n  };\n  Geometry2.prototype.clone = function() {\n    var geometry = new Geometry2();\n    for (var i2 = 0; i2 < this.buffers.length; i2++) {\n      geometry.buffers[i2] = new Buffer$1(this.buffers[i2].data.slice(0));\n    }\n    for (var i2 in this.attributes) {\n      var attrib = this.attributes[i2];\n      geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);\n    }\n    if (this.indexBuffer) {\n      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n      geometry.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;\n    }\n    return geometry;\n  };\n  Geometry2.merge = function(geometries) {\n    var geometryOut = new Geometry2();\n    var arrays = [];\n    var sizes = [];\n    var offsets = [];\n    var geometry;\n    for (var i2 = 0; i2 < geometries.length; i2++) {\n      geometry = geometries[i2];\n      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {\n        sizes[j2] = sizes[j2] || 0;\n        sizes[j2] += geometry.buffers[j2].data.length;\n        offsets[j2] = 0;\n      }\n    }\n    for (var i2 = 0; i2 < geometry.buffers.length; i2++) {\n      arrays[i2] = new map$2[getBufferType(geometry.buffers[i2].data)](sizes[i2]);\n      geometryOut.buffers[i2] = new Buffer$1(arrays[i2]);\n    }\n    for (var i2 = 0; i2 < geometries.length; i2++) {\n      geometry = geometries[i2];\n      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {\n        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);\n        offsets[j2] += geometry.buffers[j2].data.length;\n      }\n    }\n    geometryOut.attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n      geometryOut.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;\n      var offset2 = 0;\n      var stride = 0;\n      var offset22 = 0;\n      var bufferIndexToCount = 0;\n      for (var i2 = 0; i2 < geometry.buffers.length; i2++) {\n        if (geometry.buffers[i2] !== geometry.indexBuffer) {\n          bufferIndexToCount = i2;\n          break;\n        }\n      }\n      for (var i2 in geometry.attributes) {\n        var attribute = geometry.attributes[i2];\n        if ((attribute.buffer | 0) === bufferIndexToCount) {\n          stride += attribute.size * byteSizeMap$1[attribute.type] / 4;\n        }\n      }\n      for (var i2 = 0; i2 < geometries.length; i2++) {\n        var indexBufferData = geometries[i2].indexBuffer.data;\n        for (var j2 = 0; j2 < indexBufferData.length; j2++) {\n          geometryOut.indexBuffer.data[j2 + offset22] += offset2;\n        }\n        offset2 += geometries[i2].buffers[bufferIndexToCount].data.length / stride;\n        offset22 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  };\n  return Geometry2;\n}();\nvar Quad = function(_super) {\n  __extends$q(Quad2, _super);\n  function Quad2() {\n    var _this = _super.call(this) || this;\n    _this.addAttribute(\"aVertexPosition\", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]);\n    return _this;\n  }\n  return Quad2;\n}(Geometry);\nvar QuadUv = function(_super) {\n  __extends$q(QuadUv2, _super);\n  function QuadUv2() {\n    var _this = _super.call(this) || this;\n    _this.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]);\n    _this.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]);\n    _this.vertexBuffer = new Buffer$1(_this.vertices);\n    _this.uvBuffer = new Buffer$1(_this.uvs);\n    _this.addAttribute(\"aVertexPosition\", _this.vertexBuffer).addAttribute(\"aTextureCoord\", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);\n    return _this;\n  }\n  QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {\n    var x2 = 0;\n    var y2 = 0;\n    this.uvs[0] = x2;\n    this.uvs[1] = y2;\n    this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[3] = y2;\n    this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;\n    this.uvs[6] = x2;\n    this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;\n    x2 = destinationFrame.x;\n    y2 = destinationFrame.y;\n    this.vertices[0] = x2;\n    this.vertices[1] = y2;\n    this.vertices[2] = x2 + destinationFrame.width;\n    this.vertices[3] = y2;\n    this.vertices[4] = x2 + destinationFrame.width;\n    this.vertices[5] = y2 + destinationFrame.height;\n    this.vertices[6] = x2;\n    this.vertices[7] = y2 + destinationFrame.height;\n    this.invalidate();\n    return this;\n  };\n  QuadUv2.prototype.invalidate = function() {\n    this.vertexBuffer._updateID++;\n    this.uvBuffer._updateID++;\n    return this;\n  };\n  return QuadUv2;\n}(Geometry);\nvar UID$2 = 0;\nvar UniformGroup = function() {\n  function UniformGroup2(uniforms, isStatic, isUbo) {\n    this.group = true;\n    this.syncUniforms = {};\n    this.dirtyId = 0;\n    this.id = UID$2++;\n    this.static = !!isStatic;\n    this.ubo = !!isUbo;\n    if (uniforms instanceof Buffer$1) {\n      this.buffer = uniforms;\n      this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;\n      this.autoManage = false;\n      this.ubo = true;\n    } else {\n      this.uniforms = uniforms;\n      if (this.ubo) {\n        this.buffer = new Buffer$1(new Float32Array(1));\n        this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;\n        this.autoManage = true;\n      }\n    }\n  }\n  UniformGroup2.prototype.update = function() {\n    this.dirtyId++;\n    if (!this.autoManage && this.buffer) {\n      this.buffer.update();\n    }\n  };\n  UniformGroup2.prototype.add = function(name, uniforms, _static) {\n    if (!this.ubo) {\n      this.uniforms[name] = new UniformGroup2(uniforms, _static);\n    } else {\n      throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n    }\n  };\n  UniformGroup2.from = function(uniforms, _static, _ubo) {\n    return new UniformGroup2(uniforms, _static, _ubo);\n  };\n  UniformGroup2.uboFrom = function(uniforms, _static) {\n    return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);\n  };\n  return UniformGroup2;\n}();\nvar FilterState = function() {\n  function FilterState2() {\n    this.renderTexture = null;\n    this.target = null;\n    this.legacy = false;\n    this.resolution = 1;\n    this.multisample = MSAA_QUALITY$3.NONE;\n    this.sourceFrame = new Rectangle();\n    this.destinationFrame = new Rectangle();\n    this.bindingSourceFrame = new Rectangle();\n    this.bindingDestinationFrame = new Rectangle();\n    this.filters = [];\n    this.transform = null;\n  }\n  FilterState2.prototype.clear = function() {\n    this.target = null;\n    this.filters = null;\n    this.renderTexture = null;\n  };\n  return FilterState2;\n}();\nvar tempPoints = [new Point(), new Point(), new Point(), new Point()];\nvar tempMatrix$2 = new Matrix();\nvar FilterSystem = function() {\n  function FilterSystem2(renderer) {\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.texturePool.setScreenSize(renderer.view);\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new Rectangle();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  FilterSystem2.prototype.push = function(target, filters) {\n    var _a3, _b3;\n    var renderer = this.renderer;\n    var filterStack = this.defaultFilterStack;\n    var state = this.statePool.pop() || new FilterState();\n    var renderTextureSystem = this.renderer.renderTexture;\n    var resolution = filters[0].resolution;\n    var multisample = filters[0].multisample;\n    var padding = filters[0].padding;\n    var autoFit = filters[0].autoFit;\n    var legacy = (_a3 = filters[0].legacy) !== null && _a3 !== void 0 ? _a3 : true;\n    for (var i2 = 1; i2 < filters.length; i2++) {\n      var filter = filters[i2];\n      resolution = Math.min(resolution, filter.resolution);\n      multisample = Math.min(multisample, filter.multisample);\n      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n      autoFit = autoFit && filter.autoFit;\n      legacy = legacy || ((_b3 = filter.legacy) !== null && _b3 !== void 0 ? _b3 : true);\n    }\n    if (filterStack.length === 1) {\n      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n    }\n    filterStack.push(state);\n    state.resolution = resolution;\n    state.multisample = multisample;\n    state.legacy = legacy;\n    state.target = target;\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n    state.sourceFrame.pad(padding);\n    var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    if (renderer.projection.transform) {\n      this.transformAABB(tempMatrix$2.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n    }\n    if (autoFit) {\n      state.sourceFrame.fit(sourceFrameProjected);\n      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n      state.sourceFrame.width = 0;\n      state.sourceFrame.height = 0;\n    }\n    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n    state.filters = filters;\n    state.destinationFrame.width = state.renderTexture.width;\n    state.destinationFrame.height = state.renderTexture.height;\n    var destinationFrame = this.tempRect;\n    destinationFrame.x = 0;\n    destinationFrame.y = 0;\n    destinationFrame.width = state.sourceFrame.width;\n    destinationFrame.height = state.sourceFrame.height;\n    state.renderTexture.filterFrame = state.sourceFrame;\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n    state.transform = renderer.projection.transform;\n    renderer.projection.transform = null;\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n    renderer.framebuffer.clear(0, 0, 0, 0);\n  };\n  FilterSystem2.prototype.pop = function() {\n    var filterStack = this.defaultFilterStack;\n    var state = filterStack.pop();\n    var filters = state.filters;\n    this.activeState = state;\n    var globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame;\n    globalUniforms.resolution = state.resolution;\n    var inputSize = globalUniforms.inputSize;\n    var inputPixel = globalUniforms.inputPixel;\n    var inputClamp = globalUniforms.inputClamp;\n    inputSize[0] = state.destinationFrame.width;\n    inputSize[1] = state.destinationFrame.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n    inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n    if (state.legacy) {\n      var filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width;\n      filterArea[1] = state.destinationFrame.height;\n      filterArea[2] = state.sourceFrame.x;\n      filterArea[3] = state.sourceFrame.y;\n      globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    var lastState = filterStack[filterStack.length - 1];\n    this.renderer.framebuffer.blit();\n    if (filters.length === 1) {\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);\n      this.returnFilterTexture(state.renderTexture);\n    } else {\n      var flip2 = state.renderTexture;\n      var flop = this.getOptimalFilterTexture(flip2.width, flip2.height, state.resolution);\n      flop.filterFrame = flip2.filterFrame;\n      var i2 = 0;\n      for (i2 = 0; i2 < filters.length - 1; ++i2) {\n        if (i2 === 1 && state.multisample > 1) {\n          flop = this.getOptimalFilterTexture(flip2.width, flip2.height, state.resolution);\n          flop.filterFrame = flip2.filterFrame;\n        }\n        filters[i2].apply(this, flip2, flop, CLEAR_MODES$3.CLEAR, state);\n        var t = flip2;\n        flip2 = flop;\n        flop = t;\n      }\n      filters[i2].apply(this, flip2, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);\n      if (i2 > 1 && state.multisample > 1) {\n        this.returnFilterTexture(state.renderTexture);\n      }\n      this.returnFilterTexture(flip2);\n      this.returnFilterTexture(flop);\n    }\n    state.clear();\n    this.statePool.push(state);\n  };\n  FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {\n    if (clearMode === void 0) {\n      clearMode = CLEAR_MODES$3.CLEAR;\n    }\n    var _a3 = this.renderer, renderTextureSystem = _a3.renderTexture, stateSystem = _a3.state;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      this.renderer.projection.transform = this.activeState.transform;\n    } else {\n      this.renderer.projection.transform = null;\n    }\n    if (filterTexture && filterTexture.filterFrame) {\n      var destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = filterTexture.filterFrame.width;\n      destinationFrame.height = filterTexture.filterFrame.height;\n      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      renderTextureSystem.bind(filterTexture);\n    } else {\n      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    }\n    var autoClear = stateSystem.stateId & 1 || this.forceClear;\n    if (clearMode === CLEAR_MODES$3.CLEAR || clearMode === CLEAR_MODES$3.BLIT && autoClear) {\n      this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  };\n  FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {\n    var renderer = this.renderer;\n    renderer.state.set(filter.state);\n    this.bindAndClear(output, clearMode);\n    filter.uniforms.uSampler = input;\n    filter.uniforms.filterGlobals = this.globalUniforms;\n    renderer.shader.bind(filter);\n    filter.legacy = !!filter.program.attributeData.aTextureCoord;\n    if (filter.legacy) {\n      this.quadUv.map(input._frame, input.filterFrame);\n      renderer.geometry.bind(this.quadUv);\n      renderer.geometry.draw(DRAW_MODES$3.TRIANGLES);\n    } else {\n      renderer.geometry.bind(this.quad);\n      renderer.geometry.draw(DRAW_MODES$3.TRIANGLE_STRIP);\n    }\n  };\n  FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {\n    var _a3 = this.activeState, sourceFrame = _a3.sourceFrame, destinationFrame = _a3.destinationFrame;\n    var orig = sprite._texture.orig;\n    var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n    var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  };\n  FilterSystem2.prototype.destroy = function() {\n    this.renderer = null;\n    this.texturePool.clear(false);\n  };\n  FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {\n    if (resolution === void 0) {\n      resolution = 1;\n    }\n    if (multisample === void 0) {\n      multisample = MSAA_QUALITY$3.NONE;\n    }\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  };\n  FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {\n    if (typeof input === \"number\") {\n      var swap2 = input;\n      input = resolution;\n      resolution = swap2;\n    }\n    input = input || this.activeState.renderTexture;\n    var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  };\n  FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  };\n  FilterSystem2.prototype.emptyPool = function() {\n    this.texturePool.clear(true);\n  };\n  FilterSystem2.prototype.resize = function() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  };\n  FilterSystem2.prototype.transformAABB = function(matrix, rect) {\n    var lt = tempPoints[0];\n    var lb = tempPoints[1];\n    var rt = tempPoints[2];\n    var rb = tempPoints[3];\n    lt.set(rect.left, rect.top);\n    lb.set(rect.left, rect.bottom);\n    rt.set(rect.right, rect.top);\n    rb.set(rect.right, rect.bottom);\n    matrix.apply(lt, lt);\n    matrix.apply(lb, lb);\n    matrix.apply(rt, rt);\n    matrix.apply(rb, rb);\n    var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n    var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n    var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n    var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0;\n    rect.y = y0;\n    rect.width = x1 - x0;\n    rect.height = y1 - y0;\n  };\n  FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n      return;\n    }\n    if (transform) {\n      var a2 = transform.a, b2 = transform.b, c2 = transform.c, d2 = transform.d;\n      if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4)) {\n        return;\n      }\n    }\n    transform = transform ? tempMatrix$2.copyFrom(transform) : tempMatrix$2.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.transformAABB(transform, frame);\n    frame.ceil(resolution);\n    this.transformAABB(transform.invert(), frame);\n  };\n  return FilterSystem2;\n}();\nvar ObjectRenderer = function() {\n  function ObjectRenderer2(renderer) {\n    this.renderer = renderer;\n  }\n  ObjectRenderer2.prototype.flush = function() {\n  };\n  ObjectRenderer2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  ObjectRenderer2.prototype.start = function() {\n  };\n  ObjectRenderer2.prototype.stop = function() {\n    this.flush();\n  };\n  ObjectRenderer2.prototype.render = function(_object) {\n  };\n  return ObjectRenderer2;\n}();\nvar BatchSystem = function() {\n  function BatchSystem2(renderer) {\n    this.renderer = renderer;\n    this.emptyRenderer = new ObjectRenderer(renderer);\n    this.currentRenderer = this.emptyRenderer;\n  }\n  BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  };\n  BatchSystem2.prototype.flush = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  };\n  BatchSystem2.prototype.reset = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  };\n  BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {\n    var boundTextures = this.renderer.texture.boundTextures;\n    for (var i2 = maxTextures - 1; i2 >= 0; --i2) {\n      arr[i2] = boundTextures[i2] || null;\n      if (arr[i2]) {\n        arr[i2]._batchLocation = i2;\n      }\n    }\n  };\n  BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {\n    var elements = texArray.elements, ids = texArray.ids, count = texArray.count;\n    var j2 = 0;\n    for (var i2 = 0; i2 < count; i2++) {\n      var tex = elements[i2];\n      var loc = tex._batchLocation;\n      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {\n        ids[i2] = loc;\n        continue;\n      }\n      while (j2 < maxTextures) {\n        var bound = boundTextures[j2];\n        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {\n          j2++;\n          continue;\n        }\n        ids[i2] = j2;\n        tex._batchLocation = j2;\n        boundTextures[j2] = tex;\n        break;\n      }\n    }\n  };\n  BatchSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return BatchSystem2;\n}();\nvar CONTEXT_UID_COUNTER = 0;\nvar ContextSystem = function() {\n  function ContextSystem2(renderer) {\n    this.renderer = renderer;\n    this.webGLVersion = 1;\n    this.extensions = {};\n    this.supports = {\n      uint32Indices: false\n    };\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n    renderer.view.addEventListener(\"webglcontextlost\", this.handleContextLost, false);\n    renderer.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, false);\n  }\n  Object.defineProperty(ContextSystem2.prototype, \"isLost\", {\n    get: function() {\n      return !this.gl || this.gl.isContextLost();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ContextSystem2.prototype.contextChange = function(gl) {\n    this.gl = gl;\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n    if (gl.isContextLost() && gl.getExtension(\"WEBGL_lose_context\")) {\n      gl.getExtension(\"WEBGL_lose_context\").restoreContext();\n    }\n  };\n  ContextSystem2.prototype.initFromContext = function(gl) {\n    this.gl = gl;\n    this.validateContext(gl);\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n    this.renderer.runners.contextChange.emit(gl);\n  };\n  ContextSystem2.prototype.initFromOptions = function(options) {\n    var gl = this.createContext(this.renderer.view, options);\n    this.initFromContext(gl);\n  };\n  ContextSystem2.prototype.createContext = function(canvas, options) {\n    var gl;\n    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {\n      gl = canvas.getContext(\"webgl2\", options);\n    }\n    if (gl) {\n      this.webGLVersion = 2;\n    } else {\n      this.webGLVersion = 1;\n      gl = canvas.getContext(\"webgl\", options) || canvas.getContext(\"experimental-webgl\", options);\n      if (!gl) {\n        throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n      }\n    }\n    this.gl = gl;\n    this.getExtensions();\n    return this.gl;\n  };\n  ContextSystem2.prototype.getExtensions = function() {\n    var gl = this.gl;\n    var common = {\n      anisotropicFiltering: gl.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n      s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: gl.getExtension(\"WEBGL_compressed_texture_astc\")\n    };\n    if (this.webGLVersion === 1) {\n      Object.assign(this.extensions, common, {\n        drawBuffers: gl.getExtension(\"WEBGL_draw_buffers\"),\n        depthTexture: gl.getExtension(\"WEBGL_depth_texture\"),\n        loseContext: gl.getExtension(\"WEBGL_lose_context\"),\n        vertexArrayObject: gl.getExtension(\"OES_vertex_array_object\") || gl.getExtension(\"MOZ_OES_vertex_array_object\") || gl.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n        uint32ElementIndex: gl.getExtension(\"OES_element_index_uint\"),\n        floatTexture: gl.getExtension(\"OES_texture_float\"),\n        floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n        textureHalfFloat: gl.getExtension(\"OES_texture_half_float\"),\n        textureHalfFloatLinear: gl.getExtension(\"OES_texture_half_float_linear\")\n      });\n    } else if (this.webGLVersion === 2) {\n      Object.assign(this.extensions, common, {\n        colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\")\n      });\n    }\n  };\n  ContextSystem2.prototype.handleContextLost = function(event) {\n    event.preventDefault();\n  };\n  ContextSystem2.prototype.handleContextRestored = function() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  };\n  ContextSystem2.prototype.destroy = function() {\n    var view = this.renderer.view;\n    this.renderer = null;\n    view.removeEventListener(\"webglcontextlost\", this.handleContextLost);\n    view.removeEventListener(\"webglcontextrestored\", this.handleContextRestored);\n    this.gl.useProgram(null);\n    if (this.extensions.loseContext) {\n      this.extensions.loseContext.loseContext();\n    }\n  };\n  ContextSystem2.prototype.postrender = function() {\n    if (this.renderer.renderingToScreen) {\n      this.gl.flush();\n    }\n  };\n  ContextSystem2.prototype.validateContext = function(gl) {\n    var attributes = gl.getContextAttributes();\n    var isWebGl2 = \"WebGL2RenderingContext\" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;\n    if (isWebGl2) {\n      this.webGLVersion = 2;\n    }\n    if (!attributes.stencil) {\n      console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    }\n    var hasuint32 = isWebGl2 || !!gl.getExtension(\"OES_element_index_uint\");\n    this.supports.uint32Indices = hasuint32;\n    if (!hasuint32) {\n      console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n    }\n  };\n  return ContextSystem2;\n}();\nvar GLFramebuffer = function() {\n  function GLFramebuffer2(framebuffer) {\n    this.framebuffer = framebuffer;\n    this.stencil = null;\n    this.dirtyId = -1;\n    this.dirtyFormat = -1;\n    this.dirtySize = -1;\n    this.multisample = MSAA_QUALITY$3.NONE;\n    this.msaaBuffer = null;\n    this.blitFramebuffer = null;\n    this.mipLevel = 0;\n  }\n  return GLFramebuffer2;\n}();\nvar tempRectangle = new Rectangle();\nvar FramebufferSystem = function() {\n  function FramebufferSystem2(renderer) {\n    this.renderer = renderer;\n    this.managedFramebuffers = [];\n    this.unknownFramebuffer = new Framebuffer(10, 10);\n    this.msaaSamples = null;\n  }\n  FramebufferSystem2.prototype.contextChange = function() {\n    var gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.current = this.unknownFramebuffer;\n    this.viewport = new Rectangle();\n    this.hasMRT = true;\n    this.writeDepthTexture = true;\n    this.disposeAll(true);\n    if (this.renderer.context.webGLVersion === 1) {\n      var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;\n      var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;\n      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {\n        nativeDrawBuffersExtension_1 = null;\n        nativeDepthTextureExtension = null;\n      }\n      if (nativeDrawBuffersExtension_1) {\n        gl.drawBuffers = function(activeTextures) {\n          return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);\n        };\n      } else {\n        this.hasMRT = false;\n        gl.drawBuffers = function() {\n        };\n      }\n      if (!nativeDepthTextureExtension) {\n        this.writeDepthTexture = false;\n      }\n    } else {\n      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);\n    }\n  };\n  FramebufferSystem2.prototype.bind = function(framebuffer, frame, mipLevel) {\n    if (mipLevel === void 0) {\n      mipLevel = 0;\n    }\n    var gl = this.gl;\n    if (framebuffer) {\n      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);\n      if (this.current !== framebuffer) {\n        this.current = framebuffer;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);\n      }\n      if (fbo.mipLevel !== mipLevel) {\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n        fbo.mipLevel = mipLevel;\n      }\n      if (fbo.dirtyId !== framebuffer.dirtyId) {\n        fbo.dirtyId = framebuffer.dirtyId;\n        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {\n          fbo.dirtyFormat = framebuffer.dirtyFormat;\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.updateFramebuffer(framebuffer, mipLevel);\n        } else if (fbo.dirtySize !== framebuffer.dirtySize) {\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.resizeFramebuffer(framebuffer);\n        }\n      }\n      for (var i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {\n        var tex = framebuffer.colorTextures[i2];\n        this.renderer.texture.unbind(tex.parentTextureArray || tex);\n      }\n      if (framebuffer.depthTexture) {\n        this.renderer.texture.unbind(framebuffer.depthTexture);\n      }\n      if (frame) {\n        var mipWidth = frame.width >> mipLevel;\n        var mipHeight = frame.height >> mipLevel;\n        var scale = mipWidth / frame.width;\n        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);\n      } else {\n        var mipWidth = framebuffer.width >> mipLevel;\n        var mipHeight = framebuffer.height >> mipLevel;\n        this.setViewport(0, 0, mipWidth, mipHeight);\n      }\n    } else {\n      if (this.current) {\n        this.current = null;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      }\n      if (frame) {\n        this.setViewport(frame.x, frame.y, frame.width, frame.height);\n      } else {\n        this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n      }\n    }\n  };\n  FramebufferSystem2.prototype.setViewport = function(x2, y2, width, height) {\n    var v2 = this.viewport;\n    x2 = Math.round(x2);\n    y2 = Math.round(y2);\n    width = Math.round(width);\n    height = Math.round(height);\n    if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {\n      v2.x = x2;\n      v2.y = y2;\n      v2.width = width;\n      v2.height = height;\n      this.gl.viewport(x2, y2, width, height);\n    }\n  };\n  Object.defineProperty(FramebufferSystem2.prototype, \"size\", {\n    get: function() {\n      if (this.current) {\n        return { x: 0, y: 0, width: this.current.width, height: this.current.height };\n      }\n      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FramebufferSystem2.prototype.clear = function(r2, g2, b2, a2, mask) {\n    if (mask === void 0) {\n      mask = BUFFER_BITS$3.COLOR | BUFFER_BITS$3.DEPTH;\n    }\n    var gl = this.gl;\n    gl.clearColor(r2, g2, b2, a2);\n    gl.clear(mask);\n  };\n  FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {\n    var gl = this.gl;\n    var fbo = new GLFramebuffer(gl.createFramebuffer());\n    fbo.multisample = this.detectSamples(framebuffer.multisample);\n    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;\n    this.managedFramebuffers.push(framebuffer);\n    framebuffer.disposeRunner.add(this);\n    return fbo;\n  };\n  FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {\n    var gl = this.gl;\n    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (fbo.msaaBuffer) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);\n    }\n    if (fbo.stencil) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n    }\n    var colorTextures = framebuffer.colorTextures;\n    var count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    for (var i2 = 0; i2 < count; i2++) {\n      var texture = colorTextures[i2];\n      var parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n    }\n    if (framebuffer.depthTexture && this.writeDepthTexture) {\n      this.renderer.texture.bind(framebuffer.depthTexture, 0);\n    }\n  };\n  FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {\n    var gl = this.gl;\n    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    var colorTextures = framebuffer.colorTextures;\n    var count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {\n      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);\n    } else if (fbo.msaaBuffer) {\n      gl.deleteRenderbuffer(fbo.msaaBuffer);\n      fbo.msaaBuffer = null;\n      if (fbo.blitFramebuffer) {\n        fbo.blitFramebuffer.dispose();\n        fbo.blitFramebuffer = null;\n      }\n    }\n    var activeTextures = [];\n    for (var i2 = 0; i2 < count; i2++) {\n      var texture = colorTextures[i2];\n      var parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n      if (i2 === 0 && fbo.msaaBuffer) {\n        continue;\n      }\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n      activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);\n    }\n    if (activeTextures.length > 1) {\n      gl.drawBuffers(activeTextures);\n    }\n    if (framebuffer.depthTexture) {\n      var writeDepthTexture = this.writeDepthTexture;\n      if (writeDepthTexture) {\n        var depthTexture = framebuffer.depthTexture;\n        this.renderer.texture.bind(depthTexture, 0);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n      }\n    }\n    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {\n      fbo.stencil = fbo.stencil || gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);\n    } else if (fbo.stencil) {\n      gl.deleteRenderbuffer(fbo.stencil);\n      fbo.stencil = null;\n    }\n  };\n  FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {\n    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;\n  };\n  FramebufferSystem2.prototype.detectSamples = function(samples) {\n    var msaaSamples = this.msaaSamples;\n    var res = MSAA_QUALITY$3.NONE;\n    if (samples <= 1 || msaaSamples === null) {\n      return res;\n    }\n    for (var i2 = 0; i2 < msaaSamples.length; i2++) {\n      if (msaaSamples[i2] <= samples) {\n        res = msaaSamples[i2];\n        break;\n      }\n    }\n    if (res === 1) {\n      res = MSAA_QUALITY$3.NONE;\n    }\n    return res;\n  };\n  FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {\n    var _a3 = this, current = _a3.current, renderer = _a3.renderer, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;\n    if (renderer.context.webGLVersion !== 2) {\n      return;\n    }\n    if (!current) {\n      return;\n    }\n    var fbo = current.glFramebuffers[CONTEXT_UID];\n    if (!fbo) {\n      return;\n    }\n    if (!framebuffer) {\n      if (!fbo.msaaBuffer) {\n        return;\n      }\n      var colorTexture = current.colorTextures[0];\n      if (!colorTexture) {\n        return;\n      }\n      if (!fbo.blitFramebuffer) {\n        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);\n        fbo.blitFramebuffer.addColorTexture(0, colorTexture);\n      }\n      framebuffer = fbo.blitFramebuffer;\n      if (framebuffer.colorTextures[0] !== colorTexture) {\n        framebuffer.colorTextures[0] = colorTexture;\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n      }\n      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {\n        framebuffer.width = current.width;\n        framebuffer.height = current.height;\n        framebuffer.dirtyId++;\n        framebuffer.dirtySize++;\n      }\n    }\n    if (!sourcePixels) {\n      sourcePixels = tempRectangle;\n      sourcePixels.width = current.width;\n      sourcePixels.height = current.height;\n    }\n    if (!destPixels) {\n      destPixels = sourcePixels;\n    }\n    var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;\n    this.bind(framebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);\n    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);\n  };\n  FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {\n    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    var gl = this.gl;\n    if (!fbo) {\n      return;\n    }\n    delete framebuffer.glFramebuffers[this.CONTEXT_UID];\n    var index = this.managedFramebuffers.indexOf(framebuffer);\n    if (index >= 0) {\n      this.managedFramebuffers.splice(index, 1);\n    }\n    framebuffer.disposeRunner.remove(this);\n    if (!contextLost) {\n      gl.deleteFramebuffer(fbo.framebuffer);\n      if (fbo.msaaBuffer) {\n        gl.deleteRenderbuffer(fbo.msaaBuffer);\n      }\n      if (fbo.stencil) {\n        gl.deleteRenderbuffer(fbo.stencil);\n      }\n    }\n    if (fbo.blitFramebuffer) {\n      fbo.blitFramebuffer.dispose();\n    }\n  };\n  FramebufferSystem2.prototype.disposeAll = function(contextLost) {\n    var list = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (var i2 = 0; i2 < list.length; i2++) {\n      this.disposeFramebuffer(list[i2], contextLost);\n    }\n  };\n  FramebufferSystem2.prototype.forceStencil = function() {\n    var framebuffer = this.current;\n    if (!framebuffer) {\n      return;\n    }\n    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (!fbo || fbo.stencil) {\n      return;\n    }\n    framebuffer.stencil = true;\n    var w2 = framebuffer.width;\n    var h2 = framebuffer.height;\n    var gl = this.gl;\n    var stencil = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);\n    if (fbo.msaaBuffer) {\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);\n    } else {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);\n    }\n    fbo.stencil = stencil;\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);\n  };\n  FramebufferSystem2.prototype.reset = function() {\n    this.current = this.unknownFramebuffer;\n    this.viewport = new Rectangle();\n  };\n  FramebufferSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return FramebufferSystem2;\n}();\nvar byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nvar GeometrySystem = function() {\n  function GeometrySystem2(renderer) {\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  GeometrySystem2.prototype.contextChange = function() {\n    this.disposeAll(true);\n    var gl = this.gl = this.renderer.gl;\n    var context2 = this.renderer.context;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    if (context2.webGLVersion !== 2) {\n      var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;\n      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {\n        nativeVaoExtension_1 = null;\n      }\n      if (nativeVaoExtension_1) {\n        gl.createVertexArray = function() {\n          return nativeVaoExtension_1.createVertexArrayOES();\n        };\n        gl.bindVertexArray = function(vao) {\n          return nativeVaoExtension_1.bindVertexArrayOES(vao);\n        };\n        gl.deleteVertexArray = function(vao) {\n          return nativeVaoExtension_1.deleteVertexArrayOES(vao);\n        };\n      } else {\n        this.hasVao = false;\n        gl.createVertexArray = function() {\n          return null;\n        };\n        gl.bindVertexArray = function() {\n          return null;\n        };\n        gl.deleteVertexArray = function() {\n          return null;\n        };\n      }\n    }\n    if (context2.webGLVersion !== 2) {\n      var instanceExt_1 = gl.getExtension(\"ANGLE_instanced_arrays\");\n      if (instanceExt_1) {\n        gl.vertexAttribDivisor = function(a2, b2) {\n          return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);\n        };\n        gl.drawElementsInstanced = function(a2, b2, c2, d2, e) {\n          return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e);\n        };\n        gl.drawArraysInstanced = function(a2, b2, c2, d2) {\n          return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);\n        };\n      } else {\n        this.hasInstance = false;\n      }\n    }\n    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;\n  };\n  GeometrySystem2.prototype.bind = function(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    var gl = this.gl;\n    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    var incRefCount = false;\n    if (!vaos) {\n      this.managedGeometries[geometry.id] = geometry;\n      geometry.disposeRunner.add(this);\n      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n      incRefCount = true;\n    }\n    var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry;\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      if (this.hasVao) {\n        gl.bindVertexArray(vao);\n      } else {\n        this.activateVao(geometry, shader.program);\n      }\n    }\n    this.updateBuffers();\n  };\n  GeometrySystem2.prototype.reset = function() {\n    this.unbind();\n  };\n  GeometrySystem2.prototype.updateBuffers = function() {\n    var geometry = this._activeGeometry;\n    var bufferSystem = this.renderer.buffer;\n    for (var i2 = 0; i2 < geometry.buffers.length; i2++) {\n      var buffer = geometry.buffers[i2];\n      bufferSystem.update(buffer);\n    }\n  };\n  GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {\n    var geometryAttributes = geometry.attributes;\n    var shaderAttributes = program.attributeData;\n    for (var j2 in shaderAttributes) {\n      if (!geometryAttributes[j2]) {\n        throw new Error('shader and geometry incompatible, geometry missing the \"' + j2 + '\" attribute');\n      }\n    }\n  };\n  GeometrySystem2.prototype.getSignature = function(geometry, program) {\n    var attribs = geometry.attributes;\n    var shaderAttributes = program.attributeData;\n    var strings = [\"g\", geometry.id];\n    for (var i2 in attribs) {\n      if (shaderAttributes[i2]) {\n        strings.push(i2, shaderAttributes[i2].location);\n      }\n    }\n    return strings.join(\"-\");\n  };\n  GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {\n    if (incRefCount === void 0) {\n      incRefCount = true;\n    }\n    var gl = this.gl;\n    var CONTEXT_UID = this.CONTEXT_UID;\n    var bufferSystem = this.renderer.buffer;\n    var program = shader.program;\n    if (!program.glPrograms[CONTEXT_UID]) {\n      this.renderer.shader.generateProgram(shader);\n    }\n    this.checkCompatibility(geometry, program);\n    var signature = this.getSignature(geometry, program);\n    var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    var vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program.id] = vao;\n      return vao;\n    }\n    var buffers = geometry.buffers;\n    var attributes = geometry.attributes;\n    var tempStride = {};\n    var tempStart = {};\n    for (var j2 in buffers) {\n      tempStride[j2] = 0;\n      tempStart[j2] = 0;\n    }\n    for (var j2 in attributes) {\n      if (!attributes[j2].size && program.attributeData[j2]) {\n        attributes[j2].size = program.attributeData[j2].size;\n      } else if (!attributes[j2].size) {\n        console.warn(\"PIXI Geometry attribute '\" + j2 + \"' size cannot be determined (likely the bound shader does not have the attribute)\");\n      }\n      tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap[attributes[j2].type];\n    }\n    for (var j2 in attributes) {\n      var attribute = attributes[j2];\n      var attribSize = attribute.size;\n      if (attribute.stride === void 0) {\n        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {\n          attribute.stride = 0;\n        } else {\n          attribute.stride = tempStride[attribute.buffer];\n        }\n      }\n      if (attribute.start === void 0) {\n        attribute.start = tempStart[attribute.buffer];\n        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n      }\n    }\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (var i2 = 0; i2 < buffers.length; i2++) {\n      var buffer = buffers[i2];\n      bufferSystem.bind(buffer);\n      if (incRefCount) {\n        buffer._glBuffers[CONTEXT_UID].refCount++;\n      }\n    }\n    this.activateVao(geometry, program);\n    this._activeVao = vao;\n    vaoObjectHash[program.id] = vao;\n    vaoObjectHash[signature] = vao;\n    return vao;\n  };\n  GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {\n    var _a3;\n    if (!this.managedGeometries[geometry.id]) {\n      return;\n    }\n    delete this.managedGeometries[geometry.id];\n    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    var gl = this.gl;\n    var buffers = geometry.buffers;\n    var bufferSystem = (_a3 = this.renderer) === null || _a3 === void 0 ? void 0 : _a3.buffer;\n    geometry.disposeRunner.remove(this);\n    if (!vaos) {\n      return;\n    }\n    if (bufferSystem) {\n      for (var i2 = 0; i2 < buffers.length; i2++) {\n        var buf = buffers[i2]._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffers[i2], contextLost);\n          }\n        }\n      }\n    }\n    if (!contextLost) {\n      for (var vaoId in vaos) {\n        if (vaoId[0] === \"g\") {\n          var vao = vaos[vaoId];\n          if (this._activeVao === vao) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vao);\n        }\n      }\n    }\n    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n  };\n  GeometrySystem2.prototype.disposeAll = function(contextLost) {\n    var all2 = Object.keys(this.managedGeometries);\n    for (var i2 = 0; i2 < all2.length; i2++) {\n      this.disposeGeometry(this.managedGeometries[all2[i2]], contextLost);\n    }\n  };\n  GeometrySystem2.prototype.activateVao = function(geometry, program) {\n    var gl = this.gl;\n    var CONTEXT_UID = this.CONTEXT_UID;\n    var bufferSystem = this.renderer.buffer;\n    var buffers = geometry.buffers;\n    var attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    var lastBuffer = null;\n    for (var j2 in attributes) {\n      var attribute = attributes[j2];\n      var buffer = buffers[attribute.buffer];\n      var glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j2]) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        var location2 = program.attributeData[j2].location;\n        gl.enableVertexAttribArray(location2);\n        gl.vertexAttribPointer(location2, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location2, 1);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  };\n  GeometrySystem2.prototype.draw = function(type, size, start2, instanceCount) {\n    var gl = this.gl;\n    var geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n        if (geometry.instanced) {\n          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount || 1);\n        } else {\n          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);\n        }\n      } else {\n        console.warn(\"unsupported index buffer type: uint32\");\n      }\n    } else if (geometry.instanced) {\n      gl.drawArraysInstanced(type, start2, size || geometry.getSize(), instanceCount || 1);\n    } else {\n      gl.drawArrays(type, start2, size || geometry.getSize());\n    }\n    return this;\n  };\n  GeometrySystem2.prototype.unbind = function() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  };\n  GeometrySystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return GeometrySystem2;\n}();\nvar MaskData = function() {\n  function MaskData2(maskObject) {\n    if (maskObject === void 0) {\n      maskObject = null;\n    }\n    this.type = MASK_TYPES$3.NONE;\n    this.autoDetect = true;\n    this.maskObject = maskObject || null;\n    this.pooled = false;\n    this.isMaskData = true;\n    this.resolution = null;\n    this.multisample = settings.FILTER_MULTISAMPLE;\n    this.enabled = true;\n    this._filters = null;\n    this._stencilCounter = 0;\n    this._scissorCounter = 0;\n    this._scissorRect = null;\n    this._scissorRectLocal = null;\n    this._target = null;\n  }\n  Object.defineProperty(MaskData2.prototype, \"filter\", {\n    get: function() {\n      return this._filters ? this._filters[0] : null;\n    },\n    set: function(value2) {\n      if (value2) {\n        if (this._filters) {\n          this._filters[0] = value2;\n        } else {\n          this._filters = [value2];\n        }\n      } else {\n        this._filters = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MaskData2.prototype.reset = function() {\n    if (this.pooled) {\n      this.maskObject = null;\n      this.type = MASK_TYPES$3.NONE;\n      this.autoDetect = true;\n    }\n    this._target = null;\n    this._scissorRectLocal = null;\n  };\n  MaskData2.prototype.copyCountersOrReset = function(maskAbove) {\n    if (maskAbove) {\n      this._stencilCounter = maskAbove._stencilCounter;\n      this._scissorCounter = maskAbove._scissorCounter;\n      this._scissorRect = maskAbove._scissorRect;\n    } else {\n      this._stencilCounter = 0;\n      this._scissorCounter = 0;\n      this._scissorRect = null;\n    }\n  };\n  return MaskData2;\n}();\nfunction compileShader(gl, type, src) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\nfunction logPrettyShaderError(gl, shader) {\n  var shaderSrc = gl.getShaderSource(shader).split(\"\\n\").map(function(line, index) {\n    return index + \": \" + line;\n  });\n  var shaderLog = gl.getShaderInfoLog(shader);\n  var splitShader = shaderLog.split(\"\\n\");\n  var dedupe = {};\n  var lineNumbers = splitShader.map(function(line) {\n    return parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function(n) {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  var logArgs = [\"\"];\n  lineNumbers.forEach(function(number) {\n    shaderSrc[number - 1] = \"%c\" + shaderSrc[number - 1] + \"%c\";\n    logArgs.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var fragmentSourceToLog = shaderSrc.join(\"\\n\");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed(\"click to view full shader code\");\n  console.warn.apply(console, logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error(\"PixiJS Error: Could not initialize shader.\");\n    if (gl.getProgramInfoLog(program) !== \"\") {\n      console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", gl.getProgramInfoLog(program));\n    }\n  }\n}\nfunction booleanArray(size) {\n  var array = new Array(size);\n  for (var i2 = 0; i2 < array.length; i2++) {\n    array[i2] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * size);\n    case \"vec3\":\n      return new Float32Array(3 * size);\n    case \"vec4\":\n      return new Float32Array(4 * size);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * size);\n    case \"ivec3\":\n      return new Int32Array(3 * size);\n    case \"ivec4\":\n      return new Int32Array(4 * size);\n    case \"uvec2\":\n      return new Uint32Array(2 * size);\n    case \"uvec3\":\n      return new Uint32Array(3 * size);\n    case \"uvec4\":\n      return new Uint32Array(4 * size);\n    case \"bool\":\n      return false;\n    case \"bvec2\":\n      return booleanArray(2 * size);\n    case \"bvec3\":\n      return booleanArray(3 * size);\n    case \"bvec4\":\n      return booleanArray(4 * size);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar unknownContext = {};\nvar context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context && context.isContextLost()) {\n    var canvas = document.createElement(\"canvas\");\n    var gl = void 0;\n    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {\n      gl = canvas.getContext(\"webgl2\", {});\n    }\n    if (!gl) {\n      gl = canvas.getContext(\"webgl\", {}) || canvas.getContext(\"experimental-webgl\", {});\n      if (!gl) {\n        gl = null;\n      } else {\n        gl.getExtension(\"WEBGL_draw_buffers\");\n      }\n    }\n    context = gl;\n  }\n  return context;\n}\nvar maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION$3.MEDIUM;\n    var gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? PRECISION$3.HIGH : PRECISION$3.MEDIUM;\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\nfunction setPrecision(src, requestedPrecision, maxSupportedPrecision) {\n  if (src.substring(0, 9) !== \"precision\") {\n    var precision = requestedPrecision;\n    if (requestedPrecision === PRECISION$3.HIGH && maxSupportedPrecision !== PRECISION$3.HIGH) {\n      precision = PRECISION$3.MEDIUM;\n    }\n    return \"precision \" + precision + \" float;\\n\" + src;\n  } else if (maxSupportedPrecision !== PRECISION$3.HIGH && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\nvar GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\nvar GL_TABLE = null;\nvar GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    var typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (var i2 = 0; i2 < typeNames.length; ++i2) {\n      var tn = typeNames[i2];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\nvar uniformParsers = [\n  {\n    test: function(data) {\n      return data.type === \"float\" && data.size === 1;\n    },\n    code: function(name) {\n      return '\\n            if(uv[\"' + name + '\"] !== ud[\"' + name + '\"].value)\\n            {\\n                ud[\"' + name + '\"].value = uv[\"' + name + '\"]\\n                gl.uniform1f(ud[\"' + name + '\"].location, uv[\"' + name + '\"])\\n            }\\n            ';\n    }\n  },\n  {\n    test: function(data) {\n      return (data.type === \"sampler2D\" || data.type === \"samplerCube\" || data.type === \"sampler2DArray\") && data.size === 1 && !data.isArray;\n    },\n    code: function(name) {\n      return 't = syncData.textureCount++;\\n\\n            renderer.texture.bind(uv[\"' + name + '\"], t);\\n\\n            if(ud[\"' + name + '\"].value !== t)\\n            {\\n                ud[\"' + name + '\"].value = t;\\n                gl.uniform1i(ud[\"' + name + '\"].location, t);\\n; // eslint-disable-line max-len\\n            }';\n    }\n  },\n  {\n    test: function(data, uniform) {\n      return data.type === \"mat3\" && data.size === 1 && uniform.a !== void 0;\n    },\n    code: function(name) {\n      return '\\n            gl.uniformMatrix3fv(ud[\"' + name + '\"].location, false, uv[\"' + name + '\"].toArray(true));\\n            ';\n    },\n    codeUbo: function(name) {\n      return \"\\n                var \" + name + \"_matrix = uv.\" + name + \".toArray(true);\\n\\n                data[offset] = \" + name + \"_matrix[0];\\n                data[offset+1] = \" + name + \"_matrix[1];\\n                data[offset+2] = \" + name + \"_matrix[2];\\n        \\n                data[offset + 4] = \" + name + \"_matrix[3];\\n                data[offset + 5] = \" + name + \"_matrix[4];\\n                data[offset + 6] = \" + name + \"_matrix[5];\\n        \\n                data[offset + 8] = \" + name + \"_matrix[6];\\n                data[offset + 9] = \" + name + \"_matrix[7];\\n                data[offset + 10] = \" + name + \"_matrix[8];\\n            \";\n    }\n  },\n  {\n    test: function(data, uniform) {\n      return data.type === \"vec2\" && data.size === 1 && uniform.x !== void 0;\n    },\n    code: function(name) {\n      return '\\n                cv = ud[\"' + name + '\"].value;\\n                v = uv[\"' + name + '\"];\\n\\n                if(cv[0] !== v.x || cv[1] !== v.y)\\n                {\\n                    cv[0] = v.x;\\n                    cv[1] = v.y;\\n                    gl.uniform2f(ud[\"' + name + '\"].location, v.x, v.y);\\n                }';\n    },\n    codeUbo: function(name) {\n      return \"\\n                v = uv.\" + name + \";\\n\\n                data[offset] = v.x;\\n                data[offset+1] = v.y;\\n            \";\n    }\n  },\n  {\n    test: function(data) {\n      return data.type === \"vec2\" && data.size === 1;\n    },\n    code: function(name) {\n      return '\\n                cv = ud[\"' + name + '\"].value;\\n                v = uv[\"' + name + '\"];\\n\\n                if(cv[0] !== v[0] || cv[1] !== v[1])\\n                {\\n                    cv[0] = v[0];\\n                    cv[1] = v[1];\\n                    gl.uniform2f(ud[\"' + name + '\"].location, v[0], v[1]);\\n                }\\n            ';\n    }\n  },\n  {\n    test: function(data, uniform) {\n      return data.type === \"vec4\" && data.size === 1 && uniform.width !== void 0;\n    },\n    code: function(name) {\n      return '\\n                cv = ud[\"' + name + '\"].value;\\n                v = uv[\"' + name + '\"];\\n\\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\\n                {\\n                    cv[0] = v.x;\\n                    cv[1] = v.y;\\n                    cv[2] = v.width;\\n                    cv[3] = v.height;\\n                    gl.uniform4f(ud[\"' + name + '\"].location, v.x, v.y, v.width, v.height)\\n                }';\n    },\n    codeUbo: function(name) {\n      return \"\\n                    v = uv.\" + name + \";\\n\\n                    data[offset] = v.x;\\n                    data[offset+1] = v.y;\\n                    data[offset+2] = v.width;\\n                    data[offset+3] = v.height;\\n                \";\n    }\n  },\n  {\n    test: function(data) {\n      return data.type === \"vec4\" && data.size === 1;\n    },\n    code: function(name) {\n      return '\\n                cv = ud[\"' + name + '\"].value;\\n                v = uv[\"' + name + '\"];\\n\\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n                {\\n                    cv[0] = v[0];\\n                    cv[1] = v[1];\\n                    cv[2] = v[2];\\n                    cv[3] = v[3];\\n\\n                    gl.uniform4f(ud[\"' + name + '\"].location, v[0], v[1], v[2], v[3])\\n                }';\n    }\n  }\n];\nvar GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n        gl.uniform1f(location, v);\\n    }\",\n  vec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2f(location, v[0], v[1])\\n    }\",\n  vec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3f(location, v[0], v[1], v[2])\\n    }\",\n  vec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  int: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1i(location, v);\\n    }\",\n  ivec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2i(location, v[0], v[1]);\\n    }\",\n  ivec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3i(location, v[0], v[1], v[2]);\\n    }\",\n  ivec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  uint: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1ui(location, v);\\n    }\",\n  uvec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2ui(location, v[0], v[1]);\\n    }\",\n  uvec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3ui(location, v[0], v[1], v[2]);\\n    }\",\n  uvec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  bool: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n        gl.uniform1i(location, v);\\n    }\",\n  bvec2: \"\\n    if (cv[0] != v[0] || cv[1] != v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2i(location, v[0], v[1]);\\n    }\",\n  bvec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3i(location, v[0], v[1], v[2]);\\n    }\",\n  bvec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: \"gl.uniform1i(location, v)\",\n  samplerCube: \"gl.uniform1i(location, v)\",\n  sampler2DArray: \"gl.uniform1i(location, v)\"\n};\nvar GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(group, uniformData) {\n  var _a3;\n  var funcFragments = [\"\\n        var v = null;\\n        var cv = null;\\n        var cu = null;\\n        var t = 0;\\n        var gl = renderer.gl;\\n    \"];\n  for (var i2 in group.uniforms) {\n    var data = uniformData[i2];\n    if (!data) {\n      if ((_a3 = group.uniforms[i2]) === null || _a3 === void 0 ? void 0 : _a3.group) {\n        if (group.uniforms[i2].ubo) {\n          funcFragments.push(\"\\n                        renderer.shader.syncUniformBufferGroup(uv.\" + i2 + \", '\" + i2 + \"');\\n                    \");\n        } else {\n          funcFragments.push(\"\\n                        renderer.shader.syncUniformGroup(uv.\" + i2 + \", syncData);\\n                    \");\n        }\n      }\n      continue;\n    }\n    var uniform = group.uniforms[i2];\n    var parsed = false;\n    for (var j2 = 0; j2 < uniformParsers.length; j2++) {\n      if (uniformParsers[j2].test(data, uniform)) {\n        funcFragments.push(uniformParsers[j2].code(i2, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n      var template = templateType[data.type].replace(\"location\", 'ud[\"' + i2 + '\"].location');\n      funcFragments.push('\\n            cu = ud[\"' + i2 + '\"];\\n            cv = cu.value;\\n            v = uv[\"' + i2 + '\"];\\n            ' + template + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\nvar fragTemplate$1 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  var src = \"\";\n  for (var i2 = 0; i2 < maxIfs; ++i2) {\n    if (i2 > 0) {\n      src += \"\\nelse \";\n    }\n    if (i2 < maxIfs - 1) {\n      src += \"if(test == \" + i2 + \".0){}\";\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  var shader = gl.createShader(gl.FRAGMENT_SHADER);\n  while (true) {\n    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    gl.shaderSource(shader, fragmentSrc);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      maxIfs = maxIfs / 2 | 0;\n    } else {\n      break;\n    }\n  }\n  return maxIfs;\n}\nvar unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    var func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\nvar defaultFragment$2 = \"varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\\n}\";\nvar defaultVertex$3 = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord;\\n}\\n\";\nvar UID$1 = 0;\nvar nameCache = {};\nvar Program = function() {\n  function Program2(vertexSrc, fragmentSrc, name) {\n    if (name === void 0) {\n      name = \"pixi-shader\";\n    }\n    this.id = UID$1++;\n    this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;\n    this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;\n    this.vertexSrc = this.vertexSrc.trim();\n    this.fragmentSrc = this.fragmentSrc.trim();\n    if (this.vertexSrc.substring(0, 8) !== \"#version\") {\n      name = name.replace(/\\s+/g, \"-\");\n      if (nameCache[name]) {\n        nameCache[name]++;\n        name += \"-\" + nameCache[name];\n      } else {\n        nameCache[name] = 1;\n      }\n      this.vertexSrc = \"#define SHADER_NAME \" + name + \"\\n\" + this.vertexSrc;\n      this.fragmentSrc = \"#define SHADER_NAME \" + name + \"\\n\" + this.fragmentSrc;\n      this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION$3.HIGH);\n      this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());\n    }\n    this.glPrograms = {};\n    this.syncUniforms = null;\n  }\n  Object.defineProperty(Program2, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$3;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Program2, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Program2.from = function(vertexSrc, fragmentSrc, name) {\n    var key = vertexSrc + fragmentSrc;\n    var program = ProgramCache[key];\n    if (!program) {\n      ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name);\n    }\n    return program;\n  };\n  return Program2;\n}();\nvar Shader = function() {\n  function Shader2(program, uniforms) {\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup({});\n    }\n  }\n  Shader2.prototype.checkUniformExists = function(name, group) {\n    if (group.uniforms[name]) {\n      return true;\n    }\n    for (var i2 in group.uniforms) {\n      var uniform = group.uniforms[i2];\n      if (uniform.group) {\n        if (this.checkUniformExists(name, uniform)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  Shader2.prototype.destroy = function() {\n    this.uniformGroup = null;\n  };\n  Object.defineProperty(Shader2.prototype, \"uniforms\", {\n    get: function() {\n      return this.uniformGroup.uniforms;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {\n    var program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader2(program, uniforms);\n  };\n  return Shader2;\n}();\nvar BLEND$1 = 0;\nvar OFFSET$1 = 1;\nvar CULLING$1 = 2;\nvar DEPTH_TEST$1 = 3;\nvar WINDING$1 = 4;\nvar DEPTH_MASK$1 = 5;\nvar State = function() {\n  function State2() {\n    this.data = 0;\n    this.blendMode = BLEND_MODES$3.NORMAL;\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  Object.defineProperty(State2.prototype, \"blend\", {\n    get: function() {\n      return !!(this.data & 1 << BLEND$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << BLEND$1) !== value2) {\n        this.data ^= 1 << BLEND$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"offsets\", {\n    get: function() {\n      return !!(this.data & 1 << OFFSET$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << OFFSET$1) !== value2) {\n        this.data ^= 1 << OFFSET$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"culling\", {\n    get: function() {\n      return !!(this.data & 1 << CULLING$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << CULLING$1) !== value2) {\n        this.data ^= 1 << CULLING$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"depthTest\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_TEST$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << DEPTH_TEST$1) !== value2) {\n        this.data ^= 1 << DEPTH_TEST$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"depthMask\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_MASK$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << DEPTH_MASK$1) !== value2) {\n        this.data ^= 1 << DEPTH_MASK$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"clockwiseFrontFace\", {\n    get: function() {\n      return !!(this.data & 1 << WINDING$1);\n    },\n    set: function(value2) {\n      if (!!(this.data & 1 << WINDING$1) !== value2) {\n        this.data ^= 1 << WINDING$1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"blendMode\", {\n    get: function() {\n      return this._blendMode;\n    },\n    set: function(value2) {\n      this.blend = value2 !== BLEND_MODES$3.NONE;\n      this._blendMode = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State2.prototype, \"polygonOffset\", {\n    get: function() {\n      return this._polygonOffset;\n    },\n    set: function(value2) {\n      this.offsets = !!value2;\n      this._polygonOffset = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  State2.prototype.toString = function() {\n    return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n  };\n  State2.for2d = function() {\n    var state = new State2();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  };\n  return State2;\n}();\nvar defaultVertex$2 = \"attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\nvar defaultFragment$1 = \"varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\\n}\\n\";\nvar Filter = function(_super) {\n  __extends$q(Filter2, _super);\n  function Filter2(vertexSrc, fragmentSrc, uniforms) {\n    var _this = this;\n    var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);\n    _this = _super.call(this, program, uniforms) || this;\n    _this.padding = 0;\n    _this.resolution = settings.FILTER_RESOLUTION;\n    _this.multisample = settings.FILTER_MULTISAMPLE;\n    _this.enabled = true;\n    _this.autoFit = true;\n    _this.state = new State();\n    return _this;\n  }\n  Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  };\n  Object.defineProperty(Filter2.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(value2) {\n      this.state.blendMode = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Filter2.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(value2) {\n      this._resolution = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Filter2, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Filter2, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Filter2;\n}(Shader);\nvar vertex$4 = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n}\\n\";\nvar fragment$7 = \"varying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mask;\\nuniform float alpha;\\nuniform float npmAlpha;\\nuniform vec4 maskClamp;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(maskClamp.x, vMaskCoord.x) +\\n        step(maskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, maskClamp.z) +\\n        step(vMaskCoord.y, maskClamp.w));\\n\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    original *= (alphaMul * masky.r * alpha * clip);\\n\\n    gl_FragColor = original;\\n}\\n\";\nvar tempMat$1 = new Matrix();\nvar TextureMatrix = function() {\n  function TextureMatrix2(texture, clampMargin) {\n    this._texture = texture;\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    this.clampMargin = typeof clampMargin === \"undefined\" ? 0.5 : clampMargin;\n    this.isSimple = false;\n  }\n  Object.defineProperty(TextureMatrix2.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(value2) {\n      this._texture = value2;\n      this._textureID = -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    var mat = this.mapCoord;\n    for (var i2 = 0; i2 < uvs.length; i2 += 2) {\n      var x2 = uvs[i2];\n      var y2 = uvs[i2 + 1];\n      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;\n      out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;\n    }\n    return out;\n  };\n  TextureMatrix2.prototype.update = function(forceUpdate) {\n    var tex = this._texture;\n    if (!tex || !tex.valid) {\n      return false;\n    }\n    if (!forceUpdate && this._textureID === tex._updateID) {\n      return false;\n    }\n    this._textureID = tex._updateID;\n    this._updateID++;\n    var uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    var orig = tex.orig;\n    var trim2 = tex.trim;\n    if (trim2) {\n      tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);\n      this.mapCoord.append(tempMat$1);\n    }\n    var texBase = tex.baseTexture;\n    var frame = this.uClampFrame;\n    var margin = this.clampMargin / texBase.resolution;\n    var offset2 = this.clampOffset;\n    frame[0] = (tex._frame.x + margin + offset2) / texBase.width;\n    frame[1] = (tex._frame.y + margin + offset2) / texBase.height;\n    frame[2] = (tex._frame.x + tex._frame.width - margin + offset2) / texBase.width;\n    frame[3] = (tex._frame.y + tex._frame.height - margin + offset2) / texBase.height;\n    this.uClampOffset[0] = offset2 / texBase.realWidth;\n    this.uClampOffset[1] = offset2 / texBase.realHeight;\n    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  };\n  return TextureMatrix2;\n}();\nvar SpriteMaskFilter = function(_super) {\n  __extends$q(SpriteMaskFilter2, _super);\n  function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {\n    var _this = this;\n    var sprite = null;\n    if (typeof vertexSrc !== \"string\" && fragmentSrc === void 0 && uniforms === void 0) {\n      sprite = vertexSrc;\n      vertexSrc = void 0;\n      fragmentSrc = void 0;\n      uniforms = void 0;\n    }\n    _this = _super.call(this, vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms) || this;\n    _this.maskSprite = sprite;\n    _this.maskMatrix = new Matrix();\n    return _this;\n  }\n  Object.defineProperty(SpriteMaskFilter2.prototype, \"maskSprite\", {\n    get: function() {\n      return this._maskSprite;\n    },\n    set: function(value2) {\n      this._maskSprite = value2;\n      if (this._maskSprite) {\n        this._maskSprite.renderable = false;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {\n    var maskSprite = this._maskSprite;\n    var tex = maskSprite._texture;\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.uvMatrix) {\n      tex.uvMatrix = new TextureMatrix(tex, 0);\n    }\n    tex.uvMatrix.update();\n    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\n    filterManager.applyFilter(this, input, output, clearMode);\n  };\n  return SpriteMaskFilter2;\n}(Filter);\nvar MaskSystem = function() {\n  function MaskSystem2(renderer) {\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  MaskSystem2.prototype.setMaskStack = function(maskStack) {\n    this.maskStack = maskStack;\n    this.renderer.scissor.setMaskStack(maskStack);\n    this.renderer.stencil.setMaskStack(maskStack);\n  };\n  MaskSystem2.prototype.push = function(target, maskDataOrTarget) {\n    var maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      var d2 = this.maskDataPool.pop() || new MaskData();\n      d2.pooled = true;\n      d2.maskObject = maskDataOrTarget;\n      maskData = d2;\n    }\n    var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    maskData.copyCountersOrReset(maskAbove);\n    if (maskData.autoDetect) {\n      this.detect(maskData);\n    }\n    maskData._target = target;\n    if (maskData.type !== MASK_TYPES$3.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES$3.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case MASK_TYPES$3.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case MASK_TYPES$3.SPRITE:\n          maskData.copyCountersOrReset(null);\n          this.pushSpriteMask(maskData);\n          break;\n      }\n    }\n    if (maskData.type === MASK_TYPES$3.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n  };\n  MaskSystem2.prototype.pop = function(target) {\n    var maskData = this.maskStack.pop();\n    if (!maskData || maskData._target !== target) {\n      return;\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case MASK_TYPES$3.SCISSOR:\n          this.renderer.scissor.pop();\n          break;\n        case MASK_TYPES$3.STENCIL:\n          this.renderer.stencil.pop(maskData.maskObject);\n          break;\n        case MASK_TYPES$3.SPRITE:\n          this.popSpriteMask(maskData);\n          break;\n      }\n    }\n    maskData.reset();\n    if (maskData.pooled) {\n      this.maskDataPool.push(maskData);\n    }\n    if (this.maskStack.length !== 0) {\n      var maskCurrent = this.maskStack[this.maskStack.length - 1];\n      if (maskCurrent.type === MASK_TYPES$3.SPRITE && maskCurrent._filters) {\n        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n      }\n    }\n  };\n  MaskSystem2.prototype.detect = function(maskData) {\n    var maskObject = maskData.maskObject;\n    if (maskObject.isSprite) {\n      maskData.type = MASK_TYPES$3.SPRITE;\n    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n      maskData.type = MASK_TYPES$3.SCISSOR;\n    } else {\n      maskData.type = MASK_TYPES$3.STENCIL;\n    }\n  };\n  MaskSystem2.prototype.pushSpriteMask = function(maskData) {\n    var _a3, _b3;\n    var maskObject = maskData.maskObject;\n    var target = maskData._target;\n    var alphaMaskFilter = maskData._filters;\n    if (!alphaMaskFilter) {\n      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n      }\n    }\n    var renderer = this.renderer;\n    var renderTextureSystem = renderer.renderTexture;\n    var resolution;\n    var multisample;\n    if (renderTextureSystem.current) {\n      var renderTexture = renderTextureSystem.current;\n      resolution = maskData.resolution || renderTexture.resolution;\n      multisample = (_a3 = maskData.multisample) !== null && _a3 !== void 0 ? _a3 : renderTexture.multisample;\n    } else {\n      resolution = maskData.resolution || renderer.resolution;\n      multisample = (_b3 = maskData.multisample) !== null && _b3 !== void 0 ? _b3 : renderer.multisample;\n    }\n    alphaMaskFilter[0].resolution = resolution;\n    alphaMaskFilter[0].multisample = multisample;\n    alphaMaskFilter[0].maskSprite = maskObject;\n    var stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(true);\n    renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n    if (!maskData._filters) {\n      this.alphaMaskIndex++;\n    }\n  };\n  MaskSystem2.prototype.popSpriteMask = function(maskData) {\n    this.renderer.filter.pop();\n    if (maskData._filters) {\n      maskData._filters[0].maskSprite = null;\n    } else {\n      this.alphaMaskIndex--;\n      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n    }\n  };\n  MaskSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return MaskSystem2;\n}();\nvar AbstractMaskSystem = function() {\n  function AbstractMaskSystem2(renderer) {\n    this.renderer = renderer;\n    this.maskStack = [];\n    this.glConst = 0;\n  }\n  AbstractMaskSystem2.prototype.getStackLength = function() {\n    return this.maskStack.length;\n  };\n  AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {\n    var gl = this.renderer.gl;\n    var curStackLen = this.getStackLength();\n    this.maskStack = maskStack;\n    var newStackLen = this.getStackLength();\n    if (newStackLen !== curStackLen) {\n      if (newStackLen === 0) {\n        gl.disable(this.glConst);\n      } else {\n        gl.enable(this.glConst);\n        this._useCurrent();\n      }\n    }\n  };\n  AbstractMaskSystem2.prototype._useCurrent = function() {\n  };\n  AbstractMaskSystem2.prototype.destroy = function() {\n    this.renderer = null;\n    this.maskStack = null;\n  };\n  return AbstractMaskSystem2;\n}();\nvar tempMatrix$1 = new Matrix();\nvar ScissorSystem = function(_super) {\n  __extends$q(ScissorSystem2, _super);\n  function ScissorSystem2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.glConst = WebGLRenderingContext.SCISSOR_TEST;\n    return _this;\n  }\n  ScissorSystem2.prototype.getStackLength = function() {\n    var maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._scissorCounter;\n    }\n    return 0;\n  };\n  ScissorSystem2.prototype.calcScissorRect = function(maskData) {\n    if (maskData._scissorRectLocal) {\n      return;\n    }\n    var prevData = maskData._scissorRect;\n    var maskObject = maskData.maskObject;\n    var renderer = this.renderer;\n    var renderTextureSystem = renderer.renderTexture;\n    maskObject.renderable = true;\n    var rect = maskObject.getBounds();\n    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    maskObject.renderable = false;\n    if (prevData) {\n      rect.fit(prevData);\n    }\n    maskData._scissorRectLocal = rect;\n  };\n  ScissorSystem2.isMatrixRotated = function(matrix) {\n    if (!matrix) {\n      return false;\n    }\n    var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d;\n    return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);\n  };\n  ScissorSystem2.prototype.testScissor = function(maskData) {\n    var maskObject = maskData.maskObject;\n    if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n      return false;\n    }\n    if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {\n      return false;\n    }\n    if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {\n      return false;\n    }\n    this.calcScissorRect(maskData);\n    var rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  };\n  ScissorSystem2.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (ScissorSystem2.isMatrixRotated(transform)) {\n      return;\n    }\n    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.renderer.filter.transformAABB(transform, frame);\n    frame.fit(bindingDestinationFrame);\n    frame.x = Math.round(frame.x * resolution);\n    frame.y = Math.round(frame.y * resolution);\n    frame.width = Math.round(frame.width * resolution);\n    frame.height = Math.round(frame.height * resolution);\n  };\n  ScissorSystem2.prototype.push = function(maskData) {\n    if (!maskData._scissorRectLocal) {\n      this.calcScissorRect(maskData);\n    }\n    var gl = this.renderer.gl;\n    if (!maskData._scissorRect) {\n      gl.enable(gl.SCISSOR_TEST);\n    }\n    maskData._scissorCounter++;\n    maskData._scissorRect = maskData._scissorRectLocal;\n    this._useCurrent();\n  };\n  ScissorSystem2.prototype.pop = function() {\n    var gl = this.renderer.gl;\n    if (this.getStackLength() > 0) {\n      this._useCurrent();\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  };\n  ScissorSystem2.prototype._useCurrent = function() {\n    var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    var y2;\n    if (this.renderer.renderTexture.current) {\n      y2 = rect.y;\n    } else {\n      y2 = this.renderer.height - rect.height - rect.y;\n    }\n    this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);\n  };\n  return ScissorSystem2;\n}(AbstractMaskSystem);\nvar StencilSystem = function(_super) {\n  __extends$q(StencilSystem2, _super);\n  function StencilSystem2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.glConst = WebGLRenderingContext.STENCIL_TEST;\n    return _this;\n  }\n  StencilSystem2.prototype.getStackLength = function() {\n    var maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._stencilCounter;\n    }\n    return 0;\n  };\n  StencilSystem2.prototype.push = function(maskData) {\n    var maskObject = maskData.maskObject;\n    var gl = this.renderer.gl;\n    var prevMaskCount = maskData._stencilCounter;\n    if (prevMaskCount === 0) {\n      this.renderer.framebuffer.forceStencil();\n      gl.clearStencil(0);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.enable(gl.STENCIL_TEST);\n    }\n    maskData._stencilCounter++;\n    gl.colorMask(false, false, false, false);\n    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    maskObject.renderable = true;\n    maskObject.render(this.renderer);\n    this.renderer.batch.flush();\n    maskObject.renderable = false;\n    this._useCurrent();\n  };\n  StencilSystem2.prototype.pop = function(maskObject) {\n    var gl = this.renderer.gl;\n    if (this.getStackLength() === 0) {\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      gl.colorMask(false, false, false, false);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n      maskObject.renderable = true;\n      maskObject.render(this.renderer);\n      this.renderer.batch.flush();\n      maskObject.renderable = false;\n      this._useCurrent();\n    }\n  };\n  StencilSystem2.prototype._useCurrent = function() {\n    var gl = this.renderer.gl;\n    gl.colorMask(true, true, true, true);\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  };\n  return StencilSystem2;\n}(AbstractMaskSystem);\nvar ProjectionSystem = function() {\n  function ProjectionSystem2(renderer) {\n    this.renderer = renderer;\n    this.destinationFrame = null;\n    this.sourceFrame = null;\n    this.defaultFrame = null;\n    this.projectionMatrix = new Matrix();\n    this.transform = null;\n  }\n  ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;\n    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);\n    if (this.transform) {\n      this.projectionMatrix.append(this.transform);\n    }\n    var renderer = this.renderer;\n    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;\n    renderer.globalUniforms.update();\n    if (renderer.shader.shader) {\n      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);\n    }\n  };\n  ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {\n    var pm = this.projectionMatrix;\n    var sign2 = !root ? 1 : -1;\n    pm.identity();\n    pm.a = 1 / sourceFrame.width * 2;\n    pm.d = sign2 * (1 / sourceFrame.height * 2);\n    pm.tx = -1 - sourceFrame.x * pm.a;\n    pm.ty = -sign2 - sourceFrame.y * pm.d;\n  };\n  ProjectionSystem2.prototype.setTransform = function(_matrix) {\n  };\n  ProjectionSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return ProjectionSystem2;\n}();\nvar tempRect = new Rectangle();\nvar tempRect2 = new Rectangle();\nvar RenderTextureSystem = function() {\n  function RenderTextureSystem2(renderer) {\n    this.renderer = renderer;\n    this.clearColor = renderer._backgroundColorRgba;\n    this.defaultMaskStack = [];\n    this.current = null;\n    this.sourceFrame = new Rectangle();\n    this.destinationFrame = new Rectangle();\n    this.viewportFrame = new Rectangle();\n  }\n  RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {\n    if (renderTexture === void 0) {\n      renderTexture = null;\n    }\n    var renderer = this.renderer;\n    this.current = renderTexture;\n    var baseTexture;\n    var framebuffer;\n    var resolution;\n    if (renderTexture) {\n      baseTexture = renderTexture.baseTexture;\n      resolution = baseTexture.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderTexture.frame.width;\n        tempRect.height = renderTexture.frame.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        tempRect2.x = renderTexture.frame.x;\n        tempRect2.y = renderTexture.frame.y;\n        tempRect2.width = sourceFrame.width;\n        tempRect2.height = sourceFrame.height;\n        destinationFrame = tempRect2;\n      }\n      framebuffer = baseTexture.framebuffer;\n    } else {\n      resolution = renderer.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderer.screen.width;\n        tempRect.height = renderer.screen.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        destinationFrame = tempRect;\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n      }\n    }\n    var viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution;\n    viewportFrame.y = destinationFrame.y * resolution;\n    viewportFrame.width = destinationFrame.width * resolution;\n    viewportFrame.height = destinationFrame.height * resolution;\n    if (!renderTexture) {\n      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n    }\n    viewportFrame.ceil();\n    this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n    if (renderTexture) {\n      this.renderer.mask.setMaskStack(baseTexture.maskStack);\n    } else {\n      this.renderer.mask.setMaskStack(this.defaultMaskStack);\n    }\n    this.sourceFrame.copyFrom(sourceFrame);\n    this.destinationFrame.copyFrom(destinationFrame);\n  };\n  RenderTextureSystem2.prototype.clear = function(clearColor, mask) {\n    if (this.current) {\n      clearColor = clearColor || this.current.baseTexture.clearColor;\n    } else {\n      clearColor = clearColor || this.clearColor;\n    }\n    var destinationFrame = this.destinationFrame;\n    var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;\n    var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      var _a3 = this.viewportFrame, x2 = _a3.x, y2 = _a3.y, width = _a3.width, height = _a3.height;\n      x2 = Math.round(x2);\n      y2 = Math.round(y2);\n      width = Math.round(width);\n      height = Math.round(height);\n      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n      this.renderer.gl.scissor(x2, y2, width, height);\n    }\n    this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);\n    if (clearMask) {\n      this.renderer.scissor.pop();\n    }\n  };\n  RenderTextureSystem2.prototype.resize = function() {\n    this.bind(null);\n  };\n  RenderTextureSystem2.prototype.reset = function() {\n    this.bind(null);\n  };\n  RenderTextureSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return RenderTextureSystem2;\n}();\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: \"\\n        data[offset] = v;\\n    \",\n  vec2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n    \",\n  vec3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n    \",\n  vec4: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n        data[offset+3] = v[3];\\n    \",\n  mat2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n\\n        data[offset+4] = v[2];\\n        data[offset+5] = v[3];\\n    \",\n  mat3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n        data[offset + 4] = v[3];\\n        data[offset + 5] = v[4];\\n        data[offset + 6] = v[5];\\n\\n        data[offset + 8] = v[6];\\n        data[offset + 9] = v[7];\\n        data[offset + 10] = v[8];\\n    \",\n  mat4: \"\\n        for(var i = 0; i < 16; i++)\\n        {\\n            data[offset + i] = v[i];\\n        }\\n    \"\n};\nvar GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  var uboElements = uniformData.map(function(data) {\n    return {\n      data,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  });\n  var size = 0;\n  var chunkSize = 0;\n  var offset2 = 0;\n  for (var i2 = 0; i2 < uboElements.length; i2++) {\n    var uboElement = uboElements[i2];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      var lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset2 += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset2 = Math.ceil(offset2 / 16) * 16;\n      uboElement.offset = offset2;\n      offset2 += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset2;\n      chunkSize += size;\n      offset2 += size;\n    }\n  }\n  offset2 = Math.ceil(offset2 / 16) * 16;\n  return { uboElements, size: offset2 };\n}\nfunction getUBOData(uniforms, uniformData) {\n  var usedUniformDatas = [];\n  for (var i2 in uniforms) {\n    if (uniformData[i2]) {\n      usedUniformDatas.push(uniformData[i2]);\n    }\n  }\n  usedUniformDatas.sort(function(a2, b2) {\n    return a2.index - b2.index;\n  });\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return { size: 0, syncFunc: uboUpdate };\n  }\n  var usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  var _a3 = createUBOElements(usedUniformDatas), uboElements = _a3.uboElements, size = _a3.size;\n  var funcFragments = [\"\\n    var v = null;\\n    var v2 = null;\\n    var cv = null;\\n    var t = 0;\\n    var gl = renderer.gl\\n    var index = 0;\\n    var data = buffer.data;\\n    \"];\n  for (var i2 = 0; i2 < uboElements.length; i2++) {\n    var uboElement = uboElements[i2];\n    var uniform = group.uniforms[uboElement.data.name];\n    var name = uboElement.data.name;\n    var parsed = false;\n    for (var j2 = 0; j2 < uniformParsers.length; j2++) {\n      var uniformParser = uniformParsers[j2];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(\"offset = \" + uboElement.offset / 4 + \";\", uniformParsers[j2].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        var size_1 = mapSize(uboElement.data.type);\n        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        var elementSize = size_1 / rowSize;\n        var remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(\"\\n                cv = ud.\" + name + \".value;\\n                v = uv.\" + name + \";\\n                offset = \" + uboElement.offset / 4 + \";\\n\\n                t = 0;\\n\\n                for(var i=0; i < \" + uboElement.data.size * rowSize + \"; i++)\\n                {\\n                    for(var j = 0; j < \" + elementSize + \"; j++)\\n                    {\\n                        data[offset++] = v[t++];\\n                    }\\n                    offset += \" + remainder + \";\\n                }\\n\\n                \");\n      } else {\n        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(\"\\n                cv = ud.\" + name + \".value;\\n                v = uv.\" + name + \";\\n                offset = \" + uboElement.offset / 4 + \";\\n                \" + template + \";\\n                \");\n      }\n    }\n  }\n  funcFragments.push(\"\\n       renderer.buffer.update(buffer);\\n    \");\n  return {\n    size,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", funcFragments.join(\"\\n\"))\n  };\n}\nvar GLProgram = function() {\n  function GLProgram2(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBufferBindings = {};\n  }\n  GLProgram2.prototype.destroy = function() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBufferBindings = null;\n    this.program = null;\n  };\n  return GLProgram2;\n}();\nfunction getAttributeData(program, gl) {\n  var attributes = {};\n  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (var i2 = 0; i2 < totalAttributes; i2++) {\n    var attribData = gl.getActiveAttrib(program, i2);\n    if (attribData.name.indexOf(\"gl_\") === 0) {\n      continue;\n    }\n    var type = mapType(gl, attribData.type);\n    var data = {\n      type,\n      name: attribData.name,\n      size: mapSize(type),\n      location: gl.getAttribLocation(program, attribData.name)\n    };\n    attributes[attribData.name] = data;\n  }\n  return attributes;\n}\nfunction getUniformData(program, gl) {\n  var uniforms = {};\n  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (var i2 = 0; i2 < totalUniforms; i2++) {\n    var uniformData = gl.getActiveUniform(program, i2);\n    var name = uniformData.name.replace(/\\[.*?\\]$/, \"\");\n    var isArray2 = !!uniformData.name.match(/\\[.*?\\]$/);\n    var type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i2,\n      type,\n      size: uniformData.size,\n      isArray: isArray2,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\nfunction generateProgram(gl, program) {\n  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);\n  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);\n  var webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program.attributeData = getAttributeData(webGLProgram, gl);\n  program.uniformData = getUniformData(webGLProgram, gl);\n  if (!/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    var keys = Object.keys(program.attributeData);\n    keys.sort(function(a2, b2) {\n      return a2 > b2 ? 1 : -1;\n    });\n    for (var i2 = 0; i2 < keys.length; i2++) {\n      program.attributeData[keys[i2]].location = i2;\n      gl.bindAttribLocation(webGLProgram, i2, keys[i2]);\n    }\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  var uniformData = {};\n  for (var i2 in program.uniformData) {\n    var data = program.uniformData[i2];\n    uniformData[i2] = {\n      location: gl.getUniformLocation(webGLProgram, i2),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  var glProgram = new GLProgram(webGLProgram, uniformData);\n  return glProgram;\n}\nvar UID = 0;\nvar defaultSyncData = { textureCount: 0, uboCount: 0 };\nvar ShaderSystem = function() {\n  function ShaderSystem2(renderer) {\n    this.destroyed = false;\n    this.renderer = renderer;\n    this.systemCheck();\n    this.gl = null;\n    this.shader = null;\n    this.program = null;\n    this.cache = {};\n    this._uboCache = {};\n    this.id = UID++;\n  }\n  ShaderSystem2.prototype.systemCheck = function() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n    }\n  };\n  ShaderSystem2.prototype.contextChange = function(gl) {\n    this.gl = gl;\n    this.reset();\n  };\n  ShaderSystem2.prototype.bind = function(shader, dontSync) {\n    shader.uniforms.globals = this.renderer.globalUniforms;\n    var program = shader.program;\n    var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n    this.shader = shader;\n    if (this.program !== program) {\n      this.program = program;\n      this.gl.useProgram(glProgram.program);\n    }\n    if (!dontSync) {\n      defaultSyncData.textureCount = 0;\n      defaultSyncData.uboCount = 0;\n      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);\n    }\n    return glProgram;\n  };\n  ShaderSystem2.prototype.setUniforms = function(uniforms) {\n    var shader = this.shader.program;\n    var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n  };\n  ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {\n    var glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {\n      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;\n      this.syncUniforms(group, glProgram, syncData);\n    }\n  };\n  ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {\n    var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);\n    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n  };\n  ShaderSystem2.prototype.createSyncGroups = function(group) {\n    var id = this.getSignature(group, this.shader.program.uniformData, \"u\");\n    if (!this.cache[id]) {\n      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);\n    }\n    group.syncUniforms[this.shader.program.id] = this.cache[id];\n    return group.syncUniforms[this.shader.program.id];\n  };\n  ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name) {\n    var glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n      group.dirtyId = 0;\n      var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n      group.buffer.update();\n      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n  };\n  ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name) {\n    var gl = this.renderer.gl;\n    this.renderer.buffer.bind(group.buffer);\n    var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;\n    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);\n    this.shader.uniformBindCount++;\n    var id = this.getSignature(group, this.shader.program.uniformData, \"ubo\");\n    var uboData = this._uboCache[id];\n    if (!uboData) {\n      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);\n    }\n    if (group.autoManage) {\n      var data = new Float32Array(uboData.size / 4);\n      group.buffer.update(data);\n    }\n    glProgram.uniformGroups[group.id] = uboData.syncFunc;\n    return glProgram.uniformGroups[group.id];\n  };\n  ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {\n    var uniforms = group.uniforms;\n    var strings = [preFix + \"-\"];\n    for (var i2 in uniforms) {\n      strings.push(i2);\n      if (uniformData[i2]) {\n        strings.push(uniformData[i2].type);\n      }\n    }\n    return strings.join(\"-\");\n  };\n  ShaderSystem2.prototype.getGlProgram = function() {\n    if (this.shader) {\n      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];\n    }\n    return null;\n  };\n  ShaderSystem2.prototype.generateProgram = function(shader) {\n    var gl = this.gl;\n    var program = shader.program;\n    var glProgram = generateProgram(gl, program);\n    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;\n    return glProgram;\n  };\n  ShaderSystem2.prototype.reset = function() {\n    this.program = null;\n    this.shader = null;\n  };\n  ShaderSystem2.prototype.destroy = function() {\n    this.renderer = null;\n    this.destroyed = true;\n  };\n  return ShaderSystem2;\n}();\nfunction mapWebGLBlendModesToPixi(gl, array) {\n  if (array === void 0) {\n    array = [];\n  }\n  array[BLEND_MODES$3.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.ADD] = [gl.ONE, gl.ONE];\n  array[BLEND_MODES$3.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.NONE] = [0, 0];\n  array[BLEND_MODES$3.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  array[BLEND_MODES$3.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n  array[BLEND_MODES$3.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n  array[BLEND_MODES$3.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n  array[BLEND_MODES$3.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n  array[BLEND_MODES$3.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n  array[BLEND_MODES$3.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[BLEND_MODES$3.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n  return array;\n}\nvar BLEND = 0;\nvar OFFSET = 1;\nvar CULLING = 2;\nvar DEPTH_TEST = 3;\nvar WINDING = 4;\nvar DEPTH_MASK = 5;\nvar StateSystem = function() {\n  function StateSystem2() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = BLEND_MODES$3.NONE;\n    this._blendEq = false;\n    this.map = [];\n    this.map[BLEND] = this.setBlend;\n    this.map[OFFSET] = this.setOffset;\n    this.map[CULLING] = this.setCullFace;\n    this.map[DEPTH_TEST] = this.setDepthTest;\n    this.map[WINDING] = this.setFrontFace;\n    this.map[DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  StateSystem2.prototype.contextChange = function(gl) {\n    this.gl = gl;\n    this.blendModes = mapWebGLBlendModesToPixi(gl);\n    this.set(this.defaultState);\n    this.reset();\n  };\n  StateSystem2.prototype.set = function(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      var diff2 = this.stateId ^ state.data;\n      var i2 = 0;\n      while (diff2) {\n        if (diff2 & 1) {\n          this.map[i2].call(this, !!(state.data & 1 << i2));\n        }\n        diff2 = diff2 >> 1;\n        i2++;\n      }\n      this.stateId = state.data;\n    }\n    for (var i2 = 0; i2 < this.checks.length; i2++) {\n      this.checks[i2](this, state);\n    }\n  };\n  StateSystem2.prototype.forceState = function(state) {\n    state = state || this.defaultState;\n    for (var i2 = 0; i2 < this.map.length; i2++) {\n      this.map[i2].call(this, !!(state.data & 1 << i2));\n    }\n    for (var i2 = 0; i2 < this.checks.length; i2++) {\n      this.checks[i2](this, state);\n    }\n    this.stateId = state.data;\n  };\n  StateSystem2.prototype.setBlend = function(value2) {\n    this.updateCheck(StateSystem2.checkBlendMode, value2);\n    this.gl[value2 ? \"enable\" : \"disable\"](this.gl.BLEND);\n  };\n  StateSystem2.prototype.setOffset = function(value2) {\n    this.updateCheck(StateSystem2.checkPolygonOffset, value2);\n    this.gl[value2 ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  };\n  StateSystem2.prototype.setDepthTest = function(value2) {\n    this.gl[value2 ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  };\n  StateSystem2.prototype.setDepthMask = function(value2) {\n    this.gl.depthMask(value2);\n  };\n  StateSystem2.prototype.setCullFace = function(value2) {\n    this.gl[value2 ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  };\n  StateSystem2.prototype.setFrontFace = function(value2) {\n    this.gl.frontFace(this.gl[value2 ? \"CW\" : \"CCW\"]);\n  };\n  StateSystem2.prototype.setBlendMode = function(value2) {\n    if (value2 === this.blendMode) {\n      return;\n    }\n    this.blendMode = value2;\n    var mode = this.blendModes[value2];\n    var gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  };\n  StateSystem2.prototype.setPolygonOffset = function(value2, scale) {\n    this.gl.polygonOffset(value2, scale);\n  };\n  StateSystem2.prototype.reset = function() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = -1;\n    this.setBlendMode(0);\n  };\n  StateSystem2.prototype.updateCheck = function(func, value2) {\n    var index = this.checks.indexOf(func);\n    if (value2 && index === -1) {\n      this.checks.push(func);\n    } else if (!value2 && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  };\n  StateSystem2.checkBlendMode = function(system, state) {\n    system.setBlendMode(state.blendMode);\n  };\n  StateSystem2.checkPolygonOffset = function(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  };\n  StateSystem2.prototype.destroy = function() {\n    this.gl = null;\n  };\n  return StateSystem2;\n}();\nvar TextureGCSystem = function() {\n  function TextureGCSystem2(renderer) {\n    this.renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n    this.maxIdle = settings.GC_MAX_IDLE;\n    this.checkCountMax = settings.GC_MAX_CHECK_COUNT;\n    this.mode = settings.GC_MODE;\n  }\n  TextureGCSystem2.prototype.postrender = function() {\n    if (!this.renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (this.mode === GC_MODES$3.MANUAL) {\n      return;\n    }\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  };\n  TextureGCSystem2.prototype.run = function() {\n    var tm = this.renderer.texture;\n    var managedTextures = tm.managedTextures;\n    var wasRemoved = false;\n    for (var i2 = 0; i2 < managedTextures.length; i2++) {\n      var texture = managedTextures[i2];\n      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {\n        tm.destroyTexture(texture, true);\n        managedTextures[i2] = null;\n        wasRemoved = true;\n      }\n    }\n    if (wasRemoved) {\n      var j2 = 0;\n      for (var i2 = 0; i2 < managedTextures.length; i2++) {\n        if (managedTextures[i2] !== null) {\n          managedTextures[j2++] = managedTextures[i2];\n        }\n      }\n      managedTextures.length = j2;\n    }\n  };\n  TextureGCSystem2.prototype.unload = function(displayObject) {\n    var tm = this.renderer.texture;\n    var texture = displayObject._texture;\n    if (texture && !texture.framebuffer) {\n      tm.destroyTexture(texture);\n    }\n    for (var i2 = displayObject.children.length - 1; i2 >= 0; i2--) {\n      this.unload(displayObject.children[i2]);\n    }\n  };\n  TextureGCSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return TextureGCSystem2;\n}();\nfunction mapTypeAndFormatToInternalFormat(gl) {\n  var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _j, _k, _l2, _m, _o, _p2, _q, _r2, _s, _t, _u, _v, _w, _x;\n  var table;\n  if (\"WebGL2RenderingContext\" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {\n    table = (_a3 = {}, _a3[TYPES$3.UNSIGNED_BYTE] = (_b3 = {}, _b3[FORMATS$3.RGBA] = gl.RGBA8, _b3[FORMATS$3.RGB] = gl.RGB8, _b3[FORMATS$3.RG] = gl.RG8, _b3[FORMATS$3.RED] = gl.R8, _b3[FORMATS$3.RGBA_INTEGER] = gl.RGBA8UI, _b3[FORMATS$3.RGB_INTEGER] = gl.RGB8UI, _b3[FORMATS$3.RG_INTEGER] = gl.RG8UI, _b3[FORMATS$3.RED_INTEGER] = gl.R8UI, _b3[FORMATS$3.ALPHA] = gl.ALPHA, _b3[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _b3[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b3), _a3[TYPES$3.BYTE] = (_c3 = {}, _c3[FORMATS$3.RGBA] = gl.RGBA8_SNORM, _c3[FORMATS$3.RGB] = gl.RGB8_SNORM, _c3[FORMATS$3.RG] = gl.RG8_SNORM, _c3[FORMATS$3.RED] = gl.R8_SNORM, _c3[FORMATS$3.RGBA_INTEGER] = gl.RGBA8I, _c3[FORMATS$3.RGB_INTEGER] = gl.RGB8I, _c3[FORMATS$3.RG_INTEGER] = gl.RG8I, _c3[FORMATS$3.RED_INTEGER] = gl.R8I, _c3), _a3[TYPES$3.UNSIGNED_SHORT] = (_d2 = {}, _d2[FORMATS$3.RGBA_INTEGER] = gl.RGBA16UI, _d2[FORMATS$3.RGB_INTEGER] = gl.RGB16UI, _d2[FORMATS$3.RG_INTEGER] = gl.RG16UI, _d2[FORMATS$3.RED_INTEGER] = gl.R16UI, _d2[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d2), _a3[TYPES$3.SHORT] = (_e = {}, _e[FORMATS$3.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS$3.RGB_INTEGER] = gl.RGB16I, _e[FORMATS$3.RG_INTEGER] = gl.RG16I, _e[FORMATS$3.RED_INTEGER] = gl.R16I, _e), _a3[TYPES$3.UNSIGNED_INT] = (_f = {}, _f[FORMATS$3.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS$3.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS$3.RG_INTEGER] = gl.RG32UI, _f[FORMATS$3.RED_INTEGER] = gl.R32UI, _f[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a3[TYPES$3.INT] = (_g = {}, _g[FORMATS$3.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS$3.RGB_INTEGER] = gl.RGB32I, _g[FORMATS$3.RG_INTEGER] = gl.RG32I, _g[FORMATS$3.RED_INTEGER] = gl.R32I, _g), _a3[TYPES$3.FLOAT] = (_h = {}, _h[FORMATS$3.RGBA] = gl.RGBA32F, _h[FORMATS$3.RGB] = gl.RGB32F, _h[FORMATS$3.RG] = gl.RG32F, _h[FORMATS$3.RED] = gl.R32F, _h[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a3[TYPES$3.HALF_FLOAT] = (_j = {}, _j[FORMATS$3.RGBA] = gl.RGBA16F, _j[FORMATS$3.RGB] = gl.RGB16F, _j[FORMATS$3.RG] = gl.RG16F, _j[FORMATS$3.RED] = gl.R16F, _j), _a3[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS$3.RGB] = gl.RGB565, _k), _a3[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_l2 = {}, _l2[FORMATS$3.RGBA] = gl.RGBA4, _l2), _a3[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS$3.RGBA] = gl.RGB5_A1, _m), _a3[TYPES$3.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS$3.RGBA] = gl.RGB10_A2, _o[FORMATS$3.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a3[TYPES$3.UNSIGNED_INT_10F_11F_11F_REV] = (_p2 = {}, _p2[FORMATS$3.RGB] = gl.R11F_G11F_B10F, _p2), _a3[TYPES$3.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS$3.RGB] = gl.RGB9_E5, _q), _a3[TYPES$3.UNSIGNED_INT_24_8] = (_r2 = {}, _r2[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r2), _a3[TYPES$3.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a3);\n  } else {\n    table = (_t = {}, _t[TYPES$3.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS$3.RGBA] = gl.RGBA, _u[FORMATS$3.RGB] = gl.RGB, _u[FORMATS$3.ALPHA] = gl.ALPHA, _u[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _u[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS$3.RGB] = gl.RGB, _v), _t[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS$3.RGBA] = gl.RGBA, _w), _t[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS$3.RGBA] = gl.RGBA, _x), _t);\n  }\n  return table;\n}\nvar GLTexture = function() {\n  function GLTexture2(texture) {\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.dirtyId = -1;\n    this.dirtyStyleId = -1;\n    this.mipmap = false;\n    this.wrapMode = 33071;\n    this.type = TYPES$3.UNSIGNED_BYTE;\n    this.internalFormat = FORMATS$3.RGBA;\n    this.samplerType = 0;\n  }\n  return GLTexture2;\n}();\nvar TextureSystem = function() {\n  function TextureSystem2(renderer) {\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  TextureSystem2.prototype.contextChange = function() {\n    var gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.webGLVersion = this.renderer.context.webGLVersion;\n    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (var i2 = 0; i2 < maxTextures; i2++) {\n      this.boundTextures[i2] = null;\n    }\n    this.emptyTextures = {};\n    var emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (var i2 = 0; i2 < 6; i2++) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (var i2 = 0; i2 < this.boundTextures.length; i2++) {\n      this.bind(null, i2);\n    }\n  };\n  TextureSystem2.prototype.bind = function(texture, location2) {\n    if (location2 === void 0) {\n      location2 = 0;\n    }\n    var gl = this.gl;\n    texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();\n    if (texture && texture.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      if (this.boundTextures[location2] !== texture) {\n        if (this.currentLocation !== location2) {\n          this.currentLocation = location2;\n          gl.activeTexture(gl.TEXTURE0 + location2);\n        }\n        gl.bindTexture(texture.target, glTexture.texture);\n      }\n      if (glTexture.dirtyId !== texture.dirtyId) {\n        if (this.currentLocation !== location2) {\n          this.currentLocation = location2;\n          gl.activeTexture(gl.TEXTURE0 + location2);\n        }\n        this.updateTexture(texture);\n      }\n      this.boundTextures[location2] = texture;\n    } else {\n      if (this.currentLocation !== location2) {\n        this.currentLocation = location2;\n        gl.activeTexture(gl.TEXTURE0 + location2);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n      this.boundTextures[location2] = null;\n    }\n  };\n  TextureSystem2.prototype.reset = function() {\n    this._unknownBoundTextures = true;\n    this.hasIntegerTextures = false;\n    this.currentLocation = -1;\n    for (var i2 = 0; i2 < this.boundTextures.length; i2++) {\n      this.boundTextures[i2] = this.unknownTexture;\n    }\n  };\n  TextureSystem2.prototype.unbind = function(texture) {\n    var _a3 = this, gl = _a3.gl, boundTextures = _a3.boundTextures;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      for (var i2 = 0; i2 < boundTextures.length; i2++) {\n        if (boundTextures[i2] === this.unknownTexture) {\n          this.bind(null, i2);\n        }\n      }\n    }\n    for (var i2 = 0; i2 < boundTextures.length; i2++) {\n      if (boundTextures[i2] === texture) {\n        if (this.currentLocation !== i2) {\n          gl.activeTexture(gl.TEXTURE0 + i2);\n          this.currentLocation = i2;\n        }\n        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n        boundTextures[i2] = null;\n      }\n    }\n  };\n  TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {\n    var _a3 = this, boundTextures = _a3.boundTextures, hasIntegerTextures = _a3.hasIntegerTextures, CONTEXT_UID = _a3.CONTEXT_UID;\n    if (!hasIntegerTextures) {\n      return;\n    }\n    for (var i2 = maxTextures - 1; i2 >= 0; --i2) {\n      var tex = boundTextures[i2];\n      if (tex) {\n        var glTexture = tex._glTextures[CONTEXT_UID];\n        if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {\n          this.renderer.texture.unbind(tex);\n        }\n      }\n    }\n  };\n  TextureSystem2.prototype.initTexture = function(texture) {\n    var glTexture = new GLTexture(this.gl.createTexture());\n    glTexture.dirtyId = -1;\n    texture._glTextures[this.CONTEXT_UID] = glTexture;\n    this.managedTextures.push(texture);\n    texture.on(\"dispose\", this.destroyTexture, this);\n    return glTexture;\n  };\n  TextureSystem2.prototype.initTextureType = function(texture, glTexture) {\n    var _a3, _b3;\n    glTexture.internalFormat = (_b3 = (_a3 = this.internalFormats[texture.type]) === null || _a3 === void 0 ? void 0 : _a3[texture.format]) !== null && _b3 !== void 0 ? _b3 : texture.format;\n    if (this.webGLVersion === 2 && texture.type === TYPES$3.HALF_FLOAT) {\n      glTexture.type = this.gl.HALF_FLOAT;\n    } else {\n      glTexture.type = texture.type;\n    }\n  };\n  TextureSystem2.prototype.updateTexture = function(texture) {\n    var glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    var renderer = this.renderer;\n    this.initTextureType(texture, glTexture);\n    if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {\n      if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {\n        this.hasIntegerTextures = true;\n      }\n    } else {\n      var width = texture.realWidth;\n      var height = texture.realHeight;\n      var gl = renderer.gl;\n      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n        glTexture.width = width;\n        glTexture.height = height;\n        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n      }\n    }\n    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n      this.updateTextureStyle(texture);\n    }\n    glTexture.dirtyId = texture.dirtyId;\n  };\n  TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {\n    var gl = this.gl;\n    texture = texture.castToBaseTexture();\n    if (texture._glTextures[this.CONTEXT_UID]) {\n      this.unbind(texture);\n      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n      texture.off(\"dispose\", this.destroyTexture, this);\n      delete texture._glTextures[this.CONTEXT_UID];\n      if (!skipRemove) {\n        var i2 = this.managedTextures.indexOf(texture);\n        if (i2 !== -1) {\n          removeItems(this.managedTextures, i2, 1);\n        }\n      }\n    }\n  };\n  TextureSystem2.prototype.updateTextureStyle = function(texture) {\n    var glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    if ((texture.mipmap === MIPMAP_MODES$3.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n      glTexture.mipmap = false;\n    } else {\n      glTexture.mipmap = texture.mipmap >= 1;\n    }\n    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n      glTexture.wrapMode = WRAP_MODES$3.CLAMP;\n    } else {\n      glTexture.wrapMode = texture.wrapMode;\n    }\n    if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))\n      ;\n    else {\n      this.setStyle(texture, glTexture);\n    }\n    glTexture.dirtyStyleId = texture.dirtyStyleId;\n  };\n  TextureSystem2.prototype.setStyle = function(texture, glTexture) {\n    var gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES$3.ON_MANUAL) {\n      gl.generateMipmap(texture.target);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n    if (glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$3.LINEAR) {\n        var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);\n  };\n  TextureSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  return TextureSystem2;\n}();\nvar tempMatrix = new Matrix();\nvar AbstractRenderer = function(_super) {\n  __extends$q(AbstractRenderer2, _super);\n  function AbstractRenderer2(type, options) {\n    if (type === void 0) {\n      type = RENDERER_TYPE$3.UNKNOWN;\n    }\n    var _this = _super.call(this) || this;\n    options = Object.assign({}, settings.RENDER_OPTIONS, options);\n    _this.options = options;\n    _this.type = type;\n    _this.screen = new Rectangle(0, 0, options.width, options.height);\n    _this.view = options.view || document.createElement(\"canvas\");\n    _this.resolution = options.resolution || settings.RESOLUTION;\n    _this.useContextAlpha = options.useContextAlpha;\n    _this.autoDensity = !!options.autoDensity;\n    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;\n    _this.clearBeforeRender = options.clearBeforeRender;\n    _this._backgroundColor = 0;\n    _this._backgroundColorRgba = [0, 0, 0, 1];\n    _this._backgroundColorString = \"#000000\";\n    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;\n    _this.backgroundAlpha = options.backgroundAlpha;\n    if (options.transparent !== void 0) {\n      deprecation(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\");\n      _this.useContextAlpha = options.transparent;\n      _this.backgroundAlpha = options.transparent ? 0 : 1;\n    }\n    _this._lastObjectRendered = null;\n    _this.plugins = {};\n    return _this;\n  }\n  AbstractRenderer2.prototype.initPlugins = function(staticMap) {\n    for (var o in staticMap) {\n      this.plugins[o] = new staticMap[o](this);\n    }\n  };\n  Object.defineProperty(AbstractRenderer2.prototype, \"width\", {\n    get: function() {\n      return this.view.width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractRenderer2.prototype, \"height\", {\n    get: function() {\n      return this.view.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {\n    this.view.width = Math.round(desiredScreenWidth * this.resolution);\n    this.view.height = Math.round(desiredScreenHeight * this.resolution);\n    var screenWidth = this.view.width / this.resolution;\n    var screenHeight = this.view.height / this.resolution;\n    this.screen.width = screenWidth;\n    this.screen.height = screenHeight;\n    if (this.autoDensity) {\n      this.view.style.width = screenWidth + \"px\";\n      this.view.style.height = screenHeight + \"px\";\n    }\n    this.emit(\"resize\", screenWidth, screenHeight);\n  };\n  AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (typeof options === \"number\") {\n      deprecation(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\");\n      options = { scaleMode: options, resolution, region };\n    }\n    var manualRegion = options.region, textureOptions = __rest$3(options, [\"region\"]);\n    region = manualRegion || displayObject.getLocalBounds(null, true);\n    if (region.width === 0) {\n      region.width = 1;\n    }\n    if (region.height === 0) {\n      region.height = 1;\n    }\n    var renderTexture = RenderTexture.create(__assign$8({ width: region.width, height: region.height }, textureOptions));\n    tempMatrix.tx = -region.x;\n    tempMatrix.ty = -region.y;\n    this.render(displayObject, {\n      renderTexture,\n      clear: false,\n      transform: tempMatrix,\n      skipUpdateTransform: !!displayObject.parent\n    });\n    return renderTexture;\n  };\n  AbstractRenderer2.prototype.destroy = function(removeView) {\n    for (var o in this.plugins) {\n      this.plugins[o].destroy();\n      this.plugins[o] = null;\n    }\n    if (removeView && this.view.parentNode) {\n      this.view.parentNode.removeChild(this.view);\n    }\n    var thisAny = this;\n    thisAny.plugins = null;\n    thisAny.type = RENDERER_TYPE$3.UNKNOWN;\n    thisAny.view = null;\n    thisAny.screen = null;\n    thisAny._tempDisplayObjectParent = null;\n    thisAny.options = null;\n    this._backgroundColorRgba = null;\n    this._backgroundColorString = null;\n    this._lastObjectRendered = null;\n  };\n  Object.defineProperty(AbstractRenderer2.prototype, \"backgroundColor\", {\n    get: function() {\n      return this._backgroundColor;\n    },\n    set: function(value2) {\n      this._backgroundColor = value2;\n      this._backgroundColorString = hex2string(value2);\n      hex2rgb(value2, this._backgroundColorRgba);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractRenderer2.prototype, \"backgroundAlpha\", {\n    get: function() {\n      return this._backgroundColorRgba[3];\n    },\n    set: function(value2) {\n      this._backgroundColorRgba[3] = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return AbstractRenderer2;\n}(EventEmitter$4);\nvar GLBuffer = function() {\n  function GLBuffer2(buffer) {\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.refCount = 0;\n  }\n  return GLBuffer2;\n}();\nvar BufferSystem = function() {\n  function BufferSystem2(renderer) {\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  BufferSystem2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  BufferSystem2.prototype.contextChange = function() {\n    this.disposeAll(true);\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  };\n  BufferSystem2.prototype.bind = function(buffer) {\n    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;\n    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  };\n  BufferSystem2.prototype.bindBufferBase = function(buffer, index) {\n    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;\n    if (this.boundBufferBases[index] !== buffer) {\n      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  };\n  BufferSystem2.prototype.bindBufferRange = function(buffer, index, offset2) {\n    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;\n    offset2 = offset2 || 0;\n    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset2 * 256, 256);\n  };\n  BufferSystem2.prototype.update = function(buffer) {\n    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;\n    var glBuffer = buffer._glBuffers[CONTEXT_UID];\n    if (buffer._updateID === glBuffer.updateID) {\n      return;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(buffer.type, 0, buffer.data);\n    } else {\n      var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = buffer.data.byteLength;\n      gl.bufferData(buffer.type, buffer.data, drawType);\n    }\n  };\n  BufferSystem2.prototype.dispose = function(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id]) {\n      return;\n    }\n    delete this.managedBuffers[buffer.id];\n    var glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n    var gl = this.gl;\n    buffer.disposeRunner.remove(this);\n    if (!glBuffer) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    delete buffer._glBuffers[this.CONTEXT_UID];\n  };\n  BufferSystem2.prototype.disposeAll = function(contextLost) {\n    var all2 = Object.keys(this.managedBuffers);\n    for (var i2 = 0; i2 < all2.length; i2++) {\n      this.dispose(this.managedBuffers[all2[i2]], contextLost);\n    }\n  };\n  BufferSystem2.prototype.createGLBuffer = function(buffer) {\n    var _a3 = this, CONTEXT_UID = _a3.CONTEXT_UID, gl = _a3.gl;\n    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n    this.managedBuffers[buffer.id] = buffer;\n    buffer.disposeRunner.add(this);\n    return buffer._glBuffers[CONTEXT_UID];\n  };\n  return BufferSystem2;\n}();\nvar Renderer = function(_super) {\n  __extends$q(Renderer2, _super);\n  function Renderer2(options) {\n    var _this = _super.call(this, RENDERER_TYPE$3.WEBGL, options) || this;\n    options = _this.options;\n    _this.gl = null;\n    _this.CONTEXT_UID = 0;\n    _this.runners = {\n      destroy: new Runner(\"destroy\"),\n      contextChange: new Runner(\"contextChange\"),\n      reset: new Runner(\"reset\"),\n      update: new Runner(\"update\"),\n      postrender: new Runner(\"postrender\"),\n      prerender: new Runner(\"prerender\"),\n      resize: new Runner(\"resize\")\n    };\n    _this.runners.contextChange.add(_this);\n    _this.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, true);\n    _this.addSystem(MaskSystem, \"mask\").addSystem(ContextSystem, \"context\").addSystem(StateSystem, \"state\").addSystem(ShaderSystem, \"shader\").addSystem(TextureSystem, \"texture\").addSystem(BufferSystem, \"buffer\").addSystem(GeometrySystem, \"geometry\").addSystem(FramebufferSystem, \"framebuffer\").addSystem(ScissorSystem, \"scissor\").addSystem(StencilSystem, \"stencil\").addSystem(ProjectionSystem, \"projection\").addSystem(TextureGCSystem, \"textureGC\").addSystem(FilterSystem, \"filter\").addSystem(RenderTextureSystem, \"renderTexture\").addSystem(BatchSystem, \"batch\");\n    _this.initPlugins(Renderer2.__plugins);\n    _this.multisample = void 0;\n    if (options.context) {\n      _this.context.initFromContext(options.context);\n    } else {\n      _this.context.initFromOptions({\n        alpha: !!_this.useContextAlpha,\n        antialias: options.antialias,\n        premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== \"notMultiplied\",\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: _this.options.powerPreference\n      });\n    }\n    _this.renderingToScreen = true;\n    sayHello(_this.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\");\n    _this.resize(_this.options.width, _this.options.height);\n    return _this;\n  }\n  Renderer2.create = function(options) {\n    if (isWebGLSupported()) {\n      return new Renderer2(options);\n    }\n    throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n  };\n  Renderer2.prototype.contextChange = function() {\n    var gl = this.gl;\n    var samples;\n    if (this.context.webGLVersion === 1) {\n      var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    } else {\n      var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);\n    }\n    if (samples >= MSAA_QUALITY$3.HIGH) {\n      this.multisample = MSAA_QUALITY$3.HIGH;\n    } else if (samples >= MSAA_QUALITY$3.MEDIUM) {\n      this.multisample = MSAA_QUALITY$3.MEDIUM;\n    } else if (samples >= MSAA_QUALITY$3.LOW) {\n      this.multisample = MSAA_QUALITY$3.LOW;\n    } else {\n      this.multisample = MSAA_QUALITY$3.NONE;\n    }\n  };\n  Renderer2.prototype.addSystem = function(ClassRef, name) {\n    var system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error('Whoops! The name \"' + name + '\" is already in use');\n    }\n    this[name] = system;\n    for (var i2 in this.runners) {\n      this.runners[i2].add(system);\n    }\n    return this;\n  };\n  Renderer2.prototype.render = function(displayObject, options) {\n    var renderTexture;\n    var clear;\n    var transform;\n    var skipUpdateTransform;\n    if (options) {\n      if (options instanceof RenderTexture) {\n        deprecation(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\");\n        renderTexture = options;\n        clear = arguments[2];\n        transform = arguments[3];\n        skipUpdateTransform = arguments[4];\n      } else {\n        renderTexture = options.renderTexture;\n        clear = options.clear;\n        transform = options.transform;\n        skipUpdateTransform = options.skipUpdateTransform;\n      }\n    }\n    this.renderingToScreen = !renderTexture;\n    this.runners.prerender.emit();\n    this.emit(\"prerender\");\n    this.projection.transform = transform;\n    if (this.context.isLost) {\n      return;\n    }\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      var cacheParent = displayObject.enableTempParent();\n      displayObject.updateTransform();\n      displayObject.disableTempParent(cacheParent);\n    }\n    this.renderTexture.bind(renderTexture);\n    this.batch.currentRenderer.start();\n    if (clear !== void 0 ? clear : this.clearBeforeRender) {\n      this.renderTexture.clear();\n    }\n    displayObject.render(this);\n    this.batch.currentRenderer.flush();\n    if (renderTexture) {\n      renderTexture.baseTexture.update();\n    }\n    this.runners.postrender.emit();\n    this.projection.transform = null;\n    this.emit(\"postrender\");\n  };\n  Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {\n    if (options === void 0) {\n      options = {};\n    }\n    var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);\n    this.framebuffer.blit();\n    return renderTexture;\n  };\n  Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {\n    _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);\n    this.runners.resize.emit(this.screen.height, this.screen.width);\n  };\n  Renderer2.prototype.reset = function() {\n    this.runners.reset.emit();\n    return this;\n  };\n  Renderer2.prototype.clear = function() {\n    this.renderTexture.bind();\n    this.renderTexture.clear();\n  };\n  Renderer2.prototype.destroy = function(removeView) {\n    this.runners.destroy.emit();\n    for (var r2 in this.runners) {\n      this.runners[r2].destroy();\n    }\n    _super.prototype.destroy.call(this, removeView);\n    this.gl = null;\n  };\n  Object.defineProperty(Renderer2.prototype, \"extract\", {\n    get: function() {\n      deprecation(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\");\n      return this.plugins.extract;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Renderer2.registerPlugin = function(pluginName, ctor) {\n    Renderer2.__plugins = Renderer2.__plugins || {};\n    Renderer2.__plugins[pluginName] = ctor;\n  };\n  return Renderer2;\n}(AbstractRenderer);\nfunction autoDetectRenderer(options) {\n  return Renderer.create(options);\n}\nvar $defaultVertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\";\nvar $defaultFilterVertex = \"attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\nvar defaultVertex$1 = $defaultVertex;\nvar defaultFilterVertex = $defaultFilterVertex;\nvar BatchDrawCall = function() {\n  function BatchDrawCall2() {\n    this.texArray = null;\n    this.blend = 0;\n    this.type = DRAW_MODES$3.TRIANGLES;\n    this.start = 0;\n    this.size = 0;\n    this.data = null;\n  }\n  return BatchDrawCall2;\n}();\nvar BatchTextureArray = function() {\n  function BatchTextureArray2() {\n    this.elements = [];\n    this.ids = [];\n    this.count = 0;\n  }\n  BatchTextureArray2.prototype.clear = function() {\n    for (var i2 = 0; i2 < this.count; i2++) {\n      this.elements[i2] = null;\n    }\n    this.count = 0;\n  };\n  return BatchTextureArray2;\n}();\nvar ViewableBuffer = function() {\n  function ViewableBuffer2(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  Object.defineProperty(ViewableBuffer2.prototype, \"int8View\", {\n    get: function() {\n      if (!this._int8View) {\n        this._int8View = new Int8Array(this.rawBinaryData);\n      }\n      return this._int8View;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewableBuffer2.prototype, \"uint8View\", {\n    get: function() {\n      if (!this._uint8View) {\n        this._uint8View = new Uint8Array(this.rawBinaryData);\n      }\n      return this._uint8View;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewableBuffer2.prototype, \"int16View\", {\n    get: function() {\n      if (!this._int16View) {\n        this._int16View = new Int16Array(this.rawBinaryData);\n      }\n      return this._int16View;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewableBuffer2.prototype, \"uint16View\", {\n    get: function() {\n      if (!this._uint16View) {\n        this._uint16View = new Uint16Array(this.rawBinaryData);\n      }\n      return this._uint16View;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewableBuffer2.prototype, \"int32View\", {\n    get: function() {\n      if (!this._int32View) {\n        this._int32View = new Int32Array(this.rawBinaryData);\n      }\n      return this._int32View;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ViewableBuffer2.prototype.view = function(type) {\n    return this[type + \"View\"];\n  };\n  ViewableBuffer2.prototype.destroy = function() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this._uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  };\n  ViewableBuffer2.sizeOf = function(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(type + \" isn't a valid view type\");\n    }\n  };\n  return ViewableBuffer2;\n}();\nvar AbstractBatchRenderer = function(_super) {\n  __extends$q(AbstractBatchRenderer2, _super);\n  function AbstractBatchRenderer2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.shaderGenerator = null;\n    _this.geometryClass = null;\n    _this.vertexSize = null;\n    _this.state = State.for2d();\n    _this.size = settings.SPRITE_BATCH_SIZE * 4;\n    _this._vertexCount = 0;\n    _this._indexCount = 0;\n    _this._bufferedElements = [];\n    _this._bufferedTextures = [];\n    _this._bufferSize = 0;\n    _this._shader = null;\n    _this._packedGeometries = [];\n    _this._packedGeometryPoolSize = 2;\n    _this._flushId = 0;\n    _this._aBuffers = {};\n    _this._iBuffers = {};\n    _this.MAX_TEXTURES = 1;\n    _this.renderer.on(\"prerender\", _this.onPrerender, _this);\n    renderer.runners.contextChange.add(_this);\n    _this._dcIndex = 0;\n    _this._aIndex = 0;\n    _this._iIndex = 0;\n    _this._attributeBuffer = null;\n    _this._indexBuffer = null;\n    _this._tempBoundTextures = [];\n    return _this;\n  }\n  AbstractBatchRenderer2.prototype.contextChange = function() {\n    var gl = this.renderer.gl;\n    if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {\n      this.MAX_TEXTURES = 1;\n    } else {\n      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n      this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);\n    }\n    this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n    for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {\n      this._packedGeometries[i2] = new this.geometryClass();\n    }\n    this.initFlushBuffers();\n  };\n  AbstractBatchRenderer2.prototype.initFlushBuffers = function() {\n    var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;\n    var MAX_SPRITES = this.size / 4;\n    var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;\n    while (_drawCallPool.length < MAX_SPRITES) {\n      _drawCallPool.push(new BatchDrawCall());\n    }\n    while (_textureArrayPool.length < MAX_TA) {\n      _textureArrayPool.push(new BatchTextureArray());\n    }\n    for (var i2 = 0; i2 < this.MAX_TEXTURES; i2++) {\n      this._tempBoundTextures[i2] = null;\n    }\n  };\n  AbstractBatchRenderer2.prototype.onPrerender = function() {\n    this._flushId = 0;\n  };\n  AbstractBatchRenderer2.prototype.render = function(element) {\n    if (!element._texture.valid) {\n      return;\n    }\n    if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n      this.flush();\n    }\n    this._vertexCount += element.vertexData.length / 2;\n    this._indexCount += element.indices.length;\n    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n    this._bufferedElements[this._bufferSize++] = element;\n  };\n  AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {\n    var _a3 = this, textures = _a3._bufferedTextures, MAX_TEXTURES = _a3.MAX_TEXTURES;\n    var textureArrays = AbstractBatchRenderer2._textureArrayPool;\n    var batch = this.renderer.batch;\n    var boundTextures = this._tempBoundTextures;\n    var touch = this.renderer.textureGC.count;\n    var TICK = ++BaseTexture._globalBatch;\n    var countTexArrays = 0;\n    var texArray = textureArrays[0];\n    var start2 = 0;\n    batch.copyBoundTextures(boundTextures, MAX_TEXTURES);\n    for (var i2 = 0; i2 < this._bufferSize; ++i2) {\n      var tex = textures[i2];\n      textures[i2] = null;\n      if (tex._batchEnabled === TICK) {\n        continue;\n      }\n      if (texArray.count >= MAX_TEXTURES) {\n        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n        this.buildDrawCalls(texArray, start2, i2);\n        start2 = i2;\n        texArray = textureArrays[++countTexArrays];\n        ++TICK;\n      }\n      tex._batchEnabled = TICK;\n      tex.touched = touch;\n      texArray.elements[texArray.count++] = tex;\n    }\n    if (texArray.count > 0) {\n      batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n      this.buildDrawCalls(texArray, start2, this._bufferSize);\n      ++countTexArrays;\n      ++TICK;\n    }\n    for (var i2 = 0; i2 < boundTextures.length; i2++) {\n      boundTextures[i2] = null;\n    }\n    BaseTexture._globalBatch = TICK;\n  };\n  AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start2, finish) {\n    var _a3 = this, elements = _a3._bufferedElements, _attributeBuffer = _a3._attributeBuffer, _indexBuffer = _a3._indexBuffer, vertexSize = _a3.vertexSize;\n    var drawCalls = AbstractBatchRenderer2._drawCallPool;\n    var dcIndex = this._dcIndex;\n    var aIndex = this._aIndex;\n    var iIndex = this._iIndex;\n    var drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex;\n    drawCall.texArray = texArray;\n    for (var i2 = start2; i2 < finish; ++i2) {\n      var sprite = elements[i2];\n      var tex = sprite._texture.baseTexture;\n      var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i2] = null;\n      if (start2 < i2 && drawCall.blend !== spriteBlendMode) {\n        drawCall.size = iIndex - drawCall.start;\n        start2 = i2;\n        drawCall = drawCalls[++dcIndex];\n        drawCall.texArray = texArray;\n        drawCall.start = iIndex;\n      }\n      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n      aIndex += sprite.vertexData.length / 2 * vertexSize;\n      iIndex += sprite.indices.length;\n      drawCall.blend = spriteBlendMode;\n    }\n    if (start2 < finish) {\n      drawCall.size = iIndex - drawCall.start;\n      ++dcIndex;\n    }\n    this._dcIndex = dcIndex;\n    this._aIndex = aIndex;\n    this._iIndex = iIndex;\n  };\n  AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {\n    var textureSystem = this.renderer.texture;\n    for (var j2 = 0; j2 < texArray.count; j2++) {\n      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);\n      texArray.elements[j2] = null;\n    }\n    texArray.count = 0;\n  };\n  AbstractBatchRenderer2.prototype.updateGeometry = function() {\n    var _a3 = this, packedGeometries = _a3._packedGeometries, attributeBuffer = _a3._attributeBuffer, indexBuffer = _a3._indexBuffer;\n    if (!settings.CAN_UPLOAD_SAME_BUFFER) {\n      if (this._packedGeometryPoolSize <= this._flushId) {\n        this._packedGeometryPoolSize++;\n        packedGeometries[this._flushId] = new this.geometryClass();\n      }\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.bind(packedGeometries[this._flushId]);\n      this.renderer.geometry.updateBuffers();\n      this._flushId++;\n    } else {\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.updateBuffers();\n    }\n  };\n  AbstractBatchRenderer2.prototype.drawBatches = function() {\n    var dcCount = this._dcIndex;\n    var _a3 = this.renderer, gl = _a3.gl, stateSystem = _a3.state;\n    var drawCalls = AbstractBatchRenderer2._drawCallPool;\n    var curTexArray = null;\n    for (var i2 = 0; i2 < dcCount; i2++) {\n      var _b3 = drawCalls[i2], texArray = _b3.texArray, type = _b3.type, size = _b3.size, start2 = _b3.start, blend = _b3.blend;\n      if (curTexArray !== texArray) {\n        curTexArray = texArray;\n        this.bindAndClearTexArray(texArray);\n      }\n      this.state.blendMode = blend;\n      stateSystem.set(this.state);\n      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start2 * 2);\n    }\n  };\n  AbstractBatchRenderer2.prototype.flush = function() {\n    if (this._vertexCount === 0) {\n      return;\n    }\n    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n    this._indexBuffer = this.getIndexBuffer(this._indexCount);\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._dcIndex = 0;\n    this.buildTexturesAndDrawCalls();\n    this.updateGeometry();\n    this.drawBatches();\n    this._bufferSize = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n  };\n  AbstractBatchRenderer2.prototype.start = function() {\n    this.renderer.state.set(this.state);\n    this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);\n    this.renderer.shader.bind(this._shader);\n    if (settings.CAN_UPLOAD_SAME_BUFFER) {\n      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }\n  };\n  AbstractBatchRenderer2.prototype.stop = function() {\n    this.flush();\n  };\n  AbstractBatchRenderer2.prototype.destroy = function() {\n    for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {\n      if (this._packedGeometries[i2]) {\n        this._packedGeometries[i2].destroy();\n      }\n    }\n    this.renderer.off(\"prerender\", this.onPrerender, this);\n    this._aBuffers = null;\n    this._iBuffers = null;\n    this._packedGeometries = null;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    if (this._shader) {\n      this._shader.destroy();\n      this._shader = null;\n    }\n    _super.prototype.destroy.call(this);\n  };\n  AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {\n    var roundedP2 = nextPow2(Math.ceil(size / 8));\n    var roundedSizeIndex = log2(roundedP2);\n    var roundedSize = roundedP2 * 8;\n    if (this._aBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    var buffer = this._aBuffers[roundedSize];\n    if (!buffer) {\n      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n    }\n    return buffer;\n  };\n  AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {\n    var roundedP2 = nextPow2(Math.ceil(size / 12));\n    var roundedSizeIndex = log2(roundedP2);\n    var roundedSize = roundedP2 * 12;\n    if (this._iBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    var buffer = this._iBuffers[roundedSizeIndex];\n    if (!buffer) {\n      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n    }\n    return buffer;\n  };\n  AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;\n    var packedVertices = aIndex / this.vertexSize;\n    var uvs = element.uvs;\n    var indicies = element.indices;\n    var vertexData = element.vertexData;\n    var textureId = element._texture.baseTexture._batchLocation;\n    var alpha = Math.min(element.worldAlpha, 1);\n    var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);\n    for (var i2 = 0; i2 < vertexData.length; i2 += 2) {\n      float32View[aIndex++] = vertexData[i2];\n      float32View[aIndex++] = vertexData[i2 + 1];\n      float32View[aIndex++] = uvs[i2];\n      float32View[aIndex++] = uvs[i2 + 1];\n      uint32View[aIndex++] = argb;\n      float32View[aIndex++] = textureId;\n    }\n    for (var i2 = 0; i2 < indicies.length; i2++) {\n      indexBuffer[iIndex++] = packedVertices + indicies[i2];\n    }\n  };\n  AbstractBatchRenderer2._drawCallPool = [];\n  AbstractBatchRenderer2._textureArrayPool = [];\n  return AbstractBatchRenderer2;\n}(ObjectRenderer);\nvar BatchShaderGenerator = function() {\n  function BatchShaderGenerator2(vertexSrc, fragTemplate2) {\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate2;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (fragTemplate2.indexOf(\"%count%\") < 0) {\n      throw new Error('Fragment template must contain \"%count%\".');\n    }\n    if (fragTemplate2.indexOf(\"%forloop%\") < 0) {\n      throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n  }\n  BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      var sampleValues = new Int32Array(maxTextures);\n      for (var i2 = 0; i2 < maxTextures; i2++) {\n        sampleValues[i2] = i2;\n      }\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n      var fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, \"\" + maxTextures);\n      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    var uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  };\n  BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {\n    var src = \"\";\n    src += \"\\n\";\n    src += \"\\n\";\n    for (var i2 = 0; i2 < maxTextures; i2++) {\n      if (i2 > 0) {\n        src += \"\\nelse \";\n      }\n      if (i2 < maxTextures - 1) {\n        src += \"if(vTextureId < \" + i2 + \".5)\";\n      }\n      src += \"\\n{\";\n      src += \"\\n\tcolor = texture2D(uSamplers[\" + i2 + \"], vTextureCoord);\";\n      src += \"\\n}\";\n    }\n    src += \"\\n\";\n    src += \"\\n\";\n    return src;\n  };\n  return BatchShaderGenerator2;\n}();\nvar BatchGeometry = function(_super) {\n  __extends$q(BatchGeometry2, _super);\n  function BatchGeometry2(_static) {\n    if (_static === void 0) {\n      _static = false;\n    }\n    var _this = _super.call(this) || this;\n    _this._buffer = new Buffer$1(null, _static, false);\n    _this._indexBuffer = new Buffer$1(null, _static, true);\n    _this.addAttribute(\"aVertexPosition\", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute(\"aTextureCoord\", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute(\"aColor\", _this._buffer, 4, true, TYPES$3.UNSIGNED_BYTE).addAttribute(\"aTextureId\", _this._buffer, 1, true, TYPES$3.FLOAT).addIndex(_this._indexBuffer);\n    return _this;\n  }\n  return BatchGeometry2;\n}(Geometry);\nvar defaultVertex = \"precision highp float;\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform vec4 tint;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vTextureId = aTextureId;\\n    vColor = aColor * tint;\\n}\\n\";\nvar defaultFragment = \"varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\nuniform sampler2D uSamplers[%count%];\\n\\nvoid main(void){\\n    vec4 color;\\n    %forloop%\\n    gl_FragColor = color * vColor;\\n}\\n\";\nvar BatchPluginFactory = function() {\n  function BatchPluginFactory2() {\n  }\n  BatchPluginFactory2.create = function(options) {\n    var _a3 = Object.assign({\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      geometryClass: BatchGeometry,\n      vertexSize: 6\n    }, options), vertex2 = _a3.vertex, fragment2 = _a3.fragment, vertexSize = _a3.vertexSize, geometryClass = _a3.geometryClass;\n    return function(_super) {\n      __extends$q(BatchPlugin, _super);\n      function BatchPlugin(renderer) {\n        var _this = _super.call(this, renderer) || this;\n        _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);\n        _this.geometryClass = geometryClass;\n        _this.vertexSize = vertexSize;\n        return _this;\n      }\n      return BatchPlugin;\n    }(AbstractBatchRenderer);\n  };\n  Object.defineProperty(BatchPluginFactory2, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BatchPluginFactory2, \"defaultFragmentTemplate\", {\n    get: function() {\n      return defaultFragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return BatchPluginFactory2;\n}();\nvar BatchRenderer = BatchPluginFactory.create();\n/*!\n * @pixi/loaders - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar SignalBinding = function() {\n  function SignalBinding2(fn2, once, thisArg) {\n    if (once === void 0) {\n      once = false;\n    }\n    this._fn = fn2;\n    this._once = once;\n    this._thisArg = thisArg;\n    this._next = this._prev = this._owner = null;\n  }\n  SignalBinding2.prototype.detach = function() {\n    if (this._owner === null) {\n      return false;\n    }\n    this._owner.detach(this);\n    return true;\n  };\n  return SignalBinding2;\n}();\nfunction _addSignalBinding(self2, node) {\n  if (!self2._head) {\n    self2._head = node;\n    self2._tail = node;\n  } else {\n    self2._tail._next = node;\n    node._prev = self2._tail;\n    self2._tail = node;\n  }\n  node._owner = self2;\n  return node;\n}\nvar Signal = function() {\n  function Signal2() {\n    this._head = this._tail = void 0;\n  }\n  Signal2.prototype.handlers = function(exists) {\n    if (exists === void 0) {\n      exists = false;\n    }\n    var node = this._head;\n    if (exists) {\n      return !!node;\n    }\n    var ee = [];\n    while (node) {\n      ee.push(node);\n      node = node._next;\n    }\n    return ee;\n  };\n  Signal2.prototype.has = function(node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n    }\n    return node._owner === this;\n  };\n  Signal2.prototype.dispatch = function() {\n    var arguments$1 = arguments;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    var node = this._head;\n    if (!node) {\n      return false;\n    }\n    while (node) {\n      if (node._once) {\n        this.detach(node);\n      }\n      node._fn.apply(node._thisArg, args);\n      node = node._next;\n    }\n    return true;\n  };\n  Signal2.prototype.add = function(fn2, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn2 !== \"function\") {\n      throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n    }\n    return _addSignalBinding(this, new SignalBinding(fn2, false, thisArg));\n  };\n  Signal2.prototype.once = function(fn2, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = null;\n    }\n    if (typeof fn2 !== \"function\") {\n      throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n    }\n    return _addSignalBinding(this, new SignalBinding(fn2, true, thisArg));\n  };\n  Signal2.prototype.detach = function(node) {\n    if (!(node instanceof SignalBinding)) {\n      throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n    }\n    if (node._owner !== this) {\n      return this;\n    }\n    if (node._prev) {\n      node._prev._next = node._next;\n    }\n    if (node._next) {\n      node._next._prev = node._prev;\n    }\n    if (node === this._head) {\n      this._head = node._next;\n      if (node._next === null) {\n        this._tail = null;\n      }\n    } else if (node === this._tail) {\n      this._tail = node._prev;\n      this._tail._next = null;\n    }\n    node._owner = null;\n    return this;\n  };\n  Signal2.prototype.detachAll = function() {\n    var node = this._head;\n    if (!node) {\n      return this;\n    }\n    this._head = this._tail = null;\n    while (node) {\n      node._owner = null;\n      node = node._next;\n    }\n    return this;\n  };\n  return Signal2;\n}();\nfunction parseUri(str2, opts) {\n  opts = opts || {};\n  var o = {\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  };\n  var m2 = o.parser[opts.strictMode ? \"strict\" : \"loose\"].exec(str2);\n  var uri = {};\n  var i2 = 14;\n  while (i2--) {\n    uri[o.key[i2]] = m2[i2] || \"\";\n  }\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function(_t0, t1, t2) {\n    if (t1) {\n      uri[o.q.name][t1] = t2;\n    }\n  });\n  return uri;\n}\nvar useXdr;\nvar tempAnchor = null;\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2;\nfunction _noop$1() {\n}\nfunction setExtMap(map2, extname, val) {\n  if (extname && extname.indexOf(\".\") === 0) {\n    extname = extname.substring(1);\n  }\n  if (!extname) {\n    return;\n  }\n  map2[extname] = val;\n}\nfunction reqType(xhr) {\n  return xhr.toString().replace(\"object \", \"\");\n}\nvar LoaderResource = function() {\n  function LoaderResource2(name, url2, options) {\n    this._dequeue = _noop$1;\n    this._onLoadBinding = null;\n    this._elementTimer = 0;\n    this._boundComplete = null;\n    this._boundOnError = null;\n    this._boundOnProgress = null;\n    this._boundOnTimeout = null;\n    this._boundXhrOnError = null;\n    this._boundXhrOnTimeout = null;\n    this._boundXhrOnAbort = null;\n    this._boundXhrOnLoad = null;\n    if (typeof name !== \"string\" || typeof url2 !== \"string\") {\n      throw new Error(\"Both name and url are required for constructing a resource.\");\n    }\n    options = options || {};\n    this._flags = 0;\n    this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf(\"data:\") === 0);\n    this.name = name;\n    this.url = url2;\n    this.extension = this._getExtension();\n    this.data = null;\n    this.crossOrigin = options.crossOrigin === true ? \"anonymous\" : options.crossOrigin;\n    this.timeout = options.timeout || 0;\n    this.loadType = options.loadType || this._determineLoadType();\n    this.xhrType = options.xhrType;\n    this.metadata = options.metadata || {};\n    this.error = null;\n    this.xhr = null;\n    this.children = [];\n    this.type = LoaderResource2.TYPE.UNKNOWN;\n    this.progressChunk = 0;\n    this._dequeue = _noop$1;\n    this._onLoadBinding = null;\n    this._elementTimer = 0;\n    this._boundComplete = this.complete.bind(this);\n    this._boundOnError = this._onError.bind(this);\n    this._boundOnProgress = this._onProgress.bind(this);\n    this._boundOnTimeout = this._onTimeout.bind(this);\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    this.onStart = new Signal();\n    this.onProgress = new Signal();\n    this.onComplete = new Signal();\n    this.onAfterMiddleware = new Signal();\n  }\n  LoaderResource2.setExtensionLoadType = function(extname, loadType) {\n    setExtMap(LoaderResource2._loadTypeMap, extname, loadType);\n  };\n  LoaderResource2.setExtensionXhrType = function(extname, xhrType) {\n    setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);\n  };\n  Object.defineProperty(LoaderResource2.prototype, \"isDataUrl\", {\n    get: function() {\n      return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource2.prototype, \"isComplete\", {\n    get: function() {\n      return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LoaderResource2.prototype, \"isLoading\", {\n    get: function() {\n      return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  LoaderResource2.prototype.complete = function() {\n    this._clearEvents();\n    this._finish();\n  };\n  LoaderResource2.prototype.abort = function(message) {\n    if (this.error) {\n      return;\n    }\n    this.error = new Error(message);\n    this._clearEvents();\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      if (this.data.src) {\n        this.data.src = LoaderResource2.EMPTY_GIF;\n      } else {\n        while (this.data.firstChild) {\n          this.data.removeChild(this.data.firstChild);\n        }\n      }\n    }\n    this._finish();\n  };\n  LoaderResource2.prototype.load = function(cb) {\n    var _this = this;\n    if (this.isLoading) {\n      return;\n    }\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function() {\n          return cb(_this);\n        }, 1);\n      }\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);\n    this.onStart.dispatch(this);\n    if (this.crossOrigin === false || typeof this.crossOrigin !== \"string\") {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n    switch (this.loadType) {\n      case LoaderResource2.LOAD_TYPE.IMAGE:\n        this.type = LoaderResource2.TYPE.IMAGE;\n        this._loadElement(\"image\");\n        break;\n      case LoaderResource2.LOAD_TYPE.AUDIO:\n        this.type = LoaderResource2.TYPE.AUDIO;\n        this._loadSourceElement(\"audio\");\n        break;\n      case LoaderResource2.LOAD_TYPE.VIDEO:\n        this.type = LoaderResource2.TYPE.VIDEO;\n        this._loadSourceElement(\"video\");\n        break;\n      case LoaderResource2.LOAD_TYPE.XHR:\n      default:\n        if (typeof useXdr === \"undefined\") {\n          useXdr = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()));\n        }\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n        break;\n    }\n  };\n  LoaderResource2.prototype._hasFlag = function(flag) {\n    return (this._flags & flag) !== 0;\n  };\n  LoaderResource2.prototype._setFlag = function(flag, value2) {\n    this._flags = value2 ? this._flags | flag : this._flags & ~flag;\n  };\n  LoaderResource2.prototype._clearEvents = function() {\n    clearTimeout(this._elementTimer);\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener(\"error\", this._boundOnError, false);\n      this.data.removeEventListener(\"load\", this._boundComplete, false);\n      this.data.removeEventListener(\"progress\", this._boundOnProgress, false);\n      this.data.removeEventListener(\"canplaythrough\", this._boundComplete, false);\n    }\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener(\"error\", this._boundXhrOnError, false);\n        this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener(\"progress\", this._boundOnProgress, false);\n        this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  };\n  LoaderResource2.prototype._finish = function() {\n    if (this.isComplete) {\n      throw new Error(\"Complete called again for an already completed resource.\");\n    }\n    this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);\n    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);\n    this.onComplete.dispatch(this);\n  };\n  LoaderResource2.prototype._loadElement = function(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === \"image\" && typeof globalThis.Image !== \"undefined\") {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n    this.data.addEventListener(\"error\", this._boundOnError, false);\n    this.data.addEventListener(\"load\", this._boundComplete, false);\n    this.data.addEventListener(\"progress\", this._boundOnProgress, false);\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  LoaderResource2.prototype._loadSourceElement = function(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === \"audio\" && typeof globalThis.Audio !== \"undefined\") {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n    if (this.data === null) {\n      this.abort(\"Unsupported element: \" + type);\n      return;\n    }\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n    if (!this.metadata.skipSource) {\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n        for (var i2 = 0; i2 < this.url.length; ++i2) {\n          this.data.appendChild(this._createSource(type, this.url[i2], Array.isArray(mimeTypes) ? mimeTypes[i2] : mimeTypes));\n        }\n      } else {\n        var mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));\n      }\n    }\n    this.data.addEventListener(\"error\", this._boundOnError, false);\n    this.data.addEventListener(\"load\", this._boundComplete, false);\n    this.data.addEventListener(\"progress\", this._boundOnProgress, false);\n    this.data.addEventListener(\"canplaythrough\", this._boundComplete, false);\n    this.data.load();\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  LoaderResource2.prototype._loadXhr = function() {\n    if (typeof this.xhrType !== \"string\") {\n      this.xhrType = this._determineXhrType();\n    }\n    var xhr = this.xhr = new XMLHttpRequest();\n    if (this.crossOrigin === \"use-credentials\") {\n      xhr.withCredentials = true;\n    }\n    xhr.open(\"GET\", this.url, true);\n    xhr.timeout = this.timeout;\n    if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n    xhr.addEventListener(\"error\", this._boundXhrOnError, false);\n    xhr.addEventListener(\"timeout\", this._boundXhrOnTimeout, false);\n    xhr.addEventListener(\"abort\", this._boundXhrOnAbort, false);\n    xhr.addEventListener(\"progress\", this._boundOnProgress, false);\n    xhr.addEventListener(\"load\", this._boundXhrOnLoad, false);\n    xhr.send();\n  };\n  LoaderResource2.prototype._loadXdr = function() {\n    if (typeof this.xhrType !== \"string\") {\n      this.xhrType = this._determineXhrType();\n    }\n    var xdr = this.xhr = new globalThis.XDomainRequest();\n    xdr.timeout = this.timeout || 5e3;\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open(\"GET\", this.url, true);\n    setTimeout(function() {\n      return xdr.send();\n    }, 1);\n  };\n  LoaderResource2.prototype._createSource = function(type, url2, mime) {\n    if (!mime) {\n      mime = type + \"/\" + this._getExtension(url2);\n    }\n    var source = document.createElement(\"source\");\n    source.src = url2;\n    source.type = mime;\n    return source;\n  };\n  LoaderResource2.prototype._onError = function(event) {\n    this.abort(\"Failed to load element using: \" + event.target.nodeName);\n  };\n  LoaderResource2.prototype._onProgress = function(event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  };\n  LoaderResource2.prototype._onTimeout = function() {\n    this.abort(\"Load timed out.\");\n  };\n  LoaderResource2.prototype._xhrOnError = function() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request failed. Status: \" + xhr.status + ', text: \"' + xhr.statusText + '\"');\n  };\n  LoaderResource2.prototype._xhrOnTimeout = function() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request timed out.\");\n  };\n  LoaderResource2.prototype._xhrOnAbort = function() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + \" Request was aborted by the user.\");\n  };\n  LoaderResource2.prototype._xhrOnLoad = function() {\n    var xhr = this.xhr;\n    var text2 = \"\";\n    var status = typeof xhr.status === \"undefined\" ? STATUS_OK : xhr.status;\n    if (xhr.responseType === \"\" || xhr.responseType === \"text\" || typeof xhr.responseType === \"undefined\") {\n      text2 = xhr.responseText;\n    }\n    if (status === STATUS_NONE && (text2.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    } else if (status === STATUS_IE_BUG_EMPTY) {\n      status = STATUS_EMPTY;\n    }\n    var statusType = status / 100 | 0;\n    if (statusType === STATUS_TYPE_OK) {\n      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text2;\n        this.type = LoaderResource2.TYPE.TEXT;\n      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {\n        try {\n          this.data = JSON.parse(text2);\n          this.type = LoaderResource2.TYPE.JSON;\n        } catch (e) {\n          this.abort(\"Error trying to parse loaded json: \" + e);\n          return;\n        }\n      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {\n        try {\n          if (globalThis.DOMParser) {\n            var domparser = new DOMParser();\n            this.data = domparser.parseFromString(text2, \"text/xml\");\n          } else {\n            var div = document.createElement(\"div\");\n            div.innerHTML = text2;\n            this.data = div;\n          }\n          this.type = LoaderResource2.TYPE.XML;\n        } catch (e$1) {\n          this.abort(\"Error trying to parse loaded xml: \" + e$1);\n          return;\n        }\n      } else {\n        this.data = xhr.response || text2;\n      }\n    } else {\n      this.abort(\"[\" + xhr.status + \"] \" + xhr.statusText + \": \" + xhr.responseURL);\n      return;\n    }\n    this.complete();\n  };\n  LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {\n    if (url2.indexOf(\"data:\") === 0) {\n      return \"\";\n    }\n    if (globalThis.origin !== globalThis.location.origin) {\n      return \"anonymous\";\n    }\n    loc = loc || globalThis.location;\n    if (!tempAnchor) {\n      tempAnchor = document.createElement(\"a\");\n    }\n    tempAnchor.href = url2;\n    var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });\n    var samePort = !parsedUrl.port && loc.port === \"\" || parsedUrl.port === loc.port;\n    var protocol2 = parsedUrl.protocol ? parsedUrl.protocol + \":\" : \"\";\n    if (parsedUrl.host !== loc.hostname || !samePort || protocol2 !== loc.protocol) {\n      return \"anonymous\";\n    }\n    return \"\";\n  };\n  LoaderResource2.prototype._determineXhrType = function() {\n    return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;\n  };\n  LoaderResource2.prototype._determineLoadType = function() {\n    return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;\n  };\n  LoaderResource2.prototype._getExtension = function(url2) {\n    if (url2 === void 0) {\n      url2 = this.url;\n    }\n    var ext = \"\";\n    if (this.isDataUrl) {\n      var slashIndex = url2.indexOf(\"/\");\n      ext = url2.substring(slashIndex + 1, url2.indexOf(\";\", slashIndex));\n    } else {\n      var queryStart = url2.indexOf(\"?\");\n      var hashStart = url2.indexOf(\"#\");\n      var index = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);\n      url2 = url2.substring(0, index);\n      ext = url2.substring(url2.lastIndexOf(\".\") + 1);\n    }\n    return ext.toLowerCase();\n  };\n  LoaderResource2.prototype._getMimeFromXhrType = function(type) {\n    switch (type) {\n      case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:\n        return \"application/octet-binary\";\n      case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:\n        return \"application/blob\";\n      case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:\n        return \"application/xml\";\n      case LoaderResource2.XHR_RESPONSE_TYPE.JSON:\n        return \"application/json\";\n      case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:\n      case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:\n      default:\n        return \"text/plain\";\n    }\n  };\n  return LoaderResource2;\n}();\n(function(LoaderResource2) {\n  (function(STATUS_FLAGS) {\n    STATUS_FLAGS[STATUS_FLAGS[\"NONE\"] = 0] = \"NONE\";\n    STATUS_FLAGS[STATUS_FLAGS[\"DATA_URL\"] = 1] = \"DATA_URL\";\n    STATUS_FLAGS[STATUS_FLAGS[\"COMPLETE\"] = 2] = \"COMPLETE\";\n    STATUS_FLAGS[STATUS_FLAGS[\"LOADING\"] = 4] = \"LOADING\";\n  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));\n  (function(TYPE) {\n    TYPE[TYPE[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    TYPE[TYPE[\"JSON\"] = 1] = \"JSON\";\n    TYPE[TYPE[\"XML\"] = 2] = \"XML\";\n    TYPE[TYPE[\"IMAGE\"] = 3] = \"IMAGE\";\n    TYPE[TYPE[\"AUDIO\"] = 4] = \"AUDIO\";\n    TYPE[TYPE[\"VIDEO\"] = 5] = \"VIDEO\";\n    TYPE[TYPE[\"TEXT\"] = 6] = \"TEXT\";\n  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));\n  (function(LOAD_TYPE) {\n    LOAD_TYPE[LOAD_TYPE[\"XHR\"] = 1] = \"XHR\";\n    LOAD_TYPE[LOAD_TYPE[\"IMAGE\"] = 2] = \"IMAGE\";\n    LOAD_TYPE[LOAD_TYPE[\"AUDIO\"] = 3] = \"AUDIO\";\n    LOAD_TYPE[LOAD_TYPE[\"VIDEO\"] = 4] = \"VIDEO\";\n  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));\n  (function(XHR_RESPONSE_TYPE) {\n    XHR_RESPONSE_TYPE[\"DEFAULT\"] = \"text\";\n    XHR_RESPONSE_TYPE[\"BUFFER\"] = \"arraybuffer\";\n    XHR_RESPONSE_TYPE[\"BLOB\"] = \"blob\";\n    XHR_RESPONSE_TYPE[\"DOCUMENT\"] = \"document\";\n    XHR_RESPONSE_TYPE[\"JSON\"] = \"json\";\n    XHR_RESPONSE_TYPE[\"TEXT\"] = \"text\";\n  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));\n  LoaderResource2._loadTypeMap = {\n    gif: LoaderResource2.LOAD_TYPE.IMAGE,\n    png: LoaderResource2.LOAD_TYPE.IMAGE,\n    bmp: LoaderResource2.LOAD_TYPE.IMAGE,\n    jpg: LoaderResource2.LOAD_TYPE.IMAGE,\n    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,\n    tif: LoaderResource2.LOAD_TYPE.IMAGE,\n    tiff: LoaderResource2.LOAD_TYPE.IMAGE,\n    webp: LoaderResource2.LOAD_TYPE.IMAGE,\n    tga: LoaderResource2.LOAD_TYPE.IMAGE,\n    svg: LoaderResource2.LOAD_TYPE.IMAGE,\n    \"svg+xml\": LoaderResource2.LOAD_TYPE.IMAGE,\n    mp3: LoaderResource2.LOAD_TYPE.AUDIO,\n    ogg: LoaderResource2.LOAD_TYPE.AUDIO,\n    wav: LoaderResource2.LOAD_TYPE.AUDIO,\n    mp4: LoaderResource2.LOAD_TYPE.VIDEO,\n    webm: LoaderResource2.LOAD_TYPE.VIDEO\n  };\n  LoaderResource2._xhrTypeMap = {\n    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,\n    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,\n    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,\n    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,\n    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,\n    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,\n    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER\n  };\n  LoaderResource2.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(LoaderResource || (LoaderResource = {}));\nfunction _noop() {\n}\nfunction onlyOnce(fn2) {\n  return function onceWrapper() {\n    var arguments$1 = arguments;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments$1[_i];\n    }\n    if (fn2 === null) {\n      throw new Error(\"Callback was already called.\");\n    }\n    var callFn = fn2;\n    fn2 = null;\n    callFn.apply(this, args);\n  };\n}\nvar AsyncQueueItem = function() {\n  function AsyncQueueItem2(data, callback) {\n    this.data = data;\n    this.callback = callback;\n  }\n  return AsyncQueueItem2;\n}();\nvar AsyncQueue = function() {\n  function AsyncQueue2(worker, concurrency) {\n    var _this = this;\n    if (concurrency === void 0) {\n      concurrency = 1;\n    }\n    this.workers = 0;\n    this.saturated = _noop;\n    this.unsaturated = _noop;\n    this.empty = _noop;\n    this.drain = _noop;\n    this.error = _noop;\n    this.started = false;\n    this.paused = false;\n    this._tasks = [];\n    this._insert = function(data, insertAtFront, callback) {\n      if (callback && typeof callback !== \"function\") {\n        throw new Error(\"task callback must be a function\");\n      }\n      _this.started = true;\n      if (data == null && _this.idle()) {\n        setTimeout(function() {\n          return _this.drain();\n        }, 1);\n        return;\n      }\n      var item = new AsyncQueueItem(data, typeof callback === \"function\" ? callback : _noop);\n      if (insertAtFront) {\n        _this._tasks.unshift(item);\n      } else {\n        _this._tasks.push(item);\n      }\n      setTimeout(_this.process, 1);\n    };\n    this.process = function() {\n      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {\n        var task = _this._tasks.shift();\n        if (_this._tasks.length === 0) {\n          _this.empty();\n        }\n        _this.workers += 1;\n        if (_this.workers === _this.concurrency) {\n          _this.saturated();\n        }\n        _this._worker(task.data, onlyOnce(_this._next(task)));\n      }\n    };\n    this._worker = worker;\n    if (concurrency === 0) {\n      throw new Error(\"Concurrency must not be zero\");\n    }\n    this.concurrency = concurrency;\n    this.buffer = concurrency / 4;\n  }\n  AsyncQueue2.prototype._next = function(task) {\n    var _this = this;\n    return function() {\n      var arguments$1 = arguments;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments$1[_i];\n      }\n      _this.workers -= 1;\n      task.callback.apply(task, args);\n      if (args[0] != null) {\n        _this.error(args[0], task.data);\n      }\n      if (_this.workers <= _this.concurrency - _this.buffer) {\n        _this.unsaturated();\n      }\n      if (_this.idle()) {\n        _this.drain();\n      }\n      _this.process();\n    };\n  };\n  AsyncQueue2.prototype.push = function(data, callback) {\n    this._insert(data, false, callback);\n  };\n  AsyncQueue2.prototype.kill = function() {\n    this.workers = 0;\n    this.drain = _noop;\n    this.started = false;\n    this._tasks = [];\n  };\n  AsyncQueue2.prototype.unshift = function(data, callback) {\n    this._insert(data, true, callback);\n  };\n  AsyncQueue2.prototype.length = function() {\n    return this._tasks.length;\n  };\n  AsyncQueue2.prototype.running = function() {\n    return this.workers;\n  };\n  AsyncQueue2.prototype.idle = function() {\n    return this._tasks.length + this.workers === 0;\n  };\n  AsyncQueue2.prototype.pause = function() {\n    if (this.paused === true) {\n      return;\n    }\n    this.paused = true;\n  };\n  AsyncQueue2.prototype.resume = function() {\n    if (this.paused === false) {\n      return;\n    }\n    this.paused = false;\n    for (var w2 = 1; w2 <= this.concurrency; w2++) {\n      this.process();\n    }\n  };\n  AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {\n    var i2 = 0;\n    var len = array.length;\n    function next(err) {\n      if (err || i2 === len) {\n        if (callback) {\n          callback(err);\n        }\n        return;\n      }\n      if (deferNext) {\n        setTimeout(function() {\n          iterator(array[i2++], next);\n        }, 1);\n      } else {\n        iterator(array[i2++], next);\n      }\n    }\n    next();\n  };\n  AsyncQueue2.queue = function(worker, concurrency) {\n    return new AsyncQueue2(worker, concurrency);\n  };\n  return AsyncQueue2;\n}();\nvar MAX_PROGRESS = 100;\nvar rgxExtractUrlHash = /(#[\\w-]+)?$/;\nvar Loader = function() {\n  function Loader2(baseUrl, concurrency) {\n    var _this = this;\n    if (baseUrl === void 0) {\n      baseUrl = \"\";\n    }\n    if (concurrency === void 0) {\n      concurrency = 10;\n    }\n    this.progress = 0;\n    this.loading = false;\n    this.defaultQueryString = \"\";\n    this._beforeMiddleware = [];\n    this._afterMiddleware = [];\n    this._resourcesParsing = [];\n    this._boundLoadResource = function(r2, d2) {\n      return _this._loadResource(r2, d2);\n    };\n    this.resources = {};\n    this.baseUrl = baseUrl;\n    this._beforeMiddleware = [];\n    this._afterMiddleware = [];\n    this._resourcesParsing = [];\n    this._boundLoadResource = function(r2, d2) {\n      return _this._loadResource(r2, d2);\n    };\n    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);\n    this._queue.pause();\n    this.resources = {};\n    this.onProgress = new Signal();\n    this.onError = new Signal();\n    this.onLoad = new Signal();\n    this.onStart = new Signal();\n    this.onComplete = new Signal();\n    for (var i2 = 0; i2 < Loader2._plugins.length; ++i2) {\n      var plugin = Loader2._plugins[i2];\n      var pre = plugin.pre, use = plugin.use;\n      if (pre) {\n        this.pre(pre);\n      }\n      if (use) {\n        this.use(use);\n      }\n    }\n    this._protected = false;\n  }\n  Loader2.prototype._add = function(name, url2, options, callback) {\n    if (this.loading && (!options || !options.parentResource)) {\n      throw new Error(\"Cannot add resources while the loader is running.\");\n    }\n    if (this.resources[name]) {\n      throw new Error('Resource named \"' + name + '\" already exists.');\n    }\n    url2 = this._prepareUrl(url2);\n    this.resources[name] = new LoaderResource(name, url2, options);\n    if (typeof callback === \"function\") {\n      this.resources[name].onAfterMiddleware.once(callback);\n    }\n    if (this.loading) {\n      var parent = options.parentResource;\n      var incompleteChildren = [];\n      for (var i2 = 0; i2 < parent.children.length; ++i2) {\n        if (!parent.children[i2].isComplete) {\n          incompleteChildren.push(parent.children[i2]);\n        }\n      }\n      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);\n      var eachChunk = fullChunk / (incompleteChildren.length + 2);\n      parent.children.push(this.resources[name]);\n      parent.progressChunk = eachChunk;\n      for (var i2 = 0; i2 < incompleteChildren.length; ++i2) {\n        incompleteChildren[i2].progressChunk = eachChunk;\n      }\n      this.resources[name].progressChunk = eachChunk;\n    }\n    this._queue.push(this.resources[name]);\n    return this;\n  };\n  Loader2.prototype.pre = function(fn2) {\n    this._beforeMiddleware.push(fn2);\n    return this;\n  };\n  Loader2.prototype.use = function(fn2) {\n    this._afterMiddleware.push(fn2);\n    return this;\n  };\n  Loader2.prototype.reset = function() {\n    this.progress = 0;\n    this.loading = false;\n    this._queue.kill();\n    this._queue.pause();\n    for (var k in this.resources) {\n      var res = this.resources[k];\n      if (res._onLoadBinding) {\n        res._onLoadBinding.detach();\n      }\n      if (res.isLoading) {\n        res.abort(\"loader reset\");\n      }\n    }\n    this.resources = {};\n    return this;\n  };\n  Loader2.prototype.load = function(cb) {\n    if (typeof cb === \"function\") {\n      this.onComplete.once(cb);\n    }\n    if (this.loading) {\n      return this;\n    }\n    if (this._queue.idle()) {\n      this._onStart();\n      this._onComplete();\n    } else {\n      var numTasks = this._queue._tasks.length;\n      var chunk = MAX_PROGRESS / numTasks;\n      for (var i2 = 0; i2 < this._queue._tasks.length; ++i2) {\n        this._queue._tasks[i2].data.progressChunk = chunk;\n      }\n      this._onStart();\n      this._queue.resume();\n    }\n    return this;\n  };\n  Object.defineProperty(Loader2.prototype, \"concurrency\", {\n    get: function() {\n      return this._queue.concurrency;\n    },\n    set: function(concurrency) {\n      this._queue.concurrency = concurrency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Loader2.prototype._prepareUrl = function(url2) {\n    var parsedUrl = parseUri(url2, { strictMode: true });\n    var result;\n    if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf(\"//\") === 0) {\n      result = url2;\n    } else if (this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && url2.charAt(0) !== \"/\") {\n      result = this.baseUrl + \"/\" + url2;\n    } else {\n      result = this.baseUrl + url2;\n    }\n    if (this.defaultQueryString) {\n      var hash2 = rgxExtractUrlHash.exec(result)[0];\n      result = result.slice(0, result.length - hash2.length);\n      if (result.indexOf(\"?\") !== -1) {\n        result += \"&\" + this.defaultQueryString;\n      } else {\n        result += \"?\" + this.defaultQueryString;\n      }\n      result += hash2;\n    }\n    return result;\n  };\n  Loader2.prototype._loadResource = function(resource, dequeue) {\n    var _this = this;\n    resource._dequeue = dequeue;\n    AsyncQueue.eachSeries(this._beforeMiddleware, function(fn2, next) {\n      fn2.call(_this, resource, function() {\n        next(resource.isComplete ? {} : null);\n      });\n    }, function() {\n      if (resource.isComplete) {\n        _this._onLoad(resource);\n      } else {\n        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);\n        resource.load();\n      }\n    }, true);\n  };\n  Loader2.prototype._onStart = function() {\n    this.progress = 0;\n    this.loading = true;\n    this.onStart.dispatch(this);\n  };\n  Loader2.prototype._onComplete = function() {\n    this.progress = MAX_PROGRESS;\n    this.loading = false;\n    this.onComplete.dispatch(this, this.resources);\n  };\n  Loader2.prototype._onLoad = function(resource) {\n    var _this = this;\n    resource._onLoadBinding = null;\n    this._resourcesParsing.push(resource);\n    resource._dequeue();\n    AsyncQueue.eachSeries(this._afterMiddleware, function(fn2, next) {\n      fn2.call(_this, resource, next);\n    }, function() {\n      resource.onAfterMiddleware.dispatch(resource);\n      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);\n      _this.onProgress.dispatch(_this, resource);\n      if (resource.error) {\n        _this.onError.dispatch(resource.error, _this, resource);\n      } else {\n        _this.onLoad.dispatch(_this, resource);\n      }\n      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);\n      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {\n        _this._onComplete();\n      }\n    }, true);\n  };\n  Loader2.prototype.destroy = function() {\n    if (!this._protected) {\n      this.reset();\n    }\n  };\n  Object.defineProperty(Loader2, \"shared\", {\n    get: function() {\n      var shared = Loader2._shared;\n      if (!shared) {\n        shared = new Loader2();\n        shared._protected = true;\n        Loader2._shared = shared;\n      }\n      return shared;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Loader2.registerPlugin = function(plugin) {\n    Loader2._plugins.push(plugin);\n    if (plugin.add) {\n      plugin.add();\n    }\n    return Loader2;\n  };\n  Loader2._plugins = [];\n  return Loader2;\n}();\nLoader.prototype.add = function add2(name, url2, options, callback) {\n  if (Array.isArray(name)) {\n    for (var i2 = 0; i2 < name.length; ++i2) {\n      this.add(name[i2]);\n    }\n    return this;\n  }\n  if (typeof name === \"object\") {\n    options = name;\n    callback = url2 || options.callback || options.onComplete;\n    url2 = options.url;\n    name = options.name || options.key || options.url;\n  }\n  if (typeof url2 !== \"string\") {\n    callback = options;\n    options = url2;\n    url2 = name;\n  }\n  if (typeof url2 !== \"string\") {\n    throw new Error(\"No url passed to add resource to loader.\");\n  }\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  return this._add(name, url2, options, callback);\n};\nvar AppLoaderPlugin = function() {\n  function AppLoaderPlugin2() {\n  }\n  AppLoaderPlugin2.init = function(options) {\n    options = Object.assign({\n      sharedLoader: false\n    }, options);\n    this.loader = options.sharedLoader ? Loader.shared : new Loader();\n  };\n  AppLoaderPlugin2.destroy = function() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  };\n  return AppLoaderPlugin2;\n}();\nvar TextureLoader = function() {\n  function TextureLoader2() {\n  }\n  TextureLoader2.add = function() {\n    LoaderResource.setExtensionLoadType(\"svg\", LoaderResource.LOAD_TYPE.XHR);\n    LoaderResource.setExtensionXhrType(\"svg\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  };\n  TextureLoader2.use = function(resource, next) {\n    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === \"svg\")) {\n      var data = resource.data, url2 = resource.url, name = resource.name, metadata = resource.metadata;\n      Texture.fromLoader(data, url2, name, metadata).then(function(texture) {\n        resource.texture = texture;\n        next();\n      }).catch(next);\n    } else {\n      next();\n    }\n  };\n  return TextureLoader2;\n}();\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction encodeBinary(input) {\n  var output = \"\";\n  var inx = 0;\n  while (inx < input.length) {\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;\n    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;\n    encodedCharIndexes[3] = bytebuffer[2] & 63;\n    var paddingBytes = inx - (input.length - 1);\n    switch (paddingBytes) {\n      case 2:\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n      case 1:\n        encodedCharIndexes[3] = 64;\n        break;\n    }\n    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[jnx]);\n    }\n  }\n  return output;\n}\nfunction parsing(resource, next) {\n  if (!resource.data) {\n    next();\n    return;\n  }\n  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof resource.data === \"string\") {\n      var type = resource.xhr.getResponseHeader(\"content-type\");\n      if (type && type.indexOf(\"image\") === 0) {\n        resource.data = new Image();\n        resource.data.src = \"data:\" + type + \";base64,\" + encodeBinary(resource.xhr.responseText);\n        resource.type = LoaderResource.TYPE.IMAGE;\n        resource.data.onload = function() {\n          resource.data.onload = null;\n          next();\n        };\n        return;\n      }\n    } else if (resource.data.type.indexOf(\"image\") === 0) {\n      var Url_1 = globalThis.URL || globalThis.webkitURL;\n      var src_1 = Url_1.createObjectURL(resource.data);\n      resource.blob = resource.data;\n      resource.data = new Image();\n      resource.data.src = src_1;\n      resource.type = LoaderResource.TYPE.IMAGE;\n      resource.data.onload = function() {\n        Url_1.revokeObjectURL(src_1);\n        resource.data.onload = null;\n        next();\n      };\n      return;\n    }\n  }\n  next();\n}\nLoader.registerPlugin({ use: parsing });\nLoader.registerPlugin(TextureLoader);\n/*!\n * @pixi/sound - v4.2.0\n * https://github.com/pixijs/pixi-sound\n * Compiled Wed, 05 Jan 2022 14:56:00 UTC\n *\n * @pixi/sound is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar r;\nfunction s() {\n  return r;\n}\nvar u = function(t, e) {\n  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, e2) {\n    t2.__proto__ = e2;\n  } || function(t2, e2) {\n    for (var n in e2)\n      Object.prototype.hasOwnProperty.call(e2, n) && (t2[n] = e2[n]);\n  })(t, e);\n};\nfunction a(t, e) {\n  if (typeof e != \"function\" && e !== null)\n    throw new TypeError(\"Class extends value \" + String(e) + \" is not a constructor or null\");\n  function n() {\n    this.constructor = t;\n  }\n  u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());\n}\nvar c = function() {\n  return (c = Object.assign || function(t) {\n    for (var e, n = 1, o = arguments.length; n < o; n++)\n      for (var i2 in e = arguments[n])\n        Object.prototype.hasOwnProperty.call(e, i2) && (t[i2] = e[i2]);\n    return t;\n  }).apply(this, arguments);\n}, l = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], p$1 = {};\nfunction h(t) {\n  var e = c({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, t || {}), n = document.createElement(\"audio\"), o = {}, i2 = /^no$/;\n  l.forEach(function(t2) {\n    var r2 = n.canPlayType(\"audio/\".concat(t2)).replace(i2, \"\"), s2 = e[t2] ? n.canPlayType(e[t2]).replace(i2, \"\") : \"\";\n    o[t2] = !!r2 || !!s2;\n  }), Object.assign(p$1, o);\n}\nh();\nvar f = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction d(t) {\n  var e = f, n = typeof t == \"string\" ? t : t.url;\n  if (!e.test(n))\n    return n;\n  for (var o = e.exec(n), i2 = o[2].split(\",\"), r2 = i2[i2.length - 1], s2 = 0, u2 = i2.length; s2 < u2; s2++) {\n    var a2 = i2[s2];\n    if (p$1[a2]) {\n      r2 = a2;\n      break;\n    }\n  }\n  var c2 = n.replace(o[1], r2);\n  if (typeof t != \"string\") {\n    var l2 = t;\n    l2.extension = r2, l2.url = c2;\n  }\n  return c2;\n}\nvar _ = function() {\n  function e() {\n  }\n  return e.add = function() {\n    e.setLegacy(s().useLegacy);\n  }, e.setLegacy = function(e2) {\n    var n = l;\n    e2 ? n.forEach(function(e3) {\n      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.AUDIO);\n    }) : n.forEach(function(e3) {\n      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.XHR);\n    });\n  }, e.pre = function(t, e2) {\n    d(t), e2();\n  }, e.use = function(t, e2) {\n    t.data && l.indexOf(t.extension) > -1 ? t.sound = s().add(t.name, { loaded: e2, preload: true, url: t.url, source: t.data }) : e2();\n  }, e;\n}(), y = 0, m = function(t) {\n  function e(e2) {\n    var n = t.call(this) || this;\n    return n.id = y++, n.init(e2), n;\n  }\n  return a(e, t), e.prototype.set = function(t2, e2) {\n    if (this[t2] === void 0)\n      throw new Error(\"Property with name \".concat(t2, \" does not exist.\"));\n    switch (t2) {\n      case \"speed\":\n        this.speed = e2;\n        break;\n      case \"volume\":\n        this.volume = e2;\n        break;\n      case \"paused\":\n        this.paused = e2;\n        break;\n      case \"loop\":\n        this.loop = e2;\n        break;\n      case \"muted\":\n        this.muted = e2;\n    }\n    return this;\n  }, Object.defineProperty(e.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t2) {\n    this._paused = t2, this.refreshPaused();\n  }, enumerable: false, configurable: true }), e.prototype._onPlay = function() {\n    this._playing = true;\n  }, e.prototype._onPause = function() {\n    this._playing = false;\n  }, e.prototype.init = function(t2) {\n    this._playing = false, this._duration = t2.source.duration;\n    var e2 = this._source = t2.source.cloneNode(false);\n    e2.src = t2.parent.url, e2.onplay = this._onPlay.bind(this), e2.onpause = this._onPause.bind(this), t2.context.on(\"refresh\", this.refresh, this), t2.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = t2;\n  }, e.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, e.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(e.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t2) {\n    this._speed = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t2) {\n    this._volume = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t2) {\n    this._loop = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t2) {\n    this._muted = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(t2) {\n  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {\n    var t2 = this._media.context, e2 = this._media.parent;\n    this._source.loop = this._loop || e2.loop;\n    var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = i2 * n * o, this._source.playbackRate = this._speed * t2.speed * e2.speed;\n  }, e.prototype.refreshPaused = function() {\n    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;\n    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", n));\n  }, e.prototype.play = function(t2) {\n    var n = this, i2 = t2.start, r2 = t2.end, s2 = t2.speed, u2 = t2.loop, a2 = t2.volume, c2 = t2.muted;\n    this._speed = s2, this._volume = a2, this._loop = !!u2, this._muted = c2, this.refresh(), this.loop && r2 !== null && (this.loop = false), this._start = i2, this._end = r2 || this._duration, this._start = Math.max(0, this._start - e.PADDING), this._end = Math.min(this._end + e.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      n._source && (n._source.currentTime = i2, n._source.onloadedmetadata = null, n.emit(\"progress\", i2, n._duration), Ticker.shared.add(n._onUpdate, n));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, e.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, e.prototype._onComplete = function() {\n    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, e.prototype.destroy = function() {\n    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var t2 = this._source;\n    t2 && (t2.onended = null, t2.onplay = null, t2.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = false, this._end = null, this._start = 0, this._duration = 0, this._playing = false, this._pausedReal = false, this._paused = false, this._muted = false, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, e.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, e.PADDING = 0.1, e;\n}(EventEmitter$4), g = function(t) {\n  function e() {\n    return t !== null && t.apply(this, arguments) || this;\n  }\n  return a(e, t), e.prototype.init = function(t2) {\n    this.parent = t2, this._source = t2.options.source || new Audio(), t2.url && (this._source.src = t2.url);\n  }, e.prototype.create = function() {\n    return new m(this);\n  }, Object.defineProperty(e.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(t2) {\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(e.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: false, configurable: true }), e.prototype.load = function(t2) {\n    var e2 = this._source, n = this.parent;\n    if (e2.readyState !== 4)\n      if (n.url) {\n        e2.src = n.url;\n        var o = function() {\n          s2(), n.isLoaded = true;\n          var e3 = n.autoPlayStart();\n          t2 && t2(null, n, e3);\n        }, i2 = function() {\n          s2(), t2 && t2(new Error(\"Sound loading has been aborted\"));\n        }, r2 = function() {\n          s2();\n          var n2 = \"Failed to load audio element (code: \".concat(e2.error.code, \")\");\n          t2 && t2(new Error(n2));\n        }, s2 = function() {\n          e2.removeEventListener(\"canplaythrough\", o), e2.removeEventListener(\"load\", o), e2.removeEventListener(\"abort\", i2), e2.removeEventListener(\"error\", r2);\n        };\n        e2.addEventListener(\"canplaythrough\", o, false), e2.addEventListener(\"load\", o, false), e2.addEventListener(\"abort\", i2, false), e2.addEventListener(\"error\", r2, false), e2.load();\n      } else\n        t2(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      n.isLoaded = true;\n      var u2 = n.autoPlayStart();\n      t2 && setTimeout(function() {\n        t2(null, n, u2);\n      }, 0);\n    }\n  }, e;\n}(EventEmitter$4), b = function() {\n  function t(t2, e) {\n    this.parent = t2, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return t.prototype.play = function(t2) {\n    return this.parent.play({ complete: t2, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, t.prototype.destroy = function() {\n    this.parent = null;\n  }, t;\n}(), v = function() {\n  function t() {\n  }\n  return t.setParamValue = function(t2, e) {\n    if (t2.setValueAtTime) {\n      var n = s().context;\n      t2.setValueAtTime(e, n.audioContext.currentTime);\n    } else\n      t2.value = e;\n    return e;\n  }, t;\n}(), P = 0, x$1 = function(t) {\n  function e(e2) {\n    var n = t.call(this) || this;\n    return n.id = P++, n._media = null, n._paused = false, n._muted = false, n._elapsed = 0, n.init(e2), n;\n  }\n  return a(e, t), e.prototype.set = function(t2, e2) {\n    if (this[t2] === void 0)\n      throw new Error(\"Property with name \".concat(t2, \" does not exist.\"));\n    switch (t2) {\n      case \"speed\":\n        this.speed = e2;\n        break;\n      case \"volume\":\n        this.volume = e2;\n        break;\n      case \"muted\":\n        this.muted = e2;\n        break;\n      case \"loop\":\n        this.loop = e2;\n        break;\n      case \"paused\":\n        this.paused = e2;\n    }\n    return this;\n  }, e.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(e.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t2) {\n    this._speed = t2, this.refresh(), this._update(true);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t2) {\n    this._volume = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t2) {\n    this._muted = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t2) {\n    this._loop = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t2) {\n    var e2;\n    this._filters && ((e2 = this._filters) === null || e2 === void 0 || e2.filter(function(t3) {\n      return t3;\n    }).forEach(function(t3) {\n      return t3.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = (t2 == null ? void 0 : t2.length) ? t2.slice(0) : null, this.refresh();\n  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {\n    if (this._source) {\n      var t2 = this._media.context, e2 = this._media.parent;\n      this._source.loop = this._loop || e2.loop;\n      var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);\n      v.setParamValue(this._gain.gain, i2 * o * n), v.setParamValue(this._source.playbackRate, this._speed * e2.speed * t2.speed), this.applyFilters();\n    }\n  }, e.prototype.applyFilters = function() {\n    var t2;\n    if ((t2 = this._filters) === null || t2 === void 0 ? void 0 : t2.length) {\n      this._source.disconnect();\n      var e2 = this._source;\n      this._filters.forEach(function(t3) {\n        e2.connect(t3.destination), e2 = t3;\n      }), e2.connect(this._gain);\n    }\n  }, e.prototype.refreshPaused = function() {\n    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;\n    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", n));\n  }, e.prototype.play = function(t2) {\n    var e2 = t2.start, n = t2.end, o = t2.speed, i2 = t2.loop, r2 = t2.volume, s2 = t2.muted, u2 = t2.filters;\n    this._paused = false;\n    var a2 = this._media.nodes.cloneBufferSource(), c2 = a2.source, l2 = a2.gain;\n    this._source = c2, this._gain = l2, this._speed = o, this._volume = r2, this._loop = !!i2, this._muted = s2, this._filters = u2, this.refresh();\n    var p2 = this._source.buffer.duration;\n    this._duration = p2, this._end = n, this._lastUpdate = this._now(), this._elapsed = e2, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = e2, this._source.start(0, e2)) : n ? this._source.start(0, e2, n - e2) : this._source.start(0, e2), this.emit(\"start\"), this._update(true), this.enableTicker(true);\n  }, e.prototype.enableTicker = function(t2) {\n    Ticker.shared.remove(this._updateListener, this), t2 && Ticker.shared.add(this._updateListener, this);\n  }, Object.defineProperty(e.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t2) {\n    this._paused = t2, this.refreshPaused();\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    var t2;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (t2 = this._filters) === null || t2 === void 0 || t2.forEach(function(t3) {\n      return t3.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = false, this._elapsed = 0, this._duration = 0, this._paused = false, this._muted = false, this._pausedReal = false;\n  }, e.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, e.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, e.prototype._updateListener = function() {\n    this._update();\n  }, e.prototype._update = function(t2) {\n    if (t2 === void 0 && (t2 = false), this._source) {\n      var e2 = this._now(), n = e2 - this._lastUpdate;\n      if (n > 0 || t2) {\n        var o = this._source.playbackRate.value;\n        this._elapsed += n * o, this._lastUpdate = e2;\n        var i2 = this._duration, r2 = void 0;\n        if (this._source.loopStart) {\n          var s2 = this._source.loopEnd - this._source.loopStart;\n          r2 = (this._source.loopStart + this._elapsed % s2) / i2;\n        } else\n          r2 = this._elapsed % i2 / i2;\n        this._progress = r2, this.emit(\"progress\", this._progress, i2);\n      }\n    }\n  }, e.prototype.init = function(t2) {\n    this._media = t2, t2.context.events.on(\"refresh\", this.refresh, this), t2.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, e.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(false), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch (t2) {\n      }\n      this._source = null;\n    }\n  }, e.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(false), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch (t2) {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, e;\n}(EventEmitter$4), O = function() {\n  function t(t2, e) {\n    this._output = e, this._input = t2;\n  }\n  return Object.defineProperty(t.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t2) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(t3) {\n      t3 && t3.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t2 && t2.length) {\n      this._filters = t2.slice(0), this._input.disconnect();\n      var n = null;\n      t2.forEach(function(t3) {\n        n === null ? e._input.connect(t3.destination) : n.connect(t3.destination), n = t3;\n      }), n.connect(this._output);\n    }\n  }, enumerable: false, configurable: true }), t.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, t;\n}(), j = function(t) {\n  function e(e2) {\n    var n = this, o = e2.audioContext, i2 = o.createBufferSource(), r2 = o.createGain(), s2 = o.createAnalyser();\n    return i2.connect(s2), s2.connect(r2), r2.connect(e2.destination), (n = t.call(this, s2, r2) || this).context = e2, n.bufferSource = i2, n.gain = r2, n.analyser = s2, n;\n  }\n  return a(e, t), Object.defineProperty(e.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(e.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    t.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, e.prototype.cloneBufferSource = function() {\n    var t2 = this.bufferSource, e2 = this.context.audioContext.createBufferSource();\n    e2.buffer = t2.buffer, v.setParamValue(e2.playbackRate, t2.playbackRate.value), e2.loop = t2.loop;\n    var n = this.context.audioContext.createGain();\n    return e2.connect(n), n.connect(this.destination), { source: e2, gain: n };\n  }, Object.defineProperty(e.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: false, configurable: true }), e.BUFFER_SIZE = 0, e;\n}(O), w = function() {\n  function t() {\n  }\n  return t.prototype.init = function(t2) {\n    this.parent = t2, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t2.options.source;\n  }, t.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch (t2) {\n    }\n    this._source = null, this.source = null;\n  }, t.prototype.create = function() {\n    return new x$1(this);\n  }, Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t2) {\n    this._nodes.filters = t2;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t2) {\n    this._source.buffer = t2;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: false, configurable: true }), t.prototype.load = function(t2) {\n    this.source ? this._decode(this.source, t2) : this.parent.url ? this._loadUrl(t2) : t2 && t2(new Error(\"sound.url or sound.source must be set\"));\n  }, t.prototype._loadUrl = function(t2) {\n    var e = this, n = new XMLHttpRequest(), o = this.parent.url;\n    n.open(\"GET\", o, true), n.responseType = \"arraybuffer\", n.onload = function() {\n      e.source = n.response, e._decode(n.response, t2);\n    }, n.send();\n  }, t.prototype._decode = function(t2, e) {\n    var n = this, o = function(t3, o2) {\n      if (t3)\n        e && e(t3);\n      else {\n        n.parent.isLoaded = true, n.buffer = o2;\n        var i2 = n.parent.autoPlayStart();\n        e && e(null, n.parent, i2);\n      }\n    };\n    t2 instanceof AudioBuffer ? o(null, t2) : this.parent.context.decode(t2, o);\n  }, t;\n}(), A = function() {\n  function t(t2, e) {\n    this.media = t2, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var n = e.complete;\n    this._autoPlayOptions = n ? { complete: n } : null, this.isLoaded = false, this.isPlaying = false, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return t.from = function(e) {\n    var n = {};\n    return typeof e == \"string\" ? n.url = e : e instanceof ArrayBuffer || e instanceof AudioBuffer || e instanceof HTMLAudioElement ? n.source = e : n = e, (n = c({ autoPlay: false, singleInstance: false, url: null, source: null, preload: false, volume: 1, speed: 1, complete: null, loaded: null, loop: false }, n)).url && (n.url = d(n.url)), Object.freeze(n), new t(s().useLegacy ? new g() : new w(), n);\n  }, Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return s().context;\n  }, enumerable: false, configurable: true }), t.prototype.pause = function() {\n    return this.isPlaying = false, this.paused = true, this;\n  }, t.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = false, this;\n  }, Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t2) {\n    this._paused = t2, this.refreshPaused();\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t2) {\n    this._speed = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t2) {\n    this.media.filters = t2;\n  }, enumerable: false, configurable: true }), t.prototype.addSprites = function(t2, e) {\n    if (typeof t2 == \"object\") {\n      var n = {};\n      for (var o in t2)\n        n[o] = this.addSprites(o, t2[o]);\n      return n;\n    }\n    var i2 = new b(this, e);\n    return this._sprites[t2] = i2, i2;\n  }, t.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, t.prototype.removeSprites = function(t2) {\n    if (t2) {\n      var e = this._sprites[t2];\n      e !== void 0 && (e.destroy(), delete this._sprites[t2]);\n    } else\n      for (var n in this._sprites)\n        this.removeSprites(n);\n    return this;\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: false, configurable: true }), t.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = false, this._autoPlayOptions = null, this;\n    this.isPlaying = false;\n    for (var t2 = this._instances.length - 1; t2 >= 0; t2--)\n      this._instances[t2].stop();\n    return this;\n  }, t.prototype.play = function(t2, e) {\n    var n, o = this;\n    typeof t2 == \"string\" ? n = { sprite: r2 = t2, loop: this.loop, complete: e } : typeof t2 == \"function\" ? (n = {}).complete = t2 : n = t2;\n    if ((n = c({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: false, loop: false }, n || {})).sprite) {\n      var i2 = n.sprite, r2 = this._sprites[i2];\n      n.start = r2.start + (n.start || 0), n.end = r2.end, n.speed = r2.speed || 1, n.loop = r2.loop || n.loop, delete n.sprite;\n    }\n    if (n.offset && (n.start = n.offset), !this.isLoaded)\n      return new Promise(function(t3, e2) {\n        o.autoPlay = true, o._autoPlayOptions = n, o._preload(function(o2, i3, r3) {\n          o2 ? e2(o2) : (n.loaded && n.loaded(o2, i3, r3), t3(r3));\n        });\n      });\n    (this.singleInstance || n.singleInstance) && this._removeInstances();\n    var s2 = this._createInstance();\n    return this._instances.push(s2), this.isPlaying = true, s2.once(\"end\", function() {\n      n.complete && n.complete(o), o._onComplete(s2);\n    }), s2.once(\"stop\", function() {\n      o._onComplete(s2);\n    }), s2.play(n), s2;\n  }, t.prototype.refresh = function() {\n    for (var t2 = this._instances.length, e = 0; e < t2; e++)\n      this._instances[e].refresh();\n  }, t.prototype.refreshPaused = function() {\n    for (var t2 = this._instances.length, e = 0; e < t2; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t2) {\n    this._volume = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t2) {\n    this._muted = t2, this.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t2) {\n    this._loop = t2, this.refresh();\n  }, enumerable: false, configurable: true }), t.prototype._preload = function(t2) {\n    this.media.load(t2);\n  }, Object.defineProperty(t.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: false, configurable: true }), t.prototype.autoPlayStart = function() {\n    var t2;\n    return this.autoPlay && (t2 = this.play(this._autoPlayOptions)), t2;\n  }, t.prototype._removeInstances = function() {\n    for (var t2 = this._instances.length - 1; t2 >= 0; t2--)\n      this._poolInstance(this._instances[t2]);\n    this._instances.length = 0;\n  }, t.prototype._onComplete = function(t2) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t2);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t2);\n  }, t.prototype._createInstance = function() {\n    if (t._pool.length > 0) {\n      var e = t._pool.pop();\n      return e.init(this.media), e;\n    }\n    return this.media.create();\n  }, t.prototype._poolInstance = function(e) {\n    e.destroy(), t._pool.indexOf(e) < 0 && t._pool.push(e);\n  }, t._pool = [], t;\n}(), F = function(t) {\n  function e() {\n    var e2 = t !== null && t.apply(this, arguments) || this;\n    return e2.speed = 1, e2.muted = false, e2.volume = 1, e2.paused = false, e2;\n  }\n  return a(e, t), e.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, e.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(e.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(t2) {\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: false, configurable: true }), e.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, e.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, e.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, e;\n}(EventEmitter$4), C = function(t) {\n  function e() {\n    var o = this, i2 = window, r2 = new e.AudioContext(), s2 = r2.createDynamicsCompressor(), u2 = r2.createAnalyser();\n    return u2.connect(s2), s2.connect(r2.destination), (o = t.call(this, u2, s2) || this)._ctx = r2, o._offlineCtx = new e.OfflineAudioContext(1, 2, i2.OfflineAudioContext ? r2.sampleRate : 44100), o._unlocked = false, o.compressor = s2, o.analyser = u2, o.events = new EventEmitter$4(), o.volume = 1, o.speed = 1, o.muted = false, o.paused = false, r2.state !== \"running\" && (o._unlock(), o._unlock = o._unlock.bind(o), document.addEventListener(\"mousedown\", o._unlock, true), document.addEventListener(\"touchstart\", o._unlock, true), document.addEventListener(\"touchend\", o._unlock, true)), o;\n  }\n  return a(e, t), e.prototype._unlock = function() {\n    this._unlocked || (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, true), document.removeEventListener(\"touchend\", this._unlock, true), document.removeEventListener(\"touchstart\", this._unlock, true), this._unlocked = true));\n  }, e.prototype.playEmptySound = function() {\n    var t2 = this._ctx.createBufferSource();\n    t2.buffer = this._ctx.createBuffer(1, 1, 22050), t2.connect(this._ctx.destination), t2.start(0, 0, 0), t2.context.state === \"suspended\" && t2.context.resume();\n  }, Object.defineProperty(e, \"AudioContext\", { get: function() {\n    var t2 = window;\n    return t2.AudioContext || t2.webkitAudioContext || null;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e, \"OfflineAudioContext\", { get: function() {\n    var t2 = window;\n    return t2.OfflineAudioContext || t2.webkitOfflineAudioContext || null;\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    t.prototype.destroy.call(this);\n    var e2 = this._ctx;\n    e2.close !== void 0 && e2.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(e.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t2) {\n    t2 && this._ctx.state === \"running\" ? this._ctx.suspend() : t2 || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = t2;\n  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, e.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, e.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, e.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, e.prototype.decode = function(t2, e2) {\n    var n = function(t3) {\n      e2(new Error(t3.message || \"Unable to decode file\"));\n    }, o = this._offlineCtx.decodeAudioData(t2, function(t3) {\n      e2(null, t3);\n    }, n);\n    o && o.catch(n);\n  }, e;\n}(O), E = function() {\n  function t() {\n    this.init();\n  }\n  return t.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t2) {\n    this.useLegacy || (this._context.filters = t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"supported\", { get: function() {\n    return C.AudioContext !== null;\n  }, enumerable: false, configurable: true }), t.prototype.add = function(t2, e) {\n    if (typeof t2 == \"object\") {\n      var n = {};\n      for (var o in t2) {\n        var i2 = this._getOptions(t2[o], e);\n        n[o] = this.add(o, i2);\n      }\n      return n;\n    }\n    if (e instanceof A)\n      return this._sounds[t2] = e, e;\n    var r2 = this._getOptions(e), s2 = A.from(r2);\n    return this._sounds[t2] = s2, s2;\n  }, t.prototype._getOptions = function(t2, e) {\n    var n;\n    return n = typeof t2 == \"string\" ? { url: t2 } : t2 instanceof ArrayBuffer || t2 instanceof AudioBuffer || t2 instanceof HTMLAudioElement ? { source: t2 } : t2, n = c(c({}, n), e || {});\n  }, Object.defineProperty(t.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t2) {\n    _.setLegacy(t2), this._useLegacy = t2, this._context = !t2 && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: false, configurable: true }), t.prototype.remove = function(t2) {\n    return this.exists(t2, true), this._sounds[t2].destroy(), delete this._sounds[t2], this;\n  }, Object.defineProperty(t.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t2) {\n    this._context.volume = t2, this._context.refresh();\n  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t2) {\n    this._context.speed = t2, this._context.refresh();\n  }, enumerable: false, configurable: true }), t.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, t.prototype.pauseAll = function() {\n    return this._context.paused = true, this._context.refreshPaused(), this;\n  }, t.prototype.resumeAll = function() {\n    return this._context.paused = false, this._context.refreshPaused(), this;\n  }, t.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, t.prototype.muteAll = function() {\n    return this._context.muted = true, this._context.refresh(), this;\n  }, t.prototype.unmuteAll = function() {\n    return this._context.muted = false, this._context.refresh(), this;\n  }, t.prototype.removeAll = function() {\n    for (var t2 in this._sounds)\n      this._sounds[t2].destroy(), delete this._sounds[t2];\n    return this;\n  }, t.prototype.stopAll = function() {\n    for (var t2 in this._sounds)\n      this._sounds[t2].stop();\n    return this;\n  }, t.prototype.exists = function(t2, e) {\n    return !!this._sounds[t2];\n  }, t.prototype.find = function(t2) {\n    return this.exists(t2, true), this._sounds[t2];\n  }, t.prototype.play = function(t2, e) {\n    return this.find(t2).play(e);\n  }, t.prototype.stop = function(t2) {\n    return this.find(t2).stop();\n  }, t.prototype.pause = function(t2) {\n    return this.find(t2).pause();\n  }, t.prototype.resume = function(t2) {\n    return this.find(t2).resume();\n  }, t.prototype.volume = function(t2, e) {\n    var n = this.find(t2);\n    return e !== void 0 && (n.volume = e), n.volume;\n  }, t.prototype.speed = function(t2, e) {\n    var n = this.find(t2);\n    return e !== void 0 && (n.speed = e), n.speed;\n  }, t.prototype.duration = function(t2) {\n    return this.find(t2).duration;\n  }, t.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, t;\n}(), S = function() {\n  function t(t2, e) {\n    this.init(t2, e);\n  }\n  return t.prototype.init = function(t2, e) {\n    this.destination = t2, this.source = e || t2;\n  }, t.prototype.connect = function(t2) {\n    this.source.connect(t2);\n  }, t.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, t.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, t;\n}();\n({ __proto__: null, Filter: S, EqualizerFilter: function(t) {\n  function e(n, o, i2, r2, u2, a2, c2, l2, p2, h2) {\n    n === void 0 && (n = 0), o === void 0 && (o = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), u2 === void 0 && (u2 = 0), a2 === void 0 && (a2 = 0), c2 === void 0 && (c2 = 0), l2 === void 0 && (l2 = 0), p2 === void 0 && (p2 = 0), h2 === void 0 && (h2 = 0);\n    var f2 = this;\n    if (!s().useLegacy) {\n      var d2 = [{ f: e.F32, type: \"lowshelf\", gain: n }, { f: e.F64, type: \"peaking\", gain: o }, { f: e.F125, type: \"peaking\", gain: i2 }, { f: e.F250, type: \"peaking\", gain: r2 }, { f: e.F500, type: \"peaking\", gain: u2 }, { f: e.F1K, type: \"peaking\", gain: a2 }, { f: e.F2K, type: \"peaking\", gain: c2 }, { f: e.F4K, type: \"peaking\", gain: l2 }, { f: e.F8K, type: \"peaking\", gain: p2 }, { f: e.F16K, type: \"highshelf\", gain: h2 }].map(function(t2) {\n        var e2 = s().context.audioContext.createBiquadFilter();\n        return e2.type = t2.type, v.setParamValue(e2.Q, 1), e2.frequency.value = t2.f, v.setParamValue(e2.gain, t2.gain), e2;\n      });\n      (f2 = t.call(this, d2[0], d2[d2.length - 1]) || this).bands = d2, f2.bandsMap = {};\n      for (var _2 = 0; _2 < f2.bands.length; _2++) {\n        var y2 = f2.bands[_2];\n        _2 > 0 && f2.bands[_2 - 1].connect(y2), f2.bandsMap[y2.frequency.value] = y2;\n      }\n      return f2;\n    }\n    f2 = t.call(this, null) || this;\n  }\n  return a(e, t), e.prototype.setGain = function(t2, e2) {\n    if (e2 === void 0 && (e2 = 0), !this.bandsMap[t2])\n      throw new Error(\"No band found for frequency \".concat(t2));\n    v.setParamValue(this.bandsMap[t2].gain, e2);\n  }, e.prototype.getGain = function(t2) {\n    if (!this.bandsMap[t2])\n      throw new Error(\"No band found for frequency \".concat(t2));\n    return this.bandsMap[t2].gain.value;\n  }, Object.defineProperty(e.prototype, \"f32\", { get: function() {\n    return this.getGain(e.F32);\n  }, set: function(t2) {\n    this.setGain(e.F32, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f64\", { get: function() {\n    return this.getGain(e.F64);\n  }, set: function(t2) {\n    this.setGain(e.F64, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f125\", { get: function() {\n    return this.getGain(e.F125);\n  }, set: function(t2) {\n    this.setGain(e.F125, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f250\", { get: function() {\n    return this.getGain(e.F250);\n  }, set: function(t2) {\n    this.setGain(e.F250, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f500\", { get: function() {\n    return this.getGain(e.F500);\n  }, set: function(t2) {\n    this.setGain(e.F500, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f1k\", { get: function() {\n    return this.getGain(e.F1K);\n  }, set: function(t2) {\n    this.setGain(e.F1K, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f2k\", { get: function() {\n    return this.getGain(e.F2K);\n  }, set: function(t2) {\n    this.setGain(e.F2K, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f4k\", { get: function() {\n    return this.getGain(e.F4K);\n  }, set: function(t2) {\n    this.setGain(e.F4K, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f8k\", { get: function() {\n    return this.getGain(e.F8K);\n  }, set: function(t2) {\n    this.setGain(e.F8K, t2);\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"f16k\", { get: function() {\n    return this.getGain(e.F16K);\n  }, set: function(t2) {\n    this.setGain(e.F16K, t2);\n  }, enumerable: false, configurable: true }), e.prototype.reset = function() {\n    this.bands.forEach(function(t2) {\n      v.setParamValue(t2.gain, 0);\n    });\n  }, e.prototype.destroy = function() {\n    this.bands.forEach(function(t2) {\n      t2.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, e.F32 = 32, e.F64 = 64, e.F125 = 125, e.F250 = 250, e.F500 = 500, e.F1K = 1e3, e.F2K = 2e3, e.F4K = 4e3, e.F8K = 8e3, e.F16K = 16e3, e;\n}(S), DistortionFilter: function(t) {\n  function e(e2) {\n    e2 === void 0 && (e2 = 0);\n    var n = this;\n    if (!s().useLegacy) {\n      var o = s().context.audioContext.createWaveShaper();\n      return (n = t.call(this, o) || this)._distortion = o, n.amount = e2, n;\n    }\n    n = t.call(this, null) || this;\n  }\n  return a(e, t), Object.defineProperty(e.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(t2) {\n    this._amount = t2;\n    for (var e2, n = 1e3 * t2, o = 44100, i2 = new Float32Array(o), r2 = Math.PI / 180, s2 = 0; s2 < o; ++s2)\n      e2 = 2 * s2 / o - 1, i2[s2] = (3 + n) * e2 * 20 * r2 / (Math.PI + n * Math.abs(e2));\n    this._distortion.curve = i2, this._distortion.oversample = \"4x\";\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    this._distortion = null, t.prototype.destroy.call(this);\n  }, e;\n}(S), StereoFilter: function(t) {\n  function e(e2) {\n    e2 === void 0 && (e2 = 0);\n    var n = this;\n    if (!s().useLegacy) {\n      var o, i2, r2, u2 = s().context.audioContext;\n      return u2.createStereoPanner ? r2 = o = u2.createStereoPanner() : ((i2 = u2.createPanner()).panningModel = \"equalpower\", r2 = i2), (n = t.call(this, r2) || this)._stereo = o, n._panner = i2, n.pan = e2, n;\n    }\n    n = t.call(this, null) || this;\n  }\n  return a(e, t), Object.defineProperty(e.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(t2) {\n    this._pan = t2, this._stereo ? v.setParamValue(this._stereo.pan, t2) : this._panner.setPosition(t2, 0, 1 - Math.abs(t2));\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    t.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, e;\n}(S), ReverbFilter: function(t) {\n  function e(e2, n, o) {\n    e2 === void 0 && (e2 = 3), n === void 0 && (n = 2), o === void 0 && (o = false);\n    var i2 = this;\n    if (!s().useLegacy)\n      return (i2 = t.call(this, null) || this)._seconds = i2._clamp(e2, 1, 50), i2._decay = i2._clamp(n, 0, 100), i2._reverse = o, i2._rebuild(), i2;\n    i2 = t.call(this, null) || this;\n  }\n  return a(e, t), e.prototype._clamp = function(t2, e2, n) {\n    return Math.min(n, Math.max(e2, t2));\n  }, Object.defineProperty(e.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(t2) {\n    this._seconds = this._clamp(t2, 1, 50), this._rebuild();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(t2) {\n    this._decay = this._clamp(t2, 0, 100), this._rebuild();\n  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(t2) {\n    this._reverse = t2, this._rebuild();\n  }, enumerable: false, configurable: true }), e.prototype._rebuild = function() {\n    for (var t2, e2 = s().context.audioContext, n = e2.sampleRate, o = n * this._seconds, i2 = e2.createBuffer(2, o, n), r2 = i2.getChannelData(0), u2 = i2.getChannelData(1), a2 = 0; a2 < o; a2++)\n      t2 = this._reverse ? o - a2 : a2, r2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay), u2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay);\n    var c2 = s().context.audioContext.createConvolver();\n    c2.buffer = i2, this.init(c2);\n  }, e;\n}(S), MonoFilter: function(t) {\n  function e() {\n    var e2 = this;\n    if (!s().useLegacy) {\n      var n = s().context.audioContext, o = n.createChannelSplitter(), i2 = n.createChannelMerger();\n      return i2.connect(o), (e2 = t.call(this, i2, o) || this)._merger = i2, e2;\n    }\n    e2 = t.call(this, null) || this;\n  }\n  return a(e, t), e.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, t.prototype.destroy.call(this);\n  }, e;\n}(S), StreamFilter: function(t) {\n  function e() {\n    var e2 = this;\n    if (!s().useLegacy) {\n      var n = s().context.audioContext, o = n.createMediaStreamDestination(), i2 = n.createMediaStreamSource(o.stream);\n      return (e2 = t.call(this, o, i2) || this)._stream = o.stream, e2;\n    }\n    e2 = t.call(this, null) || this;\n  }\n  return a(e, t), Object.defineProperty(e.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {\n    this._stream = null, t.prototype.destroy.call(this);\n  }, e;\n}(S), TelephoneFilter: function(t) {\n  function e() {\n    if (!s().useLegacy) {\n      var e2 = s().context.audioContext, n = e2.createBiquadFilter(), o = e2.createBiquadFilter(), i2 = e2.createBiquadFilter(), r2 = e2.createBiquadFilter();\n      return n.type = \"lowpass\", v.setParamValue(n.frequency, 2e3), o.type = \"lowpass\", v.setParamValue(o.frequency, 2e3), i2.type = \"highpass\", v.setParamValue(i2.frequency, 500), r2.type = \"highpass\", v.setParamValue(r2.frequency, 500), n.connect(o), o.connect(i2), i2.connect(r2), t.call(this, n, r2) || this;\n    }\n    t.call(this, null);\n  }\n  return a(e, t), e;\n}(S) });\nvar T = 0;\nvar G = { __proto__: null, playOnce: function(t, e) {\n  var n = \"alias\".concat(T++);\n  return s().add(n, { url: t, preload: true, autoPlay: true, loaded: function(t2) {\n    t2 && (s().remove(n), e && e(t2));\n  }, complete: function() {\n    s().remove(n), e && e(null);\n  } }), n;\n}, get PLAY_ID() {\n  return T;\n}, render: function(t, e) {\n  var n = document.createElement(\"canvas\");\n  e = c({ width: 512, height: 128, fill: \"black\" }, e || {}), n.width = e.width, n.height = e.height;\n  var o = BaseTexture.from(n);\n  if (!(t.media instanceof w))\n    return o;\n  var r2 = t.media, s2 = n.getContext(\"2d\");\n  s2.fillStyle = e.fill;\n  for (var u2 = r2.buffer.getChannelData(0), a2 = Math.ceil(u2.length / e.width), l2 = e.height / 2, p2 = 0; p2 < e.width; p2++) {\n    for (var h2 = 1, f2 = -1, d2 = 0; d2 < a2; d2++) {\n      var _2 = u2[p2 * a2 + d2];\n      _2 < h2 && (h2 = _2), _2 > f2 && (f2 = _2);\n    }\n    s2.fillRect(p2, (1 + h2) * l2, 1, Math.max(1, (f2 - h2) * l2));\n  }\n  return o;\n}, resolveUrl: d, sineTone: function(t, e) {\n  t === void 0 && (t = 200), e === void 0 && (e = 1);\n  var n = A.from({ singleInstance: true });\n  if (!(n.media instanceof w))\n    return n;\n  for (var o = n.media, i2 = n.context.audioContext.createBuffer(1, 48e3 * e, 48e3), r2 = i2.getChannelData(0), s2 = 0; s2 < r2.length; s2++) {\n    var u2 = t * (s2 / i2.sampleRate) * Math.PI;\n    r2[s2] = 2 * Math.sin(u2);\n  }\n  return o.buffer = i2, n.isLoaded = true, n;\n}, validateFormats: h, supported: p$1, extensions: l }, I = function(t) {\n  return r = t, t;\n}(new E());\nLoader.registerPlugin(_);\nfunction finallyConstructor(callback) {\n  var constructor = this.constructor;\n  return this.then(function(value2) {\n    return constructor.resolve(callback()).then(function() {\n      return value2;\n    });\n  }, function(reason) {\n    return constructor.resolve(callback()).then(function() {\n      return constructor.reject(reason);\n    });\n  });\n}\nfunction allSettled(arr) {\n  var P2 = this;\n  return new P2(function(resolve2, reject2) {\n    if (!(arr && typeof arr.length !== \"undefined\")) {\n      return reject2(new TypeError(typeof arr + \" \" + arr + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"));\n    }\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0)\n      return resolve2([]);\n    var remaining = args.length;\n    function res(i3, val) {\n      if (val && (typeof val === \"object\" || typeof val === \"function\")) {\n        var then = val.then;\n        if (typeof then === \"function\") {\n          then.call(val, function(val2) {\n            res(i3, val2);\n          }, function(e) {\n            args[i3] = { status: \"rejected\", reason: e };\n            if (--remaining === 0) {\n              resolve2(args);\n            }\n          });\n          return;\n        }\n      }\n      args[i3] = { status: \"fulfilled\", value: val };\n      if (--remaining === 0) {\n        resolve2(args);\n      }\n    }\n    for (var i2 = 0; i2 < args.length; i2++) {\n      res(i2, args[i2]);\n    }\n  });\n}\nvar setTimeoutFunc = setTimeout;\nfunction isArray$1(x2) {\n  return Boolean(x2 && typeof x2.length !== \"undefined\");\n}\nfunction noop() {\n}\nfunction bind$2(fn2, thisArg) {\n  return function() {\n    fn2.apply(thisArg, arguments);\n  };\n}\nfunction Promise$1(fn2) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof fn2 !== \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0;\n  this._handled = false;\n  this._value = void 0;\n  this._deferreds = [];\n  doResolve(fn2, this);\n}\nfunction handle(self2, deferred) {\n  while (self2._state === 3) {\n    self2 = self2._value;\n  }\n  if (self2._state === 0) {\n    self2._deferreds.push(deferred);\n    return;\n  }\n  self2._handled = true;\n  Promise$1._immediateFn(function() {\n    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self2._state === 1 ? resolve : reject)(deferred.promise, self2._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self2._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\nfunction resolve(self2, newValue) {\n  try {\n    if (newValue === self2)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (newValue && (typeof newValue === \"object\" || typeof newValue === \"function\")) {\n      var then = newValue.then;\n      if (newValue instanceof Promise$1) {\n        self2._state = 3;\n        self2._value = newValue;\n        finale(self2);\n        return;\n      } else if (typeof then === \"function\") {\n        doResolve(bind$2(then, newValue), self2);\n        return;\n      }\n    }\n    self2._state = 1;\n    self2._value = newValue;\n    finale(self2);\n  } catch (e) {\n    reject(self2, e);\n  }\n}\nfunction reject(self2, newValue) {\n  self2._state = 2;\n  self2._value = newValue;\n  finale(self2);\n}\nfunction finale(self2) {\n  if (self2._state === 2 && self2._deferreds.length === 0) {\n    Promise$1._immediateFn(function() {\n      if (!self2._handled) {\n        Promise$1._unhandledRejectionFn(self2._value);\n      }\n    });\n  }\n  for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {\n    handle(self2, self2._deferreds[i2]);\n  }\n  self2._deferreds = null;\n}\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n  this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n  this.promise = promise;\n}\nfunction doResolve(fn2, self2) {\n  var done = false;\n  try {\n    fn2(function(value2) {\n      if (done)\n        return;\n      done = true;\n      resolve(self2, value2);\n    }, function(reason) {\n      if (done)\n        return;\n      done = true;\n      reject(self2, reason);\n    });\n  } catch (ex) {\n    if (done)\n      return;\n    done = true;\n    reject(self2, ex);\n  }\n}\nPromise$1.prototype[\"catch\"] = function(onRejected) {\n  return this.then(null, onRejected);\n};\nPromise$1.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\nPromise$1.prototype[\"finally\"] = finallyConstructor;\nPromise$1.all = function(arr) {\n  return new Promise$1(function(resolve2, reject2) {\n    if (!isArray$1(arr)) {\n      return reject2(new TypeError(\"Promise.all accepts an array\"));\n    }\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0)\n      return resolve2([]);\n    var remaining = args.length;\n    function res(i3, val) {\n      try {\n        if (val && (typeof val === \"object\" || typeof val === \"function\")) {\n          var then = val.then;\n          if (typeof then === \"function\") {\n            then.call(val, function(val2) {\n              res(i3, val2);\n            }, reject2);\n            return;\n          }\n        }\n        args[i3] = val;\n        if (--remaining === 0) {\n          resolve2(args);\n        }\n      } catch (ex) {\n        reject2(ex);\n      }\n    }\n    for (var i2 = 0; i2 < args.length; i2++) {\n      res(i2, args[i2]);\n    }\n  });\n};\nPromise$1.allSettled = allSettled;\nPromise$1.resolve = function(value2) {\n  if (value2 && typeof value2 === \"object\" && value2.constructor === Promise$1) {\n    return value2;\n  }\n  return new Promise$1(function(resolve2) {\n    resolve2(value2);\n  });\n};\nPromise$1.reject = function(value2) {\n  return new Promise$1(function(resolve2, reject2) {\n    reject2(value2);\n  });\n};\nPromise$1.race = function(arr) {\n  return new Promise$1(function(resolve2, reject2) {\n    if (!isArray$1(arr)) {\n      return reject2(new TypeError(\"Promise.race accepts an array\"));\n    }\n    for (var i2 = 0, len = arr.length; i2 < len; i2++) {\n      Promise$1.resolve(arr[i2]).then(resolve2, reject2);\n    }\n  });\n};\nPromise$1._immediateFn = typeof setImmediate === \"function\" && function(fn2) {\n  setImmediate(fn2);\n} || function(fn2) {\n  setTimeoutFunc(fn2, 0);\n};\nPromise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== \"undefined\" && console) {\n    console.warn(\"Possible Unhandled Promise Rejection:\", err);\n  }\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n  if (val === null || val === void 0) {\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  }\n  return Object(val);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    }\n    var test1 = new String(\"abc\");\n    test1[5] = \"de\";\n    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n      return false;\n    }\n    var test2 = {};\n    for (var i2 = 0; i2 < 10; i2++) {\n      test2[\"_\" + String.fromCharCode(i2)] = i2;\n    }\n    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n      return test2[n];\n    });\n    if (order2.join(\"\") !== \"0123456789\") {\n      return false;\n    }\n    var test3 = {};\n    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n      test3[letter] = letter;\n    });\n    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n      return false;\n    }\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n  for (var s2 = 1; s2 < arguments.length; s2++) {\n    from = Object(arguments[s2]);\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n      for (var i2 = 0; i2 < symbols.length; i2++) {\n        if (propIsEnumerable.call(from, symbols[i2])) {\n          to[symbols[i2]] = from[symbols[i2]];\n        }\n      }\n    }\n  }\n  return to;\n};\n/*!\n * @pixi/polyfill - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/polyfill is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nif (typeof globalThis === \"undefined\") {\n  if (typeof self !== \"undefined\") {\n    self.globalThis = self;\n  } else if (typeof __webpack_require__.g !== \"undefined\") {\n    __webpack_require__.g.globalThis = __webpack_require__.g;\n  }\n}\nif (!globalThis.Promise) {\n  globalThis.Promise = Promise$1;\n}\nif (!Object.assign) {\n  Object.assign = objectAssign;\n}\nvar ONE_FRAME_TIME = 16;\nif (!(Date.now && Date.prototype.getTime)) {\n  Date.now = function now2() {\n    return new Date().getTime();\n  };\n}\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var startTime_1 = Date.now();\n  if (!globalThis.performance) {\n    globalThis.performance = {};\n  }\n  globalThis.performance.now = function() {\n    return Date.now() - startTime_1;\n  };\n}\nvar lastTime = Date.now();\nvar vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {\n  var p = vendors[x];\n  globalThis.requestAnimationFrame = globalThis[p + \"RequestAnimationFrame\"];\n  globalThis.cancelAnimationFrame = globalThis[p + \"CancelAnimationFrame\"] || globalThis[p + \"CancelRequestAnimationFrame\"];\n}\nif (!globalThis.requestAnimationFrame) {\n  globalThis.requestAnimationFrame = function(callback) {\n    if (typeof callback !== \"function\") {\n      throw new TypeError(callback + \"is not a function\");\n    }\n    var currentTime = Date.now();\n    var delay = ONE_FRAME_TIME + lastTime - currentTime;\n    if (delay < 0) {\n      delay = 0;\n    }\n    lastTime = currentTime;\n    return globalThis.self.setTimeout(function() {\n      lastTime = Date.now();\n      callback(performance.now());\n    }, delay);\n  };\n}\nif (!globalThis.cancelAnimationFrame) {\n  globalThis.cancelAnimationFrame = function(id) {\n    return clearTimeout(id);\n  };\n}\nif (!Math.sign) {\n  Math.sign = function mathSign(x2) {\n    x2 = Number(x2);\n    if (x2 === 0 || isNaN(x2)) {\n      return x2;\n    }\n    return x2 > 0 ? 1 : -1;\n  };\n}\nif (!Number.isInteger) {\n  Number.isInteger = function numberIsInteger(value2) {\n    return typeof value2 === \"number\" && isFinite(value2) && Math.floor(value2) === value2;\n  };\n}\nif (!globalThis.ArrayBuffer) {\n  globalThis.ArrayBuffer = Array;\n}\nif (!globalThis.Float32Array) {\n  globalThis.Float32Array = Array;\n}\nif (!globalThis.Uint32Array) {\n  globalThis.Uint32Array = Array;\n}\nif (!globalThis.Uint16Array) {\n  globalThis.Uint16Array = Array;\n}\nif (!globalThis.Uint8Array) {\n  globalThis.Uint8Array = Array;\n}\nif (!globalThis.Int32Array) {\n  globalThis.Int32Array = Array;\n}\n/*!\n * @pixi/display - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.SORTABLE_CHILDREN = false;\nvar Bounds = function() {\n  function Bounds2() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.rect = null;\n    this.updateID = -1;\n  }\n  Bounds2.prototype.isEmpty = function() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  };\n  Bounds2.prototype.clear = function() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  };\n  Bounds2.prototype.getRectangle = function(rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return Rectangle.EMPTY;\n    }\n    rect = rect || new Rectangle(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  };\n  Bounds2.prototype.addPoint = function(point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  };\n  Bounds2.prototype.addPointMatrix = function(matrix, point) {\n    var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;\n    var x2 = a2 * point.x + c2 * point.y + tx;\n    var y2 = b2 * point.x + d2 * point.y + ty;\n    this.minX = Math.min(this.minX, x2);\n    this.maxX = Math.max(this.maxX, x2);\n    this.minY = Math.min(this.minY, y2);\n    this.maxY = Math.max(this.maxY, y2);\n  };\n  Bounds2.prototype.addQuad = function(vertices) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x2 = vertices[0];\n    var y2 = vertices[1];\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = vertices[2];\n    y2 = vertices[3];\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = vertices[4];\n    y2 = vertices[5];\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = vertices[6];\n    y2 = vertices[7];\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  };\n  Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {\n    var a2 = matrix.a;\n    var b2 = matrix.b;\n    var c2 = matrix.c;\n    var d2 = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x2 = a2 * x0 + c2 * y0 + tx;\n    var y2 = b2 * x0 + d2 * y0 + ty;\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = a2 * x1 + c2 * y0 + tx;\n    y2 = b2 * x1 + d2 * y0 + ty;\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = a2 * x0 + c2 * y1 + tx;\n    y2 = b2 * x0 + d2 * y1 + ty;\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    x2 = a2 * x1 + c2 * y1 + tx;\n    y2 = b2 * x1 + d2 * y1 + ty;\n    minX = x2 < minX ? x2 : minX;\n    minY = y2 < minY ? y2 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {\n      var x2 = vertexData[i2];\n      var y2 = vertexData[i2 + 1];\n      minX = x2 < minX ? x2 : minX;\n      minY = y2 < minY ? y2 : minY;\n      maxX = x2 > maxX ? x2 : maxX;\n      maxY = y2 > maxY ? y2 : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  };\n  Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {\n    if (padX === void 0) {\n      padX = 0;\n    }\n    if (padY === void 0) {\n      padY = padX;\n    }\n    var a2 = matrix.a;\n    var b2 = matrix.b;\n    var c2 = matrix.c;\n    var d2 = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {\n      var rawX = vertices[i2];\n      var rawY = vertices[i2 + 1];\n      var x2 = a2 * rawX + c2 * rawY + tx;\n      var y2 = d2 * rawY + b2 * rawX + ty;\n      minX = Math.min(minX, x2 - padX);\n      maxX = Math.max(maxX, x2 + padX);\n      minY = Math.min(minY, y2 - padY);\n      maxY = Math.max(maxY, y2 + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  Bounds2.prototype.addBounds = function(bounds) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  };\n  Bounds2.prototype.addBoundsMask = function(bounds, mask) {\n    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  };\n  Bounds2.prototype.addBoundsArea = function(bounds, area2) {\n    var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;\n    var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;\n    var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;\n    var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  Bounds2.prototype.pad = function(paddingX, paddingY) {\n    if (paddingX === void 0) {\n      paddingX = 0;\n    }\n    if (paddingY === void 0) {\n      paddingY = paddingX;\n    }\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  };\n  Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  };\n  return Bounds2;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$p = function(d2, b2) {\n  extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$p(d2, b2);\n};\nfunction __extends$p(d2, b2) {\n  extendStatics$p(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar DisplayObject = function(_super) {\n  __extends$p(DisplayObject2, _super);\n  function DisplayObject2() {\n    var _this = _super.call(this) || this;\n    _this.tempDisplayObjectParent = null;\n    _this.transform = new Transform();\n    _this.alpha = 1;\n    _this.visible = true;\n    _this.renderable = true;\n    _this.cullable = false;\n    _this.cullArea = null;\n    _this.parent = null;\n    _this.worldAlpha = 1;\n    _this._lastSortedIndex = 0;\n    _this._zIndex = 0;\n    _this.filterArea = null;\n    _this.filters = null;\n    _this._enabledFilters = null;\n    _this._bounds = new Bounds();\n    _this._localBounds = null;\n    _this._boundsID = 0;\n    _this._boundsRect = null;\n    _this._localBoundsRect = null;\n    _this._mask = null;\n    _this._maskRefCount = 0;\n    _this._destroyed = false;\n    _this.isSprite = false;\n    _this.isMask = false;\n    return _this;\n  }\n  DisplayObject2.mixin = function(source) {\n    var keys = Object.keys(source);\n    for (var i2 = 0; i2 < keys.length; ++i2) {\n      var propertyName = keys[i2];\n      Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  };\n  Object.defineProperty(DisplayObject2.prototype, \"destroyed\", {\n    get: function() {\n      return this._destroyed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DisplayObject2.prototype._recursivePostUpdateTransform = function() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n  DisplayObject2.prototype.updateTransform = function() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  };\n  DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._bounds.updateID !== this._boundsID) {\n      this.calculateBounds();\n      this._bounds.updateID = this._boundsID;\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new Rectangle();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  };\n  DisplayObject2.prototype.getLocalBounds = function(rect) {\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new Rectangle();\n      }\n      rect = this._localBoundsRect;\n    }\n    if (!this._localBounds) {\n      this._localBounds = new Bounds();\n    }\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    var worldBounds = this._bounds;\n    var worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    this._bounds = worldBounds;\n    this._bounds.updateID += this._boundsID - worldBoundsID;\n    return bounds;\n  };\n  DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {\n    if (skipUpdate === void 0) {\n      skipUpdate = false;\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.apply(position, point);\n  };\n  DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.applyInverse(position, point);\n  };\n  DisplayObject2.prototype.setParent = function(container) {\n    if (!container || !container.addChild) {\n      throw new Error(\"setParent: Argument must be a Container\");\n    }\n    container.addChild(this);\n    return container;\n  };\n  DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (scaleX === void 0) {\n      scaleX = 1;\n    }\n    if (scaleY === void 0) {\n      scaleY = 1;\n    }\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n    if (skewX === void 0) {\n      skewX = 0;\n    }\n    if (skewY === void 0) {\n      skewY = 0;\n    }\n    if (pivotX === void 0) {\n      pivotX = 0;\n    }\n    if (pivotY === void 0) {\n      pivotY = 0;\n    }\n    this.position.x = x2;\n    this.position.y = y2;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n  DisplayObject2.prototype.destroy = function(_options) {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.emit(\"destroyed\");\n    this.removeAllListeners();\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this.mask = null;\n    this.cullArea = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this._destroyed = true;\n  };\n  Object.defineProperty(DisplayObject2.prototype, \"_tempDisplayObjectParent\", {\n    get: function() {\n      if (this.tempDisplayObjectParent === null) {\n        this.tempDisplayObjectParent = new TemporaryDisplayObject();\n      }\n      return this.tempDisplayObjectParent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DisplayObject2.prototype.enableTempParent = function() {\n    var myParent = this.parent;\n    this.parent = this._tempDisplayObjectParent;\n    return myParent;\n  };\n  DisplayObject2.prototype.disableTempParent = function(cacheParent) {\n    this.parent = cacheParent;\n  };\n  Object.defineProperty(DisplayObject2.prototype, \"x\", {\n    get: function() {\n      return this.position.x;\n    },\n    set: function(value2) {\n      this.transform.position.x = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"y\", {\n    get: function() {\n      return this.position.y;\n    },\n    set: function(value2) {\n      this.transform.position.y = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"worldTransform\", {\n    get: function() {\n      return this.transform.worldTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"localTransform\", {\n    get: function() {\n      return this.transform.localTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"position\", {\n    get: function() {\n      return this.transform.position;\n    },\n    set: function(value2) {\n      this.transform.position.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"scale\", {\n    get: function() {\n      return this.transform.scale;\n    },\n    set: function(value2) {\n      this.transform.scale.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"pivot\", {\n    get: function() {\n      return this.transform.pivot;\n    },\n    set: function(value2) {\n      this.transform.pivot.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"skew\", {\n    get: function() {\n      return this.transform.skew;\n    },\n    set: function(value2) {\n      this.transform.skew.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"rotation\", {\n    get: function() {\n      return this.transform.rotation;\n    },\n    set: function(value2) {\n      this.transform.rotation = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"angle\", {\n    get: function() {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function(value2) {\n      this.transform.rotation = value2 * DEG_TO_RAD;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"zIndex\", {\n    get: function() {\n      return this._zIndex;\n    },\n    set: function(value2) {\n      this._zIndex = value2;\n      if (this.parent) {\n        this.parent.sortDirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"worldVisible\", {\n    get: function() {\n      var item = this;\n      do {\n        if (!item.visible) {\n          return false;\n        }\n        item = item.parent;\n      } while (item);\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject2.prototype, \"mask\", {\n    get: function() {\n      return this._mask;\n    },\n    set: function(value2) {\n      if (this._mask === value2) {\n        return;\n      }\n      if (this._mask) {\n        var maskObject = this._mask.maskObject || this._mask;\n        maskObject._maskRefCount--;\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = true;\n          maskObject.isMask = false;\n        }\n      }\n      this._mask = value2;\n      if (this._mask) {\n        var maskObject = this._mask.maskObject || this._mask;\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = false;\n          maskObject.isMask = true;\n        }\n        maskObject._maskRefCount++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DisplayObject2;\n}(EventEmitter$4);\nvar TemporaryDisplayObject = function(_super) {\n  __extends$p(TemporaryDisplayObject2, _super);\n  function TemporaryDisplayObject2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.sortDirty = null;\n    return _this;\n  }\n  return TemporaryDisplayObject2;\n}(DisplayObject);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n/*!\n * @pixi/constants - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$2;\n(function(ENV2) {\n  ENV2[ENV2[\"WEBGL_LEGACY\"] = 0] = \"WEBGL_LEGACY\";\n  ENV2[ENV2[\"WEBGL\"] = 1] = \"WEBGL\";\n  ENV2[ENV2[\"WEBGL2\"] = 2] = \"WEBGL2\";\n})(ENV$2 || (ENV$2 = {}));\nvar RENDERER_TYPE$2;\n(function(RENDERER_TYPE2) {\n  RENDERER_TYPE2[RENDERER_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"CANVAS\"] = 2] = \"CANVAS\";\n})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));\nvar BUFFER_BITS$2;\n(function(BUFFER_BITS2) {\n  BUFFER_BITS2[BUFFER_BITS2[\"COLOR\"] = 16384] = \"COLOR\";\n  BUFFER_BITS2[BUFFER_BITS2[\"DEPTH\"] = 256] = \"DEPTH\";\n  BUFFER_BITS2[BUFFER_BITS2[\"STENCIL\"] = 1024] = \"STENCIL\";\n})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));\nvar BLEND_MODES$2;\n(function(BLEND_MODES2) {\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL\"] = 0] = \"NORMAL\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD\"] = 1] = \"ADD\";\n  BLEND_MODES2[BLEND_MODES2[\"MULTIPLY\"] = 2] = \"MULTIPLY\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN\"] = 3] = \"SCREEN\";\n  BLEND_MODES2[BLEND_MODES2[\"OVERLAY\"] = 4] = \"OVERLAY\";\n  BLEND_MODES2[BLEND_MODES2[\"DARKEN\"] = 5] = \"DARKEN\";\n  BLEND_MODES2[BLEND_MODES2[\"LIGHTEN\"] = 6] = \"LIGHTEN\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_DODGE\"] = 7] = \"COLOR_DODGE\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_BURN\"] = 8] = \"COLOR_BURN\";\n  BLEND_MODES2[BLEND_MODES2[\"HARD_LIGHT\"] = 9] = \"HARD_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"SOFT_LIGHT\"] = 10] = \"SOFT_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"DIFFERENCE\"] = 11] = \"DIFFERENCE\";\n  BLEND_MODES2[BLEND_MODES2[\"EXCLUSION\"] = 12] = \"EXCLUSION\";\n  BLEND_MODES2[BLEND_MODES2[\"HUE\"] = 13] = \"HUE\";\n  BLEND_MODES2[BLEND_MODES2[\"SATURATION\"] = 14] = \"SATURATION\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR\"] = 15] = \"COLOR\";\n  BLEND_MODES2[BLEND_MODES2[\"LUMINOSITY\"] = 16] = \"LUMINOSITY\";\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL_NPM\"] = 17] = \"NORMAL_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD_NPM\"] = 18] = \"ADD_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN_NPM\"] = 19] = \"SCREEN_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"NONE\"] = 20] = \"NONE\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OVER\"] = 0] = \"SRC_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_IN\"] = 21] = \"SRC_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OUT\"] = 22] = \"SRC_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_ATOP\"] = 23] = \"SRC_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OVER\"] = 24] = \"DST_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_IN\"] = 25] = \"DST_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OUT\"] = 26] = \"DST_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_ATOP\"] = 27] = \"DST_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"ERASE\"] = 26] = \"ERASE\";\n  BLEND_MODES2[BLEND_MODES2[\"SUBTRACT\"] = 28] = \"SUBTRACT\";\n  BLEND_MODES2[BLEND_MODES2[\"XOR\"] = 29] = \"XOR\";\n})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));\nvar DRAW_MODES$2;\n(function(DRAW_MODES2) {\n  DRAW_MODES2[DRAW_MODES2[\"POINTS\"] = 0] = \"POINTS\";\n  DRAW_MODES2[DRAW_MODES2[\"LINES\"] = 1] = \"LINES\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));\nvar FORMATS$2;\n(function(FORMATS2) {\n  FORMATS2[FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  FORMATS2[FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  FORMATS2[FORMATS2[\"RG\"] = 33319] = \"RG\";\n  FORMATS2[FORMATS2[\"RED\"] = 6403] = \"RED\";\n  FORMATS2[FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  FORMATS2[FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  FORMATS2[FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  FORMATS2[FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  FORMATS2[FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  FORMATS2[FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  FORMATS2[FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  FORMATS2[FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  FORMATS2[FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$2 || (FORMATS$2 = {}));\nvar TARGETS$2;\n(function(TARGETS2) {\n  TARGETS2[TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  TARGETS2[TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$2 || (TARGETS$2 = {}));\nvar TYPES$2;\n(function(TYPES2) {\n  TYPES2[TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  TYPES2[TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  TYPES2[TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  TYPES2[TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  TYPES2[TYPES2[\"INT\"] = 5124] = \"INT\";\n  TYPES2[TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  TYPES2[TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  TYPES2[TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n})(TYPES$2 || (TYPES$2 = {}));\nvar SAMPLER_TYPES$2;\n(function(SAMPLER_TYPES2) {\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"FLOAT\"] = 0] = \"FLOAT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"INT\"] = 1] = \"INT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"UINT\"] = 2] = \"UINT\";\n})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));\nvar SCALE_MODES$2;\n(function(SCALE_MODES2) {\n  SCALE_MODES2[SCALE_MODES2[\"NEAREST\"] = 0] = \"NEAREST\";\n  SCALE_MODES2[SCALE_MODES2[\"LINEAR\"] = 1] = \"LINEAR\";\n})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));\nvar WRAP_MODES$2;\n(function(WRAP_MODES2) {\n  WRAP_MODES2[WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  WRAP_MODES2[WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  WRAP_MODES2[WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));\nvar MIPMAP_MODES$2;\n(function(MIPMAP_MODES2) {\n  MIPMAP_MODES2[MIPMAP_MODES2[\"OFF\"] = 0] = \"OFF\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"POW2\"] = 1] = \"POW2\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON\"] = 2] = \"ON\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON_MANUAL\"] = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));\nvar ALPHA_MODES$2;\n(function(ALPHA_MODES2) {\n  ALPHA_MODES2[ALPHA_MODES2[\"NPM\"] = 0] = \"NPM\";\n  ALPHA_MODES2[ALPHA_MODES2[\"UNPACK\"] = 1] = \"UNPACK\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PMA\"] = 2] = \"PMA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"NO_PREMULTIPLIED_ALPHA\"] = 0] = \"NO_PREMULTIPLIED_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ON_UPLOAD\"] = 1] = \"PREMULTIPLY_ON_UPLOAD\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ALPHA\"] = 2] = \"PREMULTIPLY_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLIED_ALPHA\"] = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));\nvar CLEAR_MODES$2;\n(function(CLEAR_MODES2) {\n  CLEAR_MODES2[CLEAR_MODES2[\"NO\"] = 0] = \"NO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"YES\"] = 1] = \"YES\";\n  CLEAR_MODES2[CLEAR_MODES2[\"AUTO\"] = 2] = \"AUTO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLEND\"] = 0] = \"BLEND\";\n  CLEAR_MODES2[CLEAR_MODES2[\"CLEAR\"] = 1] = \"CLEAR\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLIT\"] = 2] = \"BLIT\";\n})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));\nvar GC_MODES$2;\n(function(GC_MODES2) {\n  GC_MODES2[GC_MODES2[\"AUTO\"] = 0] = \"AUTO\";\n  GC_MODES2[GC_MODES2[\"MANUAL\"] = 1] = \"MANUAL\";\n})(GC_MODES$2 || (GC_MODES$2 = {}));\nvar PRECISION$2;\n(function(PRECISION2) {\n  PRECISION2[\"LOW\"] = \"lowp\";\n  PRECISION2[\"MEDIUM\"] = \"mediump\";\n  PRECISION2[\"HIGH\"] = \"highp\";\n})(PRECISION$2 || (PRECISION$2 = {}));\nvar MASK_TYPES$2;\n(function(MASK_TYPES2) {\n  MASK_TYPES2[MASK_TYPES2[\"NONE\"] = 0] = \"NONE\";\n  MASK_TYPES2[MASK_TYPES2[\"SCISSOR\"] = 1] = \"SCISSOR\";\n  MASK_TYPES2[MASK_TYPES2[\"STENCIL\"] = 2] = \"STENCIL\";\n  MASK_TYPES2[MASK_TYPES2[\"SPRITE\"] = 3] = \"SPRITE\";\n})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));\nvar MSAA_QUALITY$2;\n(function(MSAA_QUALITY2) {\n  MSAA_QUALITY2[MSAA_QUALITY2[\"NONE\"] = 0] = \"NONE\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"LOW\"] = 2] = \"LOW\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"MEDIUM\"] = 4] = \"MEDIUM\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"HIGH\"] = 8] = \"HIGH\";\n})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));\nvar BUFFER_TYPE$2;\n(function(BUFFER_TYPE2) {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));\nfunction sortChildren(a2, b2) {\n  if (a2.zIndex === b2.zIndex) {\n    return a2._lastSortedIndex - b2._lastSortedIndex;\n  }\n  return a2.zIndex - b2.zIndex;\n}\nvar Container = function(_super) {\n  __extends$p(Container2, _super);\n  function Container2() {\n    var _this = _super.call(this) || this;\n    _this.children = [];\n    _this.sortableChildren = settings.SORTABLE_CHILDREN;\n    _this.sortDirty = false;\n    return _this;\n  }\n  Container2.prototype.onChildrenChange = function(_length) {\n  };\n  Container2.prototype.addChild = function() {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    if (children.length > 1) {\n      for (var i2 = 0; i2 < children.length; i2++) {\n        this.addChild(children[i2]);\n      }\n    } else {\n      var child = children[0];\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      child.transform._parentID = -1;\n      this.children.push(child);\n      this._boundsID++;\n      this.onChildrenChange(this.children.length - 1);\n      this.emit(\"childAdded\", child, this, this.children.length - 1);\n      child.emit(\"added\", this);\n    }\n    return children[0];\n  };\n  Container2.prototype.addChildAt = function(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + \"addChildAt: The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.sortDirty = true;\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit(\"added\", this);\n    this.emit(\"childAdded\", child, this, index);\n    return child;\n  };\n  Container2.prototype.swapChildren = function(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  Container2.prototype.getChildIndex = function(child) {\n    var index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n    }\n    return index;\n  };\n  Container2.prototype.setChildIndex = function(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    var currentIndex = this.getChildIndex(child);\n    removeItems(this.children, currentIndex, 1);\n    this.children.splice(index, 0, child);\n    this.onChildrenChange(index);\n  };\n  Container2.prototype.getChildAt = function(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"getChildAt: Index (\" + index + \") does not exist.\");\n    }\n    return this.children[index];\n  };\n  Container2.prototype.removeChild = function() {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    if (children.length > 1) {\n      for (var i2 = 0; i2 < children.length; i2++) {\n        this.removeChild(children[i2]);\n      }\n    } else {\n      var child = children[0];\n      var index = this.children.indexOf(child);\n      if (index === -1) {\n        return null;\n      }\n      child.parent = null;\n      child.transform._parentID = -1;\n      removeItems(this.children, index, 1);\n      this._boundsID++;\n      this.onChildrenChange(index);\n      child.emit(\"removed\", this);\n      this.emit(\"childRemoved\", child, this, index);\n    }\n    return children[0];\n  };\n  Container2.prototype.removeChildAt = function(index) {\n    var child = this.getChildAt(index);\n    child.parent = null;\n    child.transform._parentID = -1;\n    removeItems(this.children, index, 1);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit(\"removed\", this);\n    this.emit(\"childRemoved\", child, this, index);\n    return child;\n  };\n  Container2.prototype.removeChildren = function(beginIndex, endIndex) {\n    if (beginIndex === void 0) {\n      beginIndex = 0;\n    }\n    if (endIndex === void 0) {\n      endIndex = this.children.length;\n    }\n    var begin = beginIndex;\n    var end2 = endIndex;\n    var range = end2 - begin;\n    var removed;\n    if (range > 0 && range <= end2) {\n      removed = this.children.splice(begin, range);\n      for (var i2 = 0; i2 < removed.length; ++i2) {\n        removed[i2].parent = null;\n        if (removed[i2].transform) {\n          removed[i2].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (var i2 = 0; i2 < removed.length; ++i2) {\n        removed[i2].emit(\"removed\", this);\n        this.emit(\"childRemoved\", removed[i2], this, i2);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  };\n  Container2.prototype.sortChildren = function() {\n    var sortRequired = false;\n    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n      var child = this.children[i2];\n      child._lastSortedIndex = i2;\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n    this.sortDirty = false;\n  };\n  Container2.prototype.updateTransform = function() {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n      var child = this.children[i2];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  Container2.prototype.calculateBounds = function() {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (var i2 = 0; i2 < this.children.length; i2++) {\n      var child = this.children[i2];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n      if (child._mask) {\n        var maskObject = child._mask.maskObject || child._mask;\n        maskObject.calculateBounds();\n        this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._bounds.updateID = this._boundsID;\n  };\n  Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {\n    if (skipChildrenUpdate === void 0) {\n      skipChildrenUpdate = false;\n    }\n    var result = _super.prototype.getLocalBounds.call(this, rect);\n    if (!skipChildrenUpdate) {\n      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n        var child = this.children[i2];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n    return result;\n  };\n  Container2.prototype._calculateBounds = function() {\n  };\n  Container2.prototype._renderWithCulling = function(renderer) {\n    var sourceFrame = renderer.renderTexture.sourceFrame;\n    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {\n      return;\n    }\n    var bounds;\n    var transform;\n    if (this.cullArea) {\n      bounds = this.cullArea;\n      transform = this.worldTransform;\n    } else if (this._render !== Container2.prototype._render) {\n      bounds = this.getBounds(true);\n    }\n    if (bounds && sourceFrame.intersects(bounds, transform)) {\n      this._render(renderer);\n    } else if (this.cullArea) {\n      return;\n    }\n    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n      var child = this.children[i2];\n      var childCullable = child.cullable;\n      child.cullable = childCullable || !this.cullArea;\n      child.render(renderer);\n      child.cullable = childCullable;\n    }\n  };\n  Container2.prototype.render = function(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvanced(renderer);\n    } else if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n        this.children[i2].render(renderer);\n      }\n    }\n  };\n  Container2.prototype.renderAdvanced = function(renderer) {\n    var filters = this.filters;\n    var mask = this._mask;\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (var i2 = 0; i2 < filters.length; i2++) {\n        if (filters[i2].enabled) {\n          this._enabledFilters.push(filters[i2]);\n        }\n      }\n    }\n    var flush = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES$2.NONE));\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.push(this, this._enabledFilters);\n    }\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    }\n    if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {\n        this.children[i2].render(renderer);\n      }\n    }\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (mask) {\n      renderer.mask.pop(this);\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.pop();\n    }\n  };\n  Container2.prototype._render = function(_renderer) {\n  };\n  Container2.prototype.destroy = function(options) {\n    _super.prototype.destroy.call(this);\n    this.sortDirty = false;\n    var destroyChildren = typeof options === \"boolean\" ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (var i2 = 0; i2 < oldChildren.length; ++i2) {\n        oldChildren[i2].destroy(options);\n      }\n    }\n  };\n  Object.defineProperty(Container2.prototype, \"width\", {\n    get: function() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(value2) {\n      var width = this.getLocalBounds().width;\n      if (width !== 0) {\n        this.scale.x = value2 / width;\n      } else {\n        this.scale.x = 1;\n      }\n      this._width = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Container2.prototype, \"height\", {\n    get: function() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(value2) {\n      var height = this.getLocalBounds().height;\n      if (height !== 0) {\n        this.scale.y = value2 / height;\n      } else {\n        this.scale.y = 1;\n      }\n      this._height = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Container2;\n}(DisplayObject);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n/*!\n * @pixi/accessibility - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/accessibility is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar accessibleTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  accessibleType: \"button\",\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: true,\n  renderId: -1\n};\nDisplayObject.mixin(accessibleTarget);\nvar KEY_CODE_TAB = 9;\nvar DIV_TOUCH_SIZE = 100;\nvar DIV_TOUCH_POS_X = 0;\nvar DIV_TOUCH_POS_Y = 0;\nvar DIV_TOUCH_ZINDEX = 2;\nvar DIV_HOOK_SIZE = 1;\nvar DIV_HOOK_POS_X = -1e3;\nvar DIV_HOOK_POS_Y = -1e3;\nvar DIV_HOOK_ZINDEX = 2;\nvar AccessibilityManager = function() {\n  function AccessibilityManager2(renderer) {\n    this.debug = false;\n    this._isActive = false;\n    this._isMobileAccessibility = false;\n    this.pool = [];\n    this.renderId = 0;\n    this.children = [];\n    this.androidUpdateCount = 0;\n    this.androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (isMobile.tablet || isMobile.phone) {\n      this.createTouchHook();\n    }\n    var div = document.createElement(\"div\");\n    div.style.width = DIV_TOUCH_SIZE + \"px\";\n    div.style.height = DIV_TOUCH_SIZE + \"px\";\n    div.style.position = \"absolute\";\n    div.style.top = DIV_TOUCH_POS_X + \"px\";\n    div.style.left = DIV_TOUCH_POS_Y + \"px\";\n    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n    this.div = div;\n    this.renderer = renderer;\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onMouseMove = this._onMouseMove.bind(this);\n    globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n  }\n  Object.defineProperty(AccessibilityManager2.prototype, \"isActive\", {\n    get: function() {\n      return this._isActive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AccessibilityManager2.prototype, \"isMobileAccessibility\", {\n    get: function() {\n      return this._isMobileAccessibility;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  AccessibilityManager2.prototype.createTouchHook = function() {\n    var _this = this;\n    var hookDiv = document.createElement(\"button\");\n    hookDiv.style.width = DIV_HOOK_SIZE + \"px\";\n    hookDiv.style.height = DIV_HOOK_SIZE + \"px\";\n    hookDiv.style.position = \"absolute\";\n    hookDiv.style.top = DIV_HOOK_POS_X + \"px\";\n    hookDiv.style.left = DIV_HOOK_POS_Y + \"px\";\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = \"#FF0000\";\n    hookDiv.title = \"select to enable accessibility for this content\";\n    hookDiv.addEventListener(\"focus\", function() {\n      _this._isMobileAccessibility = true;\n      _this.activate();\n      _this.destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  };\n  AccessibilityManager2.prototype.destroyTouchHook = function() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  };\n  AccessibilityManager2.prototype.activate = function() {\n    var _a3;\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, true);\n    globalThis.removeEventListener(\"keydown\", this._onKeyDown, false);\n    this.renderer.on(\"postrender\", this.update, this);\n    (_a3 = this.renderer.view.parentNode) === null || _a3 === void 0 ? void 0 : _a3.appendChild(this.div);\n  };\n  AccessibilityManager2.prototype.deactivate = function() {\n    var _a3;\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\n    globalThis.addEventListener(\"keydown\", this._onKeyDown, false);\n    this.renderer.off(\"postrender\", this.update);\n    (_a3 = this.div.parentNode) === null || _a3 === void 0 ? void 0 : _a3.removeChild(this.div);\n  };\n  AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {\n    if (!displayObject.visible || !displayObject.accessibleChildren) {\n      return;\n    }\n    if (displayObject.accessible && displayObject.interactive) {\n      if (!displayObject._accessibleActive) {\n        this.addChild(displayObject);\n      }\n      displayObject.renderId = this.renderId;\n    }\n    var children = displayObject.children;\n    if (children) {\n      for (var i2 = 0; i2 < children.length; i2++) {\n        this.updateAccessibleObjects(children[i2]);\n      }\n    }\n  };\n  AccessibilityManager2.prototype.update = function() {\n    var now2 = performance.now();\n    if (isMobile.android.device && now2 < this.androidUpdateCount) {\n      return;\n    }\n    this.androidUpdateCount = now2 + this.androidUpdateFrequency;\n    if (!this.renderer.renderingToScreen) {\n      return;\n    }\n    if (this.renderer._lastObjectRendered) {\n      this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n    }\n    var _a3 = this.renderer.view.getBoundingClientRect(), left2 = _a3.left, top2 = _a3.top, width = _a3.width, height = _a3.height;\n    var _b3 = this.renderer, viewWidth = _b3.width, viewHeight = _b3.height, resolution = _b3.resolution;\n    var sx = width / viewWidth * resolution;\n    var sy = height / viewHeight * resolution;\n    var div = this.div;\n    div.style.left = left2 + \"px\";\n    div.style.top = top2 + \"px\";\n    div.style.width = viewWidth + \"px\";\n    div.style.height = viewHeight + \"px\";\n    for (var i2 = 0; i2 < this.children.length; i2++) {\n      var child = this.children[i2];\n      if (child.renderId !== this.renderId) {\n        child._accessibleActive = false;\n        removeItems(this.children, i2, 1);\n        this.div.removeChild(child._accessibleDiv);\n        this.pool.push(child._accessibleDiv);\n        child._accessibleDiv = null;\n        i2--;\n      } else {\n        div = child._accessibleDiv;\n        var hitArea = child.hitArea;\n        var wt = child.worldTransform;\n        if (child.hitArea) {\n          div.style.left = (wt.tx + hitArea.x * wt.a) * sx + \"px\";\n          div.style.top = (wt.ty + hitArea.y * wt.d) * sy + \"px\";\n          div.style.width = hitArea.width * wt.a * sx + \"px\";\n          div.style.height = hitArea.height * wt.d * sy + \"px\";\n        } else {\n          hitArea = child.getBounds();\n          this.capHitArea(hitArea);\n          div.style.left = hitArea.x * sx + \"px\";\n          div.style.top = hitArea.y * sy + \"px\";\n          div.style.width = hitArea.width * sx + \"px\";\n          div.style.height = hitArea.height * sy + \"px\";\n          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {\n            div.title = child.accessibleTitle;\n          }\n          if (div.getAttribute(\"aria-label\") !== child.accessibleHint && child.accessibleHint !== null) {\n            div.setAttribute(\"aria-label\", child.accessibleHint);\n          }\n        }\n        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {\n          div.title = child.accessibleTitle;\n          div.tabIndex = child.tabIndex;\n          if (this.debug) {\n            this.updateDebugHTML(div);\n          }\n        }\n      }\n    }\n    this.renderId++;\n  };\n  AccessibilityManager2.prototype.updateDebugHTML = function(div) {\n    div.innerHTML = \"type: \" + div.type + \"</br> title : \" + div.title + \"</br> tabIndex: \" + div.tabIndex;\n  };\n  AccessibilityManager2.prototype.capHitArea = function(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    var _a3 = this.renderer, viewWidth = _a3.width, viewHeight = _a3.height;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  };\n  AccessibilityManager2.prototype.addChild = function(displayObject) {\n    var div = this.pool.pop();\n    if (!div) {\n      div = document.createElement(\"button\");\n      div.style.width = DIV_TOUCH_SIZE + \"px\";\n      div.style.height = DIV_TOUCH_SIZE + \"px\";\n      div.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\";\n      div.style.position = \"absolute\";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = \"none\";\n      if (navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n        div.setAttribute(\"aria-live\", \"off\");\n      } else {\n        div.setAttribute(\"aria-live\", \"polite\");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute(\"aria-relevant\", \"additions\");\n      } else {\n        div.setAttribute(\"aria-relevant\", \"text\");\n      }\n      div.addEventListener(\"click\", this._onClick.bind(this));\n      div.addEventListener(\"focus\", this._onFocus.bind(this));\n      div.addEventListener(\"focusout\", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = displayObject.accessiblePointerEvents;\n    div.type = displayObject.accessibleType;\n    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {\n      div.title = displayObject.accessibleTitle;\n    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {\n      div.title = \"displayObject \" + displayObject.tabIndex;\n    }\n    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {\n      div.setAttribute(\"aria-label\", displayObject.accessibleHint);\n    }\n    if (this.debug) {\n      this.updateDebugHTML(div);\n    }\n    displayObject._accessibleActive = true;\n    displayObject._accessibleDiv = div;\n    div.displayObject = displayObject;\n    this.children.push(displayObject);\n    this.div.appendChild(displayObject._accessibleDiv);\n    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;\n  };\n  AccessibilityManager2.prototype._onClick = function(e) {\n    var interactionManager = this.renderer.plugins.interaction;\n    var displayObject = e.target.displayObject;\n    var eventData = interactionManager.eventData;\n    interactionManager.dispatchEvent(displayObject, \"click\", eventData);\n    interactionManager.dispatchEvent(displayObject, \"pointertap\", eventData);\n    interactionManager.dispatchEvent(displayObject, \"tap\", eventData);\n  };\n  AccessibilityManager2.prototype._onFocus = function(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"assertive\");\n    }\n    var interactionManager = this.renderer.plugins.interaction;\n    var displayObject = e.target.displayObject;\n    var eventData = interactionManager.eventData;\n    interactionManager.dispatchEvent(displayObject, \"mouseover\", eventData);\n  };\n  AccessibilityManager2.prototype._onFocusOut = function(e) {\n    if (!e.target.getAttribute(\"aria-live\")) {\n      e.target.setAttribute(\"aria-live\", \"polite\");\n    }\n    var interactionManager = this.renderer.plugins.interaction;\n    var displayObject = e.target.displayObject;\n    var eventData = interactionManager.eventData;\n    interactionManager.dispatchEvent(displayObject, \"mouseout\", eventData);\n  };\n  AccessibilityManager2.prototype._onKeyDown = function(e) {\n    if (e.keyCode !== KEY_CODE_TAB) {\n      return;\n    }\n    this.activate();\n  };\n  AccessibilityManager2.prototype._onMouseMove = function(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this.deactivate();\n  };\n  AccessibilityManager2.prototype.destroy = function() {\n    this.destroyTouchHook();\n    this.div = null;\n    globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, true);\n    globalThis.removeEventListener(\"keydown\", this._onKeyDown);\n    this.pool = null;\n    this.children = null;\n    this.renderer = null;\n  };\n  return AccessibilityManager2;\n}();\n/*!\n * @pixi/interaction - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar InteractionData = function() {\n  function InteractionData2() {\n    this.pressure = 0;\n    this.rotationAngle = 0;\n    this.twist = 0;\n    this.tangentialPressure = 0;\n    this.global = new Point();\n    this.target = null;\n    this.originalEvent = null;\n    this.identifier = null;\n    this.isPrimary = false;\n    this.button = 0;\n    this.buttons = 0;\n    this.width = 0;\n    this.height = 0;\n    this.tiltX = 0;\n    this.tiltY = 0;\n    this.pointerType = null;\n    this.pressure = 0;\n    this.rotationAngle = 0;\n    this.twist = 0;\n    this.tangentialPressure = 0;\n  }\n  Object.defineProperty(InteractionData2.prototype, \"pointerId\", {\n    get: function() {\n      return this.identifier;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n  };\n  InteractionData2.prototype.copyEvent = function(event) {\n    if (\"isPrimary\" in event && event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = \"button\" in event && event.button;\n    var buttons = \"buttons\" in event && event.buttons;\n    this.buttons = Number.isInteger(buttons) ? buttons : \"which\" in event && event.which;\n    this.width = \"width\" in event && event.width;\n    this.height = \"height\" in event && event.height;\n    this.tiltX = \"tiltX\" in event && event.tiltX;\n    this.tiltY = \"tiltY\" in event && event.tiltY;\n    this.pointerType = \"pointerType\" in event && event.pointerType;\n    this.pressure = \"pressure\" in event && event.pressure;\n    this.rotationAngle = \"rotationAngle\" in event && event.rotationAngle;\n    this.twist = \"twist\" in event && event.twist || 0;\n    this.tangentialPressure = \"tangentialPressure\" in event && event.tangentialPressure || 0;\n  };\n  InteractionData2.prototype.reset = function() {\n    this.isPrimary = false;\n  };\n  return InteractionData2;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$o = function(d2, b2) {\n  extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$o(d2, b2);\n};\nfunction __extends$o(d2, b2) {\n  extendStatics$o(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar InteractionEvent = function() {\n  function InteractionEvent2() {\n    this.stopped = false;\n    this.stopsPropagatingAt = null;\n    this.stopPropagationHint = false;\n    this.target = null;\n    this.currentTarget = null;\n    this.type = null;\n    this.data = null;\n  }\n  InteractionEvent2.prototype.stopPropagation = function() {\n    this.stopped = true;\n    this.stopPropagationHint = true;\n    this.stopsPropagatingAt = this.currentTarget;\n  };\n  InteractionEvent2.prototype.reset = function() {\n    this.stopped = false;\n    this.stopsPropagatingAt = null;\n    this.stopPropagationHint = false;\n    this.currentTarget = null;\n    this.target = null;\n  };\n  return InteractionEvent2;\n}();\nvar InteractionTrackingData = function() {\n  function InteractionTrackingData2(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData2.FLAGS.NONE;\n  }\n  InteractionTrackingData2.prototype._doSet = function(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & ~flag;\n    }\n  };\n  Object.defineProperty(InteractionTrackingData2.prototype, \"pointerId\", {\n    get: function() {\n      return this._pointerId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData2.prototype, \"flags\", {\n    get: function() {\n      return this._flags;\n    },\n    set: function(flags) {\n      this._flags = flags;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData2.prototype, \"none\", {\n    get: function() {\n      return this._flags === InteractionTrackingData2.FLAGS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData2.prototype, \"over\", {\n    get: function() {\n      return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;\n    },\n    set: function(yn) {\n      this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData2.prototype, \"rightDown\", {\n    get: function() {\n      return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;\n    },\n    set: function(yn) {\n      this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData2.prototype, \"leftDown\", {\n    get: function() {\n      return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;\n    },\n    set: function(yn) {\n      this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InteractionTrackingData2.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  });\n  return InteractionTrackingData2;\n}();\nvar TreeSearch = function() {\n  function TreeSearch2() {\n    this._tempPoint = new Point();\n  }\n  TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n    var point = interactionEvent.data.global;\n    interactive = displayObject.interactive || interactive;\n    var hit = false;\n    var interactiveParent = interactive;\n    var hitTestChildren = true;\n    if (displayObject.hitArea) {\n      if (hitTest) {\n        displayObject.worldTransform.applyInverse(point, this._tempPoint);\n        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {\n          hitTest = false;\n          hitTestChildren = false;\n        } else {\n          hit = true;\n        }\n      }\n      interactiveParent = false;\n    } else if (displayObject._mask) {\n      if (hitTest) {\n        if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {\n          hitTest = false;\n        }\n      }\n    }\n    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {\n      var children = displayObject.children;\n      for (var i2 = children.length - 1; i2 >= 0; i2--) {\n        var child = children[i2];\n        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n        if (childHit) {\n          if (!child.parent) {\n            continue;\n          }\n          interactiveParent = false;\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n    if (interactive) {\n      if (hitTest && !interactionEvent.target) {\n        if (!displayObject.hitArea && displayObject.containsPoint) {\n          if (displayObject.containsPoint(point)) {\n            hit = true;\n          }\n        }\n      }\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.target = displayObject;\n        }\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n    return hit;\n  };\n  TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {\n    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n  };\n  return TreeSearch2;\n}();\nvar interactiveTarget = {\n  interactive: false,\n  interactiveChildren: true,\n  hitArea: null,\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(value2) {\n    if (value2) {\n      this.cursor = \"pointer\";\n    } else if (this.cursor === \"pointer\") {\n      this.cursor = null;\n    }\n  },\n  cursor: null,\n  get trackedPointers() {\n    if (this._trackedPointers === void 0) {\n      this._trackedPointers = {};\n    }\n    return this._trackedPointers;\n  },\n  _trackedPointers: void 0\n};\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1;\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\nvar InteractionManager = function(_super) {\n  __extends$o(InteractionManager2, _super);\n  function InteractionManager2(renderer, options) {\n    var _this = _super.call(this) || this;\n    options = options || {};\n    _this.renderer = renderer;\n    _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID;\n    _this.mouse.global.set(-999999);\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n    _this.interactionDataPool = [];\n    _this.eventData = new InteractionEvent();\n    _this.interactionDOMElement = null;\n    _this.moveWhenInside = false;\n    _this.eventsAdded = false;\n    _this.tickerAdded = false;\n    _this.mouseOverRenderer = !(\"PointerEvent\" in globalThis);\n    _this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    _this.supportsPointerEvents = !!globalThis.PointerEvent;\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    _this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    _this.currentCursorMode = null;\n    _this.cursor = null;\n    _this.resolution = 1;\n    _this.delayedEvents = [];\n    _this.search = new TreeSearch();\n    _this._tempDisplayObject = new TemporaryDisplayObject();\n    _this._eventListenerOptions = { capture: true, passive: false };\n    _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;\n    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);\n    return _this;\n  }\n  Object.defineProperty(InteractionManager2.prototype, \"useSystemTicker\", {\n    get: function() {\n      return this._useSystemTicker;\n    },\n    set: function(useSystemTicker) {\n      this._useSystemTicker = useSystemTicker;\n      if (useSystemTicker) {\n        this.addTickerListener();\n      } else {\n        this.removeTickerListener();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionManager2.prototype, \"lastObjectRendered\", {\n    get: function() {\n      return this.renderer._lastObjectRendered || this._tempDisplayObject;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InteractionManager2.prototype.hitTest = function(globalPoint, root) {\n    hitTestEvent.target = null;\n    hitTestEvent.data.global = globalPoint;\n    if (!root) {\n      root = this.lastObjectRendered;\n    }\n    this.processInteractive(hitTestEvent, root, null, true);\n    return hitTestEvent.target;\n  };\n  InteractionManager2.prototype.setTargetElement = function(element, resolution) {\n    if (resolution === void 0) {\n      resolution = 1;\n    }\n    this.removeTickerListener();\n    this.removeEvents();\n    this.interactionDOMElement = element;\n    this.resolution = resolution;\n    this.addEvents();\n    this.addTickerListener();\n  };\n  InteractionManager2.prototype.addTickerListener = function() {\n    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {\n      return;\n    }\n    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n    this.tickerAdded = true;\n  };\n  InteractionManager2.prototype.removeTickerListener = function() {\n    if (!this.tickerAdded) {\n      return;\n    }\n    Ticker.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  };\n  InteractionManager2.prototype.addEvents = function() {\n    if (this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n    var style = this.interactionDOMElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = \"none\";\n      style.msTouchAction = \"none\";\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = \"none\";\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions);\n      globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions);\n      globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions);\n    } else {\n      globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions);\n      globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions);\n    }\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions);\n    }\n    this.eventsAdded = true;\n  };\n  InteractionManager2.prototype.removeEvents = function() {\n    if (!this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n    var style = this.interactionDOMElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = \"\";\n      style.msTouchAction = \"\";\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = \"\";\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions);\n      globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions);\n      globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions);\n    } else {\n      globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions);\n      globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions);\n    }\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions);\n    }\n    this.interactionDOMElement = null;\n    this.eventsAdded = false;\n  };\n  InteractionManager2.prototype.tickerUpdate = function(deltaTime) {\n    this._deltaTime += deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this.update();\n  };\n  InteractionManager2.prototype.update = function() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    this.cursor = null;\n    for (var k in this.activeInteractionData) {\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        var interactionData = this.activeInteractionData[k];\n        if (interactionData.originalEvent && interactionData.pointerType !== \"touch\") {\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);\n        }\n      }\n    }\n    this.setCursorMode(this.cursor);\n  };\n  InteractionManager2.prototype.setCursorMode = function(mode) {\n    mode = mode || \"default\";\n    var applyStyles2 = true;\n    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {\n      applyStyles2 = false;\n    }\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    var style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case \"string\":\n          if (applyStyles2) {\n            this.interactionDOMElement.style.cursor = style;\n          }\n          break;\n        case \"function\":\n          style(mode);\n          break;\n        case \"object\":\n          if (applyStyles2) {\n            Object.assign(this.interactionDOMElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles2 && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  };\n  InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {\n    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n      displayObject.emit(eventString, eventData);\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  };\n  InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {\n    this.delayedEvents.push({ displayObject, eventString, eventData });\n  };\n  InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {\n    var rect;\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: this.interactionDOMElement.width,\n        height: this.interactionDOMElement.height,\n        left: 0,\n        top: 0\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n    var resolutionMultiplier = 1 / this.resolution;\n    point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;\n  };\n  InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {\n    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n    var delayedEvents = this.delayedEvents;\n    if (!delayedEvents.length) {\n      return hit;\n    }\n    interactionEvent.stopPropagationHint = false;\n    var delayedLen = delayedEvents.length;\n    this.delayedEvents = [];\n    for (var i2 = 0; i2 < delayedLen; i2++) {\n      var _a3 = delayedEvents[i2], displayObject_1 = _a3.displayObject, eventString = _a3.eventString, eventData = _a3.eventData;\n      if (eventData.stopsPropagatingAt === displayObject_1) {\n        eventData.stopPropagationHint = true;\n      }\n      this.dispatchEvent(displayObject_1, eventString, eventData);\n    }\n    return hit;\n  };\n  InteractionManager2.prototype.onPointerDown = function(originalEvent) {\n    if (this.supportsTouchEvents && originalEvent.pointerType === \"touch\") {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      var cancelable = originalEvent.cancelable || !(\"cancelable\" in originalEvent);\n      if (cancelable) {\n        originalEvent.preventDefault();\n      }\n    }\n    var eventLen = events.length;\n    for (var i2 = 0; i2 < eventLen; i2++) {\n      var event = events[i2];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);\n      this.emit(\"pointerdown\", interactionEvent);\n      if (event.pointerType === \"touch\") {\n        this.emit(\"touchstart\", interactionEvent);\n      } else if (event.pointerType === \"mouse\" || event.pointerType === \"pen\") {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? \"rightdown\" : \"mousedown\", this.eventData);\n      }\n    }\n  };\n  InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.dispatchEvent(displayObject, \"pointerdown\", interactionEvent);\n      if (data.pointerType === \"touch\") {\n        this.dispatchEvent(displayObject, \"touchstart\", interactionEvent);\n      } else if (data.pointerType === \"mouse\" || data.pointerType === \"pen\") {\n        var isRightButton = data.button === 2;\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n        this.dispatchEvent(displayObject, isRightButton ? \"rightdown\" : \"mousedown\", interactionEvent);\n      }\n    }\n  };\n  InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {\n    var events = this.normalizeToPointerData(originalEvent);\n    var eventLen = events.length;\n    var eventAppend = originalEvent.target !== this.interactionDOMElement ? \"outside\" : \"\";\n    for (var i2 = 0; i2 < eventLen; i2++) {\n      var event = events[i2];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);\n      this.emit(cancelled ? \"pointercancel\" : \"pointerup\" + eventAppend, interactionEvent);\n      if (event.pointerType === \"mouse\" || event.pointerType === \"pen\") {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? \"rightup\" + eventAppend : \"mouseup\" + eventAppend, interactionEvent);\n      } else if (event.pointerType === \"touch\") {\n        this.emit(cancelled ? \"touchcancel\" : \"touchend\" + eventAppend, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId);\n      }\n    }\n  };\n  InteractionManager2.prototype.onPointerCancel = function(event) {\n    if (this.supportsTouchEvents && event.pointerType === \"touch\") {\n      return;\n    }\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  };\n  InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    if (displayObject.trackedPointers[id] !== void 0) {\n      delete displayObject.trackedPointers[id];\n      this.dispatchEvent(displayObject, \"pointercancel\", interactionEvent);\n      if (data.pointerType === \"touch\") {\n        this.dispatchEvent(displayObject, \"touchcancel\", interactionEvent);\n      }\n    }\n  };\n  InteractionManager2.prototype.onPointerUp = function(event) {\n    if (this.supportsTouchEvents && event.pointerType === \"touch\") {\n      return;\n    }\n    this.onPointerComplete(event, false, this.processPointerUp);\n  };\n  InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var trackingData = displayObject.trackedPointers[id];\n    var isTouch = data.pointerType === \"touch\";\n    var isMouse = data.pointerType === \"mouse\" || data.pointerType === \"pen\";\n    var isMouseTap = false;\n    if (isMouse) {\n      var isRightButton = data.button === 2;\n      var flags = InteractionTrackingData.FLAGS;\n      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n      var isDown = trackingData !== void 0 && trackingData.flags & test;\n      if (hit) {\n        this.dispatchEvent(displayObject, isRightButton ? \"rightup\" : \"mouseup\", interactionEvent);\n        if (isDown) {\n          this.dispatchEvent(displayObject, isRightButton ? \"rightclick\" : \"click\", interactionEvent);\n          isMouseTap = true;\n        }\n      } else if (isDown) {\n        this.dispatchEvent(displayObject, isRightButton ? \"rightupoutside\" : \"mouseupoutside\", interactionEvent);\n      }\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n    if (hit) {\n      this.dispatchEvent(displayObject, \"pointerup\", interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, \"touchend\", interactionEvent);\n      }\n      if (trackingData) {\n        if (!isMouse || isMouseTap) {\n          this.dispatchEvent(displayObject, \"pointertap\", interactionEvent);\n        }\n        if (isTouch) {\n          this.dispatchEvent(displayObject, \"tap\", interactionEvent);\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.dispatchEvent(displayObject, \"pointerupoutside\", interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, \"touchendoutside\", interactionEvent);\n      }\n    }\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  };\n  InteractionManager2.prototype.onPointerMove = function(originalEvent) {\n    if (this.supportsTouchEvents && originalEvent.pointerType === \"touch\") {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    if (events[0].pointerType === \"mouse\" || events[0].pointerType === \"pen\") {\n      this._didMove = true;\n      this.cursor = null;\n    }\n    var eventLen = events.length;\n    for (var i2 = 0; i2 < eventLen; i2++) {\n      var event = events[i2];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);\n      this.emit(\"pointermove\", interactionEvent);\n      if (event.pointerType === \"touch\") {\n        this.emit(\"touchmove\", interactionEvent);\n      }\n      if (event.pointerType === \"mouse\" || event.pointerType === \"pen\") {\n        this.emit(\"mousemove\", interactionEvent);\n      }\n    }\n    if (events[0].pointerType === \"mouse\") {\n      this.setCursorMode(this.cursor);\n    }\n  };\n  InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var isTouch = data.pointerType === \"touch\";\n    var isMouse = data.pointerType === \"mouse\" || data.pointerType === \"pen\";\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n    if (!this.moveWhenInside || hit) {\n      this.dispatchEvent(displayObject, \"pointermove\", interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, \"touchmove\", interactionEvent);\n      }\n      if (isMouse) {\n        this.dispatchEvent(displayObject, \"mousemove\", interactionEvent);\n      }\n    }\n  };\n  InteractionManager2.prototype.onPointerOut = function(originalEvent) {\n    if (this.supportsTouchEvents && originalEvent.pointerType === \"touch\") {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    var event = events[0];\n    if (event.pointerType === \"mouse\") {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);\n    this.emit(\"pointerout\", interactionEvent);\n    if (event.pointerType === \"mouse\" || event.pointerType === \"pen\") {\n      this.emit(\"mouseout\", interactionEvent);\n    } else {\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  };\n  InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var isMouse = data.pointerType === \"mouse\" || data.pointerType === \"pen\";\n    var trackingData = displayObject.trackedPointers[id];\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n    if (trackingData === void 0) {\n      return;\n    }\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.delayDispatchEvent(displayObject, \"pointerover\", interactionEvent);\n        if (isMouse) {\n          this.delayDispatchEvent(displayObject, \"mouseover\", interactionEvent);\n        }\n      }\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.dispatchEvent(displayObject, \"pointerout\", this.eventData);\n      if (isMouse) {\n        this.dispatchEvent(displayObject, \"mouseout\", interactionEvent);\n      }\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  };\n  InteractionManager2.prototype.onPointerOver = function(originalEvent) {\n    var events = this.normalizeToPointerData(originalEvent);\n    var event = events[0];\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    if (event.pointerType === \"mouse\") {\n      this.mouseOverRenderer = true;\n    }\n    this.emit(\"pointerover\", interactionEvent);\n    if (event.pointerType === \"mouse\" || event.pointerType === \"pen\") {\n      this.emit(\"mouseover\", interactionEvent);\n    }\n  };\n  InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {\n    var pointerId = event.pointerId;\n    var interactionData;\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === \"mouse\") {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    interactionData.copyEvent(event);\n    return interactionData;\n  };\n  InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {\n    var interactionData = this.activeInteractionData[pointerId];\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData.reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  };\n  InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n    if (pointerEvent.pointerType === \"touch\") {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent.reset();\n    return interactionEvent;\n  };\n  InteractionManager2.prototype.normalizeToPointerData = function(event) {\n    var normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (var i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {\n        var touch = event.changedTouches[i2];\n        if (typeof touch.button === \"undefined\") {\n          touch.button = event.touches.length ? 1 : 0;\n        }\n        if (typeof touch.buttons === \"undefined\") {\n          touch.buttons = event.touches.length ? 1 : 0;\n        }\n        if (typeof touch.isPrimary === \"undefined\") {\n          touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n        }\n        if (typeof touch.width === \"undefined\") {\n          touch.width = touch.radiusX || 1;\n        }\n        if (typeof touch.height === \"undefined\") {\n          touch.height = touch.radiusY || 1;\n        }\n        if (typeof touch.tiltX === \"undefined\") {\n          touch.tiltX = 0;\n        }\n        if (typeof touch.tiltY === \"undefined\") {\n          touch.tiltY = 0;\n        }\n        if (typeof touch.pointerType === \"undefined\") {\n          touch.pointerType = \"touch\";\n        }\n        if (typeof touch.pointerId === \"undefined\") {\n          touch.pointerId = touch.identifier || 0;\n        }\n        if (typeof touch.pressure === \"undefined\") {\n          touch.pressure = touch.force || 0.5;\n        }\n        if (typeof touch.twist === \"undefined\") {\n          touch.twist = 0;\n        }\n        if (typeof touch.tangentialPressure === \"undefined\") {\n          touch.tangentialPressure = 0;\n        }\n        if (typeof touch.layerX === \"undefined\") {\n          touch.layerX = touch.offsetX = touch.clientX;\n        }\n        if (typeof touch.layerY === \"undefined\") {\n          touch.layerY = touch.offsetY = touch.clientY;\n        }\n        touch.isNormalized = true;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      var tempEvent = event;\n      if (typeof tempEvent.isPrimary === \"undefined\") {\n        tempEvent.isPrimary = true;\n      }\n      if (typeof tempEvent.width === \"undefined\") {\n        tempEvent.width = 1;\n      }\n      if (typeof tempEvent.height === \"undefined\") {\n        tempEvent.height = 1;\n      }\n      if (typeof tempEvent.tiltX === \"undefined\") {\n        tempEvent.tiltX = 0;\n      }\n      if (typeof tempEvent.tiltY === \"undefined\") {\n        tempEvent.tiltY = 0;\n      }\n      if (typeof tempEvent.pointerType === \"undefined\") {\n        tempEvent.pointerType = \"mouse\";\n      }\n      if (typeof tempEvent.pointerId === \"undefined\") {\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      }\n      if (typeof tempEvent.pressure === \"undefined\") {\n        tempEvent.pressure = 0.5;\n      }\n      if (typeof tempEvent.twist === \"undefined\") {\n        tempEvent.twist = 0;\n      }\n      if (typeof tempEvent.tangentialPressure === \"undefined\") {\n        tempEvent.tangentialPressure = 0;\n      }\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  };\n  InteractionManager2.prototype.destroy = function() {\n    this.removeEvents();\n    this.removeTickerListener();\n    this.removeAllListeners();\n    this.renderer = null;\n    this.mouse = null;\n    this.eventData = null;\n    this.interactionDOMElement = null;\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n    this.onPointerOver = null;\n    this.search = null;\n  };\n  return InteractionManager2;\n}(EventEmitter$4);\n/*!\n * @pixi/app - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/app is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Application = function() {\n  function Application2(options) {\n    var _this = this;\n    this.stage = new Container();\n    options = Object.assign({\n      forceCanvas: false\n    }, options);\n    this.renderer = autoDetectRenderer(options);\n    Application2._plugins.forEach(function(plugin) {\n      plugin.init.call(_this, options);\n    });\n  }\n  Application2.registerPlugin = function(plugin) {\n    Application2._plugins.push(plugin);\n  };\n  Application2.prototype.render = function() {\n    this.renderer.render(this.stage);\n  };\n  Object.defineProperty(Application2.prototype, \"view\", {\n    get: function() {\n      return this.renderer.view;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Application2.prototype, \"screen\", {\n    get: function() {\n      return this.renderer.screen;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Application2.prototype.destroy = function(removeView, stageOptions) {\n    var _this = this;\n    var plugins2 = Application2._plugins.slice(0);\n    plugins2.reverse();\n    plugins2.forEach(function(plugin) {\n      plugin.destroy.call(_this);\n    });\n    this.stage.destroy(stageOptions);\n    this.stage = null;\n    this.renderer.destroy(removeView);\n    this.renderer = null;\n  };\n  Application2._plugins = [];\n  return Application2;\n}();\nvar ResizePlugin = function() {\n  function ResizePlugin2() {\n  }\n  ResizePlugin2.init = function(options) {\n    var _this = this;\n    Object.defineProperty(this, \"resizeTo\", {\n      set: function(dom) {\n        globalThis.removeEventListener(\"resize\", this.queueResize);\n        this._resizeTo = dom;\n        if (dom) {\n          globalThis.addEventListener(\"resize\", this.queueResize);\n          this.resize();\n        }\n      },\n      get: function() {\n        return this._resizeTo;\n      }\n    });\n    this.queueResize = function() {\n      if (!_this._resizeTo) {\n        return;\n      }\n      _this.cancelResize();\n      _this._resizeId = requestAnimationFrame(function() {\n        return _this.resize();\n      });\n    };\n    this.cancelResize = function() {\n      if (_this._resizeId) {\n        cancelAnimationFrame(_this._resizeId);\n        _this._resizeId = null;\n      }\n    };\n    this.resize = function() {\n      if (!_this._resizeTo) {\n        return;\n      }\n      _this.cancelResize();\n      var width;\n      var height;\n      if (_this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        var _a3 = _this._resizeTo, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      _this.renderer.resize(width, height);\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  };\n  ResizePlugin2.destroy = function() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this.cancelResize();\n    this.cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  };\n  return ResizePlugin2;\n}();\nApplication.registerPlugin(ResizePlugin);\n/*!\n * @pixi/extract - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar TEMP_RECT = new Rectangle();\nvar BYTES_PER_PIXEL = 4;\nvar Extract = function() {\n  function Extract2(renderer) {\n    this.renderer = renderer;\n  }\n  Extract2.prototype.image = function(target, format2, quality) {\n    var image = new Image();\n    image.src = this.base64(target, format2, quality);\n    return image;\n  };\n  Extract2.prototype.base64 = function(target, format2, quality) {\n    return this.canvas(target).toDataURL(format2, quality);\n  };\n  Extract2.prototype.canvas = function(target) {\n    var renderer = this.renderer;\n    var resolution;\n    var frame;\n    var flipY = false;\n    var renderTexture;\n    var generated = false;\n    if (target) {\n      if (target instanceof RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = this.renderer.generateTexture(target);\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      resolution = renderTexture.baseTexture.resolution;\n      frame = renderTexture.frame;\n      flipY = false;\n      renderer.renderTexture.bind(renderTexture);\n    } else {\n      resolution = this.renderer.resolution;\n      flipY = true;\n      frame = TEMP_RECT;\n      frame.width = this.renderer.width;\n      frame.height = this.renderer.height;\n      renderer.renderTexture.bind(null);\n    }\n    var width = Math.floor(frame.width * resolution + 1e-4);\n    var height = Math.floor(frame.height * resolution + 1e-4);\n    var canvasBuffer = new CanvasRenderTarget(width, height, 1);\n    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    var gl = renderer.gl;\n    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n    Extract2.arrayPostDivide(webglPixels, canvasData.data);\n    canvasBuffer.context.putImageData(canvasData, 0, 0);\n    if (flipY) {\n      var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n      target_1.context.scale(1, -1);\n      target_1.context.drawImage(canvasBuffer.canvas, 0, -height);\n      canvasBuffer.destroy();\n      canvasBuffer = target_1;\n    }\n    if (generated) {\n      renderTexture.destroy(true);\n    }\n    return canvasBuffer.canvas;\n  };\n  Extract2.prototype.pixels = function(target) {\n    var renderer = this.renderer;\n    var resolution;\n    var frame;\n    var renderTexture;\n    var generated = false;\n    if (target) {\n      if (target instanceof RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = this.renderer.generateTexture(target);\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      resolution = renderTexture.baseTexture.resolution;\n      frame = renderTexture.frame;\n      renderer.renderTexture.bind(renderTexture);\n    } else {\n      resolution = renderer.resolution;\n      frame = TEMP_RECT;\n      frame.width = renderer.width;\n      frame.height = renderer.height;\n      renderer.renderTexture.bind(null);\n    }\n    var width = frame.width * resolution;\n    var height = frame.height * resolution;\n    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    var gl = renderer.gl;\n    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n    if (generated) {\n      renderTexture.destroy(true);\n    }\n    Extract2.arrayPostDivide(webglPixels, webglPixels);\n    return webglPixels;\n  };\n  Extract2.prototype.destroy = function() {\n    this.renderer = null;\n  };\n  Extract2.arrayPostDivide = function(pixels, out) {\n    for (var i2 = 0; i2 < pixels.length; i2 += 4) {\n      var alpha = out[i2 + 3] = pixels[i2 + 3];\n      if (alpha !== 0) {\n        out[i2] = Math.round(Math.min(pixels[i2] * 255 / alpha, 255));\n        out[i2 + 1] = Math.round(Math.min(pixels[i2 + 1] * 255 / alpha, 255));\n        out[i2 + 2] = Math.round(Math.min(pixels[i2 + 2] * 255 / alpha, 255));\n      } else {\n        out[i2] = pixels[i2];\n        out[i2 + 1] = pixels[i2 + 1];\n        out[i2 + 2] = pixels[i2 + 2];\n      }\n    }\n  };\n  return Extract2;\n}();\n/*!\n * @pixi/compressed-textures - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/compressed-textures is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _a$2;\nvar INTERNAL_FORMATS;\n(function(INTERNAL_FORMATS2) {\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB_S3TC_DXT1_EXT\"] = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_S3TC_DXT1_EXT\"] = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_S3TC_DXT3_EXT\"] = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_S3TC_DXT5_EXT\"] = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\"] = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\"] = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\"] = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB_S3TC_DXT1_EXT\"] = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_R11_EAC\"] = 37488] = \"COMPRESSED_R11_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SIGNED_R11_EAC\"] = 37489] = \"COMPRESSED_SIGNED_R11_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RG11_EAC\"] = 37490] = \"COMPRESSED_RG11_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SIGNED_RG11_EAC\"] = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB8_ETC2\"] = 37492] = \"COMPRESSED_RGB8_ETC2\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA8_ETC2_EAC\"] = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB8_ETC2\"] = 37493] = \"COMPRESSED_SRGB8_ETC2\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\"] = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\"] = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\"] = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\"] = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\"] = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB_ETC1_WEBGL\"] = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGB_ATC_WEBGL\"] = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\"] = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2[\"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\"] = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\";\n})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));\nvar INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$n = function(d2, b2) {\n  extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$n(d2, b2);\n};\nfunction __extends$n(d2, b2) {\n  extendStatics$n(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nfunction __awaiter(thisArg, _arguments, P2, generator) {\n  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {\n    function fulfilled(value2) {\n      try {\n        step(generator.next(value2));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value2) {\n      try {\n        step(generator[\"throw\"](value2));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve2(result.value) : new P2(function(resolve3) {\n        resolve3(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _2 = { label: 0, sent: function() {\n    if (t[0] & 1) {\n      throw t[1];\n    }\n    return t[1];\n  }, trys: [], ops: [] }, f2, y2, t, g2;\n  return g2 = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g2[Symbol.iterator] = function() {\n    return this;\n  }), g2;\n  function verb(n) {\n    return function(v2) {\n      return step([n, v2]);\n    };\n  }\n  function step(op) {\n    if (f2) {\n      throw new TypeError(\"Generator is already executing.\");\n    }\n    while (_2) {\n      try {\n        if (f2 = 1, y2 && (t = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t = y2[\"return\"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) {\n          return t;\n        }\n        if (y2 = 0, t) {\n          op = [op[0] & 2, t.value];\n        }\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _2.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _2.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _2.ops.pop();\n            _2.trys.pop();\n            continue;\n          default:\n            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _2 = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _2.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _2.label < t[1]) {\n              _2.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _2.label < t[2]) {\n              _2.label = t[2];\n              _2.ops.push(op);\n              break;\n            }\n            if (t[2]) {\n              _2.ops.pop();\n            }\n            _2.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _2);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f2 = t = 0;\n      }\n    }\n    if (op[0] & 5) {\n      throw op[1];\n    }\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\nvar BlobResource = function(_super) {\n  __extends$n(BlobResource2, _super);\n  function BlobResource2(source, options) {\n    if (options === void 0) {\n      options = { width: 1, height: 1, autoLoad: true };\n    }\n    var _this = this;\n    var origin;\n    var data;\n    if (typeof source === \"string\") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    _this = _super.call(this, data, options) || this;\n    _this.origin = origin;\n    _this.buffer = data ? new ViewableBuffer(data) : null;\n    if (_this.origin && options.autoLoad !== false) {\n      _this.load();\n    }\n    if (data && data.length) {\n      _this.loaded = true;\n      _this.onBlobLoaded(_this.buffer.rawBinaryData);\n    }\n    return _this;\n  }\n  BlobResource2.prototype.onBlobLoaded = function(_data2) {\n  };\n  BlobResource2.prototype.load = function() {\n    return __awaiter(this, void 0, Promise, function() {\n      var response, blob, arrayBuffer;\n      return __generator(this, function(_a3) {\n        switch (_a3.label) {\n          case 0:\n            return [4, fetch(this.origin)];\n          case 1:\n            response = _a3.sent();\n            return [4, response.blob()];\n          case 2:\n            blob = _a3.sent();\n            return [4, blob.arrayBuffer()];\n          case 3:\n            arrayBuffer = _a3.sent();\n            this.data = new Uint32Array(arrayBuffer);\n            this.buffer = new ViewableBuffer(arrayBuffer);\n            this.loaded = true;\n            this.onBlobLoaded(arrayBuffer);\n            this.update();\n            return [2, this];\n        }\n      });\n    });\n  };\n  return BlobResource2;\n}(BufferResource);\nvar CompressedTextureResource = function(_super) {\n  __extends$n(CompressedTextureResource2, _super);\n  function CompressedTextureResource2(source, options) {\n    var _this = _super.call(this, source, options) || this;\n    _this.format = options.format;\n    _this.levels = options.levels || 1;\n    _this._width = options.width;\n    _this._height = options.height;\n    _this._extension = CompressedTextureResource2._formatToExtension(_this.format);\n    if (options.levelBuffers || _this.buffer) {\n      _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(source instanceof Uint8Array ? source : _this.buffer.uint8View, _this.format, _this.levels, 4, 4, _this.width, _this.height);\n    }\n    return _this;\n  }\n  CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {\n    var gl = renderer.gl;\n    var extension = renderer.context.extensions[this._extension];\n    if (!extension) {\n      throw new Error(this._extension + \" textures are not supported on the current machine\");\n    }\n    if (!this._levelBuffers) {\n      return false;\n    }\n    for (var i2 = 0, j2 = this.levels; i2 < j2; i2++) {\n      var _a3 = this._levelBuffers[i2], levelID = _a3.levelID, levelWidth = _a3.levelWidth, levelHeight = _a3.levelHeight, levelBuffer = _a3.levelBuffer;\n      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n    }\n    return true;\n  };\n  CompressedTextureResource2.prototype.onBlobLoaded = function() {\n    this._levelBuffers = CompressedTextureResource2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n  };\n  CompressedTextureResource2._formatToExtension = function(format2) {\n    if (format2 >= 33776 && format2 <= 33779) {\n      return \"s3tc\";\n    } else if (format2 >= 37488 && format2 <= 37497) {\n      return \"etc\";\n    } else if (format2 >= 35840 && format2 <= 35843) {\n      return \"pvrtc\";\n    } else if (format2 >= 36196) {\n      return \"etc1\";\n    } else if (format2 >= 35986 && format2 <= 34798) {\n      return \"atc\";\n    }\n    throw new Error(\"Invalid (compressed) texture format given!\");\n  };\n  CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {\n    var buffers = new Array(levels);\n    var offset2 = buffer.byteOffset;\n    var levelWidth = imageWidth;\n    var levelHeight = imageHeight;\n    var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n    var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n    var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];\n    for (var i2 = 0; i2 < levels; i2++) {\n      buffers[i2] = {\n        levelID: i2,\n        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n        levelBuffer: new Uint8Array(buffer.buffer, offset2, levelSize)\n      };\n      offset2 += levelSize;\n      levelWidth = levelWidth >> 1 || 1;\n      levelHeight = levelHeight >> 1 || 1;\n      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];\n    }\n    return buffers;\n  };\n  return CompressedTextureResource2;\n}(BlobResource);\nvar CompressedTextureLoader = function() {\n  function CompressedTextureLoader2() {\n  }\n  CompressedTextureLoader2.use = function(resource, next) {\n    var data = resource.data;\n    var loader = this;\n    if (resource.type === LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {\n      var textures = data.textures;\n      var textureURL = void 0;\n      var fallbackURL = void 0;\n      for (var i2 = 0, j2 = textures.length; i2 < j2; i2++) {\n        var texture = textures[i2];\n        var url_1 = texture.src;\n        var format2 = texture.format;\n        if (!format2) {\n          fallbackURL = url_1;\n        }\n        if (CompressedTextureLoader2.textureFormats[format2]) {\n          textureURL = url_1;\n          break;\n        }\n      }\n      textureURL = textureURL || fallbackURL;\n      if (!textureURL) {\n        next(new Error(\"Cannot load compressed-textures in \" + resource.url + \", make sure you provide a fallback\"));\n        return;\n      }\n      if (textureURL === resource.url) {\n        next(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n        return;\n      }\n      var loadOptions = {\n        crossOrigin: resource.crossOrigin,\n        metadata: resource.metadata.imageMetadata,\n        parentResource: resource\n      };\n      var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, \"\"), textureURL);\n      var resourceName = data.cacheID;\n      loader.add(resourceName, resourcePath, loadOptions, function(res) {\n        if (res.error) {\n          next(res.error);\n          return;\n        }\n        var _a3 = res.texture, texture2 = _a3 === void 0 ? null : _a3, _b3 = res.textures, textures2 = _b3 === void 0 ? {} : _b3;\n        Object.assign(resource, { texture: texture2, textures: textures2 });\n        next();\n      });\n    } else {\n      next();\n    }\n  };\n  Object.defineProperty(CompressedTextureLoader2, \"textureExtensions\", {\n    get: function() {\n      if (!CompressedTextureLoader2._textureExtensions) {\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\");\n        if (!gl) {\n          console.warn(\"WebGL not available for compressed textures. Silently failing.\");\n          return {};\n        }\n        var extensions = {\n          s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n          s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n          etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n          etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n          pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n          atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n          astc: gl.getExtension(\"WEBGL_compressed_texture_astc\")\n        };\n        CompressedTextureLoader2._textureExtensions = extensions;\n      }\n      return CompressedTextureLoader2._textureExtensions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CompressedTextureLoader2, \"textureFormats\", {\n    get: function() {\n      if (!CompressedTextureLoader2._textureFormats) {\n        var extensions = CompressedTextureLoader2.textureExtensions;\n        CompressedTextureLoader2._textureFormats = {};\n        for (var extensionName in extensions) {\n          var extension = extensions[extensionName];\n          if (!extension) {\n            continue;\n          }\n          Object.assign(CompressedTextureLoader2._textureFormats, Object.getPrototypeOf(extension));\n        }\n      }\n      return CompressedTextureLoader2._textureFormats;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return CompressedTextureLoader2;\n}();\nfunction registerCompressedTextures(url2, resources, metadata) {\n  var result = {\n    textures: {},\n    texture: null\n  };\n  if (!resources) {\n    return result;\n  }\n  var textures = resources.map(function(resource) {\n    return new Texture(new BaseTexture(resource, Object.assign({\n      mipmap: MIPMAP_MODES$3.OFF,\n      alphaMode: ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA\n    }, metadata)));\n  });\n  textures.forEach(function(texture, i2) {\n    var baseTexture = texture.baseTexture;\n    var cacheID = url2 + \"-\" + (i2 + 1);\n    BaseTexture.addToCache(baseTexture, cacheID);\n    Texture.addToCache(texture, cacheID);\n    if (i2 === 0) {\n      BaseTexture.addToCache(baseTexture, url2);\n      Texture.addToCache(texture, url2);\n      result.texture = texture;\n    }\n    result.textures[cacheID] = texture;\n  });\n  return result;\n}\nvar _a$1, _b$1;\nLoaderResource.setExtensionXhrType(\"dds\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar DDS_MAGIC_SIZE = 4;\nvar DDS_HEADER_SIZE = 124;\nvar DDS_HEADER_PF_SIZE = 32;\nvar DDS_HEADER_DX10_SIZE = 20;\nvar DDS_MAGIC = 542327876;\nvar DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n};\nvar DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n};\nvar DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n};\nvar DXGI_FORMAT;\n(function(DXGI_FORMAT2) {\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_UNKNOWN\"] = 0] = \"DXGI_FORMAT_UNKNOWN\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_TYPELESS\"] = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_FLOAT\"] = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_UINT\"] = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32A32_SINT\"] = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_TYPELESS\"] = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_FLOAT\"] = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_UINT\"] = 7] = \"DXGI_FORMAT_R32G32B32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32B32_SINT\"] = 8] = \"DXGI_FORMAT_R32G32B32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_TYPELESS\"] = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_FLOAT\"] = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_UNORM\"] = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_UINT\"] = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_SNORM\"] = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16B16A16_SINT\"] = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_TYPELESS\"] = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_FLOAT\"] = 16] = \"DXGI_FORMAT_R32G32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_UINT\"] = 17] = \"DXGI_FORMAT_R32G32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G32_SINT\"] = 18] = \"DXGI_FORMAT_R32G32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32G8X24_TYPELESS\"] = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\"] = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\"] = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\"] = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_TYPELESS\"] = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_UNORM\"] = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10A2_UINT\"] = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R11G11B10_FLOAT\"] = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_TYPELESS\"] = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UNORM\"] = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\"] = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_UINT\"] = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_SNORM\"] = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8B8A8_SINT\"] = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_TYPELESS\"] = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_FLOAT\"] = 34] = \"DXGI_FORMAT_R16G16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_UNORM\"] = 35] = \"DXGI_FORMAT_R16G16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_UINT\"] = 36] = \"DXGI_FORMAT_R16G16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_SNORM\"] = 37] = \"DXGI_FORMAT_R16G16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16G16_SINT\"] = 38] = \"DXGI_FORMAT_R16G16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_TYPELESS\"] = 39] = \"DXGI_FORMAT_R32_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D32_FLOAT\"] = 40] = \"DXGI_FORMAT_D32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_FLOAT\"] = 41] = \"DXGI_FORMAT_R32_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_UINT\"] = 42] = \"DXGI_FORMAT_R32_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R32_SINT\"] = 43] = \"DXGI_FORMAT_R32_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R24G8_TYPELESS\"] = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D24_UNORM_S8_UINT\"] = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\"] = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_X24_TYPELESS_G8_UINT\"] = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_TYPELESS\"] = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_UNORM\"] = 49] = \"DXGI_FORMAT_R8G8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_UINT\"] = 50] = \"DXGI_FORMAT_R8G8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_SNORM\"] = 51] = \"DXGI_FORMAT_R8G8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_SINT\"] = 52] = \"DXGI_FORMAT_R8G8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_TYPELESS\"] = 53] = \"DXGI_FORMAT_R16_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_FLOAT\"] = 54] = \"DXGI_FORMAT_R16_FLOAT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_D16_UNORM\"] = 55] = \"DXGI_FORMAT_D16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_UNORM\"] = 56] = \"DXGI_FORMAT_R16_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_UINT\"] = 57] = \"DXGI_FORMAT_R16_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_SNORM\"] = 58] = \"DXGI_FORMAT_R16_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R16_SINT\"] = 59] = \"DXGI_FORMAT_R16_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_TYPELESS\"] = 60] = \"DXGI_FORMAT_R8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_UNORM\"] = 61] = \"DXGI_FORMAT_R8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_UINT\"] = 62] = \"DXGI_FORMAT_R8_UINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_SNORM\"] = 63] = \"DXGI_FORMAT_R8_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8_SINT\"] = 64] = \"DXGI_FORMAT_R8_SINT\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_A8_UNORM\"] = 65] = \"DXGI_FORMAT_A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R1_UNORM\"] = 66] = \"DXGI_FORMAT_R1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\"] = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R8G8_B8G8_UNORM\"] = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_G8R8_G8B8_UNORM\"] = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_TYPELESS\"] = 70] = \"DXGI_FORMAT_BC1_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_UNORM\"] = 71] = \"DXGI_FORMAT_BC1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC1_UNORM_SRGB\"] = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_TYPELESS\"] = 73] = \"DXGI_FORMAT_BC2_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_UNORM\"] = 74] = \"DXGI_FORMAT_BC2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC2_UNORM_SRGB\"] = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_TYPELESS\"] = 76] = \"DXGI_FORMAT_BC3_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_UNORM\"] = 77] = \"DXGI_FORMAT_BC3_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC3_UNORM_SRGB\"] = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_TYPELESS\"] = 79] = \"DXGI_FORMAT_BC4_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_UNORM\"] = 80] = \"DXGI_FORMAT_BC4_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC4_SNORM\"] = 81] = \"DXGI_FORMAT_BC4_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_TYPELESS\"] = 82] = \"DXGI_FORMAT_BC5_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_UNORM\"] = 83] = \"DXGI_FORMAT_BC5_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC5_SNORM\"] = 84] = \"DXGI_FORMAT_BC5_SNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B5G6R5_UNORM\"] = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B5G5R5A1_UNORM\"] = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_UNORM\"] = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_UNORM\"] = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\"] = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_TYPELESS\"] = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\"] = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_TYPELESS\"] = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\"] = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_TYPELESS\"] = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_UF16\"] = 95] = \"DXGI_FORMAT_BC6H_UF16\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC6H_SF16\"] = 96] = \"DXGI_FORMAT_BC6H_SF16\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_TYPELESS\"] = 97] = \"DXGI_FORMAT_BC7_TYPELESS\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_UNORM\"] = 98] = \"DXGI_FORMAT_BC7_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_BC7_UNORM_SRGB\"] = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_AYUV\"] = 100] = \"DXGI_FORMAT_AYUV\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y410\"] = 101] = \"DXGI_FORMAT_Y410\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y416\"] = 102] = \"DXGI_FORMAT_Y416\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_NV12\"] = 103] = \"DXGI_FORMAT_NV12\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P010\"] = 104] = \"DXGI_FORMAT_P010\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P016\"] = 105] = \"DXGI_FORMAT_P016\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_420_OPAQUE\"] = 106] = \"DXGI_FORMAT_420_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_YUY2\"] = 107] = \"DXGI_FORMAT_YUY2\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y210\"] = 108] = \"DXGI_FORMAT_Y210\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_Y216\"] = 109] = \"DXGI_FORMAT_Y216\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_NV11\"] = 110] = \"DXGI_FORMAT_NV11\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_AI44\"] = 111] = \"DXGI_FORMAT_AI44\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_IA44\"] = 112] = \"DXGI_FORMAT_IA44\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P8\"] = 113] = \"DXGI_FORMAT_P8\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_A8P8\"] = 114] = \"DXGI_FORMAT_A8P8\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_B4G4R4A4_UNORM\"] = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_P208\"] = 116] = \"DXGI_FORMAT_P208\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_V208\"] = 117] = \"DXGI_FORMAT_V208\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_V408\"] = 118] = \"DXGI_FORMAT_V408\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\"] = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\"] = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\";\n  DXGI_FORMAT2[DXGI_FORMAT2[\"DXGI_FORMAT_FORCE_UINT\"] = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(DXGI_FORMAT || (DXGI_FORMAT = {}));\nvar D3D10_RESOURCE_DIMENSION;\n(function(D3D10_RESOURCE_DIMENSION2) {\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE1D\"] = 2] = \"DDS_DIMENSION_TEXTURE1D\";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE2D\"] = 3] = \"DDS_DIMENSION_TEXTURE2D\";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2[\"DDS_DIMENSION_TEXTURE3D\"] = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));\nvar PF_FLAGS = 1;\nvar DDPF_ALPHA = 2;\nvar DDPF_FOURCC = 4;\nvar DDPF_RGB = 64;\nvar DDPF_YUV = 512;\nvar DDPF_LUMINANCE = 131072;\nvar FOURCC_DXT1 = 827611204;\nvar FOURCC_DXT3 = 861165636;\nvar FOURCC_DXT5 = 894720068;\nvar FOURCC_DX10 = 808540228;\nvar DDS_RESOURCE_MISC_TEXTURECUBE = 4;\nvar FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1);\nvar DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);\nvar DDSLoader = function() {\n  function DDSLoader2() {\n  }\n  DDSLoader2.use = function(resource, next) {\n    if (resource.extension === \"dds\" && resource.data) {\n      try {\n        Object.assign(resource, registerCompressedTextures(resource.name || resource.url, DDSLoader2.parse(resource.data), resource.metadata));\n      } catch (err) {\n        next(err);\n        return;\n      }\n    }\n    next();\n  };\n  DDSLoader2.parse = function(arrayBuffer) {\n    var data = new Uint32Array(arrayBuffer);\n    var magicWord = data[0];\n    if (magicWord !== DDS_MAGIC) {\n      throw new Error(\"Invalid DDS file magic word\");\n    }\n    var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n    var height = header[DDS_FIELDS.HEIGHT];\n    var width = header[DDS_FIELDS.WIDTH];\n    var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];\n    var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n    var formatFlags = pixelFormat[PF_FLAGS];\n    if (formatFlags & DDPF_FOURCC) {\n      var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n      if (fourCC !== FOURCC_DX10) {\n        var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];\n        var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n        var texData = new Uint8Array(arrayBuffer, dataOffset_1);\n        var resource = new CompressedTextureResource(texData, {\n          format: internalFormat_1,\n          width,\n          height,\n          levels: mipmapCount\n        });\n        return [resource];\n      }\n      var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n      var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n      var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];\n      var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];\n      var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];\n      var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];\n      var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];\n      if (internalFormat_2 === void 0) {\n        throw new Error(\"DDSLoader cannot parse texture data with DXGI format \" + dxgiFormat);\n      }\n      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {\n        throw new Error(\"DDSLoader does not support cubemap textures\");\n      }\n      if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {\n        throw new Error(\"DDSLoader does not supported 3D texture data\");\n      }\n      var imageBuffers = new Array();\n      var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n      if (arraySize === 1) {\n        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));\n      } else {\n        var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];\n        var imageSize = 0;\n        var levelWidth = width;\n        var levelHeight = height;\n        for (var i2 = 0; i2 < mipmapCount; i2++) {\n          var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);\n          var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);\n          var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n          imageSize += levelSize;\n          levelWidth = levelWidth >>> 1;\n          levelHeight = levelHeight >>> 1;\n        }\n        var imageOffset = dataOffset;\n        for (var i2 = 0; i2 < arraySize; i2++) {\n          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));\n          imageOffset += imageSize;\n        }\n      }\n      return imageBuffers.map(function(buffer) {\n        return new CompressedTextureResource(buffer, {\n          format: internalFormat_2,\n          width,\n          height,\n          levels: mipmapCount\n        });\n      });\n    }\n    if (formatFlags & DDPF_RGB) {\n      throw new Error(\"DDSLoader does not support uncompressed texture data.\");\n    }\n    if (formatFlags & DDPF_YUV) {\n      throw new Error(\"DDSLoader does not supported YUV uncompressed texture data.\");\n    }\n    if (formatFlags & DDPF_LUMINANCE) {\n      throw new Error(\"DDSLoader does not support single-channel (lumninance) texture data!\");\n    }\n    if (formatFlags & DDPF_ALPHA) {\n      throw new Error(\"DDSLoader does not support single-channel (alpha) texture data!\");\n    }\n    throw new Error(\"DDSLoader failed to load a texture file due to an unknown reason!\");\n  };\n  return DDSLoader2;\n}();\nvar _a$3, _b, _c;\nLoaderResource.setExtensionXhrType(\"ktx\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];\nvar ENDIANNESS = 67305985;\nvar KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n};\nvar FILE_HEADER_SIZE = 64;\nvar TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$3.UNSIGNED_BYTE] = 1, _a$3[TYPES$3.UNSIGNED_SHORT] = 2, _a$3[TYPES$3.INT] = 4, _a$3[TYPES$3.UNSIGNED_INT] = 4, _a$3[TYPES$3.FLOAT] = 4, _a$3[TYPES$3.HALF_FLOAT] = 8, _a$3);\nvar FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$3.RGBA] = 4, _b[FORMATS$3.RGB] = 3, _b[FORMATS$3.RG] = 2, _b[FORMATS$3.RED] = 1, _b[FORMATS$3.LUMINANCE] = 1, _b[FORMATS$3.LUMINANCE_ALPHA] = 2, _b[FORMATS$3.ALPHA] = 1, _b);\nvar TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_6_5] = 2, _c);\nvar KTXLoader = function() {\n  function KTXLoader2() {\n  }\n  KTXLoader2.use = function(resource, next) {\n    if (resource.extension === \"ktx\" && resource.data) {\n      try {\n        var url_1 = resource.name || resource.url;\n        var _a3 = KTXLoader2.parse(url_1, resource.data), compressed = _a3.compressed, uncompressed = _a3.uncompressed;\n        if (compressed) {\n          Object.assign(resource, registerCompressedTextures(url_1, compressed, resource.metadata));\n        } else if (uncompressed) {\n          var textures_1 = {};\n          uncompressed.forEach(function(image, i2) {\n            var texture = new Texture(new BaseTexture(image.resource, {\n              mipmap: MIPMAP_MODES$3.OFF,\n              alphaMode: ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA,\n              type: image.type,\n              format: image.format\n            }));\n            var cacheID = url_1 + \"-\" + (i2 + 1);\n            BaseTexture.addToCache(texture.baseTexture, cacheID);\n            Texture.addToCache(texture, cacheID);\n            if (i2 === 0) {\n              textures_1[url_1] = texture;\n              BaseTexture.addToCache(texture.baseTexture, url_1);\n              Texture.addToCache(texture, url_1);\n            }\n            textures_1[cacheID] = texture;\n          });\n          Object.assign(resource, { textures: textures_1 });\n        }\n      } catch (err) {\n        next(err);\n        return;\n      }\n    }\n    next();\n  };\n  KTXLoader2.parse = function(url2, arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    if (!KTXLoader2.validate(url2, dataView)) {\n      return null;\n    }\n    var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;\n    var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);\n    var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);\n    var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n    var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);\n    var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;\n    var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;\n    var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;\n    var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);\n    var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n    var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n    if (pixelHeight === 0 || pixelDepth !== 1) {\n      throw new Error(\"Only 2D textures are supported\");\n    }\n    if (numberOfFaces !== 1) {\n      throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n    }\n    if (numberOfArrayElements !== 1) {\n      throw new Error(\"WebGL does not support array textures\");\n    }\n    var blockWidth = 4;\n    var blockHeight = 4;\n    var alignedWidth = pixelWidth + 3 & ~3;\n    var alignedHeight = pixelHeight + 3 & ~3;\n    var imageBuffers = new Array(numberOfArrayElements);\n    var imagePixels = pixelWidth * pixelHeight;\n    if (glType === 0) {\n      imagePixels = alignedWidth * alignedHeight;\n    }\n    var imagePixelByteSize;\n    if (glType !== 0) {\n      if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {\n        imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];\n      } else {\n        imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];\n      }\n    } else {\n      imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n    }\n    if (imagePixelByteSize === void 0) {\n      throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n    }\n    var imageByteSize = imagePixels * imagePixelByteSize;\n    var mipByteSize = imageByteSize;\n    var mipWidth = pixelWidth;\n    var mipHeight = pixelHeight;\n    var alignedMipWidth = alignedWidth;\n    var alignedMipHeight = alignedHeight;\n    var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;\n    for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n      var imageSize = dataView.getUint32(imageOffset, littleEndian);\n      var elementOffset = imageOffset + 4;\n      for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {\n        var mips = imageBuffers[arrayElement];\n        if (!mips) {\n          mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);\n        }\n        mips[mipmapLevel] = {\n          levelID: mipmapLevel,\n          levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,\n          levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,\n          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)\n        };\n        elementOffset += mipByteSize;\n      }\n      imageOffset += imageSize + 4;\n      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;\n      mipWidth = mipWidth >> 1 || 1;\n      mipHeight = mipHeight >> 1 || 1;\n      alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);\n      alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);\n      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n    }\n    if (glType !== 0) {\n      return {\n        uncompressed: imageBuffers.map(function(levelBuffers) {\n          var buffer = levelBuffers[0].levelBuffer;\n          var convertToInt = false;\n          if (glType === TYPES$3.FLOAT) {\n            buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n          } else if (glType === TYPES$3.UNSIGNED_INT) {\n            convertToInt = true;\n            buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n          } else if (glType === TYPES$3.INT) {\n            convertToInt = true;\n            buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n          }\n          return {\n            resource: new BufferResource(buffer, {\n              width: levelBuffers[0].levelWidth,\n              height: levelBuffers[0].levelHeight\n            }),\n            type: glType,\n            format: convertToInt ? KTXLoader2.convertFormatToInteger(glFormat) : glFormat\n          };\n        })\n      };\n    }\n    return {\n      compressed: imageBuffers.map(function(levelBuffers) {\n        return new CompressedTextureResource(null, {\n          format: glInternalFormat,\n          width: pixelWidth,\n          height: pixelHeight,\n          levels: numberOfMipmapLevels,\n          levelBuffers\n        });\n      })\n    };\n  };\n  KTXLoader2.validate = function(url2, dataView) {\n    for (var i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {\n      if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2]) {\n        console.error(url2 + \" is not a valid *.ktx file!\");\n        return false;\n      }\n    }\n    return true;\n  };\n  KTXLoader2.convertFormatToInteger = function(format2) {\n    switch (format2) {\n      case FORMATS$3.RGBA:\n        return FORMATS$3.RGBA_INTEGER;\n      case FORMATS$3.RGB:\n        return FORMATS$3.RGB_INTEGER;\n      case FORMATS$3.RG:\n        return FORMATS$3.RG_INTEGER;\n      case FORMATS$3.RED:\n        return FORMATS$3.RED_INTEGER;\n      default:\n        return format2;\n    }\n  };\n  return KTXLoader2;\n}();\n/*!\n * @pixi/particle-container - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/particle-container is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$m = function(d2, b2) {\n  extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$m(d2, b2);\n};\nfunction __extends$m(d2, b2) {\n  extendStatics$m(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\n(function(_super) {\n  __extends$m(ParticleContainer, _super);\n  function ParticleContainer(maxSize, properties, batchSize, autoResize) {\n    if (maxSize === void 0) {\n      maxSize = 1500;\n    }\n    if (batchSize === void 0) {\n      batchSize = 16384;\n    }\n    if (autoResize === void 0) {\n      autoResize = false;\n    }\n    var _this = _super.call(this) || this;\n    var maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n    _this._properties = [false, true, false, false, false];\n    _this._maxSize = maxSize;\n    _this._batchSize = batchSize;\n    _this._buffers = null;\n    _this._bufferUpdateIDs = [];\n    _this._updateID = 0;\n    _this.interactiveChildren = false;\n    _this.blendMode = BLEND_MODES$3.NORMAL;\n    _this.autoResize = autoResize;\n    _this.roundPixels = true;\n    _this.baseTexture = null;\n    _this.setProperties(properties);\n    _this._tint = 0;\n    _this.tintRgb = new Float32Array(4);\n    _this.tint = 16777215;\n    return _this;\n  }\n  ParticleContainer.prototype.setProperties = function(properties) {\n    if (properties) {\n      this._properties[0] = \"vertices\" in properties || \"scale\" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n      this._properties[1] = \"position\" in properties ? !!properties.position : this._properties[1];\n      this._properties[2] = \"rotation\" in properties ? !!properties.rotation : this._properties[2];\n      this._properties[3] = \"uvs\" in properties ? !!properties.uvs : this._properties[3];\n      this._properties[4] = \"tint\" in properties || \"alpha\" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n    }\n  };\n  ParticleContainer.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  };\n  Object.defineProperty(ParticleContainer.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(value2) {\n      this._tint = value2;\n      hex2rgb(value2, this.tintRgb);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ParticleContainer.prototype.render = function(renderer) {\n    var _this = this;\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n    if (!this.baseTexture) {\n      this.baseTexture = this.children[0]._texture.baseTexture;\n      if (!this.baseTexture.valid) {\n        this.baseTexture.once(\"update\", function() {\n          return _this.onChildrenChange(0);\n        });\n      }\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins.particle);\n    renderer.plugins.particle.render(this);\n  };\n  ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {\n    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    while (this._bufferUpdateIDs.length < bufferIndex) {\n      this._bufferUpdateIDs.push(0);\n    }\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  };\n  ParticleContainer.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var i2 = 0; i2 < this._buffers.length; ++i2) {\n        this._buffers[i2].destroy();\n      }\n      this._buffers = null;\n    }\n  };\n  ParticleContainer.prototype.destroy = function(options) {\n    _super.prototype.destroy.call(this, options);\n    this.dispose();\n    this._properties = null;\n    this._buffers = null;\n    this._bufferUpdateIDs = null;\n  };\n  return ParticleContainer;\n})(Container);\nvar ParticleBuffer = function() {\n  function ParticleBuffer2(properties, dynamicPropertyFlags, size) {\n    this.geometry = new Geometry();\n    this.indexBuffer = null;\n    this.size = size;\n    this.dynamicProperties = [];\n    this.staticProperties = [];\n    for (var i2 = 0; i2 < properties.length; ++i2) {\n      var property = properties[i2];\n      property = {\n        attributeName: property.attributeName,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        type: property.type || TYPES$3.FLOAT,\n        offset: property.offset\n      };\n      if (dynamicPropertyFlags[i2]) {\n        this.dynamicProperties.push(property);\n      } else {\n        this.staticProperties.push(property);\n      }\n    }\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this._updateID = 0;\n    this.initBuffers();\n  }\n  ParticleBuffer2.prototype.initBuffers = function() {\n    var geometry = this.geometry;\n    var dynamicOffset = 0;\n    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);\n    geometry.addIndex(this.indexBuffer);\n    this.dynamicStride = 0;\n    for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {\n      var property = this.dynamicProperties[i2];\n      property.offset = dynamicOffset;\n      dynamicOffset += property.size;\n      this.dynamicStride += property.size;\n    }\n    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(dynBuffer);\n    this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n    this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);\n    var staticOffset = 0;\n    this.staticStride = 0;\n    for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {\n      var property = this.staticProperties[i2];\n      property.offset = staticOffset;\n      staticOffset += property.size;\n      this.staticStride += property.size;\n    }\n    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(statBuffer);\n    this.staticDataUint32 = new Uint32Array(statBuffer);\n    this.staticBuffer = new Buffer$1(this.staticData, true, false);\n    for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {\n      var property = this.dynamicProperties[i2];\n      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);\n    }\n    for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {\n      var property = this.staticProperties[i2];\n      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);\n    }\n  };\n  ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {\n    for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {\n      var property = this.dynamicProperties[i2];\n      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  };\n  ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {\n    for (var i2 = 0; i2 < this.staticProperties.length; i2++) {\n      var property = this.staticProperties[i2];\n      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);\n    }\n    this.staticBuffer._updateID++;\n  };\n  ParticleBuffer2.prototype.destroy = function() {\n    this.indexBuffer = null;\n    this.dynamicProperties = null;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this.staticProperties = null;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.geometry.destroy();\n  };\n  return ParticleBuffer2;\n}();\nvar fragment$6 = \"varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\\n    gl_FragColor = color;\\n}\";\nvar vertex$3 = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPositionCoord;\\nattribute float aRotation;\\n\\nuniform mat3 translationMatrix;\\nuniform vec4 uColor;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void){\\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPositionCoord;\\n\\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vColor = aColor * uColor;\\n}\\n\";\nvar ParticleRenderer = function(_super) {\n  __extends$m(ParticleRenderer2, _super);\n  function ParticleRenderer2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.shader = null;\n    _this.properties = null;\n    _this.tempMatrix = new Matrix();\n    _this.properties = [\n      {\n        attributeName: \"aVertexPosition\",\n        size: 2,\n        uploadFunction: _this.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: \"aPositionCoord\",\n        size: 2,\n        uploadFunction: _this.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: \"aRotation\",\n        size: 1,\n        uploadFunction: _this.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: \"aTextureCoord\",\n        size: 2,\n        uploadFunction: _this.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: \"aColor\",\n        size: 1,\n        type: TYPES$3.UNSIGNED_BYTE,\n        uploadFunction: _this.uploadTint,\n        offset: 0\n      }\n    ];\n    _this.shader = Shader.from(vertex$3, fragment$6, {});\n    _this.state = State.for2d();\n    return _this;\n  }\n  ParticleRenderer2.prototype.render = function(container) {\n    var children = container.children;\n    var maxSize = container._maxSize;\n    var batchSize = container._batchSize;\n    var renderer = this.renderer;\n    var totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize && !container.autoResize) {\n      totalChildren = maxSize;\n    }\n    var buffers = container._buffers;\n    if (!buffers) {\n      buffers = container._buffers = this.generateBuffers(container);\n    }\n    var baseTexture = children[0]._texture.baseTexture;\n    this.state.blendMode = correctBlendMode(container.blendMode, baseTexture.alphaMode);\n    renderer.state.set(this.state);\n    var gl = renderer.gl;\n    var m2 = container.worldTransform.copyTo(this.tempMatrix);\n    m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n    this.shader.uniforms.translationMatrix = m2.toArray(true);\n    this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);\n    this.shader.uniforms.uSampler = baseTexture;\n    this.renderer.shader.bind(this.shader);\n    var updateStatic = false;\n    for (var i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {\n      var amount = totalChildren - i2;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j2 >= buffers.length) {\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      var buffer = buffers[j2];\n      buffer.uploadDynamic(children, i2, amount);\n      var bid = container._bufferUpdateIDs[j2] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i2, amount);\n      }\n      renderer.geometry.bind(buffer.geometry);\n      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  };\n  ParticleRenderer2.prototype.generateBuffers = function(container) {\n    var buffers = [];\n    var size = container._maxSize;\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n    for (var i2 = 0; i2 < size; i2 += batchSize) {\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  };\n  ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  };\n  ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset2) {\n    var w0 = 0;\n    var w1 = 0;\n    var h0 = 0;\n    var h1 = 0;\n    for (var i2 = 0; i2 < amount; ++i2) {\n      var sprite = children[startIndex + i2];\n      var texture = sprite._texture;\n      var sx = sprite.scale.x;\n      var sy = sprite.scale.y;\n      var trim2 = texture.trim;\n      var orig = texture.orig;\n      if (trim2) {\n        w1 = trim2.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim2.width;\n        h1 = trim2.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim2.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset2] = w1 * sx;\n      array[offset2 + 1] = h1 * sy;\n      array[offset2 + stride] = w0 * sx;\n      array[offset2 + stride + 1] = h1 * sy;\n      array[offset2 + stride * 2] = w0 * sx;\n      array[offset2 + stride * 2 + 1] = h0 * sy;\n      array[offset2 + stride * 3] = w1 * sx;\n      array[offset2 + stride * 3 + 1] = h0 * sy;\n      offset2 += stride * 4;\n    }\n  };\n  ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset2) {\n    for (var i2 = 0; i2 < amount; i2++) {\n      var spritePosition = children[startIndex + i2].position;\n      array[offset2] = spritePosition.x;\n      array[offset2 + 1] = spritePosition.y;\n      array[offset2 + stride] = spritePosition.x;\n      array[offset2 + stride + 1] = spritePosition.y;\n      array[offset2 + stride * 2] = spritePosition.x;\n      array[offset2 + stride * 2 + 1] = spritePosition.y;\n      array[offset2 + stride * 3] = spritePosition.x;\n      array[offset2 + stride * 3 + 1] = spritePosition.y;\n      offset2 += stride * 4;\n    }\n  };\n  ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset2) {\n    for (var i2 = 0; i2 < amount; i2++) {\n      var spriteRotation = children[startIndex + i2].rotation;\n      array[offset2] = spriteRotation;\n      array[offset2 + stride] = spriteRotation;\n      array[offset2 + stride * 2] = spriteRotation;\n      array[offset2 + stride * 3] = spriteRotation;\n      offset2 += stride * 4;\n    }\n  };\n  ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset2) {\n    for (var i2 = 0; i2 < amount; ++i2) {\n      var textureUvs = children[startIndex + i2]._texture._uvs;\n      if (textureUvs) {\n        array[offset2] = textureUvs.x0;\n        array[offset2 + 1] = textureUvs.y0;\n        array[offset2 + stride] = textureUvs.x1;\n        array[offset2 + stride + 1] = textureUvs.y1;\n        array[offset2 + stride * 2] = textureUvs.x2;\n        array[offset2 + stride * 2 + 1] = textureUvs.y2;\n        array[offset2 + stride * 3] = textureUvs.x3;\n        array[offset2 + stride * 3 + 1] = textureUvs.y3;\n        offset2 += stride * 4;\n      } else {\n        array[offset2] = 0;\n        array[offset2 + 1] = 0;\n        array[offset2 + stride] = 0;\n        array[offset2 + stride + 1] = 0;\n        array[offset2 + stride * 2] = 0;\n        array[offset2 + stride * 2 + 1] = 0;\n        array[offset2 + stride * 3] = 0;\n        array[offset2 + stride * 3 + 1] = 0;\n        offset2 += stride * 4;\n      }\n    }\n  };\n  ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset2) {\n    for (var i2 = 0; i2 < amount; ++i2) {\n      var sprite = children[startIndex + i2];\n      var premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n      var alpha = sprite.alpha;\n      var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      array[offset2] = argb;\n      array[offset2 + stride] = argb;\n      array[offset2 + stride * 2] = argb;\n      array[offset2 + stride * 3] = argb;\n      offset2 += stride * 4;\n    }\n  };\n  ParticleRenderer2.prototype.destroy = function() {\n    _super.prototype.destroy.call(this);\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.tempMatrix = null;\n  };\n  return ParticleRenderer2;\n}(ObjectRenderer);\n/*!\n * @pixi/graphics - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar LINE_JOIN;\n(function(LINE_JOIN2) {\n  LINE_JOIN2[\"MITER\"] = \"miter\";\n  LINE_JOIN2[\"BEVEL\"] = \"bevel\";\n  LINE_JOIN2[\"ROUND\"] = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\nvar LINE_CAP;\n(function(LINE_CAP2) {\n  LINE_CAP2[\"BUTT\"] = \"butt\";\n  LINE_CAP2[\"ROUND\"] = \"round\";\n  LINE_CAP2[\"SQUARE\"] = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(length2, defaultSegments) {\n    if (defaultSegments === void 0) {\n      defaultSegments = 20;\n    }\n    if (!this.adaptive || !length2 || isNaN(length2)) {\n      return defaultSegments;\n    }\n    var result = Math.ceil(length2 / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\nvar FillStyle = function() {\n  function FillStyle2() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n    this.reset();\n  }\n  FillStyle2.prototype.clone = function() {\n    var obj = new FillStyle2();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  };\n  FillStyle2.prototype.reset = function() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  };\n  FillStyle2.prototype.destroy = function() {\n    this.texture = null;\n    this.matrix = null;\n  };\n  return FillStyle2;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$l = function(d2, b2) {\n  extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$l(d2, b2);\n};\nfunction __extends$l(d2, b2) {\n  extendStatics$l(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nfunction fixOrientation(points, hole) {\n  var _a3, _b3;\n  if (hole === void 0) {\n    hole = false;\n  }\n  var m2 = points.length;\n  if (m2 < 6) {\n    return;\n  }\n  var area2 = 0;\n  for (var i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {\n    var x2 = points[i2];\n    var y2 = points[i2 + 1];\n    area2 += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area2 > 0 || hole && area2 <= 0) {\n    var n = m2 / 2;\n    for (var i2 = n + n % 2; i2 < m2; i2 += 2) {\n      var i1 = m2 - i2 - 2;\n      var i22 = m2 - i2 - 1;\n      var i3 = i2;\n      var i4 = i2 + 1;\n      _a3 = [points[i3], points[i1]], points[i1] = _a3[0], points[i3] = _a3[1];\n      _b3 = [points[i4], points[i22]], points[i22] = _b3[0], points[i4] = _b3[1];\n    }\n  }\n}\nvar buildPoly = {\n  build: function(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices2 = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      var holeArray = [];\n      for (var i2 = 0; i2 < holes.length; i2++) {\n        var hole = holes[i2];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      var triangles = earcut$1(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      var vertPos = verts.length / 2;\n      for (var i2 = 0; i2 < triangles.length; i2 += 3) {\n        indices2.push(triangles[i2] + vertPos);\n        indices2.push(triangles[i2 + 1] + vertPos);\n        indices2.push(triangles[i2 + 2] + vertPos);\n      }\n      for (var i2 = 0; i2 < points.length; i2++) {\n        verts.push(points[i2]);\n      }\n    }\n  }\n};\nvar buildCircle = {\n  build: function(graphicsData) {\n    var points = graphicsData.points;\n    var x2;\n    var y2;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x2 = circle.x;\n      y2 = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x2 = ellipse.x;\n      y2 = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x2 = roundedRect.x + halfWidth;\n      y2 = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m2 = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m2;\n    if (m2 === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x2 + dx;\n      points[1] = points[3] = y2 + dy;\n      points[2] = points[4] = x2 - dx;\n      points[5] = points[7] = y2 - dy;\n      return;\n    }\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m2;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x2 + x0;\n      var x22 = x2 - x0;\n      var y1 = y2 + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x22;\n      if (dy) {\n        var y22 = y2 - y0;\n        points[j3++] = x22;\n        points[j3++] = y22;\n        points[--j4] = y22;\n        points[--j4] = x1;\n      }\n    }\n    for (var i2 = 1; i2 < n; i2++) {\n      var a2 = Math.PI / 2 * (i2 / n);\n      var x0 = dx + Math.cos(a2) * rx;\n      var y0 = dy + Math.sin(a2) * ry;\n      var x1 = x2 + x0;\n      var x22 = x2 - x0;\n      var y1 = y2 + y0;\n      var y22 = y2 - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    {\n      var x0 = dx;\n      var y0 = dy + ry;\n      var x1 = x2 + x0;\n      var x22 = x2 - x0;\n      var y1 = y2 + y0;\n      var y22 = y2 - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y22;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x22;\n        points[j1++] = y1;\n        points[--j4] = y22;\n        points[--j4] = x22;\n      }\n    }\n  },\n  triangulate: function(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices2 = graphicsGeometry.indices;\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x2;\n    var y2;\n    if (graphicsData.type !== SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x2 = circle.x;\n      y2 = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x2 = roundedRect.x + roundedRect.width / 2;\n      y2 = roundedRect.y + roundedRect.height / 2;\n    }\n    var matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (var i2 = 2; i2 < points.length; i2 += 2) {\n      verts.push(points[i2], points[i2 + 1]);\n      indices2.push(vertPos++, center, vertPos);\n    }\n    indices2.push(center + 1, center, vertPos);\n  }\n};\nvar buildRectangle = {\n  build: function(graphicsData) {\n    var rectData = graphicsData.shape;\n    var x2 = rectData.x;\n    var y2 = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);\n  },\n  triangulate: function(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\nfunction getPt(n1, n2, perc) {\n  var diff2 = n2 - n1;\n  return n1 + diff2 * perc;\n}\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x2 = 0;\n  var y2 = 0;\n  for (var i2 = 0, j2 = 0; i2 <= n; ++i2) {\n    j2 = i2 / n;\n    xa = getPt(fromX, cpX, j2);\n    ya = getPt(fromY, cpY, j2);\n    xb = getPt(cpX, toX, j2);\n    yb = getPt(cpY, toY, j2);\n    x2 = getPt(xa, xb, j2);\n    y2 = getPt(ya, yb, j2);\n    if (i2 === 0 && points[points.length - 2] === x2 && points[points.length - 1] === y2) {\n      continue;\n    }\n    points.push(x2, y2);\n  }\n  return points;\n}\nvar buildRoundedRectangle = {\n  build: function(graphicsData) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(graphicsData);\n      return;\n    }\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x2 = rrectData.x;\n    var y2 = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n    points.length = 0;\n    if (!radius) {\n      points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);\n    } else {\n      quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);\n      quadraticBezierCurve(x2 + width - radius, y2, x2 + width, y2, x2 + width, y2 + radius, points);\n      quadraticBezierCurve(x2 + width, y2 + height - radius, x2 + width, y2 + height, x2 + width - radius, y2 + height, points);\n      quadraticBezierCurve(x2 + radius, y2 + height, x2, y2 + height, x2, y2 + height - radius, points);\n    }\n  },\n  triangulate: function(graphicsData, graphicsGeometry) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(graphicsData, graphicsGeometry);\n      return;\n    }\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices2 = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = earcut$1(points, null, 2);\n    for (var i2 = 0, j2 = triangles.length; i2 < j2; i2 += 3) {\n      indices2.push(triangles[i2] + vecPos);\n      indices2.push(triangles[i2 + 1] + vecPos);\n      indices2.push(triangles[i2 + 2] + vecPos);\n    }\n    for (var i2 = 0, j2 = points.length; i2 < j2; i2++) {\n      verts.push(points[i2], points[++i2]);\n    }\n  }\n};\nfunction square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  var ix = x2 - nx * innerWeight;\n  var iy = y2 - ny * innerWeight;\n  var ox = x2 + nx * outerWeight;\n  var oy = y2 + ny * outerWeight;\n  var exx;\n  var eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round$1(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  var style = graphicsData.lineStyle;\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  var verts = graphicsGeometry.points;\n  var length2 = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2;\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment;\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round$1(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (var i2 = 1; i2 < length2 - 1; ++i2) {\n    x0 = points[(i2 - 1) * 2];\n    y0 = points[(i2 - 1) * 2 + 1];\n    x1 = points[i2 * 2];\n    y1 = points[i2 * 2 + 1];\n    x2 = points[(i2 + 1) * 2];\n    y2 = points[(i2 + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    if (Math.abs(cross) < 0.1) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      continue;\n    }\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    var insideWeight = clockwise ? innerWeight : outerWeight;\n    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    var insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n        ;\n      else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          indexCount += round$1(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n        } else {\n          indexCount += round$1(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n        }\n      } else {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length2 - 2) * 2];\n  y0 = points[(length2 - 2) * 2 + 1];\n  x1 = points[(length2 - 1) * 2];\n  y1 = points[(length2 - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round$1(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  var indices2 = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n  for (var i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {\n    x0 = verts[i2 * 2];\n    y0 = verts[i2 * 2 + 1];\n    x1 = verts[(i2 + 1) * 2];\n    y1 = verts[(i2 + 1) * 2 + 1];\n    x2 = verts[(i2 + 2) * 2];\n    y2 = verts[(i2 + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices2.push(i2, i2 + 1, i2 + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i2 = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) {\n    return;\n  }\n  var verts = graphicsGeometry.points;\n  var indices2 = graphicsGeometry.indices;\n  var length2 = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i2 = 1; i2 < length2; i2++) {\n    verts.push(points[i2 * 2], points[i2 * 2 + 1]);\n    indices2.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices2.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\nvar ArcUtils = function() {\n  function ArcUtils2() {\n  }\n  ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    var dd = a1 * a1 + b1 * b1;\n    var cc = a2 * a2 + b2 * b2;\n    var tt = a1 * a2 + b1 * b2;\n    var k1 = radius * Math.sqrt(dd) / mm;\n    var k2 = radius * Math.sqrt(cc) / mm;\n    var j1 = k1 * tt / dd;\n    var j2 = k2 * tt / cc;\n    var cx = k1 * b2 + k2 * b1;\n    var cy = k1 * a2 + k2 * a1;\n    var px = b1 * (k2 + j1);\n    var py = a1 * (k2 + j1);\n    var qx = b2 * (k1 + j2);\n    var qy = a2 * (k1 + j2);\n    var startAngle = Math.atan2(py - cy, px - cx);\n    var endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius,\n      startAngle,\n      endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  };\n  ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    var sweep = endAngle - startAngle;\n    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n    var theta = sweep / (n * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = n - 1;\n    var remainder = segMinus % 1 / segMinus;\n    for (var i2 = 0; i2 <= segMinus; ++i2) {\n      var real = i2 + remainder * i2;\n      var angle = theta + startAngle + theta2 * real;\n      var c2 = Math.cos(angle);\n      var s2 = -Math.sin(angle);\n      points.push((cTheta * c2 + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c2) * radius + cy);\n    }\n  };\n  return ArcUtils2;\n}();\nvar BezierUtils = function() {\n  function BezierUtils2() {\n  }\n  BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0;\n    var t = 0;\n    var t2 = 0;\n    var t3 = 0;\n    var nt = 0;\n    var nt2 = 0;\n    var nt3 = 0;\n    var x2 = 0;\n    var y2 = 0;\n    var dx = 0;\n    var dy = 0;\n    var prevX = fromX;\n    var prevY = fromY;\n    for (var i2 = 1; i2 <= n; ++i2) {\n      t = i2 / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x2 = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n      y2 = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x2;\n      dy = prevY - y2;\n      prevX = x2;\n      prevY = y2;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  };\n  BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY);\n    for (var i2 = 1, j2 = 0; i2 <= n; ++i2) {\n      j2 = i2 / n;\n      dt = 1 - j2;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j2 * j2;\n      t3 = t2 * j2;\n      points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  };\n  return BezierUtils2;\n}();\nvar QuadraticUtils = function() {\n  function QuadraticUtils2() {\n  }\n  QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2 * cpX + toX;\n    var ay = fromY - 2 * cpY + toY;\n    var bx = 2 * cpX - 2 * fromX;\n    var by = 2 * cpY - 2 * fromY;\n    var a2 = 4 * (ax * ax + ay * ay);\n    var b2 = 4 * (ax * bx + ay * by);\n    var c2 = bx * bx + by * by;\n    var s2 = 2 * Math.sqrt(a2 + b2 + c2);\n    var a22 = Math.sqrt(a2);\n    var a32 = 2 * a2 * a22;\n    var c22 = 2 * Math.sqrt(c2);\n    var ba = b2 / a22;\n    return (a32 * s2 + a22 * b2 * (s2 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba + s2) / (ba + c22))) / (4 * a32);\n  };\n  QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    var xa = 0;\n    var ya = 0;\n    for (var i2 = 1; i2 <= n; ++i2) {\n      var j2 = i2 / n;\n      xa = fromX + (cpX - fromX) * j2;\n      ya = fromY + (cpY - fromY) * j2;\n      points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);\n    }\n  };\n  return QuadraticUtils2;\n}();\nvar BatchPart = function() {\n  function BatchPart2() {\n    this.reset();\n  }\n  BatchPart2.prototype.begin = function(style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  };\n  BatchPart2.prototype.end = function(endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  };\n  BatchPart2.prototype.reset = function() {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  };\n  return BatchPart2;\n}();\nvar _a;\nvar FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);\nvar BATCH_POOL = [];\nvar DRAW_CALL_POOL = [];\nvar GraphicsData = function() {\n  function GraphicsData2(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    this.points = [];\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  GraphicsData2.prototype.clone = function() {\n    return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  };\n  GraphicsData2.prototype.destroy = function() {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  };\n  return GraphicsData2;\n}();\nvar tmpPoint = new Point();\nvar tmpBounds = new Bounds();\nvar GraphicsGeometry = function(_super) {\n  __extends$l(GraphicsGeometry2, _super);\n  function GraphicsGeometry2() {\n    var _this = _super.call(this) || this;\n    _this.closePointEps = 1e-4;\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    _this.points = [];\n    _this.colors = [];\n    _this.uvs = [];\n    _this.indices = [];\n    _this.textureIds = [];\n    _this.graphicsData = [];\n    _this.drawCalls = [];\n    _this.batchDirty = -1;\n    _this.batches = [];\n    _this.dirty = 0;\n    _this.cacheDirty = -1;\n    _this.clearDirty = 0;\n    _this.shapeIndex = 0;\n    _this._bounds = new Bounds();\n    _this.boundsDirty = -1;\n    return _this;\n  }\n  Object.defineProperty(GraphicsGeometry2.prototype, \"bounds\", {\n    get: function() {\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  GraphicsGeometry2.prototype.invalidate = function() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (var i2 = 0; i2 < this.drawCalls.length; i2++) {\n      this.drawCalls[i2].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i2]);\n    }\n    this.drawCalls.length = 0;\n    for (var i2 = 0; i2 < this.batches.length; i2++) {\n      var batchPart = this.batches[i2];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  };\n  GraphicsGeometry2.prototype.clear = function() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  };\n  GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  GraphicsGeometry2.prototype.destroy = function() {\n    _super.prototype.destroy.call(this);\n    for (var i2 = 0; i2 < this.graphicsData.length; ++i2) {\n      this.graphicsData[i2].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  GraphicsGeometry2.prototype.containsPoint = function(point) {\n    var graphicsData = this.graphicsData;\n    for (var i2 = 0; i2 < graphicsData.length; ++i2) {\n      var data = graphicsData[i2];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n          if (data.holes) {\n            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {\n              var hole = data.holes[i_1];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (var i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {\n      this.shapeIndex++;\n      var data = graphicsData[i2];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type];\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (var j2 = 0; j2 < 2; j2++) {\n        var style = j2 === 0 ? fillStyle : lineStyle;\n        if (!style.visible) {\n          continue;\n        }\n        var nextTexture = style.texture.baseTexture;\n        var index_1 = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES$3.REPEAT;\n        if (j2 === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        var size = this.points.length / 2 - attribIndex;\n        if (size === 0) {\n          continue;\n        }\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index_1, attribIndex);\n          batchPart = null;\n        }\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index_1, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    var index = this.indices.length;\n    var attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      this.batchable = true;\n      return;\n    }\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      var need32 = attrib > 65535 && allow32Indices;\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  };\n  GraphicsGeometry2.prototype.validateBatching = function() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (var i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {\n      var data = this.graphicsData[i2];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n    return true;\n  };\n  GraphicsGeometry2.prototype.packBatches = function() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n    for (var i2 = 0, l2 = batches.length; i2 < l2; i2++) {\n      var batch = batches[i2];\n      for (var j2 = 0; j2 < batch.size; j2++) {\n        var index = batch.start + j2;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  GraphicsGeometry2.prototype.isBatchable = function() {\n    if (this.points.length > 65535 * 2) {\n      return false;\n    }\n    var batches = this.batches;\n    for (var i2 = 0; i2 < batches.length; i2++) {\n      if (batches[i2].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;\n  };\n  GraphicsGeometry2.prototype.buildDrawCalls = function() {\n    var TICK = ++BaseTexture._globalBatch;\n    for (var i2 = 0; i2 < this.drawCalls.length; i2++) {\n      this.drawCalls[i2].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i2]);\n    }\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES$3.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = DRAW_MODES$3.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup);\n    for (var i2 = 0; i2 < this.batches.length; i2++) {\n      var data = this.batches[i2];\n      var MAX_TEXTURES = 8;\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES$3.LINES : DRAW_MODES$3.TRIANGLES;\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          nextTexture.touched = 1;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = WRAP_MODES$3.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK;\n    this.packAttributes();\n  };\n  GraphicsGeometry2.prototype.packAttributes = function() {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p2 = 0;\n    for (var i2 = 0; i2 < verts.length / 2; i2++) {\n      f32[p2++] = verts[i2 * 2];\n      f32[p2++] = verts[i2 * 2 + 1];\n      f32[p2++] = uvs[i2 * 2];\n      f32[p2++] = uvs[i2 * 2 + 1];\n      u32[p2++] = colors[i2];\n      f32[p2++] = textureIds[i2];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  GraphicsGeometry2.prototype.processFill = function(data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  GraphicsGeometry2.prototype.processLine = function(data) {\n    buildLine(data, this);\n    for (var i2 = 0; i2 < data.holes.length; i2++) {\n      buildLine(data.holes[i2], this);\n    }\n  };\n  GraphicsGeometry2.prototype.processHoles = function(holes) {\n    for (var i2 = 0; i2 < holes.length; i2++) {\n      var hole = holes[i2];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  GraphicsGeometry2.prototype.calculateBounds = function() {\n    var bounds = this._bounds;\n    var sequenceBounds = tmpBounds;\n    var curMatrix = Matrix.IDENTITY;\n    this._bounds.clear();\n    sequenceBounds.clear();\n    for (var i2 = 0; i2 < this.graphicsData.length; i2++) {\n      var data = this.graphicsData[i2];\n      var shape = data.shape;\n      var type = data.type;\n      var lineStyle = data.lineStyle;\n      var nextMatrix = data.matrix || Matrix.IDENTITY;\n      var lineWidth = 0;\n      if (lineStyle && lineStyle.visible) {\n        lineWidth = lineStyle.width;\n        if (type !== SHAPES.POLY || data.fillStyle.visible) {\n          lineWidth *= Math.max(0, lineStyle.alignment);\n        } else {\n          lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);\n        }\n      }\n      if (curMatrix !== nextMatrix) {\n        if (!sequenceBounds.isEmpty()) {\n          bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n          sequenceBounds.clear();\n        }\n        curMatrix = nextMatrix;\n      }\n      if (type === SHAPES.RECT || type === SHAPES.RREC) {\n        var rect = shape;\n        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);\n      } else if (type === SHAPES.CIRC) {\n        var circle = shape;\n        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);\n      } else if (type === SHAPES.ELIP) {\n        var ellipse = shape;\n        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);\n      } else {\n        var poly = shape;\n        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);\n      }\n    }\n    if (!sequenceBounds.isEmpty()) {\n      bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n    }\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {\n    for (var i2 = 0; i2 < points.length / 2; i2++) {\n      var x2 = points[i2 * 2];\n      var y2 = points[i2 * 2 + 1];\n      points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;\n      points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;\n    }\n  };\n  GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset2) {\n    if (offset2 === void 0) {\n      offset2 = 0;\n    }\n    var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n    var rgba = premultiplyTint(rgb, alpha);\n    colors.length = Math.max(colors.length, offset2 + size);\n    for (var i2 = 0; i2 < size; i2++) {\n      colors[offset2 + i2] = rgba;\n    }\n  };\n  GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset2) {\n    if (offset2 === void 0) {\n      offset2 = 0;\n    }\n    textureIds.length = Math.max(textureIds.length, offset2 + size);\n    for (var i2 = 0; i2 < size; i2++) {\n      textureIds[offset2 + i2] = id;\n    }\n  };\n  GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start2, size, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n    while (index < size) {\n      var x2 = verts[(start2 + index) * 2];\n      var y2 = verts[(start2 + index) * 2 + 1];\n      if (matrix) {\n        var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;\n        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;\n        x2 = nx;\n      }\n      index++;\n      uvs.push(x2 / frame.width, y2 / frame.height);\n    }\n    var baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start2, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start2 + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start2] + eps);\n    var minY = Math.floor(uvs[start2 + 1] + eps);\n    for (var i2 = start2 + 2; i2 < finish; i2 += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i2] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (var i2 = start2; i2 < finish; i2 += 2) {\n      uvs[i2] = (uvs[i2] + offsetX) * scaleX;\n      uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;\n    }\n  };\n  GraphicsGeometry2.BATCHABLE_SIZE = 100;\n  return GraphicsGeometry2;\n}(BatchGeometry);\nvar LineStyle = function(_super) {\n  __extends$l(LineStyle2, _super);\n  function LineStyle2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.width = 0;\n    _this.alignment = 0.5;\n    _this.native = false;\n    _this.cap = LINE_CAP.BUTT;\n    _this.join = LINE_JOIN.MITER;\n    _this.miterLimit = 10;\n    return _this;\n  }\n  LineStyle2.prototype.clone = function() {\n    var obj = new LineStyle2();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  };\n  LineStyle2.prototype.reset = function() {\n    _super.prototype.reset.call(this);\n    this.color = 0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  };\n  return LineStyle2;\n}(FillStyle);\nvar temp = new Float32Array(3);\nvar DEFAULT_SHADERS = {};\nvar Graphics = function(_super) {\n  __extends$l(Graphics2, _super);\n  function Graphics2(geometry) {\n    if (geometry === void 0) {\n      geometry = null;\n    }\n    var _this = _super.call(this) || this;\n    _this.shader = null;\n    _this.pluginName = \"batch\";\n    _this.currentPath = null;\n    _this.batches = [];\n    _this.batchTint = -1;\n    _this.batchDirty = -1;\n    _this.vertexData = null;\n    _this._fillStyle = new FillStyle();\n    _this._lineStyle = new LineStyle();\n    _this._matrix = null;\n    _this._holeMode = false;\n    _this.state = State.for2d();\n    _this._geometry = geometry || new GraphicsGeometry();\n    _this._geometry.refCount++;\n    _this._transformID = -1;\n    _this.tint = 16777215;\n    _this.blendMode = BLEND_MODES$3.NORMAL;\n    return _this;\n  }\n  Object.defineProperty(Graphics2.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Graphics2.prototype.clone = function() {\n    this.finishPoly();\n    return new Graphics2(this._geometry);\n  };\n  Object.defineProperty(Graphics2.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(value2) {\n      this.state.blendMode = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics2.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(value2) {\n      this._tint = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics2.prototype, \"fill\", {\n    get: function() {\n      return this._fillStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics2.prototype, \"line\", {\n    get: function() {\n      return this._lineStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {\n    if (options === void 0) {\n      options = null;\n    }\n    if (color === void 0) {\n      color = 0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    if (alignment === void 0) {\n      alignment = 0.5;\n    }\n    if (native === void 0) {\n      native = false;\n    }\n    if (typeof options === \"number\") {\n      options = { width: options, color, alpha, alignment, native };\n    }\n    return this.lineTextureStyle(options);\n  };\n  Graphics2.prototype.lineTextureStyle = function(options) {\n    options = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: options && options.texture ? 16777215 : 0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, { visible }, options);\n    }\n    return this;\n  };\n  Graphics2.prototype.startPoly = function() {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  Graphics2.prototype.finishPoly = function() {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  Graphics2.prototype.moveTo = function(x2, y2) {\n    this.startPoly();\n    this.currentPath.points[0] = x2;\n    this.currentPath.points[1] = y2;\n    return this;\n  };\n  Graphics2.prototype.lineTo = function(x2, y2) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    if (fromX !== x2 || fromY !== y2) {\n      points.push(x2, y2);\n    }\n    return this;\n  };\n  Graphics2.prototype._initCurve = function(x2, y2) {\n    if (x2 === void 0) {\n      x2 = 0;\n    }\n    if (y2 === void 0) {\n      y2 = 0;\n    }\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x2, y2];\n      }\n    } else {\n      this.moveTo(x2, y2);\n    }\n  };\n  Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {\n    this._initCurve();\n    var points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  };\n  Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) {\n      anticlockwise = false;\n    }\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n    var sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this._geometry.closePointEps;\n    var points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps)\n        ;\n      else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  Graphics2.prototype.beginFill = function(color, alpha) {\n    if (color === void 0) {\n      color = 0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n  };\n  Graphics2.prototype.beginTextureFill = function(options) {\n    options = Object.assign({\n      texture: Texture.WHITE,\n      color: 16777215,\n      alpha: 1,\n      matrix: null\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, { visible }, options);\n    }\n    return this;\n  };\n  Graphics2.prototype.endFill = function() {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  };\n  Graphics2.prototype.drawRect = function(x2, y2, width, height) {\n    return this.drawShape(new Rectangle(x2, y2, width, height));\n  };\n  Graphics2.prototype.drawRoundedRect = function(x2, y2, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));\n  };\n  Graphics2.prototype.drawCircle = function(x2, y2, radius) {\n    return this.drawShape(new Circle(x2, y2, radius));\n  };\n  Graphics2.prototype.drawEllipse = function(x2, y2, width, height) {\n    return this.drawShape(new Ellipse(x2, y2, width, height));\n  };\n  Graphics2.prototype.drawPolygon = function() {\n    var arguments$1 = arguments;\n    var path = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      path[_i] = arguments$1[_i];\n    }\n    var points;\n    var closeStroke = true;\n    var poly = path[0];\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    var shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  Graphics2.prototype.drawShape = function(shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  };\n  Graphics2.prototype.clear = function() {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  Graphics2.prototype.isFastRect = function() {\n    var data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  };\n  Graphics2.prototype._render = function(renderer) {\n    this.finishPoly();\n    var geometry = this._geometry;\n    var hasuint32 = renderer.context.supports.uint32Indices;\n    geometry.updateBatches(hasuint32);\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  };\n  Graphics2.prototype._populateBatches = function() {\n    var geometry = this._geometry;\n    var blendMode = this.blendMode;\n    var len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (var i2 = 0; i2 < len; i2++) {\n      var gI = geometry.batches[i2];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData,\n        blendMode,\n        indices: indices2,\n        uvs,\n        _batchRGB: hex2rgb(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i2] = batch;\n    }\n  };\n  Graphics2.prototype._renderBatched = function(renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (var i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {\n      var batch = this.batches[i2];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  Graphics2.prototype._renderDirect = function(renderer) {\n    var shader = this._resolveDirectShader(renderer);\n    var geometry = this._geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls;\n    uniforms.translationMatrix = this.transform.worldTransform;\n    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    renderer.state.set(this.state);\n    for (var i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);\n    }\n  };\n  Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {\n    var texArray = drawCall.texArray, type = drawCall.type, size = drawCall.size, start2 = drawCall.start;\n    var groupTextureCount = texArray.count;\n    for (var j2 = 0; j2 < groupTextureCount; j2++) {\n      renderer.texture.bind(texArray.elements[j2], j2);\n    }\n    renderer.geometry.draw(type, size, start2);\n  };\n  Graphics2.prototype._resolveDirectShader = function(renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n    if (!shader) {\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;\n        var sampleValues = new Int32Array(MAX_TEXTURES);\n        for (var i2 = 0; i2 < MAX_TEXTURES; i2++) {\n          sampleValues[i2] = i2;\n        }\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: sampleValues }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  };\n  Graphics2.prototype._calculateBounds = function() {\n    this.finishPoly();\n    var geometry = this._geometry;\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    var _a3 = geometry.bounds, minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  Graphics2.prototype.containsPoint = function(point) {\n    this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);\n    return this._geometry.containsPoint(Graphics2._TEMP_POINT);\n  };\n  Graphics2.prototype.calculateTints = function() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = hex2rgb(this.tint, temp);\n      for (var i2 = 0; i2 < this.batches.length; i2++) {\n        var batch = this.batches[i2];\n        var batchTint = batch._batchRGB;\n        var r2 = tintRGB[0] * batchTint[0] * 255;\n        var g2 = tintRGB[1] * batchTint[1] * 255;\n        var b2 = tintRGB[2] * batchTint[2] * 255;\n        var color = (r2 << 16) + (g2 << 8) + (b2 | 0);\n        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n      }\n    }\n  };\n  Graphics2.prototype.calculateVertices = function() {\n    var wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    var wt = this.transform.worldTransform;\n    var a2 = wt.a;\n    var b2 = wt.b;\n    var c2 = wt.c;\n    var d2 = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this._geometry.points;\n    var vertexData = this.vertexData;\n    var count = 0;\n    for (var i2 = 0; i2 < data.length; i2 += 2) {\n      var x2 = data[i2];\n      var y2 = data[i2 + 1];\n      vertexData[count++] = a2 * x2 + c2 * y2 + tx;\n      vertexData[count++] = d2 * y2 + b2 * x2 + ty;\n    }\n  };\n  Graphics2.prototype.closePath = function() {\n    var currentPath = this.currentPath;\n    if (currentPath) {\n      currentPath.closeStroke = true;\n      this.finishPoly();\n    }\n    return this;\n  };\n  Graphics2.prototype.setMatrix = function(matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  Graphics2.prototype.beginHole = function() {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  Graphics2.prototype.endHole = function() {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  Graphics2.prototype.destroy = function(options) {\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    _super.prototype.destroy.call(this, options);\n  };\n  Graphics2.nextRoundedRectBehavior = false;\n  Graphics2._TEMP_POINT = new Point();\n  return Graphics2;\n}(Container);\n/*!\n * @pixi/sprite - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$k = function(d2, b2) {\n  extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$k(d2, b2);\n};\nfunction __extends$k(d2, b2) {\n  extendStatics$k(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar tempPoint$2 = new Point();\nvar indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nvar Sprite = function(_super) {\n  __extends$k(Sprite2, _super);\n  function Sprite2(texture) {\n    var _this = _super.call(this) || this;\n    _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);\n    _this._texture = null;\n    _this._width = 0;\n    _this._height = 0;\n    _this._tint = null;\n    _this._tintRGB = null;\n    _this.tint = 16777215;\n    _this.blendMode = BLEND_MODES$3.NORMAL;\n    _this._cachedTint = 16777215;\n    _this.uvs = null;\n    _this.texture = texture || Texture.EMPTY;\n    _this.vertexData = new Float32Array(8);\n    _this.vertexTrimmedData = null;\n    _this._transformID = -1;\n    _this._textureID = -1;\n    _this._transformTrimmedID = -1;\n    _this._textureTrimmedID = -1;\n    _this.indices = indices;\n    _this.pluginName = \"batch\";\n    _this.isSprite = true;\n    _this._roundPixels = settings.ROUND_PIXELS;\n    return _this;\n  }\n  Sprite2.prototype._onTextureUpdate = function() {\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    if (this._width) {\n      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;\n    }\n    if (this._height) {\n      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;\n    }\n  };\n  Sprite2.prototype._onAnchorUpdate = function() {\n    this._transformID = -1;\n    this._transformTrimmedID = -1;\n  };\n  Sprite2.prototype.calculateVertices = function() {\n    var texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n      return;\n    }\n    if (this._textureID !== texture._updateID) {\n      this.uvs = this._texture._uvs.uvsFloat32;\n    }\n    this._transformID = this.transform._worldID;\n    this._textureID = texture._updateID;\n    var wt = this.transform.worldTransform;\n    var a2 = wt.a;\n    var b2 = wt.b;\n    var c2 = wt.c;\n    var d2 = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var vertexData = this.vertexData;\n    var trim2 = texture.trim;\n    var orig = texture.orig;\n    var anchor = this._anchor;\n    var w0 = 0;\n    var w1 = 0;\n    var h0 = 0;\n    var h1 = 0;\n    if (trim2) {\n      w1 = trim2.x - anchor._x * orig.width;\n      w0 = w1 + trim2.width;\n      h1 = trim2.y - anchor._y * orig.height;\n      h0 = h1 + trim2.height;\n    } else {\n      w1 = -anchor._x * orig.width;\n      w0 = w1 + orig.width;\n      h1 = -anchor._y * orig.height;\n      h0 = h1 + orig.height;\n    }\n    vertexData[0] = a2 * w1 + c2 * h1 + tx;\n    vertexData[1] = d2 * h1 + b2 * w1 + ty;\n    vertexData[2] = a2 * w0 + c2 * h1 + tx;\n    vertexData[3] = d2 * h1 + b2 * w0 + ty;\n    vertexData[4] = a2 * w0 + c2 * h0 + tx;\n    vertexData[5] = d2 * h0 + b2 * w0 + ty;\n    vertexData[6] = a2 * w1 + c2 * h0 + tx;\n    vertexData[7] = d2 * h0 + b2 * w1 + ty;\n    if (this._roundPixels) {\n      var resolution = settings.RESOLUTION;\n      for (var i2 = 0; i2 < vertexData.length; ++i2) {\n        vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);\n      }\n    }\n  };\n  Sprite2.prototype.calculateTrimmedVertices = function() {\n    if (!this.vertexTrimmedData) {\n      this.vertexTrimmedData = new Float32Array(8);\n    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n      return;\n    }\n    this._transformTrimmedID = this.transform._worldID;\n    this._textureTrimmedID = this._texture._updateID;\n    var texture = this._texture;\n    var vertexData = this.vertexTrimmedData;\n    var orig = texture.orig;\n    var anchor = this._anchor;\n    var wt = this.transform.worldTransform;\n    var a2 = wt.a;\n    var b2 = wt.b;\n    var c2 = wt.c;\n    var d2 = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var w1 = -anchor._x * orig.width;\n    var w0 = w1 + orig.width;\n    var h1 = -anchor._y * orig.height;\n    var h0 = h1 + orig.height;\n    vertexData[0] = a2 * w1 + c2 * h1 + tx;\n    vertexData[1] = d2 * h1 + b2 * w1 + ty;\n    vertexData[2] = a2 * w0 + c2 * h1 + tx;\n    vertexData[3] = d2 * h1 + b2 * w0 + ty;\n    vertexData[4] = a2 * w0 + c2 * h0 + tx;\n    vertexData[5] = d2 * h0 + b2 * w0 + ty;\n    vertexData[6] = a2 * w1 + c2 * h0 + tx;\n    vertexData[7] = d2 * h0 + b2 * w1 + ty;\n  };\n  Sprite2.prototype._render = function(renderer) {\n    this.calculateVertices();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  Sprite2.prototype._calculateBounds = function() {\n    var trim2 = this._texture.trim;\n    var orig = this._texture.orig;\n    if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    } else {\n      this.calculateTrimmedVertices();\n      this._bounds.addQuad(this.vertexTrimmedData);\n    }\n  };\n  Sprite2.prototype.getLocalBounds = function(rect) {\n    if (this.children.length === 0) {\n      if (!this._localBounds) {\n        this._localBounds = new Bounds();\n      }\n      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._localBounds.getRectangle(rect);\n    }\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  Sprite2.prototype.containsPoint = function(point) {\n    this.worldTransform.applyInverse(point, tempPoint$2);\n    var width = this._texture.orig.width;\n    var height = this._texture.orig.height;\n    var x1 = -width * this.anchor.x;\n    var y1 = 0;\n    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Sprite2.prototype.destroy = function(options) {\n    _super.prototype.destroy.call(this, options);\n    this._texture.off(\"update\", this._onTextureUpdate, this);\n    this._anchor = null;\n    var destroyTexture = typeof options === \"boolean\" ? options : options && options.texture;\n    if (destroyTexture) {\n      var destroyBaseTexture = typeof options === \"boolean\" ? options : options && options.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  };\n  Sprite2.from = function(source, options) {\n    var texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new Sprite2(texture);\n  };\n  Object.defineProperty(Sprite2.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(value2) {\n      if (this._roundPixels !== value2) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite2.prototype, \"width\", {\n    get: function() {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(value2) {\n      var s2 = sign(this.scale.x) || 1;\n      this.scale.x = s2 * value2 / this._texture.orig.width;\n      this._width = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite2.prototype, \"height\", {\n    get: function() {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(value2) {\n      var s2 = sign(this.scale.y) || 1;\n      this.scale.y = s2 * value2 / this._texture.orig.height;\n      this._height = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite2.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(value2) {\n      this._anchor.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite2.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(value2) {\n      this._tint = value2;\n      this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite2.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(value2) {\n      if (this._texture === value2) {\n        return;\n      }\n      if (this._texture) {\n        this._texture.off(\"update\", this._onTextureUpdate, this);\n      }\n      this._texture = value2 || Texture.EMPTY;\n      this._cachedTint = 16777215;\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      if (value2) {\n        if (value2.baseTexture.valid) {\n          this._onTextureUpdate();\n        } else {\n          value2.once(\"update\", this._onTextureUpdate, this);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Sprite2;\n}(Container);\n/*!\n * @pixi/text - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$j = function(d2, b2) {\n  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$j(d2, b2);\n};\nfunction __extends$j(d2, b2) {\n  extendStatics$j(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar TEXT_GRADIENT;\n(function(TEXT_GRADIENT2) {\n  TEXT_GRADIENT2[TEXT_GRADIENT2[\"LINEAR_VERTICAL\"] = 0] = \"LINEAR_VERTICAL\";\n  TEXT_GRADIENT2[TEXT_GRADIENT2[\"LINEAR_HORIZONTAL\"] = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nvar defaultStyle = {\n  align: \"left\",\n  breakWords: false,\n  dropShadow: false,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: false,\n  whiteSpace: \"pre\",\n  wordWrap: false,\n  wordWrapWidth: 100,\n  leading: 0\n};\nvar genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nvar TextStyle = function() {\n  function TextStyle2(style) {\n    this.styleID = 0;\n    this.reset();\n    deepCopyProperties(this, style, style);\n  }\n  TextStyle2.prototype.clone = function() {\n    var clonedProperties = {};\n    deepCopyProperties(clonedProperties, this, defaultStyle);\n    return new TextStyle2(clonedProperties);\n  };\n  TextStyle2.prototype.reset = function() {\n    deepCopyProperties(this, defaultStyle, defaultStyle);\n  };\n  Object.defineProperty(TextStyle2.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(align) {\n      if (this._align !== align) {\n        this._align = align;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"breakWords\", {\n    get: function() {\n      return this._breakWords;\n    },\n    set: function(breakWords) {\n      if (this._breakWords !== breakWords) {\n        this._breakWords = breakWords;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadow\", {\n    get: function() {\n      return this._dropShadow;\n    },\n    set: function(dropShadow) {\n      if (this._dropShadow !== dropShadow) {\n        this._dropShadow = dropShadow;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadowAlpha\", {\n    get: function() {\n      return this._dropShadowAlpha;\n    },\n    set: function(dropShadowAlpha) {\n      if (this._dropShadowAlpha !== dropShadowAlpha) {\n        this._dropShadowAlpha = dropShadowAlpha;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadowAngle\", {\n    get: function() {\n      return this._dropShadowAngle;\n    },\n    set: function(dropShadowAngle) {\n      if (this._dropShadowAngle !== dropShadowAngle) {\n        this._dropShadowAngle = dropShadowAngle;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadowBlur\", {\n    get: function() {\n      return this._dropShadowBlur;\n    },\n    set: function(dropShadowBlur) {\n      if (this._dropShadowBlur !== dropShadowBlur) {\n        this._dropShadowBlur = dropShadowBlur;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadowColor\", {\n    get: function() {\n      return this._dropShadowColor;\n    },\n    set: function(dropShadowColor) {\n      var outputColor = getColor(dropShadowColor);\n      if (this._dropShadowColor !== outputColor) {\n        this._dropShadowColor = outputColor;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"dropShadowDistance\", {\n    get: function() {\n      return this._dropShadowDistance;\n    },\n    set: function(dropShadowDistance) {\n      if (this._dropShadowDistance !== dropShadowDistance) {\n        this._dropShadowDistance = dropShadowDistance;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fill\", {\n    get: function() {\n      return this._fill;\n    },\n    set: function(fill) {\n      var outputColor = getColor(fill);\n      if (this._fill !== outputColor) {\n        this._fill = outputColor;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fillGradientType\", {\n    get: function() {\n      return this._fillGradientType;\n    },\n    set: function(fillGradientType) {\n      if (this._fillGradientType !== fillGradientType) {\n        this._fillGradientType = fillGradientType;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fillGradientStops\", {\n    get: function() {\n      return this._fillGradientStops;\n    },\n    set: function(fillGradientStops) {\n      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {\n        this._fillGradientStops = fillGradientStops;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fontFamily\", {\n    get: function() {\n      return this._fontFamily;\n    },\n    set: function(fontFamily) {\n      if (this.fontFamily !== fontFamily) {\n        this._fontFamily = fontFamily;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(fontSize) {\n      if (this._fontSize !== fontSize) {\n        this._fontSize = fontSize;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fontStyle\", {\n    get: function() {\n      return this._fontStyle;\n    },\n    set: function(fontStyle) {\n      if (this._fontStyle !== fontStyle) {\n        this._fontStyle = fontStyle;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fontVariant\", {\n    get: function() {\n      return this._fontVariant;\n    },\n    set: function(fontVariant) {\n      if (this._fontVariant !== fontVariant) {\n        this._fontVariant = fontVariant;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"fontWeight\", {\n    get: function() {\n      return this._fontWeight;\n    },\n    set: function(fontWeight) {\n      if (this._fontWeight !== fontWeight) {\n        this._fontWeight = fontWeight;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(letterSpacing) {\n      if (this._letterSpacing !== letterSpacing) {\n        this._letterSpacing = letterSpacing;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"lineHeight\", {\n    get: function() {\n      return this._lineHeight;\n    },\n    set: function(lineHeight) {\n      if (this._lineHeight !== lineHeight) {\n        this._lineHeight = lineHeight;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"leading\", {\n    get: function() {\n      return this._leading;\n    },\n    set: function(leading) {\n      if (this._leading !== leading) {\n        this._leading = leading;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"lineJoin\", {\n    get: function() {\n      return this._lineJoin;\n    },\n    set: function(lineJoin) {\n      if (this._lineJoin !== lineJoin) {\n        this._lineJoin = lineJoin;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"miterLimit\", {\n    get: function() {\n      return this._miterLimit;\n    },\n    set: function(miterLimit) {\n      if (this._miterLimit !== miterLimit) {\n        this._miterLimit = miterLimit;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"padding\", {\n    get: function() {\n      return this._padding;\n    },\n    set: function(padding) {\n      if (this._padding !== padding) {\n        this._padding = padding;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"stroke\", {\n    get: function() {\n      return this._stroke;\n    },\n    set: function(stroke) {\n      var outputColor = getColor(stroke);\n      if (this._stroke !== outputColor) {\n        this._stroke = outputColor;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"strokeThickness\", {\n    get: function() {\n      return this._strokeThickness;\n    },\n    set: function(strokeThickness) {\n      if (this._strokeThickness !== strokeThickness) {\n        this._strokeThickness = strokeThickness;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"textBaseline\", {\n    get: function() {\n      return this._textBaseline;\n    },\n    set: function(textBaseline) {\n      if (this._textBaseline !== textBaseline) {\n        this._textBaseline = textBaseline;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"trim\", {\n    get: function() {\n      return this._trim;\n    },\n    set: function(trim2) {\n      if (this._trim !== trim2) {\n        this._trim = trim2;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"whiteSpace\", {\n    get: function() {\n      return this._whiteSpace;\n    },\n    set: function(whiteSpace) {\n      if (this._whiteSpace !== whiteSpace) {\n        this._whiteSpace = whiteSpace;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"wordWrap\", {\n    get: function() {\n      return this._wordWrap;\n    },\n    set: function(wordWrap) {\n      if (this._wordWrap !== wordWrap) {\n        this._wordWrap = wordWrap;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextStyle2.prototype, \"wordWrapWidth\", {\n    get: function() {\n      return this._wordWrapWidth;\n    },\n    set: function(wordWrapWidth) {\n      if (this._wordWrapWidth !== wordWrapWidth) {\n        this._wordWrapWidth = wordWrapWidth;\n        this.styleID++;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TextStyle2.prototype.toFontString = function() {\n    var fontSizeString = typeof this.fontSize === \"number\" ? this.fontSize + \"px\" : this.fontSize;\n    var fontFamilies = this.fontFamily;\n    if (!Array.isArray(this.fontFamily)) {\n      fontFamilies = this.fontFamily.split(\",\");\n    }\n    for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {\n      var fontFamily = fontFamilies[i2].trim();\n      if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {\n        fontFamily = '\"' + fontFamily + '\"';\n      }\n      fontFamilies[i2] = fontFamily;\n    }\n    return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + fontSizeString + \" \" + fontFamilies.join(\",\");\n  };\n  return TextStyle2;\n}();\nfunction getSingleColor(color) {\n  if (typeof color === \"number\") {\n    return hex2string(color);\n  } else if (typeof color === \"string\") {\n    if (color.indexOf(\"0x\") === 0) {\n      color = color.replace(\"0x\", \"#\");\n    }\n  }\n  return color;\n}\nfunction getColor(color) {\n  if (!Array.isArray(color)) {\n    return getSingleColor(color);\n  } else {\n    for (var i2 = 0; i2 < color.length; ++i2) {\n      color[i2] = getSingleColor(color[i2]);\n    }\n    return color;\n  }\n}\nfunction areArraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    return false;\n  }\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (var i2 = 0; i2 < array1.length; ++i2) {\n    if (array1[i2] !== array2[i2]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepCopyProperties(target, source, propertyObj) {\n  for (var prop in propertyObj) {\n    if (Array.isArray(source[prop])) {\n      target[prop] = source[prop].slice();\n    } else {\n      target[prop] = source[prop];\n    }\n  }\n}\nvar TextMetrics = function() {\n  function TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text2;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  TextMetrics2.measureText = function(text2, style, wordWrap, canvas) {\n    if (canvas === void 0) {\n      canvas = TextMetrics2._canvas;\n    }\n    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;\n    var font = style.toFontString();\n    var fontProperties = TextMetrics2.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    var context2 = canvas.getContext(\"2d\");\n    context2.font = font;\n    var outputText = wordWrap ? TextMetrics2.wordWrap(text2, style, canvas) : text2;\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    var lineWidths = new Array(lines.length);\n    var maxLineWidth = 0;\n    for (var i2 = 0; i2 < lines.length; i2++) {\n      var lineWidth = context2.measureText(lines[i2]).width + (lines[i2].length - 1) * style.letterSpacing;\n      lineWidths[i2] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    var width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n    return new TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n  };\n  TextMetrics2.wordWrap = function(text2, style, canvas) {\n    if (canvas === void 0) {\n      canvas = TextMetrics2._canvas;\n    }\n    var context2 = canvas.getContext(\"2d\");\n    var width = 0;\n    var line = \"\";\n    var lines = \"\";\n    var cache2 = /* @__PURE__ */ Object.create(null);\n    var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;\n    var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);\n    var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);\n    var canPrependSpaces = !collapseSpaces;\n    var wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    var tokens = TextMetrics2.tokenize(text2);\n    for (var i2 = 0; i2 < tokens.length; i2++) {\n      var token = tokens[i2];\n      if (TextMetrics2.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += TextMetrics2.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);\n        var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache2, context2);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += TextMetrics2.addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (TextMetrics2.canBreakWords(token, style.breakWords)) {\n          var characters = TextMetrics2.wordWrapSplit(token);\n          for (var j2 = 0; j2 < characters.length; j2++) {\n            var char = characters[j2];\n            var k = 1;\n            while (characters[j2 + k]) {\n              var nextChar = characters[j2 + k];\n              var lastChar = char[char.length - 1];\n              if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              k++;\n            }\n            j2 += char.length - 1;\n            var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache2, context2);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += TextMetrics2.addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += TextMetrics2.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          var isLastToken = i2 === tokens.length - 1;\n          lines += TextMetrics2.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += TextMetrics2.addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += TextMetrics2.addLine(line, false);\n    return lines;\n  };\n  TextMetrics2.addLine = function(line, newLine) {\n    if (newLine === void 0) {\n      newLine = true;\n    }\n    line = TextMetrics2.trimRight(line);\n    line = newLine ? line + \"\\n\" : line;\n    return line;\n  };\n  TextMetrics2.getFromCache = function(key, letterSpacing, cache2, context2) {\n    var width = cache2[key];\n    if (typeof width !== \"number\") {\n      var spacing = key.length * letterSpacing;\n      width = context2.measureText(key).width + spacing;\n      cache2[key] = width;\n    }\n    return width;\n  };\n  TextMetrics2.collapseSpaces = function(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  };\n  TextMetrics2.collapseNewlines = function(whiteSpace) {\n    return whiteSpace === \"normal\";\n  };\n  TextMetrics2.trimRight = function(text2) {\n    if (typeof text2 !== \"string\") {\n      return \"\";\n    }\n    for (var i2 = text2.length - 1; i2 >= 0; i2--) {\n      var char = text2[i2];\n      if (!TextMetrics2.isBreakingSpace(char)) {\n        break;\n      }\n      text2 = text2.slice(0, -1);\n    }\n    return text2;\n  };\n  TextMetrics2.isNewline = function(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;\n  };\n  TextMetrics2.isBreakingSpace = function(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;\n  };\n  TextMetrics2.tokenize = function(text2) {\n    var tokens = [];\n    var token = \"\";\n    if (typeof text2 !== \"string\") {\n      return tokens;\n    }\n    for (var i2 = 0; i2 < text2.length; i2++) {\n      var char = text2[i2];\n      var nextChar = text2[i2 + 1];\n      if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  };\n  TextMetrics2.canBreakWords = function(_token, breakWords) {\n    return breakWords;\n  };\n  TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  };\n  TextMetrics2.wordWrapSplit = function(token) {\n    return token.split(\"\");\n  };\n  TextMetrics2.measureFont = function(font) {\n    if (TextMetrics2._fonts[font]) {\n      return TextMetrics2._fonts[font];\n    }\n    var properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    };\n    var canvas = TextMetrics2._canvas;\n    var context2 = TextMetrics2._context;\n    context2.font = font;\n    var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;\n    var width = Math.ceil(context2.measureText(metricsString).width);\n    var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);\n    var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);\n    baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;\n    canvas.width = width;\n    canvas.height = height;\n    context2.fillStyle = \"#f00\";\n    context2.fillRect(0, 0, width, height);\n    context2.font = font;\n    context2.textBaseline = \"alphabetic\";\n    context2.fillStyle = \"#000\";\n    context2.fillText(metricsString, 0, baseline);\n    var imagedata = context2.getImageData(0, 0, width, height).data;\n    var pixels = imagedata.length;\n    var line = width * 4;\n    var i2 = 0;\n    var idx = 0;\n    var stop = false;\n    for (i2 = 0; i2 < baseline; ++i2) {\n      for (var j2 = 0; j2 < line; j2 += 4) {\n        if (imagedata[idx + j2] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n    properties.ascent = baseline - i2;\n    idx = pixels - line;\n    stop = false;\n    for (i2 = height; i2 > baseline; --i2) {\n      for (var j2 = 0; j2 < line; j2 += 4) {\n        if (imagedata[idx + j2] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n    properties.descent = i2 - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    TextMetrics2._fonts[font] = properties;\n    return properties;\n  };\n  TextMetrics2.clearMetrics = function(font) {\n    if (font === void 0) {\n      font = \"\";\n    }\n    if (font) {\n      delete TextMetrics2._fonts[font];\n    } else {\n      TextMetrics2._fonts = {};\n    }\n  };\n  Object.defineProperty(TextMetrics2, \"_canvas\", {\n    get: function() {\n      if (!TextMetrics2.__canvas) {\n        var canvas = void 0;\n        try {\n          var c2 = new OffscreenCanvas(0, 0);\n          var context2 = c2.getContext(\"2d\");\n          if (context2 && context2.measureText) {\n            TextMetrics2.__canvas = c2;\n            return c2;\n          }\n          canvas = document.createElement(\"canvas\");\n        } catch (ex) {\n          canvas = document.createElement(\"canvas\");\n        }\n        canvas.width = canvas.height = 10;\n        TextMetrics2.__canvas = canvas;\n      }\n      return TextMetrics2.__canvas;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextMetrics2, \"_context\", {\n    get: function() {\n      if (!TextMetrics2.__context) {\n        TextMetrics2.__context = TextMetrics2._canvas.getContext(\"2d\");\n      }\n      return TextMetrics2.__context;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TextMetrics2;\n}();\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nvar Text = function(_super) {\n  __extends$j(Text2, _super);\n  function Text2(text2, style, canvas) {\n    var _this = this;\n    var ownCanvas = false;\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\");\n      ownCanvas = true;\n    }\n    canvas.width = 3;\n    canvas.height = 3;\n    var texture = Texture.from(canvas);\n    texture.orig = new Rectangle();\n    texture.trim = new Rectangle();\n    _this = _super.call(this, texture) || this;\n    _this._ownCanvas = ownCanvas;\n    _this.canvas = canvas;\n    _this.context = _this.canvas.getContext(\"2d\");\n    _this._resolution = settings.RESOLUTION;\n    _this._autoResolution = true;\n    _this._text = null;\n    _this._style = null;\n    _this._styleListener = null;\n    _this._font = \"\";\n    _this.text = text2;\n    _this.style = style;\n    _this.localStyleID = -1;\n    return _this;\n  }\n  Text2.prototype.updateText = function(respectDirty) {\n    var style = this._style;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    this._font = this._style.toFontString();\n    var context2 = this.context;\n    var measured = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas);\n    var width = measured.width;\n    var height = measured.height;\n    var lines = measured.lines;\n    var lineHeight = measured.lineHeight;\n    var lineWidths = measured.lineWidths;\n    var maxLineWidth = measured.maxLineWidth;\n    var fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);\n    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);\n    context2.scale(this._resolution, this._resolution);\n    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    context2.font = this._font;\n    context2.lineWidth = style.strokeThickness;\n    context2.textBaseline = style.textBaseline;\n    context2.lineJoin = style.lineJoin;\n    context2.miterLimit = style.miterLimit;\n    var linePositionX;\n    var linePositionY;\n    var passesCount = style.dropShadow ? 2 : 1;\n    for (var i2 = 0; i2 < passesCount; ++i2) {\n      var isShadowPass = style.dropShadow && i2 === 0;\n      var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      var dsOffsetShadow = dsOffsetText * this._resolution;\n      if (isShadowPass) {\n        context2.fillStyle = \"black\";\n        context2.strokeStyle = \"black\";\n        var dropShadowColor = style.dropShadowColor;\n        var rgb = hex2rgb(typeof dropShadowColor === \"number\" ? dropShadowColor : string2hex(dropShadowColor));\n        var dropShadowBlur = style.dropShadowBlur * this._resolution;\n        var dropShadowDistance = style.dropShadowDistance * this._resolution;\n        context2.shadowColor = \"rgba(\" + rgb[0] * 255 + \",\" + rgb[1] * 255 + \",\" + rgb[2] * 255 + \",\" + style.dropShadowAlpha + \")\";\n        context2.shadowBlur = dropShadowBlur;\n        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context2.fillStyle = this._generateFillStyle(style, lines, measured);\n        context2.strokeStyle = style.stroke;\n        context2.shadowColor = \"black\";\n        context2.shadowBlur = 0;\n        context2.shadowOffsetX = 0;\n        context2.shadowOffsetY = 0;\n      }\n      var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      for (var i_1 = 0; i_1 < lines.length; i_1++) {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i_1];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;\n        }\n        if (style.stroke && style.strokeThickness) {\n          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n        }\n        if (style.fill) {\n          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n        }\n      }\n    }\n    this.updateTexture();\n  };\n  Text2.prototype.drawLetterSpacing = function(text2, x2, y2, isStroke) {\n    if (isStroke === void 0) {\n      isStroke = false;\n    }\n    var style = this._style;\n    var letterSpacing = style.letterSpacing;\n    var supportLetterSpacing = Text2.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n    if (letterSpacing === 0 || supportLetterSpacing) {\n      if (supportLetterSpacing) {\n        this.context.letterSpacing = letterSpacing;\n        this.context.textLetterSpacing = letterSpacing;\n      }\n      if (isStroke) {\n        this.context.strokeText(text2, x2, y2);\n      } else {\n        this.context.fillText(text2, x2, y2);\n      }\n      return;\n    }\n    var currentPosition = x2;\n    var stringArray = Array.from ? Array.from(text2) : text2.split(\"\");\n    var previousWidth = this.context.measureText(text2).width;\n    var currentWidth = 0;\n    for (var i2 = 0; i2 < stringArray.length; ++i2) {\n      var currentChar = stringArray[i2];\n      if (isStroke) {\n        this.context.strokeText(currentChar, currentPosition, y2);\n      } else {\n        this.context.fillText(currentChar, currentPosition, y2);\n      }\n      var textStr = \"\";\n      for (var j2 = i2 + 1; j2 < stringArray.length; ++j2) {\n        textStr += stringArray[j2];\n      }\n      currentWidth = this.context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  };\n  Text2.prototype.updateTexture = function() {\n    var canvas = this.canvas;\n    if (this._style.trim) {\n      var trimmed = trimCanvas(canvas);\n      if (trimmed.data) {\n        canvas.width = trimmed.width;\n        canvas.height = trimmed.height;\n        this.context.putImageData(trimmed.data, 0, 0);\n      }\n    }\n    var texture = this._texture;\n    var style = this._style;\n    var padding = style.trim ? 0 : style.padding;\n    var baseTexture = texture.baseTexture;\n    texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n    texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n    texture.updateUvs();\n    this._recursivePostUpdateTransform();\n    this.dirty = false;\n  };\n  Text2.prototype._render = function(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    _super.prototype._render.call(this, renderer);\n  };\n  Text2.prototype.getLocalBounds = function(rect) {\n    this.updateText(true);\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  Text2.prototype._calculateBounds = function() {\n    this.updateText(true);\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  };\n  Text2.prototype._generateFillStyle = function(style, lines, metrics) {\n    var fillStyle = style.fill;\n    if (!Array.isArray(fillStyle)) {\n      return fillStyle;\n    } else if (fillStyle.length === 1) {\n      return fillStyle[0];\n    }\n    var gradient;\n    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n    var padding = style.padding || 0;\n    var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;\n    var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;\n    var fill = fillStyle.slice();\n    var fillGradientStops = style.fillGradientStops.slice();\n    if (!fillGradientStops.length) {\n      var lengthPlus1 = fill.length + 1;\n      for (var i2 = 1; i2 < lengthPlus1; ++i2) {\n        fillGradientStops.push(i2 / lengthPlus1);\n      }\n    }\n    fill.unshift(fillStyle[0]);\n    fillGradientStops.unshift(0);\n    fill.push(fillStyle[fillStyle.length - 1]);\n    fillGradientStops.push(1);\n    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n      for (var i2 = 0; i2 < lines.length; i2++) {\n        var lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight;\n        var thisLineTop = metrics.lineHeight * i2;\n        var thisLineGradientStart = thisLineTop;\n        if (i2 > 0 && lastLineBottom > thisLineTop) {\n          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n        }\n        var thisLineBottom = thisLineTop + textHeight;\n        var nextLineTop = metrics.lineHeight * (i2 + 1);\n        var thisLineGradientEnd = thisLineBottom;\n        if (i2 + 1 < lines.length && nextLineTop < thisLineBottom) {\n          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n        }\n        var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n        for (var j2 = 0; j2 < fill.length; j2++) {\n          var lineStop = 0;\n          if (typeof fillGradientStops[j2] === \"number\") {\n            lineStop = fillGradientStops[j2];\n          } else {\n            lineStop = j2 / fill.length;\n          }\n          var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n          globalStop = Number(globalStop.toFixed(5));\n          gradient.addColorStop(globalStop, fill[j2]);\n        }\n      }\n    } else {\n      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n      var totalIterations = fill.length + 1;\n      var currentIteration = 1;\n      for (var i2 = 0; i2 < fill.length; i2++) {\n        var stop = void 0;\n        if (typeof fillGradientStops[i2] === \"number\") {\n          stop = fillGradientStops[i2];\n        } else {\n          stop = currentIteration / totalIterations;\n        }\n        gradient.addColorStop(stop, fill[i2]);\n        currentIteration++;\n      }\n    }\n    return gradient;\n  };\n  Text2.prototype.destroy = function(options) {\n    if (typeof options === \"boolean\") {\n      options = { children: options };\n    }\n    options = Object.assign({}, defaultDestroyOptions, options);\n    _super.prototype.destroy.call(this, options);\n    if (this._ownCanvas) {\n      this.canvas.height = this.canvas.width = 0;\n    }\n    this.context = null;\n    this.canvas = null;\n    this._style = null;\n  };\n  Object.defineProperty(Text2.prototype, \"width\", {\n    get: function() {\n      this.updateText(true);\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(value2) {\n      this.updateText(true);\n      var s2 = sign(this.scale.x) || 1;\n      this.scale.x = s2 * value2 / this._texture.orig.width;\n      this._width = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Text2.prototype, \"height\", {\n    get: function() {\n      this.updateText(true);\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(value2) {\n      this.updateText(true);\n      var s2 = sign(this.scale.y) || 1;\n      this.scale.y = s2 * value2 / this._texture.orig.height;\n      this._height = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Text2.prototype, \"style\", {\n    get: function() {\n      return this._style;\n    },\n    set: function(style) {\n      style = style || {};\n      if (style instanceof TextStyle) {\n        this._style = style;\n      } else {\n        this._style = new TextStyle(style);\n      }\n      this.localStyleID = -1;\n      this.dirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Text2.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(text2) {\n      text2 = String(text2 === null || text2 === void 0 ? \"\" : text2);\n      if (this._text === text2) {\n        return;\n      }\n      this._text = text2;\n      this.dirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Text2.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(value2) {\n      this._autoResolution = false;\n      if (this._resolution === value2) {\n        return;\n      }\n      this._resolution = value2;\n      this.dirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Text2.nextLineHeightBehavior = false;\n  Text2.experimentalLetterSpacing = false;\n  return Text2;\n}(Sprite);\n/*!\n * @pixi/prepare - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.UPLOADS_PER_FRAME = 4;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$i = function(d2, b2) {\n  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$i(d2, b2);\n};\nfunction __extends$i(d2, b2) {\n  extendStatics$i(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar CountLimiter = function() {\n  function CountLimiter2(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame;\n    this.itemsLeft = 0;\n  }\n  CountLimiter2.prototype.beginFrame = function() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  };\n  CountLimiter2.prototype.allowedToUpload = function() {\n    return this.itemsLeft-- > 0;\n  };\n  return CountLimiter2;\n}();\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false;\n  if (item && item._textures && item._textures.length) {\n    for (var i2 = 0; i2 < item._textures.length; i2++) {\n      if (item._textures[i2] instanceof Texture) {\n        var baseTexture = item._textures[i2].baseTexture;\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof BaseTexture) {\n    var texture = item.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof Texture) {\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction drawText(_helper, item) {\n  if (item instanceof Text) {\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof TextStyle) {\n    var font = item.toFontString();\n    TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\nfunction findText(item, queue) {\n  if (item instanceof Text) {\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    }\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTextStyle(item, queue) {\n  if (item instanceof TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\nvar BasePrepare = function() {\n  function BasePrepare2(renderer) {\n    var _this = this;\n    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = function() {\n      if (!_this.queue) {\n        return;\n      }\n      _this.prepareItems();\n    };\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  BasePrepare2.prototype.upload = function(item, done) {\n    if (typeof item === \"function\") {\n      done = item;\n      item = null;\n    }\n    if (item) {\n      this.add(item);\n    }\n    if (this.queue.length) {\n      if (done) {\n        this.completes.push(done);\n      }\n      if (!this.ticking) {\n        this.ticking = true;\n        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n      }\n    } else if (done) {\n      done();\n    }\n  };\n  BasePrepare2.prototype.tick = function() {\n    setTimeout(this.delayedTick, 0);\n  };\n  BasePrepare2.prototype.prepareItems = function() {\n    this.limiter.beginFrame();\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      var item = this.queue[0];\n      var uploaded = false;\n      if (item && !item._destroyed) {\n        for (var i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {\n          if (this.uploadHooks[i2](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n    if (!this.queue.length) {\n      this.ticking = false;\n      var completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var i2 = 0, len = completes.length; i2 < len; i2++) {\n        completes[i2]();\n      }\n    } else {\n      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n    }\n  };\n  BasePrepare2.prototype.registerFindHook = function(addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  };\n  BasePrepare2.prototype.registerUploadHook = function(uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  };\n  BasePrepare2.prototype.add = function(item) {\n    for (var i2 = 0, len = this.addHooks.length; i2 < len; i2++) {\n      if (this.addHooks[i2](item, this.queue)) {\n        break;\n      }\n    }\n    if (item instanceof Container) {\n      for (var i2 = item.children.length - 1; i2 >= 0; i2--) {\n        this.add(item.children[i2]);\n      }\n    }\n    return this;\n  };\n  BasePrepare2.prototype.destroy = function() {\n    if (this.ticking) {\n      Ticker.system.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  };\n  return BasePrepare2;\n}();\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof BaseTexture) {\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics)) {\n    return false;\n  }\n  var geometry = item.geometry;\n  item.finishPoly();\n  geometry.updateBatches();\n  var batches = geometry.batches;\n  for (var i2 = 0; i2 < batches.length; i2++) {\n    var texture = batches[i2].style.texture;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\nfunction findGraphics(item, queue) {\n  if (item instanceof Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\nvar Prepare = function(_super) {\n  __extends$i(Prepare2, _super);\n  function Prepare2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.uploadHookHelper = _this.renderer;\n    _this.registerFindHook(findGraphics);\n    _this.registerUploadHook(uploadBaseTextures);\n    _this.registerUploadHook(uploadGraphics);\n    return _this;\n  }\n  return Prepare2;\n}(BasePrepare);\n/*!\n * @pixi/spritesheet - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Spritesheet = function() {\n  function Spritesheet2(texture, data, resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    this._texture = texture instanceof Texture ? texture : null;\n    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  Spritesheet2.prototype._updateResolution = function(resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    var scale = this.data.meta.scale;\n    var resolution = getResolutionOfUrl(resolutionFilename, null);\n    if (resolution === null) {\n      resolution = scale !== void 0 ? parseFloat(scale) : 1;\n    }\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  };\n  Spritesheet2.prototype.parse = function(callback) {\n    this._batchIndex = 0;\n    this._callback = callback;\n    if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {\n      this._processFrames(0);\n      this._processAnimations();\n      this._parseComplete();\n    } else {\n      this._nextBatch();\n    }\n  };\n  Spritesheet2.prototype._processFrames = function(initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet2.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i2 = this._frameKeys[frameIndex];\n      var data = this._frames[i2];\n      var rect = data.frame;\n      if (rect) {\n        var frame = null;\n        var trim2 = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim2 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i2] = new Texture(this.baseTexture, frame, orig, trim2, data.rotated ? 2 : 0, data.anchor);\n        Texture.addToCache(this.textures[i2], i2);\n      }\n      frameIndex++;\n    }\n  };\n  Spritesheet2.prototype._processAnimations = function() {\n    var animations = this.data.animations || {};\n    for (var animName in animations) {\n      this.animations[animName] = [];\n      for (var i2 = 0; i2 < animations[animName].length; i2++) {\n        var frameName = animations[animName][i2];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n  Spritesheet2.prototype._parseComplete = function() {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n  Spritesheet2.prototype._nextBatch = function() {\n    var _this = this;\n    this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(function() {\n      if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n  Spritesheet2.prototype.destroy = function(destroyBase) {\n    var _a3;\n    if (destroyBase === void 0) {\n      destroyBase = false;\n    }\n    for (var i2 in this.textures) {\n      this.textures[i2].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      (_a3 = this._texture) === null || _a3 === void 0 ? void 0 : _a3.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n  };\n  Spritesheet2.BATCH_SIZE = 1e3;\n  return Spritesheet2;\n}();\nvar SpritesheetLoader = function() {\n  function SpritesheetLoader2() {\n  }\n  SpritesheetLoader2.use = function(resource, next) {\n    var _a3, _b3;\n    var loader = this;\n    var imageResourceName = resource.name + \"_image\";\n    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {\n      next();\n      return;\n    }\n    var multiPacks = (_b3 = (_a3 = resource.data) === null || _a3 === void 0 ? void 0 : _a3.meta) === null || _b3 === void 0 ? void 0 : _b3.related_multi_packs;\n    if (Array.isArray(multiPacks)) {\n      var _loop_1 = function(item2) {\n        if (typeof item2 !== \"string\") {\n          return \"continue\";\n        }\n        var itemName = item2.replace(\".json\", \"\");\n        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, \"\"), item2);\n        if (loader.resources[itemName] || Object.values(loader.resources).some(function(r2) {\n          return url.format(url.parse(r2.url)) === itemUrl;\n        })) {\n          return \"continue\";\n        }\n        var options = {\n          crossOrigin: resource.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: resource,\n          metadata: resource.metadata\n        };\n        loader.add(itemName, itemUrl, options);\n      };\n      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {\n        var item = multiPacks_1[_i];\n        _loop_1(item);\n      }\n    }\n    var loadOptions = {\n      crossOrigin: resource.crossOrigin,\n      metadata: resource.metadata.imageMetadata,\n      parentResource: resource\n    };\n    var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);\n    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n      if (res.error) {\n        next(res.error);\n        return;\n      }\n      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);\n      spritesheet.parse(function() {\n        resource.spritesheet = spritesheet;\n        resource.textures = spritesheet.textures;\n        next();\n      });\n    });\n  };\n  SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {\n    if (resource.isDataUrl) {\n      return resource.data.meta.image;\n    }\n    return url.resolve(resource.url.replace(baseUrl, \"\"), resource.data.meta.image);\n  };\n  return SpritesheetLoader2;\n}();\n/*!\n * @pixi/sprite-tiling - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$h = function(d2, b2) {\n  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$h(d2, b2);\n};\nfunction __extends$h(d2, b2) {\n  extendStatics$h(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar tempPoint$1 = new Point();\n(function(_super) {\n  __extends$h(TilingSprite, _super);\n  function TilingSprite(texture, width, height) {\n    if (width === void 0) {\n      width = 100;\n    }\n    if (height === void 0) {\n      height = 100;\n    }\n    var _this = _super.call(this, texture) || this;\n    _this.tileTransform = new Transform();\n    _this._width = width;\n    _this._height = height;\n    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);\n    _this.pluginName = \"tilingSprite\";\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  Object.defineProperty(TilingSprite.prototype, \"clampMargin\", {\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(value2) {\n      this.uvMatrix.clampMargin = value2;\n      this.uvMatrix.update(true);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tileScale\", {\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(value2) {\n      this.tileTransform.scale.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tilePosition\", {\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(value2) {\n      this.tileTransform.position.copyFrom(value2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  TilingSprite.prototype._onTextureUpdate = function() {\n    if (this.uvMatrix) {\n      this.uvMatrix.texture = this._texture;\n    }\n    this._cachedTint = 16777215;\n  };\n  TilingSprite.prototype._render = function(renderer) {\n    var texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvMatrix.update();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  TilingSprite.prototype._calculateBounds = function() {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  TilingSprite.prototype.getLocalBounds = function(rect) {\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  TilingSprite.prototype.containsPoint = function(point) {\n    this.worldTransform.applyInverse(point, tempPoint$1);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n    if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n      if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  TilingSprite.prototype.destroy = function(options) {\n    _super.prototype.destroy.call(this, options);\n    this.tileTransform = null;\n    this.uvMatrix = null;\n  };\n  TilingSprite.from = function(source, options) {\n    var texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new TilingSprite(texture, options.width, options.height);\n  };\n  Object.defineProperty(TilingSprite.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(value2) {\n      this._width = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(value2) {\n      this._height = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TilingSprite;\n})(Sprite);\nvar fragmentSimpleSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl1VertexSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl1FragmentSrc = \"#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl2VertexSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl2FragmentSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n\";\nvar tempMat = new Matrix();\nvar TilingSpriteRenderer = function(_super) {\n  __extends$h(TilingSpriteRenderer2, _super);\n  function TilingSpriteRenderer2(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    renderer.runners.contextChange.add(_this);\n    _this.quad = new QuadUv();\n    _this.state = State.for2d();\n    return _this;\n  }\n  TilingSpriteRenderer2.prototype.contextChange = function() {\n    var renderer = this.renderer;\n    var uniforms = { globals: renderer.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  };\n  TilingSpriteRenderer2.prototype.render = function(ts) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    var vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1 - anchorX;\n    vertices[5] = vertices[7] = 1 - anchorY;\n    quad.invalidate();\n    var tex = ts._texture;\n    var baseTex = tex.baseTexture;\n    var lt = ts.tileTransform.localTransform;\n    var uv = ts.uvMatrix;\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === WRAP_MODES$3.CLAMP) {\n          baseTex.wrapMode = WRAP_MODES$3.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== WRAP_MODES$3.CLAMP;\n      }\n    }\n    var shader = isSimple ? this.simpleShader : this.shader;\n    var w2 = tex.width;\n    var h2 = tex.height;\n    var W = ts._width;\n    var H = ts._height;\n    tempMat.set(lt.a * w2 / W, lt.b * w2 / H, lt.c * h2 / W, lt.d * h2 / H, lt.tx / W, lt.ty / H);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  };\n  return TilingSpriteRenderer2;\n}(ObjectRenderer);\n/*!\n * @pixi/mesh - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$g = function(d2, b2) {\n  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$g(d2, b2);\n};\nfunction __extends$g(d2, b2) {\n  extendStatics$g(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar MeshBatchUvs = function() {\n  function MeshBatchUvs2(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer;\n    this.uvMatrix = uvMatrix;\n    this.data = null;\n    this._bufferUpdateId = -1;\n    this._textureUpdateId = -1;\n    this._updateID = 0;\n  }\n  MeshBatchUvs2.prototype.update = function(forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {\n      return;\n    }\n    this._bufferUpdateId = this.uvBuffer._updateID;\n    this._textureUpdateId = this.uvMatrix._updateID;\n    var data = this.uvBuffer.data;\n    if (!this.data || this.data.length !== data.length) {\n      this.data = new Float32Array(data.length);\n    }\n    this.uvMatrix.multiplyUvs(data, this.data);\n    this._updateID++;\n  };\n  return MeshBatchUvs2;\n}();\nvar tempPoint = new Point();\nvar tempPolygon = new Polygon();\nvar Mesh = function(_super) {\n  __extends$g(Mesh2, _super);\n  function Mesh2(geometry, shader, state, drawMode) {\n    if (drawMode === void 0) {\n      drawMode = DRAW_MODES$3.TRIANGLES;\n    }\n    var _this = _super.call(this) || this;\n    _this.geometry = geometry;\n    _this.shader = shader;\n    _this.state = state || State.for2d();\n    _this.drawMode = drawMode;\n    _this.start = 0;\n    _this.size = 0;\n    _this.uvs = null;\n    _this.indices = null;\n    _this.vertexData = new Float32Array(1);\n    _this.vertexDirty = -1;\n    _this._transformID = -1;\n    _this._roundPixels = settings.ROUND_PIXELS;\n    _this.batchUvs = null;\n    return _this;\n  }\n  Object.defineProperty(Mesh2.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    set: function(value2) {\n      if (this._geometry === value2) {\n        return;\n      }\n      if (this._geometry) {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0) {\n          this._geometry.dispose();\n        }\n      }\n      this._geometry = value2;\n      if (this._geometry) {\n        this._geometry.refCount++;\n      }\n      this.vertexDirty = -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"uvBuffer\", {\n    get: function() {\n      return this.geometry.buffers[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"verticesBuffer\", {\n    get: function() {\n      return this.geometry.buffers[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"material\", {\n    get: function() {\n      return this.shader;\n    },\n    set: function(value2) {\n      this.shader = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(value2) {\n      this.state.blendMode = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(value2) {\n      if (this._roundPixels !== value2) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"tint\", {\n    get: function() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function(value2) {\n      this.shader.tint = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh2.prototype, \"texture\", {\n    get: function() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function(value2) {\n      this.shader.texture = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Mesh2.prototype._render = function(renderer) {\n    var vertices = this.geometry.buffers[0].data;\n    var shader = this.shader;\n    if (shader.batchable && this.drawMode === DRAW_MODES$3.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {\n      this._renderToBatch(renderer);\n    } else {\n      this._renderDefault(renderer);\n    }\n  };\n  Mesh2.prototype._renderDefault = function(renderer) {\n    var shader = this.shader;\n    shader.alpha = this.worldAlpha;\n    if (shader.update) {\n      shader.update();\n    }\n    renderer.batch.flush();\n    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n    renderer.shader.bind(shader);\n    renderer.state.set(this.state);\n    renderer.geometry.bind(this.geometry, shader);\n    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  };\n  Mesh2.prototype._renderToBatch = function(renderer) {\n    var geometry = this.geometry;\n    var shader = this.shader;\n    if (shader.uvMatrix) {\n      shader.uvMatrix.update();\n      this.calculateUvs();\n    }\n    this.calculateVertices();\n    this.indices = geometry.indexBuffer.data;\n    this._tintRGB = shader._tintRGB;\n    this._texture = shader.texture;\n    var pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n    renderer.plugins[pluginName].render(this);\n  };\n  Mesh2.prototype.calculateVertices = function() {\n    var geometry = this.geometry;\n    var verticesBuffer = geometry.buffers[0];\n    var vertices = verticesBuffer.data;\n    var vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n      return;\n    }\n    this._transformID = this.transform._worldID;\n    if (this.vertexData.length !== vertices.length) {\n      this.vertexData = new Float32Array(vertices.length);\n    }\n    var wt = this.transform.worldTransform;\n    var a2 = wt.a;\n    var b2 = wt.b;\n    var c2 = wt.c;\n    var d2 = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var vertexData = this.vertexData;\n    for (var i2 = 0; i2 < vertexData.length / 2; i2++) {\n      var x2 = vertices[i2 * 2];\n      var y2 = vertices[i2 * 2 + 1];\n      vertexData[i2 * 2] = a2 * x2 + c2 * y2 + tx;\n      vertexData[i2 * 2 + 1] = b2 * x2 + d2 * y2 + ty;\n    }\n    if (this._roundPixels) {\n      var resolution = settings.RESOLUTION;\n      for (var i2 = 0; i2 < vertexData.length; ++i2) {\n        vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);\n      }\n    }\n    this.vertexDirty = vertexDirtyId;\n  };\n  Mesh2.prototype.calculateUvs = function() {\n    var geomUvs = this.geometry.buffers[1];\n    var shader = this.shader;\n    if (!shader.uvMatrix.isSimple) {\n      if (!this.batchUvs) {\n        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n      }\n      this.batchUvs.update();\n      this.uvs = this.batchUvs.data;\n    } else {\n      this.uvs = geomUvs.data;\n    }\n  };\n  Mesh2.prototype._calculateBounds = function() {\n    this.calculateVertices();\n    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  };\n  Mesh2.prototype.containsPoint = function(point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n    this.worldTransform.applyInverse(point, tempPoint);\n    var vertices = this.geometry.getBuffer(\"aVertexPosition\").data;\n    var points = tempPolygon.points;\n    var indices2 = this.geometry.getIndex().data;\n    var len = indices2.length;\n    var step = this.drawMode === 4 ? 3 : 1;\n    for (var i2 = 0; i2 + 2 < len; i2 += step) {\n      var ind0 = indices2[i2] * 2;\n      var ind1 = indices2[i2 + 1] * 2;\n      var ind2 = indices2[i2 + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Mesh2.prototype.destroy = function(options) {\n    _super.prototype.destroy.call(this, options);\n    if (this._cachedTexture) {\n      this._cachedTexture.destroy();\n      this._cachedTexture = null;\n    }\n    this.geometry = null;\n    this.shader = null;\n    this.state = null;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = null;\n  };\n  Mesh2.BATCHABLE_SIZE = 100;\n  return Mesh2;\n}(Container);\nvar fragment$5 = \"varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n\";\nvar vertex$2 = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTextureMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar MeshMaterial = function(_super) {\n  __extends$g(MeshMaterial2, _super);\n  function MeshMaterial2(uSampler, options) {\n    var _this = this;\n    var uniforms = {\n      uSampler,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    options = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: \"batch\"\n    }, options);\n    if (options.uniforms) {\n      Object.assign(uniforms, options.uniforms);\n    }\n    _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;\n    _this._colorDirty = false;\n    _this.uvMatrix = new TextureMatrix(uSampler);\n    _this.batchable = options.program === void 0;\n    _this.pluginName = options.pluginName;\n    _this.tint = options.tint;\n    _this.alpha = options.alpha;\n    return _this;\n  }\n  Object.defineProperty(MeshMaterial2.prototype, \"texture\", {\n    get: function() {\n      return this.uniforms.uSampler;\n    },\n    set: function(value2) {\n      if (this.uniforms.uSampler !== value2) {\n        this.uniforms.uSampler = value2;\n        this.uvMatrix.texture = value2;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MeshMaterial2.prototype, \"alpha\", {\n    get: function() {\n      return this._alpha;\n    },\n    set: function(value2) {\n      if (value2 === this._alpha) {\n        return;\n      }\n      this._alpha = value2;\n      this._colorDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MeshMaterial2.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(value2) {\n      if (value2 === this._tint) {\n        return;\n      }\n      this._tint = value2;\n      this._tintRGB = (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);\n      this._colorDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  MeshMaterial2.prototype.update = function() {\n    if (this._colorDirty) {\n      this._colorDirty = false;\n      var baseTexture = this.texture.baseTexture;\n      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);\n    }\n    if (this.uvMatrix.update()) {\n      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n    }\n  };\n  return MeshMaterial2;\n}(Shader);\nvar MeshGeometry = function(_super) {\n  __extends$g(MeshGeometry2, _super);\n  function MeshGeometry2(vertices, uvs, index) {\n    var _this = _super.call(this) || this;\n    var verticesBuffer = new Buffer$1(vertices);\n    var uvsBuffer = new Buffer$1(uvs, true);\n    var indexBuffer = new Buffer$1(index, true, true);\n    _this.addAttribute(\"aVertexPosition\", verticesBuffer, 2, false, TYPES$3.FLOAT).addAttribute(\"aTextureCoord\", uvsBuffer, 2, false, TYPES$3.FLOAT).addIndex(indexBuffer);\n    _this._updateId = -1;\n    return _this;\n  }\n  Object.defineProperty(MeshGeometry2.prototype, \"vertexDirtyId\", {\n    get: function() {\n      return this.buffers[0]._updateID;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return MeshGeometry2;\n}(Geometry);\n/*!\n * @pixi/text-bitmap - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$f = function(d2, b2) {\n  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$f(d2, b2);\n};\nfunction __extends$f(d2, b2) {\n  extendStatics$f(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar BitmapFontData = function() {\n  function BitmapFontData2() {\n    this.info = [];\n    this.common = [];\n    this.page = [];\n    this.char = [];\n    this.kerning = [];\n    this.distanceField = [];\n  }\n  return BitmapFontData2;\n}();\nvar TextFormat = function() {\n  function TextFormat2() {\n  }\n  TextFormat2.test = function(data) {\n    return typeof data === \"string\" && data.indexOf(\"info face=\") === 0;\n  };\n  TextFormat2.parse = function(txt) {\n    var items = txt.match(/^[a-z]+\\s+.+$/gm);\n    var rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (var i2 in items) {\n      var name = items[i2].match(/^[a-z]+/gm)[0];\n      var attributeList = items[i2].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      var itemData = {};\n      for (var i_1 in attributeList) {\n        var split = attributeList[i_1].split(\"=\");\n        var key = split[0];\n        var strValue = split[1].replace(/\"/gm, \"\");\n        var floatValue = parseFloat(strValue);\n        var value2 = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value2;\n      }\n      rawData[name].push(itemData);\n    }\n    var font = new BitmapFontData();\n    rawData.info.forEach(function(info) {\n      return font.info.push({\n        face: info.face,\n        size: parseInt(info.size, 10)\n      });\n    });\n    rawData.common.forEach(function(common) {\n      return font.common.push({\n        lineHeight: parseInt(common.lineHeight, 10)\n      });\n    });\n    rawData.page.forEach(function(page) {\n      return font.page.push({\n        id: parseInt(page.id, 10),\n        file: page.file\n      });\n    });\n    rawData.char.forEach(function(char) {\n      return font.char.push({\n        id: parseInt(char.id, 10),\n        page: parseInt(char.page, 10),\n        x: parseInt(char.x, 10),\n        y: parseInt(char.y, 10),\n        width: parseInt(char.width, 10),\n        height: parseInt(char.height, 10),\n        xoffset: parseInt(char.xoffset, 10),\n        yoffset: parseInt(char.yoffset, 10),\n        xadvance: parseInt(char.xadvance, 10)\n      });\n    });\n    rawData.kerning.forEach(function(kerning) {\n      return font.kerning.push({\n        first: parseInt(kerning.first, 10),\n        second: parseInt(kerning.second, 10),\n        amount: parseInt(kerning.amount, 10)\n      });\n    });\n    rawData.distanceField.forEach(function(df) {\n      return font.distanceField.push({\n        distanceRange: parseInt(df.distanceRange, 10),\n        fieldType: df.fieldType\n      });\n    });\n    return font;\n  };\n  return TextFormat2;\n}();\nvar XMLFormat = function() {\n  function XMLFormat2() {\n  }\n  XMLFormat2.test = function(data) {\n    return data instanceof XMLDocument && data.getElementsByTagName(\"page\").length && data.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  };\n  XMLFormat2.parse = function(xml) {\n    var data = new BitmapFontData();\n    var info = xml.getElementsByTagName(\"info\");\n    var common = xml.getElementsByTagName(\"common\");\n    var page = xml.getElementsByTagName(\"page\");\n    var char = xml.getElementsByTagName(\"char\");\n    var kerning = xml.getElementsByTagName(\"kerning\");\n    var distanceField = xml.getElementsByTagName(\"distanceField\");\n    for (var i2 = 0; i2 < info.length; i2++) {\n      data.info.push({\n        face: info[i2].getAttribute(\"face\"),\n        size: parseInt(info[i2].getAttribute(\"size\"), 10)\n      });\n    }\n    for (var i2 = 0; i2 < common.length; i2++) {\n      data.common.push({\n        lineHeight: parseInt(common[i2].getAttribute(\"lineHeight\"), 10)\n      });\n    }\n    for (var i2 = 0; i2 < page.length; i2++) {\n      data.page.push({\n        id: parseInt(page[i2].getAttribute(\"id\"), 10) || 0,\n        file: page[i2].getAttribute(\"file\")\n      });\n    }\n    for (var i2 = 0; i2 < char.length; i2++) {\n      var letter = char[i2];\n      data.char.push({\n        id: parseInt(letter.getAttribute(\"id\"), 10),\n        page: parseInt(letter.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(letter.getAttribute(\"x\"), 10),\n        y: parseInt(letter.getAttribute(\"y\"), 10),\n        width: parseInt(letter.getAttribute(\"width\"), 10),\n        height: parseInt(letter.getAttribute(\"height\"), 10),\n        xoffset: parseInt(letter.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt(letter.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt(letter.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (var i2 = 0; i2 < kerning.length; i2++) {\n      data.kerning.push({\n        first: parseInt(kerning[i2].getAttribute(\"first\"), 10),\n        second: parseInt(kerning[i2].getAttribute(\"second\"), 10),\n        amount: parseInt(kerning[i2].getAttribute(\"amount\"), 10)\n      });\n    }\n    for (var i2 = 0; i2 < distanceField.length; i2++) {\n      data.distanceField.push({\n        fieldType: distanceField[i2].getAttribute(\"fieldType\"),\n        distanceRange: parseInt(distanceField[i2].getAttribute(\"distanceRange\"), 10)\n      });\n    }\n    return data;\n  };\n  return XMLFormat2;\n}();\nvar XMLStringFormat = function() {\n  function XMLStringFormat2() {\n  }\n  XMLStringFormat2.test = function(data) {\n    if (typeof data === \"string\" && data.indexOf(\"<font>\") > -1) {\n      var xml = new globalThis.DOMParser().parseFromString(data, \"text/xml\");\n      return XMLFormat.test(xml);\n    }\n    return false;\n  };\n  XMLStringFormat2.parse = function(xmlTxt) {\n    var xml = new globalThis.DOMParser().parseFromString(xmlTxt, \"text/xml\");\n    return XMLFormat.parse(xml);\n  };\n  return XMLStringFormat2;\n}();\nvar formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(data) {\n  for (var i2 = 0; i2 < formats.length; i2++) {\n    if (formats[i2].test(data)) {\n      return formats[i2];\n    }\n  }\n  return null;\n}\nfunction generateFillStyle(canvas, context2, style, resolution, lines, metrics) {\n  var fillStyle = style.fill;\n  if (!Array.isArray(fillStyle)) {\n    return fillStyle;\n  } else if (fillStyle.length === 1) {\n    return fillStyle[0];\n  }\n  var gradient;\n  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n  var padding = style.padding || 0;\n  var width = canvas.width / resolution - dropShadowCorrection - padding * 2;\n  var height = canvas.height / resolution - dropShadowCorrection - padding * 2;\n  var fill = fillStyle.slice();\n  var fillGradientStops = style.fillGradientStops.slice();\n  if (!fillGradientStops.length) {\n    var lengthPlus1 = fill.length + 1;\n    for (var i2 = 1; i2 < lengthPlus1; ++i2) {\n      fillGradientStops.push(i2 / lengthPlus1);\n    }\n  }\n  fill.unshift(fillStyle[0]);\n  fillGradientStops.unshift(0);\n  fill.push(fillStyle[fillStyle.length - 1]);\n  fillGradientStops.push(1);\n  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);\n    var lastIterationStop = 0;\n    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n    var gradStopLineHeight = textHeight / height;\n    for (var i2 = 0; i2 < lines.length; i2++) {\n      var thisLineTop = metrics.lineHeight * i2;\n      for (var j2 = 0; j2 < fill.length; j2++) {\n        var lineStop = 0;\n        if (typeof fillGradientStops[j2] === \"number\") {\n          lineStop = fillGradientStops[j2];\n        } else {\n          lineStop = j2 / fill.length;\n        }\n        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;\n        var clampedStop = Math.max(lastIterationStop, globalStop);\n        clampedStop = Math.min(clampedStop, 1);\n        gradient.addColorStop(clampedStop, fill[j2]);\n        lastIterationStop = clampedStop;\n      }\n    }\n  } else {\n    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);\n    var totalIterations = fill.length + 1;\n    var currentIteration = 1;\n    for (var i2 = 0; i2 < fill.length; i2++) {\n      var stop = void 0;\n      if (typeof fillGradientStops[i2] === \"number\") {\n        stop = fillGradientStops[i2];\n      } else {\n        stop = currentIteration / totalIterations;\n      }\n      gradient.addColorStop(stop, fill[i2]);\n      currentIteration++;\n    }\n  }\n  return gradient;\n}\nfunction drawGlyph(canvas, context2, metrics, x2, y2, resolution, style) {\n  var char = metrics.text;\n  var fontProperties = metrics.fontProperties;\n  context2.translate(x2, y2);\n  context2.scale(resolution, resolution);\n  var tx = style.strokeThickness / 2;\n  var ty = -(style.strokeThickness / 2);\n  context2.font = style.toFontString();\n  context2.lineWidth = style.strokeThickness;\n  context2.textBaseline = style.textBaseline;\n  context2.lineJoin = style.lineJoin;\n  context2.miterLimit = style.miterLimit;\n  context2.fillStyle = generateFillStyle(canvas, context2, style, resolution, [char], metrics);\n  context2.strokeStyle = style.stroke;\n  if (style.dropShadow) {\n    var dropShadowColor = style.dropShadowColor;\n    var rgb = hex2rgb(typeof dropShadowColor === \"number\" ? dropShadowColor : string2hex(dropShadowColor));\n    var dropShadowBlur = style.dropShadowBlur * resolution;\n    var dropShadowDistance = style.dropShadowDistance * resolution;\n    context2.shadowColor = \"rgba(\" + rgb[0] * 255 + \",\" + rgb[1] * 255 + \",\" + rgb[2] * 255 + \",\" + style.dropShadowAlpha + \")\";\n    context2.shadowBlur = dropShadowBlur;\n    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n  } else {\n    context2.shadowColor = \"black\";\n    context2.shadowBlur = 0;\n    context2.shadowOffsetX = 0;\n    context2.shadowOffsetY = 0;\n  }\n  if (style.stroke && style.strokeThickness) {\n    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  if (style.fill) {\n    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  context2.setTransform(1, 0, 0, 1, 0, 0);\n  context2.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction splitTextToCharacters(text2) {\n  return Array.from ? Array.from(text2) : text2.split(\"\");\n}\nfunction resolveCharacters(chars2) {\n  if (typeof chars2 === \"string\") {\n    chars2 = [chars2];\n  }\n  var result = [];\n  for (var i2 = 0, j2 = chars2.length; i2 < j2; i2++) {\n    var item = chars2[i2];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + item.length + \".\");\n      }\n      var startCode = item[0].charCodeAt(0);\n      var endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {\n        result.push(String.fromCharCode(i_1));\n      }\n    } else {\n      result.push.apply(result, splitTextToCharacters(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\nfunction extractCharCode(str2) {\n  return str2.codePointAt ? str2.codePointAt(0) : str2.charCodeAt(0);\n}\nvar BitmapFont = function() {\n  function BitmapFont2(data, textures, ownsTextures) {\n    var _a3, _b3;\n    var info = data.info[0];\n    var common = data.common[0];\n    var page = data.page[0];\n    var distanceField = data.distanceField[0];\n    var res = getResolutionOfUrl(page.file);\n    var pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (var i2 = 0; i2 < data.page.length; i2++) {\n      var _c3 = data.page[i2], id = _c3.id, file = _c3.file;\n      pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file];\n      if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== \"none\") {\n        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA;\n      }\n    }\n    for (var i2 = 0; i2 < data.char.length; i2++) {\n      var _d2 = data.char[i2], id = _d2.id, page_1 = _d2.page;\n      var _e = data.char[i2], x2 = _e.x, y2 = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;\n      x2 /= res;\n      y2 /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      var rect = new Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width, height);\n      this.chars[id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new Texture(pageTextures[page_1].baseTexture, rect),\n        page: page_1\n      };\n    }\n    for (var i2 = 0; i2 < data.kerning.length; i2++) {\n      var _f = data.kerning[i2], first = _f.first, second = _f.second, amount = _f.amount;\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;\n    this.distanceFieldType = (_b3 = (_a3 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) !== null && _b3 !== void 0 ? _b3 : \"none\";\n  }\n  BitmapFont2.prototype.destroy = function() {\n    for (var id in this.chars) {\n      this.chars[id].texture.destroy();\n      this.chars[id].texture = null;\n    }\n    for (var id in this.pageTextures) {\n      if (this._ownsTextures) {\n        this.pageTextures[id].destroy(true);\n      }\n      this.pageTextures[id] = null;\n    }\n    this.chars = null;\n    this.pageTextures = null;\n  };\n  BitmapFont2.install = function(data, textures, ownsTextures) {\n    var fontData;\n    if (data instanceof BitmapFontData) {\n      fontData = data;\n    } else {\n      var format2 = autoDetectFormat(data);\n      if (!format2) {\n        throw new Error(\"Unrecognized data format for font.\");\n      }\n      fontData = format2.parse(data);\n    }\n    if (textures instanceof Texture) {\n      textures = [textures];\n    }\n    var font = new BitmapFont2(fontData, textures, ownsTextures);\n    BitmapFont2.available[font.font] = font;\n    return font;\n  };\n  BitmapFont2.uninstall = function(name) {\n    var font = BitmapFont2.available[name];\n    if (!font) {\n      throw new Error(\"No font found named '\" + name + \"'\");\n    }\n    font.destroy();\n    delete BitmapFont2.available[name];\n  };\n  BitmapFont2.from = function(name, textStyle, options) {\n    if (!name) {\n      throw new Error(\"[BitmapFont] Property `name` is required.\");\n    }\n    var _a3 = Object.assign({}, BitmapFont2.defaultOptions, options), chars2 = _a3.chars, padding = _a3.padding, resolution = _a3.resolution, textureWidth = _a3.textureWidth, textureHeight = _a3.textureHeight;\n    var charsList = resolveCharacters(chars2);\n    var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    var lineWidth = textureWidth;\n    var fontData = new BitmapFontData();\n    fontData.info[0] = {\n      face: style.fontFamily,\n      size: style.fontSize\n    };\n    fontData.common[0] = {\n      lineHeight: style.fontSize\n    };\n    var positionX = 0;\n    var positionY = 0;\n    var canvas;\n    var context2;\n    var baseTexture;\n    var maxCharHeight = 0;\n    var textures = [];\n    for (var i2 = 0; i2 < charsList.length; i2++) {\n      if (!canvas) {\n        canvas = document.createElement(\"canvas\");\n        canvas.width = textureWidth;\n        canvas.height = textureHeight;\n        context2 = canvas.getContext(\"2d\");\n        baseTexture = new BaseTexture(canvas, { resolution });\n        textures.push(new Texture(baseTexture));\n        fontData.page.push({\n          id: textures.length - 1,\n          file: \"\"\n        });\n      }\n      var metrics = TextMetrics.measureText(charsList[i2], style, false, canvas);\n      var width = metrics.width;\n      var height = Math.ceil(metrics.height);\n      var textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      if (positionY >= textureHeight - height * resolution) {\n        if (positionY === 0) {\n          throw new Error(\"[BitmapFont] textureHeight \" + textureHeight + \"px is \" + (\"too small for \" + style.fontSize + \"px fonts\"));\n        }\n        --i2;\n        canvas = null;\n        context2 = null;\n        baseTexture = null;\n        positionY = 0;\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n      if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n        --i2;\n        positionY += maxCharHeight * resolution;\n        positionY = Math.ceil(positionY);\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      drawGlyph(canvas, context2, metrics, positionX, positionY, resolution, style);\n      var id = extractCharCode(metrics.text);\n      fontData.char.push({\n        id,\n        page: textures.length - 1,\n        x: positionX / resolution,\n        y: positionY / resolution,\n        width: textureGlyphWidth,\n        height,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))\n      });\n      positionX += (textureGlyphWidth + 2 * padding) * resolution;\n      positionX = Math.ceil(positionX);\n    }\n    for (var i2 = 0, len = charsList.length; i2 < len; i2++) {\n      var first = charsList[i2];\n      for (var j2 = 0; j2 < len; j2++) {\n        var second = charsList[j2];\n        var c1 = context2.measureText(first).width;\n        var c2 = context2.measureText(second).width;\n        var total = context2.measureText(first + second).width;\n        var amount = total - (c1 + c2);\n        if (amount) {\n          fontData.kerning.push({\n            first: extractCharCode(first),\n            second: extractCharCode(second),\n            amount\n          });\n        }\n      }\n    }\n    var font = new BitmapFont2(fontData, textures, true);\n    if (BitmapFont2.available[name] !== void 0) {\n      BitmapFont2.uninstall(name);\n    }\n    BitmapFont2.available[name] = font;\n    return font;\n  };\n  BitmapFont2.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n  BitmapFont2.NUMERIC = [[\"0\", \"9\"]];\n  BitmapFont2.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n  BitmapFont2.ASCII = [[\" \", \"~\"]];\n  BitmapFont2.defaultOptions = {\n    resolution: 1,\n    textureWidth: 512,\n    textureHeight: 512,\n    padding: 4,\n    chars: BitmapFont2.ALPHANUMERIC\n  };\n  BitmapFont2.available = {};\n  return BitmapFont2;\n}();\nvar msdfFrag = \"// Pixi texture info\\r\\nvarying vec2 vTextureCoord;\\r\\nuniform sampler2D uSampler;\\r\\n\\r\\n// Tint\\r\\nuniform vec4 uColor;\\r\\n\\r\\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\\nuniform float uFWidth;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\\n\\r\\n  // MSDF\\r\\n  float median = texColor.r + texColor.g + texColor.b -\\r\\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\\n  // SDF\\r\\n  median = min(median, texColor.a);\\r\\n\\r\\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\\n\\r\\n  // NPM Textures, NPM outputs\\r\\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\\n\\r\\n}\\r\\n\";\nvar msdfVert = \"// Mesh material default fragment\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec2 aTextureCoord;\\r\\n\\r\\nuniform mat3 projectionMatrix;\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 uTextureMatrix;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\r\\nvoid main(void)\\r\\n{\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n\\r\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\\n}\\r\\n\";\nvar pageMeshDataDefaultPageMeshData = [];\nvar pageMeshDataMSDFPageMeshData = [];\nvar charRenderDataPool = [];\n(function(_super) {\n  __extends$f(BitmapText, _super);\n  function BitmapText(text2, style) {\n    if (style === void 0) {\n      style = {};\n    }\n    var _this = _super.call(this) || this;\n    _this._tint = 16777215;\n    var _a3 = Object.assign({}, BitmapText.styleDefaults, style), align = _a3.align, tint = _a3.tint, maxWidth = _a3.maxWidth, letterSpacing = _a3.letterSpacing, fontName = _a3.fontName, fontSize = _a3.fontSize;\n    if (!BitmapFont.available[fontName]) {\n      throw new Error('Missing BitmapFont \"' + fontName + '\"');\n    }\n    _this._activePagesMeshData = [];\n    _this._textWidth = 0;\n    _this._textHeight = 0;\n    _this._align = align;\n    _this._tint = tint;\n    _this._fontName = fontName;\n    _this._fontSize = fontSize || BitmapFont.available[fontName].size;\n    _this.text = text2;\n    _this._maxWidth = maxWidth;\n    _this._maxLineHeight = 0;\n    _this._letterSpacing = letterSpacing;\n    _this._anchor = new ObservablePoint(function() {\n      _this.dirty = true;\n    }, _this, 0, 0);\n    _this._roundPixels = settings.ROUND_PIXELS;\n    _this.dirty = true;\n    _this._textureCache = {};\n    return _this;\n  }\n  BitmapText.prototype.updateText = function() {\n    var _a3;\n    var data = BitmapFont.available[this._fontName];\n    var scale = this._fontSize / data.size;\n    var pos = new Point();\n    var chars2 = [];\n    var lineWidths = [];\n    var lineSpaces = [];\n    var text2 = this._text.replace(/(?:\\r\\n|\\r)/g, \"\\n\") || \" \";\n    var charsInput = splitTextToCharacters(text2);\n    var maxWidth = this._maxWidth * data.size / this._fontSize;\n    var pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    var prevCharCode = null;\n    var lastLineWidth = 0;\n    var maxLineWidth = 0;\n    var line = 0;\n    var lastBreakPos = -1;\n    var lastBreakWidth = 0;\n    var spacesRemoved = 0;\n    var maxLineHeight = 0;\n    var spaceCount = 0;\n    for (var i2 = 0; i2 < charsInput.length; i2++) {\n      var char = charsInput[i2];\n      var charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i2;\n        lastBreakWidth = lastLineWidth;\n        spaceCount++;\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        lineWidths.push(lastLineWidth);\n        lineSpaces.push(-1);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n        continue;\n      }\n      var charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      var charRenderData = charRenderDataPool.pop() || {\n        texture: Texture.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new Point()\n      };\n      charRenderData.texture = charData.texture;\n      charRenderData.line = line;\n      charRenderData.charCode = charCode;\n      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;\n      charRenderData.position.y = pos.y + charData.yOffset;\n      charRenderData.prevSpaces = spaceCount;\n      chars2.push(charRenderData);\n      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance, charData.texture.orig.width);\n      pos.x += charData.xAdvance + this._letterSpacing;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        removeItems(chars2, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);\n        i2 = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        lineSpaces.push(chars2.length > 0 ? chars2[chars2.length - 1].prevSpaces : 0);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n      }\n    }\n    var lastChar = charsInput[charsInput.length - 1];\n    if (lastChar !== \"\\r\" && lastChar !== \"\\n\") {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      lineSpaces.push(-1);\n    }\n    var lineAlignOffsets = [];\n    for (var i2 = 0; i2 <= line; i2++) {\n      var alignOffset = 0;\n      if (this._align === \"right\") {\n        alignOffset = maxLineWidth - lineWidths[i2];\n      } else if (this._align === \"center\") {\n        alignOffset = (maxLineWidth - lineWidths[i2]) / 2;\n      } else if (this._align === \"justify\") {\n        alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    var lenChars = chars2.length;\n    var pagesMeshData = {};\n    var newPagesMeshData = [];\n    var activePagesMeshData = this._activePagesMeshData;\n    for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {\n      pageMeshDataPool.push(activePagesMeshData[i2]);\n    }\n    for (var i2 = 0; i2 < lenChars; i2++) {\n      var texture = chars2[i2].texture;\n      var baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        var pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          var geometry = new MeshGeometry();\n          var material = void 0;\n          var meshBlendMode = void 0;\n          if (data.distanceFieldType === \"none\") {\n            material = new MeshMaterial(Texture.EMPTY);\n            meshBlendMode = BLEND_MODES$3.NORMAL;\n          } else {\n            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n            meshBlendMode = BLEND_MODES$3.NORMAL_NPM;\n          }\n          var mesh = new Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode;\n          pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0;\n        pageMeshData.indexCount = 0;\n        pageMeshData.vertexCount = 0;\n        pageMeshData.uvsCount = 0;\n        pageMeshData.total = 0;\n        var _textureCache = this._textureCache;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n        pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n        pageMeshData.mesh.tint = this._tint;\n        newPagesMeshData.push(pageMeshData);\n        pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {\n      if (newPagesMeshData.indexOf(activePagesMeshData[i2]) === -1) {\n        this.removeChild(activePagesMeshData[i2].mesh);\n      }\n    }\n    for (var i2 = 0; i2 < newPagesMeshData.length; i2++) {\n      if (newPagesMeshData[i2].mesh.parent !== this) {\n        this.addChild(newPagesMeshData[i2].mesh);\n      }\n    }\n    this._activePagesMeshData = newPagesMeshData;\n    for (var i2 in pagesMeshData) {\n      var pageMeshData = pagesMeshData[i2];\n      var total = pageMeshData.total;\n      if (!(((_a3 = pageMeshData.indices) === null || _a3 === void 0 ? void 0 : _a3.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {\n        pageMeshData.vertices = new Float32Array(4 * 2 * total);\n        pageMeshData.uvs = new Float32Array(4 * 2 * total);\n        pageMeshData.indices = new Uint16Array(6 * total);\n      } else {\n        var total_1 = pageMeshData.total;\n        var vertices = pageMeshData.vertices;\n        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {\n          vertices[i_1] = 0;\n        }\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (var i2 = 0; i2 < lenChars; i2++) {\n      var char = chars2[i2];\n      var offset2 = char.position.x + lineAlignOffsets[char.line] * (this._align === \"justify\" ? char.prevSpaces : 1);\n      if (this._roundPixels) {\n        offset2 = Math.round(offset2);\n      }\n      var xPos = offset2 * scale;\n      var yPos = char.position.y * scale;\n      var texture = char.texture;\n      var pageMesh = pagesMeshData[texture.baseTexture.uid];\n      var textureFrame = texture.frame;\n      var textureUvs = texture._uvs;\n      var index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n      pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n      pageMesh.vertices[index * 8 + 0] = xPos;\n      pageMesh.vertices[index * 8 + 1] = yPos;\n      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 3] = yPos;\n      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n      pageMesh.vertices[index * 8 + 6] = xPos;\n      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (var i2 in pagesMeshData) {\n      var pageMeshData = pagesMeshData[i2];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        var vertexCount = 0;\n        var anchorOffsetX = this._textWidth * this.anchor.x;\n        var anchorOffsetY = this._textHeight * this.anchor.y;\n        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer(\"aVertexPosition\");\n      var textureBuffer = pageMeshData.mesh.geometry.getBuffer(\"aTextureCoord\");\n      var indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices;\n      textureBuffer.data = pageMeshData.uvs;\n      indexBuffer.data = pageMeshData.indices;\n      vertexBuffer.update();\n      textureBuffer.update();\n      indexBuffer.update();\n    }\n    for (var i2 = 0; i2 < chars2.length; i2++) {\n      charRenderDataPool.push(chars2[i2]);\n    }\n  };\n  BitmapText.prototype.updateTransform = function() {\n    this.validate();\n    this.containerUpdateTransform();\n  };\n  BitmapText.prototype._render = function(renderer) {\n    var _a3 = BitmapFont.available[this._fontName], distanceFieldRange = _a3.distanceFieldRange, distanceFieldType = _a3.distanceFieldType, size = _a3.size;\n    if (distanceFieldType !== \"none\") {\n      var _b3 = this.worldTransform, a2 = _b3.a, b2 = _b3.b, c2 = _b3.c, d2 = _b3.d;\n      var dx = Math.sqrt(a2 * a2 + b2 * b2);\n      var dy = Math.sqrt(c2 * c2 + d2 * d2);\n      var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n      var fontScale = this._fontSize / size;\n      for (var _i = 0, _c3 = this._activePagesMeshData; _i < _c3.length; _i++) {\n        var mesh = _c3[_i];\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * renderer.resolution;\n      }\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  BitmapText.prototype.getLocalBounds = function() {\n    this.validate();\n    return _super.prototype.getLocalBounds.call(this);\n  };\n  BitmapText.prototype.validate = function() {\n    if (this.dirty) {\n      this.updateText();\n      this.dirty = false;\n    }\n  };\n  Object.defineProperty(BitmapText.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(value2) {\n      if (this._tint === value2) {\n        return;\n      }\n      this._tint = value2;\n      for (var i2 = 0; i2 < this._activePagesMeshData.length; i2++) {\n        this._activePagesMeshData[i2].mesh.tint = value2;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(value2) {\n      if (this._align !== value2) {\n        this._align = value2;\n        this.dirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"fontName\", {\n    get: function() {\n      return this._fontName;\n    },\n    set: function(value2) {\n      if (!BitmapFont.available[value2]) {\n        throw new Error('Missing BitmapFont \"' + value2 + '\"');\n      }\n      if (this._fontName !== value2) {\n        this._fontName = value2;\n        this.dirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(value2) {\n      if (this._fontSize !== value2) {\n        this._fontSize = value2;\n        this.dirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(value2) {\n      if (typeof value2 === \"number\") {\n        this._anchor.set(value2);\n      } else {\n        this._anchor.copyFrom(value2);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(text2) {\n      text2 = String(text2 === null || text2 === void 0 ? \"\" : text2);\n      if (this._text === text2) {\n        return;\n      }\n      this._text = text2;\n      this.dirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"maxWidth\", {\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(value2) {\n      if (this._maxWidth === value2) {\n        return;\n      }\n      this._maxWidth = value2;\n      this.dirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"maxLineHeight\", {\n    get: function() {\n      this.validate();\n      return this._maxLineHeight;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"textWidth\", {\n    get: function() {\n      this.validate();\n      return this._textWidth;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(value2) {\n      if (this._letterSpacing !== value2) {\n        this._letterSpacing = value2;\n        this.dirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(value2) {\n      if (value2 !== this._roundPixels) {\n        this._roundPixels = value2;\n        this.dirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BitmapText.prototype, \"textHeight\", {\n    get: function() {\n      this.validate();\n      return this._textHeight;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  BitmapText.prototype.destroy = function(options) {\n    var _textureCache = this._textureCache;\n    for (var id in _textureCache) {\n      var texture = _textureCache[id];\n      texture.destroy();\n      delete _textureCache[id];\n    }\n    this._textureCache = null;\n    _super.prototype.destroy.call(this, options);\n  };\n  BitmapText.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  };\n  return BitmapText;\n})(Container);\nvar BitmapFontLoader = function() {\n  function BitmapFontLoader2() {\n  }\n  BitmapFontLoader2.add = function() {\n    LoaderResource.setExtensionXhrType(\"fnt\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  };\n  BitmapFontLoader2.use = function(resource, next) {\n    var format2 = autoDetectFormat(resource.data);\n    if (!format2) {\n      next();\n      return;\n    }\n    var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);\n    var data = format2.parse(resource.data);\n    var textures = {};\n    var completed = function(page) {\n      textures[page.metadata.pageFile] = page.texture;\n      if (Object.keys(textures).length === data.page.length) {\n        resource.bitmapFont = BitmapFont.install(data, textures, true);\n        next();\n      }\n    };\n    for (var i2 = 0; i2 < data.page.length; ++i2) {\n      var pageFile = data.page[i2].file;\n      var url2 = baseUrl + pageFile;\n      var exists = false;\n      for (var name in this.resources) {\n        var bitmapResource = this.resources[name];\n        if (bitmapResource.url === url2) {\n          bitmapResource.metadata.pageFile = pageFile;\n          if (bitmapResource.texture) {\n            completed(bitmapResource);\n          } else {\n            bitmapResource.onAfterMiddleware.add(completed);\n          }\n          exists = true;\n          break;\n        }\n      }\n      if (!exists) {\n        var options = {\n          crossOrigin: resource.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.IMAGE,\n          metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),\n          parentResource: resource\n        };\n        this.add(url2, options, completed);\n      }\n    }\n  };\n  BitmapFontLoader2.getBaseUrl = function(loader, resource) {\n    var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : \"\";\n    if (resource.isDataUrl) {\n      if (resUrl === \".\") {\n        resUrl = \"\";\n      }\n      if (loader.baseUrl && resUrl) {\n        if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === \"/\") {\n          resUrl += \"/\";\n        }\n      }\n    }\n    resUrl = resUrl.replace(loader.baseUrl, \"\");\n    if (resUrl && resUrl.charAt(resUrl.length - 1) !== \"/\") {\n      resUrl += \"/\";\n    }\n    return resUrl;\n  };\n  BitmapFontLoader2.dirname = function(url2) {\n    var dir = url2.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n    if (dir === url2) {\n      return \".\";\n    } else if (dir === \"\") {\n      return \"/\";\n    }\n    return dir;\n  };\n  return BitmapFontLoader2;\n}();\n/*!\n * @pixi/filter-alpha - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-alpha is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$e = function(d2, b2) {\n  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$e(d2, b2);\n};\nfunction __extends$e(d2, b2) {\n  extendStatics$e(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar fragment$4 = \"varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\\n}\\n\";\n(function(_super) {\n  __extends$e(AlphaFilter, _super);\n  function AlphaFilter(alpha) {\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    var _this = _super.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;\n    _this.alpha = alpha;\n    return _this;\n  }\n  Object.defineProperty(AlphaFilter.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(value2) {\n      this.uniforms.uAlpha = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return AlphaFilter;\n})(Filter);\n/*!\n * @pixi/filter-blur - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$d = function(d2, b2) {\n  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$d(d2, b2);\n};\nfunction __extends$d(d2, b2) {\n  extendStatics$d(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar vertTemplate = \"\\n    attribute vec2 aVertexPosition;\\n\\n    uniform mat3 projectionMatrix;\\n\\n    uniform float strength;\\n\\n    varying vec2 vBlurTexCoords[%size%];\\n\\n    uniform vec4 inputSize;\\n    uniform vec4 outputFrame;\\n\\n    vec4 filterVertexPosition( void )\\n    {\\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n    }\\n\\n    vec2 filterTextureCoord( void )\\n    {\\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n    }\\n\\n    void main(void)\\n    {\\n        gl_Position = filterVertexPosition();\\n\\n        vec2 textureCoord = filterTextureCoord();\\n        %blur%\\n    }\";\nfunction generateBlurVertSource(kernelSize, x2) {\n  var halfLength = Math.ceil(kernelSize / 2);\n  var vertSource = vertTemplate;\n  var blurLoop = \"\";\n  var template;\n  if (x2) {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\";\n  } else {\n    template = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  }\n  for (var i2 = 0; i2 < kernelSize; i2++) {\n    var blur = template.replace(\"%index%\", i2.toString());\n    blur = blur.replace(\"%sampleIndex%\", i2 - (halfLength - 1) + \".0\");\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  vertSource = vertSource.replace(\"%blur%\", blurLoop);\n  vertSource = vertSource.replace(\"%size%\", kernelSize.toString());\n  return vertSource;\n}\nvar GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\nvar fragTemplate = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(\"\\n\");\nfunction generateBlurFragSource(kernelSize) {\n  var kernel = GAUSSIAN_VALUES[kernelSize];\n  var halfLength = kernel.length;\n  var fragSource = fragTemplate;\n  var blurLoop = \"\";\n  var template = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\";\n  var value2;\n  for (var i2 = 0; i2 < kernelSize; i2++) {\n    var blur = template.replace(\"%index%\", i2.toString());\n    value2 = i2;\n    if (i2 >= halfLength) {\n      value2 = kernelSize - i2 - 1;\n    }\n    blur = blur.replace(\"%value%\", kernel[value2].toString());\n    blurLoop += blur;\n    blurLoop += \"\\n\";\n  }\n  fragSource = fragSource.replace(\"%blur%\", blurLoop);\n  fragSource = fragSource.replace(\"%size%\", kernelSize.toString());\n  return fragSource;\n}\n/*!\n * @pixi/constants - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$1;\n(function(ENV2) {\n  ENV2[ENV2[\"WEBGL_LEGACY\"] = 0] = \"WEBGL_LEGACY\";\n  ENV2[ENV2[\"WEBGL\"] = 1] = \"WEBGL\";\n  ENV2[ENV2[\"WEBGL2\"] = 2] = \"WEBGL2\";\n})(ENV$1 || (ENV$1 = {}));\nvar RENDERER_TYPE$1;\n(function(RENDERER_TYPE2) {\n  RENDERER_TYPE2[RENDERER_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"CANVAS\"] = 2] = \"CANVAS\";\n})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));\nvar BUFFER_BITS$1;\n(function(BUFFER_BITS2) {\n  BUFFER_BITS2[BUFFER_BITS2[\"COLOR\"] = 16384] = \"COLOR\";\n  BUFFER_BITS2[BUFFER_BITS2[\"DEPTH\"] = 256] = \"DEPTH\";\n  BUFFER_BITS2[BUFFER_BITS2[\"STENCIL\"] = 1024] = \"STENCIL\";\n})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));\nvar BLEND_MODES$1;\n(function(BLEND_MODES2) {\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL\"] = 0] = \"NORMAL\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD\"] = 1] = \"ADD\";\n  BLEND_MODES2[BLEND_MODES2[\"MULTIPLY\"] = 2] = \"MULTIPLY\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN\"] = 3] = \"SCREEN\";\n  BLEND_MODES2[BLEND_MODES2[\"OVERLAY\"] = 4] = \"OVERLAY\";\n  BLEND_MODES2[BLEND_MODES2[\"DARKEN\"] = 5] = \"DARKEN\";\n  BLEND_MODES2[BLEND_MODES2[\"LIGHTEN\"] = 6] = \"LIGHTEN\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_DODGE\"] = 7] = \"COLOR_DODGE\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_BURN\"] = 8] = \"COLOR_BURN\";\n  BLEND_MODES2[BLEND_MODES2[\"HARD_LIGHT\"] = 9] = \"HARD_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"SOFT_LIGHT\"] = 10] = \"SOFT_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"DIFFERENCE\"] = 11] = \"DIFFERENCE\";\n  BLEND_MODES2[BLEND_MODES2[\"EXCLUSION\"] = 12] = \"EXCLUSION\";\n  BLEND_MODES2[BLEND_MODES2[\"HUE\"] = 13] = \"HUE\";\n  BLEND_MODES2[BLEND_MODES2[\"SATURATION\"] = 14] = \"SATURATION\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR\"] = 15] = \"COLOR\";\n  BLEND_MODES2[BLEND_MODES2[\"LUMINOSITY\"] = 16] = \"LUMINOSITY\";\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL_NPM\"] = 17] = \"NORMAL_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD_NPM\"] = 18] = \"ADD_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN_NPM\"] = 19] = \"SCREEN_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"NONE\"] = 20] = \"NONE\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OVER\"] = 0] = \"SRC_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_IN\"] = 21] = \"SRC_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OUT\"] = 22] = \"SRC_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_ATOP\"] = 23] = \"SRC_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OVER\"] = 24] = \"DST_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_IN\"] = 25] = \"DST_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OUT\"] = 26] = \"DST_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_ATOP\"] = 27] = \"DST_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"ERASE\"] = 26] = \"ERASE\";\n  BLEND_MODES2[BLEND_MODES2[\"SUBTRACT\"] = 28] = \"SUBTRACT\";\n  BLEND_MODES2[BLEND_MODES2[\"XOR\"] = 29] = \"XOR\";\n})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));\nvar DRAW_MODES$1;\n(function(DRAW_MODES2) {\n  DRAW_MODES2[DRAW_MODES2[\"POINTS\"] = 0] = \"POINTS\";\n  DRAW_MODES2[DRAW_MODES2[\"LINES\"] = 1] = \"LINES\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));\nvar FORMATS$1;\n(function(FORMATS2) {\n  FORMATS2[FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  FORMATS2[FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  FORMATS2[FORMATS2[\"RG\"] = 33319] = \"RG\";\n  FORMATS2[FORMATS2[\"RED\"] = 6403] = \"RED\";\n  FORMATS2[FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  FORMATS2[FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  FORMATS2[FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  FORMATS2[FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  FORMATS2[FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  FORMATS2[FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  FORMATS2[FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  FORMATS2[FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  FORMATS2[FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$1 || (FORMATS$1 = {}));\nvar TARGETS$1;\n(function(TARGETS2) {\n  TARGETS2[TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  TARGETS2[TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$1 || (TARGETS$1 = {}));\nvar TYPES$1;\n(function(TYPES2) {\n  TYPES2[TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  TYPES2[TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  TYPES2[TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  TYPES2[TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  TYPES2[TYPES2[\"INT\"] = 5124] = \"INT\";\n  TYPES2[TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  TYPES2[TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  TYPES2[TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n})(TYPES$1 || (TYPES$1 = {}));\nvar SAMPLER_TYPES$1;\n(function(SAMPLER_TYPES2) {\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"FLOAT\"] = 0] = \"FLOAT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"INT\"] = 1] = \"INT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"UINT\"] = 2] = \"UINT\";\n})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));\nvar SCALE_MODES$1;\n(function(SCALE_MODES2) {\n  SCALE_MODES2[SCALE_MODES2[\"NEAREST\"] = 0] = \"NEAREST\";\n  SCALE_MODES2[SCALE_MODES2[\"LINEAR\"] = 1] = \"LINEAR\";\n})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));\nvar WRAP_MODES$1;\n(function(WRAP_MODES2) {\n  WRAP_MODES2[WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  WRAP_MODES2[WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  WRAP_MODES2[WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));\nvar MIPMAP_MODES$1;\n(function(MIPMAP_MODES2) {\n  MIPMAP_MODES2[MIPMAP_MODES2[\"OFF\"] = 0] = \"OFF\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"POW2\"] = 1] = \"POW2\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON\"] = 2] = \"ON\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON_MANUAL\"] = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));\nvar ALPHA_MODES$1;\n(function(ALPHA_MODES2) {\n  ALPHA_MODES2[ALPHA_MODES2[\"NPM\"] = 0] = \"NPM\";\n  ALPHA_MODES2[ALPHA_MODES2[\"UNPACK\"] = 1] = \"UNPACK\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PMA\"] = 2] = \"PMA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"NO_PREMULTIPLIED_ALPHA\"] = 0] = \"NO_PREMULTIPLIED_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ON_UPLOAD\"] = 1] = \"PREMULTIPLY_ON_UPLOAD\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ALPHA\"] = 2] = \"PREMULTIPLY_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLIED_ALPHA\"] = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));\nvar CLEAR_MODES$1;\n(function(CLEAR_MODES2) {\n  CLEAR_MODES2[CLEAR_MODES2[\"NO\"] = 0] = \"NO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"YES\"] = 1] = \"YES\";\n  CLEAR_MODES2[CLEAR_MODES2[\"AUTO\"] = 2] = \"AUTO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLEND\"] = 0] = \"BLEND\";\n  CLEAR_MODES2[CLEAR_MODES2[\"CLEAR\"] = 1] = \"CLEAR\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLIT\"] = 2] = \"BLIT\";\n})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));\nvar GC_MODES$1;\n(function(GC_MODES2) {\n  GC_MODES2[GC_MODES2[\"AUTO\"] = 0] = \"AUTO\";\n  GC_MODES2[GC_MODES2[\"MANUAL\"] = 1] = \"MANUAL\";\n})(GC_MODES$1 || (GC_MODES$1 = {}));\nvar PRECISION$1;\n(function(PRECISION2) {\n  PRECISION2[\"LOW\"] = \"lowp\";\n  PRECISION2[\"MEDIUM\"] = \"mediump\";\n  PRECISION2[\"HIGH\"] = \"highp\";\n})(PRECISION$1 || (PRECISION$1 = {}));\nvar MASK_TYPES$1;\n(function(MASK_TYPES2) {\n  MASK_TYPES2[MASK_TYPES2[\"NONE\"] = 0] = \"NONE\";\n  MASK_TYPES2[MASK_TYPES2[\"SCISSOR\"] = 1] = \"SCISSOR\";\n  MASK_TYPES2[MASK_TYPES2[\"STENCIL\"] = 2] = \"STENCIL\";\n  MASK_TYPES2[MASK_TYPES2[\"SPRITE\"] = 3] = \"SPRITE\";\n})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));\nvar MSAA_QUALITY$1;\n(function(MSAA_QUALITY2) {\n  MSAA_QUALITY2[MSAA_QUALITY2[\"NONE\"] = 0] = \"NONE\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"LOW\"] = 2] = \"LOW\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"MEDIUM\"] = 4] = \"MEDIUM\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"HIGH\"] = 8] = \"HIGH\";\n})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));\nvar BUFFER_TYPE$1;\n(function(BUFFER_TYPE2) {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));\nvar BlurFilterPass = function(_super) {\n  __extends$d(BlurFilterPass2, _super);\n  function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {\n    if (strength === void 0) {\n      strength = 8;\n    }\n    if (quality === void 0) {\n      quality = 4;\n    }\n    if (resolution === void 0) {\n      resolution = settings.FILTER_RESOLUTION;\n    }\n    if (kernelSize === void 0) {\n      kernelSize = 5;\n    }\n    var _this = this;\n    var vertSrc = generateBlurVertSource(kernelSize, horizontal);\n    var fragSrc = generateBlurFragSource(kernelSize);\n    _this = _super.call(this, vertSrc, fragSrc) || this;\n    _this.horizontal = horizontal;\n    _this.resolution = resolution;\n    _this._quality = 0;\n    _this.quality = quality;\n    _this.blur = strength;\n    return _this;\n  }\n  BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {\n    if (output) {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / output.width * (output.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / output.height * (output.height / input.height);\n      }\n    } else {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);\n      }\n    }\n    this.uniforms.strength *= this.strength;\n    this.uniforms.strength /= this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      var renderTarget = filterManager.getFilterTexture();\n      var renderer = filterManager.renderer;\n      var flip2 = input;\n      var flop = renderTarget;\n      this.state.blend = false;\n      filterManager.applyFilter(this, flip2, flop, CLEAR_MODES$1.CLEAR);\n      for (var i2 = 1; i2 < this.passes - 1; i2++) {\n        filterManager.bindAndClear(flip2, CLEAR_MODES$1.BLIT);\n        this.uniforms.uSampler = flop;\n        var temp2 = flop;\n        flop = flip2;\n        flip2 = temp2;\n        renderer.shader.bind(this);\n        renderer.geometry.draw(5);\n      }\n      this.state.blend = true;\n      filterManager.applyFilter(this, flop, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    }\n  };\n  Object.defineProperty(BlurFilterPass2.prototype, \"blur\", {\n    get: function() {\n      return this.strength;\n    },\n    set: function(value2) {\n      this.padding = 1 + Math.abs(value2) * 2;\n      this.strength = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilterPass2.prototype, \"quality\", {\n    get: function() {\n      return this._quality;\n    },\n    set: function(value2) {\n      this._quality = value2;\n      this.passes = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return BlurFilterPass2;\n}(Filter);\n(function(_super) {\n  __extends$d(BlurFilter, _super);\n  function BlurFilter(strength, quality, resolution, kernelSize) {\n    if (strength === void 0) {\n      strength = 8;\n    }\n    if (quality === void 0) {\n      quality = 4;\n    }\n    if (resolution === void 0) {\n      resolution = settings.FILTER_RESOLUTION;\n    }\n    if (kernelSize === void 0) {\n      kernelSize = 5;\n    }\n    var _this = _super.call(this) || this;\n    _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);\n    _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);\n    _this.resolution = resolution;\n    _this.quality = quality;\n    _this.blur = strength;\n    _this.repeatEdgePixels = false;\n    return _this;\n  }\n  BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {\n    var xStrength = Math.abs(this.blurXFilter.strength);\n    var yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      var renderTarget = filterManager.getFilterTexture();\n      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES$1.CLEAR);\n      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    } else if (yStrength) {\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  };\n  BlurFilter.prototype.updatePadding = function() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n    }\n  };\n  Object.defineProperty(BlurFilter.prototype, \"blur\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(value2) {\n      this.blurXFilter.blur = this.blurYFilter.blur = value2;\n      this.updatePadding();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilter.prototype, \"quality\", {\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(value2) {\n      this.blurXFilter.quality = this.blurYFilter.quality = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilter.prototype, \"blurX\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(value2) {\n      this.blurXFilter.blur = value2;\n      this.updatePadding();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilter.prototype, \"blurY\", {\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(value2) {\n      this.blurYFilter.blur = value2;\n      this.updatePadding();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilter.prototype, \"blendMode\", {\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(value2) {\n      this.blurYFilter.blendMode = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BlurFilter.prototype, \"repeatEdgePixels\", {\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(value2) {\n      this._repeatEdgePixels = value2;\n      this.updatePadding();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return BlurFilter;\n})(Filter);\n/*!\n * @pixi/filter-color-matrix - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-color-matrix is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$c = function(d2, b2) {\n  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$c(d2, b2);\n};\nfunction __extends$c(d2, b2) {\n  extendStatics$c(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar fragment$3 = \"varying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float m[20];\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n    vec4 c = texture2D(uSampler, vTextureCoord);\\n\\n    if (uAlpha == 0.0) {\\n        gl_FragColor = c;\\n        return;\\n    }\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (c.a > 0.0) {\\n      c.rgb /= c.a;\\n    }\\n\\n    vec4 result;\\n\\n    result.r = (m[0] * c.r);\\n        result.r += (m[1] * c.g);\\n        result.r += (m[2] * c.b);\\n        result.r += (m[3] * c.a);\\n        result.r += m[4];\\n\\n    result.g = (m[5] * c.r);\\n        result.g += (m[6] * c.g);\\n        result.g += (m[7] * c.b);\\n        result.g += (m[8] * c.a);\\n        result.g += m[9];\\n\\n    result.b = (m[10] * c.r);\\n       result.b += (m[11] * c.g);\\n       result.b += (m[12] * c.b);\\n       result.b += (m[13] * c.a);\\n       result.b += m[14];\\n\\n    result.a = (m[15] * c.r);\\n       result.a += (m[16] * c.g);\\n       result.a += (m[17] * c.b);\\n       result.a += (m[18] * c.a);\\n       result.a += m[19];\\n\\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\\n\\n    // Premultiply alpha again.\\n    rgb *= result.a;\\n\\n    gl_FragColor = vec4(rgb, result.a);\\n}\\n\";\nvar ColorMatrixFilter = function(_super) {\n  __extends$c(ColorMatrixFilter2, _super);\n  function ColorMatrixFilter2() {\n    var _this = this;\n    var uniforms = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    _this = _super.call(this, defaultFilterVertex, fragment$3, uniforms) || this;\n    _this.alpha = 1;\n    return _this;\n  }\n  ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply3) {\n    if (multiply3 === void 0) {\n      multiply3 = false;\n    }\n    var newMatrix = matrix;\n    if (multiply3) {\n      this._multiply(newMatrix, this.uniforms.m, matrix);\n      newMatrix = this._colorMatrix(newMatrix);\n    }\n    this.uniforms.m = newMatrix;\n  };\n  ColorMatrixFilter2.prototype._multiply = function(out, a2, b2) {\n    out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];\n    out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];\n    out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];\n    out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];\n    out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];\n    out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];\n    out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];\n    out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];\n    out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];\n    out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];\n    out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];\n    out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];\n    out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];\n    out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];\n    out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];\n    out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];\n    out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];\n    out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];\n    out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];\n    out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];\n    return out;\n  };\n  ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {\n    var m2 = new Float32Array(matrix);\n    m2[4] /= 255;\n    m2[9] /= 255;\n    m2[14] /= 255;\n    m2[19] /= 255;\n    return m2;\n  };\n  ColorMatrixFilter2.prototype.brightness = function(b2, multiply3) {\n    var matrix = [\n      b2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.tint = function(color, multiply3) {\n    var r2 = color >> 16 & 255;\n    var g2 = color >> 8 & 255;\n    var b2 = color & 255;\n    var matrix = [\n      r2 / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      g2 / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b2 / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.greyscale = function(scale, multiply3) {\n    var matrix = [\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.blackAndWhite = function(multiply3) {\n    var matrix = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.hue = function(rotation, multiply3) {\n    rotation = (rotation || 0) / 180 * Math.PI;\n    var cosR = Math.cos(rotation);\n    var sinR = Math.sin(rotation);\n    var sqrt = Math.sqrt;\n    var w2 = 1 / 3;\n    var sqrW = sqrt(w2);\n    var a00 = cosR + (1 - cosR) * w2;\n    var a01 = w2 * (1 - cosR) - sqrW * sinR;\n    var a02 = w2 * (1 - cosR) + sqrW * sinR;\n    var a10 = w2 * (1 - cosR) + sqrW * sinR;\n    var a11 = cosR + w2 * (1 - cosR);\n    var a12 = w2 * (1 - cosR) - sqrW * sinR;\n    var a20 = w2 * (1 - cosR) - sqrW * sinR;\n    var a21 = w2 * (1 - cosR) + sqrW * sinR;\n    var a22 = cosR + w2 * (1 - cosR);\n    var matrix = [\n      a00,\n      a01,\n      a02,\n      0,\n      0,\n      a10,\n      a11,\n      a12,\n      0,\n      0,\n      a20,\n      a21,\n      a22,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.contrast = function(amount, multiply3) {\n    var v2 = (amount || 0) + 1;\n    var o = -0.5 * (v2 - 1);\n    var matrix = [\n      v2,\n      0,\n      0,\n      0,\n      o,\n      0,\n      v2,\n      0,\n      0,\n      o,\n      0,\n      0,\n      v2,\n      0,\n      o,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.saturate = function(amount, multiply3) {\n    if (amount === void 0) {\n      amount = 0;\n    }\n    var x2 = amount * 2 / 3 + 1;\n    var y2 = (x2 - 1) * -0.5;\n    var matrix = [\n      x2,\n      y2,\n      y2,\n      0,\n      0,\n      y2,\n      x2,\n      y2,\n      0,\n      0,\n      y2,\n      y2,\n      x2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.desaturate = function() {\n    this.saturate(-1);\n  };\n  ColorMatrixFilter2.prototype.negative = function(multiply3) {\n    var matrix = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.sepia = function(multiply3) {\n    var matrix = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.technicolor = function(multiply3) {\n    var matrix = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.polaroid = function(multiply3) {\n    var matrix = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.toBGR = function(multiply3) {\n    var matrix = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.kodachrome = function(multiply3) {\n    var matrix = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.browni = function(multiply3) {\n    var matrix = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.vintage = function(multiply3) {\n    var matrix = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply3) {\n    desaturation = desaturation || 0.2;\n    toned = toned || 0.15;\n    lightColor = lightColor || 16770432;\n    darkColor = darkColor || 3375104;\n    var lR = (lightColor >> 16 & 255) / 255;\n    var lG = (lightColor >> 8 & 255) / 255;\n    var lB = (lightColor & 255) / 255;\n    var dR = (darkColor >> 16 & 255) / 255;\n    var dG = (darkColor >> 8 & 255) / 255;\n    var dB = (darkColor & 255) / 255;\n    var matrix = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      lR,\n      lG,\n      lB,\n      desaturation,\n      0,\n      dR,\n      dG,\n      dB,\n      toned,\n      0,\n      lR - dR,\n      lG - dG,\n      lB - dB,\n      0,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.night = function(intensity, multiply3) {\n    intensity = intensity || 0.1;\n    var matrix = [\n      intensity * -2,\n      -intensity,\n      0,\n      0,\n      0,\n      -intensity,\n      0,\n      intensity,\n      0,\n      0,\n      0,\n      intensity,\n      intensity * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.predator = function(amount, multiply3) {\n    var matrix = [\n      11.224130630493164 * amount,\n      -4.794486999511719 * amount,\n      -2.8746118545532227 * amount,\n      0 * amount,\n      0.40342438220977783 * amount,\n      -3.6330697536468506 * amount,\n      9.193157196044922 * amount,\n      -2.951810836791992 * amount,\n      0 * amount,\n      -1.316135048866272 * amount,\n      -3.2184197902679443 * amount,\n      -4.2375030517578125 * amount,\n      7.476448059082031 * amount,\n      0 * amount,\n      0.8044459223747253 * amount,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.lsd = function(multiply3) {\n    var matrix = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply3);\n  };\n  ColorMatrixFilter2.prototype.reset = function() {\n    var matrix = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, false);\n  };\n  Object.defineProperty(ColorMatrixFilter2.prototype, \"matrix\", {\n    get: function() {\n      return this.uniforms.m;\n    },\n    set: function(value2) {\n      this.uniforms.m = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ColorMatrixFilter2.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(value2) {\n      this.uniforms.uAlpha = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ColorMatrixFilter2;\n}(Filter);\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n/*!\n * @pixi/filter-displacement - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$b = function(d2, b2) {\n  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$b(d2, b2);\n};\nfunction __extends$b(d2, b2) {\n  extendStatics$b(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar fragment$2 = \"varying vec2 vFilterCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform vec2 scale;\\nuniform mat2 rotation;\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nuniform highp vec4 inputSize;\\nuniform vec4 inputClamp;\\n\\nvoid main(void)\\n{\\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\\n\\n  map -= 0.5;\\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\\n\\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\\n}\\n\";\nvar vertex$1 = \"attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 filterMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vFilterCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n\tgl_Position = filterVertexPosition();\\n\tvTextureCoord = filterTextureCoord();\\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\\n}\\n\";\n(function(_super) {\n  __extends$b(DisplacementFilter, _super);\n  function DisplacementFilter(sprite, scale) {\n    var _this = this;\n    var maskMatrix = new Matrix();\n    sprite.renderable = false;\n    _this = _super.call(this, vertex$1, fragment$2, {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this;\n    _this.maskSprite = sprite;\n    _this.maskMatrix = maskMatrix;\n    if (scale === null || scale === void 0) {\n      scale = 20;\n    }\n    _this.scale = new Point(scale, scale);\n    return _this;\n  }\n  DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {\n    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n    this.uniforms.scale.x = this.scale.x;\n    this.uniforms.scale.y = this.scale.y;\n    var wt = this.maskSprite.worldTransform;\n    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    if (lenX !== 0 && lenY !== 0) {\n      this.uniforms.rotation[0] = wt.a / lenX;\n      this.uniforms.rotation[1] = wt.b / lenX;\n      this.uniforms.rotation[2] = wt.c / lenY;\n      this.uniforms.rotation[3] = wt.d / lenY;\n    }\n    filterManager.applyFilter(this, input, output, clearMode);\n  };\n  Object.defineProperty(DisplacementFilter.prototype, \"map\", {\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(value2) {\n      this.uniforms.mapSampler = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DisplacementFilter;\n})(Filter);\n/*!\n * @pixi/filter-fxaa - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-fxaa is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$a = function(d2, b2) {\n  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$a(d2, b2);\n};\nfunction __extends$a(d2, b2) {\n  extendStatics$a(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar vertex = \"\\nattribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nvarying vec2 vFragCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\\n               out vec2 v_rgbM) {\\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\\n    v_rgbM = vec2(fragCoord * inverseVP);\\n}\\n\\nvoid main(void) {\\n\\n   gl_Position = filterVertexPosition();\\n\\n   vFragCoord = aVertexPosition * outputFrame.zw;\\n\\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n}\\n\";\nvar fragment$1 = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(_super) {\n  __extends$a(FXAAFilter, _super);\n  function FXAAFilter() {\n    return _super.call(this, vertex, fragment$1) || this;\n  }\n  return FXAAFilter;\n})(Filter);\n/*!\n * @pixi/filter-noise - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/filter-noise is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$9 = function(d2, b2) {\n  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$9(d2, b2);\n};\nfunction __extends$9(d2, b2) {\n  extendStatics$9(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar fragment = \"precision highp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform float uNoise;\\nuniform float uSeed;\\nuniform sampler2D uSampler;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\\n    float diff = (randomValue - 0.5) * uNoise;\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    // Premultiply alpha again.\\n    color.rgb *= color.a;\\n\\n    gl_FragColor = color;\\n}\\n\";\n(function(_super) {\n  __extends$9(NoiseFilter, _super);\n  function NoiseFilter(noise, seed2) {\n    if (noise === void 0) {\n      noise = 0.5;\n    }\n    if (seed2 === void 0) {\n      seed2 = Math.random();\n    }\n    var _this = _super.call(this, defaultFilterVertex, fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    _this.noise = noise;\n    _this.seed = seed2;\n    return _this;\n  }\n  Object.defineProperty(NoiseFilter.prototype, \"noise\", {\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(value2) {\n      this.uniforms.uNoise = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NoiseFilter.prototype, \"seed\", {\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(value2) {\n      this.uniforms.uSeed = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return NoiseFilter;\n})(Filter);\n/*!\n * @pixi/mixin-cache-as-bitmap - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV;\n(function(ENV2) {\n  ENV2[ENV2[\"WEBGL_LEGACY\"] = 0] = \"WEBGL_LEGACY\";\n  ENV2[ENV2[\"WEBGL\"] = 1] = \"WEBGL\";\n  ENV2[ENV2[\"WEBGL2\"] = 2] = \"WEBGL2\";\n})(ENV || (ENV = {}));\nvar RENDERER_TYPE;\n(function(RENDERER_TYPE2) {\n  RENDERER_TYPE2[RENDERER_TYPE2[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RENDERER_TYPE2[RENDERER_TYPE2[\"CANVAS\"] = 2] = \"CANVAS\";\n})(RENDERER_TYPE || (RENDERER_TYPE = {}));\nvar BUFFER_BITS;\n(function(BUFFER_BITS2) {\n  BUFFER_BITS2[BUFFER_BITS2[\"COLOR\"] = 16384] = \"COLOR\";\n  BUFFER_BITS2[BUFFER_BITS2[\"DEPTH\"] = 256] = \"DEPTH\";\n  BUFFER_BITS2[BUFFER_BITS2[\"STENCIL\"] = 1024] = \"STENCIL\";\n})(BUFFER_BITS || (BUFFER_BITS = {}));\nvar BLEND_MODES;\n(function(BLEND_MODES2) {\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL\"] = 0] = \"NORMAL\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD\"] = 1] = \"ADD\";\n  BLEND_MODES2[BLEND_MODES2[\"MULTIPLY\"] = 2] = \"MULTIPLY\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN\"] = 3] = \"SCREEN\";\n  BLEND_MODES2[BLEND_MODES2[\"OVERLAY\"] = 4] = \"OVERLAY\";\n  BLEND_MODES2[BLEND_MODES2[\"DARKEN\"] = 5] = \"DARKEN\";\n  BLEND_MODES2[BLEND_MODES2[\"LIGHTEN\"] = 6] = \"LIGHTEN\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_DODGE\"] = 7] = \"COLOR_DODGE\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR_BURN\"] = 8] = \"COLOR_BURN\";\n  BLEND_MODES2[BLEND_MODES2[\"HARD_LIGHT\"] = 9] = \"HARD_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"SOFT_LIGHT\"] = 10] = \"SOFT_LIGHT\";\n  BLEND_MODES2[BLEND_MODES2[\"DIFFERENCE\"] = 11] = \"DIFFERENCE\";\n  BLEND_MODES2[BLEND_MODES2[\"EXCLUSION\"] = 12] = \"EXCLUSION\";\n  BLEND_MODES2[BLEND_MODES2[\"HUE\"] = 13] = \"HUE\";\n  BLEND_MODES2[BLEND_MODES2[\"SATURATION\"] = 14] = \"SATURATION\";\n  BLEND_MODES2[BLEND_MODES2[\"COLOR\"] = 15] = \"COLOR\";\n  BLEND_MODES2[BLEND_MODES2[\"LUMINOSITY\"] = 16] = \"LUMINOSITY\";\n  BLEND_MODES2[BLEND_MODES2[\"NORMAL_NPM\"] = 17] = \"NORMAL_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"ADD_NPM\"] = 18] = \"ADD_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"SCREEN_NPM\"] = 19] = \"SCREEN_NPM\";\n  BLEND_MODES2[BLEND_MODES2[\"NONE\"] = 20] = \"NONE\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OVER\"] = 0] = \"SRC_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_IN\"] = 21] = \"SRC_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_OUT\"] = 22] = \"SRC_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"SRC_ATOP\"] = 23] = \"SRC_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OVER\"] = 24] = \"DST_OVER\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_IN\"] = 25] = \"DST_IN\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_OUT\"] = 26] = \"DST_OUT\";\n  BLEND_MODES2[BLEND_MODES2[\"DST_ATOP\"] = 27] = \"DST_ATOP\";\n  BLEND_MODES2[BLEND_MODES2[\"ERASE\"] = 26] = \"ERASE\";\n  BLEND_MODES2[BLEND_MODES2[\"SUBTRACT\"] = 28] = \"SUBTRACT\";\n  BLEND_MODES2[BLEND_MODES2[\"XOR\"] = 29] = \"XOR\";\n})(BLEND_MODES || (BLEND_MODES = {}));\nvar DRAW_MODES;\n(function(DRAW_MODES2) {\n  DRAW_MODES2[DRAW_MODES2[\"POINTS\"] = 0] = \"POINTS\";\n  DRAW_MODES2[DRAW_MODES2[\"LINES\"] = 1] = \"LINES\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n  DRAW_MODES2[DRAW_MODES2[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n  DRAW_MODES2[DRAW_MODES2[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES || (DRAW_MODES = {}));\nvar FORMATS;\n(function(FORMATS2) {\n  FORMATS2[FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  FORMATS2[FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  FORMATS2[FORMATS2[\"RG\"] = 33319] = \"RG\";\n  FORMATS2[FORMATS2[\"RED\"] = 6403] = \"RED\";\n  FORMATS2[FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  FORMATS2[FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  FORMATS2[FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  FORMATS2[FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  FORMATS2[FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  FORMATS2[FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  FORMATS2[FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  FORMATS2[FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  FORMATS2[FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS || (FORMATS = {}));\nvar TARGETS;\n(function(TARGETS2) {\n  TARGETS2[TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  TARGETS2[TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  TARGETS2[TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS || (TARGETS = {}));\nvar TYPES;\n(function(TYPES2) {\n  TYPES2[TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  TYPES2[TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  TYPES2[TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  TYPES2[TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  TYPES2[TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  TYPES2[TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  TYPES2[TYPES2[\"INT\"] = 5124] = \"INT\";\n  TYPES2[TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  TYPES2[TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  TYPES2[TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n})(TYPES || (TYPES = {}));\nvar SAMPLER_TYPES;\n(function(SAMPLER_TYPES2) {\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"FLOAT\"] = 0] = \"FLOAT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"INT\"] = 1] = \"INT\";\n  SAMPLER_TYPES2[SAMPLER_TYPES2[\"UINT\"] = 2] = \"UINT\";\n})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));\nvar SCALE_MODES;\n(function(SCALE_MODES2) {\n  SCALE_MODES2[SCALE_MODES2[\"NEAREST\"] = 0] = \"NEAREST\";\n  SCALE_MODES2[SCALE_MODES2[\"LINEAR\"] = 1] = \"LINEAR\";\n})(SCALE_MODES || (SCALE_MODES = {}));\nvar WRAP_MODES;\n(function(WRAP_MODES2) {\n  WRAP_MODES2[WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  WRAP_MODES2[WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  WRAP_MODES2[WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES || (WRAP_MODES = {}));\nvar MIPMAP_MODES;\n(function(MIPMAP_MODES2) {\n  MIPMAP_MODES2[MIPMAP_MODES2[\"OFF\"] = 0] = \"OFF\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"POW2\"] = 1] = \"POW2\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON\"] = 2] = \"ON\";\n  MIPMAP_MODES2[MIPMAP_MODES2[\"ON_MANUAL\"] = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES || (MIPMAP_MODES = {}));\nvar ALPHA_MODES;\n(function(ALPHA_MODES2) {\n  ALPHA_MODES2[ALPHA_MODES2[\"NPM\"] = 0] = \"NPM\";\n  ALPHA_MODES2[ALPHA_MODES2[\"UNPACK\"] = 1] = \"UNPACK\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PMA\"] = 2] = \"PMA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"NO_PREMULTIPLIED_ALPHA\"] = 0] = \"NO_PREMULTIPLIED_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ON_UPLOAD\"] = 1] = \"PREMULTIPLY_ON_UPLOAD\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLY_ALPHA\"] = 2] = \"PREMULTIPLY_ALPHA\";\n  ALPHA_MODES2[ALPHA_MODES2[\"PREMULTIPLIED_ALPHA\"] = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES || (ALPHA_MODES = {}));\nvar CLEAR_MODES;\n(function(CLEAR_MODES2) {\n  CLEAR_MODES2[CLEAR_MODES2[\"NO\"] = 0] = \"NO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"YES\"] = 1] = \"YES\";\n  CLEAR_MODES2[CLEAR_MODES2[\"AUTO\"] = 2] = \"AUTO\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLEND\"] = 0] = \"BLEND\";\n  CLEAR_MODES2[CLEAR_MODES2[\"CLEAR\"] = 1] = \"CLEAR\";\n  CLEAR_MODES2[CLEAR_MODES2[\"BLIT\"] = 2] = \"BLIT\";\n})(CLEAR_MODES || (CLEAR_MODES = {}));\nvar GC_MODES;\n(function(GC_MODES2) {\n  GC_MODES2[GC_MODES2[\"AUTO\"] = 0] = \"AUTO\";\n  GC_MODES2[GC_MODES2[\"MANUAL\"] = 1] = \"MANUAL\";\n})(GC_MODES || (GC_MODES = {}));\nvar PRECISION;\n(function(PRECISION2) {\n  PRECISION2[\"LOW\"] = \"lowp\";\n  PRECISION2[\"MEDIUM\"] = \"mediump\";\n  PRECISION2[\"HIGH\"] = \"highp\";\n})(PRECISION || (PRECISION = {}));\nvar MASK_TYPES;\n(function(MASK_TYPES2) {\n  MASK_TYPES2[MASK_TYPES2[\"NONE\"] = 0] = \"NONE\";\n  MASK_TYPES2[MASK_TYPES2[\"SCISSOR\"] = 1] = \"SCISSOR\";\n  MASK_TYPES2[MASK_TYPES2[\"STENCIL\"] = 2] = \"STENCIL\";\n  MASK_TYPES2[MASK_TYPES2[\"SPRITE\"] = 3] = \"SPRITE\";\n})(MASK_TYPES || (MASK_TYPES = {}));\nvar MSAA_QUALITY;\n(function(MSAA_QUALITY2) {\n  MSAA_QUALITY2[MSAA_QUALITY2[\"NONE\"] = 0] = \"NONE\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"LOW\"] = 2] = \"LOW\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"MEDIUM\"] = 4] = \"MEDIUM\";\n  MSAA_QUALITY2[MSAA_QUALITY2[\"HIGH\"] = 8] = \"HIGH\";\n})(MSAA_QUALITY || (MSAA_QUALITY = {}));\nvar BUFFER_TYPE;\n(function(BUFFER_TYPE2) {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE || (BUFFER_TYPE = {}));\nvar _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;\nvar CacheData = function() {\n  function CacheData2() {\n    this.textureCacheId = null;\n    this.originalRender = null;\n    this.originalRenderCanvas = null;\n    this.originalCalculateBounds = null;\n    this.originalGetLocalBounds = null;\n    this.originalUpdateTransform = null;\n    this.originalDestroy = null;\n    this.originalMask = null;\n    this.originalFilterArea = null;\n    this.originalContainsPoint = null;\n    this.sprite = null;\n  }\n  return CacheData2;\n}();\nObject.defineProperties(DisplayObject.prototype, {\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(resolution) {\n      if (resolution === this._cacheAsBitmapResolution) {\n        return;\n      }\n      this._cacheAsBitmapResolution = resolution;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(multisample) {\n      if (multisample === this._cacheAsBitmapMultisample) {\n        return;\n      }\n      this._cacheAsBitmapMultisample = multisample;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(value2) {\n      if (this._cacheAsBitmap === value2) {\n        return;\n      }\n      this._cacheAsBitmap = value2;\n      var data;\n      if (value2) {\n        if (!this._cacheData) {\n          this._cacheData = new CacheData();\n        }\n        data = this._cacheData;\n        data.originalRender = this.render;\n        data.originalRenderCanvas = this.renderCanvas;\n        data.originalUpdateTransform = this.updateTransform;\n        data.originalCalculateBounds = this.calculateBounds;\n        data.originalGetLocalBounds = this.getLocalBounds;\n        data.originalDestroy = this.destroy;\n        data.originalContainsPoint = this.containsPoint;\n        data.originalMask = this._mask;\n        data.originalFilterArea = this.filterArea;\n        this.render = this._renderCached;\n        this.renderCanvas = this._renderCachedCanvas;\n        this.destroy = this._cacheAsBitmapDestroy;\n      } else {\n        data = this._cacheData;\n        if (data.sprite) {\n          this._destroyCachedDisplayObject();\n        }\n        this.render = data.originalRender;\n        this.renderCanvas = data.originalRenderCanvas;\n        this.calculateBounds = data.originalCalculateBounds;\n        this.getLocalBounds = data.originalGetLocalBounds;\n        this.destroy = data.originalDestroy;\n        this.updateTransform = data.originalUpdateTransform;\n        this.containsPoint = data.originalContainsPoint;\n        this._mask = data.originalMask;\n        this.filterArea = data.originalFilterArea;\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function _renderCached(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObject(renderer);\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._render(renderer);\n};\nDisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {\n  var _a3;\n  if (this._cacheData && this._cacheData.sprite) {\n    return;\n  }\n  var cacheAlpha = this.alpha;\n  this.alpha = 1;\n  renderer.batch.flush();\n  var bounds = this.getLocalBounds(null, true).clone();\n  if (this.filters && this.filters.length) {\n    var padding = this.filters[0].padding;\n    bounds.pad(padding);\n  }\n  bounds.ceil(settings.RESOLUTION);\n  var cachedRenderTexture = renderer.renderTexture.current;\n  var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();\n  var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();\n  var cachedProjectionTransform = renderer.projection.transform;\n  var renderTexture = RenderTexture.create({\n    width: bounds.width,\n    height: bounds.height,\n    resolution: this.cacheAsBitmapResolution || renderer.resolution,\n    multisample: (_a3 = this.cacheAsBitmapMultisample) !== null && _a3 !== void 0 ? _a3 : renderer.multisample\n  });\n  var textureCacheId = \"cacheAsBitmap_\" + uid();\n  this._cacheData.textureCacheId = textureCacheId;\n  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n  Texture.addToCache(renderTexture, textureCacheId);\n  var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n  this.render = this._cacheData.originalRender;\n  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });\n  renderer.framebuffer.blit();\n  renderer.projection.transform = cachedProjectionTransform;\n  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);\n  this.render = this._renderCached;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  var cachedSprite = new Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.enableTempParent();\n    this.updateTransform();\n    this.disableTempParent(null);\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObjectCanvas(renderer);\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._renderCanvas(renderer);\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {\n  if (this._cacheData && this._cacheData.sprite) {\n    return;\n  }\n  var bounds = this.getLocalBounds(null, true);\n  var cacheAlpha = this.alpha;\n  this.alpha = 1;\n  var cachedRenderTarget = renderer.context;\n  var cachedProjectionTransform = renderer._projTransform;\n  bounds.ceil(settings.RESOLUTION);\n  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });\n  var textureCacheId = \"cacheAsBitmap_\" + uid();\n  this._cacheData.textureCacheId = textureCacheId;\n  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n  Texture.addToCache(renderTexture, textureCacheId);\n  var m2 = _tempMatrix;\n  this.transform.localTransform.copyTo(m2);\n  m2.invert();\n  m2.tx -= bounds.x;\n  m2.ty -= bounds.y;\n  this.renderCanvas = this._cacheData.originalRenderCanvas;\n  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });\n  renderer.context = cachedRenderTarget;\n  renderer._projTransform = cachedProjectionTransform;\n  this.renderCanvas = this._renderCachedCanvas;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  var cachedSprite = new Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.parent = renderer._tempDisplayObjectParent;\n    this.updateTransform();\n    this.parent = null;\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {\n  this._bounds.clear();\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite._calculateBounds();\n  this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {\n  this._cacheData.sprite._texture.destroy(true);\n  this._cacheData.sprite = null;\n  BaseTexture.removeFromCache(this._cacheData.textureCacheId);\n  Texture.removeFromCache(this._cacheData.textureCacheId);\n  this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {\n  this.cacheAsBitmap = false;\n  this.destroy(options);\n};\n/*!\n * @pixi/mixin-get-child-by-name - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/mixin-get-child-by-name is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.name = null;\nContainer.prototype.getChildByName = function getChildByName(name, deep) {\n  for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {\n    if (this.children[i2].name === name) {\n      return this.children[i2];\n    }\n  }\n  if (deep) {\n    for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {\n      var child = this.children[i2];\n      if (!child.getChildByName) {\n        continue;\n      }\n      var target = this.children[i2].getChildByName(name, true);\n      if (target) {\n        return target;\n      }\n    }\n  }\n  return null;\n};\n/*!\n * @pixi/mixin-get-global-position - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/mixin-get-global-position is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {\n  if (point === void 0) {\n    point = new Point();\n  }\n  if (skipUpdate === void 0) {\n    skipUpdate = false;\n  }\n  if (this.parent) {\n    this.parent.toGlobal(this.position, point, skipUpdate);\n  } else {\n    point.x = this.position.x;\n    point.y = this.position.y;\n  }\n  return point;\n};\n/*!\n * @pixi/mesh-extras - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$8 = function(d2, b2) {\n  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$8(d2, b2);\n};\nfunction __extends$8(d2, b2) {\n  extendStatics$8(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar PlaneGeometry = function(_super) {\n  __extends$8(PlaneGeometry2, _super);\n  function PlaneGeometry2(width, height, segWidth, segHeight) {\n    if (width === void 0) {\n      width = 100;\n    }\n    if (height === void 0) {\n      height = 100;\n    }\n    if (segWidth === void 0) {\n      segWidth = 10;\n    }\n    if (segHeight === void 0) {\n      segHeight = 10;\n    }\n    var _this = _super.call(this) || this;\n    _this.segWidth = segWidth;\n    _this.segHeight = segHeight;\n    _this.width = width;\n    _this.height = height;\n    _this.build();\n    return _this;\n  }\n  PlaneGeometry2.prototype.build = function() {\n    var total = this.segWidth * this.segHeight;\n    var verts = [];\n    var uvs = [];\n    var indices2 = [];\n    var segmentsX = this.segWidth - 1;\n    var segmentsY = this.segHeight - 1;\n    var sizeX = this.width / segmentsX;\n    var sizeY = this.height / segmentsY;\n    for (var i2 = 0; i2 < total; i2++) {\n      var x2 = i2 % this.segWidth;\n      var y2 = i2 / this.segWidth | 0;\n      verts.push(x2 * sizeX, y2 * sizeY);\n      uvs.push(x2 / segmentsX, y2 / segmentsY);\n    }\n    var totalSub = segmentsX * segmentsY;\n    for (var i2 = 0; i2 < totalSub; i2++) {\n      var xpos = i2 % segmentsX;\n      var ypos = i2 / segmentsX | 0;\n      var value2 = ypos * this.segWidth + xpos;\n      var value22 = ypos * this.segWidth + xpos + 1;\n      var value3 = (ypos + 1) * this.segWidth + xpos;\n      var value4 = (ypos + 1) * this.segWidth + xpos + 1;\n      indices2.push(value2, value22, value3, value22, value4, value3);\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint16Array(indices2);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  };\n  return PlaneGeometry2;\n}(MeshGeometry);\nvar RopeGeometry = function(_super) {\n  __extends$8(RopeGeometry2, _super);\n  function RopeGeometry2(width, points, textureScale) {\n    if (width === void 0) {\n      width = 200;\n    }\n    if (textureScale === void 0) {\n      textureScale = 0;\n    }\n    var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;\n    _this.points = points;\n    _this._width = width;\n    _this.textureScale = textureScale;\n    _this.build();\n    return _this;\n  }\n  Object.defineProperty(RopeGeometry2.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  RopeGeometry2.prototype.build = function() {\n    var points = this.points;\n    if (!points) {\n      return;\n    }\n    var vertexBuffer = this.getBuffer(\"aVertexPosition\");\n    var uvBuffer = this.getBuffer(\"aTextureCoord\");\n    var indexBuffer = this.getIndex();\n    if (points.length < 1) {\n      return;\n    }\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    var uvs = uvBuffer.data;\n    var indices2 = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    var amount = 0;\n    var prev2 = points[0];\n    var textureWidth = this._width * this.textureScale;\n    var total = points.length;\n    for (var i2 = 0; i2 < total; i2++) {\n      var index = i2 * 4;\n      if (this.textureScale > 0) {\n        var dx = prev2.x - points[i2].x;\n        var dy = prev2.y - points[i2].y;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        prev2 = points[i2];\n        amount += distance / textureWidth;\n      } else {\n        amount = i2 / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    var indexCount = 0;\n    for (var i2 = 0; i2 < total - 1; i2++) {\n      var index = i2 * 2;\n      indices2[indexCount++] = index;\n      indices2[indexCount++] = index + 1;\n      indices2[indexCount++] = index + 2;\n      indices2[indexCount++] = index + 2;\n      indices2[indexCount++] = index + 1;\n      indices2[indexCount++] = index + 3;\n    }\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  };\n  RopeGeometry2.prototype.updateVertices = function() {\n    var points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    var lastPoint = points[0];\n    var nextPoint;\n    var perpX = 0;\n    var perpY = 0;\n    var vertices = this.buffers[0].data;\n    var total = points.length;\n    for (var i2 = 0; i2 < total; i2++) {\n      var point = points[i2];\n      var index = i2 * 4;\n      if (i2 < points.length - 1) {\n        nextPoint = points[i2 + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  };\n  RopeGeometry2.prototype.update = function() {\n    if (this.textureScale > 0) {\n      this.build();\n    } else {\n      this.updateVertices();\n    }\n  };\n  return RopeGeometry2;\n}(MeshGeometry);\n(function(_super) {\n  __extends$8(SimpleRope, _super);\n  function SimpleRope(texture, points, textureScale) {\n    if (textureScale === void 0) {\n      textureScale = 0;\n    }\n    var _this = this;\n    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n    var meshMaterial = new MeshMaterial(texture);\n    if (textureScale > 0) {\n      texture.baseTexture.wrapMode = WRAP_MODES$3.REPEAT;\n    }\n    _this = _super.call(this, ropeGeometry, meshMaterial) || this;\n    _this.autoUpdate = true;\n    return _this;\n  }\n  SimpleRope.prototype._render = function(renderer) {\n    var geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  return SimpleRope;\n})(Mesh);\nvar SimplePlane = function(_super) {\n  __extends$8(SimplePlane2, _super);\n  function SimplePlane2(texture, verticesX, verticesY) {\n    var _this = this;\n    var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n    var meshMaterial = new MeshMaterial(Texture.WHITE);\n    _this = _super.call(this, planeGeometry, meshMaterial) || this;\n    _this.texture = texture;\n    _this.autoResize = true;\n    return _this;\n  }\n  SimplePlane2.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID;\n    var geometry = this.geometry;\n    var _a3 = this.shader.texture, width = _a3.width, height = _a3.height;\n    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {\n      geometry.width = this.shader.texture.width;\n      geometry.height = this.shader.texture.height;\n      geometry.build();\n    }\n  };\n  Object.defineProperty(SimplePlane2.prototype, \"texture\", {\n    get: function() {\n      return this.shader.texture;\n    },\n    set: function(value2) {\n      if (this.shader.texture === value2) {\n        return;\n      }\n      this.shader.texture = value2;\n      this._textureID = -1;\n      if (value2.baseTexture.valid) {\n        this.textureUpdated();\n      } else {\n        value2.once(\"update\", this.textureUpdated, this);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SimplePlane2.prototype._render = function(renderer) {\n    if (this._textureID !== this.shader.texture._updateID) {\n      this.textureUpdated();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  SimplePlane2.prototype.destroy = function(options) {\n    this.shader.texture.off(\"update\", this.textureUpdated, this);\n    _super.prototype.destroy.call(this, options);\n  };\n  return SimplePlane2;\n}(Mesh);\n(function(_super) {\n  __extends$8(SimpleMesh, _super);\n  function SimpleMesh(texture, vertices, uvs, indices2, drawMode) {\n    if (texture === void 0) {\n      texture = Texture.EMPTY;\n    }\n    var _this = this;\n    var geometry = new MeshGeometry(vertices, uvs, indices2);\n    geometry.getBuffer(\"aVertexPosition\").static = false;\n    var meshMaterial = new MeshMaterial(texture);\n    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;\n    _this.autoUpdate = true;\n    return _this;\n  }\n  Object.defineProperty(SimpleMesh.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(value2) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SimpleMesh.prototype._render = function(renderer) {\n    if (this.autoUpdate) {\n      this.geometry.getBuffer(\"aVertexPosition\").update();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  return SimpleMesh;\n})(Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n(function(_super) {\n  __extends$8(NineSlicePlane, _super);\n  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {\n    if (leftWidth === void 0) {\n      leftWidth = DEFAULT_BORDER_SIZE;\n    }\n    if (topHeight === void 0) {\n      topHeight = DEFAULT_BORDER_SIZE;\n    }\n    if (rightWidth === void 0) {\n      rightWidth = DEFAULT_BORDER_SIZE;\n    }\n    if (bottomHeight === void 0) {\n      bottomHeight = DEFAULT_BORDER_SIZE;\n    }\n    var _this = _super.call(this, Texture.WHITE, 4, 4) || this;\n    _this._origWidth = texture.orig.width;\n    _this._origHeight = texture.orig.height;\n    _this._width = _this._origWidth;\n    _this._height = _this._origHeight;\n    _this._leftWidth = leftWidth;\n    _this._rightWidth = rightWidth;\n    _this._topHeight = topHeight;\n    _this._bottomHeight = bottomHeight;\n    _this.texture = texture;\n    return _this;\n  }\n  NineSlicePlane.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID;\n    this._refresh();\n  };\n  Object.defineProperty(NineSlicePlane.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(value2) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = value2;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  NineSlicePlane.prototype.updateHorizontalVertices = function() {\n    var vertices = this.vertices;\n    var scale = this._getMinScale();\n    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;\n    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n  };\n  NineSlicePlane.prototype.updateVerticalVertices = function() {\n    var vertices = this.vertices;\n    var scale = this._getMinScale();\n    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;\n    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n  };\n  NineSlicePlane.prototype._getMinScale = function() {\n    var w2 = this._leftWidth + this._rightWidth;\n    var scaleW = this._width > w2 ? 1 : this._width / w2;\n    var h2 = this._topHeight + this._bottomHeight;\n    var scaleH = this._height > h2 ? 1 : this._height / h2;\n    var scale = Math.min(scaleW, scaleH);\n    return scale;\n  };\n  Object.defineProperty(NineSlicePlane.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(value2) {\n      this._width = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(value2) {\n      this._height = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"leftWidth\", {\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(value2) {\n      this._leftWidth = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"rightWidth\", {\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(value2) {\n      this._rightWidth = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"topHeight\", {\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(value2) {\n      this._topHeight = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"bottomHeight\", {\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(value2) {\n      this._bottomHeight = value2;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  NineSlicePlane.prototype._refresh = function() {\n    var texture = this.texture;\n    var uvs = this.geometry.buffers[1].data;\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    var _uvw = 1 / this._origWidth;\n    var _uvh = 1 / this._origHeight;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.updateHorizontalVertices();\n    this.updateVerticalVertices();\n    this.geometry.buffers[0].update();\n    this.geometry.buffers[1].update();\n  };\n  return NineSlicePlane;\n})(SimplePlane);\n/*!\n * @pixi/sprite-animated - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$7 = function(d2, b2) {\n  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3) {\n      if (b3.hasOwnProperty(p2)) {\n        d3[p2] = b3[p2];\n      }\n    }\n  };\n  return extendStatics$7(d2, b2);\n};\nfunction __extends$7(d2, b2) {\n  extendStatics$7(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar AnimatedSprite = function(_super) {\n  __extends$7(AnimatedSprite2, _super);\n  function AnimatedSprite2(textures, autoUpdate) {\n    if (autoUpdate === void 0) {\n      autoUpdate = true;\n    }\n    var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;\n    _this._textures = null;\n    _this._durations = null;\n    _this._autoUpdate = autoUpdate;\n    _this._isConnectedToTicker = false;\n    _this.animationSpeed = 1;\n    _this.loop = true;\n    _this.updateAnchor = false;\n    _this.onComplete = null;\n    _this.onFrameChange = null;\n    _this.onLoop = null;\n    _this._currentTime = 0;\n    _this._playing = false;\n    _this._previousFrame = null;\n    _this.textures = textures;\n    return _this;\n  }\n  AnimatedSprite2.prototype.stop = function() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  };\n  AnimatedSprite2.prototype.play = function() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  };\n  AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {\n    this.stop();\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n  };\n  AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {\n    var previousFrame = this.currentFrame;\n    this._currentTime = frameNumber;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n    this.play();\n  };\n  AnimatedSprite2.prototype.update = function(deltaTime) {\n    if (!this._playing) {\n      return;\n    }\n    var elapsed = this.animationSpeed * deltaTime;\n    var previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      var sign2 = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign2;\n        this._currentTime += sign2;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n          this.onLoop();\n        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this.updateTexture();\n    }\n  };\n  AnimatedSprite2.prototype.updateTexture = function() {\n    var currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this._texture = this._textures[currentFrame];\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    this.uvs = this._texture._uvs.uvsFloat32;\n    if (this.updateAnchor) {\n      this._anchor.copyFrom(this._texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  };\n  AnimatedSprite2.prototype.destroy = function(options) {\n    this.stop();\n    _super.prototype.destroy.call(this, options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  };\n  AnimatedSprite2.fromFrames = function(frames) {\n    var textures = [];\n    for (var i2 = 0; i2 < frames.length; ++i2) {\n      textures.push(Texture.from(frames[i2]));\n    }\n    return new AnimatedSprite2(textures);\n  };\n  AnimatedSprite2.fromImages = function(images) {\n    var textures = [];\n    for (var i2 = 0; i2 < images.length; ++i2) {\n      textures.push(Texture.from(images[i2]));\n    }\n    return new AnimatedSprite2(textures);\n  };\n  Object.defineProperty(AnimatedSprite2.prototype, \"totalFrames\", {\n    get: function() {\n      return this._textures.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite2.prototype, \"textures\", {\n    get: function() {\n      return this._textures;\n    },\n    set: function(value2) {\n      if (value2[0] instanceof Texture) {\n        this._textures = value2;\n        this._durations = null;\n      } else {\n        this._textures = [];\n        this._durations = [];\n        for (var i2 = 0; i2 < value2.length; i2++) {\n          this._textures.push(value2[i2].texture);\n          this._durations.push(value2[i2].time);\n        }\n      }\n      this._previousFrame = null;\n      this.gotoAndStop(0);\n      this.updateTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite2.prototype, \"currentFrame\", {\n    get: function() {\n      var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n      if (currentFrame < 0) {\n        currentFrame += this._textures.length;\n      }\n      return currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite2.prototype, \"playing\", {\n    get: function() {\n      return this._playing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimatedSprite2.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(value2) {\n      if (value2 !== this._autoUpdate) {\n        this._autoUpdate = value2;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n          Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return AnimatedSprite2;\n}(Sprite);\n/*!\n * pixi.js - v6.3.2\n * Compiled Wed, 04 May 2022 17:49:13 UTC\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nRenderer.registerPlugin(\"accessibility\", AccessibilityManager);\nRenderer.registerPlugin(\"extract\", Extract);\nRenderer.registerPlugin(\"interaction\", InteractionManager);\nRenderer.registerPlugin(\"particle\", ParticleRenderer);\nRenderer.registerPlugin(\"prepare\", Prepare);\nRenderer.registerPlugin(\"batch\", BatchRenderer);\nRenderer.registerPlugin(\"tilingSprite\", TilingSpriteRenderer);\nLoader.registerPlugin(BitmapFontLoader);\nLoader.registerPlugin(CompressedTextureLoader);\nLoader.registerPlugin(DDSLoader);\nLoader.registerPlugin(KTXLoader);\nLoader.registerPlugin(SpritesheetLoader);\nApplication.registerPlugin(TickerPlugin);\nApplication.registerPlugin(AppLoaderPlugin);\nconst _SoundMng = class {\n  constructor(cfg, hTag, val, main2, sys) {\n    __privateAdd2(this, _volume);\n    __privateAdd2(this, _getVol);\n    __privateAdd2(this, _fadeoutbgm);\n    __privateAdd2(this, _fadeoutse);\n    __privateAdd2(this, _fadebgm);\n    __privateAdd2(this, _fadese);\n    __privateAdd2(this, _playbgm);\n    __privateAdd2(this, _playse);\n    __privateAdd2(this, _playseSub);\n    __privateAdd2(this, _stop_allse);\n    __privateAdd2(this, _stopbgm);\n    __privateAdd2(this, _stopse);\n    __privateAdd2(this, _wb);\n    __privateAdd2(this, _wf);\n    __privateAdd2(this, _stopfadese);\n    __privateAdd2(this, _wl);\n    __privateAdd2(this, _ws);\n    __privateAdd2(this, _xchgbuf);\n    __privateAdd2(this, _addLoopPlay);\n    __privateAdd2(this, _delLoopPlay);\n    __privateAdd2(this, _hSndBuf, {});\n    __privateAdd2(this, _hLP, {});\n    __privateAdd2(this, _evtMng2, void 0);\n    __privateAdd2(this, _initVol, () => {\n      I.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1));\n      __privateSet2(this, _initVol, () => {\n      });\n    });\n    this.cfg = cfg;\n    this.val = val;\n    this.main = main2;\n    this.sys = sys;\n    hTag.volume = (o) => __privateMethod2(this, _volume, volume_fn).call(this, o);\n    hTag.fadebgm = (o) => __privateMethod2(this, _fadebgm, fadebgm_fn).call(this, o);\n    hTag.fadeoutbgm = (o) => __privateMethod2(this, _fadeoutbgm, fadeoutbgm_fn).call(this, o);\n    hTag.fadeoutse = (o) => __privateMethod2(this, _fadeoutse, fadeoutse_fn).call(this, o);\n    hTag.fadese = (o) => __privateMethod2(this, _fadese, fadese_fn).call(this, o);\n    hTag.playbgm = (o) => __privateMethod2(this, _playbgm, playbgm_fn).call(this, o);\n    hTag.playse = (o) => __privateMethod2(this, _playse, playse_fn).call(this, o);\n    hTag.stop_allse = () => __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);\n    hTag.stopbgm = (o) => __privateMethod2(this, _stopbgm, stopbgm_fn).call(this, o);\n    hTag.stopse = (o) => __privateMethod2(this, _stopse, stopse_fn).call(this, o);\n    hTag.wb = (o) => __privateMethod2(this, _wb, wb_fn).call(this, o);\n    hTag.wf = (o) => __privateMethod2(this, _wf, wf_fn).call(this, o);\n    hTag.stopfadese = (o) => __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, o);\n    hTag.wl = (o) => __privateMethod2(this, _wl, wl_fn).call(this, o);\n    hTag.ws = (o) => __privateMethod2(this, _ws, ws_fn).call(this, o);\n    hTag.xchgbuf = (o) => __privateMethod2(this, _xchgbuf, xchgbuf_fn).call(this, o);\n    this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\");\n    val.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(G.supported));\n  }\n  setEvtMng(evtMng) {\n    __privateSet2(this, _evtMng2, evtMng);\n  }\n  setNoticeChgVolume(setGlbVol, setMovVol) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (_name, val) => setGlbVol(I.volumeAll = Number(val)));\n    this.val.defValTrg(\"sys:sn.sound.movie_volume\", (_name, val) => setMovVol(Number(val)));\n    this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1));\n    this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    I.removeAll();\n  }\n  loadAheadSnd(hArg) {\n    [hArg.clickse, hArg.enterse, hArg.leavese].forEach((fn2) => {\n      if (!fn2 || I.exists(fn2))\n        return;\n      __privateMethod2(this, _playseSub, playseSub_fn).call(this, \"\", fn2, { preload: true, autoPlay: false });\n    });\n  }\n  playLoopFromSaveObj() {\n    const lp = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    this.val.flush();\n    if (lp === \"{}\") {\n      __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);\n      return;\n    }\n    const aFnc = [];\n    __privateSet2(this, _hLP, JSON.parse(lp));\n    for (const buf in __privateGet2(this, _hLP)) {\n      const nm = \"save:const.sn.sound.\" + buf + \".\";\n      const hArg = {\n        fn: String(this.val.getVal(nm + \"fn\")),\n        buf,\n        join: false,\n        loop: true,\n        volume: Number(this.val.getVal(nm + \"volume\")),\n        start_ms: Number(this.val.getVal(nm + \"start_ms\")),\n        end_ms: Number(this.val.getVal(nm + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(nm + \"ret_ms\"))\n      };\n      aFnc.push(() => {\n        if (hArg.buf === \"BGM\")\n          __privateMethod2(this, _playbgm, playbgm_fn).call(this, hArg);\n        else\n          __privateMethod2(this, _playse, playse_fn).call(this, hArg);\n      });\n    }\n    __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);\n    aFnc.forEach((f2) => f2());\n  }\n};\nlet SoundMng = _SoundMng;\n_hSndBuf = new WeakMap();\n_hLP = new WeakMap();\n_evtMng2 = new WeakMap();\n_volume = new WeakSet();\nvolume_fn = function(hArg) {\n  const { buf = \"SE\" } = hArg;\n  const bvn = \"const.sn.sound.\" + buf + \".volume\";\n  const arg_vol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, 1);\n  if (Number(this.val.getVal(\"sys:\" + bvn)) === arg_vol)\n    return false;\n  this.val.setVal_Nochk(\"sys\", bvn, arg_vol);\n  this.val.flush();\n  hArg.time = 0;\n  hArg.volume = Number(this.val.getVal(\"save:\" + bvn));\n  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);\n};\n_getVol = new WeakSet();\ngetVol_fn = function(hArg, def) {\n  const vol = argChk_Num(hArg, \"volume\", def);\n  if (vol < 0)\n    return 0;\n  if (vol > 1)\n    return 1;\n  return vol;\n};\n_fadeoutbgm = new WeakSet();\nfadeoutbgm_fn = function(hArg) {\n  hArg.volume = 0;\n  return __privateMethod2(this, _fadebgm, fadebgm_fn).call(this, hArg);\n};\n_fadeoutse = new WeakSet();\nfadeoutse_fn = function(hArg) {\n  hArg.volume = 0;\n  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);\n};\n_fadebgm = new WeakSet();\nfadebgm_fn = function(hArg) {\n  hArg.buf = \"BGM\";\n  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);\n};\n_fadese = new WeakSet();\nfadese_fn = function(hArg) {\n  __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg);\n  const { buf = \"SE\" } = hArg;\n  const oSb = __privateGet2(this, _hSndBuf)[buf];\n  if (!(oSb == null ? void 0 : oSb.playing()) || !oSb.snd)\n    return false;\n  const bvn = \"const.sn.sound.\" + buf + \".volume\";\n  const savevol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, NaN);\n  this.val.setVal_Nochk(\"save\", bvn, savevol);\n  const vol = savevol * Number(this.val.getVal(\"sys:\" + bvn, 1));\n  const stop = argChk_Boolean(hArg, \"stop\", savevol === 0);\n  if (stop) {\n    __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);\n    this.val.setVal_Nochk(\"save\", \"const.sn.sound.\" + buf + \".fn\", \"\");\n  }\n  this.val.flush();\n  const time = argChk_Num(hArg, \"time\", NaN);\n  const delay = argChk_Num(hArg, \"delay\", 0);\n  if (time === 0 && delay === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || __privateGet2(this, _evtMng2).isSkippingByKeyDown()) {\n    oSb.snd.volume = vol;\n    if (stop)\n      __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);\n    return false;\n  }\n  const repeat = argChk_Num(hArg, \"repeat\", 1);\n  oSb.twFade = new Tween({ v: oSb.snd.volume }).to({ v: vol }, time).delay(delay).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, \"yoyo\", false)).onUpdate((o) => {\n    if (oSb.playing())\n      oSb.snd.volume = o.v;\n  }).onComplete(() => {\n    const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf = oSb.now_buf];\n    if (!(oSb2 == null ? void 0 : oSb2.twFade))\n      return;\n    delete oSb2.twFade;\n    if (stop)\n      __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);\n    if (oSb2.resumeFade)\n      this.main.resume();\n  }).start();\n  return false;\n};\n_playbgm = new WeakSet();\nplaybgm_fn = function(hArg) {\n  hArg.buf = \"BGM\";\n  hArg.canskip = false;\n  argChk_Boolean(hArg, \"loop\", true);\n  return __privateMethod2(this, _playse, playse_fn).call(this, hArg);\n};\n_MAX_END_MS = new WeakMap();\n_playse = new WeakSet();\nplayse_fn = function(hArg) {\n  const { buf = \"SE\", fn: fn2 } = hArg;\n  __privateMethod2(this, _stopse, stopse_fn).call(this, { buf });\n  if (!fn2)\n    throw `[playse] fn\\u306F\\u5FC5\\u9808\\u3067\\u3059 buf:${buf}`;\n  if (argChk_Boolean(hArg, \"canskip\", true) && __privateGet2(this, _evtMng2).isSkippingByKeyDown())\n    return false;\n  const loop = argChk_Boolean(hArg, \"loop\", false);\n  __privateMethod2(this, _addLoopPlay, addLoopPlay_fn).call(this, buf, loop);\n  const nm = \"const.sn.sound.\" + buf + \".\";\n  this.val.setVal_Nochk(\"save\", nm + \"fn\", fn2);\n  const savevol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, 1);\n  this.val.setVal_Nochk(\"save\", nm + \"volume\", savevol);\n  const vol = savevol * Number(this.val.getVal(\"sys:\" + nm + \"volume\", 1));\n  const start_ms = argChk_Num(hArg, \"start_ms\", 0);\n  const end_ms = argChk_Num(hArg, \"end_ms\", __privateGet2(_SoundMng, _MAX_END_MS));\n  const ret_ms = argChk_Num(hArg, \"ret_ms\", 0);\n  if (start_ms < 0)\n    throw `[playse] start_ms:${start_ms} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if (ret_ms < 0)\n    throw `[playse] ret_ms:${ret_ms} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if (end_ms > 0) {\n    if (start_ms >= end_ms)\n      throw `[playse] start_ms:${start_ms} >= end_ms:${end_ms} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n    if (ret_ms >= end_ms)\n      throw `[playse] ret_ms:${ret_ms} >= end_ms:${end_ms} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n  }\n  this.val.setVal_Nochk(\"save\", nm + \"start_ms\", start_ms);\n  this.val.setVal_Nochk(\"save\", nm + \"end_ms\", end_ms);\n  this.val.setVal_Nochk(\"save\", nm + \"ret_ms\", ret_ms);\n  this.val.flush();\n  const snd = I.find(fn2);\n  const oSb = __privateGet2(this, _hSndBuf)[buf] = {\n    now_buf: buf,\n    snd,\n    loop,\n    start_ms,\n    end_ms,\n    ret_ms,\n    resume: false,\n    playing: () => true,\n    onend: () => {\n      const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf = oSb.now_buf];\n      if (!oSb2)\n        return;\n      delete __privateGet2(this, _hSndBuf)[hArg.buf];\n      oSb2.playing = () => false;\n      __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg);\n      if (oSb2.resume)\n        this.main.resume();\n    }\n  };\n  const o = {\n    loop,\n    volume: vol,\n    speed: argChk_Num(hArg, \"speed\", 1),\n    sprites: {},\n    loaded: (e, snd2) => {\n      if (e) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059a fn:${fn2} ${e}`, false);\n        return;\n      }\n      if (!snd2)\n        return;\n      const oSb2 = __privateGet2(this, _hSndBuf)[oSb.now_buf];\n      if (oSb2)\n        oSb2.snd = snd2;\n    }\n  };\n  let sp_nm = \"\";\n  if (start_ms > 0 || end_ms < __privateGet2(_SoundMng, _MAX_END_MS)) {\n    sp_nm = `${fn2};${start_ms};${end_ms};${ret_ms}`;\n    const os = o.sprites[sp_nm] = {\n      start: start_ms / 1e3,\n      end: end_ms / 1e3\n    };\n    o.preload = true;\n    const old = o.loaded;\n    o.loaded = (e, snd2) => {\n      if (e) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059b fn:${fn2} ${e}`, false);\n        return;\n      }\n      if (!snd2)\n        return;\n      const d2 = snd2.duration;\n      old == null ? void 0 : old(e, snd2);\n      if (os.end < 0) {\n        os.end += d2;\n        snd2.removeSprites(sp_nm);\n        snd2.addSprites(sp_nm, os);\n        if (os.start >= os.end)\n          throw `[playse] start_ms:${start_ms} >= end_ms:${end_ms}(${os.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n        if (ret_ms >= os.end * 1e3)\n          throw `[playse] ret_ms:${ret_ms} >= end_ms:${end_ms}(${os.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      }\n      if (os.start >= d2)\n        throw `[playse] start_ms:${start_ms} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${d2} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      if (end_ms !== __privateGet2(_SoundMng, _MAX_END_MS) && os.end >= d2)\n        throw `[playse] end_ms:${end_ms} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${d2} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      snd2.play(sp_nm, o.complete);\n    };\n  } else\n    o.autoPlay = true;\n  if (!loop)\n    o.complete = () => {\n      var _a3;\n      return (_a3 = __privateGet2(this, _hSndBuf)[oSb.now_buf]) == null ? void 0 : _a3.onend();\n    };\n  else if (ret_ms !== 0) {\n    o.loop = false;\n    o.complete = (snd2) => {\n      const d2 = snd2.duration;\n      const sp_nm2 = `${fn2};loop2;${end_ms};${ret_ms}`;\n      const o2 = {\n        preload: true,\n        loop: true,\n        volume: vol,\n        speed: o.speed,\n        sprites: {},\n        loaded: (_2, snd22) => {\n          if (!snd22)\n            return;\n          const oSb2 = __privateGet2(this, _hSndBuf)[oSb.now_buf];\n          if (oSb2)\n            oSb2.snd = snd22;\n          snd22.play(sp_nm2);\n        }\n      };\n      const o2s = o2.sprites[sp_nm2] = {\n        start: ret_ms / 1e3,\n        end: end_ms / 1e3\n      };\n      if (o2s.end < 0) {\n        o2s.end += d2;\n        snd2.removeSprites(sp_nm2);\n        snd2.addSprites(sp_nm2, o2s);\n      }\n      if (o2s.start >= d2)\n        throw `[playse] ret_ms:${ret_ms} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${d2} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn2, o2);\n    };\n  }\n  __privateGet2(this, _initVol).call(this);\n  if (snd) {\n    snd.volume = vol;\n    if (sp_nm)\n      __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn2, o);\n    else if (snd.isPlayable) {\n      const ab = snd.options.source;\n      if (!(ab instanceof ArrayBuffer) || ab.byteLength === 0)\n        snd.play(o);\n      else\n        oSb.snd = A.from(__spreadProps(__spreadValues({}, o), {\n          url: snd.options.url,\n          source: ab\n        }));\n    }\n    return false;\n  }\n  const join = argChk_Boolean(hArg, \"join\", true);\n  if (join) {\n    const old = o.loaded;\n    o.loaded = (e, snd2) => {\n      old == null ? void 0 : old(e, snd2);\n      this.main.resume();\n    };\n  }\n  __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn2, o);\n  return join;\n};\n_playseSub = new WeakSet();\nplayseSub_fn = function(buf, fn2, o) {\n  const url2 = this.cfg.searchPath(fn2, Config.EXT_SOUND);\n  if (url2.slice(-4) !== \".bin\") {\n    o.url = url2;\n    const snd = A.from(o);\n    if (buf)\n      __privateGet2(this, _hSndBuf)[buf].snd = snd;\n    if (!o.loop)\n      I.add(fn2, snd);\n    return;\n  }\n  new Loader().add({ name: fn2, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((res, next) => {\n    this.sys.dec(res.extension, res.data).then((r2) => {\n      res.data = r2;\n      next == null ? void 0 : next();\n    }).catch((e) => this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${res.name} ${e}`, false));\n  }).load((_ldr, hRes) => {\n    var _a3;\n    o.source = (_a3 = hRes[fn2]) == null ? void 0 : _a3.data;\n    const snd = A.from(o);\n    if (buf)\n      __privateGet2(this, _hSndBuf)[buf].snd = snd;\n    if (!o.loop)\n      I.add(fn2, snd);\n  });\n};\n_initVol = new WeakMap();\n_stop_allse = new WeakSet();\nstop_allse_fn = function() {\n  for (const buf in __privateGet2(this, _hSndBuf))\n    __privateMethod2(this, _stopse, stopse_fn).call(this, { buf });\n  __privateSet2(this, _hSndBuf, {});\n  I.stopAll();\n  return false;\n};\n_stopbgm = new WeakSet();\nstopbgm_fn = function(hArg) {\n  hArg.buf = \"BGM\";\n  return __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);\n};\n_stopse = new WeakSet();\nstopse_fn = function(hArg) {\n  var _a3;\n  const { buf = \"SE\" } = hArg;\n  __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);\n  const oSb = __privateGet2(this, _hSndBuf)[buf];\n  if (oSb) {\n    (_a3 = oSb.snd) == null ? void 0 : _a3.stop();\n    oSb.onend();\n  }\n  return false;\n};\n_wb = new WeakSet();\nwb_fn = function(hArg) {\n  hArg.buf = \"BGM\";\n  return __privateMethod2(this, _wf, wf_fn).call(this, hArg);\n};\n_wf = new WeakSet();\nwf_fn = function(hArg) {\n  const { buf = \"SE\" } = hArg;\n  const oSb = __privateGet2(this, _hSndBuf)[buf];\n  if (!(oSb == null ? void 0 : oSb.twFade) || !oSb.playing())\n    return false;\n  return oSb.resumeFade = __privateGet2(this, _evtMng2).waitEvent(() => __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg), argChk_Boolean(hArg, \"canskip\", true), argChk_Boolean(hArg, \"global\", false));\n};\n_stopfadese = new WeakSet();\nstopfadese_fn = function(hArg) {\n  var _a3, _b3;\n  const { buf = \"SE\" } = hArg;\n  (_b3 = (_a3 = __privateGet2(this, _hSndBuf)[buf]) == null ? void 0 : _a3.twFade) == null ? void 0 : _b3.stop().end();\n  return false;\n};\n_wl = new WeakSet();\nwl_fn = function(hArg) {\n  hArg.buf = \"BGM\";\n  return __privateMethod2(this, _ws, ws_fn).call(this, hArg);\n};\n_ws = new WeakSet();\nws_fn = function(hArg) {\n  const { buf = \"SE\" } = hArg;\n  const oSb = __privateGet2(this, _hSndBuf)[buf];\n  if (!(oSb == null ? void 0 : oSb.playing()) || oSb.loop)\n    return false;\n  return oSb.resume = __privateGet2(this, _evtMng2).waitEvent(() => {\n    hArg.buf = oSb.now_buf;\n    __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);\n    const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf];\n    if (!(oSb2 == null ? void 0 : oSb2.playing()) || oSb2.loop)\n      return;\n    oSb2.onend();\n  }, argChk_Boolean(hArg, \"canskip\", false), argChk_Boolean(hArg, \"global\", false));\n};\n_xchgbuf = new WeakSet();\nxchgbuf_fn = function(hArg) {\n  const { buf: buf1 = \"SE\", buf2 = \"SE\" } = hArg;\n  if (buf1 === buf2)\n    return false;\n  const sb1 = __privateGet2(this, _hSndBuf)[buf1];\n  if (sb1)\n    sb1.now_buf = buf2;\n  const sb2 = __privateGet2(this, _hSndBuf)[buf2];\n  if (sb2)\n    sb2.now_buf = buf1;\n  [__privateGet2(this, _hSndBuf)[buf1], __privateGet2(this, _hSndBuf)[buf2]] = [sb2, sb1];\n  const n1 = \"const.sn.sound.\" + buf1 + \".\";\n  const v1 = Number(this.val.getVal(\"save:\" + n1 + \"volume\"));\n  const f1 = Number(this.val.getVal(\"save:\" + n1 + \"fn\"));\n  const n2 = \"const.sn.sound.\" + buf2 + \".\";\n  const v2 = Number(this.val.getVal(\"save:\" + n2 + \"volume\"));\n  const f2 = Number(this.val.getVal(\"save:\" + n2 + \"fn\"));\n  this.val.setVal_Nochk(\"save\", n1 + \"volume\", v2);\n  this.val.setVal_Nochk(\"save\", n2 + \"volume\", v1);\n  this.val.setVal_Nochk(\"save\", n1 + \"fn\", f2);\n  this.val.setVal_Nochk(\"save\", n2 + \"fn\", f1);\n  if (buf1 in __privateGet2(this, _hLP) === buf2 in __privateGet2(this, _hLP)) {\n    if (buf1 in __privateGet2(this, _hLP)) {\n      delete __privateGet2(this, _hLP)[buf1];\n      __privateGet2(this, _hLP)[buf2] = 0;\n    } else {\n      delete __privateGet2(this, _hLP)[buf2];\n      __privateGet2(this, _hLP)[buf1] = 0;\n    }\n    this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(__privateGet2(this, _hLP)));\n  }\n  this.val.flush();\n  return false;\n};\n_addLoopPlay = new WeakSet();\naddLoopPlay_fn = function(buf, is_loop) {\n  if (!is_loop) {\n    __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);\n    return;\n  }\n  __privateGet2(this, _hLP)[buf] = 0;\n  this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(__privateGet2(this, _hLP)));\n  this.val.flush();\n};\n_delLoopPlay = new WeakSet();\ndelLoopPlay_fn = function(buf) {\n  delete __privateGet2(this, _hLP)[buf];\n  this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(__privateGet2(this, _hLP)));\n  this.val.flush();\n};\n__privateAdd2(SoundMng, _MAX_END_MS, 999e3);\nconst _Pages = class {\n  constructor(layer, cls, fore, back, hArg, sys, val, ret) {\n    __privateAdd2(this, _pg, void 0);\n    this.cls = cls;\n    this.hArg = hArg;\n    this.sys = sys;\n    this.val = val;\n    this.ret = ret;\n    this.lay = (hArg2) => this.getPage(hArg2).lay(hArg2);\n    this.getPage = (hArg2) => _Pages.argChk_page(hArg2, \"fore\") !== \"back\" ? __privateGet2(this, _pg).fore : __privateGet2(this, _pg).back;\n    const fncF = sys.hFactoryCls[cls];\n    if (!fncF)\n      throw `\\u5C5E\\u6027 class\\u3010${cls}\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059`;\n    __privateSet2(this, _pg, { fore: fncF(), back: fncF() });\n    __privateGet2(this, _pg).fore.layname = __privateGet2(this, _pg).back.layname = layer;\n    const nm = hArg[\":id_tag\"] = `layer:${layer} cls:${cls}`;\n    __privateGet2(this, _pg).fore.name = `${nm} page:A`;\n    __privateGet2(this, _pg).back.name = `${nm} page:B`;\n    fore.addChild(this.fore.spLay);\n    back.addChild(this.back.spLay);\n    argChk_Boolean(hArg, \"visible\", true);\n    argChk_Boolean(hArg, \"visible\", true);\n    ret.isWait = this.fore.lay(hArg) || this.back.lay(hArg);\n    const valnm = `const.sn.lay.${layer}`;\n    val.setVal_Nochk(\"tmp\", valnm, true);\n    val.defTmp(valnm + \".fore.alpha\", () => __privateGet2(this, _pg).fore.alpha);\n    val.defTmp(valnm + \".back.alpha\", () => __privateGet2(this, _pg).back.alpha);\n    val.defTmp(valnm + \".fore.height\", () => __privateGet2(this, _pg).fore.height);\n    val.defTmp(valnm + \".back.height\", () => __privateGet2(this, _pg).back.height);\n    val.defTmp(valnm + \".fore.visible\", () => __privateGet2(this, _pg).fore.spLay.visible);\n    val.defTmp(valnm + \".back.visible\", () => __privateGet2(this, _pg).back.spLay.visible);\n    val.defTmp(valnm + \".fore.width\", () => __privateGet2(this, _pg).fore.width);\n    val.defTmp(valnm + \".back.width\", () => __privateGet2(this, _pg).back.width);\n    val.defTmp(valnm + \".fore.x\", () => __privateGet2(this, _pg).fore.x);\n    val.defTmp(valnm + \".back.x\", () => __privateGet2(this, _pg).back.x);\n    val.defTmp(valnm + \".fore.y\", () => __privateGet2(this, _pg).fore.y);\n    val.defTmp(valnm + \".back.y\", () => __privateGet2(this, _pg).back.y);\n  }\n  destroy() {\n    __privateGet2(this, _pg).fore.destroy();\n    __privateGet2(this, _pg).back.destroy();\n  }\n  static argChk_page(hash2, def) {\n    var _a3;\n    const v2 = (_a3 = hash2.page) != null ? _a3 : def;\n    if (v2 === \"fore\")\n      return hash2.page = v2;\n    if (v2 === \"back\")\n      return hash2.page = v2;\n    throw Error(\"\\u5C5E\\u6027 page\\u3010\" + v2 + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\");\n  }\n  get fore() {\n    return __privateGet2(this, _pg).fore;\n  }\n  get back() {\n    return __privateGet2(this, _pg).back;\n  }\n  transPage(aPrm) {\n    [__privateGet2(this, _pg).back, __privateGet2(this, _pg).fore] = [__privateGet2(this, _pg).fore, __privateGet2(this, _pg).back];\n    __privateGet2(this, _pg).back.copy(__privateGet2(this, _pg).fore, aPrm);\n  }\n};\nlet Pages = _Pages;\n_pg = new WeakMap();\nconst _Layer = class {\n  constructor() {\n    this.layname = \"\";\n    this.name_ = \"\";\n    this.spLay = new Sprite(Texture.EMPTY);\n  }\n  set name(nm) {\n    this.name_ = nm;\n  }\n  get name() {\n    return this.name_;\n  }\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(v2) {\n    this.spLay.alpha = v2;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(v2) {\n    this.spLay.angle = v2;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(v2) {\n    this.spLay.scale.x = v2;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(v2) {\n    this.spLay.scale.y = v2;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(v2) {\n    this.spLay.x = v2;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(v2) {\n    this.spLay.y = v2;\n  }\n  destroy() {\n  }\n  lay(hArg) {\n    if (\"alpha\" in hArg)\n      this.spLay.alpha = argChk_Num(hArg, \"alpha\", 1);\n    _Layer.setBlendmode(this.spLay, hArg);\n    if (\"pivot_x\" in hArg || \"pivot_y\" in hArg)\n      this.spLay.pivot.set(argChk_Num(hArg, \"pivot_x\", this.spLay.pivot.x), argChk_Num(hArg, \"pivot_y\", this.spLay.pivot.y));\n    if (\"rotation\" in hArg)\n      this.spLay.angle = argChk_Num(hArg, \"rotation\", 0);\n    if (\"scale_x\" in hArg || \"scale_y\" in hArg)\n      this.spLay.scale.set(argChk_Num(hArg, \"scale_x\", this.spLay.scale.x), argChk_Num(hArg, \"scale_y\", this.spLay.scale.y));\n    if (\"visible\" in hArg)\n      this.spLay.visible = argChk_Boolean(hArg, \"visible\", true);\n    return false;\n  }\n  static setBlendmode(cnt, hArg) {\n    const { blendmode } = hArg;\n    if (!blendmode)\n      return;\n    const bmn = _Layer.getBlendmodeNum(blendmode);\n    const sp = cnt;\n    if (sp)\n      sp.blendMode = bmn;\n    cnt.children.forEach((c2) => {\n      const cSp = c2;\n      if (cSp)\n        cSp.blendMode = bmn;\n    });\n  }\n  static getBlendmodeNum(bm_name) {\n    if (!bm_name)\n      return BLEND_MODES$3.NORMAL;\n    const bmn = __privateGet2(_Layer, _hBlendmode)[bm_name];\n    if (bmn !== void 0)\n      return bmn;\n    throw `${bm_name} \\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044 blendmode \\u3067\\u3059`;\n  }\n  get containMovement() {\n    return false;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(hArg) {\n    this.spLay.alpha = 1;\n    this.spLay.blendMode = BLEND_MODES$3.NORMAL;\n    this.spLay.pivot.set(0, 0);\n    this.spLay.angle = 0;\n    this.spLay.scale.set(1, 1);\n    if (argChk_Boolean(hArg, \"filter\", false))\n      this.spLay.filters = [];\n  }\n  copy(fromLayer, aPrm) {\n    const org_name = this.name_;\n    this.playback(fromLayer.record(), aPrm);\n    this.name = org_name;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(hLay, _aPrm) {\n    this.name = hLay.name;\n    this.clearLay({ filter: \"true\" });\n    this.spLay.alpha = hLay.alpha;\n    this.spLay.blendMode = hLay.blendMode;\n    this.spLay.angle = hLay.rotation;\n    this.spLay.scale.set(hLay.scale_x, hLay.scale_y);\n    this.spLay.pivot.set(hLay.pivot_x, hLay.pivot_y);\n    this.spLay.position.set(hLay.x, hLay.y);\n    this.spLay.visible = hLay.visible;\n  }\n  snapshot(rnd, re2) {\n    rnd.render(this.spLay, { clear: false });\n    re2();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(_gdc) {\n  }\n  makeDesignCastChildren(_gdc) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(base, hArg, ret, isGrp = false, isButton = false) {\n    if (hArg.pos) {\n      _Layer.setXYByPos(base, hArg.pos, ret);\n      return;\n    }\n    const rct_base = base.getBounds();\n    const r_absclX = ret.scale.x < 0 ? -ret.scale.x : ret.scale.x;\n    const b_width = r_absclX === 1 ? rct_base.width : rct_base.width * r_absclX;\n    const r_absclY = ret.scale.y < 0 ? -ret.scale.y : ret.scale.y;\n    const b_height = r_absclY === 1 ? rct_base.height : rct_base.height * r_absclY;\n    let x2 = ret.x;\n    if (\"left\" in hArg) {\n      x2 = argChk_Num(hArg, \"left\", 0);\n      if (x2 > -1 && x2 < 1)\n        x2 *= CmnLib.stageW;\n    } else if (\"center\" in hArg) {\n      x2 = argChk_Num(hArg, \"center\", 0);\n      if (x2 > -1 && x2 < 1)\n        x2 *= CmnLib.stageW;\n      x2 = x2 - (isButton ? b_width / 3 : b_width) / 2;\n    } else if (\"right\" in hArg) {\n      x2 = argChk_Num(hArg, \"right\", 0);\n      if (x2 > -1 && x2 < 1)\n        x2 *= CmnLib.stageW;\n      x2 = x2 - (isButton ? b_width / 3 : b_width);\n    } else if (\"s_right\" in hArg) {\n      x2 = argChk_Num(hArg, \"s_right\", 0);\n      if (x2 > -1 && x2 < 1)\n        x2 *= CmnLib.stageW;\n      x2 = CmnLib.stageW - x2 - (isButton ? b_width / 3 : b_width);\n    }\n    ret.x = int(ret.scale.x < 0 ? x2 + (isButton ? b_width / 3 : b_width) : x2);\n    let y2 = ret.y;\n    if (\"top\" in hArg) {\n      y2 = argChk_Num(hArg, \"top\", 0);\n      if (y2 > -1 && y2 < 1)\n        y2 *= CmnLib.stageH;\n    } else if (\"middle\" in hArg) {\n      y2 = argChk_Num(hArg, \"middle\", 0);\n      if (y2 > -1 && y2 < 1)\n        y2 *= CmnLib.stageH;\n      y2 = y2 - b_height / 2;\n    } else if (\"bottom\" in hArg) {\n      y2 = argChk_Num(hArg, \"bottom\", 0);\n      if (y2 > -1 && y2 < 1)\n        y2 *= CmnLib.stageH;\n      y2 = y2 - b_height;\n    } else if (\"s_bottom\" in hArg) {\n      y2 = argChk_Num(hArg, \"s_bottom\", 0);\n      if (y2 > -1 && y2 < 1)\n        y2 *= CmnLib.stageH;\n      y2 = CmnLib.stageH - y2 - b_height;\n    }\n    ret.y = int(ret.scale.y < 0 ? y2 + b_height : y2);\n    if (isGrp) {\n      if (!(\"left\" in hArg) && !(\"center\" in hArg) && !(\"right\" in hArg) && !(\"s_right\" in hArg) && !(\"top\" in hArg) && !(\"middle\" in hArg) && !(\"bottom\" in hArg) && !(\"s_bottom\" in hArg)) {\n        _Layer.setXYByPos(base, \"c\", ret);\n      }\n    }\n  }\n  static setXYByPos(base, pos, ret) {\n    if (pos === \"stay\")\n      return;\n    if (base === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (ret === void 0)\n      throw \"setXYByPos result === undefined\";\n    const rct_base = base.getBounds();\n    const r_absclX = ret.scale.x < 0 ? -ret.scale.x : ret.scale.x;\n    const b_width = r_absclX === 1 ? rct_base.width : rct_base.width * r_absclX;\n    const r_absclY = ret.scale.y < 0 ? -ret.scale.y : ret.scale.y;\n    const b_height = r_absclY === 1 ? rct_base.height : rct_base.height * r_absclY;\n    let c2 = 0;\n    if (!pos || pos === \"c\") {\n      c2 = CmnLib.stageW * 0.5;\n    } else if (pos === \"r\") {\n      c2 = CmnLib.stageW - b_width * 0.5;\n    } else if (pos === \"l\") {\n      c2 = b_width * 0.5;\n    } else {\n      c2 = int(pos);\n    }\n    ret.x = int(c2 - b_width * 0.5);\n    ret.y = CmnLib.stageH - b_height;\n    if (ret.scale.x < 0)\n      ret.x += b_width;\n    if (ret.scale.y < 0)\n      ret.y += b_height;\n  }\n  static setXYCenter(dsp) {\n    const rct = dsp.getBounds();\n    dsp.x = (CmnLib.stageW - rct.width) * 0.5;\n    dsp.y = (CmnLib.stageH - rct.height) * 0.5;\n  }\n};\nlet Layer = _Layer;\n_hBlendmode = new WeakMap();\n__privateAdd2(Layer, _hBlendmode, {\n  \"normal\": BLEND_MODES$3.NORMAL,\n  \"add\": BLEND_MODES$3.ADD,\n  \"multiply\": BLEND_MODES$3.MULTIPLY,\n  \"screen\": BLEND_MODES$3.SCREEN\n});\nclass EventListenerCtn {\n  constructor() {\n    __privateAdd2(this, _vctEvt, []);\n  }\n  add(ed, type, fnc, ctx = {}) {\n    if (ed instanceof BaseTexture) {\n      switch (type) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          ed.on(type, fnc, ctx);\n          __privateGet2(this, _vctEvt).push(() => ed.off(type, fnc, ctx));\n          break;\n      }\n      return;\n    }\n    if (ed instanceof EventEmitter$4) {\n      ed.on(type, fnc, ctx);\n      __privateGet2(this, _vctEvt).push(() => ed.off(type, fnc, ctx));\n      return;\n    }\n    ed.addEventListener(type, fnc, ctx);\n    __privateGet2(this, _vctEvt).push(() => {\n      var _a3;\n      return ed.removeEventListener(type, fnc, { capture: (_a3 = ctx.capture) != null ? _a3 : false });\n    });\n  }\n  clear() {\n    __privateGet2(this, _vctEvt).forEach((f2) => f2());\n    __privateSet2(this, _vctEvt, []);\n  }\n}\n_vctEvt = new WeakMap();\nfunction prefixNames(prefix2) {\n  var classNames = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    classNames[_i - 1] = arguments[_i];\n  }\n  return classNames.map(function(className) {\n    return className.split(\" \").map(function(name) {\n      return name ? \"\" + prefix2 + name : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction prefixCSS(prefix2, css) {\n  return css.replace(/([^}{]*){/gm, function(_2, selector) {\n    return selector.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + prefix2 + \"$1\") + \"{\";\n  });\n}\nfunction ref(target, name) {\n  return function(e) {\n    e && (target[name] = e);\n  };\n}\nfunction refs(target, name, i2) {\n  return function(e) {\n    e && (target[name][i2] = e);\n  };\n}\nfunction Properties(properties, action) {\n  return function(component) {\n    var prototype = component.prototype;\n    properties.forEach(function(property) {\n      action(prototype, property);\n    });\n  };\n}\nfunction withMethods(methods, duplicate) {\n  if (duplicate === void 0) {\n    duplicate = {};\n  }\n  return function(prototype, propertyName) {\n    methods.forEach(function(name) {\n      var methodName = duplicate[name] || name;\n      if (methodName in prototype) {\n        return;\n      }\n      prototype[methodName] = function() {\n        var _a3;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var result = (_a3 = this[propertyName])[name].apply(_a3, args);\n        if (result === this[propertyName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\nvar PolyMap = /* @__PURE__ */ function() {\n  function PolyMap2() {\n    this.keys = [];\n    this.values = [];\n  }\n  var __proto = PolyMap2.prototype;\n  __proto.get = function(key) {\n    return this.values[this.keys.indexOf(key)];\n  };\n  __proto.set = function(key, value2) {\n    var keys = this.keys;\n    var values = this.values;\n    var prevIndex = keys.indexOf(key);\n    var index = prevIndex === -1 ? keys.length : prevIndex;\n    keys[index] = key;\n    values[index] = value2;\n  };\n  return PolyMap2;\n}();\nvar HashMap = /* @__PURE__ */ function() {\n  function HashMap2() {\n    this.object = {};\n  }\n  var __proto = HashMap2.prototype;\n  __proto.get = function(key) {\n    return this.object[key];\n  };\n  __proto.set = function(key, value2) {\n    this.object[key] = value2;\n  };\n  return HashMap2;\n}();\nvar SUPPORT_MAP = typeof Map === \"function\";\nvar Link = /* @__PURE__ */ function() {\n  function Link2() {\n  }\n  var __proto = Link2.prototype;\n  __proto.connect = function(prevLink, nextLink) {\n    this.prev = prevLink;\n    this.next = nextLink;\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  };\n  __proto.disconnect = function() {\n    var prevLink = this.prev;\n    var nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  };\n  __proto.getIndex = function() {\n    var link = this;\n    var index = -1;\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n    return index;\n  };\n  return Link2;\n}();\nfunction orderChanged(changed, fixed) {\n  var fromLinks = [];\n  var toLinks = [];\n  changed.forEach(function(_a3) {\n    var from = _a3[0], to = _a3[1];\n    var link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  });\n  fromLinks.forEach(function(link, i2) {\n    link.connect(fromLinks[i2 - 1]);\n  });\n  return changed.filter(function(_2, i2) {\n    return !fixed[i2];\n  }).map(function(_a3, i2) {\n    var from = _a3[0], to = _a3[1];\n    if (from === to) {\n      return [0, 0];\n    }\n    var fromLink = fromLinks[from];\n    var toLink = toLinks[to - 1];\n    var fromIndex = fromLink.getIndex();\n    fromLink.disconnect();\n    if (!toLink) {\n      fromLink.connect(void 0, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n    var toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\nvar Result = /* @__PURE__ */ function() {\n  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n  var __proto = Result2.prototype;\n  Object.defineProperty(__proto, \"ordered\", {\n    get: function() {\n      if (!this.cacheOrdered) {\n        this.caculateOrdered();\n      }\n      return this.cacheOrdered;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"pureChanged\", {\n    get: function() {\n      if (!this.cachePureChanged) {\n        this.caculateOrdered();\n      }\n      return this.cachePureChanged;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  __proto.caculateOrdered = function() {\n    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    var changed = this.changed;\n    var pureChanged = [];\n    this.cacheOrdered = ordered.filter(function(_a3, i2) {\n      var from = _a3[0], to = _a3[1];\n      var _b3 = changed[i2], fromBefore = _b3[0], toBefore = _b3[1];\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  };\n  return Result2;\n}();\nfunction diff$1(prevList, list, findKeyCallback2) {\n  var mapClass = SUPPORT_MAP ? Map : findKeyCallback2 ? HashMap : PolyMap;\n  var callback = findKeyCallback2 || function(e) {\n    return e;\n  };\n  var added = [];\n  var removed = [];\n  var maintained = [];\n  var prevKeys = prevList.map(callback);\n  var keys = list.map(callback);\n  var prevKeyMap = new mapClass();\n  var keyMap = new mapClass();\n  var changedBeforeAdded = [];\n  var fixed = [];\n  var removedMap = {};\n  var changed = [];\n  var addedCount = 0;\n  var removedCount = 0;\n  prevKeys.forEach(function(key, prevListIndex) {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach(function(key, listIndex) {\n    keyMap.set(key, listIndex);\n  });\n  prevKeys.forEach(function(key, prevListIndex) {\n    var listIndex = keyMap.get(key);\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  });\n  keys.forEach(function(key, listIndex) {\n    var prevListIndex = prevKeyMap.get(key);\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);\n      fixed.push(listIndex === prevListIndex);\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  });\n  removed.reverse();\n  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);\n}\nvar ListDiffer = /* @__PURE__ */ function() {\n  function ListDiffer2(list, findKeyCallback2) {\n    if (list === void 0) {\n      list = [];\n    }\n    this.findKeyCallback = findKeyCallback2;\n    this.list = [].slice.call(list);\n  }\n  var __proto = ListDiffer2.prototype;\n  __proto.update = function(list) {\n    var newData = [].slice.call(list);\n    var result = diff$1(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  };\n  return ListDiffer2;\n}();\nvar FUNCTION = \"function\";\nvar OBJECT = \"object\";\nvar STRING = \"string\";\nvar NUMBER = \"number\";\nvar UNDEFINED = \"undefined\";\nvar IS_WINDOW = typeof window !== UNDEFINED;\nvar OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}];\nvar TINY_NUM$1 = 1e-7;\nvar DEFAULT_UNIT_PRESETS = {\n  \"cm\": function(pos) {\n    return pos * 96 / 2.54;\n  },\n  \"mm\": function(pos) {\n    return pos * 96 / 254;\n  },\n  \"in\": function(pos) {\n    return pos * 96;\n  },\n  \"pt\": function(pos) {\n    return pos * 96 / 72;\n  },\n  \"pc\": function(pos) {\n    return pos * 96 / 6;\n  },\n  \"%\": function(pos, size) {\n    return pos * size / 100;\n  },\n  \"vw\": function(pos, size) {\n    if (size === void 0) {\n      size = window.innerWidth;\n    }\n    return pos / 100 * size;\n  },\n  \"vh\": function(pos, size) {\n    if (size === void 0) {\n      size = window.innerHeight;\n    }\n    return pos / 100 * size;\n  },\n  \"vmax\": function(pos, size) {\n    if (size === void 0) {\n      size = Math.max(window.innerWidth, window.innerHeight);\n    }\n    return pos / 100 * size;\n  },\n  \"vmin\": function(pos, size) {\n    if (size === void 0) {\n      size = Math.min(window.innerWidth, window.innerHeight);\n    }\n    return pos / 100 * size;\n  }\n};\nfunction dot(a1, a2, b1, b2) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\nfunction isUndefined(value2) {\n  return typeof value2 === UNDEFINED;\n}\nfunction isObject$2(value2) {\n  return value2 && typeof value2 === OBJECT;\n}\nfunction isArray(value2) {\n  return Array.isArray(value2);\n}\nfunction isString(value2) {\n  return typeof value2 === STRING;\n}\nfunction isNumber(value2) {\n  return typeof value2 === NUMBER;\n}\nfunction isFunction$2(value2) {\n  return typeof value2 === FUNCTION;\n}\nfunction isEqualSeparator(character, separator) {\n  var isCharacterSpace = character === \"\" || character == \" \";\n  var isSeparatorSpace = separator === \"\" || separator == \" \";\n  return isSeparatorSpace && isCharacterSpace || character === separator;\n}\nfunction findOpen(openCharacter, texts, index, length2, openCloseCharacters) {\n  var isIgnore = findIgnore(openCharacter, texts, index);\n  if (!isIgnore) {\n    return findClose(openCharacter, texts, index + 1, length2, openCloseCharacters);\n  }\n  return index;\n}\nfunction findIgnore(character, texts, index) {\n  if (!character.ignore) {\n    return null;\n  }\n  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join(\"\");\n  return new RegExp(character.ignore).exec(otherText);\n}\nfunction findClose(closeCharacter, texts, index, length2, openCloseCharacters) {\n  var _loop_1 = function(i3) {\n    var character = texts[i3].trim();\n    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i3)) {\n      return {\n        value: i3\n      };\n    }\n    var nextIndex = i3;\n    var openCharacter = find$1(openCloseCharacters, function(_a3) {\n      var open = _a3.open;\n      return open === character;\n    });\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i3, length2, openCloseCharacters);\n    }\n    if (nextIndex === -1) {\n      return out_i_1 = i3, \"break\";\n    }\n    i3 = nextIndex;\n    out_i_1 = i3;\n  };\n  var out_i_1;\n  for (var i2 = index; i2 < length2; ++i2) {\n    var state_1 = _loop_1(i2);\n    i2 = out_i_1;\n    if (typeof state_1 === \"object\")\n      return state_1.value;\n    if (state_1 === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction splitText(text2, splitOptions) {\n  var _a3 = isString(splitOptions) ? {\n    separator: splitOptions\n  } : splitOptions, _b3 = _a3.separator, separator = _b3 === void 0 ? \",\" : _b3, isSeparateFirst = _a3.isSeparateFirst, isSeparateOnlyOpenClose = _a3.isSeparateOnlyOpenClose, _c3 = _a3.isSeparateOpenClose, isSeparateOpenClose = _c3 === void 0 ? isSeparateOnlyOpenClose : _c3, _d2 = _a3.openCloseCharacters, openCloseCharacters = _d2 === void 0 ? OPEN_CLOSED_CHARACTERS : _d2;\n  var openClosedText = openCloseCharacters.map(function(_a4) {\n    var open = _a4.open, close = _a4.close;\n    if (open === close) {\n      return open;\n    }\n    return open + \"|\" + close;\n  }).join(\"|\");\n  var regexText = \"(\\\\s*\" + separator + \"\\\\s*|\" + openClosedText + \"|\\\\s+)\";\n  var regex = new RegExp(regexText, \"g\");\n  var texts = text2.split(regex).filter(Boolean);\n  var length2 = texts.length;\n  var values = [];\n  var tempValues = [];\n  function resetTemp() {\n    if (tempValues.length) {\n      values.push(tempValues.join(\"\"));\n      tempValues = [];\n      return true;\n    }\n    return false;\n  }\n  var _loop_2 = function(i3) {\n    var character = texts[i3].trim();\n    var nextIndex = i3;\n    var openCharacter = find$1(openCloseCharacters, function(_a4) {\n      var open = _a4.open;\n      return open === character;\n    });\n    var closeCharacter = find$1(openCloseCharacters, function(_a4) {\n      var close = _a4.close;\n      return close === character;\n    });\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i3, length2, openCloseCharacters);\n      if (nextIndex !== -1 && isSeparateOpenClose) {\n        if (resetTemp() && isSeparateFirst) {\n          return out_i_2 = i3, \"break\";\n        }\n        values.push(texts.slice(i3, nextIndex + 1).join(\"\"));\n        i3 = nextIndex;\n        if (isSeparateFirst) {\n          return out_i_2 = i3, \"break\";\n        }\n        return out_i_2 = i3, \"continue\";\n      }\n    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i3)) {\n      throw new Error(\"invalid format: \" + closeCharacter.close);\n    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {\n      resetTemp();\n      if (isSeparateFirst) {\n        return out_i_2 = i3, \"break\";\n      }\n      return out_i_2 = i3, \"continue\";\n    }\n    if (nextIndex === -1) {\n      nextIndex = length2 - 1;\n    }\n    tempValues.push(texts.slice(i3, nextIndex + 1).join(\"\"));\n    i3 = nextIndex;\n    out_i_2 = i3;\n  };\n  var out_i_2;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    var state_2 = _loop_2(i2);\n    i2 = out_i_2;\n    if (state_2 === \"break\")\n      break;\n  }\n  if (tempValues.length) {\n    values.push(tempValues.join(\"\"));\n  }\n  return values;\n}\nfunction splitSpace(text2) {\n  return splitText(text2, \"\");\n}\nfunction splitComma(text2) {\n  return splitText(text2, \",\");\n}\nfunction splitBracket(text2) {\n  var matches = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(text2);\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return {\n      prefix: matches[1],\n      value: matches[2],\n      suffix: matches[3]\n    };\n  }\n}\nfunction splitUnit(text2) {\n  var matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text2);\n  if (!matches) {\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  }\n  var prefix2 = matches[1];\n  var value2 = matches[2];\n  var unit = matches[3];\n  return {\n    prefix: prefix2,\n    unit,\n    value: parseFloat(value2)\n  };\n}\nfunction camelize(str2) {\n  return str2.replace(/[\\s-_]([a-z])/g, function(all2, letter) {\n    return letter.toUpperCase();\n  });\n}\nfunction decamelize(str2, separator) {\n  if (separator === void 0) {\n    separator = \"-\";\n  }\n  return str2.replace(/([a-z])([A-Z])/g, function(all2, letter, letter2) {\n    return \"\" + letter + separator + letter2.toLowerCase();\n  });\n}\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\nfunction findIndex(arr, callback, defaultIndex) {\n  if (defaultIndex === void 0) {\n    defaultIndex = -1;\n  }\n  var length2 = arr.length;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    if (callback(arr[i2], i2, arr)) {\n      return i2;\n    }\n  }\n  return defaultIndex;\n}\nfunction find$1(arr, callback, defalutValue) {\n  var index = findIndex(arr, callback);\n  return index > -1 ? arr[index] : defalutValue;\n}\nvar requestAnimationFrame$1 = /* @__PURE__ */ function() {\n  var firstTime = now();\n  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return raf ? raf.bind(window) : function(callback) {\n    var currTime = now();\n    var id = window.setTimeout(function() {\n      callback(currTime - firstTime);\n    }, 1e3 / 60);\n    return id;\n  };\n}();\nvar cancelAnimationFrame$1 = /* @__PURE__ */ function() {\n  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return caf ? caf.bind(window) : function(handle2) {\n    clearTimeout(handle2);\n  };\n}();\nfunction getKeys(obj) {\n  if (Object.keys) {\n    return Object.keys(obj);\n  }\n  var keys = [];\n  for (var name in keys) {\n    keys.push(name);\n  }\n  return keys;\n}\nfunction convertUnitSize(pos, size) {\n  var _a3 = splitUnit(pos), value2 = _a3.value, unit = _a3.unit;\n  if (isObject$2(size)) {\n    var sizeFunction = size[unit];\n    if (sizeFunction) {\n      if (isFunction$2(sizeFunction)) {\n        return sizeFunction(value2);\n      } else if (DEFAULT_UNIT_PRESETS[unit]) {\n        return DEFAULT_UNIT_PRESETS[unit](value2, sizeFunction);\n      }\n    }\n  } else if (unit === \"%\") {\n    return value2 * size / 100;\n  }\n  if (DEFAULT_UNIT_PRESETS[unit]) {\n    return DEFAULT_UNIT_PRESETS[unit](value2);\n  }\n  return value2;\n}\nfunction between(value2, min2, max2) {\n  return Math.max(min2, Math.min(value2, max2));\n}\nfunction checkBoundSize(targetSize, compareSize, isMax) {\n  return [[throttle(compareSize[0], TINY_NUM$1), throttle(compareSize[0] * targetSize[1] / targetSize[0], TINY_NUM$1)], [throttle(compareSize[1] * targetSize[0] / targetSize[1], TINY_NUM$1), throttle(compareSize[1], TINY_NUM$1)]].filter(function(size) {\n    return size.every(function(value2, i2) {\n      return isMax ? value2 <= compareSize[i2] : value2 >= compareSize[i2];\n    });\n  })[0] || targetSize;\n}\nfunction calculateBoundSize(size, minSize, maxSize, keepRatio) {\n  if (!keepRatio) {\n    return size.map(function(value2, i2) {\n      return between(value2, minSize[i2], maxSize[i2]);\n    });\n  }\n  var width = size[0], height = size[1];\n  var _a3 = checkBoundSize(size, minSize, false), minWidth = _a3[0], minHeight = _a3[1];\n  var _b3 = checkBoundSize(size, maxSize, true), maxWidth = _b3[0], maxHeight = _b3[1];\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n  return [width, height];\n}\nfunction sum(nums) {\n  var length2 = nums.length;\n  var total = 0;\n  for (var i2 = length2 - 1; i2 >= 0; --i2) {\n    total += nums[i2];\n  }\n  return total;\n}\nfunction average(nums) {\n  var length2 = nums.length;\n  var total = 0;\n  for (var i2 = length2 - 1; i2 >= 0; --i2) {\n    total += nums[i2];\n  }\n  return length2 ? total / length2 : 0;\n}\nfunction getRad$1(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\nfunction getCenterPoint(points) {\n  return [0, 1].map(function(i2) {\n    return average(points.map(function(pos) {\n      return pos[i2];\n    }));\n  });\n}\nfunction getShapeDirection(points) {\n  var center = getCenterPoint(points);\n  var pos1Rad = getRad$1(center, points[0]);\n  var pos2Rad = getRad$1(center, points[1]);\n  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;\n}\nfunction getDist$2(a2, b2) {\n  return Math.sqrt(Math.pow((b2 ? b2[0] : 0) - a2[0], 2) + Math.pow((b2 ? b2[1] : 0) - a2[1], 2));\n}\nfunction throttle(num, unit) {\n  if (!unit) {\n    return num;\n  }\n  return Math.round(num / unit) * unit;\n}\nfunction throttleArray(nums, unit) {\n  nums.forEach(function(_2, i2) {\n    nums[i2] = throttle(nums[i2], unit);\n  });\n  return nums;\n}\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n  return !!element.className.match(new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n}\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += \" \" + className;\n  }\n}\nfunction removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    var reg = new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n    element.className = element.className.replace(reg, \" \");\n  }\n}\nfunction addEvent(el, type, listener, options) {\n  el.addEventListener(type, listener, options);\n}\nfunction removeEvent(el, type, listener, options) {\n  el.removeEventListener(type, listener, options);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$6 = function(d2, b2) {\n  extendStatics$6 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$6(d2, b2);\n};\nfunction __extends$6(d2, b2) {\n  extendStatics$6(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$7 = function() {\n  __assign$7 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$7.apply(this, arguments);\n};\nfunction __rest$2(s2, e) {\n  var t = {};\n  for (var p2 in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)\n      t[p2] = s2[p2];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))\n        t[p2[i2]] = s2[p2[i2]];\n    }\n  return t;\n}\nfunction __spreadArrays$4() {\n  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n    s2 += arguments[i2].length;\n  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)\n    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)\n      r2[k] = a2[j2];\n  return r2;\n}\nfunction isDiff(a2, b2) {\n  if (a2 === b2) {\n    return false;\n  }\n  for (var i2 in a2) {\n    if (!(i2 in b2)) {\n      return true;\n    }\n  }\n  for (var i2 in b2) {\n    if (a2[i2] !== b2[i2]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction diffObject(a2, b2) {\n  var keys1 = Object.keys(a2);\n  var keys2 = Object.keys(b2);\n  var result = diff$1(keys1, keys2, function(key) {\n    return key;\n  });\n  var added = {};\n  var removed = {};\n  var changed = {};\n  result.added.forEach(function(index) {\n    var name = keys2[index];\n    added[name] = b2[name];\n  });\n  result.removed.forEach(function(index) {\n    var name = keys1[index];\n    removed[name] = a2[name];\n  });\n  result.maintained.forEach(function(_a3) {\n    var index = _a3[0];\n    var name = keys1[index];\n    var values = [a2[name], b2[name]];\n    if (a2[name] !== b2[name]) {\n      changed[name] = values;\n    }\n  });\n  return {\n    added,\n    removed,\n    changed\n  };\n}\nfunction executeHooks(hooks) {\n  hooks.forEach(function(hook) {\n    hook();\n  });\n}\nfunction fillKeys(keys) {\n  var index = 0;\n  return keys.map(function(key) {\n    return key == null ? \"$compat\" + ++index : \"\" + key;\n  });\n}\nfunction createProvider(el, key, index, container) {\n  if (isString(el) || isNumber(el)) {\n    return new TextProvider(\"text_\" + el, key, index, container, null, {});\n  }\n  var providerClass = typeof el.type === \"string\" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;\n  return new providerClass(el.type, key, index, container, el.ref, el.props);\n}\nfunction flat$1(arr) {\n  var arr2 = [];\n  arr.forEach(function(el) {\n    arr2 = arr2.concat(isArray(el) ? flat$1(el) : el);\n  });\n  return arr2;\n}\nfunction getAttributes(props) {\n  var className = props.className, otherProps = __rest$2(props, [\"className\"]);\n  if (className != null) {\n    otherProps.class = className;\n  }\n  delete otherProps.style;\n  delete otherProps.children;\n  return otherProps;\n}\nfunction fillProps(props, defaultProps) {\n  if (!defaultProps) {\n    return props;\n  }\n  for (var name in defaultProps) {\n    if (isUndefined(props[name])) {\n      props[name] = defaultProps[name];\n    }\n  }\n  return props;\n}\nfunction createElement(type, props) {\n  var children = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    children[_i - 2] = arguments[_i];\n  }\n  var _a3 = props || {}, key = _a3.key, ref2 = _a3.ref, otherProps = __rest$2(_a3, [\"key\", \"ref\"]);\n  return {\n    type,\n    key,\n    ref: ref2,\n    props: __assign$7(__assign$7({}, otherProps), {\n      children: flat$1(children).filter(function(child) {\n        return child != null && child !== false;\n      })\n    })\n  };\n}\nvar Provider = /* @__PURE__ */ function() {\n  function Provider2(type, key, index, container, ref2, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    this.type = type;\n    this.key = key;\n    this.index = index;\n    this.container = container;\n    this.ref = ref2;\n    this.props = props;\n    this._providers = [];\n  }\n  var __proto = Provider2.prototype;\n  __proto._should = function(nextProps, nextState) {\n    return true;\n  };\n  __proto._update = function(hooks, nextElement, nextState, isForceUpdate) {\n    if (this.base && !isString(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {\n      return false;\n    }\n    this.original = nextElement;\n    this._setState(nextState);\n    var prevProps = this.props;\n    if (!isString(nextElement)) {\n      this.props = nextElement.props;\n      this.ref = nextElement.ref;\n    }\n    this._render(hooks, this.base ? prevProps : {}, nextState);\n    return true;\n  };\n  __proto._mounted = function() {\n    var ref2 = this.ref;\n    ref2 && ref2(this.base);\n  };\n  __proto._setState = function(nextstate) {\n    return;\n  };\n  __proto._updated = function() {\n    var ref2 = this.ref;\n    ref2 && ref2(this.base);\n  };\n  __proto._destroy = function() {\n    var ref2 = this.ref;\n    ref2 && ref2(null);\n  };\n  return Provider2;\n}();\nfunction diffAttributes(attrs1, attrs2, el) {\n  var _a3 = diffObject(attrs1, attrs2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;\n  for (var name in added) {\n    el.setAttribute(name, added[name]);\n  }\n  for (var name in changed) {\n    el.setAttribute(name, changed[name][1]);\n  }\n  for (var name in removed) {\n    el.removeAttribute(name);\n  }\n}\nfunction diffEvents(events1, events2, provier) {\n  var _a3 = diffObject(events1, events2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;\n  for (var name in removed) {\n    provier.removeEventListener(name);\n  }\n  for (var name in added) {\n    provier.addEventListener(name, added[name]);\n  }\n  for (var name in changed) {\n    provier.removeEventListener(name);\n    provier.addEventListener(name, changed[name][1]);\n  }\n  for (var name in removed) {\n    provier.removeEventListener(name);\n  }\n}\nfunction diffStyle(style1, style2, el) {\n  var style = el.style;\n  var _a3 = diffObject(style1, style2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;\n  for (var beforeName in added) {\n    var name = decamelize(beforeName, \"-\");\n    if (style.setProperty) {\n      style.setProperty(name, added[beforeName]);\n    } else {\n      style[name] = added[beforeName];\n    }\n  }\n  for (var beforeName in changed) {\n    var name = decamelize(beforeName, \"-\");\n    if (style.setProperty) {\n      style.setProperty(name, changed[beforeName][1]);\n    } else {\n      style[name] = changed[beforeName][1];\n    }\n  }\n  for (var beforeName in removed) {\n    var name = decamelize(beforeName, \"-\");\n    if (style.removeProperty) {\n      style.removeProperty(name);\n    } else {\n      style[name] = \"\";\n    }\n  }\n}\nfunction splitProps(props) {\n  var attributes = {};\n  var events = {};\n  for (var name in props) {\n    if (name.indexOf(\"on\") === 0) {\n      events[name.replace(\"on\", \"\").toLowerCase()] = props[name];\n    } else {\n      attributes[name] = props[name];\n    }\n  }\n  return {\n    attributes,\n    events\n  };\n}\nvar TextProvider = /* @__PURE__ */ function(_super) {\n  __extends$6(TextProvider2, _super);\n  function TextProvider2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = TextProvider2.prototype;\n  __proto._render = function(hooks) {\n    var _this = this;\n    var isMount = !this.base;\n    if (isMount) {\n      this.base = document.createTextNode(this.type.replace(\"text_\", \"\"));\n    }\n    hooks.push(function() {\n      if (isMount) {\n        _this._mounted();\n      } else {\n        _this._updated();\n      }\n    });\n    return true;\n  };\n  __proto._unmount = function() {\n    this.base.parentNode.removeChild(this.base);\n  };\n  return TextProvider2;\n}(Provider);\nvar ElementProvider = /* @__PURE__ */ function(_super) {\n  __extends$6(ElementProvider2, _super);\n  function ElementProvider2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.events = {};\n    _this._isSVG = false;\n    return _this;\n  }\n  var __proto = ElementProvider2.prototype;\n  __proto.addEventListener = function(name, callback) {\n    var events = this.events;\n    events[name] = function(e) {\n      e.nativeEvent = e;\n      callback(e);\n    };\n    this.base.addEventListener(name, events[name]);\n  };\n  __proto.removeEventListener = function(name) {\n    var events = this.events;\n    this.base.removeEventListener(name, events[name]);\n    delete events[name];\n  };\n  __proto._should = function(nextProps) {\n    return isDiff(this.props, nextProps);\n  };\n  __proto._render = function(hooks, prevProps) {\n    var _this = this;\n    var isMount = !this.base;\n    if (isMount) {\n      var isSVG = this._hasSVG();\n      this._isSVG = isSVG;\n      var element = this.props.portalContainer;\n      if (!element) {\n        var type = this.type;\n        if (isSVG) {\n          element = document.createElementNS(\"http://www.w3.org/2000/svg\", type);\n        } else {\n          element = document.createElement(type);\n        }\n      }\n      this.base = element;\n    }\n    renderProviders(this, this._providers, this.props.children, hooks, null);\n    var base = this.base;\n    var _a3 = splitProps(prevProps), prevAttributes = _a3.attributes, prevEvents = _a3.events;\n    var _b3 = splitProps(this.props), nextAttributes = _b3.attributes, nextEvents = _b3.events;\n    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);\n    diffEvents(prevEvents, nextEvents, this);\n    diffStyle(prevProps.style || {}, this.props.style || {}, base);\n    hooks.push(function() {\n      if (isMount) {\n        _this._mounted();\n      } else {\n        _this._updated();\n      }\n    });\n    return true;\n  };\n  __proto._unmount = function() {\n    var events = this.events;\n    var base = this.base;\n    for (var name in events) {\n      base.removeEventListener(name, events[name]);\n    }\n    this._providers.forEach(function(provider) {\n      provider._unmount();\n    });\n    this.events = {};\n    if (!this.props.portalContainer) {\n      base.parentNode.removeChild(base);\n    }\n  };\n  __proto._hasSVG = function() {\n    if (this._isSVG || this.type === \"svg\") {\n      return true;\n    }\n    var containerNode = findContainerNode(this.container);\n    return containerNode && \"ownerSVGElement\" in containerNode;\n  };\n  return ElementProvider2;\n}(Provider);\nfunction findContainerNode(provider) {\n  if (!provider) {\n    return null;\n  }\n  var base = provider.base;\n  if (base instanceof Node) {\n    return base;\n  }\n  return findContainerNode(provider.container);\n}\nfunction findDOMNode(comp) {\n  if (!comp) {\n    return null;\n  }\n  if (comp instanceof Node) {\n    return comp;\n  }\n  var providers = comp.$_provider._providers;\n  if (!providers.length) {\n    return null;\n  }\n  return findDOMNode(providers[0].base);\n}\nvar FunctionProvider = /* @__PURE__ */ function(_super) {\n  __extends$6(FunctionProvider2, _super);\n  function FunctionProvider2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = FunctionProvider2.prototype;\n  __proto._render = function(hooks) {\n    var template = this.type(this.props);\n    renderProviders(this, this._providers, template ? [template] : [], hooks);\n    return true;\n  };\n  __proto._unmount = function() {\n    this._providers.forEach(function(provider) {\n      provider._unmount();\n    });\n  };\n  return FunctionProvider2;\n}(Provider);\nvar ContainerProvider = /* @__PURE__ */ function(_super) {\n  __extends$6(ContainerProvider2, _super);\n  function ContainerProvider2(base) {\n    var _this = _super.call(this, \"container\", \"container\", 0, null) || this;\n    _this.base = base;\n    return _this;\n  }\n  var __proto = ContainerProvider2.prototype;\n  __proto._render = function() {\n    return true;\n  };\n  __proto._unmount = function() {\n    return;\n  };\n  return ContainerProvider2;\n}(Provider);\nvar ComponentProvider = /* @__PURE__ */ function(_super) {\n  __extends$6(ComponentProvider2, _super);\n  function ComponentProvider2(type, key, index, container, ref2, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    return _super.call(this, type, key, index, container, ref2, fillProps(props, type.defaultProps)) || this;\n  }\n  var __proto = ComponentProvider2.prototype;\n  __proto._should = function(nextProps, nextState) {\n    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);\n  };\n  __proto._render = function(hooks, prevProps, nextState) {\n    var _this = this;\n    this.props = fillProps(this.props, this.type.defaultProps);\n    var isMount = !this.base;\n    if (isMount) {\n      this.base = new this.type(this.props);\n      this.base.$_provider = this;\n    } else {\n      this.base.props = this.props;\n    }\n    var base = this.base;\n    var prevState = base.state;\n    var template = base.render();\n    if (template && template.props && !template.props.children.length) {\n      template.props.children = this.props.children;\n    }\n    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);\n    hooks.push(function() {\n      if (isMount) {\n        _this._mounted();\n        base.componentDidMount();\n      } else {\n        _this._updated();\n        base.componentDidUpdate(prevProps, prevState);\n      }\n    });\n  };\n  __proto._setState = function(nextState) {\n    var base = this.base;\n    if (!base || !nextState) {\n      return;\n    }\n    base.state = nextState;\n  };\n  __proto._unmount = function() {\n    this._providers.forEach(function(provider) {\n      provider._unmount();\n    });\n    clearTimeout(this.base.$_timer);\n    this.base.componentWillUnmount();\n  };\n  return ComponentProvider2;\n}(Provider);\nvar Component = /* @__PURE__ */ function() {\n  function Component2(props) {\n    if (props === void 0) {\n      props = {};\n    }\n    this.props = props;\n    this.state = {};\n    this.$_timer = 0;\n    this.$_state = {};\n  }\n  var __proto = Component2.prototype;\n  __proto.shouldComponentUpdate = function(props, state) {\n    return true;\n  };\n  __proto.render = function() {\n    return null;\n  };\n  __proto.setState = function(state, callback, isForceUpdate) {\n    var _this = this;\n    if (!this.$_timer) {\n      this.$_state = {};\n    }\n    clearTimeout(this.$_timer);\n    this.$_timer = 0;\n    this.$_state = __assign$7(__assign$7({}, this.$_state), state);\n    if (!isForceUpdate) {\n      this.$_timer = setTimeout(function() {\n        _this.$_timer = 0;\n        _this.$_setState(callback, isForceUpdate);\n      });\n    } else {\n      this.$_setState(callback, isForceUpdate);\n    }\n    return;\n  };\n  __proto.forceUpdate = function(callback) {\n    this.setState({}, callback, true);\n  };\n  __proto.componentDidMount = function() {\n  };\n  __proto.componentDidUpdate = function(prevProps, prevState) {\n  };\n  __proto.componentWillUnmount = function() {\n  };\n  __proto.$_setState = function(callback, isForceUpdate) {\n    var hooks = [];\n    var provider = this.$_provider;\n    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign$7(__assign$7({}, this.state), this.$_state), isForceUpdate);\n    if (isUpdate) {\n      if (callback) {\n        hooks.push(callback);\n      }\n      executeHooks(hooks);\n    }\n  };\n  return Component2;\n}();\nvar PureComponent = /* @__PURE__ */ function(_super) {\n  __extends$6(PureComponent2, _super);\n  function PureComponent2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = PureComponent2.prototype;\n  __proto.shouldComponentUpdate = function(props, state) {\n    return isDiff(this.props, props) || isDiff(this.state, state);\n  };\n  return PureComponent2;\n}(Component);\nvar _Portal = /* @__PURE__ */ function(_super) {\n  __extends$6(_Portal2, _super);\n  function _Portal2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = _Portal2.prototype;\n  __proto.componentDidMount = function() {\n    var _a3 = this.props, element = _a3.element, container = _a3.container;\n    this._portalProvider = new ContainerProvider(container);\n    renderProvider(element, container, this._portalProvider);\n  };\n  __proto.componentDidUpdate = function() {\n    var _a3 = this.props, element = _a3.element, container = _a3.container;\n    renderProvider(element, container, this._portalProvider);\n  };\n  __proto.componentWillUnmount = function() {\n    var container = this.props.container;\n    renderProvider(null, container, this._portalProvider);\n    this._portalProvider = null;\n  };\n  return _Portal2;\n}(PureComponent);\nfunction updateProvider(provider, children, nextState) {\n  var hooks = [];\n  renderProviders(provider, provider._providers, children, hooks, nextState);\n  executeHooks(hooks);\n}\nfunction getNextSibiling(provider, childProvider) {\n  var childProviders = provider._providers;\n  var length2 = childProviders.length;\n  for (var i2 = childProvider.index + 1; i2 < length2; ++i2) {\n    var el = findDOMNode(childProviders[i2].base);\n    if (el) {\n      return el;\n    }\n  }\n  return null;\n}\nfunction diffProviders(containerProvider, providers, children) {\n  var childrenKeys = children.map(function(p2) {\n    return isString(p2) ? null : p2.key;\n  });\n  var keys1 = fillKeys(providers.map(function(p2) {\n    return p2.key;\n  }));\n  var keys2 = fillKeys(childrenKeys);\n  var result = diff$1(keys1, keys2, function(key) {\n    return key;\n  });\n  result.removed.forEach(function(index) {\n    providers.splice(index, 1)[0]._unmount();\n  });\n  result.ordered.forEach(function(_a3) {\n    var from = _a3[0], to = _a3[1];\n    var childrenProvider = providers.splice(from, 1)[0];\n    providers.splice(to, 0, childrenProvider);\n    var el = findDOMNode(childrenProvider.base);\n    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);\n    if (el) {\n      el.parentNode.insertBefore(el, next);\n    }\n  });\n  result.added.forEach(function(index) {\n    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));\n  });\n  var changed = result.maintained.filter(function(_a3) {\n    _a3[0];\n    var to = _a3[1];\n    var el = children[to];\n    var childProvider = providers[to];\n    var type = isString(el) ? \"text_\" + el : el.type;\n    if (type !== childProvider.type) {\n      childProvider._unmount();\n      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));\n      return true;\n    }\n    childProvider.index = to;\n    return false;\n  });\n  return __spreadArrays$4(result.added, changed.map(function(_a3) {\n    _a3[0];\n    var to = _a3[1];\n    return to;\n  }));\n}\nfunction renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {\n  var result = diffProviders(containerProvider, providers, children);\n  var updated = providers.filter(function(childProvider, i2) {\n    return childProvider._update(updatedHooks, children[i2], nextState, isForceUpdate);\n  });\n  var containerNode = findContainerNode(containerProvider);\n  if (containerNode) {\n    result.reverse().forEach(function(index) {\n      var childProvider = providers[index];\n      var el = findDOMNode(childProvider.base);\n      if (!el) {\n        return;\n      }\n      if (containerNode !== el && !el.parentNode) {\n        var nextElement = getNextSibiling(containerProvider, childProvider);\n        containerNode.insertBefore(el, nextElement);\n      }\n    });\n  }\n  return updated.length > 0;\n}\nfunction renderProvider(element, container, provider) {\n  if (provider === void 0) {\n    provider = container.__REACT_COMPAT__;\n  }\n  var isProvider = !!provider;\n  if (!provider) {\n    provider = new ContainerProvider(container);\n  }\n  updateProvider(provider, element ? [element] : []);\n  if (!isProvider) {\n    container.__REACT_COMPAT__ = provider;\n  }\n  return provider;\n}\nfunction render(element, container, callback) {\n  var provider = container.__REACT_COMPAT__;\n  if (element && !provider) {\n    container.innerHTML = \"\";\n  }\n  renderProvider(element, container, provider);\n  callback && callback();\n}\nfunction createPortal(el, container) {\n  return createElement(_Portal, {\n    element: el,\n    container\n  });\n}\nvar version = \"simple-1.1.0\";\nfunction some(arr, callback) {\n  var length2 = arr.length;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    if (callback(arr[i2], i2)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction find(arr, callback) {\n  var length2 = arr.length;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    if (callback(arr[i2], i2)) {\n      return arr[i2];\n    }\n  }\n  return null;\n}\nfunction getUserAgentString(agent2) {\n  var userAgent = agent2;\n  if (typeof userAgent === \"undefined\") {\n    if (typeof navigator === \"undefined\" || !navigator) {\n      return \"\";\n    }\n    userAgent = navigator.userAgent || \"\";\n  }\n  return userAgent.toLowerCase();\n}\nfunction execRegExp(pattern, text2) {\n  try {\n    return new RegExp(pattern, \"g\").exec(text2);\n  } catch (e) {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator === \"undefined\" || !navigator || !navigator.userAgentData) {\n    return false;\n  }\n  var userAgentData = navigator.userAgentData;\n  var brands = userAgentData.brands || userAgentData.uaList;\n  return !!(brands && brands.length);\n}\nfunction findVersion(versionTest, userAgent) {\n  var result = execRegExp(\"(\" + versionTest + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", userAgent);\n  return result ? result[3] : \"\";\n}\nfunction convertVersion(text2) {\n  return text2.replace(/_/g, \".\");\n}\nfunction findPreset(presets, userAgent) {\n  var userPreset = null;\n  var version2 = \"-1\";\n  some(presets, function(preset) {\n    var result = execRegExp(\"(\" + preset.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", userAgent);\n    if (!result || preset.brand) {\n      return false;\n    }\n    userPreset = preset;\n    version2 = result[3] || \"-1\";\n    if (preset.versionAlias) {\n      version2 = preset.versionAlias;\n    } else if (preset.versionTest) {\n      version2 = findVersion(preset.versionTest.toLowerCase(), userAgent) || version2;\n    }\n    version2 = convertVersion(version2);\n    return true;\n  });\n  return {\n    preset: userPreset,\n    version: version2\n  };\n}\nfunction findPresetBrand(presets, brands) {\n  var brandInfo = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  some(presets, function(preset) {\n    var result = findBrand(brands, preset);\n    if (!result) {\n      return false;\n    }\n    brandInfo.brand = preset.id;\n    brandInfo.version = preset.versionAlias || result.version;\n    return brandInfo.version !== \"-1\";\n  });\n  return brandInfo;\n}\nfunction findBrand(brands, preset) {\n  return find(brands, function(_a3) {\n    var brand = _a3.brand;\n    return execRegExp(\"\" + preset.test, brand.toLowerCase());\n  });\n}\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}];\nvar CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: true\n}];\nvar WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}];\nvar WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  test: \"webview\",\n  id: \"webview\"\n}];\nvar OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction isWebView(userAgent) {\n  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;\n}\nfunction getLegacyAgent(userAgent) {\n  var nextAgent = getUserAgentString(userAgent);\n  var isMobile2 = !!/mobi/g.exec(nextAgent);\n  var browser = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(nextAgent),\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webkit: false,\n    webkitVersion: \"-1\"\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  var _a3 = findPreset(BROWSER_PRESETS, nextAgent), browserPreset = _a3.preset, browserVersion = _a3.version;\n  var _b3 = findPreset(OS_PRESETS, nextAgent), osPreset = _b3.preset, osVersion = _b3.version;\n  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);\n  browser.chromium = !!chromiumPreset.preset;\n  browser.chromiumVersion = chromiumPreset.version;\n  if (!browser.chromium) {\n    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);\n    browser.webkit = !!webkitPreset.preset;\n    browser.webkitVersion = webkitPreset.version;\n  }\n  if (osPreset) {\n    os.name = osPreset.id;\n    os.version = osVersion;\n    os.majorVersion = parseInt(osVersion, 10);\n  }\n  if (browserPreset) {\n    browser.name = browserPreset.id;\n    browser.version = browserVersion;\n    if (browser.webview && os.name === \"ios\" && browser.name !== \"safari\") {\n      browser.webview = false;\n    }\n  }\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser,\n    os,\n    isMobile: isMobile2,\n    isHints: false\n  };\n}\nfunction getClientHintsAgent(osData) {\n  var userAgentData = navigator.userAgentData;\n  var brands = (userAgentData.uaList || userAgentData.brands).slice();\n  var fullVersionList = osData && osData.fullVersionList;\n  var isMobile2 = userAgentData.mobile || false;\n  var firstBrand = brands[0];\n  var platform2 = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();\n  var browser = {\n    name: firstBrand.brand,\n    version: firstBrand.version,\n    majorVersion: -1,\n    webkit: false,\n    webkitVersion: \"-1\",\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function(preset) {\n    return findBrand(brands, preset);\n  });\n  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);\n  browser.chromium = !!chromiumBrand.brand;\n  browser.chromiumVersion = chromiumBrand.version;\n  if (!browser.chromium) {\n    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);\n    browser.webkit = !!webkitBrand.brand;\n    browser.webkitVersion = webkitBrand.version;\n  }\n  var platfomResult = find(OS_PRESETS, function(preset) {\n    return new RegExp(\"\" + preset.test, \"g\").exec(platform2);\n  });\n  os.name = platfomResult ? platfomResult.id : \"\";\n  if (osData) {\n    os.version = osData.platformVersion;\n  }\n  if (fullVersionList && fullVersionList.length) {\n    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);\n    browser.name = browserBrandByFullVersionList.brand || browser.name;\n    browser.version = browserBrandByFullVersionList.version || browser.version;\n  } else {\n    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);\n    browser.name = browserBrand.brand || browser.name;\n    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;\n  }\n  if (browser.webkit) {\n    os.name = isMobile2 ? \"ios\" : \"mac\";\n  }\n  if (os.name === \"ios\" && browser.webview) {\n    browser.version = \"-1\";\n  }\n  os.version = convertVersion(os.version);\n  browser.version = convertVersion(browser.version);\n  os.majorVersion = parseInt(os.version, 10);\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser,\n    os,\n    isMobile: isMobile2,\n    isHints: true\n  };\n}\nfunction agent$1(userAgent) {\n  if (typeof userAgent === \"undefined\" && hasUserAgentData()) {\n    return getClientHintsAgent();\n  } else {\n    return getLegacyAgent(userAgent);\n  }\n}\nfunction add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {\n  for (var i2 = 0; i2 < n; ++i2) {\n    var x2 = startIndex + i2 * n;\n    var fromX = fromIndex + i2 * n;\n    matrix[x2] += matrix[fromX] * k;\n    inverseMatrix[x2] += inverseMatrix[fromX] * k;\n  }\n}\nfunction swap(matrix, inverseMatrix, startIndex, fromIndex, n) {\n  for (var i2 = 0; i2 < n; ++i2) {\n    var x2 = startIndex + i2 * n;\n    var fromX = fromIndex + i2 * n;\n    var v2 = matrix[x2];\n    var iv = inverseMatrix[x2];\n    matrix[x2] = matrix[fromX];\n    matrix[fromX] = v2;\n    inverseMatrix[x2] = inverseMatrix[fromX];\n    inverseMatrix[fromX] = iv;\n  }\n}\nfunction divide(matrix, inverseMatrix, startIndex, n, k) {\n  for (var i2 = 0; i2 < n; ++i2) {\n    var x2 = startIndex + i2 * n;\n    matrix[x2] /= k;\n    inverseMatrix[x2] /= k;\n  }\n}\nfunction ignoreDimension(matrix, m2, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  var newMatrix = matrix.slice();\n  for (var i2 = 0; i2 < n; ++i2) {\n    newMatrix[i2 * n + m2 - 1] = 0;\n    newMatrix[(m2 - 1) * n + i2] = 0;\n  }\n  newMatrix[(m2 - 1) * (n + 1)] = 1;\n  return newMatrix;\n}\nfunction invert(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  var newMatrix = matrix.slice();\n  var inverseMatrix = createIdentityMatrix(n);\n  for (var i2 = 0; i2 < n; ++i2) {\n    var identityIndex = n * i2 + i2;\n    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {\n      for (var j2 = i2 + 1; j2 < n; ++j2) {\n        if (newMatrix[n * i2 + j2]) {\n          swap(newMatrix, inverseMatrix, i2, j2, n);\n          break;\n        }\n      }\n    }\n    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {\n      return [];\n    }\n    divide(newMatrix, inverseMatrix, i2, n, newMatrix[identityIndex]);\n    for (var j2 = 0; j2 < n; ++j2) {\n      var targetStartIndex = j2;\n      var targetIndex = j2 + i2 * n;\n      var target = newMatrix[targetIndex];\n      if (!throttle(target, TINY_NUM$1) || i2 === j2) {\n        continue;\n      }\n      add(newMatrix, inverseMatrix, targetStartIndex, i2, n, -target);\n    }\n  }\n  return inverseMatrix;\n}\nfunction transpose(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  var newMatrix = [];\n  for (var i2 = 0; i2 < n; ++i2) {\n    for (var j2 = 0; j2 < n; ++j2) {\n      newMatrix[j2 * n + i2] = matrix[n * i2 + j2];\n    }\n  }\n  return newMatrix;\n}\nfunction getOrigin(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  var originMatrix = [];\n  var w2 = matrix[n * n - 1];\n  for (var i2 = 0; i2 < n - 1; ++i2) {\n    originMatrix[i2] = matrix[n * (n - 1) + i2] / w2;\n  }\n  originMatrix[n - 1] = 0;\n  return originMatrix;\n}\nfunction fromTranslation(pos, n) {\n  var newMatrix = createIdentityMatrix(n);\n  for (var i2 = 0; i2 < n - 1; ++i2) {\n    newMatrix[n * (n - 1) + i2] = pos[i2] || 0;\n  }\n  return newMatrix;\n}\nfunction convertPositionMatrix(matrix, n) {\n  var newMatrix = matrix.slice();\n  for (var i2 = matrix.length; i2 < n - 1; ++i2) {\n    newMatrix[i2] = 0;\n  }\n  newMatrix[n - 1] = 1;\n  return newMatrix;\n}\nfunction convertDimension(matrix, n, m2) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  if (n === m2) {\n    return matrix;\n  }\n  var newMatrix = createIdentityMatrix(m2);\n  var length2 = Math.min(n, m2);\n  for (var i2 = 0; i2 < length2 - 1; ++i2) {\n    for (var j2 = 0; j2 < length2 - 1; ++j2) {\n      newMatrix[i2 * m2 + j2] = matrix[i2 * n + j2];\n    }\n    newMatrix[(i2 + 1) * m2 - 1] = matrix[(i2 + 1) * n - 1];\n    newMatrix[(m2 - 1) * m2 + i2] = matrix[(n - 1) * n + i2];\n  }\n  newMatrix[m2 * m2 - 1] = matrix[n * n - 1];\n  return newMatrix;\n}\nfunction multiplies(n) {\n  var matrixes = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    matrixes[_i - 1] = arguments[_i];\n  }\n  var m2 = createIdentityMatrix(n);\n  matrixes.forEach(function(matrix) {\n    m2 = multiply(m2, matrix, n);\n  });\n  return m2;\n}\nfunction multiply(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n  var newMatrix = [];\n  var m2 = matrix.length / n;\n  var k = matrix2.length / m2;\n  if (!m2) {\n    return matrix2;\n  } else if (!k) {\n    return matrix;\n  }\n  for (var i2 = 0; i2 < n; ++i2) {\n    for (var j2 = 0; j2 < k; ++j2) {\n      newMatrix[j2 * n + i2] = 0;\n      for (var l2 = 0; l2 < m2; ++l2) {\n        newMatrix[j2 * n + i2] += matrix[l2 * n + i2] * matrix2[j2 * m2 + l2];\n      }\n    }\n  }\n  return newMatrix;\n}\nfunction plus(pos1, pos2) {\n  var length2 = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n  for (var i2 = 0; i2 < length2; ++i2) {\n    nextPos[i2] = nextPos[i2] + pos2[i2];\n  }\n  return nextPos;\n}\nfunction minus(pos1, pos2) {\n  var length2 = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n  for (var i2 = 0; i2 < length2; ++i2) {\n    nextPos[i2] = nextPos[i2] - pos2[i2];\n  }\n  return nextPos;\n}\nfunction convertCSStoMatrix(a2, is2d) {\n  if (is2d === void 0) {\n    is2d = a2.length === 6;\n  }\n  if (is2d) {\n    return [a2[0], a2[1], 0, a2[2], a2[3], 0, a2[4], a2[5], 1];\n  }\n  return a2;\n}\nfunction convertMatrixtoCSS(a2, is2d) {\n  if (is2d === void 0) {\n    is2d = a2.length === 9;\n  }\n  if (is2d) {\n    return [a2[0], a2[1], a2[3], a2[4], a2[6], a2[7]];\n  }\n  return a2;\n}\nfunction calculate(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = matrix2.length;\n  }\n  var result = multiply(matrix, matrix2, n);\n  var k = result[n - 1];\n  return result.map(function(v2) {\n    return v2 / k;\n  });\n}\nfunction rotateX3d(matrix, rad) {\n  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateY3d(matrix, rad) {\n  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateZ3d(matrix, rad) {\n  return multiply(matrix, createRotateMatrix(rad, 4));\n}\nfunction scale3d(matrix, _a3) {\n  var _b3 = _a3[0], sx = _b3 === void 0 ? 1 : _b3, _c3 = _a3[1], sy = _c3 === void 0 ? 1 : _c3, _d2 = _a3[2], sz = _d2 === void 0 ? 1 : _d2;\n  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);\n}\nfunction rotate(pos, rad) {\n  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));\n}\nfunction translate3d(matrix, _a3) {\n  var _b3 = _a3[0], tx = _b3 === void 0 ? 0 : _b3, _c3 = _a3[1], ty = _c3 === void 0 ? 0 : _c3, _d2 = _a3[2], tz = _d2 === void 0 ? 0 : _d2;\n  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);\n}\nfunction matrix3d(matrix1, matrix2) {\n  return multiply(matrix1, matrix2, 4);\n}\nfunction createRotateMatrix(rad, n) {\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var m2 = createIdentityMatrix(n);\n  m2[0] = cos;\n  m2[1] = sin;\n  m2[n] = -sin;\n  m2[n + 1] = cos;\n  return m2;\n}\nfunction createIdentityMatrix(n) {\n  var length2 = n * n;\n  var matrix = [];\n  for (var i2 = 0; i2 < length2; ++i2) {\n    matrix[i2] = i2 % (n + 1) ? 0 : 1;\n  }\n  return matrix;\n}\nfunction createScaleMatrix(scale, n) {\n  var m2 = createIdentityMatrix(n);\n  var length2 = Math.min(scale.length, n - 1);\n  for (var i2 = 0; i2 < length2; ++i2) {\n    m2[(n + 1) * i2] = scale[i2];\n  }\n  return m2;\n}\nfunction createOriginMatrix(origin, n) {\n  var m2 = createIdentityMatrix(n);\n  var length2 = Math.min(origin.length, n - 1);\n  for (var i2 = 0; i2 < length2; ++i2) {\n    m2[n * (n - 1) + i2] = origin[i2];\n  }\n  return m2;\n}\nfunction createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {\n  var x0 = pos0[0], y0 = pos0[1];\n  var x1 = pos1[0], y1 = pos1[1];\n  var x2 = pos2[0], y2 = pos2[1];\n  var x3 = pos3[0], y3 = pos3[1];\n  var u0 = nextPos0[0], v0 = nextPos0[1];\n  var u1 = nextPos1[0], v1 = nextPos1[1];\n  var u2 = nextPos2[0], v2 = nextPos2[1];\n  var u3 = nextPos3[0], v3 = nextPos3[1];\n  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];\n  var inverseMatrix = invert(matrix, 8);\n  if (!inverseMatrix.length) {\n    return [];\n  }\n  var h2 = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n  h2[8] = 1;\n  return convertDimension(transpose(h2), 3, 4);\n}\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction parseMat(transform) {\n  return toMat(parse(transform));\n}\nfunction calculateMatrixDist(matrix, pos) {\n  var res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n  var w2 = res[3] || 1;\n  return [res[0] / w2, res[1] / w2, res[2] / w2];\n}\nfunction toMat(matrixInfos) {\n  var target = createMatrix();\n  matrixInfos.forEach(function(info) {\n    var matrixFunction = info.matrixFunction, functionValue = info.functionValue;\n    if (!matrixFunction) {\n      return;\n    }\n    target = matrixFunction(target, functionValue);\n  });\n  return target;\n}\nfunction parse(transform) {\n  var transforms = isArray(transform) ? transform : splitSpace(transform);\n  return transforms.map(function(t) {\n    var _a3 = splitBracket(t), name = _a3.prefix, value2 = _a3.value;\n    var matrixFunction = null;\n    var functionName = name;\n    var functionValue = \"\";\n    if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n      var _b3 = splitComma(value2).map(function(v2) {\n        return parseFloat(v2);\n      }), posX = _b3[0], _c3 = _b3[1], posY = _c3 === void 0 ? 0 : _c3, _d2 = _b3[2], posZ = _d2 === void 0 ? 0 : _d2;\n      matrixFunction = translate3d;\n      functionValue = [posX, posY, posZ];\n    } else if (name === \"translateY\") {\n      var posY = parseFloat(value2);\n      matrixFunction = translate3d;\n      functionValue = [0, posY, 0];\n    } else if (name === \"translateZ\") {\n      var posZ = parseFloat(value2);\n      matrixFunction = translate3d;\n      functionValue = [0, 0, posZ];\n    } else if (name === \"scale\" || name === \"scale3d\") {\n      var _e = splitComma(value2).map(function(v2) {\n        return parseFloat(v2);\n      }), sx = _e[0], _f = _e[1], sy = _f === void 0 ? sx : _f, _g = _e[2], sz = _g === void 0 ? 1 : _g;\n      matrixFunction = scale3d;\n      functionValue = [sx, sy, sz];\n    } else if (name === \"scaleX\") {\n      var sx = parseFloat(value2);\n      matrixFunction = scale3d;\n      functionValue = [sx, 1, 1];\n    } else if (name === \"scaleY\") {\n      var sy = parseFloat(value2);\n      matrixFunction = scale3d;\n      functionValue = [1, sy, 1];\n    } else if (name === \"scaleZ\") {\n      var sz = parseFloat(value2);\n      matrixFunction = scale3d;\n      functionValue = [1, 1, sz];\n    } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n      var _h = splitUnit(value2), unit = _h.unit, unitValue = _h.value;\n      var rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n      if (name === \"rotate\" || name === \"rotateZ\") {\n        functionName = \"rotateZ\";\n        matrixFunction = rotateZ3d;\n      } else if (name === \"rotateX\") {\n        matrixFunction = rotateX3d;\n      } else if (name === \"rotateY\") {\n        matrixFunction = rotateY3d;\n      }\n      functionValue = rad;\n    } else if (name === \"matrix3d\") {\n      matrixFunction = matrix3d;\n      functionValue = splitComma(value2).map(function(v2) {\n        return parseFloat(v2);\n      });\n    } else if (name === \"matrix\") {\n      var m2 = splitComma(value2).map(function(v2) {\n        return parseFloat(v2);\n      });\n      matrixFunction = matrix3d;\n      functionValue = [m2[0], m2[1], 0, 0, m2[2], m2[3], 0, 0, 0, 0, 1, 0, m2[4], m2[5], 0, 1];\n    } else {\n      functionName = \"\";\n    }\n    return {\n      name,\n      functionName,\n      value: value2,\n      matrixFunction,\n      functionValue\n    };\n  });\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$5 = function(d2, b2) {\n  extendStatics$5 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$5(d2, b2);\n};\nfunction __extends$5(d2, b2) {\n  extendStatics$5(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar findKeyCallback = typeof Map === \"function\" ? void 0 : function() {\n  var childrenCount = 0;\n  return function(el) {\n    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);\n  };\n}();\nvar ChildrenDiffer = /* @__PURE__ */ function(_super) {\n  __extends$5(ChildrenDiffer2, _super);\n  function ChildrenDiffer2(list) {\n    if (list === void 0) {\n      list = [];\n    }\n    return _super.call(this, list, findKeyCallback) || this;\n  }\n  return ChildrenDiffer2;\n}(ListDiffer);\nfunction diff(prevList, list) {\n  return diff$1(prevList, list, findKeyCallback);\n}\nvar ChildrenDiffer$1 = ChildrenDiffer;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$3() {\n  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n    s2 += arguments[i2].length;\n  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)\n    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)\n      r2[k] = a2[j2];\n  return r2;\n}\nfunction getAreaSize(points) {\n  if (points.length < 3) {\n    return 0;\n  }\n  return Math.abs(sum(points.map(function(point, i2) {\n    var nextPoint = points[i2 + 1] || points[0];\n    return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n  }))) / 2;\n}\nfunction fitPoints(points, rect) {\n  var width = rect.width, height = rect.height, left2 = rect.left, top2 = rect.top;\n  var _a3 = getMinMaxs(points), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;\n  var ratioX = width / (maxX - minX);\n  var ratioY = height / (maxY - minY);\n  return points.map(function(point) {\n    return [left2 + (point[0] - minX) * ratioX, top2 + (point[1] - minY) * ratioY];\n  });\n}\nfunction getMinMaxs(points) {\n  var xs = points.map(function(point) {\n    return point[0];\n  });\n  var ys = points.map(function(point) {\n    return point[1];\n  });\n  return {\n    minX: Math.min.apply(Math, xs),\n    minY: Math.min.apply(Math, ys),\n    maxX: Math.max.apply(Math, xs),\n    maxY: Math.max.apply(Math, ys)\n  };\n}\nfunction isInside(pos, points, excludeLine) {\n  var x2 = pos[0], y2 = pos[1];\n  var _a3 = getMinMaxs(points), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;\n  var xLine = [[minX, y2], [maxX, y2]];\n  var yLine = [[x2, minY], [x2, maxY]];\n  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);\n  var lines = convertLines(points);\n  var intersectionXPoints = [];\n  var intersectionYPoints = [];\n  lines.forEach(function(line) {\n    var linearConstants = getLinearConstants(line[0], line[1]);\n    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);\n    if (xPoints.length === 1 ? line[0][1] !== y2 : true) {\n      intersectionXPoints.push.apply(intersectionXPoints, xPoints);\n    }\n    if (yPoints.length === 1 ? line[0][0] !== x2 : true) {\n      intersectionYPoints.push.apply(intersectionYPoints, yPoints);\n    }\n    if (!linearConstants[0]) {\n      intersectionXPoints.push.apply(intersectionXPoints, xPoints);\n    }\n    if (!linearConstants[1]) {\n      intersectionYPoints.push.apply(intersectionYPoints, yPoints);\n    }\n  });\n  if (!excludeLine) {\n    if (findIndex(intersectionXPoints, function(p2) {\n      return p2[0] === x2;\n    }) > -1 || findIndex(intersectionYPoints, function(p2) {\n      return p2[1] === y2;\n    }) > -1) {\n      return true;\n    }\n  }\n  if (intersectionXPoints.filter(function(p2) {\n    return p2[0] > x2;\n  }).length % 2 && intersectionYPoints.filter(function(p2) {\n    return p2[1] > y2;\n  }).length % 2) {\n    return true;\n  }\n  return false;\n}\nfunction getLinearConstants(point1, point2) {\n  var x1 = point1[0], y1 = point1[1];\n  var x2 = point2[0], y2 = point2[1];\n  if (x1 === x2 && y1 === y2) {\n    return [0, 0, 0];\n  }\n  if (x1 === x2) {\n    return [1, 0, -x1];\n  } else if (y1 === y2) {\n    return [0, 1, -y1];\n  } else {\n    var a_1 = (x2 - x1) / (y1 - y2);\n    var b_1 = -x1 - a_1 * y1;\n    return [1, a_1, b_1];\n  }\n}\nfunction getIntersectionPointsByConstants(linearConstants1, linearConstants2) {\n  var a1 = linearConstants1[0], b1 = linearConstants1[1], c1 = linearConstants1[2];\n  var a2 = linearConstants2[0], b2 = linearConstants2[1], c2 = linearConstants2[2];\n  var isZeroA = a1 === 0 && a2 === 0;\n  var isZeroB = b1 === 0 && b2 === 0;\n  if (isZeroA && isZeroB) {\n    return [];\n  } else if (isZeroA) {\n    var y1 = -c1 / b1;\n    var y2 = -c2 / b2;\n    if (y1 !== y2) {\n      return [];\n    } else {\n      return [[-Infinity, y1], [Infinity, y1]];\n    }\n  } else if (isZeroB) {\n    var x1 = -c1 / a1;\n    var x2 = -c2 / a2;\n    if (x1 !== x2) {\n      return [];\n    } else {\n      return [[x1, -Infinity], [x1, Infinity]];\n    }\n  } else if (a1 === 0) {\n    var y3 = -c1 / b1;\n    var x3 = -(b2 * y3 + c2) / a2;\n    return [[x3, y3]];\n  } else if (a2 === 0) {\n    var y3 = -c2 / b2;\n    var x3 = -(b1 * y3 + c1) / a1;\n    return [[x3, y3]];\n  } else if (b1 === 0) {\n    var x3 = -c1 / a1;\n    var y3 = -(a2 * x3 + c2) / b2;\n    return [[x3, y3]];\n  } else if (b2 === 0) {\n    var x3 = -c2 / a2;\n    var y3 = -(a1 * x3 + c1) / b1;\n    return [[x3, y3]];\n  } else {\n    var x3 = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n    var y3 = -(a1 * x3 + c1) / b1;\n    return [[x3, y3]];\n  }\n}\nfunction getPointsOnLines(points, lines) {\n  var minMaxs = lines.map(function(line) {\n    return [0, 1].map(function(order2) {\n      return [Math.min(line[0][order2], line[1][order2]), Math.max(line[0][order2], line[1][order2])];\n    });\n  });\n  if (points.length === 2) {\n    var _a3 = points[0], x2 = _a3[0], y2 = _a3[1];\n    if (x2 === points[1][0]) {\n      var top2 = Math.max.apply(Math, minMaxs.map(function(minMax) {\n        return minMax[1][0];\n      }));\n      var bottom2 = Math.min.apply(Math, minMaxs.map(function(minMax) {\n        return minMax[1][1];\n      }));\n      if (top2 > bottom2) {\n        return [];\n      }\n      return [[x2, top2], [x2, bottom2]];\n    } else if (y2 === points[1][1]) {\n      var left2 = Math.max.apply(Math, minMaxs.map(function(minMax) {\n        return minMax[0][0];\n      }));\n      var right2 = Math.min.apply(Math, minMaxs.map(function(minMax) {\n        return minMax[0][1];\n      }));\n      if (left2 > right2) {\n        return [];\n      }\n      return [[left2, y2], [right2, y2]];\n    }\n  }\n  return points.filter(function(point) {\n    return minMaxs.every(function(minMax) {\n      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];\n    });\n  });\n}\nfunction convertLines(points) {\n  return __spreadArrays$3(points.slice(1), [points[0]]).map(function(point, i2) {\n    return [points[i2], point];\n  });\n}\nfunction getOverlapPoints(points1, points2) {\n  var targetPoints1 = points1.slice();\n  var targetPoints2 = points2.slice();\n  if (getShapeDirection(targetPoints1) === -1) {\n    targetPoints1.reverse();\n  }\n  if (getShapeDirection(targetPoints2) === -1) {\n    targetPoints2.reverse();\n  }\n  var lines1 = convertLines(targetPoints1);\n  var lines2 = convertLines(targetPoints2);\n  var linearConstantss1 = lines1.map(function(line1) {\n    return getLinearConstants(line1[0], line1[1]);\n  });\n  var linearConstantss2 = lines2.map(function(line2) {\n    return getLinearConstants(line2[0], line2[1]);\n  });\n  var overlapInfos = [];\n  linearConstantss1.forEach(function(linearConstants1, i2) {\n    var line1 = lines1[i2];\n    var linePointInfos = [];\n    linearConstantss2.forEach(function(linearConstants2, j2) {\n      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j2]]);\n      linePointInfos.push.apply(linePointInfos, points.map(function(pos) {\n        return {\n          index1: i2,\n          index2: j2,\n          pos\n        };\n      }));\n    });\n    linePointInfos.sort(function(a2, b2) {\n      return getDist$2(line1[0], a2.pos) - getDist$2(line1[0], b2.pos);\n    });\n    overlapInfos.push.apply(overlapInfos, linePointInfos);\n    if (isInside(line1[1], targetPoints2)) {\n      overlapInfos.push({\n        index1: i2,\n        index2: -1,\n        pos: line1[1]\n      });\n    }\n  });\n  lines2.forEach(function(line2, i2) {\n    if (isInside(line2[1], targetPoints1)) {\n      var isNext_1 = false;\n      var index = findIndex(overlapInfos, function(_a3) {\n        var index2 = _a3.index2;\n        if (index2 === i2) {\n          isNext_1 = true;\n          return false;\n        }\n        if (isNext_1) {\n          return true;\n        }\n        return false;\n      });\n      if (index === -1) {\n        isNext_1 = false;\n        index = findIndex(overlapInfos, function(_a3) {\n          var index1 = _a3.index1, index2 = _a3.index2;\n          if (index1 === -1 && index2 + 1 === i2) {\n            isNext_1 = true;\n            return false;\n          }\n          if (isNext_1) {\n            return true;\n          }\n          return false;\n        });\n      }\n      if (index === -1) {\n        overlapInfos.push({\n          index1: -1,\n          index2: i2,\n          pos: line2[1]\n        });\n      } else {\n        overlapInfos.splice(index, 0, {\n          index1: -1,\n          index2: i2,\n          pos: line2[1]\n        });\n      }\n    }\n  });\n  var overlapPoints = overlapInfos.map(function(_a3) {\n    var pos = _a3.pos;\n    return pos;\n  });\n  var pointMap = {};\n  return overlapPoints.filter(function(point) {\n    var key = point[0] + \"x\" + point[1];\n    if (pointMap[key]) {\n      return false;\n    }\n    pointMap[key] = true;\n    return true;\n  });\n}\nfunction getOverlapSize(points1, points2) {\n  var points = getOverlapPoints(points1, points2);\n  return getAreaSize(points);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$6 = function() {\n  __assign$6 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$6.apply(this, arguments);\n};\nfunction __spreadArrays$2() {\n  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n    s2 += arguments[i2].length;\n  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)\n    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)\n      r2[k] = a2[j2];\n  return r2;\n}\nvar EventEmitter$2 = /* @__PURE__ */ function() {\n  function EventEmitter2() {\n    this._events = {};\n  }\n  var __proto = EventEmitter2.prototype;\n  __proto.on = function(eventName, listener) {\n    if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.on(name, eventName[name]);\n      }\n    } else {\n      this._addEvent(eventName, listener, {});\n    }\n    return this;\n  };\n  __proto.off = function(eventName, listener) {\n    if (!eventName) {\n      this._events = {};\n    } else if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.off(name);\n      }\n    } else if (!listener) {\n      this._events[eventName] = [];\n    } else {\n      var events = this._events[eventName];\n      if (events) {\n        var index = findIndex(events, function(e) {\n          return e.listener === listener;\n        });\n        if (index > -1) {\n          events.splice(index, 1);\n        }\n      }\n    }\n    return this;\n  };\n  __proto.once = function(eventName, listener) {\n    var _this = this;\n    if (listener) {\n      this._addEvent(eventName, listener, {\n        once: true\n      });\n    }\n    return new Promise(function(resolve2) {\n      _this._addEvent(eventName, resolve2, {\n        once: true\n      });\n    });\n  };\n  __proto.emit = function(eventName, param) {\n    var _this = this;\n    if (param === void 0) {\n      param = {};\n    }\n    var events = this._events[eventName];\n    if (!eventName || !events) {\n      return true;\n    }\n    var isStop = false;\n    param.eventType = eventName;\n    param.stop = function() {\n      isStop = true;\n    };\n    param.currentTarget = this;\n    __spreadArrays$2(events).forEach(function(info) {\n      info.listener(param);\n      if (info.once) {\n        _this.off(eventName, info.listener);\n      }\n    });\n    return !isStop;\n  };\n  __proto.trigger = function(eventName, param) {\n    if (param === void 0) {\n      param = {};\n    }\n    return this.emit(eventName, param);\n  };\n  __proto._addEvent = function(eventName, listener, options) {\n    var events = this._events;\n    events[eventName] = events[eventName] || [];\n    var listeners = events[eventName];\n    listeners.push(__assign$6({\n      listener\n    }, options));\n  };\n  return EventEmitter2;\n}();\nvar EventEmitter$3 = EventEmitter$2;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$4 = function(d2, b2) {\n  extendStatics$4 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$4(d2, b2);\n};\nfunction __extends$4(d2, b2) {\n  extendStatics$4(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$5 = function() {\n  __assign$5 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$5.apply(this, arguments);\n};\nfunction getDefaultScrollPosition$1(e) {\n  var container = e.container;\n  if (container === document.body) {\n    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];\n  }\n  return [container.scrollLeft, container.scrollTop];\n}\nvar DragScroll = /* @__PURE__ */ function(_super) {\n  __extends$4(DragScroll2, _super);\n  function DragScroll2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._startRect = null;\n    _this._startPos = [];\n    _this._prevTime = 0;\n    _this._timer = 0;\n    _this._prevScrollPos = [0, 0];\n    _this._isWait = false;\n    return _this;\n  }\n  var __proto = DragScroll2.prototype;\n  __proto.dragStart = function(e, options) {\n    var container = options.container;\n    var top2 = 0;\n    var left2 = 0;\n    var width = 0;\n    var height = 0;\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      var rect = container.getBoundingClientRect();\n      top2 = rect.top;\n      left2 = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n    this._startPos = [e.clientX, e.clientY];\n    this._startRect = {\n      top: top2,\n      left: left2,\n      width,\n      height\n    };\n    this._prevScrollPos = this._getScrollPosition([0, 0], options);\n  };\n  __proto.drag = function(e, options) {\n    var clientX = e.clientX, clientY = e.clientY;\n    var _a3 = options.threshold, threshold2 = _a3 === void 0 ? 0 : _a3;\n    var _b3 = this, _startRect = _b3._startRect, _startPos = _b3._startPos;\n    var direction = [0, 0];\n    if (_startRect.top > clientY - threshold2) {\n      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (_startRect.top + _startRect.height < clientY + threshold2) {\n      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n    if (_startRect.left > clientX - threshold2) {\n      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (_startRect.left + _startRect.width < clientX + threshold2) {\n      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n    clearTimeout(this._timer);\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n    return this._continueDrag(__assign$5(__assign$5({}, options), {\n      direction,\n      inputEvent: e,\n      isDrag: true\n    }));\n  };\n  __proto.checkScroll = function(options) {\n    var _this = this;\n    if (this._isWait) {\n      return false;\n    }\n    var _a3 = options.prevScrollPos, prevScrollPos = _a3 === void 0 ? this._prevScrollPos : _a3, direction = options.direction, _b3 = options.throttleTime, throttleTime = _b3 === void 0 ? 0 : _b3, inputEvent = options.inputEvent, isDrag = options.isDrag;\n    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n    var offsetX = nextScrollPos[0] - prevScrollPos[0];\n    var offsetY = nextScrollPos[1] - prevScrollPos[1];\n    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];\n    this._prevScrollPos = nextScrollPos;\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n    this.trigger(\"move\", {\n      offsetX: nextDirection[0] ? offsetX : 0,\n      offsetY: nextDirection[1] ? offsetY : 0,\n      inputEvent\n    });\n    if (throttleTime && isDrag) {\n      this._timer = window.setTimeout(function() {\n        _this._continueDrag(options);\n      }, throttleTime);\n    }\n    return true;\n  };\n  __proto.dragEnd = function() {\n    clearTimeout(this._timer);\n  };\n  __proto._getScrollPosition = function(direction, options) {\n    var container = options.container, _a3 = options.getScrollPosition, getScrollPosition = _a3 === void 0 ? getDefaultScrollPosition$1 : _a3;\n    return getScrollPosition({\n      container,\n      direction\n    });\n  };\n  __proto._continueDrag = function(options) {\n    var _this = this;\n    var container = options.container, direction = options.direction, throttleTime = options.throttleTime, useScroll = options.useScroll, isDrag = options.isDrag, inputEvent = options.inputEvent;\n    if (isDrag && this._isWait) {\n      return;\n    }\n    var nowTime = now();\n    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n    if (distTime > 0) {\n      this._timer = window.setTimeout(function() {\n        _this._continueDrag(options);\n      }, distTime);\n      return false;\n    }\n    this._prevTime = nowTime;\n    var prevScrollPos = this._getScrollPosition(direction, options);\n    this._prevScrollPos = prevScrollPos;\n    if (isDrag) {\n      this._isWait = true;\n    }\n    this.trigger(\"scroll\", {\n      container,\n      direction,\n      inputEvent\n    });\n    this._isWait = false;\n    return useScroll || this.checkScroll(__assign$5(__assign$5({}, options), {\n      prevScrollPos,\n      direction,\n      inputEvent\n    }));\n  };\n  return DragScroll2;\n}(EventEmitter$3);\nvar DragScroll$1 = DragScroll;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$3 = function(d2, b2) {\n  extendStatics$3 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$3(d2, b2);\n};\nfunction __extends$3(d2, b2) {\n  extendStatics$3(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$4 = function() {\n  __assign$4 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$4.apply(this, arguments);\n};\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\nfunction getRotatiion(touches) {\n  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;\n}\nfunction isMultiTouch(e) {\n  return e.touches && e.touches.length >= 2;\n}\nfunction getEventClients(e) {\n  if (!e) {\n    return [];\n  }\n  if (e.touches) {\n    return getClients(e.touches);\n  } else {\n    return [getClient(e)];\n  }\n}\nfunction getPosition(clients, prevClients, startClients) {\n  var length2 = startClients.length;\n  var _a3 = getAverageClient(clients, length2), clientX = _a3.clientX, clientY = _a3.clientY, originalClientX = _a3.originalClientX, originalClientY = _a3.originalClientY;\n  var _b3 = getAverageClient(prevClients, length2), prevX = _b3.clientX, prevY = _b3.clientY;\n  var _c3 = getAverageClient(startClients, length2), startX = _c3.clientX, startY = _c3.clientY;\n  var deltaX = clientX - prevX;\n  var deltaY = clientY - prevY;\n  var distX = clientX - startX;\n  var distY = clientY - startY;\n  return {\n    clientX: originalClientX,\n    clientY: originalClientY,\n    deltaX,\n    deltaY,\n    distX,\n    distY\n  };\n}\nfunction getDist$1(clients) {\n  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));\n}\nfunction getClients(touches) {\n  var length2 = Math.min(touches.length, 2);\n  var clients = [];\n  for (var i2 = 0; i2 < length2; ++i2) {\n    clients.push(getClient(touches[i2]));\n  }\n  return clients;\n}\nfunction getClient(e) {\n  return {\n    clientX: e.clientX,\n    clientY: e.clientY\n  };\n}\nfunction getAverageClient(clients, length2) {\n  if (length2 === void 0) {\n    length2 = clients.length;\n  }\n  var sumClient = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  };\n  for (var i2 = 0; i2 < length2; ++i2) {\n    var client = clients[i2];\n    sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX : client.clientX;\n    sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY : client.clientY;\n    sumClient.clientX += client.clientX;\n    sumClient.clientY += client.clientY;\n  }\n  if (!length2) {\n    return sumClient;\n  }\n  return {\n    clientX: sumClient.clientX / length2,\n    clientY: sumClient.clientY / length2,\n    originalClientX: sumClient.originalClientX / length2,\n    originalClientY: sumClient.originalClientY / length2\n  };\n}\nvar ClientStore = /* @__PURE__ */ function() {\n  function ClientStore2(clients) {\n    this.prevClients = [];\n    this.startClients = [];\n    this.movement = 0;\n    this.length = 0;\n    this.startClients = clients;\n    this.prevClients = clients;\n    this.length = clients.length;\n  }\n  var __proto = ClientStore2.prototype;\n  __proto.getAngle = function(clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    return getRotatiion(clients);\n  };\n  __proto.getRotation = function(clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    return getRotatiion(clients) - getRotatiion(this.startClients);\n  };\n  __proto.getPosition = function(clients, isAdd) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n    var deltaX = position.deltaX, deltaY = position.deltaY;\n    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    this.prevClients = clients;\n    return position;\n  };\n  __proto.getPositions = function(clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    var prevClients = this.prevClients;\n    return this.startClients.map(function(startClient, i2) {\n      return getPosition([clients[i2]], [prevClients[i2]], [startClient]);\n    });\n  };\n  __proto.getMovement = function(clients) {\n    var movement = this.movement;\n    if (!clients) {\n      return movement;\n    }\n    var currentClient = getAverageClient(clients, this.length);\n    var prevClient = getAverageClient(this.prevClients, this.length);\n    var deltaX = currentClient.clientX - prevClient.clientX;\n    var deltaY = currentClient.clientY - prevClient.clientY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n  };\n  __proto.getDistance = function(clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    return getDist$1(clients);\n  };\n  __proto.getScale = function(clients) {\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n    return getDist$1(clients) / getDist$1(this.startClients);\n  };\n  __proto.move = function(deltaX, deltaY) {\n    this.startClients.forEach(function(client) {\n      client.clientX -= deltaX;\n      client.clientY -= deltaY;\n    });\n  };\n  return ClientStore2;\n}();\nvar INPUT_TAGNAMES = [\"textarea\", \"input\"];\nvar Gesto = /* @__PURE__ */ function(_super) {\n  __extends$3(Gesto2, _super);\n  function Gesto2(targets, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.options = {};\n    _this.flag = false;\n    _this.pinchFlag = false;\n    _this.datas = {};\n    _this.isDrag = false;\n    _this.isPinch = false;\n    _this.isMouse = false;\n    _this.isTouch = false;\n    _this.clientStores = [];\n    _this.targets = [];\n    _this.prevTime = 0;\n    _this.doubleFlag = false;\n    _this._dragFlag = false;\n    _this.onDragStart = function(e, isTrusted) {\n      if (isTrusted === void 0) {\n        isTrusted = true;\n      }\n      if (!_this.flag && e.cancelable === false) {\n        return;\n      }\n      var _a4 = _this.options, container2 = _a4.container, pinchOutside = _a4.pinchOutside, preventRightClick = _a4.preventRightClick, preventDefault = _a4.preventDefault, checkInput = _a4.checkInput;\n      var isTouch = _this.isTouch;\n      var isDragStart = !_this.flag;\n      if (isDragStart) {\n        var activeElement = document.activeElement;\n        var target = e.target;\n        var tagName = target.tagName.toLowerCase();\n        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n        var hasContentEditable = target.isContentEditable;\n        if (hasInput || hasContentEditable) {\n          if (checkInput || activeElement === target) {\n            return false;\n          }\n          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {\n            return false;\n          }\n        } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n          var activeTagName = activeElement.tagName;\n          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n            activeElement.blur();\n          }\n        }\n        _this.clientStores = [new ClientStore(getEventClients(e))];\n        _this.flag = true;\n        _this.isDrag = false;\n        _this._dragFlag = true;\n        _this.datas = {};\n        if (preventRightClick && (e.which === 3 || e.button === 2)) {\n          _this.initDrag();\n          return false;\n        }\n        _this.doubleFlag = now() - _this.prevTime < 200;\n        var result = _this.emit(\"dragStart\", __assign$4(__assign$4({\n          datas: _this.datas,\n          inputEvent: e,\n          isTrusted,\n          isDouble: _this.doubleFlag\n        }, _this.getCurrentStore().getPosition()), {\n          preventDefault: function() {\n            e.preventDefault();\n          },\n          preventDrag: function() {\n            _this._dragFlag = false;\n          }\n        }));\n        if (result === false) {\n          _this.initDrag();\n        }\n        _this.flag && preventDefault && e.preventDefault();\n      }\n      if (!_this.flag) {\n        return false;\n      }\n      var timer = 0;\n      if (isDragStart && isTouch && pinchOutside) {\n        timer = setTimeout(function() {\n          addEvent(container2, \"touchstart\", _this.onDragStart, {\n            passive: false\n          });\n        });\n      }\n      if (!isDragStart && isTouch && pinchOutside) {\n        removeEvent(container2, \"touchstart\", _this.onDragStart);\n      }\n      if (_this.flag && isMultiTouch(e)) {\n        clearTimeout(timer);\n        if (isDragStart && e.touches.length !== e.changedTouches.length) {\n          return;\n        }\n        if (!_this.pinchFlag) {\n          _this.onPinchStart(e);\n        }\n      }\n    };\n    _this.onDrag = function(e, isScroll) {\n      if (!_this.flag) {\n        return;\n      }\n      var clients = getEventClients(e);\n      var result = _this.moveClients(clients, e, false);\n      if (_this._dragFlag) {\n        if (_this.pinchFlag || result.deltaX || result.deltaY) {\n          var dragResult = _this.emit(\"drag\", __assign$4(__assign$4({}, result), {\n            isScroll: !!isScroll,\n            inputEvent: e\n          }));\n          if (dragResult === false) {\n            _this.stop();\n            return;\n          }\n        }\n        if (_this.pinchFlag) {\n          _this.onPinch(e, clients);\n        }\n      }\n      _this.getCurrentStore().getPosition(clients, true);\n    };\n    _this.onDragEnd = function(e) {\n      if (!_this.flag) {\n        return;\n      }\n      var _a4 = _this.options, pinchOutside = _a4.pinchOutside, container2 = _a4.container;\n      if (_this.isTouch && pinchOutside) {\n        removeEvent(container2, \"touchstart\", _this.onDragStart);\n      }\n      if (_this.pinchFlag) {\n        _this.onPinchEnd(e);\n      }\n      var clients = (e === null || e === void 0 ? void 0 : e.touches) ? getEventClients(e) : [];\n      var clientsLength = clients.length;\n      if (clientsLength === 0 || !_this.options.keepDragging) {\n        _this.flag = false;\n      } else {\n        _this._addStore(new ClientStore(clients));\n      }\n      var position = _this._getPosition();\n      var currentTime = now();\n      var isDouble = !_this.isDrag && _this.doubleFlag;\n      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;\n      if (!_this.flag) {\n        _this.emit(\"dragEnd\", __assign$4({\n          datas: _this.datas,\n          isDouble,\n          isDrag: _this.isDrag,\n          isClick: !_this.isDrag,\n          inputEvent: e\n        }, position));\n        _this.clientStores = [];\n      }\n    };\n    _this.onBlur = function() {\n      _this.onDragEnd();\n    };\n    var elements = [].concat(targets);\n    _this.options = __assign$4({\n      checkInput: false,\n      container: elements.length > 1 ? window : elements[0],\n      preventRightClick: true,\n      preventDefault: true,\n      checkWindowBlur: false,\n      keepDragging: false,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, options);\n    var _a3 = _this.options, container = _a3.container, events = _a3.events, checkWindowBlur = _a3.checkWindowBlur;\n    _this.isTouch = events.indexOf(\"touch\") > -1;\n    _this.isMouse = events.indexOf(\"mouse\") > -1;\n    _this.targets = elements;\n    if (_this.isMouse) {\n      elements.forEach(function(el) {\n        addEvent(el, \"mousedown\", _this.onDragStart);\n      });\n      addEvent(container, \"mousemove\", _this.onDrag);\n      addEvent(container, \"mouseup\", _this.onDragEnd);\n      addEvent(container, \"contextmenu\", _this.onDragEnd);\n    }\n    if (checkWindowBlur) {\n      addEvent(window, \"blur\", _this.onBlur);\n    }\n    if (_this.isTouch) {\n      var passive_1 = {\n        passive: false\n      };\n      elements.forEach(function(el) {\n        addEvent(el, \"touchstart\", _this.onDragStart, passive_1);\n      });\n      addEvent(container, \"touchmove\", _this.onDrag, passive_1);\n      addEvent(container, \"touchend\", _this.onDragEnd, passive_1);\n      addEvent(container, \"touchcancel\", _this.onDragEnd, passive_1);\n    }\n    return _this;\n  }\n  var __proto = Gesto2.prototype;\n  __proto.stop = function() {\n    this.isDrag = false;\n    this.flag = false;\n    this.clientStores = [];\n    this.datas = {};\n  };\n  __proto.getMovement = function(clients) {\n    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function(prev2, cur) {\n      return prev2 + cur.movement;\n    }, 0);\n  };\n  __proto.isDragging = function() {\n    return this.isDrag;\n  };\n  __proto.isFlag = function() {\n    return this.flag;\n  };\n  __proto.isPinchFlag = function() {\n    return this.pinchFlag;\n  };\n  __proto.isDoubleFlag = function() {\n    return this.doubleFlag;\n  };\n  __proto.isPinching = function() {\n    return this.isPinch;\n  };\n  __proto.scrollBy = function(deltaX, deltaY, e, isCallDrag) {\n    if (isCallDrag === void 0) {\n      isCallDrag = true;\n    }\n    if (!this.flag) {\n      return;\n    }\n    this.clientStores[0].move(deltaX, deltaY);\n    isCallDrag && this.onDrag(e, true);\n  };\n  __proto.move = function(_a3, inputEvent) {\n    var deltaX = _a3[0], deltaY = _a3[1];\n    var store = this.getCurrentStore();\n    var nextClients = store.prevClients;\n    return this.moveClients(nextClients.map(function(_a4) {\n      var clientX = _a4.clientX, clientY = _a4.clientY;\n      return {\n        clientX: clientX + deltaX,\n        clientY: clientY + deltaY,\n        originalClientX: clientX,\n        originalClientY: clientY\n      };\n    }), inputEvent, true);\n  };\n  __proto.triggerDragStart = function(e) {\n    this.onDragStart(e, false);\n  };\n  __proto.setEventDatas = function(datas) {\n    var currentDatas = this.datas;\n    for (var name in datas) {\n      currentDatas[name] = datas[name];\n    }\n    return this;\n  };\n  __proto.getCurrentEvent = function(inputEvent) {\n    return __assign$4(__assign$4({\n      datas: this.datas\n    }, this._getPosition()), {\n      movement: this.getMovement(),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      inputEvent\n    });\n  };\n  __proto.getEventDatas = function() {\n    return this.datas;\n  };\n  __proto.unset = function() {\n    var _this = this;\n    var targets = this.targets;\n    var container = this.options.container;\n    this.off();\n    removeEvent(window, \"blur\", this.onBlur);\n    if (this.isMouse) {\n      targets.forEach(function(target) {\n        removeEvent(target, \"mousedown\", _this.onDragStart);\n      });\n      removeEvent(container, \"mousemove\", this.onDrag);\n      removeEvent(container, \"mouseup\", this.onDragEnd);\n      removeEvent(container, \"contextmenu\", this.onDragEnd);\n    }\n    if (this.isTouch) {\n      targets.forEach(function(target) {\n        removeEvent(target, \"touchstart\", _this.onDragStart);\n      });\n      removeEvent(container, \"touchstart\", this.onDragStart);\n      removeEvent(container, \"touchmove\", this.onDrag);\n      removeEvent(container, \"touchend\", this.onDragEnd);\n      removeEvent(container, \"touchcancel\", this.onDragEnd);\n    }\n  };\n  __proto.onPinchStart = function(e) {\n    var pinchThreshold = this.options.pinchThreshold;\n    if (this.isDrag && this.getMovement() > pinchThreshold) {\n      return;\n    }\n    var store = new ClientStore(getEventClients(e));\n    this.pinchFlag = true;\n    this._addStore(store);\n    var result = this.emit(\"pinchStart\", __assign$4(__assign$4({\n      datas: this.datas,\n      angle: store.getAngle(),\n      touches: this.getCurrentStore().getPositions()\n    }, store.getPosition()), {\n      inputEvent: e\n    }));\n    if (result === false) {\n      this.pinchFlag = false;\n    }\n  };\n  __proto.onPinch = function(e, clients) {\n    if (!this.flag || !this.pinchFlag || clients.length < 2) {\n      return;\n    }\n    var store = this.getCurrentStore();\n    this.isPinch = true;\n    this.emit(\"pinch\", __assign$4(__assign$4({\n      datas: this.datas,\n      movement: this.getMovement(clients),\n      angle: store.getAngle(clients),\n      rotation: store.getRotation(clients),\n      touches: store.getPositions(clients),\n      scale: store.getScale(clients),\n      distance: store.getDistance(clients)\n    }, store.getPosition(clients)), {\n      inputEvent: e\n    }));\n  };\n  __proto.onPinchEnd = function(e) {\n    if (!this.pinchFlag) {\n      return;\n    }\n    var isPinch = this.isPinch;\n    this.isPinch = false;\n    this.pinchFlag = false;\n    var store = this.getCurrentStore();\n    this.emit(\"pinchEnd\", __assign$4(__assign$4({\n      datas: this.datas,\n      isPinch,\n      touches: store.getPositions()\n    }, store.getPosition()), {\n      inputEvent: e\n    }));\n  };\n  __proto.initDrag = function() {\n    this.clientStores = [];\n    this.pinchFlag = false;\n    this.doubleFlag = false;\n    this.prevTime = 0;\n    this.flag = false;\n  };\n  __proto.getCurrentStore = function() {\n    return this.clientStores[0];\n  };\n  __proto.moveClients = function(clients, inputEvent, isAdd) {\n    var position = this._getPosition(clients, isAdd);\n    if (position.deltaX || position.deltaY) {\n      this.isDrag = true;\n    }\n    return __assign$4(__assign$4({\n      datas: this.datas\n    }, position), {\n      movement: this.getMovement(clients),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      inputEvent\n    });\n  };\n  __proto._addStore = function(store) {\n    this.clientStores.splice(0, 0, store);\n  };\n  __proto._getPosition = function(clients, isAdd) {\n    var store = this.getCurrentStore();\n    var position = store.getPosition(clients, isAdd);\n    var _a3 = this.clientStores.slice(1).reduce(function(prev2, cur) {\n      var storePosition = cur.getPosition();\n      prev2.distX += storePosition.distX;\n      prev2.distY += storePosition.distY;\n      return prev2;\n    }, position), distX = _a3.distX, distY = _a3.distY;\n    return __assign$4(__assign$4({}, position), {\n      distX,\n      distY\n    });\n  };\n  return Gesto2;\n}(EventEmitter$3);\nvar Gesto$1 = Gesto;\nfunction hash$2(str2) {\n  var hash2 = 5381, i2 = str2.length;\n  while (i2) {\n    hash2 = hash2 * 33 ^ str2.charCodeAt(--i2);\n  }\n  return hash2 >>> 0;\n}\nvar stringHash = hash$2;\nfunction getHash(str2) {\n  return stringHash(str2).toString(36);\n}\nfunction getShadowRoot(parentElement) {\n  if (parentElement && parentElement.getRootNode) {\n    var rootNode = parentElement.getRootNode();\n    if (rootNode.nodeType === 11) {\n      return rootNode;\n    }\n  }\n  return;\n}\nfunction replaceStyle(className, css, options) {\n  if (options.original) {\n    return css;\n  }\n  return css.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(_2, selector) {\n    var trimmedSelector = selector.trim();\n    return (trimmedSelector ? splitComma(trimmedSelector) : [\"\"]).map(function(subSelector) {\n      var trimmedSubSelector = subSelector.trim();\n      if (trimmedSubSelector.indexOf(\"@\") === 0) {\n        return trimmedSubSelector;\n      } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n        return trimmedSubSelector.replace(/\\:global/g, \"\");\n      } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n        return \"\" + trimmedSubSelector.replace(/\\:host/g, \".\" + className);\n      } else if (trimmedSubSelector) {\n        return \".\" + className + \" \" + trimmedSubSelector;\n      } else {\n        return \".\" + className;\n      }\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(className, css, options, shadowRoot) {\n  var style = document.createElement(\"style\");\n  style.setAttribute(\"type\", \"text/css\");\n  style.setAttribute(\"data-styled-id\", className);\n  if (options.nonce) {\n    style.setAttribute(\"nonce\", options.nonce);\n  }\n  style.innerHTML = replaceStyle(className, css, options);\n  (shadowRoot || document.head || document.body).appendChild(style);\n  return style;\n}\nfunction styled$1(css) {\n  var injectClassName = \"rCS\" + getHash(css);\n  var injectCount = 0;\n  var injectElement;\n  return {\n    className: injectClassName,\n    inject: function(el, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      var shadowRoot = getShadowRoot(el);\n      var firstMount = injectCount === 0;\n      var styleElement;\n      if (shadowRoot || firstMount) {\n        styleElement = injectStyle(injectClassName, css, options, shadowRoot);\n      }\n      if (firstMount) {\n        injectElement = styleElement;\n      }\n      if (!shadowRoot) {\n        ++injectCount;\n      }\n      return {\n        destroy: function() {\n          if (shadowRoot) {\n            el.removeChild(styleElement);\n            styleElement = null;\n          } else {\n            if (injectCount > 0) {\n              --injectCount;\n            }\n            if (injectCount === 0 && injectElement) {\n              injectElement.parentNode.removeChild(injectElement);\n              injectElement = null;\n            }\n          }\n        }\n      };\n    }\n  };\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$2 = function(d2, b2) {\n  extendStatics$2 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$2(d2, b2);\n};\nfunction __extends$2(d2, b2) {\n  extendStatics$2(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$3 = function() {\n  __assign$3 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$3.apply(this, arguments);\n};\nfunction __rest$1(s2, e) {\n  var t = {};\n  for (var p2 in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)\n      t[p2] = s2[p2];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))\n        t[p2[i2]] = s2[p2[i2]];\n    }\n  return t;\n}\nvar StyledElement = /* @__PURE__ */ function(_super) {\n  __extends$2(StyledElement2, _super);\n  function StyledElement2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.injectResult = null;\n    _this.tag = \"div\";\n    return _this;\n  }\n  var __proto = StyledElement2.prototype;\n  __proto.render = function() {\n    var _a3 = this.props, _b3 = _a3.className, className = _b3 === void 0 ? \"\" : _b3;\n    _a3.cspNonce;\n    var portalContainer = _a3.portalContainer, attributes = __rest$1(_a3, [\"className\", \"cspNonce\", \"portalContainer\"]);\n    var cssId = this.injector.className;\n    var Tag = this.tag;\n    var portalAttributes = {};\n    if (version.indexOf(\"simple\") > -1 && portalContainer) {\n      portalAttributes = {\n        portalContainer\n      };\n    }\n    return createElement(Tag, __assign$3({\n      \"ref\": ref(this, \"element\"),\n      \"data-styled-id\": cssId,\n      \"className\": className + \" \" + cssId\n    }, portalAttributes, attributes));\n  };\n  __proto.componentDidMount = function() {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  };\n  __proto.componentWillUnmount = function() {\n    this.injectResult.destroy();\n    this.injectResult = null;\n  };\n  __proto.getElement = function() {\n    return this.element;\n  };\n  return StyledElement2;\n}(Component);\nfunction styled(tag, css) {\n  var injector = styled$1(css);\n  return /* @__PURE__ */ function(_super) {\n    __extends$2(Styled, _super);\n    function Styled() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n      _this.injector = injector;\n      _this.tag = tag;\n      return _this;\n    }\n    return Styled;\n  }(StyledElement);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$2 = function() {\n  __assign$2 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$2.apply(this, arguments);\n};\nfunction __spreadArrays$1() {\n  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n    s2 += arguments[i2].length;\n  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)\n    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)\n      r2[k] = a2[j2];\n  return r2;\n}\nvar EventEmitter$1 = /* @__PURE__ */ function() {\n  function EventEmitter2() {\n    this._events = {};\n  }\n  var __proto = EventEmitter2.prototype;\n  __proto.on = function(eventName, listener) {\n    if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.on(name, eventName[name]);\n      }\n    } else {\n      this._addEvent(eventName, listener, {});\n    }\n    return this;\n  };\n  __proto.off = function(eventName, listener) {\n    if (!eventName) {\n      this._events = {};\n    } else if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.off(name);\n      }\n    } else if (!listener) {\n      this._events[eventName] = [];\n    } else {\n      var events = this._events[eventName];\n      if (events) {\n        var index = findIndex(events, function(e) {\n          return e.listener === listener;\n        });\n        if (index > -1) {\n          events.splice(index, 1);\n        }\n      }\n    }\n    return this;\n  };\n  __proto.once = function(eventName, listener) {\n    var _this = this;\n    if (listener) {\n      this._addEvent(eventName, listener, {\n        once: true\n      });\n    }\n    return new Promise(function(resolve2) {\n      _this._addEvent(eventName, resolve2, {\n        once: true\n      });\n    });\n  };\n  __proto.emit = function(eventName, param) {\n    var _this = this;\n    if (param === void 0) {\n      param = {};\n    }\n    var events = this._events[eventName];\n    if (!eventName || !events) {\n      return true;\n    }\n    var isStop = false;\n    param.eventType = eventName;\n    param.stop = function() {\n      isStop = true;\n    };\n    param.currentTarget = this;\n    __spreadArrays$1(events).forEach(function(info) {\n      info.listener(param);\n      if (info.once) {\n        _this.off(eventName, info.listener);\n      }\n    });\n    return !isStop;\n  };\n  __proto.trigger = function(eventName, param) {\n    if (param === void 0) {\n      param = {};\n    }\n    return this.emit(eventName, param);\n  };\n  __proto._addEvent = function(eventName, listener, options) {\n    var events = this._events;\n    events[eventName] = events[eventName] || [];\n    var listeners = events[eventName];\n    listeners.push(__assign$2({\n      listener\n    }, options));\n  };\n  return EventEmitter2;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$1 = function(d2, b2) {\n  extendStatics$1 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (Object.prototype.hasOwnProperty.call(b3, p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics$1(d2, b2);\n};\nfunction __extends$1(d2, b2) {\n  if (typeof b2 !== \"function\" && b2 !== null)\n    throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n  extendStatics$1(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign$1$1 = function() {\n  __assign$1$1 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$1$1.apply(this, arguments);\n};\nfunction __rest(s2, e) {\n  var t = {};\n  for (var p2 in s2)\n    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)\n      t[p2] = s2[p2];\n  if (s2 != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {\n      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))\n        t[p2[i2]] = s2[p2[i2]];\n    }\n  return t;\n}\nfunction __decorate$1(decorators, target, key, desc) {\n  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r2 = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n      if (d2 = decorators[i2])\n        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;\n  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {\n      if (ar || !(i2 in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i2);\n        ar[i2] = from[i2];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction makeAble(name, able) {\n  var _a3;\n  return __assign$1$1({\n    events: {},\n    props: (_a3 = {}, _a3[name] = Boolean, _a3),\n    name\n  }, able);\n}\nfunction getSVGCursor(scale, degree) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * scale, 'px\" height=\"').concat(32 * scale, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(degree, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(degree) {\n  var x1 = getSVGCursor(1, degree);\n  var degree45 = Math.round(degree / 45) * 45 % 180;\n  var defaultCursor = \"ns-resize\";\n  if (degree45 === 135) {\n    defaultCursor = \"nwse-resize\";\n  } else if (degree45 === 45) {\n    defaultCursor = \"nesw-resize\";\n  } else if (degree45 === 90) {\n    defaultCursor = \"ew-resize\";\n  }\n  return \"cursor:\".concat(defaultCursor, \";cursor: url('\").concat(x1, \"') 16 16, \").concat(defaultCursor, \";\");\n}\nvar agent = agent$1();\nvar IS_WEBKIT = agent.browser.webkit;\nvar IS_WEBKIT605 = IS_WEBKIT && function() {\n  var navi = typeof window === \"undefined\" ? {\n    userAgent: \"\"\n  } : window.navigator;\n  var res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n  return res ? parseFloat(res[1]) < 605 : false;\n}();\nvar PREFIX = \"moveable-\";\nvar MOVEABLE_CSS = \"\\n{\\n\tposition: absolute;\\n\twidth: 1px;\\n\theight: 1px;\\n\tleft: 0;\\n\ttop: 0;\\n    z-index: 3000;\\n    --moveable-color: #4af;\\n    --zoom: 1;\\n    --zoompx: 1px;\\n    will-change: transform;\\n}\\n.control-box {\\n    z-index: 0;\\n}\\n.line, .control {\\n    position: absolute;\\n\tleft: 0;\\n    top: 0;\\n    will-change: transform;\\n}\\n.control {\\n\twidth: 14px;\\n\theight: 14px;\\n\tborder-radius: 50%;\\n\tborder: 2px solid #fff;\\n\tbox-sizing: border-box;\\n    background: #4af;\\n    background: var(--moveable-color);\\n\tmargin-top: -7px;\\n    margin-left: -7px;\\n    border: 2px solid #fff;\\n    z-index: 10;\\n}\\n.padding {\\n    position: absolute;\\n    top: 0px;\\n    left: 0px;\\n    width: 100px;\\n    height: 100px;\\n    transform-origin: 0 0;\\n}\\n.line {\\n\twidth: 1px;\\n    height: 1px;\\n    background: #4af;\\n    background: var(--moveable-color);\\n\ttransform-origin: 0px 50%;\\n}\\n.line.dashed {\\n    box-sizing: border-box;\\n    background: transparent;\\n}\\n.line.dashed.horizontal {\\n    border-top: 1px dashed #4af;\\n    border-top-color: #4af;\\n    border-top-color: var(--moveable-color);\\n}\\n.line.dashed.vertical {\\n    border-left: 1px dashed #4af;\\n    border-left-color: #4af;\\n    border-left-color: var(--moveable-color);\\n}\\n.line.vertical {\\n    transform: translateX(-50%);\\n}\\n.line.horizontal {\\n    transform: translateY(-50%);\\n}\\n.line.vertical.bold {\\n    width: 2px;\\n}\\n.line.horizontal.bold {\\n    height: 2px;\\n}\\n\\n.control.origin {\\n\tborder-color: #f55;\\n\tbackground: #fff;\\n\twidth: 12px;\\n\theight: 12px;\\n\tmargin-top: -6px;\\n    margin-left: -6px;\\n\tpointer-events: none;\\n}\\n\".concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(degree) {\n  return '\\n.direction[data-rotation=\"'.concat(degree, '\"] {\\n\t').concat(getCursorCSS(degree), \"\\n}\\n\");\n}).join(\"\\n\"), \"\\n.group {\\n    z-index: -1;\\n}\\n.area {\\n    position: absolute;\\n}\\n.area-pieces {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    display: none;\\n}\\n.area.avoid, .area.pass {\\n    pointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\n    display: block;\\n}\\n.area-piece {\\n    position: absolute;\\n}\\n\\n\").concat(IS_WEBKIT605 ? ':global svg *:before {\\n\tcontent:\"\";\\n\ttransform-origin: inherit;\\n}' : \"\", \"\\n\");\nvar NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];\nvar FLOAT_POINT_NUM = 1e-4;\nvar TINY_NUM = 1e-7;\nvar MIN_SCALE = 1e-9;\nvar MAX_NUM = Math.pow(10, 10);\nvar MIN_NUM = -MAX_NUM;\nvar DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\nvar DIRECTION_INDEXES = {\n  n: [0, 1],\n  s: [2, 3],\n  w: [2, 0],\n  e: [1, 3],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n};\nvar DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n};\nvar MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\"];\nfunction setCustomDrag(e, state, delta, isPinch, isConvert) {\n  var result = state.gesto.move(delta, e.inputEvent);\n  var datas = result.originalDatas || result.datas;\n  var draggableDatas = datas.draggable || (datas.draggable = {});\n  return __assign$1$1(__assign$1$1({}, isConvert ? convertDragDist(state, result) : result), {\n    isDrag: true,\n    isPinch: !!isPinch,\n    parentEvent: true,\n    datas: draggableDatas,\n    originalDatas: e.originalDatas\n  });\n}\nvar CustomGesto = /* @__PURE__ */ function() {\n  function CustomGesto2() {\n    this.prevX = 0;\n    this.prevY = 0;\n    this.startX = 0;\n    this.startY = 0;\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {\n      draggable: {}\n    };\n  }\n  var __proto = CustomGesto2.prototype;\n  __proto.dragStart = function(client, e) {\n    this.isDrag = false;\n    this.isFlag = false;\n    var originalDatas = e.originalDatas;\n    this.datas = originalDatas;\n    if (!originalDatas.draggable) {\n      originalDatas.draggable = {};\n    }\n    return __assign$1$1(__assign$1$1({}, this.move(client, e.inputEvent)), {\n      type: \"dragstart\"\n    });\n  };\n  __proto.drag = function(client, inputEvent) {\n    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);\n  };\n  __proto.move = function(delta, inputEvent) {\n    var clientX;\n    var clientY;\n    if (!this.isFlag) {\n      this.prevX = delta[0];\n      this.prevY = delta[1];\n      this.startX = delta[0];\n      this.startY = delta[1];\n      clientX = delta[0];\n      clientY = delta[1];\n      this.isFlag = true;\n    } else {\n      clientX = this.prevX + delta[0];\n      clientY = this.prevY + delta[1];\n      this.isDrag = true;\n    }\n    this.prevX = clientX;\n    this.prevY = clientY;\n    return {\n      type: \"drag\",\n      clientX,\n      clientY,\n      inputEvent,\n      isDrag: this.isDrag,\n      distX: clientX - this.startX,\n      distY: clientY - this.startY,\n      deltaX: delta[0],\n      deltaY: delta[1],\n      datas: this.datas.draggable,\n      originalDatas: this.datas,\n      parentEvent: true,\n      parentGesto: this\n    };\n  };\n  return CustomGesto2;\n}();\nfunction fillChildEvents(moveable, name, e) {\n  var datas = e.originalDatas;\n  datas.groupable = datas.groupable || {};\n  var groupableDatas = datas.groupable;\n  groupableDatas.childDatas = groupableDatas.childDatas || [];\n  var childDatas = groupableDatas.childDatas;\n  return moveable.moveables.map(function(_2, i2) {\n    childDatas[i2] = childDatas[i2] || {};\n    childDatas[i2][name] = childDatas[i2][name] || {};\n    return __assign$1$1(__assign$1$1({}, e), {\n      datas: childDatas[i2][name],\n      originalDatas: childDatas[i2]\n    });\n  });\n}\nfunction triggerChildGesto(moveable, able, type, delta, e, isConvert) {\n  var isStart = !!type.match(/Start$/g);\n  var isEnd = !!type.match(/End$/g);\n  var isPinch = e.isPinch;\n  var datas = e.datas;\n  var events = fillChildEvents(moveable, able.name, e);\n  var moveables = moveable.moveables;\n  var childs = events.map(function(ev, i2) {\n    var childMoveable = moveables[i2];\n    var childEvent = ev;\n    if (isStart) {\n      childEvent = new CustomGesto().dragStart(delta, ev);\n    } else {\n      if (!childMoveable.state.gesto) {\n        childMoveable.state.gesto = datas.childGestos[i2];\n      }\n      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);\n    }\n    var result = able[type](childMoveable, __assign$1$1(__assign$1$1({}, childEvent), {\n      parentFlag: true\n    }));\n    if (isEnd) {\n      childMoveable.state.gesto = null;\n    }\n    return result;\n  });\n  if (isStart) {\n    datas.childGestos = moveables.map(function(child) {\n      return child.state.gesto;\n    });\n  }\n  return childs;\n}\nfunction triggerChildAbles(moveable, able, type, e, eachEvent, callback) {\n  if (eachEvent === void 0) {\n    eachEvent = function(_2, ev) {\n      return ev;\n    };\n  }\n  var isEnd = !!type.match(/End$/g);\n  var events = fillChildEvents(moveable, able.name, e);\n  var moveables = moveable.moveables;\n  var childs = events.map(function(ev, i2) {\n    var childMoveable = moveables[i2];\n    var childEvent = ev;\n    childEvent = eachEvent(childMoveable, ev);\n    var result = able[type](childMoveable, __assign$1$1(__assign$1$1({}, childEvent), {\n      parentFlag: true\n    }));\n    result && callback && callback(childMoveable, ev, result, i2);\n    if (isEnd) {\n      childMoveable.state.gesto = null;\n    }\n    return result;\n  });\n  return childs;\n}\nfunction renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {\n  if (additionalClassName === void 0) {\n    additionalClassName = \"\";\n  }\n  var _a3 = moveable.state, renderPoses = _a3.renderPoses, rotationRad = _a3.rotation, direction = _a3.direction;\n  var _b3 = moveable.props, _c3 = _b3.renderDirections, directions = _c3 === void 0 ? defaultDirections : _c3, zoom = _b3.zoom;\n  var directionMap = {};\n  if (!directions) {\n    return [];\n  }\n  var sign2 = direction > 0 ? 1 : -1;\n  var renderDirections = directions === true ? DIRECTIONS : directions;\n  var degRotation = rotationRad / Math.PI * 180;\n  renderDirections.forEach(function(dir) {\n    directionMap[dir] = true;\n  });\n  return renderDirections.map(function(dir) {\n    var indexes = DIRECTION_INDEXES[dir];\n    if (!indexes || !directionMap[dir]) {\n      return null;\n    }\n    var directionRotation = (throttle(degRotation, 15) + sign2 * DIRECTION_ROTATIONS[dir] + 720) % 180;\n    return React.createElement(\"div\", {\n      className: prefix(\"control\", \"direction\", dir, additionalClassName),\n      \"data-rotation\": directionRotation,\n      \"data-direction\": dir,\n      key: \"direction-\".concat(dir),\n      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function(index) {\n        return renderPoses[index];\n      }), false))\n    });\n  });\n}\nfunction renderLine(React, direction, pos1, pos2, zoom, key) {\n  var classNames = [];\n  for (var _i = 6; _i < arguments.length; _i++) {\n    classNames[_i - 6] = arguments[_i];\n  }\n  var rad = getRad$1(pos1, pos2);\n  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;\n  return React.createElement(\"div\", {\n    key: \"line\".concat(key),\n    className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", direction], classNames, false)),\n    \"data-rotation\": rotation,\n    \"data-line-index\": key,\n    \"data-direction\": direction,\n    style: getLineStyle(pos1, pos2, zoom, rad)\n  });\n}\nfunction renderAllDirections(moveable, React) {\n  return renderDirectionControls(moveable, DIRECTIONS, React);\n}\nfunction renderDiagonalDirections(moveable, React) {\n  return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\nfunction setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {\n  var n = moveable.state.is3d ? 4 : 3;\n  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);\n  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg = getRad$1(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n  datas.defaultDeg = datas.prevDeg;\n  datas.prevSnapDeg = 0;\n  datas.loop = 0;\n}\nfunction getAbsoluteDist(deg, direction, datas) {\n  var defaultDeg = datas.defaultDeg, prevDeg = datas.prevDeg;\n  var normalizedPrevDeg = prevDeg % 360;\n  var loop = Math.floor(prevDeg / 360);\n  if (normalizedPrevDeg < 0) {\n    normalizedPrevDeg += 360;\n  }\n  if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n    ++loop;\n  } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n    --loop;\n  }\n  var dist = direction * (loop * 360 + deg - defaultDeg);\n  datas.prevDeg = defaultDeg + dist;\n  return dist;\n}\nfunction getAbsoluteDistByClient(clientX, clientY, direction, datas) {\n  return getAbsoluteDist(getRad$1(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, datas);\n}\nfunction getRotateInfo(moveable, moveableRect, datas, dist, startValue, isSnap) {\n  var _a3 = moveable.props.throttleRotate, throttleRotate = _a3 === void 0 ? 0 : _a3;\n  var nextDist = dist;\n  var prevSnapDeg = datas.prevSnapDeg;\n  if (isSnap) {\n    nextDist = checkSnapRotate(moveable, moveableRect, datas.origin, nextDist);\n  }\n  var snapRotation = throttle(startValue + nextDist, throttleRotate);\n  var snapDeg = snapRotation - startValue;\n  datas.prevSnapDeg = snapDeg;\n  return [snapDeg - prevSnapDeg, nextDist, snapRotation];\n}\nfunction getRotationPositions(rotationPosition, _a3, direction) {\n  var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];\n  if (rotationPosition === \"none\") {\n    return;\n  }\n  var _b3 = (rotationPosition || \"top\").split(\"-\"), dir1 = _b3[0], dir2 = _b3[1];\n  var radPoses = [pos1, pos2];\n  if (dir1 === \"left\") {\n    radPoses = [pos3, pos1];\n  } else if (dir1 === \"right\") {\n    radPoses = [pos2, pos4];\n  } else if (dir1 === \"bottom\") {\n    radPoses = [pos4, pos3];\n  }\n  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];\n  var rad = getRotationRad(radPoses, direction);\n  if (dir2) {\n    var isStart = dir2 === \"top\" || dir2 === \"left\";\n    var isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];\n  }\n  return [pos, rad];\n}\nfunction dragControlCondition(moveable, e) {\n  if (e.isRequest) {\n    return e.requestAble === \"rotatable\";\n  }\n  var target = e.inputEvent.target;\n  if (hasClass(target, prefix(\"rotation-control\"))) {\n    return true;\n  }\n  var rotationTarget = moveable.props.rotationTarget;\n  if (rotationTarget) {\n    return getRefTargets(rotationTarget, true).some(function(element) {\n      if (!element) {\n        return false;\n      }\n      return target === element || target.contains(element);\n    });\n  }\n  return false;\n}\nvar Rotatable = {\n  name: \"rotatable\",\n  canPinch: true,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onBeforeRotate: \"beforeRotate\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onBeforeRotateGroup: \"beforeRotateGroup\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [\".rotation {\\n            position: absolute;\\n            height: 40px;\\n            width: 1px;\\n            transform-origin: 50% 100%;\\n            height: calc(40px * var(--zoom));\\n            top: auto;\\n            left: 0;\\n            bottom: 100%;\\n            will-change: transform;\\n        }\\n        .rotation .rotation-line {\\n            display: block;\\n            width: 100%;\\n            height: 100%;\\n            transform-origin: 50% 50%;\\n        }\\n        .rotation .rotation-control {\\n            border-color: #4af;\\n            border-color: var(--moveable-color);\\n            background:#fff;\\n            cursor: alias;\\n        }\"],\n  render: function(moveable, React) {\n    var _a3 = moveable.props, rotatable = _a3.rotatable, rotationPosition = _a3.rotationPosition, zoom = _a3.zoom, renderDirections = _a3.renderDirections;\n    var _b3 = moveable.state, renderPoses = _b3.renderPoses, direction = _b3.direction;\n    if (!rotatable) {\n      return null;\n    }\n    var positions = getRotationPositions(rotationPosition, renderPoses, direction);\n    var jsxs = [];\n    if (positions) {\n      var pos = positions[0], rad = positions[1];\n      jsxs.push(React.createElement(\"div\", {\n        key: \"rotation\",\n        className: prefix(\"rotation\"),\n        style: {\n          transform: \"translate(-50%) translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rad, \"rad)\")\n        }\n      }, React.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(zoom, \")\")\n        }\n      }), React.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(zoom, \")\")\n        }\n      })));\n    }\n    if (renderDirections) {\n      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));\n    }\n    return jsxs;\n  },\n  dragControlCondition,\n  dragControlStart: function(moveable, e) {\n    var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest;\n    var _a3 = moveable.state, target = _a3.target, left2 = _a3.left, top2 = _a3.top, origin = _a3.origin, beforeOrigin = _a3.beforeOrigin, direction = _a3.direction, beforeDirection = _a3.beforeDirection, targetTransform = _a3.targetTransform, moveableClientRect = _a3.moveableClientRect;\n    if (!isRequest && !target) {\n      return false;\n    }\n    var rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left2;\n    datas.top = top2;\n    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));\n    if (isRequest || isPinch || parentFlag) {\n      var externalRotate = parentRotate || 0;\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        defaultDeg: externalRotate,\n        prevSnapDeg: 0\n      };\n      datas.afterInfo = __assign$1$1(__assign$1$1({}, datas.beforeInfo), {\n        origin: rect.origin\n      });\n      datas.absoluteInfo = __assign$1$1(__assign$1$1({}, datas.beforeInfo), {\n        origin: rect.origin,\n        startValue: externalRotate\n      });\n    } else {\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin\n      };\n      datas.afterInfo = {\n        origin: rect.origin\n      };\n      datas.absoluteInfo = {\n        origin: rect.origin,\n        startValue: rect.rotation\n      };\n      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);\n      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);\n      setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);\n    }\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startValue = 0;\n    datas.datas = {};\n    setDefaultTransformIndex(e, \"rotate\");\n    var params = fillParams(moveable, e, __assign$1$1(__assign$1$1({\n      set: function(rotatation) {\n        datas.startValue = rotatation * Math.PI / 180;\n      }\n    }, fillTransformStartEvent(e)), {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    }));\n    var result = triggerEvent(moveable, \"onRotateStart\", params);\n    datas.isRotate = result !== false;\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest\n    };\n    return datas.isRotate ? params : false;\n  },\n  dragControl: function(moveable, e) {\n    var _a3, _b3, _c3;\n    var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, groupDelta = e.groupDelta;\n    var beforeDirection = datas.beforeDirection, beforeInfo = datas.beforeInfo, afterInfo = datas.afterInfo, absoluteInfo = datas.absoluteInfo, isRotate = datas.isRotate, startValue = datas.startValue, rect = datas.rect;\n    if (!isRotate) {\n      return;\n    }\n    resolveTransformEvent(e, \"rotate\");\n    var targetDirection = getTransformDirection(e);\n    var direction = beforeDirection * targetDirection;\n    var parentMoveable = moveable.props.parentMoveable;\n    var beforeDelta = 0;\n    var beforeDist;\n    var beforeRotation;\n    var delta = 0;\n    var dist;\n    var rotation;\n    var absoluteDelta = 0;\n    var absoluteDist;\n    var absoluteRotation;\n    var startRotation = 180 / Math.PI * startValue;\n    var absoluteStartRotation = absoluteInfo.startValue;\n    var isSnap = false;\n    if (!parentFlag && \"parentDist\" in e) {\n      var parentDist = e.parentDist;\n      beforeDist = parentDist;\n      dist = parentDist;\n      absoluteDist = parentDist;\n    } else if (isPinch || parentFlag) {\n      beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n      dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n      absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n    } else {\n      beforeDist = getAbsoluteDistByClient(clientX, clientY, beforeDirection, beforeInfo);\n      dist = getAbsoluteDistByClient(clientX, clientY, direction, afterInfo);\n      absoluteDist = getAbsoluteDistByClient(clientX, clientY, direction, absoluteInfo);\n      isSnap = true;\n    }\n    beforeRotation = startRotation + beforeDist;\n    rotation = startRotation + dist;\n    absoluteRotation = absoluteStartRotation + absoluteDist;\n    triggerEvent(moveable, \"onBeforeRotate\", fillParams(moveable, e, {\n      beforeRotation,\n      rotation,\n      absoluteRotation,\n      setRotation: function(nextRotation) {\n        dist = nextRotation - startRotation;\n        beforeDist = dist;\n        absoluteDist = dist;\n      }\n    }, true));\n    _a3 = getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap), beforeDelta = _a3[0], beforeDist = _a3[1], beforeRotation = _a3[2];\n    _b3 = getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap), delta = _b3[0], dist = _b3[1], rotation = _b3[2];\n    _c3 = getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap), absoluteDelta = _c3[0], absoluteDist = _c3[1], absoluteRotation = _c3[2];\n    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n      return;\n    }\n    var nextTransform = convertTransformFormat(datas, \"rotate(\".concat(rotation, \"deg)\"), \"rotate(\".concat(dist, \"deg)\"));\n    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);\n    var inverseDelta = minus(plus(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);\n    datas.prevInverseDist = inverseDist;\n    datas.requestValue = null;\n    var params = fillParams(moveable, e, __assign$1$1({\n      delta,\n      dist,\n      rotate: rotation,\n      rotation,\n      beforeDist,\n      beforeDelta,\n      beforeRotate: beforeRotation,\n      beforeRotation,\n      absoluteDist,\n      absoluteDelta,\n      absoluteRotate: absoluteRotation,\n      absoluteRotation,\n      isPinch: !!isPinch\n    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\n    triggerEvent(moveable, \"onRotate\", params);\n    return params;\n  },\n  dragControlAfter: function(moveable, e) {\n    e.datas.requestValue;\n  },\n  dragControlEnd: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isRotate) {\n      return;\n    }\n    datas.isRotate = false;\n    var params = fillEndParams(moveable, e, {});\n    triggerEvent(moveable, \"onRotateEnd\", params);\n    return params;\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function(moveable, e) {\n    var datas = e.datas;\n    var _a3 = moveable.state, parentLeft = _a3.left, parentTop = _a3.top, parentBeforeOrigin = _a3.beforeOrigin;\n    var params = this.dragControlStart(moveable, e);\n    if (!params) {\n      return false;\n    }\n    params.set(datas.beforeDirection * moveable.rotation);\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n      var _a4 = child.state, left2 = _a4.left, top2 = _a4.top, beforeOrigin = _a4.beforeOrigin;\n      var childClient = plus(minus([left2, top2], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));\n      ev.datas.groupClient = childClient;\n      return __assign$1$1(__assign$1$1({}, ev), {\n        parentRotate: 0\n      });\n    });\n    var nextParams = __assign$1$1(__assign$1$1({}, params), {\n      targets: moveable.props.targets,\n      events\n    });\n    var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n    datas.isRotate = result !== false;\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isRotate) {\n      return;\n    }\n    catchEvent(moveable, \"onBeforeRotate\", function(parentEvent) {\n      triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams(moveable, e, __assign$1$1(__assign$1$1({}, parentEvent), {\n        targets: moveable.props.targets\n      }), true));\n    });\n    var params = this.dragControl(moveable, e);\n    if (!params) {\n      return;\n    }\n    var direction = datas.beforeDirection;\n    var parentRotate = params.beforeDist;\n    var deg = params.beforeDelta;\n    var rad = deg / 180 * Math.PI;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_2, ev) {\n      var _a3 = ev.datas.groupClient, prevX = _a3[0], prevY = _a3[1];\n      var _b3 = rotate([prevX, prevY], rad * direction), clientX = _b3[0], clientY = _b3[1];\n      var delta = [clientX - prevX, clientY - prevY];\n      ev.datas.groupClient = [clientX, clientY];\n      return __assign$1$1(__assign$1$1({}, ev), {\n        parentRotate,\n        groupDelta: delta\n      });\n    });\n    moveable.rotation = direction * params.beforeRotation;\n    var nextParams = __assign$1$1({\n      targets: moveable.props.targets,\n      events,\n      set: function(rotation) {\n        moveable.rotation = rotation;\n      },\n      setGroupRotation: function(rotation) {\n        moveable.rotation = rotation;\n      }\n    }, params);\n    triggerEvent(moveable, \"onRotateGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    var isDrag = e.isDrag, datas = e.datas;\n    if (!datas.isRotate) {\n      return;\n    }\n    this.dragControlEnd(moveable, e);\n    var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets,\n      events\n    });\n    triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n    return isDrag;\n  },\n  request: function(moveable) {\n    var datas = {};\n    var distRotate = 0;\n    var startRotation = moveable.getRotation();\n    return {\n      isControl: true,\n      requestStart: function() {\n        return {\n          datas\n        };\n      },\n      request: function(e) {\n        if (\"deltaRotate\" in e) {\n          distRotate += e.deltaRotate;\n        } else if (\"rotate\" in e) {\n          distRotate = e.rotate - startRotation;\n        }\n        return {\n          datas,\n          parentDist: distRotate\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"];\nvar HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"];\nvar VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n};\nvar HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction hasGuidelines(moveable, ableName) {\n  var _a3 = moveable.props, snappable = _a3.snappable, bounds = _a3.bounds, innerBounds = _a3.innerBounds, verticalGuidelines = _a3.verticalGuidelines, horizontalGuidelines = _a3.horizontalGuidelines, snapGridWidth = _a3.snapGridWidth, snapGridHeight = _a3.snapGridHeight, _b3 = moveable.state, guidelines = _b3.guidelines, enableSnap = _b3.enableSnap;\n  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {\n    return false;\n  }\n  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {\n    return true;\n  }\n  return false;\n}\nfunction getSnapDirections(snapDirections) {\n  if (snapDirections === false) {\n    return {};\n  } else if (snapDirections === true || !snapDirections) {\n    return {\n      left: true,\n      right: true,\n      top: true,\n      bottom: true\n    };\n  }\n  return snapDirections;\n}\nfunction mapSnapDirectionPoses(snapDirections, snapPoses) {\n  var nextSnapDirections = getSnapDirections(snapDirections);\n  var nextSnapPoses = {};\n  for (var name in nextSnapDirections) {\n    if (name in snapPoses && nextSnapDirections[name]) {\n      nextSnapPoses[name] = snapPoses[name];\n    }\n  }\n  return nextSnapPoses;\n}\nfunction splitSnapDirectionPoses(snapDirections, snapPoses) {\n  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n  var horizontalNames = HORIZONTAL_NAMES.filter(function(name) {\n    return name in nextSnapPoses;\n  });\n  var verticalNames = VERTICAL_NAMES.filter(function(name) {\n    return name in nextSnapPoses;\n  });\n  return {\n    horizontal: horizontalNames.map(function(name) {\n      return nextSnapPoses[name];\n    }),\n    vertical: verticalNames.map(function(name) {\n      return nextSnapPoses[name];\n    })\n  };\n}\nfunction getGapGuidelines(moveable, targetRect, snapThreshold) {\n  var elementRects = moveable.state.elementRects;\n  var gapGuidelines = [];\n  [[\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(_a3) {\n    var type = _a3[0], mainNames = _a3[1], sideNames = _a3[2];\n    var targetStart = targetRect[mainNames.start];\n    var targetEnd = targetRect[mainNames.end];\n    var targetCenter = targetRect[mainNames.center];\n    var targetStart2 = targetRect[sideNames.start];\n    var targetEnd2 = targetRect[sideNames.end];\n    function getDist2(elementRect) {\n      var rect = elementRect.rect;\n      if (rect[mainNames.end] < targetStart + snapThreshold) {\n        return targetStart - rect[mainNames.end];\n      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {\n        return rect[mainNames.start] - targetEnd;\n      } else {\n        return -1;\n      }\n    }\n    var nextElementRects = elementRects.filter(function(elementRect) {\n      var rect = elementRect.rect;\n      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {\n        return false;\n      }\n      return getDist2(elementRect) > 0;\n    }).sort(function(a2, b2) {\n      return getDist2(a2) - getDist2(b2);\n    });\n    var groups = [];\n    nextElementRects.forEach(function(snapRect1) {\n      nextElementRects.forEach(function(snapRect2) {\n        if (snapRect1 === snapRect2) {\n          return;\n        }\n        var rect1 = snapRect1.rect;\n        var rect2 = snapRect2.rect;\n        var rect1Start = rect1[sideNames.start];\n        var rect1End = rect1[sideNames.end];\n        var rect2Start = rect2[sideNames.start];\n        var rect2End = rect2[sideNames.end];\n        if (rect1Start > rect2End || rect2Start > rect1End) {\n          return;\n        }\n        groups.push([snapRect1, snapRect2]);\n      });\n    });\n    groups.forEach(function(_a4) {\n      var snapRect1 = _a4[0], snapRect2 = _a4[1];\n      var rect1 = snapRect1.rect;\n      var rect2 = snapRect2.rect;\n      var rect1Start = rect1[mainNames.start];\n      var rect1End = rect1[mainNames.end];\n      var rect2Start = rect2[mainNames.start];\n      var rect2End = rect2[mainNames.end];\n      var gap2 = 0;\n      var pos = 0;\n      var isStart = false;\n      var isCenter = false;\n      var isEnd = false;\n      if (rect1End <= targetStart && targetEnd <= rect2Start) {\n        isCenter = true;\n        gap2 = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;\n        pos = rect1End + gap2 + (targetEnd - targetStart) / 2;\n        if (Math.abs(pos - targetCenter) > snapThreshold) {\n          return;\n        }\n      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n        isStart = true;\n        gap2 = rect2Start - rect1End;\n        pos = rect2End + gap2;\n        if (Math.abs(pos - targetStart) > snapThreshold) {\n          return;\n        }\n      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n        isEnd = true;\n        gap2 = rect2Start - rect1End;\n        pos = rect1Start - gap2;\n        if (Math.abs(pos - targetEnd) > snapThreshold) {\n          return;\n        }\n      } else {\n        return;\n      }\n      if (!gap2) {\n        return;\n      }\n      gapGuidelines.push({\n        type,\n        pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n        element: snapRect2.element,\n        size: 0,\n        className: snapRect2.className,\n        isStart,\n        isCenter,\n        isEnd,\n        gap: gap2,\n        hide: true,\n        gapRects: [snapRect1, snapRect2]\n      });\n    });\n  });\n  return gapGuidelines;\n}\nfunction getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {\n  if (clientLeft === void 0) {\n    clientLeft = 0;\n  }\n  if (clientTop === void 0) {\n    clientTop = 0;\n  }\n  if (snapOffset === void 0) {\n    snapOffset = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n  var guidelines = [];\n  var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top, snapOffsetBottom = snapOffset.bottom, snapOffsetRight = snapOffset.right;\n  var snapWidth = width + snapOffsetRight - snapOffsetLeft;\n  var snapHeight = height + snapOffsetBottom - snapOffsetTop;\n  horizontalGuidelines && horizontalGuidelines.forEach(function(pos) {\n    guidelines.push({\n      type: \"horizontal\",\n      pos: [snapOffsetLeft, throttle(pos - clientTop + snapOffsetTop, 0.1)],\n      size: snapWidth\n    });\n  });\n  verticalGuidelines && verticalGuidelines.forEach(function(pos) {\n    guidelines.push({\n      type: \"vertical\",\n      pos: [throttle(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],\n      size: snapHeight\n    });\n  });\n  return guidelines;\n}\nfunction calculateContainerPos(rootMatrix, containerRect, n) {\n  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);\n  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];\n}\nfunction getSnapElementRects(moveable, values) {\n  if (!values.length) {\n    return [];\n  }\n  var state = moveable.state;\n  var containerClientRect = state.containerClientRect, _a3 = state.targetClientRect, clientTop = _a3.top, clientLeft = _a3.left, rootMatrix = state.rootMatrix, is3d = state.is3d;\n  var n = is3d ? 4 : 3;\n  var _b3 = calculateContainerPos(rootMatrix, containerClientRect, n), containerLeft = _b3[0], containerTop = _b3[1];\n  var poses = getAbsolutePosesByState(state);\n  var _c3 = getMinMaxs(poses), targetLeft = _c3.minX, targetTop = _c3.minY;\n  var _d2 = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function(pos) {\n    return roundSign(pos);\n  }), distLeft = _d2[0], distTop = _d2[1];\n  return values.map(function(value2) {\n    var rect = value2.element.getBoundingClientRect();\n    var left2 = rect.left - containerLeft;\n    var top2 = rect.top - containerTop;\n    var bottom2 = top2 + rect.height;\n    var right2 = left2 + rect.width;\n    var _a4 = calculateInversePosition(rootMatrix, [left2, top2], n), elementLeft = _a4[0], elementTop = _a4[1];\n    var _b4 = calculateInversePosition(rootMatrix, [right2, bottom2], n), elementRight = _b4[0], elementBottom = _b4[1];\n    return __assign$1$1(__assign$1$1({}, value2), {\n      rect: {\n        left: elementLeft + distLeft,\n        right: elementRight + distLeft,\n        top: elementTop + distTop,\n        bottom: elementBottom + distTop,\n        center: (elementLeft + elementRight) / 2 + distLeft,\n        middle: (elementTop + elementBottom) / 2 + distTop\n      }\n    });\n  });\n}\nfunction getElementGuidelines(moveable) {\n  var state = moveable.state;\n  var _a3 = moveable.props.elementGuidelines, elementGuidelines = _a3 === void 0 ? [] : _a3;\n  if (!elementGuidelines.length) {\n    state.elementRects = [];\n    return [];\n  }\n  var prevValues = (state.elementRects || []).filter(function(snapRect) {\n    return !snapRect.refresh;\n  });\n  var nextElementGuidelines = elementGuidelines.map(function(el) {\n    if (isObject$2(el) && \"element\" in el) {\n      return el;\n    }\n    return {\n      element: getRefTarget(el, true)\n    };\n  }).filter(function(value2) {\n    return value2.element;\n  });\n  var _b3 = diff(prevValues.map(function(v2) {\n    return v2.element;\n  }), nextElementGuidelines.map(function(v2) {\n    return v2.element;\n  })), maintained = _b3.maintained, added = _b3.added;\n  var nextValues = [];\n  maintained.forEach(function(_a4) {\n    var prevIndex = _a4[0], nextIndex = _a4[1];\n    nextValues[nextIndex] = prevValues[prevIndex];\n  });\n  getSnapElementRects(moveable, added.map(function(index) {\n    return nextElementGuidelines[index];\n  })).map(function(rect, i2) {\n    nextValues[added[i2]] = rect;\n  });\n  state.elementRects = nextValues;\n  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n  var nextGuidelines = [];\n  nextValues.forEach(function(snapRect) {\n    var element = snapRect.element, _a4 = snapRect.top, topValue = _a4 === void 0 ? elementSnapDirections.top : _a4, _b4 = snapRect.left, leftValue = _b4 === void 0 ? elementSnapDirections.left : _b4, _c3 = snapRect.right, rightValue = _c3 === void 0 ? elementSnapDirections.right : _c3, _d2 = snapRect.bottom, bottomValue = _d2 === void 0 ? elementSnapDirections.bottom : _d2, _e = snapRect.center, centerValue = _e === void 0 ? elementSnapDirections.center : _e, _f = snapRect.middle, middleValue = _f === void 0 ? elementSnapDirections.middle : _f, className = snapRect.className, rect = snapRect.rect;\n    var _g = splitSnapDirectionPoses({\n      top: topValue,\n      right: rightValue,\n      left: leftValue,\n      bottom: bottomValue,\n      center: centerValue,\n      middle: middleValue\n    }, rect), horizontal = _g.horizontal, vertical = _g.vertical;\n    var rectTop = rect.top;\n    var rectLeft = rect.left;\n    var width = rect.right - rectLeft;\n    var height = rect.bottom - rectTop;\n    var sizes = [width, height];\n    vertical.forEach(function(pos) {\n      nextGuidelines.push({\n        type: \"vertical\",\n        element,\n        pos: [throttle(pos, 0.1), rectTop],\n        size: height,\n        sizes,\n        className,\n        elementRect: snapRect\n      });\n    });\n    horizontal.forEach(function(pos) {\n      nextGuidelines.push({\n        type: \"horizontal\",\n        element,\n        pos: [rectLeft, throttle(pos, 0.1)],\n        size: width,\n        sizes,\n        className,\n        elementRect: snapRect\n      });\n    });\n  });\n  return nextGuidelines;\n}\nfunction getTotalGuidelines(moveable) {\n  var _a3 = moveable.state, snapOffset = _a3.snapOffset, _b3 = _a3.containerClientRect, overflow = _b3.overflow, containerHeight = _b3.scrollHeight, containerWidth = _b3.scrollWidth, containerClientHeight = _b3.clientHeight, containerClientWidth = _b3.clientWidth, clientLeft = _b3.clientLeft, clientTop = _b3.clientTop;\n  var _c3 = moveable.props, _d2 = _c3.snapGap, snapGap = _d2 === void 0 ? true : _d2, verticalGuidelines = _c3.verticalGuidelines, horizontalGuidelines = _c3.horizontalGuidelines, _e = _c3.snapThreshold, snapThreshold = _e === void 0 ? 5 : _e, _f = _c3.snapGridWidth, snapGridWidth = _f === void 0 ? 0 : _f, _g = _c3.snapGridHeight, snapGridHeight = _g === void 0 ? 0 : _g;\n  var elementGuidelines = getElementGuidelines(moveable);\n  var totalGuidelines = __spreadArray([], elementGuidelines, true);\n  if (snapGap) {\n    var _h = getRect(getAbsolutePosesByState(moveable.state)), top2 = _h.top, left2 = _h.left, bottom2 = _h.bottom, right2 = _h.right;\n    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {\n      top: top2,\n      left: left2,\n      bottom: bottom2,\n      right: right2,\n      center: (left2 + right2) / 2,\n      middle: (top2 + bottom2) / 2\n    }, snapThreshold));\n  }\n  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));\n  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));\n  return totalGuidelines;\n}\nfunction getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {\n  if (clientLeft === void 0) {\n    clientLeft = 0;\n  }\n  if (clientTop === void 0) {\n    clientTop = 0;\n  }\n  var guidelines = [];\n  if (snapGridHeight) {\n    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n      guidelines.push({\n        type: \"horizontal\",\n        pos: [0, throttle(pos - clientTop, 0.1)],\n        size: containerWidth,\n        hide: true\n      });\n    }\n  }\n  if (snapGridWidth) {\n    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n      guidelines.push({\n        type: \"vertical\",\n        pos: [throttle(pos - clientLeft, 0.1), 0],\n        size: containerHeight,\n        hide: true\n      });\n    }\n  }\n  return guidelines;\n}\nfunction checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {\n  var props = moveable.props;\n  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);\n  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);\n}\nfunction checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {\n  return {\n    vertical: checkSnap(guidelines, \"vertical\", posesX, snapThreshold),\n    horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapThreshold)\n  };\n}\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\n  var endX = endPos[0], endY = endPos[1];\n  var startX = startPos[0], startY = startPos[1];\n  var _a3 = minus(endPos, startPos), dx = _a3[0], dy = _a3[1];\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  dx = getTinyDist(dx);\n  dy = getTinyDist(dy);\n  var verticalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  }\n  var _b3 = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []), verticalSnapInfo = _b3.vertical, horizontalSnapInfo = _b3.horizontal;\n  verticalSnapInfo.posInfos.filter(function(_a4) {\n    var pos = _a4.pos;\n    return isRight ? pos >= startX : pos <= startX;\n  });\n  horizontalSnapInfo.posInfos.filter(function(_a4) {\n    var pos = _a4.pos;\n    return isBottom ? pos >= startY : pos <= startY;\n  });\n  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n  var _c3 = getNearestSnapGuidelineInfo(verticalSnapInfo), isVerticalSnap = _c3.isSnap, verticalGuideline = _c3.guideline;\n  var _d2 = getNearestSnapGuidelineInfo(horizontalSnapInfo), isHorizontalSnap = _d2.isSnap, horizontalGuideline = _d2.guideline;\n  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\n  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\n  if (dx === 0) {\n    if (isHorizontalSnap) {\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = horizontalGuideline.pos[1];\n      horizontalInfo.offset = endY - horizontalInfo.pos;\n    }\n  } else if (dy === 0) {\n    if (isVerticalSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = verticalPos;\n      verticalInfo.offset = endX - verticalPos;\n    }\n  } else {\n    var a2 = dy / dx;\n    var b2 = endPos[1] - a2 * endX;\n    var y2 = 0;\n    var x2 = 0;\n    var isSnap = false;\n    if (isVerticalSnap) {\n      x2 = verticalPos;\n      y2 = a2 * x2 + b2;\n      isSnap = true;\n    } else if (isHorizontalSnap) {\n      y2 = horizontalPos;\n      x2 = (y2 - b2) / a2;\n      isSnap = true;\n    }\n    if (isSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = x2;\n      verticalInfo.offset = endX - x2;\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = y2;\n      horizontalInfo.offset = endY - y2;\n    }\n  }\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\nfunction checkSnaps(moveable, rect, customSnapThreshold) {\n  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);\n}\nfunction getNearestSnapGuidelineInfo(snapInfo) {\n  var isSnap = snapInfo.isSnap;\n  if (!isSnap) {\n    return {\n      isSnap: false,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  }\n  var posInfo = snapInfo.posInfos[0];\n  var guidelineInfo = posInfo.guidelineInfos[0];\n  var offset2 = guidelineInfo.offset;\n  var dist = guidelineInfo.dist;\n  var guideline = guidelineInfo.guideline;\n  return {\n    isSnap,\n    offset: offset2,\n    dist,\n    pos: posInfo.pos,\n    guideline\n  };\n}\nfunction checkSnap(guidelines, targetType, targetPoses, snapThreshold) {\n  if (!guidelines || !guidelines.length) {\n    return {\n      isSnap: false,\n      index: -1,\n      posInfos: []\n    };\n  }\n  var isVertical = targetType === \"vertical\";\n  var posType = isVertical ? 0 : 1;\n  var snapPosInfos = targetPoses.map(function(targetPos, index) {\n    var guidelineInfos = guidelines.map(function(guideline) {\n      var pos = guideline.pos;\n      var offset2 = targetPos - pos[posType];\n      return {\n        offset: offset2,\n        dist: Math.abs(offset2),\n        guideline\n      };\n    }).filter(function(_a3) {\n      var guideline = _a3.guideline, dist = _a3.dist;\n      var type = guideline.type;\n      if (type !== targetType || dist > snapThreshold) {\n        return false;\n      }\n      return true;\n    }).sort(function(a2, b2) {\n      return a2.dist - b2.dist;\n    });\n    return {\n      pos: targetPos,\n      index,\n      guidelineInfos\n    };\n  }).filter(function(snapPosInfo) {\n    return snapPosInfo.guidelineInfos.length > 0;\n  }).sort(function(a2, b2) {\n    return a2.guidelineInfos[0].dist - b2.guidelineInfos[0].dist;\n  });\n  var isSnap = snapPosInfos.length > 0;\n  return {\n    isSnap,\n    index: isSnap ? snapPosInfos[0].index : -1,\n    posInfos: snapPosInfos\n  };\n}\nfunction getSnapInfosByDirection(moveable, poses, snapDirection) {\n  var nextPoses = [];\n  if (snapDirection[0] && snapDirection[1]) {\n    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function(direction) {\n      return getPosByDirection(poses, direction);\n    });\n  } else if (!snapDirection[0] && !snapDirection[1]) {\n    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n    for (var i2 = 0; i2 < 4; ++i2) {\n      nextPoses.push(alignPoses[i2]);\n      nextPoses.push([(alignPoses[i2][0] + alignPoses[i2 + 1][0]) / 2, (alignPoses[i2][1] + alignPoses[i2 + 1][1]) / 2]);\n    }\n  } else {\n    if (moveable.props.keepRatio) {\n      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function(dir) {\n        return getPosByDirection(poses, dir);\n      });\n    } else {\n      nextPoses = getPosesByDirection(poses, snapDirection);\n      if (nextPoses.length > 1) {\n        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);\n      }\n    }\n  }\n  return checkMoveableSnapPoses(moveable, nextPoses.map(function(pos) {\n    return pos[0];\n  }), nextPoses.map(function(pos) {\n    return pos[1];\n  }), 1);\n}\nfunction checkSnapBoundPriority(a2, b2) {\n  var aDist = Math.abs(a2.offset);\n  var bDist = Math.abs(b2.offset);\n  if (a2.isBound && b2.isBound) {\n    return bDist - aDist;\n  } else if (a2.isBound) {\n    return -1;\n  } else if (b2.isBound) {\n    return 1;\n  } else if (a2.isSnap && b2.isSnap) {\n    return bDist - aDist;\n  } else if (a2.isSnap) {\n    return -1;\n  } else if (b2.isSnap) {\n    return 1;\n  } else if (aDist < TINY_NUM) {\n    return 1;\n  } else if (bDist < TINY_NUM) {\n    return -1;\n  }\n  return aDist - bDist;\n}\nfunction getNearOffsetInfo(offsets, index) {\n  return offsets.slice().sort(function(a2, b2) {\n    var aSign = a2.sign[index];\n    var bSign = b2.sign[index];\n    var aOffset = a2.offset[index];\n    var bOffset = b2.offset[index];\n    if (!aSign) {\n      return 1;\n    } else if (!bSign) {\n      return -1;\n    }\n    return checkSnapBoundPriority({\n      isBound: a2.isBound,\n      isSnap: a2.isSnap,\n      offset: aOffset\n    }, {\n      isBound: b2.isBound,\n      isSnap: b2.isSnap,\n      offset: bOffset\n    });\n  })[0];\n}\nfunction getCheckSnapDirections(direction, fixedDirection, keepRatio) {\n  var directions = [];\n  if (keepRatio) {\n    if (Math.abs(fixedDirection[0]) !== 1 || Math.abs(fixedDirection[1]) !== 1) {\n      directions.push([fixedDirection, [-1, -1]], [fixedDirection, [-1, 1]], [fixedDirection, [1, -1]], [fixedDirection, [1, 1]]);\n    } else {\n      directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]], [fixedDirection, direction]);\n    }\n    directions.push([fixedDirection, direction]);\n  } else {\n    if (direction[0] && direction[1]) {\n      directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);\n    } else if (direction[0]) {\n      var signs = Math.abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n      signs.forEach(function(sign2) {\n        directions.push([[fixedDirection[0], -1], [sign2 * direction[0], -1]], [[fixedDirection[0], 0], [sign2 * direction[0], 0]], [[fixedDirection[0], 1], [sign2 * direction[0], 1]]);\n      });\n    } else if (direction[1]) {\n      var signs = Math.abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n      signs.forEach(function(sign2) {\n        directions.push([[-1, fixedDirection[1]], [-1, sign2 * direction[1]]], [[0, fixedDirection[1]], [0, sign2 * direction[1]]], [[1, fixedDirection[1]], [1, sign2 * direction[1]]]);\n      });\n    } else {\n      directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);\n    }\n  }\n  return directions;\n}\nfunction isStartLine(dot2, line) {\n  var cx = average([line[0][0], line[1][0]]);\n  var cy = average([line[0][1], line[1][1]]);\n  return {\n    vertical: cx <= dot2[0],\n    horizontal: cy <= dot2[1]\n  };\n}\nfunction hitTestLine(dot2, _a3) {\n  var pos1 = _a3[0], pos2 = _a3[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n  var test1;\n  var test2;\n  if (!dx) {\n    test1 = pos1[0];\n    test2 = dot2[0];\n  } else if (!dy) {\n    test1 = pos1[1];\n    test2 = dot2[1];\n  } else {\n    var a2 = dy / dx;\n    test1 = a2 * (dot2[0] - pos1[0]) + pos1[1];\n    test2 = dot2[1];\n  }\n  return test1 - test2;\n}\nfunction isSameStartLine(dots, line, error) {\n  if (error === void 0) {\n    error = TINY_NUM;\n  }\n  var centerSign = hitTestLine(dots[0], line) <= 0;\n  return dots.slice(1).every(function(dot2) {\n    var value2 = hitTestLine(dot2, line);\n    var sign2 = value2 <= 0;\n    return sign2 === centerSign || Math.abs(value2) <= error;\n  });\n}\nfunction checkInnerBoundDot(pos, start2, end2, isStart, threshold2) {\n  if (threshold2 === void 0) {\n    threshold2 = 0;\n  }\n  if (isStart && start2 - threshold2 <= pos || !isStart && pos <= end2 + threshold2) {\n    return {\n      isBound: true,\n      offset: isStart ? start2 - pos : end2 - pos\n    };\n  }\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\nfunction checkInnerBound(moveable, line, center) {\n  var bounds = moveable.props.innerBounds;\n  if (!bounds) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  }\n  var left2 = bounds.left, top2 = bounds.top, width = bounds.width, height = bounds.height;\n  var leftLine = [[left2, top2], [left2, top2 + height]];\n  var topLine = [[left2, top2], [left2 + width, top2]];\n  var rightLine = [[left2 + width, top2], [left2 + width, top2 + height]];\n  var bottomLine = [[left2, top2 + height], [left2 + width, top2 + height]];\n  var _a3 = isStartLine(center, line), isHorizontalStart = _a3.horizontal, isVerticalStart = _a3.vertical;\n  if (isSameStartLine([center, [left2, top2], [left2 + width, top2], [left2, top2 + height], [left2 + width, top2 + height]], line)) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  }\n  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n  var offset2 = [0, 0];\n  var isBound = false;\n  var isAllBound = false;\n  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n    offset2 = [verticalOffset, 0];\n    isBound = isVerticalBound;\n    isAllBound = isAllVerticalBound;\n  } else {\n    offset2 = [0, horizontalOffset];\n    isBound = isHorizontalBound;\n    isAllBound = isAllHorizontalBound;\n  }\n  return {\n    isAllBound,\n    isVerticalBound,\n    isHorizontalBound,\n    isBound,\n    offset: offset2\n  };\n}\nfunction checkLineBoundCollision(line, boundLine, isStart, threshold2, isRender) {\n  var dot1 = line[0];\n  var dot2 = line[1];\n  var boundDot1 = boundLine[0];\n  var boundDot2 = boundLine[1];\n  var dy1 = getTinyDist(dot2[1] - dot1[1]);\n  var dx1 = getTinyDist(dot2[0] - dot1[0]);\n  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n  if (!dx2) {\n    if (isRender && !dy1) {\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dx1) {\n      var y2 = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];\n      return checkInnerBoundDot(y2, boundDot1[1], boundDot2[1], isStart, threshold2);\n    } else {\n      var offset2 = boundDot1[0] - dot1[0];\n      var isBound = Math.abs(offset2) <= (threshold2 || 0);\n      return {\n        isBound,\n        offset: isBound ? offset2 : 0\n      };\n    }\n  } else if (!dy2) {\n    if (isRender && !dx1) {\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dy1) {\n      var x2 = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];\n      return checkInnerBoundDot(x2, boundDot1[0], boundDot2[0], isStart, threshold2);\n    } else {\n      var offset2 = boundDot1[1] - dot1[1];\n      var isBound = Math.abs(offset2) <= (threshold2 || 0);\n      return {\n        isBound,\n        offset: isBound ? offset2 : 0\n      };\n    }\n  }\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\nfunction getInnerBoundInfo(moveable, lines, center, datas) {\n  return lines.map(function(_a3) {\n    var multiple = _a3[0], pos1 = _a3[1], pos2 = _a3[2];\n    var _b3 = checkInnerBound(moveable, [pos1, pos2], center), isBound = _b3.isBound, offset2 = _b3.offset, isVerticalBound = _b3.isVerticalBound, isHorizontalBound = _b3.isHorizontalBound;\n    var sizeOffset = getDragDist({\n      datas,\n      distX: offset2[0],\n      distY: offset2[1]\n    }).map(function(size, i2) {\n      return size * (multiple[i2] ? 2 / multiple[i2] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound,\n      isVerticalBound,\n      isHorizontalBound,\n      isSnap: false,\n      offset: sizeOffset\n    };\n  });\n}\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\n  var _a3;\n  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function(_a4) {\n    var sign2 = _a4[0], pos1 = _a4[1], pos2 = _a4[2];\n    return [sign2.map(function(dir) {\n      return Math.abs(dir) * 2;\n    }), pos1, pos2];\n  });\n  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n  var verticalOffset = 0;\n  var horizontalOffset = 0;\n  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n  if (isVerticalBound || isHorizontalBound) {\n    _a3 = getInverseDragDist({\n      datas,\n      distX: -widthOffsetInfo.offset[0],\n      distY: -heightOffsetInfo.offset[1]\n    }), verticalOffset = _a3[0], horizontalOffset = _a3[1];\n  }\n  return {\n    vertical: {\n      isBound: isVerticalBound,\n      offset: verticalOffset\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      offset: horizontalOffset\n    }\n  };\n}\nfunction getCheckSnapLineDirections(direction, keepRatio) {\n  var lineDirections = [];\n  var x2 = direction[0];\n  var y2 = direction[1];\n  if (x2 && y2) {\n    lineDirections.push([[0, y2 * 2], direction, [-x2, y2]], [[x2 * 2, 0], direction, [x2, -y2]]);\n  } else if (x2) {\n    lineDirections.push([[x2 * 2, 0], [x2, 1], [x2, -1]]);\n    if (keepRatio) {\n      lineDirections.push([[0, -1], [x2, -1], [-x2, -1]], [[0, 1], [x2, 1], [-x2, 1]]);\n    }\n  } else if (y2) {\n    lineDirections.push([[0, y2 * 2], [1, y2], [-1, y2]]);\n    if (keepRatio) {\n      lineDirections.push([[-1, 0], [-1, y2], [-1, -y2]], [[1, 0], [1, y2], [1, -y2]]);\n    }\n  } else {\n    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);\n  }\n  return lineDirections;\n}\nfunction getCheckInnerBoundLines(poses, direction, keepRatio) {\n  return getCheckSnapLineDirections(direction, keepRatio).map(function(_a3) {\n    var sign2 = _a3[0], dir1 = _a3[1], dir2 = _a3[2];\n    return [sign2, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];\n  });\n}\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\n  var nextPoses = rad ? relativePoses.map(function(pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  var dots = __spreadArray([center], boundDots, true);\n  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function(line) {\n    return !isSameStartLine(dots, line);\n  });\n}\nfunction getDistPointLine(_a3) {\n  var pos1 = _a3[0], pos2 = _a3[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n  if (!dx) {\n    return Math.abs(pos1[0]);\n  }\n  if (!dy) {\n    return Math.abs(pos1[1]);\n  }\n  var a2 = dy / dx;\n  return Math.abs((-a2 * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a2, 2) + 1));\n}\nfunction solveReverseLine(_a3) {\n  var pos1 = _a3[0], pos2 = _a3[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n  if (!dx) {\n    return [pos1[0], 0];\n  }\n  if (!dy) {\n    return [0, pos1[1]];\n  }\n  var a2 = dy / dx;\n  var b2 = -a2 * pos1[0] + pos1[1];\n  return [-b2 / (a2 + 1 / a2), b2 / (a2 * a2 + 1)];\n}\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.innerBounds;\n  var rad = rotation * Math.PI / 180;\n  if (!bounds) {\n    return [];\n  }\n  var left2 = bounds.left, top2 = bounds.top, width = bounds.width, height = bounds.height;\n  var relativeLeft = left2 - origin[0];\n  var relativeRight = left2 + width - origin[0];\n  var relativeTop = top2 - origin[1];\n  var relativeBottom = top2 + height - origin[1];\n  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];\n  var center = getPosByDirection(nextPoses, [0, 0]);\n  if (!isBoundRotate(nextPoses, dots, center, 0)) {\n    return [];\n  }\n  var result = [];\n  var dotInfos = dots.map(function(dot2) {\n    return [getDistSize(dot2), getRad$1([0, 0], dot2)];\n  });\n  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function(line) {\n    var lineRad = getRad$1([0, 0], solveReverseLine(line));\n    var lineDist = getDistPointLine(line);\n    result.push.apply(result, dotInfos.filter(function(_a3) {\n      var dotDist = _a3[0];\n      return dotDist && lineDist <= dotDist;\n    }).map(function(_a3) {\n      var dotDist = _a3[0], dotRad = _a3[1];\n      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n      var nextRad1 = dotRad + distRad;\n      var nextRad2 = dotRad - distRad;\n      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];\n    }).reduce(function(prev2, cur) {\n      prev2.push.apply(prev2, cur);\n      return prev2;\n    }, []).filter(function(nextRad) {\n      return !isBoundRotate(prevPoses, dots, center, nextRad);\n    }).map(function(nextRad) {\n      return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n    }));\n  });\n  return result;\n}\nfunction checkInnerBoundPoses(moveable) {\n  var innerBounds = moveable.props.innerBounds;\n  if (!innerBounds) {\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  }\n  var _a3 = moveable.getRect(), pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4;\n  var poses = [pos1, pos2, pos3, pos4];\n  var center = getPosByDirection(poses, [0, 0]);\n  var left2 = innerBounds.left, top2 = innerBounds.top, width = innerBounds.width, height = innerBounds.height;\n  var leftLine = [[left2, top2], [left2, top2 + height]];\n  var topLine = [[left2, top2], [left2 + width, top2]];\n  var rightLine = [[left2 + width, top2], [left2 + width, top2 + height]];\n  var bottomLine = [[left2, top2 + height], [left2 + width, top2 + height]];\n  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];\n  var horizontalPoses = [];\n  var verticalPoses = [];\n  var boundMap = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false\n  };\n  lines.forEach(function(line) {\n    var _a4 = isStartLine(center, line), isHorizontalStart = _a4.horizontal, isVerticalStart = _a4.vertical;\n    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);\n    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n    if (topBoundInfo.isBound && !boundMap.top) {\n      horizontalPoses.push(top2);\n      boundMap.top = true;\n    }\n    if (bottomBoundInfo.isBound && !boundMap.bottom) {\n      horizontalPoses.push(top2 + height);\n      boundMap.bottom = true;\n    }\n    if (leftBoundInfo.isBound && !boundMap.left) {\n      verticalPoses.push(left2);\n      boundMap.left = true;\n    }\n    if (rightBoundInfo.isBound && !boundMap.right) {\n      verticalPoses.push(left2 + width);\n      boundMap.right = true;\n    }\n  });\n  return {\n    horizontal: horizontalPoses,\n    vertical: verticalPoses\n  };\n}\nfunction checkBoundPoses(bounds, verticalPoses, horizontalPoses) {\n  var _a3 = bounds || {}, _b3 = _a3.position, position = _b3 === void 0 ? \"client\" : _b3, _c3 = _a3.left, left2 = _c3 === void 0 ? -Infinity : _c3, _d2 = _a3.top, top2 = _d2 === void 0 ? -Infinity : _d2, _e = _a3.right, right2 = _e === void 0 ? Infinity : _e, _f = _a3.bottom, bottom2 = _f === void 0 ? Infinity : _f;\n  var nextBounds = {\n    position,\n    left: left2,\n    top: top2,\n    right: right2,\n    bottom: bottom2\n  };\n  return {\n    vertical: checkBounds(nextBounds, verticalPoses, true),\n    horizontal: checkBounds(nextBounds, horizontalPoses, false)\n  };\n}\nfunction getBounds(moveable, externalBounds) {\n  var _a3 = moveable.state, _b3 = _a3.containerClientRect, containerHeight = _b3.clientHeight, containerWidth = _b3.clientWidth, clientLeft = _b3.clientLeft, clientTop = _b3.clientTop, _c3 = _a3.snapOffset, snapOffsetLeft = _c3.left, snapOffsetTop = _c3.top, snapOffsetRight = _c3.right, snapOffsetBottom = _c3.bottom;\n  var bounds = externalBounds || moveable.props.bounds || {};\n  var position = bounds.position || \"client\";\n  var isCSS = position === \"css\";\n  var _d2 = bounds.left, left2 = _d2 === void 0 ? -Infinity : _d2, _e = bounds.top, top2 = _e === void 0 ? -Infinity : _e;\n  var _f = bounds.right, right2 = _f === void 0 ? isCSS ? -Infinity : Infinity : _f, _g = bounds.bottom, bottom2 = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;\n  if (isCSS) {\n    right2 = containerWidth + snapOffsetRight - snapOffsetLeft - right2;\n    bottom2 = containerHeight + snapOffsetBottom - snapOffsetTop - bottom2;\n  }\n  return {\n    left: left2 + snapOffsetLeft - clientLeft,\n    right: right2 + snapOffsetLeft - clientLeft,\n    top: top2 + snapOffsetTop - clientTop,\n    bottom: bottom2 + snapOffsetTop - clientTop\n  };\n}\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\n  var _a3 = getBounds(moveable), left2 = _a3.left, top2 = _a3.top, right2 = _a3.right, bottom2 = _a3.bottom;\n  var endX = endPos[0], endY = endPos[1];\n  var _b3 = minus(endPos, startPos), dx = _b3[0], dy = _b3[1];\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  var verticalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  } else if (dx === 0) {\n    if (isBottom) {\n      if (bottom2 < endY) {\n        horizontalInfo.pos = bottom2;\n        horizontalInfo.offset = endY - bottom2;\n      }\n    } else {\n      if (top2 > endY) {\n        horizontalInfo.pos = top2;\n        horizontalInfo.offset = endY - top2;\n      }\n    }\n  } else if (dy === 0) {\n    if (isRight) {\n      if (right2 < endX) {\n        verticalInfo.pos = right2;\n        verticalInfo.offset = endX - right2;\n      }\n    } else {\n      if (left2 > endX) {\n        verticalInfo.pos = left2;\n        verticalInfo.offset = endX - left2;\n      }\n    }\n  } else {\n    var a2 = dy / dx;\n    var b2 = endPos[1] - a2 * endX;\n    var y2 = 0;\n    var x2 = 0;\n    var isBound = false;\n    if (isRight && right2 <= endX) {\n      y2 = a2 * right2 + b2;\n      x2 = right2;\n      isBound = true;\n    } else if (!isRight && endX <= left2) {\n      y2 = a2 * left2 + b2;\n      x2 = left2;\n      isBound = true;\n    }\n    if (isBound) {\n      if (y2 < top2 || y2 > bottom2) {\n        isBound = false;\n      }\n    }\n    if (!isBound) {\n      if (isBottom && bottom2 <= endY) {\n        y2 = bottom2;\n        x2 = (y2 - b2) / a2;\n        isBound = true;\n      } else if (!isBottom && endY <= top2) {\n        y2 = top2;\n        x2 = (y2 - b2) / a2;\n        isBound = true;\n      }\n    }\n    if (isBound) {\n      verticalInfo.isBound = true;\n      verticalInfo.pos = x2;\n      verticalInfo.offset = endX - x2;\n      horizontalInfo.isBound = true;\n      horizontalInfo.pos = y2;\n      horizontalInfo.offset = endY - y2;\n    }\n  }\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\nfunction checkBounds(bounds, poses, isVertical) {\n  var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n  var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n  var minPos = Math.min.apply(Math, poses);\n  var maxPos = Math.max.apply(Math, poses);\n  var boundInfos = [];\n  if (startBoundPos + 1 > minPos) {\n    boundInfos.push({\n      isBound: true,\n      offset: minPos - startBoundPos,\n      pos: startBoundPos\n    });\n  }\n  if (endBoundPos - 1 < maxPos) {\n    boundInfos.push({\n      isBound: true,\n      offset: maxPos - endBoundPos,\n      pos: endBoundPos\n    });\n  }\n  if (!boundInfos.length) {\n    boundInfos.push({\n      isBound: false,\n      offset: 0,\n      pos: 0\n    });\n  }\n  return boundInfos.sort(function(a2, b2) {\n    return Math.abs(b2.offset) - Math.abs(a2.offset);\n  });\n}\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\n  var nextPoses = rad ? relativePoses.map(function(pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  return nextPoses.some(function(pos) {\n    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;\n  });\n}\nfunction boundRotate(vec, boundPos, index) {\n  var r2 = getDistSize(vec);\n  var nextPos = Math.sqrt(r2 * r2 - boundPos * boundPos) || 0;\n  return [nextPos, -nextPos].sort(function(a2, b2) {\n    return Math.abs(a2 - vec[index ? 0 : 1]) - Math.abs(b2 - vec[index ? 0 : 1]);\n  }).map(function(pos) {\n    return getRad$1([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n  });\n}\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  if (!moveable.props.bounds) {\n    return [];\n  }\n  var rad = rotation * Math.PI / 180;\n  var _a3 = getBounds(moveable), left2 = _a3.left, top2 = _a3.top, right2 = _a3.right, bottom2 = _a3.bottom;\n  var relativeLeft = left2 - origin[0];\n  var relativeRight = right2 - origin[0];\n  var relativeTop = top2 - origin[1];\n  var relativeBottom = bottom2 - origin[1];\n  var boundRect = {\n    left: relativeLeft,\n    top: relativeTop,\n    right: relativeRight,\n    bottom: relativeBottom\n  };\n  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\n    return [];\n  }\n  var result = [];\n  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function(_a4) {\n    var boundPos = _a4[0], index = _a4[1];\n    nextPoses.forEach(function(nextPos) {\n      var relativeRad1 = getRad$1([0, 0], nextPos);\n      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function(relativeRad2) {\n        return rad + relativeRad2 - relativeRad1;\n      }).filter(function(nextRad) {\n        return !isBoundRotate$1(prevPoses, boundRect, nextRad);\n      }).map(function(nextRad) {\n        return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  });\n  return result;\n}\nfunction renderGuideline(info, React) {\n  var _a3;\n  var direction = info.direction, classNames = info.classNames, size = info.size, pos = info.pos, zoom = info.zoom, key = info.key;\n  var isHorizontal = direction === \"horizontal\";\n  var scaleType = isHorizontal ? \"Y\" : \"X\";\n  return React.createElement(\"div\", {\n    key,\n    className: classNames.join(\" \"),\n    style: (_a3 = {}, _a3[isHorizontal ? \"width\" : \"height\"] = \"\".concat(size), _a3.transform = \"translate(\".concat(pos[0], \", \").concat(pos[1], \") translate\").concat(scaleType, \"(-50%) scale\").concat(scaleType, \"(\").concat(zoom, \")\"), _a3)\n  });\n}\nfunction renderInnerGuideline(info, React) {\n  return renderGuideline(__assign$1$1(__assign$1$1({}, info), {\n    classNames: __spreadArray([prefix(\"line\", \"guideline\", info.direction)], info.classNames, true).filter(function(className) {\n      return className;\n    }),\n    size: info.size || \"\".concat(info.sizeValue, \"px\"),\n    pos: info.pos || info.posValue.map(function(v2) {\n      return \"\".concat(throttle(v2, 0.1), \"px\");\n    })\n  }), React);\n}\nfunction renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {\n  var zoom = moveable.props.zoom;\n  return snapPoses.map(function(_a3, i2) {\n    var type = _a3.type, pos = _a3.pos;\n    var renderPos = [0, 0];\n    renderPos[index] = minPos;\n    renderPos[index ? 0 : 1] = -targetPos + pos;\n    return renderInnerGuideline({\n      key: \"\".concat(direction, \"TargetGuideline\").concat(i2),\n      classNames: [prefix(\"target\", \"bold\", type)],\n      posValue: renderPos,\n      sizeValue: size,\n      zoom,\n      direction\n    }, React);\n  });\n}\nfunction renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {\n  var _a3 = moveable.props, zoom = _a3.zoom, isDisplayInnerSnapDigit = _a3.isDisplayInnerSnapDigit;\n  var mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n  var targetStart = targetRect[mainNames.start];\n  var targetEnd = targetRect[mainNames.end];\n  return guidelines.filter(function(_a4) {\n    var hide2 = _a4.hide, elementRect = _a4.elementRect;\n    if (hide2) {\n      return false;\n    }\n    if (isDisplayInnerSnapDigit && elementRect) {\n      var rect = elementRect.rect;\n      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {\n        return false;\n      }\n    }\n    return true;\n  }).map(function(guideline, i2) {\n    var pos = guideline.pos, size = guideline.size, element = guideline.element;\n    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];\n    return renderInnerGuideline({\n      key: \"\".concat(type, \"-default-guideline-\").concat(i2),\n      classNames: element ? [prefix(\"bold\")] : [],\n      direction: type,\n      posValue: renderPos,\n      sizeValue: size,\n      zoom\n    }, React);\n  });\n}\nfunction renderDigitLine(moveable, type, lineType, index, gap2, renderPos, className, React) {\n  var _a3;\n  var _b3 = moveable.props, _c3 = _b3.snapDigit, snapDigit = _c3 === void 0 ? 0 : _c3, _d2 = _b3.isDisplaySnapDigit, isDisplaySnapDigit = _d2 === void 0 ? true : _d2, _e = _b3.snapDistFormat, snapDistFormat = _e === void 0 ? function(v2) {\n    return v2;\n  } : _e, zoom = _b3.zoom;\n  var scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n  var sizeName = type === \"vertical\" ? \"height\" : \"width\";\n  var absGap = Math.abs(gap2);\n  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n  return React.createElement(\"div\", {\n    key: \"\".concat(type, \"-\").concat(lineType, \"-guideline-\").concat(index),\n    className: prefix(\"guideline-group\", type),\n    style: (_a3 = {\n      left: \"\".concat(renderPos[0], \"px\"),\n      top: \"\".concat(renderPos[1], \"px\")\n    }, _a3[sizeName] = \"\".concat(absGap, \"px\"), _a3)\n  }, renderInnerGuideline({\n    direction: type,\n    classNames: [prefix(lineType), className],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: absGap,\n    zoom\n  }, React), React.createElement(\"div\", {\n    className: prefix(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(scaleType, \"(-50%) scale(\").concat(zoom, \")\")\n    }\n  }, snapSize > 0 ? snapDistFormat(snapSize) : \"\"));\n}\nfunction groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {\n  var index = type === \"vertical\" ? 0 : 1;\n  var otherIndex = type === \"vertical\" ? 1 : 0;\n  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n  var targetStart = targetRect[names.start];\n  var targetEnd = targetRect[names.end];\n  return groupBy(guidelines, function(guideline) {\n    return guideline.pos[index];\n  }).map(function(nextGuidelines) {\n    var start2 = [];\n    var end2 = [];\n    var inner = [];\n    nextGuidelines.forEach(function(guideline) {\n      var _a3, _b3;\n      var element = guideline.element;\n      var rect = guideline.elementRect.rect;\n      if (rect[names.end] < targetStart) {\n        start2.push(guideline);\n      } else if (targetEnd < rect[names.start]) {\n        end2.push(guideline);\n      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {\n        var pos = guideline.pos;\n        var elementRect1 = {\n          element,\n          rect: __assign$1$1(__assign$1$1({}, rect), (_a3 = {}, _a3[names.end] = rect[names.start], _a3))\n        };\n        var elementRect2 = {\n          element,\n          rect: __assign$1$1(__assign$1$1({}, rect), (_b3 = {}, _b3[names.start] = rect[names.end], _b3))\n        };\n        var nextPos1 = [0, 0];\n        var nextPos2 = [0, 0];\n        nextPos1[index] = pos[index];\n        nextPos1[otherIndex] = pos[otherIndex];\n        nextPos2[index] = pos[index];\n        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n        start2.push({\n          type,\n          pos: nextPos1,\n          size: 0,\n          elementRect: elementRect1\n        });\n        end2.push({\n          type,\n          pos: nextPos2,\n          size: 0,\n          elementRect: elementRect2\n        });\n      }\n    });\n    start2.sort(function(a2, b2) {\n      return b2.pos[otherIndex] - a2.pos[otherIndex];\n    });\n    end2.sort(function(a2, b2) {\n      return a2.pos[otherIndex] - b2.pos[otherIndex];\n    });\n    return {\n      total: nextGuidelines,\n      start: start2,\n      end: end2,\n      inner\n    };\n  });\n}\nfunction renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {\n  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;\n  var rendered = [];\n  [\"vertical\", \"horizontal\"].forEach(function(type) {\n    var nextGuidelines = guidelines.filter(function(guideline) {\n      return guideline.type === type;\n    });\n    var index = type === \"vertical\" ? 1 : 0;\n    var otherIndex = index ? 0 : 1;\n    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);\n    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    var targetStart = targetRect[mainNames.start];\n    var targetEnd = targetRect[mainNames.end];\n    groups.forEach(function(_a3) {\n      var total = _a3.total, start2 = _a3.start, end2 = _a3.end, inner = _a3.inner;\n      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];\n      var prevRect = targetRect;\n      start2.forEach(function(guideline) {\n        var nextRect = guideline.elementRect.rect;\n        var size = prevRect[mainNames.start] - nextRect[mainNames.end];\n        if (size > 0) {\n          var renderPos = [0, 0];\n          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;\n          renderPos[otherIndex] = sidePos;\n          rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\n        }\n        prevRect = nextRect;\n      });\n      prevRect = targetRect;\n      end2.forEach(function(guideline) {\n        var nextRect = guideline.elementRect.rect;\n        var size = nextRect[mainNames.start] - prevRect[mainNames.end];\n        if (size > 0) {\n          var renderPos = [0, 0];\n          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;\n          renderPos[otherIndex] = sidePos;\n          rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\n        }\n        prevRect = nextRect;\n      });\n      inner.forEach(function(guideline) {\n        var nextRect = guideline.elementRect.rect;\n        var size1 = targetStart - nextRect[mainNames.start];\n        var size2 = nextRect[mainNames.end] - targetEnd;\n        var renderPos1 = [0, 0];\n        var renderPos2 = [0, 0];\n        renderPos1[index] = targetPos[index] - size1;\n        renderPos1[otherIndex] = sidePos;\n        renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n        renderPos2[otherIndex] = sidePos;\n        rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size1, renderPos1, guideline.className, React));\n        rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size2, renderPos2, guideline.className, React));\n      });\n    });\n  });\n  return rendered;\n}\nfunction renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {\n  var rendered = [];\n  [\"horizontal\", \"vertical\"].forEach(function(type) {\n    var nextGuidelines = guidelines.filter(function(guideline) {\n      return guideline.type === type;\n    });\n    var index = type === \"vertical\" ? 0 : 1;\n    var otherIndex = index ? 0 : 1;\n    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    var targetStart = targetRect[mainNames.start];\n    var targetEnd = targetRect[mainNames.end];\n    var targetSideStart = targetRect[sideNames.start];\n    var targetSideEnd = targetRect[sideNames.end];\n    nextGuidelines.forEach(function(_a3) {\n      var gap2 = _a3.gap, gapRects = _a3.gapRects, className = _a3.className;\n      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function(_a4) {\n        var rect = _a4.rect;\n        return rect[sideNames.start];\n      }), false));\n      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function(_a4) {\n        var rect = _a4.rect;\n        return rect[sideNames.end];\n      }), false));\n      var sideCenterPos = (sideStartPos + sideEndPos) / 2;\n      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {\n        return;\n      }\n      gapRects.forEach(function(_a4) {\n        var rect = _a4.rect;\n        var renderPos = [targetPos[0], targetPos[1]];\n        if (rect[mainNames.end] < targetStart) {\n          renderPos[index] += rect[mainNames.end] - targetStart;\n        } else if (targetEnd < rect[mainNames.start]) {\n          renderPos[index] += rect[mainNames.start] - targetStart - gap2;\n        } else {\n          return;\n        }\n        renderPos[otherIndex] += sideCenterPos - targetSideStart;\n        rendered.push(renderDigitLine(moveable, index ? \"vertical\" : \"horizontal\", \"gap\", rendered.length, gap2, renderPos, className, React));\n      });\n    });\n  });\n  return rendered;\n}\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n  if (Math.abs(dx) < TINY_NUM$1) {\n    dx = 0;\n  }\n  if (Math.abs(dy) < TINY_NUM$1) {\n    dy = 0;\n  }\n  if (!dx) {\n    if (!isVertical) {\n      return [0, snapOffset];\n    }\n    return [0, 0];\n  }\n  if (!dy) {\n    if (isVertical) {\n      return [snapOffset, 0];\n    }\n    return [0, 0];\n  }\n  var a2 = dy / dx;\n  var b2 = pos1[1] - a2 * pos1[0];\n  if (isVertical) {\n    var y2 = a2 * (pos2[0] + snapOffset) + b2;\n    return [snapOffset, y2 - pos2[1]];\n  } else {\n    var x2 = (pos2[1] + snapOffset - b2) / a2;\n    return [x2 - pos2[0], snapOffset];\n  }\n}\nfunction solveNextOffset(pos1, pos2, offset2, isVertical, datas) {\n  var sizeOffset = solveEquation(pos1, pos2, offset2, isVertical);\n  if (!sizeOffset) {\n    return {\n      isOutside: false,\n      offset: [0, 0]\n    };\n  }\n  var size = getDist$2(pos1, pos2);\n  var dist1 = getDist$2(sizeOffset, pos1);\n  var dist2 = getDist$2(sizeOffset, pos2);\n  var isOutside = dist1 > size || dist2 > size;\n  var _a3 = getDragDist({\n    datas,\n    distX: sizeOffset[0],\n    distY: sizeOffset[1]\n  }), widthOffset = _a3[0], heightOffset = _a3[1];\n  return {\n    offset: [widthOffset, heightOffset],\n    isOutside\n  };\n}\nfunction getSnapBound(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return getNearestSnapGuidelineInfo(snapInfo).offset;\n  }\n  return 0;\n}\nfunction checkThrottleDragRotate(throttleDragRotate, _a3, _b3, _c3, _d2) {\n  var distX = _a3[0], distY = _a3[1];\n  var isVerticalBound = _b3[0], isHorizontalBound = _b3[1];\n  var isVerticalSnap = _c3[0], isHorizontalSnap = _c3[1];\n  var verticalOffset = _d2[0], horizontalOffset = _d2[1];\n  var offsetX = -verticalOffset;\n  var offsetY = -horizontalOffset;\n  if (throttleDragRotate && distX && distY) {\n    offsetX = 0;\n    offsetY = 0;\n    var adjustPoses = [];\n    if (isVerticalBound && isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalBound) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset]);\n    } else if (isVerticalSnap && isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalSnap) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset]);\n    }\n    if (adjustPoses.length) {\n      adjustPoses.sort(function(a2, b2) {\n        return getDistSize(minus([distX, distY], a2)) - getDistSize(minus([distX, distY], b2));\n      });\n      var adjustPos = adjustPoses[0];\n      if (adjustPos[0] && Math.abs(distX) > TINY_NUM$1) {\n        offsetX = -adjustPos[0];\n        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM$1) {\n        var prevDistY = distY;\n        offsetY = -adjustPos[1];\n        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n      }\n      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n        if (Math.abs(offsetX) > TINY_NUM$1 && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else if (Math.abs(offsetY) > TINY_NUM$1 && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else {\n          offsetX = maxOffset(-verticalOffset, offsetX);\n          offsetY = maxOffset(-horizontalOffset, offsetY);\n        }\n      }\n    }\n  } else {\n    offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n  }\n  return [offsetX, offsetY];\n}\nfunction checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"draggable\")) {\n    return [{\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }, {\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }];\n  }\n  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n  var _a3 = getRect(poses), left2 = _a3.left, right2 = _a3.right, top2 = _a3.top, bottom2 = _a3.bottom;\n  var boundPoses = {\n    horizontal: poses.map(function(pos) {\n      return pos[1];\n    }),\n    vertical: poses.map(function(pos) {\n      return pos[0];\n    })\n  };\n  var snapDirections = getSnapDirections(moveable.props.snapDirections);\n  var snapPoses = splitSnapDirectionPoses(snapDirections, {\n    left: left2,\n    right: right2,\n    top: top2,\n    bottom: bottom2,\n    center: (left2 + right2) / 2,\n    middle: (top2 + bottom2) / 2\n  });\n  var _b3 = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses), verticalSnapBoundInfo = _b3.vertical, horizontalSnapBoundInfo = _b3.horizontal;\n  var _c3 = getInnerBoundDragInfo(moveable, poses, datas), verticalInnerBoundInfo = _c3.vertical, horizontalInnerBoundInfo = _c3.horizontal;\n  var isVerticalSnap = verticalSnapBoundInfo.isSnap;\n  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n  var _d2 = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]), offsetX = _d2[0], offsetY = _d2[1];\n  return [{\n    isBound: isVerticalBound,\n    isSnap: isVerticalSnap,\n    offset: offsetX\n  }, {\n    isBound: isHorizontalBound,\n    isSnap: isHorizontalSnap,\n    offset: offsetY\n  }];\n}\nfunction checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {\n  if (boundPoses === void 0) {\n    boundPoses = poses;\n  }\n  var _a3 = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal), horizontalBoundInfos = _a3.horizontal, verticalBoundInfos = _a3.vertical;\n  var _b3 = isRequest ? {\n    horizontal: {\n      isSnap: false,\n      index: -1\n    },\n    vertical: {\n      isSnap: false,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;\n  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo\n    }\n  };\n}\nfunction checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {\n  var _a3 = checkBoundPoses(bounds, posesX, posesY), horizontalBoundInfos = _a3.horizontal, verticalBoundInfos = _a3.vertical;\n  var _b3 = checkSnapPoses(guideines, posesX, posesY, snapThreshold), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;\n  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo\n    }\n  };\n}\nfunction checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {\n  var rad = getRad$1(startPos, endPos) / Math.PI * 180;\n  var _a3 = snapBoundInfo.vertical, isVerticalBound = _a3.isBound, isVerticalSnap = _a3.isSnap, verticalDist = _a3.dist, _b3 = snapBoundInfo.horizontal, isHorizontalBound = _b3.isBound, isHorizontalSnap = _b3.isSnap, horizontalDist = _b3.dist;\n  var rad180 = rad % 180;\n  var isHorizontalLine = rad180 < 3 || rad180 > 177;\n  var isVerticalLine = rad180 > 87 && rad180 < 93;\n  if (horizontalDist < verticalDist) {\n    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {\n      return \"vertical\";\n    }\n  }\n  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {\n    return \"horizontal\";\n  }\n  return \"\";\n}\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {\n  return directions.map(function(_a3) {\n    var startDirection = _a3[0], endDirection = _a3[1];\n    var otherStartPos = getPosByDirection(poses, startDirection);\n    var otherEndPos = getPosByDirection(poses, endDirection);\n    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {\n      vertical: [otherEndPos[0]],\n      horizontal: [otherEndPos[1]]\n    });\n    var _b3 = snapBoundInfo.horizontal, otherHorizontalOffset = _b3.offset, isOtherHorizontalBound = _b3.isBound, isOtherHorizontalSnap = _b3.isSnap, _c3 = snapBoundInfo.vertical, otherVerticalOffset = _c3.offset, isOtherVerticalBound = _c3.isBound, isOtherVerticalSnap = _c3.isSnap;\n    var multiple = minus(endDirection, startDirection);\n    if (!otherVerticalOffset && !otherHorizontalOffset) {\n      return {\n        isBound: isOtherVerticalBound || isOtherHorizontalBound,\n        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n        sign: multiple,\n        offset: [0, 0]\n      };\n    }\n    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);\n    if (!snapLine) {\n      return {\n        sign: multiple,\n        isBound: false,\n        isSnap: false,\n        offset: [0, 0]\n      };\n    }\n    var isVertical = snapLine === \"vertical\";\n    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function(size, i2) {\n      return size * (multiple[i2] ? 2 / multiple[i2] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n      offset: sizeOffset\n    };\n  });\n}\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return snapInfo.offset;\n  }\n  return 0;\n}\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {\n  var _a3 = checkBoundKeepRatio(moveable, startPos, endPos), horizontalBoundInfo = _a3.horizontal, verticalBoundInfo = _a3.vertical;\n  var _b3 = isRequest ? {\n    horizontal: {\n      isSnap: false\n    },\n    vertical: {\n      isSnap: false\n    }\n  } : checkSnapKeepRatio(moveable, startPos, endPos), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;\n  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\nfunction checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {\n  var fixedDirection = [-direction[0], -direction[1]];\n  var _a3 = moveable.state, width = _a3.width, height = _a3.height;\n  var bounds = moveable.props.bounds;\n  var maxWidth = Infinity;\n  var maxHeight = Infinity;\n  if (bounds) {\n    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];\n    var _b3 = bounds.left, left_1 = _b3 === void 0 ? -Infinity : _b3, _c3 = bounds.top, top_1 = _c3 === void 0 ? -Infinity : _c3, _d2 = bounds.right, right_1 = _d2 === void 0 ? Infinity : _d2, _e = bounds.bottom, bottom_1 = _e === void 0 ? Infinity : _e;\n    directions.forEach(function(otherDirection) {\n      var isCheckVertical = otherDirection[0] !== fixedDirection[0];\n      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n      var otherPos = getPosByDirection(poses, otherDirection);\n      var deg = getRad$1(fixedPosition, otherPos) * 360 / Math.PI;\n      if (isCheckHorizontal) {\n        var nextOtherPos = otherPos.slice();\n        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n          nextOtherPos[1] = fixedPosition[1];\n        }\n        var _a4 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas), _b4 = _a4.offset, heightOffset = _b4[1], isHeightOutside = _a4.isOutside;\n        if (!isNaN(heightOffset)) {\n          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n        }\n      }\n      if (isCheckVertical) {\n        var nextOtherPos = otherPos.slice();\n        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n          nextOtherPos[0] = fixedPosition[0];\n        }\n        var _c4 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas), widthOffset = _c4.offset[0], isWidthOutside = _c4.isOutside;\n        if (!isNaN(widthOffset)) {\n          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n        }\n      }\n    });\n  }\n  return {\n    maxWidth,\n    maxHeight\n  };\n}\nfunction snapStart(moveable) {\n  var state = moveable.state;\n  if (state.guidelines && state.guidelines.length) {\n    return;\n  }\n  var container = moveable.state.container;\n  var snapContainer = moveable.props.snapContainer || container;\n  var containerClientRect = state.containerClientRect;\n  var snapOffset = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n  if (container !== snapContainer) {\n    var snapContainerTarget = getRefTarget(snapContainer, true);\n    if (snapContainerTarget) {\n      var snapContainerRect = getClientRect(snapContainerTarget);\n      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);\n      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);\n      snapOffset.left = throttle(offset1[0], 0.1);\n      snapOffset.top = throttle(offset1[1], 0.1);\n      snapOffset.right = throttle(offset2[0], 0.1);\n      snapOffset.bottom = throttle(offset2[1], 0.1);\n    }\n  }\n  state.snapOffset = snapOffset;\n  state.guidelines = getTotalGuidelines(moveable);\n  state.enableSnap = true;\n}\nfunction getNextFixedPoses(matrix, width, height, fixedDirection, fixedPos, is3d) {\n  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n  var nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n  return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {\n  var fixedDirection = datas.fixedDirection;\n  var directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n  var lines = getCheckInnerBoundLines(poses, direction, keepRatio);\n  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas), true), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas), true);\n  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n  return {\n    width: {\n      isBound: widthOffsetInfo.isBound,\n      offset: widthOffsetInfo.offset[0]\n    },\n    height: {\n      isBound: heightOffsetInfo.isBound,\n      offset: heightOffsetInfo.offset[1]\n    }\n  };\n}\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {\n  var snapPos = getPosByDirection(poses, direction);\n  var _a3 = checkMoveableSnapBounds(moveable, isRequest, {\n    vertical: [snapPos[0]],\n    horizontal: [snapPos[1]]\n  }), horizontalOffset = _a3.horizontal.offset, verticalOffset = _a3.vertical.offset;\n  if (verticalOffset || horizontalOffset) {\n    var _b3 = getDragDist({\n      datas,\n      distX: -verticalOffset,\n      distY: -horizontalOffset\n    }), nextWidthOffset = _b3[0], nextHeightOffset = _b3[1];\n    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n    return [nextWidth - width, nextHeight - height];\n  }\n  return [0, 0];\n}\nfunction checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {\n  var poses = getAbsolutePosesByState(moveable.state);\n  var keepRatio = moveable.props.keepRatio;\n  var widthOffset = 0;\n  var heightOffset = 0;\n  for (var i2 = 0; i2 < 2; ++i2) {\n    var nextPoses = getNextPoses(widthOffset, heightOffset);\n    var _a3 = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas), widthOffsetInfo = _a3.width, heightOffsetInfo = _a3.height;\n    var isWidthBound = widthOffsetInfo.isBound;\n    var isHeightBound = heightOffsetInfo.isBound;\n    var nextWidthOffset = widthOffsetInfo.offset;\n    var nextHeightOffset = heightOffsetInfo.offset;\n    if (i2 === 1) {\n      if (!isWidthBound) {\n        nextWidthOffset = 0;\n      }\n      if (!isHeightBound) {\n        nextHeightOffset = 0;\n      }\n    }\n    if (i2 === 0 && isRequest && !isWidthBound && !isHeightBound) {\n      return [0, 0];\n    }\n    if (keepRatio) {\n      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;\n      if (isGetWidthOffset) {\n        nextWidthOffset = width * nextHeightOffset / height;\n      } else {\n        nextHeightOffset = height * nextWidthOffset / width;\n      }\n    }\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n  if (direction[0] && direction[1]) {\n    var _b3 = checkMaxBounds(moveable, poses, direction, fixedPosition, datas), maxWidth = _b3.maxWidth, maxHeight = _b3.maxHeight;\n    var _c3 = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function(pos) {\n      return pos.map(function(p2) {\n        return throttle(p2, FLOAT_POINT_NUM);\n      });\n    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas), nextWidthOffset = _c3[0], nextHeightOffset = _c3[1];\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n  return [widthOffset, heightOffset];\n}\nfunction checkSnapRotate(moveable, rect, origin, rotation) {\n  if (!hasGuidelines(moveable, \"rotatable\")) {\n    return rotation;\n  }\n  var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4;\n  var rad = rotation * Math.PI / 180;\n  var prevPoses = [pos1, pos2, pos3, pos4].map(function(pos) {\n    return minus(pos, origin);\n  });\n  var nextPoses = prevPoses.map(function(pos) {\n    return rotate(pos, rad);\n  });\n  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation), true), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation), true);\n  result.sort(function(a2, b2) {\n    return Math.abs(a2 - rotation) - Math.abs(b2 - rotation);\n  });\n  if (result.length) {\n    return result[0];\n  } else {\n    return rotation;\n  }\n}\nfunction checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"resizable\")) {\n    return [0, 0];\n  }\n  var fixedDirection = datas.fixedDirection;\n  var _a3 = moveable.state, allMatrix = _a3.allMatrix, is3d = _a3.is3d;\n  return checkSizeDist(moveable, function(widthOffset, heightOffset) {\n    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedDirection, fixedPosition, is3d);\n  }, width, height, direction, fixedPosition, isRequest, datas);\n}\nfunction checkSnapScale(moveable, scale, direction, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"scalable\")) {\n    return [0, 0];\n  }\n  var startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, fixedPosition = datas.fixedPosition, fixedDirection = datas.fixedDirection, is3d = datas.is3d;\n  var sizeDist = checkSizeDist(moveable, function(widthOffset, heightOffset) {\n    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight])), startOffsetWidth, startOffsetHeight, fixedDirection, fixedPosition, is3d);\n  }, startOffsetWidth, startOffsetHeight, direction, fixedPosition, isRequest, datas);\n  return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\nfunction startCheckSnapDrag(moveable, datas) {\n  datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\nfunction getSnapGuidelines(posInfos) {\n  var guidelines = [];\n  posInfos.forEach(function(posInfo) {\n    posInfo.guidelineInfos.forEach(function(_a3) {\n      var guideline = _a3.guideline;\n      if (guidelines.indexOf(guideline) > -1) {\n        return;\n      }\n      guidelines.push(guideline);\n    });\n  });\n  return guidelines;\n}\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {\n  var _a3 = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses), verticalBoundInfos = _a3.vertical, horizontalBoundInfos = _a3.horizontal;\n  verticalBoundInfos.forEach(function(info) {\n    if (info.isBound) {\n      verticalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos\n      });\n    }\n  });\n  horizontalBoundInfos.forEach(function(info) {\n    if (info.isBound) {\n      horizontalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos\n      });\n    }\n  });\n  var _b3 = checkInnerBoundPoses(moveable), verticalInnerBoundPoses = _b3.vertical, horizontalInnerBoundPoses = _b3.horizontal;\n  verticalInnerBoundPoses.forEach(function(innerPos) {\n    if (findIndex(verticalSnapPoses, function(_a4) {\n      var type = _a4.type, pos = _a4.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n    verticalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n  horizontalInnerBoundPoses.forEach(function(innerPos) {\n    if (findIndex(horizontalSnapPoses, function(_a4) {\n      var type = _a4.type, pos = _a4.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n    horizontalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n}\nvar Snappable = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapDirections: [Boolean, Object],\n    elementSnapDirections: [Boolean, Object],\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [\":host {\\n    --bounds-color: #d66;\\n}\\n.guideline {\\n    pointer-events: none;\\n    z-index: 2;\\n}\\n.guideline.bounds {\\n    background: #d66;\\n    background: var(--bounds-color);\\n}\\n.guideline-group {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n}\\n.guideline-group .size-value {\\n    position: absolute;\\n    color: #f55;\\n    font-size: 12px;\\n    font-weight: bold;\\n}\\n.guideline-group.horizontal .size-value {\\n    transform-origin: 50% 100%;\\n    transform: translateX(-50%);\\n    left: 50%;\\n    bottom: 5px;\\n}\\n.guideline-group.vertical .size-value {\\n    transform-origin: 0% 50%;\\n    top: 50%;\\n    transform: translateY(-50%);\\n    left: 5px;\\n}\\n.guideline.gap {\\n    background: #f55;\\n}\\n.size-value.gap {\\n    color: #f55;\\n}\\n\"],\n  render: function(moveable, React) {\n    var state = moveable.state;\n    var targetTop = state.top, targetLeft = state.left, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, snapRenderInfo = state.snapRenderInfo;\n    if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n      return [];\n    }\n    state.guidelines = getTotalGuidelines(moveable);\n    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n    var externalPoses = snapRenderInfo.externalPoses || [];\n    var poses = getAbsolutePosesByState(moveable.state);\n    var verticalSnapPoses = [];\n    var horizontalSnapPoses = [];\n    var verticalGuidelines = [];\n    var horizontalGuidelines = [];\n    var snapInfos = [];\n    var _a3 = getRect(poses), width = _a3.width, height = _a3.height, top2 = _a3.top, left2 = _a3.left, bottom2 = _a3.bottom, right2 = _a3.right;\n    var targetRect = {\n      left: left2,\n      right: right2,\n      top: top2,\n      bottom: bottom2,\n      center: (left2 + right2) / 2,\n      middle: (top2 + bottom2) / 2\n    };\n    var hasExternalPoses = externalPoses.length > 0;\n    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};\n    if (!snapRenderInfo.request) {\n      if (snapRenderInfo.direction) {\n        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n      }\n      if (snapRenderInfo.snap) {\n        var rect = getRect(poses);\n        if (snapRenderInfo.center) {\n          rect.middle = (rect.top + rect.bottom) / 2;\n          rect.center = (rect.left + rect.right) / 2;\n        }\n        snapInfos.push(checkSnaps(moveable, rect, 1));\n      }\n      if (hasExternalPoses) {\n        if (snapRenderInfo.center) {\n          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;\n          externalRect.center = (externalRect.left + externalRect.right) / 2;\n        }\n        snapInfos.push(checkSnaps(moveable, externalRect, 1));\n      }\n      snapInfos.forEach(function(snapInfo) {\n        var verticalPosInfos = snapInfo.vertical.posInfos, horizontalPosInfos = snapInfo.horizontal.posInfos;\n        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function(_a4) {\n          var guidelineInfos = _a4.guidelineInfos;\n          return guidelineInfos.some(function(_a5) {\n            var guideline = _a5.guideline;\n            return !guideline.hide;\n          });\n        }).map(function(posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function(_a4) {\n          var guidelineInfos = _a4.guidelineInfos;\n          return guidelineInfos.some(function(_a5) {\n            var guideline = _a5.guideline;\n            return !guideline.hide;\n          });\n        }).map(function(posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));\n        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));\n      });\n    }\n    addBoundGuidelines(moveable, [left2, right2], [top2, bottom2], verticalSnapPoses, horizontalSnapPoses);\n    if (hasExternalPoses) {\n      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);\n    }\n    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines, true), horizontalGuidelines, true);\n    var elementGuidelines = allGuidelines.filter(function(guideline) {\n      return guideline.element && !guideline.gapRects;\n    });\n    var gapGuidelines = allGuidelines.filter(function(guideline) {\n      return guideline.gapRects;\n    });\n    triggerEvent(moveable, \"onSnap\", {\n      guidelines: allGuidelines.filter(function(_a4) {\n        var element = _a4.element;\n        return !element;\n      }),\n      elements: elementGuidelines,\n      gaps: gapGuidelines\n    }, true);\n    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React), true), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React), true), renderGuidelines(moveable, \"horizontal\", horizontalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderGuidelines(moveable, \"vertical\", verticalGuidelines, [targetLeft, targetTop], targetRect, React), true), renderSnapPoses(moveable, \"horizontal\", horizontalSnapPoses, minLeft, targetTop, width, 0, React), true), renderSnapPoses(moveable, \"vertical\", verticalSnapPoses, minTop, targetLeft, height, 1, React), true);\n  },\n  dragStart: function(moveable, e) {\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      snap: true,\n      center: true\n    };\n    snapStart(moveable);\n  },\n  drag: function(moveable) {\n    var state = moveable.state;\n    state.guidelines = getTotalGuidelines(moveable);\n  },\n  pinchStart: function(moveable) {\n    this.unset(moveable);\n  },\n  dragEnd: function(moveable) {\n    this.unset(moveable);\n  },\n  dragControlCondition: function(moveable, e) {\n    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {\n      return true;\n    }\n    if (!e.isRequest && e.inputEvent) {\n      return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n    }\n  },\n  dragControlStart: function(moveable) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragControl: function(moveable) {\n    this.drag(moveable);\n  },\n  dragControlEnd: function(moveable) {\n    this.unset(moveable);\n  },\n  dragGroupStart: function(moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroup: function(moveable) {\n    this.drag(moveable);\n  },\n  dragGroupEnd: function(moveable) {\n    this.unset(moveable);\n  },\n  dragGroupControlStart: function(moveable) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragGroupControl: function(moveable) {\n    this.drag(moveable);\n  },\n  dragGroupControlEnd: function(moveable) {\n    this.unset(moveable);\n  },\n  unset: function(moveable) {\n    var state = moveable.state;\n    state.enableSnap = false;\n    state.guidelines = [];\n    state.snapRenderInfo = null;\n    state.elementRects = [];\n  }\n};\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  render: function(moveable, React) {\n    var _a3 = moveable.props, throttleDragRotate = _a3.throttleDragRotate, zoom = _a3.zoom;\n    var _b3 = moveable.state, dragInfo = _b3.dragInfo, beforeOrigin = _b3.beforeOrigin;\n    if (!throttleDragRotate || !dragInfo) {\n      return [];\n    }\n    var dist = dragInfo.dist;\n    if (!dist[0] && !dist[1]) {\n      return [];\n    }\n    var width = getDistSize(dist);\n    var rad = getRad$1(dist, [0, 0]);\n    return [React.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat(width, \"px\"),\n        transform: \"translate(\".concat(beforeOrigin[0], \"px, \").concat(beforeOrigin[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\")\n      }\n    })];\n  },\n  dragStart: function(moveable, e) {\n    var datas = e.datas, parentEvent = e.parentEvent, parentGesto = e.parentGesto;\n    var state = moveable.state;\n    var target = state.target, gesto = state.gesto;\n    if (gesto) {\n      return false;\n    }\n    state.gesto = parentGesto || moveable.targetGesto;\n    var style = getComputedStyle$2(target);\n    datas.datas = {};\n    datas.left = parseFloat(style.left || \"\") || 0;\n    datas.top = parseFloat(style.top || \"\") || 0;\n    datas.bottom = parseFloat(style.bottom || \"\") || 0;\n    datas.right = parseFloat(style.right || \"\") || 0;\n    datas.startValue = [0, 0];\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(e, \"translate\");\n    startCheckSnapDrag(moveable, datas);\n    datas.prevDist = [0, 0];\n    datas.prevBeforeDist = [0, 0];\n    datas.isDrag = false;\n    datas.deltaOffset = [0, 0];\n    var params = fillParams(moveable, e, __assign$1$1({\n      set: function(translate) {\n        datas.startValue = translate;\n      }\n    }, fillTransformStartEvent(e)));\n    var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n    if (result !== false) {\n      datas.isDrag = true;\n      moveable.state.dragInfo = {\n        startRect: moveable.getRect(),\n        dist: [0, 0]\n      };\n    } else {\n      state.gesto = null;\n      datas.isPinch = false;\n    }\n    return datas.isDrag ? params : false;\n  },\n  drag: function(moveable, e) {\n    if (!e) {\n      return;\n    }\n    resolveTransformEvent(e, \"translate\");\n    var datas = e.datas, parentEvent = e.parentEvent, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest, deltaOffset = e.deltaOffset;\n    var distX = e.distX, distY = e.distY;\n    var isDrag = datas.isDrag, prevDist = datas.prevDist, prevBeforeDist = datas.prevBeforeDist, startValue = datas.startValue;\n    if (!isDrag) {\n      return;\n    }\n    if (deltaOffset) {\n      distX += deltaOffset[0];\n      distY += deltaOffset[1];\n    }\n    var props = moveable.props;\n    var parentMoveable = props.parentMoveable;\n    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;\n    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n    var isSnap = false;\n    var dragRotateRad = 0;\n    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n      var startDragRotate = props.startDragRotate || 0;\n      var deg = throttle(startDragRotate + getRad$1([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;\n      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n      var r2 = getDistSize([rx, ry]);\n      dragRotateRad = deg * Math.PI / 180;\n      distX = r2 * Math.cos(dragRotateRad);\n      distY = r2 * Math.sin(dragRotateRad);\n    }\n    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n      var _a3 = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest || deltaOffset, datas), verticalInfo = _a3[0], horizontalInfo = _a3[1];\n      var isVerticalSnap = verticalInfo.isSnap, isVerticalBound = verticalInfo.isBound, verticalOffset = verticalInfo.offset;\n      var isHorizontalSnap = horizontalInfo.isSnap, isHorizontalBound = horizontalInfo.isBound, horizontalOffset = horizontalInfo.offset;\n      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n      distX += verticalOffset;\n      distY += horizontalOffset;\n    }\n    var beforeTranslate = plus(getBeforeDragDist({\n      datas,\n      distX,\n      distY\n    }), startValue);\n    var translate = plus(getTransformDist({\n      datas,\n      distX,\n      distY\n    }), startValue);\n    if (!throttleDragRotate && !isSnap) {\n      throttleArray(translate, throttleDrag);\n      throttleArray(beforeTranslate, throttleDrag);\n    }\n    var beforeDist = minus(beforeTranslate, startValue);\n    var dist = minus(translate, startValue);\n    var delta = minus(dist, prevDist);\n    var beforeDelta = minus(beforeDist, prevBeforeDist);\n    datas.prevDist = dist;\n    datas.prevBeforeDist = beforeDist;\n    datas.passDelta = delta;\n    datas.passDist = dist;\n    var left2 = datas.left + beforeDist[0];\n    var top2 = datas.top + beforeDist[1];\n    var right2 = datas.right - beforeDist[0];\n    var bottom2 = datas.bottom - beforeDist[1];\n    var nextTransform = convertTransformFormat(datas, \"translate(\".concat(translate[0], \"px, \").concat(translate[1], \"px)\"), \"translate(\".concat(dist[0], \"px, \").concat(dist[1], \"px)\"));\n    fillOriginalTransform(e, nextTransform);\n    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n    if (!parentEvent && !parentMoveable && delta.every(function(num) {\n      return !num;\n    }) && beforeDelta.some(function(num) {\n      return !num;\n    })) {\n      return;\n    }\n    var _b3 = moveable.state, width = _b3.width, height = _b3.height;\n    var params = fillParams(moveable, e, {\n      transform: nextTransform,\n      dist,\n      delta,\n      translate,\n      beforeDist,\n      beforeDelta,\n      beforeTranslate,\n      left: left2,\n      top: top2,\n      right: right2,\n      bottom: bottom2,\n      width,\n      height,\n      isPinch\n    });\n    !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n    return params;\n  },\n  dragAfter: function(moveable, e) {\n    var datas = e.datas;\n    var deltaOffset = datas.deltaOffset;\n    if (deltaOffset[0] || deltaOffset[1]) {\n      datas.deltaOffset = [0, 0];\n      return this.drag(moveable, __assign$1$1(__assign$1$1({}, e), {\n        deltaOffset\n      }));\n    }\n    return false;\n  },\n  dragEnd: function(moveable, e) {\n    var parentEvent = e.parentEvent, datas = e.datas;\n    moveable.state.gesto = null;\n    moveable.state.dragInfo = null;\n    if (!datas.isDrag) {\n      return;\n    }\n    datas.isDrag = false;\n    var param = fillEndParams(moveable, e, {});\n    !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n    return param;\n  },\n  dragGroupStart: function(moveable, e) {\n    var datas = e.datas, clientX = e.clientX, clientY = e.clientY;\n    var params = this.dragStart(moveable, e);\n    if (!params) {\n      return false;\n    }\n    var events = triggerChildGesto(moveable, this, \"dragStart\", [clientX || 0, clientY || 0], e, false);\n    var nextParams = __assign$1$1(__assign$1$1({}, params), {\n      targets: moveable.props.targets,\n      events\n    });\n    var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n    datas.isDrag = result !== false;\n    return datas.isDrag ? params : false;\n  },\n  dragGroup: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isDrag) {\n      return;\n    }\n    var params = this.drag(moveable, e);\n    var passDelta = e.datas.passDelta;\n    var events = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false);\n    if (!params) {\n      return;\n    }\n    var nextParams = __assign$1$1({\n      targets: moveable.props.targets,\n      events\n    }, params);\n    triggerEvent(moveable, \"onDragGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupEnd: function(moveable, e) {\n    var isDrag = e.isDrag, datas = e.datas;\n    if (!datas.isDrag) {\n      return;\n    }\n    this.dragEnd(moveable, e);\n    var events = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false);\n    triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams(moveable, e, {\n      targets: moveable.props.targets,\n      events\n    }));\n    return isDrag;\n  },\n  request: function(moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    return {\n      isControl: false,\n      requestStart: function() {\n        return {\n          datas\n        };\n      },\n      request: function(e) {\n        if (\"x\" in e) {\n          distX = e.x - rect.left;\n        } else if (\"deltaX\" in e) {\n          distX += e.deltaX;\n        }\n        if (\"y\" in e) {\n          distY = e.y - rect.top;\n        } else if (\"deltaY\" in e) {\n          distY += e.deltaY;\n        }\n        return {\n          datas,\n          distX,\n          distY\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas,\n          isDrag: true\n        };\n      }\n    };\n  },\n  unset: function(moveable) {\n    moveable.state.dragInfo = null;\n  }\n};\nfunction calculatePointerDist(moveable, e) {\n  var clientX = e.clientX, clientY = e.clientY, datas = e.datas;\n  var _a3 = moveable.state, moveableClientRect = _a3.moveableClientRect, rootMatrix = _a3.rootMatrix, is3d = _a3.is3d, pos1 = _a3.pos1;\n  var left2 = moveableClientRect.left, top2 = moveableClientRect.top;\n  var n = is3d ? 4 : 3;\n  var _b3 = minus(calculateInversePosition(rootMatrix, [clientX - left2, clientY - top2], n), pos1), posX = _b3[0], posY = _b3[1];\n  var _c3 = getDragDist({\n    datas,\n    distX: posX,\n    distY: posY\n  }), distX = _c3[0], distY = _c3[1];\n  return [distX, distY];\n}\nfunction setDragStart(moveable, _a3) {\n  var datas = _a3.datas;\n  var _b3 = moveable.state, allMatrix = _b3.allMatrix, beforeMatrix = _b3.beforeMatrix, is3d = _b3.is3d, left2 = _b3.left, top2 = _b3.top, origin = _b3.origin, offsetMatrix = _b3.offsetMatrix, targetMatrix = _b3.targetMatrix, transformOrigin = _b3.transformOrigin;\n  var n = is3d ? 4 : 3;\n  datas.is3d = is3d;\n  datas.matrix = allMatrix;\n  datas.targetMatrix = targetMatrix;\n  datas.beforeMatrix = beforeMatrix;\n  datas.offsetMatrix = offsetMatrix;\n  datas.transformOrigin = transformOrigin;\n  datas.inverseMatrix = invert(allMatrix, n);\n  datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n  datas.absoluteOrigin = convertPositionMatrix(plus([left2, top2], origin), n);\n  datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nfunction getTransformDirection(e) {\n  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction resolveTransformEvent(event, functionName) {\n  var datas = event.datas, originalDatas = event.originalDatas.beforeRenderable;\n  var index = datas.transformIndex;\n  var nextTransforms = originalDatas.nextTransforms;\n  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;\n  var nextIndex = 0;\n  if (index === -1) {\n    nextIndex = nextTransforms.length;\n    datas.transformIndex = nextIndex;\n  } else {\n    nextIndex = index + nextTransformAppendedIndexes.filter(function(i2) {\n      return i2 < index;\n    }).length;\n  }\n  var result = convertTransformInfo(nextTransforms, nextIndex);\n  var targetFunction = result.targetFunction;\n  var matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n  datas.beforeFunctionTexts = result.beforeFunctionTexts;\n  datas.afterFunctionTexts = result.afterFunctionTexts;\n  datas.beforeTransform = result.beforeFunctionMatrix;\n  datas.beforeTransform2 = result.beforeFunctionMatrix2;\n  datas.targetTansform = result.targetFunctionMatrix;\n  datas.afterTransform = result.afterFunctionMatrix;\n  datas.afterTransform2 = result.afterFunctionMatrix2;\n  datas.targetAllTransform = result.allFunctionMatrix;\n  if (targetFunction.functionName === matFunctionName) {\n    datas.afterFunctionTexts.splice(0, 1);\n    datas.isAppendTransform = false;\n  } else {\n    datas.isAppendTransform = true;\n    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes, true), [nextIndex], false);\n  }\n}\nfunction convertTransformFormat(datas, value2, dist) {\n  return \"\".concat(datas.beforeFunctionTexts.join(\" \"), \" \").concat(datas.isAppendTransform ? dist : value2, \" \").concat(datas.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(_a3) {\n  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;\n  var _b3 = getBeforeDragDist({\n    datas,\n    distX,\n    distY\n  }), bx = _b3[0], by = _b3[1];\n  var res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nfunction getTransfromMatrix(datas, targetMatrix, isAfter) {\n  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform, beforeTransform2 = datas.beforeTransform2, afterTransform2 = datas.afterTransform2, targetAllTransform = datas.targetAllTransform;\n  var nextTargetMatrix = isAfter ? multiply(targetAllTransform, targetMatrix, 4) : multiply(targetMatrix, targetAllTransform, 4);\n  var res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n  var afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n  return afterTargetMatrix;\n}\nfunction getBeforeDragDist(_a3) {\n  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);\n}\nfunction getDragDist(_a3, isBefore) {\n  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix, inverseMatrix = datas.inverseMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(calculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);\n}\nfunction getInverseDragDist(_a3, isBefore) {\n  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;\n  var beforeMatrix = datas.beforeMatrix, matrix = datas.matrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(calculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);\n}\nfunction calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\n  if (prevWidth === void 0) {\n    prevWidth = width;\n  }\n  if (prevHeight === void 0) {\n    prevHeight = height;\n  }\n  if (prevOrigin === void 0) {\n    prevOrigin = [0, 0];\n  }\n  if (!transformOrigin) {\n    return prevOrigin;\n  }\n  return transformOrigin.map(function(pos, i2) {\n    var _a3 = splitUnit(pos), value2 = _a3.value, unit = _a3.unit;\n    var prevSize = i2 ? prevHeight : prevWidth;\n    var size = i2 ? height : width;\n    if (pos === \"%\" || isNaN(value2)) {\n      var measureRatio = prevSize ? prevOrigin[i2] / prevSize : 0;\n      return size * measureRatio;\n    } else if (unit !== \"%\") {\n      return value2;\n    }\n    return size * value2 / 100;\n  });\n}\nfunction getPosIndexesByDirection(direction) {\n  var indexes = [];\n  if (direction[1] >= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(3);\n    }\n    if (direction[0] <= 0) {\n      indexes.push(2);\n    }\n  }\n  if (direction[1] <= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(1);\n    }\n    if (direction[0] <= 0) {\n      indexes.push(0);\n    }\n  }\n  return indexes;\n}\nfunction getPosesByDirection(poses, direction) {\n  return getPosIndexesByDirection(direction).map(function(index) {\n    return poses[index];\n  });\n}\nfunction getPosByDirection(poses, direction) {\n  var nextPoses = getPosesByDirection(poses, direction);\n  return [average(nextPoses.map(function(pos) {\n    return pos[0];\n  })), average(nextPoses.map(function(pos) {\n    return pos[1];\n  }))];\n}\nfunction getDist(startPos, matrix, width, height, n, fixedDirection) {\n  var poses = calculatePoses(matrix, width, height, n);\n  var fixedPos = getPosByDirection(poses, fixedDirection);\n  var distX = startPos[0] - fixedPos[0];\n  var distY = startPos[1] - fixedPos[1];\n  return [distX, distY];\n}\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\n  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\nfunction getNextTransformMatrix(state, datas, transform) {\n  var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d;\n  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform;\n  var n = is3d ? 4 : 3;\n  var targetTransform = parseMat([transform]);\n  return getNextMatrix(offsetMatrix, convertDimension(multiply(multiply(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);\n}\nfunction scaleMatrix(state, scale) {\n  var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, targetMatrix = state.targetMatrix;\n  var n = is3d ? 4 : 3;\n  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);\n}\nfunction fillTransformStartEvent(e) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  return {\n    setTransform: function(transform, index) {\n      if (index === void 0) {\n        index = -1;\n      }\n      originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n      setTransformIndex(e, index);\n    },\n    setTransformIndex: function(index) {\n      setTransformIndex(e, index);\n    }\n  };\n}\nfunction setDefaultTransformIndex(e, property) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  var startTransforms = originalDatas.startTransforms;\n  setTransformIndex(e, findIndex(startTransforms, function(func) {\n    return func.indexOf(\"\".concat(property, \"(\")) === 0;\n  }));\n}\nfunction setTransformIndex(e, index) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  var datas = e.datas;\n  datas.transformIndex = index;\n  if (index === -1) {\n    return;\n  }\n  var transform = originalDatas.startTransforms[index];\n  if (!transform) {\n    return;\n  }\n  var info = parse([transform]);\n  datas.startValue = info[0].functionValue;\n}\nfunction fillOriginalTransform(e, transform) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  originalDatas.nextTransforms = splitSpace(transform);\n}\nfunction getNextTransformText(e) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  return originalDatas.nextTransforms.join(\" \");\n}\nfunction fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {\n  fillOriginalTransform(e, nextTransform);\n  return {\n    transform: nextTransform,\n    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))\n  };\n}\nfunction getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {\n  var state = moveable.state;\n  var left2 = state.left, top2 = state.top;\n  var groupable = moveable.props.groupable;\n  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n  var groupLeft = groupable ? left2 : 0;\n  var groupTop = groupable ? top2 : 0;\n  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n  var dist = minus(fixedPosition, nextFixedPosition);\n  return minus(dist, [groupLeft, groupTop]);\n}\nfunction getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {\n  var dist = getTranslateDist(moveable, \"scale(\".concat(scaleDist.join(\", \"), \")\"), fixedDirection, fixedPosition, datas);\n  return dist;\n}\nfunction getOriginDirection(moveable) {\n  var _a3 = moveable.state, width = _a3.width, height = _a3.height, transformOrigin = _a3.transformOrigin;\n  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];\n}\nfunction getDirectionOffset(moveable, direction, nextMatrix) {\n  if (nextMatrix === void 0) {\n    nextMatrix = moveable.state.allMatrix;\n  }\n  var _a3 = moveable.state, width = _a3.width, height = _a3.height, is3d = _a3.is3d;\n  var n = is3d ? 4 : 3;\n  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];\n  return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\nfunction getRotateDist(moveable, rotateDist, fixedPosition, datas) {\n  var fixedDirection = getOriginDirection(moveable);\n  return getTranslateDist(moveable, \"rotate(\".concat(rotateDist, \"deg)\"), fixedDirection, fixedPosition, datas);\n}\nfunction getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {\n  var groupable = moveable.props.groupable;\n  var _a3 = moveable.state, prevOrigin = _a3.transformOrigin, targetMatrix = _a3.targetMatrix, offsetMatrix = _a3.offsetMatrix, is3d = _a3.is3d, prevWidth = _a3.width, prevHeight = _a3.height, left2 = _a3.left, top2 = _a3.top;\n  var n = is3d ? 4 : 3;\n  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\n  var groupLeft = groupable ? left2 : 0;\n  var groupTop = groupable ? top2 : 0;\n  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n  return minus(dist, [groupLeft, groupTop]);\n}\nfunction getAbsolutePosition(moveable, direction) {\n  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\nfunction multiply2(pos1, pos2) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\nfunction prefix() {\n  var classNames = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    classNames[_i] = arguments[_i];\n  }\n  return prefixNames.apply(void 0, __spreadArray([PREFIX], classNames, false));\n}\nfunction getTransformMatrix(transform) {\n  if (!transform || transform === \"none\") {\n    return [1, 0, 0, 1, 0, 0];\n  }\n  if (isObject$2(transform)) {\n    return transform;\n  }\n  return parseMat(transform);\n}\nfunction getAbsoluteMatrix(matrix, n, origin) {\n  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function(a2) {\n    return -a2;\n  }), n));\n}\nfunction measureSVGSize(el, unit, isHorizontal) {\n  if (unit === \"%\") {\n    var viewBox = getSVGViewBox(el.ownerSVGElement);\n    return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction getBeforeTransformOrigin(el) {\n  var relativeOrigin = getTransformOrigin(getComputedStyle$2(el, \":before\"));\n  return relativeOrigin.map(function(o, i2) {\n    var _a3 = splitUnit(o), value2 = _a3.value, unit = _a3.unit;\n    return value2 * measureSVGSize(el, unit, i2 === 0);\n  });\n}\nfunction getTransformOrigin(style) {\n  var transformOrigin = style.transformOrigin;\n  return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nfunction getElementTransform(target, computedStyle) {\n  if (computedStyle === void 0) {\n    computedStyle = getComputedStyle$2(target);\n  }\n  var computedTransform = computedStyle.transform;\n  if (computedTransform && computedTransform !== \"none\") {\n    return computedStyle.transform;\n  }\n  if (\"transform\" in target) {\n    var list = target.transform;\n    var baseVal = list.baseVal;\n    if (!baseVal) {\n      return \"\";\n    }\n    var length2 = baseVal.length;\n    if (!length2) {\n      return \"\";\n    }\n    var matrixs = [];\n    var _loop_1 = function(i3) {\n      var matrix = baseVal[0].matrix;\n      matrixs.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(chr) {\n        return matrix[chr];\n      }).join(\", \"), \")\"));\n    };\n    for (var i2 = 0; i2 < length2; ++i2) {\n      _loop_1(i2);\n    }\n    return matrixs.join(\" \");\n  }\n  return \"\";\n}\nfunction getOffsetInfo(el, lastParent, isParent) {\n  var body = document.body;\n  var target = !el || isParent ? el : el.parentElement;\n  var isEnd = el === lastParent || target === lastParent;\n  var position = \"relative\";\n  while (target && target !== body) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n    var style = getComputedStyle$2(target);\n    var tagName = target.tagName.toLowerCase();\n    var transform = getElementTransform(target, style);\n    position = style.position;\n    if (tagName === \"svg\" || position !== \"static\" || transform && transform !== \"none\") {\n      break;\n    }\n    target = target.parentElement;\n    position = \"relative\";\n  }\n  return {\n    isStatic: position === \"static\",\n    isEnd: isEnd || !target || target === body,\n    offsetParent: target || body\n  };\n}\nfunction getOffsetPosInfo(el, style) {\n  var _a3;\n  var tagName = el.tagName.toLowerCase();\n  var offsetLeft = el.offsetLeft;\n  var offsetTop = el.offsetTop;\n  var isSVG = isUndefined(offsetLeft);\n  var hasOffset = !isSVG;\n  var origin;\n  var targetOrigin;\n  if (!hasOffset && tagName !== \"svg\") {\n    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function(pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n    hasOffset = true;\n    _a3 = getSVGGraphicsOffset(el, origin), offsetLeft = _a3[0], offsetTop = _a3[1], origin[0] = _a3[2], origin[1] = _a3[3];\n  } else {\n    origin = getTransformOrigin(style).map(function(pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n  }\n  return {\n    tagName,\n    isSVG,\n    hasOffset,\n    offset: [offsetLeft || 0, offsetTop || 0],\n    origin,\n    targetOrigin\n  };\n}\nfunction getBodyOffset(el, isSVG, style) {\n  if (style === void 0) {\n    style = getComputedStyle$2(el);\n  }\n  var bodyStyle = getComputedStyle$2(document.body);\n  var bodyPosition = bodyStyle.position;\n  if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n    return [0, 0];\n  }\n  var marginLeft = parseInt(bodyStyle.marginLeft, 10);\n  var marginTop = parseInt(bodyStyle.marginTop, 10);\n  if (style.position === \"absolute\") {\n    if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n      marginTop = 0;\n    }\n    if (style.left !== \"auto\" || style.right !== \"auto\") {\n      marginLeft = 0;\n    }\n  }\n  return [marginLeft, marginTop];\n}\nfunction convert3DMatrixes(matrixes) {\n  matrixes.forEach(function(info) {\n    var matrix = info.matrix;\n    if (matrix) {\n      info.matrix = convertDimension(matrix, 3, 4);\n    }\n  });\n}\nfunction getBodyScrollPos() {\n  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];\n}\nfunction getPositionFixedInfo(el) {\n  var fixedContainer = el.parentElement;\n  var hasTransform = false;\n  while (fixedContainer) {\n    var transform = getComputedStyle$2(fixedContainer).transform;\n    if (transform && transform !== \"none\") {\n      hasTransform = true;\n      break;\n    }\n    if (fixedContainer === document.body) {\n      break;\n    }\n    fixedContainer = fixedContainer.parentElement;\n  }\n  return {\n    fixedContainer: fixedContainer || document.body,\n    hasTransform\n  };\n}\nfunction getMatrixStackInfo(target, container, checkContainer) {\n  var el = target;\n  var matrixes = [];\n  var requestEnd = !checkContainer && target === container || target === document.body;\n  var isEnd = requestEnd;\n  var is3d = false;\n  var n = 3;\n  var transformOrigin;\n  var targetTransformOrigin;\n  var targetMatrix;\n  var hasFixed = false;\n  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n  while (el && !isEnd) {\n    isEnd = requestEnd;\n    var style = getComputedStyle$2(el);\n    var position = style.position;\n    var transform = getElementTransform(el, style);\n    var matrix = convertCSStoMatrix(getTransformMatrix(transform));\n    var isFixed = position === \"fixed\";\n    var fixedInfo = {\n      hasTransform: false,\n      fixedContainer: null\n    };\n    if (isFixed) {\n      hasFixed = true;\n      fixedInfo = getPositionFixedInfo(el);\n      offsetContainer = fixedInfo.fixedContainer;\n    }\n    var length2 = matrix.length;\n    if (!is3d && length2 === 16) {\n      is3d = true;\n      n = 4;\n      convert3DMatrixes(matrixes);\n      if (targetMatrix) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n      }\n    }\n    if (is3d && length2 === 9) {\n      matrix = convertDimension(matrix, 3, 4);\n    }\n    var _a3 = getOffsetPosInfo(el, style), tagName = _a3.tagName, hasOffset = _a3.hasOffset, isSVG = _a3.isSVG, origin = _a3.origin, targetOrigin = _a3.targetOrigin, offsetPos = _a3.offset;\n    var offsetLeft = offsetPos[0], offsetTop = offsetPos[1];\n    if (tagName === \"svg\" && targetMatrix) {\n      matrixes.push({\n        type: \"target\",\n        target: el,\n        matrix: getSVGMatrix(el, n)\n      });\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createIdentityMatrix(n)\n      });\n    } else if (tagName === \"g\" && target !== el) {\n      offsetLeft = 0;\n      offsetTop = 0;\n    }\n    var offsetParent = void 0;\n    var isOffsetEnd = false;\n    var isStatic = false;\n    if (isFixed) {\n      offsetParent = fixedInfo.fixedContainer;\n      isOffsetEnd = true;\n    } else {\n      var offsetInfo = getOffsetInfo(el, container);\n      offsetParent = offsetInfo.offsetParent;\n      isOffsetEnd = offsetInfo.isEnd;\n      isStatic = offsetInfo.isStatic;\n    }\n    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n      offsetLeft -= offsetParent.offsetLeft;\n      offsetTop -= offsetParent.offsetTop;\n      requestEnd = requestEnd || isOffsetEnd;\n    }\n    var parentClientLeft = 0;\n    var parentClientTop = 0;\n    var fixedClientLeft = 0;\n    var fixedClientTop = 0;\n    if (isFixed) {\n      if (hasOffset && fixedInfo.hasTransform) {\n        fixedClientLeft = offsetParent.clientLeft;\n        fixedClientTop = offsetParent.clientTop;\n      }\n    } else {\n      if (hasOffset && offsetContainer !== offsetParent) {\n        parentClientLeft = offsetParent.clientLeft;\n        parentClientTop = offsetParent.clientTop;\n      }\n      if (hasOffset && offsetParent === document.body) {\n        var margin = getBodyOffset(el, false, style);\n        offsetLeft += margin[0];\n        offsetTop += margin[1];\n      }\n    }\n    matrixes.push({\n      type: \"target\",\n      target: el,\n      matrix: getAbsoluteMatrix(matrix, n, origin)\n    });\n    if (hasOffset) {\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createOriginMatrix([offsetLeft - el.scrollLeft + parentClientLeft - fixedClientLeft, offsetTop - el.scrollTop + parentClientTop - fixedClientTop], n)\n      });\n    } else {\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        origin\n      });\n    }\n    if (!targetMatrix) {\n      targetMatrix = matrix;\n    }\n    if (!transformOrigin) {\n      transformOrigin = origin;\n    }\n    if (!targetTransformOrigin) {\n      targetTransformOrigin = targetOrigin;\n    }\n    if (isEnd || isFixed) {\n      break;\n    } else {\n      el = offsetParent;\n      requestEnd = isOffsetEnd;\n    }\n    if (!checkContainer || el === document.body) {\n      isEnd = requestEnd;\n    }\n  }\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(n);\n  }\n  if (!transformOrigin) {\n    transformOrigin = [0, 0];\n  }\n  if (!targetTransformOrigin) {\n    targetTransformOrigin = [0, 0];\n  }\n  return {\n    offsetContainer,\n    matrixes,\n    targetMatrix,\n    transformOrigin,\n    targetOrigin: targetTransformOrigin,\n    is3d,\n    hasFixed\n  };\n}\nfunction calculateElementInfo(target, container, rootContainer, isAbsolute3d) {\n  if (rootContainer === void 0) {\n    rootContainer = container;\n  }\n  var width = 0;\n  var height = 0;\n  var rotation = 0;\n  var allResult = {};\n  if (target) {\n    var _a3 = getSize(target), offsetWidth = _a3.offsetWidth, offsetHeight = _a3.offsetHeight;\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  if (target) {\n    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);\n    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);\n    allResult = __assign$1$1(__assign$1$1({}, result), position);\n    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);\n    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n  }\n  var n = isAbsolute3d ? 4 : 3;\n  return __assign$1$1({\n    width,\n    height,\n    rotation,\n    rootMatrix: createIdentityMatrix(n),\n    beforeMatrix: createIdentityMatrix(n),\n    offsetMatrix: createIdentityMatrix(n),\n    allMatrix: createIdentityMatrix(n),\n    targetMatrix: createIdentityMatrix(n),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!isAbsolute3d,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: false\n  }, allResult);\n}\nfunction calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {\n  var _a3;\n  if (rootContainer === void 0) {\n    rootContainer = container;\n  }\n  var _b3 = getMatrixStackInfo(target, container), matrixes = _b3.matrixes, is3d = _b3.is3d, prevTargetMatrix = _b3.targetMatrix, transformOrigin = _b3.transformOrigin, targetOrigin = _b3.targetOrigin, offsetContainer = _b3.offsetContainer, hasFixed = _b3.hasFixed;\n  var _c3 = getMatrixStackInfo(offsetContainer, rootContainer, true), rootMatrixes = _c3.matrixes, isRoot3d = _c3.is3d;\n  var isNext3d = isAbsolute3d || isRoot3d || is3d;\n  var n = isNext3d ? 4 : 3;\n  var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n  var targetMatrix = prevTargetMatrix;\n  var allMatrix = createIdentityMatrix(n);\n  var rootMatrix = createIdentityMatrix(n);\n  var beforeMatrix = createIdentityMatrix(n);\n  var offsetMatrix = createIdentityMatrix(n);\n  var length2 = matrixes.length;\n  rootMatrixes.reverse();\n  matrixes.reverse();\n  if (!is3d && isNext3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n    convert3DMatrixes(matrixes);\n  }\n  if (!isRoot3d && isNext3d) {\n    convert3DMatrixes(rootMatrixes);\n  }\n  rootMatrixes.forEach(function(info) {\n    rootMatrix = multiply(rootMatrix, info.matrix, n);\n  });\n  var originalRootContainer = rootContainer || document.body;\n  var endContainer = ((_a3 = rootMatrixes[0]) === null || _a3 === void 0 ? void 0 : _a3.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function(matrix, info) {\n    return multiply(matrix, info.matrix, n);\n  }, createIdentityMatrix(n));\n  matrixes.forEach(function(info, i2) {\n    if (length2 - 2 === i2) {\n      beforeMatrix = allMatrix.slice();\n    }\n    if (length2 - 1 === i2) {\n      offsetMatrix = allMatrix.slice();\n    }\n    if (!info.matrix) {\n      var nextInfo = matrixes[i2 + 1];\n      var offset2 = getSVGOffset(info, nextInfo, endContainer, n, multiply(rootMatrixBeforeOffset, allMatrix, n));\n      info.matrix = createOriginMatrix(offset2, n);\n    }\n    allMatrix = multiply(allMatrix, info.matrix, n);\n  });\n  var isMatrix3d = !isSVGGraphicElement && is3d;\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n  return {\n    hasFixed,\n    rootMatrix,\n    beforeMatrix,\n    offsetMatrix,\n    allMatrix,\n    targetMatrix,\n    targetTransform,\n    transformOrigin,\n    targetOrigin,\n    is3d: isNext3d\n  };\n}\nfunction makeMatrixCSS(matrix, is3d) {\n  if (is3d === void 0) {\n    is3d = matrix.length > 9;\n  }\n  return \"\".concat(is3d ? \"matrix3d\" : \"matrix\", \"(\").concat(convertMatrixtoCSS(matrix, !is3d).join(\",\"), \")\");\n}\nfunction getSVGViewBox(el) {\n  var clientWidth = el.clientWidth;\n  var clientHeight = el.clientHeight;\n  if (!el) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth,\n      clientHeight\n    };\n  }\n  var viewBox = el.viewBox;\n  var baseVal = viewBox && viewBox.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: baseVal.x,\n    y: baseVal.y,\n    width: baseVal.width || clientWidth,\n    height: baseVal.height || clientHeight,\n    clientWidth,\n    clientHeight\n  };\n}\nfunction getSVGMatrix(el, n) {\n  var _a3 = getSVGViewBox(el), viewBoxWidth = _a3.width, viewBoxHeight = _a3.height, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;\n  var scaleX = clientWidth / viewBoxWidth;\n  var scaleY = clientHeight / viewBoxHeight;\n  var preserveAspectRatio = el.preserveAspectRatio.baseVal;\n  var align = preserveAspectRatio.align;\n  var meetOrSlice = preserveAspectRatio.meetOrSlice;\n  var svgOrigin = [0, 0];\n  var scale = [scaleX, scaleY];\n  var translate = [0, 0];\n  if (align !== 1) {\n    var xAlign = (align - 2) % 3;\n    var yAlign = Math.floor((align - 2) / 3);\n    svgOrigin[0] = viewBoxWidth * xAlign / 2;\n    svgOrigin[1] = viewBoxHeight * yAlign / 2;\n    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n  }\n  var scaleMatrix2 = createScaleMatrix(scale, n);\n  scaleMatrix2[n * (n - 1)] = translate[0], scaleMatrix2[n * (n - 1) + 1] = translate[1];\n  return getAbsoluteMatrix(scaleMatrix2, n, svgOrigin);\n}\nfunction getSVGGraphicsOffset(el, origin) {\n  if (!el.getBBox || el.tagName.toLowerCase() === \"g\") {\n    return [0, 0, 0, 0];\n  }\n  var bbox = el.getBBox();\n  var viewBox = getSVGViewBox(el.ownerSVGElement);\n  var left2 = bbox.x - viewBox.x;\n  var top2 = bbox.y - viewBox.y;\n  return [left2, top2, origin[0] - left2, origin[1] - top2];\n}\nfunction calculatePosition(matrix, pos, n) {\n  return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nfunction calculatePoses(matrix, width, height, n) {\n  return [[0, 0], [width, 0], [0, height], [width, height]].map(function(pos) {\n    return calculatePosition(matrix, pos, n);\n  });\n}\nfunction getRect(poses) {\n  var posesX = poses.map(function(pos) {\n    return pos[0];\n  });\n  var posesY = poses.map(function(pos) {\n    return pos[1];\n  });\n  var left2 = Math.min.apply(Math, posesX);\n  var top2 = Math.min.apply(Math, posesY);\n  var right2 = Math.max.apply(Math, posesX);\n  var bottom2 = Math.max.apply(Math, posesY);\n  var rectWidth = right2 - left2;\n  var rectHeight = bottom2 - top2;\n  return {\n    left: left2,\n    top: top2,\n    right: right2,\n    bottom: bottom2,\n    width: rectWidth,\n    height: rectHeight\n  };\n}\nfunction calculateRect(matrix, width, height, n) {\n  var poses = calculatePoses(matrix, width, height, n);\n  return getRect(poses);\n}\nfunction getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {\n  var _a3;\n  var target = offsetInfo.target;\n  var origin = offsetInfo.origin;\n  var targetMatrix = targetInfo.matrix;\n  var _b3 = getSize(target), width = _b3.offsetWidth, height = _b3.offsetHeight;\n  var containerClientRect = container.getBoundingClientRect();\n  var margin = [0, 0];\n  if (container === document.body) {\n    margin = getBodyOffset(target, true);\n  }\n  var rect = target.getBoundingClientRect();\n  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];\n  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n  var mat = multiplies(n, beforeMatrix, targetMatrix);\n  var _c3 = calculateRect(mat, width, height, n), prevLeft = _c3.left, prevTop = _c3.top, prevWidth = _c3.width, prevHeight = _c3.height;\n  var posOrigin = calculatePosition(mat, origin, n);\n  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];\n  var offset2 = [0, 0];\n  var count = 0;\n  while (++count < 10) {\n    var inverseBeforeMatrix = invert(beforeMatrix, n);\n    _a3 = minus(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset2[0] = _a3[0], offset2[1] = _a3[1];\n    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset2, n), targetMatrix);\n    var _d2 = calculateRect(mat2, width, height, n), nextLeft = _d2.left, nextTop = _d2.top;\n    var distLeft = nextLeft - rectLeft;\n    var distTop = nextTop - rectTop;\n    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n      break;\n    }\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n  return offset2.map(function(p2) {\n    return Math.round(p2);\n  });\n}\nfunction calculateMoveablePosition(matrix, origin, width, height) {\n  var is3d = matrix.length === 16;\n  var n = is3d ? 4 : 3;\n  var poses = calculatePoses(matrix, width, height, n);\n  var _a3 = poses[0], x1 = _a3[0], y1 = _a3[1], _b3 = poses[1], x2 = _b3[0], y2 = _b3[1], _c3 = poses[2], x3 = _c3[0], y3 = _c3[1], _d2 = poses[3], x4 = _d2[0], y4 = _d2[1];\n  var _e = calculatePosition(matrix, origin, n), originX = _e[0], originY = _e[1];\n  var left2 = Math.min(x1, x2, x3, x4);\n  var top2 = Math.min(y1, y2, y3, y4);\n  var right2 = Math.max(x1, x2, x3, x4);\n  var bottom2 = Math.max(y1, y2, y3, y4);\n  x1 = x1 - left2 || 0;\n  x2 = x2 - left2 || 0;\n  x3 = x3 - left2 || 0;\n  x4 = x4 - left2 || 0;\n  y1 = y1 - top2 || 0;\n  y2 = y2 - top2 || 0;\n  y3 = y3 - top2 || 0;\n  y4 = y4 - top2 || 0;\n  originX = originX - left2 || 0;\n  originY = originY - top2 || 0;\n  var direction = getShapeDirection(poses);\n  return {\n    left: left2,\n    top: top2,\n    right: right2,\n    bottom: bottom2,\n    origin: [originX, originY],\n    pos1: [x1, y1],\n    pos2: [x2, y2],\n    pos3: [x3, y3],\n    pos4: [x4, y4],\n    direction\n  };\n}\nfunction getDistSize(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nfunction getDiagonalSize(pos1, pos2) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\nfunction getLineStyle(pos1, pos2, zoom, rad) {\n  if (zoom === void 0) {\n    zoom = 1;\n  }\n  if (rad === void 0) {\n    rad = getRad$1(pos1, pos2);\n  }\n  var width = getDiagonalSize(pos1, pos2);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(pos1[0], \"px, \").concat(pos1[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\"),\n    width: \"\".concat(width, \"px\")\n  };\n}\nfunction getControlTransform(rotation, zoom) {\n  var poses = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    poses[_i - 2] = arguments[_i];\n  }\n  var length2 = poses.length;\n  var x2 = poses.reduce(function(prev2, pos) {\n    return prev2 + pos[0];\n  }, 0) / length2;\n  var y2 = poses.reduce(function(prev2, pos) {\n    return prev2 + pos[1];\n  }, 0) / length2;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(x2, \"px, \").concat(y2, \"px) rotate(\").concat(rotation, \"rad) scale(\").concat(zoom, \")\")\n  };\n}\nfunction getCSSSize(target) {\n  var style = getComputedStyle$2(target);\n  return [parseFloat(style.width), parseFloat(style.height)];\n}\nfunction getSize(target, style) {\n  if (style === void 0) {\n    style = getComputedStyle$2(target);\n  }\n  var hasOffset = !isUndefined(target.offsetWidth);\n  if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n    var bbox = target.getBBox();\n    var offsetWidth = bbox.width;\n    var offsetHeight = bbox.height;\n    return {\n      svg: true,\n      offsetWidth,\n      offsetHeight,\n      clientWidth: offsetWidth,\n      clientHeight: offsetHeight,\n      cssWidth: offsetWidth,\n      cssHeight: offsetHeight\n    };\n  } else {\n    var boxSizing = style.boxSizing === \"border-box\";\n    var borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    var borderRight = parseFloat(style.borderRightWidth) || 0;\n    var borderTop = parseFloat(style.borderTopWidth) || 0;\n    var borderBottom = parseFloat(style.borderBottomWidth) || 0;\n    var paddingLeft = parseFloat(style.paddingLeft) || 0;\n    var paddingRight = parseFloat(style.paddingRight) || 0;\n    var paddingTop = parseFloat(style.paddingTop) || 0;\n    var paddingBottom = parseFloat(style.paddingBottom) || 0;\n    var cssWidth = parseFloat(style.width);\n    var cssHeight = parseFloat(style.height);\n    var offsetWidth = cssWidth;\n    var offsetHeight = cssHeight;\n    var clientWidth = cssWidth;\n    var clientHeight = cssHeight;\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorder = borderLeft + borderRight;\n    var verticalBorder = borderTop + borderBottom;\n    var horizontalOffset = horizontalPadding + horizontalBorder;\n    var verticalOffset = verticalPadding + verticalBorder;\n    if (boxSizing) {\n      cssWidth = offsetWidth - horizontalOffset;\n      cssHeight = offsetHeight - verticalOffset;\n    } else {\n      offsetWidth = cssWidth + horizontalOffset;\n      offsetHeight = cssHeight + verticalOffset;\n    }\n    clientWidth = cssWidth + horizontalPadding;\n    clientHeight = cssHeight + verticalPadding;\n    return {\n      svg: false,\n      offsetWidth,\n      offsetHeight,\n      clientWidth,\n      clientHeight,\n      cssWidth,\n      cssHeight\n    };\n  }\n}\nfunction getRotationRad(poses, direction) {\n  return getRad$1(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nfunction getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {\n  var beforeDirection = 1;\n  var beforeOrigin = [0, 0];\n  var targetClientRect = resetClientRect();\n  var containerClientRect = resetClientRect();\n  var moveableClientRect = resetClientRect();\n  var result = calculateElementInfo(target, container, rootContainer, false);\n  if (target) {\n    var n = result.is3d ? 4 : 3;\n    var beforePosition = calculateMoveablePosition(result.offsetMatrix, plus(result.transformOrigin, getOrigin(result.targetMatrix, n)), result.width, result.height);\n    beforeDirection = beforePosition.direction;\n    beforeOrigin = plus(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);\n    targetClientRect = getClientRect(target);\n    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);\n    if (moveableElement) {\n      moveableClientRect = getClientRect(moveableElement);\n    }\n  }\n  return __assign$1$1({\n    targetClientRect,\n    containerClientRect,\n    moveableClientRect,\n    beforeDirection,\n    beforeOrigin,\n    originalBeforeOrigin: beforeOrigin,\n    target\n  }, result);\n}\nfunction resetClientRect() {\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction getClientRect(el, isExtends) {\n  var _a3;\n  var left2 = 0;\n  var top2 = 0;\n  var width = 0;\n  var height = 0;\n  if (el === document.body || el === document.documentElement) {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    var scrollPos = getBodyScrollPos();\n    _a3 = [-scrollPos[0], -scrollPos[1]], left2 = _a3[0], top2 = _a3[1];\n  } else {\n    var clientRect = el.getBoundingClientRect();\n    left2 = clientRect.left;\n    top2 = clientRect.top;\n    width = clientRect.width;\n    height = clientRect.height;\n  }\n  var rect = {\n    left: left2,\n    right: left2 + width,\n    top: top2,\n    bottom: top2 + height,\n    width,\n    height\n  };\n  if (isExtends) {\n    rect.clientLeft = el.clientLeft;\n    rect.clientTop = el.clientTop;\n    rect.clientWidth = el.clientWidth;\n    rect.clientHeight = el.clientHeight;\n    rect.scrollWidth = el.scrollWidth;\n    rect.scrollHeight = el.scrollHeight;\n    rect.overflow = getComputedStyle$2(el).overflow !== \"visible\";\n  }\n  return rect;\n}\nfunction getDirection(target) {\n  if (!target) {\n    return;\n  }\n  var direciton = target.getAttribute(\"data-direction\");\n  if (!direciton) {\n    return;\n  }\n  var dir = [0, 0];\n  direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n  direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n  direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n  direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n  return dir;\n}\nfunction getAbsolutePoses(poses, dist) {\n  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];\n}\nfunction getAbsolutePosesByState(_a3) {\n  var left2 = _a3.left, top2 = _a3.top, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4;\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left2, top2]);\n}\nfunction roundSign(num) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nfunction unset(self2, name) {\n  var _a3;\n  (_a3 = self2[name]) === null || _a3 === void 0 ? void 0 : _a3.unset();\n  self2[name] = null;\n}\nfunction fillParams(moveable, e, params, isBeforeEvent) {\n  var datas = e.datas;\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n  var nextParams = __assign$1$1(__assign$1$1({}, params), {\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    moveable,\n    datas: datas.datas\n  });\n  if (!datas.isStartEvent) {\n    datas.isStartEvent = true;\n  } else if (!isBeforeEvent) {\n    datas.lastEvent = nextParams;\n  }\n  return nextParams;\n}\nfunction fillEndParams(moveable, e, params) {\n  var datas = e.datas;\n  var isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n  return __assign$1$1(__assign$1$1({\n    isDrag\n  }, params), {\n    moveable,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    lastEvent: datas.lastEvent,\n    isDouble: e.isDouble,\n    datas: datas.datas\n  });\n}\nfunction catchEvent(moveable, name, callback) {\n  moveable._emitter.on(name, callback);\n}\nfunction triggerEvent(moveable, name, params, isManager) {\n  return moveable.triggerEvent(name, params, isManager);\n}\nfunction getComputedStyle$2(el, pseudoElt) {\n  return window.getComputedStyle(el, pseudoElt);\n}\nfunction filterAbles(ables, methods, triggerAblesSimultaneously) {\n  var enabledAbles = {};\n  var ableGroups = {};\n  return ables.filter(function(able) {\n    var name = able.name;\n    if (enabledAbles[name] || !methods.some(function(method) {\n      return able[method];\n    })) {\n      return false;\n    }\n    if (!triggerAblesSimultaneously && able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n      ableGroups[able.ableGroup] = true;\n    }\n    enabledAbles[name] = true;\n    return true;\n  });\n}\nfunction equals(a1, a2) {\n  return a1 === a2 || a1 == null && a2 == null;\n}\nfunction selectValue() {\n  var values = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n  var length2 = values.length - 1;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    var value2 = values[i2];\n    if (!isUndefined(value2)) {\n      return value2;\n    }\n  }\n  return values[length2];\n}\nfunction groupBy(arr, func) {\n  var groups = [];\n  var groupKeys = [];\n  arr.forEach(function(el, index) {\n    var groupKey = func(el, index, arr);\n    var keyIndex = groupKeys.indexOf(groupKey);\n    var group = groups[keyIndex] || [];\n    if (keyIndex === -1) {\n      groupKeys.push(groupKey);\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nfunction groupByMap(arr, func) {\n  var groups = [];\n  var groupKeys = {};\n  arr.forEach(function(el, index) {\n    var groupKey = func(el, index, arr);\n    var group = groupKeys[groupKey];\n    if (!group) {\n      group = [];\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nfunction flat(arr) {\n  return arr.reduce(function(prev2, cur) {\n    return prev2.concat(cur);\n  }, []);\n}\nfunction maxOffset() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  args.sort(function(a2, b2) {\n    return Math.abs(b2) - Math.abs(a2);\n  });\n  return args[0];\n}\nfunction calculateInversePosition(matrix, pos, n) {\n  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);\n}\nfunction convertDragDist(state, e) {\n  var _a3;\n  var is3d = state.is3d, rootMatrix = state.rootMatrix;\n  var n = is3d ? 4 : 3;\n  _a3 = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a3[0], e.distY = _a3[1];\n  return e;\n}\nfunction calculatePadding(matrix, pos, transformOrigin, origin, n) {\n  return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\nfunction convertCSSSize(value2, size, isRelative) {\n  return isRelative ? \"\".concat(value2 / size * 100, \"%\") : \"\".concat(value2, \"px\");\n}\nfunction moveControlPos(controlPoses, index, dist, isRect) {\n  var _a3 = controlPoses[index], direction = _a3.direction, sub = _a3.sub;\n  var dists = controlPoses.map(function() {\n    return [0, 0];\n  });\n  var directions = direction ? direction.split(\"\") : [];\n  if (isRect && index < 8) {\n    var verticalDirection_1 = directions.filter(function(dir) {\n      return dir === \"w\" || dir === \"e\";\n    })[0];\n    var horizontalDirection_1 = directions.filter(function(dir) {\n      return dir === \"n\" || dir === \"s\";\n    })[0];\n    dists[index] = dist;\n    controlPoses.forEach(function(controlPose, i2) {\n      var controlDir = controlPose.direction;\n      if (!controlDir) {\n        return;\n      }\n      if (controlDir.indexOf(verticalDirection_1) > -1) {\n        dists[i2][0] = dist[0];\n      }\n      if (controlDir.indexOf(horizontalDirection_1) > -1) {\n        dists[i2][1] = dist[1];\n      }\n    });\n    if (verticalDirection_1) {\n      dists[1][0] = dist[0] / 2;\n      dists[5][0] = dist[0] / 2;\n    }\n    if (horizontalDirection_1) {\n      dists[3][1] = dist[1] / 2;\n      dists[7][1] = dist[1] / 2;\n    }\n  } else if (direction && !sub) {\n    directions.forEach(function(dir) {\n      var isVertical = dir === \"n\" || dir === \"s\";\n      controlPoses.forEach(function(controlPose, i2) {\n        var dirDir = controlPose.direction, dirHorizontal = controlPose.horizontal, dirVertical = controlPose.vertical;\n        if (!dirDir || dirDir.indexOf(dir) === -1) {\n          return;\n        }\n        dists[i2] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];\n      });\n    });\n  } else {\n    dists[index] = dist;\n  }\n  return dists;\n}\nfunction getTinyDist(v2) {\n  return Math.abs(v2) <= TINY_NUM ? 0 : v2;\n}\nfunction directionCondition(moveable, e) {\n  if (e.isRequest) {\n    if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n      return e.parentDirection;\n    } else {\n      return false;\n    }\n  }\n  return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\nfunction invertObject(obj) {\n  var nextObj = {};\n  for (var name in obj) {\n    nextObj[obj[name]] = name;\n  }\n  return nextObj;\n}\nfunction convertTransformInfo(transforms, index) {\n  var beforeFunctionTexts = transforms.slice(0, index < 0 ? void 0 : index);\n  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? void 0 : index + 1);\n  var targetFunctionText = transforms[index] || \"\";\n  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n  var beforeFunctions = parse(beforeFunctionTexts);\n  var beforeFunctions2 = parse(beforeFunctionTexts2);\n  var targetFunctions = parse([targetFunctionText]);\n  var afterFunctions = parse(afterFunctionTexts);\n  var afterFunctions2 = parse(afterFunctionTexts2);\n  var beforeFunctionMatrix = toMat(beforeFunctions);\n  var beforeFunctionMatrix2 = toMat(beforeFunctions2);\n  var afterFunctionMatrix = toMat(afterFunctions);\n  var afterFunctionMatrix2 = toMat(afterFunctions2);\n  var allFunctionMatrix = multiply(beforeFunctionMatrix, afterFunctionMatrix, 4);\n  return {\n    transforms,\n    beforeFunctionMatrix,\n    beforeFunctionMatrix2,\n    targetFunctionMatrix: toMat(targetFunctions),\n    afterFunctionMatrix,\n    afterFunctionMatrix2,\n    allFunctionMatrix,\n    beforeFunctions,\n    beforeFunctions2,\n    targetFunction: targetFunctions[0],\n    afterFunctions,\n    afterFunctions2,\n    beforeFunctionTexts,\n    beforeFunctionTexts2,\n    targetFunctionText,\n    afterFunctionTexts,\n    afterFunctionTexts2\n  };\n}\nfunction isArrayFormat(arr) {\n  if (!arr || !isObject$2(arr)) {\n    return false;\n  }\n  if (arr instanceof Element) {\n    return false;\n  }\n  return isArray(arr) || \"length\" in arr;\n}\nfunction getRefTarget(target, isSelector) {\n  if (!target) {\n    return null;\n  }\n  if (isString(target)) {\n    if (isSelector) {\n      return document.querySelector(target);\n    }\n    return target;\n  }\n  if (isFunction$2(target)) {\n    return target();\n  }\n  if (\"current\" in target) {\n    return target.current;\n  }\n  return target;\n}\nfunction getRefTargets(targets, isSelector) {\n  if (!targets) {\n    return [];\n  }\n  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n  return userTargets.reduce(function(prev2, target) {\n    if (isString(target) && isSelector) {\n      return __spreadArray(__spreadArray([], prev2, true), [].slice.call(document.querySelectorAll(target)), true);\n    }\n    prev2.push(getRefTarget(target, isSelector));\n    return prev2;\n  }, []);\n}\nfunction getElementTargets(targets, selectorMap) {\n  var elementTargets = [];\n  targets.forEach(function(target) {\n    if (!target) {\n      return;\n    }\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        elementTargets.push.apply(elementTargets, selectorMap[target]);\n      }\n      return;\n    }\n    elementTargets.push(target);\n  });\n  return elementTargets;\n}\nfunction getAbsoluteRotation(pos1, pos2, direction) {\n  var deg = getRad$1(pos1, pos2) / Math.PI * 180;\n  deg = direction >= 0 ? deg : 180 - deg;\n  deg = deg >= 0 ? deg : 360 + deg;\n  return deg;\n}\nfunction getDragDistByState(state, dist) {\n  var rootMatrix = state.rootMatrix, is3d = state.is3d;\n  var n = is3d ? 4 : 3;\n  var inverseMatrix = invert(rootMatrix, n);\n  if (!is3d) {\n    inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n  }\n  inverseMatrix[12] = 0;\n  inverseMatrix[13] = 0;\n  inverseMatrix[14] = 0;\n  return calculateMatrixDist(inverseMatrix, dist);\n}\nfunction getOffsetSizeDist(sizeDirection, keepRatio, datas, e) {\n  var ratio = datas.ratio, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;\n  var distWidth = 0;\n  var distHeight = 0;\n  var distX = e.distX, distY = e.distY, parentDistance = e.parentDistance, parentDist = e.parentDist, parentScale = e.parentScale, isPinch = e.isPinch;\n  var startFixedDirection = datas.fixedDirection;\n  if (parentDist) {\n    distWidth = parentDist[0];\n    distHeight = parentDist[1];\n    if (keepRatio) {\n      if (!distWidth) {\n        distWidth = distHeight * ratio;\n      } else if (!distHeight) {\n        distHeight = distWidth / ratio;\n      }\n    }\n  } else if (parentScale) {\n    distWidth = (parentScale[0] - 1) * startOffsetWidth;\n    distHeight = (parentScale[1] - 1) * startOffsetHeight;\n  } else if (isPinch) {\n    if (parentDistance) {\n      distWidth = parentDistance;\n      distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n    }\n  } else {\n    var dist_1 = getDragDist({\n      datas,\n      distX,\n      distY\n    });\n    dist_1 = [0, 1].map(function(index) {\n      var directionRatio = Math.abs(sizeDirection[index] - startFixedDirection[index]);\n      if (directionRatio !== 0) {\n        directionRatio = 2 / directionRatio;\n      }\n      return dist_1[index] * directionRatio;\n    });\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n      var rad = getRad$1([0, 0], dist_1);\n      var standardRad = getRad$1([0, 0], sizeDirection);\n      var size = getDistSize(dist_1);\n      var signSize = Math.cos(rad - standardRad) * size;\n      if (!sizeDirection[0]) {\n        distHeight = signSize;\n        distWidth = distHeight * ratio;\n      } else if (!sizeDirection[1]) {\n        distWidth = signSize;\n        distHeight = distWidth / ratio;\n      } else {\n        var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;\n        var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;\n        var distSize = getDistSize([startWidthSize + dist_1[0], startHeightSize + dist_1[1]]) - getDistSize([startWidthSize, startHeightSize]);\n        var ratioRad = getRad$1([0, 0], [ratio, 1]);\n        distWidth = Math.cos(ratioRad) * distSize;\n        distHeight = Math.sin(ratioRad) * distSize;\n      }\n    } else {\n      distWidth = sizeDirection[0] * dist_1[0];\n      distHeight = sizeDirection[1] * dist_1[1];\n    }\n  }\n  return {\n    distWidth,\n    distHeight\n  };\n}\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function() {\n    return true;\n  },\n  pinchStart: function(moveable, e) {\n    var datas = e.datas, targets = e.targets, angle = e.angle, originalDatas = e.originalDatas;\n    var _a3 = moveable.props, pinchable = _a3.pinchable, ables = _a3.ables;\n    if (!pinchable) {\n      return false;\n    }\n    var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"Start\");\n    var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlStart\");\n    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function(able) {\n      return pinchable.indexOf(able.name) > -1;\n    })).filter(function(able) {\n      return able.canPinch && able[controlEventName];\n    });\n    var params = fillParams(moveable, e, {});\n    if (targets) {\n      params.targets = targets;\n    }\n    var result = triggerEvent(moveable, eventName, params);\n    datas.isPinch = result !== false;\n    datas.ables = pinchAbles;\n    var isPinch = datas.isPinch;\n    if (!isPinch) {\n      return false;\n    }\n    pinchAbles.forEach(function(able) {\n      originalDatas[able.name] = originalDatas[able.name] || {};\n      if (!able[controlEventName]) {\n        return;\n      }\n      var ableEvent = __assign$1$1(__assign$1$1({}, e), {\n        datas: originalDatas[able.name],\n        parentRotate: angle,\n        isPinch: true\n      });\n      able[controlEventName](moveable, ableEvent);\n    });\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: [0, 0]\n    };\n    return isPinch;\n  },\n  pinch: function(moveable, e) {\n    var datas = e.datas, pinchScale = e.scale, distance = e.distance, originalDatas = e.originalDatas, inputEvent = e.inputEvent, targets = e.targets, angle = e.angle;\n    if (!datas.isPinch) {\n      return;\n    }\n    var parentDistance = distance * (1 - 1 / pinchScale);\n    var params = fillParams(moveable, e, {});\n    if (targets) {\n      params.targets = targets;\n    }\n    var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\");\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"Control\");\n    ables.forEach(function(able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n      able[controlEventName](moveable, __assign$1$1(__assign$1$1({}, e), {\n        datas: originalDatas[able.name],\n        inputEvent,\n        parentDistance,\n        parentRotate: angle,\n        isPinch: true\n      }));\n    });\n    return params;\n  },\n  pinchEnd: function(moveable, e) {\n    var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, targets = e.targets, originalDatas = e.originalDatas;\n    if (!datas.isPinch) {\n      return;\n    }\n    var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"End\");\n    var params = fillEndParams(moveable, e, {\n      isDrag: isPinch\n    });\n    if (targets) {\n      params.targets = targets;\n    }\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlEnd\");\n    ables.forEach(function(able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n      able[controlEventName](moveable, __assign$1$1(__assign$1$1({}, e), {\n        isDrag: isPinch,\n        datas: originalDatas[able.name],\n        inputEvent,\n        isPinch: true\n      }));\n    });\n    return isPinch;\n  },\n  pinchGroupStart: function(moveable, e) {\n    return this.pinchStart(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroup: function(moveable, e) {\n    return this.pinch(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroupEnd: function(moveable, e) {\n    return this.pinchEnd(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  }\n});\nvar Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean,\n    resizeFormat: Function\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onBeforeResize: \"beforeResize\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onBeforeResizeGroup: \"beforeResizeGroup\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: function(moveable, React) {\n    var _a3 = moveable.props, resizable = _a3.resizable, edge = _a3.edge;\n    if (resizable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function(moveable, e) {\n    var _a3;\n    var inputEvent = e.inputEvent, isPinch = e.isPinch, parentDirection = e.parentDirection, datas = e.datas, parentFlag = e.parentFlag;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _b3 = moveable.state, target = _b3.target, width = _b3.width, height = _b3.height;\n    if (!direction || !target) {\n      return false;\n    }\n    !isPinch && setDragStart(moveable, e);\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n    _a3 = getCSSSize(target), datas.startWidth = _a3[0], datas.startHeight = _a3[1];\n    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n    datas.minSize = padding;\n    datas.maxSize = [Infinity, Infinity];\n    if (!parentFlag) {\n      var style = getComputedStyle$2(target);\n      var position = style.position, minWidth = style.minWidth, minHeight = style.minHeight, maxWidth = style.maxWidth, maxHeight = style.maxHeight;\n      var isParentElement = position === \"static\" || position === \"relative\";\n      var container = isParentElement ? target.parentElement : target.offsetParent;\n      var containerWidth = width;\n      var containerHeight = height;\n      if (container) {\n        containerWidth = container.clientWidth;\n        containerHeight = container.clientHeight;\n        if (isParentElement) {\n          var containerStyle = getComputedStyle$2(container);\n          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;\n          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;\n        }\n      }\n      datas.minSize = plus([convertUnitSize(minWidth, containerWidth) || 0, convertUnitSize(minHeight, containerHeight) || 0], padding);\n      datas.maxSize = plus([convertUnitSize(maxWidth, containerWidth) || Infinity, convertUnitSize(maxHeight, containerHeight) || Infinity], padding);\n    }\n    var transformOrigin = moveable.props.transformOrigin || \"% %\";\n    datas.transformOrigin = transformOrigin && isString(transformOrigin) ? transformOrigin.split(\" \") : transformOrigin;\n    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];\n    function setRatio(ratio) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n    function setFixedDirection(fixedDirection) {\n      datas.fixedDirection = fixedDirection;\n      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n    }\n    setRatio(width / height);\n    setFixedDirection([-direction[0], -direction[1]]);\n    datas.setFixedDirection = setFixedDirection;\n    var params = fillParams(moveable, e, {\n      direction,\n      set: function(_a4) {\n        var startWidth = _a4[0], startHeight = _a4[1];\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setMin: function(minSize) {\n        datas.minSize = minSize;\n      },\n      setMax: function(maxSize) {\n        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];\n      },\n      setRatio,\n      setFixedDirection,\n      setOrigin: function(origin) {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    });\n    var result = triggerEvent(moveable, \"onResizeStart\", params);\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction\n      };\n    }\n    return datas.isResize ? params : false;\n  },\n  dragControl: function(moveable, e) {\n    var _a3;\n    var datas = e.datas, parentFlag = e.parentFlag, isPinch = e.isPinch, parentKeepRatio = e.parentKeepRatio, dragClient = e.dragClient, parentDist = e.parentDist, isRequest = e.isRequest;\n    var isResize = datas.isResize, transformOrigin = datas.transformOrigin, startWidth = datas.startWidth, startHeight = datas.startHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight, minSize = datas.minSize, maxSize = datas.maxSize, ratio = datas.ratio, isWidth = datas.isWidth, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;\n    if (!isResize) {\n      return;\n    }\n    var props = moveable.props;\n    var resizeFormat = props.resizeFormat, _b3 = props.throttleResize, throttleResize = _b3 === void 0 ? 1 : _b3, parentMoveable = props.parentMoveable, _c3 = props.snapThreshold, snapThreshold = _c3 === void 0 ? 5 : _c3;\n    var direction = datas.direction;\n    var sizeDirection = direction;\n    var distWidth = 0;\n    var distHeight = 0;\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;\n    function getNextBoundingSize() {\n      var nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n      distWidth = nextSize.distWidth;\n      distHeight = nextSize.distHeight;\n      var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n      var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        if (isWidth) {\n          nextHeight = nextWidth / ratio;\n        } else {\n          nextWidth = nextHeight * ratio;\n        }\n      }\n      return [nextWidth, nextHeight];\n    }\n    var _d2 = getNextBoundingSize(), boundingWidth = _d2[0], boundingHeight = _d2[1];\n    datas.setFixedDirection(datas.fixedDirection);\n    triggerEvent(moveable, \"onBeforeResize\", fillParams(moveable, e, {\n      setFixedDirection: function(nextFixedDirection) {\n        var _a4;\n        datas.setFixedDirection(nextFixedDirection);\n        _a4 = getNextBoundingSize(), boundingWidth = _a4[0], boundingHeight = _a4[1];\n        return [boundingWidth, boundingHeight];\n      },\n      boundingWidth,\n      boundingHeight,\n      setSize: function(size) {\n        boundingWidth = size[0], boundingHeight = size[1];\n      }\n    }, true));\n    var fixedPosition = dragClient;\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n    var snapDist = [0, 0];\n    if (!isPinch) {\n      snapDist = checkSnapResize(moveable, boundingWidth, boundingHeight, direction, fixedPosition, isRequest, datas);\n    }\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n    function computeSize() {\n      var _a4;\n      if (resizeFormat) {\n        _a4 = resizeFormat([boundingWidth, boundingHeight]), boundingWidth = _a4[0], boundingHeight = _a4[1];\n      }\n      boundingWidth = throttle(boundingWidth, throttleResize);\n      boundingHeight = throttle(boundingHeight, throttleResize);\n    }\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n      if (isNoSnap) {\n        computeSize();\n      }\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        boundingWidth += snapDist[0];\n        boundingHeight = boundingWidth / ratio;\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        boundingHeight += snapDist[1];\n        boundingWidth = boundingHeight * ratio;\n      }\n    } else {\n      if (startOffsetWidth + distWidth < -snapThreshold) {\n        snapDist[0] = 0;\n      }\n      if (startOffsetWidth + distHeight < -snapThreshold) {\n        snapDist[1] = 0;\n      }\n      boundingWidth += snapDist[0];\n      boundingHeight += snapDist[1];\n    }\n    _a3 = calculateBoundSize([boundingWidth, boundingHeight], minSize, maxSize, keepRatio), boundingWidth = _a3[0], boundingHeight = _a3[1];\n    computeSize();\n    distWidth = boundingWidth - startOffsetWidth;\n    distHeight = boundingHeight - startOffsetHeight;\n    var delta = [distWidth - prevWidth, distHeight - prevHeight];\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n    var inverseDelta = getResizeDist(moveable, boundingWidth, boundingHeight, datas.fixedDirection, fixedPosition, transformOrigin);\n    if (!parentMoveable && delta.every(function(num) {\n      return !num;\n    }) && inverseDelta.every(function(num) {\n      return !num;\n    })) {\n      return;\n    }\n    var params = fillParams(moveable, e, {\n      width: startWidth + distWidth,\n      height: startHeight + distHeight,\n      offsetWidth: Math.round(boundingWidth),\n      offsetHeight: Math.round(boundingHeight),\n      boundingWidth,\n      boundingHeight,\n      direction,\n      dist: [distWidth, distHeight],\n      delta,\n      isPinch: !!isPinch,\n      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onResize\", params);\n    return params;\n  },\n  dragControlAfter: function(moveable, e) {\n    var datas = e.datas;\n    var isResize = datas.isResize, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight;\n    if (!isResize) {\n      return;\n    }\n    var _a3 = moveable.state, width = _a3.width, height = _a3.height;\n    var errorWidth = width - (startOffsetWidth + prevWidth);\n    var errorHeight = height - (startOffsetHeight + prevHeight);\n    var isErrorWidth = Math.abs(errorWidth) > 3;\n    var isErrorHeight = Math.abs(errorHeight) > 3;\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n    if (isErrorWidth || isErrorHeight) {\n      return this.dragControl(moveable, e);\n    }\n  },\n  dragControlEnd: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isResize) {\n      return;\n    }\n    datas.isResize = false;\n    var params = fillEndParams(moveable, e, {});\n    triggerEvent(moveable, \"onResizeEnd\", params);\n    return params;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n    if (!params) {\n      return false;\n    }\n    var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n    function setDist(child, ev) {\n      var fixedDirection = datas.fixedDirection;\n      var fixedPosition = datas.fixedPosition;\n      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n      var pos = getPosByDirection(startPositions, fixedDirection);\n      var _a3 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a3[0], originalY = _a3[1];\n      ev.datas.originalX = originalX;\n      ev.datas.originalY = originalY;\n      return ev;\n    }\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n      return setDist(child, ev);\n    });\n    var setFixedDirection = function(fixedDirection) {\n      params.setFixedDirection(fixedDirection);\n      events.forEach(function(ev, i2) {\n        ev.setFixedDirection(fixedDirection);\n        setDist(ev.moveable, originalEvents[i2]);\n      });\n    };\n    datas.setFixedDirection = setFixedDirection;\n    var nextParams = __assign$1$1(__assign$1$1({}, params), {\n      targets: moveable.props.targets,\n      events,\n      setFixedDirection\n    });\n    var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isResize) {\n      return;\n    }\n    catchEvent(moveable, \"onBeforeResize\", function(parentEvent) {\n      triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams(moveable, e, __assign$1$1(__assign$1$1({}, parentEvent), {\n        targets: moveable.props.targets\n      }), true));\n    });\n    var params = this.dragControl(moveable, e);\n    if (!params) {\n      return;\n    }\n    var boundingWidth = params.boundingWidth, boundingHeight = params.boundingHeight, dist = params.dist;\n    var keepRatio = moveable.props.keepRatio;\n    var parentScale = [boundingWidth / (boundingWidth - dist[0]), boundingHeight / (boundingHeight - dist[1])];\n    var fixedPosition = datas.fixedPosition;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_2, ev) {\n      var _a3 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3), clientX = _a3[0], clientY = _a3[1];\n      return __assign$1$1(__assign$1$1({}, ev), {\n        parentDist: null,\n        parentScale,\n        dragClient: plus(fixedPosition, [clientX, clientY]),\n        parentKeepRatio: keepRatio\n      });\n    });\n    var nextParams = __assign$1$1({\n      targets: moveable.props.targets,\n      events\n    }, params);\n    triggerEvent(moveable, \"onResizeGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    var isDrag = e.isDrag, datas = e.datas;\n    if (!datas.isResize) {\n      return;\n    }\n    this.dragControlEnd(moveable, e);\n    var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets,\n      events\n    });\n    triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n    return isDrag;\n  },\n  request: function(moveable) {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    var rect = moveable.getRect();\n    return {\n      isControl: true,\n      requestStart: function(e) {\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function(e) {\n        if (\"offsetWidth\" in e) {\n          distWidth = e.offsetWidth - rect.offsetWidth;\n        } else if (\"deltaWidth\" in e) {\n          distWidth += e.deltaWidth;\n        }\n        if (\"offsetHeight\" in e) {\n          distHeight = e.offsetHeight - rect.offsetHeight;\n        } else if (\"deltaHeight\" in e) {\n          distHeight += e.deltaHeight;\n        }\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\nvar Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onBeforeScale: \"beforeScale\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onBeforeScaleGroup: \"beforeScaleGroup\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: function(moveable, React) {\n    var _a3 = moveable.props, resizable = _a3.resizable, scalable = _a3.scalable, edge = _a3.edge;\n    if (!resizable && scalable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function(moveable, e) {\n    var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, parentDirection = e.parentDirection;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _a3 = moveable.state, width = _a3.width, height = _a3.height, targetTransform = _a3.targetTransform, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos4 = _a3.pos4;\n    if (!direction || !target) {\n      return false;\n    }\n    if (!isPinch) {\n      setDragStart(moveable, e);\n    }\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.startValue = [1, 1];\n    var scaleWidth = getDist$2(pos1, pos2);\n    var scaleHeight = getDist$2(pos2, pos4);\n    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];\n    datas.scaleWidth = scaleWidth;\n    datas.scaleHeight = scaleHeight;\n    datas.scaleXRatio = scaleWidth / width;\n    datas.scaleYRatio = scaleHeight / height;\n    setDefaultTransformIndex(e, \"scale\");\n    datas.isWidth = isWidth;\n    function setRatio(ratio) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n    function setFixedDirection(fixedDirection) {\n      datas.fixedDirection = fixedDirection;\n      datas.fixedPosition = getPosByDirection(datas.startPositions, fixedDirection);\n    }\n    datas.setFixedDirection = setFixedDirection;\n    setRatio(getDist$2(pos1, pos2) / getDist$2(pos2, pos4));\n    setFixedDirection([-direction[0], -direction[1]]);\n    var params = fillParams(moveable, e, __assign$1$1(__assign$1$1({\n      direction,\n      set: function(scale) {\n        datas.startValue = scale;\n      },\n      setRatio,\n      setFixedDirection\n    }, fillTransformStartEvent(e)), {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    }));\n    var result = triggerEvent(moveable, \"onScaleStart\", params);\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction\n      };\n    }\n    return datas.isScale ? params : false;\n  },\n  dragControl: function(moveable, e) {\n    resolveTransformEvent(e, \"scale\");\n    var datas = e.datas, parentKeepRatio = e.parentKeepRatio, parentFlag = e.parentFlag, isPinch = e.isPinch, dragClient = e.dragClient, isRequest = e.isRequest;\n    var prevDist = datas.prevDist, direction = datas.direction, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, isScale = datas.isScale, startValue = datas.startValue, isWidth = datas.isWidth, ratio = datas.ratio;\n    if (!isScale) {\n      return false;\n    }\n    var props = moveable.props;\n    var throttleScale = props.throttleScale, parentMoveable = props.parentMoveable;\n    var sizeDirection = direction;\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    var keepRatio = ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio) || false;\n    var state = moveable.state;\n    function getNextScale() {\n      var _a3 = getOffsetSizeDist(sizeDirection, keepRatio, datas, e), distWidth = _a3.distWidth, distHeight = _a3.distHeight;\n      var scaleX = (startOffsetWidth + distWidth) / startOffsetWidth;\n      var scaleY = (startOffsetHeight + distHeight) / startOffsetHeight;\n      scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n      scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n      if (scaleX === 0) {\n        scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n      }\n      if (scaleY === 0) {\n        scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n      }\n      return [scaleX, scaleY];\n    }\n    var scale = getNextScale();\n    if (!isPinch && moveable.props.groupable) {\n      var snapRenderInfo = state.snapRenderInfo || {};\n      var stateDirection = snapRenderInfo.direction;\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = {\n          direction,\n          request: e.isRequest\n        };\n      }\n    }\n    triggerEvent(moveable, \"onBeforeScale\", fillParams(moveable, e, {\n      scale,\n      setFixedDirection: function(nextFixedDirection) {\n        datas.setFixedDirection(nextFixedDirection);\n        scale = getNextScale();\n        return scale;\n      },\n      setScale: function(nextScale) {\n        scale = nextScale;\n      }\n    }, true));\n    var dist = [scale[0] / startValue[0], scale[1] / startValue[1]];\n    var fixedPosition = dragClient;\n    var snapDist = [0, 0];\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n    if (!isPinch) {\n      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);\n    }\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n      if (isNoSnap) {\n        if (isWidth) {\n          dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];\n        } else {\n          dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];\n        }\n      }\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        dist[0] += snapDist[0];\n        var snapHeight = startOffsetWidth * dist[0] * startValue[0] / ratio;\n        dist[1] = snapHeight / startOffsetHeight / startValue[1];\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        dist[1] += snapDist[1];\n        var snapWidth = startOffsetHeight * dist[1] * startValue[1] * ratio;\n        dist[0] = snapWidth / startOffsetWidth / startValue[0];\n      }\n    } else {\n      dist[0] += snapDist[0];\n      dist[1] += snapDist[1];\n      if (!snapDist[0]) {\n        dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];\n      }\n      if (!snapDist[1]) {\n        dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];\n      }\n    }\n    if (dist[0] === 0) {\n      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n    if (dist[1] === 0) {\n      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n    scale = multiply2(dist, startValue);\n    var inverseDist = getScaleDist(moveable, dist, datas.fixedDirection, fixedPosition, datas);\n    var inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n    datas.prevDist = dist;\n    datas.prevInverseDist = inverseDist;\n    if (scale[0] === prevDist[0] && scale[1] === prevDist[1] && inverseDelta.every(function(num) {\n      return !num;\n    }) && !parentMoveable) {\n      return false;\n    }\n    var nextTransform = convertTransformFormat(datas, \"scale(\".concat(scale.join(\", \"), \")\"), \"scale(\".concat(dist.join(\", \"), \")\"));\n    var params = fillParams(moveable, e, __assign$1$1({\n      offsetWidth: startOffsetWidth,\n      offsetHeight: startOffsetHeight,\n      direction,\n      scale,\n      dist,\n      delta,\n      isPinch: !!isPinch\n    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\n    triggerEvent(moveable, \"onScale\", params);\n    return params;\n  },\n  dragControlEnd: function(moveable, e) {\n    var datas = e.datas, isDrag = e.isDrag;\n    if (!datas.isScale) {\n      return false;\n    }\n    datas.isScale = false;\n    triggerEvent(moveable, \"onScaleEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n    if (!params) {\n      return false;\n    }\n    var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n    function setDist(child, ev) {\n      var fixedDirection = datas.fixedDirection;\n      var fixedPosition = datas.fixedPosition;\n      var startPositions = ev.datas.startPositions || getAbsolutePosesByState(child.state);\n      var pos = getPosByDirection(startPositions, fixedDirection);\n      var _a3 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a3[0], originalY = _a3[1];\n      ev.datas.originalX = originalX;\n      ev.datas.originalY = originalY;\n      return ev;\n    }\n    datas.moveableScale = moveable.scale;\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function(child, ev) {\n      return setDist(child, ev);\n    });\n    var setFixedDirection = function(fixedDirection) {\n      params.setFixedDirection(fixedDirection);\n      events.forEach(function(ev, i2) {\n        ev.setFixedDirection(fixedDirection);\n        setDist(ev.moveable, originalEvents[i2]);\n      });\n    };\n    datas.setFixedDirection = setFixedDirection;\n    var nextParams = __assign$1$1(__assign$1$1({}, params), {\n      targets: moveable.props.targets,\n      events,\n      setFixedDirection\n    });\n    var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isScale) {\n      return;\n    }\n    catchEvent(moveable, \"onBeforeScale\", function(parentEvent) {\n      triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams(moveable, e, __assign$1$1(__assign$1$1({}, parentEvent), {\n        targets: moveable.props.targets\n      }), true));\n    });\n    var params = this.dragControl(moveable, e);\n    if (!params) {\n      return;\n    }\n    var moveableScale = datas.moveableScale;\n    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];\n    var keepRatio = moveable.props.keepRatio;\n    var dist = params.dist, scale = params.scale;\n    var fixedPosition = datas.fixedPosition;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function(_2, ev) {\n      var _a3 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3), clientX = _a3[0], clientY = _a3[1];\n      return __assign$1$1(__assign$1$1({}, ev), {\n        parentDist: null,\n        parentScale: scale,\n        parentKeepRatio: keepRatio,\n        dragClient: plus(fixedPosition, [clientX, clientY])\n      });\n    });\n    var nextParams = __assign$1$1({\n      targets: moveable.props.targets,\n      events\n    }, params);\n    triggerEvent(moveable, \"onScaleGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    var isDrag = e.isDrag, datas = e.datas;\n    if (!datas.isScale) {\n      return;\n    }\n    this.dragControlEnd(moveable, e);\n    var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets,\n      events\n    });\n    triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n    return isDrag;\n  },\n  request: function() {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    return {\n      isControl: true,\n      requestStart: function(e) {\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function(e) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\nfunction getMiddleLinePos(pos1, pos2) {\n  return pos1.map(function(pos, i2) {\n    return dot(pos, pos2[i2], 1, 2);\n  });\n}\nfunction getTriangleRad(pos1, pos2, pos3) {\n  var rad1 = getRad$1(pos1, pos2);\n  var rad2 = getRad$1(pos1, pos3);\n  var rad = rad2 - rad1;\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\nfunction isValidPos(poses1, poses2) {\n  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  var pi = Math.PI;\n  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {\n    return false;\n  }\n  return true;\n}\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  render: function(moveable, React) {\n    var _a3 = moveable.props, resizable = _a3.resizable, scalable = _a3.scalable, warpable = _a3.warpable, zoom = _a3.zoom;\n    if (resizable || scalable || !warpable) {\n      return [];\n    }\n    var _b3 = moveable.state, pos1 = _b3.pos1, pos2 = _b3.pos2, pos3 = _b3.pos3, pos4 = _b3.pos4;\n    var linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    var linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    var linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    var linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    var linePosTo1 = getMiddleLinePos(pos3, pos4);\n    var linePosTo2 = getMiddleLinePos(pos4, pos3);\n    var linePosTo3 = getMiddleLinePos(pos2, pos4);\n    var linePosTo4 = getMiddleLinePos(pos4, pos2);\n    return __spreadArray([React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(linePosFrom1, linePosTo1, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(linePosFrom2, linePosTo2, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(linePosFrom3, linePosTo3, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(linePosFrom4, linePosTo4, zoom)\n    })], renderAllDirections(moveable, React), true);\n  },\n  dragControlCondition: function(moveable, e) {\n    if (e.isRequest) {\n      return false;\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n  },\n  dragControlStart: function(moveable, e) {\n    var datas = e.datas, inputEvent = e.inputEvent;\n    var target = moveable.props.target;\n    var inputTarget = inputEvent.target;\n    var direction = getDirection(inputTarget);\n    if (!direction || !target) {\n      return false;\n    }\n    var state = moveable.state;\n    var transformOrigin = state.transformOrigin, is3d = state.is3d, targetTransform = state.targetTransform, targetMatrix = state.targetMatrix, width = state.width, height = state.height, left2 = state.left, top2 = state.top;\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n    datas.direction = direction;\n    datas.left = left2;\n    datas.top = top2;\n    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function(p2) {\n      return minus(p2, transformOrigin);\n    });\n    datas.nextPoses = datas.poses.map(function(_a3) {\n      var x2 = _a3[0], y2 = _a3[1];\n      return calculate(datas.warpTargetMatrix, [x2, y2, 0, 1], 4);\n    });\n    datas.startValue = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(e, \"matrix3d\");\n    state.snapRenderInfo = {\n      request: e.isRequest,\n      direction\n    };\n    var params = fillParams(moveable, e, __assign$1$1({\n      set: function(matrix) {\n        datas.startValue = matrix;\n      }\n    }, fillTransformStartEvent(e)));\n    var result = triggerEvent(moveable, \"onWarpStart\", params);\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n    return datas.isWarp;\n  },\n  dragControl: function(moveable, e) {\n    var datas = e.datas, isRequest = e.isRequest;\n    var distX = e.distX, distY = e.distY;\n    var targetInverseMatrix = datas.targetInverseMatrix, prevMatrix = datas.prevMatrix, isWarp = datas.isWarp, startValue = datas.startValue, poses = datas.poses, posIndexes = datas.posIndexes, absolutePoses = datas.absolutePoses;\n    if (!isWarp) {\n      return false;\n    }\n    resolveTransformEvent(e, \"matrix3d\");\n    if (hasGuidelines(moveable, \"warpable\")) {\n      var selectedPoses = posIndexes.map(function(index) {\n        return absolutePoses[index];\n      });\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);\n      }\n      var _a3 = checkMoveableSnapBounds(moveable, isRequest, {\n        horizontal: selectedPoses.map(function(pos) {\n          return pos[1] + distY;\n        }),\n        vertical: selectedPoses.map(function(pos) {\n          return pos[0] + distX;\n        })\n      }), horizontalSnapInfo = _a3.horizontal, verticalSnapInfo = _a3.vertical;\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n    var dist = getDragDist({\n      datas,\n      distX,\n      distY\n    }, true);\n    var nextPoses = datas.nextPoses.slice();\n    posIndexes.forEach(function(index) {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n    if (!NEARBY_POS.every(function(nearByPoses) {\n      return isValidPos(nearByPoses.map(function(i2) {\n        return poses[i2];\n      }), nearByPoses.map(function(i2) {\n        return nextPoses[i2];\n      }));\n    })) {\n      return false;\n    }\n    var h2 = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);\n    if (!h2.length) {\n      return false;\n    }\n    var afterMatrix = multiply(targetInverseMatrix, h2, 4);\n    var matrix = getTransfromMatrix(datas, afterMatrix, true);\n    var delta = multiply(invert(prevMatrix, 4), matrix, 4);\n    datas.prevMatrix = matrix;\n    var totalMatrix = multiply(startValue, matrix, 4);\n    var nextTransform = convertTransformFormat(datas, \"matrix3d(\".concat(totalMatrix.join(\", \"), \")\"), \"matrix3d(\".concat(matrix.join(\", \"), \")\"));\n    fillOriginalTransform(e, nextTransform);\n    triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, {\n      delta,\n      matrix: totalMatrix,\n      dist: matrix,\n      multiply,\n      transform: nextTransform\n    }));\n    return true;\n  },\n  dragControlEnd: function(moveable, e) {\n    var datas = e.datas, isDrag = e.isDrag;\n    if (!datas.isWarp) {\n      return false;\n    }\n    datas.isWarp = false;\n    triggerEvent(moveable, \"onWarpEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  }\n};\nvar AREA_PIECES = /* @__PURE__ */ prefix(\"area-pieces\");\nvar AREA_PIECE = /* @__PURE__ */ prefix(\"area-piece\");\nvar AVOID = /* @__PURE__ */ prefix(\"avoid\");\nfunction restoreStyle(moveable) {\n  var el = moveable.areaElement;\n  if (!el) {\n    return;\n  }\n  var _a3 = moveable.state, width = _a3.width, height = _a3.height;\n  removeClass(el, AVOID);\n  el.style.cssText += \"left: 0px; top: 0px; width: \".concat(width, \"px; height: \").concat(height, \"px\");\n}\nfunction renderPieces(React) {\n  return React.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function(moveable, React) {\n    var _a3 = moveable.props, target = _a3.target, dragArea = _a3.dragArea, groupable = _a3.groupable, passDragArea = _a3.passDragArea;\n    var _b3 = moveable.state, width = _b3.width, height = _b3.height, renderPoses = _b3.renderPoses;\n    var className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (groupable) {\n      return [React.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(moveable, \"areaElement\"),\n        className\n      }), renderPieces(React)];\n    }\n    if (!target || !dragArea) {\n      return [];\n    }\n    var h2 = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);\n    var transform = h2.length ? makeMatrixCSS(h2, true) : \"none\";\n    return [React.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(moveable, \"areaElement\"),\n      className,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(width, \"px\"),\n        height: \"\".concat(height, \"px\"),\n        transformOrigin: \"0 0\",\n        transform\n      }\n    }), renderPieces(React)];\n  },\n  dragStart: function(moveable, _a3) {\n    var datas = _a3.datas, clientX = _a3.clientX, clientY = _a3.clientY, inputEvent = _a3.inputEvent;\n    if (!inputEvent) {\n      return false;\n    }\n    datas.isDragArea = false;\n    var areaElement = moveable.areaElement;\n    var state = moveable.state;\n    var moveableClientRect = state.moveableClientRect, renderPoses = state.renderPoses, rootMatrix = state.rootMatrix, is3d = state.is3d;\n    var left2 = moveableClientRect.left, top2 = moveableClientRect.top;\n    var _b3 = getRect(renderPoses), relativeLeft = _b3.left, relativeTop = _b3.top, width = _b3.width, height = _b3.height;\n    var n = is3d ? 4 : 3;\n    var _c3 = calculateInversePosition(rootMatrix, [clientX - left2, clientY - top2], n), posX = _c3[0], posY = _c3[1];\n    posX -= relativeLeft;\n    posY -= relativeTop;\n    var rects = [{\n      left: relativeLeft,\n      top: relativeTop,\n      width,\n      height: posY - 10\n    }, {\n      left: relativeLeft,\n      top: relativeTop,\n      width: posX - 10,\n      height\n    }, {\n      left: relativeLeft,\n      top: relativeTop + posY + 10,\n      width,\n      height: height - posY - 10\n    }, {\n      left: relativeLeft + posX + 10,\n      top: relativeTop,\n      width: width - posX - 10,\n      height\n    }];\n    var children = [].slice.call(areaElement.nextElementSibling.children);\n    rects.forEach(function(rect, i2) {\n      children[i2].style.cssText = \"left: \".concat(rect.left, \"px;top: \").concat(rect.top, \"px; width: \").concat(rect.width, \"px; height: \").concat(rect.height, \"px;\");\n    });\n    addClass(areaElement, AVOID);\n    state.disableNativeEvent = true;\n    return;\n  },\n  drag: function(moveable, _a3) {\n    var datas = _a3.datas, inputEvent = _a3.inputEvent;\n    this.enableNativeEvent(moveable);\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd: function(moveable, e) {\n    this.enableNativeEvent(moveable);\n    var inputEvent = e.inputEvent, datas = e.datas;\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      restoreStyle(moveable);\n    }\n  },\n  dragGroupStart: function(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup: function(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd: function(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  unset: function(moveable) {\n    restoreStyle(moveable);\n    moveable.state.disableNativeEvent = false;\n  },\n  enableNativeEvent: function(moveable) {\n    var state = moveable.state;\n    if (state.disableNativeEvent) {\n      requestAnimationFrame$1(function() {\n        state.disableNativeEvent = false;\n      });\n    }\n  }\n};\nvar Origin = makeAble(\"origin\", {\n  render: function(moveable, React) {\n    var zoom = moveable.props.zoom;\n    var _a3 = moveable.state, beforeOrigin = _a3.beforeOrigin, rotation = _a3.rotation;\n    return [React.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(rotation, zoom, beforeOrigin),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction getDefaultScrollPosition(e) {\n  var scrollContainer = e.scrollContainer;\n  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];\n}\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: true,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragRelation: \"strong\",\n  dragStart: function(moveable, e) {\n    var props = moveable.props;\n    var _a3 = props.scrollContainer, scrollContainer = _a3 === void 0 ? moveable.getContainer() : _a3;\n    var dragScroll = new DragScroll$1();\n    var scrollContainerElement = getRefTarget(scrollContainer, true);\n    e.datas.dragScroll = dragScroll;\n    var gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n    var targets = e.targets;\n    dragScroll.on(\"scroll\", function(_a4) {\n      var container = _a4.container, direction = _a4.direction;\n      var params = fillParams(moveable, e, {\n        scrollContainer: container,\n        direction\n      });\n      var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\n      if (targets) {\n        params.targets = targets;\n      }\n      triggerEvent(moveable, eventName, params);\n    }).on(\"move\", function(_a4) {\n      var offsetX = _a4.offsetX, offsetY = _a4.offsetY;\n      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n    });\n    dragScroll.dragStart(e, {\n      container: scrollContainerElement\n    });\n  },\n  checkScroll: function(moveable, e) {\n    var dragScroll = e.datas.dragScroll;\n    if (!dragScroll) {\n      return;\n    }\n    var _a3 = moveable.props, _b3 = _a3.scrollContainer, scrollContainer = _b3 === void 0 ? moveable.getContainer() : _b3, _c3 = _a3.scrollThreshold, scrollThreshold = _c3 === void 0 ? 0 : _c3, _d2 = _a3.getScrollPosition, getScrollPosition = _d2 === void 0 ? getDefaultScrollPosition : _d2;\n    dragScroll.drag(e, {\n      container: scrollContainer,\n      threshold: scrollThreshold,\n      getScrollPosition: function(ev) {\n        return getScrollPosition({\n          scrollContainer: ev.container,\n          direction: ev.direction\n        });\n      }\n    });\n    return true;\n  },\n  drag: function(moveable, e) {\n    return this.checkScroll(moveable, e);\n  },\n  dragEnd: function(moveable, e) {\n    e.datas.dragScroll.dragEnd();\n    e.datas.dragScroll = null;\n  },\n  dragControlStart: function(moveable, e) {\n    return this.dragStart(moveable, __assign$1$1(__assign$1$1({}, e), {\n      isControl: true\n    }));\n  },\n  dragControl: function(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupStart: function(moveable, e) {\n    return this.dragStart(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroup: function(moveable, e) {\n    return this.drag(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupEnd: function(moveable, e) {\n    return this.dragEnd(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControlStart: function(moveable, e) {\n    return this.dragStart(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets,\n      isControl: true\n    }));\n  },\n  dragGroupContro: function(moveable, e) {\n    return this.drag(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControEnd: function(moveable, e) {\n    return this.dragEnd(moveable, __assign$1$1(__assign$1$1({}, e), {\n      targets: moveable.props.targets\n    }));\n  }\n};\nvar Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    useResizeObserver: Boolean,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Boolean,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    hideDefaultLines: Boolean,\n    props: Object\n  },\n  events: {}\n};\nvar Padding = makeAble(\"padding\", {\n  render: function(moveable, React) {\n    var props = moveable.props;\n    if (props.dragArea) {\n      return [];\n    }\n    var padding = props.padding || {};\n    var _a3 = padding.left, left2 = _a3 === void 0 ? 0 : _a3, _b3 = padding.top, top2 = _b3 === void 0 ? 0 : _b3, _c3 = padding.right, right2 = _c3 === void 0 ? 0 : _c3, _d2 = padding.bottom, bottom2 = _d2 === void 0 ? 0 : _d2;\n    var _e = moveable.state, renderPoses = _e.renderPoses, pos1 = _e.pos1, pos2 = _e.pos2, pos3 = _e.pos3, pos4 = _e.pos4;\n    var poses = [pos1, pos2, pos3, pos4];\n    var paddingDirections = [];\n    if (left2 > 0) {\n      paddingDirections.push([0, 2]);\n    }\n    if (top2 > 0) {\n      paddingDirections.push([0, 1]);\n    }\n    if (right2 > 0) {\n      paddingDirections.push([1, 3]);\n    }\n    if (bottom2 > 0) {\n      paddingDirections.push([2, 3]);\n    }\n    return paddingDirections.map(function(_a4, i2) {\n      var dir1 = _a4[0], dir2 = _a4[1];\n      var paddingPos1 = poses[dir1];\n      var paddingPos2 = poses[dir2];\n      var paddingPos3 = renderPoses[dir1];\n      var paddingPos4 = renderPoses[dir2];\n      var h2 = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);\n      if (!h2.length) {\n        return void 0;\n      }\n      return React.createElement(\"div\", {\n        key: \"padding\".concat(i2),\n        className: prefix(\"padding\"),\n        style: {\n          transform: makeMatrixCSS(h2, true)\n        }\n      });\n    });\n  }\n});\nvar RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction calculateRatio(values, size) {\n  var sumSize = values[0] + values[1];\n  var sumRatio = sumSize > size ? size / sumSize : 1;\n  values[0] *= sumRatio;\n  values[1] = size - values[1] * sumRatio;\n  return values;\n}\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nvar VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nvar HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];\nvar VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\nfunction getRadiusStyles(poses, controlPoses, isRelative, width, height, left2, top2, right2, bottom2) {\n  if (left2 === void 0) {\n    left2 = 0;\n  }\n  if (top2 === void 0) {\n    top2 = 0;\n  }\n  if (right2 === void 0) {\n    right2 = width;\n  }\n  if (bottom2 === void 0) {\n    bottom2 = height;\n  }\n  var clipStyles = [];\n  var isVertical = false;\n  var raws = poses.map(function(pos, i2) {\n    var _a3 = controlPoses[i2], horizontal = _a3.horizontal, vertical = _a3.vertical;\n    if (vertical && !isVertical) {\n      isVertical = true;\n      clipStyles.push(\"/\");\n    }\n    if (isVertical) {\n      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top2 : bottom2 - pos[1]);\n      clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n      return rawPos;\n    } else {\n      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left2 : right2 - pos[0]);\n      clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n      return rawPos;\n    }\n  });\n  return {\n    styles: clipStyles,\n    raws\n  };\n}\nfunction getRadiusRange(controlPoses) {\n  var horizontalRange = [0, 0];\n  var verticalRange = [0, 0];\n  var length2 = controlPoses.length;\n  for (var i2 = 0; i2 < length2; ++i2) {\n    var clipPose = controlPoses[i2];\n    if (!clipPose.sub) {\n      continue;\n    }\n    if (clipPose.horizontal) {\n      if (horizontalRange[1] === 0) {\n        horizontalRange[0] = i2;\n      }\n      horizontalRange[1] = i2 - horizontalRange[0] + 1;\n      verticalRange[0] = i2 + 1;\n    }\n    if (clipPose.vertical) {\n      if (verticalRange[1] === 0) {\n        verticalRange[0] = i2;\n      }\n      verticalRange[1] = i2 - verticalRange[0] + 1;\n    }\n  }\n  return {\n    horizontalRange,\n    verticalRange\n  };\n}\nfunction getRadiusValues(values, width, height, left2, top2, minCounts) {\n  var _a3, _b3, _c3, _d2;\n  if (minCounts === void 0) {\n    minCounts = [0, 0];\n  }\n  var splitIndex = values.indexOf(\"/\");\n  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n  var horizontalValues = values.slice(0, splitLength);\n  var verticalValues = values.slice(splitLength + 1);\n  var _e = horizontalValues[0], nwValue = _e === void 0 ? \"0px\" : _e, _f = horizontalValues[1], neValue = _f === void 0 ? nwValue : _f, _g = horizontalValues[2], seValue = _g === void 0 ? nwValue : _g, _h = horizontalValues[3], swValue = _h === void 0 ? neValue : _h;\n  var _j = verticalValues[0], wnValue = _j === void 0 ? nwValue : _j, _k = verticalValues[1], enValue = _k === void 0 ? wnValue : _k, _l2 = verticalValues[2], esValue = _l2 === void 0 ? wnValue : _l2, _m = verticalValues[3], wsValue = _m === void 0 ? enValue : _m;\n  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function(pos) {\n    return convertUnitSize(pos, width);\n  });\n  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function(pos) {\n    return convertUnitSize(pos, height);\n  });\n  var horizontalPoses = horizontalRawPoses.slice();\n  var verticalPoses = verticalRawPoses.slice();\n  _a3 = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a3[0], horizontalPoses[1] = _a3[1];\n  _b3 = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b3[0], horizontalPoses[2] = _b3[1];\n  _c3 = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c3[0], verticalPoses[3] = _c3[1];\n  _d2 = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d2[0], verticalPoses[2] = _d2[1];\n  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));\n  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));\n  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function(pos, i2) {\n    var direction = RADIUS_DIRECTIONS[i2];\n    return {\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i2],\n      vertical: 0,\n      pos: [left2 + pos, top2 + (VERTICAL_RADIUS_DIRECTIONS[i2] === -1 ? height : 0)],\n      sub: true,\n      raw: horizontalRawPoses[i2],\n      direction\n    };\n  }), true), nextVerticalPoses.map(function(pos, i2) {\n    var direction = RADIUS_DIRECTIONS[i2];\n    return {\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[i2],\n      pos: [left2 + (HORIZONTAL_RADIUS_DIRECTIONS[i2] === -1 ? width : 0), top2 + pos],\n      sub: true,\n      raw: verticalRawPoses[i2],\n      direction\n    };\n  }), true);\n}\nfunction removeRadiusPos(controlPoses, poses, index, startIndex, length2) {\n  if (length2 === void 0) {\n    length2 = poses.length;\n  }\n  var _a3 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a3.horizontalRange, verticalRange = _a3.verticalRange;\n  var radiuslIndex = index - startIndex;\n  var deleteCount = 0;\n  if (radiuslIndex === 0) {\n    deleteCount = length2;\n  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n    deleteCount = horizontalRange[1] - radiuslIndex;\n  } else if (radiuslIndex >= verticalRange[0]) {\n    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n  } else {\n    return;\n  }\n  controlPoses.splice(index, deleteCount);\n  poses.splice(index, deleteCount);\n}\nfunction addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right2, bottom2, left2, top2) {\n  if (left2 === void 0) {\n    left2 = 0;\n  }\n  if (top2 === void 0) {\n    top2 = 0;\n  }\n  var _a3 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a3.horizontalRange, verticalRange = _a3.verticalRange;\n  if (horizontalIndex > -1) {\n    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left2 : right2 - distX;\n    for (var i2 = horizontalRange[1]; i2 <= horizontalIndex; ++i2) {\n      var y2 = VERTICAL_RADIUS_DIRECTIONS[i2] === 1 ? top2 : bottom2;\n      var x2 = 0;\n      if (horizontalIndex === i2) {\n        x2 = distX;\n      } else if (i2 === 0) {\n        x2 = left2 + radiusX;\n      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i2] === -1) {\n        x2 = right2 - (poses[startIndex][0] - left2);\n      }\n      controlPoses.splice(startIndex + i2, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i2],\n        vertical: 0,\n        pos: [x2, y2]\n      });\n      poses.splice(startIndex + i2, 0, [x2, y2]);\n      if (i2 === 0) {\n        break;\n      }\n    }\n  } else if (verticalIndex > -1) {\n    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top2 : bottom2 - distY;\n    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n      var pos = [left2 + radiusY, top2];\n      controlPoses.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos\n      });\n      poses.push(pos);\n    }\n    var startVerticalIndex = verticalRange[0];\n    for (var i2 = verticalRange[1]; i2 <= verticalIndex; ++i2) {\n      var x2 = HORIZONTAL_RADIUS_DIRECTIONS[i2] === 1 ? left2 : right2;\n      var y2 = 0;\n      if (verticalIndex === i2) {\n        y2 = distY;\n      } else if (i2 === 0) {\n        y2 = top2 + radiusY;\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i2] === 1) {\n        y2 = poses[startIndex + startVerticalIndex][1];\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i2] === -1) {\n        y2 = bottom2 - (poses[startIndex + startVerticalIndex][1] - top2);\n      }\n      controlPoses.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[i2],\n        pos: [x2, y2]\n      });\n      poses.push([x2, y2]);\n      if (i2 === 0) {\n        break;\n      }\n    }\n  }\n}\nfunction splitRadiusPoses(controlPoses, raws) {\n  if (raws === void 0) {\n    raws = controlPoses.map(function(pos) {\n      return pos.raw;\n    });\n  }\n  var horizontals = controlPoses.map(function(pos, i2) {\n    return pos.horizontal ? raws[i2] : null;\n  }).filter(function(pos) {\n    return pos != null;\n  });\n  var verticals = controlPoses.map(function(pos, i2) {\n    return pos.vertical ? raws[i2] : null;\n  }).filter(function(pos) {\n    return pos != null;\n  });\n  return {\n    horizontals,\n    verticals\n  };\n}\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]];\nvar CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction getClipStyles(moveable, clipPath, poses) {\n  var clipRelative = moveable.props.clipRelative;\n  var _a3 = moveable.state, width = _a3.width, height = _a3.height;\n  var _b3 = clipPath, clipType = _b3.type, clipPoses = _b3.poses;\n  var isRect = clipType === \"rect\";\n  var isCircle = clipType === \"circle\";\n  if (clipType === \"polygon\") {\n    return poses.map(function(pos) {\n      return \"\".concat(convertCSSSize(pos[0], width, clipRelative), \" \").concat(convertCSSSize(pos[1], height, clipRelative));\n    });\n  } else if (isRect || clipType === \"inset\") {\n    var top2 = poses[1][1];\n    var right2 = poses[3][0];\n    var left2 = poses[7][0];\n    var bottom2 = poses[5][1];\n    if (isRect) {\n      return [top2, right2, bottom2, left2].map(function(pos) {\n        return \"\".concat(pos, \"px\");\n      });\n    }\n    var clipStyles = [top2, width - right2, height - bottom2, left2].map(function(pos, i2) {\n      return convertCSSSize(pos, i2 % 2 ? width : height, clipRelative);\n    });\n    if (poses.length > 8) {\n      var _c3 = minus(poses[4], poses[0]), subWidth = _c3[0], subHeight = _c3[1];\n      clipStyles.push.apply(clipStyles, __spreadArray([\"round\"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left2, top2, right2, bottom2).styles, false));\n    }\n    return clipStyles;\n  } else if (isCircle || clipType === \"ellipse\") {\n    var center = poses[0];\n    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);\n    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n    clipStyles.push(\"at\", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));\n    return clipStyles;\n  }\n}\nfunction getRectPoses(top2, right2, bottom2, left2) {\n  var xs = [left2, (left2 + right2) / 2, right2];\n  var ys = [top2, (top2 + bottom2) / 2, bottom2];\n  return CLIP_RECT_DIRECTIONS.map(function(_a3) {\n    var dirx = _a3[0], diry = _a3[1], dir = _a3[2];\n    var x2 = xs[dirx + 1];\n    var y2 = ys[diry + 1];\n    return {\n      vertical: Math.abs(diry),\n      horizontal: Math.abs(dirx),\n      direction: dir,\n      pos: [x2, y2]\n    };\n  });\n}\nfunction getClipPath(target, width, height, defaultClip, customClip) {\n  var _a3, _b3, _c3, _d2, _e, _f, _g;\n  var clipText = customClip;\n  if (!clipText) {\n    var style = getComputedStyle$2(target);\n    var clipPath = style.clipPath;\n    clipText = clipPath !== \"none\" ? clipPath : style.clip;\n  }\n  if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n    clipText = defaultClip;\n    if (!clipText) {\n      return;\n    }\n  }\n  var _h = splitBracket(clipText), _j = _h.prefix, clipPrefix = _j === void 0 ? clipText : _j, _k = _h.value, value2 = _k === void 0 ? \"\" : _k;\n  var isCircle = clipPrefix === \"circle\";\n  var splitter = \" \";\n  if (clipPrefix === \"polygon\") {\n    var values = splitComma(value2 || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n    splitter = \",\";\n    var poses = values.map(function(pos) {\n      var _a4 = pos.split(\" \"), xPos2 = _a4[0], yPos2 = _a4[1];\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [convertUnitSize(xPos2, width), convertUnitSize(yPos2, height)]\n      };\n    });\n    return {\n      type: clipPrefix,\n      clipText,\n      poses,\n      splitter\n    };\n  } else if (isCircle || clipPrefix === \"ellipse\") {\n    var xPos = \"\";\n    var yPos = \"\";\n    var radiusX_1 = 0;\n    var radiusY_1 = 0;\n    var values = splitSpace(value2);\n    if (isCircle) {\n      var radius = \"\";\n      _a3 = values[0], radius = _a3 === void 0 ? \"50%\" : _a3, _b3 = values[2], xPos = _b3 === void 0 ? \"50%\" : _b3, _c3 = values[3], yPos = _c3 === void 0 ? \"50%\" : _c3;\n      radiusX_1 = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n      radiusY_1 = radiusX_1;\n    } else {\n      var xRadius = \"\";\n      var yRadius = \"\";\n      _d2 = values[0], xRadius = _d2 === void 0 ? \"50%\" : _d2, _e = values[1], yRadius = _e === void 0 ? \"50%\" : _e, _f = values[3], xPos = _f === void 0 ? \"50%\" : _f, _g = values[4], yPos = _g === void 0 ? \"50%\" : _g;\n      radiusX_1 = convertUnitSize(xRadius, width);\n      radiusY_1 = convertUnitSize(yRadius, height);\n    }\n    var centerPos_1 = [convertUnitSize(xPos, width), convertUnitSize(yPos, height)];\n    var poses = __spreadArray([{\n      vertical: 1,\n      horizontal: 1,\n      pos: centerPos_1,\n      direction: \"nesw\"\n    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function(dir) {\n      return {\n        vertical: Math.abs(dir[1]),\n        horizontal: dir[0],\n        direction: dir[2],\n        sub: true,\n        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]\n      };\n    }), true);\n    return {\n      type: clipPrefix,\n      clipText,\n      radiusX: radiusX_1,\n      radiusY: radiusY_1,\n      left: centerPos_1[0] - radiusX_1,\n      top: centerPos_1[1] - radiusY_1,\n      poses,\n      splitter\n    };\n  } else if (clipPrefix === \"inset\") {\n    var values = splitSpace(value2 || \"0 0 0 0\");\n    var roundIndex = values.indexOf(\"round\");\n    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n    var radiusValues = values.slice(rectLength + 1);\n    var _l2 = values.slice(0, rectLength), topValue = _l2[0], _m = _l2[1], rightValue = _m === void 0 ? topValue : _m, _o = _l2[2], bottomValue = _o === void 0 ? topValue : _o, _p2 = _l2[3], leftValue = _p2 === void 0 ? rightValue : _p2;\n    var _q = [topValue, bottomValue].map(function(pos) {\n      return convertUnitSize(pos, height);\n    }), top2 = _q[0], bottom2 = _q[1];\n    var _r2 = [leftValue, rightValue].map(function(pos) {\n      return convertUnitSize(pos, width);\n    }), left2 = _r2[0], right2 = _r2[1];\n    var nextRight = width - right2;\n    var nextBottom = height - bottom2;\n    var radiusPoses = getRadiusValues(radiusValues, nextRight - left2, nextBottom - top2, left2, top2);\n    var poses = __spreadArray(__spreadArray([], getRectPoses(top2, nextRight, nextBottom, left2), true), radiusPoses, true);\n    return {\n      type: \"inset\",\n      clipText,\n      poses,\n      top: top2,\n      left: left2,\n      right: nextRight,\n      bottom: nextBottom,\n      radius: radiusValues,\n      splitter\n    };\n  } else if (clipPrefix === \"rect\") {\n    var values = splitComma(value2 || \"0px, \".concat(width, \"px, \").concat(height, \"px, 0px\"));\n    splitter = \",\";\n    var _s = values.map(function(pos) {\n      var posValue = splitUnit(pos).value;\n      return posValue;\n    }), top2 = _s[0], right2 = _s[1], bottom2 = _s[2], left2 = _s[3];\n    var poses = getRectPoses(top2, right2, bottom2, left2);\n    return {\n      type: \"rect\",\n      clipText,\n      poses,\n      top: top2,\n      right: right2,\n      bottom: bottom2,\n      left: left2,\n      values,\n      splitter\n    };\n  }\n  return;\n}\nfunction addClipPath(moveable, e) {\n  var _a3 = calculatePointerDist(moveable, e), distX = _a3[0], distY = _a3[1];\n  var _b3 = e.datas, clipPath = _b3.clipPath, index = _b3.index;\n  var _c3 = clipPath, clipType = _c3.type, clipPoses = _c3.poses, splitter = _c3.splitter;\n  var poses = clipPoses.map(function(pos) {\n    return pos.pos;\n  });\n  if (clipType === \"polygon\") {\n    poses.splice(index, 0, [distX, distY]);\n  } else if (clipType === \"inset\") {\n    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n    var length2 = clipPoses.length;\n    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);\n    if (length2 === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"added\",\n    clipType,\n    poses,\n    clipStyles,\n    clipStyle: \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nfunction removeClipPath(moveable, e) {\n  var _a3 = e.datas, clipPath = _a3.clipPath, index = _a3.index;\n  var _b3 = clipPath, clipType = _b3.type, clipPoses = _b3.poses, splitter = _b3.splitter;\n  var poses = clipPoses.map(function(pos) {\n    return pos.pos;\n  });\n  var length2 = poses.length;\n  if (clipType === \"polygon\") {\n    clipPoses.splice(index, 1);\n    poses.splice(index, 1);\n  } else if (clipType === \"inset\") {\n    if (index < 8) {\n      return;\n    }\n    removeRadiusPos(clipPoses, poses, index, 8, length2);\n    if (length2 === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"removed\",\n    clipType,\n    poses,\n    clipStyles,\n    clipStyle: \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [\".control.clip-control {\\n    background: #6d6;\\n    cursor: pointer;\\n}\\n.control.clip-control.clip-radius {\\n    background: #d66;\\n}\\n.line.clip-line {\\n    background: #6e6;\\n    cursor: move;\\n    z-index: 1;\\n}\\n.clip-area {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n}\\n.clip-ellipse {\\n    position: absolute;\\n    cursor: move;\\n    border: 1px solid #6d6;\\n    border: var(--zoompx) solid #6d6;\\n    border-radius: 50%;\\n    transform-origin: 0px 0px;\\n}\", \":host {\\n    --bounds-color: #d66;\\n}\", \".guideline {\\n    pointer-events: none;\\n    z-index: 2;\\n}\", \".line.guideline.bounds {\\n    background: #d66;\\n    background: var(--bounds-color);\\n}\"],\n  render: function(moveable, React) {\n    var _a3 = moveable.props, customClipPath = _a3.customClipPath, defaultClipPath = _a3.defaultClipPath, clipArea = _a3.clipArea, zoom = _a3.zoom;\n    var _b3 = moveable.state, target = _b3.target, width = _b3.width, height = _b3.height, allMatrix = _b3.allMatrix, is3d = _b3.is3d, left2 = _b3.left, top2 = _b3.top, pos1 = _b3.pos1, pos2 = _b3.pos2, pos3 = _b3.pos3, pos4 = _b3.pos4, clipPathState = _b3.clipPathState, snapBoundInfos = _b3.snapBoundInfos, rotationRad = _b3.rotation;\n    if (!target) {\n      return [];\n    }\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n    if (!clipPath) {\n      return [];\n    }\n    var n = is3d ? 4 : 3;\n    var type = clipPath.type;\n    var clipPoses = clipPath.poses;\n    var poses = clipPoses.map(function(pos) {\n      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n      return [calculatedPos[0] - left2, calculatedPos[1] - top2];\n    });\n    var controls = [];\n    var lines = [];\n    var isRect = type === \"rect\";\n    var isInset = type === \"inset\";\n    var isPolygon = type === \"polygon\";\n    if (isRect || isInset || isPolygon) {\n      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;\n      lines = linePoses_1.map(function(to, i3) {\n        var from = i3 === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i3 - 1];\n        var rad2 = getRad$1(from, to);\n        var dist = getDiagonalSize(from, to);\n        return React.createElement(\"div\", {\n          key: \"clipLine\".concat(i3),\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": i3,\n          style: {\n            width: \"\".concat(dist, \"px\"),\n            transform: \"translate(\".concat(from[0], \"px, \").concat(from[1], \"px) rotate(\").concat(rad2, \"rad) scaleY(\").concat(zoom, \")\")\n          }\n        });\n      });\n    }\n    controls = poses.map(function(pos, i3) {\n      return React.createElement(\"div\", {\n        key: \"clipControl\".concat(i3),\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": i3,\n        style: {\n          transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\")\n        }\n      });\n    });\n    if (isInset) {\n      controls.push.apply(controls, poses.slice(8).map(function(pos, i3) {\n        return React.createElement(\"div\", {\n          key: \"clipRadiusControl\".concat(i3),\n          className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n          \"data-clip-index\": 8 + i3,\n          style: {\n            transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\")\n          }\n        });\n      }));\n    }\n    if (type === \"circle\" || type === \"ellipse\") {\n      var clipLeft = clipPath.left, clipTop = clipPath.top, radiusX = clipPath.radiusX, radiusY = clipPath.radiusY;\n      var _c3 = minus(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)), distLeft = _c3[0], distTop = _c3[1];\n      var ellipseClipPath = \"none\";\n      if (!clipArea) {\n        var piece = Math.max(10, radiusX / 5, radiusY / 5);\n        var areaPoses = [];\n        for (var i2 = 0; i2 <= piece; ++i2) {\n          var rad = Math.PI * 2 / piece * i2;\n          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);\n        }\n        areaPoses.push([radiusX, -2]);\n        areaPoses.push([-2, -2]);\n        areaPoses.push([-2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, -2]);\n        areaPoses.push([radiusX, -2]);\n        ellipseClipPath = \"polygon(\".concat(areaPoses.map(function(pos) {\n          return \"\".concat(pos[0], \"px \").concat(pos[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      controls.push(React.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(radiusX * 2, \"px\"),\n          height: \"\".concat(radiusY * 2, \"px\"),\n          clipPath: ellipseClipPath,\n          transform: \"translate(\".concat(-left2 + distLeft, \"px, \").concat(-top2 + distTop, \"px) \").concat(makeMatrixCSS(allMatrix))\n        }\n      }));\n    }\n    if (clipArea) {\n      var _d2 = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses, true)), allWidth = _d2.width, allHeight = _d2.height, allLeft_1 = _d2.left, allTop_1 = _d2.top;\n      if (isPolygon || isRect || isInset) {\n        var areaPoses = isInset ? poses.slice(0, 8) : poses;\n        controls.push(React.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(allWidth, \"px\"),\n            height: \"\".concat(allHeight, \"px\"),\n            transform: \"translate(\".concat(allLeft_1, \"px, \").concat(allTop_1, \"px)\"),\n            clipPath: \"polygon(\".concat(areaPoses.map(function(pos) {\n              return \"\".concat(pos[0] - allLeft_1, \"px \").concat(pos[1] - allTop_1, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    if (snapBoundInfos) {\n      [\"vertical\", \"horizontal\"].forEach(function(directionType) {\n        var info = snapBoundInfos[directionType];\n        var isHorizontal = directionType === \"horizontal\";\n        if (info.isSnap) {\n          lines.push.apply(lines, info.snap.posInfos.map(function(_a4, i3) {\n            var pos = _a4.pos;\n            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left2, top2]);\n            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left2, top2]);\n            return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"snap\").concat(i3), \"guideline\");\n          }));\n        }\n        if (info.isBound) {\n          lines.push.apply(lines, info.bounds.map(function(_a4, i3) {\n            var pos = _a4.pos;\n            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left2, top2]);\n            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left2, top2]);\n            return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"bounds\").concat(i3), \"guideline\", \"bounds\", \"bold\");\n          }));\n        }\n      });\n    }\n    return __spreadArray(__spreadArray([], controls, true), lines, true);\n  },\n  dragControlCondition: function(moveable, e) {\n    return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(moveable, e) {\n    var props = moveable.props;\n    var _a3 = props.dragWithClip, dragWithClip = _a3 === void 0 ? true : _a3;\n    if (dragWithClip) {\n      return false;\n    }\n    return this.dragControlStart(moveable, e);\n  },\n  drag: function(moveable, e) {\n    return this.dragControl(moveable, __assign$1$1(__assign$1$1({}, e), {\n      isDragTarget: true\n    }));\n  },\n  dragEnd: function(moveable, e) {\n    return this.dragControlEnd(moveable, e);\n  },\n  dragControlStart: function(moveable, e) {\n    var state = moveable.state;\n    var _a3 = moveable.props, defaultClipPath = _a3.defaultClipPath, customClipPath = _a3.customClipPath;\n    var target = state.target, width = state.width, height = state.height;\n    var inputTarget = e.inputEvent ? e.inputEvent.target : null;\n    var className = inputTarget && inputTarget.getAttribute(\"class\") || \"\";\n    var datas = e.datas;\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", customClipPath);\n    if (!clipPath) {\n      return false;\n    }\n    var clipText = clipPath.clipText, type = clipPath.type, poses = clipPath.poses;\n    var result = triggerEvent(moveable, \"onClipStart\", fillParams(moveable, e, {\n      clipType: type,\n      clipStyle: clipText,\n      poses: poses.map(function(pos) {\n        return pos.pos;\n      })\n    }));\n    if (result === false) {\n      datas.isClipStart = false;\n      return false;\n    }\n    datas.isControl = className && className.indexOf(\"clip-control\") > -1;\n    datas.isLine = className.indexOf(\"clip-line\") > -1;\n    datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n    datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n    datas.clipPath = clipPath;\n    datas.isClipStart = true;\n    state.clipPathState = clipText;\n    setDragStart(moveable, e);\n    return true;\n  },\n  dragControl: function(moveable, e) {\n    var _a3;\n    var datas = e.datas, originalDatas = e.originalDatas, isDragTarget = e.isDragTarget;\n    if (!datas.isClipStart) {\n      return false;\n    }\n    var _b3 = datas, isControl = _b3.isControl, isLine = _b3.isLine, isArea = _b3.isArea, index = _b3.index, clipPath = _b3.clipPath;\n    if (!clipPath) {\n      return false;\n    }\n    var distX = 0;\n    var distY = 0;\n    var originalDraggable = originalDatas.draggable;\n    var originalDist = getDragDist(e);\n    if (isDragTarget && originalDraggable) {\n      _a3 = originalDraggable.prevBeforeDist, distX = _a3[0], distY = _a3[1];\n    } else {\n      distX = originalDist[0], distY = originalDist[1];\n    }\n    var firstDist = [distX, distY];\n    var props = moveable.props;\n    var state = moveable.state;\n    var width = state.width, height = state.height;\n    var isDragWithTarget = !isArea && !isControl && !isLine;\n    var clipType = clipPath.type, clipPoses = clipPath.poses, splitter = clipPath.splitter;\n    var poses = clipPoses.map(function(pos) {\n      return pos.pos;\n    });\n    if (isDragWithTarget) {\n      distX = -distX;\n      distY = -distY;\n    }\n    var isAll = !isControl || clipPoses[index].direction === \"nesw\";\n    var isRect = clipType === \"inset\" || clipType === \"rect\";\n    var dists = clipPoses.map(function() {\n      return [0, 0];\n    });\n    if (isControl && !isAll) {\n      var _c3 = clipPoses[index], horizontal = _c3.horizontal, vertical = _c3.vertical;\n      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];\n      dists = moveControlPos(clipPoses, index, dist, isRect);\n    } else if (isAll) {\n      dists = poses.map(function() {\n        return [distX, distY];\n      });\n    }\n    var nextPoses = poses.map(function(pos, i3) {\n      return plus(pos, dists[i3]);\n    });\n    var guidePoses = __spreadArray([], nextPoses, true);\n    state.snapBoundInfos = null;\n    var isCircle = clipPath.type === \"circle\";\n    var isEllipse = clipPath.type === \"ellipse\";\n    if (isCircle || isEllipse) {\n      var guideRect = getRect(nextPoses);\n      var ry = Math.abs(guideRect.bottom - guideRect.top);\n      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n      var bottom2 = nextPoses[0][1] + ry;\n      var left2 = nextPoses[0][0] - rx;\n      var right2 = nextPoses[0][0] + rx;\n      if (isCircle) {\n        guidePoses.push([right2, guideRect.bottom]);\n        dists.push([1, 0]);\n      }\n      guidePoses.push([guideRect.left, bottom2]);\n      dists.push([0, 1]);\n      guidePoses.push([left2, guideRect.bottom]);\n      dists.push([1, 0]);\n    }\n    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function(v2) {\n      return convertUnitSize(\"\".concat(v2), height);\n    }), (props.clipVerticalGuidelines || []).map(function(v2) {\n      return convertUnitSize(\"\".concat(v2), width);\n    }), width, height);\n    var guideXPoses = [];\n    var guideYPoses = [];\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];\n      guideXPoses = rectPoses.filter(function(_2, i3) {\n        return rectDists_1[i3][0];\n      }).map(function(pos) {\n        return pos[0];\n      });\n      guideYPoses = rectPoses.filter(function(_2, i3) {\n        return rectDists_1[i3][1];\n      }).map(function(pos) {\n        return pos[1];\n      });\n    } else {\n      guideXPoses = guidePoses.filter(function(_2, i3) {\n        return dists[i3][0];\n      }).map(function(pos) {\n        return pos[0];\n      });\n      guideYPoses = guidePoses.filter(function(_2, i3) {\n        return dists[i3][1];\n      }).map(function(pos) {\n        return pos[1];\n      });\n    }\n    var boundDelta = [0, 0];\n    var _loop_1 = function(i3) {\n      var _d2 = checkSnapBounds(guidelines, props.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: width,\n        bottom: height\n      }, guideXPoses, guideYPoses, 5), horizontalSnapInfo = _d2.horizontal, verticalSnapInfo = _d2.vertical;\n      var snapOffsetY = horizontalSnapInfo.offset;\n      var snapOffsetX = verticalSnapInfo.offset;\n      if (horizontalSnapInfo.isBound) {\n        boundDelta[1] += snapOffsetY;\n      }\n      if (verticalSnapInfo.isBound) {\n        boundDelta[0] += snapOffsetX;\n      }\n      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n        var guideRect2 = getRect(nextPoses);\n        var cy = guideRect2.bottom - guideRect2.top;\n        var cx = isEllipse ? guideRect2.right - guideRect2.left : cy;\n        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;\n        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;\n        cx -= distSnapX;\n        cy -= distSnapY;\n        if (isCircle) {\n          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n          cx = cy;\n        }\n        var center = guidePoses[0];\n        guidePoses[1][1] = center[1] - cy;\n        guidePoses[2][0] = center[0] + cx;\n        guidePoses[3][1] = center[1] + cy;\n        guidePoses[4][0] = center[0] - cx;\n      } else {\n        guidePoses.forEach(function(pos, j2) {\n          var dist2 = dists[j2];\n          if (dist2[0]) {\n            pos[0] -= snapOffsetX;\n          }\n          if (dist2[1]) {\n            pos[1] -= snapOffsetY;\n          }\n        });\n        return \"break\";\n      }\n    };\n    for (var i2 = 0; i2 < 2; ++i2) {\n      var state_1 = _loop_1();\n      if (state_1 === \"break\")\n        break;\n    }\n    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);\n    var clipStyle = \"\".concat(clipType, \"(\").concat(nextClipStyles.join(splitter), \")\");\n    state.clipPathState = clipStyle;\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n      guideXPoses = rectPoses.map(function(pos) {\n        return pos[0];\n      });\n      guideYPoses = rectPoses.map(function(pos) {\n        return pos[1];\n      });\n    } else {\n      guideXPoses = guidePoses.map(function(pos) {\n        return pos[0];\n      });\n      guideYPoses = guidePoses.map(function(pos) {\n        return pos[1];\n      });\n    }\n    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    }, guideXPoses, guideYPoses, 1);\n    if (originalDraggable) {\n      var is3d = state.is3d, allMatrix = state.allMatrix;\n      var n = is3d ? 4 : 3;\n      var dragDist = boundDelta;\n      if (isDragTarget) {\n        dragDist = [firstDist[0] + boundDelta[0] - originalDist[0], firstDist[1] + boundDelta[1] - originalDist[1]];\n      }\n      originalDraggable.deltaOffset = multiply(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);\n    }\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n      clipEventType: \"changed\",\n      clipType,\n      poses: nextPoses,\n      clipStyle,\n      clipStyles: nextClipStyles,\n      distX,\n      distY\n    }));\n    return true;\n  },\n  dragControlEnd: function(moveable, e) {\n    this.unset(moveable);\n    var isDrag = e.isDrag, datas = e.datas, isDouble = e.isDouble;\n    var isLine = datas.isLine, isClipStart = datas.isClipStart, isControl = datas.isControl;\n    if (!isClipStart) {\n      return false;\n    }\n    triggerEvent(moveable, \"onClipEnd\", fillEndParams(moveable, e, {}));\n    if (isDouble) {\n      if (isControl) {\n        removeClipPath(moveable, e);\n      } else if (isLine) {\n        addClipPath(moveable, e);\n      }\n    }\n    return isDouble || isDrag;\n  },\n  unset: function(moveable) {\n    moveable.state.clipPathState = \"\";\n    moveable.state.snapBoundInfos = null;\n  }\n};\nvar OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [\":host[data-able-origindraggable] .control.origin {\\n    pointer-events: auto;\\n}\"],\n  dragControlCondition: function(_2, e) {\n    if (e.isRequest) {\n      return e.requestAble === \"originDraggable\";\n    }\n    return hasClass(e.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function(moveable, e) {\n    var datas = e.datas;\n    setDragStart(moveable, e);\n    var params = fillParams(moveable, e, {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    });\n    var result = triggerEvent(moveable, \"onDragOriginStart\", params);\n    datas.startOrigin = moveable.state.transformOrigin;\n    datas.startTargetOrigin = moveable.state.targetOrigin;\n    datas.prevOrigin = [0, 0];\n    datas.isDragOrigin = true;\n    if (result === false) {\n      datas.isDragOrigin = false;\n      return false;\n    }\n    return params;\n  },\n  dragControl: function(moveable, e) {\n    var datas = e.datas, isPinch = e.isPinch, isRequest = e.isRequest;\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n    var _a3 = getDragDist(e), distX = _a3[0], distY = _a3[1];\n    var state = moveable.state;\n    var width = state.width, height = state.height, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, is3d = state.is3d;\n    var _b3 = moveable.props.originRelative, originRelative = _b3 === void 0 ? true : _b3;\n    var n = is3d ? 4 : 3;\n    var dist = [distX, distY];\n    if (isRequest) {\n      var distOrigin = e.distOrigin;\n      if (distOrigin[0] || distOrigin[1]) {\n        dist = distOrigin;\n      }\n    }\n    var origin = plus(datas.startOrigin, dist);\n    var targetOrigin = plus(datas.startTargetOrigin, dist);\n    var delta = minus(dist, datas.prevOrigin);\n    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\n    var rect = moveable.getRect();\n    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];\n    datas.prevOrigin = dist;\n    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(\" \");\n    var params = fillParams(moveable, e, {\n      width,\n      height,\n      origin,\n      dist,\n      delta,\n      transformOrigin,\n      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onDragOrigin\", params);\n    return params;\n  },\n  dragControlEnd: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n    triggerEvent(moveable, \"onDragOriginEnd\", fillEndParams(moveable, e, {}));\n    return true;\n  },\n  dragGroupControlCondition: function(moveable, e) {\n    return this.dragControlCondition(moveable, e);\n  },\n  dragGroupControlStart: function(moveable, e) {\n    var params = this.dragControlStart(moveable, e);\n    if (!params) {\n      return false;\n    }\n    return true;\n  },\n  dragGroupControl: function(moveable, e) {\n    var params = this.dragControl(moveable, e);\n    if (!params) {\n      return false;\n    }\n    moveable.transformOrigin = params.transformOrigin;\n    return true;\n  },\n  request: function(moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    var transformOrigin = rect.transformOrigin;\n    var distOrigin = [0, 0];\n    return {\n      isControl: true,\n      requestStart: function() {\n        return {\n          datas\n        };\n      },\n      request: function(e) {\n        if (\"deltaOrigin\" in e) {\n          distOrigin[0] += e.deltaOrigin[0];\n          distOrigin[1] += e.deltaOrigin[1];\n        } else if (\"origin\" in e) {\n          distOrigin[0] = e.origin[0] - transformOrigin[0];\n          distOrigin[1] = e.origin[1] - transformOrigin[1];\n        } else {\n          if (\"x\" in e) {\n            distX = e.x - rect.left;\n          } else if (\"deltaX\" in e) {\n            distX += e.deltaX;\n          }\n          if (\"y\" in e) {\n            distY = e.y - rect.top;\n          } else if (\"deltaY\" in e) {\n            distY += e.deltaY;\n          }\n        }\n        return {\n          datas,\n          distX,\n          distY,\n          distOrigin\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\nfunction addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {\n  var _a3 = splitRadiusPoses(controlPoses), horizontals = _a3.horizontals, verticals = _a3.verticals;\n  var horizontalsLength = horizontals.length;\n  var verticalsLength = verticals.length;\n  var horizontalIndex = -1;\n  var verticalIndex = -1;\n  if (lineIndex === 0) {\n    if (horizontalsLength === 0) {\n      horizontalIndex = 0;\n    } else if (horizontalsLength === 1) {\n      horizontalIndex = 1;\n    }\n  } else if (lineIndex === 3) {\n    if (horizontalsLength <= 2) {\n      horizontalIndex = 2;\n    } else if (horizontalsLength <= 3) {\n      horizontalIndex = 3;\n    }\n  }\n  if (lineIndex === 2) {\n    if (verticalsLength === 0) {\n      verticalIndex = 0;\n    } else if (verticalsLength < 4) {\n      verticalIndex = 3;\n    }\n  } else if (lineIndex === 1) {\n    if (verticalsLength <= 1) {\n      verticalIndex = 1;\n    } else if (verticalsLength <= 2) {\n      verticalIndex = 2;\n    }\n  }\n  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);\n}\nfunction getBorderRadius(target, width, height, minCounts, state) {\n  if (minCounts === void 0) {\n    minCounts = [0, 0];\n  }\n  var borderRadius;\n  var values = [];\n  if (!state) {\n    var style = getComputedStyle$2(target);\n    borderRadius = style && style.borderRadius || \"\";\n  } else {\n    borderRadius = state;\n  }\n  if (!borderRadius || !state && borderRadius === \"0px\") {\n    values = [];\n  } else {\n    values = splitSpace(borderRadius);\n  }\n  return getRadiusValues(values, width, height, 0, 0, minCounts);\n}\nfunction triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {\n  var state = moveable.state;\n  var width = state.width, height = state.height;\n  var _a3 = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height), raws = _a3.raws, styles = _a3.styles;\n  var _b3 = splitRadiusPoses(controlPoses, raws), horizontals = _b3.horizontals, verticals = _b3.verticals;\n  var borderRadius = styles.join(\" \");\n  state.borderRadiusState = borderRadius;\n  triggerEvent(moveable, \"onRound\", fillParams(moveable, e, {\n    horizontals,\n    verticals,\n    borderRadius,\n    width,\n    height,\n    delta,\n    dist\n  }));\n}\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\"\n  },\n  css: [\".control.border-radius {\\n    background: #d66;\\n    cursor: pointer;\\n}\", \":host[data-able-roundable] .line.direction {\\n    cursor: pointer;\\n}\"],\n  render: function(moveable, React) {\n    var _a3 = moveable.state, target = _a3.target, width = _a3.width, height = _a3.height, allMatrix = _a3.allMatrix, is3d = _a3.is3d, left2 = _a3.left, top2 = _a3.top, borderRadiusState = _a3.borderRadiusState;\n    var _b3 = moveable.props, _c3 = _b3.minRoundControls, minRoundControls = _c3 === void 0 ? [0, 0] : _c3, _d2 = _b3.maxRoundControls, maxRoundControls = _d2 === void 0 ? [4, 4] : _d2, zoom = _b3.zoom;\n    if (!target) {\n      return null;\n    }\n    var n = is3d ? 4 : 3;\n    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);\n    if (!radiusValues) {\n      return null;\n    }\n    var verticalCount = 0;\n    var horizontalCount = 0;\n    return radiusValues.map(function(v2, i2) {\n      horizontalCount += Math.abs(v2.horizontal);\n      verticalCount += Math.abs(v2.vertical);\n      var pos = minus(calculatePosition(allMatrix, v2.pos, n), [left2, top2]);\n      var isDisplay = v2.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];\n      return React.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(i2),\n        className: prefix(\"control\", \"border-radius\"),\n        \"data-radius-index\": i2,\n        style: {\n          display: isDisplay ? \"block\" : \"none\",\n          transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) scale(\").concat(zoom, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(moveable, e) {\n    if (!e.inputEvent || e.isRequest) {\n      return false;\n    }\n    var className = e.inputEvent.target.getAttribute(\"class\") || \"\";\n    return className.indexOf(\"border-radius\") > -1 || className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n  },\n  dragControlStart: function(moveable, e) {\n    var inputEvent = e.inputEvent, datas = e.datas;\n    var inputTarget = inputEvent.target;\n    var className = inputTarget.getAttribute(\"class\") || \"\";\n    var isControl = className.indexOf(\"border-radius\") > -1;\n    var isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n    var controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n    var lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n    if (!isControl && !isLine) {\n      return false;\n    }\n    var result = triggerEvent(moveable, \"onRoundStart\", fillParams(moveable, e, {}));\n    if (result === false) {\n      return false;\n    }\n    datas.lineIndex = lineIndex;\n    datas.controlIndex = controlIndex;\n    datas.isControl = isControl;\n    datas.isLine = isLine;\n    setDragStart(moveable, e);\n    var _a3 = moveable.props, roundRelative = _a3.roundRelative, _b3 = _a3.minRoundControls, minRoundControls = _b3 === void 0 ? [0, 0] : _b3;\n    var state = moveable.state;\n    var target = state.target, width = state.width, height = state.height;\n    datas.isRound = true;\n    datas.prevDist = [0, 0];\n    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];\n    datas.controlPoses = controlPoses;\n    state.borderRadiusState = getRadiusStyles(controlPoses.map(function(pos) {\n      return pos.pos;\n    }), controlPoses, roundRelative, width, height).styles.join(\" \");\n    return true;\n  },\n  dragControl: function(moveable, e) {\n    var datas = e.datas;\n    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n      return false;\n    }\n    var index = datas.controlIndex;\n    var controlPoses = datas.controlPoses;\n    var _a3 = getDragDist(e), distX = _a3[0], distY = _a3[1];\n    var dist = [distX, distY];\n    var delta = minus(dist, datas.prevDist);\n    var _b3 = moveable.props.maxRoundControls, maxRoundControls = _b3 === void 0 ? [4, 4] : _b3;\n    var _c3 = moveable.state, width = _c3.width, height = _c3.height;\n    var selectedControlPose = controlPoses[index];\n    var selectedVertical = selectedControlPose.vertical;\n    var selectedHorizontal = selectedControlPose.horizontal;\n    var dists = controlPoses.map(function(pose) {\n      var horizontal = pose.horizontal, vertical = pose.vertical;\n      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];\n      if (horizontal) {\n        if (maxRoundControls[0] === 1) {\n          return poseDist;\n        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n          return poseDist;\n        }\n      } else if (maxRoundControls[1] === 0) {\n        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n        return poseDist;\n      } else if (selectedVertical) {\n        if (maxRoundControls[1] === 1) {\n          return poseDist;\n        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n          return poseDist;\n        }\n      }\n      return [0, 0];\n    });\n    dists[index] = dist;\n    var nextPoses = controlPoses.map(function(pos, i2) {\n      return plus(pos.pos, dists[i2]);\n    });\n    datas.prevDist = [distX, distY];\n    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);\n    return true;\n  },\n  dragControlEnd: function(moveable, e) {\n    var state = moveable.state;\n    state.borderRadiusState = \"\";\n    var datas = e.datas, isDouble = e.isDouble;\n    if (!datas.isRound) {\n      return false;\n    }\n    var width = state.width, height = state.height;\n    var isControl = datas.isControl, controlIndex = datas.controlIndex, isLine = datas.isLine, lineIndex = datas.lineIndex;\n    var controlPoses = datas.controlPoses;\n    var poses = controlPoses.map(function(pos) {\n      return pos.pos;\n    });\n    var length2 = poses.length;\n    var _a3 = moveable.props.roundClickable, roundClickable = _a3 === void 0 ? true : _a3;\n    if (isDouble && roundClickable) {\n      if (isControl) {\n        removeRadiusPos(controlPoses, poses, controlIndex, 0);\n      } else if (isLine) {\n        var _b3 = calculatePointerDist(moveable, e), distX = _b3[0], distY = _b3[1];\n        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n      }\n      if (length2 !== controlPoses.length) {\n        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);\n      }\n    }\n    triggerEvent(moveable, \"onRoundEnd\", fillEndParams(moveable, e, {}));\n    state.borderRadiusState = \"\";\n    return true;\n  },\n  unset: function(moveable) {\n    moveable.state.borderRadiusState = \"\";\n  }\n};\nfunction isIdentityMatrix(matrix, is3d) {\n  var value2 = is3d ? \"matrix3d(\".concat(createIdentityMatrix(4)) : \"matrix(\".concat(createIdentityMatrix(3), \")\");\n  return matrix === value2 || matrix === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n  isPinch: true,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  setTransform: function(moveable, e) {\n    var _a3 = moveable.state, is3d = _a3.is3d, target = _a3.target, targetMatrix = _a3.targetMatrix;\n    var transform = target === null || target === void 0 ? void 0 : target.style.transform;\n    var cssMatrix = is3d ? \"matrix3d(\".concat(targetMatrix.join(\",\"), \")\") : \"matrix(\".concat(convertMatrixtoCSS(targetMatrix, true), \")\");\n    var startTransform = !transform || transform === \"none\" ? cssMatrix : transform;\n    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);\n  },\n  resetTransform: function(e) {\n    e.datas.nextTransforms = e.datas.startTransforms;\n    e.datas.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(moveable, e) {\n    return fillParams(moveable, e, {\n      setTransform: function(transform) {\n        e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n      },\n      isPinch: !!e.isPinch\n    });\n  },\n  fillDragParams: function(moveable, e) {\n    return fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    });\n  },\n  dragStart: function(moveable, e) {\n    this.setTransform(moveable, e);\n    triggerEvent(moveable, \"onBeforeRenderStart\", this.fillDragStartParams(moveable, e));\n  },\n  drag: function(moveable, e) {\n    this.resetTransform(e);\n    triggerEvent(moveable, \"onBeforeRender\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  dragEnd: function(moveable, e) {\n    triggerEvent(moveable, \"onBeforeRenderEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag\n    }));\n  },\n  dragGroupStart: function(moveable, e) {\n    var _this = this;\n    this.dragStart(moveable, e);\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function(childEvent, i2) {\n      var childMoveable = moveables[i2];\n      _this.setTransform(childMoveable, childEvent);\n      return _this.fillDragStartParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onBeforeRenderGroupStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets,\n      setTransform: function() {\n      },\n      events: params\n    }));\n  },\n  dragGroup: function(moveable, e) {\n    var _this = this;\n    this.drag(moveable, e);\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function(childEvent, i2) {\n      var childMoveable = moveables[i2];\n      _this.resetTransform(childEvent);\n      return _this.fillDragParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onBeforeRenderGroup\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets,\n      events: params\n    }));\n  },\n  dragGroupEnd: function(moveable, e) {\n    this.dragEnd(moveable, e);\n    triggerEvent(moveable, \"onBeforeRenderGroupEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: moveable.props.targets\n    }));\n  },\n  dragControlStart: function(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl: function(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart: function(moveable, e) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl: function(moveable, e) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    return this.dragGroupEnd(moveable, e);\n  }\n};\nvar Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  dragStart: function(moveable, e) {\n    triggerEvent(moveable, \"onRenderStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  drag: function(moveable, e) {\n    triggerEvent(moveable, \"onRender\", this.fillDragParams(moveable, e));\n  },\n  dragAfter: function(moveable, e) {\n    if (e.resultCount) {\n      return this.drag(moveable, e);\n    }\n  },\n  dragEnd: function(moveable, e) {\n    triggerEvent(moveable, \"onRenderEnd\", this.fillDragEndParams(moveable, e));\n  },\n  dragGroupStart: function(moveable, e) {\n    triggerEvent(moveable, \"onRenderGroupStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroup: function(moveable, e) {\n    var _this = this;\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function(childEvent, i2) {\n      var childMoveable = moveables[i2];\n      return _this.fillDragParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onRenderGroup\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets,\n      transform: getNextTransformText(e),\n      events: params\n    }));\n  },\n  dragGroupEnd: function(moveable, e) {\n    var _this = this;\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function(childEvent, i2) {\n      var childMoveable = moveables[i2];\n      return _this.fillDragEndParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onRenderGroupEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: moveable.props.targets,\n      events: params\n    }));\n  },\n  dragControlStart: function(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl: function(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlAfter: function(moveable, e) {\n    return this.dragAfter(moveable, e);\n  },\n  dragControlEnd: function(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart: function(moveable, e) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl: function(moveable, e) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    return this.dragGroupEnd(moveable, e);\n  },\n  fillDragParams: function(moveable, e) {\n    return fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      transform: getNextTransformText(e)\n    });\n  },\n  fillDragEndParams: function(moveable, e) {\n    return fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag\n    });\n  }\n};\nfunction triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {\n  var isStart = eventType === \"Start\";\n  var target = moveable.state.target;\n  var isRequest = e.isRequest;\n  if (!target || isStart && eventAffix.indexOf(\"Control\") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {\n    return false;\n  }\n  var eventName = \"\".concat(eventOperation).concat(eventAffix).concat(eventType);\n  var conditionName = \"\".concat(eventOperation).concat(eventAffix, \"Condition\");\n  var isEnd = eventType === \"End\";\n  var isAfter = eventType === \"After\";\n  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());\n  if (isFirstStart) {\n    moveable.updateRect(eventType, true, false);\n  }\n  if (eventType === \"\" && !isRequest) {\n    convertDragDist(moveable.state, e);\n  }\n  var ables = __spreadArray([], moveable[ableType], true);\n  if (isRequest) {\n    var requestAble_1 = e.requestAble;\n    if (!ables.some(function(able) {\n      return able.name === requestAble_1;\n    })) {\n      ables.push.apply(ables, moveable.props.ables.filter(function(able) {\n        return able.name === requestAble_1;\n      }));\n    }\n  }\n  if (!ables.length) {\n    return false;\n  }\n  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables, true), [Renderable], false).filter(function(able) {\n    return able[eventName];\n  });\n  var datas = e.datas;\n  if (isFirstStart) {\n    eventAbles.forEach(function(able) {\n      able.unset && able.unset(moveable);\n    });\n  }\n  var inputEvent = e.inputEvent;\n  var inputTarget;\n  if (isEnd && inputEvent) {\n    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n  }\n  var resultCount = 0;\n  var results = eventAbles.filter(function(able) {\n    var ableName = able.name;\n    var nextDatas = datas[ableName] || (datas[ableName] = {});\n    if (isStart) {\n      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n    }\n    if (nextDatas.isEventStart) {\n      var result = able[eventName](moveable, __assign$1$1(__assign$1$1({}, e), {\n        resultCount,\n        datas: nextDatas,\n        originalDatas: datas,\n        inputTarget\n      }));\n      moveable._emitter.off();\n      if (isStart && result === false) {\n        nextDatas.isEventStart = false;\n      }\n      resultCount += result ? 1 : 0;\n      return result;\n    }\n    return false;\n  });\n  var isUpdate = results.length;\n  var isForceEnd = false;\n  if (isStart && eventAbles.length && !isUpdate) {\n    isForceEnd = eventAbles.filter(function(able) {\n      var ableName = able.name;\n      var nextDatas = datas[ableName];\n      if (nextDatas.isEventStart) {\n        if (able.dragRelation === \"strong\") {\n          nextDatas.isEventStart = false;\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }).length === 0;\n  }\n  if (isEnd || isForceEnd) {\n    moveable.state.gesto = null;\n    if (moveable.moveables) {\n      moveable.moveables.forEach(function(childMoveable) {\n        childMoveable.state.gesto = null;\n      });\n    }\n  }\n  if (isFirstStart && isForceEnd) {\n    eventAbles.forEach(function(able) {\n      able.unset && able.unset(moveable);\n    });\n  }\n  if (isStart && !isRequest && isUpdate) {\n    e === null || e === void 0 ? void 0 : e.preventDefault();\n  }\n  if (moveable.isUnmounted || isForceEnd) {\n    return false;\n  }\n  if (!isStart && isUpdate && !requestInstant || isEnd) {\n    moveable.updateRect(isEnd ? eventType : \"\", true, false);\n    moveable.forceUpdate();\n  }\n  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n  }\n  return true;\n}\nfunction getTargetAbleGesto(moveable, moveableTarget, eventAffix) {\n  var controlBox = moveable.controlBox.getElement();\n  var targets = [];\n  targets.push(controlBox);\n  if (!moveable.props.dragArea || moveable.props.dragTarget) {\n    targets.push(moveableTarget);\n  }\n  var startFunc = function(e) {\n    var eventTarget = e.inputEvent.target;\n    var areaElement = moveable.areaElement;\n    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || hasClass(eventTarget, \"moveable-area\") || hasClass(eventTarget, \"moveable-padding\");\n  };\n  return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n    dragStart: startFunc,\n    pinchStart: startFunc\n  });\n}\nfunction getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {\n  if (conditionFunctions === void 0) {\n    conditionFunctions = {};\n  }\n  var _a3 = moveable.props, pinchOutside = _a3.pinchOutside, pinchThreshold = _a3.pinchThreshold;\n  var options = {\n    preventDefault: false,\n    container: window,\n    pinchThreshold,\n    pinchOutside\n  };\n  var gesto = new Gesto$1(target, options);\n  [\"drag\", \"pinch\"].forEach(function(eventOperation) {\n    [\"Start\", \"\", \"End\"].forEach(function(eventType) {\n      gesto.on(\"\".concat(eventOperation).concat(eventType), function(e) {\n        var eventName = e.eventType;\n        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n          e.stop();\n          return;\n        }\n        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n        if (!result) {\n          e.stop();\n        }\n      });\n    });\n  });\n  return gesto;\n}\nvar EventManager = /* @__PURE__ */ function() {\n  function EventManager2(target, moveable, eventName) {\n    var _this = this;\n    this.target = target;\n    this.moveable = moveable;\n    this.eventName = eventName;\n    this.ables = [];\n    this._onEvent = function(e) {\n      var eventName2 = _this.eventName;\n      var moveable2 = _this.moveable;\n      if (moveable2.state.disableNativeEvent) {\n        return;\n      }\n      _this.ables.forEach(function(able) {\n        able[eventName2](moveable2, {\n          inputEvent: e\n        });\n      });\n    };\n    target.addEventListener(eventName.toLowerCase(), this._onEvent);\n  }\n  var __proto = EventManager2.prototype;\n  __proto.setAbles = function(ables) {\n    this.ables = ables;\n  };\n  __proto.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\n    this.target = null;\n    this.moveable = null;\n  };\n  return EventManager2;\n}();\nvar MoveableManager$1 = /* @__PURE__ */ function(_super) {\n  __extends$1(MoveableManager2, _super);\n  function MoveableManager2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = __assign$1$1({\n      container: null,\n      gesto: null,\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: false\n    }, getTargetInfo(null));\n    _this.enabledAbles = [];\n    _this.targetAbles = [];\n    _this.controlAbles = [];\n    _this.rotation = 0;\n    _this.scale = [1, 1];\n    _this.isUnmounted = false;\n    _this.events = {\n      \"mouseEnter\": null,\n      \"mouseLeave\": null\n    };\n    _this._emitter = new EventEmitter$1();\n    _this._prevTarget = null;\n    _this._prevDragArea = false;\n    _this._observer = null;\n    _this._observerId = 0;\n    _this.onPreventClick = function(e) {\n      e.stopPropagation();\n      removeEvent(window, \"click\", _this.onPreventClick, true);\n    };\n    _this.checkUpdateRect = function() {\n      if (_this.isDragging()) {\n        return;\n      }\n      var parentMoveable = _this.props.parentMoveable;\n      if (parentMoveable) {\n        parentMoveable.checkUpdateRect();\n        return;\n      }\n      cancelAnimationFrame$1(_this._observerId);\n      _this._observerId = requestAnimationFrame$1(function() {\n        if (_this.isDragging()) {\n          return;\n        }\n        _this.updateRect();\n      });\n    };\n    return _this;\n  }\n  var __proto = MoveableManager2.prototype;\n  __proto.render = function() {\n    var props = this.props;\n    var state = this.state;\n    var parentPosition = props.parentPosition, className = props.className, propsTarget = props.target, zoom = props.zoom, cspNonce = props.cspNonce, translateZ = props.translateZ, ControlBoxElement = props.cssStyled, portalContainer = props.portalContainer;\n    this.checkUpdate();\n    this.updateRenderPoses();\n    var _a3 = parentPosition || {\n      left: 0,\n      top: 0\n    }, parentLeft = _a3.left, parentTop = _a3.top;\n    var left2 = state.left, top2 = state.top, stateTarget = state.target, direction = state.direction, hasFixed = state.hasFixed;\n    var groupTargets = props.targets;\n    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;\n    var isDragging = this.isDragging();\n    var ableAttributes = {};\n    this.getEnabledAbles().forEach(function(able) {\n      ableAttributes[\"data-able-\".concat(able.name.toLowerCase())] = true;\n    });\n    return createElement(ControlBoxElement, __assign$1$1({\n      cspNonce,\n      ref: ref(this, \"controlBox\"),\n      className: \"\".concat(prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\"), \" \").concat(className)\n    }, ableAttributes, {\n      onClick: this.onPreventClick,\n      portalContainer,\n      style: {\n        \"position\": hasFixed ? \"fixed\" : \"absolute\",\n        \"display\": isDisplay ? \"block\" : \"none\",\n        \"transform\": \"translate3d(\".concat(left2 - parentLeft, \"px, \").concat(top2 - parentTop, \"px, \").concat(translateZ, \")\"),\n        \"--zoom\": zoom,\n        \"--zoompx\": \"\".concat(zoom, \"px\")\n      }\n    }), this.renderAbles(), this._renderLines());\n  };\n  __proto.componentDidMount = function() {\n    this.isUnmounted = false;\n    this.controlBox.getElement();\n    var props = this.props;\n    var parentMoveable = props.parentMoveable, container = props.container, wrapperMoveable = props.wrapperMoveable;\n    this._updateTargets();\n    this._updateNativeEvents();\n    this._updateEvents();\n    if (!container && !parentMoveable && !wrapperMoveable) {\n      this.updateRect(\"\", false, true);\n    }\n    this.updateCheckInput();\n    this._updateObserver(this.props);\n  };\n  __proto.componentDidUpdate = function(prevProps) {\n    this._updateNativeEvents();\n    this._updateEvents();\n    this._updateTargets();\n    this.updateCheckInput();\n    this._updateObserver(prevProps);\n  };\n  __proto.componentWillUnmount = function() {\n    this.isUnmounted = true;\n    this._emitter.off();\n    unset(this, \"targetGesto\");\n    unset(this, \"controlGesto\");\n    var events = this.events;\n    for (var name in events) {\n      var manager = events[name];\n      manager && manager.destroy();\n    }\n  };\n  __proto.getContainer = function() {\n    var _a3 = this.props, parentMoveable = _a3.parentMoveable, wrapperMoveable = _a3.wrapperMoveable, container = _a3.container;\n    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;\n  };\n  __proto.isMoveableElement = function(target) {\n    return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n  };\n  __proto.dragStart = function(e) {\n    var targetGesto = this.targetGesto;\n    if (targetGesto && !targetGesto.isFlag()) {\n      targetGesto.triggerDragStart(e);\n    }\n    return this;\n  };\n  __proto.hitTest = function(el) {\n    var _a3 = this.state, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4, targetClientRect = _a3.targetClientRect;\n    if (!target) {\n      return 0;\n    }\n    var rect;\n    if (el instanceof Element) {\n      var clientRect = el.getBoundingClientRect();\n      rect = {\n        left: clientRect.left,\n        top: clientRect.top,\n        width: clientRect.width,\n        height: clientRect.height\n      };\n    } else {\n      rect = __assign$1$1({\n        width: 0,\n        height: 0\n      }, el);\n    }\n    var rectLeft = rect.left, rectTop = rect.top, rectWidth = rect.width, rectHeight = rect.height;\n    var points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n    var size = getOverlapSize(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);\n    var totalSize = getAreaSize(points);\n    if (!size || !totalSize) {\n      return 0;\n    }\n    return Math.min(100, size / totalSize * 100);\n  };\n  __proto.isInside = function(clientX, clientY) {\n    var _a3 = this.state, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4, targetClientRect = _a3.targetClientRect;\n    if (!target) {\n      return false;\n    }\n    return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n  };\n  __proto.updateRect = function(type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n    var props = this.props;\n    var parentMoveable = props.parentMoveable;\n    var state = this.state;\n    var target = state.target || this.props.target;\n    var container = this.getContainer();\n    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;\n    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);\n  };\n  __proto.isDragging = function() {\n    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);\n  };\n  __proto.updateTarget = function(type) {\n    this.updateRect(type, true);\n  };\n  __proto.getRect = function() {\n    var state = this.state;\n    var poses = getAbsolutePosesByState(this.state);\n    var pos1 = poses[0], pos2 = poses[1], pos3 = poses[2], pos4 = poses[3];\n    var rect = getRect(poses);\n    var offsetWidth = state.width, offsetHeight = state.height;\n    var width = rect.width, height = rect.height, left2 = rect.left, top2 = rect.top;\n    var statePos = [state.left, state.top];\n    var origin = plus(statePos, state.origin);\n    var beforeOrigin = plus(statePos, state.beforeOrigin);\n    var transformOrigin = state.transformOrigin;\n    return {\n      width,\n      height,\n      left: left2,\n      top: top2,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      offsetWidth,\n      offsetHeight,\n      beforeOrigin,\n      origin,\n      transformOrigin,\n      rotation: this.getRotation()\n    };\n  };\n  __proto.getManager = function() {\n    return this;\n  };\n  __proto.getRotation = function() {\n    var _a3 = this.state, pos1 = _a3.pos1, pos2 = _a3.pos2, direction = _a3.direction;\n    return getAbsoluteRotation(pos1, pos2, direction);\n  };\n  __proto.request = function(ableName, param, isInstant) {\n    if (param === void 0) {\n      param = {};\n    }\n    var _a3 = this.props, ables = _a3.ables, groupable = _a3.groupable;\n    var requsetAble = ables.filter(function(able) {\n      return able.name === ableName;\n    })[0];\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    }\n    var self2 = this;\n    var ableRequester = requsetAble.request(this);\n    var requestInstant = isInstant || param.isInstant;\n    var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n    var eventAffix = \"\".concat(groupable ? \"Group\" : \"\").concat(ableRequester.isControl ? \"Control\" : \"\");\n    var requester = {\n      request: function(ableParam) {\n        triggerAble(self2, ableType, \"drag\", eventAffix, \"\", __assign$1$1(__assign$1$1({}, ableRequester.request(ableParam)), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      },\n      requestEnd: function() {\n        triggerAble(self2, ableType, \"drag\", eventAffix, \"End\", __assign$1$1(__assign$1$1({}, ableRequester.requestEnd()), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      }\n    };\n    triggerAble(self2, ableType, \"drag\", eventAffix, \"Start\", __assign$1$1(__assign$1$1({}, ableRequester.requestStart(param)), {\n      requestAble: ableName,\n      isRequest: true\n    }), requestInstant);\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  };\n  __proto.destroy = function() {\n    this.componentWillUnmount();\n  };\n  __proto.updateRenderPoses = function() {\n    var state = this.state;\n    var props = this.props;\n    var originalBeforeOrigin = state.originalBeforeOrigin, transformOrigin = state.transformOrigin, allMatrix = state.allMatrix, is3d = state.is3d, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, stateLeft = state.left, stateTop = state.top;\n    var _a3 = props.padding || {}, _b3 = _a3.left, left2 = _b3 === void 0 ? 0 : _b3, _c3 = _a3.top, top2 = _c3 === void 0 ? 0 : _c3, _d2 = _a3.bottom, bottom2 = _d2 === void 0 ? 0 : _d2, _e = _a3.right, right2 = _e === void 0 ? 0 : _e;\n    var n = is3d ? 4 : 3;\n    var absoluteOrigin = props.groupable ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);\n    state.renderPoses = [plus(pos1, calculatePadding(allMatrix, [-left2, -top2], transformOrigin, absoluteOrigin, n)), plus(pos2, calculatePadding(allMatrix, [right2, -top2], transformOrigin, absoluteOrigin, n)), plus(pos3, calculatePadding(allMatrix, [-left2, bottom2], transformOrigin, absoluteOrigin, n)), plus(pos4, calculatePadding(allMatrix, [right2, bottom2], transformOrigin, absoluteOrigin, n))];\n  };\n  __proto.checkUpdate = function() {\n    var _a3 = this.props, target = _a3.target, container = _a3.container, parentMoveable = _a3.parentMoveable;\n    var _b3 = this.state, stateTarget = _b3.target, stateContainer = _b3.container;\n    if (!stateTarget && !target) {\n      return;\n    }\n    this.updateAbles();\n    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n    if (!isChanged) {\n      return;\n    }\n    var moveableContainer = container || this.controlBox;\n    if (moveableContainer) {\n      this.unsetAbles();\n    }\n    this.updateState({\n      target,\n      container\n    });\n    if (!parentMoveable && moveableContainer) {\n      this.updateRect(\"End\", false, false);\n    }\n  };\n  __proto.triggerEvent = function(name, e) {\n    this._emitter.trigger(name, e);\n    var callback = this.props[name];\n    return callback && callback(e);\n  };\n  __proto.useCSS = function(tag, css) {\n    var customStyleMap = this.props.customStyledMap;\n    var key = tag + css;\n    if (!customStyleMap[key]) {\n      customStyleMap[key] = styled(tag, css);\n    }\n    return customStyleMap[key];\n  };\n  __proto.unsetAbles = function() {\n    var _this = this;\n    this.targetAbles.forEach(function(able) {\n      if (able.unset) {\n        able.unset(_this);\n      }\n    });\n  };\n  __proto.updateAbles = function(ables, eventAffix) {\n    if (ables === void 0) {\n      ables = this.props.ables;\n    }\n    if (eventAffix === void 0) {\n      eventAffix = \"\";\n    }\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var enabledAbles = ables.filter(function(able) {\n      return able && (able.always && props[able.name] !== false || props[able.name]);\n    });\n    var dragStart = \"drag\".concat(eventAffix, \"Start\");\n    var pinchStart = \"pinch\".concat(eventAffix, \"Start\");\n    var dragControlStart = \"drag\".concat(eventAffix, \"ControlStart\");\n    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n    this.enabledAbles = enabledAbles;\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  };\n  __proto.updateState = function(nextState, isSetState) {\n    if (isSetState) {\n      if (this.isUnmounted) {\n        return;\n      }\n      this.setState(nextState);\n    } else {\n      var state = this.state;\n      for (var name in nextState) {\n        state[name] = nextState[name];\n      }\n    }\n  };\n  __proto.getEnabledAbles = function() {\n    var props = this.props;\n    var ables = props.ables;\n    return ables.filter(function(able) {\n      return able && props[able.name];\n    });\n  };\n  __proto.renderAbles = function() {\n    var _this = this;\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var Renderer2 = {\n      createElement\n    };\n    return groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(function(_a3) {\n      var render2 = _a3.render;\n      return render2(_this, Renderer2) || [];\n    })).filter(function(el) {\n      return el;\n    }), function(_a3) {\n      var key = _a3.key;\n      return key;\n    }).map(function(group) {\n      return group[0];\n    });\n  };\n  __proto.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  };\n  __proto._updateObserver = function(prevProps) {\n    var _a3;\n    var props = this.props;\n    var target = props.target;\n    if (!window.ResizeObserver || !target || !props.useResizeObserver) {\n      (_a3 = this._observer) === null || _a3 === void 0 ? void 0 : _a3.disconnect();\n      return;\n    }\n    if (prevProps.target === target && this._observer) {\n      return;\n    }\n    var observer = new ResizeObserver(this.checkUpdateRect);\n    observer.observe(target, {\n      box: \"border-box\"\n    });\n    this._observer = observer;\n    return;\n  };\n  __proto._updateEvents = function() {\n    var controlBoxElement = this.controlBox.getElement();\n    var hasTargetAble = this.targetAbles.length;\n    var hasControlAble = this.controlAbles.length;\n    var props = this.props;\n    var target = props.dragTarget || props.target;\n    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);\n    if (isUnset) {\n      unset(this, \"targetGesto\");\n      this.updateState({\n        gesto: null\n      });\n    }\n    if (!hasControlAble) {\n      unset(this, \"controlGesto\");\n    }\n    if (target && hasTargetAble && !this.targetGesto) {\n      this.targetGesto = getTargetAbleGesto(this, target, \"\");\n    }\n    if (!this.controlGesto && hasControlAble) {\n      this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n    }\n  };\n  __proto._updateTargets = function() {\n    var props = this.props;\n    this._prevTarget = props.dragTarget || props.target;\n    this._prevDragArea = props.dragArea;\n  };\n  __proto._renderLines = function() {\n    var props = this.props;\n    var edge = props.edge, zoom = props.zoom, hideDefaultLines = props.hideDefaultLines;\n    if (hideDefaultLines) {\n      return [];\n    }\n    var renderPoses = this.state.renderPoses;\n    var Renderer2 = {\n      createElement\n    };\n    return [renderLine(Renderer2, edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer2, edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer2, edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer2, edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], zoom, 3)];\n  };\n  __proto._isTargetChanged = function(useDragArea) {\n    var props = this.props;\n    var target = props.dragTarget || props.target;\n    var prevTarget = this._prevTarget;\n    var prevDragArea = this._prevDragArea;\n    var dragArea = props.dragArea;\n    var isTargetChanged = !dragArea && prevTarget !== target;\n    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\n    return isTargetChanged || isDragAreaChanged;\n  };\n  __proto._updateNativeEvents = function() {\n    var _this = this;\n    var props = this.props;\n    var target = props.dragArea ? this.areaElement : this.state.target;\n    var events = this.events;\n    var eventKeys = getKeys(events);\n    if (this._isTargetChanged()) {\n      for (var eventName in events) {\n        var manager = events[eventName];\n        manager && manager.destroy();\n        events[eventName] = null;\n      }\n    }\n    if (!target) {\n      return;\n    }\n    var enabledAbles = this.enabledAbles;\n    eventKeys.forEach(function(eventName2) {\n      var ables = filterAbles(enabledAbles, [eventName2]);\n      var hasAbles = ables.length > 0;\n      var manager2 = events[eventName2];\n      if (!hasAbles) {\n        if (manager2) {\n          manager2.destroy();\n          events[eventName2] = null;\n        }\n        return;\n      }\n      if (!manager2) {\n        manager2 = new EventManager(target, _this, eventName2);\n        events[eventName2] = manager2;\n      }\n      manager2.setAbles(ables);\n    });\n  };\n  MoveableManager2.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    edge: false,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    parentPosition: null,\n    portalContainer: null,\n    useResizeObserver: false,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    passDragArea: false,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: false,\n    padding: {},\n    pinchOutside: true,\n    checkInput: false,\n    groupable: false,\n    hideDefaultLines: false,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {}\n  };\n  return MoveableManager2;\n}(PureComponent);\nvar Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean\n  },\n  events: {},\n  render: function(moveable, React) {\n    var targets = moveable.props.targets || [];\n    moveable.moveables = [];\n    var _a3 = moveable.state, left2 = _a3.left, top2 = _a3.top;\n    var position = {\n      left: left2,\n      top: top2\n    };\n    var props = moveable.props;\n    return targets.map(function(target, i2) {\n      return React.createElement(MoveableManager$1, {\n        key: \"moveable\" + i2,\n        ref: refs(moveable, \"moveables\", i2),\n        target,\n        origin: false,\n        cssStyled: props.cssStyled,\n        customStyledMap: props.customStyledMap,\n        useResizeObserver: props.useResizeObserver,\n        parentMoveable: moveable,\n        parentPosition: position\n      });\n    });\n  }\n};\nvar Clickable = makeAble(\"clickable\", {\n  props: {\n    clickable: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: true,\n  dragRelation: \"weak\",\n  dragStart: function(moveable, e) {\n    if (!e.isRequest) {\n      addEvent(window, \"click\", moveable.onPreventClick, true);\n    }\n  },\n  dragControlStart: function(moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroupStart: function(moveable, e) {\n    this.dragStart(moveable, e);\n    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n  },\n  dragEnd: function(moveable, e) {\n    this.endEvent(moveable);\n    var target = moveable.state.target;\n    var inputEvent = e.inputEvent;\n    var inputTarget = e.inputTarget;\n    var isMoveableElement = moveable.isMoveableElement(inputTarget);\n    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);\n    if (!e.isDrag || containsElement) {\n      this.unset(moveable);\n    }\n    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement) {\n      return;\n    }\n    var containsTarget = target.contains(inputTarget);\n    triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      inputTarget,\n      isTarget: target === inputTarget,\n      containsTarget\n    }));\n  },\n  dragGroupEnd: function(moveable, e) {\n    this.endEvent(moveable);\n    var inputEvent = e.inputEvent;\n    var inputTarget = e.inputTarget;\n    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || e.datas.inputTarget === inputTarget) {\n      return;\n    }\n    var targets = moveable.props.targets;\n    var targetIndex = targets.indexOf(inputTarget);\n    var isTarget = targetIndex > -1;\n    var containsTarget = false;\n    if (targetIndex === -1) {\n      targetIndex = findIndex(targets, function(parentTarget) {\n        return parentTarget.contains(inputTarget);\n      });\n      containsTarget = targetIndex > -1;\n    }\n    triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      targets,\n      inputTarget,\n      targetIndex,\n      isTarget,\n      containsTarget\n    }));\n  },\n  dragControlEnd: function(moveable, e) {\n    this.dragEnd(moveable, e);\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    this.dragEnd(moveable, e);\n  },\n  endEvent: function(moveable) {\n    var _this = this;\n    requestAnimationFrame$1(function() {\n      _this.unset(moveable);\n    });\n  },\n  unset: function(moveable) {\n    removeEvent(window, \"click\", moveable.onPreventClick, true);\n  }\n});\nfunction getDraggableEvent(e) {\n  var datas = e.originalDatas.draggable;\n  if (!datas) {\n    e.originalDatas.draggable = {};\n    datas = e.originalDatas.draggable;\n  }\n  return __assign$1$1(__assign$1$1({}, e), {\n    datas\n  });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  dragControlCondition: function(moveable, e) {\n    if (!moveable.props.edgeDraggable || !e.inputEvent) {\n      return false;\n    }\n    var target = e.inputEvent.target;\n    return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n  },\n  dragControlStart: function(moveable, e) {\n    return Draggable.dragStart(moveable, getDraggableEvent(e));\n  },\n  dragControl: function(moveable, e) {\n    return Draggable.drag(moveable, getDraggableEvent(e));\n  },\n  dragControlEnd: function(moveable, e) {\n    return Draggable.dragEnd(moveable, getDraggableEvent(e));\n  },\n  dragGroupControlCondition: function(moveable, e) {\n    if (!moveable.props.edgeDraggable || !e.inputEvent) {\n      return false;\n    }\n    var target = e.inputEvent.target;\n    return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n  },\n  dragGroupControlStart: function(moveable, e) {\n    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n  },\n  dragGroupControl: function(moveable, e) {\n    return Draggable.dragGroup(moveable, getDraggableEvent(e));\n  },\n  dragGroupControlEnd: function(moveable, e) {\n    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n  },\n  unset: function(moveable) {\n    return Draggable.unset(moveable);\n  }\n});\nvar IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean\n  },\n  events: {}\n};\nvar MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];\nvar MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {\n  return __assign$1$1(__assign$1$1({}, current), \"events\" in able ? able.events : {});\n}, {});\nvar MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {\n  return __assign$1$1(__assign$1$1({}, current), able.props);\n}, {});\nvar MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nvar MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);\nvar MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nfunction getMaxPos(poses, index) {\n  return Math.max.apply(Math, poses.map(function(_a3) {\n    var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];\n    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\nfunction getMinPos(poses, index) {\n  return Math.min.apply(Math, poses.map(function(_a3) {\n    var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];\n    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\nfunction getGroupRect(moveables, rotation) {\n  if (!moveables.length) {\n    return [0, 0, 0, 0];\n  }\n  var moveablePoses = moveables.map(function(_a3) {\n    var state = _a3.state;\n    return getAbsolutePosesByState(state);\n  });\n  var minX = MAX_NUM;\n  var minY = MAX_NUM;\n  var groupWidth = 0;\n  var groupHeight = 0;\n  var fixedRotation = throttle(rotation, TINY_NUM);\n  if (fixedRotation % 90) {\n    var rad_1 = fixedRotation / 180 * Math.PI;\n    var a1_1 = Math.tan(rad_1);\n    var a2_1 = -1 / a1_1;\n    var b1MinMax_1 = [MIN_NUM, MAX_NUM];\n    var b2MinMax_1 = [MIN_NUM, MAX_NUM];\n    moveablePoses.forEach(function(poses) {\n      poses.forEach(function(pos) {\n        var b1 = pos[1] - a1_1 * pos[0];\n        var b2 = pos[1] - a2_1 * pos[0];\n        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);\n        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);\n        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);\n        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);\n      });\n    });\n    b1MinMax_1.forEach(function(b1) {\n      b2MinMax_1.forEach(function(b2) {\n        var x2 = (b2 - b1) / (a1_1 - a2_1);\n        var y2 = a1_1 * x2 + b1;\n        minX = Math.min(minX, x2);\n        minY = Math.min(minY, y2);\n      });\n    });\n    var rotatePoses = moveablePoses.map(function(_a3) {\n      var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];\n      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];\n    });\n    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n  } else {\n    minX = getMinPos(moveablePoses, 0);\n    minY = getMinPos(moveablePoses, 1);\n    groupWidth = getMaxPos(moveablePoses, 0) - minX;\n    groupHeight = getMaxPos(moveablePoses, 1) - minY;\n    if (fixedRotation % 180) {\n      var changedWidth = groupWidth;\n      groupWidth = groupHeight;\n      groupHeight = changedWidth;\n    }\n  }\n  return [minX, minY, groupWidth, groupHeight];\n}\nvar MoveableGroup = /* @__PURE__ */ function(_super) {\n  __extends$1(MoveableGroup2, _super);\n  function MoveableGroup2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.differ = new ChildrenDiffer$1();\n    _this.moveables = [];\n    _this.transformOrigin = \"50% 50%\";\n    return _this;\n  }\n  var __proto = MoveableGroup2.prototype;\n  __proto.checkUpdate = function() {\n    this.updateAbles();\n  };\n  __proto.updateRect = function(type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n    if (!this.controlBox) {\n      return;\n    }\n    this.moveables.forEach(function(moveable) {\n      moveable.updateRect(type, false, false);\n    });\n    var state = this.state;\n    var props = this.props;\n    var target = state.target || props.target;\n    if (!isTarget || type !== \"\" && props.updateGroup) {\n      this.rotation = props.defaultGroupRotate;\n      this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n      this.scale = [1, 1];\n    }\n    var rotation = this.rotation;\n    var scale = this.scale;\n    var _a3 = getGroupRect(this.moveables, rotation), left2 = _a3[0], top2 = _a3[1], width = _a3[2], height = _a3[3];\n    var transform = \"rotate(\".concat(rotation, \"deg) scale(\").concat(scale[0] >= 0 ? 1 : -1, \", \").concat(scale[1] >= 0 ? 1 : -1, \")\");\n    target.style.cssText += \"left:0px;top:0px; transform-origin: \".concat(this.transformOrigin, \"; width:\").concat(width, \"px; height:\").concat(height, \"px;\") + \"transform:\".concat(transform);\n    state.width = width;\n    state.height = height;\n    var container = this.getContainer();\n    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);\n    var pos = [info.left, info.top];\n    var _b3 = getAbsolutePosesByState(info), pos1 = _b3[0], pos2 = _b3[1], pos3 = _b3[2], pos4 = _b3[3];\n    var minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n    var delta = [minPos.minX, minPos.minY];\n    info.pos1 = minus(pos1, delta);\n    info.pos2 = minus(pos2, delta);\n    info.pos3 = minus(pos3, delta);\n    info.pos4 = minus(pos4, delta);\n    info.left = left2 - info.left + delta[0];\n    info.top = top2 - info.top + delta[1];\n    info.origin = minus(plus(pos, info.origin), delta);\n    info.beforeOrigin = minus(plus(pos, info.beforeOrigin), delta);\n    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin);\n    var clientRect = info.targetClientRect;\n    var direction = scale[0] * scale[1] > 0 ? 1 : -1;\n    clientRect.top += info.top - state.top;\n    clientRect.left += info.left - state.left;\n    target.style.transform = \"translate(\".concat(-delta[0], \"px, \").concat(-delta[1], \"px) \").concat(transform);\n    this.updateState(__assign$1$1(__assign$1$1({}, info), {\n      direction,\n      beforeDirection: direction\n    }), isSetState);\n  };\n  __proto.getRect = function() {\n    return __assign$1$1(__assign$1$1({}, _super.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(child) {\n        return child.getRect();\n      })\n    });\n  };\n  __proto.triggerEvent = function(name, e, isManager) {\n    if (isManager || name.indexOf(\"Group\") > -1) {\n      return _super.prototype.triggerEvent.call(this, name, e);\n    } else {\n      this._emitter.trigger(name, e);\n    }\n  };\n  __proto.updateAbles = function() {\n    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, true), [Groupable], false), \"Group\");\n  };\n  __proto._updateTargets = function() {\n    _super.prototype._updateTargets.call(this);\n    this._prevTarget = this.props.dragTarget || this.areaElement;\n  };\n  __proto._updateEvents = function() {\n    var state = this.state;\n    var props = this.props;\n    var prevTarget = this._prevTarget;\n    var nextTarget = props.dragTarget || this.areaElement;\n    if (prevTarget !== nextTarget) {\n      unset(this, \"targetGesto\");\n      unset(this, \"controlGesto\");\n      state.target = null;\n    }\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.getElement().style.display = \"block\";\n      this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n    }\n    var isContainerChanged = !equals(state.container, props.container);\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n    var _a3 = this.differ.update(props.targets), added = _a3.added, changed = _a3.changed, removed = _a3.removed;\n    if (isContainerChanged || added.length || changed.length || removed.length) {\n      this.updateRect();\n    }\n  };\n  __proto._updateObserver = function() {\n  };\n  MoveableGroup2.defaultProps = __assign$1$1(__assign$1$1({}, MoveableManager$1.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  });\n  return MoveableGroup2;\n}(MoveableManager$1);\nvar MoveableIndividualGroup = /* @__PURE__ */ function(_super) {\n  __extends$1(MoveableIndividualGroup2, _super);\n  function MoveableIndividualGroup2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.moveables = [];\n    return _this;\n  }\n  var __proto = MoveableIndividualGroup2.prototype;\n  __proto.render = function() {\n    var _this = this;\n    var _a3 = this.props, cspNonce = _a3.cspNonce, ControlBoxElement = _a3.cssStyled, targets = _a3.targets;\n    return createElement(ControlBoxElement, {\n      cspNonce,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, targets.map(function(target, i2) {\n      return createElement(MoveableManager$1, __assign$1$1({\n        key: \"moveable\" + i2,\n        ref: refs(_this, \"moveables\", i2)\n      }, _this.props, {\n        target,\n        wrapperMoveable: _this\n      }));\n    }));\n  };\n  __proto.componentDidUpdate = function() {\n  };\n  __proto.updateRect = function(type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n    this.moveables.forEach(function(moveable) {\n      moveable.updateRect(type, isTarget, isSetState);\n    });\n  };\n  __proto.getRect = function() {\n    return __assign$1$1(__assign$1$1({}, _super.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(child) {\n        return child.getRect();\n      })\n    });\n  };\n  __proto.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  };\n  __proto.dragStart = function() {\n    return this;\n  };\n  __proto.hitTest = function() {\n    return 0;\n  };\n  __proto.isInside = function() {\n    return false;\n  };\n  __proto.isDragging = function() {\n    return false;\n  };\n  __proto.updateRenderPoses = function() {\n  };\n  __proto.checkUpdate = function() {\n  };\n  __proto.triggerEvent = function() {\n  };\n  __proto.updateAbles = function() {\n  };\n  __proto._updateEvents = function() {\n  };\n  __proto._updateObserver = function() {\n  };\n  return MoveableIndividualGroup2;\n}(MoveableManager$1);\nvar InitialMoveable = /* @__PURE__ */ function(_super) {\n  __extends$1(InitialMoveable2, _super);\n  function InitialMoveable2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.refTargets = [];\n    _this.selectorMap = {};\n    return _this;\n  }\n  var __proto = InitialMoveable2.prototype;\n  InitialMoveable2.makeStyled = function() {\n    var cssMap = {};\n    var ables = this.getTotalAbles();\n    ables.forEach(function(_a3) {\n      var css = _a3.css;\n      if (!css) {\n        return;\n      }\n      css.forEach(function(text2) {\n        cssMap[text2] = true;\n      });\n    });\n    var style = getKeys(cssMap).join(\"\\n\");\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n  };\n  InitialMoveable2.getTotalAbles = function() {\n    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, true);\n  };\n  __proto.render = function() {\n    var moveableContructor = this.constructor;\n    if (!moveableContructor.defaultStyled) {\n      moveableContructor.makeStyled();\n    }\n    var _a3 = this.props, userAbles = _a3.ables, userProps = _a3.props, props = __rest(_a3, [\"ables\", \"props\"]);\n    var refTargets = this._updateRefs(true);\n    var elementTargets = getElementTargets(refTargets, this.selectorMap);\n    var isGroup = elementTargets.length > 1;\n    var totalAbles = moveableContructor.getTotalAbles();\n    var ables = __spreadArray(__spreadArray([], totalAbles, true), userAbles || [], true);\n    var nextProps = __assign$1$1(__assign$1$1(__assign$1$1({}, props), userProps || {}), {\n      ables,\n      cssStyled: moveableContructor.defaultStyled,\n      customStyledMap: moveableContructor.customStyledMap\n    });\n    if (isGroup) {\n      if (props.individualGroupable) {\n        return createElement(MoveableIndividualGroup, __assign$1$1({\n          key: \"individual-group\",\n          ref: ref(this, \"moveable\")\n        }, nextProps, {\n          target: null,\n          targets: elementTargets\n        }));\n      }\n      return createElement(MoveableGroup, __assign$1$1({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, nextProps, {\n        target: null,\n        targets: elementTargets\n      }));\n    } else {\n      return createElement(MoveableManager$1, __assign$1$1({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, nextProps, {\n        target: elementTargets[0]\n      }));\n    }\n  };\n  __proto.componentDidMount = function() {\n    this._updateRefs();\n  };\n  __proto.componentDidUpdate = function() {\n    this._updateRefs();\n  };\n  __proto.componentWillUnmount = function() {\n    this.selectorMap = {};\n    this.refTargets = [];\n  };\n  __proto.getManager = function() {\n    return this.moveable;\n  };\n  __proto._updateRefs = function(isRender) {\n    var prevRefTargets = this.refTargets;\n    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);\n    var isBrowser = typeof document !== \"undefined\";\n    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function(target, i2) {\n      var nextTarget = nextRefTargets[i2];\n      if (!target && !nextTarget) {\n        return false;\n      } else if (target !== nextTarget) {\n        return true;\n      }\n      return false;\n    });\n    var selectorMap = this.selectorMap;\n    var nextSelectorMap = {};\n    this.refTargets.forEach(function(target) {\n      if (isString(target)) {\n        var selectorTarget = selectorMap[target];\n        if (selectorTarget) {\n          nextSelectorMap[target] = selectorMap[target];\n        } else if (isBrowser) {\n          isUpdate = true;\n          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n        }\n      }\n    });\n    this.refTargets = nextRefTargets;\n    this.selectorMap = nextSelectorMap;\n    if (!isRender && isUpdate) {\n      this.forceUpdate();\n    }\n    return nextRefTargets;\n  };\n  InitialMoveable2.defaultAbles = [];\n  InitialMoveable2.customStyledMap = {};\n  InitialMoveable2.defaultStyled = null;\n  __decorate$1([withMethods(MOVEABLE_METHODS)], InitialMoveable2.prototype, \"moveable\", void 0);\n  return InitialMoveable2;\n}(PureComponent);\nvar Moveable$2 = /* @__PURE__ */ function(_super) {\n  __extends$1(Moveable2, _super);\n  function Moveable2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Moveable2.defaultAbles = MOVEABLE_ABLES;\n  return Moveable2;\n}(InitialMoveable);\nvar Moveable$1$1 = Moveable$2;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(d2, b2) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p2 in b3)\n      if (b3.hasOwnProperty(p2))\n        d3[p2] = b3[p2];\n  };\n  return extendStatics(d2, b2);\n};\nfunction __extends(d2, b2) {\n  extendStatics(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __decorate(decorators, target, key, desc) {\n  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n    r2 = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i2 = decorators.length - 1; i2 >= 0; i2--)\n      if (d2 = decorators[i2])\n        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;\n  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;\n}\nvar InnerMoveable = /* @__PURE__ */ function(_super) {\n  __extends(InnerMoveable2, _super);\n  function InnerMoveable2(props) {\n    var _this = _super.call(this, props) || this;\n    _this.state = {};\n    _this.state = _this.props;\n    return _this;\n  }\n  var __proto = InnerMoveable2.prototype;\n  __proto.render = function() {\n    return createPortal(createElement(Moveable$1$1, __assign({\n      ref: ref(this, \"moveable\")\n    }, this.state)), this.state.parentElement);\n  };\n  return InnerMoveable2;\n}(Component);\nvar PROPERTIES = MOVEABLE_PROPS;\nvar METHODS = MOVEABLE_METHODS;\nvar EVENTS = MOVEABLE_EVENTS;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$1 = function() {\n  __assign$1 = Object.assign || function __assign2(t) {\n    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {\n      s2 = arguments[i2];\n      for (var p2 in s2)\n        if (Object.prototype.hasOwnProperty.call(s2, p2))\n          t[p2] = s2[p2];\n    }\n    return t;\n  };\n  return __assign$1.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)\n    s2 += arguments[i2].length;\n  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)\n    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)\n      r2[k] = a2[j2];\n  return r2;\n}\nvar EventEmitter = /* @__PURE__ */ function() {\n  function EventEmitter2() {\n    this._events = {};\n  }\n  var __proto = EventEmitter2.prototype;\n  __proto.on = function(eventName, listener) {\n    if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.on(name, eventName[name]);\n      }\n    } else {\n      this._addEvent(eventName, listener, {});\n    }\n    return this;\n  };\n  __proto.off = function(eventName, listener) {\n    if (!eventName) {\n      this._events = {};\n    } else if (isObject$2(eventName)) {\n      for (var name in eventName) {\n        this.off(name);\n      }\n    } else if (!listener) {\n      this._events[eventName] = [];\n    } else {\n      var events = this._events[eventName];\n      if (events) {\n        var index = findIndex(events, function(e) {\n          return e.listener === listener;\n        });\n        if (index > -1) {\n          events.splice(index, 1);\n        }\n      }\n    }\n    return this;\n  };\n  __proto.once = function(eventName, listener) {\n    var _this = this;\n    if (listener) {\n      this._addEvent(eventName, listener, {\n        once: true\n      });\n    }\n    return new Promise(function(resolve2) {\n      _this._addEvent(eventName, resolve2, {\n        once: true\n      });\n    });\n  };\n  __proto.emit = function(eventName, param) {\n    var _this = this;\n    if (param === void 0) {\n      param = {};\n    }\n    var events = this._events[eventName];\n    if (!eventName || !events) {\n      return true;\n    }\n    var isStop = false;\n    param.eventType = eventName;\n    param.stop = function() {\n      isStop = true;\n    };\n    param.currentTarget = this;\n    __spreadArrays(events).forEach(function(info) {\n      info.listener(param);\n      if (info.once) {\n        _this.off(eventName, info.listener);\n      }\n    });\n    return !isStop;\n  };\n  __proto.trigger = function(eventName, param) {\n    if (param === void 0) {\n      param = {};\n    }\n    return this.emit(eventName, param);\n  };\n  __proto._addEvent = function(eventName, listener, options) {\n    var events = this._events;\n    events[eventName] = events[eventName] || [];\n    var listeners = events[eventName];\n    listeners.push(__assign$1({\n      listener\n    }, options));\n  };\n  return EventEmitter2;\n}();\nvar MoveableManager = /* @__PURE__ */ function(_super) {\n  __extends(MoveableManager2, _super);\n  function MoveableManager2(parentElement, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.tempElement = document.createElement(\"div\");\n    var nextOptions = __assign({}, options);\n    var events = {};\n    EVENTS.forEach(function(name) {\n      events[camelize(\"on \" + name)] = function(e) {\n        return _this.trigger(name, e);\n      };\n    });\n    render(createElement(InnerMoveable, __assign({\n      ref: ref(_this, \"innerMoveable\"),\n      parentElement\n    }, nextOptions, events)), _this.tempElement);\n    var target = nextOptions.target;\n    if (isArray(target) && target.length > 1) {\n      _this.updateRect();\n    }\n    return _this;\n  }\n  var __proto = MoveableManager2.prototype;\n  __proto.setState = function(state, callback) {\n    this.innerMoveable.setState(state, callback);\n  };\n  __proto.forceUpdate = function(callback) {\n    this.innerMoveable.forceUpdate(callback);\n  };\n  __proto.dragStart = function(e) {\n    var innerMoveable = this.innerMoveable;\n    if (innerMoveable.$_timer) {\n      this.forceUpdate();\n    }\n    this.getMoveable().dragStart(e);\n  };\n  __proto.destroy = function() {\n    render(null, this.tempElement);\n    this.off();\n    this.tempElement = null;\n    this.innerMoveable = null;\n  };\n  __proto.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  };\n  MoveableManager2 = __decorate([Properties(METHODS, function(prototype, property) {\n    if (prototype[property]) {\n      return;\n    }\n    prototype[property] = function() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var self2 = this.getMoveable();\n      if (!self2 || !self2[property]) {\n        return;\n      }\n      return self2[property].apply(self2, args);\n    };\n  }), Properties(PROPERTIES, function(prototype, property) {\n    Object.defineProperty(prototype, property, {\n      get: function() {\n        return this.getMoveable().props[property];\n      },\n      set: function(value2) {\n        var _a3;\n        this.setState((_a3 = {}, _a3[property] = value2, _a3));\n      },\n      enumerable: true,\n      configurable: true\n    });\n  })], MoveableManager2);\n  return MoveableManager2;\n}(EventEmitter);\nvar Moveable = /* @__PURE__ */ function(_super) {\n  __extends(Moveable2, _super);\n  function Moveable2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return Moveable2;\n}(MoveableManager);\nvar Moveable$1 = Moveable;\nvar __accessCheck$2 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$2 = (obj, member, getter) => {\n  __accessCheck$2(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$2 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet$2 = (obj, member, value2, setter) => {\n  __accessCheck$2(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar __privateWrapper = (obj, member, setter, getter) => {\n  return {\n    set _(value2) {\n      __privateSet$2(obj, member, value2, setter);\n    },\n    get _() {\n      return __privateGet$2(obj, member, getter);\n    }\n  };\n};\nvar __privateMethod$2 = (obj, member, method) => {\n  __accessCheck$2(obj, member, \"access private method\");\n  return method;\n};\nvar _divDesignRoot, _scrItr, _alzTagArg, _cfg$1, _ID_DESIGNMODE, _cntDesignCast, _hId2dc, _aDC, _resizeDiv, resizeDiv_fn;\nconst _DesignCast = class {\n  constructor(bg_col, isLay = false) {\n    this.bg_col = bg_col;\n    this.isLay = isLay;\n    __privateAdd$2(this, _resizeDiv);\n    this.hArg = {};\n    this.id_tag = \"\";\n    this.hDesignArg = {\n      \"rotation\": 0,\n      \"pivot_x\": 0,\n      \"pivot_y\": 0,\n      \"left\": 0,\n      \"center\": 0,\n      \"right\": 0,\n      \"s_right\": 0,\n      \"top\": 0,\n      \"middle\": 0,\n      \"bottom\": 0,\n      \"s_bottom\": 0,\n      \"width\": 0,\n      \"height\": 0\n    };\n    this.fncLay = () => {\n    };\n    this.mov = void 0;\n    this.div = void 0;\n    this.lx = 0;\n    this.ly = 0;\n    this.rect = Rectangle.EMPTY;\n    this.pivot = new Point(0, 0);\n    this.scale = new Point(1, 1);\n    this.rotation = 0;\n    this.oldFn = () => \"\";\n    this.rotatable = true;\n  }\n  static init(appPixi, sys, scrItr, prpPrs, alzTagArg, cfg, hPages) {\n    appPixi.view.insertAdjacentHTML(\"beforebegin\", `<div id=\"${__privateGet$2(_DesignCast, _ID_DESIGNMODE)}\" style=\"width: ${CmnLib.stageW * _DesignCast.sys.cvsScale}px; height: ${CmnLib.stageH * sys.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`);\n    __privateSet$2(_DesignCast, _divDesignRoot, document.getElementById(__privateGet$2(_DesignCast, _ID_DESIGNMODE)));\n    _DesignCast.divHint.classList.add(\"sn_design_hint\");\n    appPixi.view.parentElement.appendChild(_DesignCast.divHint);\n    _DesignCast.sys = sys;\n    __privateSet$2(_DesignCast, _scrItr, scrItr);\n    _DesignCast.prpPrs = prpPrs;\n    __privateSet$2(_DesignCast, _alzTagArg, alzTagArg);\n    __privateSet$2(_DesignCast, _cfg$1, cfg);\n    _DesignCast.hPages = hPages;\n    addStyle(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(txt, x2, y2, dc) {\n    _DesignCast.divHint.innerHTML = txt;\n    const s2 = window.getComputedStyle(_DesignCast.divHint);\n    const w2 = parseFloat(s2.width);\n    const h2 = parseFloat(s2.height);\n    _DesignCast.divHint.style.cssText = `display: block; left: ${Math.max(10, dc.lx + x2 - w2)}px;\n\t\ttop: ${Math.max(10, dc.ly + y2 - h2 - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const s2 = __privateGet$2(_DesignCast, _divDesignRoot).style;\n    s2.width = `${CmnLib.stageW * _DesignCast.sys.cvsScale}px`;\n    s2.height = `${CmnLib.stageH * _DesignCast.sys.cvsScale}px`;\n  }\n  destroy() {\n    var _a3;\n    this.div = void 0;\n    (_a3 = this.mov) == null ? void 0 : _a3.destroy();\n    this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(hArg) {\n    var _a3, _b3;\n    if (!this.includeDesignArg(hArg))\n      return;\n    if (!this.id_tag)\n      this.id_tag = (_a3 = hArg[\":id_tag\"]) != null ? _a3 : \"\";\n    this.hArg = hArg;\n    const id_dc = (_b3 = hArg[\":id_dc\"]) != null ? _b3 : this.id_tag;\n    __privateGet$2(_DesignCast, _hId2dc)[id_dc] = this;\n  }\n  includeDesignArg(hArg) {\n    for (const name in hArg)\n      if (name in this.hDesignArg)\n        return true;\n    return false;\n  }\n  getRect() {\n    return Rectangle.EMPTY;\n  }\n  cnvPosArg(_x, _y) {\n    return {};\n  }\n  cnvSizeArg(_x, _y) {\n    return {};\n  }\n  setPos(_x, _y) {\n  }\n  setSize(_w, _h) {\n  }\n  setOther(_hPrm2) {\n  }\n  adopt(idcCh) {\n    this.child = idcCh;\n    idcCh.parent = this;\n  }\n  static enterMode() {\n    _DesignCast.leaveMode();\n    __privateGet$2(_DesignCast, _divDesignRoot).style.display = \"inline\";\n    __privateSet$2(_DesignCast, _cntDesignCast, 0);\n    __privateSet$2(_DesignCast, _hId2dc, {});\n  }\n  static allHide() {\n    __privateGet$2(_DesignCast, _aDC).forEach((v2) => v2.visible = false);\n  }\n  set visible(v2) {\n    if (!this.div || !this.mov)\n      return;\n    this.div.style.display = v2 ? \"inline\" : \"none\";\n    this.mov.updateTarget();\n  }\n  static leaveMode() {\n    __privateGet$2(_DesignCast, _divDesignRoot).textContent = \"\";\n    __privateGet$2(_DesignCast, _divDesignRoot).style.display = \"none\";\n    __privateGet$2(_DesignCast, _aDC).forEach((v2) => v2.destroy());\n    __privateSet$2(_DesignCast, _aDC, []);\n  }\n  cvsResize() {\n    var _a3;\n    __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this);\n    (_a3 = this.mov) == null ? void 0 : _a3.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    var _a3, _b3;\n    const id_dc = (_a3 = this.hArg[\":id_dc\"]) != null ? _a3 : this.id_tag;\n    __privateGet$2(_DesignCast, _hId2dc)[id_dc] = this;\n    const d2 = this.div = document.createElement(\"div\");\n    d2.id = __privateGet$2(_DesignCast, _ID_DESIGNMODE) + \"_\" + ++__privateWrapper(_DesignCast, _cntDesignCast)._;\n    d2.classList.add(\"sn_design_cast\");\n    d2.dataset.id_dc = id_dc;\n    d2.style.backgroundColor = `${this.bg_col}`;\n    d2.style.display = \"none\";\n    this.rect = this.getRect();\n    __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this);\n    (this.parent ? (_b3 = document.querySelector(`[data-id_dc=\"${this.parent.id_tag}\"]`)) != null ? _b3 : __privateGet$2(_DesignCast, _divDesignRoot) : __privateGet$2(_DesignCast, _divDesignRoot)).appendChild(d2);\n    const tmp = {\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    };\n    const procStart = () => {\n      tmp.aPos = [NaN, NaN];\n      tmp.roDeg = this.rotation;\n      const dpx = this.pivot.x * _DesignCast.sys.cvsScale;\n      const dpy = this.pivot.y * _DesignCast.sys.cvsScale;\n      tmp.trOrg = `${dpx}px ${dpy}px`;\n      tmp.origin = [dpx, dpy];\n      Object.assign(this.mov, {\n        verticalGuidelines: [],\n        horizontalGuidelines: []\n      });\n    };\n    const procEnd = (o) => {\n      _DesignCast.sys.send2Dbg(\"_changeCast\", __spreadProps(__spreadValues({}, o), {\n        \":id_tag\": this.id_tag\n      }));\n      _DesignCast.divHint.style.display = \"none\";\n    };\n    const resizeEnd = () => {\n      const [dx, dy] = tmp.aPos;\n      if (isNaN(dx)) {\n        _DesignCast.divHint.style.display = \"none\";\n        return;\n      }\n      const ix = int(this.rect.x += dx / _DesignCast.sys.cvsScale + this.pivot.x);\n      const iy = int(this.rect.y += dy / _DesignCast.sys.cvsScale + this.pivot.y);\n      this.setPos(ix, iy);\n      const iw = uint(this.rect.width), ih = uint(this.rect.height);\n      this.setSize(iw, ih);\n      procEnd(__spreadValues(__spreadValues({}, this.cnvPosArg(ix, iy)), this.cnvSizeArg(iw, ih)));\n    };\n    let heCh = void 0;\n    this.mov = new Moveable$1(document.body, {\n      target: d2,\n      draggable: true,\n      resizable: true,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: true\n    }).on(\"dragStart\", (e) => {\n      var _a4;\n      procStart();\n      this.onDragStart();\n      const m2 = (_a4 = this.child) == null ? void 0 : _a4.mov;\n      if (m2) {\n        heCh = m2.target;\n        if (m2.isInside(e.clientX, e.clientY))\n          m2.target = void 0;\n      }\n    }).on(\"drag\", (e) => {\n      tmp.aPos = e.beforeTranslate;\n      this.procDragHint(e, e.left, e.top);\n    }).on(\"dragEnd\", () => {\n      var _a4, _b4;\n      resizeEnd();\n      if ((_a4 = this.child) == null ? void 0 : _a4.mov)\n        this.child.mov.target = heCh;\n      if ((_b4 = this.parent) == null ? void 0 : _b4.mov)\n        this.parent.mov.target = this.parent.div;\n    }).on(\"resizeStart\", procStart).on(\"resize\", (e) => {\n      d2.style.width = `${e.width}px`;\n      d2.style.height = `${e.height}px`;\n      tmp.aPos = e.drag.beforeTranslate;\n      this.rect.width = e.width / _DesignCast.sys.cvsScale;\n      this.rect.height = e.height / _DesignCast.sys.cvsScale;\n      this.procResizeHint(e, e.drag.left, e.drag.top);\n    }).on(\"resizeEnd\", resizeEnd).on(\"rotateStart\", (e) => {\n      procStart();\n      e.set(tmp.roDeg);\n    }).on(\"rotate\", (e) => {\n      tmp.roDeg = e.beforeRotate;\n      _DesignCast.setHint(int(tmp.roDeg) + \"\\u5EA6\", e.drag.left, e.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = tmp.roDeg;\n      this.setOther({});\n      procEnd({ rotation: int(tmp.roDeg) });\n    }).on(\"dragOriginStart\", () => procStart).on(\"dragOrigin\", (e) => {\n      tmp.trOrg = e.transformOrigin;\n      tmp.origin = e.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [dpx, dpy] = tmp.origin;\n      tmp.trOrg = `${dpx}px ${dpy}px`;\n      const px = this.pivot.x = dpx / _DesignCast.sys.cvsScale;\n      const py = this.pivot.y = dpy / _DesignCast.sys.cvsScale;\n      this.setOther({});\n      const ix = int(this.rect.x + px);\n      const iy = int(this.rect.y + py);\n      this.setPos(ix, iy);\n      procEnd(__spreadProps(__spreadValues({}, this.cnvPosArg(ix, iy)), {\n        pivot_x: int(px),\n        pivot_y: int(py)\n      }));\n    }).on(\"render\", () => {\n      const { aPos, roDeg, trOrg } = tmp;\n      d2.style.transformOrigin = trOrg;\n      d2.style.transform = `translate(${aPos[0]}px, ${aPos[1]}px) rotate(${roDeg}deg)`;\n    });\n    __privateGet$2(_DesignCast, _aDC).push(this);\n    d2.addEventListener(\"dragenter\", () => d2.classList.add(\"drag_border\"));\n    d2.addEventListener(\"dragover\", (e) => {\n      e.stopPropagation();\n      e.preventDefault();\n      if (e.dataTransfer)\n        e.dataTransfer.dropEffect = \"copy\";\n    });\n    d2.addEventListener(\"dragleave\", () => d2.classList.remove(\"drag_border\"));\n    d2.addEventListener(\"drop\", (e) => {\n      e.stopPropagation();\n      e.preventDefault();\n      d2.classList.remove(\"drag_border\");\n      const dt = e.dataTransfer;\n      if (!dt || dt.files.length === 0)\n        return;\n      const f2 = dt.files[0];\n      const o = {\n        \":id_tag\": this.id_tag,\n        fn: getFn(f2.name),\n        ext: getExt(f2.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: __privateGet$2(_DesignCast, _cfg$1).searchPath(this.oldFn(), Config.EXT_SPRITE)\n      };\n      f2.arrayBuffer().then((buf) => {\n        o.buf = buf;\n        try {\n          o.url = __privateGet$2(_DesignCast, _scrItr).cnvPath4Dbg(__privateGet$2(_DesignCast, _cfg$1).searchPath(f2.name, Config.EXT_SPRITE));\n        } catch {\n        }\n        _DesignCast.sys.send2Dbg(\"_dropFile\", o);\n      }).catch((e2) => console.error(`drop2dc %o`, e2));\n    });\n    d2.addEventListener(\"dblclick\", (e) => {\n      e.preventDefault();\n      _DesignCast.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(e, left2, top2) {\n    const [dx, dy] = e.beforeTranslate;\n    _DesignCast.setHint(`(${int(this.rect.x + dx / _DesignCast.sys.cvsScale)}, ${int(this.rect.y + dy / _DesignCast.sys.cvsScale)})`, left2, top2, this);\n  }\n  procResizeHint(e, left2, top2) {\n    _DesignCast.setHint(`(${int(e.drag.left)}, ${int(e.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`, left2, top2, this);\n  }\n  static replaceToken(o) {\n    var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _i, _j, _k;\n    const id_tag = o[\":id_tag\"];\n    const id_dc = id_tag;\n    const dc = __privateGet$2(_DesignCast, _hId2dc)[id_dc];\n    const d2 = document.querySelector(`div[data-id_dc='${id_dc}']`);\n    if (!d2 || !dc)\n      return;\n    const token = o[\":token\"];\n    __privateGet$2(_DesignCast, _scrItr).replace(o[\":idx_tkn\"], token);\n    const [_tag_name, args] = tagToken2Name_Args(token);\n    if (dc.child)\n      dc.child.hArg[\":token\"] = dc.hArg[\":token\"];\n    __privateGet$2(_DesignCast, _alzTagArg).go(args);\n    const p2 = __privateGet$2(_DesignCast, _alzTagArg).hPrm;\n    if (\"pivot_x\" in p2 || \"pivot_y\" in p2) {\n      const px = Number(_DesignCast.prpPrs.getValAmpersand((_a3 = p2.pivot_x.val) != null ? _a3 : \"0\"));\n      const py = Number(_DesignCast.prpPrs.getValAmpersand((_b3 = p2.pivot_y.val) != null ? _b3 : \"0\"));\n      if (isNaN(px) || isNaN(py))\n        DebugMng.myTrace(`pivot_x\\u304Bpivot_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${o[\":path\"].slice(13)} ln:${o[\":ln\"]})\n${token}`, \"F\");\n      dc.pivot.set(px, py);\n    }\n    if (\"left\" in p2 || \"top\" in p2 || \"x\" in p2 || \"y\" in p2) {\n      const x2 = int(_DesignCast.prpPrs.getValAmpersand((_d2 = (_c3 = p2.left.val) != null ? _c3 : p2.x.val) != null ? _d2 : \"0\"));\n      const y2 = int(_DesignCast.prpPrs.getValAmpersand((_f = (_e = p2.top.val) != null ? _e : p2.y.val) != null ? _f : \"0\"));\n      if (isNaN(x2) || isNaN(y2))\n        DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${o[\":path\"].slice(13)} ln:${o[\":ln\"]})\n${token}`, \"F\");\n      dc.rect.x = x2 - dc.pivot.x;\n      dc.rect.y = y2 - dc.pivot.y;\n      dc.setPos(x2, y2);\n    }\n    if (\"width\" in p2 || \"height\" in p2) {\n      const w2 = int(_DesignCast.prpPrs.getValAmpersand((_g = p2.width.val) != null ? _g : \"0\"));\n      const h2 = int(_DesignCast.prpPrs.getValAmpersand((_h = p2.height.val) != null ? _h : \"0\"));\n      if (isNaN(w2) || isNaN(h2))\n        DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${o[\":path\"].slice(13)} ln:${o[\":ln\"]})\n${token}`, \"F\");\n      dc.rect.width = w2;\n      dc.rect.height = h2;\n      dc.setSize(w2, h2);\n    }\n    if (\"scale_x\" in p2 || \"scale_y\" in p2) {\n      const sx = Number(_DesignCast.prpPrs.getValAmpersand((_i = p2.scale_x.val) != null ? _i : \"0\"));\n      const sy = Number(_DesignCast.prpPrs.getValAmpersand((_j = p2.scale_y.val) != null ? _j : \"0\"));\n      if (isNaN(sx) || isNaN(sy))\n        DebugMng.myTrace(`scale_x\\u304Bscale_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${o[\":path\"].slice(13)} ln:${o[\":ln\"]})\n${token}`, \"F\");\n      dc.scale.set(sx, sy);\n    }\n    if (\"rotation\" in p2) {\n      const r2 = Number(_DesignCast.prpPrs.getValAmpersand((_k = p2.rotation.val) != null ? _k : \"0\"));\n      if (isNaN(r2))\n        DebugMng.myTrace(`rotation\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${o[\":path\"].slice(13)} ln:${o[\":ln\"]})\n${token}`, \"F\");\n      dc.rotation = r2;\n    }\n    dc.setOther(p2);\n    dc.cvsResize();\n  }\n};\nlet DesignCast = _DesignCast;\n_divDesignRoot = /* @__PURE__ */ new WeakMap();\n_scrItr = /* @__PURE__ */ new WeakMap();\n_alzTagArg = /* @__PURE__ */ new WeakMap();\n_cfg$1 = /* @__PURE__ */ new WeakMap();\n_ID_DESIGNMODE = /* @__PURE__ */ new WeakMap();\n_cntDesignCast = /* @__PURE__ */ new WeakMap();\n_hId2dc = /* @__PURE__ */ new WeakMap();\n_aDC = /* @__PURE__ */ new WeakMap();\n_resizeDiv = /* @__PURE__ */ new WeakSet();\nresizeDiv_fn = function() {\n  this.fncLay();\n  if (this.div)\n    Object.assign(this.div.style, {\n      left: `${this.lx + this.rect.x * _DesignCast.sys.cvsScale}px`,\n      top: `${this.ly + this.rect.y * _DesignCast.sys.cvsScale}px`,\n      width: `${this.rect.width * _DesignCast.sys.cvsScale}px`,\n      height: `${this.rect.height * _DesignCast.sys.cvsScale}px`,\n      transformOrigin: `${this.pivot.x * _DesignCast.sys.cvsScale}px ${this.pivot.y * _DesignCast.sys.cvsScale}px`,\n      transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n    });\n};\n__privateAdd$2(DesignCast, _divDesignRoot, void 0);\n__privateAdd$2(DesignCast, _scrItr, void 0);\n__privateAdd$2(DesignCast, _alzTagArg, void 0);\n__privateAdd$2(DesignCast, _cfg$1, void 0);\nDesignCast.divHint = document.createElement(\"div\");\n__privateAdd$2(DesignCast, _ID_DESIGNMODE, \"DesignMode\");\n__privateAdd$2(DesignCast, _cntDesignCast, 0);\n__privateAdd$2(DesignCast, _hId2dc, {});\n__privateAdd$2(DesignCast, _aDC, []);\nclass GrpLayDesignCast extends DesignCast {\n  constructor(spLay, gl) {\n    super(\"#29e\", true);\n    __privateAdd2(this, _sp, void 0);\n    this.spLay = spLay;\n    this.gl = gl;\n    this.oldFn = () => {\n      var _a3;\n      return (_a3 = this.hArg.fn) != null ? _a3 : \"\";\n    };\n  }\n  setSp(sp) {\n    __privateSet2(this, _sp, sp);\n  }\n  getRect() {\n    var _a3, _b3, _c3, _d2;\n    return new Rectangle(this.spLay.x, this.spLay.y, (_b3 = (_a3 = __privateGet2(this, _sp)) == null ? void 0 : _a3.width) != null ? _b3 : 0, (_d2 = (_c3 = __privateGet2(this, _sp)) == null ? void 0 : _c3.height) != null ? _d2 : 0);\n  }\n  cnvPosArg(left2, top2) {\n    return { left: left2, top: top2 };\n  }\n  cnvSizeArg(width, height) {\n    return { width, height };\n  }\n  setPos(x2, y2) {\n    this.spLay.x = x2;\n    this.spLay.y = y2;\n  }\n  setSize(w2, h2) {\n    __privateGet2(this, _sp).width = w2;\n    __privateGet2(this, _sp).height = h2;\n  }\n  setOther(hPrm) {\n    var _a3;\n    if (\"fn\" in hPrm) {\n      const fn2 = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.fn.val) != null ? _a3 : \"\");\n      this.gl.lay({ fn: fn2 });\n    }\n    this.spLay.pivot.copyFrom(this.pivot);\n    this.spLay.scale.copyFrom(this.scale);\n    this.spLay.angle = this.rotation;\n  }\n}\n_sp = new WeakMap();\nclass TxtLayDesignCast extends DesignCast {\n  constructor(spLay, ts) {\n    super(\"#29e\", true);\n    this.spLay = spLay;\n    this.ts = ts;\n    this.hDesignArg = {\n      \"rotation\": 0,\n      \"pivot_x\": 0,\n      \"pivot_y\": 0,\n      \"left\": 0,\n      \"center\": 0,\n      \"right\": 0,\n      \"s_right\": 0,\n      \"top\": 0,\n      \"middle\": 0,\n      \"bottom\": 0,\n      \"s_bottom\": 0,\n      \"width\": 0,\n      \"height\": 0,\n      \"pl\": 0,\n      \"pr\": 0,\n      \"pt\": 0,\n      \"pb\": 0\n    };\n  }\n  getRect() {\n    const it = this.ts.infTL;\n    return new Rectangle(this.spLay.x, this.spLay.y, it.$width, it.$height);\n  }\n  cnvPosArg(left2, top2) {\n    return { left: left2, top: top2 };\n  }\n  cnvSizeArg(width, height) {\n    return { width, height };\n  }\n  setPos(x2, y2) {\n    this.spLay.position.set(x2, y2);\n    this.ts.lay(this.cnvPosArg(x2, y2));\n  }\n  setSize(w2, h2) {\n    this.ts.lay(this.cnvSizeArg(w2, h2));\n  }\n  setOther(hPrm) {\n    var _a3;\n    (_a3 = this.child) == null ? void 0 : _a3.setOther(hPrm);\n    this.spLay.pivot.copyFrom(this.pivot);\n    this.spLay.scale.copyFrom(this.scale);\n    this.spLay.angle = this.rotation;\n  }\n}\nclass TxtLayPadDesignCast extends DesignCast {\n  constructor(ts) {\n    super(\"#9e2\");\n    __privateAdd2(this, _procHint);\n    this.ts = ts;\n    this.rotatable = false;\n  }\n  getRect() {\n    const it = this.ts.infTL;\n    return new Rectangle(it.pad_left, it.pad_top, it.$width - it.pad_left - it.pad_right, it.$height - it.pad_top - it.pad_bottom);\n  }\n  cnvPosArg(pl, pt) {\n    return { pl, pt };\n  }\n  cnvSizeArg(w2, h2) {\n    const it = this.ts.infTL;\n    return {\n      pr: it.$width - it.pad_left - w2,\n      pb: it.$height - it.pad_top - h2\n    };\n  }\n  setPos(x2, y2) {\n    this.ts.lay(this.cnvPosArg(x2, y2));\n  }\n  setSize(w2, h2) {\n    this.ts.lay(__spreadProps(__spreadValues({}, this.cnvSizeArg(w2, h2)), { \":redraw\": true }));\n  }\n  setOther(hPrm) {\n    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;\n    const it = this.ts.infTL;\n    if (\"pl\" in hPrm || \"pt\" in hPrm) {\n      this.setPos(this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand((_b3 = (_a3 = hPrm.pl) == null ? void 0 : _a3.val) != null ? _b3 : `${it.pad_left}`)), this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand((_d2 = (_c3 = hPrm.pt) == null ? void 0 : _c3.val) != null ? _d2 : `${it.pad_top}`)));\n      this.cvsResize();\n    }\n    if (\"pr\" in hPrm || \"pb\" in hPrm) {\n      this.ts.lay({\n        pr: parseFloat(DesignCast.prpPrs.getValAmpersand((_f = (_e = hPrm.pr) == null ? void 0 : _e.val) != null ? _f : `${it.pad_right}`)),\n        pb: parseFloat(DesignCast.prpPrs.getValAmpersand((_h = (_g = hPrm.pb) == null ? void 0 : _g.val) != null ? _h : `${it.pad_bottom}`))\n      });\n      const rect = this.getRect();\n      this.setSize(this.rect.width = rect.width, this.rect.height = rect.height);\n      this.cvsResize();\n    }\n  }\n  procDragHint(e, left2, top2) {\n    const [dx, dy] = e.beforeTranslate;\n    __privateMethod2(this, _procHint, procHint_fn).call(this, left2, top2, dx, dy);\n  }\n  procResizeHint(e, left2, top2) {\n    const [dx, dy] = e.drag.beforeTranslate;\n    __privateMethod2(this, _procHint, procHint_fn).call(this, left2, top2, dx, dy);\n  }\n}\n_procHint = new WeakSet();\nprocHint_fn = function(left2, top2, dx, dy) {\n  const x2 = this.rect.x, y2 = this.rect.y;\n  const w2 = this.rect.width, h2 = this.rect.height;\n  const it = this.ts.infTL;\n  const pl = int(x2 + dx / DesignCast.sys.cvsScale);\n  const pt = int(y2 + dy / DesignCast.sys.cvsScale);\n  const pr = int(it.$width - pl - w2);\n  const pb = int(it.$height - pt - h2);\n  const sp = (re2) => \"&nbsp;\".repeat(re2);\n  DesignCast.setHint(sp(5 + 5 + 1) + `\\u4E0A\\u5E45=${pt}<br/>\n\t\t\t\\u5DE6\\u5E45=${pl + sp(1 + 3 + 5 + 1)}\\u53F3\\u5E45=${pr}<br/>` + sp(5) + `\\u5185\\u5074 ${int(w2)} x ${int(h2)}<br/>` + sp(5 + 5) + `\\u4E0B\\u5E45=${pb}`, left2, top2, this);\n};\nclass BtnDesignCast extends DesignCast {\n  constructor(btn, hArg) {\n    super(\"#e92\");\n    this.btn = btn;\n    this.hArg = hArg;\n    this.pivot.x = argChk_Num(hArg, \"pivot_x\", this.pivot.x);\n    this.pivot.y = argChk_Num(hArg, \"pivot_y\", this.pivot.y);\n    this.scale.x = argChk_Num(hArg, \"scale_x\", this.scale.x);\n    this.scale.y = argChk_Num(hArg, \"scale_y\", this.scale.y);\n    this.rotation = argChk_Num(hArg, \"rotation\", this.rotation);\n    this.sethArg(hArg);\n  }\n  sethArg(hArg) {\n    var _a3;\n    super.sethArg(hArg);\n    const layer = (_a3 = this.hArg.layer) != null ? _a3 : \"\";\n    this.fncLay = !this.parent && !this.child && layer ? () => {\n      const f2 = DesignCast.hPages[layer].fore;\n      this.lx = f2.x * DesignCast.sys.cvsScale;\n      this.ly = f2.y * DesignCast.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(left2, top2) {\n    return { left: left2, top: top2 };\n  }\n  cnvSizeArg(width, height) {\n    return { width, height };\n  }\n  setPos(x2, y2) {\n    this.btn.x = x2;\n    this.btn.y = y2;\n  }\n  setOther(_hPrm2) {\n    this.btn.pivot.copyFrom(this.pivot);\n    this.btn.scale.copyFrom(this.scale);\n    this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n    const aBtn = this.btn.parent.children.filter((b2) => b2 !== this.btn);\n    Object.assign(this.mov, {\n      verticalGuidelines: aBtn.map((b2) => this.lx + b2.x * DesignCast.sys.cvsScale),\n      horizontalGuidelines: aBtn.map((b2) => this.ly + b2.y * DesignCast.sys.cvsScale)\n    });\n  }\n}\nclass TxtBtnDesignCast extends BtnDesignCast {\n  constructor(btn, hArg, txt) {\n    super(btn, hArg);\n    this.txt = txt;\n    this.oldFn = () => {\n      var _a3;\n      return (_a3 = this.hArg.b_pic) != null ? _a3 : \"\";\n    };\n    if (!argChk_Boolean(hArg, \"design\", true)) {\n      this.setPos = () => {\n      };\n      this.setSize = () => {\n      };\n    }\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(w2, h2) {\n    this.txt.width = w2;\n    this.txt.height = h2;\n  }\n  setOther(hPrm) {\n    var _a3;\n    super.setOther(hPrm);\n    if (\"b_pic\" in hPrm) {\n      const b_pic = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.b_pic.val) != null ? _a3 : \"\");\n      this.btn.update_b_pic(b_pic, this.txt);\n    }\n  }\n}\nclass PicBtnDesignCast extends BtnDesignCast {\n  constructor(btn, hArg) {\n    super(btn, hArg);\n    __privateAdd2(this, _sp2, void 0);\n    this.oldFn = () => {\n      var _a3;\n      return (_a3 = this.hArg.pic) != null ? _a3 : \"\";\n    };\n  }\n  setSp(sp) {\n    __privateSet2(this, _sp2, sp);\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, __privateGet2(this, _sp2).width, __privateGet2(this, _sp2).height);\n  }\n  setSize(w2, h2) {\n    __privateGet2(this, _sp2).width = w2;\n    __privateGet2(this, _sp2).height = h2;\n  }\n  setOther(hPrm) {\n    var _a3;\n    super.setOther(hPrm);\n    if (\"pic\" in hPrm) {\n      const pic = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.pic.val) != null ? _a3 : \"\");\n      this.btn.update_pic(pic, __privateGet2(this, _sp2));\n    }\n  }\n}\n_sp2 = new WeakMap();\nvar __accessCheck$1 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$1 = (obj, member, getter) => {\n  __accessCheck$1(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$1 = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet$1 = (obj, member, value2, setter) => {\n  __accessCheck$1(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar __privateMethod$1 = (obj, member, method) => {\n  __accessCheck$1(obj, member, \"access private method\");\n  return method;\n};\nvar _elc, _hFace, _main, _cfg, _appPixi, _sys, _glbVol, _movVol, _evtMng, _idc$1, _csvFn, _sBkFn, _sBkFace, _width, _height, _dec2cache, _sortAFrameName, sortAFrameName_fn, _dec2cache4Cripto, dec2cache4Cripto_fn, _mkSprite, mkSprite_fn, _rtTsy, _spTsy, _fncRender, _hAEncImg, _hEncImgOUrl;\nconst _GrpLayer = class extends Layer {\n  constructor() {\n    super();\n    __privateAdd$1(this, _idc$1, new GrpLayDesignCast(this.spLay, this));\n    __privateAdd$1(this, _csvFn, \"\");\n    __privateAdd$1(this, _sBkFn, \"\");\n    __privateAdd$1(this, _sBkFace, \"\");\n    this.lay = (hArg) => this.laySub(hArg, (isStop) => {\n      if (isStop)\n        __privateGet$1(_GrpLayer, _main).resume();\n    });\n    __privateAdd$1(this, _width, 0);\n    __privateAdd$1(this, _height, 0);\n    __privateAdd$1(this, _rtTsy, void 0);\n    __privateAdd$1(this, _spTsy, void 0);\n    __privateAdd$1(this, _fncRender, () => {\n    });\n    this.record = () => Object.assign(super.record(), {\n      sBkFn: __privateGet$1(this, _sBkFn),\n      sBkFace: __privateGet$1(this, _sBkFace),\n      idc_hArg: __privateGet$1(this, _idc$1).gethArg()\n    });\n    this.dump = () => super.dump() + `, \"pic\":\"${__privateGet$1(this, _csvFn)}\"`;\n    if (CmnLib.isDbg) {\n      this.setSp = (sp) => __privateGet$1(this, _idc$1).setSp(sp);\n      this.cvsResize = () => {\n        super.cvsResize();\n        __privateGet$1(this, _idc$1).cvsResize();\n      };\n    }\n  }\n  static init(main2, cfg, appPixi, sys, sndMng) {\n    __privateSet$1(_GrpLayer, _main, main2);\n    __privateSet$1(_GrpLayer, _cfg, cfg);\n    __privateSet$1(_GrpLayer, _appPixi, appPixi);\n    __privateSet$1(_GrpLayer, _sys, sys);\n    const fnc = () => {\n      const vol = __privateGet$1(_GrpLayer, _glbVol) * __privateGet$1(_GrpLayer, _movVol);\n      for (const fn2 in _GrpLayer.hFn2VElm)\n        _GrpLayer.hFn2VElm[fn2].volume = vol;\n    };\n    sndMng.setNoticeChgVolume((vol) => {\n      __privateSet$1(_GrpLayer, _glbVol, vol);\n      fnc();\n    }, (vol) => {\n      __privateSet$1(_GrpLayer, _movVol, vol);\n      fnc();\n    });\n    if (__privateGet$1(_GrpLayer, _sys).crypto)\n      __privateSet$1(_GrpLayer, _dec2cache, __privateMethod$1(_GrpLayer, _dec2cache4Cripto, dec2cache4Cripto_fn));\n  }\n  static setEvtMng(evtMng) {\n    __privateSet$1(_GrpLayer, _evtMng, evtMng);\n  }\n  static destroy() {\n    __privateGet$1(_GrpLayer, _elc).clear();\n    __privateSet$1(_GrpLayer, _hFace, {});\n    _GrpLayer.hFn2ResAniSpr = {};\n    _GrpLayer.hFn2VElm = {};\n  }\n  setSp(_sp3) {\n  }\n  laySub(hArg, resolve2) {\n    const { fn: fn2, face = \"\" } = hArg;\n    __privateGet$1(this, _idc$1).sethArg(hArg);\n    if (!fn2) {\n      super.lay(hArg);\n      if (this.spLay.children.length > 0)\n        this.setPos(hArg);\n      __privateSet$1(this, _sBkFn, \"\");\n      __privateSet$1(this, _csvFn, __privateSet$1(this, _sBkFace, face));\n      resolve2(false);\n      return false;\n    }\n    const inFn = \"fn\" in hArg;\n    const inFace = \"face\" in hArg;\n    this.clearLay({ filter: \"true\" });\n    if (inFn)\n      __privateSet$1(this, _sBkFn, fn2);\n    if (inFace)\n      __privateSet$1(this, _sBkFace, face);\n    super.lay(hArg);\n    hArg.dx = 0;\n    hArg.dy = 0;\n    const ret = _GrpLayer.csv2Sprites(__privateSet$1(this, _csvFn, fn2 + (face ? \",\" + face : \"\")), this.spLay, (sp) => {\n      if (\"width\" in hArg || \"height\" in hArg) {\n        sp.width = argChk_Num(hArg, \"width\", 0);\n        sp.height = argChk_Num(hArg, \"height\", 0);\n      }\n      __privateSet$1(this, _width, sp.width);\n      __privateSet$1(this, _height, sp.height);\n      Layer.setXY(sp, hArg, this.spLay, true);\n      this.setSp(sp);\n    }, (isStop) => {\n      Layer.setBlendmode(this.spLay, hArg);\n      resolve2(isStop);\n    });\n    if (!ret)\n      resolve2(false);\n    return ret;\n  }\n  get width() {\n    return __privateGet$1(this, _width);\n  }\n  get height() {\n    return __privateGet$1(this, _height);\n  }\n  static csv2Sprites(csv, parent, fncFirstComp, fncAllComp = () => {\n  }) {\n    let needLoad = false;\n    if (csv.slice(0, 5) === \"data:\") {\n      const fnc = () => {\n        const sp = Sprite.from(csv);\n        parent == null ? void 0 : parent.addChild(sp);\n        fncFirstComp(sp);\n        fncAllComp(needLoad);\n      };\n      if (csv in TextureCache)\n        fnc();\n      else {\n        needLoad = true;\n        new Loader().add(csv, csv).load(fnc);\n      }\n      return needLoad;\n    }\n    const aComp = [];\n    const ldr = new Loader();\n    csv.split(\",\").forEach((fn2, i2) => {\n      if (!fn2)\n        throw \"face\\u5C5E\\u6027\\u306B\\u7A7A\\u8981\\u7D20\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059\";\n      const f2 = __privateGet$1(_GrpLayer, _hFace)[fn2] || {\n        fn: fn2,\n        dx: 0,\n        dy: 0,\n        blendmode: BLEND_MODES$3.NORMAL\n      };\n      const fnc = i2 === 0 ? fncFirstComp : (sp) => {\n        sp.x = f2.dx;\n        sp.y = f2.dy;\n        sp.blendMode = f2.blendmode;\n      };\n      aComp.push({ fn: f2.fn, fnc });\n      if (f2.fn in _GrpLayer.hFn2ResAniSpr)\n        return;\n      if (f2.fn in TextureCache)\n        return;\n      if (f2.fn in Loader.shared.resources)\n        return;\n      needLoad = true;\n      const url2 = __privateGet$1(_GrpLayer, _cfg).searchPath(f2.fn, Config.EXT_SPRITE);\n      const xt = __privateGet$1(this, _sys).crypto ? { xhrType: url2.slice(-5) === \".json\" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};\n      ldr.add(__spreadProps(__spreadValues({}, xt), { name: f2.fn, url: url2 }));\n    });\n    const fncLoaded = (hRes) => {\n      var _a3;\n      for (const v2 of aComp) {\n        const sp = __privateMethod$1(_a3 = _GrpLayer, _mkSprite, mkSprite_fn).call(_a3, v2.fn, hRes);\n        sp.name = v2.fn;\n        parent == null ? void 0 : parent.addChild(sp);\n        v2.fnc(sp);\n      }\n      fncAllComp(needLoad);\n    };\n    if (needLoad) {\n      ldr.use((res, next) => {\n        __privateGet$1(this, _sys).dec(res.extension, res.data).then((r2) => {\n          var _a3;\n          return __privateGet$1(_a3 = _GrpLayer, _dec2cache).call(_a3, r2, res, () => next == null ? void 0 : next());\n        }).catch((e) => __privateGet$1(this, _main).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${res.name} ${e}`, false));\n      }).load((_ldr, hRes) => fncLoaded(hRes));\n    } else\n      fncLoaded({});\n    return needLoad;\n  }\n  static wv(hArg) {\n    const { fn: fn2 } = hArg;\n    if (!fn2)\n      throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const hve = _GrpLayer.hFn2VElm[fn2];\n    if (!hve || hve.loop)\n      return false;\n    if (hve.ended) {\n      delete _GrpLayer.hFn2VElm[fn2];\n      return false;\n    }\n    const fnc = () => {\n      hve.removeEventListener(\"ended\", fnc);\n      delete _GrpLayer.hFn2VElm[fn2];\n      __privateGet$1(this, _main).resume();\n    };\n    hve.addEventListener(\"ended\", fnc, { once: true, passive: true });\n    return __privateGet$1(_GrpLayer, _evtMng).waitEvent(() => {\n      hve.pause();\n      fnc();\n    }, argChk_Boolean(hArg, \"canskip\", true), argChk_Boolean(hArg, \"global\", false));\n  }\n  renderStart() {\n    __privateSet$1(this, _rtTsy, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    __privateSet$1(this, _spTsy, new Sprite(__privateGet$1(this, _rtTsy)));\n    __privateGet$1(this, _spTsy).visible = false;\n    this.spLay.addChildAt(__privateGet$1(this, _spTsy), 0);\n    __privateGet$1(this, _spTsy).position.set(-this.spLay.x, -this.spLay.y);\n    let fncRenderFore = () => {\n      const a2 = this.spLay.alpha;\n      this.spLay.alpha = 1;\n      this.spLay.children.forEach((s2) => s2.visible = true);\n      __privateGet$1(this, _spTsy).visible = false;\n      __privateGet$1(_GrpLayer, _appPixi).renderer.render(this.spLay, { renderTexture: __privateGet$1(this, _rtTsy) });\n      this.spLay.alpha = a2;\n      this.spLay.children.forEach((s2) => s2.visible = false);\n    };\n    if (!this.containMovement) {\n      let oldFnc = fncRenderFore;\n      fncRenderFore = () => {\n        fncRenderFore = () => {\n        };\n        oldFnc();\n      };\n    }\n    __privateSet$1(this, _fncRender, () => {\n      fncRenderFore();\n      __privateGet$1(this, _spTsy).visible = true;\n    });\n    __privateGet$1(_GrpLayer, _appPixi).ticker.add(__privateGet$1(this, _fncRender));\n  }\n  renderEnd() {\n    __privateGet$1(_GrpLayer, _appPixi).ticker.remove(__privateGet$1(this, _fncRender));\n    this.spLay.removeChild(__privateGet$1(this, _spTsy));\n    this.spLay.children.forEach((s2) => s2.visible = true);\n    __privateGet$1(this, _spTsy).destroy(true);\n  }\n  static loadPic2Img(src, img, onload) {\n    const oUrl = __privateGet$1(this, _hEncImgOUrl)[src];\n    if (oUrl) {\n      img.src = oUrl;\n      return;\n    }\n    const aImg = __privateGet$1(this, _hAEncImg)[src];\n    if (aImg) {\n      aImg.push(img);\n      return;\n    }\n    __privateGet$1(this, _hAEncImg)[src] = [img];\n    const url2 = __privateGet$1(_GrpLayer, _cfg).searchPath(src, Config.EXT_SPRITE);\n    const ld2 = new Loader().add({ name: src, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });\n    if (__privateGet$1(_GrpLayer, _sys).crypto)\n      ld2.use((res, next) => {\n        __privateGet$1(_GrpLayer, _sys).dec(res.extension, res.data).then((r2) => {\n          if (res.extension !== \"bin\") {\n            next == null ? void 0 : next();\n            return;\n          }\n          res.data = r2;\n          if (r2 instanceof HTMLImageElement) {\n            res.type = LoaderResource.TYPE.IMAGE;\n          }\n          next == null ? void 0 : next();\n        }).catch((e) => __privateGet$1(_GrpLayer, _main).errScript(`GrpLayer loadPic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${res.name} ${e}`, false));\n      });\n    ld2.load((_ldr, hRes) => {\n      for (const s2 in hRes) {\n        const u2 = __privateGet$1(this, _hEncImgOUrl)[s2] = hRes[s2].data.src;\n        __privateGet$1(this, _hAEncImg)[s2].forEach((i2) => {\n          i2.src = u2;\n          if (onload)\n            i2.onload = () => onload(i2);\n        });\n        delete __privateGet$1(this, _hAEncImg)[s2];\n      }\n    });\n  }\n  setPos(hArg) {\n    Layer.setXY(this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0], hArg, this.spLay, true);\n  }\n  static add_face(hArg) {\n    const { name } = hArg;\n    if (!name)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (name in __privateGet$1(_GrpLayer, _hFace))\n      throw \"\\u4E00\\u3064\\u306Ename\\uFF08\" + name + \"\\uFF09\\u306B\\u5BFE\\u3057\\u3066\\u540C\\u3058\\u753B\\u50CF\\u3092\\u8907\\u6570\\u5272\\u308A\\u5F53\\u3066\\u3089\\u308C\\u307E\\u305B\\u3093\";\n    const { fn: fn2 = name } = hArg;\n    __privateGet$1(_GrpLayer, _hFace)[name] = {\n      fn: fn2,\n      dx: argChk_Num(hArg, \"dx\", 0),\n      dy: argChk_Num(hArg, \"dy\", 0),\n      blendmode: Layer.getBlendmodeNum(hArg.blendmode || \"\")\n    };\n    return false;\n  }\n  static clearFace2Name() {\n    __privateSet$1(_GrpLayer, _hFace, {});\n  }\n  get containMovement() {\n    if (__privateGet$1(this, _csvFn) === \"\")\n      return false;\n    const c2 = this.spLay.children;\n    return __privateGet$1(this, _csvFn).split(\",\").some((fn2, i2) => c2[i2] instanceof AnimatedSprite || _GrpLayer.hFn2VElm[fn2]);\n  }\n  clearLay(hArg) {\n    super.clearLay(hArg);\n    for (const c2 of this.spLay.removeChildren())\n      c2.destroy();\n    __privateSet$1(this, _sBkFn, \"\");\n    __privateSet$1(this, _sBkFace, \"\");\n    __privateSet$1(this, _csvFn, \"\");\n  }\n  playback(hLay, aPrm) {\n    super.playback(hLay, aPrm);\n    if (hLay.sBkFn === \"\" && hLay.sBkFace === \"\") {\n      __privateSet$1(this, _sBkFn, hLay.sBkFn);\n      __privateSet$1(this, _sBkFace, hLay.sBkFace);\n      __privateGet$1(this, _idc$1).sethArg(hLay.idc_hArg);\n      return;\n    }\n    aPrm.push(new Promise((re2) => this.laySub({ fn: hLay.sBkFn, face: hLay.sBkFace, left: hLay.x, top: hLay.y, alpha: hLay.alpha, blendmode: hLay.blendMode, rotation: hLay.rotation, scale_x: hLay.scale_x, scale_y: hLay.scale_y }, (_isStop) => {\n      this.spLay.position.set(hLay.x, hLay.y);\n      re2();\n    })));\n  }\n  makeDesignCast(gdc) {\n    if (!this.spLay.visible)\n      return;\n    gdc(__privateGet$1(this, _idc$1));\n  }\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    __privateGet$1(this, _idc$1).visible = true;\n  }\n};\nlet GrpLayer = _GrpLayer;\n_elc = /* @__PURE__ */ new WeakMap();\n_hFace = /* @__PURE__ */ new WeakMap();\n_main = /* @__PURE__ */ new WeakMap();\n_cfg = /* @__PURE__ */ new WeakMap();\n_appPixi = /* @__PURE__ */ new WeakMap();\n_sys = /* @__PURE__ */ new WeakMap();\n_glbVol = /* @__PURE__ */ new WeakMap();\n_movVol = /* @__PURE__ */ new WeakMap();\n_evtMng = /* @__PURE__ */ new WeakMap();\n_idc$1 = /* @__PURE__ */ new WeakMap();\n_csvFn = /* @__PURE__ */ new WeakMap();\n_sBkFn = /* @__PURE__ */ new WeakMap();\n_sBkFace = /* @__PURE__ */ new WeakMap();\n_width = /* @__PURE__ */ new WeakMap();\n_height = /* @__PURE__ */ new WeakMap();\n_dec2cache = /* @__PURE__ */ new WeakMap();\n_sortAFrameName = /* @__PURE__ */ new WeakSet();\nsortAFrameName_fn = function(aFn) {\n  const a_base_name = /([^\\d]+)\\d+\\.(\\w+)/.exec(aFn[0]);\n  if (!a_base_name)\n    return;\n  const is = a_base_name[1].length;\n  const ie = -a_base_name[2].length - 1;\n  aFn.sort((a2, b2) => int(a2.slice(is, ie)) > int(b2.slice(is, ie)) ? 1 : -1);\n};\n_dec2cache4Cripto = /* @__PURE__ */ new WeakSet();\ndec2cache4Cripto_fn = function(r2, res, next) {\n  var _a3;\n  res.data = r2;\n  if (res.extension === \"bin\") {\n    if (r2 instanceof HTMLImageElement) {\n      res.texture = Texture.fromLoader(r2, res.url, res.name);\n      res.type = LoaderResource.TYPE.IMAGE;\n      URL.revokeObjectURL(r2.src);\n    } else if (r2 instanceof HTMLVideoElement) {\n      r2.volume = __privateGet$1(_GrpLayer, _glbVol);\n      _GrpLayer.hFn2VElm[res.name] = r2;\n      res.type = LoaderResource.TYPE.VIDEO;\n      URL.revokeObjectURL(r2.src);\n    }\n  }\n  if (res.extension !== \"json\") {\n    next();\n    return;\n  }\n  if (typeof r2 !== \"string\") {\n    next();\n    return;\n  }\n  const o = res.data = JSON.parse(r2);\n  res.type = LoaderResource.TYPE.JSON;\n  if (!((_a3 = o.meta) == null ? void 0 : _a3.image)) {\n    next();\n    return;\n  }\n  const fn2 = getFn(o.meta.image);\n  const url2 = __privateGet$1(_GrpLayer, _cfg).searchPath(fn2, Config.EXT_SPRITE);\n  new Loader().use((res2, next2) => {\n    __privateGet$1(this, _sys).dec(res2.extension, res2.data).then((r22) => {\n      res2.data = r22;\n      if (r22 instanceof HTMLImageElement) {\n        res2.type = LoaderResource.TYPE.IMAGE;\n        URL.revokeObjectURL(r22.src);\n      }\n      next2 == null ? void 0 : next2();\n    }).catch((e) => __privateGet$1(this, _main).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 dec2res4Cripto fn:${res2.name} ${e}`, false));\n  }).add({ name: fn2, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((ldr, _hRes) => {\n    var _a4;\n    for (const fn22 in ldr.resources) {\n      const bt = Texture.from(ldr.resources[fn22].data).baseTexture;\n      const aFn = Object.values(o.frames);\n      __privateMethod$1(_a4 = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(_a4, aFn);\n      _GrpLayer.hFn2ResAniSpr[res.name] = {\n        aTex: aFn.map((f2) => new Texture(bt, new Rectangle(f2.frame.x, f2.frame.y, f2.frame.w, f2.frame.h))),\n        meta: o.meta\n      };\n    }\n    next();\n  });\n};\n_mkSprite = /* @__PURE__ */ new WeakSet();\nmkSprite_fn = function(fn2, hRes) {\n  var _a3;\n  const ras = _GrpLayer.hFn2ResAniSpr[fn2];\n  if (ras) {\n    const asp = new AnimatedSprite(ras.aTex);\n    asp.animationSpeed = (_a3 = ras.meta.animationSpeed) != null ? _a3 : 1;\n    asp.play();\n    return asp;\n  }\n  if (fn2 in TextureCache)\n    return Sprite.from(fn2);\n  if (fn2 in _GrpLayer.hFn2VElm)\n    return Sprite.from(_GrpLayer.hFn2VElm[fn2]);\n  return fn2 in hRes ? new Sprite(hRes[fn2].texture) : new Sprite();\n};\n_rtTsy = /* @__PURE__ */ new WeakMap();\n_spTsy = /* @__PURE__ */ new WeakMap();\n_fncRender = /* @__PURE__ */ new WeakMap();\n_hAEncImg = /* @__PURE__ */ new WeakMap();\n_hEncImgOUrl = /* @__PURE__ */ new WeakMap();\n__privateAdd$1(GrpLayer, _sortAFrameName);\n__privateAdd$1(GrpLayer, _dec2cache4Cripto);\n__privateAdd$1(GrpLayer, _mkSprite);\n__privateAdd$1(GrpLayer, _elc, new EventListenerCtn());\n__privateAdd$1(GrpLayer, _hFace, {});\n__privateAdd$1(GrpLayer, _main, void 0);\n__privateAdd$1(GrpLayer, _cfg, void 0);\n__privateAdd$1(GrpLayer, _appPixi, void 0);\n__privateAdd$1(GrpLayer, _sys, void 0);\n__privateAdd$1(GrpLayer, _glbVol, 1);\n__privateAdd$1(GrpLayer, _movVol, 1);\n__privateAdd$1(GrpLayer, _evtMng, void 0);\nGrpLayer.hFn2ResAniSpr = {};\n__privateAdd$1(GrpLayer, _dec2cache, (_r2, res, next) => {\n  var _a3;\n  switch (res.type) {\n    case LoaderResource.TYPE.JSON:\n      const aFn = res.spritesheet._frameKeys;\n      __privateMethod$1(_a3 = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(_a3, aFn);\n      _GrpLayer.hFn2ResAniSpr[res.name] = {\n        aTex: aFn.map((fn2) => Texture.from(fn2)),\n        meta: res.data.meta\n      };\n      break;\n    case LoaderResource.TYPE.VIDEO:\n      const hve = res.data;\n      hve.volume = __privateGet$1(_GrpLayer, _glbVol);\n      _GrpLayer.hFn2VElm[res.name] = hve;\n  }\n  next();\n});\nGrpLayer.hFn2VElm = {};\n__privateAdd$1(GrpLayer, _hAEncImg, {});\n__privateAdd$1(GrpLayer, _hEncImgOUrl, {});\nconst _TxtStage = class extends Container {\n  constructor(spLay, canFocus, sys) {\n    super();\n    __privateAdd2(this, _lay_sub);\n    __privateAdd2(this, _htm2tx);\n    __privateAdd2(this, _spWork);\n    __privateAdd2(this, _getChRects);\n    __privateAdd2(this, _clearText);\n    __privateAdd2(this, _htmTxt, document.createElement(\"span\"));\n    __privateAdd2(this, _cntTxt, new Container());\n    __privateAdd2(this, _grpDbgMasume, new Graphics());\n    __privateAdd2(this, _idc2, new TxtLayDesignCast(this.spLay, this));\n    __privateAdd2(this, _idcCh, new TxtLayPadDesignCast(this));\n    __privateAdd2(this, _infTL, {\n      fontsize: 24,\n      $width: 0,\n      $height: 0,\n      pad_left: 0,\n      pad_right: 0,\n      pad_top: 0,\n      pad_bottom: 0\n    });\n    __privateAdd2(this, _break_fixed, false);\n    __privateAdd2(this, _break_fixed_left, 0);\n    __privateAdd2(this, _break_fixed_top, 0);\n    __privateAdd2(this, _left, 0);\n    __privateAdd2(this, _isTategaki, false);\n    __privateAdd2(this, _padTx4x, 0);\n    __privateAdd2(this, _padTx4y, 0);\n    __privateAdd2(this, _ch_filter, void 0);\n    __privateAdd2(this, _aSpTw, []);\n    __privateAdd2(this, _aRect, []);\n    __privateAdd2(this, _lenHtmTxt, 0);\n    __privateAdd2(this, _REGDS, /animation\\-duration: (?<ms>\\d+)ms;/);\n    __privateAdd2(this, _fncEndChIn, () => {\n    });\n    __privateAdd2(this, _isChInIng, false);\n    __privateAdd2(this, _lh_half, 0);\n    __privateAdd2(this, _fi_easing, \"Quadratic.Out\");\n    __privateAdd2(this, _fo_easing, \"Quadratic.Out\");\n    __privateAdd2(this, _sss, void 0);\n    this.spLay = spLay;\n    this.canFocus = canFocus;\n    this.sys = sys;\n    __privateGet2(this, _htmTxt).classList.add(\"sn_tx\");\n    __privateGet2(this, _htmTxt).style.position = \"absolute\";\n    __privateGet2(_TxtStage, _appPixi2).view.parentElement.appendChild(__privateGet2(this, _htmTxt));\n    this.addChild(__privateGet2(this, _cntTxt));\n    this.addChild(__privateGet2(this, _grpDbgMasume));\n    __privateGet2(this, _grpDbgMasume).name = \"grpDbgMasume\";\n    __privateGet2(this, _idc2).adopt(__privateGet2(this, _idcCh));\n  }\n  static init(cfg, appPixi) {\n    __privateSet2(_TxtStage, _cfg2, cfg);\n    __privateSet2(_TxtStage, _appPixi2, appPixi);\n    __privateSet2(_TxtStage, _reg\\u884C\\u982D\\u7981\\u5247, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/);\n    __privateSet2(_TxtStage, _reg\\u884C\\u672B\\u7981\\u5247, /[［（｛〈「『【〔“〝]/);\n    __privateSet2(_TxtStage, _reg\\u5206\\u5272\\u7981\\u6B62, /[─‥…]/);\n  }\n  static setEvtMng(evtMng) {\n    __privateSet2(_TxtStage, _evtMng3, evtMng);\n  }\n  static destroy() {\n    __privateSet2(_TxtStage, _hWarning, {\n      backgroundColor: 0,\n      borderBottomWidth: 0,\n      borderLeftWidth: 0,\n      borderRightWidth: 0,\n      borderTopWidth: 0,\n      marginBottom: 0,\n      marginLeft: 0,\n      marginRight: 0,\n      marginTop: 0\n    });\n    __privateSet2(_TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));\n    __privateSet2(_TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));\n    __privateSet2(_TxtStage, _cntBreak, new Container());\n  }\n  lay(hArg) {\n    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;\n    const s2 = __privateGet2(this, _htmTxt).style;\n    if (hArg.style) {\n      const cln = document.createElement(\"span\");\n      cln.style.cssText = hArg.style;\n      const len = cln.style.length;\n      for (let i2 = 0; i2 < len; ++i2) {\n        const key = cln.style[i2];\n        if (key in __privateGet2(_TxtStage, _hWarning)) {\n          DebugMng.myTrace(`${key}\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093`, \"W\");\n          continue;\n        }\n        s2[key] = cln.style[key];\n      }\n      if (!cln.style.opacity && \"alpha\" in hArg)\n        s2.opacity = String(this.spLay.alpha);\n    } else if (\"alpha\" in hArg)\n      s2.opacity = String(this.spLay.alpha);\n    if (\"width\" in hArg)\n      s2.width = ((_a3 = hArg.width) != null ? _a3 : \"0\") + \"px\";\n    if (\"height\" in hArg)\n      s2.height = ((_b3 = hArg.height) != null ? _b3 : \"0\") + \"px\";\n    if (\"pl\" in hArg)\n      s2.paddingLeft = ((_c3 = hArg.pl) != null ? _c3 : \"0\") + \"px\";\n    if (\"pr\" in hArg)\n      s2.paddingRight = ((_d2 = hArg.pr) != null ? _d2 : \"0\") + \"px\";\n    if (\"pt\" in hArg)\n      s2.paddingTop = ((_e = hArg.pt) != null ? _e : \"0\") + \"px\";\n    if (\"pb\" in hArg)\n      s2.paddingBottom = ((_f = hArg.pb) != null ? _f : \"0\") + \"px\";\n    if (\"kinsoku_sol\" in hArg)\n      __privateSet2(_TxtStage, _reg\\u884C\\u982D\\u7981\\u5247, new RegExp(`[${hArg.kinsoku_sol}]`));\n    if (\"kinsoku_eol\" in hArg)\n      __privateSet2(_TxtStage, _reg\\u884C\\u672B\\u7981\\u5247, new RegExp(`[${hArg.kinsoku_eol}]`));\n    if (\"kinsoku_dns\" in hArg)\n      __privateSet2(_TxtStage, _reg\\u5206\\u5272\\u7981\\u6B62, new RegExp(`[${hArg.kinsoku_dns}]`));\n    __privateMethod2(this, _lay_sub, lay_sub_fn).call(this);\n    __privateGet2(this, _idc2).sethArg(hArg);\n    __privateSet2(this, _left, this.spLay.position.x);\n    s2.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`;\n    this.cvsResize();\n    s2.display = this.spLay.visible ? \"inline\" : \"none\";\n    s2.textShadow = (_h = (_g = hArg.filter) != null ? _g : s2.textShadow) != null ? _h : \"\";\n    __privateSet2(this, _break_fixed, argChk_Boolean(hArg, \"break_fixed\", __privateGet2(this, _break_fixed)));\n    __privateSet2(this, _break_fixed_left, argChk_Num(hArg, \"break_fixed_left\", __privateGet2(this, _break_fixed_left)));\n    __privateSet2(this, _break_fixed_top, argChk_Num(hArg, \"break_fixed_top\", __privateGet2(this, _break_fixed_top)));\n    if (\":redraw\" in hArg && __privateGet2(this, _lenHtmTxt) > 0) {\n      const aSpan = [\n        __privateGet2(this, _htmTxt).innerHTML.replace(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>\\u3000</span>`\n      ];\n      __privateMethod2(this, _clearText, clearText_fn).call(this);\n      this.goTxt(aSpan);\n    }\n  }\n  cvsResize() {\n    const s2 = __privateGet2(this, _htmTxt).style;\n    s2.left = `${this.sys.ofsLeft4elm + __privateGet2(this, _left) * this.sys.cvsScale}px`;\n    s2.top = `${this.sys.ofsTop4elm + this.spLay.position.y * this.sys.cvsScale}px`;\n    s2.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * this.sys.cvsScale}, ${this.spLay.scale.y * this.sys.cvsScale})`;\n    __privateGet2(this, _idc2).cvsResize();\n    __privateGet2(this, _idcCh).cvsResize();\n  }\n  get tategaki() {\n    return __privateGet2(this, _isTategaki);\n  }\n  get infTL() {\n    return __privateGet2(this, _infTL);\n  }\n  get getWidth() {\n    return __privateGet2(this, _infTL).$width;\n  }\n  get getHeight() {\n    return __privateGet2(this, _infTL).$height;\n  }\n  setSize(width, height) {\n    __privateGet2(this, _infTL).$width = width;\n    __privateGet2(this, _infTL).$height = height;\n    __privateGet2(this, _htmTxt).style.width = __privateGet2(this, _infTL).$width + \"px\";\n    __privateGet2(this, _htmTxt).style.height = __privateGet2(this, _infTL).$height + \"px\";\n  }\n  goTxt(aSpan) {\n    var _a3, _b3, _c3, _d2, _e;\n    __privateGet2(_TxtStage, _cntBreak).visible = false;\n    const begin = __privateGet2(this, _aRect).length;\n    if (begin === 0) {\n      if (__privateGet2(_TxtStage, _cfg2).oCfg.debug.masume) {\n        if (CmnLib.debugLog)\n          console.log(`\\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${__privateGet2(this, _infTL).pad_left} pr:${__privateGet2(this, _infTL).pad_right} pt:${__privateGet2(this, _infTL).pad_top} pb:${__privateGet2(this, _infTL).pad_bottom} w:${__privateGet2(this, _infTL).$width} h:${__privateGet2(this, _infTL).$height}`);\n        __privateGet2(this, _grpDbgMasume).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-__privateGet2(this, _infTL).pad_left, -__privateGet2(this, _infTL).pad_top, __privateGet2(this, _infTL).$width, __privateGet2(this, _infTL).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(0, 0, __privateGet2(this, _infTL).$width - __privateGet2(this, _infTL).pad_left - __privateGet2(this, _infTL).pad_right, __privateGet2(this, _infTL).$height - __privateGet2(this, _infTL).pad_top - __privateGet2(this, _infTL).pad_bottom).endFill();\n      }\n      __privateGet2(this, _htmTxt).innerHTML = [...aSpan].join(\"\").replaceAll(/[\\n\\t]/g, \"\");\n    } else\n      __privateGet2(this, _htmTxt).insertAdjacentHTML(\"beforeend\", aSpan.slice(__privateGet2(this, _lenHtmTxt)).join(\"\").replaceAll(/[\\n\\t]/g, \"\"));\n    __privateSet2(this, _lenHtmTxt, aSpan.length);\n    let len = 0;\n    let j2 = 2;\n    do {\n      const e = __privateSet2(this, _aRect, __privateMethod2(this, _getChRects, getChRects_fn).call(this, __privateGet2(this, _htmTxt)));\n      len = e.length;\n      if (this.sys.cvsScale !== 1) {\n        const ox = this.sys.ofsPadLeft_Dom2PIXI + parseFloat(__privateGet2(this, _htmTxt).style.left) * (1 - this.sys.cvsScale);\n        const oy = this.sys.ofsPadTop_Dom2PIXI + parseFloat(__privateGet2(this, _htmTxt).style.top) * (1 - this.sys.cvsScale);\n        for (let i2 = 0; i2 < len; ++i2) {\n          const r2 = e[i2].rect;\n          r2.x -= ox;\n          r2.y -= oy;\n          r2.x /= this.sys.cvsScale;\n          r2.y /= this.sys.cvsScale;\n          r2.width /= this.sys.cvsScale;\n          r2.height /= this.sys.cvsScale;\n        }\n      }\n      if (len < 2)\n        break;\n      let sl_xy = -Infinity;\n      for (; j2 < len; ++j2) {\n        const he = e[j2];\n        if (he.elm.outerHTML.slice(0, 3) === \"<rt\")\n          continue;\n        const xy = this.tategaki ? he.rect.y : he.rect.x;\n        if (sl_xy <= xy) {\n          sl_xy = xy;\n          continue;\n        }\n        sl_xy = -Infinity;\n        const oldJ = j2;\n        if (__privateGet2(_TxtStage, _reg\\u5206\\u5272\\u7981\\u6B62).test(e[j2 - 1].ch) && e[j2 - 1].ch === he.ch) {\n          --j2;\n        } else {\n          if (__privateGet2(_TxtStage, _reg\\u884C\\u672B\\u7981\\u5247).test(e[j2 - 1].ch)) {\n            --j2;\n          } else if (__privateGet2(_TxtStage, _reg\\u884C\\u982D\\u7981\\u5247).test(he.ch)) {\n            while (j2 > 0 && __privateGet2(_TxtStage, _reg\\u884C\\u982D\\u7981\\u5247).test(e[--j2].ch)) {\n            }\n          } else\n            continue;\n          while (j2 > 0 && __privateGet2(_TxtStage, _reg\\u884C\\u672B\\u7981\\u5247).test(e[j2 - 1].ch)) {\n            --j2;\n          }\n        }\n        const pal = e[j2].elm.parentElement;\n        const br = document.createElement(\"br\");\n        if (pal.classList.contains(\"sn_tx\"))\n          pal.insertBefore(br, e[j2].elm);\n        else {\n          const ppal = pal.parentElement;\n          if (ppal.classList.contains(\"sn_ch\")) {\n            ppal.parentElement.insertBefore(br, ppal);\n          } else\n            ppal.insertBefore(br, pal);\n        }\n        j2 += 2;\n        if (j2 < oldJ)\n          j2 = oldJ;\n        len = -1;\n        break;\n      }\n    } while (len < 0);\n    const fncMasumeLog = CmnLib.debugLog ? (v2, rct) => console.log(`\\u{1F34C} masume ch:${v2.ch} x:${rct.x} y:${rct.y} w:${rct.width} h:${rct.height}`) : () => {\n    };\n    const fncMasume = __privateGet2(_TxtStage, _cfg2).oCfg.debug.masume ? (v2, rct) => {\n      fncMasumeLog(v2, rct);\n      __privateGet2(this, _grpDbgMasume).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(rct.x, rct.y, rct.width, rct.height).endFill();\n    } : () => {\n    };\n    const ease = CmnTween.ease(__privateGet2(this, _fi_easing));\n    const bcr = __privateGet2(this, _htmTxt).getBoundingClientRect();\n    const sx = bcr.left + globalThis.scrollX + __privateGet2(this, _infTL).pad_left;\n    const sy = bcr.top + globalThis.scrollY + __privateGet2(this, _infTL).pad_top;\n    let rctLastCh = new Rectangle();\n    for (let i2 = begin; i2 < len; ++i2) {\n      const v2 = __privateGet2(this, _aRect)[i2];\n      const rct = v2.rect;\n      const arg = JSON.parse((_a3 = v2.arg) != null ? _a3 : '{\"delay\": 0}');\n      const add3 = JSON.parse((_b3 = v2.add) != null ? _b3 : \"{}\");\n      const cis = __privateGet2(_TxtStage, _hChInStyle)[add3.ch_in_style];\n      rct.x -= sx;\n      rct.y -= sy;\n      fncMasume(v2, rct);\n      if (cis) {\n        if (__privateGet2(this, _isTategaki)) {\n          rct.x += (rct.width - rct.height) / 2;\n          rct.width = rct.height;\n        } else {\n          rct.y += (rct.height - rct.width) / 2;\n          rct.height = rct.width;\n        }\n        rctLastCh = rct;\n      }\n      switch (v2.cmd) {\n        case \"grp\":\n          const cnt = new Container();\n          __privateGet2(this, _cntTxt).addChild(cnt);\n          GrpLayer.csv2Sprites(arg.pic, cnt, (sp2) => {\n            __privateMethod2(this, _spWork, spWork_fn).call(this, cnt, arg, add3, rct, ease, cis != null ? cis : {});\n            if (!cnt.parent)\n              cnt.removeChild(sp2);\n          });\n          break;\n        case \"link\":\n          const sp = new Sprite();\n          arg.key = `lnk=[${i2}] ` + this.name;\n          let eCh = v2.elm;\n          if (!eCh.classList.contains(\"sn_ch\"))\n            eCh = eCh.parentElement;\n          __privateMethod2(this, _spWork, spWork_fn).call(this, sp, arg, add3, rct, ease, cis != null ? cis : {});\n          (_c3 = arg.hint_tate) != null ? _c3 : arg.hint_tate = __privateGet2(this, _isTategaki);\n          const st_normal = eCh.style.cssText;\n          const st_hover = st_normal + ((_d2 = arg.style_hover) != null ? _d2 : \"\");\n          const st_clicked = st_normal + ((_e = arg.style_clicked) != null ? _e : \"\");\n          __privateGet2(_TxtStage, _evtMng3).button(arg, sp, () => eCh.style.cssText = st_normal, () => {\n            if (!this.canFocus())\n              return false;\n            eCh.style.cssText = st_hover;\n            return true;\n          }, () => eCh.style.cssText = st_clicked);\n          __privateGet2(this, _cntTxt).addChild(sp);\n          break;\n      }\n    }\n    const chs = __privateGet2(this, _htmTxt).querySelectorAll(\"span.sn_ch\");\n    chs.forEach((v2) => v2.className = v2.className.replace(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\"));\n    __privateSet2(this, _isChInIng, true);\n    __privateSet2(this, _fncEndChIn, () => {\n      __privateSet2(this, _isChInIng, false);\n      chs.forEach((v2) => v2.className = v2.className.replace(/ go_ch_in_[^\\s\"]+/g, \"\"));\n      if (begin !== len) {\n        __privateSet2(this, _break_fixed_left, rctLastCh.x + (__privateGet2(this, _isTategaki) ? 0 : rctLastCh.width));\n        __privateSet2(this, _break_fixed_top, rctLastCh.y + (__privateGet2(this, _isTategaki) ? rctLastCh.height : 0));\n      }\n      __privateGet2(_TxtStage, _cntBreak).position.set(__privateGet2(this, _break_fixed_left), __privateGet2(this, _break_fixed_top));\n      __privateGet2(_TxtStage, _cntBreak).visible = true;\n      __privateSet2(this, _fncEndChIn, () => {\n      });\n    });\n    const len_chs = chs.length;\n    if (len_chs === 0) {\n      __privateGet2(this, _fncEndChIn).call(this);\n      return;\n    }\n    let le = void 0;\n    for (let i2 = len_chs - 1; i2 >= 0; --i2) {\n      const v2 = chs[i2];\n      if (v2.className === \"sn_ch\")\n        break;\n      const st = v2.getAttribute(\"style\");\n      if (!st) {\n        le = v2;\n        break;\n      }\n      const m2 = st.match(__privateGet2(this, _REGDS));\n      const g2 = m2 == null ? void 0 : m2.groups;\n      if (!g2 || Number(g2.ms) > 0) {\n        le = v2;\n        break;\n      }\n    }\n    if (!le) {\n      __privateGet2(this, _fncEndChIn).call(this);\n      return;\n    }\n    le.addEventListener(\"animationend\", __privateGet2(this, _fncEndChIn), { once: true, passive: true });\n  }\n  skipChIn() {\n    let isLiveTw = __privateGet2(this, _isChInIng);\n    __privateGet2(this, _fncEndChIn).call(this);\n    __privateGet2(this, _aSpTw).forEach((st) => {\n      if (st.tw) {\n        st.tw.stop().end();\n        isLiveTw = true;\n      }\n    });\n    __privateSet2(this, _aSpTw, []);\n    return isLiveTw;\n  }\n  static initChStyle() {\n    __privateSet2(_TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));\n    __privateSet2(_TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(name) {\n    return __privateGet2(_TxtStage, _hChInStyle)[name];\n  }\n  static ch_in_style(hArg) {\n    var _a3, _b3, _c3;\n    const { name } = hArg;\n    if (!name)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (__privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).test(name))\n      throw `name\\u3010${name}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (name in __privateGet2(_TxtStage, _hChInStyle))\n      throw `name\\u3010${name}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const x2 = String((_a3 = hArg.x) != null ? _a3 : \"=0\");\n    const y2 = String((_b3 = hArg.y) != null ? _b3 : \"=0\");\n    return __privateGet2(_TxtStage, _hChInStyle)[name] = {\n      wait: argChk_Num(hArg, \"wait\", 500),\n      alpha: argChk_Num(hArg, \"alpha\", 0),\n      x: x2,\n      y: y2,\n      nx: parseFloat(x2.charAt(0) === \"=\" ? x2.slice(1) : x2),\n      ny: parseFloat(y2.charAt(0) === \"=\" ? y2.slice(1) : y2),\n      scale_x: argChk_Num(hArg, \"scale_x\", 1),\n      scale_y: argChk_Num(hArg, \"scale_y\", 1),\n      rotate: argChk_Num(hArg, \"rotate\", 0),\n      join: argChk_Boolean(hArg, \"join\", true),\n      ease: (_c3 = hArg.ease) != null ? _c3 : \"ease-out\"\n    };\n  }\n  static getChOutStyle(name) {\n    return __privateGet2(_TxtStage, _hChOutStyle)[name];\n  }\n  static ch_out_style(hArg) {\n    var _a3, _b3, _c3;\n    const { name } = hArg;\n    if (!name)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (__privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).test(name))\n      throw `name\\u3010${name}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (name in __privateGet2(_TxtStage, _hChOutStyle))\n      throw `name\\u3010${name}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const x2 = String((_a3 = hArg.x) != null ? _a3 : \"=0\");\n    const y2 = String((_b3 = hArg.y) != null ? _b3 : \"=0\");\n    return __privateGet2(_TxtStage, _hChOutStyle)[name] = {\n      wait: argChk_Num(hArg, \"wait\", 500),\n      alpha: argChk_Num(hArg, \"alpha\", 0),\n      x: x2,\n      y: y2,\n      nx: parseFloat(x2.charAt(0) === \"=\" ? x2.slice(1) : x2),\n      ny: parseFloat(y2.charAt(0) === \"=\" ? y2.slice(1) : y2),\n      scale_x: argChk_Num(hArg, \"scale_x\", 1),\n      scale_y: argChk_Num(hArg, \"scale_y\", 1),\n      rotate: argChk_Num(hArg, \"rotate\", 0),\n      join: argChk_Boolean(hArg, \"join\", false),\n      ease: (_c3 = hArg.ease) != null ? _c3 : \"ease-out\"\n    };\n  }\n  dispBreak(pic) {\n    const cnt = __privateGet2(_TxtStage, _cntBreak);\n    cnt.visible = false;\n    this.addChild(cnt);\n    GrpLayer.csv2Sprites(pic, cnt, (sp) => {\n      if (!cnt.parent)\n        cnt.removeChild(sp);\n    });\n  }\n  static delBreak() {\n    const cnt = __privateGet2(_TxtStage, _cntBreak);\n    if (cnt.parent) {\n      cnt.parent.removeChild(cnt);\n      cnt.removeChildren();\n    }\n    __privateSet2(_TxtStage, _cntBreak, new Container());\n  }\n  reNew() {\n    var _a3;\n    __privateMethod2(this, _clearText, clearText_fn).call(this);\n    const to = new _TxtStage(this.spLay, () => this.canFocus(), this.sys);\n    __privateSet2(to, _infTL, __privateGet2(this, _infTL));\n    __privateGet2(to, _htmTxt).style.cssText = __privateGet2(this, _htmTxt).style.cssText;\n    __privateSet2(to, _left, __privateGet2(this, _left));\n    to.name = this.name;\n    __privateMethod2(_a3 = to, _lay_sub, lay_sub_fn).call(_a3);\n    __privateGet2(to, _idc2).sethArg(__privateGet2(this, _idc2).gethArg());\n    __privateSet2(to, _ch_filter, __privateGet2(this, _ch_filter));\n    __privateSet2(to, _fi_easing, __privateGet2(this, _fi_easing));\n    __privateSet2(to, _fo_easing, __privateGet2(this, _fo_easing));\n    __privateSet2(to, _break_fixed, __privateGet2(this, _break_fixed));\n    __privateSet2(to, _break_fixed_left, __privateGet2(this, _break_fixed_left));\n    __privateSet2(to, _break_fixed_top, __privateGet2(this, _break_fixed_top));\n    this.destroy();\n    return to;\n  }\n  record() {\n    return {\n      infTL: __privateGet2(this, _infTL),\n      cssText: __privateGet2(this, _htmTxt).style.cssText,\n      left: __privateGet2(this, _left),\n      idc_hArg: __privateGet2(this, _idc2).gethArg(),\n      ch_filter: __privateGet2(this, _ch_filter),\n      fi_easing: __privateGet2(this, _fi_easing),\n      fo_easing: __privateGet2(this, _fo_easing),\n      break_fixed: __privateGet2(this, _break_fixed),\n      break_fixed_left: __privateGet2(this, _break_fixed_left),\n      break_fixed_top: __privateGet2(this, _break_fixed_top)\n    };\n  }\n  playback(hLay) {\n    var _a3, _b3, _c3;\n    __privateSet2(this, _infTL, hLay.infTL);\n    this.position.set(__privateGet2(this, _infTL).pad_left, __privateGet2(this, _infTL).pad_top);\n    __privateGet2(this, _htmTxt).style.cssText = hLay.cssText;\n    __privateSet2(this, _left, hLay.left);\n    __privateMethod2(this, _lay_sub, lay_sub_fn).call(this);\n    __privateGet2(this, _idc2).sethArg(hLay.idc_hArg);\n    __privateSet2(this, _ch_filter, hLay.ch_filter);\n    __privateSet2(this, _fi_easing, hLay.fi_easing);\n    __privateSet2(this, _fo_easing, hLay.fo_easing);\n    __privateSet2(this, _break_fixed, (_a3 = hLay.break_fixed) != null ? _a3 : false);\n    __privateSet2(this, _break_fixed_left, (_b3 = hLay.break_fixed_left) != null ? _b3 : 0);\n    __privateSet2(this, _break_fixed_top, (_c3 = hLay.break_fixed_top) != null ? _c3 : 0);\n  }\n  snapshot(rnd, re2) {\n    __privateMethod2(this, _htm2tx, htm2tx_fn).call(this, (tx) => {\n      __privateSet2(this, _sss, new Sprite(tx));\n      if (__privateGet2(this, _isTategaki)) {\n        __privateGet2(this, _sss).x += CmnLib.stageW - (__privateGet2(this, _left) + __privateGet2(this, _infTL).$width);\n      }\n      __privateGet2(this, _sss).y -= __privateGet2(this, _padTx4y);\n      __privateGet2(this, _sss).texture.frame = new Rectangle(0, 0, __privateGet2(this, _infTL).$width - __privateGet2(this, _left), __privateGet2(this, _infTL).$height);\n      __privateGet2(this, _cntTxt).addChild(__privateGet2(this, _sss));\n      rnd.render(__privateGet2(this, _sss), void 0, false);\n      re2();\n    }, false);\n  }\n  snapshot_end() {\n    if (__privateGet2(this, _sss)) {\n      __privateGet2(this, _cntTxt).removeChild(__privateGet2(this, _sss));\n      __privateSet2(this, _sss, void 0);\n    }\n  }\n  makeDesignCast(gdc) {\n    gdc(__privateGet2(this, _idc2));\n    const o = __privateGet2(this, _idc2).gethArg();\n    __privateGet2(this, _idcCh).sethArg(__spreadProps(__spreadValues({}, o), { \":id_dc\": o[\":id_tag\"] + \"_pad\" }));\n    gdc(__privateGet2(this, _idcCh));\n  }\n  showDesignCast() {\n    __privateGet2(this, _idc2).visible = true;\n    __privateGet2(this, _idcCh).visible = true;\n  }\n  dump() {\n    const aStyle = [];\n    const s2 = __privateGet2(this, _htmTxt).style;\n    const len = s2.length;\n    for (let i2 = 0; i2 < len; ++i2) {\n      const key = s2[i2];\n      aStyle.push(`\"${key}\":\"${s2[key].replace(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${__privateGet2(this, _htmTxt).textContent.replace(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${aStyle.join(\",\")}}`;\n  }\n  destroy() {\n    _TxtStage.delBreak();\n    __privateGet2(this, _htmTxt).parentElement.removeChild(__privateGet2(this, _htmTxt));\n    this.removeChild(__privateGet2(this, _cntTxt));\n    this.removeChild(__privateGet2(this, _grpDbgMasume));\n    super.destroy();\n  }\n};\nlet TxtStage = _TxtStage;\n_cfg2 = new WeakMap();\n_appPixi2 = new WeakMap();\n_evtMng3 = new WeakMap();\n_htmTxt = new WeakMap();\n_cntTxt = new WeakMap();\n_grpDbgMasume = new WeakMap();\n_idc2 = new WeakMap();\n_idcCh = new WeakMap();\n_infTL = new WeakMap();\n_break_fixed = new WeakMap();\n_break_fixed_left = new WeakMap();\n_break_fixed_top = new WeakMap();\n_lay_sub = new WeakSet();\nlay_sub_fn = function() {\n  var _a3;\n  const s2 = __privateGet2(this, _htmTxt).style;\n  const fs = parseFloat(s2.fontSize || \"0\");\n  __privateGet2(this, _infTL).fontsize = fs;\n  __privateGet2(this, _infTL).pad_left = parseFloat(s2.paddingLeft || \"0\");\n  __privateGet2(this, _infTL).pad_right = parseFloat(s2.paddingRight || \"0\");\n  __privateGet2(this, _infTL).pad_top = parseFloat(s2.paddingTop || \"0\");\n  __privateGet2(this, _infTL).pad_bottom = parseFloat(s2.paddingBottom || \"0\");\n  __privateGet2(this, _infTL).$width = parseFloat(s2.width || \"0\");\n  __privateGet2(this, _infTL).$height = parseFloat(s2.height || \"0\");\n  this.position.set(__privateGet2(this, _infTL).pad_left, __privateGet2(this, _infTL).pad_top);\n  __privateSet2(this, _isTategaki, s2.writingMode === \"vertical-rl\");\n  __privateSet2(this, _padTx4x, 0);\n  __privateSet2(this, _padTx4y, 0);\n  const lh = (_a3 = s2.lineHeight) != null ? _a3 : \"0\";\n  __privateSet2(this, _lh_half, __privateGet2(this, _isTategaki) ? 0 : (lh.slice(-2) === \"px\" ? parseFloat(lh) : fs * parseFloat(lh) - fs) / 2);\n};\n_left = new WeakMap();\n_isTategaki = new WeakMap();\n_padTx4x = new WeakMap();\n_padTx4y = new WeakMap();\n_hWarning = new WeakMap();\n_htm2tx = new WeakSet();\nhtm2tx_fn = function(fnc, hidden = true) {\n  const util2 = {\n    escape: (str2) => str2.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (url2) => {\n      const extension = parseExtension(url2).toLowerCase();\n      return mimes()[extension] || \"\";\n    },\n    dataAsUrl,\n    isDataUrl,\n    resolveUrl,\n    getAndEncode,\n    asArray: (arrayLike) => {\n      const a2 = [];\n      const len = arrayLike.length;\n      for (let i2 = 0; i2 < len; ++i2)\n        a2.push(arrayLike[i2]);\n      return a2;\n    }\n  };\n  function mimes() {\n    const WOFF = \"application/font-woff\";\n    const JPEG = \"image/jpeg\";\n    return {\n      \"woff\": WOFF,\n      \"woff2\": WOFF,\n      \"ttf\": \"application/font-truetype\",\n      \"eot\": \"application/vnd.ms-fontobject\",\n      \"png\": \"image/png\",\n      \"jpg\": JPEG,\n      \"jpeg\": JPEG,\n      \"gif\": \"image/gif\",\n      \"tiff\": \"image/tiff\",\n      \"svg\": \"image/svg+xml\"\n    };\n  }\n  const inliner = newInliner();\n  const fontFaces = newFontFaces();\n  function embedFonts(node) {\n    return fontFaces.resolveAll().then((cssText) => {\n      const styleNode = document.createElement(\"style\");\n      node.appendChild(styleNode);\n      styleNode.appendChild(document.createTextNode(cssText));\n      return node;\n    });\n  }\n  function parseExtension(url2) {\n    var _a3;\n    const match = /\\.([^\\.\\/]*?)$/g.exec(url2);\n    return (_a3 = match == null ? void 0 : match[1]) != null ? _a3 : \"\";\n  }\n  function isDataUrl(url2) {\n    return url2.search(/^(data:)/) !== -1;\n  }\n  function resolveUrl(url2, baseUrl) {\n    const doc2 = document.implementation.createHTMLDocument();\n    const base = doc2.createElement(\"base\");\n    doc2.head.appendChild(base);\n    const a2 = doc2.createElement(\"a\");\n    doc2.body.appendChild(a2);\n    base.href = baseUrl;\n    a2.href = url2;\n    return a2.href;\n  }\n  function getAndEncode(url2) {\n    let TIMEOUT = 3e4;\n    return new Promise(function(resolve2) {\n      const request = new XMLHttpRequest();\n      request.onreadystatechange = done;\n      request.ontimeout = timeout;\n      request.responseType = \"blob\";\n      request.timeout = TIMEOUT;\n      request.open(\"GET\", url2, true);\n      request.send();\n      function done() {\n        if (request.readyState !== 4)\n          return;\n        if (request.status !== 200) {\n          fail(\"cannot fetch resource: \" + url2 + \", status: \" + request.status);\n          return;\n        }\n        const encoder = new FileReader();\n        encoder.onloadend = function() {\n          const content = encoder.result.toString().split(/,/)[1];\n          resolve2(content);\n        };\n        encoder.readAsDataURL(request.response);\n      }\n      function timeout() {\n        fail(\"timeout of \" + TIMEOUT + \"ms occured while fetching resource: \" + url2);\n      }\n      function fail(message) {\n        console.error(message);\n        resolve2(\"\");\n      }\n    });\n  }\n  function dataAsUrl(content, type) {\n    return \"data:\" + type + \";base64,\" + content;\n  }\n  function newInliner() {\n    const URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll,\n      shouldProcess\n    };\n    function shouldProcess(str2) {\n      return str2.search(URL_REGEX) !== -1;\n    }\n    function readUrls(str2) {\n      const result = [];\n      let match;\n      while (match = URL_REGEX.exec(str2)) {\n        result.push(match[1]);\n      }\n      return result.filter(function(url2) {\n        return !util2.isDataUrl(url2);\n      });\n    }\n    function inline(str2, url2, baseUrl, get) {\n      return Promise.resolve(url2).then((url22) => baseUrl ? util2.resolveUrl(url22, baseUrl) : url22).then(get || util2.getAndEncode).then((data) => util2.dataAsUrl(data, util2.mimeType(url2))).then((dataUrl) => str2.replace(urlAsRegex(url2), \"$1\" + dataUrl + \"$3\"));\n      function urlAsRegex(url22) {\n        return new RegExp(`(url\\\\(['\"]?)(` + util2.escape(url22) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function inlineAll(str2, baseUrl, get) {\n      if (nothingToInline())\n        return Promise.resolve(str2);\n      return Promise.resolve(str2).then(readUrls).then((urls) => {\n        let done = Promise.resolve(str2);\n        for (const url2 of urls) {\n          done = done.then((string) => {\n            return inline(string, url2, baseUrl, get);\n          });\n        }\n        return done;\n      });\n      function nothingToInline() {\n        return !shouldProcess(str2);\n      }\n    }\n  }\n  function newFontFaces() {\n    return {\n      resolveAll,\n      impl: { readAll }\n    };\n    function resolveAll() {\n      return readAll().then((webFonts) => Promise.allSettled(webFonts.map((webFont) => webFont.resolve()))).then((cssStrings) => cssStrings.join(\"\\n\"));\n    }\n    function readAll() {\n      return Promise.resolve(util2.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then((rules) => rules.map(newWebFont));\n      function selectWebFontRules(cssRules) {\n        return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => inliner.shouldProcess(rule.style.getPropertyValue(\"src\")));\n      }\n      function getCssRules(styleSheets) {\n        const cssRules = [];\n        for (const sheet of styleSheets) {\n          try {\n            if (sheet.href)\n              continue;\n            util2.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));\n          } catch (e) {\n            console.error(\"Error while reading CSS rules from \" + sheet.href, e.toString());\n          }\n        }\n        return cssRules;\n      }\n      function newWebFont(webFontRule) {\n        return {\n          resolve: function resolve2() {\n            const baseUrl = (webFontRule.parentStyleSheet || {}).href;\n            return inliner.inlineAll(webFontRule.cssText, baseUrl);\n          },\n          src: function() {\n            return webFontRule.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(__privateGet2(this, _htmTxt)).then((node) => {\n    const cln = node.cloneNode(true);\n    cln.style.padding = \"0px\";\n    cln.style.paddingRight = __privateGet2(this, _padTx4x) + \"px\";\n    cln.style.paddingTop = __privateGet2(this, _padTx4y) + \"px\";\n    cln.style.left = \"0px\";\n    cln.style.top = \"0px\";\n    cln.style.width = __privateGet2(this, _infTL).$width - __privateGet2(this, _infTL).pad_left - __privateGet2(this, _infTL).pad_right + \"px\";\n    cln.style.height = __privateGet2(this, _infTL).$height - __privateGet2(this, _infTL).pad_top - __privateGet2(this, _infTL).pad_bottom + \"px\";\n    __privateGet2(this, _htmTxt).hidden = hidden;\n    return cln;\n  }).then(embedFonts).then((node) => {\n    node.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const img = new Image();\n    img.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${__privateGet2(this, _infTL).$width}px\" height=\"${__privateGet2(this, _infTL).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(node).replaceAll(\"#\", \"%23\").replaceAll(\"\\n\", \"%0A\")}</foreignObject></svg>`;\n    return new Promise((resolve2) => img.onload = () => resolve2(img));\n  }).then((img) => new Promise((resolve2) => setTimeout(() => resolve2(img), 100))).then((img) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = __privateGet2(this, _infTL).$width;\n    canvas.height = __privateGet2(this, _infTL).$height;\n    canvas.getContext(\"2d\").drawImage(img, 0, 0);\n    canvas.toBlob((blob) => {\n      if (!blob)\n        return;\n      const url2 = URL.createObjectURL(blob);\n      Texture.from(url2).once(\"update\", (tx2) => {\n        fnc(tx2);\n        URL.revokeObjectURL(url2);\n      });\n    });\n  }).catch((err) => DebugMng.myTrace(`goTxt() = ${err}`));\n};\n_ch_filter = new WeakMap();\n_aSpTw = new WeakMap();\n_aRect = new WeakMap();\n_lenHtmTxt = new WeakMap();\n_reg\\u884C\\u982D\\u7981\\u5247 = new WeakMap();\n_reg\\u884C\\u672B\\u7981\\u5247 = new WeakMap();\n_reg\\u5206\\u5272\\u7981\\u6B62 = new WeakMap();\n_REGDS = new WeakMap();\n_fncEndChIn = new WeakMap();\n_spWork = new WeakSet();\nspWork_fn = function(sp, arg, add3, rct, ease, cis) {\n  var _a3, _b3, _c3;\n  sp.alpha = 0;\n  if (arg.x)\n    rct.x = arg.x.charAt(0) === \"=\" ? rct.x + parseInt(arg.x.slice(1)) : parseInt(arg.x);\n  if (arg.y)\n    rct.y = arg.y.charAt(0) === \"=\" ? rct.y + parseInt(arg.y.slice(1)) : parseInt(arg.y);\n  if (arg.width)\n    rct.width = parseInt(arg.width);\n  if (arg.height)\n    rct.height = parseInt(arg.height);\n  if (arg.wait)\n    cis.wait = parseInt(arg.wait);\n  sp.width = rct.width;\n  sp.height = rct.height;\n  sp.position.set(cis.x.charAt(0) === \"=\" ? rct.x + sp.width * cis.nx : cis.nx, cis.y.charAt(0) === \"=\" ? rct.y + sp.height * cis.ny : cis.ny);\n  const st = {\n    sp,\n    tw: new Tween(sp).to({ alpha: 1, x: rct.x, y: rct.y, width: rct.width, height: rct.height, angle: 0 }, (_a3 = cis.wait) != null ? _a3 : 0).easing(ease).delay(((_b3 = add3.wait) != null ? _b3 : 0) + ((_c3 = arg.delay) != null ? _c3 : 0)).onComplete(() => {\n      st.tw = void 0;\n    }).start()\n  };\n  __privateGet2(this, _aSpTw).push(st);\n};\n_isChInIng = new WeakMap();\n_hChInStyle = new WeakMap();\n_REG_NG_CHSTYLE_NAME_CHR = new WeakMap();\n_hChOutStyle = new WeakMap();\n_cntBreak = new WeakMap();\n_lh_half = new WeakMap();\n_getChRects = new WeakSet();\ngetChRects_fn = function(elm) {\n  var _a3, _b3, _c3, _d2;\n  const ret = [];\n  if (elm.nodeType !== elm.TEXT_NODE) {\n    elm.childNodes.forEach((v2) => ret.push(__privateMethod2(this, _getChRects, getChRects_fn).call(this, v2)));\n    return Array.prototype.concat.apply([], ret);\n  }\n  const range = elm.ownerDocument.createRange();\n  range.selectNodeContents(elm);\n  let pos = 0;\n  const end2 = range.endOffset;\n  while (pos < end2) {\n    range.setStart(elm, pos);\n    range.setEnd(elm, ++pos);\n    const r2 = range.getBoundingClientRect();\n    const pe = range.startContainer.parentElement;\n    if (!pe)\n      throw `fn:TxtStage.ts pe null`;\n    const ch = range.toString();\n    const cr = {\n      ch,\n      rect: new Rectangle(r2.left + globalThis.scrollX, r2.top + globalThis.scrollY, r2.width, r2.height + (\"gjqy\".includes(ch) ? __privateGet2(this, _lh_half) : 0)),\n      elm: pe,\n      cmd: (_a3 = pe.getAttribute(\"data-cmd\")) != null ? _a3 : void 0,\n      arg: (_b3 = pe.getAttribute(\"data-arg\")) != null ? _b3 : void 0,\n      add: (_c3 = pe.getAttribute(\"data-add\")) != null ? _c3 : void 0,\n      tcy: (_d2 = pe.getAttribute(\"data-tcy\")) != null ? _d2 : void 0\n    };\n    ret.push(cr);\n  }\n  range.detach();\n  return ret;\n};\n_fi_easing = new WeakMap();\n_fo_easing = new WeakMap();\n_clearText = new WeakSet();\nclearText_fn = function() {\n  var _a3;\n  __privateGet2(this, _grpDbgMasume).clear();\n  __privateSet2(this, _aRect, []);\n  __privateSet2(this, _lenHtmTxt, 0);\n  this.skipChIn();\n  const n = __privateGet2(this, _htmTxt).cloneNode(true);\n  n.textContent = \"\";\n  const old = __privateGet2(this, _htmTxt);\n  old.parentElement.insertBefore(n, old);\n  let sum_wait = 0;\n  old.querySelectorAll(\"span.sn_ch\").forEach((elm) => {\n    var _a4, _b3, _c3, _d2, _e, _f;\n    const add3 = JSON.parse((_f = (_e = (_b3 = elm == null ? void 0 : elm.getAttribute(\"data-add\")) != null ? _b3 : (_a4 = elm == null ? void 0 : elm.children[0]) == null ? void 0 : _a4.getAttribute(\"data-add\")) != null ? _e : (_d2 = (_c3 = elm == null ? void 0 : elm.children[0]) == null ? void 0 : _c3.children[0]) == null ? void 0 : _d2.getAttribute(\"data-add\")) != null ? _f : \"{}\");\n    if (!add3.ch_out_style)\n      return;\n    const cos = __privateGet2(_TxtStage, _hChOutStyle)[add3.ch_out_style];\n    if (!cos)\n      return;\n    if (cos.wait === 0) {\n      elm.style.display = \"none\";\n      return;\n    }\n    sum_wait += cos.wait;\n    if (!cos.join)\n      elm.style.animationDelay = \"0ms\";\n    elm.classList.add(`go_ch_out_${add3.ch_out_style}`);\n  });\n  const end2 = () => {\n    old.parentElement.removeChild(old);\n    __privateGet2(this, _cntTxt).removeChildren().forEach((c2) => {\n      if (c2 instanceof Container)\n        __privateGet2(_TxtStage, _evtMng3).unButton(c2);\n      c2.destroy();\n    });\n  };\n  if (sum_wait === 0) {\n    __privateGet2(this, _htmTxt).textContent = \"\";\n    end2();\n  } else\n    (_a3 = old.lastElementChild) == null ? void 0 : _a3.addEventListener(\"animationend\", end2, { once: true, passive: true });\n  __privateSet2(this, _htmTxt, n);\n};\n_sss = new WeakMap();\n__privateAdd2(TxtStage, _cfg2, void 0);\n__privateAdd2(TxtStage, _appPixi2, void 0);\n__privateAdd2(TxtStage, _evtMng3, void 0);\n__privateAdd2(TxtStage, _hWarning, {\n  backgroundColor: 0,\n  borderBottomWidth: 0,\n  borderLeftWidth: 0,\n  borderRightWidth: 0,\n  borderTopWidth: 0,\n  marginBottom: 0,\n  marginLeft: 0,\n  marginRight: 0,\n  marginTop: 0\n});\n__privateAdd2(TxtStage, _reg\\u884C\\u982D\\u7981\\u5247, void 0);\n__privateAdd2(TxtStage, _reg\\u884C\\u672B\\u7981\\u5247, void 0);\n__privateAdd2(TxtStage, _reg\\u5206\\u5272\\u7981\\u6B62, void 0);\n__privateAdd2(TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));\n__privateAdd2(TxtStage, _REG_NG_CHSTYLE_NAME_CHR, /[\\s\\.,]/);\n__privateAdd2(TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));\n__privateAdd2(TxtStage, _cntBreak, new Container());\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value2) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);\n};\nvar __privateSet = (obj, member, value2, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value2) : member.set(obj, value2);\n  return value2;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _procMasume4txt, _procMasume4pic, _rctBtnTxt, _idc, _sp_b_pic, _sp_pic, _loaded_b_pic, loaded_b_pic_fn, _normal, _hover, _clicked, _loaded_pic, loaded_pic_fn;\nconst _Button = class extends Container {\n  constructor(hArg, evtMng, resolve2, canFocus) {\n    var _a4, _b3, _c3;\n    var _a3;\n    super();\n    this.hArg = hArg;\n    this.evtMng = evtMng;\n    this.resolve = resolve2;\n    this.canFocus = canFocus;\n    __privateAdd(this, _loaded_b_pic);\n    __privateAdd(this, _loaded_pic);\n    this.getBtnBounds = () => __privateGet(this, _rctBtnTxt);\n    __privateAdd(this, _rctBtnTxt, new Rectangle());\n    __privateAdd(this, _idc, void 0);\n    __privateAdd(this, _sp_b_pic, void 0);\n    __privateAdd(this, _sp_pic, void 0);\n    __privateAdd(this, _normal, () => {\n    });\n    __privateAdd(this, _hover, () => false);\n    __privateAdd(this, _clicked, () => {\n    });\n    if (CmnLib.isDbg) {\n      this.makeDesignCast = (gdc) => gdc(__privateGet(this, _idc));\n      this.cvsResize = () => __privateGet(this, _idc).cvsResize();\n    }\n    let oName = {\n      x: this.x = uint((_a4 = hArg.left) != null ? _a4 : 0),\n      y: this.y = uint((_b3 = hArg.top) != null ? _b3 : 0),\n      rotation: this.angle = argChk_Num(hArg, \"rotation\", this.angle),\n      pivot_x: this.pivot.x = argChk_Num(hArg, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = argChk_Num(hArg, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = argChk_Num(hArg, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = argChk_Num(hArg, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    const enabled = oName.enabled = argChk_Boolean(hArg, \"enabled\", true);\n    this.getBtnBounds = () => {\n      __privateGet(this, _rctBtnTxt).x = oName.x;\n      __privateGet(this, _rctBtnTxt).y = oName.y;\n      return __privateGet(this, _rctBtnTxt);\n    };\n    if (hArg.pic) {\n      oName.type = \"pic\";\n      __privateSet(this, _idc, new PicBtnDesignCast(this, hArg));\n      if (enabled)\n        this.evtMng.button(this.hArg, this, () => __privateGet(this, _normal).call(this), () => __privateGet(this, _hover).call(this), () => __privateGet(this, _clicked).call(this));\n      if (!GrpLayer.csv2Sprites(hArg.pic, this, (sp) => {\n        __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, sp, oName);\n        __privateGet(this, _rctBtnTxt).width = sp.width * oName.scale_x;\n        __privateGet(this, _rctBtnTxt).height = sp.height * oName.scale_y;\n      }, (isStop2) => {\n        if (isStop2)\n          resolve2();\n      }))\n        resolve2();\n      return;\n    }\n    if (!hArg.text)\n      throw \"text\\u307E\\u305F\\u306Fpic\\u5C5E\\u6027\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const height = argChk_Num(hArg, \"height\", 30);\n    const style = new TextStyle({\n      align: \"center\",\n      dropShadow: true,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: \"black\",\n      fontFamily: _Button.fontFamily,\n      fontSize: height,\n      padding: 5\n    });\n    if (hArg.style)\n      try {\n        const o = JSON.parse(hArg.style);\n        for (const nm in o)\n          style[nm] = o[nm];\n      } catch (e) {\n        throw new Error(mesErrJSON(hArg, \"style\", e.message));\n      }\n    const txt = new Text((_c3 = hArg.text) != null ? _c3 : \"\", style);\n    txt.alpha = argChk_Num(hArg, \"alpha\", txt.alpha);\n    txt.width = argChk_Num(hArg, \"width\", 100);\n    txt.height = hArg.height = height;\n    this.setText = (text2) => txt.text = text2;\n    oName.type = \"text\";\n    oName = __spreadValues(__spreadValues({}, oName), style);\n    oName.alpha = txt.alpha;\n    oName.text = txt.text;\n    oName.width = txt.width;\n    oName.height = txt.height;\n    __privateSet(this, _idc, new TxtBtnDesignCast(this, hArg, txt));\n    let isStop = false;\n    if (hArg.b_pic) {\n      oName.b_pic = hArg.b_pic;\n      isStop = GrpLayer.csv2Sprites(hArg.b_pic, this, (sp) => {\n        __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, sp, txt);\n        oName.width = this.width;\n        oName.height = this.height;\n      }, (isStop2) => {\n        Layer.setBlendmode(this, hArg);\n        if (isStop2)\n          resolve2();\n      });\n    }\n    txt.name = JSON.stringify(oName);\n    this.addChild(txt);\n    __privateGet(this, _rctBtnTxt).width = txt.width;\n    __privateGet(this, _rctBtnTxt).height = txt.height;\n    oName.width = this.width;\n    oName.height = this.height;\n    if (!hArg.b_pic)\n      Layer.setBlendmode(this, hArg);\n    __privateGet(_a3 = _Button, _procMasume4txt).call(_a3, this, txt);\n    if (!enabled) {\n      if (!isStop)\n        resolve2();\n      return;\n    }\n    const style_hover = style.clone();\n    if (hArg.style_hover)\n      try {\n        const o = JSON.parse(hArg.style_hover);\n        for (const nm in o)\n          style_hover[nm] = o[nm];\n      } catch (e) {\n        throw new Error(mesErrJSON(hArg, \"style_hover\", e.message));\n      }\n    else\n      style_hover.fill = \"white\";\n    const style_clicked = style_hover.clone();\n    if (hArg.style_clicked)\n      try {\n        const o = JSON.parse(hArg.style_clicked);\n        for (const nm in o)\n          style_clicked[nm] = o[nm];\n      } catch (e) {\n        throw new Error(mesErrJSON(hArg, \"style_clicked\", e.message));\n      }\n    else\n      style_clicked.dropShadow = false;\n    evtMng.button(hArg, this, () => txt.style = style, () => {\n      if (!canFocus())\n        return false;\n      txt.style = style_hover;\n      return true;\n    }, () => txt.style = style_clicked);\n    if (!isStop)\n      resolve2();\n  }\n  static init(cfg) {\n    if (!cfg.oCfg.debug.masume)\n      return;\n    __privateSet(_Button, _procMasume4txt, (me, txt) => me.addChild(new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(txt.x, txt.y, txt.width, txt.height).endFill()));\n    __privateSet(_Button, _procMasume4pic, (me, sp, w3, h2) => me.addChild(new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(sp.x, sp.y, w3, h2).endFill()));\n  }\n  setText(_text) {\n  }\n  destroy(_options) {\n    this.evtMng.unButton(this);\n    super.destroy();\n  }\n  makeDesignCast(_gdc) {\n  }\n  showDesignCast() {\n    __privateGet(this, _idc).visible = true;\n  }\n  cvsResize() {\n  }\n  update_b_pic(fn2, txt) {\n    var _a3;\n    const oName = JSON.parse((_a3 = txt.name) != null ? _a3 : \"{}\");\n    if (__privateGet(this, _sp_b_pic))\n      this.removeChild(__privateGet(this, _sp_b_pic));\n    this.hArg.b_pic = oName.b_pic = fn2;\n    txt.name = JSON.stringify(oName);\n    if (!fn2)\n      return;\n    GrpLayer.csv2Sprites(fn2, this, (sp) => __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, sp, txt), () => Layer.setBlendmode(this, this.hArg));\n  }\n  update_pic(fn2, sp) {\n    var _a3;\n    const oName = JSON.parse((_a3 = sp.name) != null ? _a3 : \"{}\");\n    if (__privateGet(this, _sp_pic))\n      this.removeChild(__privateGet(this, _sp_pic));\n    this.hArg.pic = oName.pic = fn2;\n    sp.name = JSON.stringify(oName);\n    if (!fn2)\n      return;\n    GrpLayer.csv2Sprites(fn2, this, (sp2) => __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, sp2, oName), () => Layer.setBlendmode(this, this.hArg));\n  }\n};\nlet Button = _Button;\n_procMasume4txt = /* @__PURE__ */ new WeakMap();\n_procMasume4pic = /* @__PURE__ */ new WeakMap();\n_rctBtnTxt = /* @__PURE__ */ new WeakMap();\n_idc = /* @__PURE__ */ new WeakMap();\n_sp_b_pic = /* @__PURE__ */ new WeakMap();\n_sp_pic = /* @__PURE__ */ new WeakMap();\n_loaded_b_pic = /* @__PURE__ */ new WeakSet();\nloaded_b_pic_fn = function(sp, txt) {\n  __privateSet(this, _sp_b_pic, sp);\n  this.setChildIndex(sp, 0);\n  sp.alpha = txt.alpha;\n  sp.setTransform(txt.x, txt.y, 1, 1, txt.rotation, 0, 0, (sp.width - txt.width) / 2, (sp.height - txt.height) / 2);\n  sp.name = txt.name;\n};\n_normal = /* @__PURE__ */ new WeakMap();\n_hover = /* @__PURE__ */ new WeakMap();\n_clicked = /* @__PURE__ */ new WeakMap();\n_loaded_pic = /* @__PURE__ */ new WeakSet();\nloaded_pic_fn = function(sp, oName) {\n  var _a3;\n  __privateSet(this, _sp_pic, sp);\n  oName.alpha = sp.alpha = argChk_Num(this.hArg, \"alpha\", sp.alpha);\n  __privateGet(this, _idc).setSp(sp);\n  const w3 = sp.width / 3;\n  const h2 = sp.height;\n  const tx = sp.texture.baseTexture;\n  const txNormal = new Texture(tx, new Rectangle(0, 0, w3, h2));\n  const txClicked = new Texture(tx, new Rectangle(w3, 0, w3, h2));\n  const txHover = new Texture(tx, new Rectangle(w3 * 2, 0, w3, h2));\n  const normal = () => sp.texture = txNormal;\n  normal();\n  __privateSet(this, _normal, normal);\n  __privateSet(this, _hover, () => {\n    if (!this.canFocus())\n      return false;\n    sp.texture = txHover;\n    return true;\n  });\n  __privateSet(this, _clicked, () => sp.texture = txClicked);\n  if (\"width\" in this.hArg) {\n    oName.width = uint(this.hArg.width);\n    this.scale.x *= oName.width / w3;\n  } else\n    oName.width = w3;\n  if (\"height\" in this.hArg) {\n    oName.height = uint(this.hArg.height);\n    this.scale.y *= oName.height / w3;\n  } else\n    oName.height = w3;\n  sp.name = JSON.stringify(oName);\n  __privateGet(_a3 = _Button, _procMasume4pic).call(_a3, this, sp, w3, h2);\n};\nButton.fontFamily = \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif\";\n__privateAdd(Button, _procMasume4txt, (_me, _txt) => {\n});\n__privateAdd(Button, _procMasume4pic, (_me, _sp3, _w3, _h) => {\n});\nconst _TxtLayer = class extends Layer {\n  constructor() {\n    super();\n    __privateAdd2(this, _set_ch_in);\n    __privateAdd2(this, _set_ch_out);\n    __privateAdd2(this, _drawBack);\n    __privateAdd2(this, _setFfs);\n    __privateAdd2(this, _mkStyle_r_align4ff);\n    __privateAdd2(this, _tagCh_sub);\n    __privateAdd2(this, _beginSpan);\n    __privateAdd2(this, _autoCloseSpan);\n    __privateAdd2(this, _b_color, void 0);\n    __privateAdd2(this, _b_alpha, void 0);\n    __privateAdd2(this, _b_alpha_isfixed, void 0);\n    __privateAdd2(this, _b_do, void 0);\n    __privateAdd2(this, _b_pic, void 0);\n    __privateAdd2(this, _txs, void 0);\n    __privateAdd2(this, _rbSpl, void 0);\n    __privateAdd2(this, _cntBtn, void 0);\n    __privateAdd2(this, _$ch_in_style, void 0);\n    __privateAdd2(this, _ch_in_join, void 0);\n    __privateAdd2(this, _$ch_out_style, void 0);\n    __privateAdd2(this, _ffs, void 0);\n    __privateAdd2(this, _fncFFSStyle, void 0);\n    __privateAdd2(this, _fncFFSSpan, void 0);\n    __privateAdd2(this, _strNoFFS, void 0);\n    __privateAdd2(this, _regNoFFS, void 0);\n    __privateAdd2(this, _ruby_pd, void 0);\n    __privateAdd2(this, _r_align, void 0);\n    __privateAdd2(this, _needGoTxt, void 0);\n    __privateAdd2(this, _putCh2, void 0);\n    __privateAdd2(this, _cumDelay, void 0);\n    __privateAdd2(this, _firstCh, void 0);\n    __privateAdd2(this, _aSpan, void 0);\n    __privateAdd2(this, _aSpan_bk, void 0);\n    __privateAdd2(this, _aSpan_link, void 0);\n    __privateAdd2(this, _hSpanBk, void 0);\n    __privateAdd2(this, _page_text, void 0);\n    __privateSet2(this, _b_color, 0);\n    __privateSet2(this, _b_alpha, 0);\n    __privateSet2(this, _b_alpha_isfixed, false);\n    __privateSet2(this, _b_do, void 0);\n    __privateSet2(this, _b_pic, \"\");\n    __privateSet2(this, _txs, new TxtStage(this.spLay, () => this.canFocus(), __privateGet2(_TxtLayer, _sys3)));\n    __privateSet2(this, _rbSpl, new RubySpliter());\n    __privateSet2(this, _cntBtn, new Container());\n    __privateSet2(this, _$ch_in_style, \"\");\n    __privateSet2(this, _ch_in_join, true);\n    __privateSet2(this, _$ch_out_style, \"\");\n    __privateSet2(this, _ffs, \"\");\n    __privateSet2(this, _fncFFSStyle, (_ch2) => \"\");\n    __privateSet2(this, _fncFFSSpan, (ch) => ch);\n    __privateSet2(this, _strNoFFS, \"\");\n    __privateSet2(this, _regNoFFS, new RegExp(\"[\\u3000]\"));\n    this.isCur = false;\n    __privateSet2(this, _ruby_pd, () => \"\");\n    __privateSet2(this, _r_align, \"\");\n    __privateSet2(this, _needGoTxt, false);\n    __privateSet2(this, _putCh2, (ch, ruby) => {\n      var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _i, _j, _k;\n      if (__privateGet2(_TxtLayer, _cfg3).oCfg.debug.putCh)\n        console.log(`\\u{1F58A} \\u6587\\u5B57\\u8868\\u793A text:\\`${ch}\\` ruby:\\`${ruby}\\` name:\\`${this.name_}\\``);\n      const a_ruby = ruby.split(\"\\uFF5C\");\n      let add_htm = \"\";\n      const isSkip = __privateGet2(_TxtLayer, _evtMng4).isSkippingByKeyDown();\n      switch (a_ruby.length) {\n        case 1:\n          __privateSet2(this, _needGoTxt, true);\n          if (ch === \"\\n\") {\n            if (__privateGet2(this, _aSpan_bk)) {\n              add_htm = __privateGet2(this, _aSpan_bk).slice(-1)[0];\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              __privateGet2(this, _aSpan).push(__privateGet2(_a3 = _TxtLayer, _rec).call(_a3, \"<br/>\"));\n              __privateGet2(this, _aSpan).push(add_htm);\n              __privateSet2(this, _aSpan_bk, __privateGet2(this, _aSpan));\n              __privateSet2(this, _aSpan, []);\n              __privateSet2(_TxtLayer, _rec_bk, __privateGet2(_TxtLayer, _rec));\n              __privateSet2(_TxtLayer, _rec, (tx) => tx);\n              return;\n            }\n            if (__privateGet2(this, _firstCh)) {\n              __privateSet2(this, _firstCh, false);\n              add_htm = \"<ruby>\\u3000<rt>\\u3000</rt></ruby><br/>\";\n            } else\n              add_htm = \"<br/>\";\n            break;\n          }\n          if (__privateGet2(this, _firstCh)) {\n            __privateSet2(this, _firstCh, false);\n            if (ruby === \"\")\n              ruby = \"\\u3000\";\n          }\n          add_htm = __privateMethod2(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, ruby, isSkip, __privateGet2(this, _r_align));\n          break;\n        case 2:\n          switch (a_ruby[0]) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              __privateSet2(this, _firstCh, false);\n              __privateSet2(this, _needGoTxt, true);\n              add_htm = __privateMethod2(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, a_ruby[1], isSkip, a_ruby[0]);\n              break;\n            case \"gotxt\": {\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              if (this.isCur)\n                __privateGet2(_b3 = _TxtLayer, _recText).call(_b3, __privateGet2(this, _aSpan).join(\"\").replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, \"\").replace(/style='(anim\\S+ \\S+?;\\s*)+/g, `style='`).replace(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replace(/class='sn_ch .+?'/g, `class='sn_ch'`).replaceAll(`class='offrec'`, `style='display: none;'`).replaceAll(\"`\", \"\\\\`\"));\n              if (!__privateGet2(this, _needGoTxt))\n                return;\n              __privateGet2(this, _txs).goTxt(__privateGet2(this, _aSpan));\n              __privateSet2(this, _needGoTxt, false);\n              __privateSet2(this, _cumDelay, 0);\n              return;\n            }\n            case \"add\":\n              {\n                const o = JSON.parse(a_ruby[1]);\n                (_c3 = o.style) != null ? _c3 : o.style = \"\";\n                __privateMethod2(this, _beginSpan, beginSpan_fn).call(this, o);\n                if (__privateGet2(this, _aSpan_bk))\n                  __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n                else {\n                  if (isSkip)\n                    __privateSet2(this, _cumDelay, 0);\n                  const wait = Number((_d2 = o.wait) != null ? _d2 : -1);\n                  const sn_ch = wait === 0 ? \"\" : ` sn_ch_in_${__privateGet2(this, _$ch_in_style)}`;\n                  const ad = wait < 0 ? \"\" : ` animation-duration: ${wait}ms;`;\n                  __privateGet2(this, _aSpan).push(`<span class='sn_ch${sn_ch + __privateGet2(_TxtLayer, _class_offrec)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${ad} ${o.style}' data-add='${JSON.stringify(o)}'>`);\n                }\n                __privateSet2(this, _aSpan_bk, __privateGet2(this, _aSpan));\n                __privateSet2(this, _aSpan, []);\n                __privateSet2(_TxtLayer, _rec_bk, __privateGet2(_TxtLayer, _rec));\n                __privateSet2(_TxtLayer, _rec, (tx) => tx);\n              }\n              return;\n            case \"add_close\":\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              return;\n            case \"grp\":\n              __privateSet2(this, _needGoTxt, true);\n              {\n                if (isSkip)\n                  __privateSet2(this, _cumDelay, 0);\n                const arg = (a_ruby[1] ? a_ruby[1].slice(0, -1) + \",\" : `{`) + `\"delay\": ${__privateGet2(this, _cumDelay)}}`;\n                if (__privateGet2(this, _ch_in_join))\n                  __privateSet2(this, _cumDelay, __privateGet2(this, _cumDelay) + (__privateGet2(_TxtLayer, _doAutoWc) ? 0 : LayerMng.msecChWait));\n                const o = JSON.parse(arg);\n                (_e = o.style) != null ? _e : o.style = \"\";\n                if (!(\"id\" in o))\n                  o.id = __privateGet2(this, _aSpan).length;\n                if (o.id === \"break\") {\n                  __privateGet2(this, _txs).dispBreak(o.pic);\n                  return;\n                }\n                add_htm = `<span data-cmd='grp' data-id='${o.id}' data-arg='${arg}'`;\n                const wait = Number((_f = o.wait) != null ? _f : -1);\n                const sn_ch = wait === 0 ? \"\" : ` sn_ch_in_${__privateGet2(this, _$ch_in_style)}`;\n                const ad = wait < 0 ? \"\" : ` animation-duration: ${wait}ms;`;\n                add_htm += ` class='sn_ch${sn_ch}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${__privateGet2(this, _$ch_in_style)}\", \"ch_out_style\":\"${__privateGet2(this, _$ch_out_style)}\"}'>\\u3000</span>`;\n                if (__privateGet2(this, _firstCh)) {\n                  __privateSet2(this, _firstCh, false);\n                  add_htm = `<ruby>${add_htm}<rt>\\u3000</rt></ruby>`;\n                }\n                if (__privateGet2(this, _aSpan).slice(-1)[0] === add_htm)\n                  return;\n              }\n              break;\n            case \"del\":\n              const id_del = a_ruby[1];\n              if (id_del !== \"break\")\n                throw \"\\u6587\\u5B57\\u30EC\\u30A4\\u30E4del\\u30B3\\u30DE\\u30F3\\u30C9\\u306F\\u3001\\u73FE\\u5728id=break\\u306E\\u307F\\u30B5\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3059\";\n              TxtStage.delBreak();\n              return;\n            case \"span\":\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              __privateSet2(this, _needGoTxt, true);\n              {\n                const o = JSON.parse(a_ruby[1]);\n                __privateMethod2(this, _beginSpan, beginSpan_fn).call(this, o);\n                if (!o.style)\n                  return;\n                if (isSkip)\n                  __privateSet2(this, _cumDelay, 0);\n                const wait = Number((_g = o.wait) != null ? _g : -1);\n                const sn_ch = wait === 0 ? \"\" : ` sn_ch_in_${__privateGet2(this, _$ch_in_style)}`;\n                const ad = wait < 0 ? \"\" : ` animation-duration: ${wait}ms;`;\n                __privateGet2(this, _aSpan).push(`<span class='sn_ch${sn_ch + __privateGet2(_TxtLayer, _class_offrec)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${__privateGet2(this, _$ch_in_style)}\", \"ch_out_style\":\"${__privateGet2(this, _$ch_out_style)}\"}'>`);\n                __privateSet2(this, _aSpan_bk, __privateGet2(this, _aSpan));\n                __privateSet2(this, _aSpan, []);\n                __privateSet2(_TxtLayer, _rec_bk, __privateGet2(_TxtLayer, _rec));\n                __privateSet2(_TxtLayer, _rec, (tx) => tx);\n              }\n              return;\n            case \"link\":\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              __privateSet2(this, _needGoTxt, true);\n              {\n                const o = JSON.parse(a_ruby[1]);\n                (_h = o.style) != null ? _h : o.style = \"\";\n                __privateMethod2(this, _beginSpan, beginSpan_fn).call(this, o);\n                if (isSkip)\n                  __privateSet2(this, _cumDelay, 0);\n                const wait = Number((_i = o.wait) != null ? _i : -1);\n                const sn_ch = wait === 0 ? \"\" : ` sn_ch_in_${__privateGet2(this, _$ch_in_style)}`;\n                const ad = wait < 0 ? \"\" : ` animation-duration: ${wait}ms;`;\n                __privateSet2(this, _aSpan_link, ` data-cmd='link' data-arg='${a_ruby[1]}'`);\n                __privateGet2(this, _aSpan).push(`<span${__privateGet2(this, _aSpan_link)} class='sn_ch${sn_ch + __privateGet2(_TxtLayer, _class_offrec)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${__privateGet2(this, _$ch_in_style)}\", \"ch_out_style\":\"${__privateGet2(this, _$ch_out_style)}\"}'>`);\n                __privateSet2(this, _aSpan_bk, __privateGet2(this, _aSpan));\n                __privateSet2(this, _aSpan, []);\n                __privateSet2(_TxtLayer, _rec_bk, __privateGet2(_TxtLayer, _rec));\n                __privateSet2(_TxtLayer, _rec, (tx) => tx);\n              }\n              return;\n            case \"endlink\":\n              __privateSet2(this, _needGoTxt, true);\n              if (__privateGet2(this, _aSpan_bk))\n                __privateSet2(this, _aSpan, __privateGet2(this, _aSpan).map((v2) => v2.replace(/ data-cmd='linkrsv'/, __privateGet2(this, _aSpan_link))));\n              __privateMethod2(this, _autoCloseSpan, autoCloseSpan_fn).call(this);\n              return;\n            default:\n              __privateSet2(this, _needGoTxt, true);\n              add_htm = __privateMethod2(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, ruby, isSkip, __privateGet2(this, _r_align));\n          }\n          break;\n        case 3:\n          __privateSet2(this, _firstCh, false);\n          __privateSet2(this, _needGoTxt, true);\n          switch (a_ruby[0]) {\n            case \"tcy\":\n              {\n                if (__privateGet2(_TxtLayer, _val).doRecLog())\n                  __privateSet2(this, _page_text, __privateGet2(this, _page_text) + (ch + (ruby ? `\\u300A${ruby}\\u300B` : \"\")));\n                const tx = a_ruby[1];\n                const id_tcy = tx.length > 1 ? __privateGet2(this, _aSpan).length + 1 : \"\";\n                const rb = CmnLib.isSafari ? a_ruby[2].replace(/[A-Za-z0-9]/g, (s2) => String.fromCharCode(s2.charCodeAt(0) + 65248)) : a_ruby[2];\n                if (isSkip)\n                  __privateSet2(this, _cumDelay, 0);\n                const rs = this.mkStyle_r_align(tx, rb, __privateGet2(this, _r_align));\n                const da = ` data-add='{\"ch_in_style\":\"${__privateGet2(this, _$ch_in_style)}\", \"ch_out_style\":\"${__privateGet2(this, _$ch_out_style)}\"}'`;\n                const st = `<span data-tcy='${id_tcy}' style='\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;\n${__privateGet2(this, _fncFFSStyle).call(this, tx)}`;\n                add_htm = rb ? __privateGet2(this, _aSpan_bk) ? `<ruby>${st}'${da} data-cmd='linkrsv'>${tx}</span>\n\t\t\t\t\t\t\t<rt${rs}>${rb}</rt></ruby>` : `<span class='sn_ch sn_ch_in_${__privateGet2(this, _$ch_in_style)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;'>\n\t\t\t\t\t\t\t<ruby>${st}'${da}>${tx}</span>\n\t\t\t\t\t\t\t<rt${rs}>${rb}</rt></ruby>\n\t\t\t\t\t\t</span>` : __privateGet2(this, _aSpan_bk) ? `${st}'${da} data-cmd='linkrsv'>${tx}</span>` : `${st}\n\t\t\t\t\t\t\tanimation-delay: ${__privateGet2(this, _cumDelay)}ms;\n\t\t\t\t\t\t\theight: 1em;\n\t\t\t\t\t\t' class='sn_ch sn_ch_in_${__privateGet2(this, _$ch_in_style)}'${da}>${tx}</span>`;\n                if (__privateGet2(this, _ch_in_join))\n                  __privateSet2(this, _cumDelay, __privateGet2(this, _cumDelay) + (__privateGet2(_TxtLayer, _doAutoWc) ? (_j = __privateGet2(_TxtLayer, _hAutoWc)[ch.charAt(0)]) != null ? _j : 0 : LayerMng.msecChWait));\n              }\n              break;\n            default:\n              throw `\\u7570\\u5E38\\u306A\\u5024\\u3067\\u3059 putCh(text: ${ch}, ruby: ${ruby})`;\n          }\n          break;\n      }\n      __privateGet2(this, _aSpan).push(__privateGet2(_k = _TxtLayer, _rec).call(_k, add_htm));\n    });\n    __privateSet2(this, _cumDelay, 0);\n    __privateSet2(this, _firstCh, true);\n    __privateSet2(this, _aSpan, []);\n    __privateSet2(this, _aSpan_bk, void 0);\n    __privateSet2(this, _aSpan_link, \"\");\n    __privateSet2(this, _hSpanBk, {\n      ch_in_style: \"\",\n      ch_out_style: \"\",\n      r_align: \"\"\n    });\n    this.click = () => {\n      if (!this.spLay.interactiveChildren || !this.spLay.visible)\n        return true;\n      return __privateGet2(this, _txs).skipChIn();\n    };\n    __privateSet2(this, _page_text, \"\");\n    this.addButton = (hArg) => new Promise((re2) => {\n      hArg.key = `btn=[${__privateGet2(this, _cntBtn).children.length}] ` + this.name_;\n      hArg[\":id_tag\"] = hArg.key.slice(0, -7);\n      argChk_Boolean(hArg, \"hint_tate\", __privateGet2(this, _txs).tategaki);\n      const btn = new Button(hArg, __privateGet2(_TxtLayer, _evtMng4), () => re2(), () => this.canFocus());\n      btn.name = JSON.stringify(hArg).replaceAll('\"', \"'\");\n      __privateGet2(this, _cntBtn).addChild(btn);\n    });\n    this.record = () => Object.assign(super.record(), {\n      enabled: this.enabled,\n      r_align: __privateGet2(this, _r_align),\n      b_do: __privateGet2(this, _b_do) === void 0 ? void 0 : __privateGet2(this, _b_do) instanceof Sprite ? \"Sprite\" : \"Graphics\",\n      b_pic: __privateGet2(this, _b_pic),\n      b_color: __privateGet2(this, _b_color),\n      b_alpha: __privateGet2(this, _b_alpha),\n      b_alpha_isfixed: __privateGet2(this, _b_alpha_isfixed),\n      ffs: __privateGet2(this, _ffs),\n      txs: __privateGet2(this, _txs).record(),\n      strNoFFS: __privateGet2(this, _strNoFFS),\n      btns: __privateGet2(this, _cntBtn).children.map((btn) => btn.name)\n    });\n    this.spLay.addChild(__privateGet2(this, _txs));\n    __privateGet2(this, _rbSpl).init(__privateGet2(this, _putCh2));\n    this.spLay.addChild(__privateGet2(this, _cntBtn));\n    __privateGet2(this, _cntBtn).name = \"cntBtn\";\n    const padding = 16;\n    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${padding}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(cfg, hTag, val, recText, isPageFore, appPixi) {\n    var _a3, _b3;\n    __privateSet2(_TxtLayer, _cfg3, cfg);\n    TxtStage.init(cfg, appPixi);\n    __privateSet2(_TxtLayer, _val, val);\n    __privateSet2(_TxtLayer, _recText, recText);\n    __privateSet2(_TxtLayer, _isPageFore, isPageFore);\n    val.setDoRecProc(_TxtLayer.chgDoRec);\n    hTag.autowc = (o) => {\n      var _a4;\n      return __privateMethod2(_a4 = _TxtLayer, _autowc, autowc_fn).call(_a4, o);\n    };\n    hTag.autowc({ enabled: false, text: \"\", time: 0 });\n    hTag.ch_in_style = (o) => {\n      var _a4;\n      return __privateMethod2(_a4 = _TxtLayer, _ch_in_style, ch_in_style_fn).call(_a4, o);\n    };\n    hTag.ch_out_style = (o) => {\n      var _a4;\n      return __privateMethod2(_a4 = _TxtLayer, _ch_out_style, ch_out_style_fn).call(_a4, o);\n    };\n    TxtStage.initChStyle();\n    initStyle();\n    let font = \"\";\n    cfg.matchPath(\".+\", Config.EXT_FONT).forEach((o) => {\n      for (const key in o)\n        font += `\n@font-face {\n\tfont-family: '${o[key]}';\n\tsrc: url('${__privateGet2(this, _cfg3).searchPath(o[key], Config.EXT_FONT)}');\n}\n`;\n    });\n    font += `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`;\n    addStyle(font);\n    __privateMethod2(_a3 = _TxtLayer, _ch_in_style, ch_in_style_fn).call(_a3, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: true,\n      ease: \"ease-out\"\n    });\n    __privateMethod2(_b3 = _TxtLayer, _ch_out_style, ch_out_style_fn).call(_b3, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: false,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(main2, evtMng, sys) {\n    __privateSet2(_TxtLayer, _main2, main2);\n    __privateSet2(_TxtLayer, _evtMng4, evtMng);\n    __privateSet2(_TxtLayer, _sys3, sys);\n    TxtStage.setEvtMng(evtMng);\n  }\n  destroy() {\n    if (__privateGet2(this, _b_do)) {\n      this.spLay.removeChild(__privateGet2(this, _b_do)).destroy();\n      __privateSet2(this, _b_do, void 0);\n    }\n    this.clearText();\n    __privateGet2(this, _txs).destroy();\n  }\n  static destroy() {\n    __privateSet2(_TxtLayer, _doAutoWc, false);\n    __privateSet2(_TxtLayer, _hAutoWc, {});\n    __privateSet2(_TxtLayer, _rec, (tx) => tx);\n  }\n  set name(nm) {\n    this.name_ = nm;\n    __privateGet2(this, _txs).name = nm;\n  }\n  get name() {\n    return this.name_;\n  }\n  cvsResize() {\n    __privateGet2(this, _txs).cvsResize();\n  }\n  cvsResizeChildren() {\n    __privateGet2(this, _cntBtn).children.forEach((b2) => b2.cvsResize());\n  }\n  lay(hArg) {\n    var _a3;\n    super.lay(hArg);\n    Layer.setXY(this.spLay, hArg, this.spLay);\n    hArg[\":id_tag\"] = this.name_.slice(0, -7);\n    RubySpliter.setting(hArg);\n    __privateMethod2(this, _setFfs, setFfs_fn).call(this, hArg);\n    __privateGet2(this, _txs).lay(hArg);\n    if (\"r_align\" in hArg)\n      __privateSet2(this, _r_align, (_a3 = hArg.r_align) != null ? _a3 : \"\");\n    __privateSet2(this, _ruby_pd, CmnLib.isSafari ? __privateGet2(this, _txs).tategaki ? (v2, l2) => `text-align: start; height: ${l2}em; padding-top: ${v2}; padding-bottom: ${v2};` : (v2, l2) => `text-align: start; width: ${l2}em; padding-left: ${v2}; padding-right: ${v2};` : __privateGet2(this, _txs).tategaki ? (v2) => `text-align: justify; text-align-last: justify; padding-top: ${v2}; padding-bottom: ${v2};` : (v2) => `text-align: justify; text-align-last: justify; padding-left: ${v2}; padding-right: ${v2};`);\n    if (CmnLib.isFirefox)\n      this.mkStyle_r_align = __privateMethod2(this, _mkStyle_r_align4ff, mkStyle_r_align4ff_fn);\n    if (\"alpha\" in hArg)\n      __privateGet2(this, _cntBtn).children.forEach((e) => e.alpha = this.spLay.alpha);\n    __privateMethod2(this, _set_ch_in, set_ch_in_fn).call(this, hArg);\n    __privateMethod2(this, _set_ch_out, set_ch_out_fn).call(this, hArg);\n    return __privateMethod2(this, _drawBack, drawBack_fn).call(this, hArg, (isStop) => {\n      if (isStop)\n        __privateGet2(_TxtLayer, _main2).resume();\n    });\n  }\n  get width() {\n    return __privateGet2(this, _txs).getWidth;\n  }\n  get height() {\n    return __privateGet2(this, _txs).getHeight;\n  }\n  chgBackAlpha(g_alpha) {\n    const alpha = __privateGet2(this, _b_alpha_isfixed) ? __privateGet2(this, _b_alpha) : g_alpha * __privateGet2(this, _b_alpha);\n    if (__privateGet2(this, _b_do) instanceof Graphics) {\n      if (__privateGet2(this, _b_do)) {\n        this.spLay.removeChild(__privateGet2(this, _b_do));\n        __privateGet2(this, _b_do).destroy();\n      }\n      this.spLay.addChildAt(__privateSet2(this, _b_do, new Graphics()).beginFill(__privateGet2(this, _b_color)).lineStyle(void 0).drawRect(0, 0, __privateGet2(this, _txs).getWidth, __privateGet2(this, _txs).getHeight).endFill(), 0);\n      __privateGet2(this, _b_do).name = \"back(color)\";\n    }\n    if (__privateGet2(this, _b_do)) {\n      __privateGet2(this, _b_do).visible = alpha > 0;\n      __privateGet2(this, _b_do).alpha = alpha;\n    }\n  }\n  static chgDoRec(doRec) {\n    __privateSet2(_TxtLayer, _rec, doRec ? (tx) => tx : (tx) => `<span class='offrec'>${tx}</span>`);\n    __privateSet2(_TxtLayer, _class_offrec, doRec ? \"\" : \" offrec\");\n  }\n  mkStyle_r_align(ch, rb, r_align) {\n    if (!r_align)\n      return \"\";\n    const len = ch.length * 2;\n    if (len - rb.length < 0)\n      return ` style='text-align: ${r_align};'`;\n    let st = \"\";\n    switch (r_align) {\n      case \"justify\":\n        st = __privateGet2(this, _ruby_pd).call(this, \"0\", len);\n        break;\n      case \"121\":\n        st = __privateGet2(this, _ruby_pd).call(this, `calc(${(len - rb.length) / (rb.length * 2)}em)`, len);\n        break;\n      case \"even\":\n        st = __privateGet2(this, _ruby_pd).call(this, `calc(${(len - rb.length) / (rb.length + 1)}em)`, len);\n        break;\n      case \"1ruby\":\n        st = __privateGet2(this, _ruby_pd).call(this, \"1em\", len);\n        break;\n      default:\n        st = `text-align: ${r_align};`;\n    }\n    return ` style='${st}'`;\n  }\n  tagCh(text2) {\n    __privateGet2(this, _rbSpl).putTxt(text2);\n  }\n  clearText() {\n    var _a3;\n    this.spLay.addChild(__privateSet2(this, _txs, __privateGet2(this, _txs).reNew()));\n    __privateSet2(this, _cumDelay, 0);\n    __privateSet2(this, _firstCh, true);\n    __privateSet2(this, _aSpan, []);\n    __privateSet2(this, _aSpan_bk, void 0);\n    __privateSet2(_TxtLayer, _rec, __privateGet2(_TxtLayer, _rec_bk));\n    __privateSet2(this, _page_text, \"\");\n    __privateGet2(_a3 = _TxtLayer, _recText).call(_a3, \"\", true);\n  }\n  get pageText() {\n    return __privateGet2(this, _page_text).replace(\"\\u300A\\u3000\\u300B\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var _a3, _b3;\n    return ((_a3 = this.spLay.interactiveChildren) != null ? _a3 : false) && this.spLay.visible && __privateGet2(_b3 = _TxtLayer, _isPageFore).call(_b3, this);\n  }\n  clearLay(hArg) {\n    super.clearLay(hArg);\n    this.clearText();\n    __privateGet2(this, _cntBtn).removeChildren().forEach((c2) => c2.destroy());\n  }\n  playback(hLay, aPrm) {\n    super.playback(hLay, aPrm);\n    this.enabled = hLay.enabled;\n    __privateSet2(this, _r_align, hLay.r_align);\n    this.cvsResize();\n    __privateMethod2(this, _setFfs, setFfs_fn).call(this, hLay);\n    __privateGet2(this, _txs).playback(hLay.txs);\n    __privateSet2(this, _b_alpha, hLay.b_alpha);\n    __privateSet2(this, _b_alpha_isfixed, hLay.b_alpha_isfixed);\n    aPrm.push(new Promise((re2) => {\n      if (!__privateMethod2(this, _drawBack, drawBack_fn).call(this, hLay.b_do ? hLay.b_do === \"Sprite\" ? { b_pic: hLay.b_pic } : { b_color: hLay.b_color } : { b_pic: \"\" }, (isStop) => {\n        if (isStop)\n          re2();\n      }))\n        re2();\n    }));\n    const aBtn = hLay.btns;\n    aPrm = aPrm.concat(aBtn.map((v2) => this.addButton(JSON.parse(v2.replaceAll(`'`, '\"')))));\n  }\n  snapshot(rnd, re2) {\n    rnd.render(this.spLay, { clear: false });\n    __privateGet2(this, _txs).snapshot(rnd, re2);\n  }\n  snapshot_end() {\n    __privateGet2(this, _txs).snapshot_end();\n  }\n  makeDesignCast(gdc) {\n    if (!this.spLay.visible)\n      return;\n    __privateGet2(this, _txs).makeDesignCast(gdc);\n  }\n  makeDesignCastChildren(gdc) {\n    if (!this.spLay.visible)\n      return;\n    __privateGet2(this, _cntBtn).children.forEach((btn) => btn.makeDesignCast(gdc));\n  }\n  showDesignCast() {\n    __privateGet2(this, _txs).showDesignCast();\n  }\n  showDesignCastChildren() {\n    __privateGet2(this, _cntBtn).children.forEach((btn) => btn.showDesignCast());\n  }\n  dump() {\n    __privateGet2(this, _putCh2).call(this, \"\", \"gotxt\\uFF5C\");\n    return super.dump() + `, \"enabled\":\"${this.enabled}\", ${__privateGet2(this, _txs).dump()}, \"b_pic\":\"${__privateGet2(this, _b_pic)}\", \"b_color\":\"${__privateGet2(this, _b_color)}\", \"b_alpha\":${__privateGet2(this, _b_alpha)}, \"b_alpha_isfixed\":\"${__privateGet2(this, _b_alpha_isfixed)}\", \"width\":${__privateGet2(this, _txs).getWidth}, \"height\":${__privateGet2(this, _txs).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Sprite ? \"Sprite\" : e instanceof Graphics ? \"Graphics\" : e instanceof Container ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${__privateGet2(this, _cntBtn).children.map((d2) => {\n      var _a3;\n      return (_a3 = d2.children[0].name) != null ? _a3 : \"{}\";\n    }).join(\",\")}]`;\n  }\n};\nlet TxtLayer = _TxtLayer;\n_cfg3 = new WeakMap();\n_val = new WeakMap();\n_recText = new WeakMap();\n_isPageFore = new WeakMap();\n_ch_in_style = new WeakSet();\nch_in_style_fn = function(hArg) {\n  const o = TxtStage.ch_in_style(hArg);\n  const x2 = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`;\n  const y2 = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`;\n  const { name } = hArg;\n  addStyle(`\n.sn_ch_in_${name} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${name} {\n\topacity: ${o.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${name} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes sn_ch_in_${name} {\n\tfrom {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x2}, ${y2});}\n\tto {opacity: 1; transform: none;}\n}\n`);\n  return false;\n};\n_ch_out_style = new WeakSet();\nch_out_style_fn = function(hArg) {\n  const o = TxtStage.ch_out_style(hArg);\n  const x2 = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`;\n  const y2 = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`;\n  const { name } = hArg;\n  addStyle(`\n.go_ch_out_${name} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${name} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes go_ch_out_${name} {\n\tto {\n\t\topacity: ${o.alpha};\n\t\ttransform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x2}, ${y2});\n\t}\n`);\n  return false;\n};\n_main2 = new WeakMap();\n_evtMng4 = new WeakMap();\n_sys3 = new WeakMap();\n_doAutoWc = new WeakMap();\n_hAutoWc = new WeakMap();\n_autowc = new WeakSet();\nautowc_fn = function(hArg) {\n  __privateSet2(_TxtLayer, _doAutoWc, argChk_Boolean(hArg, \"enabled\", __privateGet2(_TxtLayer, _doAutoWc)));\n  __privateGet2(_TxtLayer, _val).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", __privateGet2(_TxtLayer, _doAutoWc));\n  const { text: text2 } = hArg;\n  if (\"text\" in hArg !== \"time\" in hArg)\n    throw \"[autowc] text\\u3068time\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u5FC5\\u9808\\u3067\\u3059\";\n  __privateGet2(_TxtLayer, _val).setVal_Nochk(\"save\", \"const.sn.autowc.text\", text2);\n  if (!text2) {\n    __privateGet2(_TxtLayer, _val).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\");\n    return false;\n  }\n  const len = text2.length;\n  if (__privateGet2(_TxtLayer, _doAutoWc) && len === 0)\n    throw '[autowc] enabled === false \\u304B\\u3064 text === \"\" \\u306F\\u8A31\\u3055\\u308C\\u307E\\u305B\\u3093';\n  const a2 = String(hArg.time).split(\",\");\n  if (a2.length !== len)\n    throw \"[autowc] text\\u6587\\u5B57\\u6570\\u3068time\\u306B\\u8A18\\u8FF0\\u3055\\u308C\\u305F\\u5F85\\u3061\\u6642\\u9593\\uFF08\\u30B3\\u30F3\\u30DE\\u533A\\u5207\\u308A\\uFF09\\u306F\\u540C\\u6570\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  __privateSet2(_TxtLayer, _hAutoWc, {});\n  a2.forEach((v2, i2) => __privateGet2(_TxtLayer, _hAutoWc)[text2[i2]] = uint(v2));\n  __privateGet2(_TxtLayer, _val).setVal_Nochk(\"save\", \"const.sn.autowc.time\", hArg.time);\n  return false;\n};\n_b_color = new WeakMap();\n_b_alpha = new WeakMap();\n_b_alpha_isfixed = new WeakMap();\n_b_do = new WeakMap();\n_b_pic = new WeakMap();\n_txs = new WeakMap();\n_rbSpl = new WeakMap();\n_cntBtn = new WeakMap();\n_set_ch_in = new WeakSet();\nset_ch_in_fn = function(hArg) {\n  const { in_style } = hArg;\n  if (!in_style)\n    return;\n  const cis = TxtStage.getChInStyle(in_style);\n  if (!cis)\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044in_style\\u3010${in_style}\\u3011\\u3067\\u3059`;\n  __privateSet2(this, _$ch_in_style, in_style);\n  __privateSet2(this, _ch_in_join, cis.join);\n};\n_$ch_in_style = new WeakMap();\n_ch_in_join = new WeakMap();\n_set_ch_out = new WeakSet();\nset_ch_out_fn = function(hArg) {\n  const { out_style } = hArg;\n  if (!out_style)\n    return;\n  const cos = TxtStage.getChOutStyle(out_style);\n  if (!cos)\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044out_style\\u3010${out_style}\\u3011\\u3067\\u3059`;\n  __privateSet2(this, _$ch_out_style, out_style);\n};\n_$ch_out_style = new WeakMap();\n_drawBack = new WeakSet();\ndrawBack_fn = function(hArg, fncComp) {\n  if (\"back_clear\" in hArg) {\n    if (argChk_Boolean(hArg, \"back_clear\", false)) {\n      __privateSet2(this, _b_color, 0);\n      __privateSet2(this, _b_alpha, 0);\n      __privateSet2(this, _b_alpha_isfixed, false);\n      __privateSet2(this, _b_pic, \"\");\n    }\n    fncComp(false);\n    return false;\n  }\n  __privateSet2(this, _b_alpha, argChk_Num(hArg, \"b_alpha\", __privateGet2(this, _b_alpha)));\n  __privateSet2(this, _b_alpha_isfixed, argChk_Boolean(hArg, \"b_alpha_isfixed\", __privateGet2(this, _b_alpha_isfixed)));\n  const alpha = (__privateGet2(this, _b_alpha_isfixed) ? 1 : Number(__privateGet2(_TxtLayer, _val).getVal(\"sys:TextLayer.Back.Alpha\"))) * __privateGet2(this, _b_alpha);\n  if (hArg.b_pic) {\n    if (__privateGet2(this, _b_pic) !== hArg.b_pic) {\n      __privateSet2(this, _b_pic, hArg.b_pic);\n      if (__privateGet2(this, _b_do)) {\n        this.spLay.removeChild(__privateGet2(this, _b_do));\n        __privateGet2(this, _b_do).destroy();\n      }\n      return GrpLayer.csv2Sprites(__privateGet2(this, _b_pic), this.spLay, (sp) => {\n        __privateSet2(this, _b_do, sp);\n        sp.name = \"back(pic)\";\n        sp.visible = alpha > 0;\n        sp.alpha = alpha;\n        __privateGet2(this, _txs).setSize(sp.width, sp.height);\n        this.spLay.setChildIndex(sp, 0);\n        fncComp(true);\n      });\n    }\n  } else if (\"b_color\" in hArg) {\n    __privateSet2(this, _b_color, argChk_Color(hArg, \"b_color\", 0));\n    if (__privateGet2(this, _b_do)) {\n      this.spLay.removeChild(__privateGet2(this, _b_do));\n      __privateGet2(this, _b_do).destroy();\n    }\n    __privateSet2(this, _b_pic, \"\");\n    this.spLay.addChildAt(__privateSet2(this, _b_do, new Graphics()).beginFill(__privateGet2(this, _b_color)).lineStyle(void 0).drawRect(0, 0, __privateGet2(this, _txs).getWidth, __privateGet2(this, _txs).getHeight).endFill(), 0);\n    __privateGet2(this, _b_do).name = \"back(color)\";\n  }\n  if (__privateGet2(this, _b_do)) {\n    __privateGet2(this, _b_do).visible = alpha > 0;\n    __privateGet2(this, _b_do).alpha = alpha;\n  }\n  fncComp(false);\n  return false;\n};\n_setFfs = new WeakSet();\nsetFfs_fn = function(hArg) {\n  var _a3, _b3;\n  if (\"noffs\" in hArg) {\n    __privateSet2(this, _strNoFFS, (_a3 = hArg.noffs) != null ? _a3 : \"\");\n    __privateSet2(this, _regNoFFS, new RegExp(`[\\u3000${__privateGet2(this, _strNoFFS)}]`));\n  }\n  if (!(\"ffs\" in hArg))\n    return;\n  (_b3 = __privateGet2(this, _ffs)) != null ? _b3 : __privateSet2(this, _ffs, \"\");\n  if (__privateGet2(this, _ffs) === \"\") {\n    __privateSet2(this, _fncFFSStyle, () => \"\");\n    __privateSet2(this, _fncFFSSpan, (ch) => ch);\n  } else {\n    __privateSet2(this, _fncFFSStyle, (ch) => __privateGet2(this, _regNoFFS).test(ch) ? \"\" : ` font-feature-settings: ${__privateGet2(this, _ffs)};`);\n    __privateSet2(this, _fncFFSSpan, (ch) => __privateGet2(this, _regNoFFS).test(ch) ? ch : `<span style='font-feature-settings: ${__privateGet2(this, _ffs)};'>${ch}</span>`);\n  }\n};\n_ffs = new WeakMap();\n_fncFFSStyle = new WeakMap();\n_fncFFSSpan = new WeakMap();\n_strNoFFS = new WeakMap();\n_regNoFFS = new WeakMap();\n_rec = new WeakMap();\n_rec_bk = new WeakMap();\n_class_offrec = new WeakMap();\n_ruby_pd = new WeakMap();\n_r_align = new WeakMap();\n_mkStyle_r_align4ff = new WeakSet();\nmkStyle_r_align4ff_fn = function(ch, rb, r_align) {\n  if (!r_align)\n    return \"\";\n  const len = ch.length * 2;\n  if (len - rb.length < 0)\n    return ` style='text-align: ${r_align};'`;\n  let st = \"\";\n  switch (r_align) {\n    case \"left\":\n      st = `ruby-align: start;`;\n      break;\n    case \"center\":\n      st = `ruby-align: center;`;\n      break;\n    case \"right\":\n      st = `ruby-align: start;`;\n      break;\n    case \"justify\":\n      st = `ruby-align: space-between;`;\n      break;\n    case \"121\":\n      st = `ruby-align: space-around;`;\n      break;\n    case \"even\":\n      const ev = (len - rb.length) / (rb.length + 1);\n      st = `ruby-align: space-between; ` + (__privateGet2(this, _txs).tategaki ? `padding-top: ${ev}em; padding-bottom: ${ev}em;` : `padding-left: ${ev}em; padding-right: ${ev}em;`);\n      break;\n    case \"1ruby\":\n      st = `ruby-align: space-between; ` + (__privateGet2(this, _txs).tategaki ? `padding-top: 1em; padding-bottom: 1em;` : `padding-left: 1em; padding-right: 1em;`);\n      break;\n    default:\n      st = `text-align: ${r_align};`;\n  }\n  return ` style='${st}'`;\n};\n_needGoTxt = new WeakMap();\n_putCh2 = new WeakMap();\n_tagCh_sub = new WeakSet();\ntagCh_sub_fn = function(ch, ruby, isSkip, r_align) {\n  var _a3;\n  if (ch === \" \")\n    ch = \"&nbsp;\";\n  if (__privateGet2(_TxtLayer, _val).doRecLog())\n    __privateSet2(this, _page_text, __privateGet2(this, _page_text) + (ch + (ruby ? `\\u300A${ruby}\\u300B` : \"\")));\n  let add_htm = \"\";\n  const rs = this.mkStyle_r_align(ch, ruby, r_align);\n  if (isSkip)\n    __privateSet2(this, _cumDelay, 0);\n  const da = ` data-add='{\"ch_in_style\":\"${__privateGet2(this, _$ch_in_style)}\", \"ch_out_style\":\"${__privateGet2(this, _$ch_out_style)}\"}'`;\n  add_htm = ruby ? __privateGet2(this, _aSpan_bk) ? `<ruby style='${__privateGet2(this, _fncFFSStyle).call(this, ch)}'${da} data-cmd='linkrsv'>${ch}<rt${rs}>${ruby}</rt></ruby>` : `<span class='sn_ch sn_ch_in_${__privateGet2(this, _$ch_in_style)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${__privateGet2(this, _fncFFSStyle).call(this, ch)}'>\n\t\t\t\t\t<ruby${da}>${ch}<rt${rs}>${ruby}</rt></ruby>\n\t\t\t\t</span>` : __privateGet2(this, _aSpan_bk) ? __privateGet2(this, _fncFFSSpan).call(this, ch) : `<span class='sn_ch sn_ch_in_${__privateGet2(this, _$ch_in_style)}' style='animation-delay: ${__privateGet2(this, _cumDelay)}ms;${__privateGet2(this, _fncFFSStyle).call(this, ch)}'${da}>${ch}</span>`;\n  if (__privateGet2(this, _ch_in_join))\n    __privateSet2(this, _cumDelay, __privateGet2(this, _cumDelay) + (__privateGet2(_TxtLayer, _doAutoWc) ? (_a3 = __privateGet2(_TxtLayer, _hAutoWc)[ch.charAt(0)]) != null ? _a3 : 0 : LayerMng.msecChWait));\n  return add_htm;\n};\n_cumDelay = new WeakMap();\n_firstCh = new WeakMap();\n_aSpan = new WeakMap();\n_aSpan_bk = new WeakMap();\n_aSpan_link = new WeakMap();\n_hSpanBk = new WeakMap();\n_beginSpan = new WeakSet();\nbeginSpan_fn = function(o) {\n  __privateGet2(this, _hSpanBk).ch_in_style = __privateGet2(this, _$ch_in_style);\n  __privateMethod2(this, _set_ch_in, set_ch_in_fn).call(this, o);\n  __privateGet2(this, _hSpanBk).ch_out_style = __privateGet2(this, _$ch_out_style);\n  __privateMethod2(this, _set_ch_out, set_ch_out_fn).call(this, o);\n  __privateGet2(this, _hSpanBk).r_align = __privateGet2(this, _r_align);\n  if (\"r_align\" in o)\n    __privateSet2(this, _r_align, o.r_align);\n};\n_autoCloseSpan = new WeakSet();\nautoCloseSpan_fn = function() {\n  if (!__privateGet2(this, _aSpan_bk))\n    return;\n  __privateGet2(this, _aSpan_bk).push(__privateGet2(this, _aSpan), \"</span>\");\n  __privateSet2(this, _aSpan, Array.prototype.concat.apply([], __privateGet2(this, _aSpan_bk)));\n  __privateSet2(this, _aSpan_bk, void 0);\n  __privateSet2(_TxtLayer, _rec, __privateGet2(_TxtLayer, _rec_bk));\n  __privateMethod2(this, _set_ch_in, set_ch_in_fn).call(this, { in_style: __privateGet2(this, _hSpanBk).ch_in_style });\n  __privateMethod2(this, _set_ch_out, set_ch_out_fn).call(this, { out_style: __privateGet2(this, _hSpanBk).ch_out_style });\n  __privateSet2(this, _r_align, __privateGet2(this, _hSpanBk).r_align);\n};\n_page_text = new WeakMap();\n__privateAdd2(TxtLayer, _ch_in_style);\n__privateAdd2(TxtLayer, _ch_out_style);\n__privateAdd2(TxtLayer, _autowc);\n__privateAdd2(TxtLayer, _cfg3, void 0);\n__privateAdd2(TxtLayer, _val, void 0);\n__privateAdd2(TxtLayer, _recText, void 0);\n__privateAdd2(TxtLayer, _isPageFore, void 0);\n__privateAdd2(TxtLayer, _main2, void 0);\n__privateAdd2(TxtLayer, _evtMng4, void 0);\n__privateAdd2(TxtLayer, _sys3, void 0);\n__privateAdd2(TxtLayer, _doAutoWc, false);\n__privateAdd2(TxtLayer, _hAutoWc, {});\n__privateAdd2(TxtLayer, _rec, (tx) => tx);\n__privateAdd2(TxtLayer, _rec_bk, (tx) => tx);\n__privateAdd2(TxtLayer, _class_offrec, \" offrec\");\nclass FrameMng {\n  constructor(cfg, hTag, appPixi, val, main2, sys, hTwInf) {\n    __privateAdd2(this, _add_frame);\n    __privateAdd2(this, _rect);\n    __privateAdd2(this, _let_frame);\n    __privateAdd2(this, _set_frame);\n    __privateAdd2(this, _frame);\n    __privateAdd2(this, _tsy_frame);\n    __privateAdd2(this, _evtMng5, void 0);\n    __privateAdd2(this, _hIfrm, /* @__PURE__ */ Object.create(null));\n    __privateAdd2(this, _hDisabled, {});\n    __privateAdd2(this, _zIdx, 1);\n    this.cfg = cfg;\n    this.appPixi = appPixi;\n    this.val = val;\n    this.main = main2;\n    this.sys = sys;\n    this.hTwInf = hTwInf;\n    hTag.add_frame = (o) => __privateMethod2(this, _add_frame, add_frame_fn).call(this, o);\n    hTag.let_frame = (o) => __privateMethod2(this, _let_frame, let_frame_fn).call(this, o);\n    hTag.set_frame = (o) => __privateMethod2(this, _set_frame, set_frame_fn).call(this, o);\n    hTag.frame = (o) => __privateMethod2(this, _frame, frame_fn).call(this, o);\n    hTag.tsy_frame = (o) => __privateMethod2(this, _tsy_frame, tsy_frame_fn).call(this, o);\n  }\n  setEvtMng(evtMng) {\n    __privateSet2(this, _evtMng5, evtMng);\n  }\n  destroy() {\n    for (const n in __privateGet2(this, _hIfrm)) {\n      const f2 = __privateGet2(this, _hIfrm)[n];\n      f2.parentElement.removeChild(f2);\n    }\n    __privateSet2(this, _hIfrm, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(id) {\n    return __privateGet2(this, _hDisabled)[id];\n  }\n  cvsResize() {\n    for (const id in __privateGet2(this, _hIfrm)) {\n      const f2 = __privateGet2(this, _hIfrm)[id];\n      const vn = \"const.sn.frm.\" + id;\n      const x2 = Number(this.val.getVal(vn + \".x\"));\n      const y2 = Number(this.val.getVal(vn + \".y\"));\n      const w2 = Number(this.val.getVal(vn + \".width\"));\n      const h2 = Number(this.val.getVal(vn + \".height\"));\n      f2.style.left = `${this.sys.ofsLeft4elm + x2 * this.sys.cvsScale}px`;\n      f2.style.top = `${this.sys.ofsTop4elm + y2 * this.sys.cvsScale}px`;\n      f2.width = String(w2 * this.sys.cvsScale);\n      f2.height = String(h2 * this.sys.cvsScale);\n    }\n  }\n}\n_evtMng5 = new WeakMap();\n_hIfrm = new WeakMap();\n_add_frame = new WeakSet();\nadd_frame_fn = function(hArg) {\n  const { id, src, alpha: a2 = 1, scale_x: sx = 1, scale_y: sy = 1, rotate: r2 = 0 } = hArg;\n  if (!id)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!src)\n    throw \"src\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const vn = \"const.sn.frm.\" + id;\n  if (this.val.getVal(`tmp:${vn}`))\n    throw `frame\\u3010${id}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  const v2 = argChk_Boolean(hArg, \"visible\", true);\n  const b_color = hArg.b_color ? ` background-color: ${hArg.b_color};` : \"\";\n  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg);\n  this.appPixi.view.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${id}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${a2}; position: absolute; left:${this.sys.ofsLeft4elm + rct.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + rct.y * this.sys.cvsScale}px; z-index: 1; ${b_color} border: 0px; overflow: hidden; display: ${v2 ? \"inline\" : \"none\"}; transform: scale(${sx}, ${sy}) rotate(${r2}deg);\" width=\"${rct.width * this.sys.cvsScale}\" height=\"${rct.height * this.sys.cvsScale}\"></iframe>`);\n  const url2 = this.cfg.searchPath(src, Config.EXT_HTML);\n  const ld = new Loader().add({ name: src, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });\n  if (this.sys.crypto)\n    ld.use((res, next) => {\n      try {\n        res.data = this.sys.decStr(res.extension, res.data);\n      } catch (e) {\n        this.main.errScript(`[add_frame]Html \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 src:${res.name} ${e}`, false);\n      }\n      next == null ? void 0 : next();\n    });\n  ld.load((_ldr, hRes) => {\n    var _a3;\n    const ifrm = document.getElementById(id);\n    __privateGet2(this, _hIfrm)[id] = ifrm;\n    __privateGet2(this, _hDisabled)[id] = false;\n    ifrm.srcdoc = String((_a3 = hRes[src]) == null ? void 0 : _a3.data).replace(\"sn_repRes();\", \"\").replace(/\\s(?:src|href)=([\"'])(\\S+)\\1/g, (v22, p1, p2) => p2.slice(0, 3) === \"../\" ? this.sys.cur + p2.slice(4) : v22.replace(p1, p1 + url2.slice(0, url2.lastIndexOf(\"/\") + 1)));\n    ifrm.onload = () => {\n      var _a4;\n      this.val.setVal_Nochk(\"tmp\", vn, true);\n      this.val.setVal_Nochk(\"tmp\", vn + \".alpha\", a2);\n      this.val.setVal_Nochk(\"tmp\", vn + \".x\", rct.x);\n      this.val.setVal_Nochk(\"tmp\", vn + \".y\", rct.y);\n      this.val.setVal_Nochk(\"tmp\", vn + \".scale_x\", sx);\n      this.val.setVal_Nochk(\"tmp\", vn + \".scale_y\", sy);\n      this.val.setVal_Nochk(\"tmp\", vn + \".rotate\", r2);\n      this.val.setVal_Nochk(\"tmp\", vn + \".width\", rct.width);\n      this.val.setVal_Nochk(\"tmp\", vn + \".height\", rct.height);\n      this.val.setVal_Nochk(\"tmp\", vn + \".visible\", v2);\n      const win = ifrm.contentWindow;\n      __privateGet2(this, _evtMng5).resvFlameEvent(win);\n      (_a4 = win.sn_repRes) == null ? void 0 : _a4.call(win, (img) => {\n        var _a5;\n        return GrpLayer.loadPic2Img((_a5 = img.dataset.src) != null ? _a5 : \"\", img);\n      });\n      this.main.resume();\n    };\n  });\n  return true;\n};\n_hDisabled = new WeakMap();\n_rect = new WeakSet();\nrect_fn = function(hArg) {\n  const a2 = __spreadValues({}, hArg);\n  const re2 = this.sys.resolution;\n  return new DOMRect(argChk_Num(a2, \"x\", 0) * re2, argChk_Num(a2, \"y\", 0) * re2, argChk_Num(a2, \"width\", CmnLib.stageW) * re2, argChk_Num(a2, \"height\", CmnLib.stageH) * re2);\n};\n_let_frame = new WeakSet();\nlet_frame_fn = function(hArg) {\n  const { id, var_name } = hArg;\n  if (!id)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const f2 = document.getElementById(id);\n  if (!f2)\n    throw `id\\u3010${id}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const vn = \"const.sn.frm.\" + id;\n  if (!this.val.getVal(`tmp:${vn}`))\n    throw `frame\\u3010${id}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!var_name)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const win = f2.contentWindow;\n  if (!win.hasOwnProperty(var_name))\n    throw `frame\\u3010${id}\\u3011\\u306B\\u5909\\u6570/\\u95A2\\u6570\\u3010${var_name}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u5909\\u6570\\u306F var\\u4ED8\\u304D\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044`;\n  const v2 = win[var_name];\n  this.val.setVal_Nochk(\"tmp\", vn + \".\" + var_name, argChk_Boolean(hArg, \"function\", false) ? v2() : v2);\n  return false;\n};\n_set_frame = new WeakSet();\nset_frame_fn = function(hArg) {\n  const { id, var_name, text: text2 } = hArg;\n  if (!id)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const f2 = document.getElementById(id);\n  if (!f2)\n    throw `id\\u3010${id}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const vn = \"const.sn.frm.\" + id;\n  if (!this.val.getVal(`tmp:${vn}`))\n    throw `frame\\u3010${id}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!var_name)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!text2)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  this.val.setVal_Nochk(\"tmp\", vn + \".\" + var_name, text2);\n  const win = f2.contentWindow;\n  win[var_name] = text2;\n  return false;\n};\n_zIdx = new WeakMap();\n_frame = new WeakSet();\nframe_fn = function(hArg) {\n  const { id } = hArg;\n  if (!id)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const f2 = document.getElementById(id);\n  if (!f2)\n    throw `id\\u3010${id}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const vn = \"const.sn.frm.\" + id;\n  if (!this.val.getVal(\"tmp:\" + vn))\n    throw `frame\\u3010${id}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const s2 = f2.style;\n  if (argChk_Boolean(hArg, \"float\", false))\n    s2.zIndex = `${++__privateWrapper2(this, _zIdx)._}`;\n  else if (\"index\" in hArg)\n    s2.zIndex = `${argChk_Num(hArg, \"index\", 0)}`;\n  else if (hArg.dive)\n    s2.zIndex = `-${++__privateWrapper2(this, _zIdx)._}`;\n  if (\"alpha\" in hArg) {\n    const a2 = s2.opacity = String(hArg.alpha);\n    this.val.setVal_Nochk(\"tmp\", vn + \".alpha\", a2);\n  }\n  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg);\n  if (\"x\" in hArg || \"y\" in hArg) {\n    s2.left = `${this.sys.ofsLeft4elm + rct.x * this.sys.cvsScale}px`;\n    s2.top = `${this.sys.ofsTop4elm + rct.y * this.sys.cvsScale}px`;\n    this.val.setVal_Nochk(\"tmp\", vn + \".x\", rct.x);\n    this.val.setVal_Nochk(\"tmp\", vn + \".y\", rct.y);\n  }\n  if (\"scale_x\" in hArg || \"scale_y\" in hArg || \"rotate\" in hArg) {\n    const sx = argChk_Num(hArg, \"scale_x\", 1);\n    const sy = argChk_Num(hArg, \"scale_y\", 1);\n    const r2 = argChk_Num(hArg, \"rotate\", 0);\n    s2.transform = `scale(${sx}, ${sy}) rotate(${r2}deg)`;\n    this.val.setVal_Nochk(\"tmp\", vn + \".scale_x\", sx);\n    this.val.setVal_Nochk(\"tmp\", vn + \".scale_y\", sy);\n    this.val.setVal_Nochk(\"tmp\", vn + \".rotate\", r2);\n  }\n  if (\"width\" in hArg) {\n    f2.width = String(rct.width * this.sys.cvsScale);\n    this.val.setVal_Nochk(\"tmp\", vn + \".width\", rct.width);\n  }\n  if (\"height\" in hArg) {\n    f2.height = String(rct.height * this.sys.cvsScale);\n    this.val.setVal_Nochk(\"tmp\", vn + \".height\", rct.height);\n  }\n  if (\"visible\" in hArg) {\n    const v2 = argChk_Boolean(hArg, \"visible\", true);\n    s2.display = v2 ? \"inline\" : \"none\";\n    this.val.setVal_Nochk(\"tmp\", vn + \".visible\", v2);\n  }\n  if (\"b_color\" in hArg)\n    s2.backgroundColor = hArg.b_color;\n  if (\"disabled\" in hArg) {\n    const d2 = __privateGet2(this, _hDisabled)[id] = argChk_Boolean(hArg, \"disabled\", true);\n    const il = f2.contentDocument.body.querySelectorAll(\"input,select\");\n    il.forEach((v2) => v2.disabled = d2);\n  }\n  return false;\n};\n_tsy_frame = new WeakSet();\ntsy_frame_fn = function(hArg) {\n  var _a3;\n  const { id } = hArg;\n  if (!id)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const f2 = document.getElementById(id);\n  if (!f2)\n    throw `id\\u3010${id}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const vn = `const.sn.frm.` + id;\n  if (!this.val.getVal(`tmp:${vn}`, 0))\n    throw `frame\\u3010${id}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const hNow = {};\n  if (\"alpha\" in hArg)\n    hNow.a = f2.style.opacity;\n  if (\"x\" in hArg || \"y\" in hArg || \"scale_x\" in hArg || \"scale_y\" in hArg || \"rotate\" in hArg) {\n    hNow.x = Number(this.val.getVal(`tmp:${vn}.x`));\n    hNow.y = Number(this.val.getVal(`tmp:${vn}.y`));\n    hNow.sx = Number(this.val.getVal(`tmp:${vn}.scale_x`));\n    hNow.sy = Number(this.val.getVal(`tmp:${vn}.scale_y`));\n    hNow.r = Number(this.val.getVal(`tmp:${vn}.rotate`));\n  }\n  if (\"width\" in hArg)\n    hNow.w = this.val.getVal(`tmp:${vn}.width`);\n  if (\"height\" in hArg)\n    hNow.h = this.val.getVal(`tmp:${vn}.height`);\n  const hArg2 = cnvTweenArg(hArg, hNow);\n  const hTo = {};\n  const repeat = argChk_Num(hArg, \"repeat\", 1);\n  let fncA = () => {\n  };\n  if (\"alpha\" in hArg) {\n    hTo.a = argChk_Num(hArg2, \"alpha\", 0);\n    fncA = () => {\n      f2.style.opacity = hNow.a;\n      this.val.setVal_Nochk(\"tmp\", \"alpha\", hNow.a);\n    };\n  }\n  let fncXYSR = () => {\n  };\n  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg2);\n  if (\"x\" in hArg || \"y\" in hArg || \"scale_x\" in hArg || \"scale_y\" in hArg || \"rotate\" in hArg) {\n    hTo.x = rct.x;\n    hTo.y = rct.y;\n    hTo.sx = argChk_Num(hArg2, \"scale_x\", 1);\n    hTo.sy = argChk_Num(hArg2, \"scale_y\", 1);\n    hTo.r = argChk_Num(hArg2, \"rotate\", 0);\n    fncXYSR = () => {\n      f2.style.left = this.sys.ofsLeft4elm + hNow.x * this.sys.cvsScale + \"px\";\n      f2.style.top = this.sys.ofsTop4elm + hNow.y * this.sys.cvsScale + \"px\";\n      f2.style.transform = `scale(${hNow.sx}, ${hNow.sy}) rotate(${hNow.r}deg)`;\n      this.val.setVal_Nochk(\"tmp\", vn + \".x\", hNow.x);\n      this.val.setVal_Nochk(\"tmp\", vn + \".y\", hNow.y);\n      this.val.setVal_Nochk(\"tmp\", vn + \".scale_x\", hNow.sx);\n      this.val.setVal_Nochk(\"tmp\", vn + \".scale_y\", hNow.sy);\n      this.val.setVal_Nochk(\"tmp\", vn + \".rotate\", hNow.r);\n    };\n  }\n  let fncW = () => {\n  };\n  if (\"width\" in hArg) {\n    hTo.w = rct.width;\n    fncW = () => {\n      f2.width = hNow.w * this.sys.cvsScale + \"px\";\n      this.val.setVal_Nochk(\"tmp\", vn + \".width\", hNow.w);\n    };\n  }\n  let fncH = () => {\n  };\n  if (\"height\" in hArg) {\n    hTo.h = rct.height;\n    fncH = () => {\n      f2.height = hNow.h * this.sys.cvsScale + \"px\";\n      this.val.setVal_Nochk(\"tmp\", vn + \".height\", hNow.h);\n    };\n  }\n  this.appPixi.stage.interactive = false;\n  const tw_nm = `frm\n${hArg.id}`;\n  const tw = new Tween(hNow).to(hTo, argChk_Num(hArg, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || __privateGet2(this, _evtMng5).isSkippingByKeyDown()) ? 0 : 1)).delay(argChk_Num(hArg, \"delay\", 0)).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, \"yoyo\", false)).onUpdate(() => {\n    fncA();\n    fncXYSR();\n    fncW();\n    fncH();\n  }).onComplete(() => {\n    var _a4, _b3;\n    this.appPixi.stage.interactive = true;\n    const ti = this.hTwInf[tw_nm];\n    if (!ti)\n      return;\n    delete this.hTwInf[tw_nm];\n    (_a4 = ti.tw) == null ? void 0 : _a4.stop();\n    if (ti.resume)\n      this.main.resume();\n    (_b3 = ti.onEnd) == null ? void 0 : _b3.call(ti);\n  });\n  if (\"chain\" in hArg) {\n    const twFrom = this.hTwInf[(_a3 = hArg.chain) != null ? _a3 : \"\"];\n    if (!twFrom || !twFrom.tw)\n      throw `${hArg.chain}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete twFrom.onEnd;\n    twFrom.tw.chain(tw);\n  } else\n    tw.start();\n  this.hTwInf[tw_nm] = { tw, resume: false };\n  return false;\n};\nconst _LayerMng = class {\n  constructor(cfg, hTag, appPixi, val, main2, scrItr, sys, sndMng, alzTagArg, prpPrs) {\n    __privateAdd2(this, _selectNode);\n    __privateAdd2(this, _foreachRedrawTxtLayBack);\n    __privateAdd2(this, _snapshot);\n    __privateAdd2(this, _loadplugin);\n    __privateAdd2(this, _add_lay);\n    __privateAdd2(this, _lay);\n    __privateAdd2(this, _rebuildLayerRankInfo);\n    __privateAdd2(this, _clear_lay);\n    __privateAdd2(this, _trans);\n    __privateAdd2(this, _getLayers);\n    __privateAdd2(this, _foreachLayers);\n    __privateAdd2(this, _sortLayers);\n    __privateAdd2(this, _wt);\n    __privateAdd2(this, _finish_trans);\n    __privateAdd2(this, _quake);\n    __privateAdd2(this, _tsy);\n    __privateAdd2(this, _wait_tsy);\n    __privateAdd2(this, _stop_tsy);\n    __privateAdd2(this, _pause_tsy);\n    __privateAdd2(this, _resume_tsy);\n    __privateAdd2(this, _ch);\n    __privateAdd2(this, _$getTxtLayer);\n    __privateAdd2(this, _$current);\n    __privateAdd2(this, _argChk_layer);\n    __privateAdd2(this, _clear_text);\n    __privateAdd2(this, _endlink);\n    __privateAdd2(this, _er);\n    __privateAdd2(this, _graph);\n    __privateAdd2(this, _link);\n    __privateAdd2(this, _r);\n    __privateAdd2(this, _rec_r);\n    __privateAdd2(this, _rec_ch);\n    __privateAdd2(this, _reset_rec);\n    __privateAdd2(this, _ruby2);\n    __privateAdd2(this, _span);\n    __privateAdd2(this, _tcy);\n    __privateAdd2(this, _dump_lay);\n    __privateAdd2(this, _enable_event);\n    __privateAdd2(this, _button);\n    __privateAdd2(this, _stage, void 0);\n    __privateAdd2(this, _fore, void 0);\n    __privateAdd2(this, _back, void 0);\n    __privateAdd2(this, _frmMng, void 0);\n    __privateAdd2(this, _bg_color, void 0);\n    __privateAdd2(this, _fncTicker, void 0);\n    __privateAdd2(this, _hProcDbgRes2, void 0);\n    __privateAdd2(this, _modeLn, void 0);\n    __privateAdd2(this, _modeLnSub, void 0);\n    __privateAdd2(this, _grpCover, void 0);\n    __privateAdd2(this, _evtMng6, void 0);\n    __privateAdd2(this, _cmdTxt, void 0);\n    __privateAdd2(this, _hPages, void 0);\n    __privateAdd2(this, _aLayName, void 0);\n    __privateAdd2(this, _curTxtlay, void 0);\n    __privateAdd2(this, _firstGrplay, void 0);\n    __privateAdd2(this, _srcRuleTransFragment, void 0);\n    __privateAdd2(this, _ufRuleTrans, void 0);\n    __privateAdd2(this, _fltRule, void 0);\n    __privateAdd2(this, _rtTransBack, void 0);\n    __privateAdd2(this, _spTransBack, void 0);\n    __privateAdd2(this, _rtTransFore, void 0);\n    __privateAdd2(this, _spTransFore, void 0);\n    __privateAdd2(this, _aBackTransAfter, void 0);\n    __privateAdd2(this, _tiTrans, void 0);\n    __privateAdd2(this, _hTwInf, void 0);\n    __privateAdd2(this, _getTxtLayer, void 0);\n    __privateAdd2(this, _current, void 0);\n    __privateAdd2(this, _pgTxtlay, void 0);\n    __privateAdd2(this, _chkTxtLay, void 0);\n    __privateAdd2(this, _oLastPage, void 0);\n    __privateAdd2(this, _aTxtLog, void 0);\n    this.cfg = cfg;\n    this.hTag = hTag;\n    this.appPixi = appPixi;\n    this.val = val;\n    this.main = main2;\n    this.scrItr = scrItr;\n    this.sys = sys;\n    this.sndMng = sndMng;\n    this.alzTagArg = alzTagArg;\n    this.prpPrs = prpPrs;\n    __privateSet2(this, _fore, new Container());\n    __privateSet2(this, _back, new Container());\n    __privateSet2(this, _fncTicker, () => update());\n    __privateSet2(this, _hProcDbgRes2, {\n      attach: (_2) => {\n        DesignCast.leaveMode();\n        return false;\n      },\n      continue: (_2) => {\n        DesignCast.leaveMode();\n        return false;\n      },\n      disconnect: (_2) => {\n        DesignCast.leaveMode();\n        return false;\n      },\n      _enterDesign: (_2) => {\n        DesignCast.enterMode();\n        __privateGet2(this, _aLayName).forEach((layer) => {\n          const lay = __privateGet2(this, _hPages)[layer].fore;\n          lay.makeDesignCastChildren((gdc) => gdc.make());\n          lay.makeDesignCast((gdc) => gdc.make());\n        });\n        __privateMethod2(this, _selectNode, selectNode_fn).call(this, __privateGet2(this, _curTxtlay));\n        return false;\n      },\n      _replaceToken: (_2, o) => {\n        DesignCast.replaceToken(o);\n        return false;\n      },\n      _selectNode: (_2, o) => {\n        __privateMethod2(this, _selectNode, selectNode_fn).call(this, o.node);\n        return false;\n      }\n    });\n    __privateSet2(this, _modeLn, \"\");\n    __privateSet2(this, _modeLnSub, \"\");\n    this.getFrmDisabled = (id) => __privateGet2(this, _frmMng).getFrmDisabled(id);\n    __privateSet2(this, _grpCover, void 0);\n    __privateSet2(this, _cmdTxt, (cmd, tl = this.currentTxtlayForeNeedErr, _record = true) => tl.tagCh(\"\\uFF5C\\u3000\\u300A\" + cmd + \"\\u300B\"));\n    this.goTxt = () => {\n    };\n    this.breakLine = () => {\n    };\n    this.breakPage = () => {\n    };\n    __privateSet2(this, _hPages, {});\n    __privateSet2(this, _aLayName, []);\n    __privateSet2(this, _curTxtlay, \"\");\n    __privateSet2(this, _firstGrplay, \"\");\n    __privateSet2(this, _srcRuleTransFragment, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`);\n    __privateSet2(this, _ufRuleTrans, {\n      rule: Texture.EMPTY,\n      vague: 0,\n      tick: 0\n    });\n    __privateSet2(this, _fltRule, new Filter(void 0, __privateGet2(this, _srcRuleTransFragment), __privateGet2(this, _ufRuleTrans)));\n    __privateSet2(this, _rtTransBack, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    __privateSet2(this, _spTransBack, new Sprite(__privateGet2(this, _rtTransBack)));\n    __privateSet2(this, _rtTransFore, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    __privateSet2(this, _spTransFore, new Sprite(__privateGet2(this, _rtTransFore)));\n    __privateSet2(this, _aBackTransAfter, []);\n    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });\n    __privateSet2(this, _hTwInf, {});\n    __privateSet2(this, _getTxtLayer, (_hArg) => {\n      __privateGet2(this, _chkTxtLay).call(this);\n      throw 0;\n    });\n    __privateSet2(this, _current, (_hArg) => {\n      __privateGet2(this, _chkTxtLay).call(this);\n      throw 0;\n    });\n    __privateSet2(this, _chkTxtLay, () => {\n      throw \"\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u6587\\u5B57\\u8868\\u793A\\u3084\\u64CD\\u4F5C\\u3059\\u308B\\u524D\\u306B\\u3001[add_lay layer=\\uFF08\\u30EC\\u30A4\\u30E4\\u540D\\uFF09 class=txt]\\u3067\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u3092\\u8FFD\\u52A0\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n    });\n    __privateSet2(this, _oLastPage, { text: \"\" });\n    __privateSet2(this, _aTxtLog, []);\n    const fncResizeLay = () => {\n      sys.cvsResize();\n      this.cvsResizeDesign();\n      if (__privateGet2(this, _modeLnSub))\n        __privateGet2(this, _aLayName).forEach((layer) => __privateGet2(this, _hPages)[layer].fore.cvsResizeChildren());\n      else\n        __privateGet2(this, _aLayName).forEach((layer) => __privateGet2(this, _hPages)[layer].fore.cvsResize());\n      __privateGet2(this, _frmMng).cvsResize();\n      __privateGet2(this, _evtMng6).cvsResize();\n    };\n    if (CmnLib.isMobile) {\n      globalThis.addEventListener(\"orientationchange\", fncResizeLay, { passive: true });\n    } else {\n      let tid = void 0;\n      globalThis.addEventListener(\"resize\", () => {\n        if (tid)\n          return;\n        tid = setTimeout(() => {\n          tid = void 0;\n          fncResizeLay();\n        }, 1e3 / 60 * 10);\n      }, { passive: true });\n    }\n    sys.cvsResize();\n    TxtLayer.init(cfg, hTag, val, (txt) => this.recText(txt), (me) => __privateGet2(this, _hPages)[me.layname].fore === me, appPixi);\n    GrpLayer.init(main2, cfg, appPixi, sys, sndMng);\n    Button.init(cfg);\n    __privateSet2(this, _frmMng, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, main2, this.sys, __privateGet2(this, _hTwInf)));\n    sys.hFactoryCls.grp = () => new GrpLayer();\n    sys.hFactoryCls.txt = () => new TxtLayer();\n    hTag.loadplugin = (o) => __privateMethod2(this, _loadplugin, loadplugin_fn).call(this, o);\n    hTag.snapshot = (o) => __privateMethod2(this, _snapshot, snapshot_fn).call(this, o);\n    hTag.add_lay = (o) => __privateMethod2(this, _add_lay, add_lay_fn).call(this, o);\n    hTag.clear_lay = (o) => __privateMethod2(this, _clear_lay, clear_lay_fn).call(this, o);\n    hTag.finish_trans = () => __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);\n    hTag.lay = (o) => __privateMethod2(this, _lay, lay_fn).call(this, o);\n    hTag.trans = (o) => __privateMethod2(this, _trans, trans_fn).call(this, o);\n    hTag.wt = (o) => __privateMethod2(this, _wt, wt_fn).call(this, o);\n    hTag.quake = (o) => __privateMethod2(this, _quake, quake_fn).call(this, o);\n    hTag.stop_quake = (o) => hTag.finish_trans(o);\n    hTag.wq = (o) => hTag.wt(o);\n    hTag.pause_tsy = (o) => __privateMethod2(this, _pause_tsy, pause_tsy_fn).call(this, o);\n    hTag.resume_tsy = (o) => __privateMethod2(this, _resume_tsy, resume_tsy_fn).call(this, o);\n    hTag.stop_tsy = (o) => __privateMethod2(this, _stop_tsy, stop_tsy_fn).call(this, o);\n    hTag.tsy = (o) => __privateMethod2(this, _tsy, tsy_fn).call(this, o);\n    hTag.wait_tsy = (o) => __privateMethod2(this, _wait_tsy, wait_tsy_fn).call(this, o);\n    hTag.ch = (o) => __privateMethod2(this, _ch, ch_fn).call(this, o);\n    hTag.clear_text = (o) => __privateMethod2(this, _clear_text, clear_text_fn).call(this, o);\n    hTag.current = (o) => __privateGet2(this, _current).call(this, o);\n    hTag.endlink = (o) => __privateMethod2(this, _endlink, endlink_fn).call(this, o);\n    hTag.er = (o) => __privateMethod2(this, _er, er_fn).call(this, o);\n    hTag.graph = (o) => __privateMethod2(this, _graph, graph_fn).call(this, o);\n    hTag.link = (o) => __privateMethod2(this, _link, link_fn).call(this, o);\n    hTag.r = (o) => __privateMethod2(this, _r, r_fn).call(this, o);\n    hTag.rec_ch = (o) => __privateMethod2(this, _rec_ch, rec_ch_fn).call(this, o);\n    hTag.rec_r = () => __privateMethod2(this, _rec_r, rec_r_fn).call(this);\n    hTag.reset_rec = (o) => __privateMethod2(this, _reset_rec, reset_rec_fn).call(this, o);\n    hTag.ruby2 = (o) => __privateMethod2(this, _ruby2, ruby2_fn).call(this, o);\n    hTag.span = (o) => __privateMethod2(this, _span, span_fn).call(this, o);\n    hTag.tcy = (o) => __privateMethod2(this, _tcy, tcy_fn).call(this, o);\n    hTag.add_face = (o) => GrpLayer.add_face(o);\n    hTag.wv = (o) => GrpLayer.wv(o);\n    hTag.dump_lay = (o) => __privateMethod2(this, _dump_lay, dump_lay_fn).call(this, o);\n    hTag.enable_event = (o) => __privateMethod2(this, _enable_event, enable_event_fn).call(this, o);\n    hTag.button = (o) => __privateMethod2(this, _button, button_fn).call(this, o);\n    if (cfg.existsBreakline)\n      this.breakLine = () => __privateGet2(this, _cmdTxt).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakline\"}');\n    if (cfg.existsBreakpage)\n      this.breakPage = () => __privateGet2(this, _cmdTxt).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakpage\"}');\n    __privateSet2(this, _bg_color, parseColor(String(cfg.oCfg.init.bg_color)));\n    const grp = new Graphics();\n    grp.beginFill(__privateGet2(this, _bg_color), 1).lineStyle(0, __privateGet2(this, _bg_color)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill();\n    __privateGet2(this, _fore).addChild(grp.clone());\n    __privateGet2(this, _back).addChild(grp);\n    __privateGet2(this, _back).visible = false;\n    __privateSet2(this, _stage, this.appPixi.stage);\n    __privateGet2(this, _stage).addChild(__privateGet2(this, _back));\n    __privateGet2(this, _stage).addChild(__privateGet2(this, _fore));\n    __privateGet2(this, _stage).addChild(__privateGet2(this, _spTransBack));\n    __privateGet2(this, _stage).addChild(__privateGet2(this, _spTransFore));\n    this.appPixi.ticker.add(__privateGet2(this, _fncTicker));\n    const fncTxt_b_alpha = (_name, val2) => {\n      __privateMethod2(this, _foreachRedrawTxtLayBack, foreachRedrawTxtLayBack_fn).call(this, Number(val2));\n    };\n    fncTxt_b_alpha(\"\", val.getVal(\"sys:TextLayer.Back.Alpha\", 1));\n    val.defValTrg(\"sys:TextLayer.Back.Alpha\", fncTxt_b_alpha);\n    const fncBtnFont = (_name, val2) => Button.fontFamily = val2;\n    fncBtnFont(\"\", val.getVal(\"tmp:sn.button.fontFamily\", Button.fontFamily));\n    val.defValTrg(\"tmp:sn.button.fontFamily\", fncBtnFont);\n    val.defTmp(\"const.sn.log.json\", () => JSON.stringify(__privateGet2(this, _oLastPage).text ? [...__privateGet2(this, _aTxtLog), __privateGet2(this, _oLastPage)] : __privateGet2(this, _aTxtLog)));\n    val.defTmp(\"const.sn.last_page_text\", () => {\n      var _a3, _b3;\n      return (_b3 = (_a3 = this.currentTxtlayFore) == null ? void 0 : _a3.pageText) != null ? _b3 : \"\";\n    });\n    if (CmnLib.isDbg) {\n      DesignCast.init(this.appPixi, sys, scrItr, prpPrs, alzTagArg, this.cfg, __privateGet2(this, _hPages));\n      this.cvsResizeDesign = () => DesignCast.cvsResizeDesign();\n      sys.addHook((type, o) => {\n        var _a3, _b3;\n        if (!((_b3 = (_a3 = __privateGet2(this, _hProcDbgRes2))[type]) == null ? void 0 : _b3.call(_a3, type, o)))\n          return;\n        delete __privateGet2(this, _hProcDbgRes2)[type];\n      });\n    }\n  }\n  cvsResizeDesign() {\n  }\n  cover(visible, bg_color = 0) {\n    if (__privateGet2(this, _grpCover)) {\n      __privateGet2(this, _stage).removeChild(__privateGet2(this, _grpCover));\n      __privateGet2(this, _grpCover).destroy();\n      __privateSet2(this, _grpCover, void 0);\n    }\n    if (visible)\n      __privateGet2(this, _stage).addChild(__privateSet2(this, _grpCover, new Graphics()).beginFill(bg_color).lineStyle(0, bg_color).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill());\n  }\n  setEvtMng(evtMng) {\n    __privateSet2(this, _evtMng6, evtMng);\n    __privateGet2(this, _frmMng).setEvtMng(evtMng);\n    GrpLayer.setEvtMng(evtMng);\n  }\n  before_destroy() {\n    for (const pg in __privateGet2(this, _hPages))\n      __privateGet2(this, _hPages)[pg].destroy();\n  }\n  destroy() {\n    GrpLayer.destroy();\n    RubySpliter.destroy();\n    TxtStage.destroy();\n    TxtLayer.destroy();\n    __privateGet2(this, _frmMng).destroy();\n    this.stopAllTw();\n    this.appPixi.ticker.remove(__privateGet2(this, _fncTicker));\n    __privateSet2(_LayerMng, _msecChWait, 10);\n  }\n  stopAllTw() {\n    __privateSet2(this, _hTwInf, {});\n    removeAll();\n  }\n  clearBreak() {\n    if (!this.currentTxtlayFore)\n      return;\n    this.clearBreak = () => __privateGet2(this, _cmdTxt).call(this, \"del\\uFF5Cbreak\");\n    this.clearBreak();\n  }\n  clickTxtLay() {\n    if (!this.currentTxtlayFore)\n      return;\n    const vct = __privateMethod2(this, _getLayers, getLayers_fn).call(this);\n    const len = vct.length;\n    for (let i2 = 0; i2 < len; ++i2) {\n      const name = vct[i2];\n      const pg = __privateGet2(this, _hPages)[name];\n      if (!(pg.fore instanceof TxtLayer))\n        continue;\n      const pTxt = pg.fore;\n      if (!pTxt.click())\n        break;\n    }\n  }\n  static get msecChWait() {\n    return __privateGet2(_LayerMng, _msecChWait);\n  }\n  static set msecChWait(v2) {\n    __privateSet2(_LayerMng, _msecChWait, v2);\n  }\n  setNormalChWait() {\n    __privateSet2(_LayerMng, _msecChWait, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    __privateGet2(this, _chkTxtLay).call(this);\n    return this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    if (!__privateGet2(this, _pgTxtlay))\n      return void 0;\n    return __privateGet2(this, _pgTxtlay).fore;\n  }\n  recText(txt, pagebreak = false) {\n    const o = __privateGet2(this, _oLastPage);\n    if (pagebreak) {\n      if (o.text) {\n        o.text = String(o.text).replaceAll(`</span><span class='sn_ch'>`, \"\");\n        if (__privateGet2(this, _aTxtLog).push(o) > this.cfg.oCfg.log.max_len)\n          __privateSet2(this, _aTxtLog, __privateGet2(this, _aTxtLog).slice(-this.cfg.oCfg.log.max_len));\n      }\n      __privateSet2(this, _oLastPage, { text: \"\" });\n      return;\n    }\n    o.text = txt.replace(/\\\\`/, \"`\");\n    this.val.setVal_Nochk(\"save\", \"const.sn.sLog\", String(this.val.getVal(\"const.sn.log.json\")));\n  }\n  record() {\n    const o = {};\n    __privateGet2(this, _aLayName).forEach((layer) => {\n      const pg = __privateGet2(this, _hPages)[layer];\n      o[layer] = {\n        cls: pg.cls,\n        fore: pg.fore.record(),\n        back: pg.back.record()\n      };\n    });\n    return o;\n  }\n  playback($hPages, fncComp) {\n    var _a3, _b3;\n    __privateSet2(this, _aTxtLog, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\"))));\n    __privateSet2(this, _oLastPage, { text: \"\" });\n    const aPrm = [];\n    const aSort = [];\n    for (const layer in $hPages) {\n      const $pg = $hPages[layer];\n      aSort.push({ layer, idx: $pg.fore.idx });\n      const pg = (_b3 = (_a3 = __privateGet2(this, _hPages))[layer]) != null ? _b3 : _a3[layer] = new Pages(layer, $pg.cls, __privateGet2(this, _fore), __privateGet2(this, _back), {}, this.sys, this.val, { isWait: false });\n      pg.fore.playback($pg.fore, aPrm);\n      pg.back.playback($pg.back, aPrm);\n    }\n    const len = __privateGet2(this, _fore).children.length;\n    Promise.allSettled(aPrm).then(() => {\n      aSort.sort(function(a2, b2) {\n        if (a2.idx < b2.idx)\n          return -1;\n        if (a2.idx > b2.idx)\n          return 1;\n        return 0;\n      });\n      aSort.forEach((o) => {\n        const pg = __privateGet2(this, _hPages)[o.layer];\n        if (!pg)\n          return;\n        const idx = len > o.idx ? o.idx : len - 1;\n        __privateGet2(this, _fore).setChildIndex(pg.fore.spLay, idx);\n        __privateGet2(this, _back).setChildIndex(pg.back.spLay, idx);\n      });\n      fncComp();\n    }).catch((e) => console.error(`fn:LayerMng.ts playback e:%o`, e));\n  }\n};\nlet LayerMng = _LayerMng;\n_stage = new WeakMap();\n_fore = new WeakMap();\n_back = new WeakMap();\n_frmMng = new WeakMap();\n_bg_color = new WeakMap();\n_fncTicker = new WeakMap();\n_hProcDbgRes2 = new WeakMap();\n_modeLn = new WeakMap();\n_modeLnSub = new WeakMap();\n_selectNode = new WeakSet();\nselectNode_fn = function(node) {\n  [__privateWrapper2(this, _modeLn)._, this._modeLnSub = \"\"] = node.split(\"/\");\n  const pages = __privateGet2(this, _hPages)[__privateGet2(this, _modeLn)];\n  if (!pages)\n    return;\n  DesignCast.allHide();\n  if (__privateGet2(this, _modeLnSub))\n    pages.fore.showDesignCastChildren();\n  else\n    pages.fore.showDesignCast();\n};\n_grpCover = new WeakMap();\n_evtMng6 = new WeakMap();\n_foreachRedrawTxtLayBack = new WeakSet();\nforeachRedrawTxtLayBack_fn = function(g_alpha) {\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name) => {\n    const pg = __privateGet2(this, _hPages)[name];\n    if (!(pg.fore instanceof TxtLayer))\n      return;\n    const pTxt = pg.fore;\n    pTxt.chgBackAlpha(g_alpha);\n    pg.back.chgBackAlpha(g_alpha);\n  });\n};\n_cmdTxt = new WeakMap();\n_snapshot = new WeakSet();\nsnapshot_fn = function(hArg) {\n  const fn0 = hArg.fn ? hArg.fn.slice(0, 10) === \"userdata:/\" ? hArg.fn : `downloads:/${hArg.fn + getDateStr(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${getDateStr(\"-\", \"_\", \"\", \"_\")}.png`;\n  const fn2 = this.cfg.searchPath(fn0);\n  if (this.sys.canCapturePage(fn2))\n    return false;\n  const ext = getExt(fn2);\n  const b_color = argChk_Color(hArg, \"b_color\", __privateGet2(this, _bg_color));\n  const rnd = autoDetectRenderer({\n    width: argChk_Num(hArg, \"width\", CmnLib.stageW),\n    height: argChk_Num(hArg, \"height\", CmnLib.stageH),\n    backgroundAlpha: b_color > 16777216 && ext === \"png\" ? 0 : 1,\n    antialias: argChk_Boolean(hArg, \"smoothing\", false),\n    preserveDrawingBuffer: true,\n    backgroundColor: b_color & 16777215,\n    autoDensity: true\n  });\n  const a2 = [];\n  const pg = hArg.page !== \"back\" ? \"fore\" : \"back\";\n  if (__privateGet2(this, _tiTrans).tw)\n    a2.push(new Promise((re2) => {\n      __privateGet2(this, _back).visible = true;\n      __privateGet2(this, _aBackTransAfter).forEach((lay) => rnd.render(lay, { clear: false }));\n      __privateGet2(this, _back).visible = false;\n      __privateGet2(this, _spTransBack).visible = true;\n      __privateGet2(this, _fore).filters = __privateGet2(this, _spTransFore).filters;\n      __privateGet2(this, _fore).visible = true;\n      rnd.render(__privateGet2(this, _fore), { clear: false });\n      __privateGet2(this, _fore).visible = false;\n      __privateGet2(this, _fore).filters = [];\n      re2();\n    }));\n  else\n    __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((v2) => a2.push(new Promise((re2) => __privateGet2(this, _hPages)[v2][pg].snapshot(rnd, () => re2()))));\n  Promise.allSettled(a2).then(async () => {\n    const renTx = RenderTexture.create({ width: rnd.width, height: rnd.height, transform: true });\n    rnd.render(__privateGet2(this, _stage), { renderTexture: renTx });\n    await this.sys.savePic(fn2, rnd.plugins.extract.base64(Sprite.from(renTx)));\n    if (!__privateGet2(this, _tiTrans).tw)\n      __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((v2) => __privateGet2(this, _hPages)[v2][pg].snapshot_end());\n    rnd.destroy(true);\n  });\n  return false;\n};\n_loadplugin = new WeakSet();\nloadplugin_fn = function(hArg) {\n  const { fn: fn2 } = hArg;\n  if (!fn2)\n    throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const join = argChk_Boolean(hArg, \"join\", true);\n  switch (getExt(fn2)) {\n    case \"css\":\n      (async () => {\n        const res = await fetch(fn2);\n        if (!res.ok)\n          throw new Error(\"Network response was not ok.\");\n        addStyle(await res.text());\n        if (join)\n          this.main.resume();\n      })();\n      break;\n    default:\n      throw \"\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3067\\u3059\";\n  }\n  return join;\n};\n_add_lay = new WeakSet();\nadd_lay_fn = function(hArg) {\n  const { layer, class: cls } = hArg;\n  if (!layer)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (layer.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (layer in __privateGet2(this, _hPages))\n    throw `layer\\u3010${layer}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  if (!cls)\n    throw \"cls\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const ret = { isWait: false };\n  __privateGet2(this, _hPages)[layer] = new Pages(layer, cls, __privateGet2(this, _fore), __privateGet2(this, _back), hArg, this.sys, this.val, ret);\n  __privateGet2(this, _aLayName).push(layer);\n  switch (cls) {\n    case \"txt\":\n      if (!__privateGet2(this, _curTxtlay)) {\n        __privateSet2(this, _chkTxtLay, () => {\n        });\n        __privateSet2(this, _getTxtLayer, __privateMethod2(this, _$getTxtLayer, $getTxtLayer_fn));\n        __privateSet2(this, _current, __privateMethod2(this, _$current, $current_fn));\n        this.hTag.current({ layer });\n        this.goTxt = () => {\n          if (this.val.getVal(\"sn.skip.enabled\")) {\n            __privateSet2(_LayerMng, _msecChWait, 0);\n          } else {\n            this.setNormalChWait();\n          }\n          __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name) => {\n            const pg = __privateGet2(this, _hPages)[name];\n            if (!(pg.fore instanceof TxtLayer))\n              return;\n            __privateGet2(this, _cmdTxt).call(this, \"gotxt\\uFF5C\", pg.fore, false);\n          });\n        };\n      }\n      this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + (layer != null ? layer : __privateGet2(this, _curTxtlay)) + \".enabled\", true);\n      break;\n    case \"grp\":\n      if (__privateGet2(this, _firstGrplay))\n        break;\n      __privateSet2(this, _firstGrplay, layer);\n      break;\n  }\n  this.scrItr.recodeDesign(hArg);\n  return ret.isWait;\n};\n_hPages = new WeakMap();\n_aLayName = new WeakMap();\n_curTxtlay = new WeakMap();\n_firstGrplay = new WeakMap();\n_lay = new WeakSet();\nlay_fn = function(hArg) {\n  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg);\n  const pg = __privateGet2(this, _hPages)[layer];\n  const back = pg.back.spLay;\n  const fore = pg.fore.spLay;\n  if (argChk_Boolean(hArg, \"float\", false)) {\n    __privateGet2(this, _back).setChildIndex(back, __privateGet2(this, _back).children.length - 1);\n    __privateGet2(this, _fore).setChildIndex(fore, __privateGet2(this, _fore).children.length - 1);\n    __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);\n  } else if (hArg.index) {\n    if (argChk_Num(hArg, \"index\", 0)) {\n      __privateGet2(this, _back).setChildIndex(back, hArg.index);\n      __privateGet2(this, _fore).setChildIndex(fore, hArg.index);\n      __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);\n    }\n  } else if (hArg.dive) {\n    const { dive } = hArg;\n    let idx_dive = 0;\n    if (layer === dive)\n      throw \"[lay] \\u5C5E\\u6027 layer\\u3068dive\\u304C\\u540C\\u3058\\u3010\" + dive + \"\\u3011\\u3067\\u3059\";\n    const pg_dive = __privateGet2(this, _hPages)[dive];\n    if (!pg_dive)\n      throw \"[lay] \\u5C5E\\u6027 dive\\u3010\" + dive + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n    const back_dive = pg_dive.back;\n    const fore_dive = pg_dive.fore;\n    const idx_back_dive = __privateGet2(this, _back).getChildIndex(back_dive.spLay);\n    const idx_fore_dive = __privateGet2(this, _fore).getChildIndex(fore_dive.spLay);\n    idx_dive = idx_back_dive < idx_fore_dive ? idx_back_dive : idx_fore_dive;\n    if (idx_dive > __privateGet2(this, _back).getChildIndex(back))\n      --idx_dive;\n    __privateGet2(this, _fore).setChildIndex(fore, idx_dive);\n    __privateGet2(this, _back).setChildIndex(back, idx_dive);\n    __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);\n  }\n  hArg[\":id_tag\"] = pg.fore.name.slice(0, -7);\n  this.scrItr.recodeDesign(hArg);\n  return pg.lay(hArg);\n};\n_rebuildLayerRankInfo = new WeakSet();\nrebuildLayerRankInfo_fn = function() {\n  __privateSet2(this, _aLayName, __privateMethod2(this, _sortLayers, sortLayers_fn).call(this));\n};\n_clear_lay = new WeakSet();\nclear_lay_fn = function(hArg) {\n  __privateMethod2(this, _foreachLayers, foreachLayers_fn).call(this, hArg, (name) => {\n    const pg = __privateGet2(this, _hPages)[__privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, { layer: name })];\n    if (hArg.page === \"both\") {\n      pg.fore.clearLay(hArg);\n      pg.back.clearLay(hArg);\n    } else {\n      pg.getPage(hArg).clearLay(hArg);\n    }\n  });\n  return false;\n};\n_srcRuleTransFragment = new WeakMap();\n_ufRuleTrans = new WeakMap();\n_fltRule = new WeakMap();\n_rtTransBack = new WeakMap();\n_spTransBack = new WeakMap();\n_rtTransFore = new WeakMap();\n_spTransFore = new WeakMap();\n_aBackTransAfter = new WeakMap();\n_trans = new WeakSet();\ntrans_fn = function(hArg) {\n  __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);\n  const ease = CmnTween.ease(hArg.ease);\n  __privateSet2(this, _aBackTransAfter, []);\n  const hTarget = {};\n  const aFore = [];\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((lay_nm) => {\n    hTarget[lay_nm] = true;\n    aFore.push(__privateGet2(this, _hPages)[lay_nm].fore);\n  });\n  const aBack = [];\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((lay_nm) => {\n    const lay = __privateGet2(this, _hPages)[lay_nm][hTarget[lay_nm] ? \"back\" : \"fore\"];\n    __privateGet2(this, _aBackTransAfter).push(lay.spLay);\n    aBack.push(lay);\n  });\n  __privateGet2(this, _rtTransBack).resize(CmnLib.stageW, CmnLib.stageH);\n  this.appPixi.renderer.render(__privateGet2(this, _back), { renderTexture: __privateGet2(this, _rtTransBack) });\n  let fncRenderBack = () => {\n    __privateGet2(this, _back).visible = true;\n    __privateGet2(this, _aBackTransAfter).forEach((spLay) => {\n      this.appPixi.renderer.render(spLay, { renderTexture: __privateGet2(this, _rtTransBack), clear: false });\n    });\n    __privateGet2(this, _back).visible = false;\n  };\n  if (!aBack.some((lay) => lay.containMovement)) {\n    let oldFnc = fncRenderBack;\n    fncRenderBack = () => {\n      fncRenderBack = () => {\n      };\n      oldFnc();\n    };\n  }\n  __privateGet2(this, _rtTransFore).resize(CmnLib.stageW, CmnLib.stageH);\n  this.appPixi.renderer.render(__privateGet2(this, _fore), { renderTexture: __privateGet2(this, _rtTransFore) });\n  let fncRenderFore = () => {\n    __privateGet2(this, _fore).visible = true;\n    this.appPixi.renderer.render(__privateGet2(this, _fore), { renderTexture: __privateGet2(this, _rtTransFore) });\n    __privateGet2(this, _fore).visible = false;\n  };\n  if (!aFore.some((lay) => lay.containMovement)) {\n    let oldFnc = fncRenderFore;\n    fncRenderFore = () => {\n      fncRenderFore = () => {\n      };\n      oldFnc();\n    };\n  }\n  const fncRender = () => {\n    fncRenderBack();\n    __privateGet2(this, _spTransBack).visible = true;\n    fncRenderFore();\n    __privateGet2(this, _spTransFore).visible = true;\n  };\n  __privateGet2(this, _spTransFore).alpha = 1;\n  const comp = () => {\n    var _a3;\n    if (this.appPixi.ticker)\n      this.appPixi.ticker.remove(fncRender);\n    [__privateWrapper2(this, _fore)._, __privateWrapper2(this, _back)._] = [__privateGet2(this, _back), __privateGet2(this, _fore)];\n    const aPrm = [];\n    for (const lay_name in __privateGet2(this, _hPages)) {\n      const pg = __privateGet2(this, _hPages)[lay_name];\n      if (hTarget[lay_name]) {\n        pg.transPage(aPrm);\n        continue;\n      }\n      const idx = __privateGet2(this, _fore).getChildIndex(pg.back.spLay);\n      __privateGet2(this, _fore).removeChild(pg.back.spLay);\n      __privateGet2(this, _back).removeChild(pg.fore.spLay);\n      __privateGet2(this, _fore).addChildAt(pg.fore.spLay, idx);\n      __privateGet2(this, _back).addChildAt(pg.back.spLay, idx);\n    }\n    Promise.allSettled(aPrm);\n    __privateGet2(this, _fore).visible = true;\n    __privateGet2(this, _back).visible = false;\n    __privateGet2(this, _spTransBack).visible = false;\n    __privateGet2(this, _spTransFore).visible = false;\n    (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.stop();\n    if (__privateGet2(this, _tiTrans).resume)\n      this.main.resume();\n    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });\n  };\n  __privateSet2(this, _tiTrans, { tw: void 0, resume: false });\n  const time = argChk_Num(hArg, \"time\", 0);\n  if (time === 0 || __privateGet2(this, _evtMng6).isSkippingByKeyDown()) {\n    comp();\n    return false;\n  }\n  const is_glsl = \"glsl\" in hArg;\n  if (!is_glsl && !(\"rule\" in hArg)) {\n    __privateGet2(this, _spTransFore).filters = [];\n    __privateGet2(this, _tiTrans).tw = new Tween(__privateGet2(this, _spTransFore)).to({ alpha: 0 }, time).delay(argChk_Num(hArg, \"delay\", 0)).easing(ease).onComplete(comp).start();\n    this.appPixi.ticker.add(fncRender);\n    return false;\n  }\n  const flt = is_glsl ? new Filter(void 0, hArg.glsl, __privateGet2(this, _ufRuleTrans)) : __privateGet2(this, _fltRule);\n  flt.uniforms.vague = argChk_Num(hArg, \"vague\", 0.04);\n  flt.uniforms.tick = 0;\n  __privateGet2(this, _tiTrans).tw = new Tween(flt.uniforms).to({ tick: 1 }, time).delay(argChk_Num(hArg, \"delay\", 0)).easing(ease).onComplete(comp);\n  __privateGet2(this, _spTransFore).filters = [flt];\n  if (is_glsl) {\n    __privateGet2(this, _tiTrans).tw.start();\n    this.appPixi.ticker.add(fncRender);\n    return false;\n  }\n  if (!hArg.rule)\n    throw \"rule\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  GrpLayer.csv2Sprites(hArg.rule, void 0, (sp) => {\n    var _a3;\n    flt.uniforms.rule = sp.texture;\n    sp.destroy();\n    (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.start();\n    this.appPixi.ticker.add(fncRender);\n  });\n  return false;\n};\n_tiTrans = new WeakMap();\n_getLayers = new WeakSet();\ngetLayers_fn = function(layer = \"\") {\n  return layer ? layer.split(\",\") : __privateGet2(this, _aLayName);\n};\n_foreachLayers = new WeakSet();\nforeachLayers_fn = function(hArg, fnc) {\n  const vct = __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer);\n  vct.forEach((name) => {\n    if (!name)\n      return;\n    const pg = __privateGet2(this, _hPages)[name];\n    if (!pg)\n      throw \"\\u5B58\\u5728\\u3057\\u306A\\u3044layer\\u3010\" + name + \"\\u3011\\u3067\\u3059\";\n    fnc(name, pg);\n  });\n  return vct;\n};\n_sortLayers = new WeakSet();\nsortLayers_fn = function(layers = \"\") {\n  return __privateMethod2(this, _getLayers, getLayers_fn).call(this, layers).sort((a2, b2) => {\n    const ai = __privateGet2(this, _fore).getChildIndex(__privateGet2(this, _hPages)[a2].fore.spLay);\n    const bi = __privateGet2(this, _fore).getChildIndex(__privateGet2(this, _hPages)[b2].fore.spLay);\n    if (ai < bi)\n      return -1;\n    if (ai > bi)\n      return 1;\n    return 0;\n  });\n};\n_wt = new WeakSet();\nwt_fn = function(hArg) {\n  if (!__privateGet2(this, _tiTrans).tw)\n    return false;\n  __privateGet2(this, _tiTrans).resume = true;\n  return __privateGet2(this, _evtMng6).waitLimitedEvent(hArg, () => __privateMethod2(this, _finish_trans, finish_trans_fn).call(this));\n};\n_finish_trans = new WeakSet();\nfinish_trans_fn = function() {\n  var _a3;\n  (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.end();\n  return false;\n};\n_quake = new WeakSet();\nquake_fn = function(hArg) {\n  __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);\n  const time = argChk_Num(hArg, \"time\", NaN);\n  if (time === 0)\n    return false;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n    return false;\n  if (__privateGet2(this, _evtMng6).isSkippingByKeyDown())\n    return false;\n  const aDo = [];\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((lay_nm) => {\n    aDo.push(__privateGet2(this, _hPages)[lay_nm].fore.spLay);\n  });\n  __privateGet2(this, _rtTransFore).resize(CmnLib.stageW, CmnLib.stageH);\n  const fncRender = () => {\n    __privateGet2(this, _fore).visible = true;\n    aDo.forEach((lay) => this.appPixi.renderer.render(lay, { renderTexture: __privateGet2(this, _rtTransFore), clear: false }));\n    __privateGet2(this, _fore).visible = false;\n  };\n  __privateGet2(this, _spTransFore).visible = true;\n  __privateGet2(this, _spTransFore).alpha = 1;\n  const h2 = uint(argChk_Num(hArg, \"hmax\", 10));\n  const v2 = uint(argChk_Num(hArg, \"vmax\", 10));\n  const fncH = h2 === 0 ? () => {\n  } : () => __privateGet2(this, _spTransFore).x = Math.round(Math.random() * h2 * 2) - h2;\n  const fncV = v2 === 0 ? () => {\n  } : () => __privateGet2(this, _spTransFore).y = Math.round(Math.random() * v2 * 2) - v2;\n  __privateGet2(this, _spTransFore).filters = [];\n  const repeat = argChk_Num(hArg, \"repeat\", 1);\n  const tw = new Tween(__privateGet2(this, _spTransFore)).to({ x: 0, y: 0 }, time).delay(argChk_Num(hArg, \"delay\", 0)).easing(CmnTween.ease(hArg.ease)).onUpdate(() => {\n    fncH();\n    fncV();\n  }).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, \"yoyo\", false)).onComplete(() => {\n    var _a3, _b3;\n    (_a3 = this.appPixi.ticker) == null ? void 0 : _a3.remove(fncRender);\n    __privateGet2(this, _fore).visible = true;\n    __privateGet2(this, _spTransFore).visible = false;\n    __privateGet2(this, _spTransFore).x = 0;\n    __privateGet2(this, _spTransFore).y = 0;\n    (_b3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _b3.stop();\n    if (__privateGet2(this, _tiTrans).resume)\n      this.main.resume();\n    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });\n  }).start();\n  __privateSet2(this, _tiTrans, { tw, resume: false });\n  this.appPixi.ticker.add(fncRender);\n  return false;\n};\n_hTwInf = new WeakMap();\n_tsy = new WeakSet();\ntsy_fn = function(hArg) {\n  var _a3, _b3;\n  if (!hArg.layer)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg);\n  let foreLay = __privateGet2(this, _hPages)[layer].fore;\n  let finishBlendLayer = () => {\n  };\n  const isSkip = __privateGet2(this, _evtMng6).isSkippingByKeyDown();\n  if (!isSkip && \"render\" in hArg) {\n    foreLay.renderStart();\n    finishBlendLayer = () => foreLay.renderEnd();\n  }\n  const hTo = cnvTweenArg(hArg, foreLay);\n  const repeat = argChk_Num(hArg, \"repeat\", 1);\n  const tw_nm = (_a3 = hArg.name) != null ? _a3 : hArg.layer;\n  const tw = new Tween(foreLay).to(hTo, argChk_Num(hArg, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || isSkip) ? 0 : 1)).delay(argChk_Num(hArg, \"delay\", 0)).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, \"yoyo\", false)).onComplete(() => {\n    var _a4, _b4;\n    const ti = __privateGet2(this, _hTwInf)[tw_nm];\n    if (!ti)\n      return;\n    finishBlendLayer();\n    delete __privateGet2(this, _hTwInf)[tw_nm];\n    (_a4 = ti.tw) == null ? void 0 : _a4.stop();\n    if (ti.resume)\n      this.main.resume();\n    (_b4 = ti.onEnd) == null ? void 0 : _b4.call(ti);\n  });\n  if (\"chain\" in hArg) {\n    const twFrom = __privateGet2(this, _hTwInf)[(_b3 = hArg.chain) != null ? _b3 : \"\"];\n    if (!(twFrom == null ? void 0 : twFrom.tw))\n      throw `${hArg.chain}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete twFrom.onEnd;\n    twFrom.tw.chain(tw);\n  } else\n    tw.start();\n  const arrive = argChk_Boolean(hArg, \"arrive\", false);\n  const backlay = argChk_Boolean(hArg, \"backlay\", false);\n  __privateGet2(this, _hTwInf)[tw_nm] = { tw, resume: false, onEnd: () => {\n    if (arrive)\n      Object.assign(foreLay, hTo);\n    if (backlay) {\n      const backCnt = __privateGet2(this, _hPages)[layer].back.spLay;\n      for (const nm in hMemberCnt)\n        backCnt[nm] = foreLay[nm];\n    }\n  } };\n  return false;\n};\n_wait_tsy = new WeakSet();\nwait_tsy_fn = function(hArg) {\n  var _a3;\n  const tw_nm = \"id\" in hArg ? `frm\n${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;\n  if (!tw_nm)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  const ti = __privateGet2(this, _hTwInf)[tw_nm];\n  if (!(ti == null ? void 0 : ti.tw))\n    return false;\n  return ti.resume = __privateGet2(this, _evtMng6).waitEvent(() => {\n    var _a4;\n    return (_a4 = ti.tw) == null ? void 0 : _a4.end();\n  }, argChk_Boolean(hArg, \"canskip\", true), argChk_Boolean(hArg, \"global\", false));\n};\n_stop_tsy = new WeakSet();\nstop_tsy_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  const tw_nm = \"id\" in hArg ? `frm\n${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;\n  if (!tw_nm)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.end();\n  return false;\n};\n_pause_tsy = new WeakSet();\npause_tsy_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  const tw_nm = \"id\" in hArg ? `frm\n${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;\n  if (!tw_nm)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.pause();\n  return false;\n};\n_resume_tsy = new WeakSet();\nresume_tsy_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  const tw_nm = \"id\" in hArg ? `frm\n${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;\n  if (!tw_nm)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.resume();\n  return false;\n};\n_msecChWait = new WeakMap();\n_ch = new WeakSet();\nch_fn = function(hArg) {\n  const { text: text2 } = hArg;\n  if (!text2)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const tl = __privateGet2(this, _getTxtLayer).call(this, hArg);\n  delete hArg.text;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n    hArg.wait = 0;\n  else if (\"wait\" in hArg)\n    argChk_Num(hArg, \"wait\", NaN);\n  const record = argChk_Boolean(hArg, \"record\", true);\n  const doRecLog = this.val.doRecLog();\n  if (!record)\n    this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", record);\n  tl.tagCh(text2.replaceAll(\"[r]\", \"\\n\"));\n  if (!record)\n    this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", doRecLog);\n  return false;\n};\n_getTxtLayer = new WeakMap();\n_$getTxtLayer = new WeakSet();\n$getTxtLayer_fn = function(hArg) {\n  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg, __privateGet2(this, _curTxtlay));\n  const pg = __privateGet2(this, _hPages)[layer];\n  const lay = pg.getPage(hArg);\n  if (!(lay instanceof TxtLayer))\n    throw layer + \"\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  const tf = lay;\n  return tf;\n};\n_current = new WeakMap();\n_$current = new WeakSet();\n$current_fn = function(hArg) {\n  const { layer } = hArg;\n  if (!layer)\n    throw \"[current] layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  __privateSet2(this, _pgTxtlay, __privateGet2(this, _hPages)[layer]);\n  if (!(__privateGet2(this, _pgTxtlay).getPage(hArg) instanceof TxtLayer))\n    throw `${layer}\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  this.recText(\"\", true);\n  __privateSet2(this, _curTxtlay, layer);\n  this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", layer);\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name) => {\n    const pg = __privateGet2(this, _hPages)[name];\n    if (!(pg.fore instanceof TxtLayer))\n      return;\n    pg.fore.isCur = pg.back.isCur = name === layer;\n  });\n  return false;\n};\n_pgTxtlay = new WeakMap();\n_chkTxtLay = new WeakMap();\n_argChk_layer = new WeakSet();\nargChk_layer_fn = function(hash2, def = \"\") {\n  var _a3;\n  const v2 = (_a3 = hash2.layer) != null ? _a3 : def;\n  if (v2.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (!(v2 in __privateGet2(this, _hPages)))\n    throw \"\\u5C5E\\u6027 layer\\u3010\" + v2 + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return hash2.layer = v2;\n};\n_oLastPage = new WeakMap();\n_aTxtLog = new WeakMap();\n_clear_text = new WeakSet();\nclear_text_fn = function(hArg) {\n  const tf = __privateGet2(this, _getTxtLayer).call(this, hArg);\n  if (hArg.layer === __privateGet2(this, _curTxtlay) && hArg.page === \"fore\")\n    this.recText(\"\", true);\n  tf.clearText();\n  return false;\n};\n_endlink = new WeakSet();\nendlink_fn = function(hArg) {\n  __privateGet2(this, _cmdTxt).call(this, \"endlink\\uFF5C\", __privateGet2(this, _getTxtLayer).call(this, hArg));\n  return false;\n};\n_er = new WeakSet();\ner_fn = function(hArg) {\n  if (argChk_Boolean(hArg, \"rec_page_break\", true))\n    this.recText(\"\", true);\n  if (__privateGet2(this, _pgTxtlay)) {\n    __privateGet2(this, _pgTxtlay).fore.clearLay(hArg);\n    __privateGet2(this, _pgTxtlay).back.clearLay(hArg);\n  }\n  return false;\n};\n_graph = new WeakSet();\ngraph_fn = function(hArg) {\n  if (!hArg.pic)\n    throw \"[graph] pic\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  hArg.text = \"\\uFF5C\\u3000\\u300Agrp\\uFF5C\" + JSON.stringify(hArg) + \"\\u300B\";\n  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);\n};\n_link = new WeakSet();\nlink_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  (_a3 = hArg.style) != null ? _a3 : hArg.style = \"background-color: rgba(255,0,0,0.5);\";\n  (_b3 = hArg.style_hover) != null ? _b3 : hArg.style_hover = \"background-color: rgba(255,0,0,0.9);\";\n  (_c3 = hArg.style_clicked) != null ? _c3 : hArg.style_clicked = hArg.style;\n  __privateGet2(this, _cmdTxt).call(this, \"link\\uFF5C\" + JSON.stringify(hArg), __privateGet2(this, _getTxtLayer).call(this, hArg));\n  return false;\n};\n_r = new WeakSet();\nr_fn = function(hArg) {\n  hArg.text = \"\\n\";\n  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);\n};\n_rec_r = new WeakSet();\nrec_r_fn = function() {\n  this.recText(\"\\n\");\n  return false;\n};\n_rec_ch = new WeakSet();\nrec_ch_fn = function(hArg) {\n  var _a3;\n  __privateSet2(this, _oLastPage, hArg);\n  this.recText((_a3 = hArg.text) != null ? _a3 : \"\");\n  return false;\n};\n_reset_rec = new WeakSet();\nreset_rec_fn = function(hArg) {\n  var _a3;\n  __privateSet2(this, _aTxtLog, []);\n  __privateSet2(this, _oLastPage, { text: (_a3 = hArg.text) != null ? _a3 : \"\" });\n  this.val.setVal_Nochk(\"save\", \"const.sn.sLog\", hArg.text ? `[{text:\"${hArg.text}\"}]` : \"[]\");\n  return false;\n};\n_ruby2 = new WeakSet();\nruby2_fn = function(hArg) {\n  const { t, r: r2 } = hArg;\n  if (!t)\n    throw \"[ruby2] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!r2)\n    throw \"[ruby2] r\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  hArg.text = \"\\uFF5C\" + t + \"\\u300A\" + r2 + \"\\u300B\";\n  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);\n};\n_span = new WeakSet();\nspan_fn = function(hArg) {\n  __privateGet2(this, _cmdTxt).call(this, \"span\\uFF5C\" + JSON.stringify(hArg), __privateGet2(this, _getTxtLayer).call(this, hArg));\n  return false;\n};\n_tcy = new WeakSet();\ntcy_fn = function(hArg) {\n  var _a3;\n  if (!hArg.t)\n    throw \"[tcy] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  hArg.text = \"\\uFF5C\\u3000\\u300Atcy\\uFF5C\" + hArg.t + \"\\uFF5C\" + ((_a3 = hArg.r) != null ? _a3 : \"\") + \"\\u300B\";\n  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);\n};\n_dump_lay = new WeakSet();\ndump_lay_fn = function(hArg) {\n  console.group(\"\\u{1F95F} [dump_lay]\");\n  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((name) => {\n    const pg = __privateGet2(this, _hPages)[name];\n    try {\n      console.info(`%c${pg.fore.name.slice(0, -7)} %o`, `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`, JSON.parse(`{\"back\":{${pg.back.dump()}}, \"fore\":{${pg.fore.dump()}}}`));\n    } catch (error) {\n      console.error(`dump_lay err:%o`, error);\n      console.error(`   back:${pg.back.dump()}`);\n      console.error(`   fore:${pg.fore.dump()}`);\n    }\n  });\n  console.groupEnd();\n  return false;\n};\n_enable_event = new WeakSet();\nenable_event_fn = function(hArg) {\n  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg, __privateGet2(this, _curTxtlay));\n  const v2 = argChk_Boolean(hArg, \"enabled\", true);\n  __privateGet2(this, _getTxtLayer).call(this, hArg).enabled = v2;\n  this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + layer + \".enabled\", v2);\n  return false;\n};\n_button = new WeakSet();\nbutton_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  Pages.argChk_page(hArg, \"back\");\n  (_a3 = hArg.clicksebuf) != null ? _a3 : hArg.clicksebuf = \"SYS\";\n  (_b3 = hArg.entersebuf) != null ? _b3 : hArg.entersebuf = \"SYS\";\n  (_c3 = hArg.leavesebuf) != null ? _c3 : hArg.leavesebuf = \"SYS\";\n  if (!hArg.fn)\n    hArg.fn = this.scrItr.scriptFn;\n  __privateGet2(this, _getTxtLayer).call(this, hArg).addButton(hArg);\n  this.scrItr.recodeDesign(hArg);\n  return false;\n};\n__privateAdd2(LayerMng, _msecChWait, 10);\nclass FocusMng {\n  constructor() {\n    __privateAdd2(this, _radio_next);\n    __privateAdd2(this, _allOff);\n    __privateAdd2(this, _aBtn, []);\n    __privateAdd2(this, _idx, -1);\n    __privateAdd2(this, _logFocus, CmnLib.debugLog ? (i2) => console.log(`\\u{1F47E} <FocusMng idx:${i2} btn:%o`, __privateGet2(this, _aBtn)[i2].btn) : () => {\n    });\n  }\n  destroy() {\n    __privateSet2(this, _aBtn, []);\n    __privateSet2(this, _idx, -1);\n  }\n  add(cmp, on2, off) {\n    var _a3;\n    if (__privateGet2(this, _aBtn).findIndex((b2) => b2.btn === cmp) >= 0)\n      return;\n    if (cmp instanceof Container) {\n      cmp.on(\"pointerdown\", () => {\n        for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {\n          const b2 = __privateGet2(this, _aBtn)[i2];\n          if (b2.btn === cmp) {\n            __privateSet2(this, _idx, i2);\n            return;\n          }\n        }\n        __privateSet2(this, _idx, -1);\n      });\n      __privateGet2(this, _aBtn).push({ btn: cmp, on: on2, off });\n      return;\n    }\n    cmp.addEventListener(\"focus\", () => {\n      for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {\n        const b2 = __privateGet2(this, _aBtn)[i2];\n        if (b2.btn === cmp) {\n          __privateSet2(this, _idx, i2);\n          return;\n        }\n      }\n      __privateSet2(this, _idx, -1);\n    });\n    let fnc = (_2) => {\n    };\n    let fnc4EnterSwitch = cmp.localName === \"button\" || cmp.localName === \"a\" ? (e) => !e.isTrusted && e.key === \"Enter\" : (e) => e.key === \"Enter\";\n    const inp = cmp;\n    switch ((_a3 = inp.type) != null ? _a3 : \"\") {\n      case \"checkbox\":\n        fnc = () => inp.checked = !inp.checked;\n        break;\n      case \"\":\n        if (cmp.querySelectorAll(\"input[type]\").length > 0) {\n          fnc = (e) => __privateMethod2(this, _radio_next, radio_next_fn).call(this, cmp, e.key);\n          fnc4EnterSwitch = () => false;\n        }\n        break;\n      case \"range\":\n        fnc = (e) => {\n          if (e.isTrusted)\n            return;\n          if (e.key === \"ArrowUp\")\n            inp.stepUp();\n          else\n            inp.stepDown();\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        fnc = (e) => {\n          var _a4;\n          if (e.isTrusted)\n            return;\n          let cur = ((_a4 = inp.selectionStart) != null ? _a4 : 0) + (e.key === \"ArrowUp\" ? -1 : 1);\n          if (cur < 0)\n            cur = 0;\n          inp.setSelectionRange(cur, cur);\n        };\n        break;\n    }\n    cmp.addEventListener(\"keydown\", (e) => {\n      if (e.key !== \"ArrowUp\" && e.key !== \"ArrowDown\" && e.key !== \"Enter\")\n        return;\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n      if (fnc4EnterSwitch(e)) {\n        cmp.dispatchEvent(new MouseEvent(\"click\"));\n        return;\n      }\n      fnc(e);\n    }, { passive: true });\n    if (!cmp.hasAttribute(\"tabindex\"))\n      cmp.tabIndex = 0;\n    __privateGet2(this, _aBtn).push({ btn: cmp, on: on2, off });\n  }\n  remove(cmp) {\n    const idx = __privateGet2(this, _aBtn).findIndex((b2) => b2.btn === cmp);\n    if (idx < 0)\n      return;\n    __privateGet2(this, _aBtn).splice(idx, 1);\n    if (__privateGet2(this, _aBtn).length === 0)\n      __privateSet2(this, _idx, -1);\n    else if (idx <= __privateGet2(this, _idx))\n      --__privateWrapper2(this, _idx)._;\n  }\n  isFocus(cmp) {\n    if (__privateGet2(this, _idx) < 0)\n      return false;\n    return __privateGet2(this, _aBtn)[__privateGet2(this, _idx)].btn === cmp;\n  }\n  prev() {\n    __privateMethod2(this, _allOff, allOff_fn).call(this);\n    const len = __privateGet2(this, _aBtn).length;\n    if (len === 0)\n      return;\n    if (--__privateWrapper2(this, _idx)._ < 0)\n      __privateSet2(this, _idx, len - 1);\n    for (let i2 = len; i2 >= 1; --i2) {\n      const j2 = (__privateGet2(this, _idx) + i2) % len;\n      if (__privateGet2(this, _aBtn)[j2].on()) {\n        __privateSet2(this, _idx, j2);\n        __privateGet2(this, _logFocus).call(this, j2);\n        return;\n      }\n    }\n    __privateSet2(this, _idx, -1);\n  }\n  next() {\n    __privateMethod2(this, _allOff, allOff_fn).call(this);\n    const len = __privateGet2(this, _aBtn).length;\n    if (len === 0)\n      return;\n    if (++__privateWrapper2(this, _idx)._ >= len)\n      __privateSet2(this, _idx, 0);\n    for (let i2 = 0; i2 < len; ++i2) {\n      const j2 = (__privateGet2(this, _idx) + i2) % len;\n      if (__privateGet2(this, _aBtn)[j2].on()) {\n        __privateSet2(this, _idx, j2);\n        __privateGet2(this, _logFocus).call(this, j2);\n        return;\n      }\n    }\n    __privateSet2(this, _idx, -1);\n  }\n  getFocus() {\n    if (__privateGet2(this, _idx) < 0)\n      return void 0;\n    __privateMethod2(this, _allOff, allOff_fn).call(this);\n    if (__privateGet2(this, _idx) >= __privateGet2(this, _aBtn).length)\n      __privateSet2(this, _idx, 0);\n    const b2 = __privateGet2(this, _aBtn)[__privateGet2(this, _idx)];\n    return b2.on() ? b2.btn : void 0;\n  }\n  blur() {\n    __privateMethod2(this, _allOff, allOff_fn).call(this);\n    __privateSet2(this, _idx, -1);\n    globalThis.focus();\n  }\n}\n_aBtn = new WeakMap();\n_idx = new WeakMap();\n_radio_next = new WeakSet();\nradio_next_fn = function(elm, key) {\n  const op = elm.querySelectorAll(\"input[type]\");\n  const len = op.length;\n  for (let i2 = 0; i2 < len; ++i2) {\n    if (!op[i2].checked)\n      continue;\n    op[(i2 + len + (key === \"ArrowUp\" ? -1 : 1)) % len].checked = true;\n    break;\n  }\n};\n_logFocus = new WeakMap();\n_allOff = new WeakSet();\nallOff_fn = function() {\n  for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {\n    const b2 = __privateGet2(this, _aBtn)[i2];\n    if (!(b2.btn instanceof Container) || b2.btn.parent)\n      b2.off();\n    else\n      __privateGet2(this, _aBtn).splice(i2, 1);\n  }\n};\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [top, bottom, right, left];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar beforeRead = \"beforeRead\";\nvar read$6 = \"read\";\nvar afterRead = \"afterRead\";\nvar beforeMain = \"beforeMain\";\nvar main$1 = \"main\";\nvar afterMain = \"afterMain\";\nvar beforeWrite = \"beforeWrite\";\nvar write$6 = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];\nfunction getNodeName(element) {\n  return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (node.toString() !== \"[object Window]\") {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function(name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name];\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function(name2) {\n      var value2 = attributes[name2];\n      if (value2 === false) {\n        element.removeAttribute(name2);\n      } else {\n        element.setAttribute(name2, value2 === true ? \"\" : value2);\n      }\n    });\n  });\n}\nfunction effect$2(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return function() {\n    Object.keys(state.elements).forEach(function(name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n      var style = styleProperties.reduce(function(style2, property) {\n        style2[property] = \"\";\n        return style2;\n      }, {});\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function(attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n}\nvar applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: true,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  var rect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n  if (isHTMLElement(element) && includeScale) {\n    var offsetHeight = element.offsetHeight;\n    var offsetWidth = element.offsetWidth;\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element);\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width,\n    height\n  };\n}\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode();\n  if (parent.contains(child)) {\n    return true;\n  } else if (rootNode && isShadowRoot(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent.isSameNode(next)) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(element)) >= 0;\n}\nfunction getDocumentElement(element) {\n  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getParentNode(element) {\n  if (getNodeName(element) === \"html\") {\n    return element;\n  }\n  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);\n}\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\") {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1;\n  var isIE = navigator.userAgent.indexOf(\"Trident\") !== -1;\n  if (isIE && isHTMLElement(element)) {\n    var elementCss = getComputedStyle$1(element);\n    if (elementCss.position === \"fixed\") {\n      return null;\n    }\n  }\n  var currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && [\"html\", \"body\"].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle$1(currentNode);\n    if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n}\nfunction getOffsetParent(element) {\n  var window2 = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle$1(offsetParent).position === \"static\")) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element) || window2;\n}\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value2, max$1) {\n  return max(min$1, min(value2, max$1));\n}\nfunction withinMaxClamp(min2, value2, max2) {\n  var v2 = within(min2, value2, max2);\n  return v2 > max2 ? max2 : v2;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value2, keys) {\n  return keys.reduce(function(hashMap, key) {\n    hashMap[key] = value2;\n    return hashMap;\n  }, {});\n}\nvar toPaddingObject = function toPaddingObject2(padding, state) {\n  padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n  var state = _ref.state, name = _ref.name, options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \"height\" : \"width\";\n  if (!arrowElement || !popperOffsets2) {\n    return;\n  }\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === \"y\" ? top : left;\n  var maxProp = axis === \"y\" ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2;\n  var min2 = paddingObject[minProp];\n  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset2 = within(min2, center, max2);\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n  var state = _ref2.state, options = _ref2.options;\n  var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n  if (arrowElement == null) {\n    return;\n  }\n  if (typeof arrowElement === \"string\") {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n  state.elements.arrow = arrowElement;\n}\nvar arrow$1 = {\n  name: \"arrow\",\n  enabled: true,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(placement) {\n  return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(_ref) {\n  var x2 = _ref.x, y2 = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x2 * dpr) / dpr || 0,\n    y: round(y2 * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;\n  var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n    x: x2,\n    y: y2\n  }) : {\n    x: x2,\n    y: y2\n  };\n  x2 = _ref3.x;\n  y2 = _ref3.y;\n  var hasX = offsets.hasOwnProperty(\"x\");\n  var hasY = offsets.hasOwnProperty(\"y\");\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper2);\n    var heightProp = \"clientHeight\";\n    var widthProp = \"clientWidth\";\n    if (offsetParent === getWindow(popper2)) {\n      offsetParent = getDocumentElement(popper2);\n      if (getComputedStyle$1(offsetParent).position !== \"static\" && position === \"absolute\") {\n        heightProp = \"scrollHeight\";\n        widthProp = \"scrollWidth\";\n      }\n    }\n    offsetParent = offsetParent;\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n      y2 -= offsetY - popperRect.height;\n      y2 *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n      x2 -= offsetX - popperRect.width;\n      x2 *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x2,\n    y: y2\n  }) : {\n    x: x2,\n    y: y2\n  };\n  x2 = _ref4.x;\n  y2 = _ref4.y;\n  if (gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x2 + \"px, \" + y2 + \"px)\" : \"translate3d(\" + x2 + \"px, \" + y2 + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x2 + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state, options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n    isFixed: state.options.strategy === \"fixed\"\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n      roundOffsets\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: \"absolute\",\n      adaptive: false,\n      roundOffsets\n    })));\n  }\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-placement\": state.placement\n  });\n}\nvar computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: true\n};\nfunction effect(_ref) {\n  var state = _ref.state, instance = _ref.instance, options = _ref.options;\n  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n  var window2 = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  if (scroll) {\n    scrollParents.forEach(function(scrollParent) {\n      scrollParent.addEventListener(\"scroll\", instance.update, passive);\n    });\n  }\n  if (resize) {\n    window2.addEventListener(\"resize\", instance.update, passive);\n  }\n  return function() {\n    if (scroll) {\n      scrollParents.forEach(function(scrollParent) {\n        scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n      });\n    }\n    if (resize) {\n      window2.removeEventListener(\"resize\", instance.update, passive);\n    }\n  };\n}\nvar eventListeners = {\n  name: \"eventListeners\",\n  enabled: true,\n  phase: \"write\",\n  fn: function fn() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function(matched) {\n    return hash$1[matched];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function(matched) {\n    return hash[matched];\n  });\n}\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft,\n    scrollTop\n  };\n}\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x2 = 0;\n  var y2 = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x2 = visualViewport.offsetLeft;\n      y2 = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x: x2 + getWindowScrollBarX(element),\n    y: y2\n  };\n}\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y2 = -winScroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === \"rtl\") {\n    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x: x2,\n    y: y2\n  };\n}\nfunction isScrollParent(element) {\n  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n  if ([\"html\", \"body\", \"#document\"].indexOf(getNodeName(node)) >= 0) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n  return getScrollParent(getParentNode(node));\n}\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n  if (list === void 0) {\n    list = [];\n  }\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\nfunction getClippingParents(element) {\n  var clippingParents2 = listScrollParents(getParentNode(element));\n  var canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n  return clippingParents2.filter(function(clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n  });\n}\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents2[0];\n  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\nfunction computeOffsets(_ref) {\n  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference2.x + reference2.width / 2 - element.width / 2;\n  var commonY = reference2.y + reference2.height / 2 - element.height / 2;\n  var offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference2.y - element.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference2.x - element.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n  return offsets;\n}\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets2 = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \"absolute\",\n    placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset;\n  if (elementContext === popper && offsetData) {\n    var offset2 = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function(key) {\n      var multiply3 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n      overflowOffsets[key] += offset2[axis] * multiply3;\n    });\n  }\n  return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n    return getVariation(placement2) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function(placement2) {\n    return allowedAutoPlacements.indexOf(placement2) >= 0;\n  });\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n  }\n  var overflows = allowedPlacements.reduce(function(acc, placement2) {\n    acc[placement2] = detectOverflow(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement2)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function(a2, b2) {\n    return overflows[a2] - overflows[b2];\n  });\n}\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding,\n      flipVariations,\n      allowedAutoPlacements\n    }) : placement2);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = /* @__PURE__ */ new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements2[0];\n  for (var i2 = 0; i2 < placements2.length; i2++) {\n    var placement = placements2[i2];\n    var _basePlacement = getBasePlacement(placement);\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \"width\" : \"height\";\n    var overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(function(check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    var numberOfChecks = flipVariations ? 3 : 1;\n    var _loop = function _loop2(_i2) {\n      var fittingPlacement = placements2.find(function(placement2) {\n        var checks2 = checksMap.get(placement2);\n        if (checks2) {\n          return checks2.slice(0, _i2).every(function(check) {\n            return check;\n          });\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n      if (_ret === \"break\")\n        break;\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\nvar flip$1 = {\n  name: \"flip\",\n  enabled: true,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: false\n  }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function(side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state, name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: \"reference\"\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-reference-hidden\": isReferenceHidden,\n    \"data-popper-escaped\": hasPopperEscaped\n  });\n}\nvar hide$1 = {\n  name: \"hide\",\n  enabled: true,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset2) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  var _ref = typeof offset2 === \"function\" ? offset2(Object.assign({}, rects, {\n    placement\n  })) : offset2, skidding = _ref[0], distance = _ref[1];\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset(_ref2) {\n  var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function(acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x2;\n    state.modifiersData.popperOffsets.y += y2;\n  }\n  state.modifiersData[name] = data;\n}\nvar offset$1 = {\n  name: \"offset\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(_ref) {\n  var state = _ref.state, name = _ref.name;\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: \"absolute\",\n    placement: state.placement\n  });\n}\nvar popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: true,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets2) {\n    return;\n  }\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n    var mainSide = mainAxis === \"y\" ? top : left;\n    var altSide = mainAxis === \"y\" ? bottom : right;\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    var offset2 = popperOffsets2[mainAxis];\n    var min$1 = offset2 + overflow[mainSide];\n    var max$1 = offset2 - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide];\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset2 = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset2 + maxOffset2 - offsetModifierValue;\n    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);\n    popperOffsets2[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset2;\n  }\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n    var _mainSide = mainAxis === \"x\" ? top : left;\n    var _altSide = mainAxis === \"x\" ? bottom : right;\n    var _offset = popperOffsets2[altAxis];\n    var _len = altAxis === \"y\" ? \"height\" : \"width\";\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n    popperOffsets2[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n}\nvar preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: true,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n}\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction order(modifiers) {\n  var map2 = /* @__PURE__ */ new Map();\n  var visited = /* @__PURE__ */ new Set();\n  var result = [];\n  modifiers.forEach(function(modifier) {\n    map2.set(modifier.name, modifier);\n  });\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function(dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map2.get(dep);\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n  modifiers.forEach(function(modifier) {\n    if (!visited.has(modifier.name)) {\n      sort(modifier);\n    }\n  });\n  return result;\n}\nfunction orderModifiers(modifiers) {\n  var orderedModifiers = order(modifiers);\n  return modifierPhases.reduce(function(acc, phase) {\n    return acc.concat(orderedModifiers.filter(function(modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\nfunction debounce(fn2) {\n  var pending;\n  return function() {\n    if (!pending) {\n      pending = new Promise(function(resolve2) {\n        Promise.resolve().then(function() {\n          pending = void 0;\n          resolve2(fn2());\n        });\n      });\n    }\n    return pending;\n  };\n}\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function(merged2, current) {\n    var existing = merged2[current.name];\n    merged2[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged2;\n  }, {});\n  return Object.keys(merged).map(function(key) {\n    return merged[key];\n  });\n}\nvar DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function(element) {\n    return !(element && typeof element.getBoundingClientRect === \"function\");\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper2(reference2, popper2, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference2,\n        popper: popper2\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options2 = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options2);\n        state.scrollParents = {\n          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n          popper: listScrollParents(popper2)\n        };\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));\n        state.orderedModifiers = orderedModifiers.filter(function(m2) {\n          return m2.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n        if (!areValidElements(reference3, popper3)) {\n          return;\n        }\n        state.rects = {\n          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === \"fixed\"),\n          popper: getLayoutRect(popper3)\n        };\n        state.reset = false;\n        state.placement = state.options.placement;\n        state.orderedModifiers.forEach(function(modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n          if (typeof fn2 === \"function\") {\n            state = fn2({\n              state,\n              options: _options,\n              name,\n              instance\n            }) || state;\n          }\n        }\n      },\n      update: debounce(function() {\n        return new Promise(function(resolve2) {\n          instance.forceUpdate();\n          resolve2(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference2, popper2)) {\n      return instance;\n    }\n    instance.setOptions(options).then(function(state2) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state2);\n      }\n    });\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function(_ref3) {\n        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;\n        if (typeof effect2 === \"function\") {\n          var cleanupFn = effect2({\n            state,\n            name,\n            instance,\n            options: options2\n          });\n          var noopFn = function noopFn2() {\n          };\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function(fn2) {\n        return fn2();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\");\nclass EventMng {\n  constructor(cfg, hTag, appPixi, main2, layMng, val, sndMng, scrItr, sys) {\n    __privateAdd2(this, _ev_keydown);\n    __privateAdd2(this, _ev_contextmenu);\n    __privateAdd2(this, _ev_wheel);\n    __privateAdd2(this, _ev_wheel_waitstop);\n    __privateAdd2(this, _waitEventBase);\n    __privateAdd2(this, _dispHint);\n    __privateAdd2(this, _clear_event);\n    __privateAdd2(this, _clear_eventer);\n    __privateAdd2(this, _event);\n    __privateAdd2(this, _canFocus);\n    __privateAdd2(this, _getHtmlElmList);\n    __privateAdd2(this, _l);\n    __privateAdd2(this, _p);\n    __privateAdd2(this, _set_cancel_skip);\n    __privateAdd2(this, _set_focus);\n    __privateAdd2(this, _wait);\n    __privateAdd2(this, _waitclick);\n    __privateAdd2(this, _elc2, new EventListenerCtn());\n    __privateAdd2(this, _gamepad, new GamepadListener({\n      analog: false,\n      deadZone: 0.3\n    }));\n    __privateAdd2(this, _fcs, new FocusMng());\n    __privateAdd2(this, _resvFlameEvent4Wheel, (_win) => {\n    });\n    __privateAdd2(this, _wheeling, false);\n    __privateAdd2(this, _extend_wheel, false);\n    __privateAdd2(this, _hLocalEvt2Fnc, {});\n    __privateAdd2(this, _hGlobalEvt2Fnc, {});\n    __privateAdd2(this, _isDbgBreak, false);\n    __privateAdd2(this, _isWait, false);\n    __privateAdd2(this, _getEvt2Fnc, (key) => {\n      var _a3;\n      return (_a3 = __privateGet2(this, _hLocalEvt2Fnc)[key]) != null ? _a3 : __privateGet2(this, _hGlobalEvt2Fnc)[key];\n    });\n    __privateAdd2(this, _firstWait, () => {\n      __privateSet2(this, _firstWait, () => {\n      });\n      this.scrItr.firstWait();\n    });\n    __privateAdd2(this, _elmV, {\n      getBoundingClientRect: (x2 = 0, y2 = 0) => DOMRect.fromRect({ x: x2, y: y2, width: 0, height: 0 })\n    });\n    __privateAdd2(this, _elmHint, void 0);\n    __privateAdd2(this, _spanHint, void 0);\n    __privateAdd2(this, _popper, void 0);\n    __privateAdd2(this, _oHintOpt, {\n      placement: \"bottom\",\n      modifiers: [{ fallbackPlacements: [\"top\", \"bottom\"] }]\n    });\n    __privateAdd2(this, _procWheel4wle, (_elc3, _fnc) => {\n    });\n    __privateAdd2(this, _elcWLE, new EventListenerCtn());\n    __privateAdd2(this, _goTxt, () => this.layMng.goTxt());\n    __privateAdd2(this, _stopSkip, () => false);\n    __privateAdd2(this, _cancelWait, () => {\n    });\n    __privateAdd2(this, _hDownKeys, {\n      \"Alt\": 0,\n      \"Meta\": 0,\n      \"Control\": 0,\n      \"ArrowDown\": 0,\n      \"End\": 0,\n      \"Enter\": 0,\n      \"Escape\": 0,\n      \" \": 0,\n      \"GoBack\": 0\n    });\n    var _a3;\n    this.cfg = cfg;\n    this.hTag = hTag;\n    this.appPixi = appPixi;\n    this.main = main2;\n    this.layMng = layMng;\n    this.val = val;\n    this.sndMng = sndMng;\n    this.scrItr = scrItr;\n    this.sys = sys;\n    hTag.clear_event = (o) => __privateMethod2(this, _clear_event, clear_event_fn).call(this, o);\n    hTag.event = (o) => __privateMethod2(this, _event, event_fn).call(this, o);\n    hTag.l = (o) => __privateMethod2(this, _l, l_fn).call(this, o);\n    hTag.p = (o) => __privateMethod2(this, _p, p_fn).call(this, o);\n    hTag.s = () => {\n      this.scrItr.recodePage();\n      __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => {\n      }, false, true);\n      return true;\n    };\n    hTag.set_cancel_skip = () => __privateMethod2(this, _set_cancel_skip, set_cancel_skip_fn).call(this);\n    hTag.set_focus = (o) => __privateMethod2(this, _set_focus, set_focus_fn).call(this, o);\n    hTag.wait = (o) => __privateMethod2(this, _wait, wait_fn).call(this, o);\n    hTag.waitclick = () => __privateMethod2(this, _waitclick, waitclick_fn).call(this);\n    sndMng.setEvtMng(this);\n    scrItr.setOtherObj(this, layMng);\n    TxtLayer.setEvtMng(main2, this, sys);\n    layMng.setEvtMng(this);\n    sys.setFire((KEY, e) => this.fire(KEY, e));\n    if (CmnLib.isDbg) {\n      const hHook = {\n        pause: () => {\n          __privateSet2(this, _isDbgBreak, true);\n          if (!__privateGet2(this, _isWait))\n            return;\n          const hArg = {};\n          this.scrItr.recodeDesign(hArg);\n          this.sys.callHook(\"_enterDesign\", hArg);\n          this.sys.send2Dbg(\"_enterDesign\", hArg);\n        },\n        stopOnBreakpoint: () => __privateSet2(this, _isDbgBreak, true),\n        stopOnDataBreakpoint: () => __privateSet2(this, _isDbgBreak, true),\n        continue: () => __privateSet2(this, _isDbgBreak, false),\n        disconnect: () => __privateSet2(this, _isDbgBreak, false)\n      };\n      hHook.attach = hHook.stopOnEntry = hHook.stopOnStep = hHook.stopOnStepIn = hHook.stopOnStepOut = hHook.stopOnBackstep = hHook.pause;\n      sys.addHook((type) => {\n        var _a4;\n        return (_a4 = hHook[type]) == null ? void 0 : _a4.call(hHook);\n      });\n    }\n    addStyle(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`);\n    (_a3 = appPixi.view.parentElement) == null ? void 0 : _a3.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`);\n    __privateSet2(this, _elmHint, document.querySelector(\".sn_hint\"));\n    __privateSet2(this, _spanHint, __privateGet2(this, _elmHint).querySelector(\"span\"));\n    __privateSet2(this, _popper, createPopper(__privateGet2(this, _elmV), __privateGet2(this, _elmHint)));\n    __privateGet2(this, _elmHint).hidden = true;\n    appPixi.stage.interactive = true;\n    if (CmnLib.isMobile)\n      appPixi.stage.on(\"pointerdown\", (e) => this.fire(\"click\", e));\n    else\n      __privateGet2(this, _elc2).add(appPixi.stage, \"pointerdown\", (e) => {\n        switch (e.data.button) {\n          case 0:\n            this.fire(\"click\", e);\n            break;\n          case 1:\n            this.fire(\"middleclick\", e);\n            break;\n        }\n      });\n    __privateGet2(this, _elc2).add(window, \"keydown\", (e) => __privateMethod2(this, _ev_keydown, ev_keydown_fn).call(this, e));\n    __privateGet2(this, _elc2).add(appPixi.view, \"contextmenu\", (e) => __privateMethod2(this, _ev_contextmenu, ev_contextmenu_fn).call(this, e));\n    const fncMql = (mq) => {\n      CmnLib.isDarkMode = mq.matches;\n      val.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", CmnLib.isDarkMode);\n    };\n    const mql = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    fncMql(mql);\n    mql.addEventListener(\"change\", (e) => {\n      fncMql(e);\n      this.fire(\"sn:chgDarkMode\", e);\n    });\n    if (\"WheelEvent\" in window) {\n      __privateGet2(this, _elc2).add(appPixi.view, \"wheel\", (e) => __privateMethod2(this, _ev_wheel, ev_wheel_fn).call(this, e), { passive: true });\n      __privateSet2(this, _resvFlameEvent4Wheel, (win) => win.addEventListener(\"wheel\", (e) => __privateMethod2(this, _ev_wheel, ev_wheel_fn).call(this, e), { passive: true }));\n      __privateSet2(this, _procWheel4wle, (elc, fnc) => elc.add(appPixi.view, \"wheel\", (e) => {\n        if (e[\"isComposing\"])\n          return;\n        if (e.deltaY <= 0)\n          return;\n        e.stopPropagation();\n        fnc();\n      }));\n    }\n    if (CmnLib.debugLog) {\n      __privateGet2(this, _gamepad).on(\"gamepad:connected\", (e) => console.log(`\\u{1F47A}<'gamepad:connected' index:${e.detail.index} id:${e.detail.gamepad.id}`));\n      __privateGet2(this, _gamepad).on(\"gamepad:disconnected\", (e) => console.log(`\\u{1F47A}<'gamepad:disconnected' index:${e.detail.index} id:${e.detail.gamepad.id}`));\n    }\n    const aStick = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      \"\",\n      \"ArrowDown\",\n      \"\"\n    ];\n    const stick_xy = [0, 0];\n    __privateGet2(this, _gamepad).on(\"gamepad:axis\", (e) => {\n      if (!document.hasFocus() || e.detail.stick !== 0)\n        return;\n      stick_xy[e.detail.axis] = e.detail.value;\n      const s2 = (stick_xy[1] + 1) * 3 + (stick_xy[0] + 1);\n      const s22 = aStick[s2];\n      if (!s22)\n        return;\n      const cmp = __privateGet2(this, _fcs).getFocus();\n      (!cmp || cmp instanceof Container ? globalThis : cmp).dispatchEvent(new KeyboardEvent(\"keydown\", { key: s22, bubbles: true }));\n      if (!cmp || cmp instanceof Container)\n        return;\n      if (cmp.getAttribute(\"type\") === \"range\")\n        cmp.dispatchEvent(new InputEvent(\"input\", { bubbles: true }));\n    });\n    __privateGet2(this, _gamepad).on(\"gamepad:button\", (e) => {\n      if (!document.hasFocus() || e.detail.value === 0)\n        return;\n      if (e.detail.button % 2 === 0) {\n        const cmp = __privateGet2(this, _fcs).getFocus();\n        (!cmp || cmp instanceof Container ? globalThis : cmp).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: true }));\n      } else\n        appPixi.view.dispatchEvent(new Event(\"contextmenu\"));\n    });\n    __privateGet2(this, _gamepad).start();\n    __privateGet2(this, _elc2).add(window, \"keyup\", (e) => {\n      if (e[\"isComposing\"])\n        return;\n      if (e.key in __privateGet2(this, _hDownKeys))\n        __privateGet2(this, _hDownKeys)[e.key] = 0;\n    });\n    val.defTmp(\"const.sn.key.alternate\", () => __privateGet2(this, _hDownKeys)[\"Alt\"] > 0);\n    val.defTmp(\"const.sn.key.command\", () => __privateGet2(this, _hDownKeys)[\"Meta\"] > 0);\n    val.defTmp(\"const.sn.key.control\", () => __privateGet2(this, _hDownKeys)[\"Control\"] > 0);\n    val.defTmp(\"const.sn.key.end\", () => __privateGet2(this, _hDownKeys)[\"End\"] > 0);\n    val.defTmp(\"const.sn.key.escape\", () => __privateGet2(this, _hDownKeys)[\"Escape\"] > 0);\n    val.defTmp(\"const.sn.key.back\", () => __privateGet2(this, _hDownKeys)[\"GoBack\"] > 0);\n  }\n  resvFlameEvent(win) {\n    win.addEventListener(\"keydown\", (e) => __privateMethod2(this, _ev_keydown, ev_keydown_fn).call(this, e));\n    win.addEventListener(\"contextmenu\", (e) => __privateMethod2(this, _ev_contextmenu, ev_contextmenu_fn).call(this, e));\n    __privateGet2(this, _resvFlameEvent4Wheel).call(this, win);\n  }\n  destroy() {\n    __privateGet2(this, _fcs).destroy();\n    __privateGet2(this, _elc2).clear();\n  }\n  fire(KEY, e) {\n    var _a3;\n    if (__privateGet2(this, _stopSkip).call(this) || !__privateGet2(this, _isWait) || __privateGet2(this, _isDbgBreak))\n      return;\n    const key = KEY.toLowerCase();\n    if (CmnLib.debugLog)\n      console.log(`\\u{1F47A} fire<(key:\\`${key}\\` type:${e.type} e:%o)`, __spreadValues({}, e));\n    if (key === \"enter\") {\n      const em = __privateGet2(this, _fcs).getFocus();\n      if (em instanceof Container) {\n        em.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const ke = __privateGet2(this, _getEvt2Fnc).call(this, key);\n    if (!ke) {\n      if (key.slice(0, 5) === \"swipe\")\n        globalThis.scrollBy(-e.deltaX, -e.deltaY);\n      return;\n    }\n    if (key.slice(-5) !== \"wheel\")\n      (_a3 = e.preventDefault) == null ? void 0 : _a3.call(e);\n    e.stopPropagation();\n    if (key.slice(0, 4) !== \"dom=\")\n      this.layMng.clickTxtLay();\n    __privateSet2(this, _isWait, false);\n    ke(e);\n    __privateGet2(this, _elmHint).hidden = true;\n  }\n  popLocalEvts() {\n    const ret = __privateGet2(this, _hLocalEvt2Fnc);\n    __privateSet2(this, _hLocalEvt2Fnc, {});\n    return ret;\n  }\n  pushLocalEvts(h2) {\n    __privateSet2(this, _hLocalEvt2Fnc, h2);\n  }\n  waitEvent(onFinish, canskip = true, global2 = false) {\n    if (canskip && global2)\n      throw `canskip\\u3068global\\u3092\\u540C\\u6642\\u306Btrue\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093`;\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku) {\n        onFinish();\n        return false;\n      }\n      __privateGet2(this, _stopSkip).call(this);\n    }\n    __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, onFinish, canskip, global2);\n    return true;\n  }\n  unButton(ctnBtn) {\n    __privateGet2(this, _fcs).remove(ctnBtn);\n  }\n  button(hArg, ctnBtn, normal, hover, clicked) {\n    var _a3, _b3;\n    if (!hArg.fn && !hArg.label)\n      this.main.errScript(\"fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\");\n    ctnBtn.interactive = ctnBtn.buttonMode = true;\n    const key = (_b3 = (_a3 = hArg.key) == null ? void 0 : _a3.toLowerCase()) != null ? _b3 : \" \";\n    if (!hArg.fn)\n      hArg.fn = this.scrItr.scriptFn;\n    const glb = argChk_Boolean(hArg, \"global\", false);\n    if (glb)\n      __privateGet2(this, _hGlobalEvt2Fnc)[key] = () => this.main.resumeByJumpOrCall(hArg);\n    else\n      __privateGet2(this, _hLocalEvt2Fnc)[key] = () => this.main.resumeByJumpOrCall(hArg);\n    const ee = ctnBtn;\n    ee.on(\"pointerdown\", (e) => this.fire(key, e));\n    const onHint = hArg.hint ? () => __privateMethod2(this, _dispHint, dispHint_fn).call(this, hArg, ctnBtn) : () => {\n    };\n    const nr = () => {\n      normal();\n      __privateGet2(this, _elmHint).hidden = true;\n    };\n    const hv = () => {\n      onHint();\n      return hover();\n    };\n    ee.on(\"pointerover\", hv);\n    ee.on(\"pointerout\", () => {\n      if (__privateGet2(this, _fcs).isFocus(ctnBtn))\n        hv();\n      else\n        nr();\n    });\n    ee.on(\"pointerdown\", clicked);\n    ee.on(\"pointerup\", CmnLib.isMobile ? nr : () => {\n      if (__privateGet2(this, _fcs).isFocus(ctnBtn))\n        hv();\n      else\n        nr();\n    });\n    __privateGet2(this, _fcs).add(ctnBtn, hv, nr);\n    if (hArg.clickse) {\n      this.cfg.searchPath(hArg.clickse, Config.EXT_SOUND);\n      ee.on(\"pointerdown\", () => {\n        const o = { fn: hArg.clickse, join: false };\n        if (hArg.clicksebuf)\n          o.buf = hArg.clicksebuf;\n        this.hTag.playse(o);\n      });\n    }\n    if (hArg.enterse) {\n      this.cfg.searchPath(hArg.enterse, Config.EXT_SOUND);\n      ee.on(\"pointerover\", () => {\n        const o = { fn: hArg.enterse, join: false };\n        if (hArg.entersebuf)\n          o.buf = hArg.entersebuf;\n        this.hTag.playse(o);\n      });\n    }\n    if (hArg.leavese) {\n      this.cfg.searchPath(hArg.leavese, Config.EXT_SOUND);\n      ee.on(\"pointerout\", () => {\n        const o = { fn: hArg.leavese, join: false };\n        if (hArg.leavesebuf)\n          o.buf = hArg.leavesebuf;\n        this.hTag.playse(o);\n      });\n    }\n    if (hArg.onenter) {\n      const k = key + hArg.onenter.toLowerCase();\n      const o = { fn: hArg.fn, label: hArg.onenter, call: true, key: k };\n      if (glb)\n        __privateGet2(this, _hGlobalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);\n      else\n        __privateGet2(this, _hLocalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);\n      ee.on(\"pointerover\", (e) => this.fire(k, e));\n    }\n    if (hArg.onleave) {\n      const k = key + hArg.onleave.toLowerCase();\n      const o = { fn: hArg.fn, label: hArg.onleave, call: true, key: k };\n      if (glb)\n        __privateGet2(this, _hGlobalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);\n      else\n        __privateGet2(this, _hLocalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);\n      ee.on(\"pointerout\", (e) => this.fire(k, e));\n    }\n    this.sndMng.loadAheadSnd(hArg);\n  }\n  cvsResize() {\n    __privateGet2(this, _elmHint).hidden = true;\n  }\n  waitLimitedEvent(hArg, onFinish) {\n    __privateGet2(this, _goTxt).call(this);\n    this.val.saveKidoku();\n    const fnc = () => {\n      __privateGet2(this, _elcWLE).clear();\n      onFinish();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n        __privateGet2(this, _stopSkip).call(this);\n      else {\n        fnc();\n        return false;\n      }\n    }\n    if (!argChk_Boolean(hArg, \"canskip\", true))\n      return true;\n    __privateGet2(this, _elcWLE).add(window, \"pointerdown\", (e) => {\n      e.stopPropagation();\n      fnc();\n    });\n    __privateGet2(this, _elcWLE).add(window, \"keydown\", (e) => {\n      if (e[\"isComposing\"])\n        return;\n      e.stopPropagation();\n      fnc();\n    });\n    __privateGet2(this, _procWheel4wle).call(this, __privateGet2(this, _elcWLE), fnc);\n    return true;\n  }\n  isSkippingByKeyDown() {\n    if (this.scrItr.skip4page)\n      return true;\n    for (const k in __privateGet2(this, _hDownKeys))\n      if (__privateGet2(this, _hDownKeys)[k] === 2)\n        return true;\n    return false;\n  }\n}\n_elc2 = new WeakMap();\n_gamepad = new WeakMap();\n_fcs = new WeakMap();\n_resvFlameEvent4Wheel = new WeakMap();\n_ev_keydown = new WeakSet();\nev_keydown_fn = function(e) {\n  if (e[\"isComposing\"])\n    return;\n  if (e.key in __privateGet2(this, _hDownKeys))\n    __privateGet2(this, _hDownKeys)[e.key] = e.repeat ? 2 : 1;\n  const key = (e.altKey ? e.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (e.ctrlKey ? e.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (e.shiftKey ? e.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + e.key;\n  this.fire(key, e);\n};\n_ev_contextmenu = new WeakSet();\nev_contextmenu_fn = function(e) {\n  const key = (e.altKey ? e.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (e.ctrlKey ? e.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (e.shiftKey ? e.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(key, e);\n  e.preventDefault();\n};\n_ev_wheel = new WeakSet();\nev_wheel_fn = function(e) {\n  if (e[\"isComposing\"])\n    return;\n  if (__privateGet2(this, _wheeling)) {\n    __privateSet2(this, _extend_wheel, true);\n    return;\n  }\n  __privateSet2(this, _wheeling, true);\n  __privateMethod2(this, _ev_wheel_waitstop, ev_wheel_waitstop_fn).call(this);\n  const key = (e.altKey ? \"alt+\" : \"\") + (e.ctrlKey ? \"ctrl+\" : \"\") + (e.shiftKey ? \"shift+\" : \"\") + (e.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(key, e);\n};\n_wheeling = new WeakMap();\n_extend_wheel = new WeakMap();\n_ev_wheel_waitstop = new WeakSet();\nev_wheel_waitstop_fn = function() {\n  setTimeout(() => {\n    if (__privateGet2(this, _extend_wheel)) {\n      __privateSet2(this, _extend_wheel, false);\n      __privateMethod2(this, _ev_wheel_waitstop, ev_wheel_waitstop_fn).call(this);\n      return;\n    }\n    __privateSet2(this, _wheeling, false);\n  }, 250);\n};\n_hLocalEvt2Fnc = new WeakMap();\n_hGlobalEvt2Fnc = new WeakMap();\n_isDbgBreak = new WeakMap();\n_isWait = new WeakMap();\n_getEvt2Fnc = new WeakMap();\n_waitEventBase = new WeakSet();\nwaitEventBase_fn = function(onFinish, canskip = true, global2 = true) {\n  __privateGet2(this, _goTxt).call(this);\n  this.val.saveKidoku();\n  if (canskip) {\n    __privateGet2(this, _hLocalEvt2Fnc)[\"click\"] = __privateGet2(this, _hLocalEvt2Fnc)[\"enter\"] = __privateGet2(this, _hLocalEvt2Fnc)[\"arrowdown\"] = __privateGet2(this, _hLocalEvt2Fnc)[\"wheel.y>0\"] = onFinish;\n  } else {\n    delete __privateGet2(this, _hLocalEvt2Fnc)[\"click\"];\n    delete __privateGet2(this, _hLocalEvt2Fnc)[\"enter\"];\n    delete __privateGet2(this, _hLocalEvt2Fnc)[\"arrowdown\"];\n    delete __privateGet2(this, _hLocalEvt2Fnc)[\"wheel.y>0\"];\n  }\n  __privateSet2(this, _getEvt2Fnc, global2 ? (key) => {\n    var _a3;\n    return (_a3 = __privateGet2(this, _hLocalEvt2Fnc)[key]) != null ? _a3 : __privateGet2(this, _hGlobalEvt2Fnc)[key];\n  } : (key) => __privateGet2(this, _hLocalEvt2Fnc)[key]);\n  __privateSet2(this, _isWait, true);\n  __privateGet2(this, _firstWait).call(this);\n  if (CmnLib.debugLog) {\n    const o = /* @__PURE__ */ Object.create(null);\n    o.local = Object.keys(__privateGet2(this, _hLocalEvt2Fnc));\n    o.global = Object.keys(__privateGet2(this, _hGlobalEvt2Fnc));\n    console.log(`\\u{1F38D} wait event... %o`, o);\n  }\n};\n_firstWait = new WeakMap();\n_elmV = new WeakMap();\n_elmHint = new WeakMap();\n_spanHint = new WeakMap();\n_popper = new WeakMap();\n_oHintOpt = new WeakMap();\n_dispHint = new WeakSet();\ndispHint_fn = function(hArg, ctnBtn) {\n  var _a3, _b3;\n  const rctBtn = ctnBtn instanceof Button ? ctnBtn.getBtnBounds() : ctnBtn.getBounds();\n  const isLink = hArg[\":\\u30BF\\u30B0\\u540D\"] === \"link\";\n  if (!isLink) {\n    const cpp = ctnBtn.parent.parent;\n    rctBtn.x += cpp.x;\n    rctBtn.y += cpp.y;\n  }\n  if (!hArg.hint) {\n    __privateGet2(this, _elmHint).hidden = true;\n    return;\n  }\n  __privateGet2(this, _elmHint).style.cssText = `position:${__privateGet2(this, _elmHint).style.position}; transform:${__privateGet2(this, _elmHint).style.transform};` + ((_a3 = hArg.hint_style) != null ? _a3 : \"\");\n  __privateGet2(this, _spanHint).style.cssText = \"\";\n  __privateGet2(this, _spanHint).textContent = (_b3 = hArg.hint) != null ? _b3 : \"\";\n  try {\n    const o = hArg.hint_opt ? __spreadValues(__spreadValues({}, __privateGet2(this, _oHintOpt)), JSON.parse(hArg.hint_opt)) : __privateGet2(this, _oHintOpt);\n    __privateGet2(this, _popper).setOptions(o);\n  } catch (e) {\n    console.error(mesErrJSON(hArg, \"hint_opt\", e.message));\n  }\n  __privateGet2(this, _elmV).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + rctBtn.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + rctBtn.y * this.sys.cvsScale,\n    width: rctBtn.width,\n    height: rctBtn.height\n  });\n  __privateGet2(this, _popper).update();\n  __privateGet2(this, _elmHint).hidden = false;\n};\n_procWheel4wle = new WeakMap();\n_elcWLE = new WeakMap();\n_clear_event = new WeakSet();\nclear_event_fn = function(hArg) {\n  const glb = argChk_Boolean(hArg, \"global\", false);\n  const h2 = glb ? __privateGet2(this, _hGlobalEvt2Fnc) : __privateGet2(this, _hLocalEvt2Fnc);\n  for (const nm in h2)\n    __privateMethod2(this, _clear_eventer, clear_eventer_fn).call(this, nm, h2[nm]);\n  if (glb)\n    __privateSet2(this, _hGlobalEvt2Fnc, {});\n  else\n    __privateSet2(this, _hLocalEvt2Fnc, {});\n  __privateSet2(this, _isWait, false);\n  return false;\n};\n_clear_eventer = new WeakSet();\nclear_eventer_fn = function(KeY, e2f) {\n  if (KeY.slice(0, 4) !== \"dom=\")\n    return;\n  __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, KeY).el.forEach((v2) => v2.removeEventListener(\"click\", e2f));\n};\n_event = new WeakSet();\nevent_fn = function(hArg) {\n  var _a3, _b3;\n  const KeY = hArg.key;\n  if (!KeY)\n    throw \"key\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const key = KeY.toLowerCase();\n  const call = argChk_Boolean(hArg, \"call\", false);\n  const h2 = argChk_Boolean(hArg, \"global\", false) ? __privateGet2(this, _hGlobalEvt2Fnc) : __privateGet2(this, _hLocalEvt2Fnc);\n  if (argChk_Boolean(hArg, \"del\", false)) {\n    if (hArg.fn || hArg.label || call)\n      throw \"fn/label/call\\u3068del\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\";\n    __privateMethod2(this, _clear_eventer, clear_eventer_fn).call(this, KeY, h2[key]);\n    delete h2[key];\n    return false;\n  }\n  (_a3 = hArg.fn) != null ? _a3 : hArg.fn = this.scrItr.scriptFn;\n  if (KeY.slice(0, 4) === \"dom=\") {\n    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, KeY);\n    if (g2.el.length === 0) {\n      if (argChk_Boolean(hArg, \"need_err\", true))\n        throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${g2.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n      return false;\n    }\n    let aEv = [\"click\", \"keydown\"];\n    const inp = g2.el[0];\n    switch ((_b3 = inp.type) != null ? _b3 : \"\") {\n      case \"checkbox\":\n        aEv = [\"input\"];\n        break;\n      case \"range\":\n        aEv = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        aEv = [\"input\", \"change\"];\n        break;\n    }\n    aEv.forEach((v2, i2) => g2.el.forEach((elm) => {\n      __privateGet2(this, _elc2).add(elm, v2, (e) => {\n        if (!__privateGet2(this, _isWait) || this.layMng.getFrmDisabled(g2.id))\n          return;\n        if (v2 === \"keydown\" && e.key !== \"Enter\")\n          return;\n        const d2 = elm.dataset;\n        for (const n in d2)\n          if (d2.hasOwnProperty(n))\n            this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${n}`, d2[n]);\n        this.fire(KeY, e);\n      });\n      if (i2 === 0)\n        __privateGet2(this, _fcs).add(elm, () => {\n          if (!__privateMethod2(this, _canFocus, canFocus_fn).call(this, elm))\n            return false;\n          elm.focus();\n          return true;\n        }, () => {\n        });\n    }));\n  }\n  h2[key] = () => this.main.resumeByJumpOrCall(hArg);\n  return false;\n};\n_canFocus = new WeakSet();\ncanFocus_fn = function(elm) {\n  if (elm.offsetParent === null)\n    return false;\n  let el = elm;\n  do {\n    const style = getComputedStyle(el);\n    if (style.display === \"none\" || el.dataset.focus === \"false\" || (el == null ? void 0 : el.disabled))\n      return false;\n    el = el.parentElement;\n  } while (el !== null);\n  return true;\n};\n_getHtmlElmList = new WeakSet();\ngetHtmlElmList_fn = function(KeY) {\n  const idx = KeY.indexOf(\":\");\n  let sel = \"\";\n  if (idx >= 0) {\n    const id = KeY.slice(4, idx);\n    const frmnm = `const.sn.frm.${id}`;\n    if (!this.val.getVal(`tmp:${frmnm}`, 0))\n      throw `HTML\\u3010${id}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n    const ifrm = document.getElementById(id);\n    const win = ifrm.contentWindow;\n    sel = KeY.slice(idx + 1);\n    return { el: win.document.querySelectorAll(sel), id, sel };\n  }\n  sel = KeY.slice(4);\n  return { el: document.querySelectorAll(sel), id: \"\", sel };\n};\n_goTxt = new WeakMap();\n_l = new WeakSet();\nl_fn = function(hArg) {\n  if (this.scrItr.skip4page)\n    return false;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\")) {\n    __privateGet2(this, _goTxt).call(this);\n    return false;\n  }\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      __privateGet2(this, _stopSkip).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return false;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return __privateMethod2(this, _wait, wait_fn).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n    });\n  if (argChk_Boolean(hArg, \"visible\", true))\n    this.layMng.breakLine();\n  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => this.main.resume());\n  return true;\n};\n_p = new WeakSet();\np_fn = function(hArg) {\n  this.scrItr.recodePage();\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      __privateGet2(this, _stopSkip).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\") {\n      __privateGet2(this, _goTxt).call(this);\n      return false;\n    }\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return __privateMethod2(this, _wait, wait_fn).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  if (argChk_Boolean(hArg, \"visible\", true))\n    this.layMng.breakPage();\n  const fnc = () => {\n    this.sndMng.clearCache();\n    this.main.resume();\n  };\n  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, argChk_Boolean(hArg, \"er\", false) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(hArg);\n    fnc();\n  } : fnc);\n  return true;\n};\n_stopSkip = new WeakMap();\n_set_cancel_skip = new WeakSet();\nset_cancel_skip_fn = function() {\n  __privateSet2(this, _stopSkip, () => {\n    __privateSet2(this, _stopSkip, () => false);\n    this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", true);\n    this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", false);\n    this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", false);\n    this.layMng.setNormalChWait();\n    __privateGet2(this, _cancelWait).call(this);\n    return true;\n  });\n  return false;\n};\n_set_focus = new WeakSet();\nset_focus_fn = function(hArg) {\n  const { add: add3, del, to } = hArg;\n  if ((add3 == null ? void 0 : add3.slice(0, 4)) === \"dom=\") {\n    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, add3);\n    if (g2.el.length === 0 && argChk_Boolean(hArg, \"need_err\", true))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${g2.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    g2.el.forEach((elm) => __privateGet2(this, _fcs).add(elm, () => {\n      if (!__privateMethod2(this, _canFocus, canFocus_fn).call(this, elm))\n        return false;\n      elm.focus();\n      return true;\n    }, () => {\n    }));\n    return false;\n  }\n  if ((del == null ? void 0 : del.slice(0, 4)) === \"dom=\") {\n    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, del);\n    if (g2.el.length === 0 && argChk_Boolean(hArg, \"need_err\", true))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${g2.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    g2.el.forEach((elm) => __privateGet2(this, _fcs).remove(elm));\n    return false;\n  }\n  if (!to)\n    throw \"[set_focus] add \\u304B to \\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  switch (to) {\n    case \"null\":\n      __privateGet2(this, _fcs).blur();\n      break;\n    case \"next\":\n      __privateGet2(this, _fcs).next();\n      break;\n    case \"prev\":\n      __privateGet2(this, _fcs).prev();\n      break;\n  }\n  return false;\n};\n_wait = new WeakSet();\nwait_fn = function(hArg) {\n  const time = argChk_Num(hArg, \"time\", NaN);\n  if (this.scrItr.skip4page)\n    return false;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      __privateGet2(this, _stopSkip).call(this);\n    return false;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    __privateSet2(this, _cancelWait, () => {\n      this.scrItr.subIdxToken();\n      tw.end();\n    });\n  const tw = new Tween({}).to({}, time).onComplete(() => {\n    __privateSet2(this, _cancelWait, () => {\n    });\n    tw.stop();\n    this.main.resume();\n  }).start();\n  return this.waitEvent(() => tw.end(), argChk_Boolean(hArg, \"canskip\", true), argChk_Boolean(hArg, \"global\", false));\n};\n_cancelWait = new WeakMap();\n_waitclick = new WeakSet();\nwaitclick_fn = function() {\n  if (this.scrItr.skip4page)\n    return false;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\"))\n    __privateGet2(this, _stopSkip).call(this);\n  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => this.main.resume());\n  return true;\n};\n_hDownKeys = new WeakMap();\nclass CallStack {\n  constructor(fn2 = \"\", idx = 0, csArg = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    this.fn = fn2;\n    this.idx = idx;\n    this.csArg = csArg;\n    this.toString = () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`;\n  }\n}\nconst _ScriptIterator = class {\n  constructor(cfg, hTag, main2, val, alzTagArg, runAnalyze, prpPrs, sndMng, sys) {\n    __privateAdd2(this, _regBreakPoint);\n    __privateAdd2(this, _go_stepover);\n    __privateAdd2(this, _go_stepout);\n    __privateAdd2(this, _idxDx4Dbg);\n    __privateAdd2(this, _isIdxOverLast);\n    __privateAdd2(this, _isBreak_base);\n    __privateAdd2(this, _subHitCondition);\n    __privateAdd2(this, _aStack);\n    __privateAdd2(this, _let_ml);\n    __privateAdd2(this, _dump_stack);\n    __privateAdd2(this, _cnvIdx2lineCol);\n    __privateAdd2(this, _dump_script);\n    __privateAdd2(this, _endif);\n    __privateAdd2(this, _if);\n    __privateAdd2(this, _call);\n    __privateAdd2(this, _callSub);\n    __privateAdd2(this, _jump);\n    __privateAdd2(this, _page);\n    __privateAdd2(this, _pop_stack);\n    __privateAdd2(this, _return);\n    __privateAdd2(this, _clearResvToken);\n    __privateAdd2(this, _jumpWork);\n    __privateAdd2(this, _nextToken_Proc);\n    __privateAdd2(this, _errOverScr);\n    __privateAdd2(this, _seekScript);\n    __privateAdd2(this, _resolveScript);\n    __privateAdd2(this, _jump_light);\n    __privateAdd2(this, _recordKidoku);\n    __privateAdd2(this, _eraseKidoku);\n    __privateAdd2(this, _bracket2macro);\n    __privateAdd2(this, _char2macro);\n    __privateAdd2(this, _macro);\n    __privateAdd2(this, _load);\n    __privateAdd2(this, _loadFromMark);\n    __privateAdd2(this, _reload_script);\n    __privateAdd2(this, _record_place);\n    __privateAdd2(this, _nowScrIdx);\n    __privateAdd2(this, _save);\n    __privateAdd2(this, _script, void 0);\n    __privateAdd2(this, _scriptFn, void 0);\n    __privateAdd2(this, _idxToken, void 0);\n    __privateAdd2(this, _lineNum, void 0);\n    __privateAdd2(this, _aCallStk, void 0);\n    __privateAdd2(this, _grm, void 0);\n    __privateAdd2(this, _hHook2, void 0);\n    __privateAdd2(this, _cnvSnPath, void 0);\n    __privateAdd2(this, _cnvSnPath4Dbg, void 0);\n    __privateAdd2(this, _csDepth_macro_esc, void 0);\n    __privateAdd2(this, _breakState, void 0);\n    __privateAdd2(this, _procDebugtag, void 0);\n    __privateAdd2(this, _evtMng7, void 0);\n    __privateAdd2(this, _layMng, void 0);\n    __privateAdd2(this, _fncSet, void 0);\n    __privateAdd2(this, _fncBreak, void 0);\n    __privateAdd2(this, _fnLastBreak, void 0);\n    __privateAdd2(this, _hScrCache4Dump, void 0);\n    __privateAdd2(this, _dumpErrLine, void 0);\n    __privateAdd2(this, _aIfStk, void 0);\n    __privateAdd2(this, _resvToken, void 0);\n    __privateAdd2(this, _skipLabel, void 0);\n    __privateAdd2(this, _dbgToken, void 0);\n    __privateAdd2(this, _REG_NONAME_LABEL, void 0);\n    __privateAdd2(this, _REG_TOKEN_MACRO_BEGIN, void 0);\n    __privateAdd2(this, _REG_TOKEN_MACRO_END, void 0);\n    __privateAdd2(this, _REG_TAG_LET_ML, void 0);\n    __privateAdd2(this, _REG_TAG_ENDLET_ML, void 0);\n    __privateAdd2(this, _hScript, void 0);\n    __privateAdd2(this, _REG_WILDCARD, void 0);\n    __privateAdd2(this, _REG_WILDCARD2, void 0);\n    __privateAdd2(this, _replaceScript_Wildcard, void 0);\n    __privateAdd2(this, _isKidoku, void 0);\n    __privateAdd2(this, _strStepin, void 0);\n    __privateAdd2(this, _REGSTEPIN, void 0);\n    __privateAdd2(this, _skip4page, void 0);\n    __privateAdd2(this, _mark, void 0);\n    __privateAdd2(this, _aPageLog, void 0);\n    __privateAdd2(this, _posAPageLog, void 0);\n    this.cfg = cfg;\n    this.hTag = hTag;\n    this.main = main2;\n    this.val = val;\n    this.alzTagArg = alzTagArg;\n    this.runAnalyze = runAnalyze;\n    this.prpPrs = prpPrs;\n    this.sndMng = sndMng;\n    this.sys = sys;\n    __privateSet2(this, _script, { aToken: [\"\"], len: 1, aLNum: [1] });\n    __privateSet2(this, _scriptFn, \"\");\n    __privateSet2(this, _idxToken, 0);\n    __privateSet2(this, _lineNum, 0);\n    this.addLineNum = (len) => __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + len);\n    __privateSet2(this, _aCallStk, []);\n    __privateSet2(this, _grm, new Grammar());\n    this.firstWait = () => {\n    };\n    __privateSet2(this, _hHook2, {\n      disconnect: () => {\n        __privateSet2(_ScriptIterator, _hFn2hLineBP, {});\n        __privateSet2(_ScriptIterator, _hFuncBP, {});\n        this.isBreak = () => false;\n        __privateGet2(this, _hHook2).continue({});\n        __privateSet2(this, _breakState, 0);\n      },\n      restart: () => this.isBreak = () => false,\n      add_break: (o) => __privateMethod2(this, _regBreakPoint, regBreakPoint_fn).call(this, o.fn, o.o),\n      data_break: (o) => {\n        if (__privateGet2(this, _breakState) !== 0)\n          return;\n        __privateSet2(this, _breakState, 1);\n        this.main.setLoop(false, `\\u5909\\u6570 ${o.dataId}\\u3010${o.old_v}\\u3011\\u2192\\u3010${o.new_v}\\u3011\\u30C7\\u30FC\\u30BF\\u30D6\\u30EC\\u30FC\\u30AF`);\n        this.sys.callHook(\"stopOnDataBreakpoint\", {});\n        this.sys.send2Dbg(\"stopOnDataBreakpoint\", {});\n      },\n      set_func_break: (o) => {\n        __privateSet2(_ScriptIterator, _hFuncBP, {});\n        o.a.forEach((v2) => __privateGet2(_ScriptIterator, _hFuncBP)[v2.name] = 1);\n        this.sys.send2Dbg(o.ri, {});\n      },\n      stack: (o) => this.sys.send2Dbg(o.ri, { a: __privateMethod2(this, _aStack, aStack_fn).call(this) }),\n      eval: (o) => {\n        this.sys.send2Dbg(o.ri, { v: this.prpPrs.parse(o.txt) });\n      },\n      continue: () => {\n        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))\n          return;\n        __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));\n        __privateSet2(this, _breakState, 3);\n        this.main.setLoop(true);\n        this.main.resume();\n      },\n      stepover: (o) => __privateMethod2(this, _go_stepover, go_stepover_fn).call(this, o),\n      stepin: () => {\n        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))\n          return;\n        const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get)];\n        this.sys.callHook(`stopOnStep${__privateGet2(this, _REGSTEPIN).test(tkn) ? \"In\" : \"\"}`, {});\n        __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));\n        __privateSet2(this, _breakState, __privateGet2(this, _breakState) === 1 ? 4 : 5);\n        this.main.setLoop(true);\n        this.main.resume();\n      },\n      stepout: (o) => {\n        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))\n          return;\n        if (__privateGet2(this, _aCallStk).length > 0)\n          __privateMethod2(this, _go_stepout, go_stepout_fn).call(this, true);\n        else\n          __privateMethod2(this, _go_stepover, go_stepover_fn).call(this, o);\n      },\n      pause: () => {\n        __privateSet2(this, _breakState, 4);\n        this.main.setLoop(false, \"\\u4E00\\u6642\\u505C\\u6B62\");\n        this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        __privateSet2(this, _breakState, 4);\n        this.main.setLoop(false, \"\\u4E00\\u6642\\u505C\\u6B62\");\n        this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    });\n    __privateSet2(this, _cnvSnPath, (fn2) => this.cfg.searchPath(fn2, Config.EXT_SCRIPT));\n    __privateSet2(this, _cnvSnPath4Dbg, (fn2) => (this.sys.pathBaseCnvSnPath4Dbg + __privateGet2(this, _cnvSnPath).call(this, fn2)).replace(__privateGet2(_ScriptIterator, _REG4CODE_FN), `$1/prj/$2/${__privateGet2(this, _scriptFn)}$3`));\n    this.cnvPath4Dbg = (fn2) => this.sys.pathBaseCnvSnPath4Dbg + fn2.replace(\"/crypto_prj/\", \"/prj/\");\n    __privateSet2(this, _csDepth_macro_esc, 0);\n    __privateSet2(this, _breakState, 0);\n    this.isBreak = (_token) => false;\n    __privateSet2(this, _procDebugtag, (_tag_name) => {\n    });\n    __privateSet2(this, _fncSet, () => {\n    });\n    __privateSet2(this, _fncBreak, () => {\n    });\n    __privateSet2(this, _fnLastBreak, \"\");\n    __privateSet2(this, _hScrCache4Dump, {});\n    this.noticeBreak = (_goto) => {\n    };\n    __privateSet2(this, _dumpErrLine, 5);\n    __privateSet2(this, _aIfStk, [-1]);\n    __privateSet2(this, _resvToken, \"\");\n    __privateSet2(this, _skipLabel, \"\");\n    this.nextToken = () => \"\";\n    __privateSet2(this, _dbgToken, (_token) => {\n    });\n    __privateSet2(this, _REG_NONAME_LABEL, /(\\*{2,})(.*)/);\n    __privateSet2(this, _REG_TOKEN_MACRO_BEGIN, /\\[macro\\s/);\n    __privateSet2(this, _REG_TOKEN_MACRO_END, /\\[endmacro[\\s\\]]/);\n    __privateSet2(this, _REG_TAG_LET_ML, /^\\[let_ml\\s/g);\n    __privateSet2(this, _REG_TAG_ENDLET_ML, /^\\[endlet_ml\\s*]/g);\n    __privateSet2(this, _hScript, /* @__PURE__ */ Object.create(null));\n    __privateSet2(this, _REG_WILDCARD, /^\\[(call|loadplugin)\\s/);\n    __privateSet2(this, _REG_WILDCARD2, /\\bfn\\s*=\\s*[^\\s\\]]+/);\n    __privateSet2(this, _replaceScript_Wildcard, () => {\n      for (let i2 = __privateGet2(this, _script).len - 1; i2 >= 0; --i2) {\n        const token = __privateGet2(this, _script).aToken[i2];\n        if (!__privateGet2(this, _REG_WILDCARD).test(token))\n          continue;\n        const [tag_name, args] = tagToken2Name_Args(token);\n        this.alzTagArg.go(args);\n        const p_fn2 = this.alzTagArg.hPrm.fn;\n        if (!p_fn2)\n          continue;\n        const fn2 = p_fn2.val;\n        if (!fn2 || fn2.slice(-1) !== \"*\")\n          continue;\n        const ext = tag_name === \"loadplugin\" ? \"css\" : \"sn\";\n        const a2 = this.cfg.matchPath(\"^\" + fn2.slice(0, -1) + \".*\", ext);\n        __privateGet2(this, _script).aToken.splice(i2, 1, \"\t\", \"; \" + token);\n        __privateGet2(this, _script).aLNum.splice(i2, 1, NaN, NaN);\n        for (const v2 of a2) {\n          const nt = token.replace(__privateGet2(this, _REG_WILDCARD2), \"fn=\" + decodeURIComponent(getFn(v2[ext])));\n          __privateGet2(this, _script).aToken.splice(i2, 0, nt);\n          __privateGet2(this, _script).aLNum.splice(i2, 0, NaN);\n        }\n      }\n      __privateGet2(this, _script).len = __privateGet2(this, _script).aToken.length;\n    });\n    __privateSet2(this, _isKidoku, false);\n    __privateSet2(this, _strStepin, \"call\");\n    __privateSet2(this, _REGSTEPIN, /\\[(call)\\b/);\n    __privateSet2(this, _skip4page, false);\n    __privateSet2(this, _mark, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    });\n    __privateSet2(this, _aPageLog, []);\n    __privateSet2(this, _posAPageLog, -1);\n    hTag.let_ml = (o) => __privateMethod2(this, _let_ml, let_ml_fn).call(this, o);\n    hTag.dump_stack = () => __privateMethod2(this, _dump_stack, dump_stack_fn).call(this);\n    hTag.dump_script = (o) => __privateMethod2(this, _dump_script, dump_script_fn).call(this, o);\n    hTag[\"else\"] = hTag.elsif = hTag.endif = () => __privateMethod2(this, _endif, endif_fn).call(this);\n    hTag[\"if\"] = (o) => __privateMethod2(this, _if, if_fn).call(this, o);\n    hTag.call = (o) => __privateMethod2(this, _call, call_fn).call(this, o);\n    hTag.jump = (o) => __privateMethod2(this, _jump, jump_fn).call(this, o);\n    hTag.page = (o) => __privateMethod2(this, _page, page_fn).call(this, o);\n    hTag.pop_stack = (o) => __privateMethod2(this, _pop_stack, pop_stack_fn).call(this, o);\n    hTag.return = () => __privateMethod2(this, _return, return_fn).call(this);\n    hTag.bracket2macro = (o) => __privateMethod2(this, _bracket2macro, bracket2macro_fn).call(this, o);\n    hTag.char2macro = (o) => __privateMethod2(this, _char2macro, char2macro_fn).call(this, o);\n    hTag.endmacro = () => __privateMethod2(this, _return, return_fn).call(this);\n    hTag.macro = (o) => __privateMethod2(this, _macro, macro_fn).call(this, o);\n    hTag.load = (o) => __privateMethod2(this, _load, load_fn).call(this, o);\n    hTag.reload_script = (o) => __privateMethod2(this, _reload_script, reload_script_fn).call(this, o);\n    hTag.record_place = () => __privateMethod2(this, _record_place, record_place_fn).call(this);\n    hTag.save = (o) => __privateMethod2(this, _save, save_fn).call(this, o);\n    if (cfg.oCfg.debug.token)\n      __privateSet2(this, _dbgToken, (token) => console.log(`\\u{1F331} \\u30C8\\u30FC\\u30AF\\u30F3 fn:${__privateGet2(this, _scriptFn)} idx:${__privateGet2(this, _idxToken)} ln:${__privateGet2(this, _lineNum)} token\\u3010${token}\\u3011`));\n    val.defTmp(\"const.sn.vctCallStk.length\", () => __privateGet2(this, _aCallStk).length);\n    __privateGet2(this, _grm).setEscape(cfg.oCfg.init.escape);\n    if (CmnLib.isDbg) {\n      sys.addHook((type, o) => {\n        var _a3, _b3;\n        return (_b3 = (_a3 = __privateGet2(this, _hHook2))[type]) == null ? void 0 : _b3.call(_a3, o);\n      });\n      this.isBreak = __privateMethod2(this, _isBreak_base, isBreak_base_fn);\n      const fnc = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        };\n        this.sys.send2Dbg(\"hi\", {});\n      };\n      __privateGet2(this, _hHook2).auth = (o) => {\n        const hLineBP = o.hBreakpoint.hFn2hLineBP;\n        for (const fn2 in hLineBP)\n          __privateMethod2(this, _regBreakPoint, regBreakPoint_fn).call(this, fn2, hLineBP[fn2]);\n        __privateSet2(_ScriptIterator, _hFuncBP, {});\n        o.hBreakpoint.aFunc.forEach((v2) => __privateGet2(_ScriptIterator, _hFuncBP)[v2.name] = 1);\n        if (o.stopOnEntry) {\n          while (true) {\n            let tkn = this.nextToken();\n            if (!tkn)\n              break;\n            const uc = tkn.charCodeAt(0);\n            if (uc === 91)\n              break;\n            if (uc === 38)\n              break;\n            if (uc === 42 && tkn.length === 1)\n              break;\n            if (uc === 10)\n              __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + tkn.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {});\n          this.analyzeInit = fnc;\n          this.analyzeInit();\n        } else {\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          };\n          this.analyzeInit = fnc;\n          this.analyzeInit();\n        }\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    if (cfg.oCfg.debug.tag)\n      __privateSet2(this, _procDebugtag, (tag_name) => console.log(`\\u{1F332} \\u30BF\\u30B0\\u89E3\\u6790 fn:${__privateGet2(this, _scriptFn)} idx:${__privateGet2(this, _idxToken)} ln:${__privateGet2(this, _lineNum)} [${tag_name} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return __privateGet2(this, _scriptFn);\n  }\n  subIdxToken() {\n    --__privateWrapper2(this, _idxToken)._;\n  }\n  get lineNum() {\n    return __privateGet2(this, _lineNum);\n  }\n  destroy() {\n    this.isBreak = () => false;\n  }\n  \\u30BF\\u30B0\\u89E3\\u6790(tagToken) {\n    const [tag_name, args] = tagToken2Name_Args(tagToken);\n    const tag_fnc = this.hTag[tag_name];\n    if (!tag_fnc)\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u3010${tag_name}\\u3011\\u3067\\u3059`;\n    this.alzTagArg.go(args);\n    __privateGet2(this, _procDebugtag).call(this, tag_name);\n    const hPrm = this.alzTagArg.hPrm;\n    if (hPrm.cond) {\n      const cond = hPrm.cond.val;\n      if (!cond || cond.charAt(0) === \"&\")\n        throw \"\\u5C5E\\u6027cond\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n      const p2 = this.prpPrs.parse(cond);\n      const ps = String(p2);\n      if (ps === \"null\" || ps === \"undefined\")\n        return false;\n      if (!p2)\n        return false;\n    }\n    let hArg = {};\n    const len = __privateGet2(this, _aCallStk).length;\n    if (this.alzTagArg.isKomeParam) {\n      if (len === 0)\n        throw \"\\u5C5E\\u6027\\u300C*\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u306E\\u307F\\u6709\\u52B9\\u3067\\u3059\";\n      hArg = __spreadValues({}, __privateGet2(this, _aCallStk)[__privateGet2(this, _aCallStk).length - 1].csArg);\n    }\n    hArg[\":\\u30BF\\u30B0\\u540D\"] = tag_name;\n    for (const arg_nm in hPrm) {\n      let v2 = hPrm[arg_nm].val;\n      if ((v2 == null ? void 0 : v2.charAt(0)) === \"%\") {\n        if (len === 0)\n          throw \"\\u5C5E\\u6027\\u300C%\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u5B9A\\u7FA9\\u5185\\u3067\\u306E\\u307F\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\uFF08\\u305D\\u306E\\u30DE\\u30AF\\u30ED\\u306E\\u5F15\\u6570\\u3092\\u793A\\u3059\\u7C21\\u7565\\u6587\\u6CD5\\u3067\\u3042\\u308B\\u305F\\u3081\\uFF09\";\n        const mac = __privateGet2(this, _aCallStk)[__privateGet2(this, _aCallStk).length - 1].csArg[v2.slice(1)];\n        if (mac) {\n          hArg[arg_nm] = mac;\n          continue;\n        }\n        v2 = hPrm[arg_nm].def;\n        if (v2 === void 0 || v2 === \"null\")\n          continue;\n      }\n      v2 = this.prpPrs.getValAmpersand(v2 != null ? v2 : \"\");\n      if (v2 !== \"undefined\") {\n        hArg[arg_nm] = v2;\n        continue;\n      }\n      const def = hPrm[arg_nm].def;\n      if (def === void 0)\n        continue;\n      v2 = this.prpPrs.getValAmpersand(def);\n      if (v2 !== \"undefined\")\n        hArg[arg_nm] = v2;\n    }\n    return tag_fnc(hArg);\n  }\n  setOtherObj(evtMng, layMng) {\n    __privateSet2(this, _evtMng7, evtMng);\n    __privateSet2(this, _layMng, layMng);\n  }\n  dumpErrForeLine() {\n    var _a3;\n    if (__privateGet2(this, _idxToken) === 0) {\n      console.group(`\\u{1F95F} Error line (from 0 rows before) fn:${__privateGet2(this, _scriptFn)}`);\n      console.groupEnd();\n      return;\n    }\n    let s2 = \"\";\n    for (let i2 = __privateGet2(this, _idxToken) - 1; i2 >= 0; --i2) {\n      s2 = __privateGet2(this, _script).aToken[i2] + s2;\n      if (((_a3 = s2.match(/\\n/g)) != null ? _a3 : []).length >= __privateGet2(this, _dumpErrLine))\n        break;\n    }\n    const a2 = s2.split(\"\\n\").slice(-__privateGet2(this, _dumpErrLine));\n    const len = a2.length;\n    console.group(`\\u{1F95F} Error line (from ${len} rows before) fn:${__privateGet2(this, _scriptFn)}`);\n    const ln_txt_width = String(__privateGet2(this, _lineNum)).length;\n    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));\n    for (let i2 = 0; i2 < len; ++i2) {\n      const ln = __privateGet2(this, _lineNum) - len + i2 + 1;\n      const mes = `${String(ln).padStart(ln_txt_width, \" \")}: %c`;\n      const e = a2[i2];\n      const line = e.length > 75 ? e.slice(0, 75) + \"\\u2026\" : e;\n      if (i2 === len - 1)\n        console.info(mes + line.slice(0, lc.col_s) + \"%c\" + line.slice(lc.col_s), \"color: black; background-color: skyblue;\", \"color: black; background-color: pink;\");\n      else\n        console.info(mes + line, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const o = __privateMethod2(this, _seekScript, seekScript_fn).call(this, __privateGet2(this, _script), Boolean(this.val.getVal(\"mp:const.sn.macro.name\")), __privateGet2(this, _lineNum), __privateGet2(this, _skipLabel), __privateGet2(this, _idxToken));\n    __privateSet2(this, _idxToken, o.idx);\n    __privateSet2(this, _lineNum, o.ln);\n    this.runAnalyze();\n  }\n  get isKidoku() {\n    return __privateGet2(this, _isKidoku);\n  }\n  get isNextKidoku() {\n    let fn2 = __privateGet2(this, _scriptFn);\n    let idx = __privateGet2(this, _idxToken);\n    let len = __privateGet2(this, _script).len;\n    if (__privateGet2(this, _aCallStk).length > 0) {\n      const cs = __privateGet2(this, _aCallStk)[0];\n      fn2 = cs.fn;\n      idx = cs.idx;\n      const st = __privateGet2(this, _hScript)[fn2];\n      if (st)\n        len = st.len;\n    }\n    const areas = this.val.getAreaKidoku(fn2);\n    if (!areas)\n      return false;\n    if (idx === len)\n      return false;\n    return areas.search(idx);\n  }\n  get normalWait() {\n    return __privateGet2(this, _isKidoku) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return __privateGet2(this, _skip4page);\n  }\n  recodePage() {\n    __privateSet2(this, _skip4page, false);\n    if (!this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: fn2, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);\n    const i2 = idx - 1;\n    const key = i2 + \":\" + fn2;\n    const iPl = __privateGet2(this, _aPageLog).findIndex((p2) => p2.key === key);\n    if (iPl > -1) {\n      __privateSet2(this, _posAPageLog, iPl);\n      return;\n    }\n    const o = {\n      key,\n      fn: fn2,\n      idx: i2,\n      retFn: fn2,\n      retIdx: 0,\n      retMark: __spreadValues({}, __privateGet2(this, _mark))\n    };\n    if (__privateGet2(this, _posAPageLog) >= 0) {\n      const pl = __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)];\n      o.retFn = pl.fn;\n      o.retIdx = pl.idx + 1;\n    }\n    if (++__privateWrapper2(this, _posAPageLog)._ === __privateGet2(this, _aPageLog).length)\n      __privateGet2(this, _aPageLog).push(o);\n    else\n      __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)] = o;\n  }\n  recodeDesign(hArg) {\n    let fn2 = \"\";\n    let idx = 0;\n    const len = __privateGet2(this, _aCallStk).length;\n    if (hArg.design_unit && len > 0) {\n      const cs = __privateGet2(this, _aCallStk)[0];\n      fn2 = cs.fn;\n      idx = cs.idx;\n    } else {\n      fn2 = __privateGet2(this, _scriptFn);\n      idx = __privateGet2(this, _idxToken);\n    }\n    hArg[\":path\"] = __privateGet2(this, _cnvSnPath4Dbg).call(this, fn2);\n    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _hScript)[fn2], idx);\n    hArg[\":ln\"] = lc.ln;\n    hArg[\":col_s\"] = lc.col_s;\n    hArg[\":col_e\"] = lc.col_e;\n    const idx_1 = idx - 1;\n    hArg[\":idx_tkn\"] = idx_1;\n    hArg[\":token\"] = __privateGet2(this, _hScript)[fn2].aToken[idx_1];\n    this.sys.send2Dbg(\"_recodeDesign\", hArg);\n  }\n  replace(idx, val) {\n    __privateGet2(this, _script).aToken[idx] = val;\n  }\n};\nlet ScriptIterator = _ScriptIterator;\n_script = new WeakMap();\n_scriptFn = new WeakMap();\n_idxToken = new WeakMap();\n_lineNum = new WeakMap();\n_aCallStk = new WeakMap();\n_grm = new WeakMap();\n_regBreakPoint = new WeakSet();\nregBreakPoint_fn = function(fn2, o) {\n  __privateGet2(_ScriptIterator, _hFn2hLineBP)[__privateGet2(this, _cnvSnPath4Dbg).call(this, fn2)] = o;\n};\n_hHook2 = new WeakMap();\n_cnvSnPath = new WeakMap();\n_REG4CODE_FN = new WeakMap();\n_cnvSnPath4Dbg = new WeakMap();\n_go_stepover = new WeakSet();\ngo_stepover_fn = function(o) {\n  if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))\n    return;\n  const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get)];\n  if (__privateGet2(this, _REGSTEPIN).test(tkn))\n    __privateMethod2(this, _go_stepout, go_stepout_fn).call(this, false);\n  else {\n    this.sys.callHook(\"stopOnStep\", {});\n    __privateGet2(this, _hHook2).stepin(o);\n  }\n};\n_go_stepout = new WeakSet();\ngo_stepout_fn = function(out) {\n  this.sys.callHook(`stopOnStep${out ? \"Out\" : \"\"}`, {});\n  __privateSet2(this, _csDepth_macro_esc, __privateGet2(this, _aCallStk).length - (out ? 1 : 0));\n  __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));\n  __privateSet2(this, _breakState, out ? 7 : 6);\n  this.main.setLoop(true);\n  this.main.resume();\n};\n_csDepth_macro_esc = new WeakMap();\n_idxDx4Dbg = new WeakSet();\nidxDx4Dbg_get = function() {\n  return __privateGet2(this, _breakState) === 2 || __privateGet2(this, _breakState) === 4 ? 1 : 0;\n};\n_isIdxOverLast = new WeakSet();\nisIdxOverLast_fn = function() {\n  if (__privateGet2(this, _idxToken) < __privateGet2(this, _script).len)\n    return false;\n  this.sys.callHook(\"stopOnEntry\", {});\n  this.main.setLoop(false, \"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\");\n  return true;\n};\n_hFn2hLineBP = new WeakMap();\n_hFuncBP = new WeakMap();\n_breakState = new WeakMap();\n_isBreak_base = new WeakSet();\nisBreak_base_fn = function(token) {\n  switch (__privateGet2(this, _breakState)) {\n    case 6:\n      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);\n      __privateSet2(this, _breakState, 7);\n      break;\n    case 7:\n      if (__privateGet2(this, _aCallStk).length !== __privateGet2(this, _csDepth_macro_esc))\n        break;\n      __privateSet2(this, _breakState, 4);\n      this.main.setLoop(false, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\");\n      this.sys.send2Dbg(\"stopOnStep\", {});\n      return true;\n    case 5:\n      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);\n      __privateSet2(this, _breakState, 4);\n      break;\n    case 4:\n      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);\n      this.main.setLoop(false, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\");\n      this.sys.send2Dbg(\"stopOnStep\", {});\n      return true;\n    case 3:\n      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);\n      __privateSet2(this, _breakState, 0);\n      break;\n    default:\n      {\n        if (tagToken2Name(token) in __privateGet2(_ScriptIterator, _hFuncBP)) {\n          __privateSet2(this, _breakState, 2);\n          this.main.setLoop(false, `\\u95A2\\u6570 ${token} \\u30D6\\u30EC\\u30FC\\u30AF`);\n          this.sys.callHook(\"stopOnBreakpoint\", {});\n          this.sys.send2Dbg(\"stopOnBreakpoint\", {});\n          return true;\n        }\n      }\n      {\n        const bp = __privateGet2(_ScriptIterator, _hFn2hLineBP)[__privateGet2(this, _cnvSnPath4Dbg).call(this, __privateGet2(this, _scriptFn))];\n        if (!bp)\n          break;\n        const o = bp[__privateGet2(this, _lineNum)];\n        if (!o)\n          break;\n        if (o.condition) {\n          if (!this.prpPrs.parse(o.condition))\n            break;\n        } else if (\"hitCondition\" in o && --o.hitCondition > 0)\n          break;\n        const isBreak = __privateGet2(this, _breakState) === 0;\n        __privateSet2(this, _breakState, 2);\n        this.main.setLoop(false, isBreak ? (o.condition ? \"\\u6761\\u4EF6\" : \"\\u30D2\\u30C3\\u30C8\\u30AB\\u30A6\\u30F3\\u30C8\") + \"\\u30D6\\u30EC\\u30FC\\u30AF\" : \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\");\n        const type = isBreak ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(type, {});\n        this.sys.send2Dbg(type, {});\n      }\n      return true;\n  }\n  return false;\n};\n_subHitCondition = new WeakSet();\nsubHitCondition_fn = function() {\n  var _a3;\n  const o = (_a3 = __privateGet2(_ScriptIterator, _hFn2hLineBP)[getFn(__privateGet2(this, _scriptFn))]) == null ? void 0 : _a3[__privateGet2(this, _lineNum)];\n  if (o == null ? void 0 : o.hitCondition)\n    --o.hitCondition;\n};\n_aStack = new WeakSet();\naStack_fn = function() {\n  var _a3, _b3;\n  const idx_n = __privateGet2(this, _breakState) === 3 ? 1 : 0;\n  const tkn0 = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - 1 + idx_n];\n  const fn0 = __privateGet2(this, _cnvSnPath4Dbg).call(this, __privateGet2(this, _scriptFn));\n  const tag_name0 = tagToken2Name(tkn0);\n  const nm = tag_name0 ? `[${tag_name0}]` : tkn0;\n  const ma = (_a3 = this.val.getVal(\"mp:const.sn.macro\")) != null ? _a3 : \"{}\";\n  if (__privateGet2(this, _idxToken) === 0)\n    return [{ fn: fn0, ln: 1, col: 1, nm, ma }];\n  const lc0 = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));\n  const a2 = [{ fn: fn0, ln: lc0.ln, col: lc0.col_s + 1, nm, ma }];\n  const len = __privateGet2(this, _aCallStk).length;\n  if (len === 0)\n    return a2;\n  for (let i2 = len - 1; i2 >= 0; --i2) {\n    const cs = __privateGet2(this, _aCallStk)[i2];\n    const st = __privateGet2(this, _hScript)[cs.fn];\n    const tkn = st.aToken[cs.idx - 1];\n    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, st, cs.idx);\n    const tag_name = tagToken2Name(tkn);\n    a2.push({\n      fn: __privateGet2(this, _cnvSnPath4Dbg).call(this, cs.fn),\n      ln: lc.ln,\n      col: lc.col_s + 1,\n      nm: tag_name ? `[${tag_name}]` : tkn,\n      ma: (_b3 = cs.csArg[\":hMp\"][\"const.sn.macro\"]) != null ? _b3 : \"{}\"\n    });\n  }\n  return a2;\n};\n_procDebugtag = new WeakMap();\n_evtMng7 = new WeakMap();\n_layMng = new WeakMap();\n_let_ml = new WeakSet();\nlet_ml_fn = function(hArg) {\n  var _a3;\n  const { name } = hArg;\n  if (!name)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let ml = \"\";\n  const len = __privateGet2(this, _script).len;\n  for (; __privateGet2(this, _idxToken) < len; ++__privateWrapper2(this, _idxToken)._) {\n    ml = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];\n    if (ml !== \"\")\n      break;\n  }\n  hArg.text = ml;\n  hArg.cast = \"str\";\n  this.hTag[\"let\"](hArg);\n  __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) + 2);\n  __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + ((_a3 = ml.match(/\\n/g)) != null ? _a3 : []).length);\n  return false;\n};\n_dump_stack = new WeakSet();\ndump_stack_fn = function() {\n  var _a3;\n  if (__privateGet2(this, _idxToken) === 0) {\n    console.group(`\\u{1F95F} [dump_stack] \\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${__privateGet2(this, _scriptFn)} line:${1} col:${0}`);\n    console.groupEnd();\n    return false;\n  }\n  const lc0 = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));\n  const now2 = `\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${__privateGet2(this, _scriptFn)} line:${lc0.ln} col:${lc0.col_s + 1}`;\n  console.group(`\\u{1F95F} [dump_stack] ${now2}`);\n  const len = __privateGet2(this, _aCallStk).length;\n  if (len > 0) {\n    console.info(now2);\n    for (let i2 = len - 1; i2 >= 0; --i2) {\n      const cs = __privateGet2(this, _aCallStk)[i2];\n      const hMp = cs.csArg[\":hMp\"];\n      const from_macro_nm = hMp ? hMp[\":\\u30BF\\u30B0\\u540D\"] : void 0;\n      const call_nm = (_a3 = cs.csArg[\":\\u30BF\\u30B0\\u540D\"]) != null ? _a3 : \"\";\n      const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _hScript)[cs.fn], cs.idx);\n      console.info(`${len - i2}\\u3064\\u524D\\u306E\\u30B3\\u30FC\\u30EB\\u5143 fn:${cs.fn} line:${lc.ln} col:${lc.col_s + 1}` + (from_macro_nm ? \"\\uFF08[\" + from_macro_nm + \"]\\u30DE\\u30AF\\u30ED\\u5185\\uFF09\" : \" \") + `\\u3067 [${call_nm} ...]\\u3092\\u30B3\\u30FC\\u30EB`);\n    }\n  }\n  console.groupEnd();\n  return false;\n};\n_cnvIdx2lineCol = new WeakSet();\ncnvIdx2lineCol_fn = function(st, idx) {\n  const ret = { ln: 1, col_s: 0, col_e: 0 };\n  if (!st)\n    return ret;\n  let i2 = idx - 1;\n  const lN = ret.ln = st.aLNum[i2];\n  while (st.aLNum[i2] === lN) {\n    if (st.aToken[i2].charAt(0) !== \"\\n\") {\n      const len = st.aToken[i2].length;\n      if (ret.col_e > 0)\n        ret.col_s += len;\n      ret.col_e += len;\n    }\n    if (--i2 < 0)\n      break;\n  }\n  return ret;\n};\n_dump_script = new WeakSet();\ndump_script_fn = function(hArg) {\n  const { set_fnc, break_fnc } = hArg;\n  if (!set_fnc)\n    throw \"set_fnc\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  __privateSet2(this, _fncSet, globalThis[set_fnc]);\n  if (!__privateGet2(this, _fncSet)) {\n    if (argChk_Boolean(hArg, \"need_err\", true))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${set_fnc}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    __privateSet2(this, _fncSet, () => {\n    });\n    return false;\n  }\n  this.noticeBreak = (goto) => {\n    var _a3;\n    if (__privateGet2(this, _fnLastBreak) !== __privateGet2(this, _scriptFn)) {\n      __privateSet2(this, _fnLastBreak, __privateGet2(this, _scriptFn));\n      __privateGet2(this, _fncSet).call(this, __privateGet2(this, _hScrCache4Dump)[__privateGet2(this, _scriptFn)] = (_a3 = __privateGet2(this, _hScrCache4Dump)[__privateGet2(this, _scriptFn)]) != null ? _a3 : __privateGet2(this, _script).aToken.join(\"\"));\n    }\n    __privateGet2(this, _fncBreak).call(this, __privateGet2(this, _lineNum), goto);\n  };\n  this.noticeBreak(true);\n  if (!break_fnc)\n    return false;\n  __privateSet2(this, _fncBreak, globalThis[break_fnc]);\n  if (!__privateGet2(this, _fncBreak)) {\n    if (argChk_Boolean(hArg, \"need_err\", true))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${break_fnc}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    __privateSet2(this, _fncBreak, () => {\n    });\n  }\n  return false;\n};\n_fncSet = new WeakMap();\n_fncBreak = new WeakMap();\n_fnLastBreak = new WeakMap();\n_hScrCache4Dump = new WeakMap();\n_dumpErrLine = new WeakMap();\n_aIfStk = new WeakMap();\n_endif = new WeakSet();\nendif_fn = function() {\n  if (__privateGet2(this, _aIfStk)[0] === -1)\n    throw \"if\\u30D6\\u30ED\\u30C3\\u30AF\\u5185\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  __privateSet2(this, _idxToken, __privateGet2(this, _aIfStk)[0]);\n  __privateGet2(this, _aIfStk).shift();\n  return false;\n};\n_if = new WeakSet();\nif_fn = function(hArg) {\n  var _a3;\n  const { exp } = hArg;\n  if (!exp)\n    throw \"exp\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (exp.charAt(0) === \"&\")\n    throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  let cntDepth = 0;\n  let idxGo = this.prpPrs.parse(exp) ? __privateGet2(this, _idxToken) : -1;\n  const lnIf = __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)];\n  let zLn = __privateGet2(this, _lineNum) - (lnIf || 0);\n  const len = __privateGet2(this, _script).len;\n  for (; __privateGet2(this, _idxToken) < len; ++__privateWrapper2(this, _idxToken)._) {\n    const ln = __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)];\n    __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] = (ln || 0) + zLn;\n    const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];\n    if (!tkn)\n      continue;\n    const uc = tkn.charCodeAt(0);\n    if (uc === 10) {\n      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + tkn.length);\n      continue;\n    }\n    if (uc !== 91)\n      continue;\n    const [tag_name, args] = tagToken2Name_Args(tkn);\n    if (!(tag_name in this.hTag))\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0[${tag_name}]\\u3067\\u3059`;\n    this.alzTagArg.go(args);\n    switch (tag_name) {\n      case \"if\":\n        ++cntDepth;\n        break;\n      case \"elsif\":\n        if (cntDepth > 0)\n          break;\n        if (idxGo > -1)\n          break;\n        const e = (_a3 = this.alzTagArg.hPrm.exp.val) != null ? _a3 : \"\";\n        if (e.charAt(0) === \"&\")\n          throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n        if (this.prpPrs.parse(e))\n          idxGo = __privateGet2(this, _idxToken) + 1;\n        break;\n      case \"else\":\n        if (cntDepth > 0)\n          break;\n        if (idxGo === -1)\n          idxGo = __privateGet2(this, _idxToken) + 1;\n        break;\n      case \"endif\":\n        if (cntDepth > 0) {\n          --cntDepth;\n          break;\n        }\n        if (idxGo === -1) {\n          ++__privateWrapper2(this, _idxToken)._;\n          __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] += zLn;\n        } else {\n          __privateGet2(this, _aIfStk).unshift(__privateGet2(this, _idxToken) + 1);\n          __privateSet2(this, _idxToken, idxGo);\n          __privateSet2(this, _lineNum, __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)]);\n        }\n        return false;\n    }\n  }\n  throw \"[endif]\\u304C\\u306A\\u3044\\u307E\\u307E\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\";\n};\n_call = new WeakSet();\ncall_fn = function(hArg) {\n  if (!argChk_Boolean(hArg, \"count\", false))\n    __privateMethod2(this, _eraseKidoku, eraseKidoku_fn).call(this);\n  const { fn: fn2 } = hArg;\n  if (fn2)\n    __privateGet2(this, _cnvSnPath).call(this, fn2);\n  __privateMethod2(this, _callSub, callSub_fn).call(this, { \":hEvt1Time\": __privateGet2(this, _evtMng7).popLocalEvts(), \":hMp\": this.val.cloneMp() });\n  if (argChk_Boolean(hArg, \"clear_local_event\", false))\n    this.hTag.clear_event({});\n  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, fn2, hArg.label);\n  return true;\n};\n_callSub = new WeakSet();\ncallSub_fn = function(csa) {\n  __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] = __privateGet2(this, _lineNum);\n  if (!__privateGet2(this, _resvToken)) {\n    csa[\":resvToken\"] = \"\";\n    __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);\n  }\n  __privateGet2(this, _aCallStk).push(new CallStack(__privateGet2(this, _scriptFn), __privateGet2(this, _idxToken), csa));\n  __privateGet2(this, _aIfStk).unshift(-1);\n};\n_jump = new WeakSet();\njump_fn = function(hArg) {\n  if (!argChk_Boolean(hArg, \"count\", true))\n    __privateMethod2(this, _eraseKidoku, eraseKidoku_fn).call(this);\n  __privateGet2(this, _aIfStk)[0] = -1;\n  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, hArg.fn, hArg.label);\n  return true;\n};\n_page = new WeakSet();\npage_fn = function(hArg) {\n  if (__privateGet2(this, _posAPageLog) === -1)\n    return false;\n  if (argChk_Boolean(hArg, \"clear\", false)) {\n    __privateSet2(this, _aPageLog, []);\n    __privateSet2(this, _posAPageLog, -1);\n    return false;\n  }\n  const { to } = hArg;\n  if (!to)\n    throw \"clear\\u304Bto\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const oldPos = __privateGet2(this, _posAPageLog);\n  switch (to) {\n    case \"prev\":\n      if (__privateGet2(this, _posAPageLog) > 0)\n        --__privateWrapper2(this, _posAPageLog)._;\n      break;\n    case \"next\":\n      const len = __privateGet2(this, _aPageLog).length;\n      if (__privateGet2(this, _posAPageLog) < len - 1)\n        ++__privateWrapper2(this, _posAPageLog)._;\n      break;\n    default:\n      throw `\\u5C5E\\u6027to\\u300C${to}\\u300D\\u306F\\u7570\\u5E38\\u3067\\u3059`;\n  }\n  if (oldPos === __privateGet2(this, _posAPageLog))\n    return false;\n  const o = __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)];\n  const { fn: fn2, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);\n  if (o.key === idx + \":\" + fn2)\n    return false;\n  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, { fn: o.retFn, index: o.retIdx }, o.retMark);\n};\n_pop_stack = new WeakSet();\npop_stack_fn = function(hArg) {\n  if (argChk_Boolean(hArg, \"clear\", false))\n    __privateSet2(this, _aCallStk, []);\n  else if (!__privateGet2(this, _aCallStk).pop())\n    throw \"[pop_stack] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);\n  __privateSet2(this, _aIfStk, [-1]);\n  this.val.setMp({});\n  return false;\n};\n_return = new WeakSet();\nreturn_fn = function() {\n  const cs = __privateGet2(this, _aCallStk).pop();\n  if (!cs)\n    throw \"[return] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  const csa = cs.csArg;\n  __privateGet2(this, _aIfStk).shift();\n  const hMp = csa[\":hMp\"];\n  if (hMp)\n    this.val.setMp(hMp);\n  const after_token = csa[\":resvToken\"];\n  if (after_token)\n    this.nextToken = () => {\n      __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);\n      return after_token;\n    };\n  else\n    __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);\n  if (csa[\":hEvt1Time\"])\n    __privateGet2(this, _evtMng7).pushLocalEvts(csa[\":hEvt1Time\"]);\n  if (cs.fn in __privateGet2(this, _hScript)) {\n    __privateMethod2(this, _jump_light, jump_light_fn).call(this, cs);\n    return false;\n  }\n  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, cs.fn, \"\", cs.idx);\n  return true;\n};\n_resvToken = new WeakMap();\n_clearResvToken = new WeakSet();\nclearResvToken_fn = function() {\n  __privateSet2(this, _resvToken, \"\");\n  this.nextToken = __privateMethod2(this, _nextToken_Proc, nextToken_Proc_fn);\n};\n_skipLabel = new WeakMap();\n_jumpWork = new WeakSet();\njumpWork_fn = function(fn2 = \"\", label = \"\", idx = 0) {\n  if (!fn2 && !label)\n    this.main.errScript(\"[jump\\u7CFB] fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\");\n  if (label) {\n    if (label.charAt(0) !== \"*\")\n      this.main.errScript(\"[jump\\u7CFB] label\\u306F*\\u3067\\u59CB\\u307E\\u308A\\u307E\\u3059\");\n    __privateSet2(this, _skipLabel, label);\n    if (__privateGet2(this, _skipLabel).slice(0, 2) !== \"**\")\n      __privateSet2(this, _idxToken, idx);\n  } else {\n    __privateSet2(this, _skipLabel, \"\");\n    __privateSet2(this, _idxToken, idx);\n  }\n  if (!fn2) {\n    this.analyzeInit();\n    return;\n  }\n  const full_path = __privateGet2(this, _cnvSnPath).call(this, fn2);\n  if (fn2 === __privateGet2(this, _scriptFn)) {\n    this.analyzeInit();\n    return;\n  }\n  __privateSet2(this, _scriptFn, fn2);\n  const st = __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)];\n  if (st) {\n    __privateSet2(this, _script, st);\n    this.analyzeInit();\n    return;\n  }\n  new Loader().add({ name: __privateGet2(this, _scriptFn), url: full_path }).use((res, next) => {\n    try {\n      res.data = this.sys.decStr(res.extension, res.data);\n    } catch (e) {\n      this.main.errScript(`[jump\\u7CFB]sn\\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${res.name} ${e}`, false);\n    }\n    next == null ? void 0 : next();\n  }).load((_ldr, hRes) => {\n    this.nextToken = __privateMethod2(this, _nextToken_Proc, nextToken_Proc_fn);\n    __privateSet2(this, _lineNum, 1);\n    __privateMethod2(this, _resolveScript, resolveScript_fn).call(this, hRes[fn2].data);\n    this.hTag.record_place({});\n    this.main.resume(() => this.analyzeInit());\n  });\n  this.main.stop();\n};\n_nextToken_Proc = new WeakSet();\nnextToken_Proc_fn = function() {\n  var _a3, _b3;\n  if (__privateMethod2(this, _errOverScr, errOverScr_fn).call(this))\n    return \"\";\n  __privateMethod2(this, _recordKidoku, recordKidoku_fn).call(this);\n  (_a3 = __privateGet2(this, _script).aLNum)[_b3 = __privateGet2(this, _idxToken)] || (_a3[_b3] = __privateGet2(this, _lineNum));\n  const token = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];\n  __privateGet2(this, _dbgToken).call(this, token);\n  ++__privateWrapper2(this, _idxToken)._;\n  return token;\n};\n_dbgToken = new WeakMap();\n_errOverScr = new WeakSet();\nerrOverScr_fn = function() {\n  if (__privateGet2(this, _idxToken) < __privateGet2(this, _script).len)\n    return false;\n  this.main.errScript(\"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\");\n  return true;\n};\n_REG_NONAME_LABEL = new WeakMap();\n_REG_TOKEN_MACRO_BEGIN = new WeakMap();\n_REG_TOKEN_MACRO_END = new WeakMap();\n_REG_TAG_LET_ML = new WeakMap();\n_REG_TAG_ENDLET_ML = new WeakMap();\n_seekScript = new WeakSet();\nseekScript_fn = function(st, inMacro, ln, skipLabel, idx) {\n  var _a3, _b3, _c3, _d2, _e;\n  const len = st.aToken.length;\n  if (!skipLabel) {\n    if (__privateMethod2(this, _errOverScr, errOverScr_fn).call(this))\n      return { idx, ln };\n    if (!st.aLNum[idx]) {\n      ln = 1;\n      for (let j2 = 0; j2 < idx; ++j2) {\n        (_a3 = st.aLNum)[j2] || (_a3[j2] = ln);\n        const tkn = st.aToken[j2];\n        if (tkn.charCodeAt(0) === 10)\n          ln += tkn.length;\n        else\n          ln += ((_b3 = tkn.match(/\\n/g)) != null ? _b3 : []).length;\n      }\n      st.aLNum[idx] = ln;\n    } else\n      ln = st.aLNum[idx];\n    return { idx, ln };\n  }\n  st.aLNum[0] = 1;\n  const a_skipLabel = skipLabel.match(__privateGet2(this, _REG_NONAME_LABEL));\n  if (a_skipLabel) {\n    skipLabel = a_skipLabel[1];\n    let i2 = idx;\n    switch (a_skipLabel[2]) {\n      case \"before\":\n        while (st.aToken[--i2] !== skipLabel) {\n          if (i2 === 0)\n            DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \" + ln + \"\\u884C\\u76EE\\u4EE5\\u524D\\u3067\" + (inMacro ? \"\\u30DE\\u30AF\\u30ED\\u5185\\u306B\" : \"\") + \"\\u30E9\\u30D9\\u30EB\\u3010\" + skipLabel + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n          if (inMacro && st.aToken[i2].search(__privateGet2(this, _REG_TOKEN_MACRO_BEGIN)) > -1)\n            DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + skipLabel + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        }\n        return { idx: i2 + 1, ln: st.aLNum[i2] };\n      case \"after\":\n        while (st.aToken[++i2] !== skipLabel) {\n          if (i2 === len)\n            DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + ln + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + skipLabel + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n          if (st.aToken[i2].search(__privateGet2(this, _REG_TOKEN_MACRO_END)) > -1)\n            DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + ln + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + skipLabel + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        }\n        return { idx: i2 + 1, ln: st.aLNum[i2] };\n      default:\n        DebugMng.myTrace(\"[jump\\u7CFB] \\u7121\\u540D\\u30E9\\u30D9\\u30EB\\u6307\\u5B9A\\u3010label=\" + skipLabel + \"\\u3011\\u304C\\u9593\\u9055\\u3063\\u3066\\u3044\\u307E\\u3059\", \"ET\");\n    }\n  }\n  ln = 1;\n  const reLabel = new RegExp(\"^\" + skipLabel.replaceAll(\"*\", \"\\\\*\") + \"(?:\\\\s|;|\\\\[|$)\");\n  let in_let_ml = false;\n  for (let i2 = 0; i2 < len; ++i2) {\n    (_c3 = st.aLNum)[i2] || (_c3[i2] = ln);\n    const tkn = st.aToken[i2];\n    if (in_let_ml) {\n      __privateGet2(this, _REG_TAG_ENDLET_ML).lastIndex = 0;\n      if (__privateGet2(this, _REG_TAG_ENDLET_ML).test(tkn))\n        in_let_ml = false;\n      else\n        ln += ((_d2 = tkn.match(/\\n/g)) != null ? _d2 : []).length;\n      continue;\n    }\n    const uc = tkn.charCodeAt(0);\n    if (uc === 10) {\n      ln += tkn.length;\n      continue;\n    }\n    if (uc === 42) {\n      if (tkn.search(reLabel) > -1)\n        return { idx: i2 + 1, ln };\n      continue;\n    }\n    if (uc !== 91)\n      continue;\n    ln += ((_e = tkn.match(/\\n/g)) != null ? _e : []).length;\n    __privateGet2(this, _REG_TAG_LET_ML).lastIndex = 0;\n    if (__privateGet2(this, _REG_TAG_LET_ML).test(tkn))\n      in_let_ml = true;\n  }\n  if (in_let_ml)\n    throw \"[let_ml]\\u306E\\u7D42\\u7AEF\\u30FB[endlet_ml]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  DebugMng.myTrace(`[jump\\u7CFB] \\u30E9\\u30D9\\u30EB\\u3010${skipLabel}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`, \"ET\");\n  throw \"Dummy\";\n};\n_hScript = new WeakMap();\n_resolveScript = new WeakSet();\nresolveScript_fn = function(txt) {\n  const v2 = __privateGet2(this, _grm).matchToken(txt.replace(/(\\r\\n|\\r)/g, \"\\n\"));\n  for (let i2 = v2.length - 1; i2 >= 0; --i2) {\n    const e = v2[i2];\n    __privateGet2(this, _REG_TAG_LET_ML).lastIndex = 0;\n    if (__privateGet2(this, _REG_TAG_LET_ML).test(e)) {\n      const idx = e.indexOf(\"]\") + 1;\n      if (idx === 0)\n        throw \"[let_ml]\\u3067\\u9589\\u3058\\u308B\\u3010]\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n      const a2 = e.slice(0, idx);\n      const b2 = e.slice(idx);\n      v2.splice(i2, 1, a2, b2);\n    }\n  }\n  __privateSet2(this, _script, { aToken: v2, len: v2.length, aLNum: [] });\n  let mes = \"\";\n  try {\n    mes = \"ScriptIterator.replaceScriptChar2macro\";\n    __privateGet2(this, _grm).replaceScr_C2M_And_let_ml(__privateGet2(this, _script));\n    mes = \"ScriptIterator.replaceScript_Wildcard\";\n    __privateGet2(this, _replaceScript_Wildcard).call(this);\n  } catch (err) {\n    if (err instanceof Error) {\n      const e = err;\n      mes += `\\u4F8B\\u5916 mes=${e.message}(${e.name})`;\n    } else {\n      mes = err;\n    }\n    this.main.errScript(mes, false);\n  }\n  __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)] = __privateGet2(this, _script);\n  this.val.loadScrWork(__privateGet2(this, _scriptFn));\n};\n_jump_light = new WeakSet();\njump_light_fn = function(cs) {\n  __privateSet2(this, _scriptFn, cs.fn);\n  __privateSet2(this, _idxToken, cs.idx);\n  const st = __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)];\n  if (st)\n    __privateSet2(this, _script, st);\n  __privateSet2(this, _lineNum, __privateGet2(this, _script).aLNum[cs.idx]);\n};\n_REG_WILDCARD = new WeakMap();\n_REG_WILDCARD2 = new WeakMap();\n_replaceScript_Wildcard = new WeakMap();\n_recordKidoku = new WeakSet();\nrecordKidoku_fn = function() {\n  const areas = this.val.getAreaKidoku(__privateGet2(this, _scriptFn));\n  if (!areas)\n    throw `recordKidoku fn:'${__privateGet2(this, _scriptFn)}' (areas === null)`;\n  if (__privateGet2(this, _aCallStk).length > 0) {\n    areas.record(__privateGet2(this, _idxToken));\n    return;\n  }\n  __privateSet2(this, _isKidoku, areas.search(__privateGet2(this, _idxToken)));\n  this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", __privateGet2(this, _isKidoku));\n  if (__privateGet2(this, _isKidoku))\n    return;\n  areas.record(__privateGet2(this, _idxToken));\n};\n_isKidoku = new WeakMap();\n_eraseKidoku = new WeakSet();\neraseKidoku_fn = function() {\n  var _a3;\n  (_a3 = this.val.getAreaKidoku(__privateGet2(this, _scriptFn))) == null ? void 0 : _a3.erase(__privateGet2(this, _idxToken));\n  __privateSet2(this, _isKidoku, false);\n};\n_bracket2macro = new WeakSet();\nbracket2macro_fn = function(hArg) {\n  __privateGet2(this, _grm).bracket2macro(hArg, __privateGet2(this, _script), __privateGet2(this, _idxToken));\n  return false;\n};\n_char2macro = new WeakSet();\nchar2macro_fn = function(hArg) {\n  __privateGet2(this, _grm).char2macro(hArg, this.hTag, __privateGet2(this, _script), __privateGet2(this, _idxToken));\n  return false;\n};\n_macro = new WeakSet();\nmacro_fn = function(hArg) {\n  var _a3, _b3, _c3;\n  const { name } = hArg;\n  if (!name)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (name in this.hTag)\n    throw `[${name}]\\u306F\\u30BF\\u30B0\\u304B\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30DE\\u30AF\\u30ED\\u3067\\u3059`;\n  const ln = __privateGet2(this, _lineNum);\n  const cs = new CallStack(__privateGet2(this, _scriptFn), __privateGet2(this, _idxToken));\n  __privateSet2(this, _strStepin, __privateGet2(this, _strStepin) + (\"|\" + name));\n  __privateSet2(this, _REGSTEPIN, new RegExp(`\\\\[(${__privateGet2(this, _strStepin)})\\\\b`));\n  this.hTag[name] = (hArgM) => {\n    hArgM.design_unit = hArg.design_unit;\n    __privateMethod2(this, _callSub, callSub_fn).call(this, __spreadProps(__spreadValues({}, hArgM), { \":hMp\": this.val.cloneMp() }));\n    this.val.setMp(hArgM);\n    this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(hArg));\n    this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", __privateGet2(this, _scriptFn));\n    __privateSet2(this, _lineNum, ln);\n    __privateMethod2(this, _jump_light, jump_light_fn).call(this, cs);\n    return false;\n  };\n  for (; __privateGet2(this, _idxToken) < __privateGet2(this, _script).len; ++__privateWrapper2(this, _idxToken)._) {\n    (_a3 = __privateGet2(this, _script).aLNum)[_b3 = __privateGet2(this, _idxToken)] || (_a3[_b3] = __privateGet2(this, _lineNum));\n    const token = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];\n    if (token.search(__privateGet2(this, _REG_TOKEN_MACRO_END)) > -1) {\n      ++__privateWrapper2(this, _idxToken)._;\n      return false;\n    }\n    const uc = token.charCodeAt(0);\n    if (uc === 10)\n      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + token.length);\n    else if (uc === 91)\n      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + ((_c3 = token.match(/\\n/g)) != null ? _c3 : []).length);\n  }\n  throw `\\u30DE\\u30AF\\u30ED[${name}]\\u5B9A\\u7FA9\\u306E\\u7D42\\u7AEF\\u30FB[endmacro]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`;\n};\n_strStepin = new WeakMap();\n_REGSTEPIN = new WeakMap();\n_load = new WeakSet();\nload_fn = function(hArg) {\n  if (!(\"place\" in hArg))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const place = Number(hArg.place);\n  if (\"fn\" in hArg !== \"label\" in hArg)\n    throw \"fn\\u3068label\\u306F\\u30BB\\u30C3\\u30C8\\u3067\\u6307\\u5B9A\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  const mark = this.val.getMark(place);\n  if (!mark)\n    throw `place\\u3010${place}\\u3011\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, hArg, mark);\n};\n_loadFromMark = new WeakSet();\nloadFromMark_fn = function(hArg, mark, reload_sound = true) {\n  this.hTag.clear_event({});\n  this.val.mark2save(mark);\n  this.val.setMp({});\n  __privateGet2(this, _layMng).recText(\"\", true);\n  if (reload_sound)\n    this.sndMng.playLoopFromSaveObj();\n  if (argChk_Boolean(hArg, \"do_rec\", true))\n    __privateSet2(this, _mark, {\n      hSave: this.val.cloneSave(),\n      hPages: __spreadValues({}, mark.hPages),\n      aIfStk: [...mark.aIfStk]\n    });\n  const o = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(o);\n  const fn2 = String(this.val.getVal(\"save:const.sn.scriptFn\"));\n  const idx = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  __privateSet2(this, _aIfStk, [...__privateGet2(this, _mark).aIfStk]);\n  __privateSet2(this, _aCallStk, []);\n  __privateGet2(this, _layMng).cover(true);\n  __privateGet2(this, _layMng).stopAllTw();\n  if (\"index\" in hArg) {\n    __privateGet2(this, _layMng).playback(__privateGet2(this, _mark).hPages, () => {\n      var _a3, _b3;\n      __privateGet2(this, _layMng).cover(false);\n      __privateSet2(this, _skip4page, true);\n      __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, (_a3 = hArg.fn) != null ? _a3 : fn2, \"\", (_b3 = hArg.index) != null ? _b3 : idx);\n    });\n    return true;\n  }\n  delete __privateGet2(this, _hScript)[fn2];\n  __privateGet2(this, _layMng).playback(__privateGet2(this, _mark).hPages, \"label\" in hArg ? () => {\n    __privateGet2(this, _layMng).cover(false);\n    __privateSet2(this, _scriptFn, fn2);\n    __privateSet2(this, _idxToken, idx);\n    this.hTag.call({ fn: hArg.fn, label: hArg.label });\n  } : () => {\n    __privateGet2(this, _layMng).cover(false);\n    __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, fn2, \"\", idx);\n  });\n  return true;\n};\n_skip4page = new WeakMap();\n_reload_script = new WeakSet();\nreload_script_fn = function(hArg) {\n  const mark = this.val.getMark(0);\n  delete __privateGet2(this, _hScript)[getFn(mark.hSave[\"const.sn.scriptFn\"])];\n  hArg.do_rec = false;\n  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, hArg, mark, false);\n};\n_mark = new WeakMap();\n_record_place = new WeakSet();\nrecord_place_fn = function() {\n  if (this.main.isDestroyed())\n    return false;\n  const { fn: fn2, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);\n  this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", fn2);\n  this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", idx);\n  __privateSet2(this, _mark, {\n    hSave: this.val.cloneSave(),\n    hPages: __privateGet2(this, _layMng).record(),\n    aIfStk: __privateGet2(this, _aIfStk).slice(__privateGet2(this, _aCallStk).length)\n  });\n  return false;\n};\n_nowScrIdx = new WeakSet();\nnowScrIdx_fn = function() {\n  const len = __privateGet2(this, _aCallStk).length;\n  if (len === 0)\n    return {\n      fn: __privateGet2(this, _scriptFn),\n      idx: __privateGet2(this, _idxToken)\n    };\n  const cs = __privateGet2(this, _aCallStk)[0];\n  return {\n    fn: cs.fn,\n    idx: cs.idx\n  };\n};\n_save = new WeakSet();\nsave_fn = function(hArg) {\n  var _a3;\n  if (!(\"place\" in hArg))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const place = Number(hArg.place);\n  delete hArg[\":\\u30BF\\u30B0\\u540D\"];\n  delete hArg.place;\n  hArg.text = ((_a3 = hArg.text) != null ? _a3 : \"\").replace(/^(<br\\/>)+/, \"\");\n  __privateGet2(this, _mark).json = hArg;\n  this.val.setMark(place, __privateGet2(this, _mark));\n  const now_sp = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  if (place === now_sp)\n    this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", now_sp + 1);\n  return false;\n};\n_aPageLog = new WeakMap();\n_posAPageLog = new WeakMap();\n__privateAdd2(ScriptIterator, _REG4CODE_FN, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/);\n__privateAdd2(ScriptIterator, _hFn2hLineBP, {});\n__privateAdd2(ScriptIterator, _hFuncBP, {});\nclass Main {\n  constructor(sys) {\n    __privateAdd2(this, _init);\n    __privateAdd2(this, _runAnalyze);\n    __privateAdd2(this, _cfg4, void 0);\n    __privateAdd2(this, _appPixi3, void 0);\n    __privateAdd2(this, _hTag2, void 0);\n    __privateAdd2(this, _val2, void 0);\n    __privateAdd2(this, _prpPrs, void 0);\n    __privateAdd2(this, _sndMng, void 0);\n    __privateAdd2(this, _scrItr2, void 0);\n    __privateAdd2(this, _dbgMng, void 0);\n    __privateAdd2(this, _layMng2, void 0);\n    __privateAdd2(this, _evtMng8, void 0);\n    __privateAdd2(this, _fncNext, void 0);\n    __privateAdd2(this, _alzTagArg2, void 0);\n    __privateAdd2(this, _inited, void 0);\n    __privateAdd2(this, _SN_ID, void 0);\n    __privateAdd2(this, _fncTicker2, void 0);\n    __privateAdd2(this, _fncresume, void 0);\n    __privateAdd2(this, _isLoop, void 0);\n    __privateAdd2(this, _destroyed, void 0);\n    __privateAdd2(this, _clone_cvs, void 0);\n    this.sys = sys;\n    __privateSet2(this, _hTag2, /* @__PURE__ */ Object.create(null));\n    __privateSet2(this, _fncNext, () => {\n    });\n    __privateSet2(this, _alzTagArg2, new AnalyzeTagArg());\n    __privateSet2(this, _inited, false);\n    __privateSet2(this, _SN_ID, \"skynovel\");\n    __privateSet2(this, _fncTicker2, () => __privateGet2(this, _fncNext).call(this));\n    __privateSet2(this, _fncresume, (fnc = __privateMethod2(this, _runAnalyze, runAnalyze_fn)) => {\n      if (__privateGet2(this, _destroyed))\n        return;\n      __privateGet2(this, _layMng2).clearBreak();\n      __privateSet2(this, _fncNext, fnc);\n      this.resume = (fnc2 = __privateMethod2(this, _runAnalyze, runAnalyze_fn)) => {\n        __privateSet2(this, _fncNext, fnc2);\n      };\n      __privateGet2(this, _scrItr2).noticeBreak(false);\n    });\n    this.resume = __privateGet2(this, _fncresume);\n    this.stop = () => {\n      __privateSet2(this, _fncNext, () => {\n      });\n      this.resume = __privateGet2(this, _fncresume);\n      __privateGet2(this, _scrItr2).noticeBreak(true);\n    };\n    __privateSet2(this, _isLoop, true);\n    __privateSet2(this, _destroyed, false);\n    this.isDestroyed = () => __privateGet2(this, _destroyed);\n    skipHello();\n    Config.generate(sys).then((c2) => __privateSet2(this, _cfg4, c2)).then(() => __privateMethod2(this, _init, init_fn).call(this)).catch((e) => console.error(`load err fn:prj.json e:%o`, e));\n  }\n  errScript(mes, isThrow = true) {\n    this.stop();\n    DebugMng.myTrace(mes);\n    if (CmnLib.debugLog)\n      console.log(\"\\u{1F35C} SKYNovel err!\");\n    if (isThrow)\n      throw mes;\n  }\n  resumeByJumpOrCall(hArg) {\n    var _a3, _b3;\n    if (hArg.url) {\n      globalThis.open(hArg.url);\n      return;\n    }\n    __privateGet2(this, _val2).setVal_Nochk(\"tmp\", \"sn.eventArg\", (_a3 = hArg.arg) != null ? _a3 : \"\");\n    __privateGet2(this, _val2).setVal_Nochk(\"tmp\", \"sn.eventLabel\", (_b3 = hArg.label) != null ? _b3 : \"\");\n    if (argChk_Boolean(hArg, \"call\", false)) {\n      __privateGet2(this, _scrItr2).subIdxToken();\n      this.resume(() => __privateGet2(this, _hTag2).call(hArg));\n    } else {\n      __privateGet2(this, _hTag2).clear_event({});\n      this.resume(() => __privateGet2(this, _hTag2).jump(hArg));\n    }\n  }\n  setLoop(isLoop, mes = \"\") {\n    if (__privateSet2(this, _isLoop, isLoop))\n      this.resume();\n    else\n      this.stop();\n    this.sys.setTitleInfo(mes ? ` -- ${mes}\\u4E2D` : \"\");\n  }\n  fire(KEY, e) {\n    __privateGet2(this, _evtMng8).fire(KEY, e);\n  }\n  async destroy(ms_late = 0) {\n    if (__privateGet2(this, _destroyed))\n      return;\n    __privateSet2(this, _destroyed, true);\n    if (!__privateGet2(this, _inited))\n      return;\n    this.stop();\n    __privateSet2(this, _isLoop, false);\n    __privateGet2(this, _layMng2).before_destroy();\n    if (ms_late > 0)\n      await new Promise((r2) => setTimeout(r2, ms_late));\n    __privateSet2(this, _hTag2, {});\n    __privateGet2(this, _evtMng8).destroy();\n    __privateGet2(this, _scrItr2).destroy();\n    __privateGet2(this, _layMng2).destroy();\n    __privateGet2(this, _dbgMng).destroy();\n    __privateGet2(this, _appPixi3).ticker.remove(__privateGet2(this, _fncTicker2));\n    if (__privateGet2(this, _clone_cvs) && __privateGet2(this, _appPixi3)) {\n      __privateGet2(this, _appPixi3).view.parentNode.appendChild(__privateGet2(this, _clone_cvs));\n    }\n    clearTextureCache();\n    __privateGet2(this, _appPixi3).destroy(true);\n  }\n}\n_cfg4 = new WeakMap();\n_appPixi3 = new WeakMap();\n_hTag2 = new WeakMap();\n_val2 = new WeakMap();\n_prpPrs = new WeakMap();\n_sndMng = new WeakMap();\n_scrItr2 = new WeakMap();\n_dbgMng = new WeakMap();\n_layMng2 = new WeakMap();\n_evtMng8 = new WeakMap();\n_fncNext = new WeakMap();\n_alzTagArg2 = new WeakMap();\n_inited = new WeakMap();\n_SN_ID = new WeakMap();\n_init = new WeakSet();\ninit_fn = async function() {\n  var _a3, _b3, _c3;\n  const cc = (_a3 = document.createElement(\"canvas\")) == null ? void 0 : _a3.getContext(\"2d\");\n  if (!cc)\n    throw \"argChk_Color err\";\n  CmnLib.cc4ColorName = cc;\n  const hApp = {\n    width: __privateGet2(this, _cfg4).oCfg.window.width,\n    height: __privateGet2(this, _cfg4).oCfg.window.height,\n    backgroundColor: parseColor(String(__privateGet2(this, _cfg4).oCfg.init.bg_color)),\n    resolution: (_b3 = globalThis.devicePixelRatio) != null ? _b3 : 1,\n    autoResize: true\n  };\n  const cvs = document.getElementById(__privateGet2(this, _SN_ID));\n  if (cvs) {\n    __privateSet2(this, _clone_cvs, cvs.cloneNode(true));\n    __privateGet2(this, _clone_cvs).id = __privateGet2(this, _SN_ID);\n    hApp.view = cvs;\n  }\n  __privateSet2(this, _appPixi3, new Application(hApp));\n  if (!cvs) {\n    document.body.appendChild(__privateGet2(this, _appPixi3).view);\n    __privateGet2(this, _appPixi3).view.id = __privateGet2(this, _SN_ID);\n  }\n  __privateSet2(this, _val2, new Variable(__privateGet2(this, _cfg4), __privateGet2(this, _hTag2)));\n  __privateSet2(this, _prpPrs, new PropParser(__privateGet2(this, _val2), (_c3 = __privateGet2(this, _cfg4).oCfg.init.escape) != null ? _c3 : \"\\\\\"));\n  await Promise.allSettled(this.sys.init(__privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), __privateGet2(this, _val2), this));\n  __privateGet2(this, _hTag2).title({ text: __privateGet2(this, _cfg4).oCfg.book.title || \"SKYNovel\" });\n  __privateSet2(this, _sndMng, new SoundMng(__privateGet2(this, _cfg4), __privateGet2(this, _hTag2), __privateGet2(this, _val2), this, this.sys));\n  __privateSet2(this, _scrItr2, new ScriptIterator(__privateGet2(this, _cfg4), __privateGet2(this, _hTag2), this, __privateGet2(this, _val2), __privateGet2(this, _alzTagArg2), () => __privateMethod2(this, _runAnalyze, runAnalyze_fn).call(this), __privateGet2(this, _prpPrs), __privateGet2(this, _sndMng), this.sys));\n  __privateSet2(this, _dbgMng, new DebugMng(this.sys, __privateGet2(this, _hTag2), __privateGet2(this, _scrItr2)));\n  __privateSet2(this, _layMng2, new LayerMng(__privateGet2(this, _cfg4), __privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), __privateGet2(this, _val2), this, __privateGet2(this, _scrItr2), this.sys, __privateGet2(this, _sndMng), __privateGet2(this, _alzTagArg2), __privateGet2(this, _prpPrs)));\n  __privateSet2(this, _evtMng8, new EventMng(__privateGet2(this, _cfg4), __privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), this, __privateGet2(this, _layMng2), __privateGet2(this, _val2), __privateGet2(this, _sndMng), __privateGet2(this, _scrItr2), this.sys));\n  __privateGet2(this, _appPixi3).ticker.add(__privateGet2(this, _fncTicker2));\n  this.resumeByJumpOrCall({ fn: \"main\" });\n  __privateSet2(this, _inited, true);\n};\n_fncTicker2 = new WeakMap();\n_fncresume = new WeakMap();\n_isLoop = new WeakMap();\n_runAnalyze = new WeakSet();\nrunAnalyze_fn = function() {\n  var _a3;\n  while (__privateGet2(this, _isLoop)) {\n    let token = __privateGet2(this, _scrItr2).nextToken();\n    if (!token)\n      break;\n    const uc = token.charCodeAt(0);\n    if (uc === 9)\n      continue;\n    if (uc === 10) {\n      __privateGet2(this, _scrItr2).addLineNum(token.length);\n      continue;\n    }\n    if (uc === 91) {\n      if (__privateGet2(this, _scrItr2).isBreak(token))\n        return;\n      try {\n        const cl = ((_a3 = token.match(/\\n/g)) != null ? _a3 : []).length;\n        if (cl > 0)\n          __privateGet2(this, _scrItr2).addLineNum(cl);\n        if (__privateGet2(this, _scrItr2).\\u30BF\\u30B0\\u89E3\\u6790(token)) {\n          this.stop();\n          break;\n        }\n        continue;\n      } catch (err) {\n        if (err instanceof Error) {\n          const e = err;\n          let mes = `\\u30BF\\u30B0\\u89E3\\u6790\\u4E2D\\u4F8B\\u5916 mes=${e.message}(${e.name})`;\n          mes = `[${tagToken2Name(token)}]` + mes;\n          this.errScript(mes, false);\n        } else\n          this.errScript(String(err), false);\n        return;\n      }\n    }\n    if (uc === 38) {\n      try {\n        if (token.slice(-1) !== \"&\") {\n          if (__privateGet2(this, _scrItr2).isBreak(token))\n            return;\n          const o = splitAmpersand(token.slice(1));\n          o.name = __privateGet2(this, _prpPrs).getValAmpersand(o.name);\n          o.text = String(__privateGet2(this, _prpPrs).parse(o.text));\n          __privateGet2(this, _hTag2).let(o);\n          continue;\n        }\n        if (token.charAt(1) === \"&\")\n          throw new Error(\"\\u300C&\\u8868\\u793A&\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\");\n        token = String(__privateGet2(this, _prpPrs).parse(token.slice(1, -1)));\n      } catch (err) {\n        this.errScript(err instanceof Error ? `& \\u5909\\u6570\\u64CD\\u4F5C\\u30FB\\u8868\\u793A mes=${err.message}(${err.name})` : err, false);\n        return;\n      }\n    } else if (uc === 59)\n      continue;\n    else if (uc === 42 && token.length > 1)\n      continue;\n    try {\n      const tl = __privateGet2(this, _layMng2).currentTxtlayForeNeedErr;\n      tl.tagCh(token);\n    } catch (err) {\n      this.errScript(err instanceof Error ? `\\u6587\\u5B57\\u8868\\u793A mes=${err.message}(${err.name})` : err, false);\n      return;\n    }\n  }\n};\n_destroyed = new WeakMap();\n_clone_cvs = new WeakMap();\nvar assign = make_assign();\nvar create$1 = make_create();\nvar trim$1 = make_trim();\nvar Global$5 = typeof window !== \"undefined\" ? window : commonjsGlobal;\nvar util$6 = {\n  assign,\n  create: create$1,\n  trim: trim$1,\n  bind: bind$1,\n  slice: slice$1,\n  each: each$7,\n  map,\n  pluck: pluck$1,\n  isList: isList$1,\n  isFunction: isFunction$1,\n  isObject: isObject$1,\n  Global: Global$5\n};\nfunction make_assign() {\n  if (Object.assign) {\n    return Object.assign;\n  } else {\n    return function shimAssign(obj, props1, props2, etc) {\n      for (var i2 = 1; i2 < arguments.length; i2++) {\n        each$7(Object(arguments[i2]), function(val, key) {\n          obj[key] = val;\n        });\n      }\n      return obj;\n    };\n  }\n}\nfunction make_create() {\n  if (Object.create) {\n    return function create2(obj, assignProps1, assignProps2, etc) {\n      var assignArgsList = slice$1(arguments, 1);\n      return assign.apply(this, [Object.create(obj)].concat(assignArgsList));\n    };\n  } else {\n    let F2 = function() {\n    };\n    return function create2(obj, assignProps1, assignProps2, etc) {\n      var assignArgsList = slice$1(arguments, 1);\n      F2.prototype = obj;\n      return assign.apply(this, [new F2()].concat(assignArgsList));\n    };\n  }\n}\nfunction make_trim() {\n  if (String.prototype.trim) {\n    return function trim2(str2) {\n      return String.prototype.trim.call(str2);\n    };\n  } else {\n    return function trim2(str2) {\n      return str2.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n    };\n  }\n}\nfunction bind$1(obj, fn2) {\n  return function() {\n    return fn2.apply(obj, Array.prototype.slice.call(arguments, 0));\n  };\n}\nfunction slice$1(arr, index) {\n  return Array.prototype.slice.call(arr, index || 0);\n}\nfunction each$7(obj, fn2) {\n  pluck$1(obj, function(val, key) {\n    fn2(val, key);\n    return false;\n  });\n}\nfunction map(obj, fn2) {\n  var res = isList$1(obj) ? [] : {};\n  pluck$1(obj, function(v2, k) {\n    res[k] = fn2(v2, k);\n    return false;\n  });\n  return res;\n}\nfunction pluck$1(obj, fn2) {\n  if (isList$1(obj)) {\n    for (var i2 = 0; i2 < obj.length; i2++) {\n      if (fn2(obj[i2], i2)) {\n        return obj[i2];\n      }\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (fn2(obj[key], key)) {\n          return obj[key];\n        }\n      }\n    }\n  }\n}\nfunction isList$1(val) {\n  return val != null && typeof val != \"function\" && typeof val.length == \"number\";\n}\nfunction isFunction$1(val) {\n  return val && {}.toString.call(val) === \"[object Function]\";\n}\nfunction isObject$1(val) {\n  return val && {}.toString.call(val) === \"[object Object]\";\n}\nvar util$5 = util$6;\nvar slice = util$5.slice;\nvar pluck = util$5.pluck;\nvar each$6 = util$5.each;\nvar bind = util$5.bind;\nvar create = util$5.create;\nvar isList = util$5.isList;\nvar isFunction = util$5.isFunction;\nvar isObject = util$5.isObject;\nvar storeEngine = {\n  createStore\n};\nvar storeAPI = {\n  version: \"2.0.12\",\n  enabled: false,\n  get: function(key, optionalDefaultValue) {\n    var data = this.storage.read(this._namespacePrefix + key);\n    return this._deserialize(data, optionalDefaultValue);\n  },\n  set: function(key, value2) {\n    if (value2 === void 0) {\n      return this.remove(key);\n    }\n    this.storage.write(this._namespacePrefix + key, this._serialize(value2));\n    return value2;\n  },\n  remove: function(key) {\n    this.storage.remove(this._namespacePrefix + key);\n  },\n  each: function(callback) {\n    var self2 = this;\n    this.storage.each(function(val, namespacedKey) {\n      callback.call(self2, self2._deserialize(val), (namespacedKey || \"\").replace(self2._namespaceRegexp, \"\"));\n    });\n  },\n  clearAll: function() {\n    this.storage.clearAll();\n  },\n  hasNamespace: function(namespace) {\n    return this._namespacePrefix == \"__storejs_\" + namespace + \"_\";\n  },\n  createStore: function() {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function(plugin) {\n    this._addPlugin(plugin);\n  },\n  namespace: function(namespace) {\n    return createStore(this.storage, this.plugins, namespace);\n  }\n};\nfunction _warn() {\n  var _console = typeof console == \"undefined\" ? null : console;\n  if (!_console) {\n    return;\n  }\n  var fn2 = _console.warn ? _console.warn : _console.log;\n  fn2.apply(_console, arguments);\n}\nfunction createStore(storages2, plugins2, namespace) {\n  if (!namespace) {\n    namespace = \"\";\n  }\n  if (storages2 && !isList(storages2)) {\n    storages2 = [storages2];\n  }\n  if (plugins2 && !isList(plugins2)) {\n    plugins2 = [plugins2];\n  }\n  var namespacePrefix = namespace ? \"__storejs_\" + namespace + \"_\" : \"\";\n  var namespaceRegexp = namespace ? new RegExp(\"^\" + namespacePrefix) : null;\n  var legalNamespaces = /^[a-zA-Z0-9_\\-]*$/;\n  if (!legalNamespaces.test(namespace)) {\n    throw new Error(\"store.js namespaces can only have alphanumerics + underscores and dashes\");\n  }\n  var _privateStoreProps = {\n    _namespacePrefix: namespacePrefix,\n    _namespaceRegexp: namespaceRegexp,\n    _testStorage: function(storage) {\n      try {\n        var testStr = \"__storejs__test__\";\n        storage.write(testStr, testStr);\n        var ok = storage.read(testStr) === testStr;\n        storage.remove(testStr);\n        return ok;\n      } catch (e) {\n        return false;\n      }\n    },\n    _assignPluginFnProp: function(pluginFnProp, propName) {\n      var oldFn = this[propName];\n      this[propName] = function pluginFn() {\n        var args = slice(arguments, 0);\n        var self2 = this;\n        function super_fn() {\n          if (!oldFn) {\n            return;\n          }\n          each$6(arguments, function(arg, i2) {\n            args[i2] = arg;\n          });\n          return oldFn.apply(self2, args);\n        }\n        var newFnArgs = [super_fn].concat(args);\n        return pluginFnProp.apply(self2, newFnArgs);\n      };\n    },\n    _serialize: function(obj) {\n      return JSON.stringify(obj);\n    },\n    _deserialize: function(strVal, defaultVal) {\n      if (!strVal) {\n        return defaultVal;\n      }\n      var val = \"\";\n      try {\n        val = JSON.parse(strVal);\n      } catch (e) {\n        val = strVal;\n      }\n      return val !== void 0 ? val : defaultVal;\n    },\n    _addStorage: function(storage) {\n      if (this.enabled) {\n        return;\n      }\n      if (this._testStorage(storage)) {\n        this.storage = storage;\n        this.enabled = true;\n      }\n    },\n    _addPlugin: function(plugin) {\n      var self2 = this;\n      if (isList(plugin)) {\n        each$6(plugin, function(plugin2) {\n          self2._addPlugin(plugin2);\n        });\n        return;\n      }\n      var seenPlugin = pluck(this.plugins, function(seenPlugin2) {\n        return plugin === seenPlugin2;\n      });\n      if (seenPlugin) {\n        return;\n      }\n      this.plugins.push(plugin);\n      if (!isFunction(plugin)) {\n        throw new Error(\"Plugins must be function values that return objects\");\n      }\n      var pluginProperties = plugin.call(this);\n      if (!isObject(pluginProperties)) {\n        throw new Error(\"Plugins must return an object of function properties\");\n      }\n      each$6(pluginProperties, function(pluginFnProp, propName) {\n        if (!isFunction(pluginFnProp)) {\n          throw new Error(\"Bad plugin property: \" + propName + \" from plugin \" + plugin.name + \". Plugins should only return functions.\");\n        }\n        self2._assignPluginFnProp(pluginFnProp, propName);\n      });\n    },\n    addStorage: function(storage) {\n      _warn(\"store.addStorage(storage) is deprecated. Use createStore([storages])\");\n      this._addStorage(storage);\n    }\n  };\n  var store = create(_privateStoreProps, storeAPI, {\n    plugins: []\n  });\n  store.raw = {};\n  each$6(store, function(prop, propName) {\n    if (isFunction(prop)) {\n      store.raw[propName] = bind(store, prop);\n    }\n  });\n  each$6(storages2, function(storage) {\n    store._addStorage(storage);\n  });\n  each$6(plugins2, function(plugin) {\n    store._addPlugin(plugin);\n  });\n  return store;\n}\nvar util$4 = util$6;\nvar Global$4 = util$4.Global;\nvar localStorage_1 = {\n  name: \"localStorage\",\n  read: read$5,\n  write: write$5,\n  each: each$5,\n  remove: remove$5,\n  clearAll: clearAll$5\n};\nfunction localStorage() {\n  return Global$4.localStorage;\n}\nfunction read$5(key) {\n  return localStorage().getItem(key);\n}\nfunction write$5(key, data) {\n  return localStorage().setItem(key, data);\n}\nfunction each$5(fn2) {\n  for (var i2 = localStorage().length - 1; i2 >= 0; i2--) {\n    var key = localStorage().key(i2);\n    fn2(read$5(key), key);\n  }\n}\nfunction remove$5(key) {\n  return localStorage().removeItem(key);\n}\nfunction clearAll$5() {\n  return localStorage().clear();\n}\nvar util$3 = util$6;\nvar Global$3 = util$3.Global;\nvar oldFFGlobalStorage = {\n  name: \"oldFF-globalStorage\",\n  read: read$4,\n  write: write$4,\n  each: each$4,\n  remove: remove$4,\n  clearAll: clearAll$4\n};\nvar globalStorage = Global$3.globalStorage;\nfunction read$4(key) {\n  return globalStorage[key];\n}\nfunction write$4(key, data) {\n  globalStorage[key] = data;\n}\nfunction each$4(fn2) {\n  for (var i2 = globalStorage.length - 1; i2 >= 0; i2--) {\n    var key = globalStorage.key(i2);\n    fn2(globalStorage[key], key);\n  }\n}\nfunction remove$4(key) {\n  return globalStorage.removeItem(key);\n}\nfunction clearAll$4() {\n  each$4(function(key, _2) {\n    delete globalStorage[key];\n  });\n}\nvar util$2 = util$6;\nvar Global$2 = util$2.Global;\nvar oldIEUserDataStorage = {\n  name: \"oldIE-userDataStorage\",\n  write: write$3,\n  read: read$3,\n  each: each$3,\n  remove: remove$3,\n  clearAll: clearAll$3\n};\nvar storageName = \"storejs\";\nvar doc$1 = Global$2.document;\nvar _withStorageEl = _makeIEStorageElFunction();\nvar disable = (Global$2.navigator ? Global$2.navigator.userAgent : \"\").match(/ (MSIE 8|MSIE 9|MSIE 10)\\./);\nfunction write$3(unfixedKey, data) {\n  if (disable) {\n    return;\n  }\n  var fixedKey = fixKey(unfixedKey);\n  _withStorageEl(function(storageEl) {\n    storageEl.setAttribute(fixedKey, data);\n    storageEl.save(storageName);\n  });\n}\nfunction read$3(unfixedKey) {\n  if (disable) {\n    return;\n  }\n  var fixedKey = fixKey(unfixedKey);\n  var res = null;\n  _withStorageEl(function(storageEl) {\n    res = storageEl.getAttribute(fixedKey);\n  });\n  return res;\n}\nfunction each$3(callback) {\n  _withStorageEl(function(storageEl) {\n    var attributes = storageEl.XMLDocument.documentElement.attributes;\n    for (var i2 = attributes.length - 1; i2 >= 0; i2--) {\n      var attr = attributes[i2];\n      callback(storageEl.getAttribute(attr.name), attr.name);\n    }\n  });\n}\nfunction remove$3(unfixedKey) {\n  var fixedKey = fixKey(unfixedKey);\n  _withStorageEl(function(storageEl) {\n    storageEl.removeAttribute(fixedKey);\n    storageEl.save(storageName);\n  });\n}\nfunction clearAll$3() {\n  _withStorageEl(function(storageEl) {\n    var attributes = storageEl.XMLDocument.documentElement.attributes;\n    storageEl.load(storageName);\n    for (var i2 = attributes.length - 1; i2 >= 0; i2--) {\n      storageEl.removeAttribute(attributes[i2].name);\n    }\n    storageEl.save(storageName);\n  });\n}\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\");\nfunction fixKey(key) {\n  return key.replace(/^\\d/, \"___$&\").replace(forbiddenCharsRegex, \"___\");\n}\nfunction _makeIEStorageElFunction() {\n  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior) {\n    return null;\n  }\n  var scriptTag = \"script\", storageOwner, storageContainer, storageEl;\n  try {\n    storageContainer = new ActiveXObject(\"htmlfile\");\n    storageContainer.open();\n    storageContainer.write(\"<\" + scriptTag + \">document.w=window</\" + scriptTag + '><iframe src=\"/favicon.ico\"></iframe>');\n    storageContainer.close();\n    storageOwner = storageContainer.w.frames[0].document;\n    storageEl = storageOwner.createElement(\"div\");\n  } catch (e) {\n    storageEl = doc$1.createElement(\"div\");\n    storageOwner = doc$1.body;\n  }\n  return function(storeFunction) {\n    var args = [].slice.call(arguments, 0);\n    args.unshift(storageEl);\n    storageOwner.appendChild(storageEl);\n    storageEl.addBehavior(\"#default#userData\");\n    storageEl.load(storageName);\n    storeFunction.apply(this, args);\n    storageOwner.removeChild(storageEl);\n    return;\n  };\n}\nvar util$1 = util$6;\nvar Global$1 = util$1.Global;\nvar trim = util$1.trim;\nvar cookieStorage = {\n  name: \"cookieStorage\",\n  read: read$2,\n  write: write$2,\n  each: each$2,\n  remove: remove$2,\n  clearAll: clearAll$2\n};\nvar doc = Global$1.document;\nfunction read$2(key) {\n  if (!key || !_has(key)) {\n    return null;\n  }\n  var regexpStr = \"(?:^|.*;\\\\s*)\" + escape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\";\n  return unescape(doc.cookie.replace(new RegExp(regexpStr), \"$1\"));\n}\nfunction each$2(callback) {\n  var cookies = doc.cookie.split(/; ?/g);\n  for (var i2 = cookies.length - 1; i2 >= 0; i2--) {\n    if (!trim(cookies[i2])) {\n      continue;\n    }\n    var kvp = cookies[i2].split(\"=\");\n    var key = unescape(kvp[0]);\n    var val = unescape(kvp[1]);\n    callback(val, key);\n  }\n}\nfunction write$2(key, data) {\n  if (!key) {\n    return;\n  }\n  doc.cookie = escape(key) + \"=\" + escape(data) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\";\n}\nfunction remove$2(key) {\n  if (!key || !_has(key)) {\n    return;\n  }\n  doc.cookie = escape(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\";\n}\nfunction clearAll$2() {\n  each$2(function(_2, key) {\n    remove$2(key);\n  });\n}\nfunction _has(key) {\n  return new RegExp(\"(?:^|;\\\\s*)\" + escape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\").test(doc.cookie);\n}\nvar util = util$6;\nvar Global = util.Global;\nvar sessionStorage_1 = {\n  name: \"sessionStorage\",\n  read: read$1,\n  write: write$1,\n  each: each$1,\n  remove: remove$1,\n  clearAll: clearAll$1\n};\nfunction sessionStorage$1() {\n  return Global.sessionStorage;\n}\nfunction read$1(key) {\n  return sessionStorage$1().getItem(key);\n}\nfunction write$1(key, data) {\n  return sessionStorage$1().setItem(key, data);\n}\nfunction each$1(fn2) {\n  for (var i2 = sessionStorage$1().length - 1; i2 >= 0; i2--) {\n    var key = sessionStorage$1().key(i2);\n    fn2(read$1(key), key);\n  }\n}\nfunction remove$1(key) {\n  return sessionStorage$1().removeItem(key);\n}\nfunction clearAll$1() {\n  return sessionStorage$1().clear();\n}\nvar memoryStorage_1 = {\n  name: \"memoryStorage\",\n  read,\n  write,\n  each,\n  remove,\n  clearAll\n};\nvar memoryStorage = {};\nfunction read(key) {\n  return memoryStorage[key];\n}\nfunction write(key, data) {\n  memoryStorage[key] = data;\n}\nfunction each(callback) {\n  for (var key in memoryStorage) {\n    if (memoryStorage.hasOwnProperty(key)) {\n      callback(memoryStorage[key], key);\n    }\n  }\n}\nfunction remove(key) {\n  delete memoryStorage[key];\n}\nfunction clearAll(key) {\n  memoryStorage = {};\n}\nvar all = [\n  localStorage_1,\n  oldFFGlobalStorage,\n  oldIEUserDataStorage,\n  cookieStorage,\n  sessionStorage_1,\n  memoryStorage_1\n];\nif (typeof JSON !== \"object\") {\n  JSON = {};\n}\n(function() {\n  var rx_one = /^[\\],:{}\\s]*$/;\n  var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n  var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n  var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n  var rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n  var rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n  function f(n) {\n    return n < 10 ? \"0\" + n : n;\n  }\n  function this_value() {\n    return this.valueOf();\n  }\n  if (typeof Date.prototype.toJSON !== \"function\") {\n    Date.prototype.toJSON = function() {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n    };\n    Boolean.prototype.toJSON = this_value;\n    Number.prototype.toJSON = this_value;\n    String.prototype.toJSON = this_value;\n  }\n  var gap;\n  var indent;\n  var meta;\n  var rep;\n  function quote(string) {\n    rx_escapable.lastIndex = 0;\n    return rx_escapable.test(string) ? '\"' + string.replace(rx_escapable, function(a2) {\n      var c2 = meta[a2];\n      return typeof c2 === \"string\" ? c2 : \"\\\\u\" + (\"0000\" + a2.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n  }\n  function str(key, holder) {\n    var i2;\n    var k;\n    var v2;\n    var length2;\n    var mind = gap;\n    var partial;\n    var value2 = holder[key];\n    if (value2 && typeof value2 === \"object\" && typeof value2.toJSON === \"function\") {\n      value2 = value2.toJSON(key);\n    }\n    if (typeof rep === \"function\") {\n      value2 = rep.call(holder, key, value2);\n    }\n    switch (typeof value2) {\n      case \"string\":\n        return quote(value2);\n      case \"number\":\n        return isFinite(value2) ? String(value2) : \"null\";\n      case \"boolean\":\n      case \"null\":\n        return String(value2);\n      case \"object\":\n        if (!value2) {\n          return \"null\";\n        }\n        gap += indent;\n        partial = [];\n        if (Object.prototype.toString.apply(value2) === \"[object Array]\") {\n          length2 = value2.length;\n          for (i2 = 0; i2 < length2; i2 += 1) {\n            partial[i2] = str(i2, value2) || \"null\";\n          }\n          v2 = partial.length === 0 ? \"[]\" : gap ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" : \"[\" + partial.join(\",\") + \"]\";\n          gap = mind;\n          return v2;\n        }\n        if (rep && typeof rep === \"object\") {\n          length2 = rep.length;\n          for (i2 = 0; i2 < length2; i2 += 1) {\n            if (typeof rep[i2] === \"string\") {\n              k = rep[i2];\n              v2 = str(k, value2);\n              if (v2) {\n                partial.push(quote(k) + (gap ? \": \" : \":\") + v2);\n              }\n            }\n          }\n        } else {\n          for (k in value2) {\n            if (Object.prototype.hasOwnProperty.call(value2, k)) {\n              v2 = str(k, value2);\n              if (v2) {\n                partial.push(quote(k) + (gap ? \": \" : \":\") + v2);\n              }\n            }\n          }\n        }\n        v2 = partial.length === 0 ? \"{}\" : gap ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" : \"{\" + partial.join(\",\") + \"}\";\n        gap = mind;\n        return v2;\n    }\n  }\n  if (typeof JSON.stringify !== \"function\") {\n    meta = {\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    };\n    JSON.stringify = function(value2, replacer, space) {\n      var i2;\n      gap = \"\";\n      indent = \"\";\n      if (typeof space === \"number\") {\n        for (i2 = 0; i2 < space; i2 += 1) {\n          indent += \" \";\n        }\n      } else if (typeof space === \"string\") {\n        indent = space;\n      }\n      rep = replacer;\n      if (replacer && typeof replacer !== \"function\" && (typeof replacer !== \"object\" || typeof replacer.length !== \"number\")) {\n        throw new Error(\"JSON.stringify\");\n      }\n      return str(\"\", { \"\": value2 });\n    };\n  }\n  if (typeof JSON.parse !== \"function\") {\n    JSON.parse = function(text, reviver) {\n      var j;\n      function walk(holder, key) {\n        var k;\n        var v2;\n        var value2 = holder[key];\n        if (value2 && typeof value2 === \"object\") {\n          for (k in value2) {\n            if (Object.prototype.hasOwnProperty.call(value2, k)) {\n              v2 = walk(value2, k);\n              if (v2 !== void 0) {\n                value2[k] = v2;\n              } else {\n                delete value2[k];\n              }\n            }\n          }\n        }\n        return reviver.call(holder, key, value2);\n      }\n      text = String(text);\n      rx_dangerous.lastIndex = 0;\n      if (rx_dangerous.test(text)) {\n        text = text.replace(rx_dangerous, function(a2) {\n          return \"\\\\u\" + (\"0000\" + a2.charCodeAt(0).toString(16)).slice(-4);\n        });\n      }\n      if (rx_one.test(text.replace(rx_two, \"@\").replace(rx_three, \"]\").replace(rx_four, \"\"))) {\n        j = eval(\"(\" + text + \")\");\n        return typeof reviver === \"function\" ? walk({ \"\": j }, \"\") : j;\n      }\n      throw new SyntaxError(\"JSON.parse\");\n    };\n  }\n})();\nvar json2 = json2Plugin;\nfunction json2Plugin() {\n  return {};\n}\nvar engine = storeEngine;\nvar storages = all;\nvar plugins = [json2];\nvar store_legacy = engine.createStore(storages, plugins);\n/*!\ndevtools-detect\nhttps://github.com/sindresorhus/devtools-detect\nBy Sindre Sorhus\nMIT License\n*/\nconst devtools = {\n  isOpen: false,\n  orientation: void 0\n};\nconst threshold = 160;\nconst emitEvent = (isOpen, orientation) => {\n  globalThis.dispatchEvent(new globalThis.CustomEvent(\"devtoolschange\", {\n    detail: {\n      isOpen,\n      orientation\n    }\n  }));\n};\nconst main = ({ emitEvents = true } = {}) => {\n  const widthThreshold = globalThis.outerWidth - globalThis.innerWidth > threshold;\n  const heightThreshold = globalThis.outerHeight - globalThis.innerHeight > threshold;\n  const orientation = widthThreshold ? \"vertical\" : \"horizontal\";\n  if (!(heightThreshold && widthThreshold) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || widthThreshold || heightThreshold)) {\n    if ((!devtools.isOpen || devtools.orientation !== orientation) && emitEvents) {\n      emitEvent(true, orientation);\n    }\n    devtools.isOpen = true;\n    devtools.orientation = orientation;\n  } else {\n    if (devtools.isOpen && emitEvents) {\n      emitEvent(false, void 0);\n    }\n    devtools.isOpen = false;\n    devtools.orientation = void 0;\n  }\n};\nmain({ emitEvents: false });\nsetInterval(main, 500);\nclass SysWeb extends SysBase {\n  constructor(hPlg = {}, arg = { cur: \"prj/\", crypto: false, dip: \"\" }) {\n    super(hPlg, arg);\n    __privateAdd2(this, _path_base, void 0);\n    __privateAdd2(this, _now_prj, void 0);\n    __privateAdd2(this, _main3, void 0);\n    __privateAdd2(this, _hAppendFile, void 0);\n    __privateSet2(this, _path_base, \"\");\n    __privateSet2(this, _now_prj, \":\");\n    this.run = async () => {\n      if (__privateGet2(this, _main3)) {\n        const ms_late = 10;\n        __privateGet2(this, _main3).destroy(ms_late);\n        await new Promise((r2) => setTimeout(r2, ms_late));\n      }\n      __privateSet2(this, _main3, new Main(this));\n    };\n    __privateSet2(this, _main3, void 0);\n    this.pathBaseCnvSnPath4Dbg = \"${pathbase}/\";\n    this._export = () => {\n      (async () => {\n        const s2 = JSON.stringify({\n          \"sys\": this.data.sys,\n          \"mark\": this.data.mark,\n          \"kidoku\": this.data.kidoku\n        });\n        const s22 = this.crypto ? await this.enc(s2) : s2;\n        const blob = new Blob([s22], { \"type\": \"text/json\" });\n        const a3 = document.createElement(\"a\");\n        a3.href = URL.createObjectURL(blob);\n        a3.download = (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + getDateStr(\"-\", \"_\", \"\") + \".swpd\";\n        a3.click();\n        if (CmnLib.debugLog)\n          console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A8\\u30AF\\u30B9\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\");\n        setTimeout(() => this.fire(\"sn:exported\", new Event(\"click\")), 10);\n      })();\n      return false;\n    };\n    this._import = () => {\n      new Promise((rs, rj) => {\n        const inp = document.createElement(\"input\");\n        inp.type = \"file\";\n        inp.accept = \".swpd, text/plain\";\n        inp.onchange = () => {\n          if (inp.files)\n            rs(inp.files[0].path);\n          else\n            rj();\n        };\n        inp.click();\n      }).then((file) => new Promise((rs) => {\n        const rd = new FileReader();\n        rd.readAsText(file);\n        rd.onload = () => rs(rd.result);\n      })).then(async (s2) => {\n        const o = JSON.parse(this.crypto ? this.decStr(\"json\", s2) : s2);\n        if (!o.sys || !o.mark || !o.kidoku)\n          throw new Error(\"\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059\");\n        if (o.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {\n          console.error(`\\u5225\\u306E\\u30B2\\u30FC\\u30E0\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u540D=${o.sys[SysBase.VALNM_CFG_NS]}\\u3011\\u306E\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059`);\n          return;\n        }\n        this.data.sys = o.sys;\n        this.data.mark = o.mark;\n        this.data.kidoku = o.kidoku;\n        this.flush();\n        this.val.updateData(o);\n        if (CmnLib.debugLog)\n          console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A4\\u30F3\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\");\n        this.fire(\"sn:imported\", new Event(\"click\"));\n      }).catch((e) => console.error(`\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059 ${e.message}`));\n      return false;\n    };\n    this.navigate_to = (hArg) => {\n      const { url: url2 } = hArg;\n      if (!url2)\n        throw \"[navigate_to] url\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      globalThis.open(url2, \"_blank\");\n      return false;\n    };\n    __privateSet2(this, _hAppendFile, {});\n    const a2 = arg.cur.split(\"/\");\n    __privateSet2(this, _path_base, a2.length > 2 ? a2.slice(0, -2).join(\"/\") + \"/\" : \"\");\n    globalThis.onload = async () => this.loaded(hPlg, arg);\n  }\n  async loaded(hPlg, arg) {\n    await super.loaded(hPlg, arg);\n    document.querySelectorAll(\"[data-prj]\").forEach((v2) => {\n      const elm = v2.attributes.getNamedItem(\"data-prj\");\n      if (elm)\n        v2.addEventListener(\"click\", () => this.runSN(elm.value), { passive: true });\n    });\n    document.querySelectorAll(\"[data-reload]\").forEach((v2) => v2.addEventListener(\"click\", () => this.run(), { passive: true }));\n    if (arg.dip)\n      CmnLib.hDip = JSON.parse(arg.dip);\n    const sp = new URLSearchParams(location.search);\n    const dip = sp.get(\"dip\");\n    if (dip)\n      CmnLib.hDip = __spreadValues(__spreadValues({}, CmnLib.hDip), JSON.parse(dip.replaceAll(`%2C`, \",\")));\n    if (!argChk_Boolean(CmnLib.hDip, \"oninit_run\", true))\n      return;\n    if (argChk_Boolean(CmnLib.hDip, \"dbg\", false)) {\n      CmnLib.isDbg = true;\n      this.fetch = (url2) => fetch(url2, { mode: \"cors\" });\n    }\n    this.extPort = argChk_Num(CmnLib.hDip, \"port\", this.extPort);\n    const cur = sp.get(\"cur\");\n    if (cur)\n      arg.cur = __privateGet2(this, _path_base) + cur + \"/\";\n    this.run();\n  }\n  runSN(prj) {\n    this.arg.cur = __privateGet2(this, _path_base) + prj + \"/\";\n    if (__privateGet2(this, _now_prj) === this.arg.cur)\n      return;\n    __privateSet2(this, _now_prj, this.arg.cur);\n    this.run();\n  }\n  stop() {\n    if (!__privateGet2(this, _main3))\n      return;\n    __privateGet2(this, _main3).destroy();\n    __privateSet2(this, _main3, void 0);\n  }\n  async loadPath(hPathFn2Exts, cfg) {\n    await super.loadPath(hPathFn2Exts, cfg);\n    const fn2 = this.arg.cur + \"path.json\";\n    const res = await fetch(fn2);\n    if (!res.ok)\n      throw Error(res.statusText);\n    const src = await res.text();\n    const oJs = JSON.parse(this.decStr(fn2, src));\n    for (const nm in oJs) {\n      const h2 = hPathFn2Exts[nm] = oJs[nm];\n      for (const ext in h2)\n        if (ext !== \":cnt\")\n          h2[ext] = this.arg.cur + h2[ext];\n    }\n  }\n  initVal(data, hTmp, comp) {\n    const hn = encodeURIComponent(document.location.hostname);\n    hTmp[\"const.sn.isDebugger\"] = hn === \"localhost\" || hn === \"127.0.0.1\";\n    const ns = this.cfg.getNs();\n    this.flush = this.crypto ? async () => {\n      store_legacy.set(ns + \"sys_\", this.enc(JSON.stringify(this.data.sys)));\n      store_legacy.set(ns + \"mark_\", this.enc(JSON.stringify(this.data.mark)));\n      store_legacy.set(ns + \"kidoku_\", this.enc(JSON.stringify(this.data.kidoku)));\n    } : () => {\n      store_legacy.set(ns + \"sys\", this.data.sys);\n      store_legacy.set(ns + \"mark\", this.data.mark);\n      store_legacy.set(ns + \"kidoku\", this.data.kidoku);\n    };\n    const nm = ns + (this.arg.crypto ? \"sys_\" : \"sys\");\n    if (hTmp[\"const.sn.isFirstBoot\"] = store_legacy.get(nm) === void 0) {\n      this.data.sys = data.sys;\n      this.data.mark = data.mark;\n      this.data.kidoku = data.kidoku;\n      this.flush();\n      comp(this.data);\n      return;\n    }\n    if (!this.crypto) {\n      this.data.sys = store_legacy.get(ns + \"sys\");\n      this.data.mark = store_legacy.get(ns + \"mark\");\n      this.data.kidoku = store_legacy.get(ns + \"kidoku\");\n      comp(this.data);\n      return;\n    }\n    let mes = \"\";\n    try {\n      mes = \"sys\";\n      this.data.sys = JSON.parse(this.decStr(\"json\", store_legacy.get(ns + \"sys_\")));\n      mes += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1));\n      mes = \"mark\";\n      this.data.mark = JSON.parse(this.decStr(\"json\", store_legacy.get(ns + \"mark_\")));\n      mes = \"kidoku\";\n      this.data.kidoku = JSON.parse(this.decStr(\"json\", store_legacy.get(ns + \"kidoku_\")));\n    } catch (e) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${mes}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, e);\n    }\n    comp(this.data);\n  }\n  init(hTag, appPixi, val, main2) {\n    super.init(hTag, appPixi, val, main2);\n    const pCvs = appPixi.view.parentElement;\n    if (\"requestFullscreen\" in document.body) {\n      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : pCvs.requestFullscreen();\n      document.addEventListener(\"fullscreenchange\", () => this.isFullScr = Boolean(document.fullscreenElement));\n    } else {\n      const doc2 = document;\n      this.tglFlscr_sub = () => this.isFullScr ? doc2.webkitCancelFullScreen() : pCvs.webkitRequestFullscreen();\n      document.addEventListener(\"fullscreenchange\", () => this.isFullScr = Boolean(doc2.webkitFullscreenElement));\n    }\n    if (!this.cfg.oCfg.debug.devtool)\n      window.addEventListener(\"devtoolschange\", (e) => {\n        if (!e.detail.isOpen)\n          return;\n        console.error(`DevTool\\u306F\\u7981\\u6B62\\u3055\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u8A31\\u53EF\\u3059\\u308B\\u5834\\u5408\\u306F\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u8A2D\\u5B9A\\u3011\\u306E\\u3010devtool\\u3011\\u3092ON\\u306B\\u3002`);\n        main2.destroy();\n      }, { once: true, passive: true });\n    return [];\n  }\n  cvsResize() {\n    super.cvsResize();\n    if (this.isFullScr) {\n      const s2 = this.appPixi.view.style;\n      s2.width = s2.height = \"\";\n    }\n  }\n  titleSub(txt) {\n    document.title = txt;\n    document.querySelectorAll(\"[data-title]\").forEach((v2) => v2.textContent = txt);\n  }\n  async savePic(fn2, data_url) {\n    const a2 = document.createElement(\"a\");\n    a2.href = data_url;\n    a2.download = fn2;\n    a2.click();\n    if (CmnLib.debugLog)\n      console.log(\"\\u753B\\u50CF\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30C0\\u30A6\\u30F3\\u30ED\\u30FC\\u30C9\\u3057\\u307E\\u3059\");\n  }\n  async appendFile(path, data, _callback) {\n    var _a3;\n    const txt = ((_a3 = __privateGet2(this, _hAppendFile)[path]) != null ? _a3 : \"\") + data;\n    __privateGet2(this, _hAppendFile)[path] = txt;\n    const blob = new Blob([txt], { \"type\": \"text/json\" });\n    const a2 = document.createElement(\"a\");\n    a2.href = URL.createObjectURL(blob);\n    a2.download = path;\n    a2.click();\n  }\n}\n_path_base = new WeakMap();\n_now_prj = new WeakMap();\n_main3 = new WeakMap();\n_hAppendFile = new WeakMap();\n\n//# sourceMappingURL=web.js.map\n\n\n//# sourceURL=webpack://gallery/./node_modules/@famibee/skynovel/dist/web.js?");

/***/ })

}]);