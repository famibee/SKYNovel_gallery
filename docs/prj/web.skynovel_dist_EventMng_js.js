"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel_dist_EventMng_js"],{

/***/ "../skynovel/dist/EventMng.js":
/*!************************************!*\
  !*** ../skynovel/dist/EventMng.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventMng: () => (/* binding */ jr)\n/* harmony export */ });\n/* harmony import */ var _web2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web2.js */ \"../skynovel/dist/web2.js\");\n/* harmony import */ var _LayerMng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayerMng.js */ \"../skynovel/dist/LayerMng.js\");\n/* harmony import */ var _ReadState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReadState.js */ \"../skynovel/dist/ReadState.js\");\n\n\n\nclass Oe {\n  #e = [];\n  #t = -1;\n  #r = new _web2_js__WEBPACK_IMPORTED_MODULE_0__.E();\n  destroy() {\n    this.#e = [], this.#t = -1, this.#r.clear();\n  }\n  add(t, e, i) {\n    if (this.#e.findIndex((o) => o.btn === t) >= 0) return;\n    if (t instanceof _web2_js__WEBPACK_IMPORTED_MODULE_0__.j) {\n      t.on(\"pointerdown\", () => {\n        for (let o = this.#e.length - 1; o >= 0; --o)\n          if (this.#e[o].btn === t) {\n            this.#t = o;\n            return;\n          }\n        this.#t = -1;\n      }), this.#e.push({ btn: t, on: e, off: i });\n      return;\n    }\n    this.#r.add(t, \"focus\", () => {\n      for (let o = this.#e.length - 1; o >= 0; --o)\n        if (this.#e[o].btn === t) {\n          this.#t = o;\n          return;\n        }\n      this.#t = -1;\n    });\n    let n = (o) => {\n    }, a = t.localName === \"button\" || t.localName === \"a\" ? (o) => !o.isTrusted && o.key === \"Enter\" : (o) => o.key === \"Enter\";\n    const s = t;\n    switch (s.type ?? \"\") {\n      //\tswitch (btn.getAttribute('type') ?? '') {\t// textareaで''になる\n      case \"checkbox\":\n        n = () => s.checked = !s.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (n = (o) => this.#s(t, o.key), a = () => !1);\n        break;\n      case \"range\":\n        n = (o) => {\n          o.isTrusted || (o.key === \"ArrowUp\" ? s.stepUp() : s.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        n = (o) => {\n          if (o.isTrusted) return;\n          let f = (s.selectionStart ?? 0) + (o.key === \"ArrowUp\" ? -1 : 1);\n          f < 0 && (f = 0), s.setSelectionRange(f, f);\n        };\n        break;\n    }\n    this.#r.add(t, \"keydown\", (o) => {\n      if (!(o.key !== \"ArrowUp\" && o.key !== \"ArrowDown\" && o.key !== \"Enter\")) {\n        if (o.stopPropagation(), o.stopImmediatePropagation(), a(o)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        n(o);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), this.#e.push({ btn: t, on: e, off: i });\n  }\n  remove(t) {\n    const e = this.#e.findIndex((i) => i.btn === t);\n    e < 0 || (this.#e.splice(e, 1), this.#e.length === 0 ? this.#t = -1 : e <= this.#t && --this.#t);\n  }\n  #s(t, e) {\n    const i = t.querySelectorAll(\"input[type]\"), n = i.length;\n    for (let a = 0; a < n; ++a)\n      if (i[a].checked) {\n        i[(a + n + (e === \"ArrowUp\" ? -1 : 1)) % n].checked = !0;\n        break;\n      }\n  }\n  isFocus(t) {\n    return this.#t < 0 ? !1 : this.#e[this.#t].btn === t;\n  }\n  prev() {\n    this.#o();\n    const t = this.#e.length;\n    if (t !== 0) {\n      --this.#t < 0 && (this.#t = t - 1);\n      for (let e = t; e >= 1; --e) {\n        const i = (this.#t + e) % t;\n        if (this.#e[i].on()) {\n          this.#t = i, this.#a(i);\n          return;\n        }\n      }\n      this.#t = -1;\n    }\n  }\n  next() {\n    this.#o();\n    const t = this.#e.length;\n    if (t !== 0) {\n      ++this.#t >= t && (this.#t = 0);\n      for (let e = 0; e < t; ++e) {\n        const i = (this.#t + e) % t;\n        if (this.#e[i].on()) {\n          this.#t = i, this.#a(i);\n          return;\n        }\n      }\n      this.#t = -1;\n    }\n  }\n  #a = _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, this.#e[t].btn) : () => {\n  };\n  getFocus() {\n    if (this.#t < 0) return null;\n    this.#o(), this.#t >= this.#e.length && (this.#t = 0);\n    const t = this.#e[this.#t];\n    return t.on() ? t.btn : null;\n  }\n  blur() {\n    this.#o(), this.#t = -1, globalThis.focus();\n  }\n  #o() {\n    for (let t = this.#e.length - 1; t >= 0; --t) {\n      const e = this.#e[t];\n      !(e.btn instanceof _web2_js__WEBPACK_IMPORTED_MODULE_0__.j) || e.btn.parent ? e.off() : this.#e.splice(t, 1);\n    }\n  }\n}\nvar _ = \"top\", M = \"bottom\", H = \"right\", L = \"left\", Lt = \"auto\", ut = [_, M, H, L], tt = \"start\", lt = \"end\", Ee = \"clippingParents\", ie = \"viewport\", at = \"popper\", De = \"reference\", Xt = /* @__PURE__ */ ut.reduce(function(r, t) {\n  return r.concat([t + \"-\" + tt, t + \"-\" + lt]);\n}, []), ne = /* @__PURE__ */ [].concat(ut, [Lt]).reduce(function(r, t) {\n  return r.concat([t, t + \"-\" + tt, t + \"-\" + lt]);\n}, []), Se = \"beforeRead\", Ce = \"read\", Pe = \"afterRead\", _e = \"beforeMain\", Le = \"main\", Re = \"afterMain\", $e = \"beforeWrite\", je = \"write\", Te = \"afterWrite\", Me = [Se, Ce, Pe, _e, Le, Re, $e, je, Te];\nfunction N(r) {\n  return r ? (r.nodeName || \"\").toLowerCase() : null;\n}\nfunction $(r) {\n  if (r == null)\n    return window;\n  if (r.toString() !== \"[object Window]\") {\n    var t = r.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return r;\n}\nfunction Z(r) {\n  var t = $(r).Element;\n  return r instanceof t || r instanceof Element;\n}\nfunction T(r) {\n  var t = $(r).HTMLElement;\n  return r instanceof t || r instanceof HTMLElement;\n}\nfunction Rt(r) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = $(r).ShadowRoot;\n  return r instanceof t || r instanceof ShadowRoot;\n}\nfunction He(r) {\n  var t = r.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var i = t.styles[e] || {}, n = t.attributes[e] || {}, a = t.elements[e];\n    !T(a) || !N(a) || (Object.assign(a.style, i), Object.keys(n).forEach(function(s) {\n      var o = n[s];\n      o === !1 ? a.removeAttribute(s) : a.setAttribute(s, o === !0 ? \"\" : o);\n    }));\n  });\n}\nfunction Be(r) {\n  var t = r.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(i) {\n      var n = t.elements[i], a = t.attributes[i] || {}, s = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), o = s.reduce(function(f, p) {\n        return f[p] = \"\", f;\n      }, {});\n      !T(n) || !N(n) || (Object.assign(n.style, o), Object.keys(a).forEach(function(f) {\n        n.removeAttribute(f);\n      }));\n    });\n  };\n}\nconst Fe = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: He,\n  effect: Be,\n  requires: [\"computeStyles\"]\n};\nfunction W(r) {\n  return r.split(\"-\")[0];\n}\nvar G = Math.max, xt = Math.min, et = Math.round;\nfunction Pt() {\n  var r = navigator.userAgentData;\n  return r != null && r.brands && Array.isArray(r.brands) ? r.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction oe() {\n  return !/^((?!chrome|android).)*safari/i.test(Pt());\n}\nfunction rt(r, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var i = r.getBoundingClientRect(), n = 1, a = 1;\n  t && T(r) && (n = r.offsetWidth > 0 && et(i.width) / r.offsetWidth || 1, a = r.offsetHeight > 0 && et(i.height) / r.offsetHeight || 1);\n  var s = Z(r) ? $(r) : window, o = s.visualViewport, f = !oe() && e, p = (i.left + (f && o ? o.offsetLeft : 0)) / n, l = (i.top + (f && o ? o.offsetTop : 0)) / a, h = i.width / n, m = i.height / a;\n  return {\n    width: h,\n    height: m,\n    top: l,\n    right: p + h,\n    bottom: l + m,\n    left: p,\n    x: p,\n    y: l\n  };\n}\nfunction $t(r) {\n  var t = rt(r), e = r.offsetWidth, i = r.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {\n    x: r.offsetLeft,\n    y: r.offsetTop,\n    width: e,\n    height: i\n  };\n}\nfunction ae(r, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (r.contains(t))\n    return !0;\n  if (e && Rt(e)) {\n    var i = t;\n    do {\n      if (i && r.isSameNode(i))\n        return !0;\n      i = i.parentNode || i.host;\n    } while (i);\n  }\n  return !1;\n}\nfunction A(r) {\n  return $(r).getComputedStyle(r);\n}\nfunction We(r) {\n  return [\"table\", \"td\", \"th\"].indexOf(N(r)) >= 0;\n}\nfunction q(r) {\n  return ((Z(r) ? r.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    r.document\n  )) || window.document).documentElement;\n}\nfunction kt(r) {\n  return N(r) === \"html\" ? r : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    r.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    r.parentNode || // DOM Element detected\n    (Rt(r) ? r.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    q(r)\n  );\n}\nfunction zt(r) {\n  return !T(r) || // https://github.com/popperjs/popper-core/issues/837\n  A(r).position === \"fixed\" ? null : r.offsetParent;\n}\nfunction Ne(r) {\n  var t = /firefox/i.test(Pt()), e = /Trident/i.test(Pt());\n  if (e && T(r)) {\n    var i = A(r);\n    if (i.position === \"fixed\")\n      return null;\n  }\n  var n = kt(r);\n  for (Rt(n) && (n = n.host); T(n) && [\"html\", \"body\"].indexOf(N(n)) < 0; ) {\n    var a = A(n);\n    if (a.transform !== \"none\" || a.perspective !== \"none\" || a.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(a.willChange) !== -1 || t && a.willChange === \"filter\" || t && a.filter && a.filter !== \"none\")\n      return n;\n    n = n.parentNode;\n  }\n  return null;\n}\nfunction dt(r) {\n  for (var t = $(r), e = zt(r); e && We(e) && A(e).position === \"static\"; )\n    e = zt(e);\n  return e && (N(e) === \"html\" || N(e) === \"body\" && A(e).position === \"static\") ? t : e || Ne(r) || t;\n}\nfunction jt(r) {\n  return [\"top\", \"bottom\"].indexOf(r) >= 0 ? \"x\" : \"y\";\n}\nfunction ft(r, t, e) {\n  return G(r, xt(t, e));\n}\nfunction Ae(r, t, e) {\n  var i = ft(r, t, e);\n  return i > e ? e : i;\n}\nfunction se() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction fe(r) {\n  return Object.assign({}, se(), r);\n}\nfunction ce(r, t) {\n  return t.reduce(function(e, i) {\n    return e[i] = r, e;\n  }, {});\n}\nvar Ve = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, fe(typeof t != \"number\" ? t : ce(t, ut));\n};\nfunction qe(r) {\n  var t, e = r.state, i = r.name, n = r.options, a = e.elements.arrow, s = e.modifiersData.popperOffsets, o = W(e.placement), f = jt(o), p = [L, H].indexOf(o) >= 0, l = p ? \"height\" : \"width\";\n  if (!(!a || !s)) {\n    var h = Ve(n.padding, e), m = $t(a), d = f === \"y\" ? _ : L, c = f === \"y\" ? M : H, u = e.rects.reference[l] + e.rects.reference[f] - s[f] - e.rects.popper[l], v = s[f] - e.rects.reference[f], k = dt(a), g = k ? f === \"y\" ? k.clientHeight || 0 : k.clientWidth || 0 : 0, O = u / 2 - v / 2, y = h[d], w = g - m[l] - h[c], b = g / 2 - m[l] / 2 + O, x = ft(y, b, w), S = f;\n    e.modifiersData[i] = (t = {}, t[S] = x, t.centerOffset = x - b, t);\n  }\n}\nfunction Ue(r) {\n  var t = r.state, e = r.options, i = e.element, n = i === void 0 ? \"[data-popper-arrow]\" : i;\n  n != null && (typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n) || ae(t.elements.popper, n) && (t.elements.arrow = n));\n}\nconst Ie = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: qe,\n  effect: Ue,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction it(r) {\n  return r.split(\"-\")[1];\n}\nvar Ye = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction Xe(r, t) {\n  var e = r.x, i = r.y, n = t.devicePixelRatio || 1;\n  return {\n    x: et(e * n) / n || 0,\n    y: et(i * n) / n || 0\n  };\n}\nfunction Kt(r) {\n  var t, e = r.popper, i = r.popperRect, n = r.placement, a = r.variation, s = r.offsets, o = r.position, f = r.gpuAcceleration, p = r.adaptive, l = r.roundOffsets, h = r.isFixed, m = s.x, d = m === void 0 ? 0 : m, c = s.y, u = c === void 0 ? 0 : c, v = typeof l == \"function\" ? l({\n    x: d,\n    y: u\n  }) : {\n    x: d,\n    y: u\n  };\n  d = v.x, u = v.y;\n  var k = s.hasOwnProperty(\"x\"), g = s.hasOwnProperty(\"y\"), O = L, y = _, w = window;\n  if (p) {\n    var b = dt(e), x = \"clientHeight\", S = \"clientWidth\";\n    if (b === $(e) && (b = q(e), A(b).position !== \"static\" && o === \"absolute\" && (x = \"scrollHeight\", S = \"scrollWidth\")), b = b, n === _ || (n === L || n === H) && a === lt) {\n      y = M;\n      var D = h && b === w && w.visualViewport ? w.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        b[x]\n      );\n      u -= D - i.height, u *= f ? 1 : -1;\n    }\n    if (n === L || (n === _ || n === M) && a === lt) {\n      O = H;\n      var E = h && b === w && w.visualViewport ? w.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        b[S]\n      );\n      d -= E - i.width, d *= f ? 1 : -1;\n    }\n  }\n  var C = Object.assign({\n    position: o\n  }, p && Ye), B = l === !0 ? Xe({\n    x: d,\n    y: u\n  }, $(e)) : {\n    x: d,\n    y: u\n  };\n  if (d = B.x, u = B.y, f) {\n    var P;\n    return Object.assign({}, C, (P = {}, P[y] = g ? \"0\" : \"\", P[O] = k ? \"0\" : \"\", P.transform = (w.devicePixelRatio || 1) <= 1 ? \"translate(\" + d + \"px, \" + u + \"px)\" : \"translate3d(\" + d + \"px, \" + u + \"px, 0)\", P));\n  }\n  return Object.assign({}, C, (t = {}, t[y] = g ? u + \"px\" : \"\", t[O] = k ? d + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction ze(r) {\n  var t = r.state, e = r.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, a = e.adaptive, s = a === void 0 ? !0 : a, o = e.roundOffsets, f = o === void 0 ? !0 : o, p = {\n    placement: W(t.placement),\n    variation: it(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: n,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Kt(Object.assign({}, p, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: s,\n    roundOffsets: f\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Kt(Object.assign({}, p, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: f\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst Ke = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: ze,\n  data: {}\n};\nvar bt = {\n  passive: !0\n};\nfunction Je(r) {\n  var t = r.state, e = r.instance, i = r.options, n = i.scroll, a = n === void 0 ? !0 : n, s = i.resize, o = s === void 0 ? !0 : s, f = $(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return a && p.forEach(function(l) {\n    l.addEventListener(\"scroll\", e.update, bt);\n  }), o && f.addEventListener(\"resize\", e.update, bt), function() {\n    a && p.forEach(function(l) {\n      l.removeEventListener(\"scroll\", e.update, bt);\n    }), o && f.removeEventListener(\"resize\", e.update, bt);\n  };\n}\nconst Ge = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: Je,\n  data: {}\n};\nvar Ze = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction wt(r) {\n  return r.replace(/left|right|bottom|top/g, function(t) {\n    return Ze[t];\n  });\n}\nvar Qe = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Jt(r) {\n  return r.replace(/start|end/g, function(t) {\n    return Qe[t];\n  });\n}\nfunction Tt(r) {\n  var t = $(r), e = t.pageXOffset, i = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: i\n  };\n}\nfunction Mt(r) {\n  return rt(q(r)).left + Tt(r).scrollLeft;\n}\nfunction tr(r, t) {\n  var e = $(r), i = q(r), n = e.visualViewport, a = i.clientWidth, s = i.clientHeight, o = 0, f = 0;\n  if (n) {\n    a = n.width, s = n.height;\n    var p = oe();\n    (p || !p && t === \"fixed\") && (o = n.offsetLeft, f = n.offsetTop);\n  }\n  return {\n    width: a,\n    height: s,\n    x: o + Mt(r),\n    y: f\n  };\n}\nfunction er(r) {\n  var t, e = q(r), i = Tt(r), n = (t = r.ownerDocument) == null ? void 0 : t.body, a = G(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), s = G(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), o = -i.scrollLeft + Mt(r), f = -i.scrollTop;\n  return A(n || e).direction === \"rtl\" && (o += G(e.clientWidth, n ? n.clientWidth : 0) - a), {\n    width: a,\n    height: s,\n    x: o,\n    y: f\n  };\n}\nfunction Ht(r) {\n  var t = A(r), e = t.overflow, i = t.overflowX, n = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + n + i);\n}\nfunction le(r) {\n  return [\"html\", \"body\", \"#document\"].indexOf(N(r)) >= 0 ? r.ownerDocument.body : T(r) && Ht(r) ? r : le(kt(r));\n}\nfunction ct(r, t) {\n  var e;\n  t === void 0 && (t = []);\n  var i = le(r), n = i === ((e = r.ownerDocument) == null ? void 0 : e.body), a = $(i), s = n ? [a].concat(a.visualViewport || [], Ht(i) ? i : []) : i, o = t.concat(s);\n  return n ? o : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    o.concat(ct(kt(s)))\n  );\n}\nfunction _t(r) {\n  return Object.assign({}, r, {\n    left: r.x,\n    top: r.y,\n    right: r.x + r.width,\n    bottom: r.y + r.height\n  });\n}\nfunction rr(r, t) {\n  var e = rt(r, !1, t === \"fixed\");\n  return e.top = e.top + r.clientTop, e.left = e.left + r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction Gt(r, t, e) {\n  return t === ie ? _t(tr(r, e)) : Z(t) ? rr(t, e) : _t(er(q(r)));\n}\nfunction ir(r) {\n  var t = ct(kt(r)), e = [\"absolute\", \"fixed\"].indexOf(A(r).position) >= 0, i = e && T(r) ? dt(r) : r;\n  return Z(i) ? t.filter(function(n) {\n    return Z(n) && ae(n, i) && N(n) !== \"body\";\n  }) : [];\n}\nfunction nr(r, t, e, i) {\n  var n = t === \"clippingParents\" ? ir(r) : [].concat(t), a = [].concat(n, [e]), s = a[0], o = a.reduce(function(f, p) {\n    var l = Gt(r, p, i);\n    return f.top = G(l.top, f.top), f.right = xt(l.right, f.right), f.bottom = xt(l.bottom, f.bottom), f.left = G(l.left, f.left), f;\n  }, Gt(r, s, i));\n  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;\n}\nfunction pe(r) {\n  var t = r.reference, e = r.element, i = r.placement, n = i ? W(i) : null, a = i ? it(i) : null, s = t.x + t.width / 2 - e.width / 2, o = t.y + t.height / 2 - e.height / 2, f;\n  switch (n) {\n    case _:\n      f = {\n        x: s,\n        y: t.y - e.height\n      };\n      break;\n    case M:\n      f = {\n        x: s,\n        y: t.y + t.height\n      };\n      break;\n    case H:\n      f = {\n        x: t.x + t.width,\n        y: o\n      };\n      break;\n    case L:\n      f = {\n        x: t.x - e.width,\n        y: o\n      };\n      break;\n    default:\n      f = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var p = n ? jt(n) : null;\n  if (p != null) {\n    var l = p === \"y\" ? \"height\" : \"width\";\n    switch (a) {\n      case tt:\n        f[p] = f[p] - (t[l] / 2 - e[l] / 2);\n        break;\n      case lt:\n        f[p] = f[p] + (t[l] / 2 - e[l] / 2);\n        break;\n    }\n  }\n  return f;\n}\nfunction pt(r, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = i === void 0 ? r.placement : i, a = e.strategy, s = a === void 0 ? r.strategy : a, o = e.boundary, f = o === void 0 ? Ee : o, p = e.rootBoundary, l = p === void 0 ? ie : p, h = e.elementContext, m = h === void 0 ? at : h, d = e.altBoundary, c = d === void 0 ? !1 : d, u = e.padding, v = u === void 0 ? 0 : u, k = fe(typeof v != \"number\" ? v : ce(v, ut)), g = m === at ? De : at, O = r.rects.popper, y = r.elements[c ? g : m], w = nr(Z(y) ? y : y.contextElement || q(r.elements.popper), f, l, s), b = rt(r.elements.reference), x = pe({\n    reference: b,\n    element: O,\n    strategy: \"absolute\",\n    placement: n\n  }), S = _t(Object.assign({}, O, x)), D = m === at ? S : b, E = {\n    top: w.top - D.top + k.top,\n    bottom: D.bottom - w.bottom + k.bottom,\n    left: w.left - D.left + k.left,\n    right: D.right - w.right + k.right\n  }, C = r.modifiersData.offset;\n  if (m === at && C) {\n    var B = C[n];\n    Object.keys(E).forEach(function(P) {\n      var U = [H, M].indexOf(P) >= 0 ? 1 : -1, I = [_, M].indexOf(P) >= 0 ? \"y\" : \"x\";\n      E[P] += B[I] * U;\n    });\n  }\n  return E;\n}\nfunction or(r, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = e.boundary, a = e.rootBoundary, s = e.padding, o = e.flipVariations, f = e.allowedAutoPlacements, p = f === void 0 ? ne : f, l = it(i), h = l ? o ? Xt : Xt.filter(function(c) {\n    return it(c) === l;\n  }) : ut, m = h.filter(function(c) {\n    return p.indexOf(c) >= 0;\n  });\n  m.length === 0 && (m = h);\n  var d = m.reduce(function(c, u) {\n    return c[u] = pt(r, {\n      placement: u,\n      boundary: n,\n      rootBoundary: a,\n      padding: s\n    })[W(u)], c;\n  }, {});\n  return Object.keys(d).sort(function(c, u) {\n    return d[c] - d[u];\n  });\n}\nfunction ar(r) {\n  if (W(r) === Lt)\n    return [];\n  var t = wt(r);\n  return [Jt(r), t, Jt(t)];\n}\nfunction sr(r) {\n  var t = r.state, e = r.options, i = r.name;\n  if (!t.modifiersData[i]._skip) {\n    for (var n = e.mainAxis, a = n === void 0 ? !0 : n, s = e.altAxis, o = s === void 0 ? !0 : s, f = e.fallbackPlacements, p = e.padding, l = e.boundary, h = e.rootBoundary, m = e.altBoundary, d = e.flipVariations, c = d === void 0 ? !0 : d, u = e.allowedAutoPlacements, v = t.options.placement, k = W(v), g = k === v, O = f || (g || !c ? [wt(v)] : ar(v)), y = [v].concat(O).reduce(function(Q, V) {\n      return Q.concat(W(V) === Lt ? or(t, {\n        placement: V,\n        boundary: l,\n        rootBoundary: h,\n        padding: p,\n        flipVariations: c,\n        allowedAutoPlacements: u\n      }) : V);\n    }, []), w = t.rects.reference, b = t.rects.popper, x = /* @__PURE__ */ new Map(), S = !0, D = y[0], E = 0; E < y.length; E++) {\n      var C = y[E], B = W(C), P = it(C) === tt, U = [_, M].indexOf(B) >= 0, I = U ? \"width\" : \"height\", R = pt(t, {\n        placement: C,\n        boundary: l,\n        rootBoundary: h,\n        altBoundary: m,\n        padding: p\n      }), F = U ? P ? H : L : P ? M : _;\n      w[I] > b[I] && (F = wt(F));\n      var ht = wt(F), Y = [];\n      if (a && Y.push(R[B] <= 0), o && Y.push(R[F] <= 0, R[ht] <= 0), Y.every(function(Q) {\n        return Q;\n      })) {\n        D = C, S = !1;\n        break;\n      }\n      x.set(C, Y);\n    }\n    if (S)\n      for (var vt = c ? 3 : 1, Ot = function(V) {\n        var ot = y.find(function(yt) {\n          var X = x.get(yt);\n          if (X)\n            return X.slice(0, V).every(function(Et) {\n              return Et;\n            });\n        });\n        if (ot)\n          return D = ot, \"break\";\n      }, nt = vt; nt > 0; nt--) {\n        var mt = Ot(nt);\n        if (mt === \"break\") break;\n      }\n    t.placement !== D && (t.modifiersData[i]._skip = !0, t.placement = D, t.reset = !0);\n  }\n}\nconst fr = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: sr,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction Zt(r, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: r.top - t.height - e.y,\n    right: r.right - t.width + e.x,\n    bottom: r.bottom - t.height + e.y,\n    left: r.left - t.width - e.x\n  };\n}\nfunction Qt(r) {\n  return [_, H, M, L].some(function(t) {\n    return r[t] >= 0;\n  });\n}\nfunction cr(r) {\n  var t = r.state, e = r.name, i = t.rects.reference, n = t.rects.popper, a = t.modifiersData.preventOverflow, s = pt(t, {\n    elementContext: \"reference\"\n  }), o = pt(t, {\n    altBoundary: !0\n  }), f = Zt(s, i), p = Zt(o, n, a), l = Qt(f), h = Qt(p);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: f,\n    popperEscapeOffsets: p,\n    isReferenceHidden: l,\n    hasPopperEscaped: h\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": l,\n    \"data-popper-escaped\": h\n  });\n}\nconst lr = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: cr\n};\nfunction pr(r, t, e) {\n  var i = W(r), n = [L, _].indexOf(i) >= 0 ? -1 : 1, a = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: r\n  })) : e, s = a[0], o = a[1];\n  return s = s || 0, o = (o || 0) * n, [L, H].indexOf(i) >= 0 ? {\n    x: o,\n    y: s\n  } : {\n    x: s,\n    y: o\n  };\n}\nfunction ur(r) {\n  var t = r.state, e = r.options, i = r.name, n = e.offset, a = n === void 0 ? [0, 0] : n, s = ne.reduce(function(l, h) {\n    return l[h] = pr(h, t.rects, a), l;\n  }, {}), o = s[t.placement], f = o.x, p = o.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += f, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = s;\n}\nconst dr = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: ur\n};\nfunction hr(r) {\n  var t = r.state, e = r.name;\n  t.modifiersData[e] = pe({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst vr = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: hr,\n  data: {}\n};\nfunction mr(r) {\n  return r === \"x\" ? \"y\" : \"x\";\n}\nfunction yr(r) {\n  var t = r.state, e = r.options, i = r.name, n = e.mainAxis, a = n === void 0 ? !0 : n, s = e.altAxis, o = s === void 0 ? !1 : s, f = e.boundary, p = e.rootBoundary, l = e.altBoundary, h = e.padding, m = e.tether, d = m === void 0 ? !0 : m, c = e.tetherOffset, u = c === void 0 ? 0 : c, v = pt(t, {\n    boundary: f,\n    rootBoundary: p,\n    padding: h,\n    altBoundary: l\n  }), k = W(t.placement), g = it(t.placement), O = !g, y = jt(k), w = mr(y), b = t.modifiersData.popperOffsets, x = t.rects.reference, S = t.rects.popper, D = typeof u == \"function\" ? u(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : u, E = typeof D == \"number\" ? {\n    mainAxis: D,\n    altAxis: D\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, D), C = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, B = {\n    x: 0,\n    y: 0\n  };\n  if (b) {\n    if (a) {\n      var P, U = y === \"y\" ? _ : L, I = y === \"y\" ? M : H, R = y === \"y\" ? \"height\" : \"width\", F = b[y], ht = F + v[U], Y = F - v[I], vt = d ? -S[R] / 2 : 0, Ot = g === tt ? x[R] : S[R], nt = g === tt ? -S[R] : -x[R], mt = t.elements.arrow, Q = d && mt ? $t(mt) : {\n        width: 0,\n        height: 0\n      }, V = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : se(), ot = V[U], yt = V[I], X = ft(0, x[R], Q[R]), Et = O ? x[R] / 2 - vt - X - ot - E.mainAxis : Ot - X - ot - E.mainAxis, ue = O ? -x[R] / 2 + vt + X + yt + E.mainAxis : nt + X + yt + E.mainAxis, Dt = t.elements.arrow && dt(t.elements.arrow), de = Dt ? y === \"y\" ? Dt.clientTop || 0 : Dt.clientLeft || 0 : 0, Bt = (P = C?.[y]) != null ? P : 0, he = F + Et - Bt - de, ve = F + ue - Bt, Ft = ft(d ? xt(ht, he) : ht, F, d ? G(Y, ve) : Y);\n      b[y] = Ft, B[y] = Ft - F;\n    }\n    if (o) {\n      var Wt, me = y === \"x\" ? _ : L, ye = y === \"x\" ? M : H, z = b[w], gt = w === \"y\" ? \"height\" : \"width\", Nt = z + v[me], At = z - v[ye], St = [_, L].indexOf(k) !== -1, Vt = (Wt = C?.[w]) != null ? Wt : 0, qt = St ? Nt : z - x[gt] - S[gt] - Vt + E.altAxis, Ut = St ? z + x[gt] + S[gt] - Vt - E.altAxis : At, It = d && St ? Ae(qt, z, Ut) : ft(d ? qt : Nt, z, d ? Ut : At);\n      b[w] = It, B[w] = It - z;\n    }\n    t.modifiersData[i] = B;\n  }\n}\nconst gr = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: yr,\n  requiresIfExists: [\"offset\"]\n};\nfunction br(r) {\n  return {\n    scrollLeft: r.scrollLeft,\n    scrollTop: r.scrollTop\n  };\n}\nfunction wr(r) {\n  return r === $(r) || !T(r) ? Tt(r) : br(r);\n}\nfunction xr(r) {\n  var t = r.getBoundingClientRect(), e = et(t.width) / r.offsetWidth || 1, i = et(t.height) / r.offsetHeight || 1;\n  return e !== 1 || i !== 1;\n}\nfunction kr(r, t, e) {\n  e === void 0 && (e = !1);\n  var i = T(t), n = T(t) && xr(t), a = q(t), s = rt(r, n, e), o = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, f = {\n    x: 0,\n    y: 0\n  };\n  return (i || !i && !e) && ((N(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  Ht(a)) && (o = wr(t)), T(t) ? (f = rt(t, !0), f.x += t.clientLeft, f.y += t.clientTop) : a && (f.x = Mt(a))), {\n    x: s.left + o.scrollLeft - f.x,\n    y: s.top + o.scrollTop - f.y,\n    width: s.width,\n    height: s.height\n  };\n}\nfunction Or(r) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];\n  r.forEach(function(a) {\n    t.set(a.name, a);\n  });\n  function n(a) {\n    e.add(a.name);\n    var s = [].concat(a.requires || [], a.requiresIfExists || []);\n    s.forEach(function(o) {\n      if (!e.has(o)) {\n        var f = t.get(o);\n        f && n(f);\n      }\n    }), i.push(a);\n  }\n  return r.forEach(function(a) {\n    e.has(a.name) || n(a);\n  }), i;\n}\nfunction Er(r) {\n  var t = Or(r);\n  return Me.reduce(function(e, i) {\n    return e.concat(t.filter(function(n) {\n      return n.phase === i;\n    }));\n  }, []);\n}\nfunction Dr(r) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(r());\n      });\n    })), t;\n  };\n}\nfunction Sr(r) {\n  var t = r.reduce(function(e, i) {\n    var n = e[i.name];\n    return e[i.name] = n ? Object.assign({}, n, i, {\n      options: Object.assign({}, n.options, i.options),\n      data: Object.assign({}, n.data, i.data)\n    }) : i, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar te = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction ee() {\n  for (var r = arguments.length, t = new Array(r), e = 0; e < r; e++)\n    t[e] = arguments[e];\n  return !t.some(function(i) {\n    return !(i && typeof i.getBoundingClientRect == \"function\");\n  });\n}\nfunction Cr(r) {\n  r === void 0 && (r = {});\n  var t = r, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, a = n === void 0 ? te : n;\n  return function(o, f, p) {\n    p === void 0 && (p = a);\n    var l = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, te, a),\n      modifiersData: {},\n      elements: {\n        reference: o,\n        popper: f\n      },\n      attributes: {},\n      styles: {}\n    }, h = [], m = !1, d = {\n      state: l,\n      setOptions: function(k) {\n        var g = typeof k == \"function\" ? k(l.options) : k;\n        u(), l.options = Object.assign({}, a, l.options, g), l.scrollParents = {\n          reference: Z(o) ? ct(o) : o.contextElement ? ct(o.contextElement) : [],\n          popper: ct(f)\n        };\n        var O = Er(Sr([].concat(i, l.options.modifiers)));\n        return l.orderedModifiers = O.filter(function(y) {\n          return y.enabled;\n        }), c(), d.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!m) {\n          var k = l.elements, g = k.reference, O = k.popper;\n          if (ee(g, O)) {\n            l.rects = {\n              reference: kr(g, dt(O), l.options.strategy === \"fixed\"),\n              popper: $t(O)\n            }, l.reset = !1, l.placement = l.options.placement, l.orderedModifiers.forEach(function(E) {\n              return l.modifiersData[E.name] = Object.assign({}, E.data);\n            });\n            for (var y = 0; y < l.orderedModifiers.length; y++) {\n              if (l.reset === !0) {\n                l.reset = !1, y = -1;\n                continue;\n              }\n              var w = l.orderedModifiers[y], b = w.fn, x = w.options, S = x === void 0 ? {} : x, D = w.name;\n              typeof b == \"function\" && (l = b({\n                state: l,\n                options: S,\n                name: D,\n                instance: d\n              }) || l);\n            }\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Dr(function() {\n        return new Promise(function(v) {\n          d.forceUpdate(), v(l);\n        });\n      }),\n      destroy: function() {\n        u(), m = !0;\n      }\n    };\n    if (!ee(o, f))\n      return d;\n    d.setOptions(p).then(function(v) {\n      !m && p.onFirstUpdate && p.onFirstUpdate(v);\n    });\n    function c() {\n      l.orderedModifiers.forEach(function(v) {\n        var k = v.name, g = v.options, O = g === void 0 ? {} : g, y = v.effect;\n        if (typeof y == \"function\") {\n          var w = y({\n            state: l,\n            name: k,\n            instance: d,\n            options: O\n          }), b = function() {\n          };\n          h.push(w || b);\n        }\n      });\n    }\n    function u() {\n      h.forEach(function(v) {\n        return v();\n      }), h = [];\n    }\n    return d;\n  };\n}\nvar Pr = [Ge, vr, Ke, Fe, dr, fr, gr, Ie, lr], _r = /* @__PURE__ */ Cr({\n  defaultModifiers: Pr\n});\nclass jr {\n  constructor(t, e, i, n, a, s, o, f, p) {\n    if (this.cfg = t, this.hTag = e, this.appPixi = i, this.main = n, this.layMng = a, this.val = s, this.scrItr = f, this.sys = p, e.clear_event = (c) => _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.clear_event(c), e.event = (c) => this.#b(c), e.l = (c) => this.#r.l(c), e.p = (c) => this.#r.p(c), e.s = (c) => this.#r.s(c), e.set_cancel_skip = () => !1, e.set_focus = (c) => this.#w(c), e.wait = (c) => this.#r.wait(c), e.waitclick = (c) => this.#r.waitclick(c), e.page = (c) => this.#r.page(c), o.setEvtMng(this), f.setOtherObj(this, a), _LayerMng_js__WEBPACK_IMPORTED_MODULE_1__.T.setEvtMng(this, p, f), a.setEvtMng(this), p.setFire((c, u) => this.#r.fire(c, u)), _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.isDbg) {\n      const c = {\n        pause: () => {\n          if (!this.#r.isWait) return;\n          const u = {};\n          f.recodeDesign(u), p.callHook(\"_enterDesign\", u), p.send2Dbg(\"_enterDesign\", u);\n        }\n        //\t\t\t\tstopOnBreakpoint\t\t: ()=> this.#isDbgBreak = true,\n        //\t\t\t\tstopOnDataBreakpoint\t: ()=> this.#isDbgBreak = true,\n        //\t\t\t\tcontinue\t\t\t\t: ()=> this.#isDbgBreak = false,\n        //\t\t\t\tdisconnect\t\t\t\t: ()=> this.#isDbgBreak = false,\n      };\n      c.attach = c.stopOnEntry = c.stopOnStep = c.stopOnStepIn = c.stopOnStepOut = c.stopOnBackstep = c.pause, p.addHook((u) => c[u]?.());\n    }\n    (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.k)(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`), this.main.cvs.parentElement?.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), this.#i = document.querySelector(\".sn_hint\"), this.#l = this.#i.querySelector(\"span\"), this.#p = _r(this.#v, this.#i), this.#i.hidden = !0, i.stage.interactive = !0, _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.isMobile ? i.stage.on(\"pointerdown\", (c) => this.#r.fire(\"click\", c)) : this.#e.add(i.stage, \"pointerdown\", (c) => {\n      switch (c.data.button) {\n        case 0:\n          this.#r.fire(\"click\", c);\n          break;\n        case 1:\n          this.#r.fire(\"middleclick\", c);\n          break;\n      }\n    }), this.#e.add(window, \"keydown\", (c) => this.#a(c)), this.#e.add(this.main.cvs, \"contextmenu\", (c) => this.#o(c));\n    const l = () => s.setVal_Nochk(\"tmp\", \"const.sn.navigator.language\", navigator.language);\n    this.#e.add(window, \"languagechange\", (c) => {\n      l(), this.#r.fire(\"sn:chgNavLang\", c), (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.l)();\n    }), l();\n    const h = (c) => {\n      _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.isDarkMode = c.matches, s.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.isDarkMode);\n    }, m = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    h(m), this.#e.add(m, \"change\", (c) => {\n      h(c), this.#r.fire(\"sn:chgDarkMode\", c);\n    });\n    let d = (c, u) => {\n    };\n    \"WheelEvent\" in window && (this.#e.add(this.main.cvs, \"wheel\", (c) => this.#d(c), { passive: !0 }), this.#s = (c) => this.#e.add(c, \"wheel\", (u) => this.#d(u), { passive: !0 }), d = (c, u) => c.add(this.main.cvs, \"wheel\", (v) => {\n      v.isComposing || v.deltaY <= 0 || (v.stopPropagation(), u());\n    })), _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.init((c) => {\n      this.#r?.destroy(), this.#r = c;\n    }, n, s, a, f, o, e, this.#t, d, this.#i, t), __webpack_require__.e(/*! import() */ \"skynovel_dist_gamepad_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./gamepad.js */ \"../skynovel/dist/gamepad.js\")).then((c) => c.g).then(({ GamepadListener: c }) => {\n      const u = new c({\n        analog: !1,\n        deadZone: 0.3\n      });\n      _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.debugLog && (u.on(\"gamepad:connected\", (g) => console.log(`👺<'gamepad:connected' index:${g.detail.index} id:${g.detail.gamepad.id}`)), u.on(\"gamepad:disconnected\", (g) => console.log(`👺<'gamepad:disconnected' index:${g.detail.index} id:${g.detail.gamepad?.id}`)));\n      const v = [\n        \"\",\n        \"ArrowUp\",\n        \"\",\n        // '7', '8', '9',\n        \"ArrowLeft\",\n        \"\",\n        \"ArrowRight\",\n        // '4', '5', '6',\n        \"\",\n        \"ArrowDown\",\n        \"\"\n        // '1', '2', '3',\n      ], k = [0, 0];\n      u.on(\"gamepad:axis\", (g) => {\n        if (!document.hasFocus()) return;\n        k[g.detail.axis] = g.detail.value;\n        const [O = 0, y = 0] = k, w = (y + 1) * 3 + (O + 1), b = v[w];\n        if (!b) return;\n        const x = this.#t.getFocus();\n        (!x || x instanceof _web2_js__WEBPACK_IMPORTED_MODULE_0__.j ? globalThis : x).dispatchEvent(new KeyboardEvent(\"keydown\", { key: b, bubbles: !0 })), !(!x || x instanceof _web2_js__WEBPACK_IMPORTED_MODULE_0__.j) && x.getAttribute(\"type\") === \"range\" && x.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n      }), u.on(\"gamepad:button\", (g) => {\n        if (document.hasFocus())\n          if (g.detail.button % 2 === 0) {\n            const O = this.#t.getFocus();\n            (!O || O instanceof _web2_js__WEBPACK_IMPORTED_MODULE_0__.j ? globalThis : O).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n          } else this.main.cvs.dispatchEvent(new Event(\"contextmenu\"));\n      }), u.start();\n    }), this.#e.add(window, \"keyup\", (c) => {\n      c.isComposing || c.key in this.#n && (this.#n[c.key] = 0);\n    }), s.defTmp(\"const.sn.key.alternate\", () => this.#n.Alt > 0), s.defTmp(\"const.sn.key.command\", () => this.#n.Meta > 0), s.defTmp(\"const.sn.key.control\", () => this.#n.Control > 0), s.defTmp(\"const.sn.key.end\", () => this.#n.End > 0), s.defTmp(\"const.sn.key.escape\", () => this.#n.Escape > 0), s.defTmp(\"const.sn.key.back\", () => this.#n.GoBack > 0);\n  }\n  #e = new _web2_js__WEBPACK_IMPORTED_MODULE_0__.E();\n  #t = new Oe();\n  #r;\n  resvFlameEvent(t) {\n    this.#e.add(t, \"keydown\", (e) => this.#a(e)), this.#e.add(t, \"contextmenu\", (e) => this.#o(e)), this.#s(t);\n  }\n  #s = (t) => {\n  };\n  #a(t) {\n    t.isComposing || (t.key in this.#n && (this.#n[t.key] = t.repeat ? 2 : 1), this.#r.fire(_web2_js__WEBPACK_IMPORTED_MODULE_0__.m.modKey(t) + t.key, t));\n  }\n  #o(t) {\n    this.#r.fire(this.#u(t) + \"rightclick\", t), t.preventDefault();\n  }\n  #u(t) {\n    return (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.metaKey ? \"meta+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\");\n  }\n  #d(t) {\n    if (this.#f) {\n      this.#c = !0;\n      return;\n    }\n    this.#f = !0, this.#h();\n    const e = this.#u(t) + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n    this.#r.fire(e, t);\n  }\n  #f = !1;\n  #c = !1;\n  #h() {\n    setTimeout(() => {\n      if (this.#c) {\n        this.#c = !1, this.#h();\n        return;\n      }\n      this.#f = !1;\n    }, 250);\n  }\n  destroy() {\n    for (const t of Array.from(document.getElementsByClassName(\"sn_hint\"))) t.parentElement?.removeChild(t);\n    this.#r.destroy(), this.#t.destroy(), this.#e.clear();\n  }\n  fire(t, e) {\n    this.#r.fire(t, e);\n  }\n  popLocalEvts() {\n    return _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.popLocalEvts();\n  }\n  pushLocalEvts(t) {\n    _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.pushLocalEvts(t);\n  }\n  unButton(t) {\n    this.#t.remove(t);\n  }\n  button(t, e, i, n, a) {\n    !t.fn && !t.label && !t.url && this.main.errScript(\"fnまたはlabelまたはurlは必須です\"), t.fn ??= this.scrItr.scriptFn, e.interactive = !0, e.cursor = \"pointer\";\n    const s = t.key?.toLowerCase() ?? \" \", o = (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"global\", !1);\n    _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.setEvt2Fnc(o, s, () => this.main.resumeByJumpOrCall(t)), e.on(\"pointerdown\", (h) => this.#r.fire(s, h));\n    const f = t.hint ? () => this.#g(t, e) : () => {\n    }, p = () => {\n      i(), this.#i.hidden = !0;\n    }, l = () => (f(), n());\n    if (e.on(\"pointerover\", l), e.on(\"pointerout\", () => {\n      this.#t.isFocus(e) ? l() : p();\n    }), e.on(\"pointerdown\", () => {\n      this.#i.hidden = !0;\n      const h = this.#t.getFocus();\n      a(), h instanceof _LayerMng_js__WEBPACK_IMPORTED_MODULE_1__.B && h.normal();\n    }), e.on(\n      \"pointerup\",\n      _web2_js__WEBPACK_IMPORTED_MODULE_0__.C.isMobile ? p : () => {\n        this.#t.isFocus(e) ? l() : p();\n      }\n    ), this.#t.add(e, l, p), t.clickse && (t.clicksebuf ??= \"SYS\", this.cfg.searchPath(t.clickse, _web2_js__WEBPACK_IMPORTED_MODULE_0__.S.SOUND), e.on(\"pointerdown\", () => {\n      this.hTag.playse({ fn: t.clickse, buf: t.clicksebuf, join: !1 });\n    })), t.enterse && (t.entersebuf ??= \"SYS\", this.cfg.searchPath(t.enterse, _web2_js__WEBPACK_IMPORTED_MODULE_0__.S.SOUND), e.on(\"pointerover\", () => {\n      this.hTag.playse({ fn: t.enterse, buf: t.entersebuf, join: !1 });\n    })), t.leavese && (t.leavesebuf ??= \"SYS\", this.cfg.searchPath(t.leavese, _web2_js__WEBPACK_IMPORTED_MODULE_0__.S.SOUND), e.on(\"pointerout\", () => {\n      this.hTag.playse({ fn: t.leavese, buf: t.leavesebuf, join: !1 });\n    })), t.onenter) {\n      const h = s + t.onenter.toLowerCase(), m = { fn: t.fn, label: t.onenter, call: !0, key: h };\n      _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.setEvt2Fnc(o, h, () => this.main.resumeByJumpOrCall(m)), e.on(\"pointerover\", (d) => this.#r.fire(h, d));\n    }\n    if (t.onleave) {\n      const h = s + t.onleave.toLowerCase(), m = { fn: t.fn, label: t.onleave, call: !0, key: h };\n      _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.setEvt2Fnc(o, h, () => this.main.resumeByJumpOrCall(m)), e.on(\"pointerout\", (d) => this.#r.fire(h, d));\n    }\n  }\n  #v = {\n    getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n  };\n  #i;\n  #l;\n  #p;\n  #m = {\n    placement: \"bottom\",\n    modifiers: [\n      {\n        // Flip | Popper https://popper.js.org/docs/v2/modifiers/flip/\n        name: \"flip\",\n        options: {\n          fallbackPlacements: [\"top\", \"bottom\"]\n        }\n      }\n    ]\n  };\n  #g(t, e) {\n    const i = e instanceof _LayerMng_js__WEBPACK_IMPORTED_MODULE_1__.B ? e.getBtnBounds() : e.getBounds();\n    if (!(t[\":タグ名\"] === \"link\")) {\n      const a = e.parent.parent;\n      i.x += a.x, i.y += a.y;\n    }\n    if (!t.hint) {\n      this.#i.hidden = !0;\n      return;\n    }\n    this.#i.style.cssText = `position:${this.#i.style.position}; transform:${this.#i.style.transform};` + (t.hint_style ?? \"\"), this.#l.style.cssText = \"\", this.#l.textContent = t.hint ?? \"\";\n    try {\n      const a = t.hint_opt ? { ...this.#m, ...JSON.parse(t.hint_opt) } : this.#m;\n      this.#p.setOptions(a);\n    } catch (a) {\n      console.error((0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.o)(\n        t,\n        \"hint_opt\",\n        `dispHint 引数 hint_opt エラー ${a instanceof SyntaxError ? a.message : \"\"}`\n      ));\n    }\n    this.#v.getBoundingClientRect = () => DOMRect.fromRect({\n      x: this.sys.ofsLeft4elm + i.x * this.sys.cvsScale,\n      y: this.sys.ofsTop4elm + i.y * this.sys.cvsScale,\n      width: i.width,\n      height: i.height\n    }), this.#p.update(), this.#i.hidden = !1;\n  }\n  hideHint() {\n    this.#i.hidden = !0;\n  }\n  cvsResize() {\n    this.hideHint();\n  }\n  #b(t) {\n    const e = t.key;\n    if (!e) throw \"keyは必須です\";\n    const i = e.toLowerCase(), n = (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"call\", !1), a = (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"global\", !1);\n    if ((0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"del\", !1)) {\n      if (t.fn || t.label || n || t.url) throw \"fn/label/callとdelは同時指定できません\";\n      return _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.clear_eventer(e, a, i), !1;\n    }\n    if (!t.fn && !t.label && !t.url) throw \"fn,label,url いずれかは必須です\";\n    if (t.fn ??= this.scrItr.scriptFn, e.startsWith(\"dom=\")) {\n      const s = _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.getHtmlElmList(e);\n      if (s.el.length === 0) {\n        if ((0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"need_err\", !0)) throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n        return !1;\n      }\n      let o = [\"click\", \"keydown\"];\n      switch (s.el[0].type ?? \"\") {\n        //\tswitch (g.el[0].getAttribute('type') ?? '') { textareaで''になる\n        case \"checkbox\":\n          o = [\"input\"];\n          break;\n        case \"range\":\n          o = [\"input\"];\n          break;\n        case \"text\":\n        case \"textarea\":\n          o = [\"input\", \"change\"];\n          break;\n      }\n      const p = o.length;\n      for (let l = 0; l < p; ++l) {\n        const h = o[l];\n        s.el.forEach((m) => {\n          this.#e.add(m, h, (d) => {\n            if (!this.#r.isWait || this.layMng.getFrmDisabled(s.id) || h === \"keydown\" && d.key !== \"Enter\") return;\n            const c = m.dataset;\n            for (const [u, v] of Object.entries(c)) this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${u}`, v);\n            this.#r.fire(e, d);\n          }), l === 0 && this.#t.add(\n            m,\n            () => this.#y(m) ? (m.focus(), !0) : !1,\n            () => {\n            }\n          );\n        });\n      }\n    }\n    return _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.setEvt2Fnc(a, i, () => this.main.resumeByJumpOrCall(t)), !1;\n  }\n  #y(t) {\n    if (t.offsetParent === null) return !1;\n    let e = t;\n    do {\n      if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || e?.disabled) return !1;\n      e = e.parentElement;\n    } while (e !== null);\n    return !0;\n  }\n  // フォーカス移動\n  #w(t) {\n    const { add: e, del: i, to: n } = t;\n    if (e?.startsWith(\"dom=\")) {\n      const a = _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.getHtmlElmList(e);\n      if (a.el.length === 0 && (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"need_err\", !0)) throw `HTML内にセレクタ（${a.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n      return a.el.forEach((s) => this.#t.add(\n        s,\n        () => this.#y(s) ? (s.focus(), !0) : !1,\n        () => {\n        }\n      )), !1;\n    }\n    if (i?.startsWith(\"dom=\")) {\n      const a = _ReadState_js__WEBPACK_IMPORTED_MODULE_2__.R.getHtmlElmList(i);\n      if (a.el.length === 0 && (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.a)(t, \"need_err\", !0)) throw `HTML内にセレクタ（${a.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n      return a.el.forEach((s) => this.#t.remove(s)), !1;\n    }\n    if (!n) throw \"[set_focus] add か to は必須です\";\n    switch (n) {\n      case \"null\":\n        this.#t.blur();\n        break;\n      case \"next\":\n        this.#t.next();\n        break;\n      case \"prev\":\n        this.#t.prev();\n        break;\n    }\n    return !1;\n  }\n  // テキスト表示待ちと処理終了待ち（予約イベント受付しない）\n  //\twaitEvent を使用する場合、通常 break 時は breakLimitedEvent() すること\n  waitEvent = (t, e, i) => this.#r.waitEvent(t, e, i);\n  breakEvent(t) {\n    this.#r.breakEvent(t);\n  }\n  // キー押下によるスキップ中か\n  get isSkipping() {\n    return this.#r.isSkipping ? !0 : Object.keys(this.#n).some((t) => this.#n[t] === 2);\n  }\n  // 0:no push  1:one push  2:push repeating\n  #n = {\n    Alt: 0,\n    Meta: 0,\n    // COMMANDキー\n    Control: 0,\n    ArrowDown: 0,\n    End: 0,\n    Enter: 0,\n    Escape: 0,\n    \" \": 0,\n    GoBack: 0\n    // AndroidのBackキーだと思う\n  };\n}\n\n//# sourceMappingURL=EventMng.js.map\n\n\n//# sourceURL=webpack://gallery/../skynovel/dist/EventMng.js?");

/***/ })

}]);