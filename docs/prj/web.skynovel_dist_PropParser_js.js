"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgallery"] = self["webpackChunkgallery"] || []).push([["skynovel_dist_PropParser_js"],{

/***/ "../skynovel/dist/PropParser.js":
/*!**************************************!*\
  !*** ../skynovel/dist/PropParser.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PropParser: () => (/* binding */ Lt)\n/* harmony export */ });\n/* harmony import */ var _web2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web2.js */ \"../skynovel/dist/web2.js\");\n\nvar lt = { exports: {} }, Ht = lt.exports, Ot;\nfunction Xt() {\n  return Ot || (Ot = 1, function(At, e) {\n    (function(c, l) {\n      At.exports = l();\n    })(typeof self < \"u\" ? self : Ht, function() {\n      return function(c) {\n        var l = {};\n        function v(o) {\n          if (l[o]) return l[o].exports;\n          var f = l[o] = { i: o, l: !1, exports: {} };\n          return c[o].call(f.exports, f, f.exports, v), f.l = !0, f.exports;\n        }\n        return v.m = c, v.c = l, v.d = function(o, f, I) {\n          v.o(o, f) || Object.defineProperty(o, f, { configurable: !1, enumerable: !0, get: I });\n        }, v.r = function(o) {\n          Object.defineProperty(o, \"__esModule\", { value: !0 });\n        }, v.n = function(o) {\n          var f = o && o.__esModule ? function() {\n            return o.default;\n          } : function() {\n            return o;\n          };\n          return v.d(f, \"a\", f), f;\n        }, v.o = function(o, f) {\n          return Object.prototype.hasOwnProperty.call(o, f);\n        }, v.p = \"\", v(v.s = 0);\n      }([function(c, l, v) {\n        function o(t) {\n          if (!(this instanceof o)) return new o(t);\n          this._ = t;\n        }\n        var f = o.prototype;\n        function I(t, r) {\n          for (var n = 0; n < t; n++) r(n);\n        }\n        function x(t, r, n) {\n          return function(i, u) {\n            I(u.length, function(s) {\n              i(u[s], s, u);\n            });\n          }(function(i, u, s) {\n            r = t(r, i, u, s);\n          }, n), r;\n        }\n        function O(t, r) {\n          return x(function(n, i, u, s) {\n            return n.concat([t(i, u, s)]);\n          }, [], r);\n        }\n        function ht(t, r) {\n          var n = { v: 0, buf: r };\n          return I(t, function() {\n            var i;\n            n = { v: n.v << 1 | (i = n.buf, i[0] >> 7), buf: function(u) {\n              var s = x(function(a, h, b, S) {\n                return a.concat(b === S.length - 1 ? Buffer.from([h, 0]).readUInt16BE(0) : S.readUInt16BE(b));\n              }, [], u);\n              return Buffer.from(O(function(a) {\n                return (a << 1 & 65535) >> 8;\n              }, s));\n            }(n.buf) };\n          }), n;\n        }\n        function tt() {\n          return typeof Buffer < \"u\";\n        }\n        function D() {\n          if (!tt()) throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n        }\n        function rt(t) {\n          D();\n          var r = x(function(s, a) {\n            return s + a;\n          }, 0, t);\n          if (r % 8 != 0) throw new Error(\"The bits [\" + t.join(\", \") + \"] add up to \" + r + \" which is not an even number of bytes; the total should be divisible by 8\");\n          var n, i = r / 8, u = (n = function(s) {\n            return s > 48;\n          }, x(function(s, a) {\n            return s || (n(a) ? a : s);\n          }, null, t));\n          if (u) throw new Error(u + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n          return new o(function(s, a) {\n            var h = i + a;\n            return h > s.length ? B(a, i.toString() + \" bytes\") : d(h, x(function(b, S) {\n              var N = ht(S, b.buf);\n              return { coll: b.coll.concat(N.v), buf: N.buf };\n            }, { coll: [], buf: s.slice(a, h) }, t).coll);\n          });\n        }\n        function P(t, r) {\n          return new o(function(n, i) {\n            return D(), i + r > n.length ? B(i, r + \" bytes for \" + t) : d(i + r, n.slice(i, i + r));\n          });\n        }\n        function W(t, r) {\n          if (typeof (n = r) != \"number\" || Math.floor(n) !== n || r < 0 || r > 6) throw new Error(t + \" requires integer length in range [0, 6].\");\n          var n;\n        }\n        function Z(t) {\n          return W(\"uintBE\", t), P(\"uintBE(\" + t + \")\", t).map(function(r) {\n            return r.readUIntBE(0, t);\n          });\n        }\n        function $(t) {\n          return W(\"uintLE\", t), P(\"uintLE(\" + t + \")\", t).map(function(r) {\n            return r.readUIntLE(0, t);\n          });\n        }\n        function p(t) {\n          return W(\"intBE\", t), P(\"intBE(\" + t + \")\", t).map(function(r) {\n            return r.readIntBE(0, t);\n          });\n        }\n        function y(t) {\n          return W(\"intLE\", t), P(\"intLE(\" + t + \")\", t).map(function(r) {\n            return r.readIntLE(0, t);\n          });\n        }\n        function g(t) {\n          return t instanceof o;\n        }\n        function E(t) {\n          return {}.toString.call(t) === \"[object Array]\";\n        }\n        function L(t) {\n          return tt() && Buffer.isBuffer(t);\n        }\n        function d(t, r) {\n          return { status: !0, index: t, value: r, furthest: -1, expected: [] };\n        }\n        function B(t, r) {\n          return E(r) || (r = [r]), { status: !1, index: -1, value: null, furthest: t, expected: r };\n        }\n        function j(t, r) {\n          if (!r || t.furthest > r.furthest) return t;\n          var n = t.furthest === r.furthest ? function(i, u) {\n            if (function() {\n              if (o._supportsSet !== void 0) return o._supportsSet;\n              var q = typeof Set < \"u\";\n              return o._supportsSet = q, q;\n            }() && Array.from) {\n              for (var s = new Set(i), a = 0; a < u.length; a++) s.add(u[a]);\n              var h = Array.from(s);\n              return h.sort(), h;\n            }\n            for (var b = {}, S = 0; S < i.length; S++) b[i[S]] = !0;\n            for (var N = 0; N < u.length; N++) b[u[N]] = !0;\n            var k = [];\n            for (var _ in b) ({}).hasOwnProperty.call(b, _) && k.push(_);\n            return k.sort(), k;\n          }(t.expected, r.expected) : r.expected;\n          return { status: t.status, index: t.index, value: t.value, furthest: r.furthest, expected: n };\n        }\n        var nt = {};\n        function bt(t, r) {\n          if (L(t)) return { offset: r, line: -1, column: -1 };\n          t in nt || (nt[t] = {});\n          for (var n = nt[t], i = 0, u = 0, s = 0, a = r; a >= 0; ) {\n            if (a in n) {\n              i = n[a].line, s === 0 && (s = n[a].lineStart);\n              break;\n            }\n            (t.charAt(a) === `\n` || t.charAt(a) === \"\\r\" && t.charAt(a + 1) !== `\n`) && (u++, s === 0 && (s = a + 1)), a--;\n          }\n          var h = i + u, b = r - s;\n          return n[r] = { line: h, lineStart: s }, { offset: r, line: h + 1, column: b + 1 };\n        }\n        function G(t) {\n          if (!g(t)) throw new Error(\"not a parser: \" + t);\n        }\n        function et(t, r) {\n          return typeof t == \"string\" ? t.charAt(r) : t[r];\n        }\n        function U(t) {\n          if (typeof t != \"number\") throw new Error(\"not a number: \" + t);\n        }\n        function M(t) {\n          if (typeof t != \"function\") throw new Error(\"not a function: \" + t);\n        }\n        function J(t) {\n          if (typeof t != \"string\") throw new Error(\"not a string: \" + t);\n        }\n        var kt = 2, qt = 3, R = 8, It = 5 * R, Rt = 4 * R, yt = \"  \";\n        function it(t, r) {\n          return new Array(r + 1).join(t);\n        }\n        function ot(t, r, n) {\n          var i = r - t.length;\n          return i <= 0 ? t : it(n, i) + t;\n        }\n        function vt(t, r, n, i) {\n          return { from: t - r > 0 ? t - r : 0, to: t + n > i ? i : t + n };\n        }\n        function Mt(t, r) {\n          var n, i, u, s, a, h = r.index, b = h.offset, S = 1;\n          if (b === t.length) return \"Got the end of the input\";\n          if (L(t)) {\n            var N = b - b % R, k = b - N, _ = vt(N, It, Rt + R, t.length), q = O(function(w) {\n              return O(function(C) {\n                return ot(C.toString(16), 2, \"0\");\n              }, w);\n            }, function(w, C) {\n              var H = w.length, V = [], X = 0;\n              if (H <= C) return [w.slice()];\n              for (var Y = 0; Y < H; Y++) V[X] || V.push([]), V[X].push(w[Y]), (Y + 1) % C == 0 && X++;\n              return V;\n            }(t.slice(_.from, _.to).toJSON().data, R));\n            s = function(w) {\n              return w.from === 0 && w.to === 1 ? { from: w.from, to: w.to } : { from: w.from / R, to: Math.floor(w.to / R) };\n            }(_), i = N / R, n = 3 * k, k >= 4 && (n += 1), S = 2, u = O(function(w) {\n              return w.length <= 4 ? w.join(\" \") : w.slice(0, 4).join(\" \") + \"  \" + w.slice(4).join(\" \");\n            }, q), (a = (8 * (s.to > 0 ? s.to - 1 : s.to)).toString(16).length) < 2 && (a = 2);\n          } else {\n            var T = t.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n            n = h.column - 1, i = h.line - 1, s = vt(i, kt, qt, T.length), u = T.slice(s.from, s.to), a = s.to.toString().length;\n          }\n          var Ct = i - s.from;\n          return L(t) && (a = (8 * (s.to > 0 ? s.to - 1 : s.to)).toString(16).length) < 2 && (a = 2), x(function(w, C, H) {\n            var V, X = H === Ct, Y = X ? \"> \" : yt;\n            return V = L(t) ? ot((8 * (s.from + H)).toString(16), a, \"0\") : ot((s.from + H + 1).toString(), a, \" \"), [].concat(w, [Y + V + \" | \" + C], X ? [yt + it(\" \", a) + \" | \" + ot(\"\", n, \" \") + it(\"^\", S)] : []);\n          }, [], u).join(`\n`);\n        }\n        function Et(t, r) {\n          return [`\n`, \"-- PARSING FAILED \" + it(\"-\", 50), `\n\n`, Mt(t, r), `\n\n`, (n = r.expected, n.length === 1 ? `Expected:\n\n` + n[0] : `Expected one of the following: \n\n` + n.join(\", \")), `\n`].join(\"\");\n          var n;\n        }\n        function wt(t) {\n          return t.flags !== void 0 ? t.flags : [t.global ? \"g\" : \"\", t.ignoreCase ? \"i\" : \"\", t.multiline ? \"m\" : \"\", t.unicode ? \"u\" : \"\", t.sticky ? \"y\" : \"\"].join(\"\");\n        }\n        function ut() {\n          for (var t = [].slice.call(arguments), r = t.length, n = 0; n < r; n += 1) G(t[n]);\n          return o(function(i, u) {\n            for (var s, a = new Array(r), h = 0; h < r; h += 1) {\n              if (!(s = j(t[h]._(i, u), s)).status) return s;\n              a[h] = s.value, u = s.index;\n            }\n            return j(d(u, a), s);\n          });\n        }\n        function F() {\n          var t = [].slice.call(arguments);\n          if (t.length === 0) throw new Error(\"seqMap needs at least one argument\");\n          var r = t.pop();\n          return M(r), ut.apply(null, t).map(function(n) {\n            return r.apply(null, n);\n          });\n        }\n        function st() {\n          var t = [].slice.call(arguments), r = t.length;\n          if (r === 0) return at(\"zero alternates\");\n          for (var n = 0; n < r; n += 1) G(t[n]);\n          return o(function(i, u) {\n            for (var s, a = 0; a < t.length; a += 1) if ((s = j(t[a]._(i, u), s)).status) return s;\n            return s;\n          });\n        }\n        function xt(t, r) {\n          return pt(t, r).or(z([]));\n        }\n        function pt(t, r) {\n          return G(t), G(r), F(t, r.then(t).many(), function(n, i) {\n            return [n].concat(i);\n          });\n        }\n        function K(t) {\n          J(t);\n          var r = \"'\" + t + \"'\";\n          return o(function(n, i) {\n            var u = i + t.length, s = n.slice(i, u);\n            return s === t ? d(u, s) : B(i, r);\n          });\n        }\n        function A(t, r) {\n          (function(u) {\n            if (!(u instanceof RegExp)) throw new Error(\"not a regexp: \" + u);\n            for (var s = wt(u), a = 0; a < s.length; a++) {\n              var h = s.charAt(a);\n              if (h !== \"i\" && h !== \"m\" && h !== \"u\" && h !== \"s\") throw new Error('unsupported regexp flag \"' + h + '\": ' + u);\n            }\n          })(t), arguments.length >= 2 ? U(r) : r = 0;\n          var n = function(u) {\n            return RegExp(\"^(?:\" + u.source + \")\", wt(u));\n          }(t), i = \"\" + t;\n          return o(function(u, s) {\n            var a = n.exec(u.slice(s));\n            if (a) {\n              if (0 <= r && r <= a.length) {\n                var h = a[0], b = a[r];\n                return d(s + h.length, b);\n              }\n              return B(s, \"valid match group (0 to \" + a.length + \") in \" + i);\n            }\n            return B(s, i);\n          });\n        }\n        function z(t) {\n          return o(function(r, n) {\n            return d(n, t);\n          });\n        }\n        function at(t) {\n          return o(function(r, n) {\n            return B(n, t);\n          });\n        }\n        function ft(t) {\n          if (g(t)) return o(function(r, n) {\n            var i = t._(r, n);\n            return i.index = n, i.value = \"\", i;\n          });\n          if (typeof t == \"string\") return ft(K(t));\n          if (t instanceof RegExp) return ft(A(t));\n          throw new Error(\"not a string, regexp, or parser: \" + t);\n        }\n        function Nt(t) {\n          return G(t), o(function(r, n) {\n            var i = t._(r, n), u = r.slice(n, i.index);\n            return i.status ? B(n, 'not \"' + u + '\"') : d(n, null);\n          });\n        }\n        function ct(t) {\n          return M(t), o(function(r, n) {\n            var i = et(r, n);\n            return n < r.length && t(i) ? d(n + 1, i) : B(n, \"a character/byte matching \" + t);\n          });\n        }\n        function St(t, r) {\n          arguments.length < 2 && (r = t, t = void 0);\n          var n = o(function(i, u) {\n            return n._ = r()._, n._(i, u);\n          });\n          return t ? n.desc(t) : n;\n        }\n        function mt() {\n          return at(\"fantasy-land/empty\");\n        }\n        f.parse = function(t) {\n          if (typeof t != \"string\" && !L(t)) throw new Error(\".parse must be called with a string or Buffer as its argument\");\n          var r, n = this.skip(gt)._(t, 0);\n          return r = n.status ? { status: !0, value: n.value } : { status: !1, index: bt(t, n.furthest), expected: n.expected }, delete nt[t], r;\n        }, f.tryParse = function(t) {\n          var r = this.parse(t);\n          if (r.status) return r.value;\n          var n = Et(t, r), i = new Error(n);\n          throw i.type = \"ParsimmonError\", i.result = r, i;\n        }, f.assert = function(t, r) {\n          return this.chain(function(n) {\n            return t(n) ? z(n) : at(r);\n          });\n        }, f.or = function(t) {\n          return st(this, t);\n        }, f.trim = function(t) {\n          return this.wrap(t, t);\n        }, f.wrap = function(t, r) {\n          return F(t, this, r, function(n, i) {\n            return i;\n          });\n        }, f.thru = function(t) {\n          return t(this);\n        }, f.then = function(t) {\n          return G(t), ut(this, t).map(function(r) {\n            return r[1];\n          });\n        }, f.many = function() {\n          var t = this;\n          return o(function(r, n) {\n            for (var i = [], u = void 0; ; ) {\n              if (!(u = j(t._(r, n), u)).status) return j(d(n, i), u);\n              if (n === u.index) throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n              n = u.index, i.push(u.value);\n            }\n          });\n        }, f.tieWith = function(t) {\n          return J(t), this.map(function(r) {\n            if (function(u) {\n              if (!E(u)) throw new Error(\"not an array: \" + u);\n            }(r), r.length) {\n              J(r[0]);\n              for (var n = r[0], i = 1; i < r.length; i++) J(r[i]), n += t + r[i];\n              return n;\n            }\n            return \"\";\n          });\n        }, f.tie = function() {\n          return this.tieWith(\"\");\n        }, f.times = function(t, r) {\n          var n = this;\n          return arguments.length < 2 && (r = t), U(t), U(r), o(function(i, u) {\n            for (var s = [], a = void 0, h = void 0, b = 0; b < t; b += 1) {\n              if (h = j(a = n._(i, u), h), !a.status) return h;\n              u = a.index, s.push(a.value);\n            }\n            for (; b < r && (h = j(a = n._(i, u), h), a.status); b += 1) u = a.index, s.push(a.value);\n            return j(d(u, s), h);\n          });\n        }, f.result = function(t) {\n          return this.map(function() {\n            return t;\n          });\n        }, f.atMost = function(t) {\n          return this.times(0, t);\n        }, f.atLeast = function(t) {\n          return F(this.times(t), this.many(), function(r, n) {\n            return r.concat(n);\n          });\n        }, f.map = function(t) {\n          M(t);\n          var r = this;\n          return o(function(n, i) {\n            var u = r._(n, i);\n            return u.status ? j(d(u.index, t(u.value)), u) : u;\n          });\n        }, f.contramap = function(t) {\n          M(t);\n          var r = this;\n          return o(function(n, i) {\n            var u = r.parse(t(n.slice(i)));\n            return u.status ? d(i + n.length, u.value) : u;\n          });\n        }, f.promap = function(t, r) {\n          return M(t), M(r), this.contramap(t).map(r);\n        }, f.skip = function(t) {\n          return ut(this, t).map(function(r) {\n            return r[0];\n          });\n        }, f.mark = function() {\n          return F(Q, this, Q, function(t, r, n) {\n            return { start: t, value: r, end: n };\n          });\n        }, f.node = function(t) {\n          return F(Q, this, Q, function(r, n, i) {\n            return { name: t, value: n, start: r, end: i };\n          });\n        }, f.sepBy = function(t) {\n          return xt(this, t);\n        }, f.sepBy1 = function(t) {\n          return pt(this, t);\n        }, f.lookahead = function(t) {\n          return this.skip(ft(t));\n        }, f.notFollowedBy = function(t) {\n          return this.skip(Nt(t));\n        }, f.desc = function(t) {\n          E(t) || (t = [t]);\n          var r = this;\n          return o(function(n, i) {\n            var u = r._(n, i);\n            return u.status || (u.expected = t), u;\n          });\n        }, f.fallback = function(t) {\n          return this.or(z(t));\n        }, f.ap = function(t) {\n          return F(t, this, function(r, n) {\n            return r(n);\n          });\n        }, f.chain = function(t) {\n          var r = this;\n          return o(function(n, i) {\n            var u = r._(n, i);\n            return u.status ? j(t(u.value)._(n, u.index), u) : u;\n          });\n        }, f.concat = f.or, f.empty = mt, f.of = z, f[\"fantasy-land/ap\"] = f.ap, f[\"fantasy-land/chain\"] = f.chain, f[\"fantasy-land/concat\"] = f.concat, f[\"fantasy-land/empty\"] = f.empty, f[\"fantasy-land/of\"] = f.of, f[\"fantasy-land/map\"] = f.map;\n        var Q = o(function(t, r) {\n          return d(r, bt(t, r));\n        }), Ft = o(function(t, r) {\n          return r >= t.length ? B(r, \"any character/byte\") : d(r + 1, et(t, r));\n        }), zt = o(function(t, r) {\n          return d(t.length, t.slice(r));\n        }), gt = o(function(t, r) {\n          return r < t.length ? B(r, \"EOF\") : d(r, null);\n        }), Vt = A(/[0-9]/).desc(\"a digit\"), Dt = A(/[0-9]*/).desc(\"optional digits\"), Wt = A(/[a-z]/i).desc(\"a letter\"), $t = A(/[a-z]*/i).desc(\"optional letters\"), Gt = A(/\\s*/).desc(\"optional whitespace\"), Ut = A(/\\s+/).desc(\"whitespace\"), Bt = K(\"\\r\"), _t = K(`\n`), Pt = K(`\\r\n`), jt = st(Pt, _t, Bt).desc(\"newline\"), Tt = st(jt, gt);\n        o.all = zt, o.alt = st, o.any = Ft, o.cr = Bt, o.createLanguage = function(t) {\n          var r = {};\n          for (var n in t) ({}).hasOwnProperty.call(t, n) && function(i) {\n            r[i] = St(function() {\n              return t[i](r);\n            });\n          }(n);\n          return r;\n        }, o.crlf = Pt, o.custom = function(t) {\n          return o(t(d, B));\n        }, o.digit = Vt, o.digits = Dt, o.empty = mt, o.end = Tt, o.eof = gt, o.fail = at, o.formatError = Et, o.index = Q, o.isParser = g, o.lazy = St, o.letter = Wt, o.letters = $t, o.lf = _t, o.lookahead = ft, o.makeFailure = B, o.makeSuccess = d, o.newline = jt, o.noneOf = function(t) {\n          return ct(function(r) {\n            return t.indexOf(r) < 0;\n          }).desc(\"none of '\" + t + \"'\");\n        }, o.notFollowedBy = Nt, o.of = z, o.oneOf = function(t) {\n          for (var r = t.split(\"\"), n = 0; n < r.length; n++) r[n] = \"'\" + r[n] + \"'\";\n          return ct(function(i) {\n            return t.indexOf(i) >= 0;\n          }).desc(r);\n        }, o.optWhitespace = Gt, o.Parser = o, o.range = function(t, r) {\n          return ct(function(n) {\n            return t <= n && n <= r;\n          }).desc(t + \"-\" + r);\n        }, o.regex = A, o.regexp = A, o.sepBy = xt, o.sepBy1 = pt, o.seq = ut, o.seqMap = F, o.seqObj = function() {\n          for (var t, r = {}, n = 0, i = (t = arguments, Array.prototype.slice.call(t)), u = i.length, s = 0; s < u; s += 1) {\n            var a = i[s];\n            if (!g(a)) {\n              if (E(a) && a.length === 2 && typeof a[0] == \"string\" && g(a[1])) {\n                var h = a[0];\n                if (Object.prototype.hasOwnProperty.call(r, h)) throw new Error(\"seqObj: duplicate key \" + h);\n                r[h] = !0, n++;\n                continue;\n              }\n              throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n            }\n          }\n          if (n === 0) throw new Error(\"seqObj expects at least one named parser, found zero\");\n          return o(function(b, S) {\n            for (var N, k = {}, _ = 0; _ < u; _ += 1) {\n              var q, T;\n              if (E(i[_]) ? (q = i[_][0], T = i[_][1]) : (q = null, T = i[_]), !(N = j(T._(b, S), N)).status) return N;\n              q && (k[q] = N.value), S = N.index;\n            }\n            return j(d(S, k), N);\n          });\n        }, o.string = K, o.succeed = z, o.takeWhile = function(t) {\n          return M(t), o(function(r, n) {\n            for (var i = n; i < r.length && t(et(r, i)); ) i++;\n            return d(i, r.slice(n, i));\n          });\n        }, o.test = ct, o.whitespace = Ut, o[\"fantasy-land/empty\"] = mt, o[\"fantasy-land/of\"] = z, o.Binary = { bitSeq: rt, bitSeqObj: function(t) {\n          D();\n          var r = {}, n = 0, i = O(function(s) {\n            if (E(s)) {\n              var a = s;\n              if (a.length !== 2) throw new Error(\"[\" + a.join(\", \") + \"] should be length 2, got length \" + a.length);\n              if (J(a[0]), U(a[1]), Object.prototype.hasOwnProperty.call(r, a[0])) throw new Error(\"duplicate key in bitSeqObj: \" + a[0]);\n              return r[a[0]] = !0, n++, a;\n            }\n            return U(s), [null, s];\n          }, t);\n          if (n < 1) throw new Error(\"bitSeqObj expects at least one named pair, got [\" + t.join(\", \") + \"]\");\n          var u = O(function(s) {\n            return s[0];\n          }, i);\n          return rt(O(function(s) {\n            return s[1];\n          }, i)).map(function(s) {\n            return x(function(a, h) {\n              return h[0] !== null && (a[h[0]] = h[1]), a;\n            }, {}, O(function(a, h) {\n              return [a, s[h]];\n            }, u));\n          });\n        }, byte: function(t) {\n          if (D(), U(t), t > 255) throw new Error(\"Value specified to byte constructor (\" + t + \"=0x\" + t.toString(16) + \") is larger in value than a single byte.\");\n          var r = (t > 15 ? \"0x\" : \"0x0\") + t.toString(16);\n          return o(function(n, i) {\n            var u = et(n, i);\n            return u === t ? d(i + 1, u) : B(i, r);\n          });\n        }, buffer: function(t) {\n          return P(\"buffer\", t).map(function(r) {\n            return Buffer.from(r);\n          });\n        }, encodedString: function(t, r) {\n          return P(\"string\", r).map(function(n) {\n            return n.toString(t);\n          });\n        }, uintBE: Z, uint8BE: Z(1), uint16BE: Z(2), uint32BE: Z(4), uintLE: $, uint8LE: $(1), uint16LE: $(2), uint32LE: $(4), intBE: p, int8BE: p(1), int16BE: p(2), int32BE: p(4), intLE: y, int8LE: y(1), int16LE: y(2), int32LE: y(4), floatBE: P(\"floatBE\", 4).map(function(t) {\n          return t.readFloatBE(0);\n        }), floatLE: P(\"floatLE\", 4).map(function(t) {\n          return t.readFloatLE(0);\n        }), doubleBE: P(\"doubleBE\", 8).map(function(t) {\n          return t.readDoubleBE(0);\n        }), doubleLE: P(\"doubleLE\", 8).map(function(t) {\n          return t.readDoubleLE(0);\n        }) }, c.exports = o;\n      }]);\n    });\n  }(lt)), lt.exports;\n}\nvar m = Xt();\nclass Lt {\n  constructor(e, c = \"\\\\\") {\n    this.val = e;\n    function l(p) {\n      const y = [];\n      for (const g of p) y.push(\n        (typeof g == \"string\" ? m.string(g) : m.regex(g)).trim(m.optWhitespace)\n      );\n      return m.alt.apply(null, y);\n    }\n    function v(p) {\n      let g = Object.keys(p).sort().map(\n        (E) => (typeof p[E] == \"string\" ? m.string(p[E]) : m.regex(p[E])).trim(m.optWhitespace).result(E)\n      );\n      return m.alt.apply(null, g);\n    }\n    function o(p, y) {\n      const g = m.lazy(() => m.seq(p, g).or(y));\n      return g;\n    }\n    function f(p, y) {\n      return m.seqMap(y, p.many(), (g, E) => E.reduce((L, d) => [d, L], g));\n    }\n    function I(p, y) {\n      let g = m.lazy(\n        () => y.chain(\n          (E) => m.seq(\n            p,\n            m.of(E),\n            g\n          ).or(m.of(E))\n        )\n      );\n      return g;\n    }\n    function x(p, y) {\n      return m.seqMap(\n        y,\n        m.seq(p, y).many(),\n        (g, E) => E.reduce((L, d) => [d[0], L, d[1]], g)\n      );\n    }\n    const O = m.alt(\n      m.alt(\n        m.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        m.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      m.alt(\n        m.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((p) => (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.i)(p))\n    ).map((p) => [\"!num!\", p]).desc(\"number\"), ht = m.string(\"null\").map(() => [\"!str!\", null]), tt = m.regex(/(true|false)/).map((p) => [\"!bool!\", p === \"true\"]).desc(\"boolean\"), D = m.regex(new RegExp(`(?:\"(?:\\\\${c}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${c}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${c}[\"'#\\\\n]|[^#])*\\\\#)`)).map((p) => [\"!str!\", p.slice(1, -1).replaceAll(c, \"\")]).desc(\"string\"), rt = /\\[[^\\]]+\\]/g, P = m.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((p) => {\n      const y = String(p).replaceAll(\n        rt,\n        (E) => \".\" + this.parse(E.slice(1, -1))\n      ), g = this.val.getVal(y);\n      return g == null ? [\"!str!\", g] : typeof g == \"boolean\" ? [\"!bool!\", g] : Object.prototype.toString.call(g) === \"[object String]\" ? [\"!str!\", String(g)] : [\"!num!\", Number(g)];\n    }).desc(\"string\"), W = m.lazy(\n      () => m.string(\"(\").then(this.#e).skip(m.string(\")\")).or(O).or(ht).or(tt).or(D).or(P)\n    ), $ = [\n      // 演算子の優先順位 - JavaScript | MDN https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_precedence\n      // 優先順位：18（メンバーへのアクセス、計算値によるメンバーへのアクセス）\n      // a.b  a[b]\n      { type: o, ops: l([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      // 優先順位：16\n      { type: f, ops: v({ PostfixInc: \"++\" }) },\n      { type: f, ops: v({ PostfixDec: \"--\" }) },\n      // 【未サポート】後置インクリメント・デクリメント\n      // 優先順位：15\n      { type: o, ops: l([/!(?!=)|~/]) },\n      // 論理 NOT (!)、ビット単位 NOT (~)\n      { type: o, ops: v({ PrefixInc: \"++\" }) },\n      { type: o, ops: v({ PrefixDec: \"--\" }) },\n      // 【未サポート】前置インクリメント・デクリメント\n      //\t{type: PREFIX, ops: opeH({Unaryplus: /\\+(?!\\+)/})},\t// 単項プラス\n      { type: o, ops: v({ UnaryNegate: /-(?!-)/ }) },\n      // 単項マイナス\n      // 優先順位：14以下（並びに注意）\n      { type: I, ops: l([\"**\"]) },\n      { type: x, ops: l([\"*\", \"/\", \"¥\", \"%\"]) },\n      { type: x, ops: l([\"+\", \"-\"]) },\n      { type: x, ops: l([/>>>|<<|>>/]) },\n      { type: x, ops: l([/<=|<|>=|>/]) },\n      { type: x, ops: l([/===|!==|==|!=/]) },\n      { type: x, ops: l([/&(?!&)/]) },\n      { type: x, ops: l([\"^\"]) },\n      { type: x, ops: l([/\\|(?!\\|)/]) },\n      { type: x, ops: l([\"&&\"]) },\n      { type: x, ops: l([\"||\"]) },\n      { type: I, ops: l([\":\"]) },\n      { type: I, ops: l([\"?\"]) }\n    ].reduce(\n      (p, y) => y.type(y.ops, p),\n      W\n    );\n    this.#e = $.trim(m.optWhitespace);\n  }\n  #e = null;\n  parse(e) {\n    const c = this.#e.parse(e);\n    if (!c.status) throw Error(\"(PropParser)文法エラー【\" + e + \"】\");\n    const l = c.value;\n    return l[0] === \"!str!\" ? this.#i(l[1]) : this.#t(l);\n  }\n  #t(e) {\n    const c = e.shift();\n    if (c instanceof Array) return this.#t(c);\n    const l = this.#r[c];\n    return l ? l(e) : Object(null);\n  }\n  #r = {\n    \"!num!\": (e) => e.shift(),\n    \"!str!\": (e) => this.#i(e.shift()),\n    \"!bool!\": (e) => e.shift(),\n    PostfixInc: (e) => {\n      throw Error(\"(PropParser)後置インクリメントは未サポートです\");\n    },\n    PostfixDec: (e) => {\n      throw Error(\"(PropParser)後置デクリメントは未サポートです\");\n    },\n    PrefixInc: (e) => {\n      throw Error(\"(PropParser)前置インクリメントは未サポートです\");\n    },\n    PrefixDec: (e) => {\n      throw Error(\"(PropParser)前置デクリメントは未サポートです\");\n    },\n    // 論理 NOT\n    \"!\": (e) => !this.#r.Boolean(e),\n    // チルダ演算子（ビット反転）\n    \"~\": (e) => ~Number(this.#t(e.shift())),\n    //\t\tUnaryNegate:\ta=> - Number(this.#calc(a.shift())),\n    UnaryNegate: (e) => -this.#r.Number(e),\n    //\tUnaryplus:\t\ta=> this.#hFnc['Number'](a),\n    // 乗算、除算、剰余\n    \"**\": (e) => Number(this.#t(e.shift())) ** Number(this.#t(e.shift())),\n    \"*\": (e) => Number(this.#t(e.shift())) * Number(this.#t(e.shift())),\n    \"/\": (e) => Number(this.#t(e.shift())) / Number(this.#t(e.shift())),\n    \"¥\": (e) => Math.floor(this.#r[\"/\"](e)),\n    \"%\": (e) => Number(this.#t(e.shift())) % Number(this.#t(e.shift())),\n    // 加算、減算、文字列の連結\n    \"+\": (e) => {\n      const c = this.#t(e.shift()), l = this.#t(e.shift());\n      return Object.prototype.toString.call(c) === \"[object String]\" || Object.prototype.toString.call(l) === \"[object String]\" ? String(c) + String(l) : Number(c) + Number(l);\n    },\n    \"-\": (e) => Number(this.#t(e.shift())) - Number(this.#t(e.shift())),\n    // 関数\n    int: (e) => (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.i)(this.#n(e.shift())),\n    parseInt: (e) => (0,_web2_js__WEBPACK_IMPORTED_MODULE_0__.i)(this.#r.Number(e)),\n    Number: (e) => {\n      const c = this.#t(e.shift());\n      return Object.prototype.toString.call(c) === \"[object String]\" ? this.#n(this.#e.parse(String(c)).value) : Number(c);\n    },\n    Boolean: (e) => {\n      const c = e.shift();\n      return c[0] === \"!bool!\" ? !!c[1] : !!this.#t(c);\n    },\n    ceil: (e) => Math.ceil(this.#n(e.shift())),\n    floor: (e) => Math.floor(this.#n(e.shift())),\n    round: (e) => Math.round(this.#n(e.shift())),\n    isNaN: (e) => Number.isNaN(this.#n(e.shift())),\n    // ビットシフト\n    \"<<\": (e) => Number(this.#t(e.shift())) << Number(this.#t(e.shift())),\n    \">>\": (e) => Number(this.#t(e.shift())) >> Number(this.#t(e.shift())),\n    \">>>\": (e) => Number(this.#t(e.shift())) >>> Number(this.#t(e.shift())),\n    // 等値、非等値、厳密等価、厳密非等価\n    \"<\": (e) => Number(this.#t(e.shift())) < Number(this.#t(e.shift())),\n    \"<=\": (e) => Number(this.#t(e.shift())) <= Number(this.#t(e.shift())),\n    \">\": (e) => Number(this.#t(e.shift())) > Number(this.#t(e.shift())),\n    \">=\": (e) => Number(this.#t(e.shift())) >= Number(this.#t(e.shift())),\n    // 小なり、以下、大なり、以上\n    \"==\": (e) => {\n      const c = this.#t(e.shift()), l = this.#t(e.shift());\n      return c == null && l == null && (!c || !l) ? c == l : String(c) === String(l);\n    },\n    \"!=\": (e) => !this.#r[\"==\"](e),\n    \"===\": (e) => {\n      const c = this.#t(e.shift()), l = this.#t(e.shift());\n      return Object.prototype.toString.call(c) != Object.prototype.toString.call(l) ? !1 : String(c) === String(l);\n    },\n    \"!==\": (e) => !this.#r[\"===\"](e),\n    // ビット演算子\n    \"&\": (e) => Number(this.#t(e.shift())) & Number(this.#t(e.shift())),\n    \"^\": (e) => Number(this.#t(e.shift())) ^ Number(this.#t(e.shift())),\n    \"|\": (e) => Number(this.#t(e.shift())) | Number(this.#t(e.shift())),\n    // 論理 AND,OR\n    \"&&\": (e) => String(this.#t(e.shift())) === \"true\" && String(this.#t(e.shift())) === \"true\",\n    \"||\": (e) => String(this.#t(e.shift())) === \"true\" || String(this.#t(e.shift())) === \"true\",\n    // 条件\n    \"?\": (e) => {\n      const c = this.#r.Boolean(e), l = e.shift();\n      if (l[0] !== \":\") throw Error(\"(PropParser)三項演算子の文法エラーです。: が見つかりません\");\n      return this.#t(l[c ? 1 : 2]);\n    },\n    \":\": () => {\n      throw Error(\"(PropParser)三項演算子の文法エラーです。? が見つかりません\");\n    }\n  };\n  #n(e) {\n    const c = this.#t(e);\n    if (Object.prototype.toString.call(c) !== \"[object Number]\") throw Error(\"(PropParser)引数【\" + c + \"】が数値ではありません\");\n    return Number(c);\n  }\n  #o = /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g;\n  #i(e) {\n    return e == null ? e : String(e).replaceAll(\n      this.#o,\n      (c) => c.startsWith(\"$\") ? this.val.getVal(c.slice(1)) : this.parse(c.slice(2, -1))\n    );\n  }\n  getValAmpersand = (e) => e.startsWith(\"&\") ? String(this.parse(e.slice(1))) : e;\n  static #u = /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/;\n  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1\n  // →これは改良しようがない。いい意味で改善の余地なし\n  static getValName(e) {\n    const l = this.#u.exec(e.trim())?.groups;\n    if (!l) return null;\n    const { scope: v = \"tmp\", name: o, at: f = \"\" } = l;\n    return {\n      scope: v,\n      name: Lt.#s(o),\n      at: f\n    };\n  }\n  static #s(e) {\n    let c = 0, l = 0;\n    for (; ; ) {\n      if (c = e.indexOf('[\"'), c < 0) {\n        if (c = e.indexOf(\"['\"), c < 0) break;\n        l = e.indexOf(\"']\", c + 2);\n      } else\n        l = e.indexOf('\"]', c + 2);\n      if (l < 0) break;\n      e = e.slice(0, c) + \".\" + e.slice(c + 2, l) + e.slice(l + 2), c = l - 2;\n    }\n    return e;\n  }\n}\n\n//# sourceMappingURL=PropParser.js.map\n\n\n//# sourceURL=webpack://gallery/../skynovel/dist/PropParser.js?");

/***/ })

}]);