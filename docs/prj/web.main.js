/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../skynovel/dist/web.js":
/*!*******************************!*\
  !*** ../skynovel/dist/web.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ CmnLib),\n/* harmony export */   \"Layer\": () => (/* binding */ Layer),\n/* harmony export */   \"SysWeb\": () => (/* binding */ SysWeb),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ argChk_Boolean),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ argChk_Num)\n/* harmony export */ });\nvar Cp = Object.defineProperty;\nvar Rp = (r, t, e) => t in r ? Cp(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar Pt = (r, t, e) => (Rp(r, typeof t != \"symbol\" ? t + \"\" : t, e), e), Lc = (r, t, e) => {\n  if (!t.has(r))\n    throw TypeError(\"Cannot \" + e);\n};\nvar H = (r, t, e) => (Lc(r, t, \"read from private field\"), e ? e.call(r) : t.get(r)), rt = (r, t, e) => {\n  if (t.has(r))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(r) : t.set(r, e);\n}, nt = (r, t, e, o) => (Lc(r, t, \"write to private field\"), o ? o.call(r, e) : t.set(r, e), e), Pe = (r, t, e, o) => ({\n  set _(T) {\n    nt(r, t, T, e);\n  },\n  get _() {\n    return H(r, t, o);\n  }\n}), ot = (r, t, e) => (Lc(r, t, \"access private method\"), e);\nvar commonjsGlobal$1 = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {}, platform$1 = { exports: {} };\n/*!\n * Platform.js v1.3.6\n * Copyright 2014-2020 Benjamin Tan\n * Copyright 2011-2013 John-David Dalton\n * Available under MIT license\n */\n(function(r, t) {\n  (function() {\n    var e = {\n      function: !0,\n      object: !0\n    }, o = e[typeof window] && window || this, T = t, S = r && !r.nodeType && r, N = T && S && typeof commonjsGlobal$1 == \"object\" && commonjsGlobal$1;\n    N && (N.global === N || N.window === N || N.self === N) && (o = N);\n    var D = Math.pow(2, 53) - 1, B = /\\bOpera/, $ = Object.prototype, U = $.hasOwnProperty, z = $.toString;\n    function V(it) {\n      return it = String(it), it.charAt(0).toUpperCase() + it.slice(1);\n    }\n    function X(it, st, ut) {\n      var ft = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      return st && ut && /^Win/i.test(it) && !/^Windows Phone /i.test(it) && (ft = ft[/[\\d.]+$/.exec(it)]) && (it = \"Windows \" + ft), it = String(it), st && ut && (it = it.replace(RegExp(st, \"i\"), ut)), it = Y(\n        it.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]\n      ), it;\n    }\n    function W(it, st) {\n      var ut = -1, ft = it ? it.length : 0;\n      if (typeof ft == \"number\" && ft > -1 && ft <= D)\n        for (; ++ut < ft; )\n          st(it[ut], ut, it);\n      else\n        q(it, st);\n    }\n    function Y(it) {\n      return it = et(it), /^(?:webOS|i(?:OS|P))/.test(it) ? it : V(it);\n    }\n    function q(it, st) {\n      for (var ut in it)\n        U.call(it, ut) && st(it[ut], ut, it);\n    }\n    function Z(it) {\n      return it == null ? V(it) : z.call(it).slice(8, -1);\n    }\n    function K(it, st) {\n      var ut = it != null ? typeof it[st] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(ut) && (ut == \"object\" ? !!it[st] : !0);\n    }\n    function J(it) {\n      return String(it).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function tt(it, st) {\n      var ut = null;\n      return W(it, function(ft, ct) {\n        ut = st(ut, ft, ct, it);\n      }), ut;\n    }\n    function et(it) {\n      return String(it).replace(/^ +| +$/g, \"\");\n    }\n    function Q(it) {\n      var st = o, ut = it && typeof it == \"object\" && Z(it) != \"String\";\n      ut && (st = it, it = null);\n      var ft = st.navigator || {}, ct = ft.userAgent || \"\";\n      it || (it = ct);\n      var pt = ut ? !!ft.likeChrome : /\\bChrome\\b/.test(it) && !/internal|\\n/i.test(z.toString()), mt = \"Object\", vt = ut ? mt : \"ScriptBridgingProxyObject\", _t = ut ? mt : \"Environment\", xt = ut && st.java ? \"JavaPackage\" : Z(st.java), Rt = ut ? mt : \"RuntimeObject\", yt = /\\bJava/.test(xt) && st.java, ht = yt && Z(st.environment) == _t, bt = yt ? \"a\" : \"\\u03B1\", St = yt ? \"b\" : \"\\u03B2\", Ot = st.document || {}, wt = st.operamini || st.opera, Ft = B.test(Ft = ut && wt ? wt[\"[[Class]]\"] : Z(wt)) ? Ft : wt = null, dt, Gt = it, Mt = [], Bt = null, Dt = it == ct, Et = Dt && wt && typeof wt.version == \"function\" && wt.version(), zt, It = ee([\n        { label: \"EdgeHTML\", pattern: \"Edge\" },\n        \"Trident\",\n        { label: \"WebKit\", pattern: \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]), Ct = he([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { label: \"Microsoft Edge\", pattern: \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { label: \"Samsung Internet\", pattern: \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { label: \"Silk\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { label: \"SRWare Iron\", pattern: \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { label: \"Yandex Browser\", pattern: \"YaBrowser\" },\n        { label: \"UC Browser\", pattern: \"UCBrowser\" },\n        \"Opera Mini\",\n        { label: \"Opera Mini\", pattern: \"OPiOS\" },\n        \"Opera\",\n        { label: \"Opera\", pattern: \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { label: \"Chrome\", pattern: \"(?:HeadlessChrome)\" },\n        { label: \"Chrome Mobile\", pattern: \"(?:CriOS|CrMo)\" },\n        { label: \"Firefox\", pattern: \"(?:Firefox|Minefield)\" },\n        { label: \"Firefox for iOS\", pattern: \"FxiOS\" },\n        { label: \"IE\", pattern: \"IEMobile\" },\n        { label: \"IE\", pattern: \"MSIE\" },\n        \"Safari\"\n      ]), Lt = Be([\n        { label: \"BlackBerry\", pattern: \"BB10\" },\n        \"BlackBerry\",\n        { label: \"Galaxy S\", pattern: \"GT-I9000\" },\n        { label: \"Galaxy S2\", pattern: \"GT-I9100\" },\n        { label: \"Galaxy S3\", pattern: \"GT-I9300\" },\n        { label: \"Galaxy S4\", pattern: \"GT-I9500\" },\n        { label: \"Galaxy S5\", pattern: \"SM-G900\" },\n        { label: \"Galaxy S6\", pattern: \"SM-G920\" },\n        { label: \"Galaxy S6 Edge\", pattern: \"SM-G925\" },\n        { label: \"Galaxy S7\", pattern: \"SM-G930\" },\n        { label: \"Galaxy S7 Edge\", pattern: \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { label: \"Kindle Fire\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { label: \"Wii U\", pattern: \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { label: \"Xbox 360\", pattern: \"Xbox\" },\n        \"Xoom\"\n      ]), $t = te({\n        Apple: { iPad: 1, iPhone: 1, iPod: 1 },\n        Alcatel: {},\n        Archos: {},\n        Amazon: { Kindle: 1, \"Kindle Fire\": 1 },\n        Asus: { Transformer: 1 },\n        \"Barnes & Noble\": { Nook: 1 },\n        BlackBerry: { PlayBook: 1 },\n        Google: { \"Google TV\": 1, Nexus: 1 },\n        HP: { TouchPad: 1 },\n        HTC: {},\n        Huawei: {},\n        Lenovo: {},\n        LG: {},\n        Microsoft: { Xbox: 1, \"Xbox One\": 1 },\n        Motorola: { Xoom: 1 },\n        Nintendo: { \"Wii U\": 1, Wii: 1 },\n        Nokia: { Lumia: 1 },\n        Oppo: {},\n        Samsung: { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        Sony: { PlayStation: 1, \"PlayStation Vita\": 1 },\n        Xiaomi: { Mi: 1, Redmi: 1 }\n      }), At = we([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { label: \"Chrome OS\", pattern: \"CrOS\" },\n        \"Debian\",\n        { label: \"DragonFly BSD\", pattern: \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function ee(de) {\n        return tt(de, function(ce, ie) {\n          return ce || RegExp(\"\\\\b\" + (ie.pattern || J(ie)) + \"\\\\b\", \"i\").exec(it) && (ie.label || ie);\n        });\n      }\n      function te(de) {\n        return tt(de, function(ce, ie, Le) {\n          return ce || (ie[Lt] || ie[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(Lt)] || RegExp(\"\\\\b\" + J(Le) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(it)) && Le;\n        });\n      }\n      function he(de) {\n        return tt(de, function(ce, ie) {\n          return ce || RegExp(\"\\\\b\" + (ie.pattern || J(ie)) + \"\\\\b\", \"i\").exec(it) && (ie.label || ie);\n        });\n      }\n      function we(de) {\n        return tt(de, function(ce, ie) {\n          var Le = ie.pattern || J(ie);\n          return !ce && (ce = RegExp(\"\\\\b\" + Le + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(it)) && (ce = X(ce, Le, ie.label || ie)), ce;\n        });\n      }\n      function Be(de) {\n        return tt(de, function(ce, ie) {\n          var Le = ie.pattern || J(ie);\n          return !ce && (ce = RegExp(\"\\\\b\" + Le + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(it) || RegExp(\"\\\\b\" + Le + \" *\\\\w+-[\\\\w]*\", \"i\").exec(it) || RegExp(\"\\\\b\" + Le + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(it)) && ((ce = String(ie.label && !RegExp(Le, \"i\").test(ie.label) ? ie.label : ce).split(\"/\"))[1] && !/[\\d.]+/.test(ce[0]) && (ce[0] += \" \" + ce[1]), ie = ie.label || ie, ce = Y(ce[0].replace(RegExp(Le, \"i\"), ie).replace(RegExp(\"; *(?:\" + ie + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + ie + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"))), ce;\n        });\n      }\n      function ne(de) {\n        return tt(de, function(ce, ie) {\n          return ce || (RegExp(ie + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(it) || 0)[1] || null;\n        });\n      }\n      function Me() {\n        return this.description || \"\";\n      }\n      if (It && (It = [It]), /\\bAndroid\\b/.test(At) && !Lt && (dt = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(it)) && (Lt = et(dt[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null), $t && !Lt ? Lt = Be([$t]) : $t && Lt && (Lt = Lt.replace(RegExp(\"^(\" + J($t) + \")[-_.\\\\s]\", \"i\"), $t + \" \").replace(RegExp(\"^(\" + J($t) + \")[-_.]?(\\\\w)\", \"i\"), $t + \" $2\")), (dt = /\\bGoogle TV\\b/.exec(Lt)) && (Lt = dt[0]), /\\bSimulator\\b/i.test(it) && (Lt = (Lt ? Lt + \" \" : \"\") + \"Simulator\"), Ct == \"Opera Mini\" && /\\bOPiOS\\b/.test(it) && Mt.push(\"running in Turbo/Uncompressed mode\"), Ct == \"IE\" && /\\blike iPhone OS\\b/.test(it) ? (dt = Q(it.replace(/like iPhone OS/, \"\")), $t = dt.manufacturer, Lt = dt.product) : /^iP/.test(Lt) ? (Ct || (Ct = \"Safari\"), At = \"iOS\" + ((dt = / OS ([\\d_]+)/i.exec(it)) ? \" \" + dt[1].replace(/_/g, \".\") : \"\")) : Ct == \"Konqueror\" && /^Linux\\b/i.test(At) ? At = \"Kubuntu\" : $t && $t != \"Google\" && (/Chrome/.test(Ct) && !/\\bMobile Safari\\b/i.test(it) || /\\bVita\\b/.test(Lt)) || /\\bAndroid\\b/.test(At) && /^Chrome/.test(Ct) && /\\bVersion\\//i.test(it) ? (Ct = \"Android Browser\", At = /\\bAndroid\\b/.test(At) ? At : \"Android\") : Ct == \"Silk\" ? (/\\bMobi/i.test(it) || (At = \"Android\", Mt.unshift(\"desktop mode\")), /Accelerated *= *true/i.test(it) && Mt.unshift(\"accelerated\")) : Ct == \"UC Browser\" && /\\bUCWEB\\b/.test(it) ? Mt.push(\"speed mode\") : Ct == \"PaleMoon\" && (dt = /\\bFirefox\\/([\\d.]+)\\b/.exec(it)) ? Mt.push(\"identifying as Firefox \" + dt[1]) : Ct == \"Firefox\" && (dt = /\\b(Mobile|Tablet|TV)\\b/i.exec(it)) ? (At || (At = \"Firefox OS\"), Lt || (Lt = dt[1])) : !Ct || (dt = !/\\bMinefield\\b/i.test(it) && /\\b(?:Firefox|Safari)\\b/.exec(Ct)) ? (Ct && !Lt && /[\\/,]|^[^(]+?\\)/.test(it.slice(it.indexOf(dt + \"/\") + 8)) && (Ct = null), (dt = Lt || $t || At) && (Lt || $t || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(At)) && (Ct = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(At) ? At : dt) + \" Browser\")) : Ct == \"Electron\" && (dt = (/\\bChrome\\/([\\d.]+)\\b/.exec(it) || 0)[1]) && Mt.push(\"Chromium \" + dt), Et || (Et = ne([\n        \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n        \"Version\",\n        J(Ct),\n        \"(?:Firefox|Minefield|NetFront)\"\n      ])), (dt = It == \"iCab\" && parseFloat(Et) > 3 && \"WebKit\" || /\\bOpera\\b/.test(Ct) && (/\\bOPR\\b/.test(it) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(it) && !/^(?:Trident|EdgeHTML)$/.test(It) && \"WebKit\" || !It && /\\bMSIE\\b/i.test(it) && (At == \"Mac OS\" ? \"Tasman\" : \"Trident\") || It == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(Ct) && \"NetFront\") && (It = [dt]), Ct == \"IE\" && (dt = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(it) || 0)[1]) ? (Ct += \" Mobile\", At = \"Windows Phone \" + (/\\+$/.test(dt) ? dt : dt + \".x\"), Mt.unshift(\"desktop mode\")) : /\\bWPDesktop\\b/i.test(it) ? (Ct = \"IE Mobile\", At = \"Windows Phone 8.x\", Mt.unshift(\"desktop mode\"), Et || (Et = (/\\brv:([\\d.]+)/.exec(it) || 0)[1])) : Ct != \"IE\" && It == \"Trident\" && (dt = /\\brv:([\\d.]+)/.exec(it)) && (Ct && Mt.push(\"identifying as \" + Ct + (Et ? \" \" + Et : \"\")), Ct = \"IE\", Et = dt[1]), Dt) {\n        if (K(st, \"global\"))\n          if (yt && (dt = yt.lang.System, Gt = dt.getProperty(\"os.arch\"), At = At || dt.getProperty(\"os.name\") + \" \" + dt.getProperty(\"os.version\")), ht) {\n            try {\n              Et = st.require(\"ringo/engine\").version.join(\".\"), Ct = \"RingoJS\";\n            } catch {\n              (dt = st.system) && dt.global.system == st.system && (Ct = \"Narwhal\", At || (At = dt[0].os || null));\n            }\n            Ct || (Ct = \"Rhino\");\n          } else\n            typeof st.process == \"object\" && !st.process.browser && (dt = st.process) && (typeof dt.versions == \"object\" && (typeof dt.versions.electron == \"string\" ? (Mt.push(\"Node \" + dt.versions.node), Ct = \"Electron\", Et = dt.versions.electron) : typeof dt.versions.nw == \"string\" && (Mt.push(\"Chromium \" + Et, \"Node \" + dt.versions.node), Ct = \"NW.js\", Et = dt.versions.nw)), Ct || (Ct = \"Node.js\", Gt = dt.arch, At = dt.platform, Et = /[\\d.]+/.exec(dt.version), Et = Et ? Et[0] : null));\n        else\n          Z(dt = st.runtime) == vt ? (Ct = \"Adobe AIR\", At = dt.flash.system.Capabilities.os) : Z(dt = st.phantom) == Rt ? (Ct = \"PhantomJS\", Et = (dt = dt.version || null) && dt.major + \".\" + dt.minor + \".\" + dt.patch) : typeof Ot.documentMode == \"number\" && (dt = /\\bTrident\\/(\\d+)/i.exec(it)) ? (Et = [Et, Ot.documentMode], (dt = +dt[1] + 4) != Et[1] && (Mt.push(\"IE \" + Et[1] + \" mode\"), It && (It[1] = \"\"), Et[1] = dt), Et = Ct == \"IE\" ? String(Et[1].toFixed(1)) : Et[0]) : typeof Ot.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(Ct) && (Mt.push(\"masking as \" + Ct + \" \" + Et), Ct = \"IE\", Et = \"11.0\", It = [\"Trident\"], At = \"Windows\");\n        At = At && Y(At);\n      }\n      if (Et && (dt = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(Et) || /(?:alpha|beta)(?: ?\\d)?/i.exec(it + \";\" + (Dt && ft.appMinorVersion)) || /\\bMinefield\\b/i.test(it) && \"a\") && (Bt = /b/i.test(dt) ? \"beta\" : \"alpha\", Et = Et.replace(RegExp(dt + \"\\\\+?$\"), \"\") + (Bt == \"beta\" ? St : bt) + (/\\d+\\+?/.exec(dt) || \"\")), Ct == \"Fennec\" || Ct == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(At))\n        Ct = \"Firefox Mobile\";\n      else if (Ct == \"Maxthon\" && Et)\n        Et = Et.replace(/\\.[\\d.]+/, \".x\");\n      else if (/\\bXbox\\b/i.test(Lt))\n        Lt == \"Xbox 360\" && (At = null), Lt == \"Xbox 360\" && /\\bIEMobile\\b/.test(it) && Mt.unshift(\"mobile mode\");\n      else if ((/^(?:Chrome|IE|Opera)$/.test(Ct) || Ct && !Lt && !/Browser|Mobi/.test(Ct)) && (At == \"Windows CE\" || /Mobi/i.test(it)))\n        Ct += \" Mobile\";\n      else if (Ct == \"IE\" && Dt)\n        try {\n          st.external === null && Mt.unshift(\"platform preview\");\n        } catch {\n          Mt.unshift(\"embedded\");\n        }\n      else\n        (/\\bBlackBerry\\b/.test(Lt) || /\\bBB10\\b/.test(it)) && (dt = (RegExp(Lt.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(it) || 0)[1] || Et) ? (dt = [dt, /BB10/.test(it)], At = (dt[1] ? (Lt = null, $t = \"BlackBerry\") : \"Device Software\") + \" \" + dt[0], Et = null) : this != q && Lt != \"Wii\" && (Dt && wt || /Opera/.test(Ct) && /\\b(?:MSIE|Firefox)\\b/i.test(it) || Ct == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(At) || Ct == \"IE\" && (At && !/^Win/.test(At) && Et > 5.5 || /\\bWindows XP\\b/.test(At) && Et > 8 || Et == 8 && !/\\bTrident\\b/.test(it))) && !B.test(dt = Q.call(q, it.replace(B, \"\") + \";\")) && dt.name && (dt = \"ing as \" + dt.name + ((dt = dt.version) ? \" \" + dt : \"\"), B.test(Ct) ? (/\\bIE\\b/.test(dt) && At == \"Mac OS\" && (At = null), dt = \"identify\" + dt) : (dt = \"mask\" + dt, Ft ? Ct = Y(Ft.replace(/([a-z])([A-Z])/g, \"$1 $2\")) : Ct = \"Opera\", /\\bIE\\b/.test(dt) && (At = null), Dt || (Et = null)), It = [\"Presto\"], Mt.push(dt));\n      (dt = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(it) || 0)[1]) && (dt = [parseFloat(dt.replace(/\\.(\\d)$/, \".0$1\")), dt], Ct == \"Safari\" && dt[1].slice(-1) == \"+\" ? (Ct = \"WebKit Nightly\", Bt = \"alpha\", Et = dt[1].slice(0, -1)) : (Et == dt[1] || Et == (dt[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(it) || 0)[1])) && (Et = null), dt[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(it) || 0)[1], dt[0] == 537.36 && dt[2] == 537.36 && parseFloat(dt[1]) >= 28 && It == \"WebKit\" && (It = [\"Blink\"]), !Dt || !pt && !dt[1] ? (It && (It[1] = \"like Safari\"), dt = (dt = dt[0], dt < 400 ? 1 : dt < 500 ? 2 : dt < 526 ? 3 : dt < 533 ? 4 : dt < 534 ? \"4+\" : dt < 535 ? 5 : dt < 537 ? 6 : dt < 538 ? 7 : dt < 601 ? 8 : dt < 602 ? 9 : dt < 604 ? 10 : dt < 606 ? 11 : dt < 608 ? 12 : \"12\")) : (It && (It[1] = \"like Chrome\"), dt = dt[1] || (dt = dt[0], dt < 530 ? 1 : dt < 532 ? 2 : dt < 532.05 ? 3 : dt < 533 ? 4 : dt < 534.03 ? 5 : dt < 534.07 ? 6 : dt < 534.1 ? 7 : dt < 534.13 ? 8 : dt < 534.16 ? 9 : dt < 534.24 ? 10 : dt < 534.3 ? 11 : dt < 535.01 ? 12 : dt < 535.02 ? \"13+\" : dt < 535.07 ? 15 : dt < 535.11 ? 16 : dt < 535.19 ? 17 : dt < 536.05 ? 18 : dt < 536.1 ? 19 : dt < 537.01 ? 20 : dt < 537.11 ? \"21+\" : dt < 537.13 ? 23 : dt < 537.18 ? 24 : dt < 537.24 ? 25 : dt < 537.36 ? 26 : It != \"Blink\" ? \"27\" : \"28\")), It && (It[1] += \" \" + (dt += typeof dt == \"number\" ? \".x\" : /[.+]/.test(dt) ? \"\" : \"+\")), Ct == \"Safari\" && (!Et || parseInt(Et) > 45) ? Et = dt : Ct == \"Chrome\" && /\\bHeadlessChrome/i.test(it) && Mt.unshift(\"headless\")), Ct == \"Opera\" && (dt = /\\bzbov|zvav$/.exec(At)) ? (Ct += \" \", Mt.unshift(\"desktop mode\"), dt == \"zvav\" ? (Ct += \"Mini\", Et = null) : Ct += \"Mobile\", At = At.replace(RegExp(\" *\" + dt + \"$\"), \"\")) : Ct == \"Safari\" && /\\bChrome\\b/.exec(It && It[1]) ? (Mt.unshift(\"desktop mode\"), Ct = \"Chrome Mobile\", Et = null, /\\bOS X\\b/.test(At) ? ($t = \"Apple\", At = \"iOS 4.3+\") : At = null) : /\\bSRWare Iron\\b/.test(Ct) && !Et && (Et = ne(\"Chrome\")), Et && Et.indexOf(dt = /[\\d.]+$/.exec(At)) == 0 && it.indexOf(\"/\" + dt + \"-\") > -1 && (At = et(At.replace(dt, \"\"))), At && At.indexOf(Ct) != -1 && !RegExp(Ct + \" OS\").test(At) && (At = At.replace(RegExp(\" *\" + J(Ct) + \" *\"), \"\")), It && !/\\b(?:Avant|Nook)\\b/.test(Ct) && (/Browser|Lunascape|Maxthon/.test(Ct) || Ct != \"Safari\" && /^iOS/.test(At) && /\\bSafari\\b/.test(It[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(Ct) && It[1]) && (dt = It[It.length - 1]) && Mt.push(dt), Mt.length && (Mt = [\"(\" + Mt.join(\"; \") + \")\"]), $t && Lt && Lt.indexOf($t) < 0 && Mt.push(\"on \" + $t), Lt && Mt.push((/^on /.test(Mt[Mt.length - 1]) ? \"\" : \"on \") + Lt), At && (dt = / ([\\d.+]+)$/.exec(At), zt = dt && At.charAt(At.length - dt[0].length - 1) == \"/\", At = {\n        architecture: 32,\n        family: dt && !zt ? At.replace(dt[0], \"\") : At,\n        version: dt ? dt[1] : null,\n        toString: function() {\n          var de = this.version;\n          return this.family + (de && !zt ? \" \" + de : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n        }\n      }), (dt = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec(Gt)) && !/\\bi686\\b/i.test(Gt) ? (At && (At.architecture = 64, At.family = At.family.replace(RegExp(\" *\" + dt), \"\")), Ct && (/\\bWOW64\\b/i.test(it) || Dt && /\\w(?:86|32)$/.test(ft.cpuClass || ft.platform) && !/\\bWin64; x64\\b/i.test(it)) && Mt.unshift(\"32-bit\")) : At && /^OS X/.test(At.family) && Ct == \"Chrome\" && parseFloat(Et) >= 39 && (At.architecture = 64), it || (it = null);\n      var ye = {};\n      return ye.description = it, ye.layout = It && It[0], ye.manufacturer = $t, ye.name = Ct, ye.prerelease = Bt, ye.product = Lt, ye.ua = it, ye.version = Ct && Et, ye.os = At || {\n        architecture: null,\n        family: null,\n        version: null,\n        toString: function() {\n          return \"null\";\n        }\n      }, ye.parse = Q, ye.toString = Me, ye.version && Mt.unshift(Et), ye.name && Mt.unshift(Ct), At && Ct && !(At == String(At).split(\" \")[0] && (At == Ct.split(\" \")[0] || Lt)) && Mt.push(Lt ? \"(\" + At + \")\" : \"on \" + At), Mt.length && (ye.description = Mt.join(\" \")), ye;\n    }\n    var at = Q();\n    T && S ? q(at, function(it, st) {\n      T[st] = it;\n    }) : o.platform = at;\n  }).call(commonjsGlobal$1);\n})(platform$1, platform$1.exports);\nconst platform = platform$1.exports;\nfunction int(r) {\n  return parseInt(String(r), 10);\n}\nfunction uint(r) {\n  const t = parseInt(String(r), 10);\n  return t < 0 ? -t : t;\n}\n\"toInt\" in String.prototype || (String.prototype.toInt = function() {\n  return int(this);\n});\n\"toUint\" in String.prototype || (String.prototype.toUint = function() {\n  const r = int(this);\n  return r < 0 ? -r : r;\n});\nfunction getDateStr(r = \"/\", t = \" \", e = \":\", o = \"\") {\n  const T = new Date();\n  return T.getFullYear() + r + String(100 + T.getMonth() + 1).slice(1, 3) + r + String(100 + T.getDate()).slice(1, 3) + t + String(100 + T.getHours()).slice(1, 3) + e + String(100 + T.getMinutes()).slice(1, 3) + (o === \"\" ? \"\" : o + String(T.getMilliseconds()));\n}\nconst hMemberCnt = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction cnvTweenArg(r, t) {\n  const e = {};\n  for (const o of Object.keys(hMemberCnt)) {\n    if (!(o in r))\n      continue;\n    const T = String(r[o]), S = (T.charAt(0) === \"=\" ? T.slice(1) : T).split(\",\"), N = e[o] = parseFloat(S[0]);\n    S.length > 1 && (e[o] += Math.round(Math.random() * (parseFloat(S[1]) - N + 1))), T.charAt(0) === \"=\" && (e[o] += parseFloat(t[o]));\n  }\n  return e;\n}\nconst css_key4del = \"/* SKYNovel */\";\nfunction initStyle() {\n  const r = document.getElementsByTagName(\"head\")[0], t = r.children.length;\n  for (let e = t - 1; e >= 0; --e) {\n    const o = r.children[e];\n    o instanceof HTMLStyleElement && o.innerText.slice(0, 14) === css_key4del && r.removeChild(o);\n  }\n}\nfunction addStyle(r) {\n  const t = document.createElement(\"style\");\n  t.innerHTML = css_key4del + r, document.getElementsByTagName(\"head\")[0].appendChild(t);\n}\nfunction argChk_Num(r, t, e) {\n  const o = r[t];\n  if (!(t in r)) {\n    if (isNaN(e))\n      throw `[${r[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${t} \\u306F\\u5FC5\\u9808\\u3067\\u3059`;\n    return r[t] = e, e;\n  }\n  const T = String(o).slice(0, 2) === \"0x\" ? parseInt(o) : parseFloat(o);\n  if (isNaN(T))\n    throw `[${r[\":\\u30BF\\u30B0\\u540D\"]}]\\u5C5E\\u6027 ${t} \\u306E\\u5024\\u3010${o}\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  return r[t] = T;\n}\nfunction argChk_Boolean(r, t, e) {\n  if (!(t in r))\n    return r[t] = e;\n  const o = r[t];\n  if (o === null)\n    return !1;\n  const T = String(o);\n  return r[t] = T === \"false\" ? !1 : Boolean(T);\n}\nfunction parseColor(r) {\n  if (r.charAt(0) === \"#\")\n    return parseInt(r.slice(1), 16);\n  const t = Number(r);\n  if (!isNaN(t))\n    return t;\n  if (r === \"black\")\n    return 0;\n  CmnLib.cc4ColorName.fillStyle = r;\n  const e = CmnLib.cc4ColorName.fillStyle;\n  if (e === \"#000000\")\n    throw `\\u8272\\u540D\\u524D ${r} \\u304C\\u7570\\u5E38\\u3067\\u3059`;\n  return parseInt(e.slice(1), 16);\n}\nfunction argChk_Color(r, t, e) {\n  const o = r[t];\n  return o ? r[t] = parseColor(String(o)) : r[t] = e;\n}\nconst REG_ERRMES_JSON = /JSON at position (\\d+)$/;\nfunction mesErrJSON(r, t = \"\", e = \"\") {\n  var T;\n  const o = ((T = e.match(REG_ERRMES_JSON)) != null ? T : [\"\", \"\"])[1];\n  return `[${r[\":\\u30BF\\u30B0\\u540D\"]}] ${t} \\u5C5E\\u6027\\u306E\\u89E3\\u6790\\u30A8\\u30E9\\u30FC : ${e}\n${r[t]}${o ? `\n${\"^\".padStart(Number(o))}` : \"\"}`;\n}\nconst REG_FN = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction getFn(r) {\n  var t;\n  return ((t = r.match(REG_FN)) != null ? t : [\"\"])[0];\n}\nconst REG_EXT = /\\.([^\\.]+)$/;\nfunction getExt(r) {\n  var t;\n  return ((t = r.match(REG_EXT)) != null ? t : [\"\", \"\"])[1];\n}\nvar If, wf, Pf, Af;\nclass CmnLib {\n}\nPt(CmnLib, \"stageW\", 0), Pt(CmnLib, \"stageH\", 0), Pt(CmnLib, \"debugLog\", !1), Pt(CmnLib, \"isSafari\", platform$1.exports.name === \"Safari\"), Pt(CmnLib, \"isFirefox\", platform$1.exports.name === \"Firefox\"), Pt(CmnLib, \"isMac\", new RegExp(\"OS X\").test((wf = (If = platform$1.exports.os) == null ? void 0 : If.family) != null ? wf : \"\")), Pt(CmnLib, \"isMobile\", !new RegExp(\"(Windows|OS X)\").test((Af = (Pf = platform$1.exports.os) == null ? void 0 : Pf.family) != null ? Af : \"\")), Pt(CmnLib, \"hDip\", {}), Pt(CmnLib, \"isDbg\", !1), Pt(CmnLib, \"isPackaged\", !1), Pt(CmnLib, \"isDarkMode\", !1), Pt(CmnLib, \"cc4ColorName\");\nfunction finallyConstructor(r) {\n  var t = this.constructor;\n  return this.then(\n    function(e) {\n      return t.resolve(r()).then(function() {\n        return e;\n      });\n    },\n    function(e) {\n      return t.resolve(r()).then(function() {\n        return t.reject(e);\n      });\n    }\n  );\n}\nfunction allSettled(r) {\n  var t = this;\n  return new t(function(e, o) {\n    if (!(r && typeof r.length < \"u\"))\n      return o(\n        new TypeError(\n          typeof r + \" \" + r + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"\n        )\n      );\n    var T = Array.prototype.slice.call(r);\n    if (T.length === 0)\n      return e([]);\n    var S = T.length;\n    function N(B, $) {\n      if ($ && (typeof $ == \"object\" || typeof $ == \"function\")) {\n        var U = $.then;\n        if (typeof U == \"function\") {\n          U.call(\n            $,\n            function(z) {\n              N(B, z);\n            },\n            function(z) {\n              T[B] = { status: \"rejected\", reason: z }, --S === 0 && e(T);\n            }\n          );\n          return;\n        }\n      }\n      T[B] = { status: \"fulfilled\", value: $ }, --S === 0 && e(T);\n    }\n    for (var D = 0; D < T.length; D++)\n      N(D, T[D]);\n  });\n}\nvar setTimeoutFunc = setTimeout;\nfunction isArray$1(r) {\n  return Boolean(r && typeof r.length < \"u\");\n}\nfunction noop() {\n}\nfunction bind$2(r, t) {\n  return function() {\n    r.apply(t, arguments);\n  };\n}\nfunction Promise$1(r) {\n  if (!(this instanceof Promise$1))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof r != \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(r, this);\n}\nfunction handle(r, t) {\n  for (; r._state === 3; )\n    r = r._value;\n  if (r._state === 0) {\n    r._deferreds.push(t);\n    return;\n  }\n  r._handled = !0, Promise$1._immediateFn(function() {\n    var e = r._state === 1 ? t.onFulfilled : t.onRejected;\n    if (e === null) {\n      (r._state === 1 ? resolve$1 : reject)(t.promise, r._value);\n      return;\n    }\n    var o;\n    try {\n      o = e(r._value);\n    } catch (T) {\n      reject(t.promise, T);\n      return;\n    }\n    resolve$1(t.promise, o);\n  });\n}\nfunction resolve$1(r, t) {\n  try {\n    if (t === r)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (t && (typeof t == \"object\" || typeof t == \"function\")) {\n      var e = t.then;\n      if (t instanceof Promise$1) {\n        r._state = 3, r._value = t, finale(r);\n        return;\n      } else if (typeof e == \"function\") {\n        doResolve(bind$2(e, t), r);\n        return;\n      }\n    }\n    r._state = 1, r._value = t, finale(r);\n  } catch (o) {\n    reject(r, o);\n  }\n}\nfunction reject(r, t) {\n  r._state = 2, r._value = t, finale(r);\n}\nfunction finale(r) {\n  r._state === 2 && r._deferreds.length === 0 && Promise$1._immediateFn(function() {\n    r._handled || Promise$1._unhandledRejectionFn(r._value);\n  });\n  for (var t = 0, e = r._deferreds.length; t < e; t++)\n    handle(r, r._deferreds[t]);\n  r._deferreds = null;\n}\nfunction Handler(r, t, e) {\n  this.onFulfilled = typeof r == \"function\" ? r : null, this.onRejected = typeof t == \"function\" ? t : null, this.promise = e;\n}\nfunction doResolve(r, t) {\n  var e = !1;\n  try {\n    r(\n      function(o) {\n        e || (e = !0, resolve$1(t, o));\n      },\n      function(o) {\n        e || (e = !0, reject(t, o));\n      }\n    );\n  } catch (o) {\n    if (e)\n      return;\n    e = !0, reject(t, o);\n  }\n}\nPromise$1.prototype.catch = function(r) {\n  return this.then(null, r);\n};\nPromise$1.prototype.then = function(r, t) {\n  var e = new this.constructor(noop);\n  return handle(this, new Handler(r, t, e)), e;\n};\nPromise$1.prototype.finally = finallyConstructor;\nPromise$1.all = function(r) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(r))\n      return e(new TypeError(\"Promise.all accepts an array\"));\n    var o = Array.prototype.slice.call(r);\n    if (o.length === 0)\n      return t([]);\n    var T = o.length;\n    function S(D, B) {\n      try {\n        if (B && (typeof B == \"object\" || typeof B == \"function\")) {\n          var $ = B.then;\n          if (typeof $ == \"function\") {\n            $.call(\n              B,\n              function(U) {\n                S(D, U);\n              },\n              e\n            );\n            return;\n          }\n        }\n        o[D] = B, --T === 0 && t(o);\n      } catch (U) {\n        e(U);\n      }\n    }\n    for (var N = 0; N < o.length; N++)\n      S(N, o[N]);\n  });\n};\nPromise$1.allSettled = allSettled;\nPromise$1.resolve = function(r) {\n  return r && typeof r == \"object\" && r.constructor === Promise$1 ? r : new Promise$1(function(t) {\n    t(r);\n  });\n};\nPromise$1.reject = function(r) {\n  return new Promise$1(function(t, e) {\n    e(r);\n  });\n};\nPromise$1.race = function(r) {\n  return new Promise$1(function(t, e) {\n    if (!isArray$1(r))\n      return e(new TypeError(\"Promise.race accepts an array\"));\n    for (var o = 0, T = r.length; o < T; o++)\n      Promise$1.resolve(r[o]).then(t, e);\n  });\n};\nPromise$1._immediateFn = typeof setImmediate == \"function\" && function(r) {\n  setImmediate(r);\n} || function(r) {\n  setTimeoutFunc(r, 0);\n};\nPromise$1._unhandledRejectionFn = function(t) {\n  typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", t);\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$2 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(r) {\n  if (r == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(r);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var r = new String(\"abc\");\n    if (r[5] = \"de\", Object.getOwnPropertyNames(r)[0] === \"5\")\n      return !1;\n    for (var t = {}, e = 0; e < 10; e++)\n      t[\"_\" + String.fromCharCode(e)] = e;\n    var o = Object.getOwnPropertyNames(t).map(function(S) {\n      return t[S];\n    });\n    if (o.join(\"\") !== \"0123456789\")\n      return !1;\n    var T = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(S) {\n      T[S] = S;\n    }), Object.keys(Object.assign({}, T)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(r, t) {\n  for (var e, o = toObject(r), T, S = 1; S < arguments.length; S++) {\n    e = Object(arguments[S]);\n    for (var N in e)\n      hasOwnProperty$2.call(e, N) && (o[N] = e[N]);\n    if (getOwnPropertySymbols) {\n      T = getOwnPropertySymbols(e);\n      for (var D = 0; D < T.length; D++)\n        propIsEnumerable.call(e, T[D]) && (o[T[D]] = e[T[D]]);\n    }\n  }\n  return o;\n};\n/*!\n * @pixi/polyfill - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/polyfill is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ntypeof globalThis > \"u\" && (typeof self < \"u\" ? self.globalThis = self : typeof __webpack_require__.g < \"u\" && (__webpack_require__.g.globalThis = __webpack_require__.g));\nglobalThis.Promise || (globalThis.Promise = Promise$1);\nObject.assign || (Object.assign = objectAssign);\nvar ONE_FRAME_TIME = 16;\nDate.now && Date.prototype.getTime || (Date.now = function() {\n  return new Date().getTime();\n});\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var startTime_1 = Date.now();\n  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {\n    return Date.now() - startTime_1;\n  };\n}\nvar lastTime = Date.now(), vendors = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var x$1 = 0; x$1 < vendors.length && !globalThis.requestAnimationFrame; ++x$1) {\n  var p$1 = vendors[x$1];\n  globalThis.requestAnimationFrame = globalThis[p$1 + \"RequestAnimationFrame\"], globalThis.cancelAnimationFrame = globalThis[p$1 + \"CancelAnimationFrame\"] || globalThis[p$1 + \"CancelRequestAnimationFrame\"];\n}\nglobalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(r) {\n  if (typeof r != \"function\")\n    throw new TypeError(r + \"is not a function\");\n  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;\n  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {\n    lastTime = Date.now(), r(performance.now());\n  }, e);\n});\nglobalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(r) {\n  return clearTimeout(r);\n});\nMath.sign || (Math.sign = function(t) {\n  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;\n});\nNumber.isInteger || (Number.isInteger = function(t) {\n  return typeof t == \"number\" && isFinite(t) && Math.floor(t) === t;\n});\nglobalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);\nglobalThis.Float32Array || (globalThis.Float32Array = Array);\nglobalThis.Uint32Array || (globalThis.Uint32Array = Array);\nglobalThis.Uint16Array || (globalThis.Uint16Array = Array);\nglobalThis.Uint8Array || (globalThis.Uint8Array = Array);\nglobalThis.Int32Array || (globalThis.Int32Array = Array);\n/*!\n * @pixi/settings - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$6;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$6 || (ENV$6 = {}));\nvar RENDERER_TYPE$6;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$6 || (RENDERER_TYPE$6 = {}));\nvar BUFFER_BITS$6;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$6 || (BUFFER_BITS$6 = {}));\nvar BLEND_MODES$6;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$6 || (BLEND_MODES$6 = {}));\nvar DRAW_MODES$6;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$6 || (DRAW_MODES$6 = {}));\nvar FORMATS$6;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$6 || (FORMATS$6 = {}));\nvar TARGETS$6;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$6 || (TARGETS$6 = {}));\nvar TYPES$6;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$6 || (TYPES$6 = {}));\nvar SAMPLER_TYPES$6;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$6 || (SAMPLER_TYPES$6 = {}));\nvar SCALE_MODES$6;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$6 || (SCALE_MODES$6 = {}));\nvar WRAP_MODES$6;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$6 || (WRAP_MODES$6 = {}));\nvar MIPMAP_MODES$6;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$6 || (MIPMAP_MODES$6 = {}));\nvar ALPHA_MODES$6;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$6 || (ALPHA_MODES$6 = {}));\nvar CLEAR_MODES$6;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$6 || (CLEAR_MODES$6 = {}));\nvar GC_MODES$6;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$6 || (GC_MODES$6 = {}));\nvar PRECISION$6;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$6 || (PRECISION$6 = {}));\nvar MASK_TYPES$6;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$6 || (MASK_TYPES$6 = {}));\nvar COLOR_MASK_BITS$6;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$6 || (COLOR_MASK_BITS$6 = {}));\nvar MSAA_QUALITY$6;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$6 || (MSAA_QUALITY$6 = {}));\nvar BUFFER_TYPE$6;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$6 || (BUFFER_TYPE$6 = {}));\nvar BrowserAdapter$1 = {\n  createCanvas: function(r, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = r, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var r;\n    return (r = document.baseURI) !== null && r !== void 0 ? r : window.location.href;\n  },\n  fetch: function(r, t) {\n    return fetch(r, t);\n  }\n}, appleIphone$1 = /iPhone/i, appleIpod$1 = /iPod/i, appleTablet$1 = /iPad/i, appleUniversal$1 = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone$1 = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet$1 = /Android/i, amazonPhone$1 = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet$1 = /Silk/i, windowsPhone$1 = /Windows Phone/i, windowsTablet$1 = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry$1 = /BlackBerry/i, otherBlackBerry10$1 = /BB10/i, otherOpera$1 = /Opera Mini/i, otherChrome$1 = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox$1 = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13$1 = function(r) {\n  return typeof r < \"u\" && r.platform === \"MacIntel\" && typeof r.maxTouchPoints == \"number\" && r.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch$1(r) {\n  return function(t) {\n    return t.test(r);\n  };\n}\nfunction isMobile$1$1(r) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !r && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof r == \"string\" ? t.userAgent = r : r && r.userAgent && (t = {\n    userAgent: r.userAgent,\n    platform: r.platform,\n    maxTouchPoints: r.maxTouchPoints || 0\n  });\n  var e = t.userAgent, o = e.split(\"[FBAN\");\n  typeof o[1] < \"u\" && (e = o[0]), o = e.split(\"Twitter\"), typeof o[1] < \"u\" && (e = o[0]);\n  var T = createMatch$1(e), S = {\n    apple: {\n      phone: T(appleIphone$1) && !T(windowsPhone$1),\n      ipod: T(appleIpod$1),\n      tablet: !T(appleIphone$1) && (T(appleTablet$1) || isAppleTabletOnIos13$1(t)) && !T(windowsPhone$1),\n      universal: T(appleUniversal$1),\n      device: (T(appleIphone$1) || T(appleIpod$1) || T(appleTablet$1) || T(appleUniversal$1) || isAppleTabletOnIos13$1(t)) && !T(windowsPhone$1)\n    },\n    amazon: {\n      phone: T(amazonPhone$1),\n      tablet: !T(amazonPhone$1) && T(amazonTablet$1),\n      device: T(amazonPhone$1) || T(amazonTablet$1)\n    },\n    android: {\n      phone: !T(windowsPhone$1) && T(amazonPhone$1) || !T(windowsPhone$1) && T(androidPhone$1),\n      tablet: !T(windowsPhone$1) && !T(amazonPhone$1) && !T(androidPhone$1) && (T(amazonTablet$1) || T(androidTablet$1)),\n      device: !T(windowsPhone$1) && (T(amazonPhone$1) || T(amazonTablet$1) || T(androidPhone$1) || T(androidTablet$1)) || T(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: T(windowsPhone$1),\n      tablet: T(windowsTablet$1),\n      device: T(windowsPhone$1) || T(windowsTablet$1)\n    },\n    other: {\n      blackberry: T(otherBlackBerry$1),\n      blackberry10: T(otherBlackBerry10$1),\n      opera: T(otherOpera$1),\n      firefox: T(otherFirefox$1),\n      chrome: T(otherChrome$1),\n      device: T(otherBlackBerry$1) || T(otherBlackBerry10$1) || T(otherOpera$1) || T(otherFirefox$1) || T(otherChrome$1)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return S.any = S.apple.device || S.android.device || S.windows.device || S.other.device, S.phone = S.apple.phone || S.android.phone || S.windows.phone, S.tablet = S.apple.tablet || S.android.tablet || S.windows.tablet, S;\n}\nvar isMobile$2 = isMobile$1$1(globalThis.navigator);\nfunction canUploadSameBuffer$1() {\n  return !isMobile$2.apple.device;\n}\nfunction maxRecommendedTextures$1(r) {\n  var t = !0;\n  if (isMobile$2.tablet || isMobile$2.phone) {\n    if (isMobile$2.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 11 && (t = !1);\n      }\n    }\n    if (isMobile$2.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? r : 4;\n}\nvar settings$1 = {\n  ADAPTER: BrowserAdapter$1,\n  MIPMAP_TEXTURES: MIPMAP_MODES$6.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY$6.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  GC_MODE: GC_MODES$6.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES$6.CLAMP,\n  SCALE_MODE: SCALE_MODES$6.LINEAR,\n  PRECISION_VERTEX: PRECISION$6.HIGH,\n  PRECISION_FRAGMENT: isMobile$2.apple.device ? PRECISION$6.HIGH : PRECISION$6.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),\n  CREATE_IMAGE_BITMAP: !1,\n  ROUND_PIXELS: !1\n}, eventemitter3 = { exports: {} };\n(function(r) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function o() {\n  }\n  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));\n  function T(B, $, U) {\n    this.fn = B, this.context = $, this.once = U || !1;\n  }\n  function S(B, $, U, z, V) {\n    if (typeof U != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var X = new T(U, z || B, V), W = e ? e + $ : $;\n    return B._events[W] ? B._events[W].fn ? B._events[W] = [B._events[W], X] : B._events[W].push(X) : (B._events[W] = X, B._eventsCount++), B;\n  }\n  function N(B, $) {\n    --B._eventsCount === 0 ? B._events = new o() : delete B._events[$];\n  }\n  function D() {\n    this._events = new o(), this._eventsCount = 0;\n  }\n  D.prototype.eventNames = function() {\n    var $ = [], U, z;\n    if (this._eventsCount === 0)\n      return $;\n    for (z in U = this._events)\n      t.call(U, z) && $.push(e ? z.slice(1) : z);\n    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;\n  }, D.prototype.listeners = function($) {\n    var U = e ? e + $ : $, z = this._events[U];\n    if (!z)\n      return [];\n    if (z.fn)\n      return [z.fn];\n    for (var V = 0, X = z.length, W = new Array(X); V < X; V++)\n      W[V] = z[V].fn;\n    return W;\n  }, D.prototype.listenerCount = function($) {\n    var U = e ? e + $ : $, z = this._events[U];\n    return z ? z.fn ? 1 : z.length : 0;\n  }, D.prototype.emit = function($, U, z, V, X, W) {\n    var Y = e ? e + $ : $;\n    if (!this._events[Y])\n      return !1;\n    var q = this._events[Y], Z = arguments.length, K, J;\n    if (q.fn) {\n      switch (q.once && this.removeListener($, q.fn, void 0, !0), Z) {\n        case 1:\n          return q.fn.call(q.context), !0;\n        case 2:\n          return q.fn.call(q.context, U), !0;\n        case 3:\n          return q.fn.call(q.context, U, z), !0;\n        case 4:\n          return q.fn.call(q.context, U, z, V), !0;\n        case 5:\n          return q.fn.call(q.context, U, z, V, X), !0;\n        case 6:\n          return q.fn.call(q.context, U, z, V, X, W), !0;\n      }\n      for (J = 1, K = new Array(Z - 1); J < Z; J++)\n        K[J - 1] = arguments[J];\n      q.fn.apply(q.context, K);\n    } else {\n      var tt = q.length, et;\n      for (J = 0; J < tt; J++)\n        switch (q[J].once && this.removeListener($, q[J].fn, void 0, !0), Z) {\n          case 1:\n            q[J].fn.call(q[J].context);\n            break;\n          case 2:\n            q[J].fn.call(q[J].context, U);\n            break;\n          case 3:\n            q[J].fn.call(q[J].context, U, z);\n            break;\n          case 4:\n            q[J].fn.call(q[J].context, U, z, V);\n            break;\n          default:\n            if (!K)\n              for (et = 1, K = new Array(Z - 1); et < Z; et++)\n                K[et - 1] = arguments[et];\n            q[J].fn.apply(q[J].context, K);\n        }\n    }\n    return !0;\n  }, D.prototype.on = function($, U, z) {\n    return S(this, $, U, z, !1);\n  }, D.prototype.once = function($, U, z) {\n    return S(this, $, U, z, !0);\n  }, D.prototype.removeListener = function($, U, z, V) {\n    var X = e ? e + $ : $;\n    if (!this._events[X])\n      return this;\n    if (!U)\n      return N(this, X), this;\n    var W = this._events[X];\n    if (W.fn)\n      W.fn === U && (!V || W.once) && (!z || W.context === z) && N(this, X);\n    else {\n      for (var Y = 0, q = [], Z = W.length; Y < Z; Y++)\n        (W[Y].fn !== U || V && !W[Y].once || z && W[Y].context !== z) && q.push(W[Y]);\n      q.length ? this._events[X] = q.length === 1 ? q[0] : q : N(this, X);\n    }\n    return this;\n  }, D.prototype.removeAllListeners = function($) {\n    var U;\n    return $ ? (U = e ? e + $ : $, this._events[U] && N(this, U)) : (this._events = new o(), this._eventsCount = 0), this;\n  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, r.exports = D;\n})(eventemitter3);\nconst i$1 = eventemitter3.exports;\nvar earcut$1 = { exports: {} };\nearcut$1.exports = earcut;\nearcut$1.exports.default = earcut;\nfunction earcut(r, t, e) {\n  e = e || 2;\n  var o = t && t.length, T = o ? t[0] * e : r.length, S = linkedList(r, 0, T, e, !0), N = [];\n  if (!S || S.next === S.prev)\n    return N;\n  var D, B, $, U, z, V, X;\n  if (o && (S = eliminateHoles(r, t, S, e)), r.length > 80 * e) {\n    D = $ = r[0], B = U = r[1];\n    for (var W = e; W < T; W += e)\n      z = r[W], V = r[W + 1], z < D && (D = z), V < B && (B = V), z > $ && ($ = z), V > U && (U = V);\n    X = Math.max($ - D, U - B), X = X !== 0 ? 32767 / X : 0;\n  }\n  return earcutLinked(S, N, e, D, B, X, 0), N;\n}\nfunction linkedList(r, t, e, o, T) {\n  var S, N;\n  if (T === signedArea(r, t, e, o) > 0)\n    for (S = t; S < e; S += o)\n      N = insertNode(S, r[S], r[S + 1], N);\n  else\n    for (S = e - o; S >= t; S -= o)\n      N = insertNode(S, r[S], r[S + 1], N);\n  return N && equals$1(N, N.next) && (removeNode(N), N = N.next), N;\n}\nfunction filterPoints(r, t) {\n  if (!r)\n    return r;\n  t || (t = r);\n  var e = r, o;\n  do\n    if (o = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {\n      if (removeNode(e), e = t = e.prev, e === e.next)\n        break;\n      o = !0;\n    } else\n      e = e.next;\n  while (o || e !== t);\n  return t;\n}\nfunction earcutLinked(r, t, e, o, T, S, N) {\n  if (!!r) {\n    !N && S && indexCurve(r, o, T, S);\n    for (var D = r, B, $; r.prev !== r.next; ) {\n      if (B = r.prev, $ = r.next, S ? isEarHashed(r, o, T, S) : isEar(r)) {\n        t.push(B.i / e | 0), t.push(r.i / e | 0), t.push($.i / e | 0), removeNode(r), r = $.next, D = $.next;\n        continue;\n      }\n      if (r = $, r === D) {\n        N ? N === 1 ? (r = cureLocalIntersections(filterPoints(r), t, e), earcutLinked(r, t, e, o, T, S, 2)) : N === 2 && splitEarcut(r, t, e, o, T, S) : earcutLinked(filterPoints(r), t, e, o, T, S, 1);\n        break;\n      }\n    }\n  }\n}\nfunction isEar(r) {\n  var t = r.prev, e = r, o = r.next;\n  if (area(t, e, o) >= 0)\n    return !1;\n  for (var T = t.x, S = e.x, N = o.x, D = t.y, B = e.y, $ = o.y, U = T < S ? T < N ? T : N : S < N ? S : N, z = D < B ? D < $ ? D : $ : B < $ ? B : $, V = T > S ? T > N ? T : N : S > N ? S : N, X = D > B ? D > $ ? D : $ : B > $ ? B : $, W = o.next; W !== t; ) {\n    if (W.x >= U && W.x <= V && W.y >= z && W.y <= X && pointInTriangle(T, D, S, B, N, $, W.x, W.y) && area(W.prev, W, W.next) >= 0)\n      return !1;\n    W = W.next;\n  }\n  return !0;\n}\nfunction isEarHashed(r, t, e, o) {\n  var T = r.prev, S = r, N = r.next;\n  if (area(T, S, N) >= 0)\n    return !1;\n  for (var D = T.x, B = S.x, $ = N.x, U = T.y, z = S.y, V = N.y, X = D < B ? D < $ ? D : $ : B < $ ? B : $, W = U < z ? U < V ? U : V : z < V ? z : V, Y = D > B ? D > $ ? D : $ : B > $ ? B : $, q = U > z ? U > V ? U : V : z > V ? z : V, Z = zOrder(X, W, t, e, o), K = zOrder(Y, q, t, e, o), J = r.prevZ, tt = r.nextZ; J && J.z >= Z && tt && tt.z <= K; ) {\n    if (J.x >= X && J.x <= Y && J.y >= W && J.y <= q && J !== T && J !== N && pointInTriangle(D, U, B, z, $, V, J.x, J.y) && area(J.prev, J, J.next) >= 0 || (J = J.prevZ, tt.x >= X && tt.x <= Y && tt.y >= W && tt.y <= q && tt !== T && tt !== N && pointInTriangle(D, U, B, z, $, V, tt.x, tt.y) && area(tt.prev, tt, tt.next) >= 0))\n      return !1;\n    tt = tt.nextZ;\n  }\n  for (; J && J.z >= Z; ) {\n    if (J.x >= X && J.x <= Y && J.y >= W && J.y <= q && J !== T && J !== N && pointInTriangle(D, U, B, z, $, V, J.x, J.y) && area(J.prev, J, J.next) >= 0)\n      return !1;\n    J = J.prevZ;\n  }\n  for (; tt && tt.z <= K; ) {\n    if (tt.x >= X && tt.x <= Y && tt.y >= W && tt.y <= q && tt !== T && tt !== N && pointInTriangle(D, U, B, z, $, V, tt.x, tt.y) && area(tt.prev, tt, tt.next) >= 0)\n      return !1;\n    tt = tt.nextZ;\n  }\n  return !0;\n}\nfunction cureLocalIntersections(r, t, e) {\n  var o = r;\n  do {\n    var T = o.prev, S = o.next.next;\n    !equals$1(T, S) && intersects(T, o, o.next, S) && locallyInside(T, S) && locallyInside(S, T) && (t.push(T.i / e | 0), t.push(o.i / e | 0), t.push(S.i / e | 0), removeNode(o), removeNode(o.next), o = r = S), o = o.next;\n  } while (o !== r);\n  return filterPoints(o);\n}\nfunction splitEarcut(r, t, e, o, T, S) {\n  var N = r;\n  do {\n    for (var D = N.next.next; D !== N.prev; ) {\n      if (N.i !== D.i && isValidDiagonal(N, D)) {\n        var B = splitPolygon(N, D);\n        N = filterPoints(N, N.next), B = filterPoints(B, B.next), earcutLinked(N, t, e, o, T, S, 0), earcutLinked(B, t, e, o, T, S, 0);\n        return;\n      }\n      D = D.next;\n    }\n    N = N.next;\n  } while (N !== r);\n}\nfunction eliminateHoles(r, t, e, o) {\n  var T = [], S, N, D, B, $;\n  for (S = 0, N = t.length; S < N; S++)\n    D = t[S] * o, B = S < N - 1 ? t[S + 1] * o : r.length, $ = linkedList(r, D, B, o, !1), $ === $.next && ($.steiner = !0), T.push(getLeftmost($));\n  for (T.sort(compareX), S = 0; S < T.length; S++)\n    e = eliminateHole(T[S], e);\n  return e;\n}\nfunction compareX(r, t) {\n  return r.x - t.x;\n}\nfunction eliminateHole(r, t) {\n  var e = findHoleBridge(r, t);\n  if (!e)\n    return t;\n  var o = splitPolygon(e, r);\n  return filterPoints(o, o.next), filterPoints(e, e.next);\n}\nfunction findHoleBridge(r, t) {\n  var e = t, o = r.x, T = r.y, S = -1 / 0, N;\n  do {\n    if (T <= e.y && T >= e.next.y && e.next.y !== e.y) {\n      var D = e.x + (T - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if (D <= o && D > S && (S = D, N = e.x < e.next.x ? e : e.next, D === o))\n        return N;\n    }\n    e = e.next;\n  } while (e !== t);\n  if (!N)\n    return null;\n  var B = N, $ = N.x, U = N.y, z = 1 / 0, V;\n  e = N;\n  do\n    o >= e.x && e.x >= $ && o !== e.x && pointInTriangle(T < U ? o : S, T, $, U, T < U ? S : o, T, e.x, e.y) && (V = Math.abs(T - e.y) / (o - e.x), locallyInside(e, r) && (V < z || V === z && (e.x > N.x || e.x === N.x && sectorContainsSector(N, e))) && (N = e, z = V)), e = e.next;\n  while (e !== B);\n  return N;\n}\nfunction sectorContainsSector(r, t) {\n  return area(r.prev, r, t.prev) < 0 && area(t.next, r, r.next) < 0;\n}\nfunction indexCurve(r, t, e, o) {\n  var T = r;\n  do\n    T.z === 0 && (T.z = zOrder(T.x, T.y, t, e, o)), T.prevZ = T.prev, T.nextZ = T.next, T = T.next;\n  while (T !== r);\n  T.prevZ.nextZ = null, T.prevZ = null, sortLinked(T);\n}\nfunction sortLinked(r) {\n  var t, e, o, T, S, N, D, B, $ = 1;\n  do {\n    for (e = r, r = null, S = null, N = 0; e; ) {\n      for (N++, o = e, D = 0, t = 0; t < $ && (D++, o = o.nextZ, !!o); t++)\n        ;\n      for (B = $; D > 0 || B > 0 && o; )\n        D !== 0 && (B === 0 || !o || e.z <= o.z) ? (T = e, e = e.nextZ, D--) : (T = o, o = o.nextZ, B--), S ? S.nextZ = T : r = T, T.prevZ = S, S = T;\n      e = o;\n    }\n    S.nextZ = null, $ *= 2;\n  } while (N > 1);\n  return r;\n}\nfunction zOrder(r, t, e, o, T) {\n  return r = (r - e) * T | 0, t = (t - o) * T | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, r | t << 1;\n}\nfunction getLeftmost(r) {\n  var t = r, e = r;\n  do\n    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;\n  while (t !== r);\n  return e;\n}\nfunction pointInTriangle(r, t, e, o, T, S, N, D) {\n  return (T - N) * (t - D) >= (r - N) * (S - D) && (r - N) * (o - D) >= (e - N) * (t - D) && (e - N) * (S - D) >= (T - N) * (o - D);\n}\nfunction isValidDiagonal(r, t) {\n  return r.next.i !== t.i && r.prev.i !== t.i && !intersectsPolygon(r, t) && (locallyInside(r, t) && locallyInside(t, r) && middleInside(r, t) && (area(r.prev, r, t.prev) || area(r, t.prev, t)) || equals$1(r, t) && area(r.prev, r, r.next) > 0 && area(t.prev, t, t.next) > 0);\n}\nfunction area(r, t, e) {\n  return (t.y - r.y) * (e.x - t.x) - (t.x - r.x) * (e.y - t.y);\n}\nfunction equals$1(r, t) {\n  return r.x === t.x && r.y === t.y;\n}\nfunction intersects(r, t, e, o) {\n  var T = sign$1(area(r, t, e)), S = sign$1(area(r, t, o)), N = sign$1(area(e, o, r)), D = sign$1(area(e, o, t));\n  return !!(T !== S && N !== D || T === 0 && onSegment(r, e, t) || S === 0 && onSegment(r, o, t) || N === 0 && onSegment(e, r, o) || D === 0 && onSegment(e, t, o));\n}\nfunction onSegment(r, t, e) {\n  return t.x <= Math.max(r.x, e.x) && t.x >= Math.min(r.x, e.x) && t.y <= Math.max(r.y, e.y) && t.y >= Math.min(r.y, e.y);\n}\nfunction sign$1(r) {\n  return r > 0 ? 1 : r < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(r, t) {\n  var e = r;\n  do {\n    if (e.i !== r.i && e.next.i !== r.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, r, t))\n      return !0;\n    e = e.next;\n  } while (e !== r);\n  return !1;\n}\nfunction locallyInside(r, t) {\n  return area(r.prev, r, r.next) < 0 ? area(r, t, r.next) >= 0 && area(r, r.prev, t) >= 0 : area(r, t, r.prev) < 0 || area(r, r.next, t) < 0;\n}\nfunction middleInside(r, t) {\n  var e = r, o = !1, T = (r.x + t.x) / 2, S = (r.y + t.y) / 2;\n  do\n    e.y > S != e.next.y > S && e.next.y !== e.y && T < (e.next.x - e.x) * (S - e.y) / (e.next.y - e.y) + e.x && (o = !o), e = e.next;\n  while (e !== r);\n  return o;\n}\nfunction splitPolygon(r, t) {\n  var e = new Node$1(r.i, r.x, r.y), o = new Node$1(t.i, t.x, t.y), T = r.next, S = t.prev;\n  return r.next = t, t.prev = r, e.next = T, T.prev = e, o.next = e, e.prev = o, S.next = o, o.prev = S, o;\n}\nfunction insertNode(r, t, e, o) {\n  var T = new Node$1(r, t, e);\n  return o ? (T.next = o.next, T.prev = o, o.next.prev = T, o.next = T) : (T.prev = T, T.next = T), T;\n}\nfunction removeNode(r) {\n  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);\n}\nfunction Node$1(r, t, e) {\n  this.i = r, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nearcut.deviation = function(r, t, e, o) {\n  var T = t && t.length, S = T ? t[0] * e : r.length, N = Math.abs(signedArea(r, 0, S, e));\n  if (T)\n    for (var D = 0, B = t.length; D < B; D++) {\n      var $ = t[D] * e, U = D < B - 1 ? t[D + 1] * e : r.length;\n      N -= Math.abs(signedArea(r, $, U, e));\n    }\n  var z = 0;\n  for (D = 0; D < o.length; D += 3) {\n    var V = o[D] * e, X = o[D + 1] * e, W = o[D + 2] * e;\n    z += Math.abs(\n      (r[V] - r[W]) * (r[X + 1] - r[V + 1]) - (r[V] - r[X]) * (r[W + 1] - r[V + 1])\n    );\n  }\n  return N === 0 && z === 0 ? 0 : Math.abs((z - N) / N);\n};\nfunction signedArea(r, t, e, o) {\n  for (var T = 0, S = t, N = e - o; S < e; S += o)\n    T += (r[N] - r[S]) * (r[S + 1] + r[N + 1]), N = S;\n  return T;\n}\nearcut.flatten = function(r) {\n  for (var t = r[0][0].length, e = { vertices: [], holes: [], dimensions: t }, o = 0, T = 0; T < r.length; T++) {\n    for (var S = 0; S < r[T].length; S++)\n      for (var N = 0; N < t; N++)\n        e.vertices.push(r[T][S][N]);\n    T > 0 && (o += r[T - 1].length, e.holes.push(o));\n  }\n  return e;\n};\nvar punycode$1 = { exports: {} };\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n(function(r, t) {\n  (function(e) {\n    var o = t && !t.nodeType && t, T = r && !r.nodeType && r, S = typeof commonjsGlobal$1 == \"object\" && commonjsGlobal$1;\n    (S.global === S || S.window === S || S.self === S) && (e = S);\n    var N, D = 2147483647, B = 36, $ = 1, U = 26, z = 38, V = 700, X = 72, W = 128, Y = \"-\", q = /^xn--/, Z = /[^\\x20-\\x7E]/, K = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, J = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, tt = B - $, et = Math.floor, Q = String.fromCharCode, at;\n    function it(ht) {\n      throw RangeError(J[ht]);\n    }\n    function st(ht, bt) {\n      for (var St = ht.length, Ot = []; St--; )\n        Ot[St] = bt(ht[St]);\n      return Ot;\n    }\n    function ut(ht, bt) {\n      var St = ht.split(\"@\"), Ot = \"\";\n      St.length > 1 && (Ot = St[0] + \"@\", ht = St[1]), ht = ht.replace(K, \".\");\n      var wt = ht.split(\".\"), Ft = st(wt, bt).join(\".\");\n      return Ot + Ft;\n    }\n    function ft(ht) {\n      for (var bt = [], St = 0, Ot = ht.length, wt, Ft; St < Ot; )\n        wt = ht.charCodeAt(St++), wt >= 55296 && wt <= 56319 && St < Ot ? (Ft = ht.charCodeAt(St++), (Ft & 64512) == 56320 ? bt.push(((wt & 1023) << 10) + (Ft & 1023) + 65536) : (bt.push(wt), St--)) : bt.push(wt);\n      return bt;\n    }\n    function ct(ht) {\n      return st(ht, function(bt) {\n        var St = \"\";\n        return bt > 65535 && (bt -= 65536, St += Q(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), St += Q(bt), St;\n      }).join(\"\");\n    }\n    function pt(ht) {\n      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : B;\n    }\n    function mt(ht, bt) {\n      return ht + 22 + 75 * (ht < 26) - ((bt != 0) << 5);\n    }\n    function vt(ht, bt, St) {\n      var Ot = 0;\n      for (ht = St ? et(ht / V) : ht >> 1, ht += et(ht / bt); ht > tt * U >> 1; Ot += B)\n        ht = et(ht / tt);\n      return et(Ot + (tt + 1) * ht / (ht + z));\n    }\n    function _t(ht) {\n      var bt = [], St = ht.length, Ot, wt = 0, Ft = W, dt = X, Gt, Mt, Bt, Dt, Et, zt, It, Ct, Lt;\n      for (Gt = ht.lastIndexOf(Y), Gt < 0 && (Gt = 0), Mt = 0; Mt < Gt; ++Mt)\n        ht.charCodeAt(Mt) >= 128 && it(\"not-basic\"), bt.push(ht.charCodeAt(Mt));\n      for (Bt = Gt > 0 ? Gt + 1 : 0; Bt < St; ) {\n        for (Dt = wt, Et = 1, zt = B; Bt >= St && it(\"invalid-input\"), It = pt(ht.charCodeAt(Bt++)), (It >= B || It > et((D - wt) / Et)) && it(\"overflow\"), wt += It * Et, Ct = zt <= dt ? $ : zt >= dt + U ? U : zt - dt, !(It < Ct); zt += B)\n          Lt = B - Ct, Et > et(D / Lt) && it(\"overflow\"), Et *= Lt;\n        Ot = bt.length + 1, dt = vt(wt - Dt, Ot, Dt == 0), et(wt / Ot) > D - Ft && it(\"overflow\"), Ft += et(wt / Ot), wt %= Ot, bt.splice(wt++, 0, Ft);\n      }\n      return ct(bt);\n    }\n    function xt(ht) {\n      var bt, St, Ot, wt, Ft, dt, Gt, Mt, Bt, Dt, Et, zt = [], It, Ct, Lt, $t;\n      for (ht = ft(ht), It = ht.length, bt = W, St = 0, Ft = X, dt = 0; dt < It; ++dt)\n        Et = ht[dt], Et < 128 && zt.push(Q(Et));\n      for (Ot = wt = zt.length, wt && zt.push(Y); Ot < It; ) {\n        for (Gt = D, dt = 0; dt < It; ++dt)\n          Et = ht[dt], Et >= bt && Et < Gt && (Gt = Et);\n        for (Ct = Ot + 1, Gt - bt > et((D - St) / Ct) && it(\"overflow\"), St += (Gt - bt) * Ct, bt = Gt, dt = 0; dt < It; ++dt)\n          if (Et = ht[dt], Et < bt && ++St > D && it(\"overflow\"), Et == bt) {\n            for (Mt = St, Bt = B; Dt = Bt <= Ft ? $ : Bt >= Ft + U ? U : Bt - Ft, !(Mt < Dt); Bt += B)\n              $t = Mt - Dt, Lt = B - Dt, zt.push(\n                Q(mt(Dt + $t % Lt, 0))\n              ), Mt = et($t / Lt);\n            zt.push(Q(mt(Mt, 0))), Ft = vt(St, Ct, Ot == wt), St = 0, ++Ot;\n          }\n        ++St, ++bt;\n      }\n      return zt.join(\"\");\n    }\n    function Rt(ht) {\n      return ut(ht, function(bt) {\n        return q.test(bt) ? _t(bt.slice(4).toLowerCase()) : bt;\n      });\n    }\n    function yt(ht) {\n      return ut(ht, function(bt) {\n        return Z.test(bt) ? \"xn--\" + xt(bt) : bt;\n      });\n    }\n    if (N = {\n      version: \"1.3.2\",\n      ucs2: {\n        decode: ft,\n        encode: ct\n      },\n      decode: _t,\n      encode: xt,\n      toASCII: yt,\n      toUnicode: Rt\n    }, o && T)\n      if (r.exports == o)\n        T.exports = N;\n      else\n        for (at in N)\n          N.hasOwnProperty(at) && (o[at] = N[at]);\n    else\n      e.punycode = N;\n  })(commonjsGlobal$1);\n})(punycode$1, punycode$1.exports);\nvar util$8 = {\n  isString: function(r) {\n    return typeof r == \"string\";\n  },\n  isObject: function(r) {\n    return typeof r == \"object\" && r !== null;\n  },\n  isNull: function(r) {\n    return r === null;\n  },\n  isNullOrUndefined: function(r) {\n    return r == null;\n  }\n}, querystring$1 = {};\nfunction hasOwnProperty$1(r, t) {\n  return Object.prototype.hasOwnProperty.call(r, t);\n}\nvar decode$3 = function(r, t, e, o) {\n  t = t || \"&\", e = e || \"=\";\n  var T = {};\n  if (typeof r != \"string\" || r.length === 0)\n    return T;\n  var S = /\\+/g;\n  r = r.split(t);\n  var N = 1e3;\n  o && typeof o.maxKeys == \"number\" && (N = o.maxKeys);\n  var D = r.length;\n  N > 0 && D > N && (D = N);\n  for (var B = 0; B < D; ++B) {\n    var $ = r[B].replace(S, \"%20\"), U = $.indexOf(e), z, V, X, W;\n    U >= 0 ? (z = $.substr(0, U), V = $.substr(U + 1)) : (z = $, V = \"\"), X = decodeURIComponent(z), W = decodeURIComponent(V), hasOwnProperty$1(T, X) ? Array.isArray(T[X]) ? T[X].push(W) : T[X] = [T[X], W] : T[X] = W;\n  }\n  return T;\n}, stringifyPrimitive$1 = function(r) {\n  switch (typeof r) {\n    case \"string\":\n      return r;\n    case \"boolean\":\n      return r ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(r) ? r : \"\";\n    default:\n      return \"\";\n  }\n}, encode$3 = function(r, t, e, o) {\n  return t = t || \"&\", e = e || \"=\", r === null && (r = void 0), typeof r == \"object\" ? Object.keys(r).map(function(T) {\n    var S = encodeURIComponent(stringifyPrimitive$1(T)) + e;\n    return Array.isArray(r[T]) ? r[T].map(function(N) {\n      return S + encodeURIComponent(stringifyPrimitive$1(N));\n    }).join(t) : S + encodeURIComponent(stringifyPrimitive$1(r[T]));\n  }).join(t) : o ? encodeURIComponent(stringifyPrimitive$1(o)) + e + encodeURIComponent(stringifyPrimitive$1(r)) : \"\";\n};\nquerystring$1.decode = querystring$1.parse = decode$3;\nquerystring$1.encode = querystring$1.stringify = encode$3;\nvar punycode = punycode$1.exports, util$7 = util$8, parse$2 = urlParse, resolve = urlResolve, format$1 = urlFormat;\nfunction Url() {\n  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", `\n`, \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, hostlessProtocol = {\n  javascript: !0,\n  \"javascript:\": !0\n}, slashedProtocol = {\n  http: !0,\n  https: !0,\n  ftp: !0,\n  gopher: !0,\n  file: !0,\n  \"http:\": !0,\n  \"https:\": !0,\n  \"ftp:\": !0,\n  \"gopher:\": !0,\n  \"file:\": !0\n}, querystring = querystring$1;\nfunction urlParse(r, t, e) {\n  if (r && util$7.isObject(r) && r instanceof Url)\n    return r;\n  var o = new Url();\n  return o.parse(r, t, e), o;\n}\nUrl.prototype.parse = function(r, t, e) {\n  if (!util$7.isString(r))\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof r);\n  var o = r.indexOf(\"?\"), T = o !== -1 && o < r.indexOf(\"#\") ? \"?\" : \"#\", S = r.split(T), N = /\\\\/g;\n  S[0] = S[0].replace(N, \"/\"), r = S.join(T);\n  var D = r;\n  if (D = D.trim(), !e && r.split(\"#\").length === 1) {\n    var B = simplePathPattern.exec(D);\n    if (B)\n      return this.path = D, this.href = D, this.pathname = B[1], B[2] ? (this.search = B[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = \"\", this.query = {}), this;\n  }\n  var $ = protocolPattern.exec(D);\n  if ($) {\n    $ = $[0];\n    var U = $.toLowerCase();\n    this.protocol = U, D = D.substr($.length);\n  }\n  if (e || $ || D.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var z = D.substr(0, 2) === \"//\";\n    z && !($ && hostlessProtocol[$]) && (D = D.substr(2), this.slashes = !0);\n  }\n  if (!hostlessProtocol[$] && (z || $ && !slashedProtocol[$])) {\n    for (var V = -1, X = 0; X < hostEndingChars.length; X++) {\n      var W = D.indexOf(hostEndingChars[X]);\n      W !== -1 && (V === -1 || W < V) && (V = W);\n    }\n    var Y, q;\n    V === -1 ? q = D.lastIndexOf(\"@\") : q = D.lastIndexOf(\"@\", V), q !== -1 && (Y = D.slice(0, q), D = D.slice(q + 1), this.auth = decodeURIComponent(Y)), V = -1;\n    for (var X = 0; X < nonHostChars.length; X++) {\n      var W = D.indexOf(nonHostChars[X]);\n      W !== -1 && (V === -1 || W < V) && (V = W);\n    }\n    V === -1 && (V = D.length), this.host = D.slice(0, V), D = D.slice(V), this.parseHost(), this.hostname = this.hostname || \"\";\n    var Z = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!Z)\n      for (var K = this.hostname.split(/\\./), X = 0, J = K.length; X < J; X++) {\n        var tt = K[X];\n        if (!!tt && !tt.match(hostnamePartPattern)) {\n          for (var et = \"\", Q = 0, at = tt.length; Q < at; Q++)\n            tt.charCodeAt(Q) > 127 ? et += \"x\" : et += tt[Q];\n          if (!et.match(hostnamePartPattern)) {\n            var it = K.slice(0, X), st = K.slice(X + 1), ut = tt.match(hostnamePartStart);\n            ut && (it.push(ut[1]), st.unshift(ut[2])), st.length && (D = \"/\" + st.join(\".\") + D), this.hostname = it.join(\".\");\n            break;\n          }\n        }\n      }\n    this.hostname.length > hostnameMaxLen ? this.hostname = \"\" : this.hostname = this.hostname.toLowerCase(), Z || (this.hostname = punycode.toASCII(this.hostname));\n    var ft = this.port ? \":\" + this.port : \"\", ct = this.hostname || \"\";\n    this.host = ct + ft, this.href += this.host, Z && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), D[0] !== \"/\" && (D = \"/\" + D));\n  }\n  if (!unsafeProtocol[U])\n    for (var X = 0, J = autoEscape.length; X < J; X++) {\n      var pt = autoEscape[X];\n      if (D.indexOf(pt) !== -1) {\n        var mt = encodeURIComponent(pt);\n        mt === pt && (mt = escape(pt)), D = D.split(pt).join(mt);\n      }\n    }\n  var vt = D.indexOf(\"#\");\n  vt !== -1 && (this.hash = D.substr(vt), D = D.slice(0, vt));\n  var _t = D.indexOf(\"?\");\n  if (_t !== -1 ? (this.search = D.substr(_t), this.query = D.substr(_t + 1), t && (this.query = querystring.parse(this.query)), D = D.slice(0, _t)) : t && (this.search = \"\", this.query = {}), D && (this.pathname = D), slashedProtocol[U] && this.hostname && !this.pathname && (this.pathname = \"/\"), this.pathname || this.search) {\n    var ft = this.pathname || \"\", xt = this.search || \"\";\n    this.path = ft + xt;\n  }\n  return this.href = this.format(), this;\n};\nfunction urlFormat(r) {\n  return util$7.isString(r) && (r = urlParse(r)), r instanceof Url ? r.format() : Url.prototype.format.call(r);\n}\nUrl.prototype.format = function() {\n  var r = this.auth || \"\";\n  r && (r = encodeURIComponent(r), r = r.replace(/%3A/i, \":\"), r += \"@\");\n  var t = this.protocol || \"\", e = this.pathname || \"\", o = this.hash || \"\", T = !1, S = \"\";\n  this.host ? T = r + this.host : this.hostname && (T = r + (this.hostname.indexOf(\":\") === -1 ? this.hostname : \"[\" + this.hostname + \"]\"), this.port && (T += \":\" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (S = querystring.stringify(this.query));\n  var N = this.search || S && \"?\" + S || \"\";\n  return t && t.substr(-1) !== \":\" && (t += \":\"), this.slashes || (!t || slashedProtocol[t]) && T !== !1 ? (T = \"//\" + (T || \"\"), e && e.charAt(0) !== \"/\" && (e = \"/\" + e)) : T || (T = \"\"), o && o.charAt(0) !== \"#\" && (o = \"#\" + o), N && N.charAt(0) !== \"?\" && (N = \"?\" + N), e = e.replace(/[?#]/g, function(D) {\n    return encodeURIComponent(D);\n  }), N = N.replace(\"#\", \"%23\"), t + T + e + N + o;\n};\nfunction urlResolve(r, t) {\n  return urlParse(r, !1, !0).resolve(t);\n}\nUrl.prototype.resolve = function(r) {\n  return this.resolveObject(urlParse(r, !1, !0)).format();\n};\nUrl.prototype.resolveObject = function(r) {\n  if (util$7.isString(r)) {\n    var t = new Url();\n    t.parse(r, !1, !0), r = t;\n  }\n  for (var e = new Url(), o = Object.keys(this), T = 0; T < o.length; T++) {\n    var S = o[T];\n    e[S] = this[S];\n  }\n  if (e.hash = r.hash, r.href === \"\")\n    return e.href = e.format(), e;\n  if (r.slashes && !r.protocol) {\n    for (var N = Object.keys(r), D = 0; D < N.length; D++) {\n      var B = N[D];\n      B !== \"protocol\" && (e[B] = r[B]);\n    }\n    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = \"/\"), e.href = e.format(), e;\n  }\n  if (r.protocol && r.protocol !== e.protocol) {\n    if (!slashedProtocol[r.protocol]) {\n      for (var $ = Object.keys(r), U = 0; U < $.length; U++) {\n        var z = $[U];\n        e[z] = r[z];\n      }\n      return e.href = e.format(), e;\n    }\n    if (e.protocol = r.protocol, !r.host && !hostlessProtocol[r.protocol]) {\n      for (var J = (r.pathname || \"\").split(\"/\"); J.length && !(r.host = J.shift()); )\n        ;\n      r.host || (r.host = \"\"), r.hostname || (r.hostname = \"\"), J[0] !== \"\" && J.unshift(\"\"), J.length < 2 && J.unshift(\"\"), e.pathname = J.join(\"/\");\n    } else\n      e.pathname = r.pathname;\n    if (e.search = r.search, e.query = r.query, e.host = r.host || \"\", e.auth = r.auth, e.hostname = r.hostname || r.host, e.port = r.port, e.pathname || e.search) {\n      var V = e.pathname || \"\", X = e.search || \"\";\n      e.path = V + X;\n    }\n    return e.slashes = e.slashes || r.slashes, e.href = e.format(), e;\n  }\n  var W = e.pathname && e.pathname.charAt(0) === \"/\", Y = r.host || r.pathname && r.pathname.charAt(0) === \"/\", q = Y || W || e.host && r.pathname, Z = q, K = e.pathname && e.pathname.split(\"/\") || [], J = r.pathname && r.pathname.split(\"/\") || [], tt = e.protocol && !slashedProtocol[e.protocol];\n  if (tt && (e.hostname = \"\", e.port = null, e.host && (K[0] === \"\" ? K[0] = e.host : K.unshift(e.host)), e.host = \"\", r.protocol && (r.hostname = null, r.port = null, r.host && (J[0] === \"\" ? J[0] = r.host : J.unshift(r.host)), r.host = null), q = q && (J[0] === \"\" || K[0] === \"\")), Y)\n    e.host = r.host || r.host === \"\" ? r.host : e.host, e.hostname = r.hostname || r.hostname === \"\" ? r.hostname : e.hostname, e.search = r.search, e.query = r.query, K = J;\n  else if (J.length)\n    K || (K = []), K.pop(), K = K.concat(J), e.search = r.search, e.query = r.query;\n  else if (!util$7.isNullOrUndefined(r.search)) {\n    if (tt) {\n      e.hostname = e.host = K.shift();\n      var et = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n      et && (e.auth = et.shift(), e.host = e.hostname = et.shift());\n    }\n    return e.search = r.search, e.query = r.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.href = e.format(), e;\n  }\n  if (!K.length)\n    return e.pathname = null, e.search ? e.path = \"/\" + e.search : e.path = null, e.href = e.format(), e;\n  for (var Q = K.slice(-1)[0], at = (e.host || r.host || K.length > 1) && (Q === \".\" || Q === \"..\") || Q === \"\", it = 0, st = K.length; st >= 0; st--)\n    Q = K[st], Q === \".\" ? K.splice(st, 1) : Q === \"..\" ? (K.splice(st, 1), it++) : it && (K.splice(st, 1), it--);\n  if (!q && !Z)\n    for (; it--; it)\n      K.unshift(\"..\");\n  q && K[0] !== \"\" && (!K[0] || K[0].charAt(0) !== \"/\") && K.unshift(\"\"), at && K.join(\"/\").substr(-1) !== \"/\" && K.push(\"\");\n  var ut = K[0] === \"\" || K[0] && K[0].charAt(0) === \"/\";\n  if (tt) {\n    e.hostname = e.host = ut ? \"\" : K.length ? K.shift() : \"\";\n    var et = e.host && e.host.indexOf(\"@\") > 0 ? e.host.split(\"@\") : !1;\n    et && (e.auth = et.shift(), e.host = e.hostname = et.shift());\n  }\n  return q = q || e.host && K.length, q && !ut && K.unshift(\"\"), K.length ? e.pathname = K.join(\"/\") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : \"\") + (e.search ? e.search : \"\")), e.auth = r.auth || e.auth, e.slashes = e.slashes || r.slashes, e.href = e.format(), e;\n};\nUrl.prototype.parseHost = function() {\n  var r = this.host, t = portPattern.exec(r);\n  t && (t = t[0], t !== \":\" && (this.port = t.substr(1)), r = r.substr(0, r.length - t.length)), r && (this.hostname = r);\n};\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$5;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$5 || (ENV$5 = {}));\nvar RENDERER_TYPE$5;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {}));\nvar BUFFER_BITS$5;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {}));\nvar BLEND_MODES$5;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$5 || (BLEND_MODES$5 = {}));\nvar DRAW_MODES$5;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$5 || (DRAW_MODES$5 = {}));\nvar FORMATS$5;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$5 || (FORMATS$5 = {}));\nvar TARGETS$5;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$5 || (TARGETS$5 = {}));\nvar TYPES$5;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$5 || (TYPES$5 = {}));\nvar SAMPLER_TYPES$5;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {}));\nvar SCALE_MODES$5;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$5 || (SCALE_MODES$5 = {}));\nvar WRAP_MODES$5;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$5 || (WRAP_MODES$5 = {}));\nvar MIPMAP_MODES$5;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {}));\nvar ALPHA_MODES$5;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {}));\nvar CLEAR_MODES$5;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {}));\nvar GC_MODES$5;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$5 || (GC_MODES$5 = {}));\nvar PRECISION$5;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$5 || (PRECISION$5 = {}));\nvar MASK_TYPES$5;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$5 || (MASK_TYPES$5 = {}));\nvar COLOR_MASK_BITS$5;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$5 || (COLOR_MASK_BITS$5 = {}));\nvar MSAA_QUALITY$5;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {}));\nvar BUFFER_TYPE$5;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));\n/*!\n * @pixi/utils - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar url$1 = {\n  parse: parse$2,\n  format: format$1,\n  resolve\n};\nsettings$1.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nvar saidHello = !1, VERSION$1 = \"6.5.5\";\nfunction skipHello() {\n  saidHello = !0;\n}\nfunction sayHello(r) {\n  var t;\n  if (!saidHello) {\n    if (settings$1.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n      var e = [\n        `\n %c %c %c PixiJS ` + VERSION$1 + \" - \\u2730 \" + r + ` \\u2730  %c  %c  http://www.pixijs.com/  %c %c \\u2665%c\\u2665%c\\u2665 \n\n`,\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff66a5; background: #030307; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ffc3dc; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\"\n      ];\n      (t = globalThis.console).log.apply(t, e);\n    } else\n      globalThis.console && globalThis.console.log(\"PixiJS \" + VERSION$1 + \" - \" + r + \" - http://www.pixijs.com/\");\n    saidHello = !0;\n  }\n}\nvar supported;\nfunction isWebGLSupported() {\n  return typeof supported > \"u\" && (supported = function() {\n    var t = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!settings$1.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      var e = settings$1.ADAPTER.createCanvas(), o = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t), T = !!(o && o.getContextAttributes().stencil);\n      if (o) {\n        var S = o.getExtension(\"WEBGL_lose_context\");\n        S && S.loseContext();\n      }\n      return o = null, T;\n    } catch {\n      return !1;\n    }\n  }()), supported;\n}\nvar aliceblue = \"#f0f8ff\", antiquewhite = \"#faebd7\", aqua = \"#00ffff\", aquamarine = \"#7fffd4\", azure = \"#f0ffff\", beige = \"#f5f5dc\", bisque = \"#ffe4c4\", black = \"#000000\", blanchedalmond = \"#ffebcd\", blue = \"#0000ff\", blueviolet = \"#8a2be2\", brown = \"#a52a2a\", burlywood = \"#deb887\", cadetblue = \"#5f9ea0\", chartreuse = \"#7fff00\", chocolate = \"#d2691e\", coral = \"#ff7f50\", cornflowerblue = \"#6495ed\", cornsilk = \"#fff8dc\", crimson = \"#dc143c\", cyan = \"#00ffff\", darkblue = \"#00008b\", darkcyan = \"#008b8b\", darkgoldenrod = \"#b8860b\", darkgray = \"#a9a9a9\", darkgreen = \"#006400\", darkgrey = \"#a9a9a9\", darkkhaki = \"#bdb76b\", darkmagenta = \"#8b008b\", darkolivegreen = \"#556b2f\", darkorange = \"#ff8c00\", darkorchid = \"#9932cc\", darkred = \"#8b0000\", darksalmon = \"#e9967a\", darkseagreen = \"#8fbc8f\", darkslateblue = \"#483d8b\", darkslategray = \"#2f4f4f\", darkslategrey = \"#2f4f4f\", darkturquoise = \"#00ced1\", darkviolet = \"#9400d3\", deeppink = \"#ff1493\", deepskyblue = \"#00bfff\", dimgray = \"#696969\", dimgrey = \"#696969\", dodgerblue = \"#1e90ff\", firebrick = \"#b22222\", floralwhite = \"#fffaf0\", forestgreen = \"#228b22\", fuchsia = \"#ff00ff\", gainsboro = \"#dcdcdc\", ghostwhite = \"#f8f8ff\", goldenrod = \"#daa520\", gold = \"#ffd700\", gray = \"#808080\", green = \"#008000\", greenyellow = \"#adff2f\", grey = \"#808080\", honeydew = \"#f0fff0\", hotpink = \"#ff69b4\", indianred = \"#cd5c5c\", indigo = \"#4b0082\", ivory = \"#fffff0\", khaki = \"#f0e68c\", lavenderblush = \"#fff0f5\", lavender = \"#e6e6fa\", lawngreen = \"#7cfc00\", lemonchiffon = \"#fffacd\", lightblue = \"#add8e6\", lightcoral = \"#f08080\", lightcyan = \"#e0ffff\", lightgoldenrodyellow = \"#fafad2\", lightgray = \"#d3d3d3\", lightgreen = \"#90ee90\", lightgrey = \"#d3d3d3\", lightpink = \"#ffb6c1\", lightsalmon = \"#ffa07a\", lightseagreen = \"#20b2aa\", lightskyblue = \"#87cefa\", lightslategray = \"#778899\", lightslategrey = \"#778899\", lightsteelblue = \"#b0c4de\", lightyellow = \"#ffffe0\", lime = \"#00ff00\", limegreen = \"#32cd32\", linen = \"#faf0e6\", magenta = \"#ff00ff\", maroon = \"#800000\", mediumaquamarine = \"#66cdaa\", mediumblue = \"#0000cd\", mediumorchid = \"#ba55d3\", mediumpurple = \"#9370db\", mediumseagreen = \"#3cb371\", mediumslateblue = \"#7b68ee\", mediumspringgreen = \"#00fa9a\", mediumturquoise = \"#48d1cc\", mediumvioletred = \"#c71585\", midnightblue = \"#191970\", mintcream = \"#f5fffa\", mistyrose = \"#ffe4e1\", moccasin = \"#ffe4b5\", navajowhite = \"#ffdead\", navy = \"#000080\", oldlace = \"#fdf5e6\", olive = \"#808000\", olivedrab = \"#6b8e23\", orange = \"#ffa500\", orangered = \"#ff4500\", orchid = \"#da70d6\", palegoldenrod = \"#eee8aa\", palegreen = \"#98fb98\", paleturquoise = \"#afeeee\", palevioletred = \"#db7093\", papayawhip = \"#ffefd5\", peachpuff = \"#ffdab9\", peru = \"#cd853f\", pink = \"#ffc0cb\", plum = \"#dda0dd\", powderblue = \"#b0e0e6\", purple = \"#800080\", rebeccapurple = \"#663399\", red = \"#ff0000\", rosybrown = \"#bc8f8f\", royalblue = \"#4169e1\", saddlebrown = \"#8b4513\", salmon = \"#fa8072\", sandybrown = \"#f4a460\", seagreen = \"#2e8b57\", seashell = \"#fff5ee\", sienna = \"#a0522d\", silver = \"#c0c0c0\", skyblue = \"#87ceeb\", slateblue = \"#6a5acd\", slategray = \"#708090\", slategrey = \"#708090\", snow = \"#fffafa\", springgreen = \"#00ff7f\", steelblue = \"#4682b4\", tan = \"#d2b48c\", teal = \"#008080\", thistle = \"#d8bfd8\", tomato = \"#ff6347\", turquoise = \"#40e0d0\", violet = \"#ee82ee\", wheat = \"#f5deb3\", white = \"#ffffff\", whitesmoke = \"#f5f5f5\", yellow = \"#ffff00\", yellowgreen = \"#9acd32\", cssColorNames = {\n  aliceblue,\n  antiquewhite,\n  aqua,\n  aquamarine,\n  azure,\n  beige,\n  bisque,\n  black,\n  blanchedalmond,\n  blue,\n  blueviolet,\n  brown,\n  burlywood,\n  cadetblue,\n  chartreuse,\n  chocolate,\n  coral,\n  cornflowerblue,\n  cornsilk,\n  crimson,\n  cyan,\n  darkblue,\n  darkcyan,\n  darkgoldenrod,\n  darkgray,\n  darkgreen,\n  darkgrey,\n  darkkhaki,\n  darkmagenta,\n  darkolivegreen,\n  darkorange,\n  darkorchid,\n  darkred,\n  darksalmon,\n  darkseagreen,\n  darkslateblue,\n  darkslategray,\n  darkslategrey,\n  darkturquoise,\n  darkviolet,\n  deeppink,\n  deepskyblue,\n  dimgray,\n  dimgrey,\n  dodgerblue,\n  firebrick,\n  floralwhite,\n  forestgreen,\n  fuchsia,\n  gainsboro,\n  ghostwhite,\n  goldenrod,\n  gold,\n  gray,\n  green,\n  greenyellow,\n  grey,\n  honeydew,\n  hotpink,\n  indianred,\n  indigo,\n  ivory,\n  khaki,\n  lavenderblush,\n  lavender,\n  lawngreen,\n  lemonchiffon,\n  lightblue,\n  lightcoral,\n  lightcyan,\n  lightgoldenrodyellow,\n  lightgray,\n  lightgreen,\n  lightgrey,\n  lightpink,\n  lightsalmon,\n  lightseagreen,\n  lightskyblue,\n  lightslategray,\n  lightslategrey,\n  lightsteelblue,\n  lightyellow,\n  lime,\n  limegreen,\n  linen,\n  magenta,\n  maroon,\n  mediumaquamarine,\n  mediumblue,\n  mediumorchid,\n  mediumpurple,\n  mediumseagreen,\n  mediumslateblue,\n  mediumspringgreen,\n  mediumturquoise,\n  mediumvioletred,\n  midnightblue,\n  mintcream,\n  mistyrose,\n  moccasin,\n  navajowhite,\n  navy,\n  oldlace,\n  olive,\n  olivedrab,\n  orange,\n  orangered,\n  orchid,\n  palegoldenrod,\n  palegreen,\n  paleturquoise,\n  palevioletred,\n  papayawhip,\n  peachpuff,\n  peru,\n  pink,\n  plum,\n  powderblue,\n  purple,\n  rebeccapurple,\n  red,\n  rosybrown,\n  royalblue,\n  saddlebrown,\n  salmon,\n  sandybrown,\n  seagreen,\n  seashell,\n  sienna,\n  silver,\n  skyblue,\n  slateblue,\n  slategray,\n  slategrey,\n  snow,\n  springgreen,\n  steelblue,\n  tan,\n  teal,\n  thistle,\n  tomato,\n  turquoise,\n  violet,\n  wheat,\n  white,\n  whitesmoke,\n  yellow,\n  yellowgreen\n};\nfunction hex2rgb(r, t) {\n  return t === void 0 && (t = []), t[0] = (r >> 16 & 255) / 255, t[1] = (r >> 8 & 255) / 255, t[2] = (r & 255) / 255, t;\n}\nfunction hex2string(r) {\n  var t = r.toString(16);\n  return t = \"000000\".substring(0, 6 - t.length) + t, \"#\" + t;\n}\nfunction string2hex(r) {\n  return typeof r == \"string\" && (r = cssColorNames[r.toLowerCase()] || r, r[0] === \"#\" && (r = r.slice(1))), parseInt(r, 16);\n}\nfunction mapPremultipliedBlendModes$1() {\n  for (var r = [], t = [], e = 0; e < 32; e++)\n    r[e] = e, t[e] = e;\n  r[BLEND_MODES$5.NORMAL_NPM] = BLEND_MODES$5.NORMAL, r[BLEND_MODES$5.ADD_NPM] = BLEND_MODES$5.ADD, r[BLEND_MODES$5.SCREEN_NPM] = BLEND_MODES$5.SCREEN, t[BLEND_MODES$5.NORMAL] = BLEND_MODES$5.NORMAL_NPM, t[BLEND_MODES$5.ADD] = BLEND_MODES$5.ADD_NPM, t[BLEND_MODES$5.SCREEN] = BLEND_MODES$5.SCREEN_NPM;\n  var o = [];\n  return o.push(t), o.push(r), o;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes$1();\nfunction correctBlendMode(r, t) {\n  return premultiplyBlendMode[t ? 1 : 0][r];\n}\nfunction premultiplyRgba(r, t, e, o) {\n  return e = e || new Float32Array(4), o || o === void 0 ? (e[0] = r[0] * t, e[1] = r[1] * t, e[2] = r[2] * t) : (e[0] = r[0], e[1] = r[1], e[2] = r[2]), e[3] = t, e;\n}\nfunction premultiplyTint(r, t) {\n  if (t === 1)\n    return (t * 255 << 24) + r;\n  if (t === 0)\n    return 0;\n  var e = r >> 16 & 255, o = r >> 8 & 255, T = r & 255;\n  return e = e * t + 0.5 | 0, o = o * t + 0.5 | 0, T = T * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (o << 8) + T;\n}\nfunction premultiplyTintToRgba(r, t, e, o) {\n  return e = e || new Float32Array(4), e[0] = (r >> 16 & 255) / 255, e[1] = (r >> 8 & 255) / 255, e[2] = (r & 255) / 255, (o || o === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;\n}\nfunction createIndicesForQuads(r, t) {\n  t === void 0 && (t = null);\n  var e = r * 6;\n  if (t = t || new Uint16Array(e), t.length !== e)\n    throw new Error(\"Out buffer length is incorrect, got \" + t.length + \" and expected \" + e);\n  for (var o = 0, T = 0; o < e; o += 6, T += 4)\n    t[o + 0] = T + 0, t[o + 1] = T + 1, t[o + 2] = T + 2, t[o + 3] = T + 0, t[o + 4] = T + 2, t[o + 5] = T + 3;\n  return t;\n}\nfunction getBufferType(r) {\n  if (r.BYTES_PER_ELEMENT === 4)\n    return r instanceof Float32Array ? \"Float32Array\" : r instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (r.BYTES_PER_ELEMENT === 2) {\n    if (r instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (r.BYTES_PER_ELEMENT === 1 && r instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nfunction nextPow2(r) {\n  return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;\n}\nfunction isPow2(r) {\n  return !(r & r - 1) && !!r;\n}\nfunction log2(r) {\n  var t = (r > 65535 ? 1 : 0) << 4;\n  r >>>= t;\n  var e = (r > 255 ? 1 : 0) << 3;\n  return r >>>= e, t |= e, e = (r > 15 ? 1 : 0) << 2, r >>>= e, t |= e, e = (r > 3 ? 1 : 0) << 1, r >>>= e, t |= e, t | r >> 1;\n}\nfunction removeItems(r, t, e) {\n  var o = r.length, T;\n  if (!(t >= o || e === 0)) {\n    e = t + e > o ? o - t : e;\n    var S = o - e;\n    for (T = t; T < S; ++T)\n      r[T] = r[T + e];\n    r.length = S;\n  }\n}\nfunction sign(r) {\n  return r === 0 ? 0 : r < 0 ? -1 : 1;\n}\nvar nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\nvar warnings$1 = {};\nfunction deprecation$1(r, t, e) {\n  if (e === void 0 && (e = 3), !warnings$1[t]) {\n    var o = new Error().stack;\n    typeof o > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + r) : (o = o.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + r), console.warn(o), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + r), console.warn(o))), warnings$1[t] = !0;\n  }\n}\nvar ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction clearTextureCache() {\n  var r;\n  for (r in TextureCache)\n    delete TextureCache[r];\n  for (r in BaseTextureCache)\n    delete BaseTextureCache[r];\n}\nvar CanvasRenderTarget = function() {\n  function r(t, e, o) {\n    this.canvas = settings$1.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = o || settings$1.RESOLUTION, this.resize(t, e);\n  }\n  return r.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }, r.prototype.resize = function(t, e) {\n    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n  }, r.prototype.destroy = function() {\n    this.context = null, this.canvas = null;\n  }, Object.defineProperty(r.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(t) {\n      this.canvas.width = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(t) {\n      this.canvas.height = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}();\nfunction trimCanvas(r) {\n  var t = r.width, e = r.height, o = r.getContext(\"2d\"), T = o.getImageData(0, 0, t, e), S = T.data, N = S.length, D = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  }, B = null, $, U, z;\n  for ($ = 0; $ < N; $ += 4)\n    S[$ + 3] !== 0 && (U = $ / 4 % t, z = ~~($ / 4 / t), D.top === null && (D.top = z), (D.left === null || U < D.left) && (D.left = U), (D.right === null || D.right < U) && (D.right = U + 1), (D.bottom === null || D.bottom < z) && (D.bottom = z));\n  return D.top !== null && (t = D.right - D.left, e = D.bottom - D.top + 1, B = o.getImageData(D.left, D.top, t, e)), {\n    height: e,\n    width: t,\n    data: B\n  };\n}\nvar tempAnchor$1;\nfunction determineCrossOrigin(r, t) {\n  if (t === void 0 && (t = globalThis.location), r.indexOf(\"data:\") === 0)\n    return \"\";\n  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement(\"a\")), tempAnchor$1.href = r;\n  var e = url$1.parse(tempAnchor$1.href), o = !e.port && t.port === \"\" || e.port === t.port;\n  return e.hostname !== t.hostname || !o || e.protocol !== t.protocol ? \"anonymous\" : \"\";\n}\nfunction getResolutionOfUrl(r, t) {\n  var e = settings$1.RETINA_PREFIX.exec(r);\n  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;\n}\n/*!\n * @pixi/math - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;\n(function(r) {\n  r[r.POLY = 0] = \"POLY\", r[r.RECT = 1] = \"RECT\", r[r.CIRC = 2] = \"CIRC\", r[r.ELIP = 3] = \"ELIP\", r[r.RREC = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\nvar Point = function() {\n  function r(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;\n  }\n  return r.prototype.clone = function() {\n    return new r(this.x, this.y);\n  }, r.prototype.copyFrom = function(t) {\n    return this.set(t.x, t.y), this;\n  }, r.prototype.copyTo = function(t) {\n    return t.set(this.x, this.y), t;\n  }, r.prototype.equals = function(t) {\n    return t.x === this.x && t.y === this.y;\n  }, r.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n  }, r;\n}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {\n  function r(t, e, o, T) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 0), this.x = Number(t), this.y = Number(e), this.width = Number(o), this.height = Number(T), this.type = SHAPES.RECT;\n  }\n  return Object.defineProperty(r.prototype, \"left\", {\n    get: function() {\n      return this.x;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"right\", {\n    get: function() {\n      return this.x + this.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"top\", {\n    get: function() {\n      return this.y;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"bottom\", {\n    get: function() {\n      return this.y + this.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"EMPTY\", {\n    get: function() {\n      return new r(0, 0, 0, 0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.clone = function() {\n    return new r(this.x, this.y, this.width, this.height);\n  }, r.prototype.copyFrom = function(t) {\n    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;\n  }, r.prototype.copyTo = function(t) {\n    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;\n  }, r.prototype.contains = function(t, e) {\n    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;\n  }, r.prototype.intersects = function(t, e) {\n    if (!e) {\n      var o = this.x < t.x ? t.x : this.x, T = this.right > t.right ? t.right : this.right;\n      if (T <= o)\n        return !1;\n      var S = this.y < t.y ? t.y : this.y, N = this.bottom > t.bottom ? t.bottom : this.bottom;\n      return N > S;\n    }\n    var D = this.left, B = this.right, $ = this.top, U = this.bottom;\n    if (B <= D || U <= $)\n      return !1;\n    var z = tempPoints$1[0].set(t.left, t.top), V = tempPoints$1[1].set(t.left, t.bottom), X = tempPoints$1[2].set(t.right, t.top), W = tempPoints$1[3].set(t.right, t.bottom);\n    if (X.x <= z.x || V.y <= z.y)\n      return !1;\n    var Y = Math.sign(e.a * e.d - e.b * e.c);\n    if (Y === 0 || (e.apply(z, z), e.apply(V, V), e.apply(X, X), e.apply(W, W), Math.max(z.x, V.x, X.x, W.x) <= D || Math.min(z.x, V.x, X.x, W.x) >= B || Math.max(z.y, V.y, X.y, W.y) <= $ || Math.min(z.y, V.y, X.y, W.y) >= U))\n      return !1;\n    var q = Y * (V.y - z.y), Z = Y * (z.x - V.x), K = q * D + Z * $, J = q * B + Z * $, tt = q * D + Z * U, et = q * B + Z * U;\n    if (Math.max(K, J, tt, et) <= q * z.x + Z * z.y || Math.min(K, J, tt, et) >= q * W.x + Z * W.y)\n      return !1;\n    var Q = Y * (z.y - X.y), at = Y * (X.x - z.x), it = Q * D + at * $, st = Q * B + at * $, ut = Q * D + at * U, ft = Q * B + at * U;\n    return !(Math.max(it, st, ut, ft) <= Q * z.x + at * z.y || Math.min(it, st, ut, ft) >= Q * W.x + at * W.y);\n  }, r.prototype.pad = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;\n  }, r.prototype.fit = function(t) {\n    var e = Math.max(this.x, t.x), o = Math.min(this.x + this.width, t.x + t.width), T = Math.max(this.y, t.y), S = Math.min(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = Math.max(o - e, 0), this.y = T, this.height = Math.max(S - T, 0), this;\n  }, r.prototype.ceil = function(t, e) {\n    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);\n    var o = Math.ceil((this.x + this.width - e) * t) / t, T = Math.ceil((this.y + this.height - e) * t) / t;\n    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = o - this.x, this.height = T - this.y, this;\n  }, r.prototype.enlarge = function(t) {\n    var e = Math.min(this.x, t.x), o = Math.max(this.x + this.width, t.x + t.width), T = Math.min(this.y, t.y), S = Math.max(this.y + this.height, t.y + t.height);\n    return this.x = e, this.width = o - e, this.y = T, this.height = S - T, this;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, r;\n}(), Circle = function() {\n  function r(t, e, o) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), this.x = t, this.y = e, this.radius = o, this.type = SHAPES.CIRC;\n  }\n  return r.prototype.clone = function() {\n    return new r(this.x, this.y, this.radius);\n  }, r.prototype.contains = function(t, e) {\n    if (this.radius <= 0)\n      return !1;\n    var o = this.radius * this.radius, T = this.x - t, S = this.y - e;\n    return T *= T, S *= S, T + S <= o;\n  }, r.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n  }, r;\n}(), Ellipse = function() {\n  function r(t, e, o, T) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 0), this.x = t, this.y = e, this.width = o, this.height = T, this.type = SHAPES.ELIP;\n  }\n  return r.prototype.clone = function() {\n    return new r(this.x, this.y, this.width, this.height);\n  }, r.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    var o = (t - this.x) / this.width, T = (e - this.y) / this.height;\n    return o *= o, T *= T, o + T <= 1;\n  }, r.prototype.getBounds = function() {\n    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n  }, r;\n}(), Polygon = function() {\n  function r() {\n    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)\n      e[o] = t[o];\n    var T = Array.isArray(e[0]) ? e[0] : e;\n    if (typeof T[0] != \"number\") {\n      for (var S = [], N = 0, D = T.length; N < D; N++)\n        S.push(T[N].x, T[N].y);\n      T = S;\n    }\n    this.points = T, this.type = SHAPES.POLY, this.closeStroke = !0;\n  }\n  return r.prototype.clone = function() {\n    var t = this.points.slice(), e = new r(t);\n    return e.closeStroke = this.closeStroke, e;\n  }, r.prototype.contains = function(t, e) {\n    for (var o = !1, T = this.points.length / 2, S = 0, N = T - 1; S < T; N = S++) {\n      var D = this.points[S * 2], B = this.points[S * 2 + 1], $ = this.points[N * 2], U = this.points[N * 2 + 1], z = B > e != U > e && t < ($ - D) * ((e - B) / (U - B)) + D;\n      z && (o = !o);\n    }\n    return o;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(t, e) {\n      return t + \", \" + e;\n    }, \"\") + \"]\");\n  }, r;\n}(), RoundedRectangle = function() {\n  function r(t, e, o, T, S) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 0), S === void 0 && (S = 20), this.x = t, this.y = e, this.width = o, this.height = T, this.radius = S, this.type = SHAPES.RREC;\n  }\n  return r.prototype.clone = function() {\n    return new r(this.x, this.y, this.width, this.height, this.radius);\n  }, r.prototype.contains = function(t, e) {\n    if (this.width <= 0 || this.height <= 0)\n      return !1;\n    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {\n      var o = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n      if (e >= this.y + o && e <= this.y + this.height - o || t >= this.x + o && t <= this.x + this.width - o)\n        return !0;\n      var T = t - (this.x + o), S = e - (this.y + o), N = o * o;\n      if (T * T + S * S <= N || (T = t - (this.x + this.width - o), T * T + S * S <= N) || (S = e - (this.y + this.height - o), T * T + S * S <= N) || (T = t - (this.x + o), T * T + S * S <= N))\n        return !0;\n    }\n    return !1;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n  }, r;\n}(), ObservablePoint = function() {\n  function r(t, e, o, T) {\n    o === void 0 && (o = 0), T === void 0 && (T = 0), this._x = o, this._y = T, this.cb = t, this.scope = e;\n  }\n  return r.prototype.clone = function(t, e) {\n    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new r(t, e, this._x, this._y);\n  }, r.prototype.set = function(t, e) {\n    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;\n  }, r.prototype.copyFrom = function(t) {\n    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;\n  }, r.prototype.copyTo = function(t) {\n    return t.set(this._x, this._y), t;\n  }, r.prototype.equals = function(t) {\n    return t.x === this._x && t.y === this._y;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:ObservablePoint x=\" + 0 + \" y=\" + 0 + \" scope=\" + this.scope + \"]\";\n  }, Object.defineProperty(r.prototype, \"x\", {\n    get: function() {\n      return this._x;\n    },\n    set: function(t) {\n      this._x !== t && (this._x = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"y\", {\n    get: function() {\n      return this._y;\n    },\n    set: function(t) {\n      this._y !== t && (this._y = t, this.cb.call(this.scope));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}(), Matrix = function() {\n  function r(t, e, o, T, S, N) {\n    t === void 0 && (t = 1), e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 1), S === void 0 && (S = 0), N === void 0 && (N = 0), this.array = null, this.a = t, this.b = e, this.c = o, this.d = T, this.tx = S, this.ty = N;\n  }\n  return r.prototype.fromArray = function(t) {\n    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];\n  }, r.prototype.set = function(t, e, o, T, S, N) {\n    return this.a = t, this.b = e, this.c = o, this.d = T, this.tx = S, this.ty = N, this;\n  }, r.prototype.toArray = function(t, e) {\n    this.array || (this.array = new Float32Array(9));\n    var o = e || this.array;\n    return t ? (o[0] = this.a, o[1] = this.b, o[2] = 0, o[3] = this.c, o[4] = this.d, o[5] = 0, o[6] = this.tx, o[7] = this.ty, o[8] = 1) : (o[0] = this.a, o[1] = this.c, o[2] = this.tx, o[3] = this.b, o[4] = this.d, o[5] = this.ty, o[6] = 0, o[7] = 0, o[8] = 1), o;\n  }, r.prototype.apply = function(t, e) {\n    e = e || new Point();\n    var o = t.x, T = t.y;\n    return e.x = this.a * o + this.c * T + this.tx, e.y = this.b * o + this.d * T + this.ty, e;\n  }, r.prototype.applyInverse = function(t, e) {\n    e = e || new Point();\n    var o = 1 / (this.a * this.d + this.c * -this.b), T = t.x, S = t.y;\n    return e.x = this.d * o * T + -this.c * o * S + (this.ty * this.c - this.tx * this.d) * o, e.y = this.a * o * S + -this.b * o * T + (-this.ty * this.a + this.tx * this.b) * o, e;\n  }, r.prototype.translate = function(t, e) {\n    return this.tx += t, this.ty += e, this;\n  }, r.prototype.scale = function(t, e) {\n    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;\n  }, r.prototype.rotate = function(t) {\n    var e = Math.cos(t), o = Math.sin(t), T = this.a, S = this.c, N = this.tx;\n    return this.a = T * e - this.b * o, this.b = T * o + this.b * e, this.c = S * e - this.d * o, this.d = S * o + this.d * e, this.tx = N * e - this.ty * o, this.ty = N * o + this.ty * e, this;\n  }, r.prototype.append = function(t) {\n    var e = this.a, o = this.b, T = this.c, S = this.d;\n    return this.a = t.a * e + t.b * T, this.b = t.a * o + t.b * S, this.c = t.c * e + t.d * T, this.d = t.c * o + t.d * S, this.tx = t.tx * e + t.ty * T + this.tx, this.ty = t.tx * o + t.ty * S + this.ty, this;\n  }, r.prototype.setTransform = function(t, e, o, T, S, N, D, B, $) {\n    return this.a = Math.cos(D + $) * S, this.b = Math.sin(D + $) * S, this.c = -Math.sin(D - B) * N, this.d = Math.cos(D - B) * N, this.tx = t - (o * this.a + T * this.c), this.ty = e - (o * this.b + T * this.d), this;\n  }, r.prototype.prepend = function(t) {\n    var e = this.tx;\n    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {\n      var o = this.a, T = this.c;\n      this.a = o * t.a + this.b * t.c, this.b = o * t.b + this.b * t.d, this.c = T * t.a + this.d * t.c, this.d = T * t.b + this.d * t.d;\n    }\n    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;\n  }, r.prototype.decompose = function(t) {\n    var e = this.a, o = this.b, T = this.c, S = this.d, N = t.pivot, D = -Math.atan2(-T, S), B = Math.atan2(o, e), $ = Math.abs(D + B);\n    return $ < 1e-5 || Math.abs(PI_2 - $) < 1e-5 ? (t.rotation = B, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = D, t.skew.y = B), t.scale.x = Math.sqrt(e * e + o * o), t.scale.y = Math.sqrt(T * T + S * S), t.position.x = this.tx + (N.x * e + N.y * T), t.position.y = this.ty + (N.x * o + N.y * S), t;\n  }, r.prototype.invert = function() {\n    var t = this.a, e = this.b, o = this.c, T = this.d, S = this.tx, N = t * T - e * o;\n    return this.a = T / N, this.b = -e / N, this.c = -o / N, this.d = t / N, this.tx = (o * this.ty - T * S) / N, this.ty = -(t * this.ty - e * S) / N, this;\n  }, r.prototype.identity = function() {\n    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n  }, r.prototype.clone = function() {\n    var t = new r();\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, r.prototype.copyTo = function(t) {\n    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n  }, r.prototype.copyFrom = function(t) {\n    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n  }, Object.defineProperty(r, \"IDENTITY\", {\n    get: function() {\n      return new r();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"TEMP_MATRIX\", {\n    get: function() {\n      return new r();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;\nfunction init() {\n  for (var r = 0; r < 16; r++) {\n    var t = [];\n    rotationCayley.push(t);\n    for (var e = 0; e < 16; e++)\n      for (var o = signum(ux[r] * ux[e] + vx[r] * uy[e]), T = signum(uy[r] * ux[e] + vy[r] * uy[e]), S = signum(ux[r] * vx[e] + vx[r] * vy[e]), N = signum(uy[r] * vx[e] + vy[r] * vy[e]), D = 0; D < 16; D++)\n        if (ux[D] === o && uy[D] === T && vx[D] === S && vy[D] === N) {\n          t.push(D);\n          break;\n        }\n  }\n  for (var r = 0; r < 16; r++) {\n    var B = new Matrix();\n    B.set(ux[r], uy[r], vx[r], vy[r], 0, 0), rotationMatrices.push(B);\n  }\n}\ninit();\nvar groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: function(r) {\n    return ux[r];\n  },\n  uY: function(r) {\n    return uy[r];\n  },\n  vX: function(r) {\n    return vx[r];\n  },\n  vY: function(r) {\n    return vy[r];\n  },\n  inv: function(r) {\n    return r & 8 ? r & 15 : -r & 7;\n  },\n  add: function(r, t) {\n    return rotationCayley[r][t];\n  },\n  sub: function(r, t) {\n    return rotationCayley[r][groupD8.inv(t)];\n  },\n  rotate180: function(r) {\n    return r ^ 4;\n  },\n  isVertical: function(r) {\n    return (r & 3) === 2;\n  },\n  byDirection: function(r, t) {\n    return Math.abs(r) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(r) ? r > 0 ? groupD8.E : groupD8.W : t > 0 ? r > 0 ? groupD8.SE : groupD8.SW : r > 0 ? groupD8.NE : groupD8.NW;\n  },\n  matrixAppendRotationInv: function(r, t, e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0);\n    var T = rotationMatrices[groupD8.inv(t)];\n    T.tx = e, T.ty = o, r.append(T);\n  }\n}, Transform = function() {\n  function r() {\n    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n  }\n  return r.prototype.onChange = function() {\n    this._localID++;\n  }, r.prototype.updateSkew = function() {\n    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n  }, r.prototype.updateLocalTransform = function() {\n    var t = this.localTransform;\n    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);\n  }, r.prototype.updateTransform = function(t) {\n    var e = this.localTransform;\n    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {\n      var o = t.worldTransform, T = this.worldTransform;\n      T.a = e.a * o.a + e.b * o.c, T.b = e.a * o.b + e.b * o.d, T.c = e.c * o.a + e.d * o.c, T.d = e.c * o.b + e.d * o.d, T.tx = e.tx * o.a + e.ty * o.c + o.tx, T.ty = e.tx * o.b + e.ty * o.d + o.ty, this._parentID = t._worldID, this._worldID++;\n    }\n  }, r.prototype.setFromMatrix = function(t) {\n    t.decompose(this), this._localID++;\n  }, Object.defineProperty(r.prototype, \"rotation\", {\n    get: function() {\n      return this._rotation;\n    },\n    set: function(t) {\n      this._rotation !== t && (this._rotation = t, this.updateSkew());\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.IDENTITY = new r(), r;\n}();\n/*!\n * @pixi/display - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.SORTABLE_CHILDREN = !1;\nvar Bounds = function() {\n  function r() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n  }\n  return r.prototype.isEmpty = function() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }, r.prototype.clear = function() {\n    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n  }, r.prototype.getRectangle = function(t) {\n    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);\n  }, r.prototype.addPoint = function(t) {\n    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);\n  }, r.prototype.addPointMatrix = function(t, e) {\n    var o = t.a, T = t.b, S = t.c, N = t.d, D = t.tx, B = t.ty, $ = o * e.x + S * e.y + D, U = T * e.x + N * e.y + B;\n    this.minX = Math.min(this.minX, $), this.maxX = Math.max(this.maxX, $), this.minY = Math.min(this.minY, U), this.maxY = Math.max(this.maxY, U);\n  }, r.prototype.addQuad = function(t) {\n    var e = this.minX, o = this.minY, T = this.maxX, S = this.maxY, N = t[0], D = t[1];\n    e = N < e ? N : e, o = D < o ? D : o, T = N > T ? N : T, S = D > S ? D : S, N = t[2], D = t[3], e = N < e ? N : e, o = D < o ? D : o, T = N > T ? N : T, S = D > S ? D : S, N = t[4], D = t[5], e = N < e ? N : e, o = D < o ? D : o, T = N > T ? N : T, S = D > S ? D : S, N = t[6], D = t[7], e = N < e ? N : e, o = D < o ? D : o, T = N > T ? N : T, S = D > S ? D : S, this.minX = e, this.minY = o, this.maxX = T, this.maxY = S;\n  }, r.prototype.addFrame = function(t, e, o, T, S) {\n    this.addFrameMatrix(t.worldTransform, e, o, T, S);\n  }, r.prototype.addFrameMatrix = function(t, e, o, T, S) {\n    var N = t.a, D = t.b, B = t.c, $ = t.d, U = t.tx, z = t.ty, V = this.minX, X = this.minY, W = this.maxX, Y = this.maxY, q = N * e + B * o + U, Z = D * e + $ * o + z;\n    V = q < V ? q : V, X = Z < X ? Z : X, W = q > W ? q : W, Y = Z > Y ? Z : Y, q = N * T + B * o + U, Z = D * T + $ * o + z, V = q < V ? q : V, X = Z < X ? Z : X, W = q > W ? q : W, Y = Z > Y ? Z : Y, q = N * e + B * S + U, Z = D * e + $ * S + z, V = q < V ? q : V, X = Z < X ? Z : X, W = q > W ? q : W, Y = Z > Y ? Z : Y, q = N * T + B * S + U, Z = D * T + $ * S + z, V = q < V ? q : V, X = Z < X ? Z : X, W = q > W ? q : W, Y = Z > Y ? Z : Y, this.minX = V, this.minY = X, this.maxX = W, this.maxY = Y;\n  }, r.prototype.addVertexData = function(t, e, o) {\n    for (var T = this.minX, S = this.minY, N = this.maxX, D = this.maxY, B = e; B < o; B += 2) {\n      var $ = t[B], U = t[B + 1];\n      T = $ < T ? $ : T, S = U < S ? U : S, N = $ > N ? $ : N, D = U > D ? U : D;\n    }\n    this.minX = T, this.minY = S, this.maxX = N, this.maxY = D;\n  }, r.prototype.addVertices = function(t, e, o, T) {\n    this.addVerticesMatrix(t.worldTransform, e, o, T);\n  }, r.prototype.addVerticesMatrix = function(t, e, o, T, S, N) {\n    S === void 0 && (S = 0), N === void 0 && (N = S);\n    for (var D = t.a, B = t.b, $ = t.c, U = t.d, z = t.tx, V = t.ty, X = this.minX, W = this.minY, Y = this.maxX, q = this.maxY, Z = o; Z < T; Z += 2) {\n      var K = e[Z], J = e[Z + 1], tt = D * K + $ * J + z, et = U * J + B * K + V;\n      X = Math.min(X, tt - S), Y = Math.max(Y, tt + S), W = Math.min(W, et - N), q = Math.max(q, et + N);\n    }\n    this.minX = X, this.minY = W, this.maxX = Y, this.maxY = q;\n  }, r.prototype.addBounds = function(t) {\n    var e = this.minX, o = this.minY, T = this.maxX, S = this.maxY;\n    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < o ? t.minY : o, this.maxX = t.maxX > T ? t.maxX : T, this.maxY = t.maxY > S ? t.maxY : S;\n  }, r.prototype.addBoundsMask = function(t, e) {\n    var o = t.minX > e.minX ? t.minX : e.minX, T = t.minY > e.minY ? t.minY : e.minY, S = t.maxX < e.maxX ? t.maxX : e.maxX, N = t.maxY < e.maxY ? t.maxY : e.maxY;\n    if (o <= S && T <= N) {\n      var D = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;\n      this.minX = o < D ? o : D, this.minY = T < B ? T : B, this.maxX = S > $ ? S : $, this.maxY = N > U ? N : U;\n    }\n  }, r.prototype.addBoundsMatrix = function(t, e) {\n    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);\n  }, r.prototype.addBoundsArea = function(t, e) {\n    var o = t.minX > e.x ? t.minX : e.x, T = t.minY > e.y ? t.minY : e.y, S = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, N = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;\n    if (o <= S && T <= N) {\n      var D = this.minX, B = this.minY, $ = this.maxX, U = this.maxY;\n      this.minX = o < D ? o : D, this.minY = T < B ? T : B, this.maxX = S > $ ? S : $, this.maxY = N > U ? N : U;\n    }\n  }, r.prototype.pad = function(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);\n  }, r.prototype.addFramePad = function(t, e, o, T, S, N) {\n    t -= S, e -= N, o += S, T += N, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > o ? this.maxX : o, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > T ? this.maxY : T;\n  }, r;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$q = function(r, t) {\n  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$q(r, t);\n};\nfunction __extends$q(r, t) {\n  extendStatics$q(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar DisplayObject = function(r) {\n  __extends$q(t, r);\n  function t() {\n    var e = r.call(this) || this;\n    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;\n  }\n  return t.mixin = function(e) {\n    for (var o = Object.keys(e), T = 0; T < o.length; ++T) {\n      var S = o[T];\n      Object.defineProperty(t.prototype, S, Object.getOwnPropertyDescriptor(e, S));\n    }\n  }, Object.defineProperty(t.prototype, \"destroyed\", {\n    get: function() {\n      return this._destroyed;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._recursivePostUpdateTransform = function() {\n    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n  }, t.prototype.updateTransform = function() {\n    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }, t.prototype.getBounds = function(e, o) {\n    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), o || (this._boundsRect || (this._boundsRect = new Rectangle()), o = this._boundsRect), this._bounds.getRectangle(o);\n  }, t.prototype.getLocalBounds = function(e) {\n    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());\n    var o = this.transform, T = this.parent;\n    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;\n    var S = this._bounds, N = this._boundsID;\n    this._bounds = this._localBounds;\n    var D = this.getBounds(!1, e);\n    return this.parent = T, this.transform = o, this._bounds = S, this._bounds.updateID += this._boundsID - N, D;\n  }, t.prototype.toGlobal = function(e, o, T) {\n    return T === void 0 && (T = !1), T || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, o);\n  }, t.prototype.toLocal = function(e, o, T, S) {\n    return o && (e = o.toGlobal(e, T, S)), S || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, T);\n  }, t.prototype.setParent = function(e) {\n    if (!e || !e.addChild)\n      throw new Error(\"setParent: Argument must be a Container\");\n    return e.addChild(this), e;\n  }, t.prototype.setTransform = function(e, o, T, S, N, D, B, $, U) {\n    return e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 1), S === void 0 && (S = 1), N === void 0 && (N = 0), D === void 0 && (D = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), this.position.x = e, this.position.y = o, this.scale.x = T || 1, this.scale.y = S || 1, this.rotation = N, this.skew.x = D, this.skew.y = B, this.pivot.x = $, this.pivot.y = U, this;\n  }, t.prototype.destroy = function(e) {\n    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit(\"destroyed\"), this.removeAllListeners();\n  }, Object.defineProperty(t.prototype, \"_tempDisplayObjectParent\", {\n    get: function() {\n      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.enableTempParent = function() {\n    var e = this.parent;\n    return this.parent = this._tempDisplayObjectParent, e;\n  }, t.prototype.disableTempParent = function(e) {\n    this.parent = e;\n  }, Object.defineProperty(t.prototype, \"x\", {\n    get: function() {\n      return this.position.x;\n    },\n    set: function(e) {\n      this.transform.position.x = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"y\", {\n    get: function() {\n      return this.position.y;\n    },\n    set: function(e) {\n      this.transform.position.y = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldTransform\", {\n    get: function() {\n      return this.transform.worldTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"localTransform\", {\n    get: function() {\n      return this.transform.localTransform;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"position\", {\n    get: function() {\n      return this.transform.position;\n    },\n    set: function(e) {\n      this.transform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scale\", {\n    get: function() {\n      return this.transform.scale;\n    },\n    set: function(e) {\n      this.transform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"pivot\", {\n    get: function() {\n      return this.transform.pivot;\n    },\n    set: function(e) {\n      this.transform.pivot.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"skew\", {\n    get: function() {\n      return this.transform.skew;\n    },\n    set: function(e) {\n      this.transform.skew.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotation\", {\n    get: function() {\n      return this.transform.rotation;\n    },\n    set: function(e) {\n      this.transform.rotation = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"angle\", {\n    get: function() {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function(e) {\n      this.transform.rotation = e * DEG_TO_RAD;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"zIndex\", {\n    get: function() {\n      return this._zIndex;\n    },\n    set: function(e) {\n      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"worldVisible\", {\n    get: function() {\n      var e = this;\n      do {\n        if (!e.visible)\n          return !1;\n        e = e.parent;\n      } while (e);\n      return !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mask\", {\n    get: function() {\n      return this._mask;\n    },\n    set: function(e) {\n      if (this._mask !== e) {\n        if (this._mask) {\n          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          o && (o._maskRefCount--, o._maskRefCount === 0 && (o.renderable = !0, o.isMask = !1));\n        }\n        if (this._mask = e, this._mask) {\n          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n          o && (o._maskRefCount === 0 && (o.renderable = !1, o.isMask = !0), o._maskRefCount++);\n        }\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), TemporaryDisplayObject = function(r) {\n  __extends$q(t, r);\n  function t() {\n    var e = r !== null && r.apply(this, arguments) || this;\n    return e.sortDirty = null, e;\n  }\n  return t;\n}(DisplayObject);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$4;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$4 || (ENV$4 = {}));\nvar RENDERER_TYPE$4;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));\nvar BUFFER_BITS$4;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));\nvar BLEND_MODES$4;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));\nvar DRAW_MODES$4;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));\nvar FORMATS$4;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$4 || (FORMATS$4 = {}));\nvar TARGETS$4;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$4 || (TARGETS$4 = {}));\nvar TYPES$4;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$4 || (TYPES$4 = {}));\nvar SAMPLER_TYPES$4;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));\nvar SCALE_MODES$4;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));\nvar WRAP_MODES$4;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));\nvar MIPMAP_MODES$4;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));\nvar ALPHA_MODES$4;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));\nvar CLEAR_MODES$4;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));\nvar GC_MODES$4;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$4 || (GC_MODES$4 = {}));\nvar PRECISION$4;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$4 || (PRECISION$4 = {}));\nvar MASK_TYPES$4;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));\nvar COLOR_MASK_BITS$4;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$4 || (COLOR_MASK_BITS$4 = {}));\nvar MSAA_QUALITY$4;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));\nvar BUFFER_TYPE$4;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));\nfunction sortChildren(r, t) {\n  return r.zIndex === t.zIndex ? r._lastSortedIndex - t._lastSortedIndex : r.zIndex - t.zIndex;\n}\nvar Container = function(r) {\n  __extends$q(t, r);\n  function t() {\n    var e = r.call(this) || this;\n    return e.children = [], e.sortableChildren = settings$1.SORTABLE_CHILDREN, e.sortDirty = !1, e;\n  }\n  return t.prototype.onChildrenChange = function(e) {\n  }, t.prototype.addChild = function() {\n    for (var e = arguments, o = [], T = 0; T < arguments.length; T++)\n      o[T] = e[T];\n    if (o.length > 1)\n      for (var S = 0; S < o.length; S++)\n        this.addChild(o[S]);\n    else {\n      var N = o[0];\n      N.parent && N.parent.removeChild(N), N.parent = this, this.sortDirty = !0, N.transform._parentID = -1, this.children.push(N), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit(\"childAdded\", N, this, this.children.length - 1), N.emit(\"added\", this);\n    }\n    return o[0];\n  }, t.prototype.addChildAt = function(e, o) {\n    if (o < 0 || o > this.children.length)\n      throw new Error(e + \"addChildAt: The index \" + o + \" supplied is out of bounds \" + this.children.length);\n    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(o, 0, e), this._boundsID++, this.onChildrenChange(o), e.emit(\"added\", this), this.emit(\"childAdded\", e, this, o), e;\n  }, t.prototype.swapChildren = function(e, o) {\n    if (e !== o) {\n      var T = this.getChildIndex(e), S = this.getChildIndex(o);\n      this.children[T] = o, this.children[S] = e, this.onChildrenChange(T < S ? T : S);\n    }\n  }, t.prototype.getChildIndex = function(e) {\n    var o = this.children.indexOf(e);\n    if (o === -1)\n      throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n    return o;\n  }, t.prototype.setChildIndex = function(e, o) {\n    if (o < 0 || o >= this.children.length)\n      throw new Error(\"The index \" + o + \" supplied is out of bounds \" + this.children.length);\n    var T = this.getChildIndex(e);\n    removeItems(this.children, T, 1), this.children.splice(o, 0, e), this.onChildrenChange(o);\n  }, t.prototype.getChildAt = function(e) {\n    if (e < 0 || e >= this.children.length)\n      throw new Error(\"getChildAt: Index (\" + e + \") does not exist.\");\n    return this.children[e];\n  }, t.prototype.removeChild = function() {\n    for (var e = arguments, o = [], T = 0; T < arguments.length; T++)\n      o[T] = e[T];\n    if (o.length > 1)\n      for (var S = 0; S < o.length; S++)\n        this.removeChild(o[S]);\n    else {\n      var N = o[0], D = this.children.indexOf(N);\n      if (D === -1)\n        return null;\n      N.parent = null, N.transform._parentID = -1, removeItems(this.children, D, 1), this._boundsID++, this.onChildrenChange(D), N.emit(\"removed\", this), this.emit(\"childRemoved\", N, this, D);\n    }\n    return o[0];\n  }, t.prototype.removeChildAt = function(e) {\n    var o = this.getChildAt(e);\n    return o.parent = null, o.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), o.emit(\"removed\", this), this.emit(\"childRemoved\", o, this, e), o;\n  }, t.prototype.removeChildren = function(e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = this.children.length);\n    var T = e, S = o, N = S - T, D;\n    if (N > 0 && N <= S) {\n      D = this.children.splice(T, N);\n      for (var B = 0; B < D.length; ++B)\n        D[B].parent = null, D[B].transform && (D[B].transform._parentID = -1);\n      this._boundsID++, this.onChildrenChange(e);\n      for (var B = 0; B < D.length; ++B)\n        D[B].emit(\"removed\", this), this.emit(\"childRemoved\", D[B], this, B);\n      return D;\n    } else if (N === 0 && this.children.length === 0)\n      return [];\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  }, t.prototype.sortChildren = function() {\n    for (var e = !1, o = 0, T = this.children.length; o < T; ++o) {\n      var S = this.children[o];\n      S._lastSortedIndex = o, !e && S.zIndex !== 0 && (e = !0);\n    }\n    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var e = 0, o = this.children.length; e < o; ++e) {\n      var T = this.children[e];\n      T.visible && T.updateTransform();\n    }\n  }, t.prototype.calculateBounds = function() {\n    this._bounds.clear(), this._calculateBounds();\n    for (var e = 0; e < this.children.length; e++) {\n      var o = this.children[e];\n      if (!(!o.visible || !o.renderable))\n        if (o.calculateBounds(), o._mask) {\n          var T = o._mask.isMaskData ? o._mask.maskObject : o._mask;\n          T ? (T.calculateBounds(), this._bounds.addBoundsMask(o._bounds, T._bounds)) : this._bounds.addBounds(o._bounds);\n        } else\n          o.filterArea ? this._bounds.addBoundsArea(o._bounds, o.filterArea) : this._bounds.addBounds(o._bounds);\n    }\n    this._bounds.updateID = this._boundsID;\n  }, t.prototype.getLocalBounds = function(e, o) {\n    o === void 0 && (o = !1);\n    var T = r.prototype.getLocalBounds.call(this, e);\n    if (!o)\n      for (var S = 0, N = this.children.length; S < N; ++S) {\n        var D = this.children[S];\n        D.visible && D.updateTransform();\n      }\n    return T;\n  }, t.prototype._calculateBounds = function() {\n  }, t.prototype._renderWithCulling = function(e) {\n    var o = e.renderTexture.sourceFrame;\n    if (o.width > 0 && o.height > 0) {\n      var T, S;\n      if (this.cullArea ? (T = this.cullArea, S = this.worldTransform) : this._render !== t.prototype._render && (T = this.getBounds(!0)), T && o.intersects(T, S))\n        this._render(e);\n      else if (this.cullArea)\n        return;\n      for (var N = 0, D = this.children.length; N < D; ++N) {\n        var B = this.children[N], $ = B.cullable;\n        B.cullable = $ || !this.cullArea, B.render(e), B.cullable = $;\n      }\n    }\n  }, t.prototype.render = function(e) {\n    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n      if (this._mask || this.filters && this.filters.length)\n        this.renderAdvanced(e);\n      else if (this.cullable)\n        this._renderWithCulling(e);\n      else {\n        this._render(e);\n        for (var o = 0, T = this.children.length; o < T; ++o)\n          this.children[o].render(e);\n      }\n  }, t.prototype.renderAdvanced = function(e) {\n    var o = this.filters, T = this._mask;\n    if (o) {\n      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n      for (var S = 0; S < o.length; S++)\n        o[S].enabled && this._enabledFilters.push(o[S]);\n    }\n    var N = o && this._enabledFilters && this._enabledFilters.length || T && (!T.isMaskData || T.enabled && (T.autoDetect || T.type !== MASK_TYPES$4.NONE));\n    if (N && e.batch.flush(), o && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), T && e.mask.push(this, this._mask), this.cullable)\n      this._renderWithCulling(e);\n    else {\n      this._render(e);\n      for (var S = 0, D = this.children.length; S < D; ++S)\n        this.children[S].render(e);\n    }\n    N && e.batch.flush(), T && e.mask.pop(this), o && this._enabledFilters && this._enabledFilters.length && e.filter.pop();\n  }, t.prototype._render = function(e) {\n  }, t.prototype.destroy = function(e) {\n    r.prototype.destroy.call(this), this.sortDirty = !1;\n    var o = typeof e == \"boolean\" ? e : e && e.children, T = this.removeChildren(0, this.children.length);\n    if (o)\n      for (var S = 0; S < T.length; ++S)\n        T[S].destroy(e);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(e) {\n      var o = this.getLocalBounds().width;\n      o !== 0 ? this.scale.x = e / o : this.scale.x = 1, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(e) {\n      var o = this.getLocalBounds().height;\n      o !== 0 ? this.scale.y = e / o : this.scale.y = 1, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(DisplayObject);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n/*!\n * @pixi/extensions - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/extensions is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$9 = function() {\n  return __assign$9 = Object.assign || function(t) {\n    for (var e = arguments, o, T = 1, S = arguments.length; T < S; T++) {\n      o = e[T];\n      for (var N in o)\n        Object.prototype.hasOwnProperty.call(o, N) && (t[N] = o[N]);\n    }\n    return t;\n  }, __assign$9.apply(this, arguments);\n}, ExtensionType;\n(function(r) {\n  r.Application = \"application\", r.RendererPlugin = \"renderer-webgl-plugin\", r.CanvasRendererPlugin = \"renderer-canvas-plugin\", r.Loader = \"loader\", r.LoadParser = \"load-parser\", r.ResolveParser = \"resolve-parser\", r.CacheParser = \"cache-parser\", r.DetectionParser = \"detection-parser\";\n})(ExtensionType || (ExtensionType = {}));\nvar normalizeExtension = function(r) {\n  if (typeof r == \"function\" || typeof r == \"object\" && r.extension) {\n    if (!r.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    var t = typeof r.extension != \"object\" ? { type: r.extension } : r.extension;\n    r = __assign$9(__assign$9({}, t), { ref: r });\n  }\n  if (typeof r == \"object\")\n    r = __assign$9({}, r);\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof r.type == \"string\" && (r.type = [r.type]), r;\n}, extensions = {\n  _addHandlers: null,\n  _removeHandlers: null,\n  _queue: {},\n  remove: function() {\n    for (var r = arguments, t = this, e = [], o = 0; o < arguments.length; o++)\n      e[o] = r[o];\n    return e.map(normalizeExtension).forEach(function(T) {\n      T.type.forEach(function(S) {\n        var N, D;\n        return (D = (N = t._removeHandlers)[S]) === null || D === void 0 ? void 0 : D.call(N, T);\n      });\n    }), this;\n  },\n  add: function() {\n    for (var r = arguments, t = this, e = [], o = 0; o < arguments.length; o++)\n      e[o] = r[o];\n    return e.map(normalizeExtension).forEach(function(T) {\n      T.type.forEach(function(S) {\n        var N = t._addHandlers, D = t._queue;\n        N[S] ? N[S](T) : (D[S] = D[S] || [], D[S].push(T));\n      });\n    }), this;\n  },\n  handle: function(r, t, e) {\n    var o = this._addHandlers = this._addHandlers || {}, T = this._removeHandlers = this._removeHandlers || {};\n    if (o[r] || T[r])\n      throw new Error(\"Extension type \" + r + \" already has a handler\");\n    o[r] = t, T[r] = e;\n    var S = this._queue;\n    return S[r] && (S[r].forEach(function(N) {\n      return t(N);\n    }), delete S[r]), this;\n  },\n  handleByMap: function(r, t) {\n    return this.handle(r, function(e) {\n      t[e.name] = e.ref;\n    }, function(e) {\n      delete t[e.name];\n    });\n  },\n  handleByList: function(r, t) {\n    return this.handle(r, function(e) {\n      var o, T;\n      t.push(e.ref), r === ExtensionType.Loader && ((T = (o = e.ref).add) === null || T === void 0 || T.call(o));\n    }, function(e) {\n      var o = t.indexOf(e.ref);\n      o !== -1 && t.splice(o, 1);\n    });\n  }\n};\n/*!\n * @pixi/runner - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/runner is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Runner = function() {\n  function r(t) {\n    this.items = [], this._name = t, this._aliasCount = 0;\n  }\n  return r.prototype.emit = function(t, e, o, T, S, N, D, B) {\n    if (arguments.length > 8)\n      throw new Error(\"max arguments reached\");\n    var $ = this, U = $.name, z = $.items;\n    this._aliasCount++;\n    for (var V = 0, X = z.length; V < X; V++)\n      z[V][U](t, e, o, T, S, N, D, B);\n    return z === this.items && this._aliasCount--, this;\n  }, r.prototype.ensureNonAliasedItems = function() {\n    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n  }, r.prototype.add = function(t) {\n    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;\n  }, r.prototype.remove = function(t) {\n    var e = this.items.indexOf(t);\n    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;\n  }, r.prototype.contains = function(t) {\n    return this.items.indexOf(t) !== -1;\n  }, r.prototype.removeAll = function() {\n    return this.ensureNonAliasedItems(), this.items.length = 0, this;\n  }, r.prototype.destroy = function() {\n    this.removeAll(), this.items = null, this._name = null;\n  }, Object.defineProperty(r.prototype, \"empty\", {\n    get: function() {\n      return this.items.length === 0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"name\", {\n    get: function() {\n      return this._name;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}();\nObject.defineProperties(Runner.prototype, {\n  dispatch: { value: Runner.prototype.emit },\n  run: { value: Runner.prototype.emit }\n});\n/*!\n * @pixi/ticker - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/ticker is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.TARGET_FPMS = 0.06;\nvar UPDATE_PRIORITY;\n(function(r) {\n  r[r.INTERACTION = 50] = \"INTERACTION\", r[r.HIGH = 25] = \"HIGH\", r[r.NORMAL = 0] = \"NORMAL\", r[r.LOW = -25] = \"LOW\", r[r.UTILITY = -50] = \"UTILITY\";\n})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));\nvar TickerListener = function() {\n  function r(t, e, o, T) {\n    e === void 0 && (e = null), o === void 0 && (o = 0), T === void 0 && (T = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = o, this.once = T;\n  }\n  return r.prototype.match = function(t, e) {\n    return e === void 0 && (e = null), this.fn === t && this.context === e;\n  }, r.prototype.emit = function(t) {\n    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));\n    var e = this.next;\n    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;\n  }, r.prototype.connect = function(t) {\n    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;\n  }, r.prototype.destroy = function(t) {\n    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n    var e = this.next;\n    return this.next = t ? null : e, this.previous = null, e;\n  }, r;\n}(), Ticker = function() {\n  function r() {\n    var t = this;\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings$1.TARGET_FPMS, this.elapsedMS = 1 / settings$1.TARGET_FPMS, this._tick = function(e) {\n      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));\n    };\n  }\n  return r.prototype._requestIfNeeded = function() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }, r.prototype._cancelIfNeeded = function() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }, r.prototype._startIfPossible = function() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }, r.prototype.add = function(t, e, o) {\n    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o));\n  }, r.prototype.addOnce = function(t, e, o) {\n    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o, !0));\n  }, r.prototype._addListener = function(t) {\n    var e = this._head.next, o = this._head;\n    if (!e)\n      t.connect(o);\n    else {\n      for (; e; ) {\n        if (t.priority > e.priority) {\n          t.connect(o);\n          break;\n        }\n        o = e, e = e.next;\n      }\n      t.previous || t.connect(o);\n    }\n    return this._startIfPossible(), this;\n  }, r.prototype.remove = function(t, e) {\n    for (var o = this._head.next; o; )\n      o.match(t, e) ? o = o.destroy() : o = o.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }, Object.defineProperty(r.prototype, \"count\", {\n    get: function() {\n      if (!this._head)\n        return 0;\n      for (var t = 0, e = this._head; e = e.next; )\n        t++;\n      return t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.start = function() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }, r.prototype.stop = function() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }, r.prototype.destroy = function() {\n    if (!this._protected) {\n      this.stop();\n      for (var t = this._head.next; t; )\n        t = t.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }, r.prototype.update = function(t) {\n    t === void 0 && (t = performance.now());\n    var e;\n    if (t > this.lastTime) {\n      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {\n        var o = t - this._lastFrame | 0;\n        if (o < this._minElapsedMS)\n          return;\n        this._lastFrame = t - o % this._minElapsedMS;\n      }\n      this.deltaMS = e, this.deltaTime = this.deltaMS * settings$1.TARGET_FPMS;\n      for (var T = this._head, S = T.next; S; )\n        S = S.emit(this.deltaTime);\n      T.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = t;\n  }, Object.defineProperty(r.prototype, \"FPS\", {\n    get: function() {\n      return 1e3 / this.elapsedMS;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"minFPS\", {\n    get: function() {\n      return 1e3 / this._maxElapsedMS;\n    },\n    set: function(t) {\n      var e = Math.min(this.maxFPS, t), o = Math.min(Math.max(0, e) / 1e3, settings$1.TARGET_FPMS);\n      this._maxElapsedMS = 1 / o;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"maxFPS\", {\n    get: function() {\n      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n    },\n    set: function(t) {\n      if (t === 0)\n        this._minElapsedMS = 0;\n      else {\n        var e = Math.max(this.minFPS, t);\n        this._minElapsedMS = 1 / (e / 1e3);\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"shared\", {\n    get: function() {\n      if (!r._shared) {\n        var t = r._shared = new r();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return r._shared;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"system\", {\n    get: function() {\n      if (!r._system) {\n        var t = r._system = new r();\n        t.autoStart = !0, t._protected = !0;\n      }\n      return r._system;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}(), TickerPlugin = function() {\n  function r() {\n  }\n  return r.init = function(t) {\n    var e = this;\n    t = Object.assign({\n      autoStart: !0,\n      sharedTicker: !1\n    }, t), Object.defineProperty(this, \"ticker\", {\n      set: function(o) {\n        this._ticker && this._ticker.remove(this.render, this), this._ticker = o, o && o.add(this.render, this, UPDATE_PRIORITY.LOW);\n      },\n      get: function() {\n        return this._ticker;\n      }\n    }), this.stop = function() {\n      e._ticker.stop();\n    }, this.start = function() {\n      e._ticker.start();\n    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();\n  }, r.destroy = function() {\n    if (this._ticker) {\n      var t = this._ticker;\n      this.ticker = null, t.destroy();\n    }\n  }, r.extension = ExtensionType.Application, r;\n}();\n/*!\n * @pixi/core - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/core is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.PREFER_ENV = isMobile$2.any ? ENV$5.WEBGL : ENV$5.WEBGL2;\nsettings$1.STRICT_TEXTURE_CACHE = !1;\nvar INSTALLED = [];\nfunction autoDetectResource(r, t) {\n  if (!r)\n    return null;\n  var e = \"\";\n  if (typeof r == \"string\") {\n    var o = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(r);\n    o && (e = o[1].toLowerCase());\n  }\n  for (var T = INSTALLED.length - 1; T >= 0; --T) {\n    var S = INSTALLED[T];\n    if (S.test && S.test(r, e))\n      return new S(r, t);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$p = function(r, t) {\n  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$p(r, t);\n};\nfunction __extends$p(r, t) {\n  extendStatics$p(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$8 = function() {\n  return __assign$8 = Object.assign || function(t) {\n    for (var e = arguments, o, T = 1, S = arguments.length; T < S; T++) {\n      o = e[T];\n      for (var N in o)\n        Object.prototype.hasOwnProperty.call(o, N) && (t[N] = o[N]);\n    }\n    return t;\n  }, __assign$8.apply(this, arguments);\n};\nfunction __rest$3(r, t) {\n  var e = {};\n  for (var o in r)\n    Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (e[o] = r[o]);\n  if (r != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var T = 0, o = Object.getOwnPropertySymbols(r); T < o.length; T++)\n      t.indexOf(o[T]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[T]) && (e[o[T]] = r[o[T]]);\n  return e;\n}\nvar Resource = function() {\n  function r(t, e) {\n    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner(\"setRealSize\"), this.onUpdate = new Runner(\"update\"), this.onError = new Runner(\"onError\");\n  }\n  return r.prototype.bind = function(t) {\n    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n  }, r.prototype.unbind = function(t) {\n    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);\n  }, r.prototype.resize = function(t, e) {\n    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));\n  }, Object.defineProperty(r.prototype, \"valid\", {\n    get: function() {\n      return !!this._width && !!this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.update = function() {\n    this.destroyed || this.onUpdate.emit();\n  }, r.prototype.load = function() {\n    return Promise.resolve(this);\n  }, Object.defineProperty(r.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.style = function(t, e, o) {\n    return !1;\n  }, r.prototype.dispose = function() {\n  }, r.prototype.destroy = function() {\n    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n  }, r.test = function(t, e) {\n    return !1;\n  }, r;\n}(), BufferResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this, S = o || {}, N = S.width, D = S.height;\n    if (!N || !D)\n      throw new Error(\"BufferResource width or height invalid\");\n    return T = r.call(this, N, D) || this, T.data = e, T;\n  }\n  return t.prototype.upload = function(e, o, T) {\n    var S = e.gl;\n    S.pixelStorei(S.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);\n    var N = o.realWidth, D = o.realHeight;\n    return T.width === N && T.height === D ? S.texSubImage2D(o.target, 0, 0, 0, N, D, o.format, T.type, this.data) : (T.width = N, T.height = D, S.texImage2D(o.target, 0, T.internalFormat, N, D, 0, o.format, T.type, this.data)), !0;\n  }, t.prototype.dispose = function() {\n    this.data = null;\n  }, t.test = function(e) {\n    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;\n  }, t;\n}(Resource), defaultBufferOptions = {\n  scaleMode: SCALE_MODES$5.NEAREST,\n  format: FORMATS$5.RGBA,\n  alphaMode: ALPHA_MODES$5.NPM\n}, BaseTexture = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    e === void 0 && (e = null), o === void 0 && (o = null);\n    var T = r.call(this) || this;\n    o = o || {};\n    var S = o.alphaMode, N = o.mipmap, D = o.anisotropicLevel, B = o.scaleMode, $ = o.width, U = o.height, z = o.wrapMode, V = o.format, X = o.type, W = o.target, Y = o.resolution, q = o.resourceOptions;\n    return e && !(e instanceof Resource) && (e = autoDetectResource(e, q), e.internal = !0), T.resolution = Y || settings$1.RESOLUTION, T.width = Math.round(($ || 0) * T.resolution) / T.resolution, T.height = Math.round((U || 0) * T.resolution) / T.resolution, T._mipmap = N !== void 0 ? N : settings$1.MIPMAP_TEXTURES, T.anisotropicLevel = D !== void 0 ? D : settings$1.ANISOTROPIC_LEVEL, T._wrapMode = z || settings$1.WRAP_MODE, T._scaleMode = B !== void 0 ? B : settings$1.SCALE_MODE, T.format = V || FORMATS$5.RGBA, T.type = X || TYPES$5.UNSIGNED_BYTE, T.target = W || TARGETS$5.TEXTURE_2D, T.alphaMode = S !== void 0 ? S : ALPHA_MODES$5.UNPACK, T.uid = uid(), T.touched = 0, T.isPowerOfTwo = !1, T._refreshPOT(), T._glTextures = {}, T.dirtyId = 0, T.dirtyStyleId = 0, T.cacheId = null, T.valid = $ > 0 && U > 0, T.textureCacheIds = [], T.destroyed = !1, T.resource = null, T._batchEnabled = 0, T._batchLocation = 0, T.parentTextureArray = null, T.setResource(e), T;\n  }\n  return Object.defineProperty(t.prototype, \"realWidth\", {\n    get: function() {\n      return Math.round(this.width * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"realHeight\", {\n    get: function() {\n      return Math.round(this.height * this.resolution);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"mipmap\", {\n    get: function() {\n      return this._mipmap;\n    },\n    set: function(e) {\n      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"scaleMode\", {\n    get: function() {\n      return this._scaleMode;\n    },\n    set: function(e) {\n      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"wrapMode\", {\n    get: function() {\n      return this._wrapMode;\n    },\n    set: function(e) {\n      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.setStyle = function(e, o) {\n    var T;\n    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, T = !0), o !== void 0 && o !== this.mipmap && (this.mipmap = o, T = !0), T && this.dirtyStyleId++, this;\n  }, t.prototype.setSize = function(e, o, T) {\n    return T = T || this.resolution, this.setRealSize(e * T, o * T, T);\n  }, t.prototype.setRealSize = function(e, o, T) {\n    return this.resolution = T || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(o) / this.resolution, this._refreshPOT(), this.update(), this;\n  }, t.prototype._refreshPOT = function() {\n    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n  }, t.prototype.setResolution = function(e) {\n    var o = this.resolution;\n    return o === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * o) / e, this.height = Math.round(this.height * o) / e, this.emit(\"update\", this)), this._refreshPOT(), this);\n  }, t.prototype.setResource = function(e) {\n    if (this.resource === e)\n      return this;\n    if (this.resource)\n      throw new Error(\"Resource can be set only once\");\n    return e.bind(this), this.resource = e, this;\n  }, t.prototype.update = function() {\n    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n  }, t.prototype.onError = function(e) {\n    this.emit(\"error\", this, e);\n  }, t.prototype.destroy = function() {\n    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;\n  }, t.prototype.dispose = function() {\n    this.emit(\"dispose\", this);\n  }, t.prototype.castToBaseTexture = function() {\n    return this;\n  }, t.from = function(e, o, T) {\n    T === void 0 && (T = settings$1.STRICT_TEXTURE_CACHE);\n    var S = typeof e == \"string\", N = null;\n    if (S)\n      N = e;\n    else {\n      if (!e._pixiId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e._pixiId = D + \"_\" + uid();\n      }\n      N = e._pixiId;\n    }\n    var B = BaseTextureCache[N];\n    if (S && T && !B)\n      throw new Error('The cacheId \"' + N + '\" does not exist in BaseTextureCache.');\n    return B || (B = new t(e, o), B.cacheId = N, t.addToCache(B, N)), B;\n  }, t.fromBuffer = function(e, o, T, S) {\n    e = e || new Float32Array(o * T * 4);\n    var N = new BufferResource(e, { width: o, height: T }), D = e instanceof Float32Array ? TYPES$5.FLOAT : TYPES$5.UNSIGNED_BYTE;\n    return new t(N, Object.assign(defaultBufferOptions, S || { width: o, height: T, type: D }));\n  }, t.addToCache = function(e, o) {\n    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), BaseTextureCache[o] && console.warn(\"BaseTexture added to the cache with an id [\" + o + \"] that already had an entry\"), BaseTextureCache[o] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var o = BaseTextureCache[e];\n      if (o) {\n        var T = o.textureCacheIds.indexOf(e);\n        return T > -1 && o.textureCacheIds.splice(T, 1), delete BaseTextureCache[e], o;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var S = 0; S < e.textureCacheIds.length; ++S)\n        delete BaseTextureCache[e.textureCacheIds[S]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, t._globalBatch = 0, t;\n}(i$1), AbstractMultiResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this, S = o || {}, N = S.width, D = S.height;\n    T = r.call(this, N, D) || this, T.items = [], T.itemDirtyIds = [];\n    for (var B = 0; B < e; B++) {\n      var $ = new BaseTexture();\n      T.items.push($), T.itemDirtyIds.push(-2);\n    }\n    return T.length = e, T._load = null, T.baseTexture = null, T;\n  }\n  return t.prototype.initFromArray = function(e, o) {\n    for (var T = 0; T < this.length; T++)\n      !e[T] || (e[T].castToBaseTexture ? this.addBaseTextureAt(e[T].castToBaseTexture(), T) : e[T] instanceof Resource ? this.addResourceAt(e[T], T) : this.addResourceAt(autoDetectResource(e[T], o), T));\n  }, t.prototype.dispose = function() {\n    for (var e = 0, o = this.length; e < o; e++)\n      this.items[e].destroy();\n    this.items = null, this.itemDirtyIds = null, this._load = null;\n  }, t.prototype.addResourceAt = function(e, o) {\n    if (!this.items[o])\n      throw new Error(\"Index \" + o + \" is out of bounds\");\n    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[o].setResource(e), this;\n  }, t.prototype.bind = function(e) {\n    if (this.baseTexture !== null)\n      throw new Error(\"Only one base texture per TextureArray is allowed\");\n    r.prototype.bind.call(this, e);\n    for (var o = 0; o < this.length; o++)\n      this.items[o].parentTextureArray = e, this.items[o].on(\"update\", e.update, e);\n  }, t.prototype.unbind = function(e) {\n    r.prototype.unbind.call(this, e);\n    for (var o = 0; o < this.length; o++)\n      this.items[o].parentTextureArray = null, this.items[o].off(\"update\", e.update, e);\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var o = this.items.map(function(S) {\n      return S.resource;\n    }).filter(function(S) {\n      return S;\n    }), T = o.map(function(S) {\n      return S.load();\n    });\n    return this._load = Promise.all(T).then(function() {\n      var S = e.items[0], N = S.realWidth, D = S.realHeight;\n      return e.resize(N, D), Promise.resolve(e);\n    }), this._load;\n  }, t;\n}(Resource), ArrayResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this, S = o || {}, N = S.width, D = S.height, B, $;\n    return Array.isArray(e) ? (B = e, $ = e.length) : $ = e, T = r.call(this, $, { width: N, height: D }) || this, B && T.initFromArray(B, o), T;\n  }\n  return t.prototype.addBaseTextureAt = function(e, o) {\n    if (e.resource)\n      this.addResourceAt(e.resource, o);\n    else\n      throw new Error(\"ArrayResource does not support RenderTexture\");\n    return this;\n  }, t.prototype.bind = function(e) {\n    r.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_2D_ARRAY;\n  }, t.prototype.upload = function(e, o, T) {\n    var S = this, N = S.length, D = S.itemDirtyIds, B = S.items, $ = e.gl;\n    T.dirtyId < 0 && $.texImage3D($.TEXTURE_2D_ARRAY, 0, T.internalFormat, this._width, this._height, N, 0, o.format, T.type, null);\n    for (var U = 0; U < N; U++) {\n      var z = B[U];\n      D[U] < z.dirtyId && (D[U] = z.dirtyId, z.valid && $.texSubImage3D(\n        $.TEXTURE_2D_ARRAY,\n        0,\n        0,\n        0,\n        U,\n        z.resource.width,\n        z.resource.height,\n        1,\n        o.format,\n        T.type,\n        z.resource.source\n      ));\n    }\n    return !0;\n  }, t;\n}(AbstractMultiResource), BaseImageResource = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    var o = this, T = e, S = T.naturalWidth || T.videoWidth || T.width, N = T.naturalHeight || T.videoHeight || T.height;\n    return o = r.call(this, S, N) || this, o.source = e, o.noSubImage = !1, o;\n  }\n  return t.crossOrigin = function(e, o, T) {\n    T === void 0 && o.indexOf(\"data:\") !== 0 ? e.crossOrigin = determineCrossOrigin(o) : T !== !1 && (e.crossOrigin = typeof T == \"string\" ? T : \"anonymous\");\n  }, t.prototype.upload = function(e, o, T, S) {\n    var N = e.gl, D = o.realWidth, B = o.realHeight;\n    if (S = S || this.source, S instanceof HTMLImageElement) {\n      if (!S.complete || S.naturalWidth === 0)\n        return !1;\n    } else if (S instanceof HTMLVideoElement && S.readyState <= 1)\n      return !1;\n    return N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK), !this.noSubImage && o.target === N.TEXTURE_2D && T.width === D && T.height === B ? N.texSubImage2D(N.TEXTURE_2D, 0, 0, 0, o.format, T.type, S) : (T.width = D, T.height = B, N.texImage2D(o.target, 0, T.internalFormat, o.format, T.type, S)), !0;\n  }, t.prototype.update = function() {\n    if (!this.destroyed) {\n      var e = this.source, o = e.naturalWidth || e.videoWidth || e.width, T = e.naturalHeight || e.videoHeight || e.height;\n      this.resize(o, T), r.prototype.update.call(this);\n    }\n  }, t.prototype.dispose = function() {\n    this.source = null;\n  }, t;\n}(Resource), CanvasResource = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    return r.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    var o = globalThis.OffscreenCanvas;\n    return o && e instanceof o ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;\n  }, t;\n}(BaseImageResource), CubeResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this, S = o || {}, N = S.width, D = S.height, B = S.autoLoad, $ = S.linkBaseTexture;\n    if (e && e.length !== t.SIDES)\n      throw new Error(\"Invalid length. Got \" + e.length + \", expected 6\");\n    T = r.call(this, 6, { width: N, height: D }) || this;\n    for (var U = 0; U < t.SIDES; U++)\n      T.items[U].target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + U;\n    return T.linkBaseTexture = $ !== !1, e && T.initFromArray(e, o), B !== !1 && T.load(), T;\n  }\n  return t.prototype.bind = function(e) {\n    r.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_CUBE_MAP;\n  }, t.prototype.addBaseTextureAt = function(e, o, T) {\n    if (!this.items[o])\n      throw new Error(\"Index \" + o + \" is out of bounds\");\n    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)\n      if (e.resource)\n        this.addResourceAt(e.resource, o);\n      else\n        throw new Error(\"CubeResource does not support copying of renderTexture.\");\n    else\n      e.target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + o, e.parentTextureArray = this.baseTexture, this.items[o] = e;\n    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[o] = e, this;\n  }, t.prototype.upload = function(e, o, T) {\n    for (var S = this.itemDirtyIds, N = 0; N < t.SIDES; N++) {\n      var D = this.items[N];\n      (S[N] < D.dirtyId || T.dirtyId < o.dirtyId) && (D.valid && D.resource ? (D.resource.upload(e, D, T), S[N] = D.dirtyId) : S[N] < -1 && (e.gl.texImage2D(D.target, 0, T.internalFormat, o.realWidth, o.realHeight, 0, o.format, T.type, null), S[N] = -1));\n    }\n    return !0;\n  }, t.test = function(e) {\n    return Array.isArray(e) && e.length === t.SIDES;\n  }, t.SIDES = 6, t;\n}(AbstractMultiResource), ImageResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this;\n    if (o = o || {}, !(e instanceof HTMLImageElement)) {\n      var S = new Image();\n      BaseImageResource.crossOrigin(S, e, o.crossorigin), S.src = e, e = S;\n    }\n    return T = r.call(this, e) || this, !e.complete && !!T._width && !!T._height && (T._width = 0, T._height = 0), T.url = e.src, T._process = null, T.preserveBitmap = !1, T.createBitmap = (o.createBitmap !== void 0 ? o.createBitmap : settings$1.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, T.alphaMode = typeof o.alphaMode == \"number\" ? o.alphaMode : null, T.bitmap = null, T._load = null, o.autoLoad !== !1 && T.load(), T;\n  }\n  return t.prototype.load = function(e) {\n    var o = this;\n    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(T, S) {\n      var N = o.source;\n      o.url = N.src;\n      var D = function() {\n        o.destroyed || (N.onload = null, N.onerror = null, o.resize(N.width, N.height), o._load = null, o.createBitmap ? T(o.process()) : T(o));\n      };\n      N.complete && N.src ? D() : (N.onload = D, N.onerror = function(B) {\n        S(B), o.onError.emit(B);\n      });\n    }), this._load);\n  }, t.prototype.process = function() {\n    var e = this, o = this.source;\n    if (this._process !== null)\n      return this._process;\n    if (this.bitmap !== null || !globalThis.createImageBitmap)\n      return Promise.resolve(this);\n    var T = globalThis.createImageBitmap, S = !o.crossOrigin || o.crossOrigin === \"anonymous\";\n    return this._process = fetch(o.src, {\n      mode: S ? \"cors\" : \"no-cors\"\n    }).then(function(N) {\n      return N.blob();\n    }).then(function(N) {\n      return T(N, 0, 0, o.width, o.height, {\n        premultiplyAlpha: e.alphaMode === ALPHA_MODES$5.UNPACK ? \"premultiply\" : \"none\"\n      });\n    }).then(function(N) {\n      return e.destroyed ? Promise.reject() : (e.bitmap = N, e.update(), e._process = null, Promise.resolve(e));\n    }), this._process;\n  }, t.prototype.upload = function(e, o, T) {\n    if (typeof this.alphaMode == \"number\" && (o.alphaMode = this.alphaMode), !this.createBitmap)\n      return r.prototype.upload.call(this, e, o, T);\n    if (!this.bitmap && (this.process(), !this.bitmap))\n      return !1;\n    if (r.prototype.upload.call(this, e, o, T, this.bitmap), !this.preserveBitmap) {\n      var S = !0, N = o._glTextures;\n      for (var D in N) {\n        var B = N[D];\n        if (B !== T && B.dirtyId !== o.dirtyId) {\n          S = !1;\n          break;\n        }\n      }\n      S && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n    }\n    return !0;\n  }, t.prototype.dispose = function() {\n    this.source.onload = null, this.source.onerror = null, r.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n  }, t.test = function(e) {\n    return typeof e == \"string\" || e instanceof HTMLImageElement;\n  }, t;\n}(BaseImageResource), SVGResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this;\n    return o = o || {}, T = r.call(this, settings$1.ADAPTER.createCanvas()) || this, T._width = 0, T._height = 0, T.svg = e, T.scale = o.scale || 1, T._overrideWidth = o.width, T._overrideHeight = o.height, T._resolve = null, T._crossorigin = o.crossorigin, T._load = null, o.autoLoad !== !1 && T.load(), T;\n  }\n  return t.prototype.load = function() {\n    var e = this;\n    return this._load ? this._load : (this._load = new Promise(function(o) {\n      if (e._resolve = function() {\n        e.resize(e.source.width, e.source.height), o(e);\n      }, t.SVG_XML.test(e.svg.trim())) {\n        if (!btoa)\n          throw new Error(\"Your browser doesn't support base64 conversions.\");\n        e.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(e.svg)));\n      }\n      e._loadSvg();\n    }), this._load);\n  }, t.prototype._loadSvg = function() {\n    var e = this, o = new Image();\n    BaseImageResource.crossOrigin(o, this.svg, this._crossorigin), o.src = this.svg, o.onerror = function(T) {\n      !e._resolve || (o.onerror = null, e.onError.emit(T));\n    }, o.onload = function() {\n      if (!!e._resolve) {\n        var T = o.width, S = o.height;\n        if (!T || !S)\n          throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n        var N = T * e.scale, D = S * e.scale;\n        (e._overrideWidth || e._overrideHeight) && (N = e._overrideWidth || e._overrideHeight / S * T, D = e._overrideHeight || e._overrideWidth / T * S), N = Math.round(N), D = Math.round(D);\n        var B = e.source;\n        B.width = N, B.height = D, B._pixiId = \"canvas_\" + uid(), B.getContext(\"2d\").drawImage(o, 0, 0, T, S, 0, 0, N, D), e._resolve(), e._resolve = null;\n      }\n    };\n  }, t.getSize = function(e) {\n    var o = t.SVG_SIZE.exec(e), T = {};\n    return o && (T[o[1]] = Math.round(parseFloat(o[3])), T[o[5]] = Math.round(parseFloat(o[7]))), T;\n  }, t.prototype.dispose = function() {\n    r.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;\n  }, t.test = function(e, o) {\n    return o === \"svg\" || typeof e == \"string\" && e.startsWith(\"data:image/svg+xml\") || typeof e == \"string\" && t.SVG_XML.test(e);\n  }, t.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i, t;\n}(BaseImageResource), VideoResource = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = this;\n    if (o = o || {}, !(e instanceof HTMLVideoElement)) {\n      var S = document.createElement(\"video\");\n      S.setAttribute(\"preload\", \"auto\"), S.setAttribute(\"webkit-playsinline\", \"\"), S.setAttribute(\"playsinline\", \"\"), typeof e == \"string\" && (e = [e]);\n      var N = e[0].src || e[0];\n      BaseImageResource.crossOrigin(S, N, o.crossorigin);\n      for (var D = 0; D < e.length; ++D) {\n        var B = document.createElement(\"source\"), $ = e[D], U = $.src, z = $.mime;\n        U = U || e[D];\n        var V = U.split(\"?\").shift().toLowerCase(), X = V.slice(V.lastIndexOf(\".\") + 1);\n        z = z || t.MIME_TYPES[X] || \"video/\" + X, B.src = U, B.type = z, S.appendChild(B);\n      }\n      e = S;\n    }\n    return T = r.call(this, e) || this, T.noSubImage = !0, T._autoUpdate = !0, T._isConnectedToTicker = !1, T._updateFPS = o.updateFPS || 0, T._msToNextUpdate = 0, T.autoPlay = o.autoPlay !== !1, T._load = null, T._resolve = null, T._onCanPlay = T._onCanPlay.bind(T), T._onError = T._onError.bind(T), o.autoLoad !== !1 && T.load(), T;\n  }\n  return t.prototype.update = function(e) {\n    if (!this.destroyed) {\n      var o = Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - o), (!this._updateFPS || this._msToNextUpdate <= 0) && (r.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n    }\n  }, t.prototype.load = function() {\n    var e = this;\n    if (this._load)\n      return this._load;\n    var o = this.source;\n    return (o.readyState === o.HAVE_ENOUGH_DATA || o.readyState === o.HAVE_FUTURE_DATA) && o.width && o.height && (o.complete = !0), o.addEventListener(\"play\", this._onPlayStart.bind(this)), o.addEventListener(\"pause\", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (o.addEventListener(\"canplay\", this._onCanPlay), o.addEventListener(\"canplaythrough\", this._onCanPlay), o.addEventListener(\"error\", this._onError, !0)), this._load = new Promise(function(T) {\n      e.valid ? T(e) : (e._resolve = T, o.load());\n    }), this._load;\n  }, t.prototype._onError = function(e) {\n    this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(e);\n  }, t.prototype._isSourcePlaying = function() {\n    var e = this.source;\n    return e.currentTime > 0 && e.paused === !1 && e.ended === !1 && e.readyState > 2;\n  }, t.prototype._isSourceReady = function() {\n    var e = this.source;\n    return e.readyState === 3 || e.readyState === 4;\n  }, t.prototype._onPlayStart = function() {\n    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);\n  }, t.prototype._onPlayStop = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n  }, t.prototype._onCanPlay = function() {\n    var e = this.source;\n    e.removeEventListener(\"canplay\", this._onCanPlay), e.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    var o = this.valid;\n    this.resize(e.videoWidth, e.videoHeight), !o && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();\n  }, t.prototype.dispose = function() {\n    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n    var e = this.source;\n    e && (e.removeEventListener(\"error\", this._onError, !0), e.pause(), e.src = \"\", e.load()), r.prototype.dispose.call(this);\n  }, Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"updateFPS\", {\n    get: function() {\n      return this._updateFPS;\n    },\n    set: function(e) {\n      e !== this._updateFPS && (this._updateFPS = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.test = function(e, o) {\n    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(o) > -1;\n  }, t.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], t.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n  }, t;\n}(BaseImageResource), ImageBitmapResource = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    return r.call(this, e) || this;\n  }\n  return t.test = function(e) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && e instanceof ImageBitmap;\n  }, t;\n}(BaseImageResource);\nINSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\nvar _resources = {\n  __proto__: null,\n  Resource,\n  BaseImageResource,\n  INSTALLED,\n  autoDetectResource,\n  AbstractMultiResource,\n  ArrayResource,\n  BufferResource,\n  CanvasResource,\n  CubeResource,\n  ImageResource,\n  SVGResource,\n  VideoResource,\n  ImageBitmapResource\n}, DepthResource = function(r) {\n  __extends$p(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  return t.prototype.upload = function(e, o, T) {\n    var S = e.gl;\n    S.pixelStorei(S.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);\n    var N = o.realWidth, D = o.realHeight;\n    return T.width === N && T.height === D ? S.texSubImage2D(o.target, 0, 0, 0, N, D, o.format, T.type, this.data) : (T.width = N, T.height = D, S.texImage2D(o.target, 0, T.internalFormat, N, D, 0, o.format, T.type, this.data)), !0;\n  }, t;\n}(BufferResource), Framebuffer = function() {\n  function r(t, e) {\n    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner(\"disposeFramebuffer\"), this.multisample = MSAA_QUALITY$5.NONE;\n  }\n  return Object.defineProperty(r.prototype, \"colorTexture\", {\n    get: function() {\n      return this.colorTextures[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.addColorTexture = function(t, e) {\n    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {\n      scaleMode: SCALE_MODES$5.NEAREST,\n      resolution: 1,\n      mipmap: MIPMAP_MODES$5.OFF,\n      width: this.width,\n      height: this.height\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, r.prototype.addDepthTexture = function(t) {\n    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: SCALE_MODES$5.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: MIPMAP_MODES$5.OFF,\n      format: FORMATS$5.DEPTH_COMPONENT,\n      type: TYPES$5.UNSIGNED_SHORT\n    }), this.dirtyId++, this.dirtyFormat++, this;\n  }, r.prototype.enableDepth = function() {\n    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, r.prototype.enableStencil = function() {\n    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n  }, r.prototype.resize = function(t, e) {\n    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {\n      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;\n      for (var o = 0; o < this.colorTextures.length; o++) {\n        var T = this.colorTextures[o], S = T.resolution;\n        T.setSize(t / S, e / S);\n      }\n      if (this.depthTexture) {\n        var S = this.depthTexture.resolution;\n        this.depthTexture.setSize(t / S, e / S);\n      }\n    }\n  }, r.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, r.prototype.destroyDepthTexture = function() {\n    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n  }, r;\n}(), BaseRenderTexture = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    e === void 0 && (e = {});\n    var o = this;\n    if (typeof e == \"number\") {\n      var T = arguments[0], S = arguments[1], N = arguments[2], D = arguments[3];\n      e = { width: T, height: S, scaleMode: N, resolution: D };\n    }\n    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY$5.NONE, o = r.call(this, null, e) || this, o.mipmap = MIPMAP_MODES$5.OFF, o.valid = !0, o.clearColor = [0, 0, 0, 0], o.framebuffer = new Framebuffer(o.realWidth, o.realHeight).addColorTexture(0, o), o.framebuffer.multisample = e.multisample, o.maskStack = [], o.filterStack = [{}], o;\n  }\n  return t.prototype.resize = function(e, o) {\n    this.framebuffer.resize(e * this.resolution, o * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }, t.prototype.dispose = function() {\n    this.framebuffer.dispose(), r.prototype.dispose.call(this);\n  }, t.prototype.destroy = function() {\n    r.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n  }, t;\n}(BaseTexture), TextureUvs = function() {\n  function r() {\n    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n  }\n  return r.prototype.set = function(t, e, o) {\n    var T = e.width, S = e.height;\n    if (o) {\n      var N = t.width / 2 / T, D = t.height / 2 / S, B = t.x / T + N, $ = t.y / S + D;\n      o = groupD8.add(o, groupD8.NW), this.x0 = B + N * groupD8.uX(o), this.y0 = $ + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x1 = B + N * groupD8.uX(o), this.y1 = $ + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x2 = B + N * groupD8.uX(o), this.y2 = $ + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x3 = B + N * groupD8.uX(o), this.y3 = $ + D * groupD8.uY(o);\n    } else\n      this.x0 = t.x / T, this.y0 = t.y / S, this.x1 = (t.x + t.width) / T, this.y1 = t.y / S, this.x2 = (t.x + t.width) / T, this.y2 = (t.y + t.height) / S, this.x3 = t.x / T, this.y3 = (t.y + t.height) / S;\n    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n  }, r.prototype.toString = function() {\n    return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n  }, r;\n}(), DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(r) {\n  r.destroy = function() {\n  }, r.on = function() {\n  }, r.once = function() {\n  }, r.emit = function() {\n  };\n}\nvar Texture = function(r) {\n  __extends$p(t, r);\n  function t(e, o, T, S, N, D) {\n    var B = r.call(this) || this;\n    if (B.noFrame = !1, o || (B.noFrame = !0, o = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), B.baseTexture = e, B._frame = o, B.trim = S, B.valid = !1, B._uvs = DEFAULT_UVS, B.uvMatrix = null, B.orig = T || o, B._rotate = Number(N || 0), N === !0)\n      B._rotate = 2;\n    else if (B._rotate % 2 !== 0)\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    return B.defaultAnchor = D ? new Point(D.x, D.y) : new Point(0, 0), B._updateID = 0, B.textureCacheIds = [], e.valid ? B.noFrame ? e.valid && B.onBaseTextureUpdated(e) : B.frame = o : e.once(\"loaded\", B.onBaseTextureUpdated, B), B.noFrame && e.on(\"update\", B.onBaseTextureUpdated, B), B;\n  }\n  return t.prototype.update = function() {\n    this.baseTexture.resource && this.baseTexture.resource.update();\n  }, t.prototype.onBaseTextureUpdated = function(e) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid)\n        return;\n      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();\n    } else\n      this.frame = this._frame;\n    this.emit(\"update\", this);\n  }, t.prototype.destroy = function(e) {\n    if (this.baseTexture) {\n      if (e) {\n        var o = this.baseTexture.resource;\n        o && o.url && TextureCache[o.url] && t.removeFromCache(o.url), this.baseTexture.destroy();\n      }\n      this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n    }\n    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;\n  }, t.prototype.clone = function() {\n    var e = this._frame.clone(), o = this._frame === this.orig ? e : this.orig.clone(), T = new t(this.baseTexture, !this.noFrame && e, o, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n    return this.noFrame && (T._frame = e), T;\n  }, t.prototype.updateUvs = function() {\n    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n  }, t.from = function(e, o, T) {\n    o === void 0 && (o = {}), T === void 0 && (T = settings$1.STRICT_TEXTURE_CACHE);\n    var S = typeof e == \"string\", N = null;\n    if (S)\n      N = e;\n    else if (e instanceof BaseTexture) {\n      if (!e.cacheId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e.cacheId = D + \"-\" + uid(), BaseTexture.addToCache(e, e.cacheId);\n      }\n      N = e.cacheId;\n    } else {\n      if (!e._pixiId) {\n        var D = o && o.pixiIdPrefix || \"pixiid\";\n        e._pixiId = D + \"_\" + uid();\n      }\n      N = e._pixiId;\n    }\n    var B = TextureCache[N];\n    if (S && T && !B)\n      throw new Error('The cacheId \"' + N + '\" does not exist in TextureCache.');\n    return !B && !(e instanceof BaseTexture) ? (o.resolution || (o.resolution = getResolutionOfUrl(e)), B = new t(new BaseTexture(e, o)), B.baseTexture.cacheId = N, BaseTexture.addToCache(B.baseTexture, N), t.addToCache(B, N)) : !B && e instanceof BaseTexture && (B = new t(e), t.addToCache(B, N)), B;\n  }, t.fromURL = function(e, o) {\n    var T = Object.assign({ autoLoad: !1 }, o == null ? void 0 : o.resourceOptions), S = t.from(e, Object.assign({ resourceOptions: T }, o), !1), N = S.baseTexture.resource;\n    return S.baseTexture.valid ? Promise.resolve(S) : N.load().then(function() {\n      return Promise.resolve(S);\n    });\n  }, t.fromBuffer = function(e, o, T, S) {\n    return new t(BaseTexture.fromBuffer(e, o, T, S));\n  }, t.fromLoader = function(e, o, T, S) {\n    var N = new BaseTexture(e, Object.assign({\n      scaleMode: settings$1.SCALE_MODE,\n      resolution: getResolutionOfUrl(o)\n    }, S)), D = N.resource;\n    D instanceof ImageResource && (D.url = o);\n    var B = new t(N);\n    return T || (T = o), BaseTexture.addToCache(B.baseTexture, T), t.addToCache(B, T), T !== o && (BaseTexture.addToCache(B.baseTexture, o), t.addToCache(B, o)), B.baseTexture.valid ? Promise.resolve(B) : new Promise(function($) {\n      B.baseTexture.once(\"loaded\", function() {\n        return $(B);\n      });\n    });\n  }, t.addToCache = function(e, o) {\n    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), TextureCache[o] && console.warn(\"Texture added to the cache with an id [\" + o + \"] that already had an entry\"), TextureCache[o] = e);\n  }, t.removeFromCache = function(e) {\n    if (typeof e == \"string\") {\n      var o = TextureCache[e];\n      if (o) {\n        var T = o.textureCacheIds.indexOf(e);\n        return T > -1 && o.textureCacheIds.splice(T, 1), delete TextureCache[e], o;\n      }\n    } else if (e && e.textureCacheIds) {\n      for (var S = 0; S < e.textureCacheIds.length; ++S)\n        TextureCache[e.textureCacheIds[S]] === e && delete TextureCache[e.textureCacheIds[S]];\n      return e.textureCacheIds.length = 0, e;\n    }\n    return null;\n  }, Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this.baseTexture.resolution;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"frame\", {\n    get: function() {\n      return this._frame;\n    },\n    set: function(e) {\n      this._frame = e, this.noFrame = !1;\n      var o = e.x, T = e.y, S = e.width, N = e.height, D = o + S > this.baseTexture.width, B = T + N > this.baseTexture.height;\n      if (D || B) {\n        var $ = D && B ? \"and\" : \"or\", U = \"X: \" + o + \" + \" + S + \" = \" + (o + S) + \" > \" + this.baseTexture.width, z = \"Y: \" + T + \" + \" + N + \" = \" + (T + N) + \" > \" + this.baseTexture.height;\n        throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + (U + \" \" + $ + \" \" + z));\n      }\n      this.valid = S && N && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rotate\", {\n    get: function() {\n      return this._rotate;\n    },\n    set: function(e) {\n      this._rotate = e, this.valid && this.updateUvs();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.orig.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.orig.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.castToBaseTexture = function() {\n    return this.baseTexture;\n  }, Object.defineProperty(t, \"EMPTY\", {\n    get: function() {\n      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"WHITE\", {\n    get: function() {\n      if (!t._WHITE) {\n        var e = settings$1.ADAPTER.createCanvas(16, 16), o = e.getContext(\"2d\");\n        e.width = 16, e.height = 16, o.fillStyle = \"white\", o.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);\n      }\n      return t._WHITE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), RenderTexture = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    var T = r.call(this, e, o) || this;\n    return T.valid = !0, T.filterFrame = null, T.filterPoolKey = null, T.updateUvs(), T;\n  }\n  return Object.defineProperty(t.prototype, \"framebuffer\", {\n    get: function() {\n      return this.baseTexture.framebuffer;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"multisample\", {\n    get: function() {\n      return this.framebuffer.multisample;\n    },\n    set: function(e) {\n      this.framebuffer.multisample = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, o, T) {\n    T === void 0 && (T = !0);\n    var S = this.baseTexture.resolution, N = Math.round(e * S) / S, D = Math.round(o * S) / S;\n    this.valid = N > 0 && D > 0, this._frame.width = this.orig.width = N, this._frame.height = this.orig.height = D, T && this.baseTexture.resize(N, D), this.updateUvs();\n  }, t.prototype.setResolution = function(e) {\n    var o = this.baseTexture;\n    o.resolution !== e && (o.setResolution(e), this.resize(o.width, o.height, !1));\n  }, t.create = function(e) {\n    for (var o = arguments, T = [], S = 1; S < arguments.length; S++)\n      T[S - 1] = o[S];\n    return typeof e == \"number\" && (deprecation$1(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\"), e = {\n      width: e,\n      height: T[0],\n      scaleMode: T[1],\n      resolution: T[2]\n    }), new t(new BaseRenderTexture(e));\n  }, t;\n}(Texture), RenderTexturePool = function() {\n  function r(t) {\n    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n  }\n  return r.prototype.createTexture = function(t, e, o) {\n    o === void 0 && (o = MSAA_QUALITY$5.NONE);\n    var T = new BaseRenderTexture(Object.assign({\n      width: t,\n      height: e,\n      resolution: 1,\n      multisample: o\n    }, this.textureOptions));\n    return new RenderTexture(T);\n  }, r.prototype.getOptimalTexture = function(t, e, o, T) {\n    o === void 0 && (o = 1), T === void 0 && (T = MSAA_QUALITY$5.NONE);\n    var S;\n    t = Math.ceil(t * o - 1e-6), e = Math.ceil(e * o - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), S = ((t & 65535) << 16 | e & 65535) >>> 0, T > 1 && (S += T * 4294967296)) : S = T > 1 ? -T : -1, this.texturePool[S] || (this.texturePool[S] = []);\n    var N = this.texturePool[S].pop();\n    return N || (N = this.createTexture(t, e, T)), N.filterPoolKey = S, N.setResolution(o), N;\n  }, r.prototype.getFilterTexture = function(t, e, o) {\n    var T = this.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);\n    return T.filterFrame = t.filterFrame, T;\n  }, r.prototype.returnTexture = function(t) {\n    var e = t.filterPoolKey;\n    t.filterFrame = null, this.texturePool[e].push(t);\n  }, r.prototype.returnFilterTexture = function(t) {\n    this.returnTexture(t);\n  }, r.prototype.clear = function(t) {\n    if (t = t !== !1, t)\n      for (var e in this.texturePool) {\n        var o = this.texturePool[e];\n        if (o)\n          for (var T = 0; T < o.length; T++)\n            o[T].destroy(!0);\n      }\n    this.texturePool = {};\n  }, r.prototype.setScreenSize = function(t) {\n    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {\n      this.enableFullScreen = t.width > 0 && t.height > 0;\n      for (var e in this.texturePool)\n        if (Number(e) < 0) {\n          var o = this.texturePool[e];\n          if (o)\n            for (var T = 0; T < o.length; T++)\n              o[T].destroy(!0);\n          this.texturePool[e] = [];\n        }\n      this._pixelsWidth = t.width, this._pixelsHeight = t.height;\n    }\n  }, r.SCREEN_KEY = -1, r;\n}(), Attribute = function() {\n  function r(t, e, o, T, S, N, D) {\n    e === void 0 && (e = 0), o === void 0 && (o = !1), T === void 0 && (T = TYPES$5.FLOAT), this.buffer = t, this.size = e, this.normalized = o, this.type = T, this.stride = S, this.start = N, this.instance = D;\n  }\n  return r.prototype.destroy = function() {\n    this.buffer = null;\n  }, r.from = function(t, e, o, T, S) {\n    return new r(t, e, o, T, S);\n  }, r;\n}(), UID$4 = 0, Buffer$1 = function() {\n  function r(t, e, o) {\n    e === void 0 && (e = !0), o === void 0 && (o = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = o, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner(\"disposeBuffer\");\n  }\n  return r.prototype.update = function(t) {\n    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;\n  }, r.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, r.prototype.destroy = function() {\n    this.dispose(), this.data = null;\n  }, Object.defineProperty(r.prototype, \"index\", {\n    get: function() {\n      return this.type === BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;\n    },\n    set: function(t) {\n      this.type = t ? BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$5.ARRAY_BUFFER;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.from = function(t) {\n    return t instanceof Array && (t = new Float32Array(t)), new r(t);\n  }, r;\n}(), map$1$1 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(r, t) {\n  for (var e = 0, o = 0, T = {}, S = 0; S < r.length; S++)\n    o += t[S], e += r[S].length;\n  for (var N = new ArrayBuffer(e * 4), D = null, B = 0, S = 0; S < r.length; S++) {\n    var $ = t[S], U = r[S], z = getBufferType(U);\n    T[z] || (T[z] = new map$1$1[z](N)), D = T[z];\n    for (var V = 0; V < U.length; V++) {\n      var X = (V / $ | 0) * o + B, W = V % $;\n      D[X + W] = U[V];\n    }\n    B += $;\n  }\n  return new Float32Array(N);\n}\nvar byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n}, Geometry = function() {\n  function r(t, e) {\n    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner(\"disposeGeometry\"), this.refCount = 0;\n  }\n  return r.prototype.addAttribute = function(t, e, o, T, S, N, D, B) {\n    if (o === void 0 && (o = 0), T === void 0 && (T = !1), B === void 0 && (B = !1), !e)\n      throw new Error(\"You must pass a buffer when creating an attribute\");\n    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));\n    var $ = t.split(\"|\");\n    if ($.length > 1) {\n      for (var U = 0; U < $.length; U++)\n        this.addAttribute($[U], e, o, T, S);\n      return this;\n    }\n    var z = this.buffers.indexOf(e);\n    return z === -1 && (this.buffers.push(e), z = this.buffers.length - 1), this.attributes[t] = new Attribute(z, o, T, S, N, D, B), this.instanced = this.instanced || B, this;\n  }, r.prototype.getAttribute = function(t) {\n    return this.attributes[t];\n  }, r.prototype.getBuffer = function(t) {\n    return this.buffers[this.getAttribute(t).buffer];\n  }, r.prototype.addIndex = function(t) {\n    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;\n  }, r.prototype.getIndex = function() {\n    return this.indexBuffer;\n  }, r.prototype.interleave = function() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    var t = [], e = [], o = new Buffer$1(), T;\n    for (T in this.attributes) {\n      var S = this.attributes[T], N = this.buffers[S.buffer];\n      t.push(N.data), e.push(S.size * byteSizeMap$1[S.type] / 4), S.buffer = 0;\n    }\n    for (o.data = interleaveTypedArrays(t, e), T = 0; T < this.buffers.length; T++)\n      this.buffers[T] !== this.indexBuffer && this.buffers[T].destroy();\n    return this.buffers = [o], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n  }, r.prototype.getSize = function() {\n    for (var t in this.attributes) {\n      var e = this.attributes[t], o = this.buffers[e.buffer];\n      return o.data.length / (e.stride / 4 || e.size);\n    }\n    return 0;\n  }, r.prototype.dispose = function() {\n    this.disposeRunner.emit(this, !1);\n  }, r.prototype.destroy = function() {\n    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n  }, r.prototype.clone = function() {\n    for (var t = new r(), e = 0; e < this.buffers.length; e++)\n      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));\n    for (var e in this.attributes) {\n      var o = this.attributes[e];\n      t.attributes[e] = new Attribute(o.buffer, o.size, o.normalized, o.type, o.stride, o.start, o.instance);\n    }\n    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER), t;\n  }, r.merge = function(t) {\n    for (var e = new r(), o = [], T = [], S = [], N, D = 0; D < t.length; D++) {\n      N = t[D];\n      for (var B = 0; B < N.buffers.length; B++)\n        T[B] = T[B] || 0, T[B] += N.buffers[B].data.length, S[B] = 0;\n    }\n    for (var D = 0; D < N.buffers.length; D++)\n      o[D] = new map$2[getBufferType(N.buffers[D].data)](T[D]), e.buffers[D] = new Buffer$1(o[D]);\n    for (var D = 0; D < t.length; D++) {\n      N = t[D];\n      for (var B = 0; B < N.buffers.length; B++)\n        o[B].set(N.buffers[B].data, S[B]), S[B] += N.buffers[B].data.length;\n    }\n    if (e.attributes = N.attributes, N.indexBuffer) {\n      e.indexBuffer = e.buffers[N.buffers.indexOf(N.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;\n      for (var $ = 0, U = 0, z = 0, V = 0, D = 0; D < N.buffers.length; D++)\n        if (N.buffers[D] !== N.indexBuffer) {\n          V = D;\n          break;\n        }\n      for (var D in N.attributes) {\n        var X = N.attributes[D];\n        (X.buffer | 0) === V && (U += X.size * byteSizeMap$1[X.type] / 4);\n      }\n      for (var D = 0; D < t.length; D++) {\n        for (var W = t[D].indexBuffer.data, B = 0; B < W.length; B++)\n          e.indexBuffer.data[B + z] += $;\n        $ += t[D].buffers[V].data.length / U, z += W.length;\n      }\n    }\n    return e;\n  }, r;\n}(), Quad = function(r) {\n  __extends$p(t, r);\n  function t() {\n    var e = r.call(this) || this;\n    return e.addAttribute(\"aVertexPosition\", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]), e;\n  }\n  return t;\n}(Geometry), QuadUv = function(r) {\n  __extends$p(t, r);\n  function t() {\n    var e = r.call(this) || this;\n    return e.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]), e.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute(\"aVertexPosition\", e.vertexBuffer).addAttribute(\"aTextureCoord\", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;\n  }\n  return t.prototype.map = function(e, o) {\n    var T = 0, S = 0;\n    return this.uvs[0] = T, this.uvs[1] = S, this.uvs[2] = T + o.width / e.width, this.uvs[3] = S, this.uvs[4] = T + o.width / e.width, this.uvs[5] = S + o.height / e.height, this.uvs[6] = T, this.uvs[7] = S + o.height / e.height, T = o.x, S = o.y, this.vertices[0] = T, this.vertices[1] = S, this.vertices[2] = T + o.width, this.vertices[3] = S, this.vertices[4] = T + o.width, this.vertices[5] = S + o.height, this.vertices[6] = T, this.vertices[7] = S + o.height, this.invalidate(), this;\n  }, t.prototype.invalidate = function() {\n    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n  }, t;\n}(Geometry), UID$2 = 0, UniformGroup = function() {\n  function r(t, e, o) {\n    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!o, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !0));\n  }\n  return r.prototype.update = function() {\n    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n  }, r.prototype.add = function(t, e, o) {\n    if (!this.ubo)\n      this.uniforms[t] = new r(e, o);\n    else\n      throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n  }, r.from = function(t, e, o) {\n    return new r(t, e, o);\n  }, r.uboFrom = function(t, e) {\n    return new r(t, e != null ? e : !0, !0);\n  }, r;\n}(), FilterState = function() {\n  function r() {\n    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY$5.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;\n  }\n  return r.prototype.clear = function() {\n    this.target = null, this.filters = null, this.renderTexture = null;\n  }, r;\n}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {\n  function r(t) {\n    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n  }\n  return r.prototype.push = function(t, e) {\n    for (var o, T, S = this.renderer, N = this.defaultFilterStack, D = this.statePool.pop() || new FilterState(), B = this.renderer.renderTexture, $ = e[0].resolution, U = e[0].multisample, z = e[0].padding, V = e[0].autoFit, X = (o = e[0].legacy) !== null && o !== void 0 ? o : !0, W = 1; W < e.length; W++) {\n      var Y = e[W];\n      $ = Math.min($, Y.resolution), U = Math.min(U, Y.multisample), z = this.useMaxPadding ? Math.max(z, Y.padding) : z + Y.padding, V = V && Y.autoFit, X = X || ((T = Y.legacy) !== null && T !== void 0 ? T : !0);\n    }\n    N.length === 1 && (this.defaultFilterStack[0].renderTexture = B.current), N.push(D), D.resolution = $, D.multisample = U, D.legacy = X, D.target = t, D.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), D.sourceFrame.pad(z);\n    var q = this.tempRect.copyFrom(B.sourceFrame);\n    S.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(S.projection.transform).invert(), q), V ? (D.sourceFrame.fit(q), (D.sourceFrame.width <= 0 || D.sourceFrame.height <= 0) && (D.sourceFrame.width = 0, D.sourceFrame.height = 0)) : D.sourceFrame.intersects(q) || (D.sourceFrame.width = 0, D.sourceFrame.height = 0), this.roundFrame(D.sourceFrame, B.current ? B.current.resolution : S.resolution, B.sourceFrame, B.destinationFrame, S.projection.transform), D.renderTexture = this.getOptimalFilterTexture(D.sourceFrame.width, D.sourceFrame.height, $, U), D.filters = e, D.destinationFrame.width = D.renderTexture.width, D.destinationFrame.height = D.renderTexture.height;\n    var Z = this.tempRect;\n    Z.x = 0, Z.y = 0, Z.width = D.sourceFrame.width, Z.height = D.sourceFrame.height, D.renderTexture.filterFrame = D.sourceFrame, D.bindingSourceFrame.copyFrom(B.sourceFrame), D.bindingDestinationFrame.copyFrom(B.destinationFrame), D.transform = S.projection.transform, S.projection.transform = null, B.bind(D.renderTexture, D.sourceFrame, Z), S.framebuffer.clear(0, 0, 0, 0);\n  }, r.prototype.pop = function() {\n    var t = this.defaultFilterStack, e = t.pop(), o = e.filters;\n    this.activeState = e;\n    var T = this.globalUniforms.uniforms;\n    T.outputFrame = e.sourceFrame, T.resolution = e.resolution;\n    var S = T.inputSize, N = T.inputPixel, D = T.inputClamp;\n    if (S[0] = e.destinationFrame.width, S[1] = e.destinationFrame.height, S[2] = 1 / S[0], S[3] = 1 / S[1], N[0] = Math.round(S[0] * e.resolution), N[1] = Math.round(S[1] * e.resolution), N[2] = 1 / N[0], N[3] = 1 / N[1], D[0] = 0.5 * N[2], D[1] = 0.5 * N[3], D[2] = e.sourceFrame.width * S[2] - 0.5 * N[2], D[3] = e.sourceFrame.height * S[3] - 0.5 * N[3], e.legacy) {\n      var B = T.filterArea;\n      B[0] = e.destinationFrame.width, B[1] = e.destinationFrame.height, B[2] = e.sourceFrame.x, B[3] = e.sourceFrame.y, T.filterClamp = T.inputClamp;\n    }\n    this.globalUniforms.update();\n    var $ = t[t.length - 1];\n    if (this.renderer.framebuffer.blit(), o.length === 1)\n      o[0].apply(this, e.renderTexture, $.renderTexture, CLEAR_MODES$5.BLEND, e), this.returnFilterTexture(e.renderTexture);\n    else {\n      var U = e.renderTexture, z = this.getOptimalFilterTexture(U.width, U.height, e.resolution);\n      z.filterFrame = U.filterFrame;\n      var V = 0;\n      for (V = 0; V < o.length - 1; ++V) {\n        V === 1 && e.multisample > 1 && (z = this.getOptimalFilterTexture(U.width, U.height, e.resolution), z.filterFrame = U.filterFrame), o[V].apply(this, U, z, CLEAR_MODES$5.CLEAR, e);\n        var X = U;\n        U = z, z = X;\n      }\n      o[V].apply(this, U, $.renderTexture, CLEAR_MODES$5.BLEND, e), V > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(U), this.returnFilterTexture(z);\n    }\n    e.clear(), this.statePool.push(e);\n  }, r.prototype.bindAndClear = function(t, e) {\n    e === void 0 && (e = CLEAR_MODES$5.CLEAR);\n    var o = this.renderer, T = o.renderTexture, S = o.state;\n    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {\n      var N = this.tempRect;\n      N.x = 0, N.y = 0, N.width = t.filterFrame.width, N.height = t.filterFrame.height, T.bind(t, t.filterFrame, N);\n    } else\n      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? T.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    var D = S.stateId & 1 || this.forceClear;\n    (e === CLEAR_MODES$5.CLEAR || e === CLEAR_MODES$5.BLIT && D) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n  }, r.prototype.applyFilter = function(t, e, o, T) {\n    var S = this.renderer;\n    S.state.set(t.state), this.bindAndClear(o, T), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, S.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), S.geometry.bind(this.quadUv), S.geometry.draw(DRAW_MODES$5.TRIANGLES)) : (S.geometry.bind(this.quad), S.geometry.draw(DRAW_MODES$5.TRIANGLE_STRIP));\n  }, r.prototype.calculateSpriteMatrix = function(t, e) {\n    var o = this.activeState, T = o.sourceFrame, S = o.destinationFrame, N = e._texture.orig, D = t.set(S.width, 0, 0, S.height, T.x, T.y), B = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    return B.invert(), D.prepend(B), D.scale(1 / N.width, 1 / N.height), D.translate(e.anchor.x, e.anchor.y), D;\n  }, r.prototype.destroy = function() {\n    this.renderer = null, this.texturePool.clear(!1);\n  }, r.prototype.getOptimalFilterTexture = function(t, e, o, T) {\n    return o === void 0 && (o = 1), T === void 0 && (T = MSAA_QUALITY$5.NONE), this.texturePool.getOptimalTexture(t, e, o, T);\n  }, r.prototype.getFilterTexture = function(t, e, o) {\n    if (typeof t == \"number\") {\n      var T = t;\n      t = e, e = T;\n    }\n    t = t || this.activeState.renderTexture;\n    var S = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);\n    return S.filterFrame = t.filterFrame, S;\n  }, r.prototype.returnFilterTexture = function(t) {\n    this.texturePool.returnTexture(t);\n  }, r.prototype.emptyPool = function() {\n    this.texturePool.clear(!0);\n  }, r.prototype.resize = function() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }, r.prototype.transformAABB = function(t, e) {\n    var o = tempPoints[0], T = tempPoints[1], S = tempPoints[2], N = tempPoints[3];\n    o.set(e.left, e.top), T.set(e.left, e.bottom), S.set(e.right, e.top), N.set(e.right, e.bottom), t.apply(o, o), t.apply(T, T), t.apply(S, S), t.apply(N, N);\n    var D = Math.min(o.x, T.x, S.x, N.x), B = Math.min(o.y, T.y, S.y, N.y), $ = Math.max(o.x, T.x, S.x, N.x), U = Math.max(o.y, T.y, S.y, N.y);\n    e.x = D, e.y = B, e.width = $ - D, e.height = U - B;\n  }, r.prototype.roundFrame = function(t, e, o, T, S) {\n    if (!(t.width <= 0 || t.height <= 0 || o.width <= 0 || o.height <= 0)) {\n      if (S) {\n        var N = S.a, D = S.b, B = S.c, $ = S.d;\n        if ((Math.abs(D) > 1e-4 || Math.abs(B) > 1e-4) && (Math.abs(N) > 1e-4 || Math.abs($) > 1e-4))\n          return;\n      }\n      S = S ? tempMatrix$2.copyFrom(S) : tempMatrix$2.identity(), S.translate(-o.x, -o.y).scale(T.width / o.width, T.height / o.height).translate(T.x, T.y), this.transformAABB(S, t), t.ceil(e), this.transformAABB(S.invert(), t);\n    }\n  }, r;\n}(), ObjectRenderer = function() {\n  function r(t) {\n    this.renderer = t;\n  }\n  return r.prototype.flush = function() {\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r.prototype.start = function() {\n  }, r.prototype.stop = function() {\n    this.flush();\n  }, r.prototype.render = function(t) {\n  }, r;\n}(), BatchSystem = function() {\n  function r(t) {\n    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;\n  }\n  return r.prototype.setObjectRenderer = function(t) {\n    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());\n  }, r.prototype.flush = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, r.prototype.reset = function() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }, r.prototype.copyBoundTextures = function(t, e) {\n    for (var o = this.renderer.texture.boundTextures, T = e - 1; T >= 0; --T)\n      t[T] = o[T] || null, t[T] && (t[T]._batchLocation = T);\n  }, r.prototype.boundArray = function(t, e, o, T) {\n    for (var S = t.elements, N = t.ids, D = t.count, B = 0, $ = 0; $ < D; $++) {\n      var U = S[$], z = U._batchLocation;\n      if (z >= 0 && z < T && e[z] === U) {\n        N[$] = z;\n        continue;\n      }\n      for (; B < T; ) {\n        var V = e[B];\n        if (V && V._batchEnabled === o && V._batchLocation === B) {\n          B++;\n          continue;\n        }\n        N[$] = B, U._batchLocation = B, e[B] = U;\n        break;\n      }\n    }\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {\n  function r(t) {\n    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n      uint32Indices: !1\n    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), t.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1);\n  }\n  return Object.defineProperty(r.prototype, \"isLost\", {\n    get: function() {\n      return !this.gl || this.gl.isContextLost();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.contextChange = function(t) {\n    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension(\"WEBGL_lose_context\") && t.getExtension(\"WEBGL_lose_context\").restoreContext();\n  }, r.prototype.initFromContext = function(t) {\n    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);\n  }, r.prototype.initFromOptions = function(t) {\n    var e = this.createContext(this.renderer.view, t);\n    this.initFromContext(e);\n  }, r.prototype.createContext = function(t, e) {\n    var o;\n    if (settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (o = t.getContext(\"webgl2\", e)), o)\n      this.webGLVersion = 2;\n    else if (this.webGLVersion = 1, o = t.getContext(\"webgl\", e) || t.getContext(\"experimental-webgl\", e), !o)\n      throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n    return this.gl = o, this.getExtensions(), this.gl;\n  }, r.prototype.getExtensions = function() {\n    var t = this.gl, e = {\n      anisotropicFiltering: t.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      s3tc: t.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: t.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      etc: t.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: t.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: t.getExtension(\"WEBGL_compressed_texture_pvrtc\") || t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: t.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: t.getExtension(\"WEBGL_compressed_texture_astc\")\n    };\n    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {\n      drawBuffers: t.getExtension(\"WEBGL_draw_buffers\"),\n      depthTexture: t.getExtension(\"WEBGL_depth_texture\"),\n      loseContext: t.getExtension(\"WEBGL_lose_context\"),\n      vertexArrayObject: t.getExtension(\"OES_vertex_array_object\") || t.getExtension(\"MOZ_OES_vertex_array_object\") || t.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n      uint32ElementIndex: t.getExtension(\"OES_element_index_uint\"),\n      floatTexture: t.getExtension(\"OES_texture_float\"),\n      floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n      textureHalfFloat: t.getExtension(\"OES_texture_half_float\"),\n      textureHalfFloatLinear: t.getExtension(\"OES_texture_half_float_linear\")\n    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {\n      colorBufferFloat: t.getExtension(\"EXT_color_buffer_float\")\n    });\n  }, r.prototype.handleContextLost = function(t) {\n    t.preventDefault();\n  }, r.prototype.handleContextRestored = function() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }, r.prototype.destroy = function() {\n    var t = this.renderer.view;\n    this.renderer = null, t.removeEventListener(\"webglcontextlost\", this.handleContextLost), t.removeEventListener(\"webglcontextrestored\", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n  }, r.prototype.postrender = function() {\n    this.renderer.renderingToScreen && this.gl.flush();\n  }, r.prototype.validateContext = function(t) {\n    var e = t.getContextAttributes(), o = \"WebGL2RenderingContext\" in globalThis && t instanceof globalThis.WebGL2RenderingContext;\n    o && (this.webGLVersion = 2), e && !e.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    var T = o || !!t.getExtension(\"OES_element_index_uint\");\n    this.supports.uint32Indices = T, T || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n  }, r;\n}(), GLFramebuffer = function() {\n  function r(t) {\n    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY$5.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n  }\n  return r;\n}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {\n  function r(t) {\n    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;\n  }\n  return r.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {\n      var e = this.renderer.context.extensions.drawBuffers, o = this.renderer.context.extensions.depthTexture;\n      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (e = null, o = null), e ? t.drawBuffers = function(T) {\n        return e.drawBuffersWEBGL(T);\n      } : (this.hasMRT = !1, t.drawBuffers = function() {\n      }), o || (this.writeDepthTexture = !1);\n    } else\n      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);\n  }, r.prototype.bind = function(t, e, o) {\n    o === void 0 && (o = 0);\n    var T = this.gl;\n    if (t) {\n      var S = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);\n      this.current !== t && (this.current = t, T.bindFramebuffer(T.FRAMEBUFFER, S.framebuffer)), S.mipLevel !== o && (t.dirtyId++, t.dirtyFormat++, S.mipLevel = o), S.dirtyId !== t.dirtyId && (S.dirtyId = t.dirtyId, S.dirtyFormat !== t.dirtyFormat ? (S.dirtyFormat = t.dirtyFormat, S.dirtySize = t.dirtySize, this.updateFramebuffer(t, o)) : S.dirtySize !== t.dirtySize && (S.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));\n      for (var N = 0; N < t.colorTextures.length; N++) {\n        var D = t.colorTextures[N];\n        this.renderer.texture.unbind(D.parentTextureArray || D);\n      }\n      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {\n        var B = e.width >> o, $ = e.height >> o, U = B / e.width;\n        this.setViewport(e.x * U, e.y * U, B, $);\n      } else {\n        var B = t.width >> o, $ = t.height >> o;\n        this.setViewport(0, 0, B, $);\n      }\n    } else\n      this.current && (this.current = null, T.bindFramebuffer(T.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n  }, r.prototype.setViewport = function(t, e, o, T) {\n    var S = this.viewport;\n    t = Math.round(t), e = Math.round(e), o = Math.round(o), T = Math.round(T), (S.width !== o || S.height !== T || S.x !== t || S.y !== e) && (S.x = t, S.y = e, S.width = o, S.height = T, this.gl.viewport(t, e, o, T));\n  }, Object.defineProperty(r.prototype, \"size\", {\n    get: function() {\n      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.clear = function(t, e, o, T, S) {\n    S === void 0 && (S = BUFFER_BITS$5.COLOR | BUFFER_BITS$5.DEPTH);\n    var N = this.gl;\n    N.clearColor(t, e, o, T), N.clear(S);\n  }, r.prototype.initFramebuffer = function(t) {\n    var e = this.gl, o = new GLFramebuffer(e.createFramebuffer());\n    return o.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = o, this.managedFramebuffers.push(t), t.disposeRunner.add(this), o;\n  }, r.prototype.resizeFramebuffer = function(t) {\n    var e = this.gl, o = t.glFramebuffers[this.CONTEXT_UID];\n    o.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, o.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.RGBA8, t.width, t.height)), o.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, o.stencil), o.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));\n    var T = t.colorTextures, S = T.length;\n    e.drawBuffers || (S = Math.min(S, 1));\n    for (var N = 0; N < S; N++) {\n      var D = T[N], B = D.parentTextureArray || D;\n      this.renderer.texture.bind(B, 0);\n    }\n    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);\n  }, r.prototype.updateFramebuffer = function(t, e) {\n    var o = this.gl, T = t.glFramebuffers[this.CONTEXT_UID], S = t.colorTextures, N = S.length;\n    o.drawBuffers || (N = Math.min(N, 1)), T.multisample > 1 && this.canMultisampleFramebuffer(t) ? (T.msaaBuffer = T.msaaBuffer || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, T.msaaBuffer), o.renderbufferStorageMultisample(o.RENDERBUFFER, T.multisample, o.RGBA8, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.RENDERBUFFER, T.msaaBuffer)) : T.msaaBuffer && (o.deleteRenderbuffer(T.msaaBuffer), T.msaaBuffer = null, T.blitFramebuffer && (T.blitFramebuffer.dispose(), T.blitFramebuffer = null));\n    for (var D = [], B = 0; B < N; B++) {\n      var $ = S[B], U = $.parentTextureArray || $;\n      this.renderer.texture.bind(U, 0), !(B === 0 && T.msaaBuffer) && (o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + B, $.target, U._glTextures[this.CONTEXT_UID].texture, e), D.push(o.COLOR_ATTACHMENT0 + B));\n    }\n    if (D.length > 1 && o.drawBuffers(D), t.depthTexture) {\n      var z = this.writeDepthTexture;\n      if (z) {\n        var V = t.depthTexture;\n        this.renderer.texture.bind(V, 0), o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.TEXTURE_2D, V._glTextures[this.CONTEXT_UID].texture, e);\n      }\n    }\n    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (T.stencil = T.stencil || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, T.stencil), T.msaaBuffer ? o.renderbufferStorageMultisample(o.RENDERBUFFER, T.multisample, o.DEPTH24_STENCIL8, t.width, t.height) : o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, T.stencil)) : T.stencil && (o.deleteRenderbuffer(T.stencil), T.stencil = null);\n  }, r.prototype.canMultisampleFramebuffer = function(t) {\n    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;\n  }, r.prototype.detectSamples = function(t) {\n    var e = this.msaaSamples, o = MSAA_QUALITY$5.NONE;\n    if (t <= 1 || e === null)\n      return o;\n    for (var T = 0; T < e.length; T++)\n      if (e[T] <= t) {\n        o = e[T];\n        break;\n      }\n    return o === 1 && (o = MSAA_QUALITY$5.NONE), o;\n  }, r.prototype.blit = function(t, e, o) {\n    var T = this, S = T.current, N = T.renderer, D = T.gl, B = T.CONTEXT_UID;\n    if (N.context.webGLVersion === 2 && !!S) {\n      var $ = S.glFramebuffers[B];\n      if (!!$) {\n        if (!t) {\n          if (!$.msaaBuffer)\n            return;\n          var U = S.colorTextures[0];\n          if (!U)\n            return;\n          $.blitFramebuffer || ($.blitFramebuffer = new Framebuffer(S.width, S.height), $.blitFramebuffer.addColorTexture(0, U)), t = $.blitFramebuffer, t.colorTextures[0] !== U && (t.colorTextures[0] = U, t.dirtyId++, t.dirtyFormat++), (t.width !== S.width || t.height !== S.height) && (t.width = S.width, t.height = S.height, t.dirtyId++, t.dirtySize++);\n        }\n        e || (e = tempRectangle, e.width = S.width, e.height = S.height), o || (o = e);\n        var z = e.width === o.width && e.height === o.height;\n        this.bind(t), D.bindFramebuffer(D.READ_FRAMEBUFFER, $.framebuffer), D.blitFramebuffer(e.left, e.top, e.right, e.bottom, o.left, o.top, o.right, o.bottom, D.COLOR_BUFFER_BIT, z ? D.NEAREST : D.LINEAR);\n      }\n    }\n  }, r.prototype.disposeFramebuffer = function(t, e) {\n    var o = t.glFramebuffers[this.CONTEXT_UID], T = this.gl;\n    if (!!o) {\n      delete t.glFramebuffers[this.CONTEXT_UID];\n      var S = this.managedFramebuffers.indexOf(t);\n      S >= 0 && this.managedFramebuffers.splice(S, 1), t.disposeRunner.remove(this), e || (T.deleteFramebuffer(o.framebuffer), o.msaaBuffer && T.deleteRenderbuffer(o.msaaBuffer), o.stencil && T.deleteRenderbuffer(o.stencil)), o.blitFramebuffer && o.blitFramebuffer.dispose();\n    }\n  }, r.prototype.disposeAll = function(t) {\n    var e = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (var o = 0; o < e.length; o++)\n      this.disposeFramebuffer(e[o], t);\n  }, r.prototype.forceStencil = function() {\n    var t = this.current;\n    if (!!t) {\n      var e = t.glFramebuffers[this.CONTEXT_UID];\n      if (!(!e || e.stencil)) {\n        t.stencil = !0;\n        var o = t.width, T = t.height, S = this.gl, N = S.createRenderbuffer();\n        S.bindRenderbuffer(S.RENDERBUFFER, N), e.msaaBuffer ? S.renderbufferStorageMultisample(S.RENDERBUFFER, e.multisample, S.DEPTH24_STENCIL8, o, T) : S.renderbufferStorage(S.RENDERBUFFER, S.DEPTH_STENCIL, o, T), e.stencil = N, S.framebufferRenderbuffer(S.FRAMEBUFFER, S.DEPTH_STENCIL_ATTACHMENT, S.RENDERBUFFER, N);\n      }\n    }\n  }, r.prototype.reset = function() {\n    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {\n  function r(t) {\n    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n  }\n  return r.prototype.contextChange = function() {\n    this.disposeAll(!0);\n    var t = this.gl = this.renderer.gl, e = this.renderer.context;\n    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {\n      var o = this.renderer.context.extensions.vertexArrayObject;\n      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (o = null), o ? (t.createVertexArray = function() {\n        return o.createVertexArrayOES();\n      }, t.bindVertexArray = function(S) {\n        return o.bindVertexArrayOES(S);\n      }, t.deleteVertexArray = function(S) {\n        return o.deleteVertexArrayOES(S);\n      }) : (this.hasVao = !1, t.createVertexArray = function() {\n        return null;\n      }, t.bindVertexArray = function() {\n        return null;\n      }, t.deleteVertexArray = function() {\n        return null;\n      });\n    }\n    if (e.webGLVersion !== 2) {\n      var T = t.getExtension(\"ANGLE_instanced_arrays\");\n      T ? (t.vertexAttribDivisor = function(S, N) {\n        return T.vertexAttribDivisorANGLE(S, N);\n      }, t.drawElementsInstanced = function(S, N, D, B, $) {\n        return T.drawElementsInstancedANGLE(S, N, D, B, $);\n      }, t.drawArraysInstanced = function(S, N, D, B) {\n        return T.drawArraysInstancedANGLE(S, N, D, B);\n      }) : this.hasInstance = !1;\n    }\n    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;\n  }, r.prototype.bind = function(t, e) {\n    e = e || this.renderer.shader.shader;\n    var o = this.gl, T = t.glVertexArrayObjects[this.CONTEXT_UID], S = !1;\n    T || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = T = {}, S = !0);\n    var N = T[e.program.id] || this.initGeometryVao(t, e, S);\n    this._activeGeometry = t, this._activeVao !== N && (this._activeVao = N, this.hasVao ? o.bindVertexArray(N) : this.activateVao(t, e.program)), this.updateBuffers();\n  }, r.prototype.reset = function() {\n    this.unbind();\n  }, r.prototype.updateBuffers = function() {\n    for (var t = this._activeGeometry, e = this.renderer.buffer, o = 0; o < t.buffers.length; o++) {\n      var T = t.buffers[o];\n      e.update(T);\n    }\n  }, r.prototype.checkCompatibility = function(t, e) {\n    var o = t.attributes, T = e.attributeData;\n    for (var S in T)\n      if (!o[S])\n        throw new Error('shader and geometry incompatible, geometry missing the \"' + S + '\" attribute');\n  }, r.prototype.getSignature = function(t, e) {\n    var o = t.attributes, T = e.attributeData, S = [\"g\", t.id];\n    for (var N in o)\n      T[N] && S.push(N, T[N].location);\n    return S.join(\"-\");\n  }, r.prototype.initGeometryVao = function(t, e, o) {\n    o === void 0 && (o = !0);\n    var T = this.gl, S = this.CONTEXT_UID, N = this.renderer.buffer, D = e.program;\n    D.glPrograms[S] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, D);\n    var B = this.getSignature(t, D), $ = t.glVertexArrayObjects[this.CONTEXT_UID], U = $[B];\n    if (U)\n      return $[D.id] = U, U;\n    var z = t.buffers, V = t.attributes, X = {}, W = {};\n    for (var Y in z)\n      X[Y] = 0, W[Y] = 0;\n    for (var Y in V)\n      !V[Y].size && D.attributeData[Y] ? V[Y].size = D.attributeData[Y].size : V[Y].size || console.warn(\"PIXI Geometry attribute '\" + Y + \"' size cannot be determined (likely the bound shader does not have the attribute)\"), X[V[Y].buffer] += V[Y].size * byteSizeMap[V[Y].type];\n    for (var Y in V) {\n      var q = V[Y], Z = q.size;\n      q.stride === void 0 && (X[q.buffer] === Z * byteSizeMap[q.type] ? q.stride = 0 : q.stride = X[q.buffer]), q.start === void 0 && (q.start = W[q.buffer], W[q.buffer] += Z * byteSizeMap[q.type]);\n    }\n    U = T.createVertexArray(), T.bindVertexArray(U);\n    for (var K = 0; K < z.length; K++) {\n      var J = z[K];\n      N.bind(J), o && J._glBuffers[S].refCount++;\n    }\n    return this.activateVao(t, D), this._activeVao = U, $[D.id] = U, $[B] = U, U;\n  }, r.prototype.disposeGeometry = function(t, e) {\n    var o;\n    if (!!this.managedGeometries[t.id]) {\n      delete this.managedGeometries[t.id];\n      var T = t.glVertexArrayObjects[this.CONTEXT_UID], S = this.gl, N = t.buffers, D = (o = this.renderer) === null || o === void 0 ? void 0 : o.buffer;\n      if (t.disposeRunner.remove(this), !!T) {\n        if (D)\n          for (var B = 0; B < N.length; B++) {\n            var $ = N[B]._glBuffers[this.CONTEXT_UID];\n            $ && ($.refCount--, $.refCount === 0 && !e && D.dispose(N[B], e));\n          }\n        if (!e) {\n          for (var U in T)\n            if (U[0] === \"g\") {\n              var z = T[U];\n              this._activeVao === z && this.unbind(), S.deleteVertexArray(z);\n            }\n        }\n        delete t.glVertexArrayObjects[this.CONTEXT_UID];\n      }\n    }\n  }, r.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedGeometries), o = 0; o < e.length; o++)\n      this.disposeGeometry(this.managedGeometries[e[o]], t);\n  }, r.prototype.activateVao = function(t, e) {\n    var o = this.gl, T = this.CONTEXT_UID, S = this.renderer.buffer, N = t.buffers, D = t.attributes;\n    t.indexBuffer && S.bind(t.indexBuffer);\n    var B = null;\n    for (var $ in D) {\n      var U = D[$], z = N[U.buffer], V = z._glBuffers[T];\n      if (e.attributeData[$]) {\n        B !== V && (S.bind(z), B = V);\n        var X = e.attributeData[$].location;\n        if (o.enableVertexAttribArray(X), o.vertexAttribPointer(X, U.size, U.type || o.FLOAT, U.normalized, U.stride, U.start), U.instance)\n          if (this.hasInstance)\n            o.vertexAttribDivisor(X, 1);\n          else\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n      }\n    }\n  }, r.prototype.draw = function(t, e, o, T) {\n    var S = this.gl, N = this._activeGeometry;\n    if (N.indexBuffer) {\n      var D = N.indexBuffer.data.BYTES_PER_ELEMENT, B = D === 2 ? S.UNSIGNED_SHORT : S.UNSIGNED_INT;\n      D === 2 || D === 4 && this.canUseUInt32ElementIndex ? N.instanced ? S.drawElementsInstanced(t, e || N.indexBuffer.data.length, B, (o || 0) * D, T || 1) : S.drawElements(t, e || N.indexBuffer.data.length, B, (o || 0) * D) : console.warn(\"unsupported index buffer type: uint32\");\n    } else\n      N.instanced ? S.drawArraysInstanced(t, o, e || N.getSize(), T || 1) : S.drawArrays(t, o, e || N.getSize());\n    return this;\n  }, r.prototype.unbind = function() {\n    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), MaskData = function() {\n  function r(t) {\n    t === void 0 && (t = null), this.type = MASK_TYPES$5.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings$1.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n  }\n  return Object.defineProperty(r.prototype, \"filter\", {\n    get: function() {\n      return this._filters ? this._filters[0] : null;\n    },\n    set: function(t) {\n      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.reset = function() {\n    this.pooled && (this.maskObject = null, this.type = MASK_TYPES$5.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n  }, r.prototype.copyCountersOrReset = function(t) {\n    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n  }, r;\n}();\nfunction compileShader(r, t, e) {\n  var o = r.createShader(t);\n  return r.shaderSource(o, e), r.compileShader(o), o;\n}\nfunction logPrettyShaderError(r, t) {\n  var e = r.getShaderSource(t).split(`\n`).map(function($, U) {\n    return U + \": \" + $;\n  }), o = r.getShaderInfoLog(t), T = o.split(`\n`), S = {}, N = T.map(function($) {\n    return parseFloat($.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function($) {\n    return $ && !S[$] ? (S[$] = !0, !0) : !1;\n  }), D = [\"\"];\n  N.forEach(function($) {\n    e[$ - 1] = \"%c\" + e[$ - 1] + \"%c\", D.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var B = e.join(`\n`);\n  D[0] = B, console.error(o), console.groupCollapsed(\"click to view full shader code\"), console.warn.apply(console, D), console.groupEnd();\n}\nfunction logProgramError(r, t, e, o) {\n  r.getProgramParameter(t, r.LINK_STATUS) || (r.getShaderParameter(e, r.COMPILE_STATUS) || logPrettyShaderError(r, e), r.getShaderParameter(o, r.COMPILE_STATUS) || logPrettyShaderError(r, o), console.error(\"PixiJS Error: Could not initialize shader.\"), r.getProgramInfoLog(t) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", r.getProgramInfoLog(t)));\n}\nfunction booleanArray(r) {\n  for (var t = new Array(r), e = 0; e < t.length; e++)\n    t[e] = !1;\n  return t;\n}\nfunction defaultValue(r, t) {\n  switch (r) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * t);\n    case \"vec3\":\n      return new Float32Array(3 * t);\n    case \"vec4\":\n      return new Float32Array(4 * t);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * t);\n    case \"ivec3\":\n      return new Int32Array(3 * t);\n    case \"ivec4\":\n      return new Int32Array(4 * t);\n    case \"uvec2\":\n      return new Uint32Array(2 * t);\n    case \"uvec3\":\n      return new Uint32Array(3 * t);\n    case \"uvec4\":\n      return new Uint32Array(4 * t);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return booleanArray(2 * t);\n    case \"bvec3\":\n      return booleanArray(3 * t);\n    case \"bvec4\":\n      return booleanArray(4 * t);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar unknownContext = {}, context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context && context.isContextLost()) {\n    var r = settings$1.ADAPTER.createCanvas(), t = void 0;\n    settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (t = r.getContext(\"webgl2\", {})), t || (t = r.getContext(\"webgl\", {}) || r.getContext(\"experimental-webgl\", {}), t ? t.getExtension(\"WEBGL_draw_buffers\") : t = null), context = t;\n  }\n  return context;\n}\nvar maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = PRECISION$5.MEDIUM;\n    var r = getTestContext();\n    if (r && r.getShaderPrecisionFormat) {\n      var t = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);\n      maxFragmentPrecision = t.precision ? PRECISION$5.HIGH : PRECISION$5.MEDIUM;\n    }\n  }\n  return maxFragmentPrecision;\n}\nfunction setPrecision(r, t, e) {\n  if (r.substring(0, 9) !== \"precision\") {\n    var o = t;\n    return t === PRECISION$5.HIGH && e !== PRECISION$5.HIGH && (o = PRECISION$5.MEDIUM), \"precision \" + o + ` float;\n` + r;\n  } else if (e !== PRECISION$5.HIGH && r.substring(0, 15) === \"precision highp\")\n    return r.replace(\"precision highp\", \"precision mediump\");\n  return r;\n}\nvar GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(r) {\n  return GLSL_TO_SIZE[r];\n}\nvar GL_TABLE = null, GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction mapType(r, t) {\n  if (!GL_TABLE) {\n    var e = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (var o = 0; o < e.length; ++o) {\n      var T = e[o];\n      GL_TABLE[r[T]] = GL_TO_GLSL_TYPES[T];\n    }\n  }\n  return GL_TABLE[t];\n}\nvar uniformParsers = [\n  {\n    test: function(r) {\n      return r.type === \"float\" && r.size === 1 && !r.isArray;\n    },\n    code: function(r) {\n      return `\n            if(uv[\"` + r + '\"] !== ud[\"' + r + `\"].value)\n            {\n                ud[\"` + r + '\"].value = uv[\"' + r + `\"]\n                gl.uniform1f(ud[\"` + r + '\"].location, uv[\"' + r + `\"])\n            }\n            `;\n    }\n  },\n  {\n    test: function(r, t) {\n      return (r.type === \"sampler2D\" || r.type === \"samplerCube\" || r.type === \"sampler2DArray\") && r.size === 1 && !r.isArray && (t == null || t.castToBaseTexture !== void 0);\n    },\n    code: function(r) {\n      return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"` + r + `\"], t);\n\n            if(ud[\"` + r + `\"].value !== t)\n            {\n                ud[\"` + r + `\"].value = t;\n                gl.uniform1i(ud[\"` + r + `\"].location, t);\n; // eslint-disable-line max-len\n            }`;\n    }\n  },\n  {\n    test: function(r, t) {\n      return r.type === \"mat3\" && r.size === 1 && !r.isArray && t.a !== void 0;\n    },\n    code: function(r) {\n      return `\n            gl.uniformMatrix3fv(ud[\"` + r + '\"].location, false, uv[\"' + r + `\"].toArray(true));\n            `;\n    },\n    codeUbo: function(r) {\n      return `\n                var ` + r + \"_matrix = uv.\" + r + `.toArray(true);\n\n                data[offset] = ` + r + `_matrix[0];\n                data[offset+1] = ` + r + `_matrix[1];\n                data[offset+2] = ` + r + `_matrix[2];\n        \n                data[offset + 4] = ` + r + `_matrix[3];\n                data[offset + 5] = ` + r + `_matrix[4];\n                data[offset + 6] = ` + r + `_matrix[5];\n        \n                data[offset + 8] = ` + r + `_matrix[6];\n                data[offset + 9] = ` + r + `_matrix[7];\n                data[offset + 10] = ` + r + `_matrix[8];\n            `;\n    }\n  },\n  {\n    test: function(r, t) {\n      return r.type === \"vec2\" && r.size === 1 && !r.isArray && t.x !== void 0;\n    },\n    code: function(r) {\n      return `\n                cv = ud[\"` + r + `\"].value;\n                v = uv[\"` + r + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"` + r + `\"].location, v.x, v.y);\n                }`;\n    },\n    codeUbo: function(r) {\n      return `\n                v = uv.` + r + `;\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `;\n    }\n  },\n  {\n    test: function(r) {\n      return r.type === \"vec2\" && r.size === 1 && !r.isArray;\n    },\n    code: function(r) {\n      return `\n                cv = ud[\"` + r + `\"].value;\n                v = uv[\"` + r + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"` + r + `\"].location, v[0], v[1]);\n                }\n            `;\n    }\n  },\n  {\n    test: function(r, t) {\n      return r.type === \"vec4\" && r.size === 1 && !r.isArray && t.width !== void 0;\n    },\n    code: function(r) {\n      return `\n                cv = ud[\"` + r + `\"].value;\n                v = uv[\"` + r + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"` + r + `\"].location, v.x, v.y, v.width, v.height)\n                }`;\n    },\n    codeUbo: function(r) {\n      return `\n                    v = uv.` + r + `;\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `;\n    }\n  },\n  {\n    test: function(r) {\n      return r.type === \"vec4\" && r.size === 1 && !r.isArray;\n    },\n    code: function(r) {\n      return `\n                cv = ud[\"` + r + `\"].value;\n                v = uv[\"` + r + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"` + r + `\"].location, v[0], v[1], v[2], v[3])\n                }`;\n    }\n  }\n], GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(r, t) {\n  var e, o = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (var T in r.uniforms) {\n    var S = t[T];\n    if (!S) {\n      !((e = r.uniforms[T]) === null || e === void 0) && e.group && (r.uniforms[T].ubo ? o.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.` + T + \", '\" + T + `');\n                    `) : o.push(`\n                        renderer.shader.syncUniformGroup(uv.` + T + `, syncData);\n                    `));\n      continue;\n    }\n    for (var N = r.uniforms[T], D = !1, B = 0; B < uniformParsers.length; B++)\n      if (uniformParsers[B].test(S, N)) {\n        o.push(uniformParsers[B].code(T, N)), D = !0;\n        break;\n      }\n    if (!D) {\n      var $ = S.size === 1 && !S.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, U = $[S.type].replace(\"location\", 'ud[\"' + T + '\"].location');\n      o.push(`\n            cu = ud[\"` + T + `\"];\n            cv = cu.value;\n            v = uv[\"` + T + `\"];\n            ` + U + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", o.join(`\n`));\n}\nvar fragTemplate$1 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction generateIfTestSrc(r) {\n  for (var t = \"\", e = 0; e < r; ++e)\n    e > 0 && (t += `\nelse `), e < r - 1 && (t += \"if(test == \" + e + \".0){}\");\n  return t;\n}\nfunction checkMaxIfStatementsInShader(r, t) {\n  if (r === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {\n    var o = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(r));\n    if (t.shaderSource(e, o), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))\n      r = r / 2 | 0;\n    else\n      break;\n  }\n  return r;\n}\nvar unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval == \"boolean\")\n    return unsafeEval;\n  try {\n    var r = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = r({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    unsafeEval = !1;\n  }\n  return unsafeEval;\n}\nvar defaultFragment$2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`, defaultVertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`, UID$1 = 0, nameCache = {}, Program = function() {\n  function r(t, e, o) {\n    o === void 0 && (o = \"pixi-shader\"), this.id = UID$1++, this.vertexSrc = t || r.defaultVertexSrc, this.fragmentSrc = e || r.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== \"#version\" && (o = o.replace(/\\s+/g, \"-\"), nameCache[o] ? (nameCache[o]++, o += \"-\" + nameCache[o]) : nameCache[o] = 1, this.vertexSrc = \"#define SHADER_NAME \" + o + `\n` + this.vertexSrc, this.fragmentSrc = \"#define SHADER_NAME \" + o + `\n` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings$1.PRECISION_VERTEX, PRECISION$5.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings$1.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;\n  }\n  return Object.defineProperty(r, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$3;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.from = function(t, e, o) {\n    var T = t + e, S = ProgramCache[T];\n    return S || (ProgramCache[T] = S = new r(t, e, o)), S;\n  }, r;\n}(), Shader = function() {\n  function r(t, e) {\n    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({});\n  }\n  return r.prototype.checkUniformExists = function(t, e) {\n    if (e.uniforms[t])\n      return !0;\n    for (var o in e.uniforms) {\n      var T = e.uniforms[o];\n      if (T.group && this.checkUniformExists(t, T))\n        return !0;\n    }\n    return !1;\n  }, r.prototype.destroy = function() {\n    this.uniformGroup = null;\n  }, Object.defineProperty(r.prototype, \"uniforms\", {\n    get: function() {\n      return this.uniformGroup.uniforms;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.from = function(t, e, o) {\n    var T = Program.from(t, e);\n    return new r(T, o);\n  }, r;\n}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {\n  function r() {\n    this.data = 0, this.blendMode = BLEND_MODES$5.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n  }\n  return Object.defineProperty(r.prototype, \"blend\", {\n    get: function() {\n      return !!(this.data & 1 << BLEND$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"offsets\", {\n    get: function() {\n      return !!(this.data & 1 << OFFSET$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"culling\", {\n    get: function() {\n      return !!(this.data & 1 << CULLING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"depthTest\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_TEST$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"depthMask\", {\n    get: function() {\n      return !!(this.data & 1 << DEPTH_MASK$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"clockwiseFrontFace\", {\n    get: function() {\n      return !!(this.data & 1 << WINDING$1);\n    },\n    set: function(t) {\n      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"blendMode\", {\n    get: function() {\n      return this._blendMode;\n    },\n    set: function(t) {\n      this.blend = t !== BLEND_MODES$5.NONE, this._blendMode = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"polygonOffset\", {\n    get: function() {\n      return this._polygonOffset;\n    },\n    set: function(t) {\n      this.offsets = !!t, this._polygonOffset = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.toString = function() {\n    return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n  }, r.for2d = function() {\n    var t = new r();\n    return t.depthTest = !1, t.blend = !0, t;\n  }, r;\n}(), defaultFragment$1 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`, defaultVertex$2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, Filter = function(r) {\n  __extends$p(t, r);\n  function t(e, o, T) {\n    var S = this, N = Program.from(e || t.defaultVertexSrc, o || t.defaultFragmentSrc);\n    return S = r.call(this, N, T) || this, S.padding = 0, S.resolution = settings$1.FILTER_RESOLUTION, S.multisample = settings$1.FILTER_MULTISAMPLE, S.enabled = !0, S.autoFit = !0, S.state = new State(), S;\n  }\n  return t.prototype.apply = function(e, o, T, S, N) {\n    e.applyFilter(this, o, T, S);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._resolution = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex$2;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t, \"defaultFragmentSrc\", {\n    get: function() {\n      return defaultFragment$1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Shader), vertex$4 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`, fragment$7 = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`, tempMat$1 = new Matrix(), TextureMatrix = function() {\n  function r(t, e) {\n    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > \"u\" ? 0.5 : e, this.isSimple = !1;\n  }\n  return Object.defineProperty(r.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(t) {\n      this._texture = t, this._textureID = -1;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.multiplyUvs = function(t, e) {\n    e === void 0 && (e = t);\n    for (var o = this.mapCoord, T = 0; T < t.length; T += 2) {\n      var S = t[T], N = t[T + 1];\n      e[T] = S * o.a + N * o.c + o.tx, e[T + 1] = S * o.b + N * o.d + o.ty;\n    }\n    return e;\n  }, r.prototype.update = function(t) {\n    var e = this._texture;\n    if (!e || !e.valid || !t && this._textureID === e._updateID)\n      return !1;\n    this._textureID = e._updateID, this._updateID++;\n    var o = e._uvs;\n    this.mapCoord.set(o.x1 - o.x0, o.y1 - o.y0, o.x3 - o.x0, o.y3 - o.y0, o.x0, o.y0);\n    var T = e.orig, S = e.trim;\n    S && (tempMat$1.set(T.width / S.width, 0, 0, T.height / S.height, -S.x / S.width, -S.y / S.height), this.mapCoord.append(tempMat$1));\n    var N = e.baseTexture, D = this.uClampFrame, B = this.clampMargin / N.resolution, $ = this.clampOffset;\n    return D[0] = (e._frame.x + B + $) / N.width, D[1] = (e._frame.y + B + $) / N.height, D[2] = (e._frame.x + e._frame.width - B + $) / N.width, D[3] = (e._frame.y + e._frame.height - B + $) / N.height, this.uClampOffset[0] = $ / N.realWidth, this.uClampOffset[1] = $ / N.realHeight, this.isSimple = e._frame.width === N.width && e._frame.height === N.height && e.rotate === 0, !0;\n  }, r;\n}(), SpriteMaskFilter = function(r) {\n  __extends$p(t, r);\n  function t(e, o, T) {\n    var S = this, N = null;\n    return typeof e != \"string\" && o === void 0 && T === void 0 && (N = e, e = void 0, o = void 0, T = void 0), S = r.call(this, e || vertex$4, o || fragment$7, T) || this, S.maskSprite = N, S.maskMatrix = new Matrix(), S;\n  }\n  return Object.defineProperty(t.prototype, \"maskSprite\", {\n    get: function() {\n      return this._maskSprite;\n    },\n    set: function(e) {\n      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.apply = function(e, o, T, S) {\n    var N = this._maskSprite, D = N._texture;\n    !D.valid || (D.uvMatrix || (D.uvMatrix = new TextureMatrix(D, 0)), D.uvMatrix.update(), this.uniforms.npmAlpha = D.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = D, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, N).prepend(D.uvMatrix.mapCoord), this.uniforms.alpha = N.worldAlpha, this.uniforms.maskClamp = D.uvMatrix.uClampFrame, e.applyFilter(this, o, T, S));\n  }, t;\n}(Filter), MaskSystem = function() {\n  function r(t) {\n    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n  }\n  return r.prototype.setMaskStack = function(t) {\n    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);\n  }, r.prototype.push = function(t, e) {\n    var o = e;\n    if (!o.isMaskData) {\n      var T = this.maskDataPool.pop() || new MaskData();\n      T.pooled = !0, T.maskObject = e, o = T;\n    }\n    var S = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    if (o.copyCountersOrReset(S), o._colorMask = S ? S._colorMask : 15, o.autoDetect && this.detect(o), o._target = t, o.type !== MASK_TYPES$5.SPRITE && this.maskStack.push(o), o.enabled)\n      switch (o.type) {\n        case MASK_TYPES$5.SCISSOR:\n          this.renderer.scissor.push(o);\n          break;\n        case MASK_TYPES$5.STENCIL:\n          this.renderer.stencil.push(o);\n          break;\n        case MASK_TYPES$5.SPRITE:\n          o.copyCountersOrReset(null), this.pushSpriteMask(o);\n          break;\n        case MASK_TYPES$5.COLOR:\n          this.pushColorMask(o);\n          break;\n      }\n    o.type === MASK_TYPES$5.SPRITE && this.maskStack.push(o);\n  }, r.prototype.pop = function(t) {\n    var e = this.maskStack.pop();\n    if (!(!e || e._target !== t)) {\n      if (e.enabled)\n        switch (e.type) {\n          case MASK_TYPES$5.SCISSOR:\n            this.renderer.scissor.pop(e);\n            break;\n          case MASK_TYPES$5.STENCIL:\n            this.renderer.stencil.pop(e.maskObject);\n            break;\n          case MASK_TYPES$5.SPRITE:\n            this.popSpriteMask(e);\n            break;\n          case MASK_TYPES$5.COLOR:\n            this.popColorMask(e);\n            break;\n        }\n      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {\n        var o = this.maskStack[this.maskStack.length - 1];\n        o.type === MASK_TYPES$5.SPRITE && o._filters && (o._filters[0].maskSprite = o.maskObject);\n      }\n    }\n  }, r.prototype.detect = function(t) {\n    var e = t.maskObject;\n    e ? e.isSprite ? t.type = MASK_TYPES$5.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES$5.SCISSOR : t.type = MASK_TYPES$5.STENCIL : t.type = MASK_TYPES$5.COLOR;\n  }, r.prototype.pushSpriteMask = function(t) {\n    var e, o, T = t.maskObject, S = t._target, N = t._filters;\n    N || (N = this.alphaMaskPool[this.alphaMaskIndex], N || (N = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));\n    var D = this.renderer, B = D.renderTexture, $, U;\n    if (B.current) {\n      var z = B.current;\n      $ = t.resolution || z.resolution, U = (e = t.multisample) !== null && e !== void 0 ? e : z.multisample;\n    } else\n      $ = t.resolution || D.resolution, U = (o = t.multisample) !== null && o !== void 0 ? o : D.multisample;\n    N[0].resolution = $, N[0].multisample = U, N[0].maskSprite = T;\n    var V = S.filterArea;\n    S.filterArea = T.getBounds(!0), D.filter.push(S, N), S.filterArea = V, t._filters || this.alphaMaskIndex++;\n  }, r.prototype.popSpriteMask = function(t) {\n    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n  }, r.prototype.pushColorMask = function(t) {\n    var e = t._colorMask, o = t._colorMask = e & t.colorMask;\n    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);\n  }, r.prototype.popColorMask = function(t) {\n    var e = t._colorMask, o = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), AbstractMaskSystem = function() {\n  function r(t) {\n    this.renderer = t, this.maskStack = [], this.glConst = 0;\n  }\n  return r.prototype.getStackLength = function() {\n    return this.maskStack.length;\n  }, r.prototype.setMaskStack = function(t) {\n    var e = this.renderer.gl, o = this.getStackLength();\n    this.maskStack = t;\n    var T = this.getStackLength();\n    T !== o && (T === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));\n  }, r.prototype._useCurrent = function() {\n  }, r.prototype.destroy = function() {\n    this.renderer = null, this.maskStack = null;\n  }, r;\n}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, o;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._scissorCounter : 0;\n  }, t.prototype.calcScissorRect = function(e) {\n    var o;\n    if (!e._scissorRectLocal) {\n      var T = e._scissorRect, S = e.maskObject, N = this.renderer, D = N.renderTexture, B = S.getBounds(!0, (o = rectPool.pop()) !== null && o !== void 0 ? o : new Rectangle());\n      this.roundFrameToPixels(B, D.current ? D.current.resolution : N.resolution, D.sourceFrame, D.destinationFrame, N.projection.transform), T && B.fit(T), e._scissorRectLocal = B;\n    }\n  }, t.isMatrixRotated = function(e) {\n    if (!e)\n      return !1;\n    var o = e.a, T = e.b, S = e.c, N = e.d;\n    return (Math.abs(T) > 1e-4 || Math.abs(S) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(N) > 1e-4);\n  }, t.prototype.testScissor = function(e) {\n    var o = e.maskObject;\n    if (!o.isFastRect || !o.isFastRect() || t.isMatrixRotated(o.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))\n      return !1;\n    this.calcScissorRect(e);\n    var T = e._scissorRectLocal;\n    return T.width > 0 && T.height > 0;\n  }, t.prototype.roundFrameToPixels = function(e, o, T, S, N) {\n    t.isMatrixRotated(N) || (N = N ? tempMatrix$1.copyFrom(N) : tempMatrix$1.identity(), N.translate(-T.x, -T.y).scale(S.width / T.width, S.height / T.height).translate(S.x, S.y), this.renderer.filter.transformAABB(N, e), e.fit(S), e.x = Math.round(e.x * o), e.y = Math.round(e.y * o), e.width = Math.round(e.width * o), e.height = Math.round(e.height * o));\n  }, t.prototype.push = function(e) {\n    e._scissorRectLocal || this.calcScissorRect(e);\n    var o = this.renderer.gl;\n    e._scissorRect || o.enable(o.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var o = this.renderer.gl;\n    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : o.disable(o.SCISSOR_TEST);\n  }, t.prototype._useCurrent = function() {\n    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, o;\n    this.renderer.renderTexture.current ? o = e.y : o = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, o, e.width, e.height);\n  }, t;\n}(AbstractMaskSystem), StencilSystem = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, o;\n  }\n  return t.prototype.getStackLength = function() {\n    var e = this.maskStack[this.maskStack.length - 1];\n    return e ? e._stencilCounter : 0;\n  }, t.prototype.push = function(e) {\n    var o = e.maskObject, T = this.renderer.gl, S = e._stencilCounter;\n    S === 0 && (this.renderer.framebuffer.forceStencil(), T.clearStencil(0), T.clear(T.STENCIL_BUFFER_BIT), T.enable(T.STENCIL_TEST)), e._stencilCounter++;\n    var N = e._colorMask;\n    N !== 0 && (e._colorMask = 0, T.colorMask(!1, !1, !1, !1)), T.stencilFunc(T.EQUAL, S, 4294967295), T.stencilOp(T.KEEP, T.KEEP, T.INCR), o.renderable = !0, o.render(this.renderer), this.renderer.batch.flush(), o.renderable = !1, N !== 0 && (e._colorMask = N, T.colorMask((N & 1) !== 0, (N & 2) !== 0, (N & 4) !== 0, (N & 8) !== 0)), this._useCurrent();\n  }, t.prototype.pop = function(e) {\n    var o = this.renderer.gl;\n    if (this.getStackLength() === 0)\n      o.disable(o.STENCIL_TEST);\n    else {\n      var T = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, S = T ? T._colorMask : 15;\n      S !== 0 && (T._colorMask = 0, o.colorMask(!1, !1, !1, !1)), o.stencilOp(o.KEEP, o.KEEP, o.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, S !== 0 && (T._colorMask = S, o.colorMask((S & 1) !== 0, (S & 2) !== 0, (S & 4) !== 0, (S & 8) !== 0)), this._useCurrent();\n    }\n  }, t.prototype._useCurrent = function() {\n    var e = this.renderer.gl;\n    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);\n  }, t;\n}(AbstractMaskSystem), ProjectionSystem = function() {\n  function r(t) {\n    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;\n  }\n  return r.prototype.update = function(t, e, o, T) {\n    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, o, T), this.transform && this.projectionMatrix.append(this.transform);\n    var S = this.renderer;\n    S.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, S.globalUniforms.update(), S.shader.shader && S.shader.syncUniformGroup(S.shader.shader.uniforms.globals);\n  }, r.prototype.calculateProjection = function(t, e, o, T) {\n    var S = this.projectionMatrix, N = T ? -1 : 1;\n    S.identity(), S.a = 1 / e.width * 2, S.d = N * (1 / e.height * 2), S.tx = -1 - e.x * S.a, S.ty = -N - e.y * S.d;\n  }, r.prototype.setTransform = function(t) {\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {\n  function r(t) {\n    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();\n  }\n  return r.prototype.bind = function(t, e, o) {\n    t === void 0 && (t = null);\n    var T = this.renderer;\n    this.current = t;\n    var S, N, D;\n    t ? (S = t.baseTexture, D = S.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), o || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, o = tempRect2), N = S.framebuffer) : (D = T.resolution, e || (tempRect.width = T.screen.width, tempRect.height = T.screen.height, e = tempRect), o || (o = tempRect, o.width = e.width, o.height = e.height));\n    var B = this.viewportFrame;\n    B.x = o.x * D, B.y = o.y * D, B.width = o.width * D, B.height = o.height * D, t || (B.y = T.view.height - (B.y + B.height)), B.ceil(), this.renderer.framebuffer.bind(N, B), this.renderer.projection.update(o, e, D, !N), t ? this.renderer.mask.setMaskStack(S.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(o);\n  }, r.prototype.clear = function(t, e) {\n    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;\n    var o = this.destinationFrame, T = this.current ? this.current.baseTexture : this.renderer.screen, S = o.width !== T.width || o.height !== T.height;\n    if (S) {\n      var N = this.viewportFrame, D = N.x, B = N.y, $ = N.width, U = N.height;\n      D = Math.round(D), B = Math.round(B), $ = Math.round($), U = Math.round(U), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(D, B, $, U);\n    }\n    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), S && this.renderer.scissor.pop();\n  }, r.prototype.resize = function() {\n    this.bind(null);\n  }, r.prototype.reset = function() {\n    this.bind(null);\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}();\nfunction uboUpdate(r, t, e, o, T) {\n  e.buffer.update(T);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(r) {\n  for (var t = r.map(function(B) {\n    return {\n      data: B,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  }), e = 0, o = 0, T = 0, S = 0; S < t.length; S++) {\n    var N = t[S];\n    if (e = GLSL_TO_STD40_SIZE[N.data.type], N.data.size > 1 && (e = Math.max(e, 16) * N.data.size), N.dataLen = e, o % e !== 0 && o < 16) {\n      var D = o % e % 16;\n      o += D, T += D;\n    }\n    o + e > 16 ? (T = Math.ceil(T / 16) * 16, N.offset = T, T += e, o = e) : (N.offset = T, o += e, T += e);\n  }\n  return T = Math.ceil(T / 16) * 16, { uboElements: t, size: T };\n}\nfunction getUBOData(r, t) {\n  var e = [];\n  for (var o in r)\n    t[o] && e.push(t[o]);\n  return e.sort(function(T, S) {\n    return T.index - S.index;\n  }), e;\n}\nfunction generateUniformBufferSync(r, t) {\n  if (!r.autoManage)\n    return { size: 0, syncFunc: uboUpdate };\n  for (var e = getUBOData(r.uniforms, t), o = createUBOElements(e), T = o.uboElements, S = o.size, N = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `], D = 0; D < T.length; D++) {\n    for (var B = T[D], $ = r.uniforms[B.data.name], U = B.data.name, z = !1, V = 0; V < uniformParsers.length; V++) {\n      var X = uniformParsers[V];\n      if (X.codeUbo && X.test(B.data, $)) {\n        N.push(\"offset = \" + B.offset / 4 + \";\", uniformParsers[V].codeUbo(B.data.name, $)), z = !0;\n        break;\n      }\n    }\n    if (!z)\n      if (B.data.size > 1) {\n        var W = mapSize(B.data.type), Y = Math.max(GLSL_TO_STD40_SIZE[B.data.type] / 16, 1), q = W / Y, Z = (4 - q % 4) % 4;\n        N.push(`\n                cv = ud.` + U + `.value;\n                v = uv.` + U + `;\n                offset = ` + B.offset / 4 + `;\n\n                t = 0;\n\n                for(var i=0; i < ` + B.data.size * Y + `; i++)\n                {\n                    for(var j = 0; j < ` + q + `; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ` + Z + `;\n                }\n\n                `);\n      } else {\n        var K = UBO_TO_SINGLE_SETTERS[B.data.type];\n        N.push(`\n                cv = ud.` + U + `.value;\n                v = uv.` + U + `;\n                offset = ` + B.offset / 4 + `;\n                ` + K + `;\n                `);\n      }\n  }\n  return N.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size: S,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", N.join(`\n`))\n  };\n}\nvar IGLUniformData = function() {\n  function r() {\n  }\n  return r;\n}(), GLProgram = function() {\n  function r(t, e) {\n    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n  }\n  return r.prototype.destroy = function() {\n    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n  }, r;\n}();\nfunction getAttributeData(r, t) {\n  for (var e = {}, o = t.getProgramParameter(r, t.ACTIVE_ATTRIBUTES), T = 0; T < o; T++) {\n    var S = t.getActiveAttrib(r, T);\n    if (S.name.indexOf(\"gl_\") !== 0) {\n      var N = mapType(t, S.type), D = {\n        type: N,\n        name: S.name,\n        size: mapSize(N),\n        location: t.getAttribLocation(r, S.name)\n      };\n      e[S.name] = D;\n    }\n  }\n  return e;\n}\nfunction getUniformData(r, t) {\n  for (var e = {}, o = t.getProgramParameter(r, t.ACTIVE_UNIFORMS), T = 0; T < o; T++) {\n    var S = t.getActiveUniform(r, T), N = S.name.replace(/\\[.*?\\]$/, \"\"), D = !!S.name.match(/\\[.*?\\]$/), B = mapType(t, S.type);\n    e[N] = {\n      name: N,\n      index: T,\n      type: B,\n      size: S.size,\n      isArray: D,\n      value: defaultValue(B, S.size)\n    };\n  }\n  return e;\n}\nfunction generateProgram(r, t) {\n  var e = compileShader(r, r.VERTEX_SHADER, t.vertexSrc), o = compileShader(r, r.FRAGMENT_SHADER, t.fragmentSrc), T = r.createProgram();\n  if (r.attachShader(T, e), r.attachShader(T, o), r.linkProgram(T), r.getProgramParameter(T, r.LINK_STATUS) || logProgramError(r, T, e, o), t.attributeData = getAttributeData(T, r), t.uniformData = getUniformData(T, r), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(t.vertexSrc)) {\n    var S = Object.keys(t.attributeData);\n    S.sort(function(U, z) {\n      return U > z ? 1 : -1;\n    });\n    for (var N = 0; N < S.length; N++)\n      t.attributeData[S[N]].location = N, r.bindAttribLocation(T, N, S[N]);\n    r.linkProgram(T);\n  }\n  r.deleteShader(e), r.deleteShader(o);\n  var D = {};\n  for (var N in t.uniformData) {\n    var B = t.uniformData[N];\n    D[N] = {\n      location: r.getUniformLocation(T, N),\n      value: defaultValue(B.type, B.size)\n    };\n  }\n  var $ = new GLProgram(T, D);\n  return $;\n}\nvar UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {\n  function r(t) {\n    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;\n  }\n  return r.prototype.systemCheck = function() {\n    if (!unsafeEvalSupported())\n      throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n  }, r.prototype.contextChange = function(t) {\n    this.gl = t, this.reset();\n  }, r.prototype.bind = function(t, e) {\n    t.uniforms.globals = this.renderer.globalUniforms;\n    var o = t.program, T = o.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);\n    return this.shader = t, this.program !== o && (this.program = o, this.gl.useProgram(T.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), T;\n  }, r.prototype.setUniforms = function(t) {\n    var e = this.shader.program, o = e.glPrograms[this.renderer.CONTEXT_UID];\n    e.syncUniforms(o.uniformData, t, this.renderer);\n  }, r.prototype.syncUniformGroup = function(t, e) {\n    var o = this.getGlProgram();\n    (!t.static || t.dirtyId !== o.uniformDirtyGroups[t.id]) && (o.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, o, e));\n  }, r.prototype.syncUniforms = function(t, e, o) {\n    var T = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);\n    T(e.uniformData, t.uniforms, this.renderer, o);\n  }, r.prototype.createSyncGroups = function(t) {\n    var e = this.getSignature(t, this.shader.program.uniformData, \"u\");\n    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];\n  }, r.prototype.syncUniformBufferGroup = function(t, e) {\n    var o = this.getGlProgram();\n    if (!t.static || t.dirtyId !== 0 || !o.uniformGroups[t.id]) {\n      t.dirtyId = 0;\n      var T = o.uniformGroups[t.id] || this.createSyncBufferGroup(t, o, e);\n      t.buffer.update(), T(o.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(t.buffer, o.uniformBufferBindings[e]);\n  }, r.prototype.createSyncBufferGroup = function(t, e, o) {\n    var T = this.renderer.gl;\n    this.renderer.buffer.bind(t.buffer);\n    var S = this.gl.getUniformBlockIndex(e.program, o);\n    e.uniformBufferBindings[o] = this.shader.uniformBindCount, T.uniformBlockBinding(e.program, S, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n    var N = this.getSignature(t, this.shader.program.uniformData, \"ubo\"), D = this._uboCache[N];\n    if (D || (D = this._uboCache[N] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {\n      var B = new Float32Array(D.size / 4);\n      t.buffer.update(B);\n    }\n    return e.uniformGroups[t.id] = D.syncFunc, e.uniformGroups[t.id];\n  }, r.prototype.getSignature = function(t, e, o) {\n    var T = t.uniforms, S = [o + \"-\"];\n    for (var N in T)\n      S.push(N), e[N] && S.push(e[N].type);\n    return S.join(\"-\");\n  }, r.prototype.getGlProgram = function() {\n    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n  }, r.prototype.generateProgram = function(t) {\n    var e = this.gl, o = t.program, T = generateProgram(e, o);\n    return o.glPrograms[this.renderer.CONTEXT_UID] = T, T;\n  }, r.prototype.reset = function() {\n    this.program = null, this.shader = null;\n  }, r.prototype.destroy = function() {\n    this.renderer = null, this.destroyed = !0;\n  }, r;\n}();\nfunction mapWebGLBlendModesToPixi(r, t) {\n  return t === void 0 && (t = []), t[BLEND_MODES$5.NORMAL] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD] = [r.ONE, r.ONE], t[BLEND_MODES$5.MULTIPLY] = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SCREEN] = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.OVERLAY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DARKEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LIGHTEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_DODGE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_BURN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HARD_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SOFT_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DIFFERENCE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.EXCLUSION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HUE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SATURATION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LUMINOSITY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.NONE] = [0, 0], t[BLEND_MODES$5.NORMAL_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD_NPM] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE], t[BLEND_MODES$5.SCREEN_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SRC_IN] = [r.DST_ALPHA, r.ZERO], t[BLEND_MODES$5.SRC_OUT] = [r.ONE_MINUS_DST_ALPHA, r.ZERO], t[BLEND_MODES$5.SRC_ATOP] = [r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_OVER] = [r.ONE_MINUS_DST_ALPHA, r.ONE], t[BLEND_MODES$5.DST_IN] = [r.ZERO, r.SRC_ALPHA], t[BLEND_MODES$5.DST_OUT] = [r.ZERO, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_ATOP] = [r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA], t[BLEND_MODES$5.XOR] = [r.ONE_MINUS_DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SUBTRACT] = [r.ONE, r.ONE, r.ONE, r.ONE, r.FUNC_REVERSE_SUBTRACT, r.FUNC_ADD], t;\n}\nvar BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {\n  function r() {\n    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES$5.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;\n  }\n  return r.prototype.contextChange = function(t) {\n    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();\n  }, r.prototype.set = function(t) {\n    if (t = t || this.defaultState, this.stateId !== t.data) {\n      for (var e = this.stateId ^ t.data, o = 0; e; )\n        e & 1 && this.map[o].call(this, !!(t.data & 1 << o)), e = e >> 1, o++;\n      this.stateId = t.data;\n    }\n    for (var o = 0; o < this.checks.length; o++)\n      this.checks[o](this, t);\n  }, r.prototype.forceState = function(t) {\n    t = t || this.defaultState;\n    for (var e = 0; e < this.map.length; e++)\n      this.map[e].call(this, !!(t.data & 1 << e));\n    for (var e = 0; e < this.checks.length; e++)\n      this.checks[e](this, t);\n    this.stateId = t.data;\n  }, r.prototype.setBlend = function(t) {\n    this.updateCheck(r.checkBlendMode, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }, r.prototype.setOffset = function(t) {\n    this.updateCheck(r.checkPolygonOffset, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }, r.prototype.setDepthTest = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }, r.prototype.setDepthMask = function(t) {\n    this.gl.depthMask(t);\n  }, r.prototype.setCullFace = function(t) {\n    this.gl[t ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }, r.prototype.setFrontFace = function(t) {\n    this.gl.frontFace(this.gl[t ? \"CW\" : \"CCW\"]);\n  }, r.prototype.setBlendMode = function(t) {\n    if (t !== this.blendMode) {\n      this.blendMode = t;\n      var e = this.blendModes[t], o = this.gl;\n      e.length === 2 ? o.blendFunc(e[0], e[1]) : o.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, o.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, o.blendEquationSeparate(o.FUNC_ADD, o.FUNC_ADD));\n    }\n  }, r.prototype.setPolygonOffset = function(t, e) {\n    this.gl.polygonOffset(t, e);\n  }, r.prototype.reset = function() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n  }, r.prototype.updateCheck = function(t, e) {\n    var o = this.checks.indexOf(t);\n    e && o === -1 ? this.checks.push(t) : !e && o !== -1 && this.checks.splice(o, 1);\n  }, r.checkBlendMode = function(t, e) {\n    t.setBlendMode(e.blendMode);\n  }, r.checkPolygonOffset = function(t, e) {\n    t.setPolygonOffset(1, e.polygonOffset);\n  }, r.prototype.destroy = function() {\n    this.gl = null;\n  }, r;\n}(), TextureGCSystem = function() {\n  function r(t) {\n    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings$1.GC_MAX_IDLE, this.checkCountMax = settings$1.GC_MAX_CHECK_COUNT, this.mode = settings$1.GC_MODE;\n  }\n  return r.prototype.postrender = function() {\n    !this.renderer.renderingToScreen || (this.count++, this.mode !== GC_MODES$5.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n  }, r.prototype.run = function() {\n    for (var t = this.renderer.texture, e = t.managedTextures, o = !1, T = 0; T < e.length; T++) {\n      var S = e[T];\n      !S.framebuffer && this.count - S.touched > this.maxIdle && (t.destroyTexture(S, !0), e[T] = null, o = !0);\n    }\n    if (o) {\n      for (var N = 0, T = 0; T < e.length; T++)\n        e[T] !== null && (e[N++] = e[T]);\n      e.length = N;\n    }\n  }, r.prototype.unload = function(t) {\n    var e = this.renderer.texture, o = t._texture;\n    o && !o.framebuffer && e.destroyTexture(o);\n    for (var T = t.children.length - 1; T >= 0; T--)\n      this.unload(t.children[T]);\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}();\nfunction mapTypeAndFormatToInternalFormat(r) {\n  var t, e, o, T, S, N, D, B, $, U, z, V, X, W, Y, q, Z, K, J, tt, et, Q, at;\n  return \"WebGL2RenderingContext\" in globalThis && r instanceof globalThis.WebGL2RenderingContext ? at = (t = {}, t[TYPES$5.UNSIGNED_BYTE] = (e = {}, e[FORMATS$5.RGBA] = r.RGBA8, e[FORMATS$5.RGB] = r.RGB8, e[FORMATS$5.RG] = r.RG8, e[FORMATS$5.RED] = r.R8, e[FORMATS$5.RGBA_INTEGER] = r.RGBA8UI, e[FORMATS$5.RGB_INTEGER] = r.RGB8UI, e[FORMATS$5.RG_INTEGER] = r.RG8UI, e[FORMATS$5.RED_INTEGER] = r.R8UI, e[FORMATS$5.ALPHA] = r.ALPHA, e[FORMATS$5.LUMINANCE] = r.LUMINANCE, e[FORMATS$5.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, e), t[TYPES$5.BYTE] = (o = {}, o[FORMATS$5.RGBA] = r.RGBA8_SNORM, o[FORMATS$5.RGB] = r.RGB8_SNORM, o[FORMATS$5.RG] = r.RG8_SNORM, o[FORMATS$5.RED] = r.R8_SNORM, o[FORMATS$5.RGBA_INTEGER] = r.RGBA8I, o[FORMATS$5.RGB_INTEGER] = r.RGB8I, o[FORMATS$5.RG_INTEGER] = r.RG8I, o[FORMATS$5.RED_INTEGER] = r.R8I, o), t[TYPES$5.UNSIGNED_SHORT] = (T = {}, T[FORMATS$5.RGBA_INTEGER] = r.RGBA16UI, T[FORMATS$5.RGB_INTEGER] = r.RGB16UI, T[FORMATS$5.RG_INTEGER] = r.RG16UI, T[FORMATS$5.RED_INTEGER] = r.R16UI, T[FORMATS$5.DEPTH_COMPONENT] = r.DEPTH_COMPONENT16, T), t[TYPES$5.SHORT] = (S = {}, S[FORMATS$5.RGBA_INTEGER] = r.RGBA16I, S[FORMATS$5.RGB_INTEGER] = r.RGB16I, S[FORMATS$5.RG_INTEGER] = r.RG16I, S[FORMATS$5.RED_INTEGER] = r.R16I, S), t[TYPES$5.UNSIGNED_INT] = (N = {}, N[FORMATS$5.RGBA_INTEGER] = r.RGBA32UI, N[FORMATS$5.RGB_INTEGER] = r.RGB32UI, N[FORMATS$5.RG_INTEGER] = r.RG32UI, N[FORMATS$5.RED_INTEGER] = r.R32UI, N[FORMATS$5.DEPTH_COMPONENT] = r.DEPTH_COMPONENT24, N), t[TYPES$5.INT] = (D = {}, D[FORMATS$5.RGBA_INTEGER] = r.RGBA32I, D[FORMATS$5.RGB_INTEGER] = r.RGB32I, D[FORMATS$5.RG_INTEGER] = r.RG32I, D[FORMATS$5.RED_INTEGER] = r.R32I, D), t[TYPES$5.FLOAT] = (B = {}, B[FORMATS$5.RGBA] = r.RGBA32F, B[FORMATS$5.RGB] = r.RGB32F, B[FORMATS$5.RG] = r.RG32F, B[FORMATS$5.RED] = r.R32F, B[FORMATS$5.DEPTH_COMPONENT] = r.DEPTH_COMPONENT32F, B), t[TYPES$5.HALF_FLOAT] = ($ = {}, $[FORMATS$5.RGBA] = r.RGBA16F, $[FORMATS$5.RGB] = r.RGB16F, $[FORMATS$5.RG] = r.RG16F, $[FORMATS$5.RED] = r.R16F, $), t[TYPES$5.UNSIGNED_SHORT_5_6_5] = (U = {}, U[FORMATS$5.RGB] = r.RGB565, U), t[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (z = {}, z[FORMATS$5.RGBA] = r.RGBA4, z), t[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (V = {}, V[FORMATS$5.RGBA] = r.RGB5_A1, V), t[TYPES$5.UNSIGNED_INT_2_10_10_10_REV] = (X = {}, X[FORMATS$5.RGBA] = r.RGB10_A2, X[FORMATS$5.RGBA_INTEGER] = r.RGB10_A2UI, X), t[TYPES$5.UNSIGNED_INT_10F_11F_11F_REV] = (W = {}, W[FORMATS$5.RGB] = r.R11F_G11F_B10F, W), t[TYPES$5.UNSIGNED_INT_5_9_9_9_REV] = (Y = {}, Y[FORMATS$5.RGB] = r.RGB9_E5, Y), t[TYPES$5.UNSIGNED_INT_24_8] = (q = {}, q[FORMATS$5.DEPTH_STENCIL] = r.DEPTH24_STENCIL8, q), t[TYPES$5.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Z = {}, Z[FORMATS$5.DEPTH_STENCIL] = r.DEPTH32F_STENCIL8, Z), t) : at = (K = {}, K[TYPES$5.UNSIGNED_BYTE] = (J = {}, J[FORMATS$5.RGBA] = r.RGBA, J[FORMATS$5.RGB] = r.RGB, J[FORMATS$5.ALPHA] = r.ALPHA, J[FORMATS$5.LUMINANCE] = r.LUMINANCE, J[FORMATS$5.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, J), K[TYPES$5.UNSIGNED_SHORT_5_6_5] = (tt = {}, tt[FORMATS$5.RGB] = r.RGB, tt), K[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (et = {}, et[FORMATS$5.RGBA] = r.RGBA, et), K[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (Q = {}, Q[FORMATS$5.RGBA] = r.RGBA, Q), K), at;\n}\nvar GLTexture = function() {\n  function r(t) {\n    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES$5.UNSIGNED_BYTE, this.internalFormat = FORMATS$5.RGBA, this.samplerType = 0;\n  }\n  return r;\n}(), TextureSystem = function() {\n  function r(t) {\n    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;\n  }\n  return r.prototype.contextChange = function() {\n    var t = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);\n    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = e;\n    for (var o = 0; o < e; o++)\n      this.boundTextures[o] = null;\n    this.emptyTextures = {};\n    var T = new GLTexture(t.createTexture());\n    t.bindTexture(t.TEXTURE_2D, T.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = T, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);\n    for (var o = 0; o < 6; o++)\n      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);\n    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);\n    for (var o = 0; o < this.boundTextures.length; o++)\n      this.bind(null, o);\n  }, r.prototype.bind = function(t, e) {\n    e === void 0 && (e = 0);\n    var o = this.gl;\n    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {\n      t.touched = this.renderer.textureGC.count;\n      var T = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);\n      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(t.target, T.texture)), T.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), this.updateTexture(t)) : T.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;\n    } else\n      this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(o.TEXTURE_2D, this.emptyTextures[o.TEXTURE_2D].texture), this.boundTextures[e] = null;\n  }, r.prototype.reset = function() {\n    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n    for (var t = 0; t < this.boundTextures.length; t++)\n      this.boundTextures[t] = this.unknownTexture;\n  }, r.prototype.unbind = function(t) {\n    var e = this, o = e.gl, T = e.boundTextures;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = !1;\n      for (var S = 0; S < T.length; S++)\n        T[S] === this.unknownTexture && this.bind(null, S);\n    }\n    for (var S = 0; S < T.length; S++)\n      T[S] === t && (this.currentLocation !== S && (o.activeTexture(o.TEXTURE0 + S), this.currentLocation = S), o.bindTexture(t.target, this.emptyTextures[t.target].texture), T[S] = null);\n  }, r.prototype.ensureSamplerType = function(t) {\n    var e = this, o = e.boundTextures, T = e.hasIntegerTextures, S = e.CONTEXT_UID;\n    if (!!T)\n      for (var N = t - 1; N >= 0; --N) {\n        var D = o[N];\n        if (D) {\n          var B = D._glTextures[S];\n          B.samplerType !== SAMPLER_TYPES$5.FLOAT && this.renderer.texture.unbind(D);\n        }\n      }\n  }, r.prototype.initTexture = function(t) {\n    var e = new GLTexture(this.gl.createTexture());\n    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on(\"dispose\", this.destroyTexture, this), e;\n  }, r.prototype.initTextureType = function(t, e) {\n    var o, T;\n    e.internalFormat = (T = (o = this.internalFormats[t.type]) === null || o === void 0 ? void 0 : o[t.format]) !== null && T !== void 0 ? T : t.format, this.webGLVersion === 2 && t.type === TYPES$5.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;\n  }, r.prototype.updateTexture = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    if (!!e) {\n      var o = this.renderer;\n      if (this.initTextureType(t, e), t.resource && t.resource.upload(o, t, e))\n        e.samplerType !== SAMPLER_TYPES$5.FLOAT && (this.hasIntegerTextures = !0);\n      else {\n        var T = t.realWidth, S = t.realHeight, N = o.gl;\n        (e.width !== T || e.height !== S || e.dirtyId < 0) && (e.width = T, e.height = S, N.texImage2D(t.target, 0, e.internalFormat, T, S, 0, t.format, e.type, null));\n      }\n      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;\n    }\n  }, r.prototype.destroyTexture = function(t, e) {\n    var o = this.gl;\n    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), o.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off(\"dispose\", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {\n      var T = this.managedTextures.indexOf(t);\n      T !== -1 && removeItems(this.managedTextures, T, 1);\n    }\n  }, r.prototype.updateTextureStyle = function(t) {\n    var e = t._glTextures[this.CONTEXT_UID];\n    !e || ((t.mipmap === MIPMAP_MODES$5.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES$5.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);\n  }, r.prototype.setStyle = function(t, e) {\n    var o = this.gl;\n    if (e.mipmap && t.mipmap !== MIPMAP_MODES$5.ON_MANUAL && o.generateMipmap(t.target), o.texParameteri(t.target, o.TEXTURE_WRAP_S, e.wrapMode), o.texParameteri(t.target, o.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {\n      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR_MIPMAP_LINEAR : o.NEAREST_MIPMAP_NEAREST);\n      var T = this.renderer.context.extensions.anisotropicFiltering;\n      if (T && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES$5.LINEAR) {\n        var S = Math.min(t.anisotropicLevel, o.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        o.texParameterf(t.target, T.TEXTURE_MAX_ANISOTROPY_EXT, S);\n      }\n    } else\n      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);\n    o.texParameteri(t.target, o.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), _systems = {\n  __proto__: null,\n  FilterSystem,\n  BatchSystem,\n  ContextSystem,\n  FramebufferSystem,\n  GeometrySystem,\n  MaskSystem,\n  ScissorSystem,\n  StencilSystem,\n  ProjectionSystem,\n  RenderTextureSystem,\n  ShaderSystem,\n  StateSystem,\n  TextureGCSystem,\n  TextureSystem\n}, tempMatrix = new Matrix(), AbstractRenderer = function(r) {\n  __extends$p(t, r);\n  function t(e, o) {\n    e === void 0 && (e = RENDERER_TYPE$5.UNKNOWN);\n    var T = r.call(this) || this;\n    return o = Object.assign({}, settings$1.RENDER_OPTIONS, o), T.options = o, T.type = e, T.screen = new Rectangle(0, 0, o.width, o.height), T.view = o.view || settings$1.ADAPTER.createCanvas(), T.resolution = o.resolution || settings$1.RESOLUTION, T.useContextAlpha = o.useContextAlpha, T.autoDensity = !!o.autoDensity, T.preserveDrawingBuffer = o.preserveDrawingBuffer, T.clearBeforeRender = o.clearBeforeRender, T._backgroundColor = 0, T._backgroundColorRgba = [0, 0, 0, 1], T._backgroundColorString = \"#000000\", T.backgroundColor = o.backgroundColor || T._backgroundColor, T.backgroundAlpha = o.backgroundAlpha, o.transparent !== void 0 && (deprecation$1(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\"), T.useContextAlpha = o.transparent, T.backgroundAlpha = o.transparent ? 0 : 1), T._lastObjectRendered = null, T.plugins = {}, T;\n  }\n  return t.prototype.initPlugins = function(e) {\n    for (var o in e)\n      this.plugins[o] = new e[o](this);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.view.width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.view.height;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.resize = function(e, o) {\n    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(o * this.resolution);\n    var T = this.view.width / this.resolution, S = this.view.height / this.resolution;\n    this.screen.width = T, this.screen.height = S, this.autoDensity && (this.view.style.width = T + \"px\", this.view.style.height = S + \"px\"), this.emit(\"resize\", T, S);\n  }, t.prototype.generateTexture = function(e, o, T, S) {\n    o === void 0 && (o = {}), typeof o == \"number\" && (deprecation$1(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\"), o = { scaleMode: o, resolution: T, region: S });\n    var N = o.region, D = __rest$3(o, [\"region\"]);\n    S = N || e.getLocalBounds(null, !0), S.width === 0 && (S.width = 1), S.height === 0 && (S.height = 1);\n    var B = RenderTexture.create(__assign$8({ width: S.width, height: S.height }, D));\n    return tempMatrix.tx = -S.x, tempMatrix.ty = -S.y, this.render(e, {\n      renderTexture: B,\n      clear: !1,\n      transform: tempMatrix,\n      skipUpdateTransform: !!e.parent\n    }), B;\n  }, t.prototype.destroy = function(e) {\n    for (var o in this.plugins)\n      this.plugins[o].destroy(), this.plugins[o] = null;\n    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);\n    var T = this;\n    T.plugins = null, T.type = RENDERER_TYPE$5.UNKNOWN, T.view = null, T.screen = null, T._tempDisplayObjectParent = null, T.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;\n  }, Object.defineProperty(t.prototype, \"backgroundColor\", {\n    get: function() {\n      return this._backgroundColor;\n    },\n    set: function(e) {\n      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"backgroundAlpha\", {\n    get: function() {\n      return this._backgroundColorRgba[3];\n    },\n    set: function(e) {\n      this._backgroundColorRgba[3] = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(i$1), GLBuffer = function() {\n  function r(t) {\n    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n  }\n  return r;\n}(), BufferSystem = function() {\n  function r(t) {\n    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};\n  }\n  return r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r.prototype.contextChange = function() {\n    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }, r.prototype.bind = function(t) {\n    var e = this, o = e.gl, T = e.CONTEXT_UID, S = t._glBuffers[T] || this.createGLBuffer(t);\n    o.bindBuffer(t.type, S.buffer);\n  }, r.prototype.bindBufferBase = function(t, e) {\n    var o = this, T = o.gl, S = o.CONTEXT_UID;\n    if (this.boundBufferBases[e] !== t) {\n      var N = t._glBuffers[S] || this.createGLBuffer(t);\n      this.boundBufferBases[e] = t, T.bindBufferBase(T.UNIFORM_BUFFER, e, N.buffer);\n    }\n  }, r.prototype.bindBufferRange = function(t, e, o) {\n    var T = this, S = T.gl, N = T.CONTEXT_UID;\n    o = o || 0;\n    var D = t._glBuffers[N] || this.createGLBuffer(t);\n    S.bindBufferRange(S.UNIFORM_BUFFER, e || 0, D.buffer, o * 256, 256);\n  }, r.prototype.update = function(t) {\n    var e = this, o = e.gl, T = e.CONTEXT_UID, S = t._glBuffers[T];\n    if (t._updateID !== S.updateID)\n      if (S.updateID = t._updateID, o.bindBuffer(t.type, S.buffer), S.byteLength >= t.data.byteLength)\n        o.bufferSubData(t.type, 0, t.data);\n      else {\n        var N = t.static ? o.STATIC_DRAW : o.DYNAMIC_DRAW;\n        S.byteLength = t.data.byteLength, o.bufferData(t.type, t.data, N);\n      }\n  }, r.prototype.dispose = function(t, e) {\n    if (!!this.managedBuffers[t.id]) {\n      delete this.managedBuffers[t.id];\n      var o = t._glBuffers[this.CONTEXT_UID], T = this.gl;\n      t.disposeRunner.remove(this), o && (e || T.deleteBuffer(o.buffer), delete t._glBuffers[this.CONTEXT_UID]);\n    }\n  }, r.prototype.disposeAll = function(t) {\n    for (var e = Object.keys(this.managedBuffers), o = 0; o < e.length; o++)\n      this.dispose(this.managedBuffers[e[o]], t);\n  }, r.prototype.createGLBuffer = function(t) {\n    var e = this, o = e.CONTEXT_UID, T = e.gl;\n    return t._glBuffers[o] = new GLBuffer(T.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[o];\n  }, r;\n}(), Renderer = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    var o = r.call(this, RENDERER_TYPE$5.WEBGL, e) || this;\n    return e = o.options, o.gl = null, o.CONTEXT_UID = 0, o.runners = {\n      destroy: new Runner(\"destroy\"),\n      contextChange: new Runner(\"contextChange\"),\n      reset: new Runner(\"reset\"),\n      update: new Runner(\"update\"),\n      postrender: new Runner(\"postrender\"),\n      prerender: new Runner(\"prerender\"),\n      resize: new Runner(\"resize\")\n    }, o.runners.contextChange.add(o), o.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, !0), o.addSystem(MaskSystem, \"mask\").addSystem(ContextSystem, \"context\").addSystem(StateSystem, \"state\").addSystem(ShaderSystem, \"shader\").addSystem(TextureSystem, \"texture\").addSystem(BufferSystem, \"buffer\").addSystem(GeometrySystem, \"geometry\").addSystem(FramebufferSystem, \"framebuffer\").addSystem(ScissorSystem, \"scissor\").addSystem(StencilSystem, \"stencil\").addSystem(ProjectionSystem, \"projection\").addSystem(TextureGCSystem, \"textureGC\").addSystem(FilterSystem, \"filter\").addSystem(RenderTextureSystem, \"renderTexture\").addSystem(BatchSystem, \"batch\"), o.initPlugins(t.__plugins), o.multisample = void 0, e.context ? o.context.initFromContext(e.context) : o.context.initFromOptions({\n      alpha: !!o.useContextAlpha,\n      antialias: e.antialias,\n      premultipliedAlpha: o.useContextAlpha && o.useContextAlpha !== \"notMultiplied\",\n      stencil: !0,\n      preserveDrawingBuffer: e.preserveDrawingBuffer,\n      powerPreference: o.options.powerPreference\n    }), o.renderingToScreen = !0, sayHello(o.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\"), o.resize(o.options.width, o.options.height), o;\n  }\n  return t.create = function(e) {\n    if (isWebGLSupported())\n      return new t(e);\n    throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n  }, t.prototype.contextChange = function() {\n    var e = this.gl, o;\n    if (this.context.webGLVersion === 1) {\n      var T = e.getParameter(e.FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, T);\n    } else {\n      var T = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);\n      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, T);\n    }\n    o >= MSAA_QUALITY$5.HIGH ? this.multisample = MSAA_QUALITY$5.HIGH : o >= MSAA_QUALITY$5.MEDIUM ? this.multisample = MSAA_QUALITY$5.MEDIUM : o >= MSAA_QUALITY$5.LOW ? this.multisample = MSAA_QUALITY$5.LOW : this.multisample = MSAA_QUALITY$5.NONE;\n  }, t.prototype.addSystem = function(e, o) {\n    var T = new e(this);\n    if (this[o])\n      throw new Error('Whoops! The name \"' + o + '\" is already in use');\n    this[o] = T;\n    for (var S in this.runners)\n      this.runners[S].add(T);\n    return this;\n  }, t.prototype.render = function(e, o) {\n    var T, S, N, D;\n    if (o && (o instanceof RenderTexture ? (deprecation$1(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\"), T = o, S = arguments[2], N = arguments[3], D = arguments[4]) : (T = o.renderTexture, S = o.clear, N = o.transform, D = o.skipUpdateTransform)), this.renderingToScreen = !T, this.runners.prerender.emit(), this.emit(\"prerender\"), this.projection.transform = N, !this.context.isLost) {\n      if (T || (this._lastObjectRendered = e), !D) {\n        var B = e.enableTempParent();\n        e.updateTransform(), e.disableTempParent(B);\n      }\n      this.renderTexture.bind(T), this.batch.currentRenderer.start(), (S !== void 0 ? S : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), T && T.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit(\"postrender\");\n    }\n  }, t.prototype.generateTexture = function(e, o, T, S) {\n    o === void 0 && (o = {});\n    var N = r.prototype.generateTexture.call(this, e, o, T, S);\n    return this.framebuffer.blit(), N;\n  }, t.prototype.resize = function(e, o) {\n    r.prototype.resize.call(this, e, o), this.runners.resize.emit(this.screen.height, this.screen.width);\n  }, t.prototype.reset = function() {\n    return this.runners.reset.emit(), this;\n  }, t.prototype.clear = function() {\n    this.renderTexture.bind(), this.renderTexture.clear();\n  }, t.prototype.destroy = function(e) {\n    this.runners.destroy.emit();\n    for (var o in this.runners)\n      this.runners[o].destroy();\n    r.prototype.destroy.call(this, e), this.gl = null;\n  }, Object.defineProperty(t.prototype, \"extract\", {\n    get: function() {\n      return deprecation$1(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\"), this.plugins.extract;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.registerPlugin = function(e, o) {\n    deprecation$1(\"6.5.0\", \"Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.\"), extensions.add({\n      name: e,\n      type: ExtensionType.RendererPlugin,\n      ref: o\n    });\n  }, t.__plugins = {}, t;\n}(AbstractRenderer);\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nfunction autoDetectRenderer(r) {\n  return Renderer.create(r);\n}\nvar $defaultVertex = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, System = function() {\n  function r(t) {\n    deprecation$1(\"6.1.0\", \"System class is deprecated, implemement ISystem interface instead.\"), this.renderer = t;\n  }\n  return r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r;\n}(), BatchDrawCall = function() {\n  function r() {\n    this.texArray = null, this.blend = 0, this.type = DRAW_MODES$5.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n  }\n  return r;\n}(), BatchTextureArray = function() {\n  function r() {\n    this.elements = [], this.ids = [], this.count = 0;\n  }\n  return r.prototype.clear = function() {\n    for (var t = 0; t < this.count; t++)\n      this.elements[t] = null;\n    this.count = 0;\n  }, r;\n}(), ViewableBuffer = function() {\n  function r(t) {\n    typeof t == \"number\" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  return Object.defineProperty(r.prototype, \"int8View\", {\n    get: function() {\n      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"uint8View\", {\n    get: function() {\n      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"int16View\", {\n    get: function() {\n      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"uint16View\", {\n    get: function() {\n      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"int32View\", {\n    get: function() {\n      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.view = function(t) {\n    return this[t + \"View\"];\n  }, r.prototype.destroy = function() {\n    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n  }, r.sizeOf = function(t) {\n    switch (t) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(t + \" isn't a valid view type\");\n    }\n  }, r;\n}(), AbstractBatchRenderer = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return o.shaderGenerator = null, o.geometryClass = null, o.vertexSize = null, o.state = State.for2d(), o.size = settings$1.SPRITE_BATCH_SIZE * 4, o._vertexCount = 0, o._indexCount = 0, o._bufferedElements = [], o._bufferedTextures = [], o._bufferSize = 0, o._shader = null, o._packedGeometries = [], o._packedGeometryPoolSize = 2, o._flushId = 0, o._aBuffers = {}, o._iBuffers = {}, o.MAX_TEXTURES = 1, o.renderer.on(\"prerender\", o.onPrerender, o), e.runners.contextChange.add(o), o._dcIndex = 0, o._aIndex = 0, o._iIndex = 0, o._attributeBuffer = null, o._indexBuffer = null, o._tempBoundTextures = [], o;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer.gl;\n    settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings$1.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n    for (var o = 0; o < this._packedGeometryPoolSize; o++)\n      this._packedGeometries[o] = new this.geometryClass();\n    this.initFlushBuffers();\n  }, t.prototype.initFlushBuffers = function() {\n    for (var e = t._drawCallPool, o = t._textureArrayPool, T = this.size / 4, S = Math.floor(T / this.MAX_TEXTURES) + 1; e.length < T; )\n      e.push(new BatchDrawCall());\n    for (; o.length < S; )\n      o.push(new BatchTextureArray());\n    for (var N = 0; N < this.MAX_TEXTURES; N++)\n      this._tempBoundTextures[N] = null;\n  }, t.prototype.onPrerender = function() {\n    this._flushId = 0;\n  }, t.prototype.render = function(e) {\n    !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);\n  }, t.prototype.buildTexturesAndDrawCalls = function() {\n    var e = this, o = e._bufferedTextures, T = e.MAX_TEXTURES, S = t._textureArrayPool, N = this.renderer.batch, D = this._tempBoundTextures, B = this.renderer.textureGC.count, $ = ++BaseTexture._globalBatch, U = 0, z = S[0], V = 0;\n    N.copyBoundTextures(D, T);\n    for (var X = 0; X < this._bufferSize; ++X) {\n      var W = o[X];\n      o[X] = null, W._batchEnabled !== $ && (z.count >= T && (N.boundArray(z, D, $, T), this.buildDrawCalls(z, V, X), V = X, z = S[++U], ++$), W._batchEnabled = $, W.touched = B, z.elements[z.count++] = W);\n    }\n    z.count > 0 && (N.boundArray(z, D, $, T), this.buildDrawCalls(z, V, this._bufferSize), ++U, ++$);\n    for (var X = 0; X < D.length; X++)\n      D[X] = null;\n    BaseTexture._globalBatch = $;\n  }, t.prototype.buildDrawCalls = function(e, o, T) {\n    var S = this, N = S._bufferedElements, D = S._attributeBuffer, B = S._indexBuffer, $ = S.vertexSize, U = t._drawCallPool, z = this._dcIndex, V = this._aIndex, X = this._iIndex, W = U[z];\n    W.start = this._iIndex, W.texArray = e;\n    for (var Y = o; Y < T; ++Y) {\n      var q = N[Y], Z = q._texture.baseTexture, K = premultiplyBlendMode[Z.alphaMode ? 1 : 0][q.blendMode];\n      N[Y] = null, o < Y && W.blend !== K && (W.size = X - W.start, o = Y, W = U[++z], W.texArray = e, W.start = X), this.packInterleavedGeometry(q, D, B, V, X), V += q.vertexData.length / 2 * $, X += q.indices.length, W.blend = K;\n    }\n    o < T && (W.size = X - W.start, ++z), this._dcIndex = z, this._aIndex = V, this._iIndex = X;\n  }, t.prototype.bindAndClearTexArray = function(e) {\n    for (var o = this.renderer.texture, T = 0; T < e.count; T++)\n      o.bind(e.elements[T], e.ids[T]), e.elements[T] = null;\n    e.count = 0;\n  }, t.prototype.updateGeometry = function() {\n    var e = this, o = e._packedGeometries, T = e._attributeBuffer, S = e._indexBuffer;\n    settings$1.CAN_UPLOAD_SAME_BUFFER ? (o[this._flushId]._buffer.update(T.rawBinaryData), o[this._flushId]._indexBuffer.update(S), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, o[this._flushId] = new this.geometryClass()), o[this._flushId]._buffer.update(T.rawBinaryData), o[this._flushId]._indexBuffer.update(S), this.renderer.geometry.bind(o[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n  }, t.prototype.drawBatches = function() {\n    for (var e = this._dcIndex, o = this.renderer, T = o.gl, S = o.state, N = t._drawCallPool, D = null, B = 0; B < e; B++) {\n      var $ = N[B], U = $.texArray, z = $.type, V = $.size, X = $.start, W = $.blend;\n      D !== U && (D = U, this.bindAndClearTexArray(U)), this.state.blendMode = W, S.set(this.state), T.drawElements(z, V, T.UNSIGNED_SHORT, X * 2);\n    }\n  }, t.prototype.flush = function() {\n    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n  }, t.prototype.start = function() {\n    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings$1.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n  }, t.prototype.stop = function() {\n    this.flush();\n  }, t.prototype.destroy = function() {\n    for (var e = 0; e < this._packedGeometryPoolSize; e++)\n      this._packedGeometries[e] && this._packedGeometries[e].destroy();\n    this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), r.prototype.destroy.call(this);\n  }, t.prototype.getAttributeBuffer = function(e) {\n    var o = nextPow2(Math.ceil(e / 8)), T = log2(o), S = o * 8;\n    this._aBuffers.length <= T && (this._iBuffers.length = T + 1);\n    var N = this._aBuffers[S];\n    return N || (this._aBuffers[S] = N = new ViewableBuffer(S * this.vertexSize * 4)), N;\n  }, t.prototype.getIndexBuffer = function(e) {\n    var o = nextPow2(Math.ceil(e / 12)), T = log2(o), S = o * 12;\n    this._iBuffers.length <= T && (this._iBuffers.length = T + 1);\n    var N = this._iBuffers[T];\n    return N || (this._iBuffers[T] = N = new Uint16Array(S)), N;\n  }, t.prototype.packInterleavedGeometry = function(e, o, T, S, N) {\n    for (var D = o.uint32View, B = o.float32View, $ = S / this.vertexSize, U = e.uvs, z = e.indices, V = e.vertexData, X = e._texture.baseTexture._batchLocation, W = Math.min(e.worldAlpha, 1), Y = W < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, W) : e._tintRGB + (W * 255 << 24), q = 0; q < V.length; q += 2)\n      B[S++] = V[q], B[S++] = V[q + 1], B[S++] = U[q], B[S++] = U[q + 1], D[S++] = Y, B[S++] = X;\n    for (var q = 0; q < z.length; q++)\n      T[N++] = $ + z[q];\n  }, t._drawCallPool = [], t._textureArrayPool = [], t;\n}(ObjectRenderer), BatchShaderGenerator = function() {\n  function r(t, e) {\n    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf(\"%count%\") < 0)\n      throw new Error('Fragment template must contain \"%count%\".');\n    if (e.indexOf(\"%forloop%\") < 0)\n      throw new Error('Fragment template must contain \"%forloop%\".');\n  }\n  return r.prototype.generateShader = function(t) {\n    if (!this.programCache[t]) {\n      for (var e = new Int32Array(t), o = 0; o < t; o++)\n        e[o] = o;\n      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);\n      var T = this.fragTemplate;\n      T = T.replace(/%count%/gi, \"\" + t), T = T.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, T);\n    }\n    var S = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[t]\n    };\n    return new Shader(this.programCache[t], S);\n  }, r.prototype.generateSampleSrc = function(t) {\n    var e = \"\";\n    e += `\n`, e += `\n`;\n    for (var o = 0; o < t; o++)\n      o > 0 && (e += `\nelse `), o < t - 1 && (e += \"if(vTextureId < \" + o + \".5)\"), e += `\n{`, e += `\n\tcolor = texture2D(uSamplers[` + o + \"], vTextureCoord);\", e += `\n}`;\n    return e += `\n`, e += `\n`, e;\n  }, r;\n}(), BatchGeometry = function(r) {\n  __extends$p(t, r);\n  function t(e) {\n    e === void 0 && (e = !1);\n    var o = r.call(this) || this;\n    return o._buffer = new Buffer$1(null, e, !1), o._indexBuffer = new Buffer$1(null, e, !0), o.addAttribute(\"aVertexPosition\", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute(\"aTextureCoord\", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute(\"aColor\", o._buffer, 4, !0, TYPES$5.UNSIGNED_BYTE).addAttribute(\"aTextureId\", o._buffer, 1, !0, TYPES$5.FLOAT).addIndex(o._indexBuffer), o;\n  }\n  return t;\n}(Geometry), defaultVertex = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`, defaultFragment = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`, BatchPluginFactory = function() {\n  function r() {\n  }\n  return r.create = function(t) {\n    var e = Object.assign({\n      vertex: defaultVertex,\n      fragment: defaultFragment,\n      geometryClass: BatchGeometry,\n      vertexSize: 6\n    }, t), o = e.vertex, T = e.fragment, S = e.vertexSize, N = e.geometryClass;\n    return function(D) {\n      __extends$p(B, D);\n      function B($) {\n        var U = D.call(this, $) || this;\n        return U.shaderGenerator = new BatchShaderGenerator(o, T), U.geometryClass = N, U.vertexSize = S, U;\n      }\n      return B;\n    }(AbstractBatchRenderer);\n  }, Object.defineProperty(r, \"defaultVertexSrc\", {\n    get: function() {\n      return defaultVertex;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"defaultFragmentTemplate\", {\n    get: function() {\n      return defaultFragment;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}(), BatchRenderer = BatchPluginFactory.create();\nObject.assign(BatchRenderer, {\n  extension: {\n    name: \"batch\",\n    type: ExtensionType.RendererPlugin\n  }\n});\nvar resources = {}, _loop_1 = function(r) {\n  Object.defineProperty(resources, r, {\n    get: function() {\n      return deprecation$1(\"6.0.0\", \"PIXI.systems.\" + r + \" has moved to PIXI.\" + r), _resources[r];\n    }\n  });\n};\nfor (var name in _resources)\n  _loop_1(name);\nvar systems = {}, _loop_2 = function(r) {\n  Object.defineProperty(systems, r, {\n    get: function() {\n      return deprecation$1(\"6.0.0\", \"PIXI.resources.\" + r + \" has moved to PIXI.\" + r), _systems[r];\n    }\n  });\n};\nfor (var name in _systems)\n  _loop_2(name);\nvar VERSION = \"6.5.5\";\nconst n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AbstractBatchRenderer,\n  AbstractMultiResource,\n  AbstractRenderer,\n  ArrayResource,\n  Attribute,\n  BaseImageResource,\n  BaseRenderTexture,\n  BaseTexture,\n  BatchDrawCall,\n  BatchGeometry,\n  BatchPluginFactory,\n  BatchRenderer,\n  BatchShaderGenerator,\n  BatchSystem,\n  BatchTextureArray,\n  Buffer: Buffer$1,\n  BufferResource,\n  CanvasResource,\n  ContextSystem,\n  CubeResource,\n  Filter,\n  FilterState,\n  FilterSystem,\n  Framebuffer,\n  FramebufferSystem,\n  GLFramebuffer,\n  GLProgram,\n  GLTexture,\n  Geometry,\n  GeometrySystem,\n  IGLUniformData,\n  INSTALLED,\n  ImageBitmapResource,\n  ImageResource,\n  MaskData,\n  MaskSystem,\n  ObjectRenderer,\n  Program,\n  ProjectionSystem,\n  Quad,\n  QuadUv,\n  RenderTexture,\n  RenderTexturePool,\n  RenderTextureSystem,\n  Renderer,\n  Resource,\n  SVGResource,\n  ScissorSystem,\n  Shader,\n  ShaderSystem,\n  SpriteMaskFilter,\n  State,\n  StateSystem,\n  StencilSystem,\n  System,\n  Texture,\n  TextureGCSystem,\n  TextureMatrix,\n  TextureSystem,\n  TextureUvs,\n  UniformGroup,\n  VERSION,\n  VideoResource,\n  ViewableBuffer,\n  autoDetectRenderer,\n  autoDetectResource,\n  checkMaxIfStatementsInShader,\n  createUBOElements,\n  defaultFilterVertex,\n  defaultVertex: defaultVertex$1,\n  generateProgram,\n  generateUniformBufferSync,\n  getTestContext,\n  getUBOData,\n  resources,\n  systems,\n  uniformParsers,\n  get ExtensionType() {\n    return ExtensionType;\n  },\n  extensions\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*!\n * @pixi/accessibility - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/accessibility is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar accessibleTarget = {\n  accessible: !1,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: !1,\n  _accessibleDiv: null,\n  accessibleType: \"button\",\n  accessiblePointerEvents: \"auto\",\n  accessibleChildren: !0,\n  renderId: -1\n};\nDisplayObject.mixin(accessibleTarget);\nvar KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {\n  function r(t) {\n    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile$2.tablet || isMobile$2.phone) && this.createTouchHook();\n    var e = document.createElement(\"div\");\n    e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_TOUCH_POS_X + \"px\", e.style.left = DIV_TOUCH_POS_Y + \"px\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1);\n  }\n  return Object.defineProperty(r.prototype, \"isActive\", {\n    get: function() {\n      return this._isActive;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"isMobileAccessibility\", {\n    get: function() {\n      return this._isMobileAccessibility;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.createTouchHook = function() {\n    var t = this, e = document.createElement(\"button\");\n    e.style.width = DIV_HOOK_SIZE + \"px\", e.style.height = DIV_HOOK_SIZE + \"px\", e.style.position = \"absolute\", e.style.top = DIV_HOOK_POS_X + \"px\", e.style.left = DIV_HOOK_POS_Y + \"px\", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = \"#FF0000\", e.title = \"select to enable accessibility for this content\", e.addEventListener(\"focus\", function() {\n      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();\n    }), document.body.appendChild(e), this._hookDiv = e;\n  }, r.prototype.destroyTouchHook = function() {\n    !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n  }, r.prototype.activate = function() {\n    var t;\n    this._isActive || (this._isActive = !0, globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.on(\"postrender\", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));\n  }, r.prototype.deactivate = function() {\n    var t;\n    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.off(\"postrender\", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));\n  }, r.prototype.updateAccessibleObjects = function(t) {\n    if (!(!t.visible || !t.accessibleChildren)) {\n      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);\n      var e = t.children;\n      if (e)\n        for (var o = 0; o < e.length; o++)\n          this.updateAccessibleObjects(e[o]);\n    }\n  }, r.prototype.update = function() {\n    var t = performance.now();\n    if (!(isMobile$2.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {\n      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n      var e = this.renderer.view.getBoundingClientRect(), o = e.left, T = e.top, S = e.width, N = e.height, D = this.renderer, B = D.width, $ = D.height, U = D.resolution, z = S / B * U, V = N / $ * U, X = this.div;\n      X.style.left = o + \"px\", X.style.top = T + \"px\", X.style.width = B + \"px\", X.style.height = $ + \"px\";\n      for (var W = 0; W < this.children.length; W++) {\n        var Y = this.children[W];\n        if (Y.renderId !== this.renderId)\n          Y._accessibleActive = !1, removeItems(this.children, W, 1), this.div.removeChild(Y._accessibleDiv), this.pool.push(Y._accessibleDiv), Y._accessibleDiv = null, W--;\n        else {\n          X = Y._accessibleDiv;\n          var q = Y.hitArea, Z = Y.worldTransform;\n          Y.hitArea ? (X.style.left = (Z.tx + q.x * Z.a) * z + \"px\", X.style.top = (Z.ty + q.y * Z.d) * V + \"px\", X.style.width = q.width * Z.a * z + \"px\", X.style.height = q.height * Z.d * V + \"px\") : (q = Y.getBounds(), this.capHitArea(q), X.style.left = q.x * z + \"px\", X.style.top = q.y * V + \"px\", X.style.width = q.width * z + \"px\", X.style.height = q.height * V + \"px\", X.title !== Y.accessibleTitle && Y.accessibleTitle !== null && (X.title = Y.accessibleTitle), X.getAttribute(\"aria-label\") !== Y.accessibleHint && Y.accessibleHint !== null && X.setAttribute(\"aria-label\", Y.accessibleHint)), (Y.accessibleTitle !== X.title || Y.tabIndex !== X.tabIndex) && (X.title = Y.accessibleTitle, X.tabIndex = Y.tabIndex, this.debug && this.updateDebugHTML(X));\n        }\n      }\n      this.renderId++;\n    }\n  }, r.prototype.updateDebugHTML = function(t) {\n    t.innerHTML = \"type: \" + t.type + \"</br> title : \" + t.title + \"</br> tabIndex: \" + t.tabIndex;\n  }, r.prototype.capHitArea = function(t) {\n    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);\n    var e = this.renderer, o = e.width, T = e.height;\n    t.x + t.width > o && (t.width = o - t.x), t.y + t.height > T && (t.height = T - t.y);\n  }, r.prototype.addChild = function(t) {\n    var e = this.pool.pop();\n    e || (e = document.createElement(\"button\"), e.style.width = DIV_TOUCH_SIZE + \"px\", e.style.height = DIV_TOUCH_SIZE + \"px\", e.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\", e.style.position = \"absolute\", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = \"none\", navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1 ? e.setAttribute(\"aria-live\", \"off\") : e.setAttribute(\"aria-live\", \"polite\"), navigator.userAgent.match(/rv:.*Gecko\\//) ? e.setAttribute(\"aria-relevant\", \"additions\") : e.setAttribute(\"aria-relevant\", \"text\"), e.addEventListener(\"click\", this._onClick.bind(this)), e.addEventListener(\"focus\", this._onFocus.bind(this)), e.addEventListener(\"focusout\", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = \"displayObject \" + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute(\"aria-label\", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;\n  }, r.prototype._onClick = function(t) {\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, T = e.eventData;\n    e.dispatchEvent(o, \"click\", T), e.dispatchEvent(o, \"pointertap\", T), e.dispatchEvent(o, \"tap\", T);\n  }, r.prototype._onFocus = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"assertive\");\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, T = e.eventData;\n    e.dispatchEvent(o, \"mouseover\", T);\n  }, r.prototype._onFocusOut = function(t) {\n    t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"polite\");\n    var e = this.renderer.plugins.interaction, o = t.target.displayObject, T = e.eventData;\n    e.dispatchEvent(o, \"mouseout\", T);\n  }, r.prototype._onKeyDown = function(t) {\n    t.keyCode === KEY_CODE_TAB && this.activate();\n  }, r.prototype._onMouseMove = function(t) {\n    t.movementX === 0 && t.movementY === 0 || this.deactivate();\n  }, r.prototype.destroy = function() {\n    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n  }, r.extension = {\n    name: \"accessibility\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, r;\n}();\n/*!\n * @pixi/interaction - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar InteractionData = function() {\n  function r() {\n    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;\n  }\n  return Object.defineProperty(r.prototype, \"pointerId\", {\n    get: function() {\n      return this.identifier;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.getLocalPosition = function(t, e, o) {\n    return t.worldTransform.applyInverse(o || this.global, e);\n  }, r.prototype.copyEvent = function(t) {\n    \"isPrimary\" in t && t.isPrimary && (this.isPrimary = !0), this.button = \"button\" in t && t.button;\n    var e = \"buttons\" in t && t.buttons;\n    this.buttons = Number.isInteger(e) ? e : \"which\" in t && t.which, this.width = \"width\" in t && t.width, this.height = \"height\" in t && t.height, this.tiltX = \"tiltX\" in t && t.tiltX, this.tiltY = \"tiltY\" in t && t.tiltY, this.pointerType = \"pointerType\" in t && t.pointerType, this.pressure = \"pressure\" in t && t.pressure, this.rotationAngle = \"rotationAngle\" in t && t.rotationAngle, this.twist = \"twist\" in t && t.twist || 0, this.tangentialPressure = \"tangentialPressure\" in t && t.tangentialPressure || 0;\n  }, r.prototype.reset = function() {\n    this.isPrimary = !1;\n  }, r;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$o = function(r, t) {\n  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$o(r, t);\n};\nfunction __extends$o(r, t) {\n  extendStatics$o(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar InteractionEvent = function() {\n  function r() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;\n  }\n  return r.prototype.stopPropagation = function() {\n    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;\n  }, r.prototype.reset = function() {\n    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;\n  }, r;\n}(), InteractionTrackingData = function() {\n  function r(t) {\n    this._pointerId = t, this._flags = r.FLAGS.NONE;\n  }\n  return r.prototype._doSet = function(t, e) {\n    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;\n  }, Object.defineProperty(r.prototype, \"pointerId\", {\n    get: function() {\n      return this._pointerId;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"flags\", {\n    get: function() {\n      return this._flags;\n    },\n    set: function(t) {\n      this._flags = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"none\", {\n    get: function() {\n      return this._flags === r.FLAGS.NONE;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"over\", {\n    get: function() {\n      return (this._flags & r.FLAGS.OVER) !== 0;\n    },\n    set: function(t) {\n      this._doSet(r.FLAGS.OVER, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"rightDown\", {\n    get: function() {\n      return (this._flags & r.FLAGS.RIGHT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(r.FLAGS.RIGHT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"leftDown\", {\n    get: function() {\n      return (this._flags & r.FLAGS.LEFT_DOWN) !== 0;\n    },\n    set: function(t) {\n      this._doSet(r.FLAGS.LEFT_DOWN, t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  }), r;\n}(), TreeSearch = function() {\n  function r() {\n    this._tempPoint = new Point();\n  }\n  return r.prototype.recursiveFindHit = function(t, e, o, T, S) {\n    var N;\n    if (!e || !e.visible)\n      return !1;\n    var D = t.data.global;\n    S = e.interactive || S;\n    var B = !1, $ = S, U = !0;\n    if (e.hitArea)\n      T && (e.worldTransform.applyInverse(D, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? B = !0 : (T = !1, U = !1)), $ = !1;\n    else if (e._mask && T) {\n      var z = e._mask.isMaskData ? e._mask.maskObject : e._mask;\n      z && !(!((N = z.containsPoint) === null || N === void 0) && N.call(z, D)) && (T = !1);\n    }\n    if (U && e.interactiveChildren && e.children)\n      for (var V = e.children, X = V.length - 1; X >= 0; X--) {\n        var W = V[X], Y = this.recursiveFindHit(t, W, o, T, $);\n        if (Y) {\n          if (!W.parent)\n            continue;\n          $ = !1, Y && (t.target && (T = !1), B = !0);\n        }\n      }\n    return S && (T && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(D) && (B = !0), e.interactive && (B && !t.target && (t.target = e), o && o(t, e, !!B))), B;\n  }, r.prototype.findHit = function(t, e, o, T) {\n    this.recursiveFindHit(t, e, o, T, !1);\n  }, r;\n}(), interactiveTarget = {\n  interactive: !1,\n  interactiveChildren: !0,\n  hitArea: null,\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(r) {\n    r ? this.cursor = \"pointer\" : this.cursor === \"pointer\" && (this.cursor = null);\n  },\n  cursor: null,\n  get trackedPointers() {\n    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;\n  },\n  _trackedPointers: void 0\n};\nDisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1, hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n}, InteractionManager = function(r) {\n  __extends$o(t, r);\n  function t(e, o) {\n    var T = r.call(this) || this;\n    return o = o || {}, T.renderer = e, T.autoPreventDefault = o.autoPreventDefault !== void 0 ? o.autoPreventDefault : !0, T.interactionFrequency = o.interactionFrequency || 10, T.mouse = new InteractionData(), T.mouse.identifier = MOUSE_POINTER_ID, T.mouse.global.set(-999999), T.activeInteractionData = {}, T.activeInteractionData[MOUSE_POINTER_ID] = T.mouse, T.interactionDataPool = [], T.eventData = new InteractionEvent(), T.interactionDOMElement = null, T.moveWhenInside = !1, T.eventsAdded = !1, T.tickerAdded = !1, T.mouseOverRenderer = !(\"PointerEvent\" in globalThis), T.supportsTouchEvents = \"ontouchstart\" in globalThis, T.supportsPointerEvents = !!globalThis.PointerEvent, T.onPointerUp = T.onPointerUp.bind(T), T.processPointerUp = T.processPointerUp.bind(T), T.onPointerCancel = T.onPointerCancel.bind(T), T.processPointerCancel = T.processPointerCancel.bind(T), T.onPointerDown = T.onPointerDown.bind(T), T.processPointerDown = T.processPointerDown.bind(T), T.onPointerMove = T.onPointerMove.bind(T), T.processPointerMove = T.processPointerMove.bind(T), T.onPointerOut = T.onPointerOut.bind(T), T.processPointerOverOut = T.processPointerOverOut.bind(T), T.onPointerOver = T.onPointerOver.bind(T), T.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    }, T.currentCursorMode = null, T.cursor = null, T.resolution = 1, T.delayedEvents = [], T.search = new TreeSearch(), T._tempDisplayObject = new TemporaryDisplayObject(), T._eventListenerOptions = { capture: !0, passive: !1 }, T._useSystemTicker = o.useSystemTicker !== void 0 ? o.useSystemTicker : !0, T.setTargetElement(T.renderer.view, T.renderer.resolution), T;\n  }\n  return Object.defineProperty(t.prototype, \"useSystemTicker\", {\n    get: function() {\n      return this._useSystemTicker;\n    },\n    set: function(e) {\n      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"lastObjectRendered\", {\n    get: function() {\n      return this.renderer._lastObjectRendered || this._tempDisplayObject;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.hitTest = function(e, o) {\n    return hitTestEvent.target = null, hitTestEvent.data.global = e, o || (o = this.lastObjectRendered), this.processInteractive(hitTestEvent, o, null, !0), hitTestEvent.target;\n  }, t.prototype.setTargetElement = function(e, o) {\n    o === void 0 && (o = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = o, this.addEvents(), this.addTickerListener();\n  }, t.prototype.addTickerListener = function() {\n    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);\n  }, t.prototype.removeTickerListener = function() {\n    !this.tickerAdded || (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n  }, t.prototype.addEvents = function() {\n    if (!(this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"none\", e.msTouchAction = \"none\") : this.supportsPointerEvents && (e.touchAction = \"none\"), this.supportsPointerEvents ? (globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;\n    }\n  }, t.prototype.removeEvents = function() {\n    if (!(!this.eventsAdded || !this.interactionDOMElement)) {\n      var e = this.interactionDOMElement.style;\n      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"\", e.msTouchAction = \"\") : this.supportsPointerEvents && (e.touchAction = \"\"), this.supportsPointerEvents ? (globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;\n    }\n  }, t.prototype.tickerUpdate = function(e) {\n    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n  }, t.prototype.update = function() {\n    if (!!this.interactionDOMElement) {\n      if (this._didMove) {\n        this._didMove = !1;\n        return;\n      }\n      this.cursor = null;\n      for (var e in this.activeInteractionData)\n        if (this.activeInteractionData.hasOwnProperty(e)) {\n          var o = this.activeInteractionData[e];\n          if (o.originalEvent && o.pointerType !== \"touch\") {\n            var T = this.configureInteractionEventForDOMEvent(this.eventData, o.originalEvent, o);\n            this.processInteractive(T, this.lastObjectRendered, this.processPointerOverOut, !0);\n          }\n        }\n      this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.setCursorMode = function(e) {\n    e = e || \"default\";\n    var o = !0;\n    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (o = !1), this.currentCursorMode !== e) {\n      this.currentCursorMode = e;\n      var T = this.cursorStyles[e];\n      if (T)\n        switch (typeof T) {\n          case \"string\":\n            o && (this.interactionDOMElement.style.cursor = T);\n            break;\n          case \"function\":\n            T(e);\n            break;\n          case \"object\":\n            o && Object.assign(this.interactionDOMElement.style, T);\n            break;\n        }\n      else\n        o && typeof e == \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);\n    }\n  }, t.prototype.dispatchEvent = function(e, o, T) {\n    (!T.stopPropagationHint || e === T.stopsPropagatingAt) && (T.currentTarget = e, T.type = o, e.emit(o, T), e[o] && e[o](T));\n  }, t.prototype.delayDispatchEvent = function(e, o, T) {\n    this.delayedEvents.push({ displayObject: e, eventString: o, eventData: T });\n  }, t.prototype.mapPositionToPoint = function(e, o, T) {\n    var S;\n    this.interactionDOMElement.parentElement ? S = this.interactionDOMElement.getBoundingClientRect() : S = {\n      x: 0,\n      y: 0,\n      width: this.interactionDOMElement.width,\n      height: this.interactionDOMElement.height,\n      left: 0,\n      top: 0\n    };\n    var N = 1 / this.resolution;\n    e.x = (o - S.left) * (this.interactionDOMElement.width / S.width) * N, e.y = (T - S.top) * (this.interactionDOMElement.height / S.height) * N;\n  }, t.prototype.processInteractive = function(e, o, T, S) {\n    var N = this.search.findHit(e, o, T, S), D = this.delayedEvents;\n    if (!D.length)\n      return N;\n    e.stopPropagationHint = !1;\n    var B = D.length;\n    this.delayedEvents = [];\n    for (var $ = 0; $ < B; $++) {\n      var U = D[$], z = U.displayObject, V = U.eventString, X = U.eventData;\n      X.stopsPropagatingAt === z && (X.stopPropagationHint = !0), this.dispatchEvent(z, V, X);\n    }\n    return N;\n  }, t.prototype.onPointerDown = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e);\n      if (this.autoPreventDefault && o[0].isNormalized) {\n        var T = e.cancelable || !(\"cancelable\" in e);\n        T && e.preventDefault();\n      }\n      for (var S = o.length, N = 0; N < S; N++) {\n        var D = o[N], B = this.getInteractionDataForPointerId(D), $ = this.configureInteractionEventForDOMEvent(this.eventData, D, B);\n        if ($.data.originalEvent = e, this.processInteractive($, this.lastObjectRendered, this.processPointerDown, !0), this.emit(\"pointerdown\", $), D.pointerType === \"touch\")\n          this.emit(\"touchstart\", $);\n        else if (D.pointerType === \"mouse\" || D.pointerType === \"pen\") {\n          var U = D.button === 2;\n          this.emit(U ? \"rightdown\" : \"mousedown\", this.eventData);\n        }\n      }\n    }\n  }, t.prototype.processPointerDown = function(e, o, T) {\n    var S = e.data, N = e.data.identifier;\n    if (T) {\n      if (o.trackedPointers[N] || (o.trackedPointers[N] = new InteractionTrackingData(N)), this.dispatchEvent(o, \"pointerdown\", e), S.pointerType === \"touch\")\n        this.dispatchEvent(o, \"touchstart\", e);\n      else if (S.pointerType === \"mouse\" || S.pointerType === \"pen\") {\n        var D = S.button === 2;\n        D ? o.trackedPointers[N].rightDown = !0 : o.trackedPointers[N].leftDown = !0, this.dispatchEvent(o, D ? \"rightdown\" : \"mousedown\", e);\n      }\n    }\n  }, t.prototype.onPointerComplete = function(e, o, T) {\n    var S = this.normalizeToPointerData(e), N = S.length, D = e.target;\n    e.composedPath && e.composedPath().length > 0 && (D = e.composedPath()[0]);\n    for (var B = D !== this.interactionDOMElement ? \"outside\" : \"\", $ = 0; $ < N; $++) {\n      var U = S[$], z = this.getInteractionDataForPointerId(U), V = this.configureInteractionEventForDOMEvent(this.eventData, U, z);\n      if (V.data.originalEvent = e, this.processInteractive(V, this.lastObjectRendered, T, o || !B), this.emit(o ? \"pointercancel\" : \"pointerup\" + B, V), U.pointerType === \"mouse\" || U.pointerType === \"pen\") {\n        var X = U.button === 2;\n        this.emit(X ? \"rightup\" + B : \"mouseup\" + B, V);\n      } else\n        U.pointerType === \"touch\" && (this.emit(o ? \"touchcancel\" : \"touchend\" + B, V), this.releaseInteractionDataForPointerId(U.pointerId));\n    }\n  }, t.prototype.onPointerCancel = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !0, this.processPointerCancel);\n  }, t.prototype.processPointerCancel = function(e, o) {\n    var T = e.data, S = e.data.identifier;\n    o.trackedPointers[S] !== void 0 && (delete o.trackedPointers[S], this.dispatchEvent(o, \"pointercancel\", e), T.pointerType === \"touch\" && this.dispatchEvent(o, \"touchcancel\", e));\n  }, t.prototype.onPointerUp = function(e) {\n    this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !1, this.processPointerUp);\n  }, t.prototype.processPointerUp = function(e, o, T) {\n    var S = e.data, N = e.data.identifier, D = o.trackedPointers[N], B = S.pointerType === \"touch\", $ = S.pointerType === \"mouse\" || S.pointerType === \"pen\", U = !1;\n    if ($) {\n      var z = S.button === 2, V = InteractionTrackingData.FLAGS, X = z ? V.RIGHT_DOWN : V.LEFT_DOWN, W = D !== void 0 && D.flags & X;\n      T ? (this.dispatchEvent(o, z ? \"rightup\" : \"mouseup\", e), W && (this.dispatchEvent(o, z ? \"rightclick\" : \"click\", e), U = !0)) : W && this.dispatchEvent(o, z ? \"rightupoutside\" : \"mouseupoutside\", e), D && (z ? D.rightDown = !1 : D.leftDown = !1);\n    }\n    T ? (this.dispatchEvent(o, \"pointerup\", e), B && this.dispatchEvent(o, \"touchend\", e), D && ((!$ || U) && this.dispatchEvent(o, \"pointertap\", e), B && (this.dispatchEvent(o, \"tap\", e), D.over = !1))) : D && (this.dispatchEvent(o, \"pointerupoutside\", e), B && this.dispatchEvent(o, \"touchendoutside\", e)), D && D.none && delete o.trackedPointers[N];\n  }, t.prototype.onPointerMove = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e);\n      (o[0].pointerType === \"mouse\" || o[0].pointerType === \"pen\") && (this._didMove = !0, this.cursor = null);\n      for (var T = o.length, S = 0; S < T; S++) {\n        var N = o[S], D = this.getInteractionDataForPointerId(N), B = this.configureInteractionEventForDOMEvent(this.eventData, N, D);\n        B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerMove, !0), this.emit(\"pointermove\", B), N.pointerType === \"touch\" && this.emit(\"touchmove\", B), (N.pointerType === \"mouse\" || N.pointerType === \"pen\") && this.emit(\"mousemove\", B);\n      }\n      o[0].pointerType === \"mouse\" && this.setCursorMode(this.cursor);\n    }\n  }, t.prototype.processPointerMove = function(e, o, T) {\n    var S = e.data, N = S.pointerType === \"touch\", D = S.pointerType === \"mouse\" || S.pointerType === \"pen\";\n    D && this.processPointerOverOut(e, o, T), (!this.moveWhenInside || T) && (this.dispatchEvent(o, \"pointermove\", e), N && this.dispatchEvent(o, \"touchmove\", e), D && this.dispatchEvent(o, \"mousemove\", e));\n  }, t.prototype.onPointerOut = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e), T = o[0];\n      T.pointerType === \"mouse\" && (this.mouseOverRenderer = !1, this.setCursorMode(null));\n      var S = this.getInteractionDataForPointerId(T), N = this.configureInteractionEventForDOMEvent(this.eventData, T, S);\n      N.data.originalEvent = T, this.processInteractive(N, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit(\"pointerout\", N), T.pointerType === \"mouse\" || T.pointerType === \"pen\" ? this.emit(\"mouseout\", N) : this.releaseInteractionDataForPointerId(S.identifier);\n    }\n  }, t.prototype.processPointerOverOut = function(e, o, T) {\n    var S = e.data, N = e.data.identifier, D = S.pointerType === \"mouse\" || S.pointerType === \"pen\", B = o.trackedPointers[N];\n    T && !B && (B = o.trackedPointers[N] = new InteractionTrackingData(N)), B !== void 0 && (T && this.mouseOverRenderer ? (B.over || (B.over = !0, this.delayDispatchEvent(o, \"pointerover\", e), D && this.delayDispatchEvent(o, \"mouseover\", e)), D && this.cursor === null && (this.cursor = o.cursor)) : B.over && (B.over = !1, this.dispatchEvent(o, \"pointerout\", this.eventData), D && this.dispatchEvent(o, \"mouseout\", e), B.none && delete o.trackedPointers[N]));\n  }, t.prototype.onPointerOver = function(e) {\n    if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n      var o = this.normalizeToPointerData(e), T = o[0], S = this.getInteractionDataForPointerId(T), N = this.configureInteractionEventForDOMEvent(this.eventData, T, S);\n      N.data.originalEvent = T, T.pointerType === \"mouse\" && (this.mouseOverRenderer = !0), this.emit(\"pointerover\", N), (T.pointerType === \"mouse\" || T.pointerType === \"pen\") && this.emit(\"mouseover\", N);\n    }\n  }, t.prototype.getInteractionDataForPointerId = function(e) {\n    var o = e.pointerId, T;\n    return o === MOUSE_POINTER_ID || e.pointerType === \"mouse\" ? T = this.mouse : this.activeInteractionData[o] ? T = this.activeInteractionData[o] : (T = this.interactionDataPool.pop() || new InteractionData(), T.identifier = o, this.activeInteractionData[o] = T), T.copyEvent(e), T;\n  }, t.prototype.releaseInteractionDataForPointerId = function(e) {\n    var o = this.activeInteractionData[e];\n    o && (delete this.activeInteractionData[e], o.reset(), this.interactionDataPool.push(o));\n  }, t.prototype.configureInteractionEventForDOMEvent = function(e, o, T) {\n    return e.data = T, this.mapPositionToPoint(T.global, o.clientX, o.clientY), o.pointerType === \"touch\" && (o.globalX = T.global.x, o.globalY = T.global.y), T.originalEvent = o, e.reset(), e;\n  }, t.prototype.normalizeToPointerData = function(e) {\n    var o = [];\n    if (this.supportsTouchEvents && e instanceof TouchEvent)\n      for (var T = 0, S = e.changedTouches.length; T < S; T++) {\n        var N = e.changedTouches[T];\n        typeof N.button > \"u\" && (N.button = e.touches.length ? 1 : 0), typeof N.buttons > \"u\" && (N.buttons = e.touches.length ? 1 : 0), typeof N.isPrimary > \"u\" && (N.isPrimary = e.touches.length === 1 && e.type === \"touchstart\"), typeof N.width > \"u\" && (N.width = N.radiusX || 1), typeof N.height > \"u\" && (N.height = N.radiusY || 1), typeof N.tiltX > \"u\" && (N.tiltX = 0), typeof N.tiltY > \"u\" && (N.tiltY = 0), typeof N.pointerType > \"u\" && (N.pointerType = \"touch\"), typeof N.pointerId > \"u\" && (N.pointerId = N.identifier || 0), typeof N.pressure > \"u\" && (N.pressure = N.force || 0.5), typeof N.twist > \"u\" && (N.twist = 0), typeof N.tangentialPressure > \"u\" && (N.tangentialPressure = 0), typeof N.layerX > \"u\" && (N.layerX = N.offsetX = N.clientX), typeof N.layerY > \"u\" && (N.layerY = N.offsetY = N.clientY), N.isNormalized = !0, o.push(N);\n      }\n    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {\n      var D = e;\n      typeof D.isPrimary > \"u\" && (D.isPrimary = !0), typeof D.width > \"u\" && (D.width = 1), typeof D.height > \"u\" && (D.height = 1), typeof D.tiltX > \"u\" && (D.tiltX = 0), typeof D.tiltY > \"u\" && (D.tiltY = 0), typeof D.pointerType > \"u\" && (D.pointerType = \"mouse\"), typeof D.pointerId > \"u\" && (D.pointerId = MOUSE_POINTER_ID), typeof D.pressure > \"u\" && (D.pressure = 0.5), typeof D.twist > \"u\" && (D.twist = 0), typeof D.tangentialPressure > \"u\" && (D.tangentialPressure = 0), D.isNormalized = !0, o.push(D);\n    } else\n      o.push(e);\n    return o;\n  }, t.prototype.destroy = function() {\n    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;\n  }, t.extension = {\n    name: \"interaction\",\n    type: [\n      ExtensionType.RendererPlugin,\n      ExtensionType.CanvasRendererPlugin\n    ]\n  }, t;\n}(i$1);\n/*!\n * @pixi/extract - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {\n  function r(t) {\n    this.renderer = t;\n  }\n  return r.prototype.image = function(t, e, o) {\n    var T = new Image();\n    return T.src = this.base64(t, e, o), T;\n  }, r.prototype.base64 = function(t, e, o) {\n    return this.canvas(t).toDataURL(e, o);\n  }, r.prototype.canvas = function(t, e) {\n    var o = this.renderer, T, S = !1, N, D = !1;\n    t && (t instanceof RenderTexture ? N = t : (N = this.renderer.generateTexture(t), D = !0)), N ? (T = N.baseTexture.resolution, e = e != null ? e : N.frame, S = !1, o.renderTexture.bind(N)) : (T = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), S = !0, o.renderTexture.bind(null));\n    var B = Math.round(e.width * T), $ = Math.round(e.height * T), U = new CanvasRenderTarget(B, $, 1), z = new Uint8Array(BYTES_PER_PIXEL * B * $), V = o.gl;\n    V.readPixels(Math.round(e.x * T), Math.round(e.y * T), B, $, V.RGBA, V.UNSIGNED_BYTE, z);\n    var X = U.context.getImageData(0, 0, B, $);\n    if (r.arrayPostDivide(z, X.data), U.context.putImageData(X, 0, 0), S) {\n      var W = new CanvasRenderTarget(U.width, U.height, 1);\n      W.context.scale(1, -1), W.context.drawImage(U.canvas, 0, -$), U.destroy(), U = W;\n    }\n    return D && N.destroy(!0), U.canvas;\n  }, r.prototype.pixels = function(t, e) {\n    var o = this.renderer, T, S, N = !1;\n    t && (t instanceof RenderTexture ? S = t : (S = this.renderer.generateTexture(t), N = !0)), S ? (T = S.baseTexture.resolution, e = e != null ? e : S.frame, o.renderTexture.bind(S)) : (T = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), o.renderTexture.bind(null));\n    var D = Math.round(e.width * T), B = Math.round(e.height * T), $ = new Uint8Array(BYTES_PER_PIXEL * D * B), U = o.gl;\n    return U.readPixels(Math.round(e.x * T), Math.round(e.y * T), D, B, U.RGBA, U.UNSIGNED_BYTE, $), N && S.destroy(!0), r.arrayPostDivide($, $), $;\n  }, r.prototype.destroy = function() {\n    this.renderer = null;\n  }, r.arrayPostDivide = function(t, e) {\n    for (var o = 0; o < t.length; o += 4) {\n      var T = e[o + 3] = t[o + 3];\n      T !== 0 ? (e[o] = Math.round(Math.min(t[o] * 255 / T, 255)), e[o + 1] = Math.round(Math.min(t[o + 1] * 255 / T, 255)), e[o + 2] = Math.round(Math.min(t[o + 2] * 255 / T, 255))) : (e[o] = t[o], e[o + 1] = t[o + 1], e[o + 2] = t[o + 2]);\n    }\n  }, r.extension = {\n    name: \"extract\",\n    type: ExtensionType.RendererPlugin\n  }, r;\n}();\n/*!\n * @pixi/loaders - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar SignalBinding = function() {\n  function r(t, e, o) {\n    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = o, this._next = this._prev = this._owner = null;\n  }\n  return r.prototype.detach = function() {\n    return this._owner === null ? !1 : (this._owner.detach(this), !0);\n  }, r;\n}();\nfunction _addSignalBinding(r, t) {\n  return r._head ? (r._tail._next = t, t._prev = r._tail, r._tail = t) : (r._head = t, r._tail = t), t._owner = r, t;\n}\nvar Signal = function() {\n  function r() {\n    this._head = this._tail = void 0;\n  }\n  return r.prototype.handlers = function(t) {\n    t === void 0 && (t = !1);\n    var e = this._head;\n    if (t)\n      return !!e;\n    for (var o = []; e; )\n      o.push(e), e = e._next;\n    return o;\n  }, r.prototype.has = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n    return t._owner === this;\n  }, r.prototype.dispatch = function() {\n    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)\n      e[o] = t[o];\n    var T = this._head;\n    if (!T)\n      return !1;\n    for (; T; )\n      T._once && this.detach(T), T._fn.apply(T._thisArg, e), T = T._next;\n    return !0;\n  }, r.prototype.add = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !1, e));\n  }, r.prototype.once = function(t, e) {\n    if (e === void 0 && (e = null), typeof t != \"function\")\n      throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n    return _addSignalBinding(this, new SignalBinding(t, !0, e));\n  }, r.prototype.detach = function(t) {\n    if (!(t instanceof SignalBinding))\n      throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);\n  }, r.prototype.detachAll = function() {\n    var t = this._head;\n    if (!t)\n      return this;\n    for (this._head = this._tail = null; t; )\n      t._owner = null, t = t._next;\n    return this;\n  }, r;\n}();\nfunction parseUri(r, t) {\n  t = t || {};\n  for (var e = {\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, o = e.parser[t.strictMode ? \"strict\" : \"loose\"].exec(r), T = {}, S = 14; S--; )\n    T[e.key[S]] = o[S] || \"\";\n  return T[e.q.name] = {}, T[e.key[12]].replace(e.q.parser, function(N, D, B) {\n    D && (T[e.q.name][D] = B);\n  }), T;\n}\nvar useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;\nfunction _noop$1() {\n}\nfunction setExtMap(r, t, e) {\n  t && t.indexOf(\".\") === 0 && (t = t.substring(1)), t && (r[t] = e);\n}\nfunction reqType(r) {\n  return r.toString().replace(\"object \", \"\");\n}\nvar LoaderResource = function() {\n  function r(t, e, o) {\n    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != \"string\" || typeof e != \"string\")\n      throw new Error(\"Both name and url are required for constructing a resource.\");\n    o = o || {}, this._flags = 0, this._setFlag(r.STATUS_FLAGS.DATA_URL, e.indexOf(\"data:\") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = o.crossOrigin === !0 ? \"anonymous\" : o.crossOrigin, this.timeout = o.timeout || 0, this.loadType = o.loadType || this._determineLoadType(), this.xhrType = o.xhrType, this.metadata = o.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = r.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();\n  }\n  return r.setExtensionLoadType = function(t, e) {\n    setExtMap(r._loadTypeMap, t, e);\n  }, r.setExtensionXhrType = function(t, e) {\n    setExtMap(r._xhrTypeMap, t, e);\n  }, Object.defineProperty(r.prototype, \"isDataUrl\", {\n    get: function() {\n      return this._hasFlag(r.STATUS_FLAGS.DATA_URL);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"isComplete\", {\n    get: function() {\n      return this._hasFlag(r.STATUS_FLAGS.COMPLETE);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"isLoading\", {\n    get: function() {\n      return this._hasFlag(r.STATUS_FLAGS.LOADING);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.complete = function() {\n    this._clearEvents(), this._finish();\n  }, r.prototype.abort = function(t) {\n    if (!this.error) {\n      if (this.error = new Error(t), this._clearEvents(), this.xhr)\n        this.xhr.abort();\n      else if (this.xdr)\n        this.xdr.abort();\n      else if (this.data)\n        if (this.data.src)\n          this.data.src = r.EMPTY_GIF;\n        else\n          for (; this.data.firstChild; )\n            this.data.removeChild(this.data.firstChild);\n      this._finish();\n    }\n  }, r.prototype.load = function(t) {\n    var e = this;\n    if (!this.isLoading) {\n      if (this.isComplete) {\n        t && setTimeout(function() {\n          return t(e);\n        }, 1);\n        return;\n      } else\n        t && this.onComplete.once(t);\n      switch (this._setFlag(r.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != \"string\") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {\n        case r.LOAD_TYPE.IMAGE:\n          this.type = r.TYPE.IMAGE, this._loadElement(\"image\");\n          break;\n        case r.LOAD_TYPE.AUDIO:\n          this.type = r.TYPE.AUDIO, this._loadSourceElement(\"audio\");\n          break;\n        case r.LOAD_TYPE.VIDEO:\n          this.type = r.TYPE.VIDEO, this._loadSourceElement(\"video\");\n          break;\n        case r.LOAD_TYPE.XHR:\n        default:\n          typeof useXdr > \"u\" && (useXdr = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();\n          break;\n      }\n    }\n  }, r.prototype._hasFlag = function(t) {\n    return (this._flags & t) !== 0;\n  }, r.prototype._setFlag = function(t, e) {\n    this._flags = e ? this._flags | t : this._flags & ~t;\n  }, r.prototype._clearEvents = function() {\n    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener(\"error\", this._boundOnError, !1), this.data.removeEventListener(\"load\", this._boundComplete, !1), this.data.removeEventListener(\"progress\", this._boundOnProgress, !1), this.data.removeEventListener(\"canplaythrough\", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener(\"error\", this._boundXhrOnError, !1), this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, !1), this.xhr.removeEventListener(\"progress\", this._boundOnProgress, !1), this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));\n  }, r.prototype._finish = function() {\n    if (this.isComplete)\n      throw new Error(\"Complete called again for an already completed resource.\");\n    this._setFlag(r.STATUS_FLAGS.COMPLETE, !0), this._setFlag(r.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);\n  }, r.prototype._loadElement = function(t) {\n    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"image\" && typeof globalThis.Image < \"u\" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, r.prototype._loadSourceElement = function(t) {\n    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"audio\" && typeof globalThis.Audio < \"u\" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {\n      this.abort(\"Unsupported element: \" + t);\n      return;\n    }\n    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)\n      if (navigator.isCocoonJS)\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      else if (Array.isArray(this.url))\n        for (var e = this.metadata.mimeType, o = 0; o < this.url.length; ++o)\n          this.data.appendChild(this._createSource(t, this.url[o], Array.isArray(e) ? e[o] : e));\n      else {\n        var e = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));\n      }\n    this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.data.addEventListener(\"canplaythrough\", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n  }, r.prototype._loadXhr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new XMLHttpRequest();\n    this.crossOrigin === \"use-credentials\" && (t.withCredentials = !0), t.open(\"GET\", this.url, !0), t.timeout = this.timeout, this.xhrType === r.XHR_RESPONSE_TYPE.JSON || this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = r.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener(\"error\", this._boundXhrOnError, !1), t.addEventListener(\"timeout\", this._boundXhrOnTimeout, !1), t.addEventListener(\"abort\", this._boundXhrOnAbort, !1), t.addEventListener(\"progress\", this._boundOnProgress, !1), t.addEventListener(\"load\", this._boundXhrOnLoad, !1), t.send();\n  }, r.prototype._loadXdr = function() {\n    typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n    var t = this.xhr = new globalThis.XDomainRequest();\n    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open(\"GET\", this.url, !0), setTimeout(function() {\n      return t.send();\n    }, 1);\n  }, r.prototype._createSource = function(t, e, o) {\n    o || (o = t + \"/\" + this._getExtension(e));\n    var T = document.createElement(\"source\");\n    return T.src = e, T.type = o, T;\n  }, r.prototype._onError = function(t) {\n    this.abort(\"Failed to load element using: \" + t.target.nodeName);\n  }, r.prototype._onProgress = function(t) {\n    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);\n  }, r.prototype._onTimeout = function() {\n    this.abort(\"Load timed out.\");\n  }, r.prototype._xhrOnError = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request failed. Status: \" + t.status + ', text: \"' + t.statusText + '\"');\n  }, r.prototype._xhrOnTimeout = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request timed out.\");\n  }, r.prototype._xhrOnAbort = function() {\n    var t = this.xhr;\n    this.abort(reqType(t) + \" Request was aborted by the user.\");\n  }, r.prototype._xhrOnLoad = function() {\n    var t = this.xhr, e = \"\", o = typeof t.status > \"u\" ? STATUS_OK : t.status;\n    (t.responseType === \"\" || t.responseType === \"text\" || typeof t.responseType > \"u\") && (e = t.responseText), o === STATUS_NONE && (e.length > 0 || t.responseType === r.XHR_RESPONSE_TYPE.BUFFER) ? o = STATUS_OK : o === STATUS_IE_BUG_EMPTY && (o = STATUS_EMPTY);\n    var T = o / 100 | 0;\n    if (T === STATUS_TYPE_OK)\n      if (this.xhrType === r.XHR_RESPONSE_TYPE.TEXT)\n        this.data = e, this.type = r.TYPE.TEXT;\n      else if (this.xhrType === r.XHR_RESPONSE_TYPE.JSON)\n        try {\n          this.data = JSON.parse(e), this.type = r.TYPE.JSON;\n        } catch (D) {\n          this.abort(\"Error trying to parse loaded json: \" + D);\n          return;\n        }\n      else if (this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT)\n        try {\n          if (globalThis.DOMParser) {\n            var S = new DOMParser();\n            this.data = S.parseFromString(e, \"text/xml\");\n          } else {\n            var N = document.createElement(\"div\");\n            N.innerHTML = e, this.data = N;\n          }\n          this.type = r.TYPE.XML;\n        } catch (D) {\n          this.abort(\"Error trying to parse loaded xml: \" + D);\n          return;\n        }\n      else\n        this.data = t.response || e;\n    else {\n      this.abort(\"[\" + t.status + \"] \" + t.statusText + \": \" + t.responseURL);\n      return;\n    }\n    this.complete();\n  }, r.prototype._determineCrossOrigin = function(t, e) {\n    if (t.indexOf(\"data:\") === 0)\n      return \"\";\n    if (globalThis.origin !== globalThis.location.origin)\n      return \"anonymous\";\n    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement(\"a\")), tempAnchor.href = t;\n    var o = parseUri(tempAnchor.href, { strictMode: !0 }), T = !o.port && e.port === \"\" || o.port === e.port, S = o.protocol ? o.protocol + \":\" : \"\";\n    return o.host !== e.hostname || !T || S !== e.protocol ? \"anonymous\" : \"\";\n  }, r.prototype._determineXhrType = function() {\n    return r._xhrTypeMap[this.extension] || r.XHR_RESPONSE_TYPE.TEXT;\n  }, r.prototype._determineLoadType = function() {\n    return r._loadTypeMap[this.extension] || r.LOAD_TYPE.XHR;\n  }, r.prototype._getExtension = function(t) {\n    t === void 0 && (t = this.url);\n    var e = \"\";\n    if (this.isDataUrl) {\n      var o = t.indexOf(\"/\");\n      e = t.substring(o + 1, t.indexOf(\";\", o));\n    } else {\n      var T = t.indexOf(\"?\"), S = t.indexOf(\"#\"), N = Math.min(T > -1 ? T : t.length, S > -1 ? S : t.length);\n      t = t.substring(0, N), e = t.substring(t.lastIndexOf(\".\") + 1);\n    }\n    return e.toLowerCase();\n  }, r.prototype._getMimeFromXhrType = function(t) {\n    switch (t) {\n      case r.XHR_RESPONSE_TYPE.BUFFER:\n        return \"application/octet-binary\";\n      case r.XHR_RESPONSE_TYPE.BLOB:\n        return \"application/blob\";\n      case r.XHR_RESPONSE_TYPE.DOCUMENT:\n        return \"application/xml\";\n      case r.XHR_RESPONSE_TYPE.JSON:\n        return \"application/json\";\n      case r.XHR_RESPONSE_TYPE.DEFAULT:\n      case r.XHR_RESPONSE_TYPE.TEXT:\n      default:\n        return \"text/plain\";\n    }\n  }, r;\n}();\n(function(r) {\n  (function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.DATA_URL = 1] = \"DATA_URL\", t[t.COMPLETE = 2] = \"COMPLETE\", t[t.LOADING = 4] = \"LOADING\";\n  })(r.STATUS_FLAGS || (r.STATUS_FLAGS = {})), function(t) {\n    t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.JSON = 1] = \"JSON\", t[t.XML = 2] = \"XML\", t[t.IMAGE = 3] = \"IMAGE\", t[t.AUDIO = 4] = \"AUDIO\", t[t.VIDEO = 5] = \"VIDEO\", t[t.TEXT = 6] = \"TEXT\";\n  }(r.TYPE || (r.TYPE = {})), function(t) {\n    t[t.XHR = 1] = \"XHR\", t[t.IMAGE = 2] = \"IMAGE\", t[t.AUDIO = 3] = \"AUDIO\", t[t.VIDEO = 4] = \"VIDEO\";\n  }(r.LOAD_TYPE || (r.LOAD_TYPE = {})), function(t) {\n    t.DEFAULT = \"text\", t.BUFFER = \"arraybuffer\", t.BLOB = \"blob\", t.DOCUMENT = \"document\", t.JSON = \"json\", t.TEXT = \"text\";\n  }(r.XHR_RESPONSE_TYPE || (r.XHR_RESPONSE_TYPE = {})), r._loadTypeMap = {\n    gif: r.LOAD_TYPE.IMAGE,\n    png: r.LOAD_TYPE.IMAGE,\n    bmp: r.LOAD_TYPE.IMAGE,\n    jpg: r.LOAD_TYPE.IMAGE,\n    jpeg: r.LOAD_TYPE.IMAGE,\n    tif: r.LOAD_TYPE.IMAGE,\n    tiff: r.LOAD_TYPE.IMAGE,\n    webp: r.LOAD_TYPE.IMAGE,\n    tga: r.LOAD_TYPE.IMAGE,\n    svg: r.LOAD_TYPE.IMAGE,\n    \"svg+xml\": r.LOAD_TYPE.IMAGE,\n    mp3: r.LOAD_TYPE.AUDIO,\n    ogg: r.LOAD_TYPE.AUDIO,\n    wav: r.LOAD_TYPE.AUDIO,\n    mp4: r.LOAD_TYPE.VIDEO,\n    webm: r.LOAD_TYPE.VIDEO\n  }, r._xhrTypeMap = {\n    xhtml: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx: r.XHR_RESPONSE_TYPE.DOCUMENT,\n    gif: r.XHR_RESPONSE_TYPE.BLOB,\n    png: r.XHR_RESPONSE_TYPE.BLOB,\n    bmp: r.XHR_RESPONSE_TYPE.BLOB,\n    jpg: r.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: r.XHR_RESPONSE_TYPE.BLOB,\n    tif: r.XHR_RESPONSE_TYPE.BLOB,\n    tiff: r.XHR_RESPONSE_TYPE.BLOB,\n    webp: r.XHR_RESPONSE_TYPE.BLOB,\n    tga: r.XHR_RESPONSE_TYPE.BLOB,\n    json: r.XHR_RESPONSE_TYPE.JSON,\n    text: r.XHR_RESPONSE_TYPE.TEXT,\n    txt: r.XHR_RESPONSE_TYPE.TEXT,\n    ttf: r.XHR_RESPONSE_TYPE.BUFFER,\n    otf: r.XHR_RESPONSE_TYPE.BUFFER\n  }, r.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(LoaderResource || (LoaderResource = {}));\nfunction _noop() {\n}\nfunction onlyOnce(r) {\n  return function() {\n    for (var e = arguments, o = [], T = 0; T < arguments.length; T++)\n      o[T] = e[T];\n    if (r === null)\n      throw new Error(\"Callback was already called.\");\n    var S = r;\n    r = null, S.apply(this, o);\n  };\n}\nvar AsyncQueueItem = function() {\n  function r(t, e) {\n    this.data = t, this.callback = e;\n  }\n  return r;\n}(), AsyncQueue = function() {\n  function r(t, e) {\n    var o = this;\n    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(T, S, N) {\n      if (N && typeof N != \"function\")\n        throw new Error(\"task callback must be a function\");\n      if (o.started = !0, T == null && o.idle()) {\n        setTimeout(function() {\n          return o.drain();\n        }, 1);\n        return;\n      }\n      var D = new AsyncQueueItem(T, typeof N == \"function\" ? N : _noop);\n      S ? o._tasks.unshift(D) : o._tasks.push(D), setTimeout(o.process, 1);\n    }, this.process = function() {\n      for (; !o.paused && o.workers < o.concurrency && o._tasks.length; ) {\n        var T = o._tasks.shift();\n        o._tasks.length === 0 && o.empty(), o.workers += 1, o.workers === o.concurrency && o.saturated(), o._worker(T.data, onlyOnce(o._next(T)));\n      }\n    }, this._worker = t, e === 0)\n      throw new Error(\"Concurrency must not be zero\");\n    this.concurrency = e, this.buffer = e / 4;\n  }\n  return r.prototype._next = function(t) {\n    var e = this;\n    return function() {\n      for (var o = arguments, T = [], S = 0; S < arguments.length; S++)\n        T[S] = o[S];\n      e.workers -= 1, t.callback.apply(t, T), T[0] != null && e.error(T[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();\n    };\n  }, r.prototype.push = function(t, e) {\n    this._insert(t, !1, e);\n  }, r.prototype.kill = function() {\n    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];\n  }, r.prototype.unshift = function(t, e) {\n    this._insert(t, !0, e);\n  }, r.prototype.length = function() {\n    return this._tasks.length;\n  }, r.prototype.running = function() {\n    return this.workers;\n  }, r.prototype.idle = function() {\n    return this._tasks.length + this.workers === 0;\n  }, r.prototype.pause = function() {\n    this.paused !== !0 && (this.paused = !0);\n  }, r.prototype.resume = function() {\n    if (this.paused !== !1) {\n      this.paused = !1;\n      for (var t = 1; t <= this.concurrency; t++)\n        this.process();\n    }\n  }, r.eachSeries = function(t, e, o, T) {\n    var S = 0, N = t.length;\n    function D(B) {\n      if (B || S === N) {\n        o && o(B);\n        return;\n      }\n      T ? setTimeout(function() {\n        e(t[S++], D);\n      }, 1) : e(t[S++], D);\n    }\n    D();\n  }, r.queue = function(t, e) {\n    return new r(t, e);\n  }, r;\n}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\\w-]+)?$/, Loader = function() {\n  function r(t, e) {\n    var o = this;\n    t === void 0 && (t = \"\"), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = \"\", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {\n      return o._loadResource(B, $);\n    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(B, $) {\n      return o._loadResource(B, $);\n    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();\n    for (var T = 0; T < r._plugins.length; ++T) {\n      var S = r._plugins[T], N = S.pre, D = S.use;\n      N && this.pre(N), D && this.use(D);\n    }\n    this._protected = !1;\n  }\n  return r.prototype._add = function(t, e, o, T) {\n    if (this.loading && (!o || !o.parentResource))\n      throw new Error(\"Cannot add resources while the loader is running.\");\n    if (this.resources[t])\n      throw new Error('Resource named \"' + t + '\" already exists.');\n    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, o), typeof T == \"function\" && this.resources[t].onAfterMiddleware.once(T), this.loading) {\n      for (var S = o.parentResource, N = [], D = 0; D < S.children.length; ++D)\n        S.children[D].isComplete || N.push(S.children[D]);\n      var B = S.progressChunk * (N.length + 1), $ = B / (N.length + 2);\n      S.children.push(this.resources[t]), S.progressChunk = $;\n      for (var D = 0; D < N.length; ++D)\n        N[D].progressChunk = $;\n      this.resources[t].progressChunk = $;\n    }\n    return this._queue.push(this.resources[t]), this;\n  }, r.prototype.pre = function(t) {\n    return this._beforeMiddleware.push(t), this;\n  }, r.prototype.use = function(t) {\n    return this._afterMiddleware.push(t), this;\n  }, r.prototype.reset = function() {\n    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();\n    for (var t in this.resources) {\n      var e = this.resources[t];\n      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort(\"loader reset\");\n    }\n    return this.resources = {}, this;\n  }, r.prototype.load = function(t) {\n    if (deprecation$1(\"6.5.0\", \"@pixi/loaders is being replaced with @pixi/assets in the next major release.\"), typeof t == \"function\" && this.onComplete.once(t), this.loading)\n      return this;\n    if (this._queue.idle())\n      this._onStart(), this._onComplete();\n    else {\n      for (var e = this._queue._tasks.length, o = MAX_PROGRESS / e, T = 0; T < this._queue._tasks.length; ++T)\n        this._queue._tasks[T].data.progressChunk = o;\n      this._onStart(), this._queue.resume();\n    }\n    return this;\n  }, Object.defineProperty(r.prototype, \"concurrency\", {\n    get: function() {\n      return this._queue.concurrency;\n    },\n    set: function(t) {\n      this._queue.concurrency = t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype._prepareUrl = function(t) {\n    var e = parseUri(t, { strictMode: !0 }), o;\n    if (e.protocol || !e.path || t.indexOf(\"//\") === 0 ? o = t : this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && t.charAt(0) !== \"/\" ? o = this.baseUrl + \"/\" + t : o = this.baseUrl + t, this.defaultQueryString) {\n      var T = rgxExtractUrlHash.exec(o)[0];\n      o = o.slice(0, o.length - T.length), o.indexOf(\"?\") !== -1 ? o += \"&\" + this.defaultQueryString : o += \"?\" + this.defaultQueryString, o += T;\n    }\n    return o;\n  }, r.prototype._loadResource = function(t, e) {\n    var o = this;\n    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(T, S) {\n      T.call(o, t, function() {\n        S(t.isComplete ? {} : null);\n      });\n    }, function() {\n      t.isComplete ? o._onLoad(t) : (t._onLoadBinding = t.onComplete.once(o._onLoad, o), t.load());\n    }, !0);\n  }, r.prototype._onStart = function() {\n    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);\n  }, r.prototype._onComplete = function() {\n    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);\n  }, r.prototype._onLoad = function(t) {\n    var e = this;\n    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(o, T) {\n      o.call(e, t, T);\n    }, function() {\n      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();\n    }, !0);\n  }, r.prototype.destroy = function() {\n    this._protected || this.reset();\n  }, Object.defineProperty(r, \"shared\", {\n    get: function() {\n      var t = r._shared;\n      return t || (t = new r(), t._protected = !0, r._shared = t), t;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.registerPlugin = function(t) {\n    return deprecation$1(\"6.5.0\", \"Loader.registerPlugin() is deprecated, use extensions.add() instead.\"), extensions.add({\n      type: ExtensionType.Loader,\n      ref: t\n    }), r;\n  }, r._plugins = [], r;\n}();\nextensions.handleByList(ExtensionType.Loader, Loader._plugins);\nLoader.prototype.add = function(t, e, o, T) {\n  if (Array.isArray(t)) {\n    for (var S = 0; S < t.length; ++S)\n      this.add(t[S]);\n    return this;\n  }\n  if (typeof t == \"object\" && (o = t, T = e || o.callback || o.onComplete, e = o.url, t = o.name || o.key || o.url), typeof e != \"string\" && (T = o, o = e, e = t), typeof e != \"string\")\n    throw new Error(\"No url passed to add resource to loader.\");\n  return typeof o == \"function\" && (T = o, o = null), this._add(t, e, o, T);\n};\nvar AppLoaderPlugin = function() {\n  function r() {\n  }\n  return r.init = function(t) {\n    t = Object.assign({\n      sharedLoader: !1\n    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();\n  }, r.destroy = function() {\n    this.loader && (this.loader.destroy(), this.loader = null);\n  }, r.extension = ExtensionType.Application, r;\n}(), TextureLoader = function() {\n  function r() {\n  }\n  return r.add = function() {\n    LoaderResource.setExtensionLoadType(\"svg\", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType(\"svg\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, r.use = function(t, e) {\n    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === \"svg\")) {\n      var o = t.data, T = t.url, S = t.name, N = t.metadata;\n      Texture.fromLoader(o, T, S, N).then(function(D) {\n        t.texture = D, e();\n      }).catch(e);\n    } else\n      e();\n  }, r.extension = ExtensionType.Loader, r;\n}(), _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction encodeBinary(r) {\n  for (var t = \"\", e = 0; e < r.length; ) {\n    for (var o = [0, 0, 0], T = [0, 0, 0, 0], S = 0; S < o.length; ++S)\n      e < r.length ? o[S] = r.charCodeAt(e++) & 255 : o[S] = 0;\n    T[0] = o[0] >> 2, T[1] = (o[0] & 3) << 4 | o[1] >> 4, T[2] = (o[1] & 15) << 2 | o[2] >> 6, T[3] = o[2] & 63;\n    var N = e - (r.length - 1);\n    switch (N) {\n      case 2:\n        T[3] = 64, T[2] = 64;\n        break;\n      case 1:\n        T[3] = 64;\n        break;\n    }\n    for (var S = 0; S < T.length; ++S)\n      t += _keyStr.charAt(T[S]);\n  }\n  return t;\n}\nfunction parsing(r, t) {\n  if (!r.data) {\n    t();\n    return;\n  }\n  if (r.xhr && r.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof r.data == \"string\") {\n      var e = r.xhr.getResponseHeader(\"content-type\");\n      if (e && e.indexOf(\"image\") === 0) {\n        r.data = new Image(), r.data.src = \"data:\" + e + \";base64,\" + encodeBinary(r.xhr.responseText), r.type = LoaderResource.TYPE.IMAGE, r.data.onload = function() {\n          r.data.onload = null, t();\n        };\n        return;\n      }\n    } else if (r.data.type.indexOf(\"image\") === 0) {\n      var o = globalThis.URL || globalThis.webkitURL, T = o.createObjectURL(r.data);\n      r.blob = r.data, r.data = new Image(), r.data.src = T, r.type = LoaderResource.TYPE.IMAGE, r.data.onload = function() {\n        o.revokeObjectURL(T), r.data.onload = null, t();\n      };\n      return;\n    }\n  }\n  t();\n}\nvar ParsingLoader = function() {\n  function r() {\n  }\n  return r.extension = ExtensionType.Loader, r.use = parsing, r;\n}();\nextensions.add(TextureLoader, ParsingLoader);\n/*!\n * @pixi/compressed-textures - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/compressed-textures is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _a$2, INTERNAL_FORMATS;\n(function(r) {\n  r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\", r[r.COMPRESSED_R11_EAC = 37488] = \"COMPRESSED_R11_EAC\", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = \"COMPRESSED_SIGNED_R11_EAC\", r[r.COMPRESSED_RG11_EAC = 37490] = \"COMPRESSED_RG11_EAC\", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\", r[r.COMPRESSED_RGB8_ETC2 = 37492] = \"COMPRESSED_RGB8_ETC2\", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\", r[r.COMPRESSED_SRGB8_ETC2 = 37493] = \"COMPRESSED_SRGB8_ETC2\", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\";\n})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));\nvar INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$n = function(r, t) {\n  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$n(r, t);\n};\nfunction __extends$n(r, t) {\n  extendStatics$n(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction __awaiter(r, t, e, o) {\n  function T(S) {\n    return S instanceof e ? S : new e(function(N) {\n      N(S);\n    });\n  }\n  return new (e || (e = Promise))(function(S, N) {\n    function D(U) {\n      try {\n        $(o.next(U));\n      } catch (z) {\n        N(z);\n      }\n    }\n    function B(U) {\n      try {\n        $(o.throw(U));\n      } catch (z) {\n        N(z);\n      }\n    }\n    function $(U) {\n      U.done ? S(U.value) : T(U.value).then(D, B);\n    }\n    $((o = o.apply(r, t || [])).next());\n  });\n}\nfunction __generator(r, t) {\n  var e = { label: 0, sent: function() {\n    if (S[0] & 1)\n      throw S[1];\n    return S[1];\n  }, trys: [], ops: [] }, o, T, S, N;\n  return N = { next: D(0), throw: D(1), return: D(2) }, typeof Symbol == \"function\" && (N[Symbol.iterator] = function() {\n    return this;\n  }), N;\n  function D($) {\n    return function(U) {\n      return B([$, U]);\n    };\n  }\n  function B($) {\n    if (o)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; e; )\n      try {\n        if (o = 1, T && (S = $[0] & 2 ? T.return : $[0] ? T.throw || ((S = T.return) && S.call(T), 0) : T.next) && !(S = S.call(T, $[1])).done)\n          return S;\n        switch (T = 0, S && ($ = [$[0] & 2, S.value]), $[0]) {\n          case 0:\n          case 1:\n            S = $;\n            break;\n          case 4:\n            return e.label++, { value: $[1], done: !1 };\n          case 5:\n            e.label++, T = $[1], $ = [0];\n            continue;\n          case 7:\n            $ = e.ops.pop(), e.trys.pop();\n            continue;\n          default:\n            if (S = e.trys, !(S = S.length > 0 && S[S.length - 1]) && ($[0] === 6 || $[0] === 2)) {\n              e = 0;\n              continue;\n            }\n            if ($[0] === 3 && (!S || $[1] > S[0] && $[1] < S[3])) {\n              e.label = $[1];\n              break;\n            }\n            if ($[0] === 6 && e.label < S[1]) {\n              e.label = S[1], S = $;\n              break;\n            }\n            if (S && e.label < S[2]) {\n              e.label = S[2], e.ops.push($);\n              break;\n            }\n            S[2] && e.ops.pop(), e.trys.pop();\n            continue;\n        }\n        $ = t.call(r, e);\n      } catch (U) {\n        $ = [6, U], T = 0;\n      } finally {\n        o = S = 0;\n      }\n    if ($[0] & 5)\n      throw $[1];\n    return { value: $[0] ? $[1] : void 0, done: !0 };\n  }\n}\nvar BlobResource = function(r) {\n  __extends$n(t, r);\n  function t(e, o) {\n    o === void 0 && (o = { width: 1, height: 1, autoLoad: !0 });\n    var T = this, S, N;\n    return typeof e == \"string\" ? (S = e, N = new Uint8Array()) : (S = null, N = e), T = r.call(this, N, o) || this, T.origin = S, T.buffer = N ? new ViewableBuffer(N) : null, T.origin && o.autoLoad !== !1 && T.load(), N && N.length && (T.loaded = !0, T.onBlobLoaded(T.buffer.rawBinaryData)), T;\n  }\n  return t.prototype.onBlobLoaded = function(e) {\n  }, t.prototype.load = function() {\n    return __awaiter(this, void 0, Promise, function() {\n      var e, o, T;\n      return __generator(this, function(S) {\n        switch (S.label) {\n          case 0:\n            return [4, fetch(this.origin)];\n          case 1:\n            return e = S.sent(), [4, e.blob()];\n          case 2:\n            return o = S.sent(), [4, o.arrayBuffer()];\n          case 3:\n            return T = S.sent(), this.data = new Uint32Array(T), this.buffer = new ViewableBuffer(T), this.loaded = !0, this.onBlobLoaded(T), this.update(), [2, this];\n        }\n      });\n    });\n  }, t;\n}(BufferResource), CompressedTextureResource = function(r) {\n  __extends$n(t, r);\n  function t(e, o) {\n    var T = r.call(this, e, o) || this;\n    return T.format = o.format, T.levels = o.levels || 1, T._width = o.width, T._height = o.height, T._extension = t._formatToExtension(T.format), (o.levelBuffers || T.buffer) && (T._levelBuffers = o.levelBuffers || t._createLevelBuffers(\n      e instanceof Uint8Array ? e : T.buffer.uint8View,\n      T.format,\n      T.levels,\n      4,\n      4,\n      T.width,\n      T.height\n    )), T;\n  }\n  return t.prototype.upload = function(e, o, T) {\n    var S = e.gl, N = e.context.extensions[this._extension];\n    if (!N)\n      throw new Error(this._extension + \" textures are not supported on the current machine\");\n    if (!this._levelBuffers)\n      return !1;\n    for (var D = 0, B = this.levels; D < B; D++) {\n      var $ = this._levelBuffers[D], U = $.levelID, z = $.levelWidth, V = $.levelHeight, X = $.levelBuffer;\n      S.compressedTexImage2D(S.TEXTURE_2D, U, this.format, z, V, 0, X);\n    }\n    return !0;\n  }, t.prototype.onBlobLoaded = function() {\n    this._levelBuffers = t._createLevelBuffers(\n      this.buffer.uint8View,\n      this.format,\n      this.levels,\n      4,\n      4,\n      this.width,\n      this.height\n    );\n  }, t._formatToExtension = function(e) {\n    if (e >= 33776 && e <= 33779)\n      return \"s3tc\";\n    if (e >= 37488 && e <= 37497)\n      return \"etc\";\n    if (e >= 35840 && e <= 35843)\n      return \"pvrtc\";\n    if (e >= 36196)\n      return \"etc1\";\n    if (e >= 35986 && e <= 34798)\n      return \"atc\";\n    throw new Error(\"Invalid (compressed) texture format given!\");\n  }, t._createLevelBuffers = function(e, o, T, S, N, D, B) {\n    for (var $ = new Array(T), U = e.byteOffset, z = D, V = B, X = z + S - 1 & ~(S - 1), W = V + N - 1 & ~(N - 1), Y = X * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o], q = 0; q < T; q++)\n      $[q] = {\n        levelID: q,\n        levelWidth: T > 1 ? z : X,\n        levelHeight: T > 1 ? V : W,\n        levelBuffer: new Uint8Array(e.buffer, U, Y)\n      }, U += Y, z = z >> 1 || 1, V = V >> 1 || 1, X = z + S - 1 & ~(S - 1), W = V + N - 1 & ~(N - 1), Y = X * W * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o];\n    return $;\n  }, t;\n}(BlobResource), CompressedTextureLoader = function() {\n  function r() {\n  }\n  return r.use = function(t, e) {\n    var o = t.data, T = this;\n    if (t.type === LoaderResource.TYPE.JSON && o && o.cacheID && o.textures) {\n      for (var S = o.textures, N = void 0, D = void 0, B = 0, $ = S.length; B < $; B++) {\n        var U = S[B], z = U.src, V = U.format;\n        if (V || (D = z), r.textureFormats[V]) {\n          N = z;\n          break;\n        }\n      }\n      if (N = N || D, !N) {\n        e(new Error(\"Cannot load compressed-textures in \" + t.url + \", make sure you provide a fallback\"));\n        return;\n      }\n      if (N === t.url) {\n        e(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n        return;\n      }\n      var X = {\n        crossOrigin: t.crossOrigin,\n        metadata: t.metadata.imageMetadata,\n        parentResource: t\n      }, W = url$1.resolve(t.url.replace(T.baseUrl, \"\"), N), Y = o.cacheID;\n      T.add(Y, W, X, function(q) {\n        if (q.error) {\n          e(q.error);\n          return;\n        }\n        var Z = q.texture, K = Z === void 0 ? null : Z, J = q.textures, tt = J === void 0 ? {} : J;\n        Object.assign(t, { texture: K, textures: tt }), e();\n      });\n    } else\n      e();\n  }, Object.defineProperty(r, \"textureExtensions\", {\n    get: function() {\n      if (!r._textureExtensions) {\n        var t = settings$1.ADAPTER.createCanvas(), e = t.getContext(\"webgl\");\n        if (!e)\n          return console.warn(\"WebGL not available for compressed textures. Silently failing.\"), {};\n        var o = {\n          s3tc: e.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n          s3tc_sRGB: e.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n          etc: e.getExtension(\"WEBGL_compressed_texture_etc\"),\n          etc1: e.getExtension(\"WEBGL_compressed_texture_etc1\"),\n          pvrtc: e.getExtension(\"WEBGL_compressed_texture_pvrtc\") || e.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n          atc: e.getExtension(\"WEBGL_compressed_texture_atc\"),\n          astc: e.getExtension(\"WEBGL_compressed_texture_astc\")\n        };\n        r._textureExtensions = o;\n      }\n      return r._textureExtensions;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"textureFormats\", {\n    get: function() {\n      if (!r._textureFormats) {\n        var t = r.textureExtensions;\n        r._textureFormats = {};\n        for (var e in t) {\n          var o = t[e];\n          !o || Object.assign(r._textureFormats, Object.getPrototypeOf(o));\n        }\n      }\n      return r._textureFormats;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.extension = ExtensionType.Loader, r;\n}();\nfunction registerCompressedTextures(r, t, e) {\n  var o = {\n    textures: {},\n    texture: null\n  };\n  if (!t)\n    return o;\n  var T = t.map(function(S) {\n    return new Texture(new BaseTexture(S, Object.assign({\n      mipmap: MIPMAP_MODES$5.OFF,\n      alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA\n    }, e)));\n  });\n  return T.forEach(function(S, N) {\n    var D = S.baseTexture, B = r + \"-\" + (N + 1);\n    BaseTexture.addToCache(D, B), Texture.addToCache(S, B), N === 0 && (BaseTexture.addToCache(D, r), Texture.addToCache(S, r), o.texture = S), o.textures[B] = S;\n  }), o;\n}\nvar _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, DXGI_FORMAT;\n(function(r) {\n  r[r.DXGI_FORMAT_UNKNOWN = 0] = \"DXGI_FORMAT_UNKNOWN\", r[r.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\", r[r.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\", r[r.DXGI_FORMAT_R32G32B32A32_UINT = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\", r[r.DXGI_FORMAT_R32G32B32A32_SINT = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\", r[r.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\", r[r.DXGI_FORMAT_R32G32B32_FLOAT = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\", r[r.DXGI_FORMAT_R32G32B32_UINT = 7] = \"DXGI_FORMAT_R32G32B32_UINT\", r[r.DXGI_FORMAT_R32G32B32_SINT = 8] = \"DXGI_FORMAT_R32G32B32_SINT\", r[r.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\", r[r.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\", r[r.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\", r[r.DXGI_FORMAT_R16G16B16A16_UINT = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\", r[r.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\", r[r.DXGI_FORMAT_R16G16B16A16_SINT = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\", r[r.DXGI_FORMAT_R32G32_TYPELESS = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\", r[r.DXGI_FORMAT_R32G32_FLOAT = 16] = \"DXGI_FORMAT_R32G32_FLOAT\", r[r.DXGI_FORMAT_R32G32_UINT = 17] = \"DXGI_FORMAT_R32G32_UINT\", r[r.DXGI_FORMAT_R32G32_SINT = 18] = \"DXGI_FORMAT_R32G32_SINT\", r[r.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\", r[r.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\", r[r.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\", r[r.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\", r[r.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\", r[r.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\", r[r.DXGI_FORMAT_R10G10B10A2_UINT = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\", r[r.DXGI_FORMAT_R11G11B10_FLOAT = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\", r[r.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\", r[r.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\", r[r.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\", r[r.DXGI_FORMAT_R8G8B8A8_UINT = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\", r[r.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\", r[r.DXGI_FORMAT_R8G8B8A8_SINT = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\", r[r.DXGI_FORMAT_R16G16_TYPELESS = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\", r[r.DXGI_FORMAT_R16G16_FLOAT = 34] = \"DXGI_FORMAT_R16G16_FLOAT\", r[r.DXGI_FORMAT_R16G16_UNORM = 35] = \"DXGI_FORMAT_R16G16_UNORM\", r[r.DXGI_FORMAT_R16G16_UINT = 36] = \"DXGI_FORMAT_R16G16_UINT\", r[r.DXGI_FORMAT_R16G16_SNORM = 37] = \"DXGI_FORMAT_R16G16_SNORM\", r[r.DXGI_FORMAT_R16G16_SINT = 38] = \"DXGI_FORMAT_R16G16_SINT\", r[r.DXGI_FORMAT_R32_TYPELESS = 39] = \"DXGI_FORMAT_R32_TYPELESS\", r[r.DXGI_FORMAT_D32_FLOAT = 40] = \"DXGI_FORMAT_D32_FLOAT\", r[r.DXGI_FORMAT_R32_FLOAT = 41] = \"DXGI_FORMAT_R32_FLOAT\", r[r.DXGI_FORMAT_R32_UINT = 42] = \"DXGI_FORMAT_R32_UINT\", r[r.DXGI_FORMAT_R32_SINT = 43] = \"DXGI_FORMAT_R32_SINT\", r[r.DXGI_FORMAT_R24G8_TYPELESS = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\", r[r.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\", r[r.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\", r[r.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\", r[r.DXGI_FORMAT_R8G8_TYPELESS = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\", r[r.DXGI_FORMAT_R8G8_UNORM = 49] = \"DXGI_FORMAT_R8G8_UNORM\", r[r.DXGI_FORMAT_R8G8_UINT = 50] = \"DXGI_FORMAT_R8G8_UINT\", r[r.DXGI_FORMAT_R8G8_SNORM = 51] = \"DXGI_FORMAT_R8G8_SNORM\", r[r.DXGI_FORMAT_R8G8_SINT = 52] = \"DXGI_FORMAT_R8G8_SINT\", r[r.DXGI_FORMAT_R16_TYPELESS = 53] = \"DXGI_FORMAT_R16_TYPELESS\", r[r.DXGI_FORMAT_R16_FLOAT = 54] = \"DXGI_FORMAT_R16_FLOAT\", r[r.DXGI_FORMAT_D16_UNORM = 55] = \"DXGI_FORMAT_D16_UNORM\", r[r.DXGI_FORMAT_R16_UNORM = 56] = \"DXGI_FORMAT_R16_UNORM\", r[r.DXGI_FORMAT_R16_UINT = 57] = \"DXGI_FORMAT_R16_UINT\", r[r.DXGI_FORMAT_R16_SNORM = 58] = \"DXGI_FORMAT_R16_SNORM\", r[r.DXGI_FORMAT_R16_SINT = 59] = \"DXGI_FORMAT_R16_SINT\", r[r.DXGI_FORMAT_R8_TYPELESS = 60] = \"DXGI_FORMAT_R8_TYPELESS\", r[r.DXGI_FORMAT_R8_UNORM = 61] = \"DXGI_FORMAT_R8_UNORM\", r[r.DXGI_FORMAT_R8_UINT = 62] = \"DXGI_FORMAT_R8_UINT\", r[r.DXGI_FORMAT_R8_SNORM = 63] = \"DXGI_FORMAT_R8_SNORM\", r[r.DXGI_FORMAT_R8_SINT = 64] = \"DXGI_FORMAT_R8_SINT\", r[r.DXGI_FORMAT_A8_UNORM = 65] = \"DXGI_FORMAT_A8_UNORM\", r[r.DXGI_FORMAT_R1_UNORM = 66] = \"DXGI_FORMAT_R1_UNORM\", r[r.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\", r[r.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\", r[r.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\", r[r.DXGI_FORMAT_BC1_TYPELESS = 70] = \"DXGI_FORMAT_BC1_TYPELESS\", r[r.DXGI_FORMAT_BC1_UNORM = 71] = \"DXGI_FORMAT_BC1_UNORM\", r[r.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\", r[r.DXGI_FORMAT_BC2_TYPELESS = 73] = \"DXGI_FORMAT_BC2_TYPELESS\", r[r.DXGI_FORMAT_BC2_UNORM = 74] = \"DXGI_FORMAT_BC2_UNORM\", r[r.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\", r[r.DXGI_FORMAT_BC3_TYPELESS = 76] = \"DXGI_FORMAT_BC3_TYPELESS\", r[r.DXGI_FORMAT_BC3_UNORM = 77] = \"DXGI_FORMAT_BC3_UNORM\", r[r.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\", r[r.DXGI_FORMAT_BC4_TYPELESS = 79] = \"DXGI_FORMAT_BC4_TYPELESS\", r[r.DXGI_FORMAT_BC4_UNORM = 80] = \"DXGI_FORMAT_BC4_UNORM\", r[r.DXGI_FORMAT_BC4_SNORM = 81] = \"DXGI_FORMAT_BC4_SNORM\", r[r.DXGI_FORMAT_BC5_TYPELESS = 82] = \"DXGI_FORMAT_BC5_TYPELESS\", r[r.DXGI_FORMAT_BC5_UNORM = 83] = \"DXGI_FORMAT_BC5_UNORM\", r[r.DXGI_FORMAT_BC5_SNORM = 84] = \"DXGI_FORMAT_BC5_SNORM\", r[r.DXGI_FORMAT_B5G6R5_UNORM = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\", r[r.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\", r[r.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\", r[r.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\", r[r.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\", r[r.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\", r[r.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\", r[r.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\", r[r.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\", r[r.DXGI_FORMAT_BC6H_TYPELESS = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\", r[r.DXGI_FORMAT_BC6H_UF16 = 95] = \"DXGI_FORMAT_BC6H_UF16\", r[r.DXGI_FORMAT_BC6H_SF16 = 96] = \"DXGI_FORMAT_BC6H_SF16\", r[r.DXGI_FORMAT_BC7_TYPELESS = 97] = \"DXGI_FORMAT_BC7_TYPELESS\", r[r.DXGI_FORMAT_BC7_UNORM = 98] = \"DXGI_FORMAT_BC7_UNORM\", r[r.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\", r[r.DXGI_FORMAT_AYUV = 100] = \"DXGI_FORMAT_AYUV\", r[r.DXGI_FORMAT_Y410 = 101] = \"DXGI_FORMAT_Y410\", r[r.DXGI_FORMAT_Y416 = 102] = \"DXGI_FORMAT_Y416\", r[r.DXGI_FORMAT_NV12 = 103] = \"DXGI_FORMAT_NV12\", r[r.DXGI_FORMAT_P010 = 104] = \"DXGI_FORMAT_P010\", r[r.DXGI_FORMAT_P016 = 105] = \"DXGI_FORMAT_P016\", r[r.DXGI_FORMAT_420_OPAQUE = 106] = \"DXGI_FORMAT_420_OPAQUE\", r[r.DXGI_FORMAT_YUY2 = 107] = \"DXGI_FORMAT_YUY2\", r[r.DXGI_FORMAT_Y210 = 108] = \"DXGI_FORMAT_Y210\", r[r.DXGI_FORMAT_Y216 = 109] = \"DXGI_FORMAT_Y216\", r[r.DXGI_FORMAT_NV11 = 110] = \"DXGI_FORMAT_NV11\", r[r.DXGI_FORMAT_AI44 = 111] = \"DXGI_FORMAT_AI44\", r[r.DXGI_FORMAT_IA44 = 112] = \"DXGI_FORMAT_IA44\", r[r.DXGI_FORMAT_P8 = 113] = \"DXGI_FORMAT_P8\", r[r.DXGI_FORMAT_A8P8 = 114] = \"DXGI_FORMAT_A8P8\", r[r.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\", r[r.DXGI_FORMAT_P208 = 116] = \"DXGI_FORMAT_P208\", r[r.DXGI_FORMAT_V208 = 117] = \"DXGI_FORMAT_V208\", r[r.DXGI_FORMAT_V408 = 118] = \"DXGI_FORMAT_V408\", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\", r[r.DXGI_FORMAT_FORCE_UINT = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(DXGI_FORMAT || (DXGI_FORMAT = {}));\nvar D3D10_RESOURCE_DIMENSION;\n(function(r) {\n  r[r.DDS_DIMENSION_TEXTURE1D = 2] = \"DDS_DIMENSION_TEXTURE1D\", r[r.DDS_DIMENSION_TEXTURE2D = 3] = \"DDS_DIMENSION_TEXTURE2D\", r[r.DDS_DIMENSION_TEXTURE3D = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));\nvar PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);\nfunction parseDDS(r) {\n  var t = new Uint32Array(r), e = t[0];\n  if (e !== DDS_MAGIC)\n    throw new Error(\"Invalid DDS file magic word\");\n  var o = new Uint32Array(r, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), T = o[DDS_FIELDS.HEIGHT], S = o[DDS_FIELDS.WIDTH], N = o[DDS_FIELDS.MIPMAP_COUNT], D = new Uint32Array(r, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), B = D[PF_FLAGS];\n  if (B & DDPF_FOURCC) {\n    var $ = D[DDS_PF_FIELDS.FOURCC];\n    if ($ !== FOURCC_DX10) {\n      var U = FOURCC_TO_FORMAT[$], z = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint8Array(r, z), X = new CompressedTextureResource(V, {\n        format: U,\n        width: S,\n        height: T,\n        levels: N\n      });\n      return [X];\n    }\n    var W = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, Y = new Uint32Array(t.buffer, W, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), q = Y[DDS_DX10_FIELDS.DXGI_FORMAT], Z = Y[DDS_DX10_FIELDS.RESOURCE_DIMENSION], K = Y[DDS_DX10_FIELDS.MISC_FLAG], J = Y[DDS_DX10_FIELDS.ARRAY_SIZE], tt = DXGI_TO_FORMAT[q];\n    if (tt === void 0)\n      throw new Error(\"DDSParser cannot parse texture data with DXGI format \" + q);\n    if (K === DDS_RESOURCE_MISC_TEXTURECUBE)\n      throw new Error(\"DDSParser does not support cubemap textures\");\n    if (Z === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n      throw new Error(\"DDSParser does not supported 3D texture data\");\n    var et = new Array(), Q = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (J === 1)\n      et.push(new Uint8Array(r, Q));\n    else {\n      for (var at = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[tt], it = 0, st = S, ut = T, ft = 0; ft < N; ft++) {\n        var ct = Math.max(1, st + 3 & -4), pt = Math.max(1, ut + 3 & -4), mt = ct * pt * at;\n        it += mt, st = st >>> 1, ut = ut >>> 1;\n      }\n      for (var vt = Q, ft = 0; ft < J; ft++)\n        et.push(new Uint8Array(r, vt, it)), vt += it;\n    }\n    return et.map(function(_t) {\n      return new CompressedTextureResource(_t, {\n        format: tt,\n        width: S,\n        height: T,\n        levels: N\n      });\n    });\n  }\n  throw B & DDPF_RGB ? new Error(\"DDSParser does not support uncompressed texture data.\") : B & DDPF_YUV ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : B & DDPF_LUMINANCE ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : B & DDPF_ALPHA ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nvar _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$5.UNSIGNED_BYTE] = 1, _a$3[TYPES$5.UNSIGNED_SHORT] = 2, _a$3[TYPES$5.INT] = 4, _a$3[TYPES$5.UNSIGNED_INT] = 4, _a$3[TYPES$5.FLOAT] = 4, _a$3[TYPES$5.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$5.RGBA] = 4, _b[FORMATS$5.RGB] = 3, _b[FORMATS$5.RG] = 2, _b[FORMATS$5.RED] = 1, _b[FORMATS$5.LUMINANCE] = 1, _b[FORMATS$5.LUMINANCE_ALPHA] = 2, _b[FORMATS$5.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_6_5] = 2, _c);\nfunction parseKTX(r, t, e) {\n  e === void 0 && (e = !1);\n  var o = new DataView(t);\n  if (!validate(r, o))\n    return null;\n  var T = o.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, S = o.getUint32(KTX_FIELDS.GL_TYPE, T), N = o.getUint32(KTX_FIELDS.GL_FORMAT, T), D = o.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, T), B = o.getUint32(KTX_FIELDS.PIXEL_WIDTH, T), $ = o.getUint32(KTX_FIELDS.PIXEL_HEIGHT, T) || 1, U = o.getUint32(KTX_FIELDS.PIXEL_DEPTH, T) || 1, z = o.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, T) || 1, V = o.getUint32(KTX_FIELDS.NUMBER_OF_FACES, T), X = o.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, T), W = o.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, T);\n  if ($ === 0 || U !== 1)\n    throw new Error(\"Only 2D textures are supported\");\n  if (V !== 1)\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  if (z !== 1)\n    throw new Error(\"WebGL does not support array textures\");\n  var Y = 4, q = 4, Z = B + 3 & -4, K = $ + 3 & -4, J = new Array(z), tt = B * $;\n  S === 0 && (tt = Z * K);\n  var et;\n  if (S !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[S] ? et = TYPES_TO_BYTES_PER_COMPONENT[S] * FORMATS_TO_COMPONENTS[N] : et = TYPES_TO_BYTES_PER_PIXEL[S] : et = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[D], et === void 0)\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  for (var Q = e ? parseKvData(o, W, T) : null, at = tt * et, it = at, st = B, ut = $, ft = Z, ct = K, pt = FILE_HEADER_SIZE + W, mt = 0; mt < X; mt++) {\n    for (var vt = o.getUint32(pt, T), _t = pt + 4, xt = 0; xt < z; xt++) {\n      var Rt = J[xt];\n      Rt || (Rt = J[xt] = new Array(X)), Rt[mt] = {\n        levelID: mt,\n        levelWidth: X > 1 || S !== 0 ? st : ft,\n        levelHeight: X > 1 || S !== 0 ? ut : ct,\n        levelBuffer: new Uint8Array(t, _t, it)\n      }, _t += it;\n    }\n    pt += vt + 4, pt = pt % 4 !== 0 ? pt + 4 - pt % 4 : pt, st = st >> 1 || 1, ut = ut >> 1 || 1, ft = st + Y - 1 & ~(Y - 1), ct = ut + q - 1 & ~(q - 1), it = ft * ct * et;\n  }\n  return S !== 0 ? {\n    uncompressed: J.map(function(yt) {\n      var ht = yt[0].levelBuffer, bt = !1;\n      return S === TYPES$5.FLOAT ? ht = new Float32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4) : S === TYPES$5.UNSIGNED_INT ? (bt = !0, ht = new Uint32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4)) : S === TYPES$5.INT && (bt = !0, ht = new Int32Array(yt[0].levelBuffer.buffer, yt[0].levelBuffer.byteOffset, yt[0].levelBuffer.byteLength / 4)), {\n        resource: new BufferResource(ht, {\n          width: yt[0].levelWidth,\n          height: yt[0].levelHeight\n        }),\n        type: S,\n        format: bt ? convertFormatToInteger(N) : N\n      };\n    }),\n    kvData: Q\n  } : {\n    compressed: J.map(function(yt) {\n      return new CompressedTextureResource(null, {\n        format: D,\n        width: B,\n        height: $,\n        levels: X,\n        levelBuffers: yt\n      });\n    }),\n    kvData: Q\n  };\n}\nfunction validate(r, t) {\n  for (var e = 0; e < FILE_IDENTIFIER.length; e++)\n    if (t.getUint8(e) !== FILE_IDENTIFIER[e])\n      return console.error(r + \" is not a valid *.ktx file!\"), !1;\n  return !0;\n}\nfunction convertFormatToInteger(r) {\n  switch (r) {\n    case FORMATS$5.RGBA:\n      return FORMATS$5.RGBA_INTEGER;\n    case FORMATS$5.RGB:\n      return FORMATS$5.RGB_INTEGER;\n    case FORMATS$5.RG:\n      return FORMATS$5.RG_INTEGER;\n    case FORMATS$5.RED:\n      return FORMATS$5.RED_INTEGER;\n    default:\n      return r;\n  }\n}\nfunction parseKvData(r, t, e) {\n  for (var o = /* @__PURE__ */ new Map(), T = 0; T < t; ) {\n    var S = r.getUint32(FILE_HEADER_SIZE + T, e), N = FILE_HEADER_SIZE + T + 4, D = 3 - (S + 3) % 4;\n    if (S === 0 || S > t - T) {\n      console.error(\"KTXLoader: keyAndValueByteSize out of bounds\");\n      break;\n    }\n    for (var B = 0; B < S && r.getUint8(N + B) !== 0; B++)\n      ;\n    if (B === -1) {\n      console.error(\"KTXLoader: Failed to find null byte terminating kvData key\");\n      break;\n    }\n    var $ = new TextDecoder().decode(new Uint8Array(r.buffer, N, B)), U = new DataView(r.buffer, N + B + 1, S - B - 1);\n    o.set($, U), T += 4 + S + D;\n  }\n  return o;\n}\nLoaderResource.setExtensionXhrType(\"dds\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar DDSLoader = function() {\n  function r() {\n  }\n  return r.use = function(t, e) {\n    if (t.extension === \"dds\" && t.data)\n      try {\n        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));\n      } catch (o) {\n        e(o);\n        return;\n      }\n    e();\n  }, r.extension = ExtensionType.Loader, r;\n}();\nLoaderResource.setExtensionXhrType(\"ktx\", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\nvar KTXLoader = function() {\n  function r() {\n  }\n  return r.use = function(t, e) {\n    if (t.extension === \"ktx\" && t.data)\n      try {\n        var o = t.name || t.url, T = parseKTX(o, t.data, this.loadKeyValueData), S = T.compressed, N = T.uncompressed, D = T.kvData;\n        if (S) {\n          var B = registerCompressedTextures(o, S, t.metadata);\n          if (D && B.textures)\n            for (var $ in B.textures)\n              B.textures[$].baseTexture.ktxKeyValueData = D;\n          Object.assign(t, B);\n        } else if (N) {\n          var U = {};\n          N.forEach(function(z, V) {\n            var X = new Texture(new BaseTexture(z.resource, {\n              mipmap: MIPMAP_MODES$5.OFF,\n              alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA,\n              type: z.type,\n              format: z.format\n            })), W = o + \"-\" + (V + 1);\n            D && (X.baseTexture.ktxKeyValueData = D), BaseTexture.addToCache(X.baseTexture, W), Texture.addToCache(X, W), V === 0 && (U[o] = X, BaseTexture.addToCache(X.baseTexture, o), Texture.addToCache(X, o)), U[W] = X;\n          }), Object.assign(t, { textures: U });\n        }\n      } catch (z) {\n        e(z);\n        return;\n      }\n    e();\n  }, r.extension = ExtensionType.Loader, r.loadKeyValueData = !1, r;\n}();\n/*!\n * @pixi/particle-container - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/particle-container is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$m = function(r, t) {\n  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$m(r, t);\n};\nfunction __extends$m(r, t) {\n  extendStatics$m(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\n(function(r) {\n  __extends$m(t, r);\n  function t(e, o, T, S) {\n    e === void 0 && (e = 1500), T === void 0 && (T = 16384), S === void 0 && (S = !1);\n    var N = r.call(this) || this, D = 16384;\n    return T > D && (T = D), N._properties = [!1, !0, !1, !1, !1], N._maxSize = e, N._batchSize = T, N._buffers = null, N._bufferUpdateIDs = [], N._updateID = 0, N.interactiveChildren = !1, N.blendMode = BLEND_MODES$5.NORMAL, N.autoResize = S, N.roundPixels = !0, N.baseTexture = null, N.setProperties(o), N._tint = 0, N.tintRgb = new Float32Array(4), N.tint = 16777215, N;\n  }\n  return t.prototype.setProperties = function(e) {\n    e && (this._properties[0] = \"vertices\" in e || \"scale\" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = \"position\" in e ? !!e.position : this._properties[1], this._properties[2] = \"rotation\" in e ? !!e.rotation : this._properties[2], this._properties[3] = \"uvs\" in e ? !!e.uvs : this._properties[3], this._properties[4] = \"tint\" in e || \"alpha\" in e ? !!e.tint || !!e.alpha : this._properties[4]);\n  }, t.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, hex2rgb(e, this.tintRgb);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.render = function(e) {\n    var o = this;\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", function() {\n      return o.onChildrenChange(0);\n    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));\n  }, t.prototype.onChildrenChange = function(e) {\n    for (var o = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < o; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[o] = ++this._updateID;\n  }, t.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var e = 0; e < this._buffers.length; ++e)\n        this._buffers[e].destroy();\n      this._buffers = null;\n    }\n  }, t.prototype.destroy = function(e) {\n    r.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }, t;\n})(Container);\nvar ParticleBuffer = function() {\n  function r(t, e, o) {\n    this.geometry = new Geometry(), this.indexBuffer = null, this.size = o, this.dynamicProperties = [], this.staticProperties = [];\n    for (var T = 0; T < t.length; ++T) {\n      var S = t[T];\n      S = {\n        attributeName: S.attributeName,\n        size: S.size,\n        uploadFunction: S.uploadFunction,\n        type: S.type || TYPES$5.FLOAT,\n        offset: S.offset\n      }, e[T] ? this.dynamicProperties.push(S) : this.staticProperties.push(S);\n    }\n    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n  }\n  return r.prototype.initBuffers = function() {\n    var t = this.geometry, e = 0;\n    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;\n    for (var o = 0; o < this.dynamicProperties.length; ++o) {\n      var T = this.dynamicProperties[o];\n      T.offset = e, e += T.size, this.dynamicStride += T.size;\n    }\n    var S = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(S), this.dynamicDataUint32 = new Uint32Array(S), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);\n    var N = 0;\n    this.staticStride = 0;\n    for (var o = 0; o < this.staticProperties.length; ++o) {\n      var T = this.staticProperties[o];\n      T.offset = N, N += T.size, this.staticStride += T.size;\n    }\n    var D = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(D), this.staticDataUint32 = new Uint32Array(D), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);\n    for (var o = 0; o < this.dynamicProperties.length; ++o) {\n      var T = this.dynamicProperties[o];\n      t.addAttribute(T.attributeName, this.dynamicBuffer, 0, T.type === TYPES$5.UNSIGNED_BYTE, T.type, this.dynamicStride * 4, T.offset * 4);\n    }\n    for (var o = 0; o < this.staticProperties.length; ++o) {\n      var T = this.staticProperties[o];\n      t.addAttribute(T.attributeName, this.staticBuffer, 0, T.type === TYPES$5.UNSIGNED_BYTE, T.type, this.staticStride * 4, T.offset * 4);\n    }\n  }, r.prototype.uploadDynamic = function(t, e, o) {\n    for (var T = 0; T < this.dynamicProperties.length; T++) {\n      var S = this.dynamicProperties[T];\n      S.uploadFunction(t, e, o, S.type === TYPES$5.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, S.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  }, r.prototype.uploadStatic = function(t, e, o) {\n    for (var T = 0; T < this.staticProperties.length; T++) {\n      var S = this.staticProperties[T];\n      S.uploadFunction(t, e, o, S.type === TYPES$5.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, S.offset);\n    }\n    this.staticBuffer._updateID++;\n  }, r.prototype.destroy = function() {\n    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n  }, r;\n}(), fragment$6 = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`, vertex$3 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`, ParticleRenderer = function(r) {\n  __extends$m(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return o.shader = null, o.properties = null, o.tempMatrix = new Matrix(), o.properties = [\n      {\n        attributeName: \"aVertexPosition\",\n        size: 2,\n        uploadFunction: o.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: \"aPositionCoord\",\n        size: 2,\n        uploadFunction: o.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: \"aRotation\",\n        size: 1,\n        uploadFunction: o.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: \"aTextureCoord\",\n        size: 2,\n        uploadFunction: o.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: \"aColor\",\n        size: 1,\n        type: TYPES$5.UNSIGNED_BYTE,\n        uploadFunction: o.uploadTint,\n        offset: 0\n      }\n    ], o.shader = Shader.from(vertex$3, fragment$6, {}), o.state = State.for2d(), o;\n  }\n  return t.prototype.render = function(e) {\n    var o = e.children, T = e._maxSize, S = e._batchSize, N = this.renderer, D = o.length;\n    if (D !== 0) {\n      D > T && !e.autoResize && (D = T);\n      var B = e._buffers;\n      B || (B = e._buffers = this.generateBuffers(e));\n      var $ = o[0]._texture.baseTexture, U = $.alphaMode > 0;\n      this.state.blendMode = correctBlendMode(e.blendMode, U), N.state.set(this.state);\n      var z = N.gl, V = e.worldTransform.copyTo(this.tempMatrix);\n      V.prepend(N.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = V.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, U), this.shader.uniforms.uSampler = $, this.renderer.shader.bind(this.shader);\n      for (var X = !1, W = 0, Y = 0; W < D; W += S, Y += 1) {\n        var q = D - W;\n        q > S && (q = S), Y >= B.length && B.push(this._generateOneMoreBuffer(e));\n        var Z = B[Y];\n        Z.uploadDynamic(o, W, q);\n        var K = e._bufferUpdateIDs[Y] || 0;\n        X = X || Z._updateID < K, X && (Z._updateID = e._updateID, Z.uploadStatic(o, W, q)), N.geometry.bind(Z.geometry), z.drawElements(z.TRIANGLES, q * 6, z.UNSIGNED_SHORT, 0);\n      }\n    }\n  }, t.prototype.generateBuffers = function(e) {\n    for (var o = [], T = e._maxSize, S = e._batchSize, N = e._properties, D = 0; D < T; D += S)\n      o.push(new ParticleBuffer(this.properties, N, S));\n    return o;\n  }, t.prototype._generateOneMoreBuffer = function(e) {\n    var o = e._batchSize, T = e._properties;\n    return new ParticleBuffer(this.properties, T, o);\n  }, t.prototype.uploadVertices = function(e, o, T, S, N, D) {\n    for (var B = 0, $ = 0, U = 0, z = 0, V = 0; V < T; ++V) {\n      var X = e[o + V], W = X._texture, Y = X.scale.x, q = X.scale.y, Z = W.trim, K = W.orig;\n      Z ? ($ = Z.x - X.anchor.x * K.width, B = $ + Z.width, z = Z.y - X.anchor.y * K.height, U = z + Z.height) : (B = K.width * (1 - X.anchor.x), $ = K.width * -X.anchor.x, U = K.height * (1 - X.anchor.y), z = K.height * -X.anchor.y), S[D] = $ * Y, S[D + 1] = z * q, S[D + N] = B * Y, S[D + N + 1] = z * q, S[D + N * 2] = B * Y, S[D + N * 2 + 1] = U * q, S[D + N * 3] = $ * Y, S[D + N * 3 + 1] = U * q, D += N * 4;\n    }\n  }, t.prototype.uploadPosition = function(e, o, T, S, N, D) {\n    for (var B = 0; B < T; B++) {\n      var $ = e[o + B].position;\n      S[D] = $.x, S[D + 1] = $.y, S[D + N] = $.x, S[D + N + 1] = $.y, S[D + N * 2] = $.x, S[D + N * 2 + 1] = $.y, S[D + N * 3] = $.x, S[D + N * 3 + 1] = $.y, D += N * 4;\n    }\n  }, t.prototype.uploadRotation = function(e, o, T, S, N, D) {\n    for (var B = 0; B < T; B++) {\n      var $ = e[o + B].rotation;\n      S[D] = $, S[D + N] = $, S[D + N * 2] = $, S[D + N * 3] = $, D += N * 4;\n    }\n  }, t.prototype.uploadUvs = function(e, o, T, S, N, D) {\n    for (var B = 0; B < T; ++B) {\n      var $ = e[o + B]._texture._uvs;\n      $ ? (S[D] = $.x0, S[D + 1] = $.y0, S[D + N] = $.x1, S[D + N + 1] = $.y1, S[D + N * 2] = $.x2, S[D + N * 2 + 1] = $.y2, S[D + N * 3] = $.x3, S[D + N * 3 + 1] = $.y3, D += N * 4) : (S[D] = 0, S[D + 1] = 0, S[D + N] = 0, S[D + N + 1] = 0, S[D + N * 2] = 0, S[D + N * 2 + 1] = 0, S[D + N * 3] = 0, S[D + N * 3 + 1] = 0, D += N * 4);\n    }\n  }, t.prototype.uploadTint = function(e, o, T, S, N, D) {\n    for (var B = 0; B < T; ++B) {\n      var $ = e[o + B], U = $._texture.baseTexture.alphaMode > 0, z = $.alpha, V = z < 1 && U ? premultiplyTint($._tintRGB, z) : $._tintRGB + (z * 255 << 24);\n      S[D] = V, S[D + N] = V, S[D + N * 2] = V, S[D + N * 3] = V, D += N * 4;\n    }\n  }, t.prototype.destroy = function() {\n    r.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n  }, t.extension = {\n    name: \"particle\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\n/*!\n * @pixi/graphics - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar LINE_JOIN;\n(function(r) {\n  r.MITER = \"miter\", r.BEVEL = \"bevel\", r.ROUND = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\nvar LINE_CAP;\n(function(r) {\n  r.BUTT = \"butt\", r.ROUND = \"round\", r.SQUARE = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\nvar GRAPHICS_CURVES = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(r, t) {\n    if (t === void 0 && (t = 20), !this.adaptive || !r || isNaN(r))\n      return t;\n    var e = Math.ceil(r / this.maxLength);\n    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;\n  }\n}, FillStyle = function() {\n  function r() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();\n  }\n  return r.prototype.clone = function() {\n    var t = new r();\n    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;\n  }, r.prototype.reset = function() {\n    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;\n  }, r.prototype.destroy = function() {\n    this.texture = null, this.matrix = null;\n  }, r;\n}();\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$l = function(r, t) {\n  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$l(r, t);\n};\nfunction __extends$l(r, t) {\n  extendStatics$l(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction fixOrientation(r, t) {\n  var e, o;\n  t === void 0 && (t = !1);\n  var T = r.length;\n  if (!(T < 6)) {\n    for (var S = 0, N = 0, D = r[T - 2], B = r[T - 1]; N < T; N += 2) {\n      var $ = r[N], U = r[N + 1];\n      S += ($ - D) * (U + B), D = $, B = U;\n    }\n    if (!t && S > 0 || t && S <= 0)\n      for (var z = T / 2, N = z + z % 2; N < T; N += 2) {\n        var V = T - N - 2, X = T - N - 1, W = N, Y = N + 1;\n        e = [r[W], r[V]], r[V] = e[0], r[W] = e[1], o = [r[Y], r[X]], r[X] = o[0], r[Y] = o[1];\n      }\n  }\n}\nvar buildPoly = {\n  build: function(r) {\n    r.points = r.shape.points.slice();\n  },\n  triangulate: function(r, t) {\n    var e = r.points, o = r.holes, T = t.points, S = t.indices;\n    if (e.length >= 6) {\n      fixOrientation(e, !1);\n      for (var N = [], D = 0; D < o.length; D++) {\n        var B = o[D];\n        fixOrientation(B.points, !0), N.push(e.length / 2), e = e.concat(B.points);\n      }\n      var $ = earcut$1.exports(e, N, 2);\n      if (!$)\n        return;\n      for (var U = T.length / 2, D = 0; D < $.length; D += 3)\n        S.push($[D] + U), S.push($[D + 1] + U), S.push($[D + 2] + U);\n      for (var D = 0; D < e.length; D++)\n        T.push(e[D]);\n    }\n  }\n}, buildCircle = {\n  build: function(r) {\n    var t = r.points, e, o, T, S, N, D;\n    if (r.type === SHAPES.CIRC) {\n      var B = r.shape;\n      e = B.x, o = B.y, N = D = B.radius, T = S = 0;\n    } else if (r.type === SHAPES.ELIP) {\n      var $ = r.shape;\n      e = $.x, o = $.y, N = $.width, D = $.height, T = S = 0;\n    } else {\n      var U = r.shape, z = U.width / 2, V = U.height / 2;\n      e = U.x + z, o = U.y + V, N = D = Math.max(0, Math.min(U.radius, Math.min(z, V))), T = z - N, S = V - D;\n    }\n    if (!(N >= 0 && D >= 0 && T >= 0 && S >= 0)) {\n      t.length = 0;\n      return;\n    }\n    var X = Math.ceil(2.3 * Math.sqrt(N + D)), W = X * 8 + (T ? 4 : 0) + (S ? 4 : 0);\n    if (t.length = W, W !== 0) {\n      if (X === 0) {\n        t.length = 8, t[0] = t[6] = e + T, t[1] = t[3] = o + S, t[2] = t[4] = e - T, t[5] = t[7] = o - S;\n        return;\n      }\n      var Y = 0, q = X * 4 + (T ? 2 : 0) + 2, Z = q, K = W;\n      {\n        var J = T + N, tt = S, et = e + J, Q = e - J, at = o + tt;\n        if (t[Y++] = et, t[Y++] = at, t[--q] = at, t[--q] = Q, S) {\n          var it = o - tt;\n          t[Z++] = Q, t[Z++] = it, t[--K] = it, t[--K] = et;\n        }\n      }\n      for (var st = 1; st < X; st++) {\n        var ut = Math.PI / 2 * (st / X), J = T + Math.cos(ut) * N, tt = S + Math.sin(ut) * D, et = e + J, Q = e - J, at = o + tt, it = o - tt;\n        t[Y++] = et, t[Y++] = at, t[--q] = at, t[--q] = Q, t[Z++] = Q, t[Z++] = it, t[--K] = it, t[--K] = et;\n      }\n      {\n        var J = T, tt = S + D, et = e + J, Q = e - J, at = o + tt, it = o - tt;\n        t[Y++] = et, t[Y++] = at, t[--K] = it, t[--K] = et, T && (t[Y++] = Q, t[Y++] = at, t[--K] = it, t[--K] = Q);\n      }\n    }\n  },\n  triangulate: function(r, t) {\n    var e = r.points, o = t.points, T = t.indices;\n    if (e.length !== 0) {\n      var S = o.length / 2, N = S, D, B;\n      if (r.type !== SHAPES.RREC) {\n        var $ = r.shape;\n        D = $.x, B = $.y;\n      } else {\n        var U = r.shape;\n        D = U.x + U.width / 2, B = U.y + U.height / 2;\n      }\n      var z = r.matrix;\n      o.push(r.matrix ? z.a * D + z.c * B + z.tx : D, r.matrix ? z.b * D + z.d * B + z.ty : B), S++, o.push(e[0], e[1]);\n      for (var V = 2; V < e.length; V += 2)\n        o.push(e[V], e[V + 1]), T.push(S++, N, S);\n      T.push(N + 1, N, S);\n    }\n  }\n}, buildRectangle = {\n  build: function(r) {\n    var t = r.shape, e = t.x, o = t.y, T = t.width, S = t.height, N = r.points;\n    N.length = 0, N.push(e, o, e + T, o, e + T, o + S, e, o + S);\n  },\n  triangulate: function(r, t) {\n    var e = r.points, o = t.points, T = o.length / 2;\n    o.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(T, T + 1, T + 2, T + 1, T + 2, T + 3);\n  }\n};\nfunction getPt(r, t, e) {\n  var o = t - r;\n  return r + o * e;\n}\nfunction quadraticBezierCurve(r, t, e, o, T, S, N) {\n  N === void 0 && (N = []);\n  for (var D = 20, B = N, $ = 0, U = 0, z = 0, V = 0, X = 0, W = 0, Y = 0, q = 0; Y <= D; ++Y)\n    q = Y / D, $ = getPt(r, e, q), U = getPt(t, o, q), z = getPt(e, T, q), V = getPt(o, S, q), X = getPt($, z, q), W = getPt(U, V, q), !(Y === 0 && B[B.length - 2] === X && B[B.length - 1] === W) && B.push(X, W);\n  return B;\n}\nvar buildRoundedRectangle = {\n  build: function(r) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(r);\n      return;\n    }\n    var t = r.shape, e = r.points, o = t.x, T = t.y, S = t.width, N = t.height, D = Math.max(0, Math.min(t.radius, Math.min(S, N) / 2));\n    e.length = 0, D ? (quadraticBezierCurve(o, T + D, o, T, o + D, T, e), quadraticBezierCurve(o + S - D, T, o + S, T, o + S, T + D, e), quadraticBezierCurve(o + S, T + N - D, o + S, T + N, o + S - D, T + N, e), quadraticBezierCurve(o + D, T + N, o, T + N, o, T + N - D, e)) : e.push(o, T, o + S, T, o + S, T + N, o, T + N);\n  },\n  triangulate: function(r, t) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(r, t);\n      return;\n    }\n    for (var e = r.points, o = t.points, T = t.indices, S = o.length / 2, N = earcut$1.exports(e, null, 2), D = 0, B = N.length; D < B; D += 3)\n      T.push(N[D] + S), T.push(N[D + 1] + S), T.push(N[D + 2] + S);\n    for (var D = 0, B = e.length; D < B; D++)\n      o.push(e[D], e[++D]);\n  }\n};\nfunction square(r, t, e, o, T, S, N, D) {\n  var B = r - e * T, $ = t - o * T, U = r + e * S, z = t + o * S, V, X;\n  N ? (V = o, X = -e) : (V = -o, X = e);\n  var W = B + V, Y = $ + X, q = U + V, Z = z + X;\n  return D.push(W, Y), D.push(q, Z), 2;\n}\nfunction round$1(r, t, e, o, T, S, N, D) {\n  var B = e - r, $ = o - t, U = Math.atan2(B, $), z = Math.atan2(T - r, S - t);\n  D && U < z ? U += Math.PI * 2 : !D && U > z && (z += Math.PI * 2);\n  var V = U, X = z - U, W = Math.abs(X), Y = Math.sqrt(B * B + $ * $), q = (15 * W * Math.sqrt(Y) / Math.PI >> 0) + 1, Z = X / q;\n  if (V += Z, D) {\n    N.push(r, t), N.push(e, o);\n    for (var K = 1, J = V; K < q; K++, J += Z)\n      N.push(r, t), N.push(r + Math.sin(J) * Y, t + Math.cos(J) * Y);\n    N.push(r, t), N.push(T, S);\n  } else {\n    N.push(e, o), N.push(r, t);\n    for (var K = 1, J = V; K < q; K++, J += Z)\n      N.push(r + Math.sin(J) * Y, t + Math.cos(J) * Y), N.push(r, t);\n    N.push(T, S), N.push(r, t);\n  }\n  return q * 2;\n}\nfunction buildNonNativeLine(r, t) {\n  var e = r.shape, o = r.points || e.points.slice(), T = t.closePointEps;\n  if (o.length !== 0) {\n    var S = r.lineStyle, N = new Point(o[0], o[1]), D = new Point(o[o.length - 2], o[o.length - 1]), B = e.type !== SHAPES.POLY || e.closeStroke, $ = Math.abs(N.x - D.x) < T && Math.abs(N.y - D.y) < T;\n    if (B) {\n      o = o.slice(), $ && (o.pop(), o.pop(), D.set(o[o.length - 2], o[o.length - 1]));\n      var U = (N.x + D.x) * 0.5, z = (D.y + N.y) * 0.5;\n      o.unshift(U, z), o.push(U, z);\n    }\n    var V = t.points, X = o.length / 2, W = o.length, Y = V.length / 2, q = S.width / 2, Z = q * q, K = S.miterLimit * S.miterLimit, J = o[0], tt = o[1], et = o[2], Q = o[3], at = 0, it = 0, st = -(tt - Q), ut = J - et, ft = 0, ct = 0, pt = Math.sqrt(st * st + ut * ut);\n    st /= pt, ut /= pt, st *= q, ut *= q;\n    var mt = S.alignment, vt = (1 - mt) * 2, _t = mt * 2;\n    B || (S.cap === LINE_CAP.ROUND ? W += round$1(J - st * (vt - _t) * 0.5, tt - ut * (vt - _t) * 0.5, J - st * vt, tt - ut * vt, J + st * _t, tt + ut * _t, V, !0) + 2 : S.cap === LINE_CAP.SQUARE && (W += square(J, tt, st, ut, vt, _t, !0, V))), V.push(J - st * vt, tt - ut * vt), V.push(J + st * _t, tt + ut * _t);\n    for (var xt = 1; xt < X - 1; ++xt) {\n      J = o[(xt - 1) * 2], tt = o[(xt - 1) * 2 + 1], et = o[xt * 2], Q = o[xt * 2 + 1], at = o[(xt + 1) * 2], it = o[(xt + 1) * 2 + 1], st = -(tt - Q), ut = J - et, pt = Math.sqrt(st * st + ut * ut), st /= pt, ut /= pt, st *= q, ut *= q, ft = -(Q - it), ct = et - at, pt = Math.sqrt(ft * ft + ct * ct), ft /= pt, ct /= pt, ft *= q, ct *= q;\n      var Rt = et - J, yt = tt - Q, ht = et - at, bt = it - Q, St = yt * ht - bt * Rt, Ot = St < 0;\n      if (Math.abs(St) < 0.1) {\n        V.push(et - st * vt, Q - ut * vt), V.push(et + st * _t, Q + ut * _t);\n        continue;\n      }\n      var wt = (-st + J) * (-ut + Q) - (-st + et) * (-ut + tt), Ft = (-ft + at) * (-ct + Q) - (-ft + et) * (-ct + it), dt = (Rt * Ft - ht * wt) / St, Gt = (bt * wt - yt * Ft) / St, Mt = (dt - et) * (dt - et) + (Gt - Q) * (Gt - Q), Bt = et + (dt - et) * vt, Dt = Q + (Gt - Q) * vt, Et = et - (dt - et) * _t, zt = Q - (Gt - Q) * _t, It = Math.min(Rt * Rt + yt * yt, ht * ht + bt * bt), Ct = Ot ? vt : _t, Lt = It + Ct * Ct * Z, $t = Mt <= Lt;\n      $t ? S.join === LINE_JOIN.BEVEL || Mt / Z > K ? (Ot ? (V.push(Bt, Dt), V.push(et + st * _t, Q + ut * _t), V.push(Bt, Dt), V.push(et + ft * _t, Q + ct * _t)) : (V.push(et - st * vt, Q - ut * vt), V.push(Et, zt), V.push(et - ft * vt, Q - ct * vt), V.push(Et, zt)), W += 2) : S.join === LINE_JOIN.ROUND ? Ot ? (V.push(Bt, Dt), V.push(et + st * _t, Q + ut * _t), W += round$1(et, Q, et + st * _t, Q + ut * _t, et + ft * _t, Q + ct * _t, V, !0) + 4, V.push(Bt, Dt), V.push(et + ft * _t, Q + ct * _t)) : (V.push(et - st * vt, Q - ut * vt), V.push(Et, zt), W += round$1(et, Q, et - st * vt, Q - ut * vt, et - ft * vt, Q - ct * vt, V, !1) + 4, V.push(et - ft * vt, Q - ct * vt), V.push(Et, zt)) : (V.push(Bt, Dt), V.push(Et, zt)) : (V.push(et - st * vt, Q - ut * vt), V.push(et + st * _t, Q + ut * _t), S.join === LINE_JOIN.ROUND ? Ot ? W += round$1(et, Q, et + st * _t, Q + ut * _t, et + ft * _t, Q + ct * _t, V, !0) + 2 : W += round$1(et, Q, et - st * vt, Q - ut * vt, et - ft * vt, Q - ct * vt, V, !1) + 2 : S.join === LINE_JOIN.MITER && Mt / Z <= K && (Ot ? (V.push(Et, zt), V.push(Et, zt)) : (V.push(Bt, Dt), V.push(Bt, Dt)), W += 2), V.push(et - ft * vt, Q - ct * vt), V.push(et + ft * _t, Q + ct * _t), W += 2);\n    }\n    J = o[(X - 2) * 2], tt = o[(X - 2) * 2 + 1], et = o[(X - 1) * 2], Q = o[(X - 1) * 2 + 1], st = -(tt - Q), ut = J - et, pt = Math.sqrt(st * st + ut * ut), st /= pt, ut /= pt, st *= q, ut *= q, V.push(et - st * vt, Q - ut * vt), V.push(et + st * _t, Q + ut * _t), B || (S.cap === LINE_CAP.ROUND ? W += round$1(et - st * (vt - _t) * 0.5, Q - ut * (vt - _t) * 0.5, et - st * vt, Q - ut * vt, et + st * _t, Q + ut * _t, V, !1) + 2 : S.cap === LINE_CAP.SQUARE && (W += square(et, Q, st, ut, vt, _t, !1, V)));\n    for (var At = t.indices, ee = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, xt = Y; xt < W + Y - 2; ++xt)\n      J = V[xt * 2], tt = V[xt * 2 + 1], et = V[(xt + 1) * 2], Q = V[(xt + 1) * 2 + 1], at = V[(xt + 2) * 2], it = V[(xt + 2) * 2 + 1], !(Math.abs(J * (Q - it) + et * (it - tt) + at * (tt - Q)) < ee) && At.push(xt, xt + 1, xt + 2);\n  }\n}\nfunction buildNativeLine(r, t) {\n  var e = 0, o = r.shape, T = r.points || o.points, S = o.type !== SHAPES.POLY || o.closeStroke;\n  if (T.length !== 0) {\n    var N = t.points, D = t.indices, B = T.length / 2, $ = N.length / 2, U = $;\n    for (N.push(T[0], T[1]), e = 1; e < B; e++)\n      N.push(T[e * 2], T[e * 2 + 1]), D.push(U, U + 1), U++;\n    S && D.push(U, $);\n  }\n}\nfunction buildLine(r, t) {\n  r.lineStyle.native ? buildNativeLine(r, t) : buildNonNativeLine(r, t);\n}\nvar ArcUtils = function() {\n  function r() {\n  }\n  return r.curveTo = function(t, e, o, T, S, N) {\n    var D = N[N.length - 2], B = N[N.length - 1], $ = B - e, U = D - t, z = T - e, V = o - t, X = Math.abs($ * V - U * z);\n    if (X < 1e-8 || S === 0)\n      return (N[N.length - 2] !== t || N[N.length - 1] !== e) && N.push(t, e), null;\n    var W = $ * $ + U * U, Y = z * z + V * V, q = $ * z + U * V, Z = S * Math.sqrt(W) / X, K = S * Math.sqrt(Y) / X, J = Z * q / W, tt = K * q / Y, et = Z * V + K * U, Q = Z * z + K * $, at = U * (K + J), it = $ * (K + J), st = V * (Z + tt), ut = z * (Z + tt), ft = Math.atan2(it - Q, at - et), ct = Math.atan2(ut - Q, st - et);\n    return {\n      cx: et + t,\n      cy: Q + e,\n      radius: S,\n      startAngle: ft,\n      endAngle: ct,\n      anticlockwise: U * z > V * $\n    };\n  }, r.arc = function(t, e, o, T, S, N, D, B, $) {\n    for (var U = D - N, z = GRAPHICS_CURVES._segmentsCount(Math.abs(U) * S, Math.ceil(Math.abs(U) / PI_2) * 40), V = U / (z * 2), X = V * 2, W = Math.cos(V), Y = Math.sin(V), q = z - 1, Z = q % 1 / q, K = 0; K <= q; ++K) {\n      var J = K + Z * K, tt = V + N + X * J, et = Math.cos(tt), Q = -Math.sin(tt);\n      $.push((W * et + Y * Q) * S + o, (W * -Q + Y * et) * S + T);\n    }\n  }, r;\n}(), BezierUtils = function() {\n  function r() {\n  }\n  return r.curveLength = function(t, e, o, T, S, N, D, B) {\n    for (var $ = 10, U = 0, z = 0, V = 0, X = 0, W = 0, Y = 0, q = 0, Z = 0, K = 0, J = 0, tt = 0, et = t, Q = e, at = 1; at <= $; ++at)\n      z = at / $, V = z * z, X = V * z, W = 1 - z, Y = W * W, q = Y * W, Z = q * t + 3 * Y * z * o + 3 * W * V * S + X * D, K = q * e + 3 * Y * z * T + 3 * W * V * N + X * B, J = et - Z, tt = Q - K, et = Z, Q = K, U += Math.sqrt(J * J + tt * tt);\n    return U;\n  }, r.curveTo = function(t, e, o, T, S, N, D) {\n    var B = D[D.length - 2], $ = D[D.length - 1];\n    D.length -= 2;\n    var U = GRAPHICS_CURVES._segmentsCount(r.curveLength(B, $, t, e, o, T, S, N)), z = 0, V = 0, X = 0, W = 0, Y = 0;\n    D.push(B, $);\n    for (var q = 1, Z = 0; q <= U; ++q)\n      Z = q / U, z = 1 - Z, V = z * z, X = V * z, W = Z * Z, Y = W * Z, D.push(X * B + 3 * V * Z * t + 3 * z * W * o + Y * S, X * $ + 3 * V * Z * e + 3 * z * W * T + Y * N);\n  }, r;\n}(), QuadraticUtils = function() {\n  function r() {\n  }\n  return r.curveLength = function(t, e, o, T, S, N) {\n    var D = t - 2 * o + S, B = e - 2 * T + N, $ = 2 * o - 2 * t, U = 2 * T - 2 * e, z = 4 * (D * D + B * B), V = 4 * (D * $ + B * U), X = $ * $ + U * U, W = 2 * Math.sqrt(z + V + X), Y = Math.sqrt(z), q = 2 * z * Y, Z = 2 * Math.sqrt(X), K = V / Y;\n    return (q * W + Y * V * (W - Z) + (4 * X * z - V * V) * Math.log((2 * Y + K + W) / (K + Z))) / (4 * q);\n  }, r.curveTo = function(t, e, o, T, S) {\n    for (var N = S[S.length - 2], D = S[S.length - 1], B = GRAPHICS_CURVES._segmentsCount(r.curveLength(N, D, t, e, o, T)), $ = 0, U = 0, z = 1; z <= B; ++z) {\n      var V = z / B;\n      $ = N + (t - N) * V, U = D + (e - D) * V, S.push($ + (t + (o - t) * V - $) * V, U + (e + (T - e) * V - U) * V);\n    }\n  }, r;\n}(), BatchPart = function() {\n  function r() {\n    this.reset();\n  }\n  return r.prototype.begin = function(t, e, o) {\n    this.reset(), this.style = t, this.start = e, this.attribStart = o;\n  }, r.prototype.end = function(t, e) {\n    this.attribSize = e - this.attribStart, this.size = t - this.start;\n  }, r.prototype.reset = function() {\n    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n  }, r;\n}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {\n  function r(t, e, o, T) {\n    e === void 0 && (e = null), o === void 0 && (o = null), T === void 0 && (T = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = o, this.fillStyle = e, this.matrix = T, this.type = t.type;\n  }\n  return r.prototype.clone = function() {\n    return new r(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  }, r.prototype.destroy = function() {\n    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n  }, r;\n}(), tmpPoint = new Point(), GraphicsGeometry = function(r) {\n  __extends$l(t, r);\n  function t() {\n    var e = r.call(this) || this;\n    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;\n  }\n  return Object.defineProperty(t.prototype, \"bounds\", {\n    get: function() {\n      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.invalidate = function() {\n    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n    for (var e = 0; e < this.drawCalls.length; e++)\n      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);\n    this.drawCalls.length = 0;\n    for (var e = 0; e < this.batches.length; e++) {\n      var o = this.batches[e];\n      o.reset(), BATCH_POOL.push(o);\n    }\n    this.batches.length = 0;\n  }, t.prototype.clear = function() {\n    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n  }, t.prototype.drawShape = function(e, o, T, S) {\n    o === void 0 && (o = null), T === void 0 && (T = null), S === void 0 && (S = null);\n    var N = new GraphicsData(e, o, T, S);\n    return this.graphicsData.push(N), this.dirty++, this;\n  }, t.prototype.drawHole = function(e, o) {\n    if (o === void 0 && (o = null), !this.graphicsData.length)\n      return null;\n    var T = new GraphicsData(e, null, null, o), S = this.graphicsData[this.graphicsData.length - 1];\n    return T.lineStyle = S.lineStyle, S.holes.push(T), this.dirty++, this;\n  }, t.prototype.destroy = function() {\n    r.prototype.destroy.call(this);\n    for (var e = 0; e < this.graphicsData.length; ++e)\n      this.graphicsData[e].destroy();\n    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n  }, t.prototype.containsPoint = function(e) {\n    for (var o = this.graphicsData, T = 0; T < o.length; ++T) {\n      var S = o[T];\n      if (!!S.fillStyle.visible && S.shape && (S.matrix ? S.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), S.shape.contains(tmpPoint.x, tmpPoint.y))) {\n        var N = !1;\n        if (S.holes)\n          for (var D = 0; D < S.holes.length; D++) {\n            var B = S.holes[D];\n            if (B.shape.contains(tmpPoint.x, tmpPoint.y)) {\n              N = !0;\n              break;\n            }\n          }\n        if (!N)\n          return !0;\n      }\n    }\n    return !1;\n  }, t.prototype.updateBatches = function() {\n    if (!this.graphicsData.length) {\n      this.batchable = !0;\n      return;\n    }\n    if (!!this.validateBatching()) {\n      this.cacheDirty = this.dirty;\n      var e = this.uvs, o = this.graphicsData, T = null, S = null;\n      this.batches.length > 0 && (T = this.batches[this.batches.length - 1], S = T.style);\n      for (var N = this.shapeIndex; N < o.length; N++) {\n        this.shapeIndex++;\n        var D = o[N], B = D.fillStyle, $ = D.lineStyle, U = FILL_COMMANDS[D.type];\n        U.build(D), D.matrix && this.transformPoints(D.points, D.matrix), (B.visible || $.visible) && this.processHoles(D.holes);\n        for (var z = 0; z < 2; z++) {\n          var V = z === 0 ? B : $;\n          if (!!V.visible) {\n            var X = V.texture.baseTexture, W = this.indices.length, Y = this.points.length / 2;\n            X.wrapMode = WRAP_MODES$5.REPEAT, z === 0 ? this.processFill(D) : this.processLine(D);\n            var q = this.points.length / 2 - Y;\n            q !== 0 && (T && !this._compareStyles(S, V) && (T.end(W, Y), T = null), T || (T = BATCH_POOL.pop() || new BatchPart(), T.begin(V, W, Y), this.batches.push(T), S = V), this.addUvs(this.points, e, V.texture, Y, q, V.matrix));\n          }\n        }\n      }\n      var Z = this.indices.length, K = this.points.length / 2;\n      if (T && T.end(Z, K), this.batches.length === 0) {\n        this.batchable = !0;\n        return;\n      }\n      var J = K > 65535;\n      this.indicesUint16 && this.indices.length === this.indicesUint16.length && J === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = J ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n    }\n  }, t.prototype._compareStyles = function(e, o) {\n    return !(!e || !o || e.texture.baseTexture !== o.texture.baseTexture || e.color + e.alpha !== o.color + o.alpha || !!e.native != !!o.native);\n  }, t.prototype.validateBatching = function() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n      return !1;\n    for (var e = 0, o = this.graphicsData.length; e < o; e++) {\n      var T = this.graphicsData[e], S = T.fillStyle, N = T.lineStyle;\n      if (S && !S.texture.baseTexture.valid || N && !N.texture.baseTexture.valid)\n        return !1;\n    }\n    return !0;\n  }, t.prototype.packBatches = function() {\n    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n    for (var e = this.batches, o = 0, T = e.length; o < T; o++)\n      for (var S = e[o], N = 0; N < S.size; N++) {\n        var D = S.start + N;\n        this.indicesUint16[D] = this.indicesUint16[D] - S.attribStart;\n      }\n  }, t.prototype.isBatchable = function() {\n    if (this.points.length > 65535 * 2)\n      return !1;\n    for (var e = this.batches, o = 0; o < e.length; o++)\n      if (e[o].style.native)\n        return !1;\n    return this.points.length < t.BATCHABLE_SIZE * 2;\n  }, t.prototype.buildDrawCalls = function() {\n    for (var e = ++BaseTexture._globalBatch, o = 0; o < this.drawCalls.length; o++)\n      this.drawCalls[o].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[o]);\n    this.drawCalls.length = 0;\n    var T = this.colors, S = this.textureIds, N = DRAW_CALL_POOL.pop();\n    N || (N = new BatchDrawCall(), N.texArray = new BatchTextureArray()), N.texArray.count = 0, N.start = 0, N.size = 0, N.type = DRAW_MODES$5.TRIANGLES;\n    var D = 0, B = null, $ = 0, U = !1, z = DRAW_MODES$5.TRIANGLES, V = 0;\n    this.drawCalls.push(N);\n    for (var o = 0; o < this.batches.length; o++) {\n      var X = this.batches[o], W = 8, Y = X.style, q = Y.texture.baseTexture;\n      U !== !!Y.native && (U = !!Y.native, z = U ? DRAW_MODES$5.LINES : DRAW_MODES$5.TRIANGLES, B = null, D = W, e++), B !== q && (B = q, q._batchEnabled !== e && (D === W && (e++, D = 0, N.size > 0 && (N = DRAW_CALL_POOL.pop(), N || (N = new BatchDrawCall(), N.texArray = new BatchTextureArray()), this.drawCalls.push(N)), N.start = V, N.size = 0, N.texArray.count = 0, N.type = z), q.touched = 1, q._batchEnabled = e, q._batchLocation = D, q.wrapMode = WRAP_MODES$5.REPEAT, N.texArray.elements[N.texArray.count++] = q, D++)), N.size += X.size, V += X.size, $ = q._batchLocation, this.addColors(T, Y.color, Y.alpha, X.attribSize, X.attribStart), this.addTextureIds(S, $, X.attribSize, X.attribStart);\n    }\n    BaseTexture._globalBatch = e, this.packAttributes();\n  }, t.prototype.packAttributes = function() {\n    for (var e = this.points, o = this.uvs, T = this.colors, S = this.textureIds, N = new ArrayBuffer(e.length * 3 * 4), D = new Float32Array(N), B = new Uint32Array(N), $ = 0, U = 0; U < e.length / 2; U++)\n      D[$++] = e[U * 2], D[$++] = e[U * 2 + 1], D[$++] = o[U * 2], D[$++] = o[U * 2 + 1], B[$++] = T[U], D[$++] = S[U];\n    this._buffer.update(N), this._indexBuffer.update(this.indicesUint16);\n  }, t.prototype.processFill = function(e) {\n    if (e.holes.length)\n      buildPoly.triangulate(e, this);\n    else {\n      var o = FILL_COMMANDS[e.type];\n      o.triangulate(e, this);\n    }\n  }, t.prototype.processLine = function(e) {\n    buildLine(e, this);\n    for (var o = 0; o < e.holes.length; o++)\n      buildLine(e.holes[o], this);\n  }, t.prototype.processHoles = function(e) {\n    for (var o = 0; o < e.length; o++) {\n      var T = e[o], S = FILL_COMMANDS[T.type];\n      S.build(T), T.matrix && this.transformPoints(T.points, T.matrix);\n    }\n  }, t.prototype.calculateBounds = function() {\n    var e = this._bounds;\n    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);\n  }, t.prototype.transformPoints = function(e, o) {\n    for (var T = 0; T < e.length / 2; T++) {\n      var S = e[T * 2], N = e[T * 2 + 1];\n      e[T * 2] = o.a * S + o.c * N + o.tx, e[T * 2 + 1] = o.b * S + o.d * N + o.ty;\n    }\n  }, t.prototype.addColors = function(e, o, T, S, N) {\n    N === void 0 && (N = 0);\n    var D = (o >> 16) + (o & 65280) + ((o & 255) << 16), B = premultiplyTint(D, T);\n    e.length = Math.max(e.length, N + S);\n    for (var $ = 0; $ < S; $++)\n      e[N + $] = B;\n  }, t.prototype.addTextureIds = function(e, o, T, S) {\n    S === void 0 && (S = 0), e.length = Math.max(e.length, S + T);\n    for (var N = 0; N < T; N++)\n      e[S + N] = o;\n  }, t.prototype.addUvs = function(e, o, T, S, N, D) {\n    D === void 0 && (D = null);\n    for (var B = 0, $ = o.length, U = T.frame; B < N; ) {\n      var z = e[(S + B) * 2], V = e[(S + B) * 2 + 1];\n      if (D) {\n        var X = D.a * z + D.c * V + D.tx;\n        V = D.b * z + D.d * V + D.ty, z = X;\n      }\n      B++, o.push(z / U.width, V / U.height);\n    }\n    var W = T.baseTexture;\n    (U.width < W.width || U.height < W.height) && this.adjustUvs(o, T, $, N);\n  }, t.prototype.adjustUvs = function(e, o, T, S) {\n    for (var N = o.baseTexture, D = 1e-6, B = T + S * 2, $ = o.frame, U = $.width / N.width, z = $.height / N.height, V = $.x / $.width, X = $.y / $.height, W = Math.floor(e[T] + D), Y = Math.floor(e[T + 1] + D), q = T + 2; q < B; q += 2)\n      W = Math.min(W, Math.floor(e[q] + D)), Y = Math.min(Y, Math.floor(e[q + 1] + D));\n    V -= W, X -= Y;\n    for (var q = T; q < B; q += 2)\n      e[q] = (e[q] + V) * U, e[q + 1] = (e[q + 1] + X) * z;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(BatchGeometry), LineStyle = function(r) {\n  __extends$l(t, r);\n  function t() {\n    var e = r !== null && r.apply(this, arguments) || this;\n    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;\n  }\n  return t.prototype.clone = function() {\n    var e = new t();\n    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;\n  }, t.prototype.reset = function() {\n    r.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;\n  }, t;\n}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(r) {\n  __extends$l(t, r);\n  function t(e) {\n    e === void 0 && (e = null);\n    var o = r.call(this) || this;\n    return o.shader = null, o.pluginName = \"batch\", o.currentPath = null, o.batches = [], o.batchTint = -1, o.batchDirty = -1, o.vertexData = null, o._fillStyle = new FillStyle(), o._lineStyle = new LineStyle(), o._matrix = null, o._holeMode = !1, o.state = State.for2d(), o._geometry = e || new GraphicsGeometry(), o._geometry.refCount++, o._transformID = -1, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.clone = function() {\n    return this.finishPoly(), new t(this._geometry);\n  }, Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fill\", {\n    get: function() {\n      return this._fillStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"line\", {\n    get: function() {\n      return this._lineStyle;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.lineStyle = function(e, o, T, S, N) {\n    return e === void 0 && (e = null), o === void 0 && (o = 0), T === void 0 && (T = 1), S === void 0 && (S = 0.5), N === void 0 && (N = !1), typeof e == \"number\" && (e = { width: e, color: o, alpha: T, alignment: S, native: N }), this.lineTextureStyle(e);\n  }, t.prototype.lineTextureStyle = function(e) {\n    e = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: e && e.texture ? 16777215 : 0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: !1,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, e), this.currentPath && this.startPoly();\n    var o = e.width > 0 && e.alpha > 0;\n    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: o }, e)) : this._lineStyle.reset(), this;\n  }, t.prototype.startPoly = function() {\n    if (this.currentPath) {\n      var e = this.currentPath.points, o = this.currentPath.points.length;\n      o > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[o - 2], e[o - 1]));\n    } else\n      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;\n  }, t.prototype.finishPoly = function() {\n    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n  }, t.prototype.moveTo = function(e, o) {\n    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = o, this;\n  }, t.prototype.lineTo = function(e, o) {\n    this.currentPath || this.moveTo(0, 0);\n    var T = this.currentPath.points, S = T[T.length - 2], N = T[T.length - 1];\n    return (S !== e || N !== o) && T.push(e, o), this;\n  }, t.prototype._initCurve = function(e, o) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, o]) : this.moveTo(e, o);\n  }, t.prototype.quadraticCurveTo = function(e, o, T, S) {\n    this._initCurve();\n    var N = this.currentPath.points;\n    return N.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, o, T, S, N), this;\n  }, t.prototype.bezierCurveTo = function(e, o, T, S, N, D) {\n    return this._initCurve(), BezierUtils.curveTo(e, o, T, S, N, D, this.currentPath.points), this;\n  }, t.prototype.arcTo = function(e, o, T, S, N) {\n    this._initCurve(e, o);\n    var D = this.currentPath.points, B = ArcUtils.curveTo(e, o, T, S, N, D);\n    if (B) {\n      var $ = B.cx, U = B.cy, z = B.radius, V = B.startAngle, X = B.endAngle, W = B.anticlockwise;\n      this.arc($, U, z, V, X, W);\n    }\n    return this;\n  }, t.prototype.arc = function(e, o, T, S, N, D) {\n    if (D === void 0 && (D = !1), S === N)\n      return this;\n    !D && N <= S ? N += PI_2 : D && S <= N && (S += PI_2);\n    var B = N - S;\n    if (B === 0)\n      return this;\n    var $ = e + Math.cos(S) * T, U = o + Math.sin(S) * T, z = this._geometry.closePointEps, V = this.currentPath ? this.currentPath.points : null;\n    if (V) {\n      var X = Math.abs(V[V.length - 2] - $), W = Math.abs(V[V.length - 1] - U);\n      X < z && W < z || V.push($, U);\n    } else\n      this.moveTo($, U), V = this.currentPath.points;\n    return ArcUtils.arc($, U, e, o, T, S, N, D, V), this;\n  }, t.prototype.beginFill = function(e, o) {\n    return e === void 0 && (e = 0), o === void 0 && (o = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: o });\n  }, t.prototype.beginTextureFill = function(e) {\n    e = Object.assign({\n      texture: Texture.WHITE,\n      color: 16777215,\n      alpha: 1,\n      matrix: null\n    }, e), this.currentPath && this.startPoly();\n    var o = e.alpha > 0;\n    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: o }, e)) : this._fillStyle.reset(), this;\n  }, t.prototype.endFill = function() {\n    return this.finishPoly(), this._fillStyle.reset(), this;\n  }, t.prototype.drawRect = function(e, o, T, S) {\n    return this.drawShape(new Rectangle(e, o, T, S));\n  }, t.prototype.drawRoundedRect = function(e, o, T, S, N) {\n    return this.drawShape(new RoundedRectangle(e, o, T, S, N));\n  }, t.prototype.drawCircle = function(e, o, T) {\n    return this.drawShape(new Circle(e, o, T));\n  }, t.prototype.drawEllipse = function(e, o, T, S) {\n    return this.drawShape(new Ellipse(e, o, T, S));\n  }, t.prototype.drawPolygon = function() {\n    for (var e = arguments, o = [], T = 0; T < arguments.length; T++)\n      o[T] = e[T];\n    var S, N = !0, D = o[0];\n    D.points ? (N = D.closeStroke, S = D.points) : Array.isArray(o[0]) ? S = o[0] : S = o;\n    var B = new Polygon(S);\n    return B.closeStroke = N, this.drawShape(B), this;\n  }, t.prototype.drawShape = function(e) {\n    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;\n  }, t.prototype.clear = function() {\n    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n  }, t.prototype.isFastRect = function() {\n    var e = this._geometry.graphicsData;\n    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);\n  }, t.prototype._render = function(e) {\n    this.finishPoly();\n    var o = this._geometry;\n    o.updateBatches(), o.batchable ? (this.batchDirty !== o.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));\n  }, t.prototype._populateBatches = function() {\n    var e = this._geometry, o = this.blendMode, T = e.batches.length;\n    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = T, this.vertexData = new Float32Array(e.points);\n    for (var S = 0; S < T; S++) {\n      var N = e.batches[S], D = N.style.color, B = new Float32Array(this.vertexData.buffer, N.attribStart * 4 * 2, N.attribSize * 2), $ = new Float32Array(e.uvsFloat32.buffer, N.attribStart * 4 * 2, N.attribSize * 2), U = new Uint16Array(e.indicesUint16.buffer, N.start * 2, N.size), z = {\n        vertexData: B,\n        blendMode: o,\n        indices: U,\n        uvs: $,\n        _batchRGB: hex2rgb(D),\n        _tintRGB: D,\n        _texture: N.style.texture,\n        alpha: N.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[S] = z;\n    }\n  }, t.prototype._renderBatched = function(e) {\n    if (!!this.batches.length) {\n      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n      for (var o = 0, T = this.batches.length; o < T; o++) {\n        var S = this.batches[o];\n        S.worldAlpha = this.worldAlpha * S.alpha, e.plugins[this.pluginName].render(S);\n      }\n    }\n  }, t.prototype._renderDirect = function(e) {\n    var o = this._resolveDirectShader(e), T = this._geometry, S = this.tint, N = this.worldAlpha, D = o.uniforms, B = T.drawCalls;\n    D.translationMatrix = this.transform.worldTransform, D.tint[0] = (S >> 16 & 255) / 255 * N, D.tint[1] = (S >> 8 & 255) / 255 * N, D.tint[2] = (S & 255) / 255 * N, D.tint[3] = N, e.shader.bind(o), e.geometry.bind(T, o), e.state.set(this.state);\n    for (var $ = 0, U = B.length; $ < U; $++)\n      this._renderDrawCallDirect(e, T.drawCalls[$]);\n  }, t.prototype._renderDrawCallDirect = function(e, o) {\n    for (var T = o.texArray, S = o.type, N = o.size, D = o.start, B = T.count, $ = 0; $ < B; $++)\n      e.texture.bind(T.elements[$], $);\n    e.geometry.draw(S, N, D);\n  }, t.prototype._resolveDirectShader = function(e) {\n    var o = this.shader, T = this.pluginName;\n    if (!o) {\n      if (!DEFAULT_SHADERS[T]) {\n        for (var S = e.plugins[T].MAX_TEXTURES, N = new Int32Array(S), D = 0; D < S; D++)\n          N[D] = D;\n        var B = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: N }, !0)\n        }, $ = e.plugins[T]._shader.program;\n        DEFAULT_SHADERS[T] = new Shader($, B);\n      }\n      o = DEFAULT_SHADERS[T];\n    }\n    return o;\n  }, t.prototype._calculateBounds = function() {\n    this.finishPoly();\n    var e = this._geometry;\n    if (!!e.graphicsData.length) {\n      var o = e.bounds, T = o.minX, S = o.minY, N = o.maxX, D = o.maxY;\n      this._bounds.addFrame(this.transform, T, S, N, D);\n    }\n  }, t.prototype.containsPoint = function(e) {\n    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);\n  }, t.prototype.calculateTints = function() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      for (var e = hex2rgb(this.tint, temp), o = 0; o < this.batches.length; o++) {\n        var T = this.batches[o], S = T._batchRGB, N = e[0] * S[0] * 255, D = e[1] * S[1] * 255, B = e[2] * S[2] * 255, $ = (N << 16) + (D << 8) + (B | 0);\n        T._tintRGB = ($ >> 16) + ($ & 65280) + (($ & 255) << 16);\n      }\n    }\n  }, t.prototype.calculateVertices = function() {\n    var e = this.transform._worldID;\n    if (this._transformID !== e) {\n      this._transformID = e;\n      for (var o = this.transform.worldTransform, T = o.a, S = o.b, N = o.c, D = o.d, B = o.tx, $ = o.ty, U = this._geometry.points, z = this.vertexData, V = 0, X = 0; X < U.length; X += 2) {\n        var W = U[X], Y = U[X + 1];\n        z[V++] = T * W + N * Y + B, z[V++] = D * Y + S * W + $;\n      }\n    }\n  }, t.prototype.closePath = function() {\n    var e = this.currentPath;\n    return e && (e.closeStroke = !0, this.finishPoly()), this;\n  }, t.prototype.setMatrix = function(e) {\n    return this._matrix = e, this;\n  }, t.prototype.beginHole = function() {\n    return this.finishPoly(), this._holeMode = !0, this;\n  }, t.prototype.endHole = function() {\n    return this.finishPoly(), this._holeMode = !1, this;\n  }, t.prototype.destroy = function(e) {\n    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, r.prototype.destroy.call(this, e);\n  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;\n}(Container);\n/*!\n * @pixi/sprite - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$k = function(r, t) {\n  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$k(r, t);\n};\nfunction __extends$k(r, t) {\n  extendStatics$k(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(r) {\n  __extends$k(t, r);\n  function t(e) {\n    var o = r.call(this) || this;\n    return o._anchor = new ObservablePoint(o._onAnchorUpdate, o, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), o._texture = null, o._width = 0, o._height = 0, o._tint = null, o._tintRGB = null, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o._cachedTint = 16777215, o.uvs = null, o.texture = e || Texture.EMPTY, o.vertexData = new Float32Array(8), o.vertexTrimmedData = null, o._transformID = -1, o._textureID = -1, o._transformTrimmedID = -1, o._textureTrimmedID = -1, o.indices = indices, o.pluginName = \"batch\", o.isSprite = !0, o._roundPixels = settings$1.ROUND_PIXELS, o;\n  }\n  return t.prototype._onTextureUpdate = function() {\n    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);\n  }, t.prototype._onAnchorUpdate = function() {\n    this._transformID = -1, this._transformTrimmedID = -1;\n  }, t.prototype.calculateVertices = function() {\n    var e = this._texture;\n    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {\n      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;\n      var o = this.transform.worldTransform, T = o.a, S = o.b, N = o.c, D = o.d, B = o.tx, $ = o.ty, U = this.vertexData, z = e.trim, V = e.orig, X = this._anchor, W = 0, Y = 0, q = 0, Z = 0;\n      if (z ? (Y = z.x - X._x * V.width, W = Y + z.width, Z = z.y - X._y * V.height, q = Z + z.height) : (Y = -X._x * V.width, W = Y + V.width, Z = -X._y * V.height, q = Z + V.height), U[0] = T * Y + N * Z + B, U[1] = D * Z + S * Y + $, U[2] = T * W + N * Z + B, U[3] = D * Z + S * W + $, U[4] = T * W + N * q + B, U[5] = D * q + S * W + $, U[6] = T * Y + N * q + B, U[7] = D * q + S * Y + $, this._roundPixels)\n        for (var K = settings$1.RESOLUTION, J = 0; J < U.length; ++J)\n          U[J] = Math.round((U[J] * K | 0) / K);\n    }\n  }, t.prototype.calculateTrimmedVertices = function() {\n    if (!this.vertexTrimmedData)\n      this.vertexTrimmedData = new Float32Array(8);\n    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n      return;\n    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n    var e = this._texture, o = this.vertexTrimmedData, T = e.orig, S = this._anchor, N = this.transform.worldTransform, D = N.a, B = N.b, $ = N.c, U = N.d, z = N.tx, V = N.ty, X = -S._x * T.width, W = X + T.width, Y = -S._y * T.height, q = Y + T.height;\n    o[0] = D * X + $ * Y + z, o[1] = U * Y + B * X + V, o[2] = D * W + $ * Y + z, o[3] = U * Y + B * W + V, o[4] = D * W + $ * q + z, o[5] = U * q + B * W + V, o[6] = D * X + $ * q + z, o[7] = U * q + B * X + V;\n  }, t.prototype._render = function(e) {\n    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);\n  }, t.prototype._calculateBounds = function() {\n    var e = this._texture.trim, o = this._texture.orig;\n    !e || e.width === o.width && e.height === o.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$2);\n    var o = this._texture.orig.width, T = this._texture.orig.height, S = -o * this.anchor.x, N = 0;\n    return tempPoint$2.x >= S && tempPoint$2.x < S + o && (N = -T * this.anchor.y, tempPoint$2.y >= N && tempPoint$2.y < N + T);\n  }, t.prototype.destroy = function(e) {\n    r.prototype.destroy.call(this, e), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null;\n    var o = typeof e == \"boolean\" ? e : e && e.texture;\n    if (o) {\n      var T = typeof e == \"boolean\" ? e : e && e.baseTexture;\n      this._texture.destroy(!!T);\n    }\n    this._texture = null;\n  }, t.from = function(e, o) {\n    var T = e instanceof Texture ? e : Texture.from(e, o);\n    return new t(T);\n  }, Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      var o = sign(this.scale.x) || 1;\n      this.scale.x = o * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      var o = sign(this.scale.y) || 1;\n      this.scale.y = o * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this._texture;\n    },\n    set: function(e) {\n      this._texture !== e && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once(\"update\", this._onTextureUpdate, this)));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Container);\n/*!\n * @pixi/text - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$j = function(r, t) {\n  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$j(r, t);\n};\nfunction __extends$j(r, t) {\n  extendStatics$j(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar TEXT_GRADIENT;\n(function(r) {\n  r[r.LINEAR_VERTICAL = 0] = \"LINEAR_VERTICAL\", r[r.LINEAR_HORIZONTAL = 1] = \"LINEAR_HORIZONTAL\";\n})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));\nvar defaultStyle = {\n  align: \"left\",\n  breakWords: !1,\n  dropShadow: !1,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: !1,\n  whiteSpace: \"pre\",\n  wordWrap: !1,\n  wordWrapWidth: 100,\n  leading: 0\n}, genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n], TextStyle = function() {\n  function r(t) {\n    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);\n  }\n  return r.prototype.clone = function() {\n    var t = {};\n    return deepCopyProperties(t, this, defaultStyle), new r(t);\n  }, r.prototype.reset = function() {\n    deepCopyProperties(this, defaultStyle, defaultStyle);\n  }, Object.defineProperty(r.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(t) {\n      this._align !== t && (this._align = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"breakWords\", {\n    get: function() {\n      return this._breakWords;\n    },\n    set: function(t) {\n      this._breakWords !== t && (this._breakWords = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadow\", {\n    get: function() {\n      return this._dropShadow;\n    },\n    set: function(t) {\n      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadowAlpha\", {\n    get: function() {\n      return this._dropShadowAlpha;\n    },\n    set: function(t) {\n      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadowAngle\", {\n    get: function() {\n      return this._dropShadowAngle;\n    },\n    set: function(t) {\n      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadowBlur\", {\n    get: function() {\n      return this._dropShadowBlur;\n    },\n    set: function(t) {\n      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadowColor\", {\n    get: function() {\n      return this._dropShadowColor;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"dropShadowDistance\", {\n    get: function() {\n      return this._dropShadowDistance;\n    },\n    set: function(t) {\n      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fill\", {\n    get: function() {\n      return this._fill;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._fill !== e && (this._fill = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fillGradientType\", {\n    get: function() {\n      return this._fillGradientType;\n    },\n    set: function(t) {\n      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fillGradientStops\", {\n    get: function() {\n      return this._fillGradientStops;\n    },\n    set: function(t) {\n      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fontFamily\", {\n    get: function() {\n      return this._fontFamily;\n    },\n    set: function(t) {\n      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(t) {\n      this._fontSize !== t && (this._fontSize = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fontStyle\", {\n    get: function() {\n      return this._fontStyle;\n    },\n    set: function(t) {\n      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fontVariant\", {\n    get: function() {\n      return this._fontVariant;\n    },\n    set: function(t) {\n      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"fontWeight\", {\n    get: function() {\n      return this._fontWeight;\n    },\n    set: function(t) {\n      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(t) {\n      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"lineHeight\", {\n    get: function() {\n      return this._lineHeight;\n    },\n    set: function(t) {\n      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"leading\", {\n    get: function() {\n      return this._leading;\n    },\n    set: function(t) {\n      this._leading !== t && (this._leading = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"lineJoin\", {\n    get: function() {\n      return this._lineJoin;\n    },\n    set: function(t) {\n      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"miterLimit\", {\n    get: function() {\n      return this._miterLimit;\n    },\n    set: function(t) {\n      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"padding\", {\n    get: function() {\n      return this._padding;\n    },\n    set: function(t) {\n      this._padding !== t && (this._padding = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"stroke\", {\n    get: function() {\n      return this._stroke;\n    },\n    set: function(t) {\n      var e = getColor(t);\n      this._stroke !== e && (this._stroke = e, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"strokeThickness\", {\n    get: function() {\n      return this._strokeThickness;\n    },\n    set: function(t) {\n      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"textBaseline\", {\n    get: function() {\n      return this._textBaseline;\n    },\n    set: function(t) {\n      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"trim\", {\n    get: function() {\n      return this._trim;\n    },\n    set: function(t) {\n      this._trim !== t && (this._trim = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"whiteSpace\", {\n    get: function() {\n      return this._whiteSpace;\n    },\n    set: function(t) {\n      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"wordWrap\", {\n    get: function() {\n      return this._wordWrap;\n    },\n    set: function(t) {\n      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"wordWrapWidth\", {\n    get: function() {\n      return this._wordWrapWidth;\n    },\n    set: function(t) {\n      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.toFontString = function() {\n    var t = typeof this.fontSize == \"number\" ? this.fontSize + \"px\" : this.fontSize, e = this.fontFamily;\n    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(\",\"));\n    for (var o = e.length - 1; o >= 0; o--) {\n      var T = e[o].trim();\n      !/([\\\"\\'])[^\\'\\\"]+\\1/.test(T) && genericFontFamilies.indexOf(T) < 0 && (T = '\"' + T + '\"'), e[o] = T;\n    }\n    return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + t + \" \" + e.join(\",\");\n  }, r;\n}();\nfunction getSingleColor(r) {\n  return typeof r == \"number\" ? hex2string(r) : (typeof r == \"string\" && r.indexOf(\"0x\") === 0 && (r = r.replace(\"0x\", \"#\")), r);\n}\nfunction getColor(r) {\n  if (Array.isArray(r)) {\n    for (var t = 0; t < r.length; ++t)\n      r[t] = getSingleColor(r[t]);\n    return r;\n  } else\n    return getSingleColor(r);\n}\nfunction areArraysEqual(r, t) {\n  if (!Array.isArray(r) || !Array.isArray(t) || r.length !== t.length)\n    return !1;\n  for (var e = 0; e < r.length; ++e)\n    if (r[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction deepCopyProperties(r, t, e) {\n  for (var o in e)\n    Array.isArray(t[o]) ? r[o] = t[o].slice() : r[o] = t[o];\n}\nvar TextMetrics = function() {\n  function r(t, e, o, T, S, N, D, B, $) {\n    this.text = t, this.style = e, this.width = o, this.height = T, this.lines = S, this.lineWidths = N, this.lineHeight = D, this.maxLineWidth = B, this.fontProperties = $;\n  }\n  return r.measureText = function(t, e, o, T) {\n    T === void 0 && (T = r._canvas), o = o == null ? e.wordWrap : o;\n    var S = e.toFontString(), N = r.measureFont(S);\n    N.fontSize === 0 && (N.fontSize = e.fontSize, N.ascent = e.fontSize);\n    var D = T.getContext(\"2d\");\n    D.font = S;\n    for (var B = o ? r.wordWrap(t, e, T) : t, $ = B.split(/(?:\\r\\n|\\r|\\n)/), U = new Array($.length), z = 0, V = 0; V < $.length; V++) {\n      var X = D.measureText($[V]).width + ($[V].length - 1) * e.letterSpacing;\n      U[V] = X, z = Math.max(z, X);\n    }\n    var W = z + e.strokeThickness;\n    e.dropShadow && (W += e.dropShadowDistance);\n    var Y = e.lineHeight || N.fontSize + e.strokeThickness, q = Math.max(Y, N.fontSize + e.strokeThickness) + ($.length - 1) * (Y + e.leading);\n    return e.dropShadow && (q += e.dropShadowDistance), new r(t, e, W, q, $, U, Y + e.leading, z, N);\n  }, r.wordWrap = function(t, e, o) {\n    o === void 0 && (o = r._canvas);\n    for (var T = o.getContext(\"2d\"), S = 0, N = \"\", D = \"\", B = /* @__PURE__ */ Object.create(null), $ = e.letterSpacing, U = e.whiteSpace, z = r.collapseSpaces(U), V = r.collapseNewlines(U), X = !z, W = e.wordWrapWidth + $, Y = r.tokenize(t), q = 0; q < Y.length; q++) {\n      var Z = Y[q];\n      if (r.isNewline(Z)) {\n        if (!V) {\n          D += r.addLine(N), X = !z, N = \"\", S = 0;\n          continue;\n        }\n        Z = \" \";\n      }\n      if (z) {\n        var K = r.isBreakingSpace(Z), J = r.isBreakingSpace(N[N.length - 1]);\n        if (K && J)\n          continue;\n      }\n      var tt = r.getFromCache(Z, $, B, T);\n      if (tt > W)\n        if (N !== \"\" && (D += r.addLine(N), N = \"\", S = 0), r.canBreakWords(Z, e.breakWords))\n          for (var et = r.wordWrapSplit(Z), Q = 0; Q < et.length; Q++) {\n            for (var at = et[Q], it = 1; et[Q + it]; ) {\n              var st = et[Q + it], ut = at[at.length - 1];\n              if (!r.canBreakChars(ut, st, Z, Q, e.breakWords))\n                at += st;\n              else\n                break;\n              it++;\n            }\n            Q += at.length - 1;\n            var ft = r.getFromCache(at, $, B, T);\n            ft + S > W && (D += r.addLine(N), X = !1, N = \"\", S = 0), N += at, S += ft;\n          }\n        else {\n          N.length > 0 && (D += r.addLine(N), N = \"\", S = 0);\n          var ct = q === Y.length - 1;\n          D += r.addLine(Z, !ct), X = !1, N = \"\", S = 0;\n        }\n      else\n        tt + S > W && (X = !1, D += r.addLine(N), N = \"\", S = 0), (N.length > 0 || !r.isBreakingSpace(Z) || X) && (N += Z, S += tt);\n    }\n    return D += r.addLine(N, !1), D;\n  }, r.addLine = function(t, e) {\n    return e === void 0 && (e = !0), t = r.trimRight(t), t = e ? t + `\n` : t, t;\n  }, r.getFromCache = function(t, e, o, T) {\n    var S = o[t];\n    if (typeof S != \"number\") {\n      var N = t.length * e;\n      S = T.measureText(t).width + N, o[t] = S;\n    }\n    return S;\n  }, r.collapseSpaces = function(t) {\n    return t === \"normal\" || t === \"pre-line\";\n  }, r.collapseNewlines = function(t) {\n    return t === \"normal\";\n  }, r.trimRight = function(t) {\n    if (typeof t != \"string\")\n      return \"\";\n    for (var e = t.length - 1; e >= 0; e--) {\n      var o = t[e];\n      if (!r.isBreakingSpace(o))\n        break;\n      t = t.slice(0, -1);\n    }\n    return t;\n  }, r.isNewline = function(t) {\n    return typeof t != \"string\" ? !1 : r._newlines.indexOf(t.charCodeAt(0)) >= 0;\n  }, r.isBreakingSpace = function(t, e) {\n    return typeof t != \"string\" ? !1 : r._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;\n  }, r.tokenize = function(t) {\n    var e = [], o = \"\";\n    if (typeof t != \"string\")\n      return e;\n    for (var T = 0; T < t.length; T++) {\n      var S = t[T], N = t[T + 1];\n      if (r.isBreakingSpace(S, N) || r.isNewline(S)) {\n        o !== \"\" && (e.push(o), o = \"\"), e.push(S);\n        continue;\n      }\n      o += S;\n    }\n    return o !== \"\" && e.push(o), e;\n  }, r.canBreakWords = function(t, e) {\n    return e;\n  }, r.canBreakChars = function(t, e, o, T, S) {\n    return !0;\n  }, r.wordWrapSplit = function(t) {\n    return t.split(\"\");\n  }, r.measureFont = function(t) {\n    if (r._fonts[t])\n      return r._fonts[t];\n    var e = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, o = r._canvas, T = r._context;\n    T.font = t;\n    var S = r.METRICS_STRING + r.BASELINE_SYMBOL, N = Math.ceil(T.measureText(S).width), D = Math.ceil(T.measureText(r.BASELINE_SYMBOL).width), B = Math.ceil(r.HEIGHT_MULTIPLIER * D);\n    D = D * r.BASELINE_MULTIPLIER | 0, o.width = N, o.height = B, T.fillStyle = \"#f00\", T.fillRect(0, 0, N, B), T.font = t, T.textBaseline = \"alphabetic\", T.fillStyle = \"#000\", T.fillText(S, 0, D);\n    var $ = T.getImageData(0, 0, N, B).data, U = $.length, z = N * 4, V = 0, X = 0, W = !1;\n    for (V = 0; V < D; ++V) {\n      for (var Y = 0; Y < z; Y += 4)\n        if ($[X + Y] !== 255) {\n          W = !0;\n          break;\n        }\n      if (!W)\n        X += z;\n      else\n        break;\n    }\n    for (e.ascent = D - V, X = U - z, W = !1, V = B; V > D; --V) {\n      for (var Y = 0; Y < z; Y += 4)\n        if ($[X + Y] !== 255) {\n          W = !0;\n          break;\n        }\n      if (!W)\n        X -= z;\n      else\n        break;\n    }\n    return e.descent = V - D, e.fontSize = e.ascent + e.descent, r._fonts[t] = e, e;\n  }, r.clearMetrics = function(t) {\n    t === void 0 && (t = \"\"), t ? delete r._fonts[t] : r._fonts = {};\n  }, Object.defineProperty(r, \"_canvas\", {\n    get: function() {\n      if (!r.__canvas) {\n        var t = void 0;\n        try {\n          var e = new OffscreenCanvas(0, 0), o = e.getContext(\"2d\");\n          if (o && o.measureText)\n            return r.__canvas = e, e;\n          t = settings$1.ADAPTER.createCanvas();\n        } catch {\n          t = settings$1.ADAPTER.createCanvas();\n        }\n        t.width = t.height = 10, r.__canvas = t;\n      }\n      return r.__canvas;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r, \"_context\", {\n    get: function() {\n      return r.__context || (r.__context = r._canvas.getContext(\"2d\")), r.__context;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n}();\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar defaultDestroyOptions = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, Text = function(r) {\n  __extends$j(t, r);\n  function t(e, o, T) {\n    var S = this, N = !1;\n    T || (T = settings$1.ADAPTER.createCanvas(), N = !0), T.width = 3, T.height = 3;\n    var D = Texture.from(T);\n    return D.orig = new Rectangle(), D.trim = new Rectangle(), S = r.call(this, D) || this, S._ownCanvas = N, S.canvas = T, S.context = T.getContext(\"2d\"), S._resolution = settings$1.RESOLUTION, S._autoResolution = !0, S._text = null, S._style = null, S._styleListener = null, S._font = \"\", S.text = e, S.style = o, S.localStyleID = -1, S;\n  }\n  return t.prototype.updateText = function(e) {\n    var o = this._style;\n    if (this.localStyleID !== o.styleID && (this.dirty = !0, this.localStyleID = o.styleID), !(!this.dirty && e)) {\n      this._font = this._style.toFontString();\n      var T = this.context, S = TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), N = S.width, D = S.height, B = S.lines, $ = S.lineHeight, U = S.lineWidths, z = S.maxLineWidth, V = S.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, N) + o.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, D) + o.padding * 2) * this._resolution), T.scale(this._resolution, this._resolution), T.clearRect(0, 0, this.canvas.width, this.canvas.height), T.font = this._font, T.lineWidth = o.strokeThickness, T.textBaseline = o.textBaseline, T.lineJoin = o.lineJoin, T.miterLimit = o.miterLimit;\n      for (var X, W, Y = o.dropShadow ? 2 : 1, q = 0; q < Y; ++q) {\n        var Z = o.dropShadow && q === 0, K = Z ? Math.ceil(Math.max(1, D) + o.padding * 2) : 0, J = K * this._resolution;\n        if (Z) {\n          T.fillStyle = \"black\", T.strokeStyle = \"black\";\n          var tt = o.dropShadowColor, et = hex2rgb(typeof tt == \"number\" ? tt : string2hex(tt)), Q = o.dropShadowBlur * this._resolution, at = o.dropShadowDistance * this._resolution;\n          T.shadowColor = \"rgba(\" + et[0] * 255 + \",\" + et[1] * 255 + \",\" + et[2] * 255 + \",\" + o.dropShadowAlpha + \")\", T.shadowBlur = Q, T.shadowOffsetX = Math.cos(o.dropShadowAngle) * at, T.shadowOffsetY = Math.sin(o.dropShadowAngle) * at + J;\n        } else\n          T.fillStyle = this._generateFillStyle(o, B, S), T.strokeStyle = o.stroke, T.shadowColor = \"black\", T.shadowBlur = 0, T.shadowOffsetX = 0, T.shadowOffsetY = 0;\n        var it = ($ - V.fontSize) / 2;\n        (!t.nextLineHeightBehavior || $ - V.fontSize < 0) && (it = 0);\n        for (var st = 0; st < B.length; st++)\n          X = o.strokeThickness / 2, W = o.strokeThickness / 2 + st * $ + V.ascent + it, o.align === \"right\" ? X += z - U[st] : o.align === \"center\" && (X += (z - U[st]) / 2), o.stroke && o.strokeThickness && this.drawLetterSpacing(B[st], X + o.padding, W + o.padding - K, !0), o.fill && this.drawLetterSpacing(B[st], X + o.padding, W + o.padding - K);\n      }\n      this.updateTexture();\n    }\n  }, t.prototype.drawLetterSpacing = function(e, o, T, S) {\n    S === void 0 && (S = !1);\n    var N = this._style, D = N.letterSpacing, B = t.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n    if (D === 0 || B) {\n      B && (this.context.letterSpacing = D, this.context.textLetterSpacing = D), S ? this.context.strokeText(e, o, T) : this.context.fillText(e, o, T);\n      return;\n    }\n    for (var $ = o, U = Array.from ? Array.from(e) : e.split(\"\"), z = this.context.measureText(e).width, V = 0, X = 0; X < U.length; ++X) {\n      var W = U[X];\n      S ? this.context.strokeText(W, $, T) : this.context.fillText(W, $, T);\n      for (var Y = \"\", q = X + 1; q < U.length; ++q)\n        Y += U[q];\n      V = this.context.measureText(Y).width, $ += z - V + D, z = V;\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.canvas;\n    if (this._style.trim) {\n      var o = trimCanvas(e);\n      o.data && (e.width = o.width, e.height = o.height, this.context.putImageData(o.data, 0, 0));\n    }\n    var T = this._texture, S = this._style, N = S.trim ? 0 : S.padding, D = T.baseTexture;\n    T.trim.width = T._frame.width = e.width / this._resolution, T.trim.height = T._frame.height = e.height / this._resolution, T.trim.x = -N, T.trim.y = -N, T.orig.width = T._frame.width - N * 2, T.orig.height = T._frame.height - N * 2, this._onTextureUpdate(), D.setRealSize(e.width, e.height, this._resolution), T.updateUvs(), this.dirty = !1;\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), r.prototype._render.call(this, e);\n  }, t.prototype.updateTransform = function() {\n    this.updateText(!0), r.prototype.updateTransform.call(this);\n  }, t.prototype.getBounds = function(e, o) {\n    return this.updateText(!0), this._textureID === -1 && (e = !1), r.prototype.getBounds.call(this, e, o);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.updateText(!0), r.prototype.getLocalBounds.call(this, e);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n  }, t.prototype._generateFillStyle = function(e, o, T) {\n    var S = e.fill;\n    if (Array.isArray(S)) {\n      if (S.length === 1)\n        return S[0];\n    } else\n      return S;\n    var N, D = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = this.canvas.width / this._resolution - D - B * 2, U = this.canvas.height / this._resolution - D - B * 2, z = S.slice(), V = e.fillGradientStops.slice();\n    if (!V.length)\n      for (var X = z.length + 1, W = 1; W < X; ++W)\n        V.push(W / X);\n    if (z.unshift(S[0]), V.unshift(0), z.push(S[S.length - 1]), V.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      N = this.context.createLinearGradient($ / 2, B, $ / 2, U + B);\n      for (var Y = T.fontProperties.fontSize + e.strokeThickness, W = 0; W < o.length; W++) {\n        var q = T.lineHeight * (W - 1) + Y, Z = T.lineHeight * W, K = Z;\n        W > 0 && q > Z && (K = (Z + q) / 2);\n        var J = Z + Y, tt = T.lineHeight * (W + 1), et = J;\n        W + 1 < o.length && tt < J && (et = (J + tt) / 2);\n        for (var Q = (et - K) / U, at = 0; at < z.length; at++) {\n          var it = 0;\n          typeof V[at] == \"number\" ? it = V[at] : it = at / z.length;\n          var st = Math.min(1, Math.max(0, K / U + it * Q));\n          st = Number(st.toFixed(5)), N.addColorStop(st, z[at]);\n        }\n      }\n    } else {\n      N = this.context.createLinearGradient(B, U / 2, $ + B, U / 2);\n      for (var ut = z.length + 1, ft = 1, W = 0; W < z.length; W++) {\n        var ct = void 0;\n        typeof V[W] == \"number\" ? ct = V[W] : ct = ft / ut, N.addColorStop(ct, z[W]), ft++;\n      }\n    }\n    return N;\n  }, t.prototype.destroy = function(e) {\n    typeof e == \"boolean\" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), r.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var o = sign(this.scale.x) || 1;\n      this.scale.x = o * e / this._texture.orig.width, this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function(e) {\n      this.updateText(!0);\n      var o = sign(this.scale.y) || 1;\n      this.scale.y = o * e / this._texture.orig.height, this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"style\", {\n    get: function() {\n      return this._style;\n    },\n    set: function(e) {\n      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e == null ? \"\" : e), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;\n}(Sprite);\n/*!\n * @pixi/prepare - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings$1.UPLOADS_PER_FRAME = 4;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$i = function(r, t) {\n  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$i(r, t);\n};\nfunction __extends$i(r, t) {\n  extendStatics$i(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar CountLimiter = function() {\n  function r(t) {\n    this.maxItemsPerFrame = t, this.itemsLeft = 0;\n  }\n  return r.prototype.beginFrame = function() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }, r.prototype.allowedToUpload = function() {\n    return this.itemsLeft-- > 0;\n  }, r;\n}();\nfunction findMultipleBaseTextures(r, t) {\n  var e = !1;\n  if (r && r._textures && r._textures.length) {\n    for (var o = 0; o < r._textures.length; o++)\n      if (r._textures[o] instanceof Texture) {\n        var T = r._textures[o].baseTexture;\n        t.indexOf(T) === -1 && (t.push(T), e = !0);\n      }\n  }\n  return e;\n}\nfunction findBaseTexture(r, t) {\n  if (r.baseTexture instanceof BaseTexture) {\n    var e = r.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTexture(r, t) {\n  if (r._texture && r._texture instanceof Texture) {\n    var e = r._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction drawText(r, t) {\n  return t instanceof Text ? (t.updateText(!0), !0) : !1;\n}\nfunction calculateTextStyle(r, t) {\n  if (t instanceof TextStyle) {\n    var e = t.toFontString();\n    return TextMetrics.measureFont(e), !0;\n  }\n  return !1;\n}\nfunction findText(r, t) {\n  if (r instanceof Text) {\n    t.indexOf(r.style) === -1 && t.push(r.style), t.indexOf(r) === -1 && t.push(r);\n    var e = r._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction findTextStyle(r, t) {\n  return r instanceof TextStyle ? (t.indexOf(r) === -1 && t.push(r), !0) : !1;\n}\nvar BasePrepare = function() {\n  function r(t) {\n    var e = this;\n    this.limiter = new CountLimiter(settings$1.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {\n      !e.queue || e.prepareItems();\n    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);\n  }\n  return r.prototype.upload = function(t, e) {\n    var o = this;\n    return typeof t == \"function\" && (e = t, t = null), e && deprecation$1(\"6.5.0\", \"BasePrepare.upload callback is deprecated, use the return Promise instead.\"), new Promise(function(T) {\n      t && o.add(t);\n      var S = function() {\n        e == null || e(), T();\n      };\n      o.queue.length ? (o.completes.push(S), o.ticking || (o.ticking = !0, Ticker.system.addOnce(o.tick, o, UPDATE_PRIORITY.UTILITY))) : S();\n    });\n  }, r.prototype.tick = function() {\n    setTimeout(this.delayedTick, 0);\n  }, r.prototype.prepareItems = function() {\n    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n      var t = this.queue[0], e = !1;\n      if (t && !t._destroyed) {\n        for (var o = 0, T = this.uploadHooks.length; o < T; o++)\n          if (this.uploadHooks[o](this.uploadHookHelper, t)) {\n            this.queue.shift(), e = !0;\n            break;\n          }\n      }\n      e || this.queue.shift();\n    }\n    if (this.queue.length)\n      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n    else {\n      this.ticking = !1;\n      var S = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var o = 0, T = S.length; o < T; o++)\n        S[o]();\n    }\n  }, r.prototype.registerFindHook = function(t) {\n    return t && this.addHooks.push(t), this;\n  }, r.prototype.registerUploadHook = function(t) {\n    return t && this.uploadHooks.push(t), this;\n  }, r.prototype.add = function(t) {\n    for (var e = 0, o = this.addHooks.length; e < o && !this.addHooks[e](t, this.queue); e++)\n      ;\n    if (t instanceof Container)\n      for (var e = t.children.length - 1; e >= 0; e--)\n        this.add(t.children[e]);\n    return this;\n  }, r.prototype.destroy = function() {\n    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n  }, r;\n}();\nfunction uploadBaseTextures(r, t) {\n  return t instanceof BaseTexture ? (t._glTextures[r.CONTEXT_UID] || r.texture.bind(t), !0) : !1;\n}\nfunction uploadGraphics(r, t) {\n  if (!(t instanceof Graphics))\n    return !1;\n  var e = t.geometry;\n  t.finishPoly(), e.updateBatches();\n  for (var o = e.batches, T = 0; T < o.length; T++) {\n    var S = o[T].style.texture;\n    S && uploadBaseTextures(r, S.baseTexture);\n  }\n  return e.batchable || r.geometry.bind(e, t._resolveDirectShader(r)), !0;\n}\nfunction findGraphics(r, t) {\n  return r instanceof Graphics ? (t.push(r), !0) : !1;\n}\nvar Prepare = function(r) {\n  __extends$i(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return o.uploadHookHelper = o.renderer, o.registerFindHook(findGraphics), o.registerUploadHook(uploadBaseTextures), o.registerUploadHook(uploadGraphics), o;\n  }\n  return t.extension = {\n    name: \"prepare\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(BasePrepare);\n/*!\n * @pixi/spritesheet - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Spritesheet = function() {\n  function r(t, e, o) {\n    o === void 0 && (o = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;\n    var T = this.baseTexture.resource;\n    this.resolution = this._updateResolution(o || (T ? T.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n  }\n  return r.prototype._updateResolution = function(t) {\n    t === void 0 && (t = null);\n    var e = this.data.meta.scale, o = getResolutionOfUrl(t, null);\n    return o === null && (o = e !== void 0 ? parseFloat(e) : 1), o !== 1 && this.baseTexture.setResolution(o), o;\n  }, r.prototype.parse = function(t) {\n    var e = this;\n    return t && deprecation$1(\"6.5.0\", \"Spritesheet.parse callback is deprecated, use the return Promise instead.\"), new Promise(function(o) {\n      e._callback = function(T) {\n        t == null || t(T), o(T);\n      }, e._batchIndex = 0, e._frameKeys.length <= r.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();\n    });\n  }, r.prototype._processFrames = function(t) {\n    for (var e = t, o = r.BATCH_SIZE; e - t < o && e < this._frameKeys.length; ) {\n      var T = this._frameKeys[e], S = this._frames[T], N = S.frame;\n      if (N) {\n        var D = null, B = null, $ = S.trimmed !== !1 && S.sourceSize ? S.sourceSize : S.frame, U = new Rectangle(0, 0, Math.floor($.w) / this.resolution, Math.floor($.h) / this.resolution);\n        S.rotated ? D = new Rectangle(Math.floor(N.x) / this.resolution, Math.floor(N.y) / this.resolution, Math.floor(N.h) / this.resolution, Math.floor(N.w) / this.resolution) : D = new Rectangle(Math.floor(N.x) / this.resolution, Math.floor(N.y) / this.resolution, Math.floor(N.w) / this.resolution, Math.floor(N.h) / this.resolution), S.trimmed !== !1 && S.spriteSourceSize && (B = new Rectangle(Math.floor(S.spriteSourceSize.x) / this.resolution, Math.floor(S.spriteSourceSize.y) / this.resolution, Math.floor(N.w) / this.resolution, Math.floor(N.h) / this.resolution)), this.textures[T] = new Texture(this.baseTexture, D, U, B, S.rotated ? 2 : 0, S.anchor), Texture.addToCache(this.textures[T], T);\n      }\n      e++;\n    }\n  }, r.prototype._processAnimations = function() {\n    var t = this.data.animations || {};\n    for (var e in t) {\n      this.animations[e] = [];\n      for (var o = 0; o < t[e].length; o++) {\n        var T = t[e][o];\n        this.animations[e].push(this.textures[T]);\n      }\n    }\n  }, r.prototype._parseComplete = function() {\n    var t = this._callback;\n    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);\n  }, r.prototype._nextBatch = function() {\n    var t = this;\n    this._processFrames(this._batchIndex * r.BATCH_SIZE), this._batchIndex++, setTimeout(function() {\n      t._batchIndex * r.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());\n    }, 0);\n  }, r.prototype.destroy = function(t) {\n    var e;\n    t === void 0 && (t = !1);\n    for (var o in this.textures)\n      this.textures[o].destroy();\n    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n  }, r.BATCH_SIZE = 1e3, r;\n}(), SpritesheetLoader = function() {\n  function r() {\n  }\n  return r.use = function(t, e) {\n    var o, T, S = this, N = t.name + \"_image\";\n    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || S.resources[N]) {\n      e();\n      return;\n    }\n    var D = (T = (o = t.data) === null || o === void 0 ? void 0 : o.meta) === null || T === void 0 ? void 0 : T.related_multi_packs;\n    if (Array.isArray(D))\n      for (var B = function(W) {\n        if (typeof W != \"string\")\n          return \"continue\";\n        var Y = W.replace(\".json\", \"\"), q = url$1.resolve(t.url.replace(S.baseUrl, \"\"), W);\n        if (S.resources[Y] || Object.values(S.resources).some(function(K) {\n          return url$1.format(url$1.parse(K.url)) === q;\n        }))\n          return \"continue\";\n        var Z = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: t,\n          metadata: t.metadata\n        };\n        S.add(Y, q, Z);\n      }, $ = 0, U = D; $ < U.length; $++) {\n        var z = U[$];\n        B(z);\n      }\n    var V = {\n      crossOrigin: t.crossOrigin,\n      metadata: t.metadata.imageMetadata,\n      parentResource: t\n    }, X = r.getResourcePath(t, S.baseUrl);\n    S.add(N, X, V, function(Y) {\n      if (Y.error) {\n        e(Y.error);\n        return;\n      }\n      var q = new Spritesheet(Y.texture, t.data, t.url);\n      q.parse().then(function() {\n        t.spritesheet = q, t.textures = q.textures, e();\n      });\n    });\n  }, r.getResourcePath = function(t, e) {\n    return t.isDataUrl ? t.data.meta.image : url$1.resolve(t.url.replace(e, \"\"), t.data.meta.image);\n  }, r.extension = ExtensionType.Loader, r;\n}();\n/*!\n * @pixi/sprite-tiling - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$h = function(r, t) {\n  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$h(r, t);\n};\nfunction __extends$h(r, t) {\n  extendStatics$h(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tempPoint$1 = new Point();\n(function(r) {\n  __extends$h(t, r);\n  function t(e, o, T) {\n    o === void 0 && (o = 100), T === void 0 && (T = 100);\n    var S = r.call(this, e) || this;\n    return S.tileTransform = new Transform(), S._width = o, S._height = T, S.uvMatrix = S.texture.uvMatrix || new TextureMatrix(e), S.pluginName = \"tilingSprite\", S.uvRespectAnchor = !1, S;\n  }\n  return Object.defineProperty(t.prototype, \"clampMargin\", {\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(e) {\n      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tileScale\", {\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(e) {\n      this.tileTransform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tilePosition\", {\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(e) {\n      this.tileTransform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._onTextureUpdate = function() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }, t.prototype._render = function(e) {\n    var o = this._texture;\n    !o || !o.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));\n  }, t.prototype._calculateBounds = function() {\n    var e = this._width * -this._anchor._x, o = this._height * -this._anchor._y, T = this._width * (1 - this._anchor._x), S = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, e, o, T, S);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : r.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, tempPoint$1);\n    var o = this._width, T = this._height, S = -o * this.anchor._x;\n    if (tempPoint$1.x >= S && tempPoint$1.x < S + o) {\n      var N = -T * this.anchor._y;\n      if (tempPoint$1.y >= N && tempPoint$1.y < N + T)\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    r.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;\n  }, t.from = function(e, o) {\n    var T = e instanceof Texture ? e : Texture.from(e, o);\n    return new t(T, o.width, o.height);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Sprite);\nvar fragmentSimpleSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`, gl1VertexSrc = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl1FragmentSrc = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`, gl2VertexSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, gl2FragmentSrc = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`, tempMat = new Matrix(), TilingSpriteRenderer = function(r) {\n  __extends$h(t, r);\n  function t(e) {\n    var o = r.call(this, e) || this;\n    return e.runners.contextChange.add(o), o.quad = new QuadUv(), o.state = State.for2d(), o;\n  }\n  return t.prototype.contextChange = function() {\n    var e = this.renderer, o = { globals: e.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, o), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, o) : Shader.from(gl1VertexSrc, gl1FragmentSrc, o);\n  }, t.prototype.render = function(e) {\n    var o = this.renderer, T = this.quad, S = T.vertices;\n    S[0] = S[6] = e._width * -e.anchor.x, S[1] = S[3] = e._height * -e.anchor.y, S[2] = S[4] = e._width * (1 - e.anchor.x), S[5] = S[7] = e._height * (1 - e.anchor.y);\n    var N = e.uvRespectAnchor ? e.anchor.x : 0, D = e.uvRespectAnchor ? e.anchor.y : 0;\n    S = T.uvs, S[0] = S[6] = -N, S[1] = S[3] = -D, S[2] = S[4] = 1 - N, S[5] = S[7] = 1 - D, T.invalidate();\n    var B = e._texture, $ = B.baseTexture, U = $.alphaMode > 0, z = e.tileTransform.localTransform, V = e.uvMatrix, X = $.isPowerOfTwo && B.frame.width === $.width && B.frame.height === $.height;\n    X && ($._glTextures[o.CONTEXT_UID] ? X = $.wrapMode !== WRAP_MODES$5.CLAMP : $.wrapMode === WRAP_MODES$5.CLAMP && ($.wrapMode = WRAP_MODES$5.REPEAT));\n    var W = X ? this.simpleShader : this.shader, Y = B.width, q = B.height, Z = e._width, K = e._height;\n    tempMat.set(z.a * Y / Z, z.b * Y / K, z.c * q / Z, z.d * q / K, z.tx / Z, z.ty / K), tempMat.invert(), X ? tempMat.prepend(V.mapCoord) : (W.uniforms.uMapCoord = V.mapCoord.toArray(!0), W.uniforms.uClampFrame = V.uClampFrame, W.uniforms.uClampOffset = V.uClampOffset), W.uniforms.uTransform = tempMat.toArray(!0), W.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, W.uniforms.uColor, U), W.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), W.uniforms.uSampler = B, o.shader.bind(W), o.geometry.bind(T), this.state.blendMode = correctBlendMode(e.blendMode, U), o.state.set(this.state), o.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }, t.extension = {\n    name: \"tilingSprite\",\n    type: ExtensionType.RendererPlugin\n  }, t;\n}(ObjectRenderer);\n/*!\n * @pixi/mesh - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$g = function(r, t) {\n  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$g(r, t);\n};\nfunction __extends$g(r, t) {\n  extendStatics$g(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar MeshBatchUvs = function() {\n  function r(t, e) {\n    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n  }\n  return r.prototype.update = function(t) {\n    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {\n      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n      var e = this.uvBuffer.data;\n      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;\n    }\n  }, r;\n}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(r) {\n  __extends$g(t, r);\n  function t(e, o, T, S) {\n    S === void 0 && (S = DRAW_MODES$5.TRIANGLES);\n    var N = r.call(this) || this;\n    return N.geometry = e, N.shader = o, N.state = T || State.for2d(), N.drawMode = S, N.start = 0, N.size = 0, N.uvs = null, N.indices = null, N.vertexData = new Float32Array(1), N.vertexDirty = -1, N._transformID = -1, N._roundPixels = settings$1.ROUND_PIXELS, N.batchUvs = null, N;\n  }\n  return Object.defineProperty(t.prototype, \"geometry\", {\n    get: function() {\n      return this._geometry;\n    },\n    set: function(e) {\n      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"uvBuffer\", {\n    get: function() {\n      return this.geometry.buffers[1];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"verticesBuffer\", {\n    get: function() {\n      return this.geometry.buffers[0];\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"material\", {\n    get: function() {\n      return this.shader;\n    },\n    set: function(e) {\n      this.shader = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.state.blendMode;\n    },\n    set: function(e) {\n      this.state.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function(e) {\n      this.shader.tint = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function(e) {\n      this.shader.texture = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    var o = this.geometry.buffers[0].data, T = this.shader;\n    T.batchable && this.drawMode === DRAW_MODES$5.TRIANGLES && o.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);\n  }, t.prototype._renderDefault = function(e) {\n    var o = this.shader;\n    o.alpha = this.worldAlpha, o.update && o.update(), e.batch.flush(), o.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(o), e.state.set(this.state), e.geometry.bind(this.geometry, o), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }, t.prototype._renderToBatch = function(e) {\n    var o = this.geometry, T = this.shader;\n    T.uvMatrix && (T.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = o.indexBuffer.data, this._tintRGB = T._tintRGB, this._texture = T.texture;\n    var S = this.material.pluginName;\n    e.batch.setObjectRenderer(e.plugins[S]), e.plugins[S].render(this);\n  }, t.prototype.calculateVertices = function() {\n    var e = this.geometry, o = e.buffers[0], T = o.data, S = o._updateID;\n    if (!(S === this.vertexDirty && this._transformID === this.transform._worldID)) {\n      this._transformID = this.transform._worldID, this.vertexData.length !== T.length && (this.vertexData = new Float32Array(T.length));\n      for (var N = this.transform.worldTransform, D = N.a, B = N.b, $ = N.c, U = N.d, z = N.tx, V = N.ty, X = this.vertexData, W = 0; W < X.length / 2; W++) {\n        var Y = T[W * 2], q = T[W * 2 + 1];\n        X[W * 2] = D * Y + $ * q + z, X[W * 2 + 1] = B * Y + U * q + V;\n      }\n      if (this._roundPixels)\n        for (var Z = settings$1.RESOLUTION, W = 0; W < X.length; ++W)\n          X[W] = Math.round((X[W] * Z | 0) / Z);\n      this.vertexDirty = S;\n    }\n  }, t.prototype.calculateUvs = function() {\n    var e = this.geometry.buffers[1], o = this.shader;\n    o.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, o.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n  }, t.prototype._calculateBounds = function() {\n    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }, t.prototype.containsPoint = function(e) {\n    if (!this.getBounds().contains(e.x, e.y))\n      return !1;\n    this.worldTransform.applyInverse(e, tempPoint);\n    for (var o = this.geometry.getBuffer(\"aVertexPosition\").data, T = tempPolygon.points, S = this.geometry.getIndex().data, N = S.length, D = this.drawMode === 4 ? 3 : 1, B = 0; B + 2 < N; B += D) {\n      var $ = S[B] * 2, U = S[B + 1] * 2, z = S[B + 2] * 2;\n      if (T[0] = o[$], T[1] = o[$ + 1], T[2] = o[U], T[3] = o[U + 1], T[4] = o[z], T[5] = o[z + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    r.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n  }, t.BATCHABLE_SIZE = 100, t;\n}(Container), fragment$5 = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`, vertex$2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`, MeshMaterial = function(r) {\n  __extends$g(t, r);\n  function t(e, o) {\n    var T = this, S = {\n      uSampler: e,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    return o = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: \"batch\"\n    }, o), o.uniforms && Object.assign(S, o.uniforms), T = r.call(this, o.program || Program.from(vertex$2, fragment$5), S) || this, T._colorDirty = !1, T.uvMatrix = new TextureMatrix(e), T.batchable = o.program === void 0, T.pluginName = o.pluginName, T.tint = o.tint, T.alpha = o.alpha, T;\n  }\n  return Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.uniforms.uSampler;\n    },\n    set: function(e) {\n      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this._alpha;\n    },\n    set: function(e) {\n      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.update = function() {\n    if (this._colorDirty) {\n      this._colorDirty = !1;\n      var e = this.texture.baseTexture;\n      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);\n    }\n    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n  }, t;\n}(Shader), MeshGeometry = function(r) {\n  __extends$g(t, r);\n  function t(e, o, T) {\n    var S = r.call(this) || this, N = new Buffer$1(e), D = new Buffer$1(o, !0), B = new Buffer$1(T, !0, !0);\n    return S.addAttribute(\"aVertexPosition\", N, 2, !1, TYPES$5.FLOAT).addAttribute(\"aTextureCoord\", D, 2, !1, TYPES$5.FLOAT).addIndex(B), S._updateId = -1, S;\n  }\n  return Object.defineProperty(t.prototype, \"vertexDirtyId\", {\n    get: function() {\n      return this.buffers[0]._updateID;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Geometry);\n/*!\n * @pixi/text-bitmap - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$f = function(r, t) {\n  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$f(r, t);\n};\nfunction __extends$f(r, t) {\n  extendStatics$f(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar BitmapFontData = function() {\n  function r() {\n    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n  }\n  return r;\n}(), TextFormat = function() {\n  function r() {\n  }\n  return r.test = function(t) {\n    return typeof t == \"string\" && t.indexOf(\"info face=\") === 0;\n  }, r.parse = function(t) {\n    var e = t.match(/^[a-z]+\\s+.+$/gm), o = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (var T in e) {\n      var S = e[T].match(/^[a-z]+/gm)[0], N = e[T].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm), D = {};\n      for (var B in N) {\n        var $ = N[B].split(\"=\"), U = $[0], z = $[1].replace(/\"/gm, \"\"), V = parseFloat(z), X = isNaN(V) ? z : V;\n        D[U] = X;\n      }\n      o[S].push(D);\n    }\n    var W = new BitmapFontData();\n    return o.info.forEach(function(Y) {\n      return W.info.push({\n        face: Y.face,\n        size: parseInt(Y.size, 10)\n      });\n    }), o.common.forEach(function(Y) {\n      return W.common.push({\n        lineHeight: parseInt(Y.lineHeight, 10)\n      });\n    }), o.page.forEach(function(Y) {\n      return W.page.push({\n        id: parseInt(Y.id, 10),\n        file: Y.file\n      });\n    }), o.char.forEach(function(Y) {\n      return W.char.push({\n        id: parseInt(Y.id, 10),\n        page: parseInt(Y.page, 10),\n        x: parseInt(Y.x, 10),\n        y: parseInt(Y.y, 10),\n        width: parseInt(Y.width, 10),\n        height: parseInt(Y.height, 10),\n        xoffset: parseInt(Y.xoffset, 10),\n        yoffset: parseInt(Y.yoffset, 10),\n        xadvance: parseInt(Y.xadvance, 10)\n      });\n    }), o.kerning.forEach(function(Y) {\n      return W.kerning.push({\n        first: parseInt(Y.first, 10),\n        second: parseInt(Y.second, 10),\n        amount: parseInt(Y.amount, 10)\n      });\n    }), o.distanceField.forEach(function(Y) {\n      return W.distanceField.push({\n        distanceRange: parseInt(Y.distanceRange, 10),\n        fieldType: Y.fieldType\n      });\n    }), W;\n  }, r;\n}(), XMLFormat = function() {\n  function r() {\n  }\n  return r.test = function(t) {\n    return t instanceof XMLDocument && t.getElementsByTagName(\"page\").length && t.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  }, r.parse = function(t) {\n    for (var e = new BitmapFontData(), o = t.getElementsByTagName(\"info\"), T = t.getElementsByTagName(\"common\"), S = t.getElementsByTagName(\"page\"), N = t.getElementsByTagName(\"char\"), D = t.getElementsByTagName(\"kerning\"), B = t.getElementsByTagName(\"distanceField\"), $ = 0; $ < o.length; $++)\n      e.info.push({\n        face: o[$].getAttribute(\"face\"),\n        size: parseInt(o[$].getAttribute(\"size\"), 10)\n      });\n    for (var $ = 0; $ < T.length; $++)\n      e.common.push({\n        lineHeight: parseInt(T[$].getAttribute(\"lineHeight\"), 10)\n      });\n    for (var $ = 0; $ < S.length; $++)\n      e.page.push({\n        id: parseInt(S[$].getAttribute(\"id\"), 10) || 0,\n        file: S[$].getAttribute(\"file\")\n      });\n    for (var $ = 0; $ < N.length; $++) {\n      var U = N[$];\n      e.char.push({\n        id: parseInt(U.getAttribute(\"id\"), 10),\n        page: parseInt(U.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(U.getAttribute(\"x\"), 10),\n        y: parseInt(U.getAttribute(\"y\"), 10),\n        width: parseInt(U.getAttribute(\"width\"), 10),\n        height: parseInt(U.getAttribute(\"height\"), 10),\n        xoffset: parseInt(U.getAttribute(\"xoffset\"), 10),\n        yoffset: parseInt(U.getAttribute(\"yoffset\"), 10),\n        xadvance: parseInt(U.getAttribute(\"xadvance\"), 10)\n      });\n    }\n    for (var $ = 0; $ < D.length; $++)\n      e.kerning.push({\n        first: parseInt(D[$].getAttribute(\"first\"), 10),\n        second: parseInt(D[$].getAttribute(\"second\"), 10),\n        amount: parseInt(D[$].getAttribute(\"amount\"), 10)\n      });\n    for (var $ = 0; $ < B.length; $++)\n      e.distanceField.push({\n        fieldType: B[$].getAttribute(\"fieldType\"),\n        distanceRange: parseInt(B[$].getAttribute(\"distanceRange\"), 10)\n      });\n    return e;\n  }, r;\n}(), XMLStringFormat = function() {\n  function r() {\n  }\n  return r.test = function(t) {\n    if (typeof t == \"string\" && t.indexOf(\"<font>\") > -1) {\n      var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n      return XMLFormat.test(e);\n    }\n    return !1;\n  }, r.parse = function(t) {\n    var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n    return XMLFormat.parse(e);\n  }, r;\n}(), formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(r) {\n  for (var t = 0; t < formats.length; t++)\n    if (formats[t].test(r))\n      return formats[t];\n  return null;\n}\nfunction generateFillStyle(r, t, e, o, T, S) {\n  var N = e.fill;\n  if (Array.isArray(N)) {\n    if (N.length === 1)\n      return N[0];\n  } else\n    return N;\n  var D, B = e.dropShadow ? e.dropShadowDistance : 0, $ = e.padding || 0, U = r.width / o - B - $ * 2, z = r.height / o - B - $ * 2, V = N.slice(), X = e.fillGradientStops.slice();\n  if (!X.length)\n    for (var W = V.length + 1, Y = 1; Y < W; ++Y)\n      X.push(Y / W);\n  if (V.unshift(N[0]), X.unshift(0), V.push(N[N.length - 1]), X.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    D = t.createLinearGradient(U / 2, $, U / 2, z + $);\n    for (var q = 0, Z = S.fontProperties.fontSize + e.strokeThickness, K = Z / z, Y = 0; Y < T.length; Y++)\n      for (var J = S.lineHeight * Y, tt = 0; tt < V.length; tt++) {\n        var et = 0;\n        typeof X[tt] == \"number\" ? et = X[tt] : et = tt / V.length;\n        var Q = J / z + et * K, at = Math.max(q, Q);\n        at = Math.min(at, 1), D.addColorStop(at, V[tt]), q = at;\n      }\n  } else {\n    D = t.createLinearGradient($, z / 2, U + $, z / 2);\n    for (var it = V.length + 1, st = 1, Y = 0; Y < V.length; Y++) {\n      var ut = void 0;\n      typeof X[Y] == \"number\" ? ut = X[Y] : ut = st / it, D.addColorStop(ut, V[Y]), st++;\n    }\n  }\n  return D;\n}\nfunction drawGlyph(r, t, e, o, T, S, N) {\n  var D = e.text, B = e.fontProperties;\n  t.translate(o, T), t.scale(S, S);\n  var $ = N.strokeThickness / 2, U = -(N.strokeThickness / 2);\n  if (t.font = N.toFontString(), t.lineWidth = N.strokeThickness, t.textBaseline = N.textBaseline, t.lineJoin = N.lineJoin, t.miterLimit = N.miterLimit, t.fillStyle = generateFillStyle(r, t, N, S, [D], e), t.strokeStyle = N.stroke, N.dropShadow) {\n    var z = N.dropShadowColor, V = hex2rgb(typeof z == \"number\" ? z : string2hex(z)), X = N.dropShadowBlur * S, W = N.dropShadowDistance * S;\n    t.shadowColor = \"rgba(\" + V[0] * 255 + \",\" + V[1] * 255 + \",\" + V[2] * 255 + \",\" + N.dropShadowAlpha + \")\", t.shadowBlur = X, t.shadowOffsetX = Math.cos(N.dropShadowAngle) * W, t.shadowOffsetY = Math.sin(N.dropShadowAngle) * W;\n  } else\n    t.shadowColor = \"black\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;\n  N.stroke && N.strokeThickness && t.strokeText(D, $, U + e.lineHeight - B.descent), N.fill && t.fillText(D, $, U + e.lineHeight - B.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction splitTextToCharacters(r) {\n  return Array.from ? Array.from(r) : r.split(\"\");\n}\nfunction resolveCharacters(r) {\n  typeof r == \"string\" && (r = [r]);\n  for (var t = [], e = 0, o = r.length; e < o; e++) {\n    var T = r[e];\n    if (Array.isArray(T)) {\n      if (T.length !== 2)\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + T.length + \".\");\n      var S = T[0].charCodeAt(0), N = T[1].charCodeAt(0);\n      if (N < S)\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      for (var D = S, B = N; D <= B; D++)\n        t.push(String.fromCharCode(D));\n    } else\n      t.push.apply(t, splitTextToCharacters(T));\n  }\n  if (t.length === 0)\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  return t;\n}\nfunction extractCharCode(r) {\n  return r.codePointAt ? r.codePointAt(0) : r.charCodeAt(0);\n}\nvar BitmapFont = function() {\n  function r(t, e, o) {\n    var T, S, N = t.info[0], D = t.common[0], B = t.page[0], $ = t.distanceField[0], U = getResolutionOfUrl(B.file), z = {};\n    this._ownsTextures = o, this.font = N.face, this.size = N.size, this.lineHeight = D.lineHeight / U, this.chars = {}, this.pageTextures = z;\n    for (var V = 0; V < t.page.length; V++) {\n      var X = t.page[V], W = X.id, Y = X.file;\n      z[W] = e instanceof Array ? e[V] : e[Y], ($ == null ? void 0 : $.fieldType) && $.fieldType !== \"none\" && (z[W].baseTexture.alphaMode = ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA, z[W].baseTexture.mipmap = MIPMAP_MODES$5.OFF);\n    }\n    for (var V = 0; V < t.char.length; V++) {\n      var q = t.char[V], W = q.id, Z = q.page, K = t.char[V], J = K.x, tt = K.y, et = K.width, Q = K.height, at = K.xoffset, it = K.yoffset, st = K.xadvance;\n      J /= U, tt /= U, et /= U, Q /= U, at /= U, it /= U, st /= U;\n      var ut = new Rectangle(J + z[Z].frame.x / U, tt + z[Z].frame.y / U, et, Q);\n      this.chars[W] = {\n        xOffset: at,\n        yOffset: it,\n        xAdvance: st,\n        kerning: {},\n        texture: new Texture(z[Z].baseTexture, ut),\n        page: Z\n      };\n    }\n    for (var V = 0; V < t.kerning.length; V++) {\n      var ft = t.kerning[V], ct = ft.first, pt = ft.second, mt = ft.amount;\n      ct /= U, pt /= U, mt /= U, this.chars[pt] && (this.chars[pt].kerning[ct] = mt);\n    }\n    this.distanceFieldRange = $ == null ? void 0 : $.distanceRange, this.distanceFieldType = (S = (T = $ == null ? void 0 : $.fieldType) === null || T === void 0 ? void 0 : T.toLowerCase()) !== null && S !== void 0 ? S : \"none\";\n  }\n  return r.prototype.destroy = function() {\n    for (var t in this.chars)\n      this.chars[t].texture.destroy(), this.chars[t].texture = null;\n    for (var t in this.pageTextures)\n      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;\n    this.chars = null, this.pageTextures = null;\n  }, r.install = function(t, e, o) {\n    var T;\n    if (t instanceof BitmapFontData)\n      T = t;\n    else {\n      var S = autoDetectFormat(t);\n      if (!S)\n        throw new Error(\"Unrecognized data format for font.\");\n      T = S.parse(t);\n    }\n    e instanceof Texture && (e = [e]);\n    var N = new r(T, e, o);\n    return r.available[N.font] = N, N;\n  }, r.uninstall = function(t) {\n    var e = r.available[t];\n    if (!e)\n      throw new Error(\"No font found named '\" + t + \"'\");\n    e.destroy(), delete r.available[t];\n  }, r.from = function(t, e, o) {\n    if (!t)\n      throw new Error(\"[BitmapFont] Property `name` is required.\");\n    var T = Object.assign({}, r.defaultOptions, o), S = T.chars, N = T.padding, D = T.resolution, B = T.textureWidth, $ = T.textureHeight, U = resolveCharacters(S), z = e instanceof TextStyle ? e : new TextStyle(e), V = B, X = new BitmapFontData();\n    X.info[0] = {\n      face: z.fontFamily,\n      size: z.fontSize\n    }, X.common[0] = {\n      lineHeight: z.fontSize\n    };\n    for (var W = 0, Y = 0, q, Z, K, J = 0, tt = [], et = 0; et < U.length; et++) {\n      q || (q = settings$1.ADAPTER.createCanvas(), q.width = B, q.height = $, Z = q.getContext(\"2d\"), K = new BaseTexture(q, { resolution: D }), tt.push(new Texture(K)), X.page.push({\n        id: tt.length - 1,\n        file: \"\"\n      }));\n      var Q = TextMetrics.measureText(U[et], z, !1, q), at = Q.width, it = Math.ceil(Q.height), st = Math.ceil((z.fontStyle === \"italic\" ? 2 : 1) * at);\n      if (Y >= $ - it * D) {\n        if (Y === 0)\n          throw new Error(\"[BitmapFont] textureHeight \" + $ + \"px is \" + (\"too small for \" + z.fontSize + \"px fonts\"));\n        --et, q = null, Z = null, K = null, Y = 0, W = 0, J = 0;\n        continue;\n      }\n      if (J = Math.max(it + Q.fontProperties.descent, J), st * D + W >= V) {\n        --et, Y += J * D, Y = Math.ceil(Y), W = 0, J = 0;\n        continue;\n      }\n      drawGlyph(q, Z, Q, W, Y, D, z);\n      var ut = extractCharCode(Q.text);\n      X.char.push({\n        id: ut,\n        page: tt.length - 1,\n        x: W / D,\n        y: Y / D,\n        width: st,\n        height: it,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: Math.ceil(at - (z.dropShadow ? z.dropShadowDistance : 0) - (z.stroke ? z.strokeThickness : 0))\n      }), W += (st + 2 * N) * D, W = Math.ceil(W);\n    }\n    for (var et = 0, ft = U.length; et < ft; et++)\n      for (var ct = U[et], pt = 0; pt < ft; pt++) {\n        var mt = U[pt], vt = Z.measureText(ct).width, _t = Z.measureText(mt).width, xt = Z.measureText(ct + mt).width, Rt = xt - (vt + _t);\n        Rt && X.kerning.push({\n          first: extractCharCode(ct),\n          second: extractCharCode(mt),\n          amount: Rt\n        });\n      }\n    var yt = new r(X, tt, !0);\n    return r.available[t] !== void 0 && r.uninstall(t), r.available[t] = yt, yt;\n  }, r.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"], r.NUMERIC = [[\"0\", \"9\"]], r.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"], r.ASCII = [[\" \", \"~\"]], r.defaultOptions = {\n    resolution: 1,\n    textureWidth: 512,\n    textureHeight: 512,\n    padding: 4,\n    chars: r.ALPHANUMERIC\n  }, r.available = {}, r;\n}(), msdfFrag = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\n\\r\n}\\r\n`, msdfVert = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];\n(function(r) {\n  __extends$f(t, r);\n  function t(e, o) {\n    o === void 0 && (o = {});\n    var T = r.call(this) || this;\n    T._tint = 16777215;\n    var S = Object.assign({}, t.styleDefaults, o), N = S.align, D = S.tint, B = S.maxWidth, $ = S.letterSpacing, U = S.fontName, z = S.fontSize;\n    if (!BitmapFont.available[U])\n      throw new Error('Missing BitmapFont \"' + U + '\"');\n    return T._activePagesMeshData = [], T._textWidth = 0, T._textHeight = 0, T._align = N, T._tint = D, T._fontName = U, T._fontSize = z || BitmapFont.available[U].size, T.text = e, T._maxWidth = B, T._maxLineHeight = 0, T._letterSpacing = $, T._anchor = new ObservablePoint(function() {\n      T.dirty = !0;\n    }, T, 0, 0), T._roundPixels = settings$1.ROUND_PIXELS, T.dirty = !0, T._resolution = settings$1.RESOLUTION, T._autoResolution = !0, T._textureCache = {}, T;\n  }\n  return t.prototype.updateText = function() {\n    for (var e, o = BitmapFont.available[this._fontName], T = this._fontSize / o.size, S = new Point(), N = [], D = [], B = [], $ = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \", U = splitTextToCharacters($), z = this._maxWidth * o.size / this._fontSize, V = o.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, X = null, W = 0, Y = 0, q = 0, Z = -1, K = 0, J = 0, tt = 0, et = 0, Q = 0; Q < U.length; Q++) {\n      var at = U[Q], it = extractCharCode(at);\n      if (/(?:\\s)/.test(at) && (Z = Q, K = W, et++), at === \"\\r\" || at === `\n`) {\n        D.push(W), B.push(-1), Y = Math.max(Y, W), ++q, ++J, S.x = 0, S.y += o.lineHeight, X = null, et = 0;\n        continue;\n      }\n      var st = o.chars[it];\n      if (!!st) {\n        X && st.kerning[X] && (S.x += st.kerning[X]);\n        var ut = charRenderDataPool.pop() || {\n          texture: Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new Point()\n        };\n        ut.texture = st.texture, ut.line = q, ut.charCode = it, ut.position.x = S.x + st.xOffset + this._letterSpacing / 2, ut.position.y = S.y + st.yOffset, ut.prevSpaces = et, N.push(ut), W = ut.position.x + Math.max(st.xAdvance - st.xOffset, st.texture.orig.width), S.x += st.xAdvance + this._letterSpacing, tt = Math.max(tt, st.yOffset + st.texture.height), X = it, Z !== -1 && z > 0 && S.x > z && (++J, removeItems(N, 1 + Z - J, 1 + Q - Z), Q = Z, Z = -1, D.push(K), B.push(N.length > 0 ? N[N.length - 1].prevSpaces : 0), Y = Math.max(Y, K), q++, S.x = 0, S.y += o.lineHeight, X = null, et = 0);\n      }\n    }\n    var ft = U[U.length - 1];\n    ft !== \"\\r\" && ft !== `\n` && (/(?:\\s)/.test(ft) && (W = K), D.push(W), Y = Math.max(Y, W), B.push(-1));\n    for (var ct = [], Q = 0; Q <= q; Q++) {\n      var pt = 0;\n      this._align === \"right\" ? pt = Y - D[Q] : this._align === \"center\" ? pt = (Y - D[Q]) / 2 : this._align === \"justify\" && (pt = B[Q] < 0 ? 0 : (Y - D[Q]) / B[Q]), ct.push(pt);\n    }\n    for (var mt = N.length, vt = {}, _t = [], xt = this._activePagesMeshData, Q = 0; Q < xt.length; Q++)\n      V.push(xt[Q]);\n    for (var Q = 0; Q < mt; Q++) {\n      var Rt = N[Q].texture, yt = Rt.baseTexture.uid;\n      if (!vt[yt]) {\n        var ht = V.pop();\n        if (!ht) {\n          var bt = new MeshGeometry(), St = void 0, Ot = void 0;\n          o.distanceFieldType === \"none\" ? (St = new MeshMaterial(Texture.EMPTY), Ot = BLEND_MODES$5.NORMAL) : (St = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), Ot = BLEND_MODES$5.NORMAL_NPM);\n          var wt = new Mesh(bt, St);\n          wt.blendMode = Ot, ht = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh: wt,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        ht.index = 0, ht.indexCount = 0, ht.vertexCount = 0, ht.uvsCount = 0, ht.total = 0;\n        var Ft = this._textureCache;\n        Ft[yt] = Ft[yt] || new Texture(Rt.baseTexture), ht.mesh.texture = Ft[yt], ht.mesh.tint = this._tint, _t.push(ht), vt[yt] = ht;\n      }\n      vt[yt].total++;\n    }\n    for (var Q = 0; Q < xt.length; Q++)\n      _t.indexOf(xt[Q]) === -1 && this.removeChild(xt[Q].mesh);\n    for (var Q = 0; Q < _t.length; Q++)\n      _t[Q].mesh.parent !== this && this.addChild(_t[Q].mesh);\n    this._activePagesMeshData = _t;\n    for (var Q in vt) {\n      var ht = vt[Q], dt = ht.total;\n      if (!(((e = ht.indices) === null || e === void 0 ? void 0 : e.length) > 6 * dt) || ht.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n        ht.vertices = new Float32Array(4 * 2 * dt), ht.uvs = new Float32Array(4 * 2 * dt), ht.indices = new Uint16Array(6 * dt);\n      else\n        for (var Gt = ht.total, Mt = ht.vertices, Bt = Gt * 4 * 2; Bt < Mt.length; Bt++)\n          Mt[Bt] = 0;\n      ht.mesh.size = 6 * dt;\n    }\n    for (var Q = 0; Q < mt; Q++) {\n      var at = N[Q], Dt = at.position.x + ct[at.line] * (this._align === \"justify\" ? at.prevSpaces : 1);\n      this._roundPixels && (Dt = Math.round(Dt));\n      var Et = Dt * T, zt = at.position.y * T, Rt = at.texture, It = vt[Rt.baseTexture.uid], Ct = Rt.frame, Lt = Rt._uvs, $t = It.index++;\n      It.indices[$t * 6 + 0] = 0 + $t * 4, It.indices[$t * 6 + 1] = 1 + $t * 4, It.indices[$t * 6 + 2] = 2 + $t * 4, It.indices[$t * 6 + 3] = 0 + $t * 4, It.indices[$t * 6 + 4] = 2 + $t * 4, It.indices[$t * 6 + 5] = 3 + $t * 4, It.vertices[$t * 8 + 0] = Et, It.vertices[$t * 8 + 1] = zt, It.vertices[$t * 8 + 2] = Et + Ct.width * T, It.vertices[$t * 8 + 3] = zt, It.vertices[$t * 8 + 4] = Et + Ct.width * T, It.vertices[$t * 8 + 5] = zt + Ct.height * T, It.vertices[$t * 8 + 6] = Et, It.vertices[$t * 8 + 7] = zt + Ct.height * T, It.uvs[$t * 8 + 0] = Lt.x0, It.uvs[$t * 8 + 1] = Lt.y0, It.uvs[$t * 8 + 2] = Lt.x1, It.uvs[$t * 8 + 3] = Lt.y1, It.uvs[$t * 8 + 4] = Lt.x2, It.uvs[$t * 8 + 5] = Lt.y2, It.uvs[$t * 8 + 6] = Lt.x3, It.uvs[$t * 8 + 7] = Lt.y3;\n    }\n    this._textWidth = Y * T, this._textHeight = (S.y + o.lineHeight) * T;\n    for (var Q in vt) {\n      var ht = vt[Q];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        for (var At = 0, ee = this._textWidth * this.anchor.x, te = this._textHeight * this.anchor.y, he = 0; he < ht.total; he++)\n          ht.vertices[At++] -= ee, ht.vertices[At++] -= te, ht.vertices[At++] -= ee, ht.vertices[At++] -= te, ht.vertices[At++] -= ee, ht.vertices[At++] -= te, ht.vertices[At++] -= ee, ht.vertices[At++] -= te;\n      this._maxLineHeight = tt * T;\n      var we = ht.mesh.geometry.getBuffer(\"aVertexPosition\"), Be = ht.mesh.geometry.getBuffer(\"aTextureCoord\"), ne = ht.mesh.geometry.getIndex();\n      we.data = ht.vertices, Be.data = ht.uvs, ne.data = ht.indices, we.update(), Be.update(), ne.update();\n    }\n    for (var Q = 0; Q < N.length; Q++)\n      charRenderDataPool.push(N[Q]);\n  }, t.prototype.updateTransform = function() {\n    this.validate(), this.containerUpdateTransform();\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);\n    var o = BitmapFont.available[this._fontName], T = o.distanceFieldRange, S = o.distanceFieldType, N = o.size;\n    if (S !== \"none\")\n      for (var D = this.worldTransform, B = D.a, $ = D.b, U = D.c, z = D.d, V = Math.sqrt(B * B + $ * $), X = Math.sqrt(U * U + z * z), W = (Math.abs(V) + Math.abs(X)) / 2, Y = this._fontSize / N, q = 0, Z = this._activePagesMeshData; q < Z.length; q++) {\n        var K = Z[q];\n        K.mesh.shader.uniforms.uFWidth = Math.min(W * T * Y * this._resolution, 1);\n      }\n    r.prototype._render.call(this, e);\n  }, t.prototype.getLocalBounds = function() {\n    return this.validate(), r.prototype.getLocalBounds.call(this);\n  }, t.prototype.validate = function() {\n    this.dirty && (this.updateText(), this.dirty = !1);\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      if (this._tint !== e) {\n        this._tint = e;\n        for (var o = 0; o < this._activePagesMeshData.length; o++)\n          this._activePagesMeshData[o].mesh.tint = e;\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"align\", {\n    get: function() {\n      return this._align;\n    },\n    set: function(e) {\n      this._align !== e && (this._align = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontName\", {\n    get: function() {\n      return this._fontName;\n    },\n    set: function(e) {\n      if (!BitmapFont.available[e])\n        throw new Error('Missing BitmapFont \"' + e + '\"');\n      this._fontName !== e && (this._fontName = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontSize\", {\n    get: function() {\n      return this._fontSize;\n    },\n    set: function(e) {\n      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      typeof e == \"number\" ? this._anchor.set(e) : this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e == null ? \"\" : e), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxWidth\", {\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(e) {\n      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxLineHeight\", {\n    get: function() {\n      return this.validate(), this._maxLineHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textWidth\", {\n    get: function() {\n      return this.validate(), this._textWidth;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"letterSpacing\", {\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(e) {\n      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textHeight\", {\n    get: function() {\n      return this.validate(), this._textHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.destroy = function(e) {\n    var o = this._textureCache;\n    for (var T in o) {\n      var S = o[T];\n      S.destroy(), delete o[T];\n    }\n    this._textureCache = null, r.prototype.destroy.call(this, e);\n  }, t.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  }, t;\n})(Container);\nvar BitmapFontLoader = function() {\n  function r() {\n  }\n  return r.add = function() {\n    LoaderResource.setExtensionXhrType(\"fnt\", LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n  }, r.use = function(t, e) {\n    var o = autoDetectFormat(t.data);\n    if (!o) {\n      e();\n      return;\n    }\n    for (var T = r.getBaseUrl(this, t), S = o.parse(t.data), N = {}, D = function(Y) {\n      N[Y.metadata.pageFile] = Y.texture, Object.keys(N).length === S.page.length && (t.bitmapFont = BitmapFont.install(S, N, !0), e());\n    }, B = 0; B < S.page.length; ++B) {\n      var $ = S.page[B].file, U = T + $, z = !1;\n      for (var V in this.resources) {\n        var X = this.resources[V];\n        if (X.url === U) {\n          X.metadata.pageFile = $, X.texture ? D(X) : X.onAfterMiddleware.add(D), z = !0;\n          break;\n        }\n      }\n      if (!z) {\n        var W = {\n          crossOrigin: t.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.IMAGE,\n          metadata: Object.assign({ pageFile: $ }, t.metadata.imageMetadata),\n          parentResource: t\n        };\n        this.add(U, W, D);\n      }\n    }\n  }, r.getBaseUrl = function(t, e) {\n    var o = e.isDataUrl ? \"\" : r.dirname(e.url);\n    return e.isDataUrl && (o === \".\" && (o = \"\"), t.baseUrl && o && t.baseUrl.charAt(t.baseUrl.length - 1) === \"/\" && (o += \"/\")), o = o.replace(t.baseUrl, \"\"), o && o.charAt(o.length - 1) !== \"/\" && (o += \"/\"), o;\n  }, r.dirname = function(t) {\n    var e = t.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n    return e === t ? \".\" : e === \"\" ? \"/\" : e;\n  }, r.extension = ExtensionType.Loader, r;\n}();\n/*!\n * @pixi/filter-alpha - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-alpha is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$e = function(r, t) {\n  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$e(r, t);\n};\nfunction __extends$e(r, t) {\n  extendStatics$e(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$4 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n(function(r) {\n  __extends$e(t, r);\n  function t(e) {\n    e === void 0 && (e = 1);\n    var o = r.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;\n    return o.alpha = e, o;\n  }\n  return Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-blur - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$d = function(r, t) {\n  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$d(r, t);\n};\nfunction __extends$d(r, t) {\n  extendStatics$d(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(r, t) {\n  var e = Math.ceil(r / 2), o = vertTemplate, T = \"\", S;\n  t ? S = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\" : S = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  for (var N = 0; N < r; N++) {\n    var D = S.replace(\"%index%\", N.toString());\n    D = D.replace(\"%sampleIndex%\", N - (e - 1) + \".0\"), T += D, T += `\n`;\n  }\n  return o = o.replace(\"%blur%\", T), o = o.replace(\"%size%\", r.toString()), o;\n}\nvar GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, fragTemplate = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(`\n`);\nfunction generateBlurFragSource(r) {\n  for (var t = GAUSSIAN_VALUES[r], e = t.length, o = fragTemplate, T = \"\", S = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\", N, D = 0; D < r; D++) {\n    var B = S.replace(\"%index%\", D.toString());\n    N = D, D >= e && (N = r - D - 1), B = B.replace(\"%value%\", t[N].toString()), T += B, T += `\n`;\n  }\n  return o = o.replace(\"%blur%\", T), o = o.replace(\"%size%\", r.toString()), o;\n}\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$3;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$3 || (ENV$3 = {}));\nvar RENDERER_TYPE$3;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));\nvar BUFFER_BITS$3;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));\nvar BLEND_MODES$3;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));\nvar DRAW_MODES$3;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));\nvar FORMATS$3;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$3 || (FORMATS$3 = {}));\nvar TARGETS$3;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$3 || (TARGETS$3 = {}));\nvar TYPES$3;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$3 || (TYPES$3 = {}));\nvar SAMPLER_TYPES$3;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));\nvar SCALE_MODES$3;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));\nvar WRAP_MODES$3;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));\nvar MIPMAP_MODES$3;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));\nvar ALPHA_MODES$3;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));\nvar CLEAR_MODES$3;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));\nvar GC_MODES$3;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$3 || (GC_MODES$3 = {}));\nvar PRECISION$3;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$3 || (PRECISION$3 = {}));\nvar MASK_TYPES$3;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));\nvar COLOR_MASK_BITS$3;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$3 || (COLOR_MASK_BITS$3 = {}));\nvar MSAA_QUALITY$3;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));\nvar BUFFER_TYPE$3;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));\nvar BlurFilterPass = function(r) {\n  __extends$d(t, r);\n  function t(e, o, T, S, N) {\n    o === void 0 && (o = 8), T === void 0 && (T = 4), S === void 0 && (S = settings$1.FILTER_RESOLUTION), N === void 0 && (N = 5);\n    var D = this, B = generateBlurVertSource(N, e), $ = generateBlurFragSource(N);\n    return D = r.call(\n      this,\n      B,\n      $\n    ) || this, D.horizontal = e, D.resolution = S, D._quality = 0, D.quality = T, D.blur = o, D;\n  }\n  return t.prototype.apply = function(e, o, T, S) {\n    if (T ? this.horizontal ? this.uniforms.strength = 1 / T.width * (T.width / o.width) : this.uniforms.strength = 1 / T.height * (T.height / o.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / o.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / o.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n      e.applyFilter(this, o, T, S);\n    else {\n      var N = e.getFilterTexture(), D = e.renderer, B = o, $ = N;\n      this.state.blend = !1, e.applyFilter(this, B, $, CLEAR_MODES$3.CLEAR);\n      for (var U = 1; U < this.passes - 1; U++) {\n        e.bindAndClear(B, CLEAR_MODES$3.BLIT), this.uniforms.uSampler = $;\n        var z = $;\n        $ = B, B = z, D.shader.bind(this), D.geometry.draw(5);\n      }\n      this.state.blend = !0, e.applyFilter(this, $, T, S), e.returnFilterTexture(N);\n    }\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.strength;\n    },\n    set: function(e) {\n      this.padding = 1 + Math.abs(e) * 2, this.strength = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this._quality;\n    },\n    set: function(e) {\n      this._quality = e, this.passes = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\n(function(r) {\n  __extends$d(t, r);\n  function t(e, o, T, S) {\n    e === void 0 && (e = 8), o === void 0 && (o = 4), T === void 0 && (T = settings$1.FILTER_RESOLUTION), S === void 0 && (S = 5);\n    var N = r.call(this) || this;\n    return N.blurXFilter = new BlurFilterPass(!0, e, o, T, S), N.blurYFilter = new BlurFilterPass(!1, e, o, T, S), N.resolution = T, N.quality = o, N.blur = e, N.repeatEdgePixels = !1, N;\n  }\n  return t.prototype.apply = function(e, o, T, S) {\n    var N = Math.abs(this.blurXFilter.strength), D = Math.abs(this.blurYFilter.strength);\n    if (N && D) {\n      var B = e.getFilterTexture();\n      this.blurXFilter.apply(e, o, B, CLEAR_MODES$3.CLEAR), this.blurYFilter.apply(e, B, T, S), e.returnFilterTexture(B);\n    } else\n      D ? this.blurYFilter.apply(e, o, T, S) : this.blurXFilter.apply(e, o, T, S);\n  }, t.prototype.updatePadding = function() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(e) {\n      this.blurXFilter.quality = this.blurYFilter.quality = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurX\", {\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurY\", {\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(e) {\n      this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(e) {\n      this.blurYFilter.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"repeatEdgePixels\", {\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(e) {\n      this._repeatEdgePixels = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-color-matrix - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-color-matrix is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$c = function(r, t) {\n  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$c(r, t);\n};\nfunction __extends$c(r, t) {\n  extendStatics$c(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$3 = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`, ColorMatrixFilter = function(r) {\n  __extends$c(t, r);\n  function t() {\n    var e = this, o = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    return e = r.call(this, defaultFilterVertex, fragment$3, o) || this, e.alpha = 1, e;\n  }\n  return t.prototype._loadMatrix = function(e, o) {\n    o === void 0 && (o = !1);\n    var T = e;\n    o && (this._multiply(T, this.uniforms.m, e), T = this._colorMatrix(T)), this.uniforms.m = T;\n  }, t.prototype._multiply = function(e, o, T) {\n    return e[0] = o[0] * T[0] + o[1] * T[5] + o[2] * T[10] + o[3] * T[15], e[1] = o[0] * T[1] + o[1] * T[6] + o[2] * T[11] + o[3] * T[16], e[2] = o[0] * T[2] + o[1] * T[7] + o[2] * T[12] + o[3] * T[17], e[3] = o[0] * T[3] + o[1] * T[8] + o[2] * T[13] + o[3] * T[18], e[4] = o[0] * T[4] + o[1] * T[9] + o[2] * T[14] + o[3] * T[19] + o[4], e[5] = o[5] * T[0] + o[6] * T[5] + o[7] * T[10] + o[8] * T[15], e[6] = o[5] * T[1] + o[6] * T[6] + o[7] * T[11] + o[8] * T[16], e[7] = o[5] * T[2] + o[6] * T[7] + o[7] * T[12] + o[8] * T[17], e[8] = o[5] * T[3] + o[6] * T[8] + o[7] * T[13] + o[8] * T[18], e[9] = o[5] * T[4] + o[6] * T[9] + o[7] * T[14] + o[8] * T[19] + o[9], e[10] = o[10] * T[0] + o[11] * T[5] + o[12] * T[10] + o[13] * T[15], e[11] = o[10] * T[1] + o[11] * T[6] + o[12] * T[11] + o[13] * T[16], e[12] = o[10] * T[2] + o[11] * T[7] + o[12] * T[12] + o[13] * T[17], e[13] = o[10] * T[3] + o[11] * T[8] + o[12] * T[13] + o[13] * T[18], e[14] = o[10] * T[4] + o[11] * T[9] + o[12] * T[14] + o[13] * T[19] + o[14], e[15] = o[15] * T[0] + o[16] * T[5] + o[17] * T[10] + o[18] * T[15], e[16] = o[15] * T[1] + o[16] * T[6] + o[17] * T[11] + o[18] * T[16], e[17] = o[15] * T[2] + o[16] * T[7] + o[17] * T[12] + o[18] * T[17], e[18] = o[15] * T[3] + o[16] * T[8] + o[17] * T[13] + o[18] * T[18], e[19] = o[15] * T[4] + o[16] * T[9] + o[17] * T[14] + o[18] * T[19] + o[19], e;\n  }, t.prototype._colorMatrix = function(e) {\n    var o = new Float32Array(e);\n    return o[4] /= 255, o[9] /= 255, o[14] /= 255, o[19] /= 255, o;\n  }, t.prototype.brightness = function(e, o) {\n    var T = [\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(T, o);\n  }, t.prototype.tint = function(e, o) {\n    var T = e >> 16 & 255, S = e >> 8 & 255, N = e & 255, D = [\n      T / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      S / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      N / 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(D, o);\n  }, t.prototype.greyscale = function(e, o) {\n    var T = [\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      e,\n      e,\n      e,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(T, o);\n  }, t.prototype.blackAndWhite = function(e) {\n    var o = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.hue = function(e, o) {\n    e = (e || 0) / 180 * Math.PI;\n    var T = Math.cos(e), S = Math.sin(e), N = Math.sqrt, D = 1 / 3, B = N(D), $ = T + (1 - T) * D, U = D * (1 - T) - B * S, z = D * (1 - T) + B * S, V = D * (1 - T) + B * S, X = T + D * (1 - T), W = D * (1 - T) - B * S, Y = D * (1 - T) - B * S, q = D * (1 - T) + B * S, Z = T + D * (1 - T), K = [\n      $,\n      U,\n      z,\n      0,\n      0,\n      V,\n      X,\n      W,\n      0,\n      0,\n      Y,\n      q,\n      Z,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(K, o);\n  }, t.prototype.contrast = function(e, o) {\n    var T = (e || 0) + 1, S = -0.5 * (T - 1), N = [\n      T,\n      0,\n      0,\n      0,\n      S,\n      0,\n      T,\n      0,\n      0,\n      S,\n      0,\n      0,\n      T,\n      0,\n      S,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(N, o);\n  }, t.prototype.saturate = function(e, o) {\n    e === void 0 && (e = 0);\n    var T = e * 2 / 3 + 1, S = (T - 1) * -0.5, N = [\n      T,\n      S,\n      S,\n      0,\n      0,\n      S,\n      T,\n      S,\n      0,\n      0,\n      S,\n      S,\n      T,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(N, o);\n  }, t.prototype.desaturate = function() {\n    this.saturate(-1);\n  }, t.prototype.negative = function(e) {\n    var o = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.sepia = function(e) {\n    var o = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.technicolor = function(e) {\n    var o = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.polaroid = function(e) {\n    var o = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.toBGR = function(e) {\n    var o = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.kodachrome = function(e) {\n    var o = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.browni = function(e) {\n    var o = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.vintage = function(e) {\n    var o = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.colorTone = function(e, o, T, S, N) {\n    e = e || 0.2, o = o || 0.15, T = T || 16770432, S = S || 3375104;\n    var D = (T >> 16 & 255) / 255, B = (T >> 8 & 255) / 255, $ = (T & 255) / 255, U = (S >> 16 & 255) / 255, z = (S >> 8 & 255) / 255, V = (S & 255) / 255, X = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      D,\n      B,\n      $,\n      e,\n      0,\n      U,\n      z,\n      V,\n      o,\n      0,\n      D - U,\n      B - z,\n      $ - V,\n      0,\n      0\n    ];\n    this._loadMatrix(X, N);\n  }, t.prototype.night = function(e, o) {\n    e = e || 0.1;\n    var T = [\n      e * -2,\n      -e,\n      0,\n      0,\n      0,\n      -e,\n      0,\n      e,\n      0,\n      0,\n      0,\n      e,\n      e * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(T, o);\n  }, t.prototype.predator = function(e, o) {\n    var T = [\n      11.224130630493164 * e,\n      -4.794486999511719 * e,\n      -2.8746118545532227 * e,\n      0 * e,\n      0.40342438220977783 * e,\n      -3.6330697536468506 * e,\n      9.193157196044922 * e,\n      -2.951810836791992 * e,\n      0 * e,\n      -1.316135048866272 * e,\n      -3.2184197902679443 * e,\n      -4.2375030517578125 * e,\n      7.476448059082031 * e,\n      0 * e,\n      0.8044459223747253 * e,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(T, o);\n  }, t.prototype.lsd = function(e) {\n    var o = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(o, e);\n  }, t.prototype.reset = function() {\n    var e = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(e, !1);\n  }, Object.defineProperty(t.prototype, \"matrix\", {\n    get: function() {\n      return this.uniforms.m;\n    },\n    set: function(e) {\n      this.uniforms.m = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"alpha\", {\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Filter);\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n/*!\n * @pixi/filter-displacement - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$b = function(r, t) {\n  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$b(r, t);\n};\nfunction __extends$b(r, t) {\n  extendStatics$b(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment$2 = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`, vertex$1 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n(function(r) {\n  __extends$b(t, r);\n  function t(e, o) {\n    var T = this, S = new Matrix();\n    return e.renderable = !1, T = r.call(this, vertex$1, fragment$2, {\n      mapSampler: e._texture,\n      filterMatrix: S,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this, T.maskSprite = e, T.maskMatrix = S, o == null && (o = 20), T.scale = new Point(o, o), T;\n  }\n  return t.prototype.apply = function(e, o, T, S) {\n    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    var N = this.maskSprite.worldTransform, D = Math.sqrt(N.a * N.a + N.b * N.b), B = Math.sqrt(N.c * N.c + N.d * N.d);\n    D !== 0 && B !== 0 && (this.uniforms.rotation[0] = N.a / D, this.uniforms.rotation[1] = N.b / D, this.uniforms.rotation[2] = N.c / B, this.uniforms.rotation[3] = N.d / B), e.applyFilter(this, o, T, S);\n  }, Object.defineProperty(t.prototype, \"map\", {\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(e) {\n      this.uniforms.mapSampler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/filter-fxaa - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-fxaa is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$a = function(r, t) {\n  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$a(r, t);\n};\nfunction __extends$a(r, t) {\n  extendStatics$a(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar vertex = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`, fragment$1 = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(r) {\n  __extends$a(t, r);\n  function t() {\n    return r.call(this, vertex, fragment$1) || this;\n  }\n  return t;\n})(Filter);\n/*!\n * @pixi/filter-noise - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/filter-noise is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$9 = function(r, t) {\n  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$9(r, t);\n};\nfunction __extends$9(r, t) {\n  extendStatics$9(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar fragment = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n(function(r) {\n  __extends$9(t, r);\n  function t(e, o) {\n    e === void 0 && (e = 0.5), o === void 0 && (o = Math.random());\n    var T = r.call(this, defaultFilterVertex, fragment, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    return T.noise = e, T.seed = o, T;\n  }\n  return Object.defineProperty(t.prototype, \"noise\", {\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(e) {\n      this.uniforms.uNoise = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"seed\", {\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(e) {\n      this.uniforms.uSeed = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Filter);\n/*!\n * @pixi/mixin-cache-as-bitmap - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$2;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$2 || (ENV$2 = {}));\nvar RENDERER_TYPE$2;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));\nvar BUFFER_BITS$2;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));\nvar BLEND_MODES$2;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));\nvar DRAW_MODES$2;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));\nvar FORMATS$2;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$2 || (FORMATS$2 = {}));\nvar TARGETS$2;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$2 || (TARGETS$2 = {}));\nvar TYPES$2;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$2 || (TYPES$2 = {}));\nvar SAMPLER_TYPES$2;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));\nvar SCALE_MODES$2;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));\nvar WRAP_MODES$2;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));\nvar MIPMAP_MODES$2;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));\nvar ALPHA_MODES$2;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));\nvar CLEAR_MODES$2;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));\nvar GC_MODES$2;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$2 || (GC_MODES$2 = {}));\nvar PRECISION$2;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$2 || (PRECISION$2 = {}));\nvar MASK_TYPES$2;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));\nvar COLOR_MASK_BITS$2;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$2 || (COLOR_MASK_BITS$2 = {}));\nvar MSAA_QUALITY$2;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));\nvar BUFFER_TYPE$2;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));\nvar _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = !1;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY$2.NONE;\nvar CacheData = function() {\n  function r() {\n    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n  }\n  return r;\n}();\nObject.defineProperties(DisplayObject.prototype, {\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(r) {\n      r !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(r) {\n      r !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(r) {\n      if (this._cacheAsBitmap !== r) {\n        this._cacheAsBitmap = r;\n        var t;\n        r ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));\n};\nDisplayObject.prototype._initCachedDisplayObject = function(t) {\n  var e;\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var o = this.alpha;\n    this.alpha = 1, t.batch.flush();\n    var T = this.getLocalBounds(null, !0).clone();\n    if (this.filters && this.filters.length) {\n      var S = this.filters[0].padding;\n      T.pad(S);\n    }\n    T.ceil(settings$1.RESOLUTION);\n    var N = t.renderTexture.current, D = t.renderTexture.sourceFrame.clone(), B = t.renderTexture.destinationFrame.clone(), $ = t.projection.transform, U = RenderTexture.create({\n      width: T.width,\n      height: T.height,\n      resolution: this.cacheAsBitmapResolution || t.resolution,\n      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample\n    }), z = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = z, BaseTexture.addToCache(U.baseTexture, z), Texture.addToCache(U, z);\n    var V = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-T.x, -T.y);\n    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: U, clear: !0, transform: V, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = $, t.renderTexture.bind(N, D, B), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;\n    var X = new Sprite(U);\n    X.transform.worldTransform = this.transform.worldTransform, X.anchor.x = -(T.x / T.width), X.anchor.y = -(T.y / T.height), X.alpha = o, X._bounds = this._bounds, this._cacheData.sprite = X, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = X.containsPoint.bind(X);\n  }\n};\nDisplayObject.prototype._renderCachedCanvas = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var e = this.getLocalBounds(null, !0), o = this.alpha;\n    this.alpha = 1;\n    var T = t.context, S = t._projTransform;\n    e.ceil(settings$1.RESOLUTION);\n    var N = RenderTexture.create({ width: e.width, height: e.height }), D = \"cacheAsBitmap_\" + uid();\n    this._cacheData.textureCacheId = D, BaseTexture.addToCache(N.baseTexture, D), Texture.addToCache(N, D);\n    var B = _tempMatrix;\n    this.transform.localTransform.copyTo(B), B.invert(), B.tx -= e.x, B.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: N, clear: !0, transform: B, skipUpdateTransform: !1 }), t.context = T, t._projTransform = S, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;\n    var $ = new Sprite(N);\n    $.transform.worldTransform = this.transform.worldTransform, $.anchor.x = -(e.x / e.width), $.anchor.y = -(e.y / e.height), $.alpha = o, $._bounds = this._bounds, this._cacheData.sprite = $, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = $.containsPoint.bind($);\n  }\n};\nDisplayObject.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function(t) {\n  this.cacheAsBitmap = !1, this.destroy(t);\n};\n/*!\n * @pixi/mixin-get-child-by-name - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/mixin-get-child-by-name is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.name = null;\nContainer.prototype.getChildByName = function(t, e) {\n  for (var o = 0, T = this.children.length; o < T; o++)\n    if (this.children[o].name === t)\n      return this.children[o];\n  if (e)\n    for (var o = 0, T = this.children.length; o < T; o++) {\n      var S = this.children[o];\n      if (!!S.getChildByName) {\n        var N = S.getChildByName(t, !0);\n        if (N)\n          return N;\n      }\n    }\n  return null;\n};\n/*!\n * @pixi/mixin-get-global-position - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/mixin-get-global-position is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nDisplayObject.prototype.getGlobalPosition = function(t, e) {\n  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;\n};\n/*!\n * @pixi/app - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/app is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ResizePlugin = function() {\n  function r() {\n  }\n  return r.init = function(t) {\n    var e = this;\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        set: function(o) {\n          globalThis.removeEventListener(\"resize\", this.queueResize), this._resizeTo = o, o && (globalThis.addEventListener(\"resize\", this.queueResize), this.resize());\n        },\n        get: function() {\n          return this._resizeTo;\n        }\n      }\n    ), this.queueResize = function() {\n      !e._resizeTo || (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {\n        return e.resize();\n      }));\n    }, this.cancelResize = function() {\n      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);\n    }, this.resize = function() {\n      if (!!e._resizeTo) {\n        e.cancelResize();\n        var o, T;\n        if (e._resizeTo === globalThis.window)\n          o = globalThis.innerWidth, T = globalThis.innerHeight;\n        else {\n          var S = e._resizeTo, N = S.clientWidth, D = S.clientHeight;\n          o = N, T = D;\n        }\n        e.renderer.resize(o, T);\n      }\n    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;\n  }, r.destroy = function() {\n    globalThis.removeEventListener(\"resize\", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n  }, r.extension = ExtensionType.Application, r;\n}();\n/*!\n * @pixi/settings - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV$1;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV$1 || (ENV$1 = {}));\nvar RENDERER_TYPE$1;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));\nvar BUFFER_BITS$1;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));\nvar BLEND_MODES$1;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));\nvar DRAW_MODES$1;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));\nvar FORMATS$1;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS$1 || (FORMATS$1 = {}));\nvar TARGETS$1;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS$1 || (TARGETS$1 = {}));\nvar TYPES$1;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES$1 || (TYPES$1 = {}));\nvar SAMPLER_TYPES$1;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));\nvar SCALE_MODES$1;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));\nvar WRAP_MODES$1;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));\nvar MIPMAP_MODES$1;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));\nvar ALPHA_MODES$1;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));\nvar CLEAR_MODES$1;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));\nvar GC_MODES$1;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES$1 || (GC_MODES$1 = {}));\nvar PRECISION$1;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION$1 || (PRECISION$1 = {}));\nvar MASK_TYPES$1;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));\nvar COLOR_MASK_BITS$1;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS$1 || (COLOR_MASK_BITS$1 = {}));\nvar MSAA_QUALITY$1;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));\nvar BUFFER_TYPE$1;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));\nvar BrowserAdapter = {\n  createCanvas: function(r, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = r, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var r;\n    return (r = document.baseURI) !== null && r !== void 0 ? r : window.location.href;\n  },\n  fetch: function(r, t) {\n    return fetch(r, t);\n  }\n}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i, androidPhone = /\\bAndroid(?:.+)Mobile\\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\\bWindows(?:.+)ARM\\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\\b/i, isAppleTabletOnIos13 = function(r) {\n  return typeof r < \"u\" && r.platform === \"MacIntel\" && typeof r.maxTouchPoints == \"number\" && r.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction createMatch(r) {\n  return function(t) {\n    return t.test(r);\n  };\n}\nfunction isMobile$1(r) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !r && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof r == \"string\" ? t.userAgent = r : r && r.userAgent && (t = {\n    userAgent: r.userAgent,\n    platform: r.platform,\n    maxTouchPoints: r.maxTouchPoints || 0\n  });\n  var e = t.userAgent, o = e.split(\"[FBAN\");\n  typeof o[1] < \"u\" && (e = o[0]), o = e.split(\"Twitter\"), typeof o[1] < \"u\" && (e = o[0]);\n  var T = createMatch(e), S = {\n    apple: {\n      phone: T(appleIphone) && !T(windowsPhone),\n      ipod: T(appleIpod),\n      tablet: !T(appleIphone) && (T(appleTablet) || isAppleTabletOnIos13(t)) && !T(windowsPhone),\n      universal: T(appleUniversal),\n      device: (T(appleIphone) || T(appleIpod) || T(appleTablet) || T(appleUniversal) || isAppleTabletOnIos13(t)) && !T(windowsPhone)\n    },\n    amazon: {\n      phone: T(amazonPhone),\n      tablet: !T(amazonPhone) && T(amazonTablet),\n      device: T(amazonPhone) || T(amazonTablet)\n    },\n    android: {\n      phone: !T(windowsPhone) && T(amazonPhone) || !T(windowsPhone) && T(androidPhone),\n      tablet: !T(windowsPhone) && !T(amazonPhone) && !T(androidPhone) && (T(amazonTablet) || T(androidTablet)),\n      device: !T(windowsPhone) && (T(amazonPhone) || T(amazonTablet) || T(androidPhone) || T(androidTablet)) || T(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: T(windowsPhone),\n      tablet: T(windowsTablet),\n      device: T(windowsPhone) || T(windowsTablet)\n    },\n    other: {\n      blackberry: T(otherBlackBerry),\n      blackberry10: T(otherBlackBerry10),\n      opera: T(otherOpera),\n      firefox: T(otherFirefox),\n      chrome: T(otherChrome),\n      device: T(otherBlackBerry) || T(otherBlackBerry10) || T(otherOpera) || T(otherFirefox) || T(otherChrome)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return S.any = S.apple.device || S.android.device || S.windows.device || S.other.device, S.phone = S.apple.phone || S.android.phone || S.windows.phone, S.tablet = S.apple.tablet || S.android.tablet || S.windows.tablet, S;\n}\nvar isMobile = isMobile$1(globalThis.navigator);\nfunction canUploadSameBuffer() {\n  return !isMobile.apple.device;\n}\nfunction maxRecommendedTextures(r) {\n  var t = !0;\n  if (isMobile.tablet || isMobile.phone) {\n    if (isMobile.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 11 && (t = !1);\n      }\n    }\n    if (isMobile.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var o = parseInt(e[1], 10);\n        o < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? r : 4;\n}\nvar settings = {\n  ADAPTER: BrowserAdapter,\n  MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,\n  ANISOTROPIC_LEVEL: 0,\n  RESOLUTION: 1,\n  FILTER_RESOLUTION: 1,\n  FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,\n  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),\n  SPRITE_BATCH_SIZE: 4096,\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  GC_MODE: GC_MODES$1.AUTO,\n  GC_MAX_IDLE: 60 * 60,\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  WRAP_MODE: WRAP_MODES$1.CLAMP,\n  SCALE_MODE: SCALE_MODES$1.LINEAR,\n  PRECISION_VERTEX: PRECISION$1.HIGH,\n  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$1.HIGH : PRECISION$1.MEDIUM,\n  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),\n  CREATE_IMAGE_BITMAP: !1,\n  ROUND_PIXELS: !1\n}, commonjsGlobal = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {};\nfunction createCommonjsModule(r, t, e) {\n  return e = {\n    path: t,\n    exports: {},\n    require: function(o, T) {\n      return commonjsRequire(o, T == null ? e.path : T);\n    }\n  }, r(e, e.exports), e.exports;\n}\nfunction commonjsRequire() {\n  throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\ncreateCommonjsModule(function(r) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function o() {\n  }\n  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));\n  function T(B, $, U) {\n    this.fn = B, this.context = $, this.once = U || !1;\n  }\n  function S(B, $, U, z, V) {\n    if (typeof U != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var X = new T(U, z || B, V), W = e ? e + $ : $;\n    return B._events[W] ? B._events[W].fn ? B._events[W] = [B._events[W], X] : B._events[W].push(X) : (B._events[W] = X, B._eventsCount++), B;\n  }\n  function N(B, $) {\n    --B._eventsCount === 0 ? B._events = new o() : delete B._events[$];\n  }\n  function D() {\n    this._events = new o(), this._eventsCount = 0;\n  }\n  D.prototype.eventNames = function() {\n    var $ = [], U, z;\n    if (this._eventsCount === 0)\n      return $;\n    for (z in U = this._events)\n      t.call(U, z) && $.push(e ? z.slice(1) : z);\n    return Object.getOwnPropertySymbols ? $.concat(Object.getOwnPropertySymbols(U)) : $;\n  }, D.prototype.listeners = function($) {\n    var U = e ? e + $ : $, z = this._events[U];\n    if (!z)\n      return [];\n    if (z.fn)\n      return [z.fn];\n    for (var V = 0, X = z.length, W = new Array(X); V < X; V++)\n      W[V] = z[V].fn;\n    return W;\n  }, D.prototype.listenerCount = function($) {\n    var U = e ? e + $ : $, z = this._events[U];\n    return z ? z.fn ? 1 : z.length : 0;\n  }, D.prototype.emit = function($, U, z, V, X, W) {\n    var Y = arguments, q = e ? e + $ : $;\n    if (!this._events[q])\n      return !1;\n    var Z = this._events[q], K = arguments.length, J, tt;\n    if (Z.fn) {\n      switch (Z.once && this.removeListener($, Z.fn, void 0, !0), K) {\n        case 1:\n          return Z.fn.call(Z.context), !0;\n        case 2:\n          return Z.fn.call(Z.context, U), !0;\n        case 3:\n          return Z.fn.call(Z.context, U, z), !0;\n        case 4:\n          return Z.fn.call(Z.context, U, z, V), !0;\n        case 5:\n          return Z.fn.call(Z.context, U, z, V, X), !0;\n        case 6:\n          return Z.fn.call(Z.context, U, z, V, X, W), !0;\n      }\n      for (tt = 1, J = new Array(K - 1); tt < K; tt++)\n        J[tt - 1] = Y[tt];\n      Z.fn.apply(Z.context, J);\n    } else {\n      var et = Z.length, Q;\n      for (tt = 0; tt < et; tt++)\n        switch (Z[tt].once && this.removeListener($, Z[tt].fn, void 0, !0), K) {\n          case 1:\n            Z[tt].fn.call(Z[tt].context);\n            break;\n          case 2:\n            Z[tt].fn.call(Z[tt].context, U);\n            break;\n          case 3:\n            Z[tt].fn.call(Z[tt].context, U, z);\n            break;\n          case 4:\n            Z[tt].fn.call(Z[tt].context, U, z, V);\n            break;\n          default:\n            if (!J)\n              for (Q = 1, J = new Array(K - 1); Q < K; Q++)\n                J[Q - 1] = Y[Q];\n            Z[tt].fn.apply(Z[tt].context, J);\n        }\n    }\n    return !0;\n  }, D.prototype.on = function($, U, z) {\n    return S(this, $, U, z, !1);\n  }, D.prototype.once = function($, U, z) {\n    return S(this, $, U, z, !0);\n  }, D.prototype.removeListener = function($, U, z, V) {\n    var X = e ? e + $ : $;\n    if (!this._events[X])\n      return this;\n    if (!U)\n      return N(this, X), this;\n    var W = this._events[X];\n    if (W.fn)\n      W.fn === U && (!V || W.once) && (!z || W.context === z) && N(this, X);\n    else {\n      for (var Y = 0, q = [], Z = W.length; Y < Z; Y++)\n        (W[Y].fn !== U || V && !W[Y].once || z && W[Y].context !== z) && q.push(W[Y]);\n      q.length ? this._events[X] = q.length === 1 ? q[0] : q : N(this, X);\n    }\n    return this;\n  }, D.prototype.removeAllListeners = function($) {\n    var U;\n    return $ ? (U = e ? e + $ : $, this._events[U] && N(this, U)) : (this._events = new o(), this._eventsCount = 0), this;\n  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, r.exports = D;\n});\ncreateCommonjsModule(function(r, t) {\n  (function(e) {\n    var o = t && !t.nodeType && t, T = r && !r.nodeType && r, S = typeof commonjsGlobal == \"object\" && commonjsGlobal;\n    (S.global === S || S.window === S || S.self === S) && (e = S);\n    var N, D = 2147483647, B = 36, $ = 1, U = 26, z = 38, V = 700, X = 72, W = 128, Y = \"-\", q = /^xn--/, Z = /[^\\x20-\\x7E]/, K = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, J = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    }, tt = B - $, et = Math.floor, Q = String.fromCharCode, at;\n    function it(ht) {\n      throw RangeError(J[ht]);\n    }\n    function st(ht, bt) {\n      for (var St = ht.length, Ot = []; St--; )\n        Ot[St] = bt(ht[St]);\n      return Ot;\n    }\n    function ut(ht, bt) {\n      var St = ht.split(\"@\"), Ot = \"\";\n      St.length > 1 && (Ot = St[0] + \"@\", ht = St[1]), ht = ht.replace(K, \".\");\n      var wt = ht.split(\".\"), Ft = st(wt, bt).join(\".\");\n      return Ot + Ft;\n    }\n    function ft(ht) {\n      for (var bt = [], St = 0, Ot = ht.length, wt, Ft; St < Ot; )\n        wt = ht.charCodeAt(St++), wt >= 55296 && wt <= 56319 && St < Ot ? (Ft = ht.charCodeAt(St++), (Ft & 64512) == 56320 ? bt.push(((wt & 1023) << 10) + (Ft & 1023) + 65536) : (bt.push(wt), St--)) : bt.push(wt);\n      return bt;\n    }\n    function ct(ht) {\n      return st(ht, function(bt) {\n        var St = \"\";\n        return bt > 65535 && (bt -= 65536, St += Q(bt >>> 10 & 1023 | 55296), bt = 56320 | bt & 1023), St += Q(bt), St;\n      }).join(\"\");\n    }\n    function pt(ht) {\n      return ht - 48 < 10 ? ht - 22 : ht - 65 < 26 ? ht - 65 : ht - 97 < 26 ? ht - 97 : B;\n    }\n    function mt(ht, bt) {\n      return ht + 22 + 75 * (ht < 26) - ((bt != 0) << 5);\n    }\n    function vt(ht, bt, St) {\n      var Ot = 0;\n      for (ht = St ? et(ht / V) : ht >> 1, ht += et(ht / bt); ht > tt * U >> 1; Ot += B)\n        ht = et(ht / tt);\n      return et(Ot + (tt + 1) * ht / (ht + z));\n    }\n    function _t(ht) {\n      var bt = [], St = ht.length, Ot, wt = 0, Ft = W, dt = X, Gt, Mt, Bt, Dt, Et, zt, It, Ct, Lt;\n      for (Gt = ht.lastIndexOf(Y), Gt < 0 && (Gt = 0), Mt = 0; Mt < Gt; ++Mt)\n        ht.charCodeAt(Mt) >= 128 && it(\"not-basic\"), bt.push(ht.charCodeAt(Mt));\n      for (Bt = Gt > 0 ? Gt + 1 : 0; Bt < St; ) {\n        for (Dt = wt, Et = 1, zt = B; Bt >= St && it(\"invalid-input\"), It = pt(ht.charCodeAt(Bt++)), (It >= B || It > et((D - wt) / Et)) && it(\"overflow\"), wt += It * Et, Ct = zt <= dt ? $ : zt >= dt + U ? U : zt - dt, !(It < Ct); zt += B)\n          Lt = B - Ct, Et > et(D / Lt) && it(\"overflow\"), Et *= Lt;\n        Ot = bt.length + 1, dt = vt(wt - Dt, Ot, Dt == 0), et(wt / Ot) > D - Ft && it(\"overflow\"), Ft += et(wt / Ot), wt %= Ot, bt.splice(wt++, 0, Ft);\n      }\n      return ct(bt);\n    }\n    function xt(ht) {\n      var bt, St, Ot, wt, Ft, dt, Gt, Mt, Bt, Dt, Et, zt = [], It, Ct, Lt, $t;\n      for (ht = ft(ht), It = ht.length, bt = W, St = 0, Ft = X, dt = 0; dt < It; ++dt)\n        Et = ht[dt], Et < 128 && zt.push(Q(Et));\n      for (Ot = wt = zt.length, wt && zt.push(Y); Ot < It; ) {\n        for (Gt = D, dt = 0; dt < It; ++dt)\n          Et = ht[dt], Et >= bt && Et < Gt && (Gt = Et);\n        for (Ct = Ot + 1, Gt - bt > et((D - St) / Ct) && it(\"overflow\"), St += (Gt - bt) * Ct, bt = Gt, dt = 0; dt < It; ++dt)\n          if (Et = ht[dt], Et < bt && ++St > D && it(\"overflow\"), Et == bt) {\n            for (Mt = St, Bt = B; Dt = Bt <= Ft ? $ : Bt >= Ft + U ? U : Bt - Ft, !(Mt < Dt); Bt += B)\n              $t = Mt - Dt, Lt = B - Dt, zt.push(\n                Q(mt(Dt + $t % Lt, 0))\n              ), Mt = et($t / Lt);\n            zt.push(Q(mt(Mt, 0))), Ft = vt(St, Ct, Ot == wt), St = 0, ++Ot;\n          }\n        ++St, ++bt;\n      }\n      return zt.join(\"\");\n    }\n    function Rt(ht) {\n      return ut(ht, function(bt) {\n        return q.test(bt) ? _t(bt.slice(4).toLowerCase()) : bt;\n      });\n    }\n    function yt(ht) {\n      return ut(ht, function(bt) {\n        return Z.test(bt) ? \"xn--\" + xt(bt) : bt;\n      });\n    }\n    if (N = {\n      version: \"1.3.2\",\n      ucs2: {\n        decode: ft,\n        encode: ct\n      },\n      decode: _t,\n      encode: xt,\n      toASCII: yt,\n      toUnicode: Rt\n    }, o && T)\n      if (r.exports == o)\n        T.exports = N;\n      else\n        for (at in N)\n          N.hasOwnProperty(at) && (o[at] = N[at]);\n    else\n      e.punycode = N;\n  })(commonjsGlobal);\n});\nfunction hasOwnProperty(r, t) {\n  return Object.prototype.hasOwnProperty.call(r, t);\n}\nvar decode$2 = function(r, t, e, o) {\n  t = t || \"&\", e = e || \"=\";\n  var T = {};\n  if (typeof r != \"string\" || r.length === 0)\n    return T;\n  var S = /\\+/g;\n  r = r.split(t);\n  var N = 1e3;\n  o && typeof o.maxKeys == \"number\" && (N = o.maxKeys);\n  var D = r.length;\n  N > 0 && D > N && (D = N);\n  for (var B = 0; B < D; ++B) {\n    var $ = r[B].replace(S, \"%20\"), U = $.indexOf(e), z, V, X, W;\n    U >= 0 ? (z = $.substr(0, U), V = $.substr(U + 1)) : (z = $, V = \"\"), X = decodeURIComponent(z), W = decodeURIComponent(V), hasOwnProperty(T, X) ? Array.isArray(T[X]) ? T[X].push(W) : T[X] = [T[X], W] : T[X] = W;\n  }\n  return T;\n}, stringifyPrimitive = function(r) {\n  switch (typeof r) {\n    case \"string\":\n      return r;\n    case \"boolean\":\n      return r ? \"true\" : \"false\";\n    case \"number\":\n      return isFinite(r) ? r : \"\";\n    default:\n      return \"\";\n  }\n}, encode$2 = function(r, t, e, o) {\n  return t = t || \"&\", e = e || \"=\", r === null && (r = void 0), typeof r == \"object\" ? Object.keys(r).map(function(T) {\n    var S = encodeURIComponent(stringifyPrimitive(T)) + e;\n    return Array.isArray(r[T]) ? r[T].map(function(N) {\n      return S + encodeURIComponent(stringifyPrimitive(N));\n    }).join(t) : S + encodeURIComponent(stringifyPrimitive(r[T]));\n  }).join(t) : o ? encodeURIComponent(stringifyPrimitive(o)) + e + encodeURIComponent(stringifyPrimitive(r)) : \"\";\n};\ncreateCommonjsModule(function(r, t) {\n  t.decode = t.parse = decode$2, t.encode = t.stringify = encode$2;\n});\n/*!\n * @pixi/constants - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar ENV;\n(function(r) {\n  r[r.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", r[r.WEBGL = 1] = \"WEBGL\", r[r.WEBGL2 = 2] = \"WEBGL2\";\n})(ENV || (ENV = {}));\nvar RENDERER_TYPE;\n(function(r) {\n  r[r.UNKNOWN = 0] = \"UNKNOWN\", r[r.WEBGL = 1] = \"WEBGL\", r[r.CANVAS = 2] = \"CANVAS\";\n})(RENDERER_TYPE || (RENDERER_TYPE = {}));\nvar BUFFER_BITS;\n(function(r) {\n  r[r.COLOR = 16384] = \"COLOR\", r[r.DEPTH = 256] = \"DEPTH\", r[r.STENCIL = 1024] = \"STENCIL\";\n})(BUFFER_BITS || (BUFFER_BITS = {}));\nvar BLEND_MODES;\n(function(r) {\n  r[r.NORMAL = 0] = \"NORMAL\", r[r.ADD = 1] = \"ADD\", r[r.MULTIPLY = 2] = \"MULTIPLY\", r[r.SCREEN = 3] = \"SCREEN\", r[r.OVERLAY = 4] = \"OVERLAY\", r[r.DARKEN = 5] = \"DARKEN\", r[r.LIGHTEN = 6] = \"LIGHTEN\", r[r.COLOR_DODGE = 7] = \"COLOR_DODGE\", r[r.COLOR_BURN = 8] = \"COLOR_BURN\", r[r.HARD_LIGHT = 9] = \"HARD_LIGHT\", r[r.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", r[r.DIFFERENCE = 11] = \"DIFFERENCE\", r[r.EXCLUSION = 12] = \"EXCLUSION\", r[r.HUE = 13] = \"HUE\", r[r.SATURATION = 14] = \"SATURATION\", r[r.COLOR = 15] = \"COLOR\", r[r.LUMINOSITY = 16] = \"LUMINOSITY\", r[r.NORMAL_NPM = 17] = \"NORMAL_NPM\", r[r.ADD_NPM = 18] = \"ADD_NPM\", r[r.SCREEN_NPM = 19] = \"SCREEN_NPM\", r[r.NONE = 20] = \"NONE\", r[r.SRC_OVER = 0] = \"SRC_OVER\", r[r.SRC_IN = 21] = \"SRC_IN\", r[r.SRC_OUT = 22] = \"SRC_OUT\", r[r.SRC_ATOP = 23] = \"SRC_ATOP\", r[r.DST_OVER = 24] = \"DST_OVER\", r[r.DST_IN = 25] = \"DST_IN\", r[r.DST_OUT = 26] = \"DST_OUT\", r[r.DST_ATOP = 27] = \"DST_ATOP\", r[r.ERASE = 26] = \"ERASE\", r[r.SUBTRACT = 28] = \"SUBTRACT\", r[r.XOR = 29] = \"XOR\";\n})(BLEND_MODES || (BLEND_MODES = {}));\nvar DRAW_MODES;\n(function(r) {\n  r[r.POINTS = 0] = \"POINTS\", r[r.LINES = 1] = \"LINES\", r[r.LINE_LOOP = 2] = \"LINE_LOOP\", r[r.LINE_STRIP = 3] = \"LINE_STRIP\", r[r.TRIANGLES = 4] = \"TRIANGLES\", r[r.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", r[r.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(DRAW_MODES || (DRAW_MODES = {}));\nvar FORMATS;\n(function(r) {\n  r[r.RGBA = 6408] = \"RGBA\", r[r.RGB = 6407] = \"RGB\", r[r.RG = 33319] = \"RG\", r[r.RED = 6403] = \"RED\", r[r.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", r[r.RGB_INTEGER = 36248] = \"RGB_INTEGER\", r[r.RG_INTEGER = 33320] = \"RG_INTEGER\", r[r.RED_INTEGER = 36244] = \"RED_INTEGER\", r[r.ALPHA = 6406] = \"ALPHA\", r[r.LUMINANCE = 6409] = \"LUMINANCE\", r[r.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", r[r.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", r[r.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(FORMATS || (FORMATS = {}));\nvar TARGETS;\n(function(r) {\n  r[r.TEXTURE_2D = 3553] = \"TEXTURE_2D\", r[r.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", r[r.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(TARGETS || (TARGETS = {}));\nvar TYPES;\n(function(r) {\n  r[r.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", r[r.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", r[r.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", r[r.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", r[r.BYTE = 5120] = \"BYTE\", r[r.SHORT = 5122] = \"SHORT\", r[r.INT = 5124] = \"INT\", r[r.FLOAT = 5126] = \"FLOAT\", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", r[r.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(TYPES || (TYPES = {}));\nvar SAMPLER_TYPES;\n(function(r) {\n  r[r.FLOAT = 0] = \"FLOAT\", r[r.INT = 1] = \"INT\", r[r.UINT = 2] = \"UINT\";\n})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));\nvar SCALE_MODES;\n(function(r) {\n  r[r.NEAREST = 0] = \"NEAREST\", r[r.LINEAR = 1] = \"LINEAR\";\n})(SCALE_MODES || (SCALE_MODES = {}));\nvar WRAP_MODES;\n(function(r) {\n  r[r.CLAMP = 33071] = \"CLAMP\", r[r.REPEAT = 10497] = \"REPEAT\", r[r.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(WRAP_MODES || (WRAP_MODES = {}));\nvar MIPMAP_MODES;\n(function(r) {\n  r[r.OFF = 0] = \"OFF\", r[r.POW2 = 1] = \"POW2\", r[r.ON = 2] = \"ON\", r[r.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(MIPMAP_MODES || (MIPMAP_MODES = {}));\nvar ALPHA_MODES;\n(function(r) {\n  r[r.NPM = 0] = \"NPM\", r[r.UNPACK = 1] = \"UNPACK\", r[r.PMA = 2] = \"PMA\", r[r.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", r[r.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", r[r.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", r[r.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(ALPHA_MODES || (ALPHA_MODES = {}));\nvar CLEAR_MODES;\n(function(r) {\n  r[r.NO = 0] = \"NO\", r[r.YES = 1] = \"YES\", r[r.AUTO = 2] = \"AUTO\", r[r.BLEND = 0] = \"BLEND\", r[r.CLEAR = 1] = \"CLEAR\", r[r.BLIT = 2] = \"BLIT\";\n})(CLEAR_MODES || (CLEAR_MODES = {}));\nvar GC_MODES;\n(function(r) {\n  r[r.AUTO = 0] = \"AUTO\", r[r.MANUAL = 1] = \"MANUAL\";\n})(GC_MODES || (GC_MODES = {}));\nvar PRECISION;\n(function(r) {\n  r.LOW = \"lowp\", r.MEDIUM = \"mediump\", r.HIGH = \"highp\";\n})(PRECISION || (PRECISION = {}));\nvar MASK_TYPES;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.SCISSOR = 1] = \"SCISSOR\", r[r.STENCIL = 2] = \"STENCIL\", r[r.SPRITE = 3] = \"SPRITE\", r[r.COLOR = 4] = \"COLOR\";\n})(MASK_TYPES || (MASK_TYPES = {}));\nvar COLOR_MASK_BITS;\n(function(r) {\n  r[r.RED = 1] = \"RED\", r[r.GREEN = 2] = \"GREEN\", r[r.BLUE = 4] = \"BLUE\", r[r.ALPHA = 8] = \"ALPHA\";\n})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));\nvar MSAA_QUALITY;\n(function(r) {\n  r[r.NONE = 0] = \"NONE\", r[r.LOW = 2] = \"LOW\", r[r.MEDIUM = 4] = \"MEDIUM\", r[r.HIGH = 8] = \"HIGH\";\n})(MSAA_QUALITY || (MSAA_QUALITY = {}));\nvar BUFFER_TYPE;\n(function(r) {\n  r[r.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", r[r.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", r[r.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(BUFFER_TYPE || (BUFFER_TYPE = {}));\n/*!\n * @pixi/utils - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nsettings.RETINA_PREFIX = /@([0-9\\.]+)x/;\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nfunction mapPremultipliedBlendModes() {\n  for (var r = [], t = [], e = 0; e < 32; e++)\n    r[e] = e, t[e] = e;\n  r[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, r[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, r[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  var o = [];\n  return o.push(t), o.push(r), o;\n}\nmapPremultipliedBlendModes();\nvar warnings = {};\nfunction deprecation(r, t, e) {\n  if (e === void 0 && (e = 3), !warnings[t]) {\n    var o = new Error().stack;\n    typeof o > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + r) : (o = o.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + r), console.warn(o), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + r), console.warn(o))), warnings[t] = !0;\n  }\n}\n(function() {\n  function r(t, e, o) {\n    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = o || settings.RESOLUTION, this.resize(t, e);\n  }\n  return r.prototype.clear = function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }, r.prototype.resize = function(t, e) {\n    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n  }, r.prototype.destroy = function() {\n    this.context = null, this.canvas = null;\n  }, Object.defineProperty(r.prototype, \"width\", {\n    get: function() {\n      return this.canvas.width;\n    },\n    set: function(t) {\n      this.canvas.width = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"height\", {\n    get: function() {\n      return this.canvas.height;\n    },\n    set: function(t) {\n      this.canvas.height = Math.round(t);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r;\n})();\nvar Application = function() {\n  function r(t) {\n    var e = this;\n    this.stage = new Container(), t = Object.assign({\n      forceCanvas: !1\n    }, t), this.renderer = autoDetectRenderer(t), r._plugins.forEach(function(o) {\n      o.init.call(e, t);\n    });\n  }\n  return r.registerPlugin = function(t) {\n    deprecation(\"6.5.0\", \"Application.registerPlugin() is deprecated, use extensions.add()\"), extensions.add({\n      type: ExtensionType.Application,\n      ref: t\n    });\n  }, r.prototype.render = function() {\n    this.renderer.render(this.stage);\n  }, Object.defineProperty(r.prototype, \"view\", {\n    get: function() {\n      return this.renderer.view;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(r.prototype, \"screen\", {\n    get: function() {\n      return this.renderer.screen;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), r.prototype.destroy = function(t, e) {\n    var o = this, T = r._plugins.slice(0);\n    T.reverse(), T.forEach(function(S) {\n      S.destroy.call(o);\n    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;\n  }, r._plugins = [], r;\n}();\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ResizePlugin);\n/*!\n * @pixi/mesh-extras - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$8 = function(r, t) {\n  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$8(r, t);\n};\nfunction __extends$8(r, t) {\n  extendStatics$8(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar PlaneGeometry = function(r) {\n  __extends$8(t, r);\n  function t(e, o, T, S) {\n    e === void 0 && (e = 100), o === void 0 && (o = 100), T === void 0 && (T = 10), S === void 0 && (S = 10);\n    var N = r.call(this) || this;\n    return N.segWidth = T, N.segHeight = S, N.width = e, N.height = o, N.build(), N;\n  }\n  return t.prototype.build = function() {\n    for (var e = this.segWidth * this.segHeight, o = [], T = [], S = [], N = this.segWidth - 1, D = this.segHeight - 1, B = this.width / N, $ = this.height / D, U = 0; U < e; U++) {\n      var z = U % this.segWidth, V = U / this.segWidth | 0;\n      o.push(z * B, V * $), T.push(z / N, V / D);\n    }\n    for (var X = N * D, U = 0; U < X; U++) {\n      var W = U % N, Y = U / N | 0, q = Y * this.segWidth + W, Z = Y * this.segWidth + W + 1, K = (Y + 1) * this.segWidth + W, J = (Y + 1) * this.segWidth + W + 1;\n      S.push(q, Z, K, Z, J, K);\n    }\n    this.buffers[0].data = new Float32Array(o), this.buffers[1].data = new Float32Array(T), this.indexBuffer.data = new Uint16Array(S), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n  }, t;\n}(MeshGeometry), RopeGeometry = function(r) {\n  __extends$8(t, r);\n  function t(e, o, T) {\n    e === void 0 && (e = 200), T === void 0 && (T = 0);\n    var S = r.call(this, new Float32Array(o.length * 4), new Float32Array(o.length * 4), new Uint16Array((o.length - 1) * 6)) || this;\n    return S.points = o, S._width = e, S.textureScale = T, S.build(), S;\n  }\n  return Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.build = function() {\n    var e = this.points;\n    if (!!e) {\n      var o = this.getBuffer(\"aVertexPosition\"), T = this.getBuffer(\"aTextureCoord\"), S = this.getIndex();\n      if (!(e.length < 1)) {\n        o.data.length / 4 !== e.length && (o.data = new Float32Array(e.length * 4), T.data = new Float32Array(e.length * 4), S.data = new Uint16Array((e.length - 1) * 6));\n        var N = T.data, D = S.data;\n        N[0] = 0, N[1] = 0, N[2] = 0, N[3] = 1;\n        for (var B = 0, $ = e[0], U = this._width * this.textureScale, z = e.length, V = 0; V < z; V++) {\n          var X = V * 4;\n          if (this.textureScale > 0) {\n            var W = $.x - e[V].x, Y = $.y - e[V].y, q = Math.sqrt(W * W + Y * Y);\n            $ = e[V], B += q / U;\n          } else\n            B = V / (z - 1);\n          N[X] = B, N[X + 1] = 0, N[X + 2] = B, N[X + 3] = 1;\n        }\n        for (var Z = 0, V = 0; V < z - 1; V++) {\n          var X = V * 2;\n          D[Z++] = X, D[Z++] = X + 1, D[Z++] = X + 2, D[Z++] = X + 2, D[Z++] = X + 1, D[Z++] = X + 3;\n        }\n        T.update(), S.update(), this.updateVertices();\n      }\n    }\n  }, t.prototype.updateVertices = function() {\n    var e = this.points;\n    if (!(e.length < 1)) {\n      for (var o = e[0], T, S = 0, N = 0, D = this.buffers[0].data, B = e.length, $ = 0; $ < B; $++) {\n        var U = e[$], z = $ * 4;\n        $ < e.length - 1 ? T = e[$ + 1] : T = U, N = -(T.x - o.x), S = T.y - o.y;\n        var V = Math.sqrt(S * S + N * N), X = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n        S /= V, N /= V, S *= X, N *= X, D[z] = U.x + S, D[z + 1] = U.y + N, D[z + 2] = U.x - S, D[z + 3] = U.y - N, o = U;\n      }\n      this.buffers[0].update();\n    }\n  }, t.prototype.update = function() {\n    this.textureScale > 0 ? this.build() : this.updateVertices();\n  }, t;\n}(MeshGeometry);\n(function(r) {\n  __extends$8(t, r);\n  function t(e, o, T) {\n    T === void 0 && (T = 0);\n    var S = this, N = new RopeGeometry(e.height, o, T), D = new MeshMaterial(e);\n    return T > 0 && (e.baseTexture.wrapMode = WRAP_MODES$5.REPEAT), S = r.call(this, N, D) || this, S.autoUpdate = !0, S;\n  }\n  return t.prototype._render = function(e) {\n    var o = this.geometry;\n    (this.autoUpdate || o._width !== this.shader.texture.height) && (o._width = this.shader.texture.height, o.update()), r.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar SimplePlane = function(r) {\n  __extends$8(t, r);\n  function t(e, o, T) {\n    var S = this, N = new PlaneGeometry(e.width, e.height, o, T), D = new MeshMaterial(Texture.WHITE);\n    return S = r.call(this, N, D) || this, S.texture = e, S.autoResize = !0, S;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID;\n    var e = this.geometry, o = this.shader.texture, T = o.width, S = o.height;\n    this.autoResize && (e.width !== T || e.height !== S) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());\n  }, Object.defineProperty(t.prototype, \"texture\", {\n    get: function() {\n      return this.shader.texture;\n    },\n    set: function(e) {\n      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once(\"update\", this.textureUpdated, this));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), r.prototype._render.call(this, e);\n  }, t.prototype.destroy = function(e) {\n    this.shader.texture.off(\"update\", this.textureUpdated, this), r.prototype.destroy.call(this, e);\n  }, t;\n}(Mesh);\n(function(r) {\n  __extends$8(t, r);\n  function t(e, o, T, S, N) {\n    e === void 0 && (e = Texture.EMPTY);\n    var D = this, B = new MeshGeometry(o, T, S);\n    B.getBuffer(\"aVertexPosition\").static = !1;\n    var $ = new MeshMaterial(e);\n    return D = r.call(this, B, $, null, N) || this, D.autoUpdate = !0, D;\n  }\n  return Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this.autoUpdate && this.geometry.getBuffer(\"aVertexPosition\").update(), r.prototype._render.call(this, e);\n  }, t;\n})(Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n(function(r) {\n  __extends$8(t, r);\n  function t(e, o, T, S, N) {\n    o === void 0 && (o = DEFAULT_BORDER_SIZE), T === void 0 && (T = DEFAULT_BORDER_SIZE), S === void 0 && (S = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE);\n    var D = r.call(this, Texture.WHITE, 4, 4) || this;\n    return D._origWidth = e.orig.width, D._origHeight = e.orig.height, D._width = D._origWidth, D._height = D._origHeight, D._leftWidth = o, D._rightWidth = S, D._topHeight = T, D._bottomHeight = N, D.texture = e, D;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }, Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.updateHorizontalVertices = function() {\n    var e = this.vertices, o = this._getMinScale();\n    e[9] = e[11] = e[13] = e[15] = this._topHeight * o, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * o, e[25] = e[27] = e[29] = e[31] = this._height;\n  }, t.prototype.updateVerticalVertices = function() {\n    var e = this.vertices, o = this._getMinScale();\n    e[2] = e[10] = e[18] = e[26] = this._leftWidth * o, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * o, e[6] = e[14] = e[22] = e[30] = this._width;\n  }, t.prototype._getMinScale = function() {\n    var e = this._leftWidth + this._rightWidth, o = this._width > e ? 1 : this._width / e, T = this._topHeight + this._bottomHeight, S = this._height > T ? 1 : this._height / T, N = Math.min(o, S);\n    return N;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"leftWidth\", {\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(e) {\n      this._leftWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rightWidth\", {\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(e) {\n      this._rightWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"topHeight\", {\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(e) {\n      this._topHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"bottomHeight\", {\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(e) {\n      this._bottomHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._refresh = function() {\n    var e = this.texture, o = this.geometry.buffers[1].data;\n    this._origWidth = e.orig.width, this._origHeight = e.orig.height;\n    var T = 1 / this._origWidth, S = 1 / this._origHeight;\n    o[0] = o[8] = o[16] = o[24] = 0, o[1] = o[3] = o[5] = o[7] = 0, o[6] = o[14] = o[22] = o[30] = 1, o[25] = o[27] = o[29] = o[31] = 1, o[2] = o[10] = o[18] = o[26] = T * this._leftWidth, o[4] = o[12] = o[20] = o[28] = 1 - T * this._rightWidth, o[9] = o[11] = o[13] = o[15] = S * this._topHeight, o[17] = o[19] = o[21] = o[23] = 1 - S * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }, t;\n})(SimplePlane);\n/*!\n * @pixi/sprite-animated - v6.5.5\n * Compiled Fri, 30 Sep 2022 13:37:53 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics$7 = function(r, t) {\n  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$7(r, t);\n};\nfunction __extends$7(r, t) {\n  extendStatics$7(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar AnimatedSprite = function(r) {\n  __extends$7(t, r);\n  function t(e, o) {\n    o === void 0 && (o = !0);\n    var T = r.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;\n    return T._textures = null, T._durations = null, T._autoUpdate = o, T._isConnectedToTicker = !1, T.animationSpeed = 1, T.loop = !0, T.updateAnchor = !1, T.onComplete = null, T.onFrameChange = null, T.onLoop = null, T._currentTime = 0, T._playing = !1, T._previousFrame = null, T.textures = e, T;\n  }\n  return t.prototype.stop = function() {\n    !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n  }, t.prototype.play = function() {\n    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));\n  }, t.prototype.gotoAndStop = function(e) {\n    this.stop();\n    var o = this.currentFrame;\n    this._currentTime = e, o !== this.currentFrame && this.updateTexture();\n  }, t.prototype.gotoAndPlay = function(e) {\n    var o = this.currentFrame;\n    this._currentTime = e, o !== this.currentFrame && this.updateTexture(), this.play();\n  }, t.prototype.update = function(e) {\n    if (!!this._playing) {\n      var o = this.animationSpeed * e, T = this.currentFrame;\n      if (this._durations !== null) {\n        var S = this._currentTime % 1 * this._durations[this.currentFrame];\n        for (S += o / 60 * 1e3; S < 0; )\n          this._currentTime--, S += this._durations[this.currentFrame];\n        var N = Math.sign(this.animationSpeed * e);\n        for (this._currentTime = Math.floor(this._currentTime); S >= this._durations[this.currentFrame]; )\n          S -= this._durations[this.currentFrame] * N, this._currentTime += N;\n        this._currentTime += S / this._durations[this.currentFrame];\n      } else\n        this._currentTime += o;\n      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : T !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < T ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > T && this.onLoop()), this.updateTexture());\n    }\n  }, t.prototype.updateTexture = function() {\n    var e = this.currentFrame;\n    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n  }, t.prototype.destroy = function(e) {\n    this.stop(), r.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n  }, t.fromFrames = function(e) {\n    for (var o = [], T = 0; T < e.length; ++T)\n      o.push(Texture.from(e[T]));\n    return new t(o);\n  }, t.fromImages = function(e) {\n    for (var o = [], T = 0; T < e.length; ++T)\n      o.push(Texture.from(e[T]));\n    return new t(o);\n  }, Object.defineProperty(t.prototype, \"totalFrames\", {\n    get: function() {\n      return this._textures.length;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textures\", {\n    get: function() {\n      return this._textures;\n    },\n    set: function(e) {\n      if (e[0] instanceof Texture)\n        this._textures = e, this._durations = null;\n      else {\n        this._textures = [], this._durations = [];\n        for (var o = 0; o < e.length; o++)\n          this._textures.push(e[o].texture), this._durations.push(e[o].time);\n      }\n      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"currentFrame\", {\n    get: function() {\n      var e = Math.floor(this._currentTime) % this._textures.length;\n      return e < 0 && (e += this._textures.length), e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"playing\", {\n    get: function() {\n      return this._playing;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"autoUpdate\", {\n    get: function() {\n      return this._autoUpdate;\n    },\n    set: function(e) {\n      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n}(Sprite);\n/*!\n * pixi.js - v6.5.5\n * Compiled Fri, 30 Sep 2022 14:06:54 UTC\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nextensions.add(\n  AccessibilityManager,\n  Extract,\n  InteractionManager,\n  ParticleRenderer,\n  Prepare,\n  BatchRenderer,\n  TilingSpriteRenderer,\n  BitmapFontLoader,\n  CompressedTextureLoader,\n  DDSLoader,\n  KTXLoader,\n  SpritesheetLoader,\n  TickerPlugin,\n  AppLoaderPlugin\n);\nvar Ni;\nclass EventListenerCtn {\n  constructor() {\n    rt(this, Ni, []);\n  }\n  add(t, e, o, T = {}) {\n    if (t instanceof BaseTexture) {\n      switch (e) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          t.on(e, o, T), H(this, Ni).push(() => t.off(e, o, T));\n          break;\n      }\n      return;\n    }\n    if (t instanceof i$1) {\n      t.on(e, o, T), H(this, Ni).push(() => t.off(e, o, T));\n      return;\n    }\n    t.addEventListener(e, o, T), H(this, Ni).push(() => {\n      var S;\n      return t.removeEventListener(e, o, { capture: (S = T.capture) != null ? S : !1 });\n    });\n  }\n  clear() {\n    for (const t of H(this, Ni))\n      t();\n    nt(this, Ni, []);\n  }\n}\nNi = new WeakMap();\nconst PACKET_TYPES = /* @__PURE__ */ Object.create(null);\nPACKET_TYPES.open = \"0\";\nPACKET_TYPES.close = \"1\";\nPACKET_TYPES.ping = \"2\";\nPACKET_TYPES.pong = \"3\";\nPACKET_TYPES.message = \"4\";\nPACKET_TYPES.upgrade = \"5\";\nPACKET_TYPES.noop = \"6\";\nconst PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\nObject.keys(PACKET_TYPES).forEach((r) => {\n  PACKET_TYPES_REVERSE[PACKET_TYPES[r]] = r;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" }, withNativeBlob$1 = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", withNativeArrayBuffer$2 = typeof ArrayBuffer == \"function\", isView$1 = (r) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(r) : r && r.buffer instanceof ArrayBuffer, encodePacket = ({ type: r, data: t }, e, o) => withNativeBlob$1 && t instanceof Blob ? e ? o(t) : encodeBlobAsBase64(t, o) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? o(t) : encodeBlobAsBase64(new Blob([t]), o) : o(PACKET_TYPES[r] + (t || \"\")), encodeBlobAsBase64 = (r, t) => {\n  const e = new FileReader();\n  return e.onload = function() {\n    const o = e.result.split(\",\")[1];\n    t(\"b\" + o);\n  }, e.readAsDataURL(r);\n}, chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", lookup$1 = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let r = 0; r < chars.length; r++)\n  lookup$1[chars.charCodeAt(r)] = r;\nconst decode$1 = (r) => {\n  let t = r.length * 0.75, e = r.length, o, T = 0, S, N, D, B;\n  r[r.length - 1] === \"=\" && (t--, r[r.length - 2] === \"=\" && t--);\n  const $ = new ArrayBuffer(t), U = new Uint8Array($);\n  for (o = 0; o < e; o += 4)\n    S = lookup$1[r.charCodeAt(o)], N = lookup$1[r.charCodeAt(o + 1)], D = lookup$1[r.charCodeAt(o + 2)], B = lookup$1[r.charCodeAt(o + 3)], U[T++] = S << 2 | N >> 4, U[T++] = (N & 15) << 4 | D >> 2, U[T++] = (D & 3) << 6 | B & 63;\n  return $;\n}, withNativeArrayBuffer$1 = typeof ArrayBuffer == \"function\", decodePacket = (r, t) => {\n  if (typeof r != \"string\")\n    return {\n      type: \"message\",\n      data: mapBinary(r, t)\n    };\n  const e = r.charAt(0);\n  return e === \"b\" ? {\n    type: \"message\",\n    data: decodeBase64Packet(r.substring(1), t)\n  } : PACKET_TYPES_REVERSE[e] ? r.length > 1 ? {\n    type: PACKET_TYPES_REVERSE[e],\n    data: r.substring(1)\n  } : {\n    type: PACKET_TYPES_REVERSE[e]\n  } : ERROR_PACKET;\n}, decodeBase64Packet = (r, t) => {\n  if (withNativeArrayBuffer$1) {\n    const e = decode$1(r);\n    return mapBinary(e, t);\n  } else\n    return { base64: !0, data: r };\n}, mapBinary = (r, t) => {\n  switch (t) {\n    case \"blob\":\n      return r instanceof ArrayBuffer ? new Blob([r]) : r;\n    case \"arraybuffer\":\n    default:\n      return r;\n  }\n}, SEPARATOR = String.fromCharCode(30), encodePayload = (r, t) => {\n  const e = r.length, o = new Array(e);\n  let T = 0;\n  r.forEach((S, N) => {\n    encodePacket(S, !1, (D) => {\n      o[N] = D, ++T === e && t(o.join(SEPARATOR));\n    });\n  });\n}, decodePayload = (r, t) => {\n  const e = r.split(SEPARATOR), o = [];\n  for (let T = 0; T < e.length; T++) {\n    const S = decodePacket(e[T], t);\n    if (o.push(S), S.type === \"error\")\n      break;\n  }\n  return o;\n}, protocol$1 = 4;\nfunction Emitter(r) {\n  if (r)\n    return mixin(r);\n}\nfunction mixin(r) {\n  for (var t in Emitter.prototype)\n    r[t] = Emitter.prototype[t];\n  return r;\n}\nEmitter.prototype.on = Emitter.prototype.addEventListener = function(r, t) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + r] = this._callbacks[\"$\" + r] || []).push(t), this;\n};\nEmitter.prototype.once = function(r, t) {\n  function e() {\n    this.off(r, e), t.apply(this, arguments);\n  }\n  return e.fn = t, this.on(r, e), this;\n};\nEmitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(r, t) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var e = this._callbacks[\"$\" + r];\n  if (!e)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + r], this;\n  for (var o, T = 0; T < e.length; T++)\n    if (o = e[T], o === t || o.fn === t) {\n      e.splice(T, 1);\n      break;\n    }\n  return e.length === 0 && delete this._callbacks[\"$\" + r], this;\n};\nEmitter.prototype.emit = function(r) {\n  this._callbacks = this._callbacks || {};\n  for (var t = new Array(arguments.length - 1), e = this._callbacks[\"$\" + r], o = 1; o < arguments.length; o++)\n    t[o - 1] = arguments[o];\n  if (e) {\n    e = e.slice(0);\n    for (var o = 0, T = e.length; o < T; ++o)\n      e[o].apply(this, t);\n  }\n  return this;\n};\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\nEmitter.prototype.listeners = function(r) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + r] || [];\n};\nEmitter.prototype.hasListeners = function(r) {\n  return !!this.listeners(r).length;\n};\nconst globalThisShim = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction pick(r, ...t) {\n  return t.reduce((e, o) => (r.hasOwnProperty(o) && (e[o] = r[o]), e), {});\n}\nconst NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(r, t) {\n  t.useNativeTimers ? (r.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), r.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (r.setTimeoutFn = setTimeout.bind(globalThisShim), r.clearTimeoutFn = clearTimeout.bind(globalThisShim));\n}\nconst BASE64_OVERHEAD = 1.33;\nfunction byteLength(r) {\n  return typeof r == \"string\" ? utf8Length(r) : Math.ceil((r.byteLength || r.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(r) {\n  let t = 0, e = 0;\n  for (let o = 0, T = r.length; o < T; o++)\n    t = r.charCodeAt(o), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (o++, e += 4);\n  return e;\n}\nclass TransportError extends Error {\n  constructor(t, e, o) {\n    super(t), this.description = e, this.context = o, this.type = \"TransportError\";\n  }\n}\nclass Transport extends Emitter {\n  constructor(t) {\n    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = \"\", this.socket = t.socket;\n  }\n  onError(t, e, o) {\n    return super.emitReserved(\"error\", new TransportError(t, e, o)), this;\n  }\n  open() {\n    return (this.readyState === \"closed\" || this.readyState === \"\") && (this.readyState = \"opening\", this.doOpen()), this;\n  }\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  send(t) {\n    this.readyState === \"open\" && this.write(t);\n  }\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  onData(t) {\n    const e = decodePacket(t, this.socket.binaryType);\n    this.onPacket(e);\n  }\n  onPacket(t) {\n    super.emitReserved(\"packet\", t);\n  }\n  onClose(t) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", t);\n  }\n}\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map$1 = {};\nlet seed = 0, i = 0, prev;\nfunction encode$1(r) {\n  let t = \"\";\n  do\n    t = alphabet[r % length] + t, r = Math.floor(r / length);\n  while (r > 0);\n  return t;\n}\nfunction yeast() {\n  const r = encode$1(+new Date());\n  return r !== prev ? (seed = 0, prev = r) : r + \".\" + encode$1(seed++);\n}\nfor (; i < length; i++)\n  map$1[alphabet[i]] = i;\nfunction encode(r) {\n  let t = \"\";\n  for (let e in r)\n    r.hasOwnProperty(e) && (t.length && (t += \"&\"), t += encodeURIComponent(e) + \"=\" + encodeURIComponent(r[e]));\n  return t;\n}\nfunction decode(r) {\n  let t = {}, e = r.split(\"&\");\n  for (let o = 0, T = e.length; o < T; o++) {\n    let S = e[o].split(\"=\");\n    t[decodeURIComponent(S[0])] = decodeURIComponent(S[1]);\n  }\n  return t;\n}\nlet value = !1;\ntry {\n  value = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst hasCORS = value;\nfunction XHR(r) {\n  const t = r.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!t || hasCORS))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!t)\n    try {\n      return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction empty() {\n}\nconst hasXHR2 = function() {\n  return new XHR({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass Polling extends Transport {\n  constructor(t) {\n    if (super(t), this.polling = !1, typeof location < \"u\") {\n      const o = location.protocol === \"https:\";\n      let T = location.port;\n      T || (T = o ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && t.hostname !== location.hostname || T !== t.port, this.xs = t.secure !== o;\n    }\n    const e = t && t.forceBase64;\n    this.supportsBinary = hasXHR2 && !e;\n  }\n  get name() {\n    return \"polling\";\n  }\n  doOpen() {\n    this.poll();\n  }\n  pause(t) {\n    this.readyState = \"pausing\";\n    const e = () => {\n      this.readyState = \"paused\", t();\n    };\n    if (this.polling || !this.writable) {\n      let o = 0;\n      this.polling && (o++, this.once(\"pollComplete\", function() {\n        --o || e();\n      })), this.writable || (o++, this.once(\"drain\", function() {\n        --o || e();\n      }));\n    } else\n      e();\n  }\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  onData(t) {\n    const e = (o) => {\n      if (this.readyState === \"opening\" && o.type === \"open\" && this.onOpen(), o.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(o);\n    };\n    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  doClose() {\n    const t = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? t() : this.once(\"open\", t);\n  }\n  write(t) {\n    this.writable = !1, encodePayload(t, (e) => {\n      this.doWrite(e, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"https\" : \"http\";\n    let o = \"\";\n    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === \"https\" && Number(this.opts.port) !== 443 || e === \"http\" && Number(this.opts.port) !== 80) && (o = \":\" + this.opts.port);\n    const T = encode(t), S = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (S ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + o + this.opts.path + (T.length ? \"?\" + T : \"\");\n  }\n  request(t = {}) {\n    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);\n  }\n  doWrite(t, e) {\n    const o = this.request({\n      method: \"POST\",\n      data: t\n    });\n    o.on(\"success\", e), o.on(\"error\", (T, S) => {\n      this.onError(\"xhr post error\", T, S);\n    });\n  }\n  doPoll() {\n    const t = this.request();\n    t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (e, o) => {\n      this.onError(\"xhr poll error\", e, o);\n    }), this.pollXhr = t;\n  }\n}\nclass Request extends Emitter {\n  constructor(t, e) {\n    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();\n  }\n  create() {\n    const t = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n    const e = this.xhr = new XHR(t);\n    try {\n      e.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n          for (let o in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(o) && e.setRequestHeader(o, this.opts.extraHeaders[o]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        e.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof e.status == \"number\" ? e.status : 0);\n        }, 0));\n      }, e.send(this.data);\n    } catch (o) {\n      this.setTimeoutFn(() => {\n        this.onError(o);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);\n  }\n  onError(t) {\n    this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n  }\n  cleanup(t) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = empty, t)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete Request.requests[this.index], this.xhr = null;\n    }\n  }\n  onLoad() {\n    const t = this.xhr.responseText;\n    t !== null && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n  }\n  abort() {\n    this.cleanup();\n  }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", unloadHandler);\n  else if (typeof addEventListener == \"function\") {\n    const r = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n    addEventListener(r, unloadHandler, !1);\n  }\n}\nfunction unloadHandler() {\n  for (let r in Request.requests)\n    Request.requests.hasOwnProperty(r) && Request.requests[r].abort();\n}\nconst nextTick = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = \"arraybuffer\", isReactNative = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends Transport {\n  constructor(t) {\n    super(t), this.supportsBinary = !t.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const t = this.uri(), e = this.opts.protocols, o = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (o.headers = this.opts.extraHeaders);\n    try {\n      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, o);\n    } catch (T) {\n      return this.emitReserved(\"error\", T);\n    }\n    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();\n  }\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (t) => this.onClose({\n      description: \"websocket connection closed\",\n      context: t\n    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError(\"websocket error\", t);\n  }\n  write(t) {\n    this.writable = !1;\n    for (let e = 0; e < t.length; e++) {\n      const o = t[e], T = e === t.length - 1;\n      encodePacket(o, this.supportsBinary, (S) => {\n        const N = {};\n        try {\n          usingBrowserWebSocket && this.ws.send(S);\n        } catch {\n        }\n        T && nextTick(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"wss\" : \"ws\";\n    let o = \"\";\n    this.opts.port && (e === \"wss\" && Number(this.opts.port) !== 443 || e === \"ws\" && Number(this.opts.port) !== 80) && (o = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);\n    const T = encode(t), S = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (S ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + o + this.opts.path + (T.length ? \"?\" + T : \"\");\n  }\n  check() {\n    return !!WebSocket;\n  }\n}\nconst transports = {\n  websocket: WS,\n  polling: Polling\n}, re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, parts = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction parse$1(r) {\n  const t = r, e = r.indexOf(\"[\"), o = r.indexOf(\"]\");\n  e != -1 && o != -1 && (r = r.substring(0, e) + r.substring(e, o).replace(/:/g, \";\") + r.substring(o, r.length));\n  let T = re.exec(r || \"\"), S = {}, N = 14;\n  for (; N--; )\n    S[parts[N]] = T[N] || \"\";\n  return e != -1 && o != -1 && (S.source = t, S.host = S.host.substring(1, S.host.length - 1).replace(/;/g, \":\"), S.authority = S.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), S.ipv6uri = !0), S.pathNames = pathNames(S, S.path), S.queryKey = queryKey(S, S.query), S;\n}\nfunction pathNames(r, t) {\n  const e = /\\/{2,9}/g, o = t.replace(e, \"/\").split(\"/\");\n  return (t.substr(0, 1) == \"/\" || t.length === 0) && o.splice(0, 1), t.substr(t.length - 1, 1) == \"/\" && o.splice(o.length - 1, 1), o;\n}\nfunction queryKey(r, t) {\n  const e = {};\n  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(o, T, S) {\n    T && (e[T] = S);\n  }), e;\n}\nclass Socket$1 extends Emitter {\n  constructor(t, e = {}) {\n    super(), t && typeof t == \"object\" && (e = t, t = null), t ? (t = parse$1(t), e.hostname = t.host, e.secure = t.protocol === \"https\" || t.protocol === \"wss\", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse$1(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < \"u\" && location.protocol === \"https:\", e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = e.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.readyState = \"\", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !0\n    }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\", typeof this.opts.query == \"string\" && (this.opts.query = decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && addEventListener(\"beforeunload\", () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, !1), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  createTransport(t) {\n    const e = Object.assign({}, this.opts.query);\n    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);\n    const o = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n      query: e,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new transports[t](o);\n  }\n  open() {\n    let t;\n    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      t = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      t = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      t = this.createTransport(t);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    t.open(), this.setTransport(t);\n  }\n  setTransport(t) {\n    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (e) => this.onClose(\"transport close\", e));\n  }\n  probe(t) {\n    let e = this.createTransport(t), o = !1;\n    Socket$1.priorWebsocketSuccess = !1;\n    const T = () => {\n      o || (e.send([{ type: \"ping\", data: \"probe\" }]), e.once(\"packet\", (z) => {\n        if (!o)\n          if (z.type === \"pong\" && z.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e)\n              return;\n            Socket$1.priorWebsocketSuccess = e.name === \"websocket\", this.transport.pause(() => {\n              o || this.readyState !== \"closed\" && (U(), this.setTransport(e), e.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const V = new Error(\"probe error\");\n            V.transport = e.name, this.emitReserved(\"upgradeError\", V);\n          }\n      }));\n    };\n    function S() {\n      o || (o = !0, U(), e.close(), e = null);\n    }\n    const N = (z) => {\n      const V = new Error(\"probe error: \" + z);\n      V.transport = e.name, S(), this.emitReserved(\"upgradeError\", V);\n    };\n    function D() {\n      N(\"transport closed\");\n    }\n    function B() {\n      N(\"socket closed\");\n    }\n    function $(z) {\n      e && z.name !== e.name && S();\n    }\n    const U = () => {\n      e.removeListener(\"open\", T), e.removeListener(\"error\", N), e.removeListener(\"close\", D), this.off(\"close\", B), this.off(\"upgrading\", $);\n    };\n    e.once(\"open\", T), e.once(\"error\", N), e.once(\"close\", D), this.once(\"close\", B), this.once(\"upgrading\", $), e.open();\n  }\n  onOpen() {\n    if (this.readyState = \"open\", Socket$1.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade && this.transport.pause) {\n      let t = 0;\n      const e = this.upgrades.length;\n      for (; t < e; t++)\n        this.probe(this.upgrades[t]);\n    }\n  }\n  onPacket(t) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(t.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const e = new Error(\"server error\");\n          e.code = t.data, this.onError(e);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n          break;\n      }\n  }\n  onHandshake(t) {\n    this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const t = this.getWritablePackets();\n      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n    }\n  }\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let e = 1;\n    for (let o = 0; o < this.writeBuffer.length; o++) {\n      const T = this.writeBuffer[o].data;\n      if (T && (e += byteLength(T)), o > 0 && e > this.maxPayload)\n        return this.writeBuffer.slice(0, o);\n      e += 2;\n    }\n    return this.writeBuffer;\n  }\n  write(t, e, o) {\n    return this.sendPacket(\"message\", t, e, o), this;\n  }\n  send(t, e, o) {\n    return this.sendPacket(\"message\", t, e, o), this;\n  }\n  sendPacket(t, e, o, T) {\n    if (typeof e == \"function\" && (T = e, e = void 0), typeof o == \"function\" && (T = o, o = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    o = o || {}, o.compress = o.compress !== !1;\n    const S = {\n      type: t,\n      data: e,\n      options: o\n    };\n    this.emitReserved(\"packetCreate\", S), this.writeBuffer.push(S), T && this.once(\"flush\", T), this.flush();\n  }\n  close() {\n    const t = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, e = () => {\n      this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n    }, o = () => {\n      this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? o() : t();\n    }) : this.upgrading ? o() : t()), this;\n  }\n  onError(t) {\n    Socket$1.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n  }\n  onClose(t, e) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && removeEventListener(\"offline\", this.offlineEventListener, !1), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  filterUpgrades(t) {\n    const e = [];\n    let o = 0;\n    const T = t.length;\n    for (; o < T; o++)\n      ~this.transports.indexOf(t[o]) && e.push(t[o]);\n    return e;\n  }\n}\nSocket$1.protocol = protocol$1;\nfunction url(r, t = \"\", e) {\n  let o = r;\n  e = e || typeof location < \"u\" && location, r == null && (r = e.protocol + \"//\" + e.host), typeof r == \"string\" && (r.charAt(0) === \"/\" && (r.charAt(1) === \"/\" ? r = e.protocol + r : r = e.host + r), /^(https?|wss?):\\/\\//.test(r) || (typeof e < \"u\" ? r = e.protocol + \"//\" + r : r = \"https://\" + r), o = parse$1(r)), o.port || (/^(http|ws)$/.test(o.protocol) ? o.port = \"80\" : /^(http|ws)s$/.test(o.protocol) && (o.port = \"443\")), o.path = o.path || \"/\";\n  const S = o.host.indexOf(\":\") !== -1 ? \"[\" + o.host + \"]\" : o.host;\n  return o.id = o.protocol + \"://\" + S + \":\" + o.port + t, o.href = o.protocol + \"://\" + S + (e && e.port === o.port ? \"\" : \":\" + o.port), o;\n}\nconst withNativeArrayBuffer = typeof ArrayBuffer == \"function\", isView = (r) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(r) : r.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == \"function\" || typeof Blob < \"u\" && toString.call(Blob) === \"[object BlobConstructor]\", withNativeFile = typeof File == \"function\" || typeof File < \"u\" && toString.call(File) === \"[object FileConstructor]\";\nfunction isBinary(r) {\n  return withNativeArrayBuffer && (r instanceof ArrayBuffer || isView(r)) || withNativeBlob && r instanceof Blob || withNativeFile && r instanceof File;\n}\nfunction hasBinary(r, t) {\n  if (!r || typeof r != \"object\")\n    return !1;\n  if (Array.isArray(r)) {\n    for (let e = 0, o = r.length; e < o; e++)\n      if (hasBinary(r[e]))\n        return !0;\n    return !1;\n  }\n  if (isBinary(r))\n    return !0;\n  if (r.toJSON && typeof r.toJSON == \"function\" && arguments.length === 1)\n    return hasBinary(r.toJSON(), !0);\n  for (const e in r)\n    if (Object.prototype.hasOwnProperty.call(r, e) && hasBinary(r[e]))\n      return !0;\n  return !1;\n}\nfunction deconstructPacket(r) {\n  const t = [], e = r.data, o = r;\n  return o.data = _deconstructPacket(e, t), o.attachments = t.length, { packet: o, buffers: t };\n}\nfunction _deconstructPacket(r, t) {\n  if (!r)\n    return r;\n  if (isBinary(r)) {\n    const e = { _placeholder: !0, num: t.length };\n    return t.push(r), e;\n  } else if (Array.isArray(r)) {\n    const e = new Array(r.length);\n    for (let o = 0; o < r.length; o++)\n      e[o] = _deconstructPacket(r[o], t);\n    return e;\n  } else if (typeof r == \"object\" && !(r instanceof Date)) {\n    const e = {};\n    for (const o in r)\n      Object.prototype.hasOwnProperty.call(r, o) && (e[o] = _deconstructPacket(r[o], t));\n    return e;\n  }\n  return r;\n}\nfunction reconstructPacket(r, t) {\n  return r.data = _reconstructPacket(r.data, t), r.attachments = void 0, r;\n}\nfunction _reconstructPacket(r, t) {\n  if (!r)\n    return r;\n  if (r && r._placeholder === !0) {\n    if (typeof r.num == \"number\" && r.num >= 0 && r.num < t.length)\n      return t[r.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(r))\n    for (let e = 0; e < r.length; e++)\n      r[e] = _reconstructPacket(r[e], t);\n  else if (typeof r == \"object\")\n    for (const e in r)\n      Object.prototype.hasOwnProperty.call(r, e) && (r[e] = _reconstructPacket(r[e], t));\n  return r;\n}\nconst protocol = 5;\nvar PacketType;\n(function(r) {\n  r[r.CONNECT = 0] = \"CONNECT\", r[r.DISCONNECT = 1] = \"DISCONNECT\", r[r.EVENT = 2] = \"EVENT\", r[r.ACK = 3] = \"ACK\", r[r.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", r[r.BINARY_EVENT = 5] = \"BINARY_EVENT\", r[r.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\nclass Encoder {\n  constructor(t) {\n    this.replacer = t;\n  }\n  encode(t) {\n    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];\n  }\n  encodeAsString(t) {\n    let e = \"\" + t.type;\n    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + \"-\"), t.nsp && t.nsp !== \"/\" && (e += t.nsp + \",\"), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;\n  }\n  encodeAsBinary(t) {\n    const e = deconstructPacket(t), o = this.encodeAsString(e.packet), T = e.buffers;\n    return T.unshift(o), T;\n  }\n}\nclass Decoder extends Emitter {\n  constructor(t) {\n    super(), this.reviver = t;\n  }\n  add(t) {\n    let e;\n    if (typeof t == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n    } else if (isBinary(t) || t.base64)\n      if (this.reconstructor)\n        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + t);\n  }\n  decodeString(t) {\n    let e = 0;\n    const o = {\n      type: Number(t.charAt(0))\n    };\n    if (PacketType[o.type] === void 0)\n      throw new Error(\"unknown packet type \" + o.type);\n    if (o.type === PacketType.BINARY_EVENT || o.type === PacketType.BINARY_ACK) {\n      const S = e + 1;\n      for (; t.charAt(++e) !== \"-\" && e != t.length; )\n        ;\n      const N = t.substring(S, e);\n      if (N != Number(N) || t.charAt(e) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      o.attachments = Number(N);\n    }\n    if (t.charAt(e + 1) === \"/\") {\n      const S = e + 1;\n      for (; ++e && !(t.charAt(e) === \",\" || e === t.length); )\n        ;\n      o.nsp = t.substring(S, e);\n    } else\n      o.nsp = \"/\";\n    const T = t.charAt(e + 1);\n    if (T !== \"\" && Number(T) == T) {\n      const S = e + 1;\n      for (; ++e; ) {\n        const N = t.charAt(e);\n        if (N == null || Number(N) != N) {\n          --e;\n          break;\n        }\n        if (e === t.length)\n          break;\n      }\n      o.id = Number(t.substring(S, e + 1));\n    }\n    if (t.charAt(++e)) {\n      const S = this.tryParse(t.substr(e));\n      if (Decoder.isPayloadValid(o.type, S))\n        o.data = S;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return o;\n  }\n  tryParse(t) {\n    try {\n      return JSON.parse(t, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(t, e) {\n    switch (t) {\n      case PacketType.CONNECT:\n        return typeof e == \"object\";\n      case PacketType.DISCONNECT:\n        return e === void 0;\n      case PacketType.CONNECT_ERROR:\n        return typeof e == \"string\" || typeof e == \"object\";\n      case PacketType.EVENT:\n      case PacketType.BINARY_EVENT:\n        return Array.isArray(e) && e.length > 0;\n      case PacketType.ACK:\n      case PacketType.BINARY_ACK:\n        return Array.isArray(e);\n    }\n  }\n  destroy() {\n    this.reconstructor && this.reconstructor.finishedReconstruction();\n  }\n}\nclass BinaryReconstructor {\n  constructor(t) {\n    this.packet = t, this.buffers = [], this.reconPack = t;\n  }\n  takeBinaryData(t) {\n    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n      const e = reconstructPacket(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), e;\n    }\n    return null;\n  }\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  protocol,\n  get PacketType() {\n    return PacketType;\n  },\n  Encoder,\n  Decoder\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction on(r, t, e) {\n  return r.on(t, e), function() {\n    r.off(t, e);\n  };\n}\nconst RESERVED_EVENTS = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nclass Socket extends Emitter {\n  constructor(t, e, o) {\n    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, o && o.auth && (this.auth = o.auth), this.io._autoConnect && this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs)\n      return;\n    const t = this.io;\n    this.subs = [\n      on(t, \"open\", this.onopen.bind(this)),\n      on(t, \"packet\", this.onpacket.bind(this)),\n      on(t, \"error\", this.onerror.bind(this)),\n      on(t, \"close\", this.onclose.bind(this))\n    ];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  open() {\n    return this.connect();\n  }\n  send(...t) {\n    return t.unshift(\"message\"), this.emit.apply(this, t), this;\n  }\n  emit(t, ...e) {\n    if (RESERVED_EVENTS.hasOwnProperty(t))\n      throw new Error('\"' + t.toString() + '\" is a reserved event name');\n    e.unshift(t);\n    const o = {\n      type: PacketType.EVENT,\n      data: e\n    };\n    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == \"function\") {\n      const N = this.ids++, D = e.pop();\n      this._registerAckCallback(N, D), o.id = N;\n    }\n    const T = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!T || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;\n  }\n  _registerAckCallback(t, e) {\n    const o = this.flags.timeout;\n    if (o === void 0) {\n      this.acks[t] = e;\n      return;\n    }\n    const T = this.io.setTimeoutFn(() => {\n      delete this.acks[t];\n      for (let S = 0; S < this.sendBuffer.length; S++)\n        this.sendBuffer[S].id === t && this.sendBuffer.splice(S, 1);\n      e.call(this, new Error(\"operation has timed out\"));\n    }, o);\n    this.acks[t] = (...S) => {\n      this.io.clearTimeoutFn(T), e.apply(this, [null, ...S]);\n    };\n  }\n  packet(t) {\n    t.nsp = this.nsp, this.io._packet(t);\n  }\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((t) => {\n      this.packet({ type: PacketType.CONNECT, data: t });\n    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });\n  }\n  onerror(t) {\n    this.connected || this.emitReserved(\"connect_error\", t);\n  }\n  onclose(t, e) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n  }\n  onpacket(t) {\n    if (t.nsp === this.nsp)\n      switch (t.type) {\n        case PacketType.CONNECT:\n          if (t.data && t.data.sid) {\n            const T = t.data.sid;\n            this.onconnect(T);\n          } else\n            this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case PacketType.EVENT:\n        case PacketType.BINARY_EVENT:\n          this.onevent(t);\n          break;\n        case PacketType.ACK:\n        case PacketType.BINARY_ACK:\n          this.onack(t);\n          break;\n        case PacketType.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case PacketType.CONNECT_ERROR:\n          this.destroy();\n          const o = new Error(t.data.message);\n          o.data = t.data.data, this.emitReserved(\"connect_error\", o);\n          break;\n      }\n  }\n  onevent(t) {\n    const e = t.data || [];\n    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n  }\n  emitEvent(t) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const e = this._anyListeners.slice();\n      for (const o of e)\n        o.apply(this, t);\n    }\n    super.emit.apply(this, t);\n  }\n  ack(t) {\n    const e = this;\n    let o = !1;\n    return function(...T) {\n      o || (o = !0, e.packet({\n        type: PacketType.ACK,\n        id: t,\n        data: T\n      }));\n    };\n  }\n  onack(t) {\n    const e = this.acks[t.id];\n    typeof e == \"function\" && (e.apply(this, t.data), delete this.acks[t.id]);\n  }\n  onconnect(t) {\n    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\");\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {\n      this.notifyOutgoingListeners(t), this.packet(t);\n    }), this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);\n  }\n  disconnect() {\n    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(t) {\n    return this.flags.compress = t, this;\n  }\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  timeout(t) {\n    return this.flags.timeout = t, this;\n  }\n  onAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n  }\n  prependAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n  }\n  offAny(t) {\n    if (!this._anyListeners)\n      return this;\n    if (t) {\n      const e = this._anyListeners;\n      for (let o = 0; o < e.length; o++)\n        if (t === e[o])\n          return e.splice(o, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n  }\n  prependAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n  }\n  offAnyOutgoing(t) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (t) {\n      const e = this._anyOutgoingListeners;\n      for (let o = 0; o < e.length; o++)\n        if (t === e[o])\n          return e.splice(o, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(t) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const e = this._anyOutgoingListeners.slice();\n      for (const o of e)\n        o.apply(this, t.data);\n    }\n  }\n}\nfunction Backoff(r) {\n  r = r || {}, this.ms = r.min || 100, this.max = r.max || 1e4, this.factor = r.factor || 2, this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0, this.attempts = 0;\n}\nBackoff.prototype.duration = function() {\n  var r = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var t = Math.random(), e = Math.floor(t * this.jitter * r);\n    r = (Math.floor(t * 10) & 1) == 0 ? r - e : r + e;\n  }\n  return Math.min(r, this.max) | 0;\n};\nBackoff.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff.prototype.setMin = function(r) {\n  this.ms = r;\n};\nBackoff.prototype.setMax = function(r) {\n  this.max = r;\n};\nBackoff.prototype.setJitter = function(r) {\n  this.jitter = r;\n};\nclass Manager extends Emitter {\n  constructor(t, e) {\n    var o;\n    super(), this.nsps = {}, this.subs = [], t && typeof t == \"object\" && (e = t, t = void 0), e = e || {}, e.path = e.path || \"/socket.io\", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((o = e.randomizationFactor) !== null && o !== void 0 ? o : 0.5), this.backoff = new Backoff({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n    const T = e.parser || parser;\n    this.encoder = new T.Encoder(), this.decoder = new T.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(t) {\n    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n  }\n  reconnectionAttempts(t) {\n    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n  }\n  reconnectionDelay(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);\n  }\n  randomizationFactor(t) {\n    var e;\n    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);\n  }\n  reconnectionDelayMax(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);\n  }\n  timeout(t) {\n    return arguments.length ? (this._timeout = t, this) : this._timeout;\n  }\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  open(t) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Socket$1(this.uri, this.opts);\n    const e = this.engine, o = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const T = on(e, \"open\", function() {\n      o.onopen(), t && t();\n    }), S = on(e, \"error\", (N) => {\n      o.cleanup(), o._readyState = \"closed\", this.emitReserved(\"error\", N), t ? t(N) : o.maybeReconnectOnOpen();\n    });\n    if (this._timeout !== !1) {\n      const N = this._timeout;\n      N === 0 && T();\n      const D = this.setTimeoutFn(() => {\n        T(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n      }, N);\n      this.opts.autoUnref && D.unref(), this.subs.push(function() {\n        clearTimeout(D);\n      });\n    }\n    return this.subs.push(T), this.subs.push(S), this;\n  }\n  connect(t) {\n    return this.open(t);\n  }\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const t = this.engine;\n    this.subs.push(on(t, \"ping\", this.onping.bind(this)), on(t, \"data\", this.ondata.bind(this)), on(t, \"error\", this.onerror.bind(this)), on(t, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(t) {\n    try {\n      this.decoder.add(t);\n    } catch {\n      this.onclose(\"parse error\");\n    }\n  }\n  ondecoded(t) {\n    this.emitReserved(\"packet\", t);\n  }\n  onerror(t) {\n    this.emitReserved(\"error\", t);\n  }\n  socket(t, e) {\n    let o = this.nsps[t];\n    return o || (o = new Socket(this, t, e), this.nsps[t] = o), o;\n  }\n  _destroy(t) {\n    const e = Object.keys(this.nsps);\n    for (const o of e)\n      if (this.nsps[o].active)\n        return;\n    this._close();\n  }\n  _packet(t) {\n    const e = this.encoder.encode(t);\n    for (let o = 0; o < e.length; o++)\n      this.engine.write(e[o], t.options);\n  }\n  cleanup() {\n    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(t, e) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const t = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const e = this.backoff.duration();\n      this._reconnecting = !0;\n      const o = this.setTimeoutFn(() => {\n        t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), !t.skipReconnect && t.open((T) => {\n          T ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", T)) : t.onreconnect();\n        }));\n      }, e);\n      this.opts.autoUnref && o.unref(), this.subs.push(function() {\n        clearTimeout(o);\n      });\n    }\n  }\n  onreconnect() {\n    const t = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n  }\n}\nconst cache = {};\nfunction lookup(r, t) {\n  typeof r == \"object\" && (t = r, r = void 0), t = t || {};\n  const e = url(r, t.path || \"/socket.io\"), o = e.source, T = e.id, S = e.path, N = cache[T] && S in cache[T].nsps, D = t.forceNew || t[\"force new connection\"] || t.multiplex === !1 || N;\n  let B;\n  return D ? B = new Manager(o, t) : (cache[T] || (cache[T] = new Manager(o, t)), B = cache[T]), e.query && !t.query && (t.query = e.queryKey), B.socket(e.path, t);\n}\nObject.assign(lookup, {\n  Manager,\n  Socket,\n  io: lookup,\n  connect: lookup\n});\nvar xr, Br, kr, un, ln, Mi, Di, Li, dl, pl, Ya, Ss, vl, Cs, hn, gl, cn, Rs;\nconst _l = class {\n  constructor(t = {}, e) {\n    Pt(this, \"hFactoryCls\", {});\n    Pt(this, \"elc\", new EventListenerCtn());\n    Pt(this, \"fetch\", (t) => fetch(t));\n    Pt(this, \"resolution\", 1);\n    Pt(this, \"cfg\");\n    Pt(this, \"data\", { sys: {}, mark: {}, kidoku: {} });\n    Pt(this, \"val\");\n    Pt(this, \"appPixi\");\n    rt(this, xr, 0);\n    rt(this, Br, 0);\n    rt(this, kr, 1);\n    rt(this, un, 0);\n    rt(this, ln, 0);\n    rt(this, Mi, 0);\n    rt(this, Di, 0);\n    Pt(this, \"isFullScr\", !1);\n    Pt(this, \"extPort\", 3776);\n    rt(this, Li, void 0);\n    rt(this, dl, {\n      auth: (t) => {\n        if (t.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"\\u63A5\\u7D9A\");\n      },\n      continue: () => this.toast(\"\\u518D\\u751F\"),\n      disconnect: () => this.toast(\"\\u5207\\u65AD\"),\n      restart: (t) => {\n        var e;\n        this.send2Dbg((e = t == null ? void 0 : t.ri) != null ? e : \"\", {}), this.end(), this.run();\n      },\n      pause: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnEntry: () => this.toast(\"\\u4E00\\u6642\\u505C\\u6B62\"),\n      stopOnDataBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnBreakpoint: () => this.toast(\"\\u6CE8\\u610F\"),\n      stopOnStep: () => this.toast(\"\\u4E00\\u6B69\\u9032\\u3080\"),\n      stopOnStepIn: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3\"),\n      stopOnStepOut: () => this.toast(\"\\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8\"),\n      stopOnBackstep: () => this.toast(\"\\u4E00\\u6B69\\u623B\\u308B\"),\n      _addPath: (t) => this.cfg.addPath(t.fn, t.o)\n    });\n    Pt(this, \"pathBaseCnvSnPath4Dbg\", \"\");\n    Pt(this, \"fire\");\n    rt(this, Ya, []);\n    Pt(this, \"callHook\", (t, e) => {\n    });\n    Pt(this, \"send2Dbg\", (t, e) => {\n      var o;\n      (o = H(this, Li)) == null || o.emit(\"data\", t, e);\n    });\n    Pt(this, \"copyBMFolder\", (t, e) => {\n    });\n    Pt(this, \"eraseBMFolder\", (t) => {\n    });\n    Pt(this, \"close\", () => !1);\n    Pt(this, \"_export\", () => !1);\n    Pt(this, \"_import\", () => !1);\n    Pt(this, \"navigate_to\", () => !1);\n    Pt(this, \"title\", (t) => {\n      const { text: e } = t;\n      if (!e)\n        throw \"[title] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      return nt(this, Ss, e), this.titleSub(H(this, Ss) + H(this, Cs)), !1;\n    });\n    rt(this, Ss, \"\");\n    rt(this, vl, (t) => {\n      if (!t.key)\n        return this.tglFlscr_sub(), !1;\n      const e = t.key.toLowerCase();\n      return this.elc.add(document, \"keydown\", (o) => {\n        (o.altKey ? o.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (o.ctrlKey ? o.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (o.shiftKey ? o.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + o.key.toLowerCase() === e && (o.stopPropagation(), this.tglFlscr_sub());\n      }, { passive: !0 }), !1;\n    });\n    Pt(this, \"update_check\", () => !1);\n    Pt(this, \"window\", () => !1);\n    rt(this, Cs, \"\");\n    rt(this, hn, (t, e) => ({ ret: e.toString(), ext_num: 0 }));\n    rt(this, gl, {\n      1: { ext: \"jpeg\", fnc: (t) => H(this, cn).call(this, t), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (t) => H(this, cn).call(this, t), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (t) => H(this, cn).call(this, t), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (t) => H(this, cn).call(this, t), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (t) => t.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (t) => t.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (t) => t.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (t) => H(this, Rs).call(this, t), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (t) => H(this, Rs).call(this, t), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (t) => H(this, Rs).call(this, t), mime: \"video/ogv\" }\n    });\n    rt(this, cn, (t) => new Promise((e, o) => {\n      const T = new Image();\n      T.onload = () => e(T), T.onerror = (S) => o(S), T.src = URL.createObjectURL(t);\n    }));\n    rt(this, Rs, (t) => new Promise((e, o) => {\n      const T = document.createElement(\"video\");\n      this.elc.add(T, \"error\", () => {\n        var S, N;\n        return o((N = (S = T == null ? void 0 : T.error) == null ? void 0 : S.message) != null ? N : \"\");\n      }), this.elc.add(T, \"canplay\", () => e(T)), T.src = URL.createObjectURL(t);\n    }));\n    Pt(this, \"enc\", (t) => t);\n    Pt(this, \"stk\", () => \"\");\n    Pt(this, \"hash\", (t) => \"\");\n    Pt(this, \"isApp\", !1);\n    Pt(this, \"$path_downloads\", \"\");\n    Pt(this, \"$path_userdata\", \"\");\n    Pt(this, \"canCapturePage\", (t) => !1);\n    this.hPlg = t, this.arg = e;\n  }\n  async loaded(t, e) {\n    const o = t.snsys_pre;\n    return delete t.snsys_pre, o == null ? void 0 : o.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (T) => nt(this, hn, T),\n      setEnc: (T) => this.enc = T,\n      getStK: (T) => this.stk = T,\n      getHash: (T) => this.hash = T\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  destroy() {\n    this.elc.clear();\n  }\n  async loadPath(t, e) {\n    this.cfg = e;\n  }\n  initVal(t, e, o) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(t, e, o, T) {\n    this.val = o, this.appPixi = e;\n    let S = \"\";\n    try {\n      this.val.setSys(this), S = \"sys\", S += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), S = \"kidoku\", this.val.saveKidoku();\n    } catch (N) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${S}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, N);\n    }\n    return t.close = (N) => this.close(N), t.export = (N) => this._export(N), t.import = (N) => this._import(N), t.navigate_to = (N) => this.navigate_to(N), t.title = (N) => this.title(N), t.toggle_full_screen = (N) => H(this, vl).call(this, N), t.update_check = (N) => this.update_check(N), t.window = (N) => this.window(N), o.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp), o.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => CmnLib.isDbg), o.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => CmnLib.isPackaged), this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr), o.setVal_Nochk(\"sys\", _l.VALNM_CFG_NS, this.cfg.oCfg.save_ns), o.flush(), CmnLib.isDbg && this.attach_debug(T), this.hFactoryCls = {}, Object.values(this.hPlg).map((N) => N.init({\n      addTag: (D, B) => {\n        if (t[D])\n          throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30BF\\u30B0[${D}]\\u3067\\u3059`;\n        t[D] = B;\n      },\n      addLayCls: (D, B) => {\n        if (this.hFactoryCls[D])\n          throw `\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30EC\\u30A4\\u30E4cls\\u3010${D}\\u3011\\u3067\\u3059`;\n        this.hFactoryCls[D] = B;\n      },\n      searchPath: (D, B = \"\") => this.cfg.searchPath(D, B),\n      getVal: o.getVal,\n      resume: () => T.resume(),\n      render: (D, B, $ = !1) => this.appPixi.renderer.render(D, { renderTexture: B, clear: $ }),\n      setDec: (D) => nt(this, hn, D),\n      setEnc: (D) => this.enc = D,\n      getStK: (D) => this.stk = D,\n      getHash: (D) => this.hash = D\n    }));\n  }\n  get cvsWidth() {\n    return H(this, xr);\n  }\n  get cvsHeight() {\n    return H(this, Br);\n  }\n  get cvsScale() {\n    return H(this, kr);\n  }\n  get ofsLeft4elm() {\n    return H(this, un);\n  }\n  get ofsTop4elm() {\n    return H(this, ln);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return H(this, Mi);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return H(this, Di);\n  }\n  cvsResize() {\n    var B, $;\n    let t = globalThis.innerWidth, e = globalThis.innerHeight;\n    const o = this.appPixi.view, T = o.parentElement !== document.body;\n    if (T) {\n      const U = globalThis.getComputedStyle(o);\n      t = parseFloat(U.width), e = parseFloat(U.height);\n    }\n    if (CmnLib.isMobile) {\n      const z = (($ = (B = screen.orientation) == null ? void 0 : B.angle) != null ? $ : 0) % 180 === 0;\n      (z && t > e || !z && t < e) && ([t, e] = [e, t]);\n    }\n    const S = o.getBoundingClientRect();\n    if (argChk_Boolean(CmnLib.hDip, \"expanding\", !0) || T || CmnLib.stageW > t || CmnLib.stageH > e)\n      if (CmnLib.stageW / CmnLib.stageH <= t / e ? (nt(this, Br, e), nt(this, xr, CmnLib.stageW / CmnLib.stageH * e)) : (nt(this, xr, t), nt(this, Br, CmnLib.stageH / CmnLib.stageW * t)), nt(this, kr, H(this, xr) / CmnLib.stageW), T)\n        nt(this, Mi, 0), nt(this, Di, 0);\n      else {\n        const U = 1 - H(this, kr);\n        CmnLib.isMobile ? (nt(this, Mi, (t - H(this, xr)) / 2 * U), nt(this, Di, (e - H(this, Br)) / 2 * U)) : (nt(this, Mi, S.left * U), nt(this, Di, S.top * U));\n      }\n    else\n      nt(this, xr, CmnLib.stageW), nt(this, Br, CmnLib.stageH), nt(this, kr, 1), nt(this, Mi, 0), nt(this, Di, 0);\n    const N = o.parentElement.style;\n    T || (N.position = \"relative\", N.width = `${H(this, xr)}px`, N.height = `${H(this, Br)}px`);\n    const D = o.style;\n    D.width = N.width, D.height = N.height, T ? (nt(this, un, S.left), nt(this, ln, S.top)) : (nt(this, un, 0), nt(this, ln, 0)), this.isFullScr && (nt(this, un, H(this, un) + (t - H(this, xr)) / 2), nt(this, ln, H(this, ln) + (e - H(this, Br)) / 2));\n  }\n  attach_debug(t) {\n    this.attach_debug = () => {\n    };\n    const e = document.createElement(\"style\");\n    e.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`, document.getElementsByTagName(\"head\")[0].appendChild(e), this.addHook((o, T) => {\n      var S, N;\n      return (N = (S = H(this, dl))[o]) == null ? void 0 : N.call(S, T);\n    }), nt(this, Li, lookup(`http://localhost:${this.extPort}`)), H(this, Li).on(\"data\", (o, T) => {\n      this.callHook(o, T);\n    }).on(\"disconnect\", () => t.setLoop(!0)), this.callHook = (o, T) => {\n      for (const S of H(this, Ya))\n        S(o, T);\n    };\n  }\n  end() {\n    var t;\n    (t = H(this, Li)) == null || t.disconnect(), nt(this, Li, void 0);\n  }\n  toast(t) {\n    var N, D, B;\n    const e = document.body;\n    e.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach(($) => e.removeChild($));\n    const o = document.createElement(\"img\"), T = H(_l, pl)[t];\n    o.src = `data:image/svg+xml;base64,${T.dat}`;\n    const S = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * H(this, kr);\n    o.width = o.height = S, o.style.cssText = `position: absolute;\nleft: ${(CmnLib.stageW - S) / 2 * H(this, kr) + S * ((N = T.dx) != null ? N : 0)}px;\ntop: ${(CmnLib.stageH - S) / 2 * H(this, kr) + S * ((D = T.dy) != null ? D : 0)}px;`, o.classList.add(\"sn_toast\", (B = T.ease) != null ? B : \"sn_BounceInOut\"), T.ease || o.addEventListener(\"animationend\", () => e.removeChild(o), { once: !0, passive: !0 }), e.insertBefore(o, this.appPixi.view);\n  }\n  setFire(t) {\n    this.fire = t;\n  }\n  addHook(t) {\n    H(this, Ya).push(t);\n  }\n  titleSub(t) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(t) {\n    nt(this, Cs, t), this.titleSub(H(this, Ss) + H(this, Cs));\n  }\n  decStr(t, e) {\n    return H(this, hn).call(this, t, e).ret;\n  }\n  async dec(t, e) {\n    const { ret: o, ext_num: T } = H(this, hn).call(this, t, e), S = H(this, gl)[T];\n    return S != null && S.fnc ? await S.fnc(new Blob([o], { type: S.mime })) : o;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  async savePic(t, e) {\n  }\n  async appendFile(t, e, o) {\n  }\n  async ensureFileSync(t) {\n  }\n};\nlet SysBase = _l;\nxr = new WeakMap(), Br = new WeakMap(), kr = new WeakMap(), un = new WeakMap(), ln = new WeakMap(), Mi = new WeakMap(), Di = new WeakMap(), Li = new WeakMap(), dl = new WeakMap(), pl = new WeakMap(), Ya = new WeakMap(), Ss = new WeakMap(), vl = new WeakMap(), Cs = new WeakMap(), hn = new WeakMap(), gl = new WeakMap(), cn = new WeakMap(), Rs = new WeakMap(), Pt(SysBase, \"VALNM_CFG_NS\", \"const.sn.cfg.ns\"), rt(SysBase, pl, {\n  \\u63A5\\u7D9A: { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  \\u5207\\u65AD: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  \\u518D\\u751F: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \\u4E00\\u6642\\u505C\\u6B62: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \\u6CE8\\u610F: { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \\u4E00\\u6B69\\u9032\\u3080: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  \\u4E00\\u6B69\\u623B\\u308B: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  \\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A4\\u30F3: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  \\u30B9\\u30C6\\u30C3\\u30D5\\u309A\\u30A2\\u30A6\\u30C8: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nvar SEARCH_PATH_ARG_EXT = /* @__PURE__ */ ((r) => (r.DEFAULT = \"\", r.SPRITE = \"png|jpg|jpeg|json|svg|webp|mp4|webm\", r.SCRIPT = \"sn|ssn\", r.FONT = \"woff2|woff|otf|ttf\", r.SOUND = \"mp3|m4a|ogg|aac|flac|wav\", r.HTML = \"htm|html\", r.CSS = \"css\", r.SN = \"sn\", r.TST_PNGPNG_ = \"png|png_\", r.TST_HH = \"hh\", r.TST_EEE = \"eee\", r.TST_GGG = \"ggg\", r.TST_PNGXML = \"png|xml\", r))(SEARCH_PATH_ARG_EXT || {}), qa, Za, ml;\nconst Sf = class {\n  constructor(t) {\n    Pt(this, \"oCfg\", {\n      save_ns: \"\",\n      window: {\n        width: 300,\n        height: 300\n      },\n      book: {\n        title: \"\",\n        creator: \"\",\n        cre_url: \"\",\n        publisher: \"\",\n        pub_url: \"\",\n        detail: \"\",\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      init: {\n        bg_color: \"#000000\",\n        tagch_msecwait: 10,\n        auto_msecpagewait: 3500,\n        escape: \"\"\n      },\n      debug: {\n        devtool: !1,\n        token: !1,\n        tag: !1,\n        putCh: !1,\n        debugLog: !1,\n        baseTx: !1,\n        masume: !1,\n        variable: !1\n      },\n      code: {},\n      debuger_token: \"\"\n    });\n    Pt(this, \"userFnTail\", \"\");\n    Pt(this, \"hPathFn2Exts\", {});\n    rt(this, qa, !1);\n    rt(this, Za, !1);\n    rt(this, ml, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n    this.sys = t;\n  }\n  static async generate(t) {\n    const e = new Sf(t), o = t.cur + \"prj.json\", T = await (await t.fetch(o)).text(), S = JSON.parse(t.decStr(o, T));\n    return await e.load(S), e;\n  }\n  async load(t) {\n    var e, o, T, S, N, D, B, $;\n    if (this.oCfg.save_ns = (e = t == null ? void 0 : t.save_ns) != null ? e : this.oCfg.save_ns, CmnLib.stageW = this.oCfg.window.width = Number((T = (o = t == null ? void 0 : t.window) == null ? void 0 : o.width) != null ? T : this.oCfg.window.width), CmnLib.stageH = this.oCfg.window.height = Number((N = (S = t == null ? void 0 : t.window) == null ? void 0 : S.height) != null ? N : this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ($ = (B = (D = t.log) == null ? void 0 : D.max_len) == null ? void 0 : B.max_len) != null ? $ : this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, CmnLib.debugLog = this.oCfg.debug.debugLog, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), nt(this, qa, this.matchPath(\"^breakline$\", \"png|jpg|jpeg|json|svg|webp|mp4|webm\").length > 0), nt(this, Za, this.matchPath(\"^breakpage$\", \"png|jpg|jpeg|json|svg|webp|mp4|webm\").length > 0), !!this.sys.crypto)\n      for (const U of Object.values(this.hPathFn2Exts))\n        for (const [z, V] of Object.values(U)) {\n          if (z.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const X = V.slice(V.lastIndexOf(\"/\") + 1), W = U[z.slice(0, -10)], q = await (await this.sys.fetch(W)).text(), Z = this.sys.hash(q);\n          if (X !== Z)\n            throw `\\u30D5\\u30A1\\u30A4\\u30EB\\u6539\\u7AC4\\u30A8\\u30E9\\u30FC\\u3067\\u3059 fn:${W}`;\n        }\n  }\n  get existsBreakline() {\n    return H(this, qa);\n  }\n  get existsBreakpage() {\n    return H(this, Za);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  searchPath(t, e = \"\") {\n    if (!t)\n      throw \"[searchPath] fn\\u304C\\u7A7A\\u3067\\u3059\";\n    if (t.slice(0, 7) === \"http://\")\n      return t;\n    if (t.slice(0, 11) === \"downloads:/\") {\n      const B = this.sys.path_downloads + t.slice(11);\n      return this.sys.ensureFileSync(B), B;\n    }\n    if (t.slice(0, 10) === \"userdata:/\") {\n      const B = this.sys.path_userdata + \"storage/\" + t.slice(10);\n      return this.sys.ensureFileSync(B), B;\n    }\n    const o = t.match(H(this, ml));\n    let T = o ? o[1] : t;\n    const S = o ? o[2] : \"\";\n    if (this.userFnTail) {\n      const B = T + \"@@\" + this.userFnTail;\n      if (B in this.hPathFn2Exts) {\n        if (e === \"\")\n          T = B;\n        else\n          for (const $ of Object.keys(this.hPathFn2Exts[B]))\n            if (`|${e}|`.indexOf(`|${$}|`) !== -1) {\n              T = B;\n              break;\n            }\n      }\n    }\n    const N = this.hPathFn2Exts[T];\n    if (!N)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${t}\\u3011\\u3067\\u3059`;\n    let D = \"\";\n    if (!S) {\n      const B = int(N[\":cnt\"]);\n      if (e === \"\") {\n        if (B > 1)\n          throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${t}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${e}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n        return t;\n      }\n      const $ = `|${e}|`;\n      if (B > 1) {\n        let U = 0;\n        for (const z of Object.keys(N))\n          if ($.indexOf(`|${z}|`) !== -1 && ++U > 1)\n            throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u3010${t}\\u3011\\u304C\\u8907\\u6570\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u3059\\u3002\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${e}\\u3011\\u3067\\u7D5E\\u308A\\u8FBC\\u3080\\u304B\\u3001\\u30D5\\u30A1\\u30A4\\u30EB\\u540D\\u3092\\u500B\\u5225\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\\u3002`;\n      }\n      for (let U of Object.keys(N))\n        if ($.indexOf(`|${U}|`) > -1)\n          return N[U];\n      throw `\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${e}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3059\\u308B\\u30D5\\u30A1\\u30A4\\u30EB\\u304C\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${t}\\u3011`;\n    }\n    if (e !== \"\" && `|${e}|`.indexOf(`|${S}|`) === -1)\n      throw `\\u6307\\u5B9A\\u30D5\\u30A1\\u30A4\\u30EB\\u306E\\u62E1\\u5F35\\u5B50\\u3010${S}\\u3011\\u306F\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${e}\\u3011\\u306B\\u30DE\\u30C3\\u30C1\\u3057\\u307E\\u305B\\u3093\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${t}\\u3011`;\n    if (D = N[S], !D)\n      throw `\\u30B5\\u30FC\\u30C1\\u30D1\\u30B9\\u306B\\u5B58\\u5728\\u3057\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3010${S}\\u3011\\u3067\\u3059\\u3002\\u63A2\\u7D22\\u30D5\\u30A1\\u30A4\\u30EB\\u540D=\\u3010${t}\\u3011\\u3001\\u30B5\\u30FC\\u30C1\\u5BFE\\u8C61\\u62E1\\u5F35\\u5B50\\u7FA4\\u3010${e}\\u3011`;\n    return D;\n  }\n  matchPath(t, e = \"\") {\n    const o = [], T = new RegExp(t), S = new RegExp(e);\n    for (const [N, D] of Object.entries(this.hPathFn2Exts)) {\n      if (N.search(T) === -1)\n        continue;\n      if (e === \"\") {\n        o.push(D);\n        continue;\n      }\n      const B = {};\n      let $ = !1;\n      for (const U of Object.keys(D))\n        U.search(S) !== -1 && (B[U] = N, $ = !0);\n      $ && o.push(B);\n    }\n    return o;\n  }\n  addPath(t, e) {\n    const o = {};\n    for (const [T, S] of Object.entries(e))\n      o[T] = (T.charAt(0) === \":\" ? \"\" : this.sys.cur) + S;\n    this.hPathFn2Exts[t] = o;\n  }\n};\nlet Config = Sf;\nqa = new WeakMap(), Za = new WeakMap(), ml = new WeakMap();\nvar fn, $r, Ka;\nconst Pi = class {\n  constructor() {\n    rt(this, $r, () => {\n    });\n  }\n  static setting(t) {\n    t.sesame && nt(Pi, fn, t.sesame);\n  }\n  static getSesame() {\n    return H(Pi, fn);\n  }\n  static destroy() {\n    nt(Pi, fn, \"\\u30FD\");\n  }\n  init(t) {\n    nt(this, $r, t);\n  }\n  static setEscape(t) {\n    nt(Pi, Ka, new RegExp(\n      `${t ? `(?<ce>\\\\${t}\\\\S)|` : \"\"}\\uFF5C(?<str>[^\\u300A\\\\n]+)\\u300A(?<ruby>[^\\u300B\\\\n]+)\\u300B|(?:(?<kan>[\\u2E80-\\u2FDF\\u3005\\u3007\\u303B\\u3400-\\u9FFF\\u8C48-\\uFAFF]+[\\u3041-\\u30FF]*|[^\\u3000\\uFF5C\\u300A\\u300B\\\\n])\\u300A(?<kan_ruby>[^\\u300B\\\\n]+)\\u300B)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^\\uFF5C\\u300A\\u300B]+?|.)`,\n      \"gs\"\n    ));\n  }\n  putTxt(t) {\n    for (const { groups: e } of t.matchAll(H(Pi, Ka))) {\n      const { ruby: o, kan_ruby: T, kan: S, ce: N, txt: D = \"\", str: B } = e;\n      if (o) {\n        this.putTxtRb(decodeURIComponent(B), o);\n        continue;\n      }\n      if (T) {\n        this.putTxtRb(S, T);\n        continue;\n      }\n      if (N) {\n        H(this, $r).call(this, N.slice(1), \"\");\n        continue;\n      }\n      for (const $ of Array.from(D))\n        H(this, $r).call(this, $, \"\");\n    }\n  }\n  putTxtRb(t, e) {\n    if (/^\\w+{\"/.test(e)) {\n      H(this, $r).call(this, t, e);\n      return;\n    }\n    const o = Array.from(t), T = o.length;\n    if (/^\\*.?$/.test(e)) {\n      const B = \"center\\uFF5C\" + (e === \"*\" ? H(Pi, fn) : e.charAt(1));\n      for (let $ = 0; $ < T; ++$)\n        H(this, $r).call(this, o[$], B);\n      return;\n    }\n    if (T === 1 || e.indexOf(\" \") === -1) {\n      H(this, $r).call(this, t, decodeURIComponent(e));\n      return;\n    }\n    const S = e.split(\" \"), N = S.length, D = N > T ? N : T;\n    for (let B = 0; B < D; ++B)\n      H(this, $r).call(this, B < T ? o[B] : \"\", B < N ? decodeURIComponent(S[B]) : \"\");\n  }\n};\nlet RubySpliter = Pi;\nfn = new WeakMap(), $r = new WeakMap(), Ka = new WeakMap(), rt(RubySpliter, fn, \"\\u30FD\"), rt(RubySpliter, Ka, void 0);\nconst REG_TAG = /(?<name>[^\\s;\\]]+)/;\nfunction tagToken2Name_Args(r) {\n  const t = REG_TAG.exec(r.slice(1, -1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${r}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  const o = e.name;\n  return [o, r.slice(1 + o.length, -1)];\n}\nfunction tagToken2Name(r) {\n  const t = REG_TAG.exec(r.slice(1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `\\u30BF\\u30B0\\u8A18\\u8FF0\\u3010${r}\\u3011\\u7570\\u5E38\\u3067\\u3059(\\u30BF\\u30B0\\u89E3\\u6790)`;\n  return e.name;\n}\nfunction splitAmpersand(r) {\n  const t = r.replaceAll(\"==\", \"\\uFF1D\").replaceAll(\"!=\", \"\\u2260\").split(\"=\"), e = t.length;\n  if (e < 2 || e > 3)\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C=\\u300D\\u6307\\u5B9A\\u304C\\u4E00\\u3064\\u304B\\u4E8C\\u3064\\u5FC5\\u8981\\u3067\\u3059\";\n  if (t[1].charAt(0) === \"&\")\n    throw \"\\u300C&\\u8A08\\u7B97\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  return {\n    name: t[0].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    text: t[1].replaceAll(\"\\uFF1D\", \"==\").replaceAll(\"\\u2260\", \"!=\"),\n    cast: e === 3 ? t[2].trim() : void 0\n  };\n}\nvar dn, Ja, Qa, to, Ve;\nclass Grammar {\n  constructor() {\n    Pt(this, \"REG_TOKEN\");\n    rt(this, dn, void 0);\n    rt(this, Ja, new RegExp(\"\"));\n    rt(this, Qa, \"\");\n    rt(this, to, \"\");\n    rt(this, Ve, void 0);\n    Pt(this, \"REG_TOKEN_NOTXT\");\n    Pt(this, \"replaceScr_C2M_And_let_ml\", (t, e = 0) => {\n      if (!!H(this, Ve)) {\n        for (let o = t.len - 1; o >= e; --o) {\n          const T = t.aToken[o];\n          if (this.REG_TOKEN_NOTXT.test(T.charAt(0)))\n            continue;\n          const S = t.aLNum[o], N = T.match(H(this, Ja));\n          if (!N)\n            continue;\n          let D = 1;\n          for (let B = N.length - 1; B >= 0; --B) {\n            let $ = N[B];\n            const U = H(this, Ve)[$.charAt(0)];\n            U && ($ = U + (U.slice(-1) === \"]\" ? \"\" : `'${$.slice(1, -1)}']`)), t.aToken.splice(o, D, $), t.aLNum.splice(o, D, S), D = 0;\n          }\n        }\n        t.len = t.aToken.length;\n      }\n    });\n    this.setEscape(\"\");\n  }\n  setEscape(t) {\n    if (H(this, Ve) && t in H(this, Ve))\n      throw \"[\\u30A8\\u30B9\\u30B1\\u30FC\\u30D7\\u6587\\u5B57] char\\u3010\" + t + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    this.REG_TOKEN = new RegExp(\n      (t ? `\\\\${t}\\\\S|` : \"\") + `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:[^\"'#;\\\\]]+|([\"'#]).*?\\\\1|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^&;\\\\n\\\\t]+|^\\\\*[^\\\\s\\\\[&;\\\\\\\\]+|[^\\\\n\\\\t\\\\[;${t ? `\\\\${t}` : \"\"}]+`,\n      \"gs\"\n    ), RubySpliter.setEscape(t), nt(this, dn, new RegExp(`[\\\\w\\\\s;[\\\\]*=&\\uFF5C\\u300A\\u300B${t ? `\\\\${t}` : \"\"}]`)), this.REG_TOKEN_NOTXT = new RegExp(`[\\\\n\\\\t;\\\\[*&${t ? `\\\\${t}` : \"\"}]`);\n  }\n  matchToken(t) {\n    var e;\n    return (e = t.match(this.REG_TOKEN)) != null ? e : [];\n  }\n  bracket2macro(t, e, o) {\n    var B;\n    const { name: T, text: S } = t;\n    if (!T)\n      throw \"[bracket2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!S)\n      throw \"[bracket2macro] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (S.length !== 2)\n      throw \"[bracket2macro] text\\u306F\\u62EC\\u5F27\\u306E\\u524D\\u5F8C\\u3092\\u793A\\u3059\\u4E8C\\u6587\\u5B57\\u3092\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\";\n    (B = H(this, Ve)) != null || nt(this, Ve, {});\n    const N = S.charAt(0), D = S.charAt(1);\n    if (N in H(this, Ve))\n      throw \"[bracket2macro] text\\u3010\" + N + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (D in H(this, Ve))\n      throw \"[bracket2macro] text\\u3010\" + D + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (H(this, dn).test(N))\n      throw \"[bracket2macro] text\\u3010\" + N + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (H(this, dn).test(D))\n      throw \"[bracket2macro] text\\u3010\" + D + \"\\u3011\\u306F\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    H(this, Ve)[D] = \"0\", H(this, Ve)[N] = `[${T} text=`, this.addC2M(`\\\\${N}[^\\\\${D}]*\\\\${D}`, `\\\\${N}\\\\${D}`), this.replaceScr_C2M_And_let_ml(e, o);\n  }\n  char2macro(t, e, o, T) {\n    var D;\n    const { char: S, name: N } = t;\n    if (!S)\n      throw \"[char2macro] char\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if ((D = H(this, Ve)) != null || nt(this, Ve, {}), S in H(this, Ve))\n      throw \"[char2macro] char\\u3010\" + S + \"\\u3011\\u304C\\u767B\\u9332\\u6E08\\u307F\\u306E\\u62EC\\u5F27\\u30DE\\u30AF\\u30ED\\u307E\\u305F\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u3067\\u3059\";\n    if (H(this, dn).test(S))\n      throw \"[char2macro] char\\u3010\" + S + \"\\u3011\\u306F\\u4E00\\u6587\\u5B57\\u30DE\\u30AF\\u30ED\\u306B\\u4F7F\\u7528\\u3067\\u304D\\u306A\\u3044\\u6587\\u5B57\\u3067\\u3059\";\n    if (!N)\n      throw \"[char2macro] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (!(N in e))\n      throw `[char2macro] \\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u53C8\\u306F\\u30DE\\u30AF\\u30ED[${N}]\\u3067\\u3059`;\n    H(this, Ve)[S] = `[${N}]`, this.addC2M(`\\\\${S}`, `\\\\${S}`), this.replaceScr_C2M_And_let_ml(o, T);\n  }\n  addC2M(t, e) {\n    nt(this, Qa, H(this, Qa) + `${t}|`), nt(this, to, H(this, to) + `${e}`), nt(this, Ja, new RegExp(\n      `(${H(this, Qa)}[^${H(this, to)}]+)`,\n      \"g\"\n    ));\n  }\n}\ndn = new WeakMap(), Ja = new WeakMap(), Qa = new WeakMap(), to = new WeakMap(), Ve = new WeakMap();\nvar yl, pn, Is;\nclass AnalyzeTagArg {\n  constructor() {\n    rt(this, yl, /;[^\\n]*|(?<key>[^\\s=\"'#|;]+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    rt(this, pn, {});\n    rt(this, Is, !1);\n  }\n  go(t) {\n    nt(this, pn, {}), nt(this, Is, !1);\n    for (const { groups: e } of t.matchAll(H(this, yl))) {\n      const { key: o, val: T, val2: S, def: N, def2: D, literal: B } = e;\n      o ? H(this, pn)[o] = {\n        val: T != null ? T : S,\n        def: N != null ? N : D\n      } : B && (B === \"*\" ? nt(this, Is, !0) : H(this, pn)[B] = { val: \"1\" });\n    }\n  }\n  get hPrm() {\n    return H(this, pn);\n  }\n  get isKomeParam() {\n    return H(this, Is);\n  }\n}\nyl = new WeakMap(), pn = new WeakMap(), Is = new WeakMap();\nvar parsimmon_umd_min = { exports: {} };\n(function(r, t) {\n  (function(e, o) {\n    r.exports = o();\n  })(typeof self < \"u\" ? self : commonjsGlobal$1, function() {\n    return function(e) {\n      var o = {};\n      function T(S) {\n        if (o[S])\n          return o[S].exports;\n        var N = o[S] = { i: S, l: !1, exports: {} };\n        return e[S].call(N.exports, N, N.exports, T), N.l = !0, N.exports;\n      }\n      return T.m = e, T.c = o, T.d = function(S, N, D) {\n        T.o(S, N) || Object.defineProperty(S, N, { configurable: !1, enumerable: !0, get: D });\n      }, T.r = function(S) {\n        Object.defineProperty(S, \"__esModule\", { value: !0 });\n      }, T.n = function(S) {\n        var N = S && S.__esModule ? function() {\n          return S.default;\n        } : function() {\n          return S;\n        };\n        return T.d(N, \"a\", N), N;\n      }, T.o = function(S, N) {\n        return Object.prototype.hasOwnProperty.call(S, N);\n      }, T.p = \"\", T(T.s = 0);\n    }([function(e, o, T) {\n      function S(lt) {\n        if (!(this instanceof S))\n          return new S(lt);\n        this._ = lt;\n      }\n      var N = S.prototype;\n      function D(lt, gt) {\n        for (var Tt = 0; Tt < lt; Tt++)\n          gt(Tt);\n      }\n      function B(lt, gt, Tt) {\n        return function(Nt, kt) {\n          D(kt.length, function(Ut) {\n            Nt(kt[Ut], Ut, kt);\n          });\n        }(function(Nt, kt, Ut) {\n          gt = lt(gt, Nt, kt, Ut);\n        }, Tt), gt;\n      }\n      function $(lt, gt) {\n        return B(function(Tt, Nt, kt, Ut) {\n          return Tt.concat([lt(Nt, kt, Ut)]);\n        }, [], gt);\n      }\n      function U(lt, gt) {\n        var Tt = { v: 0, buf: gt };\n        return D(lt, function() {\n          var Nt;\n          Tt = { v: Tt.v << 1 | (Nt = Tt.buf, Nt[0] >> 7), buf: function(kt) {\n            var Ut = B(function(Ht, Kt, be, ze) {\n              return Ht.concat(be === ze.length - 1 ? Buffer.from([Kt, 0]).readUInt16BE(0) : ze.readUInt16BE(be));\n            }, [], kt);\n            return Buffer.from($(function(Ht) {\n              return (Ht << 1 & 65535) >> 8;\n            }, Ut));\n          }(Tt.buf) };\n        }), Tt;\n      }\n      function z() {\n        return typeof Buffer < \"u\";\n      }\n      function V() {\n        if (!z())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function X(lt) {\n        V();\n        var gt = B(function(Ut, Ht) {\n          return Ut + Ht;\n        }, 0, lt);\n        if (gt % 8 != 0)\n          throw new Error(\"The bits [\" + lt.join(\", \") + \"] add up to \" + gt + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var Tt, Nt = gt / 8, kt = (Tt = function(Ut) {\n          return Ut > 48;\n        }, B(function(Ut, Ht) {\n          return Ut || (Tt(Ht) ? Ht : Ut);\n        }, null, lt));\n        if (kt)\n          throw new Error(kt + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new S(function(Ut, Ht) {\n          var Kt = Nt + Ht;\n          return Kt > Ut.length ? it(Ht, Nt.toString() + \" bytes\") : at(Kt, B(function(be, ze) {\n            var ke = U(ze, be.buf);\n            return { coll: be.coll.concat(ke.v), buf: ke.buf };\n          }, { coll: [], buf: Ut.slice(Ht, Kt) }, lt).coll);\n        });\n      }\n      function W(lt, gt) {\n        return new S(function(Tt, Nt) {\n          return V(), Nt + gt > Tt.length ? it(Nt, gt + \" bytes for \" + lt) : at(Nt + gt, Tt.slice(Nt, Nt + gt));\n        });\n      }\n      function Y(lt, gt) {\n        if (typeof (Tt = gt) != \"number\" || Math.floor(Tt) !== Tt || gt < 0 || gt > 6)\n          throw new Error(lt + \" requires integer length in range [0, 6].\");\n        var Tt;\n      }\n      function q(lt) {\n        return Y(\"uintBE\", lt), W(\"uintBE(\" + lt + \")\", lt).map(function(gt) {\n          return gt.readUIntBE(0, lt);\n        });\n      }\n      function Z(lt) {\n        return Y(\"uintLE\", lt), W(\"uintLE(\" + lt + \")\", lt).map(function(gt) {\n          return gt.readUIntLE(0, lt);\n        });\n      }\n      function K(lt) {\n        return Y(\"intBE\", lt), W(\"intBE(\" + lt + \")\", lt).map(function(gt) {\n          return gt.readIntBE(0, lt);\n        });\n      }\n      function J(lt) {\n        return Y(\"intLE\", lt), W(\"intLE(\" + lt + \")\", lt).map(function(gt) {\n          return gt.readIntLE(0, lt);\n        });\n      }\n      function tt(lt) {\n        return lt instanceof S;\n      }\n      function et(lt) {\n        return {}.toString.call(lt) === \"[object Array]\";\n      }\n      function Q(lt) {\n        return z() && Buffer.isBuffer(lt);\n      }\n      function at(lt, gt) {\n        return { status: !0, index: lt, value: gt, furthest: -1, expected: [] };\n      }\n      function it(lt, gt) {\n        return et(gt) || (gt = [gt]), { status: !1, index: -1, value: null, furthest: lt, expected: gt };\n      }\n      function st(lt, gt) {\n        if (!gt || lt.furthest > gt.furthest)\n          return lt;\n        var Tt = lt.furthest === gt.furthest ? function(Nt, kt) {\n          if (function() {\n            if (S._supportsSet !== void 0)\n              return S._supportsSet;\n            var ei = typeof Set < \"u\";\n            return S._supportsSet = ei, ei;\n          }() && Array.from) {\n            for (var Ut = new Set(Nt), Ht = 0; Ht < kt.length; Ht++)\n              Ut.add(kt[Ht]);\n            var Kt = Array.from(Ut);\n            return Kt.sort(), Kt;\n          }\n          for (var be = {}, ze = 0; ze < Nt.length; ze++)\n            be[Nt[ze]] = !0;\n          for (var ke = 0; ke < kt.length; ke++)\n            be[kt[ke]] = !0;\n          var ti = [];\n          for (var nr in be)\n            ({}).hasOwnProperty.call(be, nr) && ti.push(nr);\n          return ti.sort(), ti;\n        }(lt.expected, gt.expected) : gt.expected;\n        return { status: lt.status, index: lt.index, value: lt.value, furthest: gt.furthest, expected: Tt };\n      }\n      var ut = {};\n      function ft(lt, gt) {\n        if (Q(lt))\n          return { offset: gt, line: -1, column: -1 };\n        lt in ut || (ut[lt] = {});\n        for (var Tt = ut[lt], Nt = 0, kt = 0, Ut = 0, Ht = gt; Ht >= 0; ) {\n          if (Ht in Tt) {\n            Nt = Tt[Ht].line, Ut === 0 && (Ut = Tt[Ht].lineStart);\n            break;\n          }\n          (lt.charAt(Ht) === `\n` || lt.charAt(Ht) === \"\\r\" && lt.charAt(Ht + 1) !== `\n`) && (kt++, Ut === 0 && (Ut = Ht + 1)), Ht--;\n        }\n        var Kt = Nt + kt, be = gt - Ut;\n        return Tt[gt] = { line: Kt, lineStart: Ut }, { offset: gt, line: Kt + 1, column: be + 1 };\n      }\n      function ct(lt) {\n        if (!tt(lt))\n          throw new Error(\"not a parser: \" + lt);\n      }\n      function pt(lt, gt) {\n        return typeof lt == \"string\" ? lt.charAt(gt) : lt[gt];\n      }\n      function mt(lt) {\n        if (typeof lt != \"number\")\n          throw new Error(\"not a number: \" + lt);\n      }\n      function vt(lt) {\n        if (typeof lt != \"function\")\n          throw new Error(\"not a function: \" + lt);\n      }\n      function _t(lt) {\n        if (typeof lt != \"string\")\n          throw new Error(\"not a string: \" + lt);\n      }\n      var xt = 2, Rt = 3, yt = 8, ht = 5 * yt, bt = 4 * yt, St = \"  \";\n      function Ot(lt, gt) {\n        return new Array(gt + 1).join(lt);\n      }\n      function wt(lt, gt, Tt) {\n        var Nt = gt - lt.length;\n        return Nt <= 0 ? lt : Ot(Tt, Nt) + lt;\n      }\n      function Ft(lt, gt, Tt, Nt) {\n        return { from: lt - gt > 0 ? lt - gt : 0, to: lt + Tt > Nt ? Nt : lt + Tt };\n      }\n      function dt(lt, gt) {\n        var Tt, Nt, kt, Ut, Ht, Kt = gt.index, be = Kt.offset, ze = 1;\n        if (be === lt.length)\n          return \"Got the end of the input\";\n        if (Q(lt)) {\n          var ke = be - be % yt, ti = be - ke, nr = Ft(ke, ht, bt + yt, lt.length), ei = $(function(De) {\n            return $(function(vs) {\n              return wt(vs.toString(16), 2, \"0\");\n            }, De);\n          }, function(De, vs) {\n            var gs = De.length, en = [], _s = 0;\n            if (gs <= vs)\n              return [De.slice()];\n            for (var ms = 0; ms < gs; ms++)\n              en[_s] || en.push([]), en[_s].push(De[ms]), (ms + 1) % vs == 0 && _s++;\n            return en;\n          }(lt.slice(nr.from, nr.to).toJSON().data, yt));\n          Ut = function(De) {\n            return De.from === 0 && De.to === 1 ? { from: De.from, to: De.to } : { from: De.from / yt, to: Math.floor(De.to / yt) };\n          }(nr), Nt = ke / yt, Tt = 3 * ti, ti >= 4 && (Tt += 1), ze = 2, kt = $(function(De) {\n            return De.length <= 4 ? De.join(\" \") : De.slice(0, 4).join(\" \") + \"  \" + De.slice(4).join(\" \");\n          }, ei), (Ht = (8 * (Ut.to > 0 ? Ut.to - 1 : Ut.to)).toString(16).length) < 2 && (Ht = 2);\n        } else {\n          var ps = lt.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          Tt = Kt.column - 1, Nt = Kt.line - 1, Ut = Ft(Nt, xt, Rt, ps.length), kt = ps.slice(Ut.from, Ut.to), Ht = Ut.to.toString().length;\n        }\n        var Sp = Nt - Ut.from;\n        return Q(lt) && (Ht = (8 * (Ut.to > 0 ? Ut.to - 1 : Ut.to)).toString(16).length) < 2 && (Ht = 2), B(function(De, vs, gs) {\n          var en, _s = gs === Sp, ms = _s ? \"> \" : St;\n          return en = Q(lt) ? wt((8 * (Ut.from + gs)).toString(16), Ht, \"0\") : wt((Ut.from + gs + 1).toString(), Ht, \" \"), [].concat(De, [ms + en + \" | \" + vs], _s ? [St + Ot(\" \", Ht) + \" | \" + wt(\"\", Tt, \" \") + Ot(\"^\", ze)] : []);\n        }, [], kt).join(`\n`);\n      }\n      function Gt(lt, gt) {\n        return [`\n`, \"-- PARSING FAILED \" + Ot(\"-\", 50), `\n\n`, dt(lt, gt), `\n\n`, (Tt = gt.expected, Tt.length === 1 ? `Expected:\n\n` + Tt[0] : `Expected one of the following: \n\n` + Tt.join(\", \")), `\n`].join(\"\");\n        var Tt;\n      }\n      function Mt(lt) {\n        return lt.flags !== void 0 ? lt.flags : [lt.global ? \"g\" : \"\", lt.ignoreCase ? \"i\" : \"\", lt.multiline ? \"m\" : \"\", lt.unicode ? \"u\" : \"\", lt.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function Bt() {\n        for (var lt = [].slice.call(arguments), gt = lt.length, Tt = 0; Tt < gt; Tt += 1)\n          ct(lt[Tt]);\n        return S(function(Nt, kt) {\n          for (var Ut, Ht = new Array(gt), Kt = 0; Kt < gt; Kt += 1) {\n            if (!(Ut = st(lt[Kt]._(Nt, kt), Ut)).status)\n              return Ut;\n            Ht[Kt] = Ut.value, kt = Ut.index;\n          }\n          return st(at(kt, Ht), Ut);\n        });\n      }\n      function Dt() {\n        var lt = [].slice.call(arguments);\n        if (lt.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var gt = lt.pop();\n        return vt(gt), Bt.apply(null, lt).map(function(Tt) {\n          return gt.apply(null, Tt);\n        });\n      }\n      function Et() {\n        var lt = [].slice.call(arguments), gt = lt.length;\n        if (gt === 0)\n          return At(\"zero alternates\");\n        for (var Tt = 0; Tt < gt; Tt += 1)\n          ct(lt[Tt]);\n        return S(function(Nt, kt) {\n          for (var Ut, Ht = 0; Ht < lt.length; Ht += 1)\n            if ((Ut = st(lt[Ht]._(Nt, kt), Ut)).status)\n              return Ut;\n          return Ut;\n        });\n      }\n      function zt(lt, gt) {\n        return It(lt, gt).or($t([]));\n      }\n      function It(lt, gt) {\n        return ct(lt), ct(gt), Dt(lt, gt.then(lt).many(), function(Tt, Nt) {\n          return [Tt].concat(Nt);\n        });\n      }\n      function Ct(lt) {\n        _t(lt);\n        var gt = \"'\" + lt + \"'\";\n        return S(function(Tt, Nt) {\n          var kt = Nt + lt.length, Ut = Tt.slice(Nt, kt);\n          return Ut === lt ? at(kt, Ut) : it(Nt, gt);\n        });\n      }\n      function Lt(lt, gt) {\n        (function(kt) {\n          if (!(kt instanceof RegExp))\n            throw new Error(\"not a regexp: \" + kt);\n          for (var Ut = Mt(kt), Ht = 0; Ht < Ut.length; Ht++) {\n            var Kt = Ut.charAt(Ht);\n            if (Kt !== \"i\" && Kt !== \"m\" && Kt !== \"u\" && Kt !== \"s\")\n              throw new Error('unsupported regexp flag \"' + Kt + '\": ' + kt);\n          }\n        })(lt), arguments.length >= 2 ? mt(gt) : gt = 0;\n        var Tt = function(kt) {\n          return RegExp(\"^(?:\" + kt.source + \")\", Mt(kt));\n        }(lt), Nt = \"\" + lt;\n        return S(function(kt, Ut) {\n          var Ht = Tt.exec(kt.slice(Ut));\n          if (Ht) {\n            if (0 <= gt && gt <= Ht.length) {\n              var Kt = Ht[0], be = Ht[gt];\n              return at(Ut + Kt.length, be);\n            }\n            return it(Ut, \"valid match group (0 to \" + Ht.length + \") in \" + Nt);\n          }\n          return it(Ut, Nt);\n        });\n      }\n      function $t(lt) {\n        return S(function(gt, Tt) {\n          return at(Tt, lt);\n        });\n      }\n      function At(lt) {\n        return S(function(gt, Tt) {\n          return it(Tt, lt);\n        });\n      }\n      function ee(lt) {\n        if (tt(lt))\n          return S(function(gt, Tt) {\n            var Nt = lt._(gt, Tt);\n            return Nt.index = Tt, Nt.value = \"\", Nt;\n          });\n        if (typeof lt == \"string\")\n          return ee(Ct(lt));\n        if (lt instanceof RegExp)\n          return ee(Lt(lt));\n        throw new Error(\"not a string, regexp, or parser: \" + lt);\n      }\n      function te(lt) {\n        return ct(lt), S(function(gt, Tt) {\n          var Nt = lt._(gt, Tt), kt = gt.slice(Tt, Nt.index);\n          return Nt.status ? it(Tt, 'not \"' + kt + '\"') : at(Tt, null);\n        });\n      }\n      function he(lt) {\n        return vt(lt), S(function(gt, Tt) {\n          var Nt = pt(gt, Tt);\n          return Tt < gt.length && lt(Nt) ? at(Tt + 1, Nt) : it(Tt, \"a character/byte matching \" + lt);\n        });\n      }\n      function we(lt, gt) {\n        arguments.length < 2 && (gt = lt, lt = void 0);\n        var Tt = S(function(Nt, kt) {\n          return Tt._ = gt()._, Tt._(Nt, kt);\n        });\n        return lt ? Tt.desc(lt) : Tt;\n      }\n      function Be() {\n        return At(\"fantasy-land/empty\");\n      }\n      N.parse = function(lt) {\n        if (typeof lt != \"string\" && !Q(lt))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var gt, Tt = this.skip(de)._(lt, 0);\n        return gt = Tt.status ? { status: !0, value: Tt.value } : { status: !1, index: ft(lt, Tt.furthest), expected: Tt.expected }, delete ut[lt], gt;\n      }, N.tryParse = function(lt) {\n        var gt = this.parse(lt);\n        if (gt.status)\n          return gt.value;\n        var Tt = Gt(lt, gt), Nt = new Error(Tt);\n        throw Nt.type = \"ParsimmonError\", Nt.result = gt, Nt;\n      }, N.assert = function(lt, gt) {\n        return this.chain(function(Tt) {\n          return lt(Tt) ? $t(Tt) : At(gt);\n        });\n      }, N.or = function(lt) {\n        return Et(this, lt);\n      }, N.trim = function(lt) {\n        return this.wrap(lt, lt);\n      }, N.wrap = function(lt, gt) {\n        return Dt(lt, this, gt, function(Tt, Nt) {\n          return Nt;\n        });\n      }, N.thru = function(lt) {\n        return lt(this);\n      }, N.then = function(lt) {\n        return ct(lt), Bt(this, lt).map(function(gt) {\n          return gt[1];\n        });\n      }, N.many = function() {\n        var lt = this;\n        return S(function(gt, Tt) {\n          for (var Nt = [], kt = void 0; ; ) {\n            if (!(kt = st(lt._(gt, Tt), kt)).status)\n              return st(at(Tt, Nt), kt);\n            if (Tt === kt.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            Tt = kt.index, Nt.push(kt.value);\n          }\n        });\n      }, N.tieWith = function(lt) {\n        return _t(lt), this.map(function(gt) {\n          if (function(kt) {\n            if (!et(kt))\n              throw new Error(\"not an array: \" + kt);\n          }(gt), gt.length) {\n            _t(gt[0]);\n            for (var Tt = gt[0], Nt = 1; Nt < gt.length; Nt++)\n              _t(gt[Nt]), Tt += lt + gt[Nt];\n            return Tt;\n          }\n          return \"\";\n        });\n      }, N.tie = function() {\n        return this.tieWith(\"\");\n      }, N.times = function(lt, gt) {\n        var Tt = this;\n        return arguments.length < 2 && (gt = lt), mt(lt), mt(gt), S(function(Nt, kt) {\n          for (var Ut = [], Ht = void 0, Kt = void 0, be = 0; be < lt; be += 1) {\n            if (Kt = st(Ht = Tt._(Nt, kt), Kt), !Ht.status)\n              return Kt;\n            kt = Ht.index, Ut.push(Ht.value);\n          }\n          for (; be < gt && (Kt = st(Ht = Tt._(Nt, kt), Kt), Ht.status); be += 1)\n            kt = Ht.index, Ut.push(Ht.value);\n          return st(at(kt, Ut), Kt);\n        });\n      }, N.result = function(lt) {\n        return this.map(function() {\n          return lt;\n        });\n      }, N.atMost = function(lt) {\n        return this.times(0, lt);\n      }, N.atLeast = function(lt) {\n        return Dt(this.times(lt), this.many(), function(gt, Tt) {\n          return gt.concat(Tt);\n        });\n      }, N.map = function(lt) {\n        vt(lt);\n        var gt = this;\n        return S(function(Tt, Nt) {\n          var kt = gt._(Tt, Nt);\n          return kt.status ? st(at(kt.index, lt(kt.value)), kt) : kt;\n        });\n      }, N.contramap = function(lt) {\n        vt(lt);\n        var gt = this;\n        return S(function(Tt, Nt) {\n          var kt = gt.parse(lt(Tt.slice(Nt)));\n          return kt.status ? at(Nt + Tt.length, kt.value) : kt;\n        });\n      }, N.promap = function(lt, gt) {\n        return vt(lt), vt(gt), this.contramap(lt).map(gt);\n      }, N.skip = function(lt) {\n        return Bt(this, lt).map(function(gt) {\n          return gt[0];\n        });\n      }, N.mark = function() {\n        return Dt(ne, this, ne, function(lt, gt, Tt) {\n          return { start: lt, value: gt, end: Tt };\n        });\n      }, N.node = function(lt) {\n        return Dt(ne, this, ne, function(gt, Tt, Nt) {\n          return { name: lt, value: Tt, start: gt, end: Nt };\n        });\n      }, N.sepBy = function(lt) {\n        return zt(this, lt);\n      }, N.sepBy1 = function(lt) {\n        return It(this, lt);\n      }, N.lookahead = function(lt) {\n        return this.skip(ee(lt));\n      }, N.notFollowedBy = function(lt) {\n        return this.skip(te(lt));\n      }, N.desc = function(lt) {\n        et(lt) || (lt = [lt]);\n        var gt = this;\n        return S(function(Tt, Nt) {\n          var kt = gt._(Tt, Nt);\n          return kt.status || (kt.expected = lt), kt;\n        });\n      }, N.fallback = function(lt) {\n        return this.or($t(lt));\n      }, N.ap = function(lt) {\n        return Dt(lt, this, function(gt, Tt) {\n          return gt(Tt);\n        });\n      }, N.chain = function(lt) {\n        var gt = this;\n        return S(function(Tt, Nt) {\n          var kt = gt._(Tt, Nt);\n          return kt.status ? st(lt(kt.value)._(Tt, kt.index), kt) : kt;\n        });\n      }, N.concat = N.or, N.empty = Be, N.of = $t, N[\"fantasy-land/ap\"] = N.ap, N[\"fantasy-land/chain\"] = N.chain, N[\"fantasy-land/concat\"] = N.concat, N[\"fantasy-land/empty\"] = N.empty, N[\"fantasy-land/of\"] = N.of, N[\"fantasy-land/map\"] = N.map;\n      var ne = S(function(lt, gt) {\n        return at(gt, ft(lt, gt));\n      }), Me = S(function(lt, gt) {\n        return gt >= lt.length ? it(gt, \"any character/byte\") : at(gt + 1, pt(lt, gt));\n      }), ye = S(function(lt, gt) {\n        return at(lt.length, lt.slice(gt));\n      }), de = S(function(lt, gt) {\n        return gt < lt.length ? it(gt, \"EOF\") : at(gt, null);\n      }), ce = Lt(/[0-9]/).desc(\"a digit\"), ie = Lt(/[0-9]*/).desc(\"optional digits\"), Le = Lt(/[a-z]/i).desc(\"a letter\"), Na = Lt(/[a-z]*/i).desc(\"optional letters\"), Dc = Lt(/\\s*/).desc(\"optional whitespace\"), Wu = Lt(/\\s+/).desc(\"whitespace\"), Ma = Ct(\"\\r\"), Yu = Ct(`\n`), qu = Ct(`\\r\n`), Zu = Et(qu, Yu, Ma).desc(\"newline\"), Da = Et(Zu, de);\n      S.all = ye, S.alt = Et, S.any = Me, S.cr = Ma, S.createLanguage = function(lt) {\n        var gt = {};\n        for (var Tt in lt)\n          ({}).hasOwnProperty.call(lt, Tt) && function(Nt) {\n            gt[Nt] = we(function() {\n              return lt[Nt](gt);\n            });\n          }(Tt);\n        return gt;\n      }, S.crlf = qu, S.custom = function(lt) {\n        return S(lt(at, it));\n      }, S.digit = ce, S.digits = ie, S.empty = Be, S.end = Da, S.eof = de, S.fail = At, S.formatError = Gt, S.index = ne, S.isParser = tt, S.lazy = we, S.letter = Le, S.letters = Na, S.lf = Yu, S.lookahead = ee, S.makeFailure = it, S.makeSuccess = at, S.newline = Zu, S.noneOf = function(lt) {\n        return he(function(gt) {\n          return lt.indexOf(gt) < 0;\n        }).desc(\"none of '\" + lt + \"'\");\n      }, S.notFollowedBy = te, S.of = $t, S.oneOf = function(lt) {\n        for (var gt = lt.split(\"\"), Tt = 0; Tt < gt.length; Tt++)\n          gt[Tt] = \"'\" + gt[Tt] + \"'\";\n        return he(function(Nt) {\n          return lt.indexOf(Nt) >= 0;\n        }).desc(gt);\n      }, S.optWhitespace = Dc, S.Parser = S, S.range = function(lt, gt) {\n        return he(function(Tt) {\n          return lt <= Tt && Tt <= gt;\n        }).desc(lt + \"-\" + gt);\n      }, S.regex = Lt, S.regexp = Lt, S.sepBy = zt, S.sepBy1 = It, S.seq = Bt, S.seqMap = Dt, S.seqObj = function() {\n        for (var lt, gt = {}, Tt = 0, Nt = (lt = arguments, Array.prototype.slice.call(lt)), kt = Nt.length, Ut = 0; Ut < kt; Ut += 1) {\n          var Ht = Nt[Ut];\n          if (!tt(Ht)) {\n            if (et(Ht) && Ht.length === 2 && typeof Ht[0] == \"string\" && tt(Ht[1])) {\n              var Kt = Ht[0];\n              if (Object.prototype.hasOwnProperty.call(gt, Kt))\n                throw new Error(\"seqObj: duplicate key \" + Kt);\n              gt[Kt] = !0, Tt++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (Tt === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return S(function(be, ze) {\n          for (var ke, ti = {}, nr = 0; nr < kt; nr += 1) {\n            var ei, ps;\n            if (et(Nt[nr]) ? (ei = Nt[nr][0], ps = Nt[nr][1]) : (ei = null, ps = Nt[nr]), !(ke = st(ps._(be, ze), ke)).status)\n              return ke;\n            ei && (ti[ei] = ke.value), ze = ke.index;\n          }\n          return st(at(ze, ti), ke);\n        });\n      }, S.string = Ct, S.succeed = $t, S.takeWhile = function(lt) {\n        return vt(lt), S(function(gt, Tt) {\n          for (var Nt = Tt; Nt < gt.length && lt(pt(gt, Nt)); )\n            Nt++;\n          return at(Nt, gt.slice(Tt, Nt));\n        });\n      }, S.test = he, S.whitespace = Wu, S[\"fantasy-land/empty\"] = Be, S[\"fantasy-land/of\"] = $t, S.Binary = { bitSeq: X, bitSeqObj: function(lt) {\n        V();\n        var gt = {}, Tt = 0, Nt = $(function(Ut) {\n          if (et(Ut)) {\n            var Ht = Ut;\n            if (Ht.length !== 2)\n              throw new Error(\"[\" + Ht.join(\", \") + \"] should be length 2, got length \" + Ht.length);\n            if (_t(Ht[0]), mt(Ht[1]), Object.prototype.hasOwnProperty.call(gt, Ht[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + Ht[0]);\n            return gt[Ht[0]] = !0, Tt++, Ht;\n          }\n          return mt(Ut), [null, Ut];\n        }, lt);\n        if (Tt < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + lt.join(\", \") + \"]\");\n        var kt = $(function(Ut) {\n          return Ut[0];\n        }, Nt);\n        return X($(function(Ut) {\n          return Ut[1];\n        }, Nt)).map(function(Ut) {\n          return B(function(Ht, Kt) {\n            return Kt[0] !== null && (Ht[Kt[0]] = Kt[1]), Ht;\n          }, {}, $(function(Ht, Kt) {\n            return [Ht, Ut[Kt]];\n          }, kt));\n        });\n      }, byte: function(lt) {\n        if (V(), mt(lt), lt > 255)\n          throw new Error(\"Value specified to byte constructor (\" + lt + \"=0x\" + lt.toString(16) + \") is larger in value than a single byte.\");\n        var gt = (lt > 15 ? \"0x\" : \"0x0\") + lt.toString(16);\n        return S(function(Tt, Nt) {\n          var kt = pt(Tt, Nt);\n          return kt === lt ? at(Nt + 1, kt) : it(Nt, gt);\n        });\n      }, buffer: function(lt) {\n        return W(\"buffer\", lt).map(function(gt) {\n          return Buffer.from(gt);\n        });\n      }, encodedString: function(lt, gt) {\n        return W(\"string\", gt).map(function(Tt) {\n          return Tt.toString(lt);\n        });\n      }, uintBE: q, uint8BE: q(1), uint16BE: q(2), uint32BE: q(4), uintLE: Z, uint8LE: Z(1), uint16LE: Z(2), uint32LE: Z(4), intBE: K, int8BE: K(1), int16BE: K(2), int32BE: K(4), intLE: J, int8LE: J(1), int16LE: J(2), int32LE: J(4), floatBE: W(\"floatBE\", 4).map(function(lt) {\n        return lt.readFloatBE(0);\n      }), floatLE: W(\"floatLE\", 4).map(function(lt) {\n        return lt.readFloatLE(0);\n      }), doubleBE: W(\"doubleBE\", 8).map(function(lt) {\n        return lt.readDoubleBE(0);\n      }), doubleLE: W(\"doubleLE\", 8).map(function(lt) {\n        return lt.readDoubleLE(0);\n      }) }, e.exports = S;\n    }]);\n  });\n})(parsimmon_umd_min);\nvar vn, Yt, qt, Fi, Bi, ys, bl, eo, Fc, El, xl, Of;\nconst Cf = class {\n  constructor(t, e = \"\\\\\") {\n    rt(this, Yt);\n    rt(this, Bi);\n    rt(this, eo);\n    rt(this, vn, null);\n    rt(this, Fi, {\n      \"!num!\": (t) => t.shift(),\n      \"!str!\": (t) => ot(this, eo, Fc).call(this, t.shift()),\n      \"!bool!\": (t) => t.shift(),\n      \"!\": (t) => {\n        const e = t.shift();\n        return e[0] === \"!bool!\" ? !Boolean(e[1]) : String(ot(this, Yt, qt).call(this, e)) !== \"true\";\n      },\n      \"~\": (t) => ~Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"**\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) ** Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"*\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) * Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"/\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) / Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"\\xA5\": (t) => Math.floor(H(this, Fi)[\"/\"](t)),\n      \"%\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) % Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"+\": (t) => {\n        const e = ot(this, Yt, qt).call(this, t.shift()), o = ot(this, Yt, qt).call(this, t.shift());\n        return Object.prototype.toString.call(e) === \"[object String]\" || Object.prototype.toString.call(o) === \"[object String]\" ? String(e) + String(o) : Number(e) + Number(o);\n      },\n      \"-\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) - Number(ot(this, Yt, qt).call(this, t.shift())),\n      int: (t) => int(ot(this, Bi, ys).call(this, t.shift())),\n      parseInt: (t) => int(H(this, Fi).Number(t)),\n      Number: (t) => {\n        const e = ot(this, Yt, qt).call(this, t.shift());\n        return Object.prototype.toString.call(e) !== \"[object String]\" ? Number(e) : ot(this, Bi, ys).call(this, H(this, vn).parse(String(e)).value);\n      },\n      ceil: (t) => Math.ceil(ot(this, Bi, ys).call(this, t.shift())),\n      floor: (t) => Math.floor(ot(this, Bi, ys).call(this, t.shift())),\n      round: (t) => Math.round(ot(this, Bi, ys).call(this, t.shift())),\n      isNaN: (t) => isNaN(Number(ot(this, Yt, qt).call(this, t.shift()))),\n      \"<<\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) << Number(ot(this, Yt, qt).call(this, t.shift())),\n      \">>\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) >> Number(ot(this, Yt, qt).call(this, t.shift())),\n      \">>>\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) >>> Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"<\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) < Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"<=\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) <= Number(ot(this, Yt, qt).call(this, t.shift())),\n      \">\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) > Number(ot(this, Yt, qt).call(this, t.shift())),\n      \">=\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) >= Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"==\": (t) => {\n        const e = ot(this, Yt, qt).call(this, t.shift()), o = ot(this, Yt, qt).call(this, t.shift());\n        return e == null && o == null && (!e || !o) ? e == o : String(e) === String(o);\n      },\n      \"!=\": (t) => !H(this, Fi)[\"==\"](t),\n      \"===\": (t) => {\n        const e = ot(this, Yt, qt).call(this, t.shift()), o = ot(this, Yt, qt).call(this, t.shift());\n        return Object.prototype.toString.call(e) != Object.prototype.toString.call(o) ? !1 : String(e) === String(o);\n      },\n      \"!==\": (t) => !H(this, Fi)[\"===\"](t),\n      \"&\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) & Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"^\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) ^ Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"|\": (t) => Number(ot(this, Yt, qt).call(this, t.shift())) | Number(ot(this, Yt, qt).call(this, t.shift())),\n      \"&&\": (t) => String(ot(this, Yt, qt).call(this, t.shift())) === \"true\" && String(ot(this, Yt, qt).call(this, t.shift())) === \"true\",\n      \"||\": (t) => String(ot(this, Yt, qt).call(this, t.shift())) === \"true\" || String(ot(this, Yt, qt).call(this, t.shift())) === \"true\",\n      \"?\": (t) => {\n        const e = t.shift();\n        let o = !1;\n        if (e[0] === \"!bool!\")\n          o = Boolean(e[1]);\n        else {\n          const S = String(ot(this, Yt, qt).call(this, e));\n          o = S !== \"true\" && S !== \"false\" ? int(S) !== 0 : S === \"true\";\n        }\n        const T = t.shift();\n        if (T[0] !== \":\")\n          throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002: \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n        return ot(this, Yt, qt).call(this, T[o ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)\\u4E09\\u9805\\u6F14\\u7B97\\u5B50\\u306E\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3067\\u3059\\u3002? \\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\");\n      }\n    });\n    rt(this, bl, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g);\n    Pt(this, \"getValAmpersand\", (t) => t.charAt(0) === \"&\" ? String(this.parse(t.slice(1))) : t);\n    this.val = t;\n    function o(q) {\n      const Z = [];\n      for (const K of q)\n        Z.push(\n          (K instanceof RegExp ? parsimmon_umd_min.exports.regex(K) : parsimmon_umd_min.exports.string(K)).trim(parsimmon_umd_min.exports.optWhitespace)\n        );\n      return parsimmon_umd_min.exports.alt.apply(null, Z);\n    }\n    function T(q, Z) {\n      const K = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(q, K).or(Z));\n      return K;\n    }\n    function S(q, Z) {\n      let K = parsimmon_umd_min.exports.lazy(\n        () => Z.chain(\n          (J) => parsimmon_umd_min.exports.seq(\n            q,\n            parsimmon_umd_min.exports.of(J),\n            K\n          ).or(parsimmon_umd_min.exports.of(J))\n        )\n      );\n      return K;\n    }\n    function N(q, Z) {\n      return parsimmon_umd_min.exports.seqMap(\n        Z,\n        parsimmon_umd_min.exports.seq(q, Z).many(),\n        (K, J) => J.reduce((tt, et) => [et[0], tt, et[1]], K)\n      );\n    }\n    const D = parsimmon_umd_min.exports.alt(\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      parsimmon_umd_min.exports.alt(\n        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((q) => int(q))\n    ).map((q) => [\"!num!\", q]).desc(\"number\"), B = parsimmon_umd_min.exports.string(\"null\").map(() => [\"!str!\", null]), $ = parsimmon_umd_min.exports.regex(/(true|false)/).map((q) => [\"!bool!\", q === \"true\"]).desc(\"boolean\"), U = parsimmon_umd_min.exports.regex(new RegExp(`(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)`)).map((q) => [\"!str!\", q.slice(1, -1).replaceAll(e, \"\")]).desc(\"string\"), z = /\\[[^\\]]+\\]/g, V = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((q) => {\n      const Z = String(q).replaceAll(\n        z,\n        (J) => \".\" + this.parse(J.slice(1, -1))\n      );\n      if (Z.charAt(0) === \"-\") {\n        const J = this.val.getVal(Z.slice(1));\n        if (J == null || String(J) === \"null\")\n          throw Error(\"(PropParser)\\u6570\\u5024\\u4EE5\\u5916\\u306B-\\u7B26\\u53F7\\u304C\\u3064\\u3044\\u3066\\u3044\\u307E\\u3059\");\n        return [\"!num!\", -Number(J)];\n      }\n      const K = this.val.getVal(Z);\n      return K == null ? [\"!str!\", K] : typeof K == \"boolean\" ? [\"!bool!\", K] : Object.prototype.toString.call(K) === \"[object String]\" ? [\"!str!\", String(K)] : [\"!num!\", Number(K)];\n    }).desc(\"string\"), X = parsimmon_umd_min.exports.lazy(\n      () => parsimmon_umd_min.exports.string(\"(\").then(H(this, vn)).skip(parsimmon_umd_min.exports.string(\")\")).or(D).or(B).or($).or(U).or(V)\n    ), Y = [\n      { type: T, ops: o([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      { type: T, ops: o([/(!(?!=)|~)/]) },\n      { type: S, ops: o([\"**\"]) },\n      { type: N, ops: o([\"*\", \"/\", \"\\xA5\", \"%\"]) },\n      { type: N, ops: o([\"+\", \"-\"]) },\n      { type: N, ops: o([/(>>>|<<|>>)/]) },\n      { type: N, ops: o([/(<=|<|>=|>)/]) },\n      { type: N, ops: o([/(===|!==|==|!=)/]) },\n      { type: N, ops: o([/&(?!&)/]) },\n      { type: N, ops: o([\"^\"]) },\n      { type: N, ops: o([/\\|(?!\\|)/]) },\n      { type: N, ops: o([\"&&\"]) },\n      { type: N, ops: o([\"||\"]) },\n      { type: S, ops: o([\":\"]) },\n      { type: S, ops: o([\"?\"]) }\n    ].reduce(\n      (q, Z) => Z.type(Z.ops, q),\n      X\n    );\n    nt(this, vn, Y.trim(parsimmon_umd_min.exports.optWhitespace));\n  }\n  parse(t) {\n    const e = H(this, vn).parse(t);\n    if (!e.status)\n      throw Error(\"(PropParser)\\u6587\\u6CD5\\u30A8\\u30E9\\u30FC\\u3010\" + t + \"\\u3011\");\n    const o = e.value;\n    return o[0] === \"!str!\" ? ot(this, eo, Fc).call(this, o[1]) : ot(this, Yt, qt).call(this, o);\n  }\n  static getValName(t) {\n    var D;\n    const e = H(this, El).exec(t.trim()), o = e == null ? void 0 : e.groups;\n    if (!o)\n      return;\n    const { scope: T = \"tmp\", name: S, at: N = \"\" } = o;\n    return {\n      scope: T,\n      name: ot(D = Cf, xl, Of).call(D, S),\n      at: N\n    };\n  }\n};\nlet PropParser = Cf;\nvn = new WeakMap(), Yt = new WeakSet(), qt = function(t) {\n  const e = t.shift();\n  if (e instanceof Array)\n    return ot(this, Yt, qt).call(this, e);\n  const o = H(this, Fi)[e];\n  return o ? o(t) : Object(null);\n}, Fi = new WeakMap(), Bi = new WeakSet(), ys = function(t) {\n  const e = ot(this, Yt, qt).call(this, t);\n  if (Object.prototype.toString.call(e) !== \"[object Number]\")\n    throw Error(\"(PropParser)\\u5F15\\u6570\\u3010\" + e + \"\\u3011\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\");\n  return Number(e);\n}, bl = new WeakMap(), eo = new WeakSet(), Fc = function(t) {\n  return t == null ? t : String(t).replaceAll(H(this, bl), (e) => e.charAt(0) === \"$\" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));\n}, El = new WeakMap(), xl = new WeakSet(), Of = function(t) {\n  let e = 0, o = 0;\n  for (; ; ) {\n    if (e = t.indexOf('[\"'), e < 0) {\n      if (e = t.indexOf(\"['\"), e < 0)\n        break;\n      o = t.indexOf(\"']\", e + 2);\n    } else\n      o = t.indexOf('\"]', e + 2);\n    if (o < 0)\n      break;\n    t = t.slice(0, e) + \".\" + t.slice(e + 2, o) + t.slice(o + 2), e = o - 2;\n  }\n  return t;\n}, rt(PropParser, xl), rt(PropParser, El, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar Tr, gn, ws, Sr, ro, Tl, Nf, Sl, Mf, Cl, Df, Rl, Lf;\nconst pe = class {\n  constructor(t, e, o) {\n    rt(this, Tl);\n    rt(this, Sl);\n    rt(this, ro, !0);\n    this.sys = t, nt(pe, Tr, o), nt(pe, gn, e), nt(pe, ws, e.title), pe.myTrace = ot(pe, Cl, Df), e.log = (T) => ot(this, Tl, Nf).call(this, T), e.trace = (T) => ot(this, Sl, Mf).call(this, T), nt(pe, Sr, document.createElement(\"span\")), H(pe, Sr).hidden = !0, H(pe, Sr).textContent = \"\", H(pe, Sr).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(H(pe, Sr));\n  }\n  destroy() {\n    nt(pe, ws, () => !1), document.body.removeChild(H(pe, Sr)), pe.myTrace = pe.trace_beforeNew;\n  }\n  static trace_beforeNew(t, e = \"E\") {\n    let o = `{${e}} ` + t, T = \"\";\n    switch (e) {\n      case \"D\":\n        T = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        T = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        T = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw o;\n      case \"E\":\n        console.error(\"%c\" + o, \"color:#FF3300;\");\n        return;\n      default:\n        T = \"color:black;\", o = \" \" + o;\n    }\n    console.info(\"%c\" + o, T);\n  }\n};\nlet DebugMng = pe;\nTr = new WeakMap(), gn = new WeakMap(), ws = new WeakMap(), Sr = new WeakMap(), ro = new WeakMap(), Tl = new WeakSet(), Nf = function(t) {\n  let e = \"\";\n  return H(this, ro) && (nt(this, ro, !1), e = `== ${platform.description} ==\n`), this.sys.appendFile(\n    this.sys.path_downloads + \"log.txt\",\n    `${e}--- ${getDateStr(\"-\", \"_\", \"\")} [fn:${H(pe, Tr).scriptFn} line:${H(pe, Tr).lineNum}] prj:${this.sys.cur}\n${t.text || `(text is ${t.text})`}\n`,\n    (o) => {\n      o && console.log(o);\n    }\n  ), !1;\n}, Sl = new WeakSet(), Mf = function(t) {\n  return pe.myTrace(t.text || `(text is ${t.text})`, \"I\"), !1;\n}, Cl = new WeakSet(), Df = function(t, e = \"E\") {\n  var S, N;\n  let o = `{${e}} ` + pe.strPos() + t;\n  ot(S = pe, Rl, Lf).call(S, o, e);\n  let T = \"\";\n  switch (e) {\n    case \"D\":\n      T = `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      T = \"color:#F80;\";\n      break;\n    case \"F\":\n      T = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      if (H(N = pe, ws).call(N, { text: t }), H(this, gn).dump_lay({}), H(this, gn).dump_val({}), H(pe, Tr).dumpErrForeLine(), H(this, gn).dump_stack({}), e === \"ET\")\n        throw o;\n      console.error(\"%c\" + o, \"color:#F30;\");\n      return;\n    default:\n      T = \"\", o = \" \" + o;\n  }\n  console.info(\"%c\" + o, T);\n}, Rl = new WeakSet(), Lf = function(t, e) {\n  let o = \"\";\n  switch (e) {\n    case \"D\":\n      o = \"color:#05A;\";\n      break;\n    case \"W\":\n      o = \"color:#F80;\";\n      break;\n    case \"F\":\n      o = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      o = \"color:#F30;\";\n      break;\n    default:\n      o = \"\";\n  }\n  H(pe, Sr).innerHTML += `<span style='${o}'>${t}</span><br/>`, H(pe, Sr).hidden = !1;\n}, rt(DebugMng, Cl), rt(DebugMng, Rl), rt(DebugMng, Tr, void 0), rt(DebugMng, gn, void 0), rt(DebugMng, ws, void 0), rt(DebugMng, Sr, void 0), Pt(DebugMng, \"myTrace\", pe.trace_beforeNew), Pt(DebugMng, \"strPos\", () => H(pe, Tr) && H(pe, Tr).lineNum > 0 ? `(fn:${H(pe, Tr).scriptFn} line:${H(pe, Tr).lineNum}) ` : \"\");\nclass Areas {\n  constructor() {\n    Pt(this, \"hAreas\", /* @__PURE__ */ Object.create(null));\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(t) {\n    return Object.entries(this.hAreas).some(([e, o]) => t >= parseInt(e) && t <= o);\n  }\n  record(t) {\n    if (!this.search(t)) {\n      for (const [e, o] of Object.entries(this.hAreas))\n        if (o + 1 === t) {\n          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;\n          return;\n        }\n      if (String(t + 1) in this.hAreas) {\n        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];\n        return;\n      }\n      this.hAreas[t] = t;\n    }\n  }\n  erase(t) {\n    if (!!this.search(t)) {\n      if (String(t) in this.hAreas) {\n        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];\n        return;\n      }\n      for (const [e, o] of Object.entries(this.hAreas))\n        if (!(t < parseInt(e) || o < t)) {\n          if (this.hAreas[e] === t) {\n            this.hAreas[e] = t - 1;\n            return;\n          }\n          this.hAreas[t + 1] = o, this.hAreas[e] = t - 1;\n          return;\n        }\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  toString() {\n    let t = \",\";\n    for (const e of Object.keys(this.hAreas).map((o) => parseInt(o)).sort((o, T) => o - T))\n      t += e === this.hAreas[e] ? \",\" + e : \",\" + e + \"~\" + this.hAreas[e];\n    return t.slice(1);\n  }\n}\nvar Ae, or, Ee, ri, Ie, Ze, Ur, io, Il, no, Bc, so, ao, wl, Ff, Pl, Bf, pr, Fr, Al, kf, Ol, $f, Nl, Uf, Ml, Gf, Dl, Hf, Ll, jf, Fl, zf, Bl, Vf, Ps, Ku, oo, kc, uo, _n, lo, $c, kl, $l, As, ho, Os, Ju, Ul, Xf, Gl, Wf, co, Uc, fo, Gc, Hl, Yf, jl, qf, Ns, Qu;\nconst Ts = class {\n  constructor(t, e) {\n    rt(this, no);\n    rt(this, wl);\n    rt(this, Pl);\n    rt(this, pr);\n    rt(this, Al);\n    rt(this, Ol);\n    rt(this, Nl);\n    rt(this, Ml);\n    rt(this, Dl);\n    rt(this, Ll);\n    rt(this, Fl);\n    rt(this, Bl);\n    rt(this, Ps);\n    rt(this, oo);\n    rt(this, lo);\n    rt(this, Os);\n    rt(this, Ul);\n    rt(this, Gl);\n    rt(this, co);\n    rt(this, fo);\n    rt(this, Hl);\n    rt(this, jl);\n    rt(this, Ns);\n    rt(this, Ae, { sys: {}, save: {}, tmp: {}, mp: {} });\n    rt(this, or, H(this, Ae).save);\n    rt(this, Ee, H(this, Ae).tmp);\n    rt(this, ri, void 0);\n    rt(this, Ie, { sys: {}, mark: {}, kidoku: {} });\n    rt(this, Ze, void 0);\n    rt(this, Ur, {});\n    rt(this, io, void 0);\n    rt(this, Il, {\n      auth: (t, e) => ot(this, no, Bc).call(this, e.hBreakpoint.aData),\n      var: (t, e) => {\n        var o;\n        return H(this, ri).send2Dbg(e.ri, { v: (o = H(this, Ae)[e.scope]) != null ? o : {} });\n      },\n      set_var: (t, e) => {\n        try {\n          H(this, uo).call(this, e.nm, e.val), H(this, ri).send2Dbg(e.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (t, e) => {\n        ot(this, no, Bc).call(this, e.a), H(this, ri).send2Dbg(e.ri, {});\n      },\n      disconnect: (t) => nt(Ts, _n, {})\n    });\n    rt(this, so, () => {\n    });\n    rt(this, ao, (t) => {\n    });\n    Pt(this, \"getMark\", (t) => H(this, Ie).mark[t]);\n    Pt(this, \"getAreaKidoku\", (t) => H(this, Ur)[t]);\n    rt(this, uo, (t, e, o = !0) => {\n      if (!t)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      if (e == null)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] text\\u306F\\u5FC5\\u9808\\u3067\\u3059\\uFF08\\u7A7A\\u6587\\u5B57\\u306FOK\\uFF09\";\n      const T = PropParser.getValName(t);\n      if (T === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + t + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const S = H(this, Ae)[T.scope];\n      if (!S)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] scope\\u304C\\u7570\\u5E38\\u3010\" + T.scope + \"\\u3011\\u3067\\u3059\";\n      const N = T.name;\n      if (N.slice(0, 6) === \"const.\" && N in S)\n        throw \"[\\u5909\\u6570\\u306B\\u5024\\u30BB\\u30C3\\u30C8] \\u5909\\u6570\\u3010\" + N + \"\\u3011\\u306F\\u66F8\\u304D\\u63DB\\u3048\\u4E0D\\u53EF\\u3067\\u3059\";\n      this.setVal_Nochk(T.scope, N, e, o);\n    });\n    Pt(this, \"getVal\", (t, e) => {\n      if (!t)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      const o = PropParser.getValName(t);\n      if (o === void 0)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] name(\" + t + \")\\u304C\\u5909\\u6570\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059\";\n      const T = H(this, Ae)[o.scope];\n      if (!T)\n        throw \"[\\u5909\\u6570\\u53C2\\u7167] scope\\u304C\\u7570\\u5E38\\u3010\" + o.scope + \"\\u3011\\u3067\\u3059\";\n      const S = o.name;\n      let N = T[S];\n      if (!(S in T)) {\n        N = e;\n        let D = \"\";\n        const B = S.split(\".\"), $ = B.length;\n        for (let U = 0; U < $; ++U, D += \".\") {\n          if (D += B[U], !(D in T))\n            continue;\n          let z = JSON.parse(T[D]);\n          if (Object.prototype.toString.call(z) !== \"[object Object]\") {\n            if (U + 1 === $) {\n              N = z;\n              break;\n            }\n            continue;\n          }\n          let V = U;\n          for (; ++V < $; ) {\n            if (!(B[V] in z)) {\n              N = e;\n              break;\n            }\n            if (z = z[B[V]], Object.prototype.toString.call(z) !== \"[object Object]\" || V + 1 === $) {\n              N = z;\n              break;\n            }\n          }\n          N instanceof Object && (N = JSON.stringify(N));\n          break;\n        }\n      }\n      return N instanceof Function && (N = N()), o.at === \"@str\" ? N : ot(this, lo, $c).call(this, N);\n    });\n    rt(this, kl, /^-?[\\d\\.]+$/);\n    rt(this, $l, () => {\n      const t = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let e in t) {\n        const o = H(this, Ae)[e], T = t[e];\n        for (let [S, N] of Object.entries(o))\n          T[S] = Object.prototype.toString.call(N) === \"[object Function]\" ? N() : N;\n      }\n      return console.info(\"\\u{1F95F} [dump_val]\", t), !1;\n    });\n    rt(this, As, !1);\n    rt(this, ho, {\n      \"sys:sn.tagCh.doWait\": (t) => ot(this, Os, Ju).call(this, t),\n      \"sys:sn.tagCh.doWait_Kidoku\": (t) => ot(this, Os, Ju).call(this, t),\n      \"sys:sn.tagCh.msecWait\": (t) => ot(this, Ul, Xf).call(this, t),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (t) => ot(this, Gl, Wf).call(this, t),\n      \"sys:sn.tagCh.canskip\": (t) => ot(this, Os, Ju).call(this, t),\n      \"sys:sn.auto.msecPageWait\": (t) => ot(this, co, Uc).call(this, t),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (t) => ot(this, co, Uc).call(this, t),\n      \"sys:sn.auto.msecLineWait\": (t) => ot(this, fo, Gc).call(this, t),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (t) => ot(this, fo, Gc).call(this, t),\n      \"save:sn.doRecLog\": (t) => {\n        H(this, ao).call(this, nt(this, As, ot(this, Hl, Yf).call(this, t)));\n      },\n      \"save:sn.userFnTail\": (t, e) => this.cfg.userFnTail = e,\n      \"tmp:sn.tagL.enabled\": (t) => ot(this, jl, qf).call(this, t),\n      \"tmp:sn.skip.all\": (t) => ot(this, Ns, Qu).call(this, t),\n      \"tmp:sn.skip.enabled\": (t) => ot(this, Ns, Qu).call(this, t),\n      \"tmp:sn.auto.enabled\": (t) => ot(this, Ns, Qu).call(this, t),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    });\n    var S;\n    if (this.cfg = t, e.let = (N) => ot(this, pr, Fr).call(this, N), e.let_abs = (N) => ot(this, Al, kf).call(this, N), e.let_char_at = (N) => ot(this, Ol, $f).call(this, N), e.let_index_of = (N) => ot(this, Nl, Uf).call(this, N), e.let_length = (N) => ot(this, Ml, Gf).call(this, N), e.let_replace = (N) => ot(this, Dl, Hf).call(this, N), e.let_round = (N) => ot(this, Ll, jf).call(this, N), e.let_search = (N) => ot(this, Fl, zf).call(this, N), e.let_substr = (N) => ot(this, Bl, Vf).call(this, N), e.clearsysvar = () => ot(this, Ps, Ku).call(this), e.clearvar = () => ot(this, oo, kc).call(this), e.dump_val = () => H(this, $l).call(this), e.copybookmark = (N) => ot(this, wl, Ff).call(this, N), e.erasebookmark = (N) => ot(this, Pl, Bf).call(this, N), H(this, or)[\"sn.userFnTail\"] = \"\", this.defTmp(\"const.sn.bookmark.json\", () => {\n      const N = [];\n      for (const D of Object.keys(H(this, Ie).mark).sort()) {\n        const B = { ...H(this, Ie).mark[D].json };\n        B.place = D, N.push(B);\n      }\n      return JSON.stringify(N);\n    }), H(this, Ee)[\"const.sn.isFirstBoot\"] = !0, H(this, Ee)[\"sn.tagL.enabled\"] = !0, H(this, Ee)[\"sn.skip.all\"] = !1, H(this, Ee)[\"sn.skip.enabled\"] = !1, H(this, Ee)[\"sn.auto.enabled\"] = !1, H(this, Ee)[\"const.sn.last_page_text\"] = \"\", H(this, Ee)[\"const.sn.displayState\"] = !1, H(this, Ee)[\"const.Date.getTime\"] = () => new Date().getTime(), H(this, Ee)[\"const.Date.getDateStr\"] = () => getDateStr(), H(this, Ee)[\"const.sn.platform\"] = JSON.stringify(platform), ot(this, Ps, Ku).call(this), ot(this, oo, kc).call(this), H(this, Ee)[\"const.sn.config.window.width\"] = t.oCfg.window.width, H(this, Ee)[\"const.sn.config.window.height\"] = t.oCfg.window.height, H(this, Ee)[\"const.sn.config.book.title\"] = t.oCfg.book.title, H(this, Ee)[\"const.sn.config.book.version\"] = t.oCfg.book.version, H(this, Ee)[\"const.sn.Math.PI\"] = Math.PI, typeof window > \"u\")\n      return;\n    const o = window, T = (S = o.AudioContext) != null ? S : o.webkitAudioContext;\n    H(this, Ee)[\"const.sn.needClick2Play\"] = () => new T().state === \"suspended\";\n  }\n  setSys(t) {\n    nt(this, ri, t), t.initVal(H(this, Ie), H(this, Ee), (e) => {\n      this.updateData(e), sessionStorage.clear();\n      const o = this.cfg.getNs();\n      nt(this, so, this.cfg.oCfg.debug.variable ? () => {\n        const S = {};\n        for (const z of Object.keys(H(this, Ze))) {\n          const V = H(this, Ze)[z];\n          S[\"sys:\" + z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"sys\"] = JSON.stringify(S);\n        const N = {};\n        for (const z of Object.keys(H(this, or))) {\n          const V = H(this, or)[z];\n          N[\"save:\" + z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"save\"] = JSON.stringify(N);\n        const D = {};\n        for (const z of Object.keys(H(this, Ee))) {\n          const V = H(this, Ee)[z];\n          D[z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"tmp\"] = JSON.stringify(D);\n        const B = {};\n        for (const z of Object.keys(H(this, Ae).mp)) {\n          const V = H(this, Ae).mp[z];\n          B[z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"mp\"] = JSON.stringify(B);\n        const $ = {};\n        for (const z of Object.keys(H(this, Ie).mark)) {\n          const V = H(this, Ie).mark[z];\n          $[z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"mark\"] = JSON.stringify($);\n        const U = {};\n        for (const z of Object.keys(H(this, Ie).kidoku)) {\n          const V = H(this, Ie).kidoku[z];\n          U[z] = V instanceof Function ? V() : V;\n        }\n        sessionStorage[o + \"kidoku\"] = JSON.stringify(U), t.flush();\n      } : () => t.flush()), nt(this, io, (S, N) => t.callHook(S, N)), t.addHook((S, N) => {\n        var D, B;\n        return (B = (D = H(this, Il))[S]) == null ? void 0 : B.call(D, S, N);\n      });\n      const T = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      (H(this, Ee)[\"const.sn.isFirstBoot\"] || T === -1) && ot(this, Ps, Ku).call(this);\n    });\n  }\n  updateData(t) {\n    nt(this, Ie, t), nt(this, Ze, H(this, Ae).sys = H(this, Ie).sys), nt(this, Ur, {});\n    for (const [e, o] of Object.entries(H(this, Ie).kidoku)) {\n      const T = new Areas();\n      T.hAreas = { ...o }, H(this, Ur)[e] = T;\n    }\n  }\n  flush() {\n    H(this, so).call(this);\n  }\n  setDoRecProc(t) {\n    nt(this, ao, t);\n  }\n  defTmp(t, e) {\n    H(this, Ee)[t] = e;\n  }\n  cloneMp() {\n    return { ...H(this, Ae).mp };\n  }\n  setMp(t) {\n    H(this, Ae).mp = t;\n  }\n  setMark(t, e) {\n    H(this, Ie).mark[t] = e, this.flush();\n  }\n  cloneSave() {\n    return { ...H(this, Ae).save };\n  }\n  mark2save(t) {\n    var e;\n    nt(this, or, H(this, Ae).save = { ...t.hSave }), nt(this, As, (e = H(this, or)[\"sn.doRecLog\"]) != null ? e : !1);\n  }\n  loadScrWork(t) {\n    t in H(this, Ur) || (H(this, Ur)[t] = new Areas());\n  }\n  saveKidoku() {\n    for (const [t, { hAreas: e }] of Object.entries(H(this, Ur)))\n      H(this, Ie).kidoku[t] = { ...e };\n    this.flush();\n  }\n  setVal_Nochk(t, e, o, T = !1) {\n    var D, B;\n    const S = H(this, Ae)[t];\n    T && (o = ot(this, lo, $c).call(this, o));\n    const N = t + \":\" + e;\n    if (N in H(Ts, _n)) {\n      const $ = S[e], U = o;\n      $ != U && H(this, io).call(this, \"data_break\", {\n        dataId: N,\n        old_v: $,\n        new_v: U\n      });\n    }\n    S[e] = o, (B = (D = H(this, ho))[N]) == null || B.call(D, e, o);\n  }\n  doRecLog() {\n    return H(this, As);\n  }\n  defValTrg(t, e) {\n    H(this, ho)[t] = e;\n  }\n};\nlet Variable = Ts;\nAe = new WeakMap(), or = new WeakMap(), Ee = new WeakMap(), ri = new WeakMap(), Ie = new WeakMap(), Ze = new WeakMap(), Ur = new WeakMap(), io = new WeakMap(), Il = new WeakMap(), no = new WeakSet(), Bc = function(t) {\n  nt(Ts, _n, {});\n  for (const e of t)\n    H(Ts, _n)[e.dataId] = 1;\n}, so = new WeakMap(), ao = new WeakMap(), wl = new WeakSet(), Ff = function(t) {\n  if (!(\"from\" in t))\n    throw \"from\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!(\"to\" in t))\n    throw \"to\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.from), o = Number(t.to);\n  if (e === o)\n    return !1;\n  if (!(e in H(this, Ie).mark))\n    throw `from:${e} \\u306E\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  return this.setMark(o, { ...H(this, Ie).mark[e] }), H(this, ri).copyBMFolder(e, o), !1;\n}, Pl = new WeakSet(), Bf = function(t) {\n  const { place: e } = t;\n  if (!e)\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return delete H(this, Ie).mark[e], this.flush(), H(this, ri).eraseBMFolder(e), !1;\n}, pr = new WeakSet(), Fr = function(t) {\n  if (!t.name)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let e = !0;\n  if (t.cast)\n    switch (t.cast) {\n      case \"num\":\n        argChk_Num(t, \"text\", NaN);\n        break;\n      case \"int\":\n        t.text = String(int(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"uint\":\n        t.text = String(uint(argChk_Num(t, \"text\", NaN)));\n        break;\n      case \"bool\":\n        argChk_Boolean(t, \"text\", !1);\n        break;\n      case \"str\":\n        e = !1;\n        break;\n      default:\n        throw \"cast\\u3010\" + t.cast + \"\\u3011\\u306F\\u672A\\u5B9A\\u7FA9\\u3067\\u3059\";\n    }\n  return H(this, uo).call(this, t.name, t.text, e), !1;\n}, Al = new WeakSet(), kf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(e < 0 ? -e : e), ot(this, pr, Fr).call(this, t), !1;\n}, Ol = new WeakSet(), $f = function(t) {\n  var e;\n  return t.text = ((e = t.text) != null ? e : \"\").charAt(argChk_Num(t, \"pos\", 0)), ot(this, pr, Fr).call(this, t), !1;\n}, Nl = new WeakSet(), Uf = function(t) {\n  var T;\n  const { val: e } = t;\n  if (!e)\n    throw \"val\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = argChk_Num(t, \"start\", 0);\n  return t.text = String(((T = t.text) != null ? T : \"\").indexOf(e, o)), ot(this, pr, Fr).call(this, t), !1;\n}, Ml = new WeakSet(), Gf = function(t) {\n  var e;\n  return t.text = String(((e = t.text) != null ? e : \"\").length), ot(this, pr, Fr).call(this, t), !1;\n}, Dl = new WeakSet(), Hf = function(t) {\n  var T;\n  if (!t.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String((T = t.text) != null ? T : \"\").replace(o, String(t.val)), ot(this, pr, Fr).call(this, t), !1;\n}, Ll = new WeakSet(), jf = function(t) {\n  const e = argChk_Num(t, \"text\", 0);\n  return t.text = String(Math.round(e)), ot(this, pr, Fr).call(this, t), !1;\n}, Fl = new WeakSet(), zf = function(t) {\n  var T;\n  if (!t.reg)\n    throw \"reg\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String(((T = t.text) != null ? T : \"\").search(o)), ot(this, pr, Fr).call(this, t), !1;\n}, Bl = new WeakSet(), Vf = function(t) {\n  var o, T;\n  const e = argChk_Num(t, \"pos\", 0);\n  return t.text = t.len !== \"all\" ? ((o = t.text) != null ? o : \"\").slice(e, e + int(argChk_Num(t, \"len\", 1))) : ((T = t.text) != null ? T : \"\").slice(e), ot(this, pr, Fr).call(this, t), !1;\n}, Ps = new WeakSet(), Ku = function() {\n  var o, T;\n  const t = nt(this, Ze, H(this, Ae).sys = H(this, Ie).sys = {});\n  typeof process < \"u\" || (this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0), this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0)), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", !0), this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\"), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", argChk_Num(t, \"sn.auto.msecPageWait\", (o = this.cfg.oCfg.init.auto_msecpagewait) != null ? o : 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", argChk_Num(t, \"sn.auto.msecPageWait\", (T = this.cfg.oCfg.init.auto_msecpagewait) != null ? T : 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500), this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const [S, N] of Object.entries(H(this, Ie).kidoku))\n    N.hAreas = {}, H(this, Ur)[S].clear();\n  return this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5), H(this, Ae).mark = H(this, Ie).mark = {}, this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1), this.flush(), !1;\n}, oo = new WeakSet(), kc = function() {\n  var T, S, N;\n  const t = (T = H(this, or)[\"const.sn.mesLayer\"]) != null ? T : \"\", e = (S = H(this, or)[\"sn.doRecLog\"]) != null ? S : !1, o = (N = H(this, or)[\"const.sn.sLog\"]) != null ? N : \"[]\";\n  return nt(this, or, H(this, Ae).save = {}), this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", t), this.setVal_Nochk(\"save\", \"sn.doRecLog\", e), this.setVal_Nochk(\"save\", \"const.sn.sLog\", o), !1;\n}, uo = new WeakMap(), _n = new WeakMap(), lo = new WeakSet(), $c = function(t) {\n  const e = t;\n  if (e === \"true\")\n    return !0;\n  if (e === \"false\")\n    return !1;\n  if (e === \"null\")\n    return null;\n  if (e !== \"undefined\")\n    return H(this, kl).test(e) ? parseFloat(e) : t;\n}, kl = new WeakMap(), $l = new WeakMap(), As = new WeakMap(), ho = new WeakMap(), Os = new WeakSet(), Ju = function(t) {\n  argChk_Boolean(H(this, Ze), t, !0);\n}, Ul = new WeakSet(), Xf = function(t) {\n  argChk_Num(H(this, Ze), t, 10), H(this, Ze)[\"sn.tagCh.doWait\"];\n}, Gl = new WeakSet(), Wf = function(t) {\n  argChk_Num(\n    H(this, Ze),\n    t,\n    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait\n  ), H(this, Ze)[\"sn.tagCh.doWait_Kidoku\"];\n}, co = new WeakSet(), Uc = function(t) {\n  argChk_Num(\n    H(this, Ze),\n    t,\n    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait\n  );\n}, fo = new WeakSet(), Gc = function(t) {\n  argChk_Num(H(this, Ze), t, 500);\n}, Hl = new WeakSet(), Yf = function(t) {\n  return argChk_Boolean(H(this, or), t, !0);\n}, jl = new WeakSet(), qf = function(t) {\n  argChk_Boolean(H(this, Ee), t, !0);\n}, Ns = new WeakSet(), Qu = function(t) {\n  argChk_Boolean(H(this, Ee), t, !1);\n}, rt(Variable, _n, {});\nvar Easing = {\n  Linear: {\n    None: function(r) {\n      return r;\n    }\n  },\n  Quadratic: {\n    In: function(r) {\n      return r * r;\n    },\n    Out: function(r) {\n      return r * (2 - r);\n    },\n    InOut: function(r) {\n      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);\n    }\n  },\n  Cubic: {\n    In: function(r) {\n      return r * r * r;\n    },\n    Out: function(r) {\n      return --r * r * r + 1;\n    },\n    InOut: function(r) {\n      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);\n    }\n  },\n  Quartic: {\n    In: function(r) {\n      return r * r * r * r;\n    },\n    Out: function(r) {\n      return 1 - --r * r * r * r;\n    },\n    InOut: function(r) {\n      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);\n    }\n  },\n  Quintic: {\n    In: function(r) {\n      return r * r * r * r * r;\n    },\n    Out: function(r) {\n      return --r * r * r * r * r + 1;\n    },\n    InOut: function(r) {\n      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);\n    }\n  },\n  Sinusoidal: {\n    In: function(r) {\n      return 1 - Math.cos(r * Math.PI / 2);\n    },\n    Out: function(r) {\n      return Math.sin(r * Math.PI / 2);\n    },\n    InOut: function(r) {\n      return 0.5 * (1 - Math.cos(Math.PI * r));\n    }\n  },\n  Exponential: {\n    In: function(r) {\n      return r === 0 ? 0 : Math.pow(1024, r - 1);\n    },\n    Out: function(r) {\n      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);\n    },\n    InOut: function(r) {\n      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);\n    }\n  },\n  Circular: {\n    In: function(r) {\n      return 1 - Math.sqrt(1 - r * r);\n    },\n    Out: function(r) {\n      return Math.sqrt(1 - --r * r);\n    },\n    InOut: function(r) {\n      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);\n    }\n  },\n  Elastic: {\n    In: function(r) {\n      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);\n    },\n    Out: function(r) {\n      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(r) {\n      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);\n    }\n  },\n  Back: {\n    In: function(r) {\n      var t = 1.70158;\n      return r * r * ((t + 1) * r - t);\n    },\n    Out: function(r) {\n      var t = 1.70158;\n      return --r * r * ((t + 1) * r + t) + 1;\n    },\n    InOut: function(r) {\n      var t = 2.5949095;\n      return (r *= 2) < 1 ? 0.5 * (r * r * ((t + 1) * r - t)) : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2);\n    }\n  },\n  Bounce: {\n    In: function(r) {\n      return 1 - Easing.Bounce.Out(1 - r);\n    },\n    Out: function(r) {\n      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;\n    },\n    InOut: function(r) {\n      return r < 0.5 ? Easing.Bounce.In(r * 2) * 0.5 : Easing.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;\n    }\n  }\n}, now$2;\ntypeof self > \"u\" && typeof process < \"u\" && process.hrtime ? now$2 = function() {\n  var r = process.hrtime();\n  return r[0] * 1e3 + r[1] / 1e6;\n} : typeof self < \"u\" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {\n  return new Date().getTime();\n};\nvar now$1$1 = now$2, Group = function() {\n  function r() {\n    this._tweens = {}, this._tweensAddedDuringUpdate = {};\n  }\n  return r.prototype.getAll = function() {\n    var t = this;\n    return Object.keys(this._tweens).map(function(e) {\n      return t._tweens[e];\n    });\n  }, r.prototype.removeAll = function() {\n    this._tweens = {};\n  }, r.prototype.add = function(t) {\n    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;\n  }, r.prototype.remove = function(t) {\n    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];\n  }, r.prototype.update = function(t, e) {\n    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);\n    var o = Object.keys(this._tweens);\n    if (o.length === 0)\n      return !1;\n    for (; o.length > 0; ) {\n      this._tweensAddedDuringUpdate = {};\n      for (var T = 0; T < o.length; T++) {\n        var S = this._tweens[o[T]], N = !e;\n        S && S.update(t, N) === !1 && !e && delete this._tweens[o[T]];\n      }\n      o = Object.keys(this._tweensAddedDuringUpdate);\n    }\n    return !0;\n  }, r;\n}(), Interpolation = {\n  Linear: function(r, t) {\n    var e = r.length - 1, o = e * t, T = Math.floor(o), S = Interpolation.Utils.Linear;\n    return t < 0 ? S(r[0], r[1], o) : t > 1 ? S(r[e], r[e - 1], e - o) : S(r[T], r[T + 1 > e ? e : T + 1], o - T);\n  },\n  Bezier: function(r, t) {\n    for (var e = 0, o = r.length - 1, T = Math.pow, S = Interpolation.Utils.Bernstein, N = 0; N <= o; N++)\n      e += T(1 - t, o - N) * T(t, N) * r[N] * S(o, N);\n    return e;\n  },\n  CatmullRom: function(r, t) {\n    var e = r.length - 1, o = e * t, T = Math.floor(o), S = Interpolation.Utils.CatmullRom;\n    return r[0] === r[e] ? (t < 0 && (T = Math.floor(o = e * (1 + t))), S(r[(T - 1 + e) % e], r[T], r[(T + 1) % e], r[(T + 2) % e], o - T)) : t < 0 ? r[0] - (S(r[0], r[0], r[1], r[1], -o) - r[0]) : t > 1 ? r[e] - (S(r[e], r[e], r[e - 1], r[e - 1], o - e) - r[e]) : S(r[T ? T - 1 : 0], r[T], r[e < T + 1 ? e : T + 1], r[e < T + 2 ? e : T + 2], o - T);\n  },\n  Utils: {\n    Linear: function(r, t, e) {\n      return (t - r) * e + r;\n    },\n    Bernstein: function(r, t) {\n      var e = Interpolation.Utils.Factorial;\n      return e(r) / e(t) / e(r - t);\n    },\n    Factorial: function() {\n      var r = [1];\n      return function(t) {\n        var e = 1;\n        if (r[t])\n          return r[t];\n        for (var o = t; o > 1; o--)\n          e *= o;\n        return r[t] = e, e;\n      };\n    }(),\n    CatmullRom: function(r, t, e, o, T) {\n      var S = (e - r) * 0.5, N = (o - t) * 0.5, D = T * T, B = T * D;\n      return (2 * t - 2 * e + S + N) * B + (-3 * t + 3 * e - 2 * S - N) * D + S * T + t;\n    }\n  }\n}, Sequence = function() {\n  function r() {\n  }\n  return r.nextId = function() {\n    return r._nextId++;\n  }, r._nextId = 0, r;\n}(), mainGroup = new Group(), Tween = function() {\n  function r(t, e) {\n    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;\n  }\n  return r.prototype.getId = function() {\n    return this._id;\n  }, r.prototype.isPlaying = function() {\n    return this._isPlaying;\n  }, r.prototype.isPaused = function() {\n    return this._isPaused;\n  }, r.prototype.to = function(t, e) {\n    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;\n  }, r.prototype.duration = function(t) {\n    return this._duration = t, this;\n  }, r.prototype.start = function(t) {\n    if (this._isPlaying)\n      return this;\n    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {\n      this._reversed = !1;\n      for (var e in this._valuesStartRepeat)\n        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];\n    }\n    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == \"string\" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;\n  }, r.prototype._setupProperties = function(t, e, o, T) {\n    for (var S in o) {\n      var N = t[S], D = Array.isArray(N), B = D ? \"array\" : typeof N, $ = !D && Array.isArray(o[S]);\n      if (!(B === \"undefined\" || B === \"function\")) {\n        if ($) {\n          var U = o[S];\n          if (U.length === 0)\n            continue;\n          U = U.map(this._handleRelativeValue.bind(this, N)), o[S] = [N].concat(U);\n        }\n        if ((B === \"object\" || D) && N && !$) {\n          e[S] = D ? [] : {};\n          for (var z in N)\n            e[S][z] = N[z];\n          T[S] = D ? [] : {}, this._setupProperties(N, e[S], o[S], T[S]);\n        } else\n          typeof e[S] > \"u\" && (e[S] = N), D || (e[S] *= 1), $ ? T[S] = o[S].slice().reverse() : T[S] = e[S] || 0;\n      }\n    }\n  }, r.prototype.stop = function() {\n    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;\n  }, r.prototype.end = function() {\n    return this._goToEnd = !0, this.update(1 / 0), this;\n  }, r.prototype.pause = function(t) {\n    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);\n  }, r.prototype.resume = function(t) {\n    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);\n  }, r.prototype.stopChainedTweens = function() {\n    for (var t = 0, e = this._chainedTweens.length; t < e; t++)\n      this._chainedTweens[t].stop();\n    return this;\n  }, r.prototype.group = function(t) {\n    return this._group = t, this;\n  }, r.prototype.delay = function(t) {\n    return this._delayTime = t, this;\n  }, r.prototype.repeat = function(t) {\n    return this._initialRepeat = t, this._repeat = t, this;\n  }, r.prototype.repeatDelay = function(t) {\n    return this._repeatDelayTime = t, this;\n  }, r.prototype.yoyo = function(t) {\n    return this._yoyo = t, this;\n  }, r.prototype.easing = function(t) {\n    return this._easingFunction = t, this;\n  }, r.prototype.interpolation = function(t) {\n    return this._interpolationFunction = t, this;\n  }, r.prototype.chain = function() {\n    for (var t = [], e = 0; e < arguments.length; e++)\n      t[e] = arguments[e];\n    return this._chainedTweens = t, this;\n  }, r.prototype.onStart = function(t) {\n    return this._onStartCallback = t, this;\n  }, r.prototype.onUpdate = function(t) {\n    return this._onUpdateCallback = t, this;\n  }, r.prototype.onRepeat = function(t) {\n    return this._onRepeatCallback = t, this;\n  }, r.prototype.onComplete = function(t) {\n    return this._onCompleteCallback = t, this;\n  }, r.prototype.onStop = function(t) {\n    return this._onStopCallback = t, this;\n  }, r.prototype.update = function(t, e) {\n    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)\n      return !0;\n    var o, T, S = this._startTime + this._duration;\n    if (!this._goToEnd && !this._isPlaying) {\n      if (t > S)\n        return !1;\n      e && this.start(t);\n    }\n    if (this._goToEnd = !1, t < this._startTime)\n      return !0;\n    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), T = (t - this._startTime) / this._duration, T = this._duration === 0 || T > 1 ? 1 : T;\n    var N = this._easingFunction(T);\n    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, N), this._onUpdateCallback && this._onUpdateCallback(this._object, T), T === 1)\n      if (this._repeat > 0) {\n        isFinite(this._repeat) && this._repeat--;\n        for (o in this._valuesStartRepeat)\n          !this._yoyo && typeof this._valuesEnd[o] == \"string\" && (this._valuesStartRepeat[o] = this._valuesStartRepeat[o] + parseFloat(this._valuesEnd[o])), this._yoyo && this._swapEndStartRepeatValues(o), this._valuesStart[o] = this._valuesStartRepeat[o];\n        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;\n      } else {\n        this._onCompleteCallback && this._onCompleteCallback(this._object);\n        for (var D = 0, B = this._chainedTweens.length; D < B; D++)\n          this._chainedTweens[D].start(this._startTime + this._duration);\n        return this._isPlaying = !1, !1;\n      }\n    return !0;\n  }, r.prototype._updateProperties = function(t, e, o, T) {\n    for (var S in o)\n      if (e[S] !== void 0) {\n        var N = e[S] || 0, D = o[S], B = Array.isArray(t[S]), $ = Array.isArray(D), U = !B && $;\n        U ? t[S] = this._interpolationFunction(D, T) : typeof D == \"object\" && D ? this._updateProperties(t[S], N, D, T) : (D = this._handleRelativeValue(N, D), typeof D == \"number\" && (t[S] = N + (D - N) * T));\n      }\n  }, r.prototype._handleRelativeValue = function(t, e) {\n    return typeof e != \"string\" ? e : e.charAt(0) === \"+\" || e.charAt(0) === \"-\" ? t + parseFloat(e) : parseFloat(e);\n  }, r.prototype._swapEndStartRepeatValues = function(t) {\n    var e = this._valuesStartRepeat[t], o = this._valuesEnd[t];\n    typeof o == \"string\" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(o) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;\n  }, r;\n}();\nSequence.nextId;\nvar TWEEN = mainGroup;\nTWEEN.getAll.bind(TWEEN);\nvar removeAll = TWEEN.removeAll.bind(TWEEN);\nTWEEN.add.bind(TWEEN);\nTWEEN.remove.bind(TWEEN);\nvar update = TWEEN.update.bind(TWEEN), po;\nconst zl = class {\n  static ease(t) {\n    if (!t)\n      return (e) => Easing.Linear.None(e);\n    if (!(t in H(zl, po)))\n      throw \"\\u7570\\u5E38\\u306Aease\\u6307\\u5B9A\\u3067\\u3059\";\n    return H(zl, po)[t];\n  }\n};\nlet CmnTween = zl;\npo = new WeakMap(), rt(CmnTween, po, {\n  \"Back.In\": (t) => Easing.Back.In(t),\n  \"Back.InOut\": (t) => Easing.Back.InOut(t),\n  \"Back.Out\": (t) => Easing.Back.Out(t),\n  \"Bounce.In\": (t) => Easing.Bounce.In(t),\n  \"Bounce.InOut\": (t) => Easing.Bounce.InOut(t),\n  \"Bounce.Out\": (t) => Easing.Bounce.Out(t),\n  \"Circular.In\": (t) => Easing.Circular.In(t),\n  \"Circular.InOut\": (t) => Easing.Circular.InOut(t),\n  \"Circular.Out\": (t) => Easing.Circular.Out(t),\n  \"Cubic.In\": (t) => Easing.Cubic.In(t),\n  \"Cubic.InOut\": (t) => Easing.Cubic.InOut(t),\n  \"Cubic.Out\": (t) => Easing.Cubic.Out(t),\n  \"Elastic.In\": (t) => Easing.Elastic.In(t),\n  \"Elastic.InOut\": (t) => Easing.Elastic.InOut(t),\n  \"Elastic.Out\": (t) => Easing.Elastic.Out(t),\n  \"Exponential.In\": (t) => Easing.Exponential.In(t),\n  \"Exponential.InOut\": (t) => Easing.Exponential.InOut(t),\n  \"Exponential.Out\": (t) => Easing.Exponential.Out(t),\n  \"Linear.None\": (t) => Easing.Linear.None(t),\n  \"Quadratic.In\": (t) => Easing.Quadratic.In(t),\n  \"Quadratic.InOut\": (t) => Easing.Quadratic.InOut(t),\n  \"Quadratic.Out\": (t) => Easing.Quadratic.Out(t),\n  \"Quartic.In\": (t) => Easing.Quartic.In(t),\n  \"Quartic.InOut\": (t) => Easing.Quartic.InOut(t),\n  \"Quartic.Out\": (t) => Easing.Quartic.Out(t),\n  \"Quintic.In\": (t) => Easing.Quintic.In(t),\n  \"Quintic.InOut\": (t) => Easing.Quintic.InOut(t),\n  \"Quintic.Out\": (t) => Easing.Quintic.Out(t),\n  \"Sinusoidal.In\": (t) => Easing.Sinusoidal.In(t),\n  \"Sinusoidal.InOut\": (t) => Easing.Sinusoidal.InOut(t),\n  \"Sinusoidal.Out\": (t) => Easing.Sinusoidal.Out(t)\n});\n/*!\n * @pixi/sound - v4.3.1\n * https://github.com/pixijs/pixi-sound\n * Compiled Mon, 19 Sep 2022 19:18:55 UTC\n *\n * @pixi/sound is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar s;\nfunction u() {\n  return s;\n}\nvar a = function(r, t) {\n  return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      Object.prototype.hasOwnProperty.call(o, T) && (e[T] = o[T]);\n  })(r, t);\n};\nfunction c(r, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  function e() {\n    this.constructor = r;\n  }\n  a(r, t), r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar l = function() {\n  return (l = Object.assign || function(r) {\n    for (var t, e = 1, o = arguments.length; e < o; e++)\n      for (var T in t = arguments[e])\n        Object.prototype.hasOwnProperty.call(t, T) && (r[T] = t[T]);\n    return r;\n  }).apply(this, arguments);\n}, p = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], h = {};\nfunction f(r) {\n  var t = l({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, r || {}), e = document.createElement(\"audio\"), o = {}, T = /^no$/;\n  p.forEach(function(S) {\n    var N = e.canPlayType(\"audio/\".concat(S)).replace(T, \"\"), D = t[S] ? e.canPlayType(t[S]).replace(T, \"\") : \"\";\n    o[S] = !!N || !!D;\n  }), Object.assign(h, o);\n}\nf();\nvar d = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction _(r) {\n  var t = d, e = typeof r == \"string\" ? r : r.url;\n  if (!t.test(e))\n    return e;\n  for (var o = t.exec(e), T = o[2].split(\",\"), S = T[T.length - 1], N = 0, D = T.length; N < D; N++) {\n    var B = T[N];\n    if (h[B]) {\n      S = B;\n      break;\n    }\n  }\n  var $ = e.replace(o[1], S);\n  if (typeof r != \"string\") {\n    var U = r;\n    U.extension = S, U.url = $;\n  }\n  return $;\n}\nvar y = function() {\n  function r() {\n  }\n  return r.add = function() {\n    r.setLegacy(u().useLegacy);\n  }, r.setLegacy = function(t) {\n    var e = p;\n    t ? e.forEach(function(o) {\n      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.AUDIO);\n    }) : e.forEach(function(o) {\n      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.XHR);\n    });\n  }, r.pre = function(t, e) {\n    _(t), e();\n  }, r.use = function(t, e) {\n    t.data && p.indexOf(t.extension) > -1 ? t.sound = u().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();\n  }, r.extension = \"loader\", r;\n}(), m = 0, g = function(r) {\n  function t(e) {\n    var o = r.call(this) || this;\n    return o.id = m++, o.init(e), o;\n  }\n  return c(t, r), t.prototype.set = function(e, o) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = o;\n        break;\n      case \"volume\":\n        this.volume = o;\n        break;\n      case \"paused\":\n        this.paused = o;\n        break;\n      case \"loop\":\n        this.loop = o;\n        break;\n      case \"muted\":\n        this.muted = o;\n    }\n    return this;\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {\n    this._playing = !0;\n  }, t.prototype._onPause = function() {\n    this._playing = !1;\n  }, t.prototype.init = function(e) {\n    this._playing = !1, this._duration = e.source.duration;\n    var o = this._source = e.source.cloneNode(!1);\n    o.src = e.parent.url, o.onplay = this._onPlay.bind(this), o.onpause = this._onPause.bind(this), e.context.on(\"refresh\", this.refresh, this), e.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = e;\n  }, t.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, t.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    var e = this._media.context, o = this._media.parent;\n    this._source.loop = this._loop || o.loop;\n    var T = e.volume * (e.muted ? 0 : 1), S = o.volume * (o.muted ? 0 : 1), N = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = N * T * S, this._source.playbackRate = this._speed * e.speed * o.speed;\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, o = this._media.parent, T = this._paused || o.paused || e.paused;\n    T !== this._pausedReal && (this._pausedReal = T, T ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", T));\n  }, t.prototype.play = function(e) {\n    var o = this, T = e.start, S = e.end, N = e.speed, D = e.loop, B = e.volume, $ = e.muted;\n    this._speed = N, this._volume = B, this._loop = !!D, this._muted = $, this.refresh(), this.loop && S !== null && (this.loop = !1), this._start = T, this._end = S || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      o._source && (o._source.currentTime = T, o._source.onloadedmetadata = null, o.emit(\"progress\", T, o._duration), Ticker.shared.add(o._onUpdate, o));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, t.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, t.prototype._onComplete = function() {\n    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t.prototype.destroy = function() {\n    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var e = this._source;\n    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, t.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, t.PADDING = 0.1, t;\n}(i$1), b = function(r) {\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  return c(t, r), t.prototype.init = function(e) {\n    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);\n  }, t.prototype.create = function() {\n    return new g(this);\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(t.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {\n    var o = this._source, T = this.parent;\n    if (o.readyState !== 4)\n      if (T.url) {\n        o.src = T.url;\n        var S = function() {\n          B(), T.isLoaded = !0;\n          var U = T.autoPlayStart();\n          e && e(null, T, U);\n        }, N = function() {\n          B(), e && e(new Error(\"Sound loading has been aborted\"));\n        }, D = function() {\n          B();\n          var U = \"Failed to load audio element (code: \".concat(o.error.code, \")\");\n          e && e(new Error(U));\n        }, B = function() {\n          o.removeEventListener(\"canplaythrough\", S), o.removeEventListener(\"load\", S), o.removeEventListener(\"abort\", N), o.removeEventListener(\"error\", D);\n        };\n        o.addEventListener(\"canplaythrough\", S, !1), o.addEventListener(\"load\", S, !1), o.addEventListener(\"abort\", N, !1), o.addEventListener(\"error\", D, !1), o.load();\n      } else\n        e(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      T.isLoaded = !0;\n      var $ = T.autoPlayStart();\n      e && setTimeout(function() {\n        e(null, T, $);\n      }, 0);\n    }\n  }, t;\n}(i$1), v = function() {\n  function r(t, e) {\n    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return r.prototype.play = function(t) {\n    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, r.prototype.destroy = function() {\n    this.parent = null;\n  }, r;\n}(), P = function() {\n  function r() {\n  }\n  return r.setParamValue = function(t, e) {\n    if (t.setValueAtTime) {\n      var o = u().context;\n      t.setValueAtTime(e, o.audioContext.currentTime);\n    } else\n      t.value = e;\n    return e;\n  }, r;\n}(), x = 0, O = function(r) {\n  function t(e) {\n    var o = r.call(this) || this;\n    return o.id = x++, o._media = null, o._paused = !1, o._muted = !1, o._elapsed = 0, o.init(e), o;\n  }\n  return c(t, r), t.prototype.set = function(e, o) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = o;\n        break;\n      case \"volume\":\n        this.volume = o;\n        break;\n      case \"muted\":\n        this.muted = o;\n        break;\n      case \"loop\":\n        this.loop = o;\n        break;\n      case \"paused\":\n        this.paused = o;\n    }\n    return this;\n  }, t.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh(), this._update(!0);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(e) {\n    var o;\n    this._filters && ((o = this._filters) === null || o === void 0 || o.filter(function(T) {\n      return T;\n    }).forEach(function(T) {\n      return T.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    if (this._source) {\n      var e = this._media.context, o = this._media.parent;\n      this._source.loop = this._loop || o.loop;\n      var T = e.volume * (e.muted ? 0 : 1), S = o.volume * (o.muted ? 0 : 1), N = this._volume * (this._muted ? 0 : 1);\n      P.setParamValue(this._gain.gain, N * S * T), P.setParamValue(this._source.playbackRate, this._speed * o.speed * e.speed), this.applyFilters();\n    }\n  }, t.prototype.applyFilters = function() {\n    var e;\n    if (!((e = this._filters) === null || e === void 0) && e.length) {\n      this._source.disconnect();\n      var o = this._source;\n      this._filters.forEach(function(T) {\n        o.connect(T.destination), o = T;\n      }), o.connect(this._gain);\n    }\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, o = this._media.parent, T = this._paused || o.paused || e.paused;\n    T !== this._pausedReal && (this._pausedReal = T, T ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", T));\n  }, t.prototype.play = function(e) {\n    var o = e.start, T = e.end, S = e.speed, N = e.loop, D = e.volume, B = e.muted, $ = e.filters;\n    this._paused = !1;\n    var U = this._media.nodes.cloneBufferSource(), z = U.source, V = U.gain;\n    this._source = z, this._gain = V, this._speed = S, this._volume = D, this._loop = !!N, this._muted = B, this._filters = $, this.refresh();\n    var X = this._source.buffer.duration;\n    this._duration = X, this._end = T, this._lastUpdate = this._now(), this._elapsed = o, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = T, this._source.loopStart = o, this._source.start(0, o)) : T ? this._source.start(0, o, T - o) : this._source.start(0, o), this.emit(\"start\"), this._update(!0), this.enableTicker(!0);\n  }, t.prototype.enableTicker = function(e) {\n    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    var e;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(o) {\n      return o.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;\n  }, t.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, t.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, t.prototype._updateListener = function() {\n    this._update();\n  }, t.prototype._update = function(e) {\n    if (e === void 0 && (e = !1), this._source) {\n      var o = this._now(), T = o - this._lastUpdate;\n      if (T > 0 || e) {\n        var S = this._source.playbackRate.value;\n        this._elapsed += T * S, this._lastUpdate = o;\n        var N = this._duration, D = void 0;\n        if (this._source.loopStart) {\n          var B = this._source.loopEnd - this._source.loopStart;\n          D = (this._source.loopStart + this._elapsed % B) / N;\n        } else\n          D = this._elapsed % N / N;\n        this._progress = D, this.emit(\"progress\", this._progress, N);\n      }\n    }\n  }, t.prototype.init = function(e) {\n    this._media = e, e.context.events.on(\"refresh\", this.refresh, this), e.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, t.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n      this._source = null;\n    }\n  }, t.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t;\n}(i$1), j = function() {\n  function r(t, e) {\n    this._output = e, this._input = t;\n  }\n  return Object.defineProperty(r.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(T) {\n      T && T.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t && t.length) {\n      this._filters = t.slice(0), this._input.disconnect();\n      var o = null;\n      t.forEach(function(T) {\n        o === null ? e._input.connect(T.destination) : o.connect(T.destination), o = T;\n      }), o.connect(this._output);\n    }\n  }, enumerable: !1, configurable: !0 }), r.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, r;\n}(), w = function(r) {\n  function t(e) {\n    var o = this, T = e.audioContext, S = T.createBufferSource(), N = T.createGain(), D = T.createAnalyser();\n    return S.connect(D), D.connect(N), N.connect(e.destination), (o = r.call(this, D, N) || this).context = e, o.bufferSource = S, o.gain = N, o.analyser = D, o;\n  }\n  return c(t, r), Object.defineProperty(t.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    r.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, t.prototype.cloneBufferSource = function() {\n    var e = this.bufferSource, o = this.context.audioContext.createBufferSource();\n    o.buffer = e.buffer, P.setParamValue(o.playbackRate, e.playbackRate.value), o.loop = e.loop;\n    var T = this.context.audioContext.createGain();\n    return o.connect(T), T.connect(this.destination), { source: o, gain: T };\n  }, Object.defineProperty(t.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;\n}(j), A = function() {\n  function r() {\n  }\n  return r.prototype.init = function(t) {\n    this.parent = t, this._nodes = new w(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;\n  }, r.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch {\n    }\n    this._source = null, this.source = null;\n  }, r.prototype.create = function() {\n    return new O(this);\n  }, Object.defineProperty(r.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t) {\n    this._nodes.filters = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t) {\n    this._source.buffer = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: !1, configurable: !0 }), r.prototype.load = function(t) {\n    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error(\"sound.url or sound.source must be set\"));\n  }, r.prototype._loadUrl = function(t) {\n    var e = this, o = new XMLHttpRequest(), T = this.parent.url;\n    o.open(\"GET\", T, !0), o.responseType = \"arraybuffer\", o.onload = function() {\n      e.source = o.response, e._decode(o.response, t);\n    }, o.send();\n  }, r.prototype._decode = function(t, e) {\n    var o = this, T = function(S, N) {\n      if (S)\n        e && e(S);\n      else {\n        o.parent.isLoaded = !0, o.buffer = N;\n        var D = o.parent.autoPlayStart();\n        e && e(null, o.parent, D);\n      }\n    };\n    t instanceof AudioBuffer ? T(null, t) : this.parent.context.decode(t, T);\n  }, r;\n}(), F = function() {\n  function r(t, e) {\n    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var o = e.complete;\n    this._autoPlayOptions = o ? { complete: o } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return r.from = function(t) {\n    var e = {};\n    return typeof t == \"string\" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = l({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = _(e.url)), Object.freeze(e), new r(u().useLegacy ? new b() : new A(), e);\n  }, Object.defineProperty(r.prototype, \"context\", { get: function() {\n    return u().context;\n  }, enumerable: !1, configurable: !0 }), r.prototype.pause = function() {\n    return this.isPlaying = !1, this.paused = !0, this;\n  }, r.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;\n  }, Object.defineProperty(r.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t) {\n    this._paused = t, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t) {\n    this._speed = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t) {\n    this.media.filters = t;\n  }, enumerable: !1, configurable: !0 }), r.prototype.addSprites = function(t, e) {\n    if (typeof t == \"object\") {\n      var o = {};\n      for (var T in t)\n        o[T] = this.addSprites(T, t[T]);\n      return o;\n    }\n    var S = new v(this, e);\n    return this._sprites[t] = S, S;\n  }, r.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, r.prototype.removeSprites = function(t) {\n    if (t) {\n      var e = this._sprites[t];\n      e !== void 0 && (e.destroy(), delete this._sprites[t]);\n    } else\n      for (var o in this._sprites)\n        this.removeSprites(o);\n    return this;\n  }, Object.defineProperty(r.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: !1, configurable: !0 }), r.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = !1, this._autoPlayOptions = null, this;\n    this.isPlaying = !1;\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._instances[t].stop();\n    return this;\n  }, r.prototype.play = function(t, e) {\n    var o, T = this;\n    if (typeof t == \"string\" ? o = { sprite: N = t, loop: this.loop, complete: e } : typeof t == \"function\" ? (o = {}).complete = t : o = t, (o = l({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, o || {})).sprite) {\n      var S = o.sprite, N = this._sprites[S];\n      o.start = N.start + (o.start || 0), o.end = N.end, o.speed = N.speed || 1, o.loop = N.loop || o.loop, delete o.sprite;\n    }\n    if (o.offset && (o.start = o.offset), !this.isLoaded)\n      return new Promise(function(B, $) {\n        T.autoPlay = !0, T._autoPlayOptions = o, T._preload(function(U, z, V) {\n          U ? $(U) : (o.loaded && o.loaded(U, z, V), B(V));\n        });\n      });\n    (this.singleInstance || o.singleInstance) && this._removeInstances();\n    var D = this._createInstance();\n    return this._instances.push(D), this.isPlaying = !0, D.once(\"end\", function() {\n      o.complete && o.complete(T), T._onComplete(D);\n    }), D.once(\"stop\", function() {\n      T._onComplete(D);\n    }), D.play(o), D;\n  }, r.prototype.refresh = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refresh();\n  }, r.prototype.refreshPaused = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(r.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t) {\n    this._volume = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t) {\n    this._muted = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t) {\n    this._loop = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), r.prototype._preload = function(t) {\n    this.media.load(t);\n  }, Object.defineProperty(r.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: !1, configurable: !0 }), r.prototype.autoPlayStart = function() {\n    var t;\n    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;\n  }, r.prototype._removeInstances = function() {\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._poolInstance(this._instances[t]);\n    this._instances.length = 0;\n  }, r.prototype._onComplete = function(t) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t);\n  }, r.prototype._createInstance = function() {\n    if (r._pool.length > 0) {\n      var t = r._pool.pop();\n      return t.init(this.media), t;\n    }\n    return this.media.create();\n  }, r.prototype._poolInstance = function(t) {\n    t.destroy(), r._pool.indexOf(t) < 0 && r._pool.push(t);\n  }, r._pool = [], r;\n}(), C = function(r) {\n  function t() {\n    var e = r !== null && r.apply(this, arguments) || this;\n    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;\n  }\n  return c(t, r), t.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, t.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, t;\n}(i$1), E = function(r) {\n  function t() {\n    var e = this, o = window, T = new t.AudioContext(), S = T.createDynamicsCompressor(), N = T.createAnalyser();\n    return N.connect(S), S.connect(T.destination), (e = r.call(this, N, S) || this)._ctx = T, e._offlineCtx = new t.OfflineAudioContext(1, 2, o.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, T.sampleRate)) : 44100), e._unlocked = !1, e.compressor = S, e.analyser = N, e.events = new i$1(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, T.state !== \"running\" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener(\"mousedown\", e._unlock, !0), document.addEventListener(\"touchstart\", e._unlock, !0), document.addEventListener(\"touchend\", e._unlock, !0)), e;\n  }\n  return c(t, r), t.prototype._unlock = function() {\n    this._unlocked || (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, !0), document.removeEventListener(\"touchend\", this._unlock, !0), document.removeEventListener(\"touchstart\", this._unlock, !0), this._unlocked = !0));\n  }, t.prototype.playEmptySound = function() {\n    var e = this._ctx.createBufferSource();\n    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === \"suspended\" && e.context.resume();\n  }, Object.defineProperty(t, \"AudioContext\", { get: function() {\n    var e = window;\n    return e.AudioContext || e.webkitAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, \"OfflineAudioContext\", { get: function() {\n    var e = window;\n    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    r.prototype.destroy.call(this);\n    var e = this._ctx;\n    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    e && this._ctx.state === \"running\" ? this._ctx.suspend() : e || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = e;\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, t.prototype.decode = function(e, o) {\n    var T = function(N) {\n      o(new Error((N == null ? void 0 : N.message) || \"Unable to decode file\"));\n    }, S = this._offlineCtx.decodeAudioData(e, function(N) {\n      o(null, N);\n    }, T);\n    S && S.catch(T);\n  }, t;\n}(j), L = function() {\n  function r() {\n    this.init();\n  }\n  return r.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new E()), this._htmlAudioContext = new C(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(r.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t) {\n    this.useLegacy || (this._context.filters = t);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"supported\", { get: function() {\n    return E.AudioContext !== null;\n  }, enumerable: !1, configurable: !0 }), r.prototype.add = function(t, e) {\n    if (typeof t == \"object\") {\n      var o = {};\n      for (var T in t) {\n        var S = this._getOptions(t[T], e);\n        o[T] = this.add(T, S);\n      }\n      return o;\n    }\n    if (e instanceof F)\n      return this._sounds[t] = e, e;\n    var N = this._getOptions(e), D = F.from(N);\n    return this._sounds[t] = D, D;\n  }, r.prototype._getOptions = function(t, e) {\n    var o;\n    return o = typeof t == \"string\" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, o = l(l({}, o), e || {});\n  }, Object.defineProperty(r.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t) {\n    y.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: !1, configurable: !0 }), r.prototype.remove = function(t) {\n    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;\n  }, Object.defineProperty(r.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t) {\n    this._context.volume = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(r.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t) {\n    this._context.speed = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), r.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, r.prototype.pauseAll = function() {\n    return this._context.paused = !0, this._context.refreshPaused(), this;\n  }, r.prototype.resumeAll = function() {\n    return this._context.paused = !1, this._context.refreshPaused(), this;\n  }, r.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, r.prototype.muteAll = function() {\n    return this._context.muted = !0, this._context.refresh(), this;\n  }, r.prototype.unmuteAll = function() {\n    return this._context.muted = !1, this._context.refresh(), this;\n  }, r.prototype.removeAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].destroy(), delete this._sounds[t];\n    return this;\n  }, r.prototype.stopAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].stop();\n    return this;\n  }, r.prototype.exists = function(t, e) {\n    return !!this._sounds[t];\n  }, r.prototype.find = function(t) {\n    return this.exists(t, !0), this._sounds[t];\n  }, r.prototype.play = function(t, e) {\n    return this.find(t).play(e);\n  }, r.prototype.stop = function(t) {\n    return this.find(t).stop();\n  }, r.prototype.pause = function(t) {\n    return this.find(t).pause();\n  }, r.prototype.resume = function(t) {\n    return this.find(t).resume();\n  }, r.prototype.volume = function(t, e) {\n    var o = this.find(t);\n    return e !== void 0 && (o.volume = e), o.volume;\n  }, r.prototype.speed = function(t, e) {\n    var o = this.find(t);\n    return e !== void 0 && (o.speed = e), o.speed;\n  }, r.prototype.duration = function(t) {\n    return this.find(t).duration;\n  }, r.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, r;\n}(), k = function() {\n  function r(t, e) {\n    this.init(t, e);\n  }\n  return r.prototype.init = function(t, e) {\n    this.destination = t, this.source = e || t;\n  }, r.prototype.connect = function(t) {\n    this.source.connect(t);\n  }, r.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, r.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, r;\n}(), M = { __proto__: null, Filter: k, EqualizerFilter: function(r) {\n  function t(e, o, T, S, N, D, B, $, U, z) {\n    e === void 0 && (e = 0), o === void 0 && (o = 0), T === void 0 && (T = 0), S === void 0 && (S = 0), N === void 0 && (N = 0), D === void 0 && (D = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), U === void 0 && (U = 0), z === void 0 && (z = 0);\n    var V = this;\n    if (!u().useLegacy) {\n      var X = [{ f: t.F32, type: \"lowshelf\", gain: e }, { f: t.F64, type: \"peaking\", gain: o }, { f: t.F125, type: \"peaking\", gain: T }, { f: t.F250, type: \"peaking\", gain: S }, { f: t.F500, type: \"peaking\", gain: N }, { f: t.F1K, type: \"peaking\", gain: D }, { f: t.F2K, type: \"peaking\", gain: B }, { f: t.F4K, type: \"peaking\", gain: $ }, { f: t.F8K, type: \"peaking\", gain: U }, { f: t.F16K, type: \"highshelf\", gain: z }].map(function(q) {\n        var Z = u().context.audioContext.createBiquadFilter();\n        return Z.type = q.type, P.setParamValue(Z.Q, 1), Z.frequency.value = q.f, P.setParamValue(Z.gain, q.gain), Z;\n      });\n      (V = r.call(this, X[0], X[X.length - 1]) || this).bands = X, V.bandsMap = {};\n      for (var W = 0; W < V.bands.length; W++) {\n        var Y = V.bands[W];\n        W > 0 && V.bands[W - 1].connect(Y), V.bandsMap[Y.frequency.value] = Y;\n      }\n      return V;\n    }\n    V = r.call(this, null) || this;\n  }\n  return c(t, r), t.prototype.setGain = function(e, o) {\n    if (o === void 0 && (o = 0), !this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    P.setParamValue(this.bandsMap[e].gain, o);\n  }, t.prototype.getGain = function(e) {\n    if (!this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    return this.bandsMap[e].gain.value;\n  }, Object.defineProperty(t.prototype, \"f32\", { get: function() {\n    return this.getGain(t.F32);\n  }, set: function(e) {\n    this.setGain(t.F32, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f64\", { get: function() {\n    return this.getGain(t.F64);\n  }, set: function(e) {\n    this.setGain(t.F64, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f125\", { get: function() {\n    return this.getGain(t.F125);\n  }, set: function(e) {\n    this.setGain(t.F125, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f250\", { get: function() {\n    return this.getGain(t.F250);\n  }, set: function(e) {\n    this.setGain(t.F250, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f500\", { get: function() {\n    return this.getGain(t.F500);\n  }, set: function(e) {\n    this.setGain(t.F500, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f1k\", { get: function() {\n    return this.getGain(t.F1K);\n  }, set: function(e) {\n    this.setGain(t.F1K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f2k\", { get: function() {\n    return this.getGain(t.F2K);\n  }, set: function(e) {\n    this.setGain(t.F2K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f4k\", { get: function() {\n    return this.getGain(t.F4K);\n  }, set: function(e) {\n    this.setGain(t.F4K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f8k\", { get: function() {\n    return this.getGain(t.F8K);\n  }, set: function(e) {\n    this.setGain(t.F8K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f16k\", { get: function() {\n    return this.getGain(t.F16K);\n  }, set: function(e) {\n    this.setGain(t.F16K, e);\n  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {\n    this.bands.forEach(function(e) {\n      P.setParamValue(e.gain, 0);\n    });\n  }, t.prototype.destroy = function() {\n    this.bands.forEach(function(e) {\n      e.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;\n}(k), DistortionFilter: function(r) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var o = this;\n    if (!u().useLegacy) {\n      var T = u().context.audioContext.createWaveShaper();\n      return (o = r.call(this, T) || this)._distortion = T, o.amount = e, o;\n    }\n    o = r.call(this, null) || this;\n  }\n  return c(t, r), Object.defineProperty(t.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(e) {\n    this._amount = e;\n    for (var o, T = 1e3 * e, S = 44100, N = new Float32Array(S), D = Math.PI / 180, B = 0; B < S; ++B)\n      o = 2 * B / S - 1, N[B] = (3 + T) * o * 20 * D / (Math.PI + T * Math.abs(o));\n    this._distortion.curve = N, this._distortion.oversample = \"4x\";\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._distortion = null, r.prototype.destroy.call(this);\n  }, t;\n}(k), StereoFilter: function(r) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var o = this;\n    if (!u().useLegacy) {\n      var T, S, N, D = u().context.audioContext;\n      return D.createStereoPanner ? N = T = D.createStereoPanner() : ((S = D.createPanner()).panningModel = \"equalpower\", N = S), (o = r.call(this, N) || this)._stereo = T, o._panner = S, o.pan = e, o;\n    }\n    o = r.call(this, null) || this;\n  }\n  return c(t, r), Object.defineProperty(t.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(e) {\n    this._pan = e, this._stereo ? P.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    r.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, t;\n}(k), ReverbFilter: function(r) {\n  function t(e, o, T) {\n    e === void 0 && (e = 3), o === void 0 && (o = 2), T === void 0 && (T = !1);\n    var S = this;\n    if (!u().useLegacy)\n      return (S = r.call(this, null) || this)._seconds = S._clamp(e, 1, 50), S._decay = S._clamp(o, 0, 100), S._reverse = T, S._rebuild(), S;\n    S = r.call(this, null) || this;\n  }\n  return c(t, r), t.prototype._clamp = function(e, o, T) {\n    return Math.min(T, Math.max(o, e));\n  }, Object.defineProperty(t.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(e) {\n    this._seconds = this._clamp(e, 1, 50), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(e) {\n    this._decay = this._clamp(e, 0, 100), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(e) {\n    this._reverse = e, this._rebuild();\n  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {\n    for (var e, o = u().context.audioContext, T = o.sampleRate, S = T * this._seconds, N = o.createBuffer(2, S, T), D = N.getChannelData(0), B = N.getChannelData(1), $ = 0; $ < S; $++)\n      e = this._reverse ? S - $ : $, D[$] = (2 * Math.random() - 1) * Math.pow(1 - e / S, this._decay), B[$] = (2 * Math.random() - 1) * Math.pow(1 - e / S, this._decay);\n    var U = u().context.audioContext.createConvolver();\n    U.buffer = N, this.init(U);\n  }, t;\n}(k), MonoFilter: function(r) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var o = u().context.audioContext, T = o.createChannelSplitter(), S = o.createChannelMerger();\n      return S.connect(T), (e = r.call(this, S, T) || this)._merger = S, e;\n    }\n    e = r.call(this, null) || this;\n  }\n  return c(t, r), t.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, r.prototype.destroy.call(this);\n  }, t;\n}(k), StreamFilter: function(r) {\n  function t() {\n    var e = this;\n    if (!u().useLegacy) {\n      var o = u().context.audioContext, T = o.createMediaStreamDestination(), S = o.createMediaStreamSource(T.stream);\n      return (e = r.call(this, T, S) || this)._stream = T.stream, e;\n    }\n    e = r.call(this, null) || this;\n  }\n  return c(t, r), Object.defineProperty(t.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._stream = null, r.prototype.destroy.call(this);\n  }, t;\n}(k), TelephoneFilter: function(r) {\n  function t() {\n    if (!u().useLegacy) {\n      var e = u().context.audioContext, o = e.createBiquadFilter(), T = e.createBiquadFilter(), S = e.createBiquadFilter(), N = e.createBiquadFilter();\n      return o.type = \"lowpass\", P.setParamValue(o.frequency, 2e3), T.type = \"lowpass\", P.setParamValue(T.frequency, 2e3), S.type = \"highpass\", P.setParamValue(S.frequency, 500), N.type = \"highpass\", P.setParamValue(N.frequency, 500), o.connect(T), T.connect(S), S.connect(N), r.call(this, o, N) || this;\n    }\n    r.call(this, null);\n  }\n  return c(t, r), t;\n}(k) }, G = 0, I = { __proto__: null, playOnce: function(r, t) {\n  var e = \"alias\".concat(G++);\n  return u().add(e, { url: r, preload: !0, autoPlay: !0, loaded: function(o) {\n    o && (u().remove(e), t && t(o));\n  }, complete: function() {\n    u().remove(e), t && t(null);\n  } }), e;\n}, get PLAY_ID() {\n  return G;\n}, render: function(r, t) {\n  var e = document.createElement(\"canvas\");\n  t = l({ width: 512, height: 128, fill: \"black\" }, t || {}), e.width = t.width, e.height = t.height;\n  var o = BaseTexture.from(e);\n  if (!(r.media instanceof A))\n    return o;\n  var T = r.media, S = e.getContext(\"2d\");\n  S.fillStyle = t.fill;\n  for (var N = T.buffer.getChannelData(0), D = Math.ceil(N.length / t.width), B = t.height / 2, $ = 0; $ < t.width; $++) {\n    for (var U = 1, z = -1, V = 0; V < D; V++) {\n      var X = N[$ * D + V];\n      X < U && (U = X), X > z && (z = X);\n    }\n    S.fillRect($, (1 + U) * B, 1, Math.max(1, (z - U) * B));\n  }\n  return o;\n}, resolveUrl: _, sineTone: function(r, t) {\n  r === void 0 && (r = 200), t === void 0 && (t = 1);\n  var e = F.from({ singleInstance: !0 });\n  if (!(e.media instanceof A))\n    return e;\n  for (var o = e.media, T = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), S = T.getChannelData(0), N = 0; N < S.length; N++) {\n    var D = r * (N / T.sampleRate) * Math.PI;\n    S[N] = 2 * Math.sin(D);\n  }\n  return o.buffer = T, e.isLoaded = !0, e;\n}, validateFormats: f, supported: h, extensions: p }, R = function(r) {\n  return s = r, r;\n}(new L());\n\"extensions\" in n ? extensions.add(y) : Loader.registerPlugin(y);\nvar Se, $e, ki, Vl, Zf, Ms, tl, Xl, Kf, Wl, Jf, vo, Hc, mn, La, go, jc, Ds, Ls, el, yn, Fa, _o, Fs, rl, Yl, Qf, Gr, wi, ql, td, mo, zc, bn, Ba, Zl, ed, yo, Vc, Kl, rd, Jl, id, Bs, il;\nconst Wa = class {\n  constructor(t, e, o, T, S) {\n    rt(this, Vl);\n    rt(this, Ms);\n    rt(this, Xl);\n    rt(this, Wl);\n    rt(this, vo);\n    rt(this, mn);\n    rt(this, go);\n    rt(this, Ls);\n    rt(this, yn);\n    rt(this, Fs);\n    rt(this, Yl);\n    rt(this, Gr);\n    rt(this, ql);\n    rt(this, mo);\n    rt(this, bn);\n    rt(this, Zl);\n    rt(this, yo);\n    rt(this, Kl);\n    rt(this, Jl);\n    rt(this, Bs);\n    rt(this, Se, {});\n    rt(this, $e, {});\n    rt(this, ki, void 0);\n    rt(this, _o, () => {\n      R.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1)), nt(this, _o, () => {\n      });\n    });\n    this.cfg = t, this.val = o, this.main = T, this.sys = S, e.volume = (N) => ot(this, Vl, Zf).call(this, N), e.fadebgm = (N) => ot(this, vo, Hc).call(this, N), e.fadeoutbgm = (N) => ot(this, Xl, Kf).call(this, N), e.fadeoutse = (N) => ot(this, Wl, Jf).call(this, N), e.fadese = (N) => ot(this, mn, La).call(this, N), e.playbgm = (N) => ot(this, go, jc).call(this, N), e.playse = (N) => ot(this, Ls, el).call(this, N), e.stop_allse = () => ot(this, Fs, rl).call(this), e.stopbgm = (N) => ot(this, Yl, Qf).call(this, N), e.stopse = (N) => ot(this, Gr, wi).call(this, N), e.wb = (N) => ot(this, ql, td).call(this, N), e.wf = (N) => ot(this, mo, zc).call(this, N), e.stopfadese = (N) => ot(this, bn, Ba).call(this, N), e.wl = (N) => ot(this, Zl, ed).call(this, N), e.ws = (N) => ot(this, yo, Vc).call(this, N), e.xchgbuf = (N) => ot(this, Kl, rd).call(this, N), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\"), o.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(I.supported));\n  }\n  setEvtMng(t) {\n    nt(this, ki, t);\n  }\n  setNoticeChgVolume(t, e) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (o, T) => t(R.volumeAll = Number(T))), this.val.defValTrg(\"sys:sn.sound.movie_volume\", (o, T) => e(Number(T))), this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1)), this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    R.removeAll();\n  }\n  loadAheadSnd(t) {\n    const { clickse: e, enterse: o, leavese: T } = t;\n    for (const S of [e, o, T])\n      !S || R.exists(S) || ot(this, yn, Fa).call(this, \"\", S, { preload: !0, autoPlay: !1 });\n  }\n  playLoopFromSaveObj() {\n    const t = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    if (this.val.flush(), t === \"{}\") {\n      ot(this, Fs, rl).call(this);\n      return;\n    }\n    nt(this, $e, JSON.parse(t));\n    const e = Object.keys(H(this, $e)).map((o) => () => {\n      const T = \"save:const.sn.sound.\" + o + \".\", S = {\n        fn: String(this.val.getVal(T + \"fn\")),\n        buf: o,\n        join: !1,\n        loop: !0,\n        volume: Number(this.val.getVal(T + \"volume\")),\n        start_ms: Number(this.val.getVal(T + \"start_ms\")),\n        end_ms: Number(this.val.getVal(T + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(T + \"ret_ms\"))\n      };\n      S.buf === \"BGM\" ? ot(this, go, jc).call(this, S) : ot(this, Ls, el).call(this, S);\n    });\n    ot(this, Fs, rl).call(this);\n    for (const o of e)\n      o();\n  }\n};\nlet SoundMng = Wa;\nSe = new WeakMap(), $e = new WeakMap(), ki = new WeakMap(), Vl = new WeakSet(), Zf = function(t) {\n  const { buf: e = \"SE\" } = t, o = \"const.sn.sound.\" + e + \".volume\", T = ot(this, Ms, tl).call(this, t, 1);\n  return Number(this.val.getVal(\"sys:\" + o)) === T ? !1 : (this.val.setVal_Nochk(\"sys\", o, T), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal(\"save:\" + o)), ot(this, mn, La).call(this, t));\n}, Ms = new WeakSet(), tl = function(t, e) {\n  const o = argChk_Num(t, \"volume\", e);\n  return o < 0 ? 0 : o > 1 ? 1 : o;\n}, Xl = new WeakSet(), Kf = function(t) {\n  return t.volume = 0, ot(this, vo, Hc).call(this, t);\n}, Wl = new WeakSet(), Jf = function(t) {\n  return t.volume = 0, ot(this, mn, La).call(this, t);\n}, vo = new WeakSet(), Hc = function(t) {\n  return t.buf = \"BGM\", ot(this, mn, La).call(this, t);\n}, mn = new WeakSet(), La = function(t) {\n  ot(this, bn, Ba).call(this, t);\n  const { buf: e = \"SE\" } = t, o = H(this, Se)[e];\n  if (!(o != null && o.playing()) || !o.snd)\n    return !1;\n  const T = \"const.sn.sound.\" + e + \".volume\", S = ot(this, Ms, tl).call(this, t, NaN);\n  this.val.setVal_Nochk(\"save\", T, S);\n  const N = S * Number(this.val.getVal(\"sys:\" + T, 1)), D = argChk_Boolean(t, \"stop\", S === 0);\n  D && (ot(this, Bs, il).call(this, e), this.val.setVal_Nochk(\"save\", \"const.sn.sound.\" + e + \".fn\", \"\")), this.val.flush();\n  const B = argChk_Num(t, \"time\", NaN), $ = argChk_Num(t, \"delay\", 0);\n  if (B === 0 && $ === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, ki).isSkippingByKeyDown())\n    return o.snd.volume = N, D && ot(this, Gr, wi).call(this, t), !1;\n  const U = argChk_Num(t, \"repeat\", 1);\n  return o.twFade = new Tween({ v: o.snd.volume }).to({ v: N }, B).delay($).easing(CmnTween.ease(t.ease)).repeat(U === 0 ? 1 / 0 : U - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onUpdate((z) => {\n    o.playing() && (o.snd.volume = z.v);\n  }).onComplete(() => {\n    const z = H(this, Se)[t.buf = o.now_buf];\n    !(z != null && z.twFade) || (delete z.twFade, D && ot(this, Gr, wi).call(this, t), z.resumeFade && this.main.resume());\n  }).start(), !1;\n}, go = new WeakSet(), jc = function(t) {\n  return t.buf = \"BGM\", t.canskip = !1, argChk_Boolean(t, \"loop\", !0), ot(this, Ls, el).call(this, t);\n}, Ds = new WeakMap(), Ls = new WeakSet(), el = function(t) {\n  var Z;\n  const { buf: e = \"SE\", fn: o } = t;\n  if (ot(this, Gr, wi).call(this, { buf: e }), !o)\n    throw `[playse] fn\\u306F\\u5FC5\\u9808\\u3067\\u3059 buf:${e}`;\n  if (argChk_Boolean(t, \"canskip\", !0) && H(this, ki).isSkippingByKeyDown())\n    return !1;\n  const T = argChk_Boolean(t, \"loop\", !1);\n  ot(this, Jl, id).call(this, e, T);\n  const S = \"const.sn.sound.\" + e + \".\";\n  this.val.setVal_Nochk(\"save\", S + \"fn\", o);\n  const N = ot(this, Ms, tl).call(this, t, 1);\n  this.val.setVal_Nochk(\"save\", S + \"volume\", N);\n  const D = N * Number(this.val.getVal(\"sys:\" + S + \"volume\", 1)), B = argChk_Num(t, \"start_ms\", 0), $ = argChk_Num(t, \"end_ms\", H(Wa, Ds)), U = argChk_Num(t, \"ret_ms\", 0), z = argChk_Num(t, \"pan\", 0);\n  if (B < 0)\n    throw `[playse] start_ms:${B} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if (U < 0)\n    throw `[playse] ret_ms:${U} \\u304C\\u8CA0\\u306E\\u5024\\u3067\\u3059`;\n  if ($ > 0) {\n    if (B >= $)\n      throw `[playse] start_ms:${B} >= end_ms:${$} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n    if (U >= $)\n      throw `[playse] ret_ms:${U} >= end_ms:${$} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n  }\n  this.val.setVal_Nochk(\"save\", S + \"start_ms\", B), this.val.setVal_Nochk(\"save\", S + \"end_ms\", $), this.val.setVal_Nochk(\"save\", S + \"ret_ms\", U), this.val.flush();\n  const V = R.find(o), X = H(this, Se)[e] = {\n    now_buf: e,\n    snd: V,\n    loop: T,\n    start_ms: B,\n    end_ms: $,\n    ret_ms: U,\n    resume: !1,\n    pan: z,\n    playing: () => !0,\n    onend: () => {\n      const K = H(this, Se)[t.buf = X.now_buf];\n      !K || (delete H(this, Se)[t.buf], K.playing = () => !1, ot(this, bn, Ba).call(this, t), K.resume && this.main.resume());\n    }\n  }, W = {\n    loop: T,\n    volume: D,\n    loaded: (K, J) => {\n      if (K) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059a fn:${o} ${K}`, !1);\n        return;\n      }\n      if (!J)\n        return;\n      const tt = H(this, Se)[X.now_buf];\n      tt && (tt.snd = J);\n    }\n  };\n  \"speed\" in t && (W.speed = argChk_Num(t, \"speed\", 1));\n  let Y = \"\";\n  if (B > 0 || $ < H(Wa, Ds)) {\n    Y = `${o};${B};${$};${U}`;\n    const K = ((Z = W.sprites) != null ? Z : W.sprites = {})[Y] = {\n      start: B / 1e3,\n      end: $ / 1e3\n    };\n    W.preload = !0;\n    const J = W.loaded;\n    W.loaded = (tt, et) => {\n      if (tt) {\n        this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059b fn:${o} ${tt}`, !1);\n        return;\n      }\n      if (!et)\n        return;\n      const Q = et.duration;\n      if (J == null || J(tt, et), K.end < 0) {\n        if (K.end += Q, et.removeSprites(Y), et.addSprites(Y, K), K.start >= K.end)\n          throw `[playse] start_ms:${B} >= end_ms:${$}(${K.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n        if (U >= K.end * 1e3)\n          throw `[playse] ret_ms:${U} >= end_ms:${$}(${K.end * 1e3}) \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      }\n      if (K.start >= Q)\n        throw `[playse] start_ms:${B} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${Q} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      if ($ !== H(Wa, Ds) && K.end >= Q)\n        throw `[playse] end_ms:${$} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${Q} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n      et.play(Y, W.complete);\n    };\n  } else\n    W.autoPlay = !0;\n  if (T ? U !== 0 && (W.loop = !1, W.complete = (K) => {\n    const J = K.duration, tt = `${o};loop2;${$};${U}`, et = {\n      preload: !0,\n      loop: !0,\n      volume: D,\n      speed: W.speed,\n      sprites: {},\n      loaded: (at, it) => {\n        if (!it)\n          return;\n        const st = H(this, Se)[X.now_buf];\n        st && (st.snd = it), it.play(tt);\n      }\n    }, Q = et.sprites[tt] = {\n      start: U / 1e3,\n      end: $ / 1e3\n    };\n    if (Q.end < 0 && (Q.end += J, K.removeSprites(tt), K.addSprites(tt, Q)), Q.start >= J)\n      throw `[playse] ret_ms:${U} >= \\u97F3\\u58F0\\u30D5\\u30A1\\u30A4\\u30EB\\u518D\\u751F\\u6642\\u9593:${J} \\u306F\\u7570\\u5E38\\u5024\\u3067\\u3059`;\n    ot(this, yn, Fa).call(this, e, o, et);\n  }) : W.complete = () => {\n    var K;\n    return (K = H(this, Se)[X.now_buf]) == null ? void 0 : K.onend();\n  }, H(this, _o).call(this), V) {\n    if (V.volume = D, Y)\n      ot(this, yn, Fa).call(this, e, o, W);\n    else if (V.isPlayable) {\n      const K = V.options.source;\n      !(K instanceof ArrayBuffer) || K.byteLength === 0 ? V.play(W) : X.snd = F.from({\n        ...W,\n        url: V.options.url,\n        source: K\n      }), V.filters = [new M.StereoFilter(z)];\n    }\n    return !1;\n  }\n  const q = argChk_Boolean(t, \"join\", !0);\n  if (q) {\n    const K = W.loaded;\n    W.loaded = (J, tt) => {\n      K == null || K(J, tt), this.main.resume();\n    };\n  }\n  return ot(this, yn, Fa).call(this, e, o, W), q;\n}, yn = new WeakSet(), Fa = function(t, e, o) {\n  const T = this.cfg.searchPath(e, SEARCH_PATH_ARG_EXT.SOUND);\n  if (T.slice(-4) !== \".bin\") {\n    o.url = T;\n    const S = F.from(o);\n    if (t) {\n      const N = H(this, Se)[t];\n      N.snd = S, N.pan !== 0 && (S.filters = [new M.StereoFilter(N.pan)]);\n    }\n    o.loop || R.add(e, S);\n    return;\n  }\n  new Loader().add({ name: e, url: T, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((S, N) => {\n    this.sys.dec(S.extension, S.data).then((D) => {\n      S.data = D, N == null || N();\n    }).catch((D) => this.main.errScript(`Sound \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${S.name} ${D}`, !1));\n  }).load((S, N) => {\n    var B;\n    o.source = (B = N[e]) == null ? void 0 : B.data;\n    const D = F.from(o);\n    if (t) {\n      const $ = H(this, Se)[t];\n      $.snd = D, $.pan !== 0 && (D.filters = [new M.StereoFilter($.pan)]);\n    }\n    o.loop || R.add(e, D);\n  });\n}, _o = new WeakMap(), Fs = new WeakSet(), rl = function() {\n  for (const t of Object.keys(H(this, Se)))\n    ot(this, Gr, wi).call(this, { buf: t });\n  return nt(this, Se, {}), R.stopAll(), !1;\n}, Yl = new WeakSet(), Qf = function(t) {\n  return t.buf = \"BGM\", ot(this, Gr, wi).call(this, t);\n}, Gr = new WeakSet(), wi = function(t) {\n  var T;\n  const { buf: e = \"SE\" } = t;\n  ot(this, Bs, il).call(this, e);\n  const o = H(this, Se)[e];\n  return o && ((T = o.snd) == null || T.stop(), o.onend()), !1;\n}, ql = new WeakSet(), td = function(t) {\n  return t.buf = \"BGM\", ot(this, mo, zc).call(this, t);\n}, mo = new WeakSet(), zc = function(t) {\n  const { buf: e = \"SE\" } = t, o = H(this, Se)[e];\n  return !(o != null && o.twFade) || !o.playing() ? !1 : o.resumeFade = H(this, ki).waitEvent(\n    () => ot(this, bn, Ba).call(this, t),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, bn = new WeakSet(), Ba = function(t) {\n  var o, T;\n  const { buf: e = \"SE\" } = t;\n  return (T = (o = H(this, Se)[e]) == null ? void 0 : o.twFade) == null || T.stop().end(), !1;\n}, Zl = new WeakSet(), ed = function(t) {\n  return t.buf = \"BGM\", ot(this, yo, Vc).call(this, t);\n}, yo = new WeakSet(), Vc = function(t) {\n  const { buf: e = \"SE\" } = t, o = H(this, Se)[e];\n  return !(o != null && o.playing()) || o.loop ? !1 : o.resume = H(this, ki).waitEvent(\n    () => {\n      t.buf = o.now_buf, ot(this, Gr, wi).call(this, t);\n      const T = H(this, Se)[t.buf];\n      !(T != null && T.playing()) || T.loop || T.onend();\n    },\n    argChk_Boolean(t, \"canskip\", !1),\n    argChk_Boolean(t, \"global\", !1)\n  );\n}, Kl = new WeakSet(), rd = function(t) {\n  const { buf: e = \"SE\", buf2: o = \"SE\" } = t;\n  if (e === o)\n    return !1;\n  const T = H(this, Se)[e];\n  T && (T.now_buf = o);\n  const S = H(this, Se)[o];\n  S && (S.now_buf = e), [H(this, Se)[e], H(this, Se)[o]] = [S, T];\n  const N = \"const.sn.sound.\" + e + \".\", D = Number(this.val.getVal(\"save:\" + N + \"volume\")), B = Number(this.val.getVal(\"save:\" + N + \"fn\")), $ = \"const.sn.sound.\" + o + \".\", U = Number(this.val.getVal(\"save:\" + $ + \"volume\")), z = Number(this.val.getVal(\"save:\" + $ + \"fn\"));\n  return this.val.setVal_Nochk(\"save\", N + \"volume\", U), this.val.setVal_Nochk(\"save\", $ + \"volume\", D), this.val.setVal_Nochk(\"save\", N + \"fn\", z), this.val.setVal_Nochk(\"save\", $ + \"fn\", B), e in H(this, $e) == o in H(this, $e) && (e in H(this, $e) ? (delete H(this, $e)[e], H(this, $e)[o] = 0) : (delete H(this, $e)[o], H(this, $e)[e] = 0), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e)))), this.val.flush(), !1;\n}, Jl = new WeakSet(), id = function(t, e) {\n  if (!e) {\n    ot(this, Bs, il).call(this, t);\n    return;\n  }\n  H(this, $e)[t] = 0, this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e))), this.val.flush();\n}, Bs = new WeakSet(), il = function(t) {\n  delete H(this, $e)[t], this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(H(this, $e))), this.val.flush();\n}, rt(SoundMng, Ds, 999e3);\nvar fe;\nconst Rf = class {\n  constructor(t, e, o, T, S, N, D, B) {\n    rt(this, fe, void 0);\n    Pt(this, \"lay\", (t) => this.getPage(t).lay(t));\n    Pt(this, \"getPage\", (t) => Rf.argChk_page(t, \"fore\") !== \"back\" ? H(this, fe).fore : H(this, fe).back);\n    this.cls = e, this.hArg = S, this.sys = N, this.val = D, this.ret = B;\n    const $ = N.hFactoryCls[e];\n    if (!$)\n      throw `\\u5C5E\\u6027 class\\u3010${e}\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059`;\n    nt(this, fe, { fore: $(), back: $() }), H(this, fe).fore.layname = H(this, fe).back.layname = t;\n    const U = S[\":id_tag\"] = `layer:${t} cls:${e}`;\n    H(this, fe).fore.name = `${U} page:A`, H(this, fe).back.name = `${U} page:B`, o.addChild(this.fore.spLay), T.addChild(this.back.spLay), argChk_Boolean(S, \"visible\", !0), argChk_Boolean(S, \"visible\", !0), B.isWait = this.fore.lay(S) || this.back.lay(S);\n    const z = `const.sn.lay.${t}`;\n    D.setVal_Nochk(\"tmp\", z, !0), D.defTmp(z + \".fore.alpha\", () => H(this, fe).fore.alpha), D.defTmp(z + \".back.alpha\", () => H(this, fe).back.alpha), D.defTmp(z + \".fore.height\", () => H(this, fe).fore.height), D.defTmp(z + \".back.height\", () => H(this, fe).back.height), D.defTmp(z + \".fore.visible\", () => H(this, fe).fore.spLay.visible), D.defTmp(z + \".back.visible\", () => H(this, fe).back.spLay.visible), D.defTmp(z + \".fore.width\", () => H(this, fe).fore.width), D.defTmp(z + \".back.width\", () => H(this, fe).back.width), D.defTmp(z + \".fore.x\", () => H(this, fe).fore.x), D.defTmp(z + \".back.x\", () => H(this, fe).back.x), D.defTmp(z + \".fore.y\", () => H(this, fe).fore.y), D.defTmp(z + \".back.y\", () => H(this, fe).back.y);\n  }\n  destroy() {\n    H(this, fe).fore.destroy(), H(this, fe).back.destroy();\n  }\n  static argChk_page(t, e) {\n    var T;\n    const o = (T = t.page) != null ? T : e;\n    if (o === \"fore\" || o === \"back\")\n      return t.page = o;\n    throw Error(\"\\u5C5E\\u6027 page\\u3010\" + o + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\");\n  }\n  get fore() {\n    return H(this, fe).fore;\n  }\n  get back() {\n    return H(this, fe).back;\n  }\n  transPage(t) {\n    [H(this, fe).back, H(this, fe).fore] = [H(this, fe).fore, H(this, fe).back], H(this, fe).back.copy(H(this, fe).fore, t);\n  }\n};\nlet Pages = Rf;\nfe = new WeakMap();\nvar Ql, th;\nconst Ai = class {\n  constructor() {\n    Pt(this, \"layname\", \"\");\n    Pt(this, \"name_\", \"\");\n    Pt(this, \"spLay\", new Sprite(Texture.EMPTY));\n  }\n  set name(t) {\n    this.name_ = t;\n  }\n  get name() {\n    return this.name_;\n  }\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(t) {\n    this.spLay.alpha = t;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(t) {\n    this.spLay.angle = t;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(t) {\n    this.spLay.scale.x = t;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(t) {\n    this.spLay.scale.y = t;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(t) {\n    this.spLay.x = t;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(t) {\n    this.spLay.y = t;\n  }\n  destroy() {\n  }\n  lay(t) {\n    return \"alpha\" in t && (this.spLay.alpha = argChk_Num(t, \"alpha\", 1)), Ai.setBlendmode(this.spLay, t), (\"pivot_x\" in t || \"pivot_y\" in t) && this.spLay.pivot.set(\n      argChk_Num(t, \"pivot_x\", this.spLay.pivot.x),\n      argChk_Num(t, \"pivot_y\", this.spLay.pivot.y)\n    ), \"rotation\" in t && (this.spLay.angle = argChk_Num(t, \"rotation\", 0)), (\"scale_x\" in t || \"scale_y\" in t) && this.spLay.scale.set(\n      argChk_Num(t, \"scale_x\", this.spLay.scale.x),\n      argChk_Num(t, \"scale_y\", this.spLay.scale.y)\n    ), \"visible\" in t && (this.spLay.visible = argChk_Boolean(t, \"visible\", !0)), !1;\n  }\n  static setBlendmode(t, e) {\n    const { blendmode: o } = e;\n    if (!o)\n      return;\n    const T = Ai.getBlendmodeNum(o);\n    t instanceof Sprite && (t.blendMode = T);\n    for (const S of t.children)\n      S instanceof Sprite && (S.blendMode = T);\n  }\n  static getBlendmodeNum(t) {\n    if (!t)\n      return BLEND_MODES$5.NORMAL;\n    const e = H(Ai, Ql)[t];\n    if (e !== void 0)\n      return e;\n    throw `${t} \\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044 blendmode \\u3067\\u3059`;\n  }\n  static getNum2Blendmode(t) {\n    var e;\n    return (e = H(Ai, th)[t]) != null ? e : \"normal\";\n  }\n  get containMovement() {\n    return !1;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(t) {\n    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES$5.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, \"filter\", !1) && (this.spLay.filters = []);\n  }\n  copy(t, e) {\n    const o = this.name_;\n    this.playback(t.record(), e), this.name = o;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(t, e) {\n    this.name = t.name, this.clearLay({ filter: \"true\" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;\n  }\n  snapshot(t, e) {\n    t.render(this.spLay, { clear: !1 }), e();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(t) {\n  }\n  makeDesignCastChildren(t) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(t, e, o, T = !1, S = !1) {\n    if (e.pos) {\n      Ai.setXYByPos(t, e.pos, o);\n      return;\n    }\n    const N = t.getBounds(), D = o.scale.x < 0 ? -o.scale.x : o.scale.x, B = D === 1 ? N.width : N.width * D, $ = o.scale.y < 0 ? -o.scale.y : o.scale.y, U = $ === 1 ? N.height : N.height * $;\n    let z = o.x;\n    \"left\" in e ? (z = argChk_Num(e, \"left\", 0), z > -1 && z < 1 && (z *= CmnLib.stageW)) : \"center\" in e ? (z = argChk_Num(e, \"center\", 0), z > -1 && z < 1 && (z *= CmnLib.stageW), z = z - (S ? B / 3 : B) / 2) : \"right\" in e ? (z = argChk_Num(e, \"right\", 0), z > -1 && z < 1 && (z *= CmnLib.stageW), z = z - (S ? B / 3 : B)) : \"s_right\" in e && (z = argChk_Num(e, \"s_right\", 0), z > -1 && z < 1 && (z *= CmnLib.stageW), z = CmnLib.stageW - z - (S ? B / 3 : B)), o.x = int(o.scale.x < 0 ? z + (S ? B / 3 : B) : z);\n    let V = o.y;\n    \"top\" in e ? (V = argChk_Num(e, \"top\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH)) : \"middle\" in e ? (V = argChk_Num(e, \"middle\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - U / 2) : \"bottom\" in e ? (V = argChk_Num(e, \"bottom\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = V - U) : \"s_bottom\" in e && (V = argChk_Num(e, \"s_bottom\", 0), V > -1 && V < 1 && (V *= CmnLib.stageH), V = CmnLib.stageH - V - U), o.y = int(o.scale.y < 0 ? V + U : V), T && !(\"left\" in e) && !(\"center\" in e) && !(\"right\" in e) && !(\"s_right\" in e) && !(\"top\" in e) && !(\"middle\" in e) && !(\"bottom\" in e) && !(\"s_bottom\" in e) && Ai.setXYByPos(t, \"c\", o);\n  }\n  static setXYByPos(t, e, o) {\n    if (e === \"stay\")\n      return;\n    if (t === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (o === void 0)\n      throw \"setXYByPos result === undefined\";\n    const T = t.getBounds(), S = o.scale.x < 0 ? -o.scale.x : o.scale.x, N = S === 1 ? T.width : T.width * S, D = o.scale.y < 0 ? -o.scale.y : o.scale.y, B = D === 1 ? T.height : T.height * D;\n    let $ = 0;\n    !e || e === \"c\" ? $ = CmnLib.stageW * 0.5 : e === \"r\" ? $ = CmnLib.stageW - N * 0.5 : e === \"l\" ? $ = N * 0.5 : $ = int(e), o.x = int($ - N * 0.5), o.y = CmnLib.stageH - B, o.scale.x < 0 && (o.x += N), o.scale.y < 0 && (o.y += B);\n  }\n  static setXYCenter(t) {\n    const e = t.getBounds();\n    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;\n  }\n};\nlet Layer = Ai;\nQl = new WeakMap(), th = new WeakMap(), rt(Layer, Ql, {\n  normal: BLEND_MODES$5.NORMAL,\n  add: BLEND_MODES$5.ADD,\n  multiply: BLEND_MODES$5.MULTIPLY,\n  screen: BLEND_MODES$5.SCREEN\n}), rt(Layer, th, {\n  0: \"normal\",\n  1: \"add\",\n  2: \"multiply\",\n  3: \"screen\"\n});\nfunction prefixNames(r) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  return t.map(function(o) {\n    return o.split(\" \").map(function(T) {\n      return T ? \"\" + r + T : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction prefixCSS(r, t) {\n  return t.replace(/([^}{]*){/gm, function(e, o) {\n    return o.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + r + \"$1\") + \"{\";\n  });\n}\nfunction ref(r, t) {\n  return function(e) {\n    e && (r[t] = e);\n  };\n}\nfunction refs(r, t, e) {\n  return function(o) {\n    o && (r[t][e] = o);\n  };\n}\nfunction Properties(r, t) {\n  return function(e) {\n    var o = e.prototype;\n    r.forEach(function(T) {\n      t(o, T);\n    });\n  };\n}\nfunction withMethods(r, t) {\n  return t === void 0 && (t = {}), function(e, o) {\n    r.forEach(function(T) {\n      var S = t[T] || T;\n      S in e || (e[S] = function() {\n        for (var N, D = [], B = 0; B < arguments.length; B++)\n          D[B] = arguments[B];\n        var $ = (N = this[o])[T].apply(N, D);\n        return $ === this[o] ? this : $;\n      });\n    });\n  };\n}\nvar PolyMap = /* @__PURE__ */ function() {\n  function r() {\n    this.keys = [], this.values = [];\n  }\n  var t = r.prototype;\n  return t.get = function(e) {\n    return this.values[this.keys.indexOf(e)];\n  }, t.set = function(e, o) {\n    var T = this.keys, S = this.values, N = T.indexOf(e), D = N === -1 ? T.length : N;\n    T[D] = e, S[D] = o;\n  }, r;\n}(), HashMap = /* @__PURE__ */ function() {\n  function r() {\n    this.object = {};\n  }\n  var t = r.prototype;\n  return t.get = function(e) {\n    return this.object[e];\n  }, t.set = function(e, o) {\n    this.object[e] = o;\n  }, r;\n}(), SUPPORT_MAP = typeof Map == \"function\", Link = /* @__PURE__ */ function() {\n  function r() {\n  }\n  var t = r.prototype;\n  return t.connect = function(e, o) {\n    this.prev = e, this.next = o, e && (e.next = this), o && (o.prev = this);\n  }, t.disconnect = function() {\n    var e = this.prev, o = this.next;\n    e && (e.next = o), o && (o.prev = e);\n  }, t.getIndex = function() {\n    for (var e = this, o = -1; e; )\n      e = e.prev, ++o;\n    return o;\n  }, r;\n}();\nfunction orderChanged(r, t) {\n  var e = [], o = [];\n  return r.forEach(function(T) {\n    var S = T[0], N = T[1], D = new Link();\n    e[S] = D, o[N] = D;\n  }), e.forEach(function(T, S) {\n    T.connect(e[S - 1]);\n  }), r.filter(function(T, S) {\n    return !t[S];\n  }).map(function(T, S) {\n    var N = T[0], D = T[1];\n    if (N === D)\n      return [0, 0];\n    var B = e[N], $ = o[D - 1], U = B.getIndex();\n    B.disconnect(), $ ? B.connect($, $.next) : B.connect(void 0, e[0]);\n    var z = B.getIndex();\n    return [U, z];\n  });\n}\nvar Result = /* @__PURE__ */ function() {\n  function r(e, o, T, S, N, D, B, $) {\n    this.prevList = e, this.list = o, this.added = T, this.removed = S, this.changed = N, this.maintained = D, this.changedBeforeAdded = B, this.fixed = $;\n  }\n  var t = r.prototype;\n  return Object.defineProperty(t, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(t, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), t.caculateOrdered = function() {\n    var e = orderChanged(this.changedBeforeAdded, this.fixed), o = this.changed, T = [];\n    this.cacheOrdered = e.filter(function(S, N) {\n      var D = S[0], B = S[1], $ = o[N], U = $[0], z = $[1];\n      if (D !== B)\n        return T.push([U, z]), !0;\n    }), this.cachePureChanged = T;\n  }, r;\n}();\nfunction diff$1(r, t, e) {\n  var o = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, T = e || function(K) {\n    return K;\n  }, S = [], N = [], D = [], B = r.map(T), $ = t.map(T), U = new o(), z = new o(), V = [], X = [], W = {}, Y = [], q = 0, Z = 0;\n  return B.forEach(function(K, J) {\n    U.set(K, J);\n  }), $.forEach(function(K, J) {\n    z.set(K, J);\n  }), B.forEach(function(K, J) {\n    var tt = z.get(K);\n    typeof tt > \"u\" ? (++Z, N.push(J)) : W[tt] = Z;\n  }), $.forEach(function(K, J) {\n    var tt = U.get(K);\n    typeof tt > \"u\" ? (S.push(J), ++q) : (D.push([tt, J]), Z = W[J] || 0, V.push([tt - Z, J - q]), X.push(J === tt), tt !== J && Y.push([tt, J]));\n  }), N.reverse(), new Result(r, t, S, N, Y, D, V, X);\n}\nvar ListDiffer = /* @__PURE__ */ function() {\n  function r(e, o) {\n    e === void 0 && (e = []), this.findKeyCallback = o, this.list = [].slice.call(e);\n  }\n  var t = r.prototype;\n  return t.update = function(e) {\n    var o = [].slice.call(e), T = diff$1(this.list, o, this.findKeyCallback);\n    return this.list = o, T;\n  }, r;\n}(), FUNCTION$1 = \"function\", OBJECT = \"object\", STRING$1 = \"string\", NUMBER = \"number\", UNDEFINED = \"undefined\", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {\n  cm: function(r) {\n    return r * 96 / 2.54;\n  },\n  mm: function(r) {\n    return r * 96 / 254;\n  },\n  in: function(r) {\n    return r * 96;\n  },\n  pt: function(r) {\n    return r * 96 / 72;\n  },\n  pc: function(r) {\n    return r * 96 / 6;\n  },\n  \"%\": function(r, t) {\n    return r * t / 100;\n  },\n  vw: function(r, t) {\n    return t === void 0 && (t = window.innerWidth), r / 100 * t;\n  },\n  vh: function(r, t) {\n    return t === void 0 && (t = window.innerHeight), r / 100 * t;\n  },\n  vmax: function(r, t) {\n    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), r / 100 * t;\n  },\n  vmin: function(r, t) {\n    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), r / 100 * t;\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$4() {\n  for (var r = 0, t = 0, e = arguments.length; t < e; t++)\n    r += arguments[t].length;\n  for (var o = Array(r), T = 0, t = 0; t < e; t++)\n    for (var S = arguments[t], N = 0, D = S.length; N < D; N++, T++)\n      o[T] = S[N];\n  return o;\n}\nfunction dot(r, t, e, o) {\n  return (r * o + t * e) / (e + o);\n}\nfunction isUndefined(r) {\n  return typeof r === UNDEFINED;\n}\nfunction isObject$2(r) {\n  return r && typeof r === OBJECT;\n}\nfunction isArray(r) {\n  return Array.isArray(r);\n}\nfunction isString$1(r) {\n  return typeof r === STRING$1;\n}\nfunction isNumber(r) {\n  return typeof r === NUMBER;\n}\nfunction isFunction$3(r) {\n  return typeof r === FUNCTION$1;\n}\nfunction isEqualSeparator(r, t) {\n  var e = r === \"\" || r == \" \", o = t === \"\" || t == \" \";\n  return o && e || r === t;\n}\nfunction findOpen(r, t, e, o, T) {\n  var S = findIgnore(r, t, e);\n  return S ? e : findClose(r, t, e + 1, o, T);\n}\nfunction findIgnore(r, t, e) {\n  if (!r.ignore)\n    return null;\n  var o = t.slice(Math.max(e - 3, 0), e + 3).join(\"\");\n  return new RegExp(r.ignore).exec(o);\n}\nfunction findClose(r, t, e, o, T) {\n  for (var S = function($) {\n    var U = t[$].trim();\n    if (U === r.close && !findIgnore(r, t, $))\n      return {\n        value: $\n      };\n    var z = $, V = find$1(T, function(X) {\n      var W = X.open;\n      return W === U;\n    });\n    if (V && (z = findOpen(V, t, $, o, T)), z === -1)\n      return N = $, \"break\";\n    $ = z, N = $;\n  }, N, D = e; D < o; ++D) {\n    var B = S(D);\n    if (D = N, typeof B == \"object\")\n      return B.value;\n    if (B === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction splitText(r, t) {\n  var e = isString$1(t) ? {\n    separator: t\n  } : t, o = e.separator, T = o === void 0 ? \",\" : o, S = e.isSeparateFirst, N = e.isSeparateOnlyOpenClose, D = e.isSeparateOpenClose, B = D === void 0 ? N : D, $ = e.openCloseCharacters, U = $ === void 0 ? OPEN_CLOSED_CHARACTERS : $, z = U.map(function(at) {\n    var it = at.open, st = at.close;\n    return it === st ? it : it + \"|\" + st;\n  }).join(\"|\"), V = \"(\\\\s*\" + T + \"\\\\s*|\" + z + \"|\\\\s+)\", X = new RegExp(V, \"g\"), W = r.split(X).filter(Boolean), Y = W.length, q = [], Z = [];\n  function K() {\n    return Z.length ? (q.push(Z.join(\"\")), Z = [], !0) : !1;\n  }\n  for (var J = function(at) {\n    var it = W[at].trim(), st = at, ut = find$1(U, function(pt) {\n      var mt = pt.open;\n      return mt === it;\n    }), ft = find$1(U, function(pt) {\n      var mt = pt.close;\n      return mt === it;\n    });\n    if (ut) {\n      if (st = findOpen(ut, W, at, Y, U), st !== -1 && B)\n        return K() && S || (q.push(W.slice(at, st + 1).join(\"\")), at = st, S) ? (tt = at, \"break\") : (tt = at, \"continue\");\n    } else if (ft && !findIgnore(ft, W, at)) {\n      var ct = __spreadArrays$4(U);\n      return ct.splice(U.indexOf(ft), 1), {\n        value: splitText(r, {\n          separator: T,\n          isSeparateFirst: S,\n          isSeparateOnlyOpenClose: N,\n          isSeparateOpenClose: B,\n          openCloseCharacters: ct\n        })\n      };\n    } else if (isEqualSeparator(it, T) && !N)\n      return K(), S ? (tt = at, \"break\") : (tt = at, \"continue\");\n    st === -1 && (st = Y - 1), Z.push(W.slice(at, st + 1).join(\"\")), at = st, tt = at;\n  }, tt, et = 0; et < Y; ++et) {\n    var Q = J(et);\n    if (et = tt, typeof Q == \"object\")\n      return Q.value;\n    if (Q === \"break\")\n      break;\n  }\n  return Z.length && q.push(Z.join(\"\")), q;\n}\nfunction splitSpace(r) {\n  return splitText(r, \"\");\n}\nfunction splitComma(r) {\n  return splitText(r, \",\");\n}\nfunction splitBracket(r) {\n  var t = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(r);\n  return !t || t.length < 4 ? {} : {\n    prefix: t[1],\n    value: t[2],\n    suffix: t[3]\n  };\n}\nfunction splitUnit(r) {\n  var t = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(r);\n  if (!t)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var e = t[1], o = t[2], T = t[3];\n  return {\n    prefix: e,\n    unit: T,\n    value: parseFloat(o)\n  };\n}\nfunction camelize(r) {\n  return r.replace(/[\\s-_]([a-z])/g, function(t, e) {\n    return e.toUpperCase();\n  });\n}\nfunction decamelize(r, t) {\n  return t === void 0 && (t = \"-\"), r.replace(/([a-z])([A-Z])/g, function(e, o, T) {\n    return \"\" + o + t + T.toLowerCase();\n  });\n}\nfunction now$1() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\nfunction findIndex(r, t, e) {\n  e === void 0 && (e = -1);\n  for (var o = r.length, T = 0; T < o; ++T)\n    if (t(r[T], T, r))\n      return T;\n  return e;\n}\nfunction find$1(r, t, e) {\n  var o = findIndex(r, t);\n  return o > -1 ? r[o] : e;\n}\nvar requestAnimationFrame$1 = /* @__PURE__ */ function() {\n  var r = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    var o = now$1(), T = window.setTimeout(function() {\n      e(o - r);\n    }, 1e3 / 60);\n    return T;\n  };\n}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {\n  var r = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return r ? r.bind(window) : function(t) {\n    clearTimeout(t);\n  };\n}();\nfunction getKeys(r) {\n  return Object.keys(r);\n}\nfunction convertUnitSize(r, t) {\n  var e = splitUnit(r), o = e.value, T = e.unit;\n  if (isObject$2(t)) {\n    var S = t[T];\n    if (S) {\n      if (isFunction$3(S))\n        return S(o);\n      if (DEFAULT_UNIT_PRESETS[T])\n        return DEFAULT_UNIT_PRESETS[T](o, S);\n    }\n  } else if (T === \"%\")\n    return o * t / 100;\n  return DEFAULT_UNIT_PRESETS[T] ? DEFAULT_UNIT_PRESETS[T](o) : o;\n}\nfunction between(r, t, e) {\n  return Math.max(t, Math.min(r, e));\n}\nfunction checkBoundSize(r, t, e, o) {\n  return o === void 0 && (o = r[0] / r[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / o, TINY_NUM$1)], [throttle(t[1] * o, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(T) {\n    return T.every(function(S, N) {\n      var D = t[N], B = throttle(D, TINY_NUM$1);\n      return e ? S <= D || S <= B : S >= D || S >= B;\n    });\n  })[0] || r;\n}\nfunction calculateBoundSize(r, t, e, o) {\n  if (!o)\n    return r.map(function(X, W) {\n      return between(X, t[W], e[W]);\n    });\n  var T = r[0], S = r[1], N = o === !0 ? T / S : o, D = checkBoundSize(r, t, !1, N), B = D[0], $ = D[1], U = checkBoundSize(r, e, !0, N), z = U[0], V = U[1];\n  return T < B || S < $ ? (T = B, S = $) : (T > z || S > V) && (T = z, S = V), [T, S];\n}\nfunction sum(r) {\n  for (var t = r.length, e = 0, o = t - 1; o >= 0; --o)\n    e += r[o];\n  return e;\n}\nfunction average(r) {\n  for (var t = r.length, e = 0, o = t - 1; o >= 0; --o)\n    e += r[o];\n  return t ? e / t : 0;\n}\nfunction getRad$1(r, t) {\n  var e = t[0] - r[0], o = t[1] - r[1], T = Math.atan2(o, e);\n  return T >= 0 ? T : T + Math.PI * 2;\n}\nfunction getCenterPoint(r) {\n  return [0, 1].map(function(t) {\n    return average(r.map(function(e) {\n      return e[t];\n    }));\n  });\n}\nfunction getShapeDirection(r) {\n  var t = getCenterPoint(r), e = getRad$1(t, r[0]), o = getRad$1(t, r[1]);\n  return e < o && o - e < Math.PI || e > o && o - e < -Math.PI ? 1 : -1;\n}\nfunction getDist$2(r, t) {\n  return Math.sqrt(Math.pow((t ? t[0] : 0) - r[0], 2) + Math.pow((t ? t[1] : 0) - r[1], 2));\n}\nfunction throttle(r, t) {\n  if (!t)\n    return r;\n  var e = 1 / t;\n  return Math.round(r / t) / e;\n}\nfunction throttleArray(r, t) {\n  return r.forEach(function(e, o) {\n    r[o] = throttle(r[o], t);\n  }), r;\n}\nfunction hasClass(r, t) {\n  return r.classList ? r.classList.contains(t) : !!r.className.match(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\"));\n}\nfunction addClass(r, t) {\n  r.classList ? r.classList.add(t) : r.className += \" \" + t;\n}\nfunction removeClass(r, t) {\n  if (r.classList)\n    r.classList.remove(t);\n  else {\n    var e = new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\");\n    r.className = r.className.replace(e, \" \");\n  }\n}\nfunction addEvent(r, t, e, o) {\n  r.addEventListener(t, e, o);\n}\nfunction removeEvent(r, t, e, o) {\n  r.removeEventListener(t, e, o);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$6 = function(r, t) {\n  return extendStatics$6 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$6(r, t);\n};\nfunction __extends$6(r, t) {\n  extendStatics$6(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$7 = function() {\n  return __assign$7 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$7.apply(this, arguments);\n};\nfunction __rest$2(r, t) {\n  var e = {};\n  for (var o in r)\n    Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (e[o] = r[o]);\n  if (r != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var T = 0, o = Object.getOwnPropertySymbols(r); T < o.length; T++)\n      t.indexOf(o[T]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[T]) && (e[o[T]] = r[o[T]]);\n  return e;\n}\nfunction __spreadArrays$3() {\n  for (var r = 0, t = 0, e = arguments.length; t < e; t++)\n    r += arguments[t].length;\n  for (var o = Array(r), T = 0, t = 0; t < e; t++)\n    for (var S = arguments[t], N = 0, D = S.length; N < D; N++, T++)\n      o[T] = S[N];\n  return o;\n}\nfunction isDiff(r, t) {\n  if (r === t)\n    return !1;\n  for (var e in r)\n    if (!(e in t))\n      return !0;\n  for (var e in t)\n    if (r[e] !== t[e])\n      return !0;\n  return !1;\n}\nfunction diffObject(r, t) {\n  var e = Object.keys(r), o = Object.keys(t), T = diff$1(e, o, function(B) {\n    return B;\n  }), S = {}, N = {}, D = {};\n  return T.added.forEach(function(B) {\n    var $ = o[B];\n    S[$] = t[$];\n  }), T.removed.forEach(function(B) {\n    var $ = e[B];\n    N[$] = r[$];\n  }), T.maintained.forEach(function(B) {\n    var $ = B[0], U = e[$], z = [r[U], t[U]];\n    r[U] !== t[U] && (D[U] = z);\n  }), {\n    added: S,\n    removed: N,\n    changed: D\n  };\n}\nfunction executeHooks(r) {\n  r.forEach(function(t) {\n    t();\n  });\n}\nfunction fillKeys(r) {\n  var t = 0;\n  return r.map(function(e) {\n    return e == null ? \"$compat\" + ++t : \"\" + e;\n  });\n}\nfunction createProvider(r, t, e, o) {\n  if (isString$1(r) || isNumber(r))\n    return new TextProvider(\"text_\" + r, t, e, o, null, {});\n  var T = typeof r.type == \"string\" ? ElementProvider : r.type.prototype.render ? ComponentProvider : FunctionProvider;\n  return new T(r.type, t, e, o, r.ref, r.props);\n}\nfunction flat$1(r) {\n  var t = [];\n  return r.forEach(function(e) {\n    t = t.concat(isArray(e) ? flat$1(e) : e);\n  }), t;\n}\nfunction getAttributes(r) {\n  var t = r.className, e = __rest$2(r, [\"className\"]);\n  return t != null && (e.class = t), delete e.style, delete e.children, e;\n}\nfunction fillProps(r, t) {\n  if (!t)\n    return r;\n  for (var e in t)\n    isUndefined(r[e]) && (r[e] = t[e]);\n  return r;\n}\nfunction createElement(r, t) {\n  for (var e = [], o = 2; o < arguments.length; o++)\n    e[o - 2] = arguments[o];\n  var T = t || {}, S = T.key, N = T.ref, D = __rest$2(T, [\"key\", \"ref\"]);\n  return {\n    type: r,\n    key: S,\n    ref: N,\n    props: __assign$7(__assign$7({}, D), {\n      children: flat$1(e).filter(function(B) {\n        return B != null && B !== !1;\n      })\n    })\n  };\n}\nvar Provider = /* @__PURE__ */ function() {\n  function r(e, o, T, S, N, D) {\n    D === void 0 && (D = {}), this.type = e, this.key = o, this.index = T, this.container = S, this.ref = N, this.props = D, this._providers = [];\n  }\n  var t = r.prototype;\n  return t._should = function(e, o) {\n    return !0;\n  }, t._update = function(e, o, T, S) {\n    if (this.base && !isString$1(o) && !S && !this._should(o.props, T))\n      return !1;\n    this.original = o, this._setState(T);\n    var N = this.props;\n    return isString$1(o) || (this.props = o.props, this.ref = o.ref), this._render(e, this.base ? N : {}, T), !0;\n  }, t._mounted = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._setState = function(e) {\n  }, t._updated = function() {\n    var e = this.ref;\n    e && e(this.base);\n  }, t._destroy = function() {\n    var e = this.ref;\n    e && e(null);\n  }, r;\n}();\nfunction diffAttributes(r, t, e) {\n  var o = diffObject(r, t), T = o.added, S = o.removed, N = o.changed;\n  for (var D in T)\n    e.setAttribute(D, T[D]);\n  for (var D in N)\n    e.setAttribute(D, N[D][1]);\n  for (var D in S)\n    e.removeAttribute(D);\n}\nfunction diffEvents(r, t, e) {\n  var o = diffObject(r, t), T = o.added, S = o.removed, N = o.changed;\n  for (var D in S)\n    e.removeEventListener(D);\n  for (var D in T)\n    e.addEventListener(D, T[D]);\n  for (var D in N)\n    e.removeEventListener(D), e.addEventListener(D, N[D][1]);\n  for (var D in S)\n    e.removeEventListener(D);\n}\nfunction diffStyle(r, t, e) {\n  var o = e.style, T = diffObject(r, t), S = T.added, N = T.removed, D = T.changed;\n  for (var B in S) {\n    var $ = decamelize(B, \"-\");\n    o.setProperty ? o.setProperty($, S[B]) : o[$] = S[B];\n  }\n  for (var B in D) {\n    var $ = decamelize(B, \"-\");\n    o.setProperty ? o.setProperty($, D[B][1]) : o[$] = D[B][1];\n  }\n  for (var B in N) {\n    var $ = decamelize(B, \"-\");\n    o.removeProperty ? o.removeProperty($) : o[$] = \"\";\n  }\n}\nfunction splitProps(r) {\n  var t = {}, e = {};\n  for (var o in r)\n    o.indexOf(\"on\") === 0 ? e[o.replace(\"on\", \"\").toLowerCase()] = r[o] : t[o] = r[o];\n  return {\n    attributes: t,\n    events: e\n  };\n}\nvar TextProvider = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(o) {\n    var T = this, S = !this.base;\n    return S && (this.base = document.createTextNode(this.type.replace(\"text_\", \"\"))), o.push(function() {\n      S ? T._mounted() : T._updated();\n    }), !0;\n  }, e._unmount = function() {\n    this.base.parentNode.removeChild(this.base);\n  }, t;\n}(Provider), ElementProvider = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.events = {}, o._isSVG = !1, o;\n  }\n  var e = t.prototype;\n  return e.addEventListener = function(o, T) {\n    var S = this.events;\n    S[o] = function(N) {\n      N.nativeEvent = N, T(N);\n    }, this.base.addEventListener(o, S[o]);\n  }, e.removeEventListener = function(o) {\n    var T = this.events;\n    this.base.removeEventListener(o, T[o]), delete T[o];\n  }, e._should = function(o) {\n    return isDiff(this.props, o);\n  }, e._render = function(o, T) {\n    var S = this, N = !this.base;\n    if (N) {\n      var D = this._hasSVG();\n      this._isSVG = D;\n      var B = this.props.portalContainer;\n      if (!B) {\n        var $ = this.type;\n        D ? B = document.createElementNS(\"http://www.w3.org/2000/svg\", $) : B = document.createElement($);\n      }\n      this.base = B;\n    }\n    renderProviders(this, this._providers, this.props.children, o, null);\n    var U = this.base, z = splitProps(T), V = z.attributes, X = z.events, W = splitProps(this.props), Y = W.attributes, q = W.events;\n    return diffAttributes(getAttributes(V), getAttributes(Y), U), diffEvents(X, q, this), diffStyle(T.style || {}, this.props.style || {}, U), o.push(function() {\n      N ? S._mounted() : S._updated();\n    }), !0;\n  }, e._unmount = function() {\n    var o = this.events, T = this.base;\n    for (var S in o)\n      T.removeEventListener(S, o[S]);\n    this._providers.forEach(function(N) {\n      N._unmount();\n    }), this.events = {}, this.props.portalContainer || T.parentNode.removeChild(T);\n  }, e._hasSVG = function() {\n    if (this._isSVG || this.type === \"svg\")\n      return !0;\n    var o = findContainerNode(this.container);\n    return o && \"ownerSVGElement\" in o;\n  }, t;\n}(Provider);\nfunction findContainerNode(r) {\n  if (!r)\n    return null;\n  var t = r.base;\n  return t instanceof Node ? t : findContainerNode(r.container);\n}\nfunction findDOMNode(r) {\n  if (!r)\n    return null;\n  if (r instanceof Node)\n    return r;\n  var t = r.$_provider._providers;\n  return t.length ? findDOMNode(t[0].base) : null;\n}\nvar FunctionProvider = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e._render = function(o) {\n    var T = this.type(this.props);\n    return renderProviders(this, this._providers, T ? [T] : [], o), !0;\n  }, e._unmount = function() {\n    this._providers.forEach(function(o) {\n      o._unmount();\n    });\n  }, t;\n}(Provider), ContainerProvider = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t(o) {\n    var T = r.call(this, \"container\", \"container\", 0, null) || this;\n    return T.base = o, T;\n  }\n  var e = t.prototype;\n  return e._render = function() {\n    return !0;\n  }, e._unmount = function() {\n  }, t;\n}(Provider), ComponentProvider = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t(o, T, S, N, D, B) {\n    return B === void 0 && (B = {}), r.call(this, o, T, S, N, D, fillProps(B, o.defaultProps)) || this;\n  }\n  var e = t.prototype;\n  return e._should = function(o, T) {\n    return this.base.shouldComponentUpdate(fillProps(o, this.type.defaultProps), T || this.base.state);\n  }, e._render = function(o, T) {\n    var S = this;\n    this.props = fillProps(this.props, this.type.defaultProps);\n    var N = !this.base;\n    N ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;\n    var D = this.base, B = D.state, $ = D.render();\n    $ && $.props && !$.props.children.length && ($.props.children = this.props.children), renderProviders(this, this._providers, $ ? [$] : [], o), o.push(function() {\n      N ? (S._mounted(), D.componentDidMount()) : (S._updated(), D.componentDidUpdate(T, B));\n    });\n  }, e._setState = function(o) {\n    var T = this.base;\n    !T || !o || (T.state = o);\n  }, e._unmount = function() {\n    this._providers.forEach(function(o) {\n      o._unmount();\n    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();\n  }, t;\n}(Provider), Component = /* @__PURE__ */ function() {\n  function r(e) {\n    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};\n  }\n  var t = r.prototype;\n  return t.shouldComponentUpdate = function(e, o) {\n    return !0;\n  }, t.render = function() {\n    return null;\n  }, t.setState = function(e, o, T) {\n    var S = this;\n    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$7(__assign$7({}, this.$_state), e), T ? this.$_setState(o, T) : this.$_timer = setTimeout(function() {\n      S.$_timer = 0, S.$_setState(o, T);\n    });\n  }, t.forceUpdate = function(e) {\n    this.setState({}, e, !0);\n  }, t.componentDidMount = function() {\n  }, t.componentDidUpdate = function(e, o) {\n  }, t.componentWillUnmount = function() {\n  }, t.$_setState = function(e, o) {\n    var T = [], S = this.$_provider, N = renderProviders(S.container, [S], [S.original], T, __assign$7(__assign$7({}, this.state), this.$_state), o);\n    N && (e && T.push(e), executeHooks(T));\n  }, r;\n}(), PureComponent = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.shouldComponentUpdate = function(o, T) {\n    return isDiff(this.props, o) || isDiff(this.state, T);\n  }, t;\n}(Component), _Portal = /* @__PURE__ */ function(r) {\n  __extends$6(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    var o = this.props, T = o.element, S = o.container;\n    this._portalProvider = new ContainerProvider(S), renderProvider(T, S, this._portalProvider);\n  }, e.componentDidUpdate = function() {\n    var o = this.props, T = o.element, S = o.container;\n    renderProvider(T, S, this._portalProvider);\n  }, e.componentWillUnmount = function() {\n    var o = this.props.container;\n    renderProvider(null, o, this._portalProvider), this._portalProvider = null;\n  }, t;\n}(PureComponent);\nfunction updateProvider(r, t, e) {\n  var o = [];\n  renderProviders(r, r._providers, t, o, e), executeHooks(o);\n}\nfunction getNextSibiling(r, t) {\n  for (var e = r._providers, o = e.length, T = t.index + 1; T < o; ++T) {\n    var S = findDOMNode(e[T].base);\n    if (S)\n      return S;\n  }\n  return null;\n}\nfunction diffProviders(r, t, e) {\n  var o = e.map(function(B) {\n    return isString$1(B) ? null : B.key;\n  }), T = fillKeys(t.map(function(B) {\n    return B.key;\n  })), S = fillKeys(o), N = diff$1(T, S, function(B) {\n    return B;\n  });\n  N.removed.forEach(function(B) {\n    t.splice(B, 1)[0]._unmount();\n  }), N.ordered.forEach(function(B) {\n    var $ = B[0], U = B[1], z = t.splice($, 1)[0];\n    t.splice(U, 0, z);\n    var V = findDOMNode(z.base), X = findDOMNode(t[U + 1] && t[U + 1].base);\n    V && V.parentNode.insertBefore(V, X);\n  }), N.added.forEach(function(B) {\n    t.splice(B, 0, createProvider(e[B], o[B], B, r));\n  });\n  var D = N.maintained.filter(function(B) {\n    B[0];\n    var $ = B[1], U = e[$], z = t[$], V = isString$1(U) ? \"text_\" + U : U.type;\n    return V !== z.type ? (z._unmount(), t.splice($, 1, createProvider(U, o[$], $, r)), !0) : (z.index = $, !1);\n  });\n  return __spreadArrays$3(N.added, D.map(function(B) {\n    B[0];\n    var $ = B[1];\n    return $;\n  }));\n}\nfunction renderProviders(r, t, e, o, T, S) {\n  var N = diffProviders(r, t, e), D = t.filter(function($, U) {\n    return $._update(o, e[U], T, S);\n  }), B = findContainerNode(r);\n  return B && N.reverse().forEach(function($) {\n    var U = t[$], z = findDOMNode(U.base);\n    if (!!z && B !== z && !z.parentNode) {\n      var V = getNextSibiling(r, U);\n      B.insertBefore(z, V);\n    }\n  }), D.length > 0;\n}\nfunction renderProvider(r, t, e) {\n  e === void 0 && (e = t.__REACT_COMPAT__);\n  var o = !!e;\n  return e || (e = new ContainerProvider(t)), updateProvider(e, r ? [r] : []), o || (t.__REACT_COMPAT__ = e), e;\n}\nfunction render(r, t, e) {\n  var o = t.__REACT_COMPAT__;\n  r && !o && (t.innerHTML = \"\"), renderProvider(r, t, o), e && e();\n}\nfunction createPortal(r, t) {\n  return createElement(_Portal, {\n    element: r,\n    container: t\n  });\n}\nvar version = \"simple-1.1.0\";\nfunction some(r, t) {\n  for (var e = r.length, o = 0; o < e; ++o)\n    if (t(r[o], o))\n      return !0;\n  return !1;\n}\nfunction find(r, t) {\n  for (var e = r.length, o = 0; o < e; ++o)\n    if (t(r[o], o))\n      return r[o];\n  return null;\n}\nfunction getUserAgentString(r) {\n  var t = r;\n  if (typeof t > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    t = navigator.userAgent || \"\";\n  }\n  return t.toLowerCase();\n}\nfunction execRegExp(r, t) {\n  try {\n    return new RegExp(r, \"g\").exec(t);\n  } catch {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var r = navigator.userAgentData, t = r.brands || r.uaList;\n  return !!(t && t.length);\n}\nfunction findVersion(r, t) {\n  var e = execRegExp(\"(\" + r + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", t);\n  return e ? e[3] : \"\";\n}\nfunction convertVersion(r) {\n  return r.replace(/_/g, \".\");\n}\nfunction findPreset(r, t) {\n  var e = null, o = \"-1\";\n  return some(r, function(T) {\n    var S = execRegExp(\"(\" + T.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", t);\n    return !S || T.brand ? !1 : (e = T, o = S[3] || \"-1\", T.versionAlias ? o = T.versionAlias : T.versionTest && (o = findVersion(T.versionTest.toLowerCase(), t) || o), o = convertVersion(o), !0);\n  }), {\n    preset: e,\n    version: o\n  };\n}\nfunction findPresetBrand(r, t) {\n  var e = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return some(r, function(o) {\n    var T = findBrand(t, o);\n    return T ? (e.brand = o.id, e.version = o.versionAlias || T.version, e.version !== \"-1\") : !1;\n  }), e;\n}\nfunction findBrand(r, t) {\n  return find(r, function(e) {\n    var o = e.brand;\n    return execRegExp(\"\" + t.test, o.toLowerCase());\n  });\n}\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  test: \"webview\",\n  id: \"webview\"\n}], OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction isWebView(r) {\n  return !!findPreset(WEBVIEW_PRESETS, r).preset;\n}\nfunction getLegacyAgent(r) {\n  var t = getUserAgentString(r), e = !!/mobi/g.exec(t), o = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(t),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, T = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, S = findPreset(BROWSER_PRESETS, t), N = S.preset, D = S.version, B = findPreset(OS_PRESETS, t), $ = B.preset, U = B.version, z = findPreset(CHROMIUM_PRESETS, t);\n  if (o.chromium = !!z.preset, o.chromiumVersion = z.version, !o.chromium) {\n    var V = findPreset(WEBKIT_PRESETS, t);\n    o.webkit = !!V.preset, o.webkitVersion = V.version;\n  }\n  return $ && (T.name = $.id, T.version = U, T.majorVersion = parseInt(U, 10)), N && (o.name = N.id, o.version = D, o.webview && T.name === \"ios\" && o.name !== \"safari\" && (o.webview = !1)), o.majorVersion = parseInt(o.version, 10), {\n    browser: o,\n    os: T,\n    isMobile: e,\n    isHints: !1\n  };\n}\nfunction getClientHintsAgent(r) {\n  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), o = r && r.fullVersionList, T = t.mobile || !1, S = e[0], N = (r && r.platform || t.platform || navigator.platform).toLowerCase(), D = {\n    name: S.brand,\n    version: S.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())\n  }, B = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  D.webkit = !D.chromium && some(WEBKIT_PRESETS, function(W) {\n    return findBrand(e, W);\n  });\n  var $ = findPresetBrand(CHROMIUM_PRESETS, e);\n  if (D.chromium = !!$.brand, D.chromiumVersion = $.version, !D.chromium) {\n    var U = findPresetBrand(WEBKIT_PRESETS, e);\n    D.webkit = !!U.brand, D.webkitVersion = U.version;\n  }\n  var z = find(OS_PRESETS, function(W) {\n    return new RegExp(\"\" + W.test, \"g\").exec(N);\n  });\n  if (B.name = z ? z.id : \"\", r && (B.version = r.platformVersion), o && o.length) {\n    var V = findPresetBrand(BROWSER_PRESETS, o);\n    D.name = V.brand || D.name, D.version = V.version || D.version;\n  } else {\n    var X = findPresetBrand(BROWSER_PRESETS, e);\n    D.name = X.brand || D.name, D.version = X.brand && r ? r.uaFullVersion : X.version;\n  }\n  return D.webkit && (B.name = T ? \"ios\" : \"mac\"), B.name === \"ios\" && D.webview && (D.version = \"-1\"), B.version = convertVersion(B.version), D.version = convertVersion(D.version), B.majorVersion = parseInt(B.version, 10), D.majorVersion = parseInt(D.version, 10), {\n    browser: D,\n    os: B,\n    isMobile: T,\n    isHints: !0\n  };\n}\nfunction agent$1(r) {\n  return typeof r > \"u\" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(r);\n}\nfunction add(r, t, e, o, T, S) {\n  for (var N = 0; N < T; ++N) {\n    var D = e + N * T, B = o + N * T;\n    r[D] += r[B] * S, t[D] += t[B] * S;\n  }\n}\nfunction swap(r, t, e, o, T) {\n  for (var S = 0; S < T; ++S) {\n    var N = e + S * T, D = o + S * T, B = r[N], $ = t[N];\n    r[N] = r[D], r[D] = B, t[N] = t[D], t[D] = $;\n  }\n}\nfunction divide(r, t, e, o, T) {\n  for (var S = 0; S < o; ++S) {\n    var N = e + S * o;\n    r[N] /= T, t[N] /= T;\n  }\n}\nfunction ignoreDimension(r, t, e) {\n  e === void 0 && (e = Math.sqrt(r.length));\n  for (var o = r.slice(), T = 0; T < e; ++T)\n    o[T * e + t - 1] = 0, o[(t - 1) * e + T] = 0;\n  return o[(t - 1) * (e + 1)] = 1, o;\n}\nfunction invert(r, t) {\n  t === void 0 && (t = Math.sqrt(r.length));\n  for (var e = r.slice(), o = createIdentityMatrix(t), T = 0; T < t; ++T) {\n    var S = t * T + T;\n    if (!throttle(e[S], TINY_NUM$1)) {\n      for (var N = T + 1; N < t; ++N)\n        if (e[t * T + N]) {\n          swap(e, o, T, N, t);\n          break;\n        }\n    }\n    if (!throttle(e[S], TINY_NUM$1))\n      return [];\n    divide(e, o, T, t, e[S]);\n    for (var N = 0; N < t; ++N) {\n      var D = N, B = N + T * t, $ = e[B];\n      !throttle($, TINY_NUM$1) || T === N || add(e, o, D, T, t, -$);\n    }\n  }\n  return o;\n}\nfunction transpose(r, t) {\n  t === void 0 && (t = Math.sqrt(r.length));\n  for (var e = [], o = 0; o < t; ++o)\n    for (var T = 0; T < t; ++T)\n      e[T * t + o] = r[t * o + T];\n  return e;\n}\nfunction getOrigin(r, t) {\n  t === void 0 && (t = Math.sqrt(r.length));\n  for (var e = [], o = r[t * t - 1], T = 0; T < t - 1; ++T)\n    e[T] = r[t * (t - 1) + T] / o;\n  return e[t - 1] = 0, e;\n}\nfunction fromTranslation(r, t) {\n  for (var e = createIdentityMatrix(t), o = 0; o < t - 1; ++o)\n    e[t * (t - 1) + o] = r[o] || 0;\n  return e;\n}\nfunction convertPositionMatrix(r, t) {\n  for (var e = r.slice(), o = r.length; o < t - 1; ++o)\n    e[o] = 0;\n  return e[t - 1] = 1, e;\n}\nfunction convertDimension(r, t, e) {\n  if (t === void 0 && (t = Math.sqrt(r.length)), t === e)\n    return r;\n  for (var o = createIdentityMatrix(e), T = Math.min(t, e), S = 0; S < T - 1; ++S) {\n    for (var N = 0; N < T - 1; ++N)\n      o[S * e + N] = r[S * t + N];\n    o[(S + 1) * e - 1] = r[(S + 1) * t - 1], o[(e - 1) * e + S] = r[(t - 1) * t + S];\n  }\n  return o[e * e - 1] = r[t * t - 1], o;\n}\nfunction multiplies(r) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  var o = createIdentityMatrix(r);\n  return t.forEach(function(T) {\n    o = multiply(o, T, r);\n  }), o;\n}\nfunction multiply(r, t, e) {\n  e === void 0 && (e = Math.sqrt(r.length));\n  var o = [], T = r.length / e, S = t.length / T;\n  if (T) {\n    if (!S)\n      return r;\n  } else\n    return t;\n  for (var N = 0; N < e; ++N)\n    for (var D = 0; D < S; ++D) {\n      o[D * e + N] = 0;\n      for (var B = 0; B < T; ++B)\n        o[D * e + N] += r[B * e + N] * t[D * T + B];\n    }\n  return o;\n}\nfunction plus(r, t) {\n  for (var e = Math.min(r.length, t.length), o = r.slice(), T = 0; T < e; ++T)\n    o[T] = o[T] + t[T];\n  return o;\n}\nfunction minus(r, t) {\n  for (var e = Math.min(r.length, t.length), o = r.slice(), T = 0; T < e; ++T)\n    o[T] = o[T] - t[T];\n  return o;\n}\nfunction convertCSStoMatrix(r, t) {\n  return t === void 0 && (t = r.length === 6), t ? [r[0], r[1], 0, r[2], r[3], 0, r[4], r[5], 1] : r;\n}\nfunction convertMatrixtoCSS(r, t) {\n  return t === void 0 && (t = r.length === 9), t ? [r[0], r[1], r[3], r[4], r[6], r[7]] : r;\n}\nfunction calculate(r, t, e) {\n  e === void 0 && (e = t.length);\n  var o = multiply(r, t, e), T = o[e - 1];\n  return o.map(function(S) {\n    return S / T;\n  });\n}\nfunction rotateX3d(r, t) {\n  return multiply(r, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateY3d(r, t) {\n  return multiply(r, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction rotateZ3d(r, t) {\n  return multiply(r, createRotateMatrix(t, 4));\n}\nfunction scale3d(r, t) {\n  var e = t[0], o = e === void 0 ? 1 : e, T = t[1], S = T === void 0 ? 1 : T, N = t[2], D = N === void 0 ? 1 : N;\n  return multiply(r, [o, 0, 0, 0, 0, S, 0, 0, 0, 0, D, 0, 0, 0, 0, 1], 4);\n}\nfunction rotate(r, t) {\n  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(r, 3));\n}\nfunction translate3d(r, t) {\n  var e = t[0], o = e === void 0 ? 0 : e, T = t[1], S = T === void 0 ? 0 : T, N = t[2], D = N === void 0 ? 0 : N;\n  return multiply(r, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, o, S, D, 1], 4);\n}\nfunction matrix3d(r, t) {\n  return multiply(r, t, 4);\n}\nfunction createRotateMatrix(r, t) {\n  var e = Math.cos(r), o = Math.sin(r), T = createIdentityMatrix(t);\n  return T[0] = e, T[1] = o, T[t] = -o, T[t + 1] = e, T;\n}\nfunction createIdentityMatrix(r) {\n  for (var t = r * r, e = [], o = 0; o < t; ++o)\n    e[o] = o % (r + 1) ? 0 : 1;\n  return e;\n}\nfunction createScaleMatrix(r, t) {\n  for (var e = createIdentityMatrix(t), o = Math.min(r.length, t - 1), T = 0; T < o; ++T)\n    e[(t + 1) * T] = r[T];\n  return e;\n}\nfunction createOriginMatrix(r, t) {\n  for (var e = createIdentityMatrix(t), o = Math.min(r.length, t - 1), T = 0; T < o; ++T)\n    e[t * (t - 1) + T] = r[T];\n  return e;\n}\nfunction createWarpMatrix(r, t, e, o, T, S, N, D) {\n  var B = r[0], $ = r[1], U = t[0], z = t[1], V = e[0], X = e[1], W = o[0], Y = o[1], q = T[0], Z = T[1], K = S[0], J = S[1], tt = N[0], et = N[1], Q = D[0], at = D[1], it = [B, 0, U, 0, V, 0, W, 0, $, 0, z, 0, X, 0, Y, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, B, 0, U, 0, V, 0, W, 0, $, 0, z, 0, X, 0, Y, 0, 1, 0, 1, 0, 1, 0, 1, -q * B, -Z * B, -K * U, -J * U, -tt * V, -et * V, -Q * W, -at * W, -q * $, -Z * $, -K * z, -J * z, -tt * X, -et * X, -Q * Y, -at * Y], st = invert(it, 8);\n  if (!st.length)\n    return [];\n  var ut = multiply(st, [q, Z, K, J, tt, et, Q, at], 8);\n  return ut[8] = 1, convertDimension(transpose(ut), 3, 4);\n}\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction parseMat(r) {\n  return toMat(parse(r));\n}\nfunction calculateMatrixDist(r, t) {\n  var e = calculate(r, [t[0], t[1] || 0, t[2] || 0, 1], 4), o = e[3] || 1;\n  return [e[0] / o, e[1] / o, e[2] / o];\n}\nfunction toMat(r) {\n  var t = createMatrix();\n  return r.forEach(function(e) {\n    var o = e.matrixFunction, T = e.functionValue;\n    !o || (t = o(t, T));\n  }), t;\n}\nfunction parse(r) {\n  var t = isArray(r) ? r : splitSpace(r);\n  return t.map(function(e) {\n    var o = splitBracket(e), T = o.prefix, S = o.value, N = null, D = T, B = \"\";\n    if (T === \"translate\" || T === \"translateX\" || T === \"translate3d\") {\n      var $ = splitComma(S).map(function(ut) {\n        return parseFloat(ut);\n      }), U = $[0], z = $[1], V = z === void 0 ? 0 : z, X = $[2], W = X === void 0 ? 0 : X;\n      N = translate3d, B = [U, V, W];\n    } else if (T === \"translateY\") {\n      var V = parseFloat(S);\n      N = translate3d, B = [0, V, 0];\n    } else if (T === \"translateZ\") {\n      var W = parseFloat(S);\n      N = translate3d, B = [0, 0, W];\n    } else if (T === \"scale\" || T === \"scale3d\") {\n      var Y = splitComma(S).map(function(ut) {\n        return parseFloat(ut);\n      }), q = Y[0], Z = Y[1], K = Z === void 0 ? q : Z, J = Y[2], tt = J === void 0 ? 1 : J;\n      N = scale3d, B = [q, K, tt];\n    } else if (T === \"scaleX\") {\n      var q = parseFloat(S);\n      N = scale3d, B = [q, 1, 1];\n    } else if (T === \"scaleY\") {\n      var K = parseFloat(S);\n      N = scale3d, B = [1, K, 1];\n    } else if (T === \"scaleZ\") {\n      var tt = parseFloat(S);\n      N = scale3d, B = [1, 1, tt];\n    } else if (T === \"rotate\" || T === \"rotateZ\" || T === \"rotateX\" || T === \"rotateY\") {\n      var et = splitUnit(S), Q = et.unit, at = et.value, it = Q === \"rad\" ? at : at * Math.PI / 180;\n      T === \"rotate\" || T === \"rotateZ\" ? (D = \"rotateZ\", N = rotateZ3d) : T === \"rotateX\" ? N = rotateX3d : T === \"rotateY\" && (N = rotateY3d), B = it;\n    } else if (T === \"matrix3d\")\n      N = matrix3d, B = splitComma(S).map(function(ut) {\n        return parseFloat(ut);\n      });\n    else if (T === \"matrix\") {\n      var st = splitComma(S).map(function(ut) {\n        return parseFloat(ut);\n      });\n      N = matrix3d, B = [st[0], st[1], 0, 0, st[2], st[3], 0, 0, 0, 0, 1, 0, st[4], st[5], 0, 1];\n    } else\n      D = \"\";\n    return {\n      name: T,\n      functionName: D,\n      value: S,\n      matrixFunction: N,\n      functionValue: B\n    };\n  });\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$5 = function(r, t) {\n  return extendStatics$5 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$5(r, t);\n};\nfunction __extends$5(r, t) {\n  extendStatics$5(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar findKeyCallback = typeof Map == \"function\" ? void 0 : function() {\n  var r = 0;\n  return function(t) {\n    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++r);\n  };\n}(), ChildrenDiffer = /* @__PURE__ */ function(r) {\n  __extends$5(t, r);\n  function t(e) {\n    return e === void 0 && (e = []), r.call(this, e, findKeyCallback) || this;\n  }\n  return t;\n}(ListDiffer);\nfunction diff(r, t) {\n  return diff$1(r, t, findKeyCallback);\n}\nconst ChildrenDiffer$1 = ChildrenDiffer;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction __spreadArrays$2() {\n  for (var r = 0, t = 0, e = arguments.length; t < e; t++)\n    r += arguments[t].length;\n  for (var o = Array(r), T = 0, t = 0; t < e; t++)\n    for (var S = arguments[t], N = 0, D = S.length; N < D; N++, T++)\n      o[T] = S[N];\n  return o;\n}\nfunction tinyThrottle(r) {\n  return throttle(r, TINY_NUM$1);\n}\nfunction isSameConstants(r, t) {\n  return r.every(function(e, o) {\n    return tinyThrottle(e - t[o]) === 0;\n  });\n}\nfunction isSamePoint(r, t) {\n  return !tinyThrottle(r[0] - t[0]) && !tinyThrottle(r[1] - t[1]);\n}\nfunction getAreaSize(r) {\n  return r.length < 3 ? 0 : Math.abs(sum(r.map(function(t, e) {\n    var o = r[e + 1] || r[0];\n    return t[0] * o[1] - o[0] * t[1];\n  }))) / 2;\n}\nfunction fitPoints(r, t) {\n  var e = t.width, o = t.height, T = t.left, S = t.top, N = getMinMaxs(r), D = N.minX, B = N.minY, $ = N.maxX, U = N.maxY, z = e / ($ - D), V = o / (U - B);\n  return r.map(function(X) {\n    return [T + (X[0] - D) * z, S + (X[1] - B) * V];\n  });\n}\nfunction getMinMaxs(r) {\n  var t = r.map(function(o) {\n    return o[0];\n  }), e = r.map(function(o) {\n    return o[1];\n  });\n  return {\n    minX: Math.min.apply(Math, t),\n    minY: Math.min.apply(Math, e),\n    maxX: Math.max.apply(Math, t),\n    maxY: Math.max.apply(Math, e)\n  };\n}\nfunction isInside(r, t, e) {\n  var o = r[0], T = r[1], S = getMinMaxs(t), N = S.minX, D = S.maxX, B = [[N, T], [D, T]], $ = getLinearConstants(B[0], B[1]), U = convertLines(t), z = [];\n  if (U.forEach(function(W) {\n    var Y = getLinearConstants(W[0], W[1]), q = W[0];\n    if (isSameConstants($, Y))\n      z.push({\n        pos: r,\n        line: W,\n        type: \"line\"\n      });\n    else {\n      var Z = getPointsOnLines(getIntersectionPointsByConstants($, Y), [B, W]);\n      Z.forEach(function(K) {\n        W.some(function(J) {\n          return isSamePoint(J, K);\n        }) ? z.push({\n          pos: K,\n          line: W,\n          type: \"point\"\n        }) : tinyThrottle(q[1] - T) !== 0 && z.push({\n          pos: K,\n          line: W,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), !e && find$1(z, function(W) {\n    return W[0] === o;\n  }))\n    return !0;\n  var V = 0, X = {};\n  return z.forEach(function(W) {\n    var Y = W.pos, q = W.type, Z = W.line;\n    if (!(Y[0] > o))\n      if (q === \"intersection\")\n        ++V;\n      else {\n        if (q === \"line\")\n          return;\n        if (q === \"point\") {\n          var K = find$1(Z, function(et) {\n            return et[1] !== T;\n          }), J = X[Y[0]], tt = K[1] > T ? 1 : -1;\n          J ? J !== tt && ++V : X[Y[0]] = tt;\n        }\n      }\n  }), V % 2 === 1;\n}\nfunction getLinearConstants(r, t) {\n  var e = r[0], o = r[1], T = t[0], S = t[1], N = T - e, D = S - o;\n  Math.abs(N) < TINY_NUM$1 && (N = 0), Math.abs(D) < TINY_NUM$1 && (D = 0);\n  var B = 0, $ = 0, U = 0;\n  return N ? D ? (B = -D / N, $ = 1, U = -B * e - o) : ($ = 1, U = -o) : D && (B = -1, U = e), [B, $, U];\n}\nfunction getIntersectionPointsByConstants(r, t) {\n  var e = r[0], o = r[1], T = r[2], S = t[0], N = t[1], D = t[2], B = e === 0 && S === 0, $ = o === 0 && N === 0, U = [];\n  if (B && $)\n    return [];\n  if (B) {\n    var z = -T / o, V = -D / N;\n    return z !== V ? [] : [[-1 / 0, z], [1 / 0, z]];\n  } else if ($) {\n    var X = -T / e, W = -D / S;\n    return X !== W ? [] : [[X, -1 / 0], [X, 1 / 0]];\n  } else if (e === 0) {\n    var Y = -T / o, q = -(N * Y + D) / S;\n    U = [[q, Y]];\n  } else if (S === 0) {\n    var Y = -D / N, q = -(o * Y + T) / e;\n    U = [[q, Y]];\n  } else if (o === 0) {\n    var q = -T / e, Y = -(S * q + D) / N;\n    U = [[q, Y]];\n  } else if (N === 0) {\n    var q = -D / S, Y = -(e * q + T) / o;\n    U = [[q, Y]];\n  } else {\n    var q = (o * D - N * T) / (N * e - o * S), Y = -(e * q + T) / o;\n    U = [[q, Y]];\n  }\n  return U.map(function(Z) {\n    return [Z[0], Z[1]];\n  });\n}\nfunction getPointsOnLines(r, t) {\n  var e = t.map(function(z) {\n    return [0, 1].map(function(V) {\n      return [Math.min(z[0][V], z[1][V]), Math.max(z[0][V], z[1][V])];\n    });\n  }), o = [];\n  if (r.length === 2) {\n    var T = r[0], S = T[0], N = T[1];\n    if (tinyThrottle(S - r[1][0])) {\n      if (!tinyThrottle(N - r[1][1])) {\n        var $ = Math.max.apply(Math, e.map(function(z) {\n          return z[0][0];\n        })), U = Math.min.apply(Math, e.map(function(z) {\n          return z[0][1];\n        }));\n        if (tinyThrottle($ - U) > 0)\n          return [];\n        o = [[$, N], [U, N]];\n      }\n    } else {\n      var D = Math.max.apply(Math, e.map(function(z) {\n        return z[1][0];\n      })), B = Math.min.apply(Math, e.map(function(z) {\n        return z[1][1];\n      }));\n      if (tinyThrottle(D - B) > 0)\n        return [];\n      o = [[S, D], [S, B]];\n    }\n  }\n  return o.length || (o = r.filter(function(z) {\n    var V = z[0], X = z[1];\n    return e.every(function(W) {\n      return 0 <= tinyThrottle(V - W[0][0]) && 0 <= tinyThrottle(W[0][1] - V) && 0 <= tinyThrottle(X - W[1][0]) && 0 <= tinyThrottle(W[1][1] - X);\n    });\n  })), o.map(function(z) {\n    return [tinyThrottle(z[0]), tinyThrottle(z[1])];\n  });\n}\nfunction convertLines(r) {\n  return __spreadArrays$2(r.slice(1), [r[0]]).map(function(t, e) {\n    return [r[e], t];\n  });\n}\nfunction getOverlapPointInfos(r, t) {\n  var e = r.slice(), o = t.slice();\n  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(o) === -1 && o.reverse();\n  var T = convertLines(e), S = convertLines(o), N = T.map(function(U) {\n    return getLinearConstants(U[0], U[1]);\n  }), D = S.map(function(U) {\n    return getLinearConstants(U[0], U[1]);\n  }), B = [];\n  N.forEach(function(U, z) {\n    var V = T[z], X = [];\n    D.forEach(function(W, Y) {\n      var q = getIntersectionPointsByConstants(U, W), Z = getPointsOnLines(q, [V, S[Y]]);\n      X.push.apply(X, Z.map(function(K) {\n        return {\n          index1: z,\n          index2: Y,\n          pos: K,\n          type: \"intersection\"\n        };\n      }));\n    }), X.sort(function(W, Y) {\n      return getDist$2(V[0], W.pos) - getDist$2(V[0], Y.pos);\n    }), B.push.apply(B, X), isInside(V[1], o) && B.push({\n      index1: z,\n      index2: -1,\n      pos: V[1],\n      type: \"inside\"\n    });\n  }), S.forEach(function(U, z) {\n    if (!!isInside(U[1], e)) {\n      var V = !1, X = findIndex(B, function(W) {\n        var Y = W.index2;\n        return Y === z ? (V = !0, !1) : !!V;\n      });\n      X === -1 && (V = !1, X = findIndex(B, function(W) {\n        var Y = W.index1, q = W.index2;\n        return Y === -1 && q + 1 === z ? (V = !0, !1) : !!V;\n      })), X === -1 ? B.push({\n        index1: -1,\n        index2: z,\n        pos: U[1],\n        type: \"inside\"\n      }) : B.splice(X, 0, {\n        index1: -1,\n        index2: z,\n        pos: U[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var $ = {};\n  return B.filter(function(U) {\n    var z = U.pos, V = z[0] + \"x\" + z[1];\n    return $[V] ? !1 : ($[V] = !0, !0);\n  });\n}\nfunction getOverlapPoints(r, t) {\n  var e = getOverlapPointInfos(r, t);\n  return e.map(function(o) {\n    var T = o.pos;\n    return T;\n  });\n}\nfunction getOverlapSize(r, t) {\n  var e = getOverlapPoints(r, t);\n  return getAreaSize(e);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign$6 = function() {\n  return __assign$6 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$6.apply(this, arguments);\n};\nfunction __spreadArrays$1() {\n  for (var r = 0, t = 0, e = arguments.length; t < e; t++)\n    r += arguments[t].length;\n  for (var o = Array(r), T = 0, t = 0; t < e; t++)\n    for (var S = arguments[t], N = 0, D = S.length; N < D; N++, T++)\n      o[T] = S[N];\n  return o;\n}\nvar EventEmitter$2 = /* @__PURE__ */ function() {\n  function r() {\n    this._events = {};\n  }\n  var t = r.prototype;\n  return t.on = function(e, o) {\n    if (isObject$2(e))\n      for (var T in e)\n        this.on(T, e[T]);\n    else\n      this._addEvent(e, o, {});\n    return this;\n  }, t.off = function(e, o) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var T in e)\n        this.off(T);\n    else if (!o)\n      this._events[e] = [];\n    else {\n      var S = this._events[e];\n      if (S) {\n        var N = findIndex(S, function(D) {\n          return D.listener === o;\n        });\n        N > -1 && S.splice(N, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, o) {\n    var T = this;\n    return o && this._addEvent(e, o, {\n      once: !0\n    }), new Promise(function(S) {\n      T._addEvent(e, S, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, o) {\n    var T = this;\n    o === void 0 && (o = {});\n    var S = this._events[e];\n    if (!e || !S)\n      return !0;\n    var N = !1;\n    return o.eventType = e, o.stop = function() {\n      N = !0;\n    }, o.currentTarget = this, __spreadArrays$1(S).forEach(function(D) {\n      D.listener(o), D.once && T.off(e, D.listener);\n    }), !N;\n  }, t.trigger = function(e, o) {\n    return o === void 0 && (o = {}), this.emit(e, o);\n  }, t._addEvent = function(e, o, T) {\n    var S = this._events;\n    S[e] = S[e] || [];\n    var N = S[e];\n    N.push(__assign$6({\n      listener: o\n    }, T));\n  }, r;\n}();\nconst EventEmitter$3 = EventEmitter$2;\nvar FUNCTION = \"function\", STRING = \"string\";\nfunction isString(r) {\n  return typeof r === STRING;\n}\nfunction isFunction$2(r) {\n  return typeof r === FUNCTION;\n}\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$4 = function(r, t) {\n  return extendStatics$4 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$4(r, t);\n};\nfunction __extends$4(r, t) {\n  extendStatics$4(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$5 = function() {\n  return __assign$5 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$5.apply(this, arguments);\n};\nfunction getDefaultScrollPosition$1(r) {\n  var t = r.container;\n  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];\n}\nfunction getContainerElement(r) {\n  if (r) {\n    if (isString(r))\n      return document.querySelector(r);\n  } else\n    return null;\n  if (isFunction$2(r))\n    return r();\n  if (r instanceof Element)\n    return r;\n  if (\"current\" in r)\n    return r.current;\n  if (\"value\" in r)\n    return r.value;\n}\nvar DragScroll = /* @__PURE__ */ function(r) {\n  __extends$4(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o._startRect = null, o._startPos = [], o._prevTime = 0, o._timer = 0, o._prevScrollPos = [0, 0], o._isWait = !1, o._flag = !1, o;\n  }\n  var e = t.prototype;\n  return e.dragStart = function(o, T) {\n    var S = getContainerElement(T.container);\n    if (!S) {\n      this._flag = !1;\n      return;\n    }\n    var N = 0, D = 0, B = 0, $ = 0;\n    if (S === document.body)\n      B = window.innerWidth, $ = window.innerHeight;\n    else {\n      var U = S.getBoundingClientRect();\n      N = U.top, D = U.left, B = U.width, $ = U.height;\n    }\n    this._flag = !0, this._startPos = [o.clientX, o.clientY], this._startRect = {\n      top: N,\n      left: D,\n      width: B,\n      height: $\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], T);\n  }, e.drag = function(o, T) {\n    if (!!this._flag) {\n      var S = o.clientX, N = o.clientY, D = T.threshold, B = D === void 0 ? 0 : D, $ = this, U = $._startRect, z = $._startPos, V = [0, 0];\n      return U.top > N - B ? (z[1] > U.top || N < z[1]) && (V[1] = -1) : U.top + U.height < N + B && (z[1] < U.top + U.height || N > z[1]) && (V[1] = 1), U.left > S - B ? (z[0] > U.left || S < z[0]) && (V[0] = -1) : U.left + U.width < S + B && (z[0] < U.left + U.width || S > z[0]) && (V[0] = 1), clearTimeout(this._timer), !V[0] && !V[1] ? !1 : this._continueDrag(__assign$5(__assign$5({}, T), {\n        direction: V,\n        inputEvent: o,\n        isDrag: !0\n      }));\n    }\n  }, e.checkScroll = function(o) {\n    var T = this;\n    if (this._isWait)\n      return !1;\n    var S = o.prevScrollPos, N = S === void 0 ? this._prevScrollPos : S, D = o.direction, B = o.throttleTime, $ = B === void 0 ? 0 : B, U = o.inputEvent, z = o.isDrag, V = this._getScrollPosition(D || [0, 0], o), X = V[0] - N[0], W = V[1] - N[1], Y = D || [X ? Math.abs(X) / X : 0, W ? Math.abs(W) / W : 0];\n    return this._prevScrollPos = V, !X && !W ? !1 : (this.trigger(\"move\", {\n      offsetX: Y[0] ? X : 0,\n      offsetY: Y[1] ? W : 0,\n      inputEvent: U\n    }), $ && z && (this._timer = window.setTimeout(function() {\n      T._continueDrag(o);\n    }, $)), !0);\n  }, e.dragEnd = function() {\n    clearTimeout(this._timer);\n  }, e._getScrollPosition = function(o, T) {\n    var S = T.container, N = T.getScrollPosition, D = N === void 0 ? getDefaultScrollPosition$1 : N;\n    return D({\n      container: getContainerElement(S),\n      direction: o\n    });\n  }, e._continueDrag = function(o) {\n    var T = this, S = o.container, N = o.direction, D = o.throttleTime, B = o.useScroll, $ = o.isDrag, U = o.inputEvent;\n    if (!($ && this._isWait)) {\n      var z = now(), V = Math.max(D + this._prevTime - z, 0);\n      if (V > 0)\n        return this._timer = window.setTimeout(function() {\n          T._continueDrag(o);\n        }, V), !1;\n      this._prevTime = z;\n      var X = this._getScrollPosition(N, o);\n      return this._prevScrollPos = X, $ && (this._isWait = !0), this.trigger(\"scroll\", {\n        container: getContainerElement(S),\n        direction: N,\n        inputEvent: U\n      }), this._isWait = !1, B || this.checkScroll(__assign$5(__assign$5({}, o), {\n        prevScrollPos: X,\n        direction: N,\n        inputEvent: U\n      }));\n    }\n  }, t;\n}(EventEmitter$3);\nconst DragScroll$1 = DragScroll;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$3 = function(r, t) {\n  return extendStatics$3 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$3(r, t);\n};\nfunction __extends$3(r, t) {\n  extendStatics$3(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$4 = function() {\n  return __assign$4 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$4.apply(this, arguments);\n};\nfunction getRad(r, t) {\n  var e = t[0] - r[0], o = t[1] - r[1], T = Math.atan2(o, e);\n  return T >= 0 ? T : T + Math.PI * 2;\n}\nfunction getRotatiion(r) {\n  return getRad([r[0].clientX, r[0].clientY], [r[1].clientX, r[1].clientY]) / Math.PI * 180;\n}\nfunction isMultiTouch(r) {\n  return r.touches && r.touches.length >= 2;\n}\nfunction getEventClients(r) {\n  return r ? r.touches ? getClients(r.touches) : [getClient(r)] : [];\n}\nfunction isMouseEvent(r) {\n  return r && (r.type.indexOf(\"mouse\") > -1 || \"button\" in r);\n}\nfunction getPosition(r, t, e) {\n  var o = e.length, T = getAverageClient(r, o), S = T.clientX, N = T.clientY, D = T.originalClientX, B = T.originalClientY, $ = getAverageClient(t, o), U = $.clientX, z = $.clientY, V = getAverageClient(e, o), X = V.clientX, W = V.clientY, Y = S - U, q = N - z, Z = S - X, K = N - W;\n  return {\n    clientX: D,\n    clientY: B,\n    deltaX: Y,\n    deltaY: q,\n    distX: Z,\n    distY: K\n  };\n}\nfunction getDist$1(r) {\n  return Math.sqrt(Math.pow(r[0].clientX - r[1].clientX, 2) + Math.pow(r[0].clientY - r[1].clientY, 2));\n}\nfunction getClients(r) {\n  for (var t = Math.min(r.length, 2), e = [], o = 0; o < t; ++o)\n    e.push(getClient(r[o]));\n  return e;\n}\nfunction getClient(r) {\n  return {\n    clientX: r.clientX,\n    clientY: r.clientY\n  };\n}\nfunction getAverageClient(r, t) {\n  t === void 0 && (t = r.length);\n  for (var e = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, o = 0; o < t; ++o) {\n    var T = r[o];\n    e.originalClientX += \"originalClientX\" in T ? T.originalClientX : T.clientX, e.originalClientY += \"originalClientY\" in T ? T.originalClientY : T.clientY, e.clientX += T.clientX, e.clientY += T.clientY;\n  }\n  return t ? {\n    clientX: e.clientX / t,\n    clientY: e.clientY / t,\n    originalClientX: e.originalClientX / t,\n    originalClientY: e.originalClientY / t\n  } : e;\n}\nvar ClientStore = /* @__PURE__ */ function() {\n  function r(e) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;\n  }\n  var t = r.prototype;\n  return t.getAngle = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e);\n  }, t.getRotation = function(e) {\n    return e === void 0 && (e = this.prevClients), getRotatiion(e) - getRotatiion(this.startClients);\n  }, t.getPosition = function(e, o) {\n    e === void 0 && (e = this.prevClients);\n    var T = getPosition(e || this.prevClients, this.prevClients, this.startClients), S = T.deltaX, N = T.deltaY;\n    return this.movement += Math.sqrt(S * S + N * N), this.prevClients = e, T;\n  }, t.getPositions = function(e) {\n    e === void 0 && (e = this.prevClients);\n    var o = this.prevClients;\n    return this.startClients.map(function(T, S) {\n      return getPosition([e[S]], [o[S]], [T]);\n    });\n  }, t.getMovement = function(e) {\n    var o = this.movement;\n    if (!e)\n      return o;\n    var T = getAverageClient(e, this.length), S = getAverageClient(this.prevClients, this.length), N = T.clientX - S.clientX, D = T.clientY - S.clientY;\n    return Math.sqrt(N * N + D * D) + o;\n  }, t.getDistance = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e);\n  }, t.getScale = function(e) {\n    return e === void 0 && (e = this.prevClients), getDist$1(e) / getDist$1(this.startClients);\n  }, t.move = function(e, o) {\n    this.startClients.forEach(function(T) {\n      T.clientX -= e, T.clientY -= o;\n    });\n  }, r;\n}(), INPUT_TAGNAMES = [\"textarea\", \"input\"], Gesto = /* @__PURE__ */ function(r) {\n  __extends$3(t, r);\n  function t(o, T) {\n    T === void 0 && (T = {});\n    var S = r.call(this) || this;\n    S.options = {}, S.flag = !1, S.pinchFlag = !1, S.data = {}, S.isDrag = !1, S.isPinch = !1, S.isMouse = !1, S.isTouch = !1, S.clientStores = [], S.targets = [], S.prevTime = 0, S.doubleFlag = !1, S._dragFlag = !1, S._isMouseEvent = !1, S._isSecondaryButton = !1, S._preventMouseEvent = !1, S.onDragStart = function(V, X) {\n      if (X === void 0 && (X = !0), !(!S.flag && V.cancelable === !1)) {\n        var W = S.options, Y = W.container, q = W.pinchOutside, Z = W.preventWheelClick, K = W.preventRightClick, J = W.preventDefault, tt = W.checkInput, et = W.preventClickEventOnDragStart, Q = W.preventClickEventOnDrag, at = W.preventClickEventByCondition, it = S.isTouch, st = !S.flag;\n        if (S._isSecondaryButton = V.which === 3 || V.button === 2, Z && (V.which === 2 || V.button === 1) || K && (V.which === 3 || V.button === 2))\n          return S.stop(), !1;\n        if (st) {\n          var ut = document.activeElement, ft = V.target;\n          if (ft) {\n            var ct = ft.tagName.toLowerCase(), pt = INPUT_TAGNAMES.indexOf(ct) > -1, mt = ft.isContentEditable;\n            if (pt || mt) {\n              if (tt || ut === ft || ut && mt && ut.isContentEditable && ut.contains(ft))\n                return !1;\n            } else if ((J || V.type === \"touchstart\") && ut) {\n              var vt = ut.tagName.toLowerCase();\n              (ut.isContentEditable || INPUT_TAGNAMES.indexOf(vt) > -1) && ut.blur();\n            }\n            (et || Q || at) && addEvent(window, \"click\", S._onClick, !0);\n          }\n          S.clientStores = [new ClientStore(getEventClients(V))], S.flag = !0, S.isDrag = !1, S._dragFlag = !0, S.data = {}, S.doubleFlag = now$1() - S.prevTime < 200, S._isMouseEvent = isMouseEvent(V), !S._isMouseEvent && S._preventMouseEvent && (S._preventMouseEvent = !1);\n          var _t = S._preventMouseEvent || S.emit(\"dragStart\", __assign$4(__assign$4({\n            data: S.data,\n            datas: S.data,\n            inputEvent: V,\n            isMouseEvent: S._isMouseEvent,\n            isSecondaryButton: S._isSecondaryButton,\n            isTrusted: X,\n            isDouble: S.doubleFlag\n          }, S.getCurrentStore().getPosition()), {\n            preventDefault: function() {\n              V.preventDefault();\n            },\n            preventDrag: function() {\n              S._dragFlag = !1;\n            }\n          }));\n          _t === !1 && S.stop(), S._isMouseEvent && S.flag && J && V.preventDefault();\n        }\n        if (!S.flag)\n          return !1;\n        var xt = 0;\n        if (st ? (S._attchDragEvent(), it && q && (xt = setTimeout(function() {\n          addEvent(Y, \"touchstart\", S.onDragStart, {\n            passive: !1\n          });\n        }))) : it && q && removeEvent(Y, \"touchstart\", S.onDragStart), S.flag && isMultiTouch(V)) {\n          if (clearTimeout(xt), st && V.touches.length !== V.changedTouches.length)\n            return;\n          S.pinchFlag || S.onPinchStart(V);\n        }\n      }\n    }, S.onDrag = function(V, X) {\n      if (!!S.flag) {\n        var W = S.options.preventDefault;\n        !S._isMouseEvent && W && V.preventDefault();\n        var Y = getEventClients(V), q = S.moveClients(Y, V, !1);\n        if (S._dragFlag) {\n          if (S.pinchFlag || q.deltaX || q.deltaY) {\n            var Z = S._preventMouseEvent || S.emit(\"drag\", __assign$4(__assign$4({}, q), {\n              isScroll: !!X,\n              inputEvent: V\n            }));\n            if (Z === !1) {\n              S.stop();\n              return;\n            }\n          }\n          S.pinchFlag && S.onPinch(V, Y);\n        }\n        S.getCurrentStore().getPosition(Y, !0);\n      }\n    }, S.onDragEnd = function(V) {\n      if (!!S.flag) {\n        var X = S.options, W = X.pinchOutside, Y = X.container, q = X.preventClickEventOnDrag, Z = X.preventClickEventOnDragStart, K = X.preventClickEventByCondition, J = S.isDrag;\n        (q || Z || K) && requestAnimationFrame(function() {\n          S._allowClickEvent();\n        }), !K && !Z && q && !J && S._allowClickEvent(), S.isTouch && W && removeEvent(Y, \"touchstart\", S.onDragStart), S.pinchFlag && S.onPinchEnd(V);\n        var tt = V != null && V.touches ? getEventClients(V) : [], et = tt.length;\n        et === 0 || !S.options.keepDragging ? S.flag = !1 : S._addStore(new ClientStore(tt));\n        var Q = S._getPosition(), at = now$1(), it = !J && S.doubleFlag;\n        S.prevTime = J || it ? 0 : at, S.flag || (S._dettachDragEvent(), S._preventMouseEvent || S.emit(\"dragEnd\", __assign$4({\n          data: S.data,\n          datas: S.data,\n          isDouble: it,\n          isDrag: J,\n          isClick: !J,\n          isMouseEvent: S._isMouseEvent,\n          isSecondaryButton: S._isSecondaryButton,\n          inputEvent: V\n        }, Q)), S.clientStores = [], S._isMouseEvent || (S._preventMouseEvent = !0, requestAnimationFrame(function() {\n          requestAnimationFrame(function() {\n            S._preventMouseEvent = !1;\n          });\n        })));\n      }\n    }, S.onBlur = function() {\n      S.onDragEnd();\n    }, S._allowClickEvent = function() {\n      removeEvent(window, \"click\", S._onClick, !0);\n    }, S._onClick = function(V) {\n      S._allowClickEvent(), S._preventMouseEvent = !1;\n      var X = S.options.preventClickEventByCondition;\n      X != null && X(V) || (V.stopPropagation(), V.preventDefault());\n    }, S._onContextMenu = function(V) {\n      var X = S.options;\n      X.preventRightClick ? S.onDragEnd(V) : V.preventDefault();\n    }, S._passCallback = function() {\n    };\n    var N = [].concat(o);\n    S.options = __assign$4({\n      checkInput: !1,\n      container: N.length > 1 ? window : N[0],\n      preventRightClick: !0,\n      preventWheelClick: !0,\n      preventClickEventOnDragStart: !1,\n      preventClickEventOnDrag: !1,\n      preventClickEventByCondition: null,\n      preventDefault: !0,\n      checkWindowBlur: !1,\n      keepDragging: !1,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, T);\n    var D = S.options, B = D.container, $ = D.events, U = D.checkWindowBlur;\n    if (S.isTouch = $.indexOf(\"touch\") > -1, S.isMouse = $.indexOf(\"mouse\") > -1, S.targets = N, S.isMouse && (N.forEach(function(V) {\n      addEvent(V, \"mousedown\", S.onDragStart), addEvent(V, \"mousemove\", S._passCallback);\n    }), addEvent(B, \"contextmenu\", S._onContextMenu)), U && addEvent(window, \"blur\", S.onBlur), S.isTouch) {\n      var z = {\n        passive: !1\n      };\n      N.forEach(function(V) {\n        addEvent(V, \"touchstart\", S.onDragStart, z), addEvent(V, \"touchmove\", S._passCallback, z);\n      });\n    }\n    return S;\n  }\n  var e = t.prototype;\n  return e.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();\n  }, e.getMovement = function(o) {\n    return this.getCurrentStore().getMovement(o) + this.clientStores.slice(1).reduce(function(T, S) {\n      return T + S.movement;\n    }, 0);\n  }, e.isDragging = function() {\n    return this.isDrag;\n  }, e.isFlag = function() {\n    return this.flag;\n  }, e.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, e.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, e.isPinching = function() {\n    return this.isPinch;\n  }, e.scrollBy = function(o, T, S, N) {\n    N === void 0 && (N = !0), this.flag && (this.clientStores[0].move(o, T), N && this.onDrag(S, !0));\n  }, e.move = function(o, T) {\n    var S = o[0], N = o[1], D = this.getCurrentStore(), B = D.prevClients;\n    return this.moveClients(B.map(function($) {\n      var U = $.clientX, z = $.clientY;\n      return {\n        clientX: U + S,\n        clientY: z + N,\n        originalClientX: U,\n        originalClientY: z\n      };\n    }), T, !0);\n  }, e.triggerDragStart = function(o) {\n    this.onDragStart(o, !1);\n  }, e.setEventData = function(o) {\n    var T = this.data;\n    for (var S in o)\n      T[S] = o[S];\n    return this;\n  }, e.setEventDatas = function(o) {\n    return this.setEventData(o);\n  }, e.getCurrentEvent = function(o) {\n    return __assign$4(__assign$4({\n      data: this.data,\n      datas: this.data\n    }, this._getPosition()), {\n      movement: this.getMovement(),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      inputEvent: o\n    });\n  }, e.getEventData = function() {\n    return this.data;\n  }, e.getEventDatas = function() {\n    return this.data;\n  }, e.unset = function() {\n    var o = this, T = this.targets, S = this.options.container;\n    this.off(), removeEvent(window, \"blur\", this.onBlur), this.isMouse && (T.forEach(function(N) {\n      removeEvent(N, \"mousedown\", o.onDragStart);\n    }), removeEvent(S, \"contextmenu\", this._onContextMenu)), this.isTouch && (T.forEach(function(N) {\n      removeEvent(N, \"touchstart\", o.onDragStart);\n    }), removeEvent(S, \"touchstart\", this.onDragStart)), this._allowClickEvent(), this._dettachDragEvent();\n  }, e.onPinchStart = function(o) {\n    var T = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > T)) {\n      var S = new ClientStore(getEventClients(o));\n      this.pinchFlag = !0, this._addStore(S);\n      var N = this.emit(\"pinchStart\", __assign$4(__assign$4({\n        data: this.data,\n        datas: this.data,\n        angle: S.getAngle(),\n        touches: this.getCurrentStore().getPositions()\n      }, S.getPosition()), {\n        inputEvent: o\n      }));\n      N === !1 && (this.pinchFlag = !1);\n    }\n  }, e.onPinch = function(o, T) {\n    if (!(!this.flag || !this.pinchFlag || T.length < 2)) {\n      var S = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", __assign$4(__assign$4({\n        data: this.data,\n        datas: this.data,\n        movement: this.getMovement(T),\n        angle: S.getAngle(T),\n        rotation: S.getRotation(T),\n        touches: S.getPositions(T),\n        scale: S.getScale(T),\n        distance: S.getDistance(T)\n      }, S.getPosition(T)), {\n        inputEvent: o\n      }));\n    }\n  }, e.onPinchEnd = function(o) {\n    if (!!this.pinchFlag) {\n      var T = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var S = this.getCurrentStore();\n      this.emit(\"pinchEnd\", __assign$4(__assign$4({\n        data: this.data,\n        datas: this.data,\n        isPinch: T,\n        touches: S.getPositions()\n      }, S.getPosition()), {\n        inputEvent: o\n      }));\n    }\n  }, e.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, e.moveClients = function(o, T, S) {\n    var N = this._getPosition(o, S);\n    return (N.deltaX || N.deltaY) && (this.isDrag = !0), __assign$4(__assign$4({\n      data: this.data,\n      datas: this.data\n    }, N), {\n      movement: this.getMovement(o),\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: !1,\n      isMouseEvent: this._isMouseEvent,\n      isSecondaryButton: this._isSecondaryButton,\n      inputEvent: T\n    });\n  }, e._addStore = function(o) {\n    this.clientStores.splice(0, 0, o);\n  }, e._getPosition = function(o, T) {\n    var S = this.getCurrentStore(), N = S.getPosition(o, T), D = this.clientStores.slice(1).reduce(function(U, z) {\n      var V = z.getPosition();\n      return U.distX += V.distX, U.distY += V.distY, U;\n    }, N), B = D.distX, $ = D.distY;\n    return __assign$4(__assign$4({}, N), {\n      distX: B,\n      distY: $\n    });\n  }, e._attchDragEvent = function() {\n    var o = this.options.container, T = {\n      passive: !1\n    };\n    this.isMouse && (addEvent(o, \"mousemove\", this.onDrag), addEvent(o, \"mouseup\", this.onDragEnd)), this.isTouch && (addEvent(o, \"touchmove\", this.onDrag, T), addEvent(o, \"touchend\", this.onDragEnd, T), addEvent(o, \"touchcancel\", this.onDragEnd, T));\n  }, e._dettachDragEvent = function() {\n    var o = this.options.container;\n    this.isMouse && (removeEvent(o, \"mousemove\", this.onDrag), removeEvent(o, \"mouseup\", this.onDragEnd)), this.isTouch && (removeEvent(o, \"touchstart\", this.onDragStart), removeEvent(o, \"touchmove\", this.onDrag), removeEvent(o, \"touchend\", this.onDragEnd), removeEvent(o, \"touchcancel\", this.onDragEnd));\n  }, t;\n}(EventEmitter$3);\nconst Gesto$1 = Gesto;\nfunction hash$2(r) {\n  for (var t = 5381, e = r.length; e; )\n    t = t * 33 ^ r.charCodeAt(--e);\n  return t >>> 0;\n}\nvar stringHash = hash$2;\nfunction getHash(r) {\n  return stringHash(r).toString(36);\n}\nfunction getShadowRoot$1(r) {\n  if (r && r.getRootNode) {\n    var t = r.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction replaceStyle(r, t, e) {\n  return e.original ? t : t.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(o, T) {\n    var S = T.trim();\n    return (S ? splitComma(S) : [\"\"]).map(function(N) {\n      var D = N.trim();\n      return D.indexOf(\"@\") === 0 ? D : D.indexOf(\":global\") > -1 ? D.replace(/\\:global/g, \"\") : D.indexOf(\":host\") > -1 ? \"\" + D.replace(/\\:host/g, \".\" + r) : D ? \".\" + r + \" \" + D : \".\" + r;\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(r, t, e, o) {\n  var T = document.createElement(\"style\");\n  return T.setAttribute(\"type\", \"text/css\"), T.setAttribute(\"data-styled-id\", r), e.nonce && T.setAttribute(\"nonce\", e.nonce), T.innerHTML = replaceStyle(r, t, e), (o || document.head || document.body).appendChild(T), T;\n}\nfunction styled$1(r) {\n  var t = \"rCS\" + getHash(r), e = 0, o;\n  return {\n    className: t,\n    inject: function(T, S) {\n      S === void 0 && (S = {});\n      var N = getShadowRoot$1(T), D = e === 0, B;\n      return (N || D) && (B = injectStyle(t, r, S, N)), D && (o = B), N || ++e, {\n        destroy: function() {\n          N ? (N.removeChild(B), B = null) : (e > 0 && --e, e === 0 && o && (o.parentNode.removeChild(o), o = null));\n        }\n      };\n    }\n  };\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar extendStatics$2 = function(r, t) {\n  return extendStatics$2 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics$2(r, t);\n};\nfunction __extends$2(r, t) {\n  extendStatics$2(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$3 = function() {\n  return __assign$3 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$3.apply(this, arguments);\n};\nfunction __rest$1(r, t) {\n  var e = {};\n  for (var o in r)\n    Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (e[o] = r[o]);\n  if (r != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var T = 0, o = Object.getOwnPropertySymbols(r); T < o.length; T++)\n      t.indexOf(o[T]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[T]) && (e[o[T]] = r[o[T]]);\n  return e;\n}\nvar StyledElement = /* @__PURE__ */ function(r) {\n  __extends$2(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.injectResult = null, o.tag = \"div\", o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this.props, T = o.className, S = T === void 0 ? \"\" : T;\n    o.cspNonce;\n    var N = o.portalContainer, D = __rest$1(o, [\"className\", \"cspNonce\", \"portalContainer\"]), B = this.injector.className, $ = this.tag, U = {};\n    return version.indexOf(\"simple\") > -1 && N && (U = {\n      portalContainer: N\n    }), createElement($, __assign$3({\n      ref: ref(this, \"element\"),\n      \"data-styled-id\": B,\n      className: S + \" \" + B\n    }, U, D));\n  }, e.componentDidMount = function() {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  }, e.componentWillUnmount = function() {\n    this.injectResult.destroy(), this.injectResult = null;\n  }, e.getElement = function() {\n    return this.element;\n  }, t;\n}(Component);\nfunction styled(r, t) {\n  var e = styled$1(t);\n  return /* @__PURE__ */ function(o) {\n    __extends$2(T, o);\n    function T() {\n      var S = o !== null && o.apply(this, arguments) || this;\n      return S.injector = e, S.tag = r, S;\n    }\n    return T;\n  }(StyledElement);\n}\nvar extendStatics$1 = function(r, t) {\n  return extendStatics$1 = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      Object.prototype.hasOwnProperty.call(o, T) && (e[T] = o[T]);\n  }, extendStatics$1(r, t);\n};\nfunction __extends$1(r, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  extendStatics$1(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$2 = function() {\n  return __assign$2 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$2.apply(this, arguments);\n};\nfunction __rest(r, t) {\n  var e = {};\n  for (var o in r)\n    Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (e[o] = r[o]);\n  if (r != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var T = 0, o = Object.getOwnPropertySymbols(r); T < o.length; T++)\n      t.indexOf(o[T]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[T]) && (e[o[T]] = r[o[T]]);\n  return e;\n}\nfunction __decorate$1(r, t, e, o) {\n  var T = arguments.length, S = T < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, N;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    S = Reflect.decorate(r, t, e, o);\n  else\n    for (var D = r.length - 1; D >= 0; D--)\n      (N = r[D]) && (S = (T < 3 ? N(S) : T > 3 ? N(t, e, S) : N(t, e)) || S);\n  return T > 3 && S && Object.defineProperty(t, e, S), S;\n}\nfunction __spreadArray(r, t, e) {\n  if (e || arguments.length === 2)\n    for (var o = 0, T = t.length, S; o < T; o++)\n      (S || !(o in t)) && (S || (S = Array.prototype.slice.call(t, 0, o)), S[o] = t[o]);\n  return r.concat(S || Array.prototype.slice.call(t));\n}\nfunction makeAble(r, t) {\n  var e;\n  return __assign$2({\n    events: {},\n    props: (e = {}, e[r] = Boolean, e),\n    name: r\n  }, t);\n}\nfunction getSVGCursor(r, t) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * r, 'px\" height=\"').concat(32 * r, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction getCursorCSS(r) {\n  var t = getSVGCursor(1, r), e = Math.round(r / 45) * 45 % 180, o = \"ns-resize\";\n  return e === 135 ? o = \"nwse-resize\" : e === 45 ? o = \"nesw-resize\" : e === 90 && (o = \"ew-resize\"), \"cursor:\".concat(o, \";cursor: url('\").concat(t, \"') 16 16, \").concat(o, \";\");\n}\nvar agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {\n  var r = typeof window > \"u\" ? {\n    userAgent: \"\"\n  } : window.navigator, t = /applewebkit\\/([^\\s]+)/g.exec(r.userAgent.toLowerCase());\n  return t ? parseFloat(t[1]) < 605 : !1;\n}(), IS_FIREFOX = agent.browser.name === \"firefox\", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = \"moveable-\", MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.edge {\n    z-index: 1;\n    background: transparent;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(r) {\n  return `\n.direction[data-rotation=\"`.concat(r, `\"] {\n\t`).concat(getCursorCSS(r), `\n}\n`);\n}).join(`\n`), `\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n`).concat(IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\", `\n`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"], DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"], DIRECTION_REGION_TO_DIRECTION = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, DIRECTION_INDEXES = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\", \"waitToChangeTarget\", \"updateSelectors\"];\nfunction setCustomDrag(r, t, e, o, T, S) {\n  S === void 0 && (S = \"draggable\");\n  var N = t.gestos[S].move(e, r.inputEvent), D = N.originalDatas || N.datas, B = D[S] || (D[S] = {});\n  return __assign$2(__assign$2({}, T ? convertDragDist(t, N) : N), {\n    isPinch: !!o,\n    parentEvent: !0,\n    datas: B,\n    originalDatas: r.originalDatas\n  });\n}\nvar CustomGesto = /* @__PURE__ */ function() {\n  function r(e) {\n    var o;\n    e === void 0 && (e = \"draggable\"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {\n      draggable: {}\n    }, this.datas = (o = {}, o[e] = {}, o);\n  }\n  var t = r.prototype;\n  return t.dragStart = function(e, o) {\n    this.isDrag = !1, this.isFlag = !1;\n    var T = o.originalDatas;\n    return this.datas = T, T[this.ableName] || (T[this.ableName] = {}), __assign$2(__assign$2({}, this.move(e, o.inputEvent)), {\n      type: \"dragstart\"\n    });\n  }, t.drag = function(e, o) {\n    return this.move([e[0] - this.prevX, e[1] - this.prevY], o);\n  }, t.move = function(e, o) {\n    var T, S;\n    return this.isFlag ? (T = this.prevX + e[0], S = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0)) : (this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], T = e[0], S = e[1], this.isFlag = !0), this.prevX = T, this.prevY = S, {\n      type: \"drag\",\n      clientX: T,\n      clientY: S,\n      inputEvent: o,\n      isDrag: this.isDrag,\n      distX: T - this.startX,\n      distY: S - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }, r;\n}();\nfunction calculatePointerDist(r, t) {\n  var e = t.clientX, o = t.clientY, T = t.datas, S = r.state, N = S.moveableClientRect, D = S.rootMatrix, B = S.is3d, $ = S.pos1, U = N.left, z = N.top, V = B ? 4 : 3, X = minus(calculateInversePosition(D, [e - U, o - z], V), $), W = X[0], Y = X[1], q = getDragDist({\n    datas: T,\n    distX: W,\n    distY: Y\n  }), Z = q[0], K = q[1];\n  return [Z, K];\n}\nfunction setDragStart(r, t) {\n  var e = t.datas, o = r.state, T = o.allMatrix, S = o.beforeMatrix, N = o.is3d, D = o.left, B = o.top, $ = o.origin, U = o.offsetMatrix, z = o.targetMatrix, V = o.transformOrigin, X = N ? 4 : 3;\n  e.is3d = N, e.matrix = T, e.targetMatrix = z, e.beforeMatrix = S, e.offsetMatrix = U, e.transformOrigin = V, e.inverseMatrix = invert(T, X), e.inverseBeforeMatrix = invert(S, X), e.absoluteOrigin = convertPositionMatrix(plus([D, B], $), X), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, X), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, X);\n}\nfunction getTransformDirection(r) {\n  return calculateMoveablePosition(r.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction resolveTransformEvent(r, t) {\n  var e = r.datas, o = r.originalDatas.beforeRenderable, T = e.transformIndex, S = o.nextTransforms, N = S.length, D = o.nextTransformAppendedIndexes, B = 0;\n  T === -1 ? (B = S.length, e.transformIndex = B) : find$1(D, function(V) {\n    return V.index === T && V.functionName === t;\n  }) ? B = T : B = T + D.filter(function(V) {\n    return V.index < T;\n  }).length;\n  var $ = convertTransformInfo(S, B), U = $.targetFunction, z = t === \"rotate\" ? \"rotateZ\" : t;\n  e.beforeFunctionTexts = $.beforeFunctionTexts, e.afterFunctionTexts = $.afterFunctionTexts, e.beforeTransform = $.beforeFunctionMatrix, e.beforeTransform2 = $.beforeFunctionMatrix2, e.targetTansform = $.targetFunctionMatrix, e.afterTransform = $.afterFunctionMatrix, e.afterTransform2 = $.afterFunctionMatrix2, e.targetAllTransform = $.allFunctionMatrix, U.functionName === z ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : N > B && (e.isAppendTransform = !0, o.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], D, !0), [{\n    functionName: t,\n    index: B,\n    isAppend: !0\n  }], !1));\n}\nfunction convertTransformFormat(r, t, e) {\n  return \"\".concat(r.beforeFunctionTexts.join(\" \"), \" \").concat(r.isAppendTransform ? e : t, \" \").concat(r.afterFunctionTexts.join(\" \"));\n}\nfunction getTransformDist(r) {\n  var t = r.datas, e = r.distX, o = r.distY, T = getBeforeDragDist({\n    datas: t,\n    distX: e,\n    distY: o\n  }), S = T[0], N = T[1], D = getTransfromMatrix(t, fromTranslation([S, N], 4));\n  return calculate(D, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nfunction getTransfromMatrix(r, t, e) {\n  var o = r.beforeTransform, T = r.afterTransform, S = r.beforeTransform2, N = r.afterTransform2, D = r.targetAllTransform, B = e ? multiply(D, t, 4) : multiply(t, D, 4), $ = multiply(invert(e ? S : o, 4), B, 4), U = multiply($, invert(e ? N : T, 4), 4);\n  return U;\n}\nfunction getBeforeDragDist(r) {\n  var t = r.datas, e = r.distX, o = r.distY, T = t.inverseBeforeMatrix, S = t.is3d, N = t.startDragBeforeDist, D = t.absoluteOrigin, B = S ? 4 : 3;\n  return minus(calculate(T, plus(D, [e, o]), B), N);\n}\nfunction getDragDist(r, t) {\n  var e = r.datas, o = r.distX, T = r.distY, S = e.inverseBeforeMatrix, N = e.inverseMatrix, D = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, z = D ? 4 : 3;\n  return minus(calculate(t ? S : N, plus(U, [o, T]), z), t ? B : $);\n}\nfunction getInverseDragDist(r, t) {\n  var e = r.datas, o = r.distX, T = r.distY, S = e.beforeMatrix, N = e.matrix, D = e.is3d, B = e.startDragBeforeDist, $ = e.startDragDist, U = e.absoluteOrigin, z = D ? 4 : 3;\n  return minus(calculate(t ? S : N, plus(t ? B : $, [o, T]), z), U);\n}\nfunction calculateTransformOrigin(r, t, e, o, T, S) {\n  return o === void 0 && (o = t), T === void 0 && (T = e), S === void 0 && (S = [0, 0]), r ? r.map(function(N, D) {\n    var B = splitUnit(N), $ = B.value, U = B.unit, z = D ? T : o, V = D ? e : t;\n    if (N === \"%\" || isNaN($)) {\n      var X = z ? S[D] / z : 0;\n      return V * X;\n    } else if (U !== \"%\")\n      return $;\n    return V * $ / 100;\n  }) : S;\n}\nfunction getPosIndexesByDirection(r) {\n  var t = [];\n  return r[1] >= 0 && (r[0] >= 0 && t.push(3), r[0] <= 0 && t.push(2)), r[1] <= 0 && (r[0] >= 0 && t.push(1), r[0] <= 0 && t.push(0)), t;\n}\nfunction getPosesByDirection(r, t) {\n  return getPosIndexesByDirection(t).map(function(e) {\n    return r[e];\n  });\n}\nfunction getPosByDirection(r, t) {\n  var e = (t[0] + 1) / 2, o = (t[1] + 1) / 2, T = [dot(r[0][0], r[1][0], e, 1 - e), dot(r[0][1], r[1][1], e, 1 - e)], S = [dot(r[2][0], r[3][0], e, 1 - e), dot(r[2][1], r[3][1], e, 1 - e)];\n  return [dot(T[0], S[0], o, 1 - o), dot(T[1], S[1], o, 1 - o)];\n}\nfunction getDist(r, t, e, o, T, S) {\n  var N = calculatePoses(t, e, o, T), D = getPosByDirection(N, S), B = r[0] - D[0], $ = r[1] - D[1];\n  return [B, $];\n}\nfunction getNextMatrix(r, t, e, o) {\n  return multiply(r, getAbsoluteMatrix(t, o, e), o);\n}\nfunction getNextTransformMatrix(r, t, e) {\n  var o = r.transformOrigin, T = r.offsetMatrix, S = r.is3d, N = t.beforeTransform, D = t.afterTransform, B = S ? 4 : 3, $ = parseMat([e]);\n  return getNextMatrix(T, convertDimension(multiply(multiply(N, $, 4), D, 4), 4, B), o, B);\n}\nfunction scaleMatrix(r, t) {\n  var e = r.transformOrigin, o = r.offsetMatrix, T = r.is3d, S = r.targetMatrix, N = T ? 4 : 3;\n  return getNextMatrix(o, multiply(S, createScaleMatrix(t, N), N), e, N);\n}\nfunction fillTransformStartEvent(r) {\n  var t = getBeforeRenderableDatas(r);\n  return {\n    setTransform: function(e, o) {\n      o === void 0 && (o = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(r, o);\n    },\n    setTransformIndex: function(e) {\n      setTransformIndex(r, e);\n    }\n  };\n}\nfunction setDefaultTransformIndex(r, t) {\n  var e = getBeforeRenderableDatas(r), o = e.startTransforms;\n  setTransformIndex(r, findIndex(o, function(T) {\n    return T.indexOf(\"\".concat(t, \"(\")) === 0;\n  }));\n}\nfunction setTransformIndex(r, t) {\n  var e = getBeforeRenderableDatas(r), o = r.datas;\n  if (o.transformIndex = t, t !== -1) {\n    var T = e.startTransforms[t];\n    if (!!T) {\n      var S = parse([T]);\n      o.startValue = S[0].functionValue;\n    }\n  }\n}\nfunction fillOriginalTransform(r, t) {\n  var e = getBeforeRenderableDatas(r);\n  e.nextTransforms = splitSpace(t);\n}\nfunction getBeforeRenderableDatas(r) {\n  return r.originalDatas.beforeRenderable;\n}\nfunction getNextTransforms(r) {\n  var t = r.originalDatas.beforeRenderable;\n  return t.nextTransforms;\n}\nfunction getNextTransformText(r) {\n  return getNextTransforms(r).join(\" \");\n}\nfunction getNextStyle(r) {\n  return getBeforeRenderableDatas(r).nextStyle;\n}\nfunction fillTransformEvent(r, t, e, o, T) {\n  fillOriginalTransform(T, t);\n  var S = Draggable.drag(r, setCustomDrag(T, r.state, e, o, !1)), N = S ? S.transform : t;\n  return __assign$2(__assign$2({\n    transform: t,\n    drag: S\n  }, fillCSSObject({\n    transform: N\n  }, T)), {\n    afterTransform: N\n  });\n}\nfunction getTranslateDist(r, t, e, o, T) {\n  var S = r.state, N = S.left, D = S.top, B = r.props.groupable, $ = getNextTransformMatrix(r.state, T, t), U = B ? N : 0, z = B ? D : 0, V = getDirectionOffset(r, e, $), X = minus(o, V);\n  return minus(X, [U, z]);\n}\nfunction getScaleDist(r, t, e, o, T) {\n  var S = getTranslateDist(r, \"scale(\".concat(t.join(\", \"), \")\"), e, o, T);\n  return S;\n}\nfunction getOriginDirection(r) {\n  var t = r.state, e = t.width, o = t.height, T = t.transformOrigin;\n  return [-1 + T[0] / (e / 2), -1 + T[1] / (o / 2)];\n}\nfunction getDirectionOffset(r, t, e) {\n  e === void 0 && (e = r.state.allMatrix);\n  var o = r.state, T = o.width, S = o.height, N = o.is3d, D = N ? 4 : 3, B = [T / 2 * (1 + t[0]), S / 2 * (1 + t[1])];\n  return calculatePosition(e, B, D);\n}\nfunction getRotateDist(r, t, e) {\n  var o = e.fixedDirection, T = e.fixedPosition;\n  return getTranslateDist(r, \"rotate(\".concat(t, \"deg)\"), o, T, e);\n}\nfunction getResizeDist(r, t, e, o, T, S) {\n  var N = r.props.groupable, D = r.state, B = D.transformOrigin, $ = D.offsetMatrix, U = D.is3d, z = D.width, V = D.height, X = D.left, W = D.top, Y = S.fixedDirection, q = S.nextTargetMatrix || D.targetMatrix, Z = U ? 4 : 3, K = calculateTransformOrigin(T, t, e, z, V, B), J = N ? X : 0, tt = N ? W : 0, et = getNextMatrix($, q, K, Z), Q = getDist(o, et, t, e, Z, Y);\n  return minus(Q, [J, tt]);\n}\nfunction getAbsolutePosition(r, t) {\n  return getPosByDirection(getAbsolutePosesByState(r.state), t);\n}\nfunction multiply2(r, t) {\n  return [r[0] * t[0], r[1] * t[1]];\n}\nfunction prefix() {\n  for (var r = [], t = 0; t < arguments.length; t++)\n    r[t] = arguments[t];\n  return prefixNames.apply(void 0, __spreadArray([PREFIX], r, !1));\n}\nfunction defaultSync(r) {\n  r();\n}\nfunction getTransformMatrix(r) {\n  return !r || r === \"none\" ? [1, 0, 0, 1, 0, 0] : isObject$2(r) ? r : parseMat(r);\n}\nfunction getAbsoluteMatrix(r, t, e) {\n  return multiplies(t, createOriginMatrix(e, t), r, createOriginMatrix(e.map(function(o) {\n    return -o;\n  }), t));\n}\nfunction measureSVGSize(r, t, e) {\n  if (t === \"%\") {\n    var o = getSVGViewBox(r.ownerSVGElement);\n    return o[e ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction getBeforeTransformOrigin(r) {\n  var t = getTransformOrigin(getComputedStyle$1$1(r, \":before\"));\n  return t.map(function(e, o) {\n    var T = splitUnit(e), S = T.value, N = T.unit;\n    return S * measureSVGSize(r, N, o === 0);\n  });\n}\nfunction getTransformOrigin(r) {\n  var t = r.transformOrigin;\n  return t ? t.split(\" \") : [\"0\", \"0\"];\n}\nfunction getElementTransform(r, t) {\n  t === void 0 && (t = getComputedStyle$1$1(r));\n  var e = t.transform;\n  if (e && e !== \"none\")\n    return t.transform;\n  if (\"transform\" in r) {\n    var o = r.transform, T = o.baseVal;\n    if (!T)\n      return \"\";\n    var S = T.length;\n    if (!S)\n      return \"\";\n    for (var N = [], D = function($) {\n      var U = T[$].matrix;\n      N.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(z) {\n        return U[z];\n      }).join(\", \"), \")\"));\n    }, B = 0; B < S; ++B)\n      D(B);\n    return N.join(\" \");\n  }\n  return \"\";\n}\nfunction getOffsetInfo(r, t, e) {\n  var o, T, S = document.body, N = !1, D, B;\n  if (!r || e)\n    D = r;\n  else {\n    var $ = (o = r == null ? void 0 : r.assignedSlot) === null || o === void 0 ? void 0 : o.parentElement, U = r.parentElement;\n    $ ? (N = !0, B = U, D = $) : D = U;\n  }\n  for (var z = !1, V = r === t || D === t, X = \"relative\"; D && D !== S; ) {\n    t === D && (V = !0);\n    var W = getComputedStyle$1$1(D), Y = D.tagName.toLowerCase(), q = getElementTransform(D, W), Z = W.willChange;\n    if (X = W.position, Y === \"svg\" || X !== \"static\" || q && q !== \"none\" || Z === \"transform\")\n      break;\n    var K = (T = r == null ? void 0 : r.assignedSlot) === null || T === void 0 ? void 0 : T.parentNode, J = D.parentNode;\n    K && (N = !0, B = J);\n    var tt = K || J;\n    if (tt && tt.nodeType === 11) {\n      D = tt.host, z = !0;\n      break;\n    }\n    D = tt, X = \"relative\";\n  }\n  return {\n    hasSlot: N,\n    parentSlotElement: B,\n    isCustomElement: z,\n    isStatic: X === \"static\",\n    isEnd: V || !D || D === S,\n    offsetParent: D || S\n  };\n}\nfunction getOffsetPosInfo(r, t, e) {\n  var o, T = r.tagName.toLowerCase(), S = r.offsetLeft, N = r.offsetTop, D = isUndefined(S), B = !D, $, U;\n  return !B && T !== \"svg\" ? ($ = IS_WEBKIT605 ? getBeforeTransformOrigin(r) : getTransformOrigin(e).map(function(z) {\n    return parseFloat(z);\n  }), U = $.slice(), B = !0, o = getSVGGraphicsOffset(r, $, r === t && t.tagName.toLowerCase() === \"g\"), S = o[0], N = o[1], $[0] = o[2], $[1] = o[3]) : ($ = getTransformOrigin(e).map(function(z) {\n    return parseFloat(z);\n  }), U = $.slice()), {\n    tagName: T,\n    isSVG: D,\n    hasOffset: B,\n    offset: [S || 0, N || 0],\n    origin: $,\n    targetOrigin: U\n  };\n}\nfunction getBodyOffset(r, t, e) {\n  e === void 0 && (e = getComputedStyle$1$1(r));\n  var o = getComputedStyle$1$1(document.body), T = o.position;\n  if (!t && (!T || T === \"static\"))\n    return [0, 0];\n  var S = parseInt(o.marginLeft, 10), N = parseInt(o.marginTop, 10);\n  return e.position === \"absolute\" && ((e.top !== \"auto\" || e.bottom !== \"auto\") && (N = 0), (e.left !== \"auto\" || e.right !== \"auto\") && (S = 0)), [S, N];\n}\nfunction convert3DMatrixes(r) {\n  r.forEach(function(t) {\n    var e = t.matrix;\n    e && (t.matrix = convertDimension(e, 3, 4));\n  });\n}\nfunction getBodyScrollPos() {\n  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];\n}\nfunction getPositionFixedInfo(r) {\n  for (var t = r.parentElement, e = !1; t; ) {\n    var o = getComputedStyle$1$1(t).transform;\n    if (o && o !== \"none\") {\n      e = !0;\n      break;\n    }\n    if (t === document.body)\n      break;\n    t = t.parentElement;\n  }\n  return {\n    fixedContainer: t || document.body,\n    hasTransform: e\n  };\n}\nfunction makeMatrixCSS(r, t) {\n  return t === void 0 && (t = r.length > 9), \"\".concat(t ? \"matrix3d\" : \"matrix\", \"(\").concat(convertMatrixtoCSS(r, !t).join(\",\"), \")\");\n}\nfunction getSVGViewBox(r) {\n  var t = r.clientWidth, e = r.clientHeight;\n  if (!r)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: t,\n      clientHeight: e\n    };\n  var o = r.viewBox, T = o && o.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: T.x,\n    y: T.y,\n    width: T.width || t,\n    height: T.height || e,\n    clientWidth: t,\n    clientHeight: e\n  };\n}\nfunction getSVGMatrix(r, t) {\n  var e = getSVGViewBox(r), o = e.width, T = e.height, S = e.clientWidth, N = e.clientHeight, D = S / o, B = N / T, $ = r.preserveAspectRatio.baseVal, U = $.align, z = $.meetOrSlice, V = [0, 0], X = [D, B], W = [0, 0];\n  if (U !== 1) {\n    var Y = (U - 2) % 3, q = Math.floor((U - 2) / 3);\n    V[0] = o * Y / 2, V[1] = T * q / 2;\n    var Z = z === 2 ? Math.max(B, D) : Math.min(D, B);\n    X[0] = Z, X[1] = Z, W[0] = (S - o) / 2 * Y, W[1] = (N - T) / 2 * q;\n  }\n  var K = createScaleMatrix(X, t);\n  return K[t * (t - 1)] = W[0], K[t * (t - 1) + 1] = W[1], getAbsoluteMatrix(K, t, V);\n}\nfunction getSVGGraphicsOffset(r, t, e) {\n  if (!r.getBBox || !e && r.tagName.toLowerCase() === \"g\")\n    return [0, 0, 0, 0];\n  var o = r.getBBox(), T = getSVGViewBox(r.ownerSVGElement), S = o.x - T.x, N = o.y - T.y;\n  return [S, N, t[0] - S, t[1] - N];\n}\nfunction calculatePosition(r, t, e) {\n  return calculate(r, convertPositionMatrix(t, e), e);\n}\nfunction calculatePoses(r, t, e, o) {\n  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(T) {\n    return calculatePosition(r, T, o);\n  });\n}\nfunction getRect(r) {\n  var t = r.map(function($) {\n    return $[0];\n  }), e = r.map(function($) {\n    return $[1];\n  }), o = Math.min.apply(Math, t), T = Math.min.apply(Math, e), S = Math.max.apply(Math, t), N = Math.max.apply(Math, e), D = S - o, B = N - T;\n  return {\n    left: o,\n    top: T,\n    right: S,\n    bottom: N,\n    width: D,\n    height: B\n  };\n}\nfunction calculateRect(r, t, e, o) {\n  var T = calculatePoses(r, t, e, o);\n  return getRect(T);\n}\nfunction getSVGOffset(r, t, e, o, T) {\n  var S, N = r.target, D = r.origin, B = t.matrix, $ = getSize(N), U = $.offsetWidth, z = $.offsetHeight, V = e.getBoundingClientRect(), X = [0, 0];\n  e === document.body && (X = getBodyOffset(N, !0));\n  for (var W = N.getBoundingClientRect(), Y = W.left - V.left + e.scrollLeft - (e.clientLeft || 0) + X[0], q = W.top - V.top + e.scrollTop - (e.clientTop || 0) + X[1], Z = W.width, K = W.height, J = multiplies(o, T, B), tt = calculateRect(J, U, z, o), et = tt.left, Q = tt.top, at = tt.width, it = tt.height, st = calculatePosition(J, D, o), ut = minus(st, [et, Q]), ft = [Y + ut[0] * Z / at, q + ut[1] * K / it], ct = [0, 0], pt = 0; ++pt < 10; ) {\n    var mt = invert(T, o);\n    S = minus(calculatePosition(mt, ft, o), calculatePosition(mt, st, o)), ct[0] = S[0], ct[1] = S[1];\n    var vt = multiplies(o, T, createOriginMatrix(ct, o), B), _t = calculateRect(vt, U, z, o), xt = _t.left, Rt = _t.top, yt = xt - Y, ht = Rt - q;\n    if (Math.abs(yt) < 2 && Math.abs(ht) < 2)\n      break;\n    ft[0] -= yt, ft[1] -= ht;\n  }\n  return ct.map(function(bt) {\n    return Math.round(bt);\n  });\n}\nfunction calculateMoveableClientPositions(r, t, e) {\n  var o = r.length === 16, T = o ? 4 : 3, S = t.map(function(B) {\n    return calculatePosition(r, B, T);\n  }), N = e.left, D = e.top;\n  return S.map(function(B) {\n    return [B[0] + N, B[1] + D];\n  });\n}\nfunction calculateMoveablePosition(r, t, e, o) {\n  var T = r.length === 16, S = T ? 4 : 3, N = calculatePoses(r, e, o, S), D = N[0], B = D[0], $ = D[1], U = N[1], z = U[0], V = U[1], X = N[2], W = X[0], Y = X[1], q = N[3], Z = q[0], K = q[1], J = calculatePosition(r, t, S), tt = J[0], et = J[1], Q = Math.min(B, z, W, Z), at = Math.min($, V, Y, K), it = Math.max(B, z, W, Z), st = Math.max($, V, Y, K);\n  B = B - Q || 0, z = z - Q || 0, W = W - Q || 0, Z = Z - Q || 0, $ = $ - at || 0, V = V - at || 0, Y = Y - at || 0, K = K - at || 0, tt = tt - Q || 0, et = et - at || 0;\n  var ut = getShapeDirection(N);\n  return {\n    left: Q,\n    top: at,\n    right: it,\n    bottom: st,\n    origin: [tt, et],\n    pos1: [B, $],\n    pos2: [z, V],\n    pos3: [W, Y],\n    pos4: [Z, K],\n    direction: ut\n  };\n}\nfunction getDistSize(r) {\n  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);\n}\nfunction getDiagonalSize(r, t) {\n  return getDistSize([t[0] - r[0], t[1] - r[1]]);\n}\nfunction getLineStyle(r, t, e, o) {\n  e === void 0 && (e = 1), o === void 0 && (o = getRad$1(r, t));\n  var T = getDiagonalSize(r, t);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(r[0], \"px, \").concat(r[1], \"px) rotate(\").concat(o, \"rad) scaleY(\").concat(e, \")\"),\n    width: \"\".concat(T, \"px\")\n  };\n}\nfunction getControlTransform(r, t) {\n  for (var e = [], o = 2; o < arguments.length; o++)\n    e[o - 2] = arguments[o];\n  var T = e.length, S = e.reduce(function(D, B) {\n    return D + B[0];\n  }, 0) / T, N = e.reduce(function(D, B) {\n    return D + B[1];\n  }, 0) / T;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(S, \"px, \").concat(N, \"px) rotate(\").concat(r, \"rad) scale(\").concat(t, \")\")\n  };\n}\nfunction getProps(r, t) {\n  var e = r[t];\n  return isObject$2(e) ? __assign$2(__assign$2({}, r), e) : r;\n}\nfunction getSize(r, t) {\n  t === void 0 && (t = r ? getComputedStyle$1$1(r) : null);\n  var e = r && !isUndefined(r.offsetWidth), o = 0, T = 0, S = 0, N = 0, D = 0, B = 0, $ = 0, U = 0, z = 0, V = 0, X = 0, W = 0, Y = 1 / 0, q = 1 / 0, Z = 1 / 0, K = 1 / 0, J = !1;\n  if (r)\n    if (!e && r.tagName.toLowerCase() !== \"svg\") {\n      var tt = r.getBBox();\n      J = !0, o = tt.width, T = tt.height, D = o, B = T, $ = o, U = T, S = o, N = T;\n    } else {\n      var et = r.style, Q = t.boxSizing === \"border-box\", at = parseFloat(t.borderLeftWidth) || 0, it = parseFloat(t.borderRightWidth) || 0, st = parseFloat(t.borderTopWidth) || 0, ut = parseFloat(t.borderBottomWidth) || 0, ft = parseFloat(t.paddingLeft) || 0, ct = parseFloat(t.paddingRight) || 0, pt = parseFloat(t.paddingTop) || 0, mt = parseFloat(t.paddingBottom) || 0, vt = ft + ct, _t = pt + mt, xt = at + it, Rt = st + ut, yt = vt + xt, ht = _t + Rt;\n      z = Math.max(vt, convertUnitSize(t.minWidth, 0) || 0), V = Math.max(_t, convertUnitSize(t.minHeight, 0) || 0), Y = convertUnitSize(t.maxWidth, 0), q = convertUnitSize(t.maxHeight, 0), isNaN(Y) && (Y = 1 / 0), isNaN(q) && (q = 1 / 0);\n      var bt = convertUnitSize(et.width, 0) || 0, St = convertUnitSize(et.height, 0) || 0, Ot = parseFloat(t.width) || 0, wt = parseFloat(t.height) || 0;\n      D = parseFloat(t.width), B = parseFloat(t.height), $ = Math.abs(Ot - bt) < 1 ? between(z, bt || D, Y) : Ot, U = Math.abs(wt - St) < 1 ? between(V, St || B, q) : wt, o = $, T = U, S = $, N = U, Q ? (Z = Y, K = q, X = z, W = V, $ = o - yt, U = T - ht) : (Z = Y + yt, K = q + ht, X = z + yt, W = V + ht, o = $ + yt, T = U + ht), S = $ + vt, N = U + _t;\n    }\n  return {\n    svg: J,\n    offsetWidth: o,\n    offsetHeight: T,\n    clientWidth: S,\n    clientHeight: N,\n    contentWidth: $,\n    contentHeight: U,\n    cssWidth: D,\n    cssHeight: B,\n    minWidth: z,\n    minHeight: V,\n    maxWidth: Y,\n    maxHeight: q,\n    minOffsetWidth: X,\n    minOffsetHeight: W,\n    maxOffsetWidth: Z,\n    maxOffsetHeight: K\n  };\n}\nfunction getRotationRad(r, t) {\n  return getRad$1(t > 0 ? r[0] : r[1], t > 0 ? r[1] : r[0]);\n}\nfunction resetClientRect() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction getClientRect(r, t) {\n  var e, o = 0, T = 0, S = 0, N = 0;\n  if (r)\n    if (r === document.body || r === document.documentElement) {\n      S = window.innerWidth, N = window.innerHeight;\n      var D = getBodyScrollPos();\n      e = [-D[0], -D[1]], o = e[0], T = e[1];\n    } else {\n      var B = r.getBoundingClientRect();\n      o = B.left, T = B.top, S = B.width, N = B.height;\n    }\n  var $ = {\n    left: o,\n    top: T,\n    width: S,\n    height: N,\n    right: o + S,\n    bottom: T + N\n  };\n  return r && t && ($.clientLeft = r.clientLeft, $.clientTop = r.clientTop, $.clientWidth = r.clientWidth, $.clientHeight = r.clientHeight, $.scrollWidth = r.scrollWidth, $.scrollHeight = r.scrollHeight, $.overflow = getComputedStyle$1$1(r).overflow !== \"visible\"), $;\n}\nfunction getDirection(r) {\n  if (!!r) {\n    var t = r.getAttribute(\"data-direction\");\n    if (!!t) {\n      var e = [0, 0];\n      return t.indexOf(\"w\") > -1 && (e[0] = -1), t.indexOf(\"e\") > -1 && (e[0] = 1), t.indexOf(\"n\") > -1 && (e[1] = -1), t.indexOf(\"s\") > -1 && (e[1] = 1), e;\n    }\n  }\n}\nfunction getAbsolutePoses(r, t) {\n  return [plus(t, r[0]), plus(t, r[1]), plus(t, r[2]), plus(t, r[3])];\n}\nfunction getAbsolutePosesByState(r) {\n  var t = r.left, e = r.top, o = r.pos1, T = r.pos2, S = r.pos3, N = r.pos4;\n  return getAbsolutePoses([o, T, S, N], [t, e]);\n}\nfunction roundSign(r) {\n  return Math.round(r % 1 === -0.5 ? r - 1 : r);\n}\nfunction unset(r, t) {\n  var e;\n  (e = r[t]) === null || e === void 0 || e.unset(), r[t] = null;\n}\nfunction fillCSSObject(r, t) {\n  if (t) {\n    var e = getBeforeRenderableDatas(t);\n    e.nextStyle = __assign$2(__assign$2({}, e.nextStyle), r);\n  }\n  return {\n    style: r,\n    cssText: getKeys(r).map(function(o) {\n      return \"\".concat(o, \": \").concat(r[o], \";\");\n    }).join(\"\")\n  };\n}\nfunction fillAfterTransform(r, t, e) {\n  var o = t.afterTransform || t.transform;\n  return __assign$2(__assign$2({}, fillCSSObject(__assign$2(__assign$2(__assign$2({}, r.style), t.style), {\n    transform: o\n  }), e)), {\n    afterTransform: o,\n    transform: r.transform\n  });\n}\nfunction fillParams(r, t, e, o) {\n  var T = t.datas;\n  T.datas || (T.datas = {});\n  var S = __assign$2(__assign$2({}, e), {\n    target: r.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: r,\n    moveable: r,\n    datas: T.datas,\n    stopDrag: function() {\n      var N;\n      (N = t.stop) === null || N === void 0 || N.call(t);\n    }\n  });\n  return T.isStartEvent ? o || (T.lastEvent = S) : T.isStartEvent = !0, S;\n}\nfunction fillEndParams(r, t, e) {\n  var o = t.datas, T = \"isDrag\" in e ? e.isDrag : t.isDrag;\n  return o.datas || (o.datas = {}), __assign$2(__assign$2({\n    isDrag: T\n  }, e), {\n    moveable: r,\n    target: r.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: r,\n    lastEvent: o.lastEvent,\n    isDouble: t.isDouble,\n    datas: o.datas\n  });\n}\nfunction catchEvent(r, t, e) {\n  r._emitter.on(t, e);\n}\nfunction triggerEvent(r, t, e, o) {\n  return r.triggerEvent(t, e, o);\n}\nfunction getComputedStyle$1$1(r, t) {\n  return window.getComputedStyle(r, t);\n}\nfunction filterAbles(r, t, e) {\n  var o = {}, T = {};\n  return r.filter(function(S) {\n    var N = S.name;\n    if (o[N] || !t.some(function(D) {\n      return S[D];\n    }))\n      return !1;\n    if (!e && S.ableGroup) {\n      if (T[S.ableGroup])\n        return !1;\n      T[S.ableGroup] = !0;\n    }\n    return o[N] = !0, !0;\n  });\n}\nfunction equals(r, t) {\n  return r === t || r == null && t == null;\n}\nfunction selectValue() {\n  for (var r = [], t = 0; t < arguments.length; t++)\n    r[t] = arguments[t];\n  for (var e = r.length - 1, o = 0; o < e; ++o) {\n    var T = r[o];\n    if (!isUndefined(T))\n      return T;\n  }\n  return r[e];\n}\nfunction groupBy(r, t) {\n  var e = [], o = [];\n  return r.forEach(function(T, S) {\n    var N = t(T, S, r), D = o.indexOf(N), B = e[D] || [];\n    D === -1 && (o.push(N), e.push(B)), B.push(T);\n  }), e;\n}\nfunction groupByMap(r, t) {\n  var e = [], o = {};\n  return r.forEach(function(T, S) {\n    var N = t(T, S, r), D = o[N];\n    D || (D = [], o[N] = D, e.push(D)), D.push(T);\n  }), e;\n}\nfunction flat(r) {\n  return r.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction maxOffset() {\n  for (var r = [], t = 0; t < arguments.length; t++)\n    r[t] = arguments[t];\n  return r.sort(function(e, o) {\n    return Math.abs(o) - Math.abs(e);\n  }), r[0];\n}\nfunction calculateInversePosition(r, t, e) {\n  return calculate(invert(r, e), convertPositionMatrix(t, e), e);\n}\nfunction convertDragDist(r, t) {\n  var e, o = r.is3d, T = r.rootMatrix, S = o ? 4 : 3;\n  return e = calculateInversePosition(T, [t.distX, t.distY], S), t.distX = e[0], t.distY = e[1], t;\n}\nfunction calculatePadding(r, t, e, o, T) {\n  return minus(calculatePosition(r, plus(e, t), T), o);\n}\nfunction convertCSSSize(r, t, e) {\n  return e ? \"\".concat(r / t * 100, \"%\") : \"\".concat(r, \"px\");\n}\nfunction getTinyDist(r) {\n  return Math.abs(r) <= TINY_NUM ? 0 : r;\n}\nfunction getDirectionCondition(r, t) {\n  return t === void 0 && (t = [r]), function(e, o) {\n    if (o.isRequest)\n      return t.some(function(S) {\n        return o.requestAble === S;\n      }) ? o.parentDirection : !1;\n    var T = o.inputEvent.target;\n    return hasClass(T, prefix(\"direction\")) && (!r || hasClass(T, prefix(r)));\n  };\n}\nfunction invertObject(r) {\n  var t = {};\n  for (var e in r)\n    t[r[e]] = e;\n  return t;\n}\nfunction convertTransformInfo(r, t) {\n  var e = r.slice(0, t < 0 ? void 0 : t), o = r.slice(0, t < 0 ? void 0 : t + 1), T = r[t] || \"\", S = t < 0 ? [] : r.slice(t), N = t < 0 ? [] : r.slice(t + 1), D = parse(e), B = parse(o), $ = parse([T]), U = parse(S), z = parse(N), V = toMat(D), X = toMat(B), W = toMat(U), Y = toMat(z), q = multiply(V, W, 4);\n  return {\n    transforms: r,\n    beforeFunctionMatrix: V,\n    beforeFunctionMatrix2: X,\n    targetFunctionMatrix: toMat($),\n    afterFunctionMatrix: W,\n    afterFunctionMatrix2: Y,\n    allFunctionMatrix: q,\n    beforeFunctions: D,\n    beforeFunctions2: B,\n    targetFunction: $[0],\n    afterFunctions: U,\n    afterFunctions2: z,\n    beforeFunctionTexts: e,\n    beforeFunctionTexts2: o,\n    targetFunctionText: T,\n    afterFunctionTexts: S,\n    afterFunctionTexts2: N\n  };\n}\nfunction isArrayFormat(r) {\n  return !r || !isObject$2(r) || r instanceof Element ? !1 : isArray(r) || \"length\" in r;\n}\nfunction getRefTarget(r, t) {\n  return r ? r instanceof Element ? r : isString$1(r) ? t ? document.querySelector(r) : r : isFunction$3(r) ? r() : \"current\" in r ? r.current : r : null;\n}\nfunction getRefTargets(r, t) {\n  if (!r)\n    return [];\n  var e = isArrayFormat(r) ? [].slice.call(r) : [r];\n  return e.reduce(function(o, T) {\n    return isString$1(T) && t ? __spreadArray(__spreadArray([], o, !0), [].slice.call(document.querySelectorAll(T)), !0) : (isArray(T) ? o.push(getRefTargets(T, t)) : o.push(getRefTarget(T, t)), o);\n  }, []);\n}\nfunction getAbsoluteRotation(r, t, e) {\n  var o = getRad$1(r, t) / Math.PI * 180;\n  return o = e >= 0 ? o : 180 - o, o = o >= 0 ? o : 360 + o, o;\n}\nfunction getDragDistByState(r, t) {\n  var e = r.rootMatrix, o = r.is3d, T = o ? 4 : 3, S = invert(e, T);\n  return o || (S = convertDimension(S, 3, 4)), S[12] = 0, S[13] = 0, S[14] = 0, calculateMatrixDist(S, t);\n}\nfunction getSizeDistByDist(r, t, e, o, T) {\n  var S = r[0], N = r[1], D = 0, B = 0;\n  if (T && S && N) {\n    var $ = getRad$1([0, 0], t), U = getRad$1([0, 0], o), z = getDistSize(t), V = Math.cos($ - U) * z;\n    if (!o[0])\n      B = V, D = B * e;\n    else if (!o[1])\n      D = V, B = D / e;\n    else {\n      var X = o[0] * 2 * S, W = o[1] * 2 * N, Y = getDistSize([X + t[0], W + t[1]]) - getDistSize([X, W]), q = getRad$1([0, 0], [e, 1]);\n      D = Math.cos(q) * Y, B = Math.sin(q) * Y;\n    }\n  } else\n    D = o[0] * t[0], B = o[1] * t[1];\n  return [D, B];\n}\nfunction getOffsetSizeDist(r, t, e, o) {\n  var T, S = e.ratio, N = e.startOffsetWidth, D = e.startOffsetHeight, B = 0, $ = 0, U = o.distX, z = o.distY, V = o.parentDistance, X = o.parentDist, W = o.parentScale, Y = e.fixedDirection, q = [0, 1].map(function(Q) {\n    return Math.abs(r[Q] - Y[Q]);\n  }), Z = [0, 1].map(function(Q) {\n    var at = q[Q];\n    return at !== 0 && (at = 2 / at), at;\n  });\n  if (X)\n    B = X[0], $ = X[1], t && (B ? $ || ($ = B / S) : B = $ * S);\n  else if (W)\n    B = (W[0] - 1) * N, $ = (W[1] - 1) * D;\n  else if (V) {\n    var K = N * q[0], J = D * q[1], tt = getDistSize([K, J]);\n    B = V / tt * K * Z[0], $ = V / tt * J * Z[1];\n  } else {\n    var et = getDragDist({\n      datas: e,\n      distX: U,\n      distY: z\n    });\n    et = Z.map(function(Q, at) {\n      return et[at] * Q;\n    }), T = getSizeDistByDist([N, D], et, S, r, t), B = T[0], $ = T[1];\n  }\n  return {\n    distWidth: B,\n    distHeight: $\n  };\n}\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function() {\n    return !0;\n  },\n  pinchStart: function(r, t) {\n    var e = t.datas, o = t.targets, T = t.angle, S = t.originalDatas, N = r.props, D = N.pinchable, B = N.ables;\n    if (!D)\n      return !1;\n    var $ = \"onPinch\".concat(o ? \"Group\" : \"\", \"Start\"), U = \"drag\".concat(o ? \"Group\" : \"\", \"ControlStart\"), z = (D === !0 ? r.controlAbles : B.filter(function(Y) {\n      return D.indexOf(Y.name) > -1;\n    })).filter(function(Y) {\n      return Y.canPinch && Y[U];\n    }), V = fillParams(r, t, {});\n    o && (V.targets = o);\n    var X = triggerEvent(r, $, V);\n    e.isPinch = X !== !1, e.ables = z;\n    var W = e.isPinch;\n    return W ? (z.forEach(function(Y) {\n      if (S[Y.name] = S[Y.name] || {}, !!Y[U]) {\n        var q = __assign$2(__assign$2({}, t), {\n          datas: S[Y.name],\n          parentRotate: T,\n          isPinch: !0\n        });\n        Y[U](r, q);\n      }\n    }), r.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: [0, 0]\n    }, W) : !1;\n  },\n  pinch: function(r, t) {\n    var e = t.datas, o = t.scale, T = t.distance, S = t.originalDatas, N = t.inputEvent, D = t.targets, B = t.angle;\n    if (!!e.isPinch) {\n      var $ = T * (1 - 1 / o), U = fillParams(r, t, {});\n      D && (U.targets = D);\n      var z = \"onPinch\".concat(D ? \"Group\" : \"\");\n      triggerEvent(r, z, U);\n      var V = e.ables, X = \"drag\".concat(D ? \"Group\" : \"\", \"Control\");\n      return V.forEach(function(W) {\n        !W[X] || W[X](r, __assign$2(__assign$2({}, t), {\n          datas: S[W.name],\n          inputEvent: N,\n          parentDistance: $,\n          parentRotate: B,\n          isPinch: !0\n        }));\n      }), U;\n    }\n  },\n  pinchEnd: function(r, t) {\n    var e = t.datas, o = t.isPinch, T = t.inputEvent, S = t.targets, N = t.originalDatas;\n    if (!!e.isPinch) {\n      var D = \"onPinch\".concat(S ? \"Group\" : \"\", \"End\"), B = fillEndParams(r, t, {\n        isDrag: o\n      });\n      S && (B.targets = S), triggerEvent(r, D, B);\n      var $ = e.ables, U = \"drag\".concat(S ? \"Group\" : \"\", \"ControlEnd\");\n      return $.forEach(function(z) {\n        !z[U] || z[U](r, __assign$2(__assign$2({}, t), {\n          isDrag: o,\n          datas: N[z.name],\n          inputEvent: T,\n          isPinch: !0\n        }));\n      }), o;\n    }\n  },\n  pinchGroupStart: function(r, t) {\n    return this.pinchStart(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  pinchGroup: function(r, t) {\n    return this.pinch(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  pinchGroupEnd: function(r, t) {\n    return this.pinchEnd(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  }\n});\nfunction fillChildEvents(r, t, e) {\n  var o = e.originalDatas;\n  o.groupable = o.groupable || {};\n  var T = o.groupable;\n  T.childDatas = T.childDatas || [];\n  var S = T.childDatas;\n  return r.moveables.map(function(N, D) {\n    return S[D] = S[D] || {}, S[D][t] = S[D][t] || {}, __assign$2(__assign$2({}, e), {\n      datas: S[D][t],\n      originalDatas: S[D]\n    });\n  });\n}\nfunction triggerChildGesto(r, t, e, o, T, S, N) {\n  var D = !!e.match(/Start$/g), B = !!e.match(/End$/g), $ = T.isPinch, U = T.datas, z = fillChildEvents(r, t.name, T), V = r.moveables, X = z.map(function(W, Y) {\n    var q = V[Y], Z = q.state, K = Z.gestos, J = W;\n    if (D)\n      J = new CustomGesto(N).dragStart(o, W);\n    else {\n      if (K[N] || (K[N] = U.childGestos[Y]), !K[N])\n        return;\n      J = setCustomDrag(W, Z, o, $, S, N);\n    }\n    var tt = t[e](q, __assign$2(__assign$2({}, J), {\n      parentFlag: !0\n    }));\n    return B && (K[N] = null), tt;\n  });\n  return D && (U.childGestos = V.map(function(W) {\n    return W.state.gestos[N];\n  })), X;\n}\nfunction triggerChildAbles(r, t, e, o, T, S) {\n  T === void 0 && (T = function(U, z) {\n    return z;\n  });\n  var N = !!e.match(/End$/g), D = fillChildEvents(r, t.name, o), B = r.moveables, $ = D.map(function(U, z) {\n    var V = B[z], X = U;\n    X = T(V, U);\n    var W = t[e](V, __assign$2(__assign$2({}, X), {\n      parentFlag: !0\n    }));\n    return W && S && S(V, U, W, z), N && (V.state.gestos = {}), W;\n  });\n  return $;\n}\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"], HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"], VERTICAL_NAMES_MAP = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, HORIZONTAL_NAMES_MAP = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction hasGuidelines(r, t) {\n  var e = r.props, o = e.snappable, T = e.bounds, S = e.innerBounds, N = e.verticalGuidelines, D = e.horizontalGuidelines, B = e.snapGridWidth, $ = e.snapGridHeight, U = r.state, z = U.guidelines, V = U.enableSnap;\n  return !o || !V || t && o !== !0 && o.indexOf(t) < 0 ? !1 : !!(B || $ || T || S || z && z.length || N && N.length || D && D.length);\n}\nfunction getSnapDirections(r) {\n  return r === !1 ? {} : r === !0 || !r ? {\n    left: !0,\n    right: !0,\n    top: !0,\n    bottom: !0\n  } : r;\n}\nfunction mapSnapDirectionPoses(r, t) {\n  var e = getSnapDirections(r), o = {};\n  for (var T in e)\n    T in t && e[T] && (o[T] = t[T]);\n  return o;\n}\nfunction splitSnapDirectionPoses(r, t) {\n  var e = mapSnapDirectionPoses(r, t), o = HORIZONTAL_NAMES.filter(function(S) {\n    return S in e;\n  }), T = VERTICAL_NAMES.filter(function(S) {\n    return S in e;\n  });\n  return {\n    horizontal: o.map(function(S) {\n      return e[S];\n    }),\n    vertical: T.map(function(S) {\n      return e[S];\n    })\n  };\n}\nfunction calculateContainerPos(r, t, e) {\n  var o = calculatePosition(r, [t.clientLeft, t.clientTop], e);\n  return [t.left + o[0], t.top + o[1]];\n}\nfunction solveLineConstants(r) {\n  var t = r[0], e = r[1], o = e[0] - t[0], T = e[1] - t[1];\n  Math.abs(o) < TINY_NUM$1 && (o = 0), Math.abs(T) < TINY_NUM$1 && (T = 0);\n  var S = 0, N = 0, D = 0;\n  return o ? T ? (S = -T / o, N = 1, D = S * t[0] - t[1]) : (N = 1, D = -t[1]) : (S = -1, D = t[0]), [S, N, D].map(function(B) {\n    return throttle(B, TINY_NUM$1);\n  });\n}\nfunction checkMoveableSnapPoses(r, t, e, o) {\n  var T = r.props, S = selectValue(o, T.snapThreshold, 5);\n  return checkSnapPoses(r.state.guidelines, t, e, S);\n}\nfunction checkSnapPoses(r, t, e, o) {\n  return {\n    vertical: checkSnap(r, \"vertical\", t, o),\n    horizontal: checkSnap(r, \"horizontal\", e, o)\n  };\n}\nfunction checkSnapKeepRatio(r, t, e) {\n  var o = e[0], T = e[1], S = t[0], N = t[1], D = minus(e, t), B = D[0], $ = D[1], U = $ > 0, z = B > 0;\n  B = getTinyDist(B), $ = getTinyDist($);\n  var V = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, X = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (B === 0 && $ === 0)\n    return {\n      vertical: V,\n      horizontal: X\n    };\n  var W = checkMoveableSnapPoses(r, B ? [o] : [], $ ? [T] : []), Y = W.vertical, q = W.horizontal;\n  Y.posInfos.filter(function(mt) {\n    var vt = mt.pos;\n    return z ? vt >= S : vt <= S;\n  }), q.posInfos.filter(function(mt) {\n    var vt = mt.pos;\n    return U ? vt >= N : vt <= N;\n  }), Y.isSnap = Y.posInfos.length > 0, q.isSnap = q.posInfos.length > 0;\n  var Z = getNearestSnapGuidelineInfo(Y), K = Z.isSnap, J = Z.guideline, tt = getNearestSnapGuidelineInfo(q), et = tt.isSnap, Q = tt.guideline, at = et ? Q.pos[1] : 0, it = K ? J.pos[0] : 0;\n  if (B === 0)\n    et && (X.isSnap = !0, X.pos = Q.pos[1], X.offset = T - X.pos);\n  else if ($ === 0)\n    K && (V.isSnap = !0, V.pos = it, V.offset = o - it);\n  else {\n    var st = $ / B, ut = e[1] - st * o, ft = 0, ct = 0, pt = !1;\n    K ? (ct = it, ft = st * ct + ut, pt = !0) : et && (ft = at, ct = (ft - ut) / st, pt = !0), pt && (V.isSnap = !0, V.pos = ct, V.offset = o - ct, X.isSnap = !0, X.pos = ft, X.offset = T - ft);\n  }\n  return {\n    vertical: V,\n    horizontal: X\n  };\n}\nfunction checkSnaps(r, t, e) {\n  var o = splitSnapDirectionPoses(r.props.snapDirections, t);\n  return checkMoveableSnapPoses(r, o.vertical, o.horizontal, e);\n}\nfunction getNearestSnapGuidelineInfo(r) {\n  var t = r.isSnap;\n  if (!t)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  var e = r.posInfos[0], o = e.guidelineInfos[0], T = o.offset, S = o.dist, N = o.guideline;\n  return {\n    isSnap: t,\n    offset: T,\n    dist: S,\n    pos: e.pos,\n    guideline: N\n  };\n}\nfunction checkSnap(r, t, e, o) {\n  if (!r || !r.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      posInfos: []\n    };\n  var T = t === \"vertical\", S = T ? 0 : 1, N = e.map(function(B, $) {\n    var U = r.map(function(z) {\n      var V = z.pos, X = B - V[S];\n      return {\n        offset: X,\n        dist: Math.abs(X),\n        guideline: z\n      };\n    }).filter(function(z) {\n      var V = z.guideline, X = z.dist, W = V.type;\n      return !(W !== t || X > o);\n    }).sort(function(z, V) {\n      return z.dist - V.dist;\n    });\n    return {\n      pos: B,\n      index: $,\n      guidelineInfos: U\n    };\n  }).filter(function(B) {\n    return B.guidelineInfos.length > 0;\n  }).sort(function(B, $) {\n    return B.guidelineInfos[0].dist - $.guidelineInfos[0].dist;\n  }), D = N.length > 0;\n  return {\n    isSnap: D,\n    index: D ? N[0].index : -1,\n    posInfos: N\n  };\n}\nfunction getSnapInfosByDirection(r, t, e) {\n  var o = [];\n  if (e[0] && e[1])\n    o = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(N) {\n      return getPosByDirection(t, N);\n    });\n  else if (!e[0] && !e[1])\n    for (var T = [t[0], t[1], t[3], t[2], t[0]], S = 0; S < 4; ++S)\n      o.push(T[S]), o.push([(T[S][0] + T[S + 1][0]) / 2, (T[S][1] + T[S + 1][1]) / 2]);\n  else\n    r.props.keepRatio ? o = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(N) {\n      return getPosByDirection(t, N);\n    }) : (o = getPosesByDirection(t, e), o.length > 1 && o.push([(o[0][0] + o[1][0]) / 2, (o[0][1] + o[1][1]) / 2]));\n  return checkMoveableSnapPoses(r, o.map(function(N) {\n    return N[0];\n  }), o.map(function(N) {\n    return N[1];\n  }), 1);\n}\nfunction checkSnapBoundPriority(r, t) {\n  var e = Math.abs(r.offset), o = Math.abs(t.offset);\n  return r.isBound && t.isBound ? o - e : r.isBound ? -1 : t.isBound ? 1 : r.isSnap && t.isSnap ? o - e : r.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : o < TINY_NUM ? -1 : e - o;\n}\nfunction getNearOffsetInfo(r, t) {\n  return r.slice().sort(function(e, o) {\n    var T = e.sign[t], S = o.sign[t], N = e.offset[t], D = o.offset[t];\n    if (T) {\n      if (!S)\n        return -1;\n    } else\n      return 1;\n    return checkSnapBoundPriority({\n      isBound: e.isBound,\n      isSnap: e.isSnap,\n      offset: N\n    }, {\n      isBound: o.isBound,\n      isSnap: o.isSnap,\n      offset: D\n    });\n  })[0];\n}\nfunction getCheckSnapDirections(r, t, e) {\n  var o = [];\n  if (e)\n    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? o.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : o.push([t, [r[0], -r[1]]], [t, [-r[0], r[1]]]), o.push([t, r]);\n  else if (r[0] && r[1] || !r[0] && !r[1]) {\n    var T = r[0] ? r : [1, 1];\n    [1, -1].forEach(function(N) {\n      [1, -1].forEach(function(D) {\n        var B = [N * T[0], D * T[1]];\n        t[0] === B[0] && t[1] === B[1] || o.push([t, B]);\n      });\n    });\n  } else if (r[0]) {\n    var S = Math.abs(t[0]) === 1 ? [1] : [1, -1];\n    S.forEach(function(N) {\n      o.push([[t[0], -1], [N * r[0], -1]], [[t[0], 0], [N * r[0], 0]], [[t[0], 1], [N * r[0], 1]]);\n    });\n  } else if (r[1]) {\n    var S = Math.abs(t[1]) === 1 ? [1] : [1, -1];\n    S.forEach(function(D) {\n      o.push([[-1, t[1]], [-1, D * r[1]]], [[0, t[1]], [0, D * r[1]]], [[1, t[1]], [1, D * r[1]]]);\n    });\n  }\n  return o;\n}\nfunction isStartLine(r, t) {\n  var e = average([t[0][0], t[1][0]]), o = average([t[0][1], t[1][1]]);\n  return {\n    vertical: e <= r[0],\n    horizontal: o <= r[1]\n  };\n}\nfunction hitTestLine(r, t) {\n  var e = t[0], o = t[1], T = o[0] - e[0], S = o[1] - e[1];\n  Math.abs(T) < TINY_NUM && (T = 0), Math.abs(S) < TINY_NUM && (S = 0);\n  var N, D;\n  if (!T)\n    N = e[0], D = r[0];\n  else if (!S)\n    N = e[1], D = r[1];\n  else {\n    var B = S / T;\n    N = B * (r[0] - e[0]) + e[1], D = r[1];\n  }\n  return N - D;\n}\nfunction isSameStartLine(r, t, e, o) {\n  return o === void 0 && (o = TINY_NUM), r.every(function(T) {\n    var S = hitTestLine(T, t), N = S <= 0;\n    return N === e || Math.abs(S) <= o;\n  });\n}\nfunction checkInnerBoundDot(r, t, e, o, T) {\n  return T === void 0 && (T = 0), o && t - T <= r || !o && r <= e + T ? {\n    isBound: !0,\n    offset: o ? t - r : e - r\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction checkInnerBound(r, t) {\n  var e = t.line, o = t.centerSign, T = t.verticalSign, S = t.horizontalSign, N = t.lineConstants, D = r.props.innerBounds;\n  if (!D)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var B = D.left, $ = D.top, U = D.width, z = D.height, V = [[B, $], [B, $ + z]], X = [[B, $], [B + U, $]], W = [[B + U, $], [B + U, $ + z]], Y = [[B, $ + z], [B + U, $ + z]];\n  if (isSameStartLine([[B, $], [B + U, $], [B, $ + z], [B + U, $ + z]], e, o))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var q = checkLineBoundCollision(e, N, X, T), Z = checkLineBoundCollision(e, N, Y, T), K = checkLineBoundCollision(e, N, V, S), J = checkLineBoundCollision(e, N, W, S), tt = q.isBound && Z.isBound, et = q.isBound || Z.isBound, Q = K.isBound && J.isBound, at = K.isBound || J.isBound, it = maxOffset(q.offset, Z.offset), st = maxOffset(K.offset, J.offset), ut = [0, 0], ft = !1, ct = !1;\n  return Math.abs(st) < Math.abs(it) ? (ut = [it, 0], ft = et, ct = tt) : (ut = [0, st], ft = at, ct = Q), {\n    isAllBound: ct,\n    isVerticalBound: et,\n    isHorizontalBound: at,\n    isBound: ft,\n    offset: ut\n  };\n}\nfunction checkLineBoundCollision(r, t, e, o, T, S) {\n  var N = t[0], D = t[1], B = r[0], $ = e[0], U = e[1], z = getTinyDist(U[1] - $[1]), V = getTinyDist(U[0] - $[0]), X = D, W = N, Y = -N / D;\n  if (V) {\n    if (!z) {\n      if (S && !X)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (W) {\n        var J = ($[1] - B[1]) / Y + B[0];\n        return checkInnerBoundDot(J, $[0], U[0], o, T);\n      } else {\n        var Z = $[1] - B[1], K = Math.abs(Z) <= (T || 0);\n        return {\n          isBound: K,\n          offset: K ? Z : 0\n        };\n      }\n    }\n  } else {\n    if (S && !W)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (X) {\n      var q = Y * ($[0] - B[0]) + B[1];\n      return checkInnerBoundDot(q, $[1], U[1], o, T);\n    } else {\n      var Z = $[0] - B[0], K = Math.abs(Z) <= (T || 0);\n      return {\n        isBound: K,\n        offset: K ? Z : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction getInnerBoundInfo(r, t, e) {\n  return t.map(function(o) {\n    var T = checkInnerBound(r, o), S = T.isBound, N = T.offset, D = T.isVerticalBound, B = T.isHorizontalBound, $ = o.multiple, U = getDragDist({\n      datas: e,\n      distX: N[0],\n      distY: N[1]\n    }).map(function(z, V) {\n      return z * ($[V] ? 2 / $[V] : 0);\n    });\n    return {\n      sign: $,\n      isBound: S,\n      isVerticalBound: D,\n      isHorizontalBound: B,\n      isSnap: !1,\n      offset: U\n    };\n  });\n}\nfunction getInnerBoundDragInfo(r, t, e) {\n  var o, T = getCheckInnerBoundLineInfos(r, t, [0, 0], !1).map(function(V) {\n    return __assign$2(__assign$2({}, V), {\n      multiple: V.multiple.map(function(X) {\n        return Math.abs(X) * 2;\n      })\n    });\n  }), S = getInnerBoundInfo(r, T, e), N = getNearOffsetInfo(S, 0), D = getNearOffsetInfo(S, 1), B = 0, $ = 0, U = N.isVerticalBound || D.isVerticalBound, z = N.isHorizontalBound || D.isHorizontalBound;\n  return (U || z) && (o = getInverseDragDist({\n    datas: e,\n    distX: -N.offset[0],\n    distY: -D.offset[1]\n  }), B = o[0], $ = o[1]), {\n    vertical: {\n      isBound: U,\n      offset: B\n    },\n    horizontal: {\n      isBound: z,\n      offset: $\n    }\n  };\n}\nfunction getCheckSnapLineDirections(r, t) {\n  var e = [], o = r[0], T = r[1];\n  return o && T ? e.push([[0, T * 2], r, [-o, T]], [[o * 2, 0], r, [o, -T]]) : o ? (e.push([[o * 2, 0], [o, 1], [o, -1]]), t && e.push([[0, -1], [o, -1], [-o, -1]], [[0, 1], [o, 1], [-o, 1]])) : T ? (e.push([[0, T * 2], [1, T], [-1, T]]), t && e.push([[-1, 0], [-1, T], [-1, -T]], [[1, 0], [1, T], [1, -T]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;\n}\nfunction getCheckInnerBoundLineInfos(r, t, e, o) {\n  var T = r.state, S = T.allMatrix, N = T.is3d, D = calculatePoses(S, 100, 100, N ? 4 : 3), B = getPosByDirection(D, [0, 0]);\n  return getCheckSnapLineDirections(e, o).map(function($) {\n    var U = $[0], z = $[1], V = $[2], X = [getPosByDirection(D, z), getPosByDirection(D, V)], W = solveLineConstants(X), Y = isStartLine(B, X), q = Y.vertical, Z = Y.horizontal, K = hitTestLine(B, X) <= 0;\n    return {\n      multiple: U,\n      centerSign: K,\n      verticalSign: q,\n      horizontalSign: Z,\n      lineConstants: W,\n      line: [getPosByDirection(t, z), getPosByDirection(t, V)]\n    };\n  });\n}\nfunction isBoundRotate$1(r, t, e, o) {\n  var T = o ? r.map(function(S) {\n    return rotate(S, o);\n  }) : r;\n  return [[T[0], T[1]], [T[1], T[3]], [T[3], T[2]], [T[2], T[0]]].some(function(S) {\n    var N = hitTestLine(e, S) <= 0;\n    return !isSameStartLine(t, S, N);\n  });\n}\nfunction getDistPointLine(r) {\n  var t = r[0], e = r[1], o = e[0] - t[0], T = e[1] - t[1];\n  if (!o)\n    return Math.abs(t[0]);\n  if (!T)\n    return Math.abs(t[1]);\n  var S = T / o;\n  return Math.abs((-S * t[0] + t[1]) / Math.sqrt(Math.pow(S, 2) + 1));\n}\nfunction solveReverseLine(r) {\n  var t = r[0], e = r[1], o = e[0] - t[0], T = e[1] - t[1];\n  if (!o)\n    return [t[0], 0];\n  if (!T)\n    return [0, t[1]];\n  var S = T / o, N = -S * t[0] + t[1];\n  return [-N / (S + 1 / S), N / (S * S + 1)];\n}\nfunction checkRotateInnerBounds(r, t, e, o, T) {\n  var S = r.props.innerBounds, N = T * Math.PI / 180;\n  if (!S)\n    return [];\n  var D = S.left, B = S.top, $ = S.width, U = S.height, z = D - o[0], V = D + $ - o[0], X = B - o[1], W = B + U - o[1], Y = [[z, X], [V, X], [z, W], [V, W]], q = getPosByDirection(e, [0, 0]);\n  if (!isBoundRotate$1(e, Y, q, 0))\n    return [];\n  var Z = [], K = Y.map(function(J) {\n    return [getDistSize(J), getRad$1([0, 0], J)];\n  });\n  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(J) {\n    var tt = getRad$1([0, 0], solveReverseLine(J)), et = getDistPointLine(J);\n    Z.push.apply(Z, K.filter(function(Q) {\n      var at = Q[0];\n      return at && et <= at;\n    }).map(function(Q) {\n      var at = Q[0], it = Q[1], st = Math.acos(at ? et / at : 0), ut = it + st, ft = it - st;\n      return [N + ut - tt, N + ft - tt];\n    }).reduce(function(Q, at) {\n      return Q.push.apply(Q, at), Q;\n    }, []).filter(function(Q) {\n      return !isBoundRotate$1(t, Y, q, Q);\n    }).map(function(Q) {\n      return throttle(Q * 180 / Math.PI, TINY_NUM);\n    }));\n  }), Z;\n}\nfunction checkInnerBoundPoses(r) {\n  var t = r.props.innerBounds;\n  if (!t)\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  var e = r.getRect(), o = e.pos1, T = e.pos2, S = e.pos3, N = e.pos4, D = [o, T, S, N], B = getPosByDirection(D, [0, 0]), $ = t.left, U = t.top, z = t.width, V = t.height, X = [[$, U], [$, U + V]], W = [[$, U], [$ + z, U]], Y = [[$ + z, U], [$ + z, U + V]], q = [[$, U + V], [$ + z, U + V]], Z = getCheckInnerBoundLineInfos(r, D, [0, 0], !1), K = [], J = [], tt = {\n    top: !1,\n    bottom: !1,\n    left: !1,\n    right: !1\n  };\n  return Z.forEach(function(et) {\n    var Q = et.line, at = et.lineConstants, it = isStartLine(B, Q), st = it.horizontal, ut = it.vertical, ft = checkLineBoundCollision(Q, at, W, ut, 1, !0), ct = checkLineBoundCollision(Q, at, q, ut, 1, !0), pt = checkLineBoundCollision(Q, at, X, st, 1, !0), mt = checkLineBoundCollision(Q, at, Y, st, 1, !0);\n    ft.isBound && !tt.top && (K.push(U), tt.top = !0), ct.isBound && !tt.bottom && (K.push(U + V), tt.bottom = !0), pt.isBound && !tt.left && (J.push($), tt.left = !0), mt.isBound && !tt.right && (J.push($ + z), tt.right = !0);\n  }), {\n    horizontal: K,\n    vertical: J\n  };\n}\nfunction checkBoundPoses(r, t, e) {\n  var o = r || {}, T = o.position, S = T === void 0 ? \"client\" : T, N = o.left, D = N === void 0 ? -1 / 0 : N, B = o.top, $ = B === void 0 ? -1 / 0 : B, U = o.right, z = U === void 0 ? 1 / 0 : U, V = o.bottom, X = V === void 0 ? 1 / 0 : V, W = {\n    position: S,\n    left: D,\n    top: $,\n    right: z,\n    bottom: X\n  };\n  return {\n    vertical: checkBounds(W, t, !0),\n    horizontal: checkBounds(W, e, !1)\n  };\n}\nfunction getBounds(r, t) {\n  var e = r.state, o = e.containerClientRect, T = o.clientHeight, S = o.clientWidth, N = o.clientLeft, D = o.clientTop, B = e.snapOffset, $ = B.left, U = B.top, z = B.right, V = B.bottom, X = t || r.props.bounds || {}, W = X.position || \"client\", Y = W === \"css\", q = X.left, Z = q === void 0 ? -1 / 0 : q, K = X.top, J = K === void 0 ? -1 / 0 : K, tt = X.right, et = tt === void 0 ? Y ? -1 / 0 : 1 / 0 : tt, Q = X.bottom, at = Q === void 0 ? Y ? -1 / 0 : 1 / 0 : Q;\n  return Y && (et = S + z - $ - et, at = T + V - U - at), {\n    left: Z + $ - N,\n    right: et + $ - N,\n    top: J + U - D,\n    bottom: at + U - D\n  };\n}\nfunction checkBoundKeepRatio(r, t, e) {\n  var o = getBounds(r), T = o.left, S = o.top, N = o.right, D = o.bottom, B = e[0], $ = e[1], U = minus(e, t), z = U[0], V = U[1];\n  Math.abs(z) < TINY_NUM && (z = 0), Math.abs(V) < TINY_NUM && (V = 0);\n  var X = V > 0, W = z > 0, Y = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, q = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (z === 0 && V === 0)\n    return {\n      vertical: Y,\n      horizontal: q\n    };\n  if (z === 0)\n    X ? D < $ && (q.pos = D, q.offset = $ - D) : S > $ && (q.pos = S, q.offset = $ - S);\n  else if (V === 0)\n    W ? N < B && (Y.pos = N, Y.offset = B - N) : T > B && (Y.pos = T, Y.offset = B - T);\n  else {\n    var Z = V / z, K = e[1] - Z * B, J = 0, tt = 0, et = !1;\n    W && N <= B ? (J = Z * N + K, tt = N, et = !0) : !W && B <= T && (J = Z * T + K, tt = T, et = !0), et && (J < S || J > D) && (et = !1), et || (X && D <= $ ? (J = D, tt = (J - K) / Z, et = !0) : !X && $ <= S && (J = S, tt = (J - K) / Z, et = !0)), et && (Y.isBound = !0, Y.pos = tt, Y.offset = B - tt, q.isBound = !0, q.pos = J, q.offset = $ - J);\n  }\n  return {\n    vertical: Y,\n    horizontal: q\n  };\n}\nfunction checkBounds(r, t, e) {\n  var o = r[e ? \"left\" : \"top\"], T = r[e ? \"right\" : \"bottom\"], S = Math.min.apply(Math, t), N = Math.max.apply(Math, t), D = [];\n  return o + 1 > S && D.push({\n    isBound: !0,\n    offset: S - o,\n    pos: o\n  }), T - 1 < N && D.push({\n    isBound: !0,\n    offset: N - T,\n    pos: T\n  }), D.length || D.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), D.sort(function(B, $) {\n    return Math.abs($.offset) - Math.abs(B.offset);\n  });\n}\nfunction isBoundRotate(r, t, e) {\n  var o = e ? r.map(function(T) {\n    return rotate(T, e);\n  }) : r;\n  return o.some(function(T) {\n    return T[0] < t.left && Math.abs(T[0] - t.left) > 0.1 || T[0] > t.right && Math.abs(T[0] - t.right) > 0.1 || T[1] < t.top && Math.abs(T[1] - t.top) > 0.1 || T[1] > t.bottom && Math.abs(T[1] - t.bottom) > 0.1;\n  });\n}\nfunction boundRotate(r, t, e) {\n  var o = getDistSize(r), T = Math.sqrt(o * o - t * t) || 0;\n  return [T, -T].sort(function(S, N) {\n    return Math.abs(S - r[e ? 0 : 1]) - Math.abs(N - r[e ? 0 : 1]);\n  }).map(function(S) {\n    return getRad$1([0, 0], e ? [S, t] : [t, S]);\n  });\n}\nfunction checkRotateBounds(r, t, e, o, T) {\n  if (!r.props.bounds)\n    return [];\n  var S = T * Math.PI / 180, N = getBounds(r), D = N.left, B = N.top, $ = N.right, U = N.bottom, z = D - o[0], V = $ - o[0], X = B - o[1], W = U - o[1], Y = {\n    left: z,\n    top: X,\n    right: V,\n    bottom: W\n  };\n  if (!isBoundRotate(e, Y, 0))\n    return [];\n  var q = [];\n  return [[z, 0], [V, 0], [X, 1], [W, 1]].forEach(function(Z) {\n    var K = Z[0], J = Z[1];\n    e.forEach(function(tt) {\n      var et = getRad$1([0, 0], tt);\n      q.push.apply(q, boundRotate(tt, K, J).map(function(Q) {\n        return S + Q - et;\n      }).filter(function(Q) {\n        return !isBoundRotate(t, Y, Q);\n      }).map(function(Q) {\n        return throttle(Q * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  }), q;\n}\nfunction renderGuideline(r, t) {\n  var e, o = r.direction, T = r.classNames, S = r.size, N = r.pos, D = r.zoom, B = r.key, $ = o === \"horizontal\", U = $ ? \"Y\" : \"X\";\n  return t.createElement(\"div\", {\n    key: B,\n    className: T.join(\" \"),\n    style: (e = {}, e[$ ? \"width\" : \"height\"] = \"\".concat(S), e.transform = \"translate(\".concat(N[0], \", \").concat(N[1], \") translate\").concat(U, \"(-50%) scale\").concat(U, \"(\").concat(D, \")\"), e)\n  });\n}\nfunction renderInnerGuideline(r, t) {\n  return renderGuideline(__assign$2(__assign$2({}, r), {\n    classNames: __spreadArray([prefix(\"line\", \"guideline\", r.direction)], r.classNames, !0).filter(function(e) {\n      return e;\n    }),\n    size: r.size || \"\".concat(r.sizeValue, \"px\"),\n    pos: r.pos || r.posValue.map(function(e) {\n      return \"\".concat(throttle(e, 0.1), \"px\");\n    })\n  }), t);\n}\nfunction renderSnapPoses(r, t, e, o, T, S, N, D) {\n  var B = r.props.zoom;\n  return e.map(function($, U) {\n    var z = $.type, V = $.pos, X = [0, 0];\n    return X[N] = o, X[N ? 0 : 1] = -T + V, renderInnerGuideline({\n      key: \"\".concat(t, \"TargetGuideline\").concat(U),\n      classNames: [prefix(\"target\", \"bold\", z)],\n      posValue: X,\n      sizeValue: S,\n      zoom: B,\n      direction: t\n    }, D);\n  });\n}\nfunction renderGuidelines(r, t, e, o, T, S) {\n  var N = r.props, D = N.zoom, B = N.isDisplayInnerSnapDigit, $ = t === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = T[$.start], z = T[$.end];\n  return e.filter(function(V) {\n    var X = V.hide, W = V.elementRect;\n    if (X)\n      return !1;\n    if (B && W) {\n      var Y = W.rect;\n      if (Y[$.start] <= U && z <= Y[$.end])\n        return !1;\n    }\n    return !0;\n  }).map(function(V, X) {\n    var W = V.pos, Y = V.size, q = V.element, Z = V.className, K = [-o[0] + W[0], -o[1] + W[1]];\n    return renderInnerGuideline({\n      key: \"\".concat(t, \"-default-guideline-\").concat(X),\n      classNames: q ? [prefix(\"bold\"), Z] : [prefix(\"normal\"), Z],\n      direction: t,\n      posValue: K,\n      sizeValue: Y,\n      zoom: D\n    }, S);\n  });\n}\nfunction renderDigitLine(r, t, e, o, T, S, N, D) {\n  var B, $ = r.props, U = $.snapDigit, z = U === void 0 ? 0 : U, V = $.isDisplaySnapDigit, X = V === void 0 ? !0 : V, W = $.snapDistFormat, Y = W === void 0 ? function(et, Q) {\n    return et;\n  } : W, q = $.zoom, Z = t === \"horizontal\" ? \"X\" : \"Y\", K = t === \"vertical\" ? \"height\" : \"width\", J = Math.abs(T), tt = X ? parseFloat(J.toFixed(z)) : 0;\n  return D.createElement(\"div\", {\n    key: \"\".concat(t, \"-\").concat(e, \"-guideline-\").concat(o),\n    className: prefix(\"guideline-group\", t),\n    style: (B = {\n      left: \"\".concat(S[0], \"px\"),\n      top: \"\".concat(S[1], \"px\")\n    }, B[K] = \"\".concat(J, \"px\"), B)\n  }, renderInnerGuideline({\n    direction: t,\n    classNames: [prefix(e), N],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: J,\n    zoom: q\n  }, D), D.createElement(\"div\", {\n    className: prefix(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(Z, \"(-50%) scale(\").concat(q, \")\")\n    }\n  }, tt > 0 ? Y(tt, t) : \"\"));\n}\nfunction groupByElementGuidelines(r, t, e, o) {\n  var T = r === \"vertical\" ? 0 : 1, S = r === \"vertical\" ? 1 : 0, N = T ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, D = e[N.start], B = e[N.end];\n  return groupBy(t, function($) {\n    return $.pos[T];\n  }).map(function($) {\n    var U = [], z = [], V = [];\n    return $.forEach(function(X) {\n      var W, Y, q = X.element, Z = X.elementRect.rect;\n      if (Z[N.end] < D)\n        U.push(X);\n      else if (B < Z[N.start])\n        z.push(X);\n      else if (Z[N.start] <= D && B <= Z[N.end] && o) {\n        var K = X.pos, J = {\n          element: q,\n          rect: __assign$2(__assign$2({}, Z), (W = {}, W[N.end] = Z[N.start], W))\n        }, tt = {\n          element: q,\n          rect: __assign$2(__assign$2({}, Z), (Y = {}, Y[N.start] = Z[N.end], Y))\n        }, et = [0, 0], Q = [0, 0];\n        et[T] = K[T], et[S] = K[S], Q[T] = K[T], Q[S] = K[S] + X.size, U.push({\n          type: r,\n          pos: et,\n          size: 0,\n          elementRect: J\n        }), z.push({\n          type: r,\n          pos: Q,\n          size: 0,\n          elementRect: tt\n        });\n      }\n    }), U.sort(function(X, W) {\n      return W.pos[S] - X.pos[S];\n    }), z.sort(function(X, W) {\n      return X.pos[S] - W.pos[S];\n    }), {\n      total: $,\n      start: U,\n      end: z,\n      inner: V\n    };\n  });\n}\nfunction renderDashedGuidelines(r, t, e, o, T) {\n  var S = r.props.isDisplayInnerSnapDigit, N = [];\n  return [\"vertical\", \"horizontal\"].forEach(function(D) {\n    var B = t.filter(function(q) {\n      return q.type === D;\n    }), $ = D === \"vertical\" ? 1 : 0, U = $ ? 0 : 1, z = groupByElementGuidelines(D, B, o, S), V = $ ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, X = $ ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, W = o[V.start], Y = o[V.end];\n    z.forEach(function(q) {\n      var Z = q.total, K = q.start, J = q.end, tt = q.inner, et = e[U] + Z[0].pos[U] - o[X.start], Q = o;\n      K.forEach(function(at) {\n        var it = at.elementRect.rect, st = Q[V.start] - it[V.end];\n        if (st > 0) {\n          var ut = [0, 0];\n          ut[$] = e[$] + Q[V.start] - W - st, ut[U] = et, N.push(renderDigitLine(r, D, \"dashed\", N.length, st, ut, at.className, T));\n        }\n        Q = it;\n      }), Q = o, J.forEach(function(at) {\n        var it = at.elementRect.rect, st = it[V.start] - Q[V.end];\n        if (st > 0) {\n          var ut = [0, 0];\n          ut[$] = e[$] + Q[V.end] - W, ut[U] = et, N.push(renderDigitLine(r, D, \"dashed\", N.length, st, ut, at.className, T));\n        }\n        Q = it;\n      }), tt.forEach(function(at) {\n        var it = at.elementRect.rect, st = W - it[V.start], ut = it[V.end] - Y, ft = [0, 0], ct = [0, 0];\n        ft[$] = e[$] - st, ft[U] = et, ct[$] = e[$] + Y - W, ct[U] = et, N.push(renderDigitLine(r, D, \"dashed\", N.length, st, ft, at.className, T)), N.push(renderDigitLine(r, D, \"dashed\", N.length, ut, ct, at.className, T));\n      });\n    });\n  }), N;\n}\nfunction renderGapGuidelines(r, t, e, o, T) {\n  var S = [];\n  return [\"horizontal\", \"vertical\"].forEach(function(N) {\n    var D = t.filter(function(q) {\n      return q.type === N;\n    }).slice(0, 1), B = N === \"vertical\" ? 0 : 1, $ = B ? 0 : 1, U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, z = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, V = o[U.start], X = o[U.end], W = o[z.start], Y = o[z.end];\n    D.forEach(function(q) {\n      var Z = q.gap, K = q.gapRects, J = Math.max.apply(Math, __spreadArray([W], K.map(function(Q) {\n        var at = Q.rect;\n        return at[z.start];\n      }), !1)), tt = Math.min.apply(Math, __spreadArray([Y], K.map(function(Q) {\n        var at = Q.rect;\n        return at[z.end];\n      }), !1)), et = (J + tt) / 2;\n      J === tt || et === (W + Y) / 2 || K.forEach(function(Q) {\n        var at = Q.rect, it = Q.className, st = [e[0], e[1]];\n        if (at[U.end] < V)\n          st[B] += at[U.end] - V;\n        else if (X < at[U.start])\n          st[B] += at[U.start] - V - Z;\n        else\n          return;\n        st[$] += et - W, S.push(renderDigitLine(r, B ? \"vertical\" : \"horizontal\", \"gap\", S.length, Z, st, it, T));\n      });\n    });\n  }), S;\n}\nfunction solveEquation(r, t, e, o) {\n  var T = t[0] - r[0], S = t[1] - r[1];\n  if (Math.abs(T) < TINY_NUM$1 && (T = 0), Math.abs(S) < TINY_NUM$1 && (S = 0), !T)\n    return o ? [0, 0] : [0, e];\n  if (!S)\n    return o ? [e, 0] : [0, 0];\n  var N = S / T, D = r[1] - N * r[0];\n  if (o) {\n    var B = N * (t[0] + e) + D;\n    return [e, B - t[1]];\n  } else {\n    var $ = (t[1] + e - D) / N;\n    return [$ - t[0], e];\n  }\n}\nfunction solveNextOffset(r, t, e, o, T) {\n  var S = solveEquation(r, t, e, o);\n  if (!S)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  var N = getDist$2(r, t), D = getDist$2(S, r), B = getDist$2(S, t), $ = D > N || B > N, U = getDragDist({\n    datas: T,\n    distX: S[0],\n    distY: S[1]\n  }), z = U[0], V = U[1];\n  return {\n    offset: [z, V],\n    isOutside: $\n  };\n}\nfunction getSnapBound(r, t) {\n  return r.isBound ? r.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;\n}\nfunction checkThrottleDragRotate(r, t, e, o, T) {\n  var S = t[0], N = t[1], D = e[0], B = e[1], $ = o[0], U = o[1], z = T[0], V = T[1], X = -z, W = -V;\n  if (r && S && N) {\n    X = 0, W = 0;\n    var Y = [];\n    if (D && B ? Y.push([0, V], [z, 0]) : D ? Y.push([z, 0]) : B ? Y.push([0, V]) : $ && U ? Y.push([0, V], [z, 0]) : $ ? Y.push([z, 0]) : U && Y.push([0, V]), Y.length) {\n      Y.sort(function(J, tt) {\n        return getDistSize(minus([S, N], J)) - getDistSize(minus([S, N], tt));\n      });\n      var q = Y[0];\n      if (q[0] && Math.abs(S) > TINY_NUM$1)\n        X = -q[0], W = N * Math.abs(S + X) / Math.abs(S) - N;\n      else if (q[1] && Math.abs(N) > TINY_NUM$1) {\n        var Z = N;\n        W = -q[1], X = S * Math.abs(N + W) / Math.abs(Z) - S;\n      }\n      if (r && B && D)\n        if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(z)) {\n          var K = Math.abs(z) / Math.abs(X);\n          X *= K, W *= K;\n        } else if (Math.abs(W) > TINY_NUM$1 && Math.abs(W) < Math.abs(V)) {\n          var K = Math.abs(V) / Math.abs(W);\n          X *= K, W *= K;\n        } else\n          X = maxOffset(-z, X), W = maxOffset(-V, W);\n    }\n  } else\n    X = S || D ? -z : 0, W = N || B ? -V : 0;\n  return [X, W];\n}\nfunction checkSnapBoundsDrag(r, t, e, o, T, S) {\n  if (!hasGuidelines(r, \"draggable\"))\n    return [{\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }, {\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }];\n  var N = getAbsolutePoses(S.absolutePoses, [t, e]), D = getRect(N), B = D.left, $ = D.right, U = D.top, z = D.bottom, V = {\n    horizontal: N.map(function(mt) {\n      return mt[1];\n    }),\n    vertical: N.map(function(mt) {\n      return mt[0];\n    })\n  }, X = getSnapDirections(r.props.snapDirections), W = splitSnapDirectionPoses(X, {\n    left: B,\n    right: $,\n    top: U,\n    bottom: z,\n    center: (B + $) / 2,\n    middle: (U + z) / 2\n  }), Y = checkMoveableSnapBounds(r, T, W, V), q = Y.vertical, Z = Y.horizontal, K = getInnerBoundDragInfo(r, N, S), J = K.vertical, tt = K.horizontal, et = q.isSnap, Q = Z.isSnap, at = q.isBound || J.isBound, it = Z.isBound || tt.isBound, st = maxOffset(q.offset, J.offset), ut = maxOffset(Z.offset, tt.offset), ft = checkThrottleDragRotate(o, [t, e], [at, it], [et, Q], [st, ut]), ct = ft[0], pt = ft[1];\n  return [{\n    isBound: at,\n    isSnap: et,\n    offset: ct\n  }, {\n    isBound: it,\n    isSnap: Q,\n    offset: pt\n  }];\n}\nfunction checkMoveableSnapBounds(r, t, e, o) {\n  o === void 0 && (o = e);\n  var T = checkBoundPoses(getBounds(r), o.vertical, o.horizontal), S = T.horizontal, N = T.vertical, D = t ? {\n    horizontal: {\n      isSnap: !1,\n      index: -1\n    },\n    vertical: {\n      isSnap: !1,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(r, e.vertical, e.horizontal), B = D.horizontal, $ = D.vertical, U = getSnapBound(S[0], B), z = getSnapBound(N[0], $), V = Math.abs(U), X = Math.abs(z);\n  return {\n    horizontal: {\n      isBound: S[0].isBound,\n      isSnap: B.isSnap,\n      snapIndex: B.index,\n      offset: U,\n      dist: V,\n      bounds: S,\n      snap: B\n    },\n    vertical: {\n      isBound: N[0].isBound,\n      isSnap: $.isSnap,\n      snapIndex: $.index,\n      offset: z,\n      dist: X,\n      bounds: N,\n      snap: $\n    }\n  };\n}\nfunction checkSnapBounds(r, t, e, o, T) {\n  var S = checkBoundPoses(t, e, o), N = S.horizontal, D = S.vertical, B = checkSnapPoses(r, e, o, T), $ = B.horizontal, U = B.vertical, z = getSnapBound(N[0], $), V = getSnapBound(D[0], U), X = Math.abs(z), W = Math.abs(V);\n  return {\n    horizontal: {\n      isBound: N[0].isBound,\n      isSnap: $.isSnap,\n      snapIndex: $.index,\n      offset: z,\n      dist: X,\n      bounds: N,\n      snap: $\n    },\n    vertical: {\n      isBound: D[0].isBound,\n      isSnap: U.isSnap,\n      snapIndex: U.index,\n      offset: V,\n      dist: W,\n      bounds: D,\n      snap: U\n    }\n  };\n}\nfunction checkSnapRightLine(r, t, e, o) {\n  var T = getRad$1(r, t) / Math.PI * 180, S = e.vertical, N = S.isBound, D = S.isSnap, B = S.dist, $ = e.horizontal, U = $.isBound, z = $.isSnap, V = $.dist, X = T % 180, W = X < 3 || X > 177, Y = X > 87 && X < 93;\n  return V < B && (N || D && !Y && (!o || !W)) ? \"vertical\" : U || z && !W && (!o || !Y) ? \"horizontal\" : \"\";\n}\nfunction getSnapBoundInfo(r, t, e, o, T, S) {\n  return e.map(function(N) {\n    var D = N[0], B = N[1], $ = getPosByDirection(t, D), U = getPosByDirection(t, B), z = o ? checkSnapBoundsKeepRatio(r, $, U, T) : checkMoveableSnapBounds(r, T, {\n      vertical: [U[0]],\n      horizontal: [U[1]]\n    }), V = z.horizontal, X = V.offset, W = V.isBound, Y = V.isSnap, q = z.vertical, Z = q.offset, K = q.isBound, J = q.isSnap, tt = minus(B, D);\n    if (!Z && !X)\n      return {\n        isBound: K || W,\n        isSnap: J || Y,\n        sign: tt,\n        offset: [0, 0]\n      };\n    var et = checkSnapRightLine($, U, z, o);\n    if (!et)\n      return {\n        sign: tt,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    var Q = et === \"vertical\", at = [0, 0];\n    return !o && Math.abs(B[0]) === 1 && Math.abs(B[1]) === 1 && D[0] !== B[0] && D[1] !== B[1] ? at = getDragDist({\n      datas: S,\n      distX: -Z,\n      distY: -X\n    }) : at = solveNextOffset($, U, -(Q ? Z : X), Q, S).offset, at = at.map(function(it, st) {\n      return it * (tt[st] ? 2 / tt[st] : 0);\n    }), {\n      sign: tt,\n      isBound: Q ? K : W,\n      isSnap: Q ? J : Y,\n      offset: at\n    };\n  });\n}\nfunction getSnapBoundOffset(r, t) {\n  return r.isBound ? r.offset : t.isSnap ? t.offset : 0;\n}\nfunction checkSnapBoundsKeepRatio(r, t, e, o) {\n  var T = checkBoundKeepRatio(r, t, e), S = T.horizontal, N = T.vertical, D = o ? {\n    horizontal: {\n      isSnap: !1\n    },\n    vertical: {\n      isSnap: !1\n    }\n  } : checkSnapKeepRatio(r, t, e), B = D.horizontal, $ = D.vertical, U = getSnapBoundOffset(S, B), z = getSnapBoundOffset(N, $), V = Math.abs(U), X = Math.abs(z);\n  return {\n    horizontal: {\n      isBound: S.isBound,\n      isSnap: B.isSnap,\n      offset: U,\n      dist: V\n    },\n    vertical: {\n      isBound: N.isBound,\n      isSnap: $.isSnap,\n      offset: z,\n      dist: X\n    }\n  };\n}\nfunction checkMaxBounds(r, t, e, o, T) {\n  var S = [-e[0], -e[1]], N = r.state, D = N.width, B = N.height, $ = r.props.bounds, U = 1 / 0, z = 1 / 0;\n  if ($) {\n    var V = [[e[0], -e[1]], [-e[0], e[1]]], X = $.left, W = X === void 0 ? -1 / 0 : X, Y = $.top, q = Y === void 0 ? -1 / 0 : Y, Z = $.right, K = Z === void 0 ? 1 / 0 : Z, J = $.bottom, tt = J === void 0 ? 1 / 0 : J;\n    V.forEach(function(et) {\n      var Q = et[0] !== S[0], at = et[1] !== S[1], it = getPosByDirection(t, et), st = getRad$1(o, it) * 360 / Math.PI;\n      if (at) {\n        var ut = it.slice();\n        (Math.abs(st - 360) < 2 || Math.abs(st - 180) < 2) && (ut[1] = o[1]);\n        var ft = solveNextOffset(o, ut, (o[1] < it[1] ? tt : q) - it[1], !1, T), ct = ft.offset, pt = ct[1], mt = ft.isOutside;\n        isNaN(pt) || (z = B + (mt ? 1 : -1) * Math.abs(pt));\n      }\n      if (Q) {\n        var ut = it.slice();\n        (Math.abs(st - 90) < 2 || Math.abs(st - 270) < 2) && (ut[0] = o[0]);\n        var vt = solveNextOffset(o, ut, (o[0] < it[0] ? K : W) - it[0], !0, T), _t = vt.offset[0], xt = vt.isOutside;\n        isNaN(_t) || (U = D + (xt ? 1 : -1) * Math.abs(_t));\n      }\n    });\n  }\n  return {\n    maxWidth: U,\n    maxHeight: z\n  };\n}\nfunction getTotalGuidelines(r) {\n  var t = r.state, e = t.snapOffset, o = t.containerClientRect, T = o.overflow, S = o.scrollHeight, N = o.scrollWidth, D = o.clientHeight, B = o.clientWidth, $ = o.clientLeft, U = o.clientTop, z = r.props, V = z.snapGap, X = V === void 0 ? !0 : V, W = z.verticalGuidelines, Y = z.horizontalGuidelines, q = z.snapThreshold, Z = q === void 0 ? 5 : q, K = z.snapGridWidth, J = K === void 0 ? 0 : K, tt = z.snapGridHeight, et = tt === void 0 ? 0 : tt, Q = z.maxSnapElementGuidelineDistance, at = Q === void 0 ? 1 / 0 : Q, it = getRect(getAbsolutePosesByState(r.state)), st = it.top, ut = it.left, ft = it.bottom, ct = it.right, pt = {\n    top: st,\n    left: ut,\n    bottom: ft,\n    right: ct,\n    center: (ut + ct) / 2,\n    middle: (st + ft) / 2\n  }, mt = getElementGuidelines(r), vt = __spreadArray([], mt, !0);\n  return X && vt.push.apply(vt, getGapGuidelines(r, pt, Z)), vt.push.apply(vt, getGridGuidelines(J, et, T ? N : B, T ? S : D, $, U)), vt.push.apply(vt, getDefaultGuidelines(Y || !1, W || !1, T ? N : B, T ? S : D, $, U, e)), vt = vt.filter(function(_t) {\n    var xt = _t.element, Rt = _t.elementRect, yt = _t.type;\n    if (!xt || !Rt)\n      return !0;\n    var ht = Rt.rect;\n    return checkBetweenRects(pt, ht, yt, at);\n  }), vt;\n}\nfunction getGapGuidelines(r, t, e) {\n  var o = r.props, T = o.maxSnapElementGuidelineDistance, S = T === void 0 ? 1 / 0 : T, N = o.maxSnapElementGapDistance, D = N === void 0 ? 1 / 0 : N, B = r.state.elementRects, $ = [];\n  return [[\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(U) {\n    var z = U[0], V = U[1], X = U[2], W = t[V.start], Y = t[V.end], q = t[V.center], Z = t[X.start], K = t[X.end];\n    function J(Q) {\n      var at = Q.rect;\n      return at[V.end] < W + e ? W - at[V.end] : Y - e < at[V.start] ? at[V.start] - Y : -1;\n    }\n    var tt = B.filter(function(Q) {\n      var at = Q.rect;\n      return at[X.start] > K || at[X.end] < Z ? !1 : J(Q) > 0;\n    }).sort(function(Q, at) {\n      return J(Q) - J(at);\n    }), et = [];\n    tt.forEach(function(Q) {\n      tt.forEach(function(at) {\n        if (Q !== at) {\n          var it = Q.rect, st = at.rect, ut = it[X.start], ft = it[X.end], ct = st[X.start], pt = st[X.end];\n          ut > pt || ct > ft || et.push([Q, at]);\n        }\n      });\n    }), et.forEach(function(Q) {\n      var at = Q[0], it = Q[1], st = at.rect, ut = it.rect, ft = st[V.start], ct = st[V.end], pt = ut[V.start], mt = ut[V.end], vt = 0, _t = 0, xt = !1, Rt = !1, yt = !1;\n      if (ct <= W && Y <= pt) {\n        if (Rt = !0, vt = (pt - ct - (Y - W)) / 2, _t = ct + vt + (Y - W) / 2, Math.abs(_t - q) > e)\n          return;\n      } else if (ct < pt && mt < W + e) {\n        if (xt = !0, vt = pt - ct, _t = mt + vt, Math.abs(_t - W) > e)\n          return;\n      } else if (ct < pt && Y - e < ft) {\n        if (yt = !0, vt = pt - ct, _t = ft - vt, Math.abs(_t - Y) > e)\n          return;\n      } else\n        return;\n      !vt || !checkBetweenRects(t, ut, z, S) || vt > D || $.push({\n        type: z,\n        pos: z === \"vertical\" ? [_t, 0] : [0, _t],\n        element: it.element,\n        size: 0,\n        className: it.className,\n        isStart: xt,\n        isCenter: Rt,\n        isEnd: yt,\n        gap: vt,\n        hide: !0,\n        gapRects: [at, it]\n      });\n    });\n  }), $;\n}\nfunction getGridGuidelines(r, t, e, o, T, S) {\n  T === void 0 && (T = 0), S === void 0 && (S = 0);\n  var N = [];\n  if (t)\n    for (var D = 0; D <= o; D += t)\n      N.push({\n        type: \"horizontal\",\n        pos: [0, throttle(D - S, 0.1)],\n        size: e,\n        hide: !0\n      });\n  if (r)\n    for (var D = 0; D <= e; D += r)\n      N.push({\n        type: \"vertical\",\n        pos: [throttle(D - T, 0.1), 0],\n        size: o,\n        hide: !0\n      });\n  return N;\n}\nfunction checkBetweenRects(r, t, e, o) {\n  return e === \"horizontal\" ? Math.abs(r.right - t.left) <= o || Math.abs(r.left - t.right) <= o || r.left <= t.right && t.left <= r.right : e === \"vertical\" ? Math.abs(r.bottom - t.top) <= o || Math.abs(r.top - t.bottom) <= o || r.top <= t.bottom && t.top <= r.bottom : !0;\n}\nfunction getElementGuidelines(r) {\n  var t = r.state, e = r.props.elementGuidelines, o = e === void 0 ? [] : e;\n  if (!o.length)\n    return t.elementRects = [], [];\n  var T = (t.elementRects || []).filter(function(V) {\n    return !V.refresh;\n  }), S = o.map(function(V) {\n    return isObject$2(V) && \"element\" in V ? __assign$2(__assign$2({}, V), {\n      element: getRefTarget(V.element, !0)\n    }) : {\n      element: getRefTarget(V, !0)\n    };\n  }).filter(function(V) {\n    return V.element;\n  }), N = diff(T.map(function(V) {\n    return V.element;\n  }), S.map(function(V) {\n    return V.element;\n  })), D = N.maintained, B = N.added, $ = [];\n  D.forEach(function(V) {\n    var X = V[0], W = V[1];\n    $[W] = T[X];\n  }), getSnapElementRects(r, B.map(function(V) {\n    return S[V];\n  })).map(function(V, X) {\n    $[B[X]] = V;\n  }), t.elementRects = $;\n  var U = getSnapDirections(r.props.elementSnapDirections), z = [];\n  return $.forEach(function(V) {\n    var X = V.element, W = V.top, Y = W === void 0 ? U.top : W, q = V.left, Z = q === void 0 ? U.left : q, K = V.right, J = K === void 0 ? U.right : K, tt = V.bottom, et = tt === void 0 ? U.bottom : tt, Q = V.center, at = Q === void 0 ? U.center : Q, it = V.middle, st = it === void 0 ? U.middle : it, ut = V.className, ft = V.rect, ct = splitSnapDirectionPoses({\n      top: Y,\n      right: J,\n      left: Z,\n      bottom: et,\n      center: at,\n      middle: st\n    }, ft), pt = ct.horizontal, mt = ct.vertical, vt = ft.top, _t = ft.left, xt = ft.right - _t, Rt = ft.bottom - vt, yt = [xt, Rt];\n    mt.forEach(function(ht) {\n      z.push({\n        type: \"vertical\",\n        element: X,\n        pos: [throttle(ht, 0.1), vt],\n        size: Rt,\n        sizes: yt,\n        className: ut,\n        elementRect: V\n      });\n    }), pt.forEach(function(ht) {\n      z.push({\n        type: \"horizontal\",\n        element: X,\n        pos: [_t, throttle(ht, 0.1)],\n        size: xt,\n        sizes: yt,\n        className: ut,\n        elementRect: V\n      });\n    });\n  }), z;\n}\nfunction getDefaultGuidelines(r, t, e, o, T, S, N) {\n  T === void 0 && (T = 0), S === void 0 && (S = 0), N === void 0 && (N = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  });\n  var D = [], B = N.left, $ = N.top, U = N.bottom, z = N.right, V = e + z - B, X = o + U - $;\n  return r && r.forEach(function(W) {\n    var Y = isObject$2(W) ? W : {\n      pos: W\n    };\n    D.push({\n      type: \"horizontal\",\n      pos: [B, throttle(Y.pos - S + $, 0.1)],\n      size: V,\n      className: Y.className\n    });\n  }), t && t.forEach(function(W) {\n    var Y = isObject$2(W) ? W : {\n      pos: W\n    };\n    D.push({\n      type: \"vertical\",\n      pos: [throttle(Y.pos - T + B, 0.1), $],\n      size: X,\n      className: Y.className\n    });\n  }), D;\n}\nfunction getSnapElementRects(r, t) {\n  if (!t.length)\n    return [];\n  var e = r.state, o = e.containerClientRect, T = e.targetClientRect, S = T.top, N = T.left, D = e.rootMatrix, B = e.is3d, $ = B ? 4 : 3, U = calculateContainerPos(D, o, $), z = U[0], V = U[1], X = getAbsolutePosesByState(e), W = getMinMaxs(X), Y = W.minX, q = W.minY, Z = minus([Y, q], calculateInversePosition(D, [N - z, S - V], $)).map(function(tt) {\n    return roundSign(tt);\n  }), K = Z[0], J = Z[1];\n  return t.map(function(tt) {\n    var et = tt.element.getBoundingClientRect(), Q = et.left - z, at = et.top - V, it = at + et.height, st = Q + et.width, ut = calculateInversePosition(D, [Q, at], $), ft = ut[0], ct = ut[1], pt = calculateInversePosition(D, [st, it], $), mt = pt[0], vt = pt[1];\n    return __assign$2(__assign$2({}, tt), {\n      rect: {\n        left: ft + K,\n        right: mt + K,\n        top: ct + J,\n        bottom: vt + J,\n        center: (ft + mt) / 2 + K,\n        middle: (ct + vt) / 2 + J\n      }\n    });\n  });\n}\nfunction snapStart(r) {\n  var t = r.state;\n  if (!(t.guidelines && t.guidelines.length)) {\n    var e = r.state.container, o = r.props.snapContainer || e, T = t.containerClientRect, S = {\n      left: 0,\n      top: 0,\n      bottom: 0,\n      right: 0\n    };\n    if (e !== o) {\n      var N = getRefTarget(o, !0);\n      if (N) {\n        var D = getClientRect(N), B = getDragDistByState(t, [D.left - T.left, D.top - T.top]), $ = getDragDistByState(t, [D.right - T.right, D.bottom - T.bottom]);\n        S.left = throttle(B[0], 1e-5), S.top = throttle(B[1], 1e-5), S.right = throttle($[0], 1e-5), S.bottom = throttle($[1], 1e-5);\n      }\n    }\n    t.snapOffset = S, t.guidelines = getTotalGuidelines(r), t.enableSnap = !0;\n  }\n}\nfunction getNextFixedPoses(r, t, e, o, T, S) {\n  var N = calculatePoses(r, t, e, S ? 4 : 3), D = getPosByDirection(N, o);\n  return getAbsolutePoses(N, minus(T, D));\n}\nfunction getSizeOffsetInfo(r, t, e, o, T, S) {\n  var N = S.fixedDirection, D = getCheckSnapDirections(e, N, o), B = getCheckInnerBoundLineInfos(r, t, e, o), $ = __spreadArray(__spreadArray([], getSnapBoundInfo(r, t, D, o, T, S), !0), getInnerBoundInfo(r, B, S), !0), U = getNearOffsetInfo($, 0), z = getNearOffsetInfo($, 1);\n  return {\n    width: {\n      isBound: U.isBound,\n      offset: U.offset[0]\n    },\n    height: {\n      isBound: z.isBound,\n      offset: z.offset[1]\n    }\n  };\n}\nfunction recheckSizeByTwoDirection(r, t, e, o, T, S, N, D, B) {\n  var $ = getPosByDirection(t, N), U = checkMoveableSnapBounds(r, D, {\n    vertical: [$[0]],\n    horizontal: [$[1]]\n  }), z = U.horizontal.offset, V = U.vertical.offset;\n  if (V || z) {\n    var X = getDragDist({\n      datas: B,\n      distX: -V,\n      distY: -z\n    }), W = X[0], Y = X[1], q = Math.min(T || 1 / 0, e + N[0] * W), Z = Math.min(S || 1 / 0, o + N[1] * Y);\n    return [q - e, Z - o];\n  }\n  return [0, 0];\n}\nfunction checkSizeDist(r, t, e, o, T, S, N, D) {\n  for (var B = getAbsolutePosesByState(r.state), $ = r.props.keepRatio, U = 0, z = 0, V = 0; V < 2; ++V) {\n    var X = t(U, z), W = getSizeOffsetInfo(r, X, T, $, N, D), Y = W.width, q = W.height, Z = Y.isBound, K = q.isBound, J = Y.offset, tt = q.offset;\n    if (V === 1 && (Z || (J = 0), K || (tt = 0)), V === 0 && N && !Z && !K)\n      return [0, 0];\n    if ($) {\n      var et = Math.abs(J) * (e ? 1 / e : 1), Q = Math.abs(tt) * (o ? 1 / o : 1), at = Z && K ? et < Q : K || !Z && et < Q;\n      at ? J = e * tt / o : tt = o * J / e;\n    }\n    U += J, z += tt;\n  }\n  if (T[0] && T[1]) {\n    var it = checkMaxBounds(r, B, T, S, D), st = it.maxWidth, ut = it.maxHeight, ft = recheckSizeByTwoDirection(r, t(U, z).map(function(mt) {\n      return mt.map(function(vt) {\n        return throttle(vt, FLOAT_POINT_NUM);\n      });\n    }), e + U, o + z, st, ut, T, N, D), J = ft[0], tt = ft[1];\n    U += J, z += tt;\n  }\n  return [U, z];\n}\nfunction checkSnapRotate(r, t, e) {\n  if (!hasGuidelines(r, \"rotatable\"))\n    return {\n      isSnap: !1,\n      rotation: e\n    };\n  var o = t.pos1, T = t.pos2, S = t.pos3, N = t.pos4, D = t.origin, B = e * Math.PI / 180, $ = [o, T, S, N].map(function(X) {\n    return minus(X, D);\n  }), U = $.map(function(X) {\n    return rotate(X, B);\n  }), z = __spreadArray(__spreadArray([], checkRotateBounds(r, $, U, D, e), !0), checkRotateInnerBounds(r, $, U, D, e), !0);\n  z.sort(function(X, W) {\n    return Math.abs(X - e) - Math.abs(W - e);\n  });\n  var V = z.length > 0;\n  return {\n    isSnap: V,\n    rotation: V ? z[0] : e\n  };\n}\nfunction checkSnapResize(r, t, e, o, T, S, N) {\n  if (!hasGuidelines(r, \"resizable\"))\n    return [0, 0];\n  var D = N.fixedDirection, B = N.nextAllMatrix, $ = r.state, U = $.allMatrix, z = $.is3d;\n  return checkSizeDist(r, function(V, X) {\n    return getNextFixedPoses(B || U, t + V, e + X, D, T, z);\n  }, t, e, o, T, S, N);\n}\nfunction checkSnapScale(r, t, e, o, T) {\n  if (!hasGuidelines(r, \"scalable\"))\n    return [0, 0];\n  var S = T.startOffsetWidth, N = T.startOffsetHeight, D = T.fixedPosition, B = T.fixedDirection, $ = T.is3d, U = checkSizeDist(r, function(z, V) {\n    return getNextFixedPoses(scaleMatrix(T, plus(t, [z / S, V / N])), S, N, B, D, $);\n  }, S, N, e, D, o, T);\n  return [U[0] / S, U[1] / N];\n}\nfunction startCheckSnapDrag(r, t) {\n  t.absolutePoses = getAbsolutePosesByState(r.state);\n}\nfunction getSnapGuidelines(r) {\n  var t = [];\n  return r.forEach(function(e) {\n    e.guidelineInfos.forEach(function(o) {\n      var T = o.guideline;\n      t.indexOf(T) > -1 || t.push(T);\n    });\n  }), t;\n}\nfunction addBoundGuidelines(r, t, e, o, T, S) {\n  var N = checkBoundPoses(getBounds(r, S), t, e), D = N.vertical, B = N.horizontal;\n  D.forEach(function(V) {\n    V.isBound && o.push({\n      type: \"bounds\",\n      pos: V.pos\n    });\n  }), B.forEach(function(V) {\n    V.isBound && T.push({\n      type: \"bounds\",\n      pos: V.pos\n    });\n  });\n  var $ = checkInnerBoundPoses(r), U = $.vertical, z = $.horizontal;\n  U.forEach(function(V) {\n    findIndex(o, function(X) {\n      var W = X.type, Y = X.pos;\n      return W === \"bounds\" && Y === V;\n    }) >= 0 || o.push({\n      type: \"bounds\",\n      pos: V\n    });\n  }), z.forEach(function(V) {\n    findIndex(T, function(X) {\n      var W = X.type, Y = X.pos;\n      return W === \"bounds\" && Y === V;\n    }) >= 0 || T.push({\n      type: \"bounds\",\n      pos: V\n    });\n  });\n}\nvar directionCondition$2 = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]), Snappable = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapDirections: [Boolean, Object],\n    elementSnapDirections: [Boolean, Object],\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function,\n    maxSnapElementGuidelineDistance: Number,\n    maxSnapElementGapDistance: Number\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [`:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`],\n  render: function(r, t) {\n    var e = r.state, o = e.top, T = e.left, S = e.pos1, N = e.pos2, D = e.pos3, B = e.pos4, $ = e.snapRenderInfo;\n    if (!$ || !hasGuidelines(r, \"\"))\n      return [];\n    e.guidelines = getTotalGuidelines(r);\n    var U = Math.min(S[0], N[0], D[0], B[0]), z = Math.min(S[1], N[1], D[1], B[1]), V = $.externalPoses || [], X = getAbsolutePosesByState(r.state), W = [], Y = [], q = [], Z = [], K = [], J = getRect(X), tt = J.width, et = J.height, Q = J.top, at = J.left, it = J.bottom, st = J.right, ut = {\n      left: at,\n      right: st,\n      top: Q,\n      bottom: it,\n      center: (at + st) / 2,\n      middle: (Q + it) / 2\n    }, ft = V.length > 0, ct = ft ? getRect(V) : {};\n    if (!$.request) {\n      if ($.direction && K.push(getSnapInfosByDirection(r, X, $.direction)), $.snap) {\n        var pt = getRect(X);\n        $.center && (pt.middle = (pt.top + pt.bottom) / 2, pt.center = (pt.left + pt.right) / 2), K.push(checkSnaps(r, pt, 1));\n      }\n      ft && ($.center && (ct.middle = (ct.top + ct.bottom) / 2, ct.center = (ct.left + ct.right) / 2), K.push(checkSnaps(r, ct, 1))), K.forEach(function(xt) {\n        var Rt = xt.vertical.posInfos, yt = xt.horizontal.posInfos;\n        W.push.apply(W, Rt.filter(function(ht) {\n          var bt = ht.guidelineInfos;\n          return bt.some(function(St) {\n            var Ot = St.guideline;\n            return !Ot.hide;\n          });\n        }).map(function(ht) {\n          return {\n            type: \"snap\",\n            pos: ht.pos\n          };\n        })), Y.push.apply(Y, yt.filter(function(ht) {\n          var bt = ht.guidelineInfos;\n          return bt.some(function(St) {\n            var Ot = St.guideline;\n            return !Ot.hide;\n          });\n        }).map(function(ht) {\n          return {\n            type: \"snap\",\n            pos: ht.pos\n          };\n        })), q.push.apply(q, getSnapGuidelines(Rt)), Z.push.apply(Z, getSnapGuidelines(yt));\n      });\n    }\n    addBoundGuidelines(r, [at, st], [Q, it], W, Y), ft && addBoundGuidelines(r, [ct.left, ct.right], [ct.top, ct.bottom], W, Y, $.externalBounds);\n    var mt = __spreadArray(__spreadArray([], q, !0), Z, !0), vt = mt.filter(function(xt) {\n      return xt.element && !xt.gapRects;\n    }), _t = mt.filter(function(xt) {\n      return xt.gapRects;\n    }).sort(function(xt, Rt) {\n      return xt.gap - Rt.gap;\n    });\n    return triggerEvent(r, \"onSnap\", {\n      guidelines: mt.filter(function(xt) {\n        var Rt = xt.element;\n        return !Rt;\n      }),\n      elements: vt,\n      gaps: _t\n    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(r, vt, [U, z], ut, t), !0), renderGapGuidelines(r, _t, [U, z], ut, t), !0), renderGuidelines(r, \"horizontal\", Z, [T, o], ut, t), !0), renderGuidelines(r, \"vertical\", q, [T, o], ut, t), !0), renderSnapPoses(r, \"horizontal\", Y, U, o, tt, 0, t), !0), renderSnapPoses(r, \"vertical\", W, z, T, et, 1, t), !0);\n  },\n  dragStart: function(r, t) {\n    r.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, snapStart(r);\n  },\n  drag: function(r) {\n    var t = r.state;\n    t.guidelines = getTotalGuidelines(r);\n  },\n  pinchStart: function(r) {\n    this.unset(r);\n  },\n  dragEnd: function(r) {\n    this.unset(r);\n  },\n  dragControlCondition: function(r, t) {\n    if (directionCondition$2(r, t) || dragControlCondition(r, t))\n      return !0;\n    if (!t.isRequest && t.inputEvent)\n      return hasClass(t.inputEvent.target, prefix(\"snap-control\"));\n  },\n  dragControlStart: function(r) {\n    r.state.snapRenderInfo = null, snapStart(r);\n  },\n  dragControl: function(r) {\n    this.drag(r);\n  },\n  dragControlEnd: function(r) {\n    this.unset(r);\n  },\n  dragGroupStart: function(r, t) {\n    this.dragStart(r, t);\n  },\n  dragGroup: function(r) {\n    this.drag(r);\n  },\n  dragGroupEnd: function(r) {\n    this.unset(r);\n  },\n  dragGroupControlStart: function(r) {\n    r.state.snapRenderInfo = null, snapStart(r);\n  },\n  dragGroupControl: function(r) {\n    this.drag(r);\n  },\n  dragGroupControlEnd: function(r) {\n    this.unset(r);\n  },\n  unset: function(r) {\n    var t = r.state;\n    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];\n  }\n};\nfunction renderDirectionControlsByInfos(r, t, e, o) {\n  var T = r.state, S = T.renderPoses, N = T.rotation, D = T.direction, B = getProps(r.props, t).zoom, $ = D > 0 ? 1 : -1, U = N / Math.PI * 180, z = {}, V = r.renderState;\n  V.renderDirectionMap || (V.renderDirectionMap = {});\n  var X = V.renderDirectionMap;\n  return e.forEach(function(W) {\n    var Y = W.dir;\n    z[Y] = !0;\n  }), e.map(function(W) {\n    var Y = W.data, q = W.classNames, Z = W.dir, K = DIRECTION_INDEXES[Z];\n    if (!K || !z[Z])\n      return null;\n    X[Z] = !0;\n    var J = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[Z] + 720) % 180, tt = {};\n    return getKeys(Y).forEach(function(et) {\n      tt[\"data-\".concat(et)] = Y[et];\n    }), o.createElement(\"div\", __assign$2({\n      className: prefix.apply(void 0, __spreadArray([\"control\", \"direction\", Z, t], q, !1)),\n      \"data-rotation\": J,\n      \"data-direction\": Z\n    }, tt, {\n      key: \"direction-\".concat(Z),\n      style: getControlTransform.apply(void 0, __spreadArray([N, B], K.map(function(et) {\n        return S[et];\n      }), !1))\n    }));\n  });\n}\nfunction renderDirectionControls(r, t, e, o) {\n  var T = getProps(r.props, e).renderDirections, S = T === void 0 ? t : T;\n  if (!S)\n    return [];\n  var N = S === !0 ? DIRECTIONS : S;\n  return renderDirectionControlsByInfos(r, e, N.map(function(D) {\n    return {\n      data: {},\n      classNames: [],\n      dir: D\n    };\n  }), o);\n}\nfunction renderAroundControls(r, t) {\n  var e = r.renderState;\n  e.renderDirectionMap || (e.renderDirectionMap = {});\n  var o = r.state, T = o.renderPoses, S = o.rotation, N = o.direction, D = e.renderDirectionMap, B = r.props.zoom, $ = N > 0 ? 1 : -1, U = S / Math.PI * 180;\n  return getKeys(D).map(function(z) {\n    var V = DIRECTION_INDEXES[z];\n    if (!V)\n      return null;\n    var X = (throttle(U, 15) + $ * DIRECTION_ROTATIONS[z] + 720) % 180;\n    return t.createElement(\"div\", {\n      className: prefix(\"around-control\"),\n      \"data-rotation\": X,\n      \"data-direction\": z,\n      key: \"direction-around-\".concat(z),\n      style: getControlTransform.apply(void 0, __spreadArray([S, B], V.map(function(W) {\n        return T[W];\n      }), !1))\n    });\n  });\n}\nfunction renderLine(r, t, e, o, T, S) {\n  for (var N = [], D = 6; D < arguments.length; D++)\n    N[D - 6] = arguments[D];\n  var B = getRad$1(e, o), $ = t ? throttle(B / Math.PI * 180, 15) % 180 : -1;\n  return r.createElement(\"div\", {\n    key: \"line-\".concat(S),\n    className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", t ? \"edge\" : \"\", t], N, !1)),\n    \"data-rotation\": $,\n    \"data-line-key\": S,\n    \"data-direction\": t,\n    style: getLineStyle(e, o, T, B)\n  });\n}\nfunction renderEdgeLines(r, t, e, o, T) {\n  var S = e === !0 ? DIRECTIONS4 : e;\n  return S.map(function(N, D) {\n    var B = DIRECTION_INDEXES[N], $ = B[0], U = B[1];\n    if (U != null)\n      return renderLine(r, N, o[$], o[U], T, \"\".concat(t, \"Edge\").concat(D), t);\n  }).filter(Boolean);\n}\nfunction getRenderDirections(r) {\n  return function(t, e) {\n    var o = getProps(t.props, r).edge;\n    return o && (o === !0 || o.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, r, o, t.state.renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, r, e), !0) : renderAllDirections(t, r, e);\n  };\n}\nfunction renderAllDirections(r, t, e) {\n  return renderDirectionControls(r, DIRECTIONS, t, e);\n}\nfunction renderDiagonalDirections(r, t, e) {\n  return renderDirectionControls(r, [\"nw\", \"ne\", \"sw\", \"se\"], t, e);\n}\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  render: function(r, t) {\n    var e = r.props, o = e.throttleDragRotate, T = e.zoom, S = r.state, N = S.dragInfo, D = S.beforeOrigin;\n    if (!o || !N)\n      return [];\n    var B = N.dist;\n    if (!B[0] && !B[1])\n      return [];\n    var $ = getDistSize(B), U = getRad$1(B, [0, 0]);\n    return [t.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat($, \"px\"),\n        transform: \"translate(\".concat(D[0], \"px, \").concat(D[1], \"px) rotate(\").concat(U, \"rad) scaleY(\").concat(T, \")\")\n      }\n    })];\n  },\n  dragStart: function(r, t) {\n    var e = t.datas, o = t.parentEvent, T = t.parentGesto, S = r.state, N = S.target, D = S.gestos;\n    if (D.draggable)\n      return !1;\n    D.draggable = T || r.targetGesto;\n    var B = getComputedStyle$1$1(N);\n    e.datas = {}, e.left = parseFloat(B.left || \"\") || 0, e.top = parseFloat(B.top || \"\") || 0, e.bottom = parseFloat(B.bottom || \"\") || 0, e.right = parseFloat(B.right || \"\") || 0, e.startValue = [0, 0], setDragStart(r, t), setDefaultTransformIndex(t, \"translate\"), startCheckSnapDrag(r, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];\n    var $ = fillParams(r, t, __assign$2({\n      set: function(z) {\n        e.startValue = z;\n      }\n    }, fillTransformStartEvent(t))), U = o || triggerEvent(r, \"onDragStart\", $);\n    return U !== !1 ? (e.isDrag = !0, r.state.dragInfo = {\n      startRect: r.getRect(),\n      dist: [0, 0]\n    }) : (D.draggable = null, e.isPinch = !1), e.isDrag ? $ : !1;\n  },\n  drag: function(r, t) {\n    if (!!t) {\n      resolveTransformEvent(t, \"translate\");\n      var e = t.datas, o = t.parentEvent, T = t.parentFlag, S = t.isPinch, N = t.isRequest, D = t.deltaOffset, B = t.distX, $ = t.distY, U = e.isDrag, z = e.prevDist, V = e.prevBeforeDist, X = e.startValue;\n      if (!!U) {\n        D && (B += D[0], $ += D[1]);\n        var W = r.props, Y = W.parentMoveable, q = o ? 0 : W.throttleDrag || 0, Z = o ? 0 : W.throttleDragRotate || 0, K = !1, J = 0;\n        if (!o && Z > 0 && (B || $)) {\n          var tt = W.startDragRotate || 0, et = throttle(tt + getRad$1([0, 0], [B, $]) * 180 / Math.PI, Z) - tt, Q = $ * Math.abs(Math.cos((et - 90) / 180 * Math.PI)), at = B * Math.abs(Math.cos(et / 180 * Math.PI)), it = getDistSize([at, Q]);\n          J = et * Math.PI / 180, B = it * Math.cos(J), $ = it * Math.sin(J);\n        }\n        if (!S && !o && !T && (!Z || B || $)) {\n          var st = checkSnapBoundsDrag(r, B, $, Z, N || D, e), ut = st[0], ft = st[1], ct = ut.isSnap, pt = ut.isBound, mt = ut.offset, vt = ft.isSnap, _t = ft.isBound, xt = ft.offset;\n          K = ct || vt || pt || _t, B += mt, $ += xt;\n        }\n        var Rt = plus(getBeforeDragDist({\n          datas: e,\n          distX: B,\n          distY: $\n        }), X), yt = plus(getTransformDist({\n          datas: e,\n          distX: B,\n          distY: $\n        }), X);\n        !Z && !K && (throttleArray(yt, q), throttleArray(Rt, q)), throttleArray(yt, TINY_NUM), throttleArray(Rt, TINY_NUM);\n        var ht = minus(Rt, X), bt = minus(yt, X), St = minus(bt, z), Ot = minus(ht, V);\n        e.prevDist = bt, e.prevBeforeDist = ht, e.passDelta = St, e.passDist = bt;\n        var wt = e.left + ht[0], Ft = e.top + ht[1], dt = e.right - ht[0], Gt = e.bottom - ht[1], Mt = convertTransformFormat(e, \"translate(\".concat(yt[0], \"px, \").concat(yt[1], \"px)\"), \"translate(\".concat(bt[0], \"px, \").concat(bt[1], \"px)\"));\n        if (fillOriginalTransform(t, Mt), r.state.dragInfo.dist = o ? [0, 0] : bt, !(!o && !Y && St.every(function(It) {\n          return !It;\n        }) && Ot.some(function(It) {\n          return !It;\n        }))) {\n          var Bt = r.state, Dt = Bt.width, Et = Bt.height, zt = fillParams(r, t, __assign$2({\n            transform: Mt,\n            dist: bt,\n            delta: St,\n            translate: yt,\n            beforeDist: ht,\n            beforeDelta: Ot,\n            beforeTranslate: Rt,\n            left: wt,\n            top: Ft,\n            right: dt,\n            bottom: Gt,\n            width: Dt,\n            height: Et,\n            isPinch: S\n          }, fillCSSObject({\n            transform: Mt\n          }, t)));\n          return !o && triggerEvent(r, \"onDrag\", zt), zt;\n        }\n      }\n    }\n  },\n  dragAfter: function(r, t) {\n    var e = t.datas, o = e.deltaOffset;\n    return o[0] || o[1] ? (e.deltaOffset = [0, 0], this.drag(r, __assign$2(__assign$2({}, t), {\n      deltaOffset: o\n    }))) : !1;\n  },\n  dragEnd: function(r, t) {\n    var e = t.parentEvent, o = t.datas;\n    if (r.state.dragInfo = null, !!o.isDrag) {\n      o.isDrag = !1;\n      var T = fillEndParams(r, t, {});\n      return !e && triggerEvent(r, \"onDragEnd\", T), T;\n    }\n  },\n  dragGroupStart: function(r, t) {\n    var e = t.datas, o = t.clientX, T = t.clientY, S = this.dragStart(r, t);\n    if (!S)\n      return !1;\n    var N = triggerChildGesto(r, this, \"dragStart\", [o || 0, T || 0], t, !1, \"draggable\"), D = __assign$2(__assign$2({}, S), {\n      targets: r.props.targets,\n      events: N\n    }), B = triggerEvent(r, \"onDragGroupStart\", D);\n    return e.isDrag = B !== !1, e.isDrag ? S : !1;\n  },\n  dragGroup: function(r, t) {\n    var e = t.datas;\n    if (!!e.isDrag) {\n      var o = this.drag(r, t), T = t.datas.passDelta, S = triggerChildGesto(r, this, \"drag\", T, t, !1, \"draggable\");\n      if (!!o) {\n        var N = __assign$2({\n          targets: r.props.targets,\n          events: S\n        }, o);\n        return triggerEvent(r, \"onDragGroup\", N), N;\n      }\n    }\n  },\n  dragGroupEnd: function(r, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isDrag) {\n      this.dragEnd(r, t);\n      var T = triggerChildGesto(r, this, \"dragEnd\", [0, 0], t, !1, \"draggable\");\n      return triggerEvent(r, \"onDragGroupEnd\", fillEndParams(r, t, {\n        targets: r.props.targets,\n        events: T\n      })), e;\n    }\n  },\n  request: function(r) {\n    var t = {}, e = r.getRect(), o = 0, T = 0;\n    return {\n      isControl: !1,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(S) {\n        return \"x\" in S ? o = S.x - e.left : \"deltaX\" in S && (o += S.deltaX), \"y\" in S ? T = S.y - e.top : \"deltaY\" in S && (T += S.deltaY), {\n          datas: t,\n          distX: o,\n          distY: T\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(r) {\n    r.state.gestos.draggable = null, r.state.dragInfo = null;\n  }\n}, directionCondition$1 = getDirectionCondition(\"resizable\"), Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean,\n    resizeFormat: Function,\n    keepRatioFinally: Boolean,\n    edge: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onBeforeResize: \"beforeResize\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onBeforeResizeGroup: \"beforeResizeGroup\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: getRenderDirections(\"resizable\"),\n  dragControlCondition: directionCondition$1,\n  dragControlStart: function(r, t) {\n    var e, o = t.inputEvent, T = t.isPinch, S = t.isGroup, N = t.parentDirection, D = t.parentGesto, B = t.datas, $ = t.parentFixedDirection, U = t.parentEvent, z = N || (T ? [0, 0] : getDirection(o.target)), V = r.state, X = V.target, W = V.width, Y = V.height, q = V.gestos;\n    if (!z || !X || q.resizable)\n      return !1;\n    q.resizable = D || r.controlGesto, !T && setDragStart(r, t), B.datas = {}, B.direction = z, B.startOffsetWidth = W, B.startOffsetHeight = Y, B.prevWidth = 0, B.prevHeight = 0, B.minSize = [0, 0], B.startWidth = V.cssWidth, B.startHeight = V.cssHeight, B.maxSize = [1 / 0, 1 / 0], S || (B.minSize = [V.minOffsetWidth, V.minOffsetHeight], B.maxSize = [V.maxOffsetWidth, V.maxOffsetHeight]);\n    var Z = r.props.transformOrigin || \"% %\";\n    B.transformOrigin = Z && isString$1(Z) ? Z.split(\" \") : Z, B.startOffsetMatrix = V.offsetMatrix, B.startTransformOrigin = V.transformOrigin, B.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !z[0] && !z[1] || z[0] || !z[1];\n    function K(it) {\n      B.ratio = it && isFinite(it) ? it : 0;\n    }\n    B.startPositions = getAbsolutePosesByState(r.state);\n    function J(it) {\n      B.fixedDirection = it, B.fixedPosition = getPosByDirection(B.startPositions, it);\n    }\n    function tt(it) {\n      B.minSize = [convertUnitSize(\"\".concat(it[0]), 0) || 0, convertUnitSize(\"\".concat(it[1]), 0) || 0];\n    }\n    function et(it) {\n      var st = [it[0] || 1 / 0, it[1] || 1 / 0];\n      (!isNumber(st[0]) || isFinite(st[0])) && (st[0] = convertUnitSize(\"\".concat(st[0]), 0) || 1 / 0), (!isNumber(st[1]) || isFinite(st[1])) && (st[1] = convertUnitSize(\"\".concat(st[1]), 0) || 1 / 0), B.maxSize = st;\n    }\n    K(W / Y), J($ || [-z[0], -z[1]]), B.setFixedDirection = J, B.setMin = tt, B.setMax = et;\n    var Q = fillParams(r, t, {\n      direction: z,\n      startRatio: B.ratio,\n      set: function(it) {\n        var st = it[0], ut = it[1];\n        B.startWidth = st, B.startHeight = ut;\n      },\n      setMin: tt,\n      setMax: et,\n      setRatio: K,\n      setFixedDirection: J,\n      setOrigin: function(it) {\n        B.transformOrigin = it;\n      },\n      dragStart: Draggable.dragStart(r, new CustomGesto().dragStart([0, 0], t))\n    }), at = U || triggerEvent(r, \"onResizeStart\", Q);\n    return B.startFixedDirection = B.fixedDirection, at !== !1 && (B.isResize = !0, r.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: z\n    }), B.isResize ? Q : !1;\n  },\n  dragControl: function(r, t) {\n    var e, o = t.datas, T = t.parentFlag, S = t.isPinch, N = t.parentKeepRatio, D = t.dragClient, B = t.parentDist, $ = t.isRequest, U = t.isGroup, z = t.parentEvent, V = t.resolveMatrix, X = o.isResize, W = o.transformOrigin, Y = o.startWidth, q = o.startHeight, Z = o.prevWidth, K = o.prevHeight, J = o.minSize, tt = o.maxSize, et = o.ratio, Q = o.startOffsetWidth, at = o.startOffsetHeight, it = o.isWidth;\n    if (!X)\n      return;\n    if (V) {\n      var st = r.state.is3d, ut = o.startOffsetMatrix, ft = o.startTransformOrigin, ct = st ? 4 : 3, pt = parseMat(getNextTransforms(t)), mt = Math.sqrt(pt.length);\n      ct !== mt && (pt = convertDimension(pt, mt, ct));\n      var vt = getNextMatrix(ut, pt, ft, ct), _t = calculatePoses(vt, Q, at, ct);\n      o.startPositions = _t, o.nextTargetMatrix = pt, o.nextAllMatrix = vt;\n    }\n    var xt = getProps(r.props, \"resizable\"), Rt = xt.resizeFormat, yt = xt.throttleResize, ht = yt === void 0 ? T ? 0 : 1 : yt, bt = xt.parentMoveable, St = xt.keepRatioFinally, Ot = o.direction, wt = Ot, Ft = 0, dt = 0;\n    !Ot[0] && !Ot[1] && (wt = [1, 1]);\n    var Gt = et && (N != null ? N : xt.keepRatio) || !1;\n    function Mt() {\n      var ne = o.fixedDirection, Me = getOffsetSizeDist(wt, Gt, o, t);\n      Ft = Me.distWidth, dt = Me.distHeight;\n      var ye = wt[0] - ne[0] || Gt ? Math.max(Q + Ft, TINY_NUM) : Q, de = wt[1] - ne[1] || Gt ? Math.max(at + dt, TINY_NUM) : at;\n      return Gt && Q && at && (it ? de = ye / et : ye = de * et), [ye, de];\n    }\n    var Bt = Mt(), Dt = Bt[0], Et = Bt[1];\n    z || (o.setFixedDirection(o.fixedDirection), triggerEvent(r, \"onBeforeResize\", fillParams(r, t, {\n      startFixedDirection: o.startFixedDirection,\n      setFixedDirection: function(ne) {\n        var Me;\n        return o.setFixedDirection(ne), Me = Mt(), Dt = Me[0], Et = Me[1], [Dt, Et];\n      },\n      boundingWidth: Dt,\n      boundingHeight: Et,\n      setSize: function(ne) {\n        Dt = ne[0], Et = ne[1];\n      }\n    }, !0)));\n    var zt = D;\n    D || (!T && S ? zt = getAbsolutePosition(r, [0, 0]) : zt = o.fixedPosition);\n    var It = [0, 0];\n    S || (It = checkSnapResize(r, Dt, Et, Ot, zt, $, o)), B && (!B[0] && (It[0] = 0), !B[1] && (It[1] = 0));\n    function Ct() {\n      var ne;\n      Rt && (ne = Rt([Dt, Et]), Dt = ne[0], Et = ne[1]), Dt = throttle(Dt, ht), Et = throttle(Et, ht);\n    }\n    if (Gt) {\n      wt[0] && wt[1] && It[0] && It[1] && (Math.abs(It[0]) > Math.abs(It[1]) ? It[1] = 0 : It[0] = 0);\n      var Lt = !It[0] && !It[1];\n      Lt && Ct(), wt[0] && !wt[1] || It[0] && !It[1] || Lt && it ? (Dt += It[0], Et = Dt / et) : (!wt[0] && wt[1] || !It[0] && It[1] || Lt && !it) && (Et += It[1], Dt = Et * et);\n    } else\n      Dt += It[0], Et += It[1], Dt = Math.max(0, Dt), Et = Math.max(0, Et);\n    e = calculateBoundSize([Dt, Et], J, tt, Gt ? et : !1), Dt = e[0], Et = e[1], Ct(), Gt && (U || St) && (it ? Et = Dt / et : Dt = Et * et), Ft = Dt - Q, dt = Et - at;\n    var $t = [Ft - Z, dt - K];\n    o.prevWidth = Ft, o.prevHeight = dt;\n    var At = getResizeDist(r, Dt, Et, zt, W, o);\n    if (!(!bt && $t.every(function(ne) {\n      return !ne;\n    }) && At.every(function(ne) {\n      return !ne;\n    }))) {\n      var ee = Draggable.drag(r, setCustomDrag(t, r.state, At, !!S, !1, \"draggable\")), te = ee.transform, he = Y + Ft, we = q + dt, Be = fillParams(r, t, __assign$2({\n        width: he,\n        height: we,\n        offsetWidth: Math.round(Dt),\n        offsetHeight: Math.round(Et),\n        startRatio: et,\n        boundingWidth: Dt,\n        boundingHeight: Et,\n        direction: Ot,\n        dist: [Ft, dt],\n        delta: $t,\n        isPinch: !!S,\n        drag: ee\n      }, fillAfterTransform({\n        style: {\n          width: \"\".concat(he, \"px\"),\n          height: \"\".concat(we, \"px\")\n        },\n        transform: te\n      }, ee, t)));\n      return !z && triggerEvent(r, \"onResize\", Be), Be;\n    }\n  },\n  dragControlAfter: function(r, t) {\n    var e = t.datas, o = e.isResize, T = e.startOffsetWidth, S = e.startOffsetHeight, N = e.prevWidth, D = e.prevHeight;\n    if (!!o) {\n      var B = r.state, $ = B.width, U = B.height, z = $ - (T + N), V = U - (S + D), X = Math.abs(z) > 3, W = Math.abs(V) > 3;\n      if (X && (e.startWidth += z, e.startOffsetWidth += z, e.prevWidth += z), W && (e.startHeight += V, e.startOffsetHeight += V, e.prevHeight += V), X || W)\n        return this.dragControl(r, t);\n    }\n  },\n  dragControlEnd: function(r, t) {\n    var e = t.datas, o = t.parentEvent;\n    if (!!e.isResize) {\n      e.isResize = !1;\n      var T = fillEndParams(r, t, {});\n      return !o && triggerEvent(r, \"onResizeEnd\", T), T;\n    }\n  },\n  dragGroupControlCondition: directionCondition$1,\n  dragGroupControlStart: function(r, t) {\n    var e = t.datas, o = this.dragControlStart(r, __assign$2(__assign$2({}, t), {\n      isGroup: !0\n    }));\n    if (!o)\n      return !1;\n    var T = fillChildEvents(r, \"resizable\", t);\n    function S(W, Y) {\n      var q = e.fixedDirection, Z = e.fixedPosition, K = Y.datas.startPositions || getAbsolutePosesByState(W.state), J = getPosByDirection(K, q), tt = calculate(createRotateMatrix(-r.rotation / 180 * Math.PI, 3), [J[0] - Z[0], J[1] - Z[1], 1], 3), et = tt[0], Q = tt[1];\n      return Y.datas.originalX = et, Y.datas.originalY = Q, Y;\n    }\n    var N = e.startOffsetWidth, D = e.startOffsetHeight;\n    function B() {\n      var W = e.minSize;\n      T.forEach(function(Y) {\n        var q = Y.datas, Z = q.minSize, K = q.startOffsetWidth, J = q.startOffsetHeight, tt = N * (K ? Z[0] / K : 0), et = D * (J ? Z[1] / J : 0);\n        W[0] = Math.max(W[0], tt), W[1] = Math.max(W[1], et);\n      });\n    }\n    function $() {\n      var W = e.maxSize;\n      T.forEach(function(Y) {\n        var q = Y.datas, Z = q.maxSize, K = q.startOffsetWidth, J = q.startOffsetHeight, tt = N * (K ? Z[0] / K : 0), et = D * (J ? Z[1] / J : 0);\n        W[0] = Math.min(W[0], tt), W[1] = Math.min(W[1], et);\n      });\n    }\n    var U = triggerChildAbles(r, this, \"dragControlStart\", t, function(W, Y) {\n      return S(W, Y);\n    });\n    B(), $();\n    var z = function(W) {\n      o.setFixedDirection(W), U.forEach(function(Y, q) {\n        Y.setFixedDirection(W), S(Y.moveable, T[q]);\n      });\n    };\n    e.setFixedDirection = z;\n    var V = __assign$2(__assign$2({}, o), {\n      targets: r.props.targets,\n      events: U.map(function(W) {\n        return __assign$2(__assign$2({}, W), {\n          setMin: function(Y) {\n            W.setMin(Y), B();\n          },\n          setMax: function(Y) {\n            W.setMax(Y), $();\n          }\n        });\n      }),\n      setFixedDirection: z,\n      setMin: function(W) {\n        o.setMin(W), B();\n      },\n      setMax: function(W) {\n        o.setMax(W), $();\n      }\n    }), X = triggerEvent(r, \"onResizeGroupStart\", V);\n    return e.isResize = X !== !1, e.isResize ? o : !1;\n  },\n  dragGroupControl: function(r, t) {\n    var e = t.datas;\n    if (!!e.isResize) {\n      var o = getProps(r.props, \"resizable\");\n      catchEvent(r, \"onBeforeResize\", function(X) {\n        triggerEvent(r, \"onBeforeResizeGroup\", fillParams(r, t, __assign$2(__assign$2({}, X), {\n          targets: o.targets\n        }), !0));\n      });\n      var T = this.dragControl(r, __assign$2(__assign$2({}, t), {\n        isGroup: !0\n      }));\n      if (!!T) {\n        var S = T.boundingWidth, N = T.boundingHeight, D = T.dist, B = o.keepRatio, $ = [S / (S - D[0]), N / (N - D[1])], U = e.fixedPosition, z = triggerChildAbles(r, this, \"dragControl\", t, function(X, W) {\n          var Y = calculate(createRotateMatrix(r.rotation / 180 * Math.PI, 3), [W.datas.originalX * $[0], W.datas.originalY * $[1], 1], 3), q = Y[0], Z = Y[1];\n          return __assign$2(__assign$2({}, W), {\n            parentDist: null,\n            parentScale: $,\n            dragClient: plus(U, [q, Z]),\n            parentKeepRatio: B\n          });\n        }), V = __assign$2({\n          targets: o.targets,\n          events: z\n        }, T);\n        return triggerEvent(r, \"onResizeGroup\", V), V;\n      }\n    }\n  },\n  dragGroupControlEnd: function(r, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isResize) {\n      this.dragControlEnd(r, t);\n      var T = triggerChildAbles(r, this, \"dragControlEnd\", t), S = fillEndParams(r, t, {\n        targets: r.props.targets,\n        events: T\n      });\n      return triggerEvent(r, \"onResizeGroupEnd\", S), e;\n    }\n  },\n  request: function(r) {\n    var t = {}, e = 0, o = 0, T = r.getRect();\n    return {\n      isControl: !0,\n      requestStart: function(S) {\n        var N;\n        return {\n          datas: t,\n          parentDirection: S.direction || [1, 1],\n          parentIsWidth: (N = S == null ? void 0 : S.horizontal) !== null && N !== void 0 ? N : !0\n        };\n      },\n      request: function(S) {\n        return \"offsetWidth\" in S ? e = S.offsetWidth - T.offsetWidth : \"deltaWidth\" in S && (e += S.deltaWidth), \"offsetHeight\" in S ? o = S.offsetHeight - T.offsetHeight : \"deltaHeight\" in S && (o += S.deltaHeight), {\n          datas: t,\n          parentDist: [e, o],\n          parentKeepRatio: S.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(r) {\n    r.state.gestos.resizable = null;\n  }\n};\nfunction setRotateStartInfo(r, t, e, o, T) {\n  var S = r.props.groupable, N = r.state, D = N.is3d ? 4 : 3, B = t.origin, $ = calculatePosition(\n    r.state.rootMatrix,\n    minus([B[0], B[1]], S ? [0, 0] : [N.left, N.top]),\n    D\n  ), U = plus([T.left, T.top], $);\n  t.startAbsoluteOrigin = U, t.prevDeg = getRad$1(U, [e, o]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2(U, [e, o]);\n}\nfunction getAbsoluteDist(r, t, e) {\n  var o = e.defaultDeg, T = e.prevDeg, S = T % 360, N = Math.floor(T / 360);\n  S < 0 && (S += 360), S > r && S > 270 && r < 90 ? ++N : S < r && S < 90 && r > 270 && --N;\n  var D = t * (N * 360 + r - o);\n  return e.prevDeg = o + D, D;\n}\nfunction getAbsoluteDistByClient(r, t, e, o) {\n  return getAbsoluteDist(getRad$1(o.startAbsoluteOrigin, [r, t]) / Math.PI * 180, e, o);\n}\nfunction getRotateInfo(r, t, e, o, T, S) {\n  var N = r.props.throttleRotate, D = N === void 0 ? 0 : N, B = e.prevSnapDeg, $ = 0, U = !1;\n  if (S) {\n    var z = checkSnapRotate(r, t, o);\n    U = z.isSnap, $ = T + z.rotation;\n  }\n  U || ($ = throttle(T + o, D));\n  var V = $ - T;\n  return e.prevSnapDeg = V, [V - B, V, $];\n}\nfunction getRotationPositions(r, t, e) {\n  var o = t[0], T = t[1], S = t[2], N = t[3];\n  if (r !== \"none\") {\n    var D = (r || \"top\").split(\"-\"), B = D[0], $ = D[1], U = [o, T];\n    B === \"left\" ? U = [S, o] : B === \"right\" ? U = [T, N] : B === \"bottom\" && (U = [N, S]);\n    var z = [(U[0][0] + U[1][0]) / 2, (U[0][1] + U[1][1]) / 2], V = getRotationRad(U, e);\n    if ($) {\n      var X = $ === \"top\" || $ === \"left\", W = B === \"bottom\" || B === \"left\";\n      z = U[X && !W || !X && W ? 0 : 1];\n    }\n    return [z, V];\n  }\n}\nfunction dragControlCondition(r, t) {\n  if (t.isRequest)\n    return t.requestAble === \"rotatable\";\n  var e = t.inputEvent.target;\n  if (hasClass(e, prefix(\"rotation-control\")) || hasClass(e, prefix(\"around-control\")) || hasClass(e, prefix(\"control\")) && hasClass(e, prefix(\"rotatable\")))\n    return !0;\n  var o = r.props.rotationTarget;\n  return o ? getRefTargets(o, !0).some(function(T) {\n    return T ? e === T || e.contains(T) : !1;\n  }) : !1;\n}\nvar directionCSS = DIRECTIONS.map(function(r) {\n  var t = \"\", e = \"\", o = \"center\", T = \"center\";\n  return r.indexOf(\"n\") > -1 && (t = \"top: -20px;\", T = \"bottom\"), r.indexOf(\"s\") > -1 && (t = \"top: 0px;\", T = \"top\"), r.indexOf(\"w\") > -1 && (e = \"left: -20px;\", o = \"right\"), r.indexOf(\"e\") > -1 && (e = \"left: 0px;\", o = \"left\"), '.around-control[data-direction*=\"'.concat(r, `\"] {\n        `).concat(e).concat(t, `\n        transform-origin: `).concat(o, \" \").concat(T, `;\n    }`);\n}).join(`\n`), css = `.rotation {\n    position: absolute;\n    height: 40px;\n    width: 1px;\n    transform-origin: 50% 100%;\n    height: calc(40px * var(--zoom));\n    top: auto;\n    left: 0;\n    bottom: 100%;\n    will-change: transform;\n}\n.rotation .rotation-line {\n    display: block;\n    width: 100%;\n    height: 100%;\n    transform-origin: 50% 50%;\n}\n.rotation .rotation-control {\n    border-color: #4af;\n    border-color: var(--moveable-color);\n    background:#fff;\n    cursor: alias;\n}\n.rotatable.direction.control {\n    cursor: alias;\n}\n.around-control {\n    position: absolute;\n    will-change: transform;\n    width: 20px;\n    height: 20px;\n    left: -10px;\n    top: -10px;\n    box-sizing: border-box;\n    background: transparent;\n    z-index: 8;\n    cursor: alias;\n    transform-origin: center center;\n}\n.rotatable.direction.control.move {\n    cursor: move;\n}\n`.concat(directionCSS, `\n`), Rotatable = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object,\n    rotateAroundControls: Boolean,\n    edge: Boolean,\n    resolveAblesWithRotatable: Object\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onBeforeRotate: \"beforeRotate\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onBeforeRotateGroup: \"beforeRotateGroup\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [css],\n  render: function(r, t) {\n    var e = getProps(r.props, \"rotatable\"), o = e.rotatable, T = e.rotationPosition, S = e.zoom, N = e.renderDirections, D = e.rotateAroundControls, B = e.resolveAblesWithRotatable, $ = r.state, U = $.renderPoses, z = $.direction;\n    if (!o)\n      return null;\n    var V = getRotationPositions(T, U, z), X = [];\n    if (V) {\n      var W = V[0], Y = V[1];\n      X.push(t.createElement(\"div\", {\n        key: \"rotation\",\n        className: prefix(\"rotation\"),\n        style: {\n          transform: \"translate(-50%) translate(\".concat(W[0], \"px, \").concat(W[1], \"px) rotate(\").concat(Y, \"rad)\")\n        }\n      }, t.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(S, \")\")\n        }\n      }), t.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(S, \")\")\n        }\n      })));\n    }\n    if (N) {\n      var q = getKeys(B || {}), Z = {};\n      q.forEach(function(J) {\n        B[J].forEach(function(tt) {\n          Z[tt] = J;\n        });\n      });\n      var K = [];\n      isArray(N) && (K = N.map(function(J) {\n        var tt = Z[J];\n        return {\n          data: tt ? {\n            resolve: tt\n          } : {},\n          classNames: tt ? [\"move\"] : [],\n          dir: J\n        };\n      })), X.push.apply(X, renderDirectionControlsByInfos(r, \"rotatable\", K, t));\n    }\n    return D && X.push.apply(X, renderAroundControls(r, t)), X;\n  },\n  dragControlCondition,\n  dragControlStart: function(r, t) {\n    var e, o, T = t.datas, S = t.clientX, N = t.clientY, D = t.parentRotate, B = t.parentFlag, $ = t.isPinch, U = t.isRequest, z = r.state, V = z.target, X = z.left, W = z.top, Y = z.direction, q = z.beforeDirection, Z = z.targetTransform, K = z.moveableClientRect, J = z.offsetMatrix, tt = z.targetMatrix, et = z.allMatrix, Q = z.width, at = z.height;\n    if (!U && !V)\n      return !1;\n    var it = r.getRect();\n    T.rect = it, T.transform = Z, T.left = X, T.top = W;\n    var st = function(wt) {\n      T.fixedDirection = wt, T.fixedPosition = getDirectionOffset(r, wt), ht && ht.setFixedDirection(wt);\n    }, ut = S, ft = N;\n    if (U || $ || B) {\n      var ct = D || 0;\n      T.beforeInfo = {\n        origin: it.beforeOrigin,\n        prevDeg: ct,\n        defaultDeg: ct,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, T.afterInfo = __assign$2(__assign$2({}, T.beforeInfo), {\n        origin: it.origin\n      }), T.absoluteInfo = __assign$2(__assign$2({}, T.beforeInfo), {\n        origin: it.origin,\n        startValue: ct\n      });\n    } else {\n      var pt = (o = t.inputEvent) === null || o === void 0 ? void 0 : o.target;\n      if (pt) {\n        var mt = pt.getAttribute(\"data-direction\") || \"\", vt = DIRECTION_REGION_TO_DIRECTION[mt];\n        if (vt) {\n          T.isControl = !0, T.isAroundControl = hasClass(pt, prefix(\"around-control\")), T.controlDirection = vt;\n          var _t = pt.getAttribute(\"data-resolve\");\n          _t && (T.resolveAble = _t);\n          var xt = calculateMoveableClientPositions(z.rootMatrix, z.renderPoses, K);\n          e = getPosByDirection(xt, vt), ut = e[0], ft = e[1];\n        }\n      }\n      T.beforeInfo = {\n        origin: it.beforeOrigin\n      }, T.afterInfo = {\n        origin: it.origin\n      }, T.absoluteInfo = {\n        origin: it.origin,\n        startValue: it.rotation\n      };\n      var Rt = st;\n      st = function(wt) {\n        var Ft = z.is3d ? 4 : 3, dt = getPosByDirection([[0, 0], [Q, 0], [0, at], [Q, at]], wt), Gt = plus(getOrigin(tt, Ft), dt), Mt = Gt[0], Bt = Gt[1], Dt = calculate(J, convertPositionMatrix([Mt, Bt], Ft)), Et = calculate(et, convertPositionMatrix([dt[0], dt[1]], Ft));\n        Rt(wt), T.beforeInfo.origin = Dt, T.afterInfo.origin = Et, T.absoluteInfo.origin = Et, setRotateStartInfo(r, T.beforeInfo, ut, ft, K), setRotateStartInfo(r, T.afterInfo, ut, ft, K), setRotateStartInfo(r, T.absoluteInfo, ut, ft, K);\n      };\n    }\n    T.startClientX = ut, T.startClientY = ft, T.direction = Y, T.beforeDirection = q, T.startValue = 0, T.datas = {}, setDefaultTransformIndex(t, \"rotate\");\n    var yt = !1, ht = !1;\n    if (T.isControl && T.resolveAble) {\n      var bt = T.resolveAble;\n      bt === \"resizable\" && (ht = Resizable.dragControlStart(r, __assign$2(__assign$2({}, new CustomGesto(\"resizable\").dragStart([0, 0], t)), {\n        parentDirection: T.controlDirection,\n        parentFixedDirection: T.fixedDirection\n      })));\n    }\n    ht || (yt = Draggable.dragStart(r, new CustomGesto().dragStart([0, 0], t))), st(getOriginDirection(r));\n    var St = fillParams(r, t, __assign$2(__assign$2({\n      set: function(wt) {\n        T.startValue = wt * Math.PI / 180;\n      },\n      setFixedDirection: st\n    }, fillTransformStartEvent(t)), {\n      dragStart: yt,\n      resizeStart: ht\n    })), Ot = triggerEvent(r, \"onRotateStart\", St);\n    return T.isRotate = Ot !== !1, z.snapRenderInfo = {\n      request: t.isRequest\n    }, T.isRotate ? St : !1;\n  },\n  dragControl: function(r, t) {\n    var e, o, T, S = t.datas, N = t.distX, D = t.distY, B = t.parentRotate, $ = t.parentFlag, U = t.isPinch, z = t.groupDelta, V = S.beforeDirection, X = S.beforeInfo, W = S.afterInfo, Y = S.absoluteInfo, q = S.isRotate, Z = S.startValue, K = S.rect, J = S.startClientX, tt = S.startClientY;\n    if (!!q) {\n      resolveTransformEvent(t, \"rotate\");\n      var et = getTransformDirection(t), Q = V * et, at = r.props.parentMoveable, it = 0, st, ut, ft = 0, ct, pt, mt = 0, vt, _t, xt = 180 / Math.PI * Z, Rt = Y.startValue, yt = !1, ht = J + N, bt = tt + D;\n      if (!$ && \"parentDist\" in t) {\n        var St = t.parentDist;\n        st = St, ct = St, vt = St;\n      } else\n        U || $ ? (st = getAbsoluteDist(B, V, X), ct = getAbsoluteDist(B, Q, W), vt = getAbsoluteDist(B, Q, Y)) : (st = getAbsoluteDistByClient(ht, bt, V, X), ct = getAbsoluteDistByClient(ht, bt, Q, W), vt = getAbsoluteDistByClient(ht, bt, Q, Y), yt = !0);\n      if (ut = xt + st, pt = xt + ct, _t = Rt + vt, triggerEvent(r, \"onBeforeRotate\", fillParams(r, t, {\n        beforeRotation: ut,\n        rotation: pt,\n        absoluteRotation: _t,\n        setRotation: function(zt) {\n          ct = zt - xt, st = ct, vt = ct;\n        }\n      }, !0)), e = getRotateInfo(r, K, X, st, xt, yt), it = e[0], st = e[1], ut = e[2], o = getRotateInfo(r, K, W, ct, xt, yt), ft = o[0], ct = o[1], pt = o[2], T = getRotateInfo(r, K, Y, vt, Rt, yt), mt = T[0], vt = T[1], _t = T[2], !(!mt && !ft && !it && !at)) {\n        var Ot = convertTransformFormat(S, \"rotate(\".concat(pt, \"deg)\"), \"rotate(\".concat(ct, \"deg)\")), wt = getRotateDist(r, ct, S), Ft = minus(plus(z || [0, 0], wt), S.prevInverseDist || [0, 0]);\n        S.prevInverseDist = wt, S.requestValue = null;\n        var dt = fillTransformEvent(r, Ot, Ft, U, t), Gt = dt, Mt = getDist$2([ht, bt], Y.startAbsoluteOrigin) - Y.startDist, Bt = void 0;\n        if (S.resolveAble === \"resizable\") {\n          var Dt = Resizable.dragControl(r, __assign$2(__assign$2({}, setCustomDrag(t, r.state, [t.deltaX, t.deltaY], !!U, !1, \"resizable\")), {\n            resolveMatrix: !0,\n            parentDistance: Mt\n          }));\n          Dt && (Bt = Dt, Gt = fillAfterTransform(Gt, Dt, t));\n        }\n        var Et = fillParams(r, t, __assign$2(__assign$2({\n          delta: ft,\n          dist: ct,\n          rotate: pt,\n          rotation: pt,\n          beforeDist: st,\n          beforeDelta: it,\n          beforeRotate: ut,\n          beforeRotation: ut,\n          absoluteDist: vt,\n          absoluteDelta: mt,\n          absoluteRotate: _t,\n          absoluteRotation: _t,\n          isPinch: !!U,\n          resize: Bt\n        }, dt), Gt));\n        return triggerEvent(r, \"onRotate\", Et), Et;\n      }\n    }\n  },\n  dragControlAfter: function(r, t) {\n    t.datas.requestValue;\n  },\n  dragControlEnd: function(r, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      e.isRotate = !1;\n      var o = fillEndParams(r, t, {});\n      return triggerEvent(r, \"onRotateEnd\", o), o;\n    }\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function(r, t) {\n    var e = t.datas, o = r.state, T = o.left, S = o.top, N = o.beforeOrigin, D = this.dragControlStart(r, t);\n    if (!D)\n      return !1;\n    D.set(e.beforeDirection * r.rotation);\n    var B = triggerChildAbles(r, this, \"dragControlStart\", t, function(z, V) {\n      var X = z.state, W = X.left, Y = X.top, q = X.beforeOrigin, Z = plus(minus([W, Y], [T, S]), minus(q, N));\n      return V.datas.startGroupClient = Z, V.datas.groupClient = Z, __assign$2(__assign$2({}, V), {\n        parentRotate: 0\n      });\n    }), $ = __assign$2(__assign$2({}, D), {\n      targets: r.props.targets,\n      events: B\n    }), U = triggerEvent(r, \"onRotateGroupStart\", $);\n    return e.isRotate = U !== !1, e.isRotate ? D : !1;\n  },\n  dragGroupControl: function(r, t) {\n    var e = t.datas;\n    if (!!e.isRotate) {\n      catchEvent(r, \"onBeforeRotate\", function($) {\n        triggerEvent(r, \"onBeforeRotateGroup\", fillParams(r, t, __assign$2(__assign$2({}, $), {\n          targets: r.props.targets\n        }), !0));\n      });\n      var o = this.dragControl(r, t);\n      if (!!o) {\n        var T = e.beforeDirection, S = o.beforeDist, N = S / 180 * Math.PI, D = triggerChildAbles(r, this, \"dragControl\", t, function($, U) {\n          var z = U.datas.startGroupClient, V = U.datas.groupClient, X = V[0], W = V[1], Y = rotate(z, N * T), q = Y[0], Z = Y[1], K = [q - X, Z - W];\n          return U.datas.groupClient = [q, Z], __assign$2(__assign$2({}, U), {\n            parentRotate: S,\n            groupDelta: K\n          });\n        });\n        r.rotation = T * o.beforeRotation;\n        var B = __assign$2({\n          targets: r.props.targets,\n          events: D,\n          set: function($) {\n            r.rotation = $;\n          },\n          setGroupRotation: function($) {\n            r.rotation = $;\n          }\n        }, o);\n        return triggerEvent(r, \"onRotateGroup\", B), B;\n      }\n    }\n  },\n  dragGroupControlEnd: function(r, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isRotate) {\n      this.dragControlEnd(r, t);\n      var T = triggerChildAbles(r, this, \"dragControlEnd\", t), S = fillEndParams(r, t, {\n        targets: r.props.targets,\n        events: T\n      });\n      return triggerEvent(r, \"onRotateGroupEnd\", S), e;\n    }\n  },\n  request: function(r) {\n    var t = {}, e = 0, o = r.getRotation();\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(T) {\n        return \"deltaRotate\" in T ? e += T.deltaRotate : \"rotate\" in T && (e = T.rotate - o), {\n          datas: t,\n          parentDist: e\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, directionCondition = getDirectionCondition(\"scalable\"), Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean,\n    edge: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onBeforeScale: \"beforeScale\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onBeforeScaleGroup: \"beforeScaleGroup\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: getRenderDirections(\"scalable\"),\n  dragControlCondition: directionCondition,\n  dragControlStart: function(r, t) {\n    var e = t.datas, o = t.isPinch, T = t.inputEvent, S = t.parentDirection, N = S || (o ? [0, 0] : getDirection(T.target)), D = r.state, B = D.width, $ = D.height, U = D.targetTransform, z = D.target, V = D.pos1, X = D.pos2, W = D.pos4;\n    if (!N || !z)\n      return !1;\n    o || setDragStart(r, t), e.datas = {}, e.transform = U, e.prevDist = [1, 1], e.direction = N, e.startOffsetWidth = B, e.startOffsetHeight = $, e.startValue = [1, 1];\n    var Y = getDist$2(V, X), q = getDist$2(X, W), Z = !N[0] && !N[1] || N[0] || !N[1];\n    e.scaleWidth = Y, e.scaleHeight = q, e.scaleXRatio = Y / B, e.scaleYRatio = q / $, setDefaultTransformIndex(t, \"scale\"), e.isWidth = Z;\n    function K(Q) {\n      e.ratio = Q && isFinite(Q) ? Q : 0;\n    }\n    e.startPositions = getAbsolutePosesByState(r.state);\n    function J(Q) {\n      e.fixedDirection = Q, e.fixedPosition = getPosByDirection(e.startPositions, Q);\n    }\n    e.setFixedDirection = J, K(getDist$2(V, X) / getDist$2(X, W)), J([-N[0], -N[1]]);\n    var tt = fillParams(r, t, __assign$2(__assign$2({\n      direction: N,\n      set: function(Q) {\n        e.startValue = Q;\n      },\n      setRatio: K,\n      setFixedDirection: J\n    }, fillTransformStartEvent(t)), {\n      dragStart: Draggable.dragStart(r, new CustomGesto().dragStart([0, 0], t))\n    })), et = triggerEvent(r, \"onScaleStart\", tt);\n    return e.startFixedDirection = e.fixedDirection, et !== !1 && (e.isScale = !0, r.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: N\n    }), e.isScale ? tt : !1;\n  },\n  dragControl: function(r, t) {\n    resolveTransformEvent(t, \"scale\");\n    var e = t.datas, o = t.parentKeepRatio, T = t.parentFlag, S = t.isPinch, N = t.dragClient, D = t.isRequest, B = e.prevDist, $ = e.direction, U = e.startOffsetWidth, z = e.startOffsetHeight, V = e.isScale, X = e.startValue, W = e.isWidth, Y = e.ratio;\n    if (!V)\n      return !1;\n    var q = r.props, Z = q.throttleScale, K = q.parentMoveable, J = $;\n    !$[0] && !$[1] && (J = [1, 1]);\n    var tt = Y && (o != null ? o : q.keepRatio) || !1, et = r.state;\n    function Q() {\n      var bt = getOffsetSizeDist(J, tt, e, t), St = bt.distWidth, Ot = bt.distHeight, wt = (U + St) / U, Ft = (z + Ot) / z;\n      return wt = J[0] || tt ? wt * X[0] : X[0], Ft = J[1] || tt ? Ft * X[1] : X[1], wt === 0 && (wt = (B[0] > 0 ? 1 : -1) * MIN_SCALE), Ft === 0 && (Ft = (B[1] > 0 ? 1 : -1) * MIN_SCALE), [wt, Ft];\n    }\n    var at = Q();\n    if (!S && r.props.groupable) {\n      var it = et.snapRenderInfo || {}, st = it.direction;\n      isArray(st) && (st[0] || st[1]) && (et.snapRenderInfo = {\n        direction: $,\n        request: t.isRequest\n      });\n    }\n    triggerEvent(r, \"onBeforeScale\", fillParams(r, t, {\n      scale: at,\n      setFixedDirection: function(bt) {\n        return e.setFixedDirection(bt), at = Q(), at;\n      },\n      startFixedDirection: e.startFixedDirection,\n      setScale: function(bt) {\n        at = bt;\n      }\n    }, !0));\n    var ut = [at[0] / X[0], at[1] / X[1]], ft = N, ct = [0, 0];\n    if (N || (!T && S ? ft = getAbsolutePosition(r, [0, 0]) : ft = e.fixedPosition), S || (ct = checkSnapScale(r, ut, $, D, e)), tt) {\n      J[0] && J[1] && ct[0] && ct[1] && (Math.abs(ct[0] * U) > Math.abs(ct[1] * z) ? ct[1] = 0 : ct[0] = 0);\n      var pt = !ct[0] && !ct[1];\n      if (pt && (W ? ut[0] = throttle(ut[0] * X[0], Z) / X[0] : ut[1] = throttle(ut[1] * X[1], Z) / X[1]), J[0] && !J[1] || ct[0] && !ct[1] || pt && W) {\n        ut[0] += ct[0];\n        var mt = U * ut[0] * X[0] / Y;\n        ut[1] = mt / z / X[1];\n      } else if (!J[0] && J[1] || !ct[0] && ct[1] || pt && !W) {\n        ut[1] += ct[1];\n        var vt = z * ut[1] * X[1] * Y;\n        ut[0] = vt / U / X[0];\n      }\n    } else\n      ut[0] += ct[0], ut[1] += ct[1], ct[0] || (ut[0] = throttle(ut[0] * X[0], Z) / X[0]), ct[1] || (ut[1] = throttle(ut[1] * X[1], Z) / X[1]);\n    ut[0] === 0 && (ut[0] = (B[0] > 0 ? 1 : -1) * MIN_SCALE), ut[1] === 0 && (ut[1] = (B[1] > 0 ? 1 : -1) * MIN_SCALE);\n    var _t = [ut[0] / B[0], ut[1] / B[1]];\n    at = multiply2(ut, X);\n    var xt = getScaleDist(r, ut, e.fixedDirection, ft, e), Rt = minus(xt, e.prevInverseDist || [0, 0]);\n    if (e.prevDist = ut, e.prevInverseDist = xt, at[0] === B[0] && at[1] === B[1] && Rt.every(function(bt) {\n      return !bt;\n    }) && !K)\n      return !1;\n    var yt = convertTransformFormat(e, \"scale(\".concat(at.join(\", \"), \")\"), \"scale(\".concat(ut.join(\", \"), \")\")), ht = fillParams(r, t, __assign$2({\n      offsetWidth: U,\n      offsetHeight: z,\n      direction: $,\n      scale: at,\n      dist: ut,\n      delta: _t,\n      isPinch: !!S\n    }, fillTransformEvent(r, yt, Rt, S, t)));\n    return triggerEvent(r, \"onScale\", ht), ht;\n  },\n  dragControlEnd: function(r, t) {\n    var e = t.datas;\n    if (!e.isScale)\n      return !1;\n    e.isScale = !1;\n    var o = fillEndParams(r, t, {});\n    return triggerEvent(r, \"onScaleEnd\", o), o;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function(r, t) {\n    var e = t.datas, o = this.dragControlStart(r, t);\n    if (!o)\n      return !1;\n    var T = fillChildEvents(r, \"resizable\", t);\n    function S(U, z) {\n      var V = e.fixedDirection, X = e.fixedPosition, W = z.datas.startPositions || getAbsolutePosesByState(U.state), Y = getPosByDirection(W, V), q = calculate(createRotateMatrix(-r.rotation / 180 * Math.PI, 3), [Y[0] - X[0], Y[1] - X[1], 1], 3), Z = q[0], K = q[1];\n      return z.datas.originalX = Z, z.datas.originalY = K, z;\n    }\n    e.moveableScale = r.scale;\n    var N = triggerChildAbles(r, this, \"dragControlStart\", t, function(U, z) {\n      return S(U, z);\n    }), D = function(U) {\n      o.setFixedDirection(U), N.forEach(function(z, V) {\n        z.setFixedDirection(U), S(z.moveable, T[V]);\n      });\n    };\n    e.setFixedDirection = D;\n    var B = __assign$2(__assign$2({}, o), {\n      targets: r.props.targets,\n      events: N,\n      setFixedDirection: D\n    }), $ = triggerEvent(r, \"onScaleGroupStart\", B);\n    return e.isScale = $ !== !1, e.isScale ? B : !1;\n  },\n  dragGroupControl: function(r, t) {\n    var e = t.datas;\n    if (!!e.isScale) {\n      catchEvent(r, \"onBeforeScale\", function(z) {\n        triggerEvent(r, \"onBeforeScaleGroup\", fillParams(r, t, __assign$2(__assign$2({}, z), {\n          targets: r.props.targets\n        }), !0));\n      });\n      var o = this.dragControl(r, t);\n      if (!!o) {\n        var T = e.moveableScale;\n        r.scale = [o.scale[0] * T[0], o.scale[1] * T[1]];\n        var S = r.props.keepRatio, N = o.dist, D = o.scale, B = e.fixedPosition, $ = triggerChildAbles(r, this, \"dragControl\", t, function(z, V) {\n          var X = calculate(createRotateMatrix(r.rotation / 180 * Math.PI, 3), [V.datas.originalX * N[0], V.datas.originalY * N[1], 1], 3), W = X[0], Y = X[1];\n          return __assign$2(__assign$2({}, V), {\n            parentDist: null,\n            parentScale: D,\n            parentKeepRatio: S,\n            dragClient: plus(B, [W, Y])\n          });\n        }), U = __assign$2({\n          targets: r.props.targets,\n          events: $\n        }, o);\n        return triggerEvent(r, \"onScaleGroup\", U), U;\n      }\n    }\n  },\n  dragGroupControlEnd: function(r, t) {\n    var e = t.isDrag, o = t.datas;\n    if (!!o.isScale) {\n      this.dragControlEnd(r, t);\n      var T = triggerChildAbles(r, this, \"dragControlEnd\", t), S = fillEndParams(r, t, {\n        targets: r.props.targets,\n        events: T\n      });\n      return triggerEvent(r, \"onScaleGroupEnd\", S), e;\n    }\n  },\n  request: function() {\n    var r = {}, t = 0, e = 0;\n    return {\n      isControl: !0,\n      requestStart: function(o) {\n        return {\n          datas: r,\n          parentDirection: o.direction || [1, 1]\n        };\n      },\n      request: function(o) {\n        return t += o.deltaWidth, e += o.deltaHeight, {\n          datas: r,\n          parentDist: [t, e],\n          parentKeepRatio: o.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: r,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction getMiddleLinePos(r, t) {\n  return r.map(function(e, o) {\n    return dot(e, t[o], 1, 2);\n  });\n}\nfunction getTriangleRad(r, t, e) {\n  var o = getRad$1(r, t), T = getRad$1(r, e), S = T - o;\n  return S >= 0 ? S : S + 2 * Math.PI;\n}\nfunction isValidPos(r, t) {\n  var e = getTriangleRad(r[0], r[1], r[2]), o = getTriangleRad(t[0], t[1], t[2]), T = Math.PI;\n  return !(e >= T && o <= T || e <= T && o >= T);\n}\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array,\n    edge: Boolean\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  render: function(r, t) {\n    var e = r.props, o = e.resizable, T = e.scalable, S = e.warpable, N = e.zoom;\n    if (o || T || !S)\n      return [];\n    var D = r.state, B = D.pos1, $ = D.pos2, U = D.pos3, z = D.pos4, V = getMiddleLinePos(B, $), X = getMiddleLinePos($, B), W = getMiddleLinePos(B, U), Y = getMiddleLinePos(U, B), q = getMiddleLinePos(U, z), Z = getMiddleLinePos(z, U), K = getMiddleLinePos($, z), J = getMiddleLinePos(z, $);\n    return __spreadArray([t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(V, q, N)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(X, Z, N)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(W, K, N)\n    }), t.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(Y, J, N)\n    })], renderAllDirections(r, \"warpable\", t), !0);\n  },\n  dragControlCondition: function(r, t) {\n    if (t.isRequest)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"warpable\"));\n  },\n  dragControlStart: function(r, t) {\n    var e = t.datas, o = t.inputEvent, T = r.props.target, S = o.target, N = getDirection(S);\n    if (!N || !T)\n      return !1;\n    var D = r.state, B = D.transformOrigin, $ = D.is3d, U = D.targetTransform, z = D.targetMatrix, V = D.width, X = D.height, W = D.left, Y = D.top;\n    e.datas = {}, e.targetTransform = U, e.warpTargetMatrix = $ ? z : convertDimension(z, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = N, e.left = W, e.top = Y, e.poses = [[0, 0], [V, 0], [0, X], [V, X]].map(function(K) {\n      return minus(K, B);\n    }), e.nextPoses = e.poses.map(function(K) {\n      var J = K[0], tt = K[1];\n      return calculate(e.warpTargetMatrix, [J, tt, 0, 1], 4);\n    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(D), e.posIndexes = getPosIndexesByDirection(N), setDragStart(r, t), setDefaultTransformIndex(t, \"matrix3d\"), D.snapRenderInfo = {\n      request: t.isRequest,\n      direction: N\n    };\n    var q = fillParams(r, t, __assign$2({\n      set: function(K) {\n        e.startValue = K;\n      }\n    }, fillTransformStartEvent(t))), Z = triggerEvent(r, \"onWarpStart\", q);\n    return Z !== !1 && (e.isWarp = !0), e.isWarp;\n  },\n  dragControl: function(r, t) {\n    var e = t.datas, o = t.isRequest, T = t.distX, S = t.distY, N = e.targetInverseMatrix, D = e.prevMatrix, B = e.isWarp, $ = e.startValue, U = e.poses, z = e.posIndexes, V = e.absolutePoses;\n    if (!B)\n      return !1;\n    if (resolveTransformEvent(t, \"matrix3d\"), hasGuidelines(r, \"warpable\")) {\n      var X = z.map(function(st) {\n        return V[st];\n      });\n      X.length > 1 && X.push([(X[0][0] + X[1][0]) / 2, (X[0][1] + X[1][1]) / 2]);\n      var W = checkMoveableSnapBounds(r, o, {\n        horizontal: X.map(function(st) {\n          return st[1] + S;\n        }),\n        vertical: X.map(function(st) {\n          return st[0] + T;\n        })\n      }), Y = W.horizontal, q = W.vertical;\n      S -= Y.offset, T -= q.offset;\n    }\n    var Z = getDragDist({\n      datas: e,\n      distX: T,\n      distY: S\n    }, !0), K = e.nextPoses.slice();\n    if (z.forEach(function(st) {\n      K[st] = plus(K[st], Z);\n    }), !NEARBY_POS.every(function(st) {\n      return isValidPos(st.map(function(ut) {\n        return U[ut];\n      }), st.map(function(ut) {\n        return K[ut];\n      }));\n    }))\n      return !1;\n    var J = createWarpMatrix(U[0], U[2], U[1], U[3], K[0], K[2], K[1], K[3]);\n    if (!J.length)\n      return !1;\n    var tt = multiply(N, J, 4), et = getTransfromMatrix(e, tt, !0), Q = multiply(invert(D, 4), et, 4);\n    e.prevMatrix = et;\n    var at = multiply($, et, 4), it = convertTransformFormat(e, \"matrix3d(\".concat(at.join(\", \"), \")\"), \"matrix3d(\".concat(et.join(\", \"), \")\"));\n    return fillOriginalTransform(t, it), triggerEvent(r, \"onWarp\", fillParams(r, t, {\n      delta: Q,\n      matrix: at,\n      dist: et,\n      multiply,\n      transform: it\n    })), !0;\n  },\n  dragControlEnd: function(r, t) {\n    var e = t.datas, o = t.isDrag;\n    return e.isWarp ? (e.isWarp = !1, triggerEvent(r, \"onWarpEnd\", fillEndParams(r, t, {})), o) : !1;\n  }\n}, AREA_PIECES = /* @__PURE__ */ prefix(\"area-pieces\"), AREA_PIECE = /* @__PURE__ */ prefix(\"area-piece\"), AVOID = /* @__PURE__ */ prefix(\"avoid\");\nfunction restoreStyle(r) {\n  var t = r.areaElement;\n  if (!!t) {\n    var e = r.state, o = e.width, T = e.height;\n    removeClass(t, AVOID), t.style.cssText += \"left: 0px; top: 0px; width: \".concat(o, \"px; height: \").concat(T, \"px\");\n  }\n}\nfunction renderPieces(r) {\n  return r.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, r.createElement(\"div\", {\n    className: AREA_PIECE\n  }), r.createElement(\"div\", {\n    className: AREA_PIECE\n  }), r.createElement(\"div\", {\n    className: AREA_PIECE\n  }), r.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function(r, t) {\n    var e = r.props, o = e.target, T = e.dragArea, S = e.groupable, N = e.passDragArea, D = r.state, B = D.width, $ = D.height, U = D.renderPoses, z = N ? prefix(\"area\", \"pass\") : prefix(\"area\");\n    if (S)\n      return [t.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(r, \"areaElement\"),\n        className: z\n      }), renderPieces(t)];\n    if (!o || !T)\n      return [];\n    var V = createWarpMatrix([0, 0], [B, 0], [0, $], [B, $], U[0], U[1], U[2], U[3]), X = V.length ? makeMatrixCSS(V, !0) : \"none\";\n    return [t.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(r, \"areaElement\"),\n      className: z,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(B, \"px\"),\n        height: \"\".concat($, \"px\"),\n        transformOrigin: \"0 0\",\n        transform: X\n      }\n    }), renderPieces(t)];\n  },\n  dragStart: function(r, t) {\n    var e = t.datas, o = t.clientX, T = t.clientY, S = t.inputEvent;\n    if (!S)\n      return !1;\n    e.isDragArea = !1;\n    var N = r.areaElement, D = r.state, B = D.moveableClientRect, $ = D.renderPoses, U = D.rootMatrix, z = D.is3d, V = B.left, X = B.top, W = getRect($), Y = W.left, q = W.top, Z = W.width, K = W.height, J = z ? 4 : 3, tt = calculateInversePosition(U, [o - V, T - X], J), et = tt[0], Q = tt[1];\n    et -= Y, Q -= q;\n    var at = [{\n      left: Y,\n      top: q,\n      width: Z,\n      height: Q - 10\n    }, {\n      left: Y,\n      top: q,\n      width: et - 10,\n      height: K\n    }, {\n      left: Y,\n      top: q + Q + 10,\n      width: Z,\n      height: K - Q - 10\n    }, {\n      left: Y + et + 10,\n      top: q,\n      width: Z - et - 10,\n      height: K\n    }], it = [].slice.call(N.nextElementSibling.children);\n    at.forEach(function(st, ut) {\n      it[ut].style.cssText = \"left: \".concat(st.left, \"px;top: \").concat(st.top, \"px; width: \").concat(st.width, \"px; height: \").concat(st.height, \"px;\");\n    }), addClass(N, AVOID), D.disableNativeEvent = !0;\n  },\n  drag: function(r, t) {\n    var e = t.datas, o = t.inputEvent;\n    if (this.enableNativeEvent(r), !o)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, restoreStyle(r));\n  },\n  dragEnd: function(r, t) {\n    this.enableNativeEvent(r);\n    var e = t.inputEvent, o = t.datas;\n    if (!e)\n      return !1;\n    o.isDragArea || restoreStyle(r);\n  },\n  dragGroupStart: function(r, t) {\n    return this.dragStart(r, t);\n  },\n  dragGroup: function(r, t) {\n    return this.drag(r, t);\n  },\n  dragGroupEnd: function(r, t) {\n    return this.dragEnd(r, t);\n  },\n  unset: function(r) {\n    restoreStyle(r), r.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent: function(r) {\n    var t = r.state;\n    t.disableNativeEvent && requestAnimationFrame$1(function() {\n      t.disableNativeEvent = !1;\n    });\n  }\n}, Origin = makeAble(\"origin\", {\n  render: function(r, t) {\n    var e = r.props.zoom, o = r.state, T = o.beforeOrigin, S = o.rotation;\n    return [t.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(S, e, T),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction getDefaultScrollPosition(r) {\n  var t = r.scrollContainer;\n  return [t.scrollLeft, t.scrollTop];\n}\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragRelation: \"strong\",\n  dragStart: function(r, t) {\n    var e = r.props, o = e.scrollContainer, T = o === void 0 ? r.getContainer() : o, S = new DragScroll$1(), N = getRefTarget(T, !0);\n    t.datas.dragScroll = S;\n    var D = t.isControl ? \"controlGesto\" : \"targetGesto\", B = t.targets;\n    S.on(\"scroll\", function($) {\n      var U = $.container, z = $.direction, V = fillParams(r, t, {\n        scrollContainer: U,\n        direction: z\n      }), X = B ? \"onScrollGroup\" : \"onScroll\";\n      B && (V.targets = B), triggerEvent(r, X, V);\n    }).on(\"move\", function($) {\n      var U = $.offsetX, z = $.offsetY;\n      r[D].scrollBy(U, z, t.inputEvent, !1);\n    }), S.dragStart(t, {\n      container: N\n    });\n  },\n  checkScroll: function(r, t) {\n    var e = t.datas.dragScroll;\n    if (!!e) {\n      var o = r.props, T = o.scrollContainer, S = T === void 0 ? r.getContainer() : T, N = o.scrollThreshold, D = N === void 0 ? 0 : N, B = o.getScrollPosition, $ = B === void 0 ? getDefaultScrollPosition : B;\n      return e.drag(t, {\n        container: S,\n        threshold: D,\n        getScrollPosition: function(U) {\n          return $({\n            scrollContainer: U.container,\n            direction: U.direction\n          });\n        }\n      }), !0;\n    }\n  },\n  drag: function(r, t) {\n    return this.checkScroll(r, t);\n  },\n  dragEnd: function(r, t) {\n    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;\n  },\n  dragControlStart: function(r, t) {\n    return this.dragStart(r, __assign$2(__assign$2({}, t), {\n      isControl: !0\n    }));\n  },\n  dragControl: function(r, t) {\n    return this.drag(r, t);\n  },\n  dragControlEnd: function(r, t) {\n    return this.dragEnd(r, t);\n  },\n  dragGroupStart: function(r, t) {\n    return this.dragStart(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  dragGroup: function(r, t) {\n    return this.drag(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  dragGroupEnd: function(r, t) {\n    return this.dragEnd(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  dragGroupControlStart: function(r, t) {\n    return this.dragStart(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets,\n      isControl: !0\n    }));\n  },\n  dragGroupContro: function(r, t) {\n    return this.drag(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  },\n  dragGroupControEnd: function(r, t) {\n    return this.dragEnd(r, __assign$2(__assign$2({}, t), {\n      targets: r.props.targets\n    }));\n  }\n}, Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    useResizeObserver: Boolean,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Object,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    hideDefaultLines: Boolean,\n    props: Object,\n    flushSync: Function,\n    stopPropagation: Boolean,\n    preventClickEventOnDrag: Boolean,\n    preventClickDefault: Boolean\n  },\n  events: {}\n}, Padding = makeAble(\"padding\", {\n  render: function(r, t) {\n    var e = r.props;\n    if (e.dragArea)\n      return [];\n    var o = e.padding || {}, T = o.left, S = T === void 0 ? 0 : T, N = o.top, D = N === void 0 ? 0 : N, B = o.right, $ = B === void 0 ? 0 : B, U = o.bottom, z = U === void 0 ? 0 : U, V = r.state, X = V.renderPoses, W = V.pos1, Y = V.pos2, q = V.pos3, Z = V.pos4, K = [W, Y, q, Z], J = [];\n    return S > 0 && J.push([0, 2]), D > 0 && J.push([0, 1]), $ > 0 && J.push([1, 3]), z > 0 && J.push([2, 3]), J.map(function(tt, et) {\n      var Q = tt[0], at = tt[1], it = K[Q], st = K[at], ut = X[Q], ft = X[at], ct = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], it, st, ut, ft);\n      if (!!ct.length)\n        return t.createElement(\"div\", {\n          key: \"padding\".concat(et),\n          className: prefix(\"padding\"),\n          style: {\n            transform: makeMatrixCSS(ct, !0)\n          }\n        });\n    });\n  }\n}), RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction calculateRatio(r, t) {\n  var e = r[0] + r[1], o = e > t ? t / e : 1;\n  return r[0] *= o, r[1] = t - r[1] * o, r;\n}\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\nfunction getRadiusStyles(r, t, e, o, T, S, N, D, B) {\n  S === void 0 && (S = 0), N === void 0 && (N = 0), D === void 0 && (D = o), B === void 0 && (B = T);\n  var $ = [], U = !1, z = r.map(function(V, X) {\n    var W = t[X], Y = W.horizontal, q = W.vertical;\n    if (q && !U && (U = !0, $.push(\"/\")), U) {\n      var Z = Math.max(0, q === 1 ? V[1] - N : B - V[1]);\n      return $.push(convertCSSSize(Z, T, e)), Z;\n    } else {\n      var Z = Math.max(0, Y === 1 ? V[0] - S : D - V[0]);\n      return $.push(convertCSSSize(Z, o, e)), Z;\n    }\n  });\n  return {\n    styles: $,\n    raws: z\n  };\n}\nfunction getRadiusRange(r) {\n  for (var t = [0, 0], e = [0, 0], o = r.length, T = 0; T < o; ++T) {\n    var S = r[T];\n    !S.sub || (S.horizontal && (t[1] === 0 && (t[0] = T), t[1] = T - t[0] + 1, e[0] = T + 1), S.vertical && (e[1] === 0 && (e[0] = T), e[1] = T - e[0] + 1));\n  }\n  return {\n    horizontalRange: t,\n    verticalRange: e\n  };\n}\nfunction getRadiusValues(r, t, e, o, T, S) {\n  var N, D, B, $;\n  S === void 0 && (S = [0, 0]);\n  var U = r.indexOf(\"/\"), z = (U > -1 ? r.slice(0, U) : r).length, V = r.slice(0, z), X = r.slice(z + 1), W = V[0], Y = W === void 0 ? \"0px\" : W, q = V[1], Z = q === void 0 ? Y : q, K = V[2], J = K === void 0 ? Y : K, tt = V[3], et = tt === void 0 ? Z : tt, Q = X[0], at = Q === void 0 ? Y : Q, it = X[1], st = it === void 0 ? at : it, ut = X[2], ft = ut === void 0 ? at : ut, ct = X[3], pt = ct === void 0 ? st : ct, mt = [Y, Z, J, et].map(function(ht) {\n    return convertUnitSize(ht, t);\n  }), vt = [at, st, ft, pt].map(function(ht) {\n    return convertUnitSize(ht, e);\n  }), _t = mt.slice(), xt = vt.slice();\n  N = calculateRatio([_t[0], _t[1]], t), _t[0] = N[0], _t[1] = N[1], D = calculateRatio([_t[3], _t[2]], t), _t[3] = D[0], _t[2] = D[1], B = calculateRatio([xt[0], xt[3]], e), xt[0] = B[0], xt[3] = B[1], $ = calculateRatio([xt[1], xt[2]], e), xt[1] = $[0], xt[2] = $[1];\n  var Rt = _t.slice(0, Math.max(S[0], V.length)), yt = xt.slice(0, Math.max(S[1], X.length));\n  return __spreadArray(__spreadArray([], Rt.map(function(ht, bt) {\n    var St = RADIUS_DIRECTIONS[bt];\n    return {\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[bt],\n      vertical: 0,\n      pos: [o + ht, T + (VERTICAL_RADIUS_DIRECTIONS[bt] === -1 ? e : 0)],\n      sub: !0,\n      raw: mt[bt],\n      direction: St\n    };\n  }), !0), yt.map(function(ht, bt) {\n    var St = RADIUS_DIRECTIONS[bt];\n    return {\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[bt],\n      pos: [o + (HORIZONTAL_RADIUS_DIRECTIONS[bt] === -1 ? t : 0), T + ht],\n      sub: !0,\n      raw: vt[bt],\n      direction: St\n    };\n  }), !0);\n}\nfunction removeRadiusPos(r, t, e, o, T) {\n  T === void 0 && (T = t.length);\n  var S = getRadiusRange(r.slice(o)), N = S.horizontalRange, D = S.verticalRange, B = e - o, $ = 0;\n  if (B === 0)\n    $ = T;\n  else if (B > 0 && B < N[1])\n    $ = N[1] - B;\n  else if (B >= D[0])\n    $ = D[0] + D[1] - B;\n  else\n    return;\n  r.splice(e, $), t.splice(e, $);\n}\nfunction addRadiusPos(r, t, e, o, T, S, N, D, B, $, U) {\n  $ === void 0 && ($ = 0), U === void 0 && (U = 0);\n  var z = getRadiusRange(r.slice(e)), V = z.horizontalRange, X = z.verticalRange;\n  if (o > -1)\n    for (var W = HORIZONTAL_RADIUS_DIRECTIONS[o] === 1 ? S - $ : D - S, Y = V[1]; Y <= o; ++Y) {\n      var q = VERTICAL_RADIUS_DIRECTIONS[Y] === 1 ? U : B, Z = 0;\n      if (o === Y ? Z = S : Y === 0 ? Z = $ + W : HORIZONTAL_RADIUS_DIRECTIONS[Y] === -1 && (Z = D - (t[e][0] - $)), r.splice(e + Y, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[Y],\n        vertical: 0,\n        pos: [Z, q]\n      }), t.splice(e + Y, 0, [Z, q]), Y === 0)\n        break;\n    }\n  else if (T > -1) {\n    var K = VERTICAL_RADIUS_DIRECTIONS[T] === 1 ? N - U : B - N;\n    if (V[1] === 0 && X[1] === 0) {\n      var J = [$ + K, U];\n      r.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: J\n      }), t.push(J);\n    }\n    for (var tt = X[0], Y = X[1]; Y <= T; ++Y) {\n      var Z = HORIZONTAL_RADIUS_DIRECTIONS[Y] === 1 ? $ : D, q = 0;\n      if (T === Y ? q = N : Y === 0 ? q = U + K : VERTICAL_RADIUS_DIRECTIONS[Y] === 1 ? q = t[e + tt][1] : VERTICAL_RADIUS_DIRECTIONS[Y] === -1 && (q = B - (t[e + tt][1] - U)), r.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[Y],\n        pos: [Z, q]\n      }), t.push([Z, q]), Y === 0)\n        break;\n    }\n  }\n}\nfunction splitRadiusPoses(r, t) {\n  t === void 0 && (t = r.map(function(T) {\n    return T.raw;\n  }));\n  var e = r.map(function(T, S) {\n    return T.horizontal ? t[S] : null;\n  }).filter(function(T) {\n    return T != null;\n  }), o = r.map(function(T, S) {\n    return T.vertical ? t[S] : null;\n  }).filter(function(T) {\n    return T != null;\n  });\n  return {\n    horizontals: e,\n    verticals: o\n  };\n}\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]], CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction getClipStyles(r, t, e) {\n  var o = r.props.clipRelative, T = r.state, S = T.width, N = T.height, D = t, B = D.type, $ = D.poses, U = B === \"rect\", z = B === \"circle\";\n  if (B === \"polygon\")\n    return e.map(function(Q) {\n      return \"\".concat(convertCSSSize(Q[0], S, o), \" \").concat(convertCSSSize(Q[1], N, o));\n    });\n  if (U || B === \"inset\") {\n    var V = e[1][1], X = e[3][0], W = e[7][0], Y = e[5][1];\n    if (U)\n      return [V, X, Y, W].map(function(Q) {\n        return \"\".concat(Q, \"px\");\n      });\n    var q = [V, S - X, N - Y, W].map(function(Q, at) {\n      return convertCSSSize(Q, at % 2 ? S : N, o);\n    });\n    if (e.length > 8) {\n      var Z = minus(e[4], e[0]), K = Z[0], J = Z[1];\n      q.push.apply(q, __spreadArray([\"round\"], getRadiusStyles(e.slice(8), $.slice(8), o, K, J, W, V, X, Y).styles, !1));\n    }\n    return q;\n  } else if (z || B === \"ellipse\") {\n    var tt = e[0], et = convertCSSSize(Math.abs(e[1][1] - tt[1]), z ? Math.sqrt((S * S + N * N) / 2) : N, o), q = z ? [et] : [convertCSSSize(Math.abs(e[2][0] - tt[0]), S, o), et];\n    return q.push(\"at\", convertCSSSize(tt[0], S, o), convertCSSSize(tt[1], N, o)), q;\n  }\n}\nfunction getRectPoses(r, t, e, o) {\n  var T = [o, (o + t) / 2, t], S = [r, (r + e) / 2, e];\n  return CLIP_RECT_DIRECTIONS.map(function(N) {\n    var D = N[0], B = N[1], $ = N[2], U = T[D + 1], z = S[B + 1];\n    return {\n      vertical: Math.abs(B),\n      horizontal: Math.abs(D),\n      direction: $,\n      pos: [U, z]\n    };\n  });\n}\nfunction getControlSize(r) {\n  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];\n  return r.forEach(function(o) {\n    var T = o.pos;\n    t[0] = Math.min(t[0], T[0]), t[1] = Math.max(t[1], T[0]), e[0] = Math.min(e[0], T[1]), e[1] = Math.max(e[1], T[1]);\n  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];\n}\nfunction moveControlPos(r, t, e, o, T) {\n  var S = r[t], N = S.direction, D = S.sub, B = r.map(function() {\n    return [0, 0];\n  }), $ = N ? N.split(\"\") : [];\n  if (o && t < 8) {\n    var U = $.filter(function(pt) {\n      return pt === \"w\" || pt === \"e\";\n    }), z = $.filter(function(pt) {\n      return pt === \"n\" || pt === \"s\";\n    }), V = U[0], X = z[0];\n    B[t] = e;\n    var W = getControlSize(r), Y = W[0], q = W[1], Z = Y && q ? Y / q : 0;\n    if (Z && T) {\n      var K = (t + 4) % 8, J = r[K].pos, tt = [0, 0];\n      N.indexOf(\"w\") > -1 ? tt[0] = -1 : N.indexOf(\"e\") > -1 && (tt[0] = 1), N.indexOf(\"n\") > -1 ? tt[1] = -1 : N.indexOf(\"s\") > -1 && (tt[1] = 1);\n      var et = getSizeDistByDist([Y, q], e, Z, tt, !0), Q = Y + et[0], at = q + et[1], it = J[1], st = J[1], ut = J[0], ft = J[0];\n      tt[0] === -1 ? ut = ft - Q : tt[0] === 1 ? ft = ut + Q : (ut = ut - Q / 2, ft = ft + Q / 2), tt[1] === -1 ? it = st - at : (tt[1] === 1 || (it = st - at / 2), st = it + at);\n      var ct = getRectPoses(it, ft, st, ut);\n      r.forEach(function(pt, mt) {\n        B[mt][0] = ct[mt].pos[0] - pt.pos[0], B[mt][1] = ct[mt].pos[1] - pt.pos[1];\n      });\n    } else\n      r.forEach(function(pt, mt) {\n        var vt = pt.direction;\n        !vt || (vt.indexOf(V) > -1 && (B[mt][0] = e[0]), vt.indexOf(X) > -1 && (B[mt][1] = e[1]));\n      }), V && (B[1][0] = e[0] / 2, B[5][0] = e[0] / 2), X && (B[3][1] = e[1] / 2, B[7][1] = e[1] / 2);\n  } else\n    N && !D ? $.forEach(function(pt) {\n      var mt = pt === \"n\" || pt === \"s\";\n      r.forEach(function(vt, _t) {\n        var xt = vt.direction, Rt = vt.horizontal, yt = vt.vertical;\n        !xt || xt.indexOf(pt) === -1 || (B[_t] = [mt || !Rt ? 0 : e[0], !mt || !yt ? 0 : e[1]]);\n      });\n    }) : B[t] = e;\n  return B;\n}\nfunction getClipPath(r, t, e, o, T) {\n  var S, N, D, B, $, U, z, V = T;\n  if (!V) {\n    var X = getComputedStyle$1$1(r), W = X.clipPath;\n    V = W !== \"none\" ? W : X.clip;\n  }\n  if (!((!V || V === \"none\" || V === \"auto\") && (V = o, !V))) {\n    var Y = splitBracket(V), q = Y.prefix, Z = q === void 0 ? V : q, K = Y.value, J = K === void 0 ? \"\" : K, tt = Z === \"circle\", et = \" \";\n    if (Z === \"polygon\") {\n      var Q = splitComma(J || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n      et = \",\";\n      var at = Q.map(function(At) {\n        var ee = At.split(\" \"), te = ee[0], he = ee[1];\n        return {\n          vertical: 1,\n          horizontal: 1,\n          pos: [convertUnitSize(te, t), convertUnitSize(he, e)]\n        };\n      });\n      return {\n        type: Z,\n        clipText: V,\n        poses: at,\n        splitter: et\n      };\n    } else if (tt || Z === \"ellipse\") {\n      var it = \"\", st = \"\", ut = 0, ft = 0, Q = splitSpace(J);\n      if (tt) {\n        var ct = \"\";\n        S = Q[0], ct = S === void 0 ? \"50%\" : S, N = Q[2], it = N === void 0 ? \"50%\" : N, D = Q[3], st = D === void 0 ? \"50%\" : D, ut = convertUnitSize(ct, Math.sqrt((t * t + e * e) / 2)), ft = ut;\n      } else {\n        var pt = \"\", mt = \"\";\n        B = Q[0], pt = B === void 0 ? \"50%\" : B, $ = Q[1], mt = $ === void 0 ? \"50%\" : $, U = Q[3], it = U === void 0 ? \"50%\" : U, z = Q[4], st = z === void 0 ? \"50%\" : z, ut = convertUnitSize(pt, t), ft = convertUnitSize(mt, e);\n      }\n      var vt = [convertUnitSize(it, t), convertUnitSize(st, e)], at = __spreadArray([{\n        vertical: 1,\n        horizontal: 1,\n        pos: vt,\n        direction: \"nesw\"\n      }], CLIP_DIRECTIONS.slice(0, tt ? 1 : 2).map(function(te) {\n        return {\n          vertical: Math.abs(te[1]),\n          horizontal: te[0],\n          direction: te[2],\n          sub: !0,\n          pos: [vt[0] + te[0] * ut, vt[1] + te[1] * ft]\n        };\n      }), !0);\n      return {\n        type: Z,\n        clipText: V,\n        radiusX: ut,\n        radiusY: ft,\n        left: vt[0] - ut,\n        top: vt[1] - ft,\n        poses: at,\n        splitter: et\n      };\n    } else if (Z === \"inset\") {\n      var Q = splitSpace(J || \"0 0 0 0\"), _t = Q.indexOf(\"round\"), xt = (_t > -1 ? Q.slice(0, _t) : Q).length, Rt = Q.slice(xt + 1), yt = Q.slice(0, xt), ht = yt[0], bt = yt[1], St = bt === void 0 ? ht : bt, Ot = yt[2], wt = Ot === void 0 ? ht : Ot, Ft = yt[3], dt = Ft === void 0 ? St : Ft, Gt = [ht, wt].map(function(te) {\n        return convertUnitSize(te, e);\n      }), Mt = Gt[0], Bt = Gt[1], Dt = [dt, St].map(function(te) {\n        return convertUnitSize(te, t);\n      }), Et = Dt[0], zt = Dt[1], It = t - zt, Ct = e - Bt, Lt = getRadiusValues(Rt, It - Et, Ct - Mt, Et, Mt), at = __spreadArray(__spreadArray([], getRectPoses(Mt, It, Ct, Et), !0), Lt, !0);\n      return {\n        type: \"inset\",\n        clipText: V,\n        poses: at,\n        top: Mt,\n        left: Et,\n        right: It,\n        bottom: Ct,\n        radius: Rt,\n        splitter: et\n      };\n    } else if (Z === \"rect\") {\n      var Q = splitComma(J || \"0px, \".concat(t, \"px, \").concat(e, \"px, 0px\"));\n      et = \",\";\n      var $t = Q.map(function(ne) {\n        var Me = splitUnit(ne).value;\n        return Me;\n      }), Mt = $t[0], zt = $t[1], Bt = $t[2], Et = $t[3], at = getRectPoses(Mt, zt, Bt, Et);\n      return {\n        type: \"rect\",\n        clipText: V,\n        poses: at,\n        top: Mt,\n        right: zt,\n        bottom: Bt,\n        left: Et,\n        values: Q,\n        splitter: et\n      };\n    }\n  }\n}\nfunction addClipPath(r, t) {\n  var e = calculatePointerDist(r, t), o = e[0], T = e[1], S = t.datas, N = S.clipPath, D = S.clipIndex, B = N, $ = B.type, U = B.poses, z = B.splitter, V = U.map(function(Z) {\n    return Z.pos;\n  });\n  if ($ === \"polygon\")\n    V.splice(D, 0, [o, T]);\n  else if ($ === \"inset\") {\n    var X = HORIZONTAL_RADIUS_ORDER.indexOf(D), W = VERTICAL_RADIUS_ORDER.indexOf(D), Y = U.length;\n    if (addRadiusPos(U, V, 8, X, W, o, T, V[4][0], V[4][1], V[0][0], V[0][1]), Y === U.length)\n      return;\n  } else\n    return;\n  var q = getClipStyles(r, N, V);\n  triggerEvent(r, \"onClip\", fillParams(r, t, {\n    clipEventType: \"added\",\n    clipType: $,\n    poses: V,\n    clipStyles: q,\n    clipStyle: \"\".concat($, \"(\").concat(q.join(z), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nfunction removeClipPath(r, t) {\n  var e = t.datas, o = e.clipPath, T = e.clipIndex, S = o, N = S.type, D = S.poses, B = S.splitter, $ = D.map(function(V) {\n    return V.pos;\n  }), U = $.length;\n  if (N === \"polygon\")\n    D.splice(T, 1), $.splice(T, 1);\n  else if (N === \"inset\") {\n    if (T < 8 || (removeRadiusPos(D, $, T, 8, U), U === D.length))\n      return;\n  } else\n    return;\n  var z = getClipStyles(r, o, $);\n  triggerEvent(r, \"onClip\", fillParams(r, t, {\n    clipEventType: \"removed\",\n    clipType: N,\n    poses: $,\n    clipStyles: z,\n    clipStyle: \"\".concat(N, \"(\").concat(z.join(B), \")\"),\n    distX: 0,\n    distY: 0\n  }));\n}\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    keepRatio: Boolean,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [`.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`, `:host {\n    --bounds-color: #d66;\n}`, `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`, `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`],\n  render: function(r, t) {\n    var e = r.props, o = e.customClipPath, T = e.defaultClipPath, S = e.clipArea, N = e.zoom, D = r.state, B = D.target, $ = D.width, U = D.height, z = D.allMatrix, V = D.is3d, X = D.left, W = D.top, Y = D.pos1, q = D.pos2, Z = D.pos3, K = D.pos4, J = D.clipPathState, tt = D.snapBoundInfos, et = D.rotation;\n    if (!B)\n      return [];\n    var Q = getClipPath(B, $, U, T || \"inset\", J || o);\n    if (!Q)\n      return [];\n    var at = V ? 4 : 3, it = Q.type, st = Q.poses, ut = st.map(function(Ct) {\n      var Lt = calculatePosition(z, Ct.pos, at);\n      return [Lt[0] - X, Lt[1] - W];\n    }), ft = [], ct = [], pt = it === \"rect\", mt = it === \"inset\", vt = it === \"polygon\";\n    if (pt || mt || vt) {\n      var _t = mt ? ut.slice(0, 8) : ut;\n      ct = _t.map(function(Ct, Lt) {\n        var $t = Lt === 0 ? _t[_t.length - 1] : _t[Lt - 1], At = getRad$1($t, Ct), ee = getDiagonalSize($t, Ct);\n        return t.createElement(\"div\", {\n          key: \"clipLine\".concat(Lt),\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": Lt,\n          style: {\n            width: \"\".concat(ee, \"px\"),\n            transform: \"translate(\".concat($t[0], \"px, \").concat($t[1], \"px) rotate(\").concat(At, \"rad) scaleY(\").concat(N, \")\")\n          }\n        });\n      });\n    }\n    if (ft = ut.map(function(Ct, Lt) {\n      return t.createElement(\"div\", {\n        key: \"clipControl\".concat(Lt),\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": Lt,\n        style: {\n          transform: \"translate(\".concat(Ct[0], \"px, \").concat(Ct[1], \"px) rotate(\").concat(et, \"rad) scale(\").concat(N, \")\")\n        }\n      });\n    }), mt && ft.push.apply(ft, ut.slice(8).map(function(Ct, Lt) {\n      return t.createElement(\"div\", {\n        key: \"clipRadiusControl\".concat(Lt),\n        className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n        \"data-clip-index\": 8 + Lt,\n        style: {\n          transform: \"translate(\".concat(Ct[0], \"px, \").concat(Ct[1], \"px) rotate(\").concat(et, \"rad) scale(\").concat(N, \")\")\n        }\n      });\n    })), it === \"circle\" || it === \"ellipse\") {\n      var xt = Q.left, Rt = Q.top, yt = Q.radiusX, ht = Q.radiusY, bt = minus(calculatePosition(z, [xt, Rt], at), calculatePosition(z, [0, 0], at)), St = bt[0], Ot = bt[1], wt = \"none\";\n      if (!S) {\n        for (var Ft = Math.max(10, yt / 5, ht / 5), dt = [], Gt = 0; Gt <= Ft; ++Gt) {\n          var Mt = Math.PI * 2 / Ft * Gt;\n          dt.push([yt + (yt - N) * Math.cos(Mt), ht + (ht - N) * Math.sin(Mt)]);\n        }\n        dt.push([yt, -2]), dt.push([-2, -2]), dt.push([-2, ht * 2 + 2]), dt.push([yt * 2 + 2, ht * 2 + 2]), dt.push([yt * 2 + 2, -2]), dt.push([yt, -2]), wt = \"polygon(\".concat(dt.map(function(Ct) {\n          return \"\".concat(Ct[0], \"px \").concat(Ct[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      ft.push(t.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(yt * 2, \"px\"),\n          height: \"\".concat(ht * 2, \"px\"),\n          clipPath: wt,\n          transform: \"translate(\".concat(-X + St, \"px, \").concat(-W + Ot, \"px) \").concat(makeMatrixCSS(z))\n        }\n      }));\n    }\n    if (S) {\n      var Bt = getRect(__spreadArray([Y, q, Z, K], ut, !0)), Dt = Bt.width, Et = Bt.height, zt = Bt.left, It = Bt.top;\n      if (vt || pt || mt) {\n        var dt = mt ? ut.slice(0, 8) : ut;\n        ft.push(t.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(Dt, \"px\"),\n            height: \"\".concat(Et, \"px\"),\n            transform: \"translate(\".concat(zt, \"px, \").concat(It, \"px)\"),\n            clipPath: \"polygon(\".concat(dt.map(function(Lt) {\n              return \"\".concat(Lt[0] - zt, \"px \").concat(Lt[1] - It, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    return tt && [\"vertical\", \"horizontal\"].forEach(function(Ct) {\n      var Lt = tt[Ct], $t = Ct === \"horizontal\";\n      Lt.isSnap && ct.push.apply(ct, Lt.snap.posInfos.map(function(At, ee) {\n        var te = At.pos, he = minus(calculatePosition(z, $t ? [0, te] : [te, 0], at), [X, W]), we = minus(calculatePosition(z, $t ? [$, te] : [te, U], at), [X, W]);\n        return renderLine(t, \"\", he, we, N, \"clip\".concat(Ct, \"snap\").concat(ee), \"guideline\");\n      })), Lt.isBound && ct.push.apply(ct, Lt.bounds.map(function(At, ee) {\n        var te = At.pos, he = minus(calculatePosition(z, $t ? [0, te] : [te, 0], at), [X, W]), we = minus(calculatePosition(z, $t ? [$, te] : [te, U], at), [X, W]);\n        return renderLine(t, \"\", he, we, N, \"clip\".concat(Ct, \"bounds\").concat(ee), \"guideline\", \"bounds\", \"bold\");\n      }));\n    }), __spreadArray(__spreadArray([], ft, !0), ct, !0);\n  },\n  dragControlCondition: function(r, t) {\n    return t.inputEvent && (t.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(r, t) {\n    var e = r.props, o = e.dragWithClip, T = o === void 0 ? !0 : o;\n    return T ? !1 : this.dragControlStart(r, t);\n  },\n  drag: function(r, t) {\n    return this.dragControl(r, __assign$2(__assign$2({}, t), {\n      isDragTarget: !0\n    }));\n  },\n  dragEnd: function(r, t) {\n    return this.dragControlEnd(r, t);\n  },\n  dragControlStart: function(r, t) {\n    var e = r.state, o = r.props, T = o.defaultClipPath, S = o.customClipPath, N = e.target, D = e.width, B = e.height, $ = t.inputEvent ? t.inputEvent.target : null, U = $ && $.getAttribute(\"class\") || \"\", z = t.datas, V = getClipPath(N, D, B, T || \"inset\", S);\n    if (!V)\n      return !1;\n    var X = V.clipText, W = V.type, Y = V.poses, q = triggerEvent(r, \"onClipStart\", fillParams(r, t, {\n      clipType: W,\n      clipStyle: X,\n      poses: Y.map(function(Z) {\n        return Z.pos;\n      })\n    }));\n    return q === !1 ? (z.isClipStart = !1, !1) : (z.isControl = U && U.indexOf(\"clip-control\") > -1, z.isLine = U.indexOf(\"clip-line\") > -1, z.isArea = U.indexOf(\"clip-area\") > -1 || U.indexOf(\"clip-ellipse\") > -1, z.clipIndex = $ ? parseInt($.getAttribute(\"data-clip-index\"), 10) : -1, z.clipPath = V, z.isClipStart = !0, e.clipPathState = X, setDragStart(r, t), !0);\n  },\n  dragControl: function(r, t) {\n    var e, o = t.datas, T = t.originalDatas, S = t.isDragTarget;\n    if (!o.isClipStart)\n      return !1;\n    var N = o, D = N.isControl, B = N.isLine, $ = N.isArea, U = N.clipIndex, z = N.clipPath;\n    if (!z)\n      return !1;\n    var V = getProps(r.props, \"clippable\"), X = V.keepRatio, W = 0, Y = 0, q = T.draggable, Z = getDragDist(t);\n    S && q ? (e = q.prevBeforeDist, W = e[0], Y = e[1]) : (W = Z[0], Y = Z[1]);\n    var K = [W, Y], J = r.state, tt = J.width, et = J.height, Q = !$ && !D && !B, at = z.type, it = z.poses, st = z.splitter, ut = it.map(function(lt) {\n      return lt.pos;\n    });\n    Q && (W = -W, Y = -Y);\n    var ft = !D || it[U].direction === \"nesw\", ct = at === \"inset\" || at === \"rect\", pt = it.map(function() {\n      return [0, 0];\n    });\n    if (D && !ft) {\n      var mt = it[U], vt = mt.horizontal, _t = mt.vertical, xt = [W * Math.abs(vt), Y * Math.abs(_t)];\n      pt = moveControlPos(it, U, xt, ct, X);\n    } else\n      ft && (pt = ut.map(function() {\n        return [W, Y];\n      }));\n    var Rt = ut.map(function(lt, gt) {\n      return plus(lt, pt[gt]);\n    }), yt = __spreadArray([], Rt, !0);\n    J.snapBoundInfos = null;\n    var ht = z.type === \"circle\", bt = z.type === \"ellipse\";\n    if (ht || bt) {\n      var St = getRect(Rt), Ot = Math.abs(St.bottom - St.top), wt = Math.abs(bt ? St.right - St.left : Ot), Ft = Rt[0][1] + Ot, dt = Rt[0][0] - wt, Gt = Rt[0][0] + wt;\n      ht && (yt.push([Gt, St.bottom]), pt.push([1, 0])), yt.push([St.left, Ft]), pt.push([0, 1]), yt.push([dt, St.bottom]), pt.push([1, 0]);\n    }\n    var Mt = getDefaultGuidelines((V.clipHorizontalGuidelines || []).map(function(lt) {\n      return convertUnitSize(\"\".concat(lt), et);\n    }), (V.clipVerticalGuidelines || []).map(function(lt) {\n      return convertUnitSize(\"\".concat(lt), tt);\n    }), tt, et), Bt = [], Dt = [];\n    if (ht || bt)\n      Bt = [yt[4][0], yt[2][0]], Dt = [yt[1][1], yt[3][1]];\n    else if (ct) {\n      var Et = [yt[0], yt[2], yt[4], yt[6]], zt = [pt[0], pt[2], pt[4], pt[6]];\n      Bt = Et.filter(function(lt, gt) {\n        return zt[gt][0];\n      }).map(function(lt) {\n        return lt[0];\n      }), Dt = Et.filter(function(lt, gt) {\n        return zt[gt][1];\n      }).map(function(lt) {\n        return lt[1];\n      });\n    } else\n      Bt = yt.filter(function(lt, gt) {\n        return pt[gt][0];\n      }).map(function(lt) {\n        return lt[0];\n      }), Dt = yt.filter(function(lt, gt) {\n        return pt[gt][1];\n      }).map(function(lt) {\n        return lt[1];\n      });\n    var It = [0, 0], Ct = checkSnapBounds(Mt, V.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: tt,\n      bottom: et\n    }, Bt, Dt, 5), Lt = Ct.horizontal, $t = Ct.vertical, At = Lt.offset, ee = $t.offset;\n    if (Lt.isBound && (It[1] += At), $t.isBound && (It[0] += ee), (bt || ht) && pt[0][0] === 0 && pt[0][1] === 0) {\n      var St = getRect(Rt), te = St.bottom - St.top, he = bt ? St.right - St.left : te, we = $t.isBound ? Math.abs(ee) : $t.snapIndex === 0 ? -ee : ee, Be = Lt.isBound ? Math.abs(At) : Lt.snapIndex === 0 ? -At : At;\n      he -= we, te -= Be, ht && (te = checkSnapBoundPriority($t, Lt) > 0 ? te : he, he = te);\n      var ne = yt[0];\n      yt[1][1] = ne[1] - te, yt[2][0] = ne[0] + he, yt[3][1] = ne[1] + te, yt[4][0] = ne[0] - he;\n    } else if (ct && X && D) {\n      var Me = getControlSize(it), ye = Me[0], de = Me[1], ce = ye && de ? ye / de : 0, ie = it[U], Le = ie.direction || \"\", Na = yt[1][1], Ft = yt[5][1], dt = yt[7][0], Gt = yt[3][0];\n      At <= ee ? At = ee / ce : ee = At * ce, Le.indexOf(\"w\") > -1 ? dt -= ee : Le.indexOf(\"e\") > -1 ? Gt -= ee : (dt += ee / 2, Gt -= ee / 2), Le.indexOf(\"n\") > -1 ? Na -= At : Le.indexOf(\"s\") > -1 ? Ft -= At : (Na += At / 2, Ft -= At / 2);\n      var Dc = getRectPoses(Na, Gt, Ft, dt);\n      yt.forEach(function(Nt, kt) {\n        var Ut;\n        Ut = Dc[kt].pos, Nt[0] = Ut[0], Nt[1] = Ut[1];\n      });\n    } else\n      yt.forEach(function(lt, gt) {\n        var Tt = pt[gt];\n        Tt[0] && (lt[0] -= ee), Tt[1] && (lt[1] -= At);\n      });\n    var Wu = getClipStyles(r, z, Rt), Ma = \"\".concat(at, \"(\").concat(Wu.join(st), \")\");\n    if (J.clipPathState = Ma, ht || bt)\n      Bt = [yt[4][0], yt[2][0]], Dt = [yt[1][1], yt[3][1]];\n    else if (ct) {\n      var Et = [yt[0], yt[2], yt[4], yt[6]];\n      Bt = Et.map(function(gt) {\n        return gt[0];\n      }), Dt = Et.map(function(gt) {\n        return gt[1];\n      });\n    } else\n      Bt = yt.map(function(lt) {\n        return lt[0];\n      }), Dt = yt.map(function(lt) {\n        return lt[1];\n      });\n    if (J.snapBoundInfos = checkSnapBounds(Mt, V.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: tt,\n      bottom: et\n    }, Bt, Dt, 1), q) {\n      var Yu = J.is3d, qu = J.allMatrix, Zu = Yu ? 4 : 3, Da = It;\n      S && (Da = [K[0] + It[0] - Z[0], K[1] + It[1] - Z[1]]), q.deltaOffset = multiply(qu, [Da[0], Da[1], 0, 0], Zu);\n    }\n    return triggerEvent(r, \"onClip\", fillParams(r, t, {\n      clipEventType: \"changed\",\n      clipType: at,\n      poses: Rt,\n      clipStyle: Ma,\n      clipStyles: Wu,\n      distX: W,\n      distY: Y\n    })), !0;\n  },\n  dragControlEnd: function(r, t) {\n    this.unset(r);\n    var e = t.isDrag, o = t.datas, T = t.isDouble, S = o.isLine, N = o.isClipStart, D = o.isControl;\n    return N ? (triggerEvent(r, \"onClipEnd\", fillEndParams(r, t, {})), T && (D ? removeClipPath(r, t) : S && addClipPath(r, t)), T || e) : !1;\n  },\n  unset: function(r) {\n    r.state.clipPathState = \"\", r.state.snapBoundInfos = null;\n  }\n}, OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [`:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`],\n  dragControlCondition: function(r, t) {\n    return t.isRequest ? t.requestAble === \"originDraggable\" : hasClass(t.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function(r, t) {\n    var e = t.datas;\n    setDragStart(r, t);\n    var o = fillParams(r, t, {\n      dragStart: Draggable.dragStart(r, new CustomGesto().dragStart([0, 0], t))\n    }), T = triggerEvent(r, \"onDragOriginStart\", o);\n    return e.startOrigin = r.state.transformOrigin, e.startTargetOrigin = r.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, T === !1 ? (e.isDragOrigin = !1, !1) : o;\n  },\n  dragControl: function(r, t) {\n    var e = t.datas, o = t.isPinch, T = t.isRequest;\n    if (!e.isDragOrigin)\n      return !1;\n    var S = getDragDist(t), N = S[0], D = S[1], B = r.state, $ = B.width, U = B.height, z = B.offsetMatrix, V = B.targetMatrix, X = B.is3d, W = r.props.originRelative, Y = W === void 0 ? !0 : W, q = X ? 4 : 3, Z = [N, D];\n    if (T) {\n      var K = t.distOrigin;\n      (K[0] || K[1]) && (Z = K);\n    }\n    var J = plus(e.startOrigin, Z), tt = plus(e.startTargetOrigin, Z), et = minus(Z, e.prevOrigin), Q = getNextMatrix(z, V, J, q), at = r.getRect(), it = getRect(calculatePoses(Q, $, U, q)), st = [at.left - it.left, at.top - it.top];\n    e.prevOrigin = Z;\n    var ut = [convertCSSSize(tt[0], $, Y), convertCSSSize(tt[1], U, Y)].join(\" \"), ft = fillParams(r, t, {\n      width: $,\n      height: U,\n      origin: J,\n      dist: Z,\n      delta: et,\n      transformOrigin: ut,\n      drag: Draggable.drag(r, setCustomDrag(t, r.state, st, !!o, !1))\n    });\n    return triggerEvent(r, \"onDragOrigin\", ft), ft;\n  },\n  dragControlEnd: function(r, t) {\n    var e = t.datas;\n    return e.isDragOrigin ? (triggerEvent(r, \"onDragOriginEnd\", fillEndParams(r, t, {})), !0) : !1;\n  },\n  dragGroupControlCondition: function(r, t) {\n    return this.dragControlCondition(r, t);\n  },\n  dragGroupControlStart: function(r, t) {\n    var e = this.dragControlStart(r, t);\n    return !!e;\n  },\n  dragGroupControl: function(r, t) {\n    var e = this.dragControl(r, t);\n    return e ? (r.transformOrigin = e.transformOrigin, !0) : !1;\n  },\n  request: function(r) {\n    var t = {}, e = r.getRect(), o = 0, T = 0, S = e.transformOrigin, N = [0, 0];\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(D) {\n        return \"deltaOrigin\" in D ? (N[0] += D.deltaOrigin[0], N[1] += D.deltaOrigin[1]) : \"origin\" in D ? (N[0] = D.origin[0] - S[0], N[1] = D.origin[1] - S[1]) : (\"x\" in D ? o = D.x - e.left : \"deltaX\" in D && (o += D.deltaX), \"y\" in D ? T = D.y - e.top : \"deltaY\" in D && (T += D.deltaY)), {\n          datas: t,\n          distX: o,\n          distY: T,\n          distOrigin: N\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction addBorderRadius(r, t, e, o, T, S, N) {\n  var D = splitRadiusPoses(r), B = D.horizontals, $ = D.verticals, U = B.length, z = $.length, V = -1, X = -1;\n  e === 0 ? U === 0 ? V = 0 : U === 1 && (V = 1) : e === 3 && (U <= 2 ? V = 2 : U <= 3 && (V = 3)), e === 2 ? z === 0 ? X = 0 : z < 4 && (X = 3) : e === 1 && (z <= 1 ? X = 1 : z <= 2 && (X = 2)), addRadiusPos(r, t, 0, V, X, o, T, S, N);\n}\nfunction getBorderRadius(r, t, e, o, T) {\n  o === void 0 && (o = [0, 0]);\n  var S, N = [];\n  if (T)\n    S = T;\n  else {\n    var D = getComputedStyle$1$1(r);\n    S = D && D.borderRadius || \"\";\n  }\n  return !S || !T && S === \"0px\" ? N = [] : N = splitSpace(S), getRadiusValues(N, t, e, 0, 0, o);\n}\nfunction triggerRoundEvent(r, t, e, o, T, S) {\n  var N = r.state, D = N.width, B = N.height, $ = getRadiusStyles(S, T, r.props.roundRelative, D, B), U = $.raws, z = $.styles, V = splitRadiusPoses(T, U), X = V.horizontals, W = V.verticals, Y = z.join(\" \");\n  N.borderRadiusState = Y, triggerEvent(r, \"onRound\", fillParams(r, t, {\n    horizontals: X,\n    verticals: W,\n    borderRadius: Y,\n    width: D,\n    height: B,\n    delta: o,\n    dist: e\n  }));\n}\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\"\n  },\n  css: [`.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`, `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`],\n  render: function(r, t) {\n    var e = r.state, o = e.target, T = e.width, S = e.height, N = e.allMatrix, D = e.is3d, B = e.left, $ = e.top, U = e.borderRadiusState, z = r.props, V = z.minRoundControls, X = V === void 0 ? [0, 0] : V, W = z.maxRoundControls, Y = W === void 0 ? [4, 4] : W, q = z.zoom;\n    if (!o)\n      return null;\n    var Z = D ? 4 : 3, K = getBorderRadius(o, T, S, X, U);\n    if (!K)\n      return null;\n    var J = 0, tt = 0;\n    return K.map(function(et, Q) {\n      tt += Math.abs(et.horizontal), J += Math.abs(et.vertical);\n      var at = minus(calculatePosition(N, et.pos, Z), [B, $]), it = et.vertical ? J <= Y[1] : tt <= Y[0];\n      return t.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(Q),\n        className: prefix(\"control\", \"border-radius\"),\n        \"data-radius-index\": Q,\n        style: {\n          display: it ? \"block\" : \"none\",\n          transform: \"translate(\".concat(at[0], \"px, \").concat(at[1], \"px) scale(\").concat(q, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(r, t) {\n    if (!t.inputEvent || t.isRequest)\n      return !1;\n    var e = t.inputEvent.target.getAttribute(\"class\") || \"\";\n    return e.indexOf(\"border-radius\") > -1 || e.indexOf(\"moveable-line\") > -1 && e.indexOf(\"moveable-direction\") > -1;\n  },\n  dragControlStart: function(r, t) {\n    var e = t.inputEvent, o = t.datas, T = e.target, S = T.getAttribute(\"class\") || \"\", N = S.indexOf(\"border-radius\") > -1, D = S.indexOf(\"moveable-line\") > -1 && S.indexOf(\"moveable-direction\") > -1, B = N ? parseInt(T.getAttribute(\"data-radius-index\"), 10) : -1, $ = -1;\n    if (D) {\n      var U = T.getAttribute(\"data-line-key\") || \"\";\n      U && ($ = parseInt(U.replace(/render-line-/g, \"\"), 10), isNaN($) && ($ = -1));\n    }\n    if (!N && !D)\n      return !1;\n    var z = triggerEvent(r, \"onRoundStart\", fillParams(r, t, {}));\n    if (z === !1)\n      return !1;\n    o.lineIndex = $, o.controlIndex = B, o.isControl = N, o.isLine = D, setDragStart(r, t);\n    var V = r.props, X = V.roundRelative, W = V.minRoundControls, Y = W === void 0 ? [0, 0] : W, q = r.state, Z = q.target, K = q.width, J = q.height;\n    o.isRound = !0, o.prevDist = [0, 0];\n    var tt = getBorderRadius(Z, K, J, Y) || [];\n    return o.controlPoses = tt, q.borderRadiusState = getRadiusStyles(tt.map(function(et) {\n      return et.pos;\n    }), tt, X, K, J).styles.join(\" \"), !0;\n  },\n  dragControl: function(r, t) {\n    var e = t.datas;\n    if (!e.isRound || !e.isControl || !e.controlPoses.length)\n      return !1;\n    var o = e.controlIndex, T = e.controlPoses, S = getDragDist(t), N = S[0], D = S[1], B = [N, D], $ = minus(B, e.prevDist), U = r.props.maxRoundControls, z = U === void 0 ? [4, 4] : U, V = r.state, X = V.width, W = V.height, Y = T[o], q = Y.vertical, Z = Y.horizontal, K = T.map(function(tt) {\n      var et = tt.horizontal, Q = tt.vertical, at = [et * Z * B[0], Q * q * B[1]];\n      if (et) {\n        if (z[0] === 1)\n          return at;\n        if (z[0] < 4 && et !== Z)\n          return at;\n      } else {\n        if (z[1] === 0)\n          return at[1] = Q * Z * B[0] / X * W, at;\n        if (q) {\n          if (z[1] === 1)\n            return at;\n          if (z[1] < 4 && Q !== q)\n            return at;\n        }\n      }\n      return [0, 0];\n    });\n    K[o] = B;\n    var J = T.map(function(tt, et) {\n      return plus(tt.pos, K[et]);\n    });\n    return e.prevDist = [N, D], triggerRoundEvent(r, t, B, $, T, J), !0;\n  },\n  dragControlEnd: function(r, t) {\n    var e = r.state;\n    e.borderRadiusState = \"\";\n    var o = t.datas, T = t.isDouble;\n    if (!o.isRound)\n      return !1;\n    var S = e.width, N = e.height, D = o.isControl, B = o.controlIndex, $ = o.isLine, U = o.lineIndex, z = o.controlPoses, V = z.map(function(J) {\n      return J.pos;\n    }), X = V.length, W = r.props.roundClickable, Y = W === void 0 ? !0 : W;\n    if (T && Y) {\n      if (D)\n        removeRadiusPos(z, V, B, 0);\n      else if ($) {\n        var q = calculatePointerDist(r, t), Z = q[0], K = q[1];\n        addBorderRadius(z, V, U, Z, K, S, N);\n      }\n      X !== z.length && triggerRoundEvent(r, t, [0, 0], [0, 0], z, V);\n    }\n    return triggerEvent(r, \"onRoundEnd\", fillEndParams(r, t, {})), e.borderRadiusState = \"\", !0;\n  },\n  unset: function(r) {\n    r.state.borderRadiusState = \"\";\n  }\n};\nfunction isIdentityMatrix(r, t) {\n  var e = t ? 4 : 3, o = createIdentityMatrix(e), T = \"matrix\".concat(t ? \"3d\" : \"\", \"(\").concat(o.join(\",\"), \")\");\n  return r === T || r === \"matrix(1,0,0,1,0,0)\";\n}\nvar BeforeRenderable = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  setTransform: function(r, t) {\n    var e = r.state, o = e.is3d, T = e.target, S = e.targetMatrix, N = T == null ? void 0 : T.style.transform, D = o ? \"matrix3d(\".concat(S.join(\",\"), \")\") : \"matrix(\".concat(convertMatrixtoCSS(S, !0), \")\"), B = !N || N === \"none\" ? D : N;\n    t.datas.startTransforms = isIdentityMatrix(B, o) ? [] : splitSpace(B);\n  },\n  resetStyle: function(r) {\n    var t = r.datas;\n    t.nextStyle = {}, t.nextTransforms = r.datas.startTransforms, t.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(r, t) {\n    return fillParams(r, t, {\n      setTransform: function(e) {\n        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);\n      },\n      isPinch: !!t.isPinch\n    });\n  },\n  fillDragParams: function(r, t) {\n    return fillParams(r, t, {\n      isPinch: !!t.isPinch\n    });\n  },\n  dragStart: function(r, t) {\n    this.setTransform(r, t), triggerEvent(r, \"onBeforeRenderStart\", this.fillDragStartParams(r, t));\n  },\n  drag: function(r, t) {\n    this.resetStyle(t);\n    var e = t.datas;\n    e.nextStyle = {}, triggerEvent(r, \"onBeforeRender\", fillParams(r, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  dragEnd: function(r, t) {\n    triggerEvent(r, \"onBeforeRenderEnd\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    }));\n  },\n  dragGroupStart: function(r, t) {\n    var e = this;\n    this.dragStart(r, t);\n    var o = fillChildEvents(r, \"beforeRenderable\", t), T = r.moveables, S = o.map(function(N, D) {\n      var B = T[D];\n      return e.setTransform(B, N), e.fillDragStartParams(B, N);\n    });\n    triggerEvent(r, \"onBeforeRenderGroupStart\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      targets: r.props.targets,\n      setTransform: function() {\n      },\n      events: S\n    }));\n  },\n  dragGroup: function(r, t) {\n    var e = this;\n    this.drag(r, t);\n    var o = fillChildEvents(r, \"beforeRenderable\", t), T = r.moveables, S = o.map(function(N, D) {\n      var B = T[D];\n      e.resetStyle(N);\n      var $ = t.datas;\n      return $.nextStyle = {}, e.fillDragParams(B, N);\n    });\n    triggerEvent(r, \"onBeforeRenderGroup\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      targets: r.props.targets,\n      events: S\n    }));\n  },\n  dragGroupEnd: function(r, t) {\n    this.dragEnd(r, t), triggerEvent(r, \"onBeforeRenderGroupEnd\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: r.props.targets\n    }));\n  },\n  dragControlStart: function(r, t) {\n    return this.dragStart(r, t);\n  },\n  dragControl: function(r, t) {\n    return this.drag(r, t);\n  },\n  dragControlEnd: function(r, t) {\n    return this.dragEnd(r, t);\n  },\n  dragGroupControlStart: function(r, t) {\n    return this.dragGroupStart(r, t);\n  },\n  dragGroupControl: function(r, t) {\n    return this.dragGroup(r, t);\n  },\n  dragGroupControlEnd: function(r, t) {\n    return this.dragGroupEnd(r, t);\n  }\n}, Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragRelation: \"weak\",\n  dragStart: function(r, t) {\n    triggerEvent(r, \"onRenderStart\", fillParams(r, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  drag: function(r, t) {\n    triggerEvent(r, \"onRender\", this.fillDragParams(r, t));\n  },\n  dragAfter: function(r, t) {\n    if (t.resultCount)\n      return this.drag(r, t);\n  },\n  dragEnd: function(r, t) {\n    triggerEvent(r, \"onRenderEnd\", this.fillDragEndParams(r, t));\n  },\n  dragGroupStart: function(r, t) {\n    triggerEvent(r, \"onRenderGroupStart\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      targets: r.props.targets\n    }));\n  },\n  dragGroup: function(r, t) {\n    var e = this, o = fillChildEvents(r, \"beforeRenderable\", t), T = r.moveables, S = o.map(function(N, D) {\n      var B = T[D];\n      return e.fillDragParams(B, N);\n    });\n    triggerEvent(r, \"onRenderGroup\", fillParams(r, t, __assign$2(__assign$2({\n      isPinch: !!t.isPinch,\n      targets: r.props.targets,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))), {\n      events: S\n    })));\n  },\n  dragGroupEnd: function(r, t) {\n    var e = this, o = fillChildEvents(r, \"beforeRenderable\", t), T = r.moveables, S = o.map(function(N, D) {\n      var B = T[D];\n      return e.fillDragEndParams(B, N);\n    });\n    triggerEvent(r, \"onRenderGroupEnd\", fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: r.props.targets,\n      events: S\n    }));\n  },\n  dragControlStart: function(r, t) {\n    return this.dragStart(r, t);\n  },\n  dragControl: function(r, t) {\n    return this.drag(r, t);\n  },\n  dragControlAfter: function(r, t) {\n    return this.dragAfter(r, t);\n  },\n  dragControlEnd: function(r, t) {\n    return this.dragEnd(r, t);\n  },\n  dragGroupControlStart: function(r, t) {\n    return this.dragGroupStart(r, t);\n  },\n  dragGroupControl: function(r, t) {\n    return this.dragGroup(r, t);\n  },\n  dragGroupControlEnd: function(r, t) {\n    return this.dragGroupEnd(r, t);\n  },\n  fillDragParams: function(r, t) {\n    return fillParams(r, t, __assign$2({\n      isPinch: !!t.isPinch,\n      transform: getNextTransformText(t)\n    }, fillCSSObject(getNextStyle(t))));\n  },\n  fillDragEndParams: function(r, t) {\n    return fillParams(r, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    });\n  }\n};\nfunction triggerAble(r, t, e, o, T, S, N) {\n  var D = T === \"Start\", B = r.state.target, $ = S.isRequest;\n  if (!B || D && o.indexOf(\"Control\") > -1 && !$ && r.areaElement === S.inputEvent.target)\n    return !1;\n  var U = \"\".concat(e).concat(o).concat(T), z = \"\".concat(e).concat(o, \"Condition\"), V = T === \"End\", X = T === \"After\", W = D && (!r.targetGesto || !r.controlGesto || !r.targetGesto.isFlag() || !r.controlGesto.isFlag());\n  W && r.updateRect(T, !0, !1), T === \"\" && !$ && convertDragDist(r.state, S);\n  var Y = __spreadArray([], r[t], !0);\n  if ($) {\n    var q = S.requestAble;\n    Y.some(function(ct) {\n      return ct.name === q;\n    }) || Y.push.apply(Y, r.props.ables.filter(function(ct) {\n      return ct.name === q;\n    }));\n  }\n  if (!Y.length || Y.every(function(ct) {\n    return ct.dragRelation;\n  }))\n    return !1;\n  var Z = __spreadArray(__spreadArray([BeforeRenderable], Y, !0), [Renderable], !1).filter(function(ct) {\n    return ct[U];\n  }), K = S.datas;\n  W && Z.forEach(function(ct) {\n    ct.unset && ct.unset(r);\n  });\n  var J = S.inputEvent, tt;\n  V && J && (tt = document.elementFromPoint(S.clientX, S.clientY) || J.target);\n  var et = 0, Q = !1, at = function() {\n    var ct;\n    Q = !0, (ct = S.stop) === null || ct === void 0 || ct.call(S);\n  }, it = Z.filter(function(ct) {\n    var pt = ct.name, mt = K[pt] || (K[pt] = {});\n    if (D && (mt.isEventStart = !ct[z] || ct[z](r, S)), mt.isEventStart) {\n      var vt = ct[U](r, __assign$2(__assign$2({}, S), {\n        stop: at,\n        resultCount: et,\n        datas: mt,\n        originalDatas: K,\n        inputTarget: tt\n      }));\n      return r._emitter.off(), D && vt === !1 && (mt.isEventStart = !1), et += vt ? 1 : 0, vt;\n    }\n    return !1;\n  }), st = it.length, ut = !1;\n  if (D && (Q || Z.length && !st) && (ut = Q || Z.filter(function(ct) {\n    var pt = ct.name, mt = K[pt];\n    return mt.isEventStart ? ct.dragRelation !== \"strong\" : !1;\n  }).length), (V || ut) && (r.state.gestos = {}, r.moveables && r.moveables.forEach(function(ct) {\n    ct.state.gestos = {};\n  })), W && ut && Z.forEach(function(ct) {\n    ct.unset && ct.unset(r);\n  }), D && !ut && !$ && st && (S == null || S.preventDefault()), r.isUnmounted || ut)\n    return !1;\n  if (!D && st && !N || V) {\n    var ft = r.props.flushSync || defaultSync;\n    ft(function() {\n      r.updateRect(V ? T : \"\", !0, !1), r.forceUpdate();\n    });\n  }\n  return !D && !V && !X && st && !N && triggerAble(r, t, e, o, T + \"After\", S), !0;\n}\nfunction checkMoveableTarget(r) {\n  var t = r.props.dragTarget;\n  return function(e) {\n    var o = e.inputEvent.target, T = r.areaElement;\n    return t && (o === t || t.contains(o)) || o === T || !r.isMoveableElement(o) && !r.controlBox.getElement().contains(o) || hasClass(o, \"moveable-area\") || hasClass(o, \"moveable-padding\") || hasClass(o, \"moveable-edgeDraggable\");\n  };\n}\nfunction getTargetAbleGesto(r, t, e) {\n  var o = r.controlBox.getElement(), T = [], S = r.props.dragTarget;\n  return T.push(o), (!r.props.dragArea || S) && T.push(t), getAbleGesto(r, T, \"targetAbles\", e, {\n    dragStart: checkMoveableTarget(r),\n    pinchStart: checkMoveableTarget(r)\n  });\n}\nfunction getAbleGesto(r, t, e, o, T) {\n  T === void 0 && (T = {});\n  var S = e === \"targetAbles\", N = r.props, D = N.pinchOutside, B = N.pinchThreshold, $ = N.preventClickEventOnDrag, U = N.preventClickDefault, z = N.checkInput, V = {\n    preventDefault: !0,\n    preventRightClick: !0,\n    preventWheelClick: !0,\n    container: window,\n    pinchThreshold: B,\n    pinchOutside: D,\n    preventClickEventOnDrag: S ? $ : !1,\n    preventClickEventOnDragStart: S ? U : !1,\n    preventClickEventByCondition: S ? null : function(Y) {\n      return r.controlBox.getElement().contains(Y.target);\n    },\n    checkInput: S ? z : !1\n  }, X = new Gesto$1(t, V), W = o === \"Control\";\n  return [\"drag\", \"pinch\"].forEach(function(Y) {\n    [\"Start\", \"\", \"End\"].forEach(function(q) {\n      X.on(\"\".concat(Y).concat(q), function(Z) {\n        var K, J = Z.eventType;\n        if (T[J] && !T[J](Z)) {\n          Z.stop();\n          return;\n        }\n        var tt = triggerAble(r, e, Y, o, q, Z);\n        tt ? (r.props.stopPropagation || q === \"Start\" && W) && ((K = Z == null ? void 0 : Z.inputEvent) === null || K === void 0 || K.stopPropagation()) : Z.stop();\n      });\n    });\n  }), X;\n}\nvar EventManager = /* @__PURE__ */ function() {\n  function r(e, o, T) {\n    var S = this;\n    this.target = e, this.moveable = o, this.eventName = T, this.ables = [], this._onEvent = function(N) {\n      var D = S.eventName, B = S.moveable;\n      B.state.disableNativeEvent || S.ables.forEach(function($) {\n        $[D](B, {\n          inputEvent: N\n        });\n      });\n    }, e.addEventListener(T.toLowerCase(), this._onEvent);\n  }\n  var t = r.prototype;\n  return t.setAbles = function(e) {\n    this.ables = e;\n  }, t.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;\n  }, r;\n}();\nfunction getShadowRoot(r) {\n  if (r && r.getRootNode) {\n    var t = r.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction getMatrixStackInfo(r, t, e) {\n  for (var o = r, T = [], S = !e && r === t || r === document.body, N = S, D = !1, B = 3, $, U, z, V = !1, X = getOffsetInfo(t, t, !0).offsetParent; o && !N; ) {\n    N = S;\n    var W = getComputedStyle(o), Y = W.position, q = getElementTransform(o, W), Z = convertCSStoMatrix(getTransformMatrix(q)), K = Y === \"fixed\", J = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    K && (V = !0, J = getPositionFixedInfo(o), X = J.fixedContainer);\n    var tt = Z.length;\n    !D && tt === 16 && (D = !0, B = 4, convert3DMatrixes(T), z && (z = convertDimension(z, 3, 4))), D && tt === 9 && (Z = convertDimension(Z, 3, 4));\n    var et = getOffsetPosInfo(o, r, W), Q = et.tagName, at = et.hasOffset, it = et.isSVG, st = et.origin, ut = et.targetOrigin, ft = et.offset, ct = ft[0], pt = ft[1];\n    Q === \"svg\" && z && (T.push({\n      type: \"target\",\n      target: o,\n      matrix: getSVGMatrix(o, B)\n    }), T.push({\n      type: \"offset\",\n      target: o,\n      matrix: createIdentityMatrix(B)\n    }));\n    var mt = void 0, vt = !1, _t = !1;\n    if (K)\n      mt = J.fixedContainer, vt = !0;\n    else {\n      var xt = getOffsetInfo(o, t);\n      if (mt = xt.offsetParent, vt = xt.isEnd, _t = xt.isStatic, IS_FIREFOX) {\n        var Rt = xt.parentSlotElement;\n        if (Rt) {\n          for (var yt = mt, ht = 0, bt = 0; yt && getShadowRoot(yt); )\n            ht += yt.offsetLeft, bt += yt.offsetTop, yt = yt.offsetParent;\n          ct -= ht, pt -= bt;\n        }\n      }\n    }\n    IS_WEBKIT && !IS_SAFARI_ABOVE15 && at && !it && _t && (Y === \"relative\" || Y === \"static\") && (ct -= mt.offsetLeft, pt -= mt.offsetTop, S = S || vt);\n    var St = 0, Ot = 0, wt = 0, Ft = 0;\n    if (K)\n      at && J.hasTransform && (wt = mt.clientLeft, Ft = mt.clientTop);\n    else if (at && X !== mt && (St = mt.clientLeft, Ot = mt.clientTop), at && mt === document.body) {\n      var dt = getBodyOffset(o, !1, W);\n      ct += dt[0], pt += dt[1];\n    }\n    if (T.push({\n      type: \"target\",\n      target: o,\n      matrix: getAbsoluteMatrix(Z, B, st)\n    }), at) {\n      var Gt = o === r, Mt = Gt ? 0 : o.scrollLeft, Bt = Gt ? 0 : o.scrollTop;\n      T.push({\n        type: \"offset\",\n        target: o,\n        matrix: createOriginMatrix([ct - Mt + St - wt, pt - Bt + Ot - Ft], B)\n      });\n    } else\n      T.push({\n        type: \"offset\",\n        target: o,\n        origin: st\n      });\n    if (z || (z = Z), $ || ($ = st), U || (U = ut), N || K)\n      break;\n    o = mt, S = vt, (!e || o === document.body) && (N = S);\n  }\n  return z || (z = createIdentityMatrix(B)), $ || ($ = [0, 0]), U || (U = [0, 0]), {\n    offsetContainer: X,\n    matrixes: T,\n    targetMatrix: z,\n    transformOrigin: $,\n    targetOrigin: U,\n    is3d: D,\n    hasFixed: V\n  };\n}\nfunction calculateMatrixStack(r, t, e, o) {\n  var T;\n  e === void 0 && (e = t);\n  var S = getMatrixStackInfo(r, t), N = S.matrixes, D = S.is3d, B = S.targetMatrix, $ = S.transformOrigin, U = S.targetOrigin, z = S.offsetContainer, V = S.hasFixed, X = getMatrixStackInfo(z, e, !0), W = X.matrixes, Y = X.is3d, q = X.offsetContainer, Z = o || Y || D, K = Z ? 4 : 3, J = r.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in r, tt = B, et = createIdentityMatrix(K), Q = createIdentityMatrix(K), at = createIdentityMatrix(K), it = createIdentityMatrix(K), st = N.length;\n  W.reverse(), N.reverse(), !D && Z && (tt = convertDimension(tt, 3, 4), convert3DMatrixes(N)), !Y && Z && convert3DMatrixes(W), W.forEach(function(vt) {\n    Q = multiply(Q, vt.matrix, K);\n  });\n  var ut = e || document.body, ft = ((T = W[0]) === null || T === void 0 ? void 0 : T.target) || getOffsetInfo(ut, ut, !0).offsetParent, ct = W.slice(1).reduce(function(vt, _t) {\n    return multiply(vt, _t.matrix, K);\n  }, createIdentityMatrix(K));\n  N.forEach(function(vt, _t) {\n    if (st - 2 === _t && (at = et.slice()), st - 1 === _t && (it = et.slice()), !vt.matrix) {\n      var xt = N[_t + 1], Rt = getSVGOffset(vt, xt, ft, K, multiply(ct, et, K));\n      vt.matrix = createOriginMatrix(Rt, K);\n    }\n    et = multiply(et, vt.matrix, K);\n  });\n  var pt = !J && D;\n  tt || (tt = createIdentityMatrix(pt ? 4 : 3));\n  var mt = makeMatrixCSS(J && tt.length === 16 ? convertDimension(tt, 4, 3) : tt, pt);\n  return Q = ignoreDimension(Q, K, K), {\n    hasFixed: V,\n    rootMatrix: Q,\n    beforeMatrix: at,\n    offsetMatrix: it,\n    allMatrix: et,\n    targetMatrix: tt,\n    targetTransform: mt,\n    transformOrigin: $,\n    targetOrigin: U,\n    is3d: Z,\n    offsetContainer: z,\n    offsetRootContainer: q\n  };\n}\nfunction calculateElementInfo(r, t, e, o) {\n  e === void 0 && (e = t);\n  var T = 0, S = 0, N = 0, D = {}, B = getSize(r);\n  if (r && (T = B.offsetWidth, S = B.offsetHeight), r) {\n    var $ = calculateMatrixStack(r, t, e, o), U = calculateMoveablePosition($.allMatrix, $.transformOrigin, T, S);\n    D = __assign$2(__assign$2({}, $), U);\n    var z = calculateMoveablePosition($.allMatrix, [50, 50], 100, 100);\n    N = getRotationRad([z.pos1, z.pos2], z.direction);\n  }\n  var V = o ? 4 : 3;\n  return __assign$2(__assign$2(__assign$2({\n    width: T,\n    height: S,\n    rotation: N\n  }, B), {\n    rootMatrix: createIdentityMatrix(V),\n    beforeMatrix: createIdentityMatrix(V),\n    offsetMatrix: createIdentityMatrix(V),\n    allMatrix: createIdentityMatrix(V),\n    targetMatrix: createIdentityMatrix(V),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!o,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null\n  }), D);\n}\nfunction getMoveableTargetInfo(r, t, e, o, T) {\n  var S = 1, N = [0, 0], D = resetClientRect(), B = resetClientRect(), $ = resetClientRect(), U = resetClientRect(), z = calculateElementInfo(t, e, T, !0);\n  if (t) {\n    var V = z.is3d ? 4 : 3, X = calculateMoveablePosition(z.offsetMatrix, plus(z.transformOrigin, getOrigin(z.targetMatrix, V)), z.width, z.height);\n    S = X.direction, N = plus(X.origin, [X.left - z.left, X.top - z.top]), D = getClientRect(t);\n    var W = getOffsetInfo(o, o, !0).offsetParent || z.offsetRootContainer;\n    $ = getClientRect(W, !0), U = getClientRect(z.offsetRootContainer), r && (B = getClientRect(r));\n  }\n  return __assign$2({\n    targetClientRect: D,\n    containerClientRect: $,\n    moveableClientRect: B,\n    rootContainerClientRect: U,\n    beforeDirection: S,\n    beforeOrigin: N,\n    originalBeforeOrigin: N,\n    target: t\n  }, z);\n}\nvar MoveableManager$1 = /* @__PURE__ */ function(r) {\n  __extends$1(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.state = __assign$2({\n      container: null,\n      gestos: {},\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: !1\n    }, getMoveableTargetInfo(null)), o.renderState = {}, o.enabledAbles = [], o.targetAbles = [], o.controlAbles = [], o.rotation = 0, o.scale = [1, 1], o.isUnmounted = !1, o.events = {\n      mouseEnter: null,\n      mouseLeave: null\n    }, o._emitter = new EventEmitter$3(), o._prevTarget = null, o._prevDragArea = !1, o._isPropTargetChanged = !1, o._observer = null, o._observerId = 0, o.checkUpdateRect = function() {\n      if (!o.isDragging()) {\n        var T = o.props.parentMoveable;\n        if (T) {\n          T.checkUpdateRect();\n          return;\n        }\n        cancelAnimationFrame$1(o._observerId), o._observerId = requestAnimationFrame$1(function() {\n          o.isDragging() || o.updateRect();\n        });\n      }\n    }, o._onPreventClick = function(T) {\n      T.stopPropagation(), T.preventDefault();\n    }, o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this.props, T = this.state, S = o.parentPosition, N = o.className, D = o.target, B = o.zoom, $ = o.cspNonce, U = o.translateZ, z = o.cssStyled, V = o.portalContainer;\n    this.checkUpdate(), this.updateRenderPoses();\n    var X = S || [0, 0], W = X[0], Y = X[1], q = T.left, Z = T.top, K = T.target, J = T.direction, tt = T.hasFixed, et = o.targets, Q = (et && et.length || D) && K, at = this.isDragging(), it = {};\n    return this.getEnabledAbles().forEach(function(st) {\n      it[\"data-able-\".concat(st.name.toLowerCase())] = !0;\n    }), createElement(z, __assign$2({\n      cspNonce: $,\n      ref: ref(this, \"controlBox\"),\n      className: \"\".concat(prefix(\"control-box\", J === -1 ? \"reverse\" : \"\", at ? \"dragging\" : \"\"), \" \").concat(N)\n    }, it, {\n      onClick: this._onPreventClick,\n      portalContainer: V,\n      style: {\n        position: tt ? \"fixed\" : \"absolute\",\n        display: Q ? \"block\" : \"none\",\n        transform: \"translate3d(\".concat(q - W, \"px, \").concat(Z - Y, \"px, \").concat(U, \")\"),\n        \"--zoom\": B,\n        \"--zoompx\": \"\".concat(B, \"px\")\n      }\n    }), this.renderAbles(), this._renderLines());\n  }, e.componentDidMount = function() {\n    this.isUnmounted = !1, this.controlBox.getElement();\n    var o = this.props, T = o.parentMoveable, S = o.container, N = o.wrapperMoveable;\n    this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), !S && !T && !N && this.updateRect(\"\", !1, !0), this.updateCheckInput(), this._updateObserver(this.props);\n  }, e.componentDidUpdate = function(o) {\n    this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(o);\n  }, e.componentWillUnmount = function() {\n    this.isUnmounted = !0, this._emitter.off(), unset(this, \"targetGesto\"), unset(this, \"controlGesto\");\n    var o = this.events;\n    for (var T in o) {\n      var S = o[T];\n      S && S.destroy();\n    }\n  }, e.getAble = function(o) {\n    var T = this.props.ables || [];\n    return find$1(T, function(S) {\n      return S.name === o;\n    });\n  }, e.getContainer = function() {\n    var o = this.props, T = o.parentMoveable, S = o.wrapperMoveable, N = o.container;\n    return N || S && S.getContainer() || T && T.getContainer() || this.controlBox.getElement().parentElement;\n  }, e.isMoveableElement = function(o) {\n    var T;\n    return o && (((T = o.getAttribute) === null || T === void 0 ? void 0 : T.call(o, \"class\")) || \"\").indexOf(PREFIX) > -1;\n  }, e.dragStart = function(o) {\n    var T = this.targetGesto, S = this.controlGesto;\n    return T && checkMoveableTarget(this)({\n      inputEvent: o\n    }) ? T.isFlag() || T.triggerDragStart(o) : S && this.isMoveableElement(o.target) && (S.isFlag() || S.triggerDragStart(o)), this;\n  }, e.hitTest = function(o) {\n    var T = this.state, S = T.target, N = T.pos1, D = T.pos2, B = T.pos3, $ = T.pos4, U = T.targetClientRect;\n    if (!S)\n      return 0;\n    var z;\n    if (o instanceof Element) {\n      var V = o.getBoundingClientRect();\n      z = {\n        left: V.left,\n        top: V.top,\n        width: V.width,\n        height: V.height\n      };\n    } else\n      z = __assign$2({\n        width: 0,\n        height: 0\n      }, o);\n    var X = z.left, W = z.top, Y = z.width, q = z.height, Z = fitPoints([N, D, $, B], U), K = getOverlapSize(Z, [[X, W], [X + Y, W], [X + Y, W + q], [X, W + q]]), J = getAreaSize(Z);\n    return !K || !J ? 0 : Math.min(100, K / J * 100);\n  }, e.isInside = function(o, T) {\n    var S = this.state, N = S.target, D = S.pos1, B = S.pos2, $ = S.pos3, U = S.pos4, z = S.targetClientRect;\n    return N ? isInside([o, T], fitPoints([D, B, U, $], z)) : !1;\n  }, e.updateRect = function(o, T, S) {\n    S === void 0 && (S = !0);\n    var N = this.props, D = N.parentMoveable, B = this.state, $ = B.target || this.props.target, U = this.getContainer(), z = D ? D.props.rootContainer : N.rootContainer;\n    this.updateState(getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), $, U, U, z || U), D ? !1 : S);\n  }, e.isDragging = function() {\n    return (this.targetGesto ? this.targetGesto.isFlag() : !1) || (this.controlGesto ? this.controlGesto.isFlag() : !1);\n  }, e.updateTarget = function(o) {\n    this.updateRect(o, !0);\n  }, e.getRect = function() {\n    var o = this.state, T = getAbsolutePosesByState(this.state), S = T[0], N = T[1], D = T[2], B = T[3], $ = getRect(T), U = o.width, z = o.height, V = $.width, X = $.height, W = $.left, Y = $.top, q = [o.left, o.top], Z = plus(q, o.origin), K = plus(q, o.beforeOrigin), J = o.transformOrigin;\n    return {\n      width: V,\n      height: X,\n      left: W,\n      top: Y,\n      pos1: S,\n      pos2: N,\n      pos3: D,\n      pos4: B,\n      offsetWidth: U,\n      offsetHeight: z,\n      beforeOrigin: K,\n      origin: Z,\n      transformOrigin: J,\n      rotation: this.getRotation()\n    };\n  }, e.getManager = function() {\n    return this;\n  }, e.getRotation = function() {\n    var o = this.state, T = o.pos1, S = o.pos2, N = o.direction;\n    return getAbsoluteRotation(T, S, N);\n  }, e.request = function(o, T, S) {\n    T === void 0 && (T = {});\n    var N = this.props, D = N.ables, B = N.groupable, $ = D.filter(function(q) {\n      return q.name === o;\n    })[0];\n    if (this.isDragging() || !$ || !$.request)\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    var U = this, z = $.request(this), V = S || T.isInstant, X = z.isControl ? \"controlAbles\" : \"targetAbles\", W = \"\".concat(B ? \"Group\" : \"\").concat(z.isControl ? \"Control\" : \"\"), Y = {\n      request: function(q) {\n        return triggerAble(U, X, \"drag\", W, \"\", __assign$2(__assign$2({}, z.request(q)), {\n          requestAble: o,\n          isRequest: !0\n        }), V), this;\n      },\n      requestEnd: function() {\n        return triggerAble(U, X, \"drag\", W, \"End\", __assign$2(__assign$2({}, z.requestEnd()), {\n          requestAble: o,\n          isRequest: !0\n        }), V), this;\n      }\n    };\n    return triggerAble(U, X, \"drag\", W, \"Start\", __assign$2(__assign$2({}, z.requestStart(T)), {\n      requestAble: o,\n      isRequest: !0\n    }), V), V ? Y.request(T).requestEnd() : Y;\n  }, e.destroy = function() {\n    this.componentWillUnmount();\n  }, e.updateRenderPoses = function() {\n    var o = this.state, T = this.props, S = o.originalBeforeOrigin, N = o.transformOrigin, D = o.allMatrix, B = o.is3d, $ = o.pos1, U = o.pos2, z = o.pos3, V = o.pos4, X = o.left, W = o.top, Y = T.padding || {}, q = Y.left, Z = q === void 0 ? 0 : q, K = Y.top, J = K === void 0 ? 0 : K, tt = Y.bottom, et = tt === void 0 ? 0 : tt, Q = Y.right, at = Q === void 0 ? 0 : Q, it = B ? 4 : 3, st = T.groupable ? S : plus(S, [X, W]);\n    o.renderPoses = [plus($, calculatePadding(D, [-Z, -J], N, st, it)), plus(U, calculatePadding(D, [at, -J], N, st, it)), plus(z, calculatePadding(D, [-Z, et], N, st, it)), plus(V, calculatePadding(D, [at, et], N, st, it))];\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1;\n    var o = this.props, T = o.target, S = o.container, N = o.parentMoveable, D = this.state, B = D.target, $ = D.container;\n    if (!(!B && !T)) {\n      this.updateAbles();\n      var U = !equals(B, T), z = U || !equals($, S);\n      if (!!z) {\n        var V = S || this.controlBox;\n        V && this.unsetAbles(), this.updateState({\n          target: T,\n          container: S\n        }), !N && V && this.updateRect(\"End\", !1, !1), this._isPropTargetChanged = U;\n      }\n    }\n  }, e.waitToChangeTarget = function() {\n    return new Promise(function() {\n    });\n  }, e.triggerEvent = function(o, T) {\n    this._emitter.trigger(o, T);\n    var S = this.props[o];\n    return S && S(T);\n  }, e.useCSS = function(o, T) {\n    var S = this.props.customStyledMap, N = o + T;\n    return S[N] || (S[N] = styled(o, T)), S[N];\n  }, e.updateSelectors = function() {\n  }, e.unsetAbles = function() {\n    var o = this;\n    this.targetAbles.forEach(function(T) {\n      T.unset && T.unset(o);\n    });\n  }, e.updateAbles = function(o, T) {\n    o === void 0 && (o = this.props.ables), T === void 0 && (T = \"\");\n    var S = this.props, N = S.triggerAblesSimultaneously, D = o.filter(function(X) {\n      return X && (X.always && S[X.name] !== !1 || S[X.name]);\n    }), B = \"drag\".concat(T, \"Start\"), $ = \"pinch\".concat(T, \"Start\"), U = \"drag\".concat(T, \"ControlStart\"), z = filterAbles(D, [B, $], N), V = filterAbles(D, [U], N);\n    this.enabledAbles = D, this.targetAbles = z, this.controlAbles = V;\n  }, e.updateState = function(o, T) {\n    if (T) {\n      if (this.isUnmounted)\n        return;\n      this.setState(o);\n    } else {\n      var S = this.state;\n      for (var N in o)\n        S[N] = o[N];\n    }\n  }, e.getEnabledAbles = function() {\n    var o = this.props, T = o.ables;\n    return T.filter(function(S) {\n      return S && o[S.name];\n    });\n  }, e.renderAbles = function() {\n    var o = this, T = this.props, S = T.triggerAblesSimultaneously, N = {\n      createElement\n    };\n    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], S).map(function(D) {\n      var B = D.render;\n      return B(o, N) || [];\n    })).filter(function(D) {\n      return D;\n    }), function(D) {\n      var B = D.key;\n      return B;\n    }).map(function(D) {\n      return D[0];\n    });\n  }, e.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }, e._updateObserver = function(o) {\n    var T, S = this.props, N = S.target;\n    if (!window.ResizeObserver || !N || !S.useResizeObserver) {\n      (T = this._observer) === null || T === void 0 || T.disconnect();\n      return;\n    }\n    if (!(o.target === N && this._observer)) {\n      var D = new ResizeObserver(this.checkUpdateRect);\n      D.observe(N, {\n        box: \"border-box\"\n      }), this._observer = D;\n    }\n  }, e._updateEvents = function() {\n    var o = this.controlBox.getElement(), T = this.targetAbles.length, S = this.controlAbles.length, N = this.props, D = N.dragTarget || N.target, B = !T && this.targetGesto || this._isTargetChanged(!0);\n    B && (unset(this, \"targetGesto\"), this.updateState({\n      gesto: null\n    })), S || unset(this, \"controlGesto\"), D && T && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, D, \"\")), !this.controlGesto && S && (this.controlGesto = getAbleGesto(this, o, \"controlAbles\", \"Control\"));\n  }, e._updateTargets = function() {\n    var o = this.props;\n    this._prevTarget = o.dragTarget || o.target, this._prevDragArea = o.dragArea;\n  }, e._renderLines = function() {\n    var o = this.props, T = o, S = T.zoom, N = T.hideDefaultLines, D = T.hideChildMoveableDefaultLines, B = T.parentMoveable;\n    if (N || B && D)\n      return [];\n    var $ = this.state.renderPoses, U = {\n      createElement\n    };\n    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(z, V) {\n      var X = z[0], W = z[1];\n      return renderLine(U, \"\", $[X], $[W], S, \"render-line-\".concat(V));\n    });\n  }, e._isTargetChanged = function(o) {\n    var T = this.props, S = T.dragTarget || T.target, N = this._prevTarget, D = this._prevDragArea, B = T.dragArea, $ = !B && N !== S, U = (o || B) && D !== B;\n    return $ || U;\n  }, e._updateNativeEvents = function() {\n    var o = this, T = this.props, S = T.dragArea ? this.areaElement : this.state.target, N = this.events, D = getKeys(N);\n    if (this._isTargetChanged())\n      for (var B in N) {\n        var $ = N[B];\n        $ && $.destroy(), N[B] = null;\n      }\n    if (!!S) {\n      var U = this.enabledAbles;\n      D.forEach(function(z) {\n        var V = filterAbles(U, [z]), X = V.length > 0, W = N[z];\n        if (!X) {\n          W && (W.destroy(), N[z] = null);\n          return;\n        }\n        W || (W = new EventManager(S, o, z), N[z] = W), W.setAbles(V);\n      });\n    }\n  }, t.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: !0,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    parentPosition: null,\n    portalContainer: null,\n    useResizeObserver: !1,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: !1,\n    passDragArea: !1,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: !1,\n    padding: {},\n    pinchOutside: !0,\n    checkInput: !1,\n    groupable: !1,\n    hideDefaultLines: !1,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: !1,\n    preventClickDefault: !1,\n    preventClickEventOnDrag: !0,\n    flushSync: defaultSync\n  }, t;\n}(PureComponent), Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean,\n    targetGroups: Object,\n    hideChildMoveableDefaultLines: Boolean\n  },\n  events: {},\n  render: function(r, t) {\n    var e = r.props.targets || [];\n    r.moveables = [];\n    var o = r.state, T = o.left, S = o.top, N = [T, S], D = r.props, B = D.zoom || 1, $ = r.renderGroupRects;\n    return __spreadArray(__spreadArray([], e.map(function(U, z) {\n      return t.createElement(MoveableManager$1, {\n        key: \"moveable\" + z,\n        ref: refs(r, \"moveables\", z),\n        target: U,\n        origin: !1,\n        cssStyled: D.cssStyled,\n        customStyledMap: D.customStyledMap,\n        useResizeObserver: D.useResizeObserver,\n        hideChildMoveableDefaultLines: D.hideChildMoveableDefaultLines,\n        parentMoveable: r,\n        parentPosition: N,\n        zoom: B\n      });\n    }), !0), flat($.map(function(U, z) {\n      var V = U.pos1, X = U.pos2, W = U.pos3, Y = U.pos4, q = [V, X, W, Y];\n      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(Z, K) {\n        var J = Z[0], tt = Z[1];\n        return renderLine(t, \"\", minus(q[J], N), minus(q[tt], N), B, \"group-rect-\".concat(z, \"-\").concat(K));\n      });\n    })), !0);\n  }\n}, Clickable = makeAble(\"clickable\", {\n  props: {\n    clickable: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: !0,\n  dragRelation: \"weak\",\n  dragStart: function() {\n  },\n  dragControlStart: function() {\n  },\n  dragGroupStart: function(r, t) {\n    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;\n  },\n  dragEnd: function(r, t) {\n    var e = r.props.target, o = t.inputEvent, T = t.inputTarget, S = r.isMoveableElement(T), N = !S && r.controlBox.getElement().contains(T);\n    if (!(!o || !T || t.isDrag || r.isMoveableElement(T) || N)) {\n      var D = e.contains(T);\n      triggerEvent(r, \"onClick\", fillParams(r, t, {\n        isDouble: t.isDouble,\n        inputTarget: T,\n        isTarget: e === T,\n        moveableTarget: r.props.target,\n        containsTarget: D\n      }));\n    }\n  },\n  dragGroupEnd: function(r, t) {\n    var e = t.inputEvent, o = t.inputTarget;\n    if (!(!e || !o || t.isDrag || r.isMoveableElement(o) || t.datas.inputTarget === o)) {\n      var T = r.props.targets, S = T.indexOf(o), N = S > -1, D = !1;\n      S === -1 && (S = findIndex(T, function(B) {\n        return B.contains(o);\n      }), D = S > -1), triggerEvent(r, \"onClickGroup\", fillParams(r, t, {\n        isDouble: t.isDouble,\n        targets: T,\n        inputTarget: o,\n        targetIndex: S,\n        isTarget: N,\n        containsTarget: D,\n        moveableTarget: T[S]\n      }));\n    }\n  },\n  dragControlEnd: function(r, t) {\n    this.dragEnd(r, t);\n  },\n  dragGroupControlEnd: function(r, t) {\n    this.dragEnd(r, t);\n  }\n});\nfunction getDraggableEvent(r) {\n  var t = r.originalDatas.draggable;\n  return t || (r.originalDatas.draggable = {}, t = r.originalDatas.draggable), __assign$2(__assign$2({}, r), {\n    datas: t\n  });\n}\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  css: [`.edge.edgeDraggable.line {\n    cursor: move;\n}`],\n  render: function(r, t) {\n    var e = r.props, o = e.edgeDraggable;\n    return o ? renderEdgeLines(t, \"edgeDraggable\", o, r.state.renderPoses, e.zoom) : [];\n  },\n  dragControlCondition: function(r, t) {\n    if (!r.props.edgeDraggable || !t.inputEvent)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"edge\")) && hasClass(e, prefix(\"edgeDraggable\"));\n  },\n  dragControlStart: function(r, t) {\n    return r.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, Draggable.dragStart(r, getDraggableEvent(t));\n  },\n  dragControl: function(r, t) {\n    return Draggable.drag(r, getDraggableEvent(t));\n  },\n  dragControlEnd: function(r, t) {\n    return Draggable.dragEnd(r, getDraggableEvent(t));\n  },\n  dragGroupControlCondition: function(r, t) {\n    if (!r.props.edgeDraggable || !t.inputEvent)\n      return !1;\n    var e = t.inputEvent.target;\n    return hasClass(e, prefix(\"direction\")) && hasClass(e, prefix(\"line\"));\n  },\n  dragGroupControlStart: function(r, t) {\n    return Draggable.dragGroupStart(r, getDraggableEvent(t));\n  },\n  dragGroupControl: function(r, t) {\n    return Draggable.dragGroup(r, getDraggableEvent(t));\n  },\n  dragGroupControlEnd: function(r, t) {\n    return Draggable.dragGroupEnd(r, getDraggableEvent(t));\n  },\n  unset: function(r) {\n    return Draggable.unset(r);\n  }\n}), IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean\n  },\n  events: {}\n}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(r, t) {\n  return __assign$2(__assign$2({}, r), \"events\" in t ? t.events : {});\n}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(r, t) {\n  return __assign$2(__assign$2({}, r), t.props);\n}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nfunction solveConstantsDistance(r, t) {\n  var e = r[0], o = r[1], T = r[2];\n  return (e * t[0] + o * t[1] + T) / Math.sqrt(e * e + o * o);\n}\nfunction solveC(r, t) {\n  var e = r[0], o = r[1];\n  return -e * t[0] - o * t[1];\n}\nfunction getMaxPos(r, t) {\n  return Math.max.apply(Math, r.map(function(e) {\n    var o = e[0], T = e[1], S = e[2], N = e[3];\n    return Math.max(o[t], T[t], S[t], N[t]);\n  }));\n}\nfunction getMinPos(r, t) {\n  return Math.min.apply(Math, r.map(function(e) {\n    var o = e[0], T = e[1], S = e[2], N = e[3];\n    return Math.min(o[t], T[t], S[t], N[t]);\n  }));\n}\nfunction getGroupRect(r, t) {\n  var e, o = [0, 0], T = [0, 0], S = [0, 0], N = [0, 0], D = 0, B = 0;\n  if (!r.length)\n    return {\n      pos1: o,\n      pos2: T,\n      pos3: S,\n      pos4: N,\n      minX: 0,\n      minY: 0,\n      width: D,\n      height: B,\n      rotation: t\n    };\n  var $ = throttle(t, TINY_NUM);\n  if ($ % 90) {\n    var U = $ / 180 * Math.PI, z = Math.tan(U), V = -1 / z, X = [MAX_NUM, MIN_NUM], W = [[0, 0], [0, 0]], Y = [MAX_NUM, MIN_NUM], q = [[0, 0], [0, 0]];\n    r.forEach(function(xt) {\n      xt.forEach(function(Rt) {\n        var yt = solveConstantsDistance([-z, 1, 0], Rt), ht = solveConstantsDistance([-V, 1, 0], Rt);\n        X[0] > yt && (W[0] = Rt, X[0] = yt), X[1] < yt && (W[1] = Rt, X[1] = yt), Y[0] > ht && (q[0] = Rt, Y[0] = ht), Y[1] < ht && (q[1] = Rt, Y[1] = ht);\n      });\n    });\n    var Z = W[0], K = W[1], J = q[0], tt = q[1], et = [-z, 1, solveC([-z, 1], Z)], Q = [-z, 1, solveC([-z, 1], K)], at = [-V, 1, solveC([-V, 1], J)], it = [-V, 1, solveC([-V, 1], tt)];\n    e = [[et, at], [et, it], [Q, at], [Q, it]].map(function(xt) {\n      var Rt = xt[0], yt = xt[1];\n      return getIntersectionPointsByConstants(Rt, yt)[0];\n    }), o = e[0], T = e[1], S = e[2], N = e[3], D = Y[1] - Y[0], B = X[1] - X[0];\n  } else {\n    var st = getMinPos(r, 0), ut = getMinPos(r, 1), ft = getMaxPos(r, 0), ct = getMaxPos(r, 1);\n    if (o = [st, ut], T = [ft, ut], S = [st, ct], N = [ft, ct], D = ft - st, B = ct - ut, $ % 180) {\n      var pt = [S, o, N, T];\n      o = pt[0], T = pt[1], S = pt[2], N = pt[3], D = ct - ut, B = ft - st;\n    }\n  }\n  if ($ % 360 > 180) {\n    var pt = [N, S, T, o];\n    o = pt[0], T = pt[1], S = pt[2], N = pt[3];\n  }\n  var mt = getMinMaxs([o, T, S, N]), vt = mt.minX, _t = mt.minY;\n  return {\n    pos1: o,\n    pos2: T,\n    pos3: S,\n    pos4: N,\n    width: D,\n    height: B,\n    minX: vt,\n    minY: _t,\n    rotation: t\n  };\n}\nfunction findMoveableGroups(r, t) {\n  var e = t.map(function(o) {\n    if (isArray(o)) {\n      var T = findMoveableGroups(r, o), S = T.length;\n      return S > 1 ? T : S === 1 ? T[0] : null;\n    } else {\n      var N = find$1(r, function(D) {\n        var B = D.manager;\n        return B.props.target === o;\n      });\n      return N ? (N.finded = !0, N.manager) : null;\n    }\n  }).filter(Boolean);\n  return e.length === 1 && isArray(e[0]) ? e[0] : e;\n}\nvar MoveableGroup = /* @__PURE__ */ function(r) {\n  __extends$1(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.differ = new ChildrenDiffer$1(), o.moveables = [], o.transformOrigin = \"50% 50%\", o.renderGroupRects = [], o;\n  }\n  var e = t.prototype;\n  return e.checkUpdate = function() {\n    this._isPropTargetChanged = !1, this.updateAbles();\n  }, e.updateRect = function(o, T, S) {\n    if (S === void 0 && (S = !0), !this.controlBox)\n      return;\n    this.moveables.forEach(function(yt) {\n      yt.updateRect(o, !1, !1);\n    });\n    var N = this.state, D = this.props, B = this.moveables, $ = N.target || D.target, U = B.map(function(yt) {\n      return {\n        finded: !1,\n        manager: yt\n      };\n    }), z = findMoveableGroups(U, this.props.targetGroups || []);\n    z.push.apply(z, U.filter(function(yt) {\n      var ht = yt.finded;\n      return !ht;\n    }).map(function(yt) {\n      var ht = yt.manager;\n      return ht;\n    }));\n    var V = [], X = !T || o !== \"\" && D.updateGroup;\n    function W(yt, ht, bt) {\n      var St = yt.map(function(Bt) {\n        if (isArray(Bt)) {\n          var Dt = W(Bt, ht), Et = [Dt.pos1, Dt.pos2, Dt.pos3, Dt.pos4];\n          return V.push(Dt), {\n            poses: Et,\n            rotation: Dt.rotation\n          };\n        } else\n          return {\n            poses: getAbsolutePosesByState(Bt.state),\n            rotation: Bt.getRotation()\n          };\n      }), Ot = St.map(function(Bt) {\n        var Dt = Bt.rotation;\n        return Dt;\n      }), wt = 0, Ft = Ot[0], dt = Ot.every(function(Bt) {\n        return Math.abs(Ft - Bt) < 0.1;\n      });\n      X ? wt = dt ? Ft : D.defaultGroupRotate || 0 : wt = !bt && dt ? Ft : ht;\n      var Gt = St.map(function(Bt) {\n        var Dt = Bt.poses;\n        return Dt;\n      }), Mt = getGroupRect(Gt, wt);\n      return Mt;\n    }\n    var Y = W(z, this.rotation, !0);\n    X && (this.rotation = Y.rotation, this.transformOrigin = D.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]), this.renderGroupRects = V;\n    var q = this.rotation, Z = this.scale, K = Y.width, J = Y.height, tt = Y.minX, et = Y.minY, Q = \"rotate(\".concat(q, \"deg) scale(\").concat(Z[0] >= 0 ? 1 : -1, \", \").concat(Z[1] >= 0 ? 1 : -1, \")\");\n    $.style.cssText += \"left:0px;top:0px; transform-origin: \".concat(this.transformOrigin, \"; width:\").concat(K, \"px; height:\").concat(J, \"px;\") + \"transform:\".concat(Q), N.width = K, N.height = J;\n    var at = this.getContainer(), it = getMoveableTargetInfo(this.controlBox.getElement(), $, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || at), st = [it.left, it.top], ut = getAbsolutePosesByState(it), ft = ut[0], ct = ut[1], pt = ut[2], mt = ut[3], vt = getMinMaxs([ft, ct, pt, mt]), _t = [vt.minX, vt.minY];\n    it.pos1 = minus(ft, _t), it.pos2 = minus(ct, _t), it.pos3 = minus(pt, _t), it.pos4 = minus(mt, _t), it.left = tt - it.left + _t[0], it.top = et - it.top + _t[1], it.origin = minus(plus(st, it.origin), _t), it.beforeOrigin = minus(plus(st, it.beforeOrigin), _t), it.originalBeforeOrigin = plus(st, it.originalBeforeOrigin);\n    var xt = it.targetClientRect, Rt = Z[0] * Z[1] > 0 ? 1 : -1;\n    xt.top += it.top - N.top, xt.left += it.left - N.left, $.style.transform = \"translate(\".concat(-_t[0], \"px, \").concat(-_t[1], \"px) \").concat(Q), this.updateState(__assign$2(__assign$2({}, it), {\n      direction: Rt,\n      beforeDirection: Rt\n    }), S);\n  }, e.getRect = function() {\n    return __assign$2(__assign$2({}, r.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(o) {\n        return o.getRect();\n      })\n    });\n  }, e.triggerEvent = function(o, T, S) {\n    if (S || o.indexOf(\"Group\") > -1)\n      return r.prototype.triggerEvent.call(this, o, T);\n    this._emitter.trigger(o, T);\n  }, e.updateAbles = function() {\n    r.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), \"Group\");\n  }, e._updateTargets = function() {\n    r.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;\n  }, e._updateEvents = function() {\n    var o = this.state, T = this.props, S = this._prevTarget, N = T.dragTarget || this.areaElement;\n    S !== N && (unset(this, \"targetGesto\"), unset(this, \"controlGesto\"), o.target = null), o.target || (o.target = this.areaElement, this.controlBox.getElement().style.display = \"block\"), o.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, N, \"Group\")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\")));\n    var D = !equals(o.container, T.container);\n    D && (o.container = T.container);\n    var B = this.differ.update(T.targets), $ = B.added, U = B.changed, z = B.removed, V = $.length || z.length;\n    (D || V || U.length) && this.updateRect(), this._isPropTargetChanged = !!V;\n  }, e._updateObserver = function() {\n  }, t.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: !0,\n    dragArea: !0,\n    keepRatio: !0,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  }), t;\n}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(r) {\n  __extends$1(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.moveables = [], o;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var o = this, T = this.props, S = T.cspNonce, N = T.cssStyled, D = T.targets;\n    return createElement(N, {\n      cspNonce: S,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, D.map(function(B, $) {\n      return createElement(MoveableManager$1, __assign$2({\n        key: \"moveable\" + $,\n        ref: refs(o, \"moveables\", $)\n      }, o.props, {\n        target: B,\n        wrapperMoveable: o\n      }));\n    }));\n  }, e.componentDidUpdate = function() {\n  }, e.updateRect = function(o, T, S) {\n    S === void 0 && (S = !0), this.moveables.forEach(function(N) {\n      N.updateRect(o, T, S);\n    });\n  }, e.getRect = function() {\n    return __assign$2(__assign$2({}, r.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(o) {\n        return o.getRect();\n      })\n    });\n  }, e.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  }, e.dragStart = function() {\n    return this;\n  }, e.hitTest = function() {\n    return 0;\n  }, e.isInside = function() {\n    return !1;\n  }, e.isDragging = function() {\n    return !1;\n  }, e.updateRenderPoses = function() {\n  }, e.checkUpdate = function() {\n  }, e.triggerEvent = function() {\n  }, e.updateAbles = function() {\n  }, e._updateEvents = function() {\n  }, e._updateObserver = function() {\n  }, t;\n}(MoveableManager$1);\nfunction getElementTargets(r, t) {\n  var e = [];\n  return r.forEach(function(o) {\n    if (!!o) {\n      if (isString$1(o)) {\n        t[o] && e.push.apply(e, t[o]);\n        return;\n      }\n      isArray(o) ? e.push.apply(e, getElementTargets(o, t)) : e.push(o);\n    }\n  }), e;\n}\nfunction getTargetGroups(r, t) {\n  var e = [];\n  return r.forEach(function(o) {\n    if (!!o) {\n      if (isString$1(o)) {\n        t[o] && e.push.apply(e, t[o]);\n        return;\n      }\n      isArray(o) ? e.push(getTargetGroups(o, t)) : e.push(o);\n    }\n  }), e;\n}\nfunction compareRefTargets(r, t) {\n  return r.length !== t.length || r.some(function(e, o) {\n    var T = t[o];\n    return !e && !T ? !1 : e != T ? isArray(e) && isArray(T) ? compareRefTargets(e, T) : !0 : !1;\n  });\n}\nvar InitialMoveable = /* @__PURE__ */ function(r) {\n  __extends$1(t, r);\n  function t() {\n    var o = r !== null && r.apply(this, arguments) || this;\n    return o.refTargets = [], o.selectorMap = {}, o._differ = new ChildrenDiffer$1(), o._elementTargets = [], o._onChangetarget = null, o;\n  }\n  var e = t.prototype;\n  return t.makeStyled = function() {\n    var o = {}, T = this.getTotalAbles();\n    T.forEach(function(N) {\n      var D = N.css;\n      !D || D.forEach(function(B) {\n        o[B] = !0;\n      });\n    });\n    var S = getKeys(o).join(`\n`);\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + S));\n  }, t.getTotalAbles = function() {\n    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);\n  }, e.render = function() {\n    var o = this.constructor;\n    o.defaultStyled || o.makeStyled();\n    var T = this.props, S = T.ables, N = T.props, D = __rest(T, [\"ables\", \"props\"]), B = this._updateRefs(!0), $ = getElementTargets(B, this.selectorMap), U = $.length > 1, z = o.getTotalAbles(), V = __spreadArray(__spreadArray([], z, !0), S || [], !0), X = __assign$2(__assign$2(__assign$2({}, D), N || {}), {\n      ables: V,\n      cssStyled: o.defaultStyled,\n      customStyledMap: o.customStyledMap\n    });\n    if (this._elementTargets = $, U) {\n      if (D.individualGroupable)\n        return createElement(MoveableIndividualGroup, __assign$2({\n          key: \"individual-group\",\n          ref: ref(this, \"moveable\")\n        }, X, {\n          target: null,\n          targets: $\n        }));\n      var W = getTargetGroups(B, this.selectorMap);\n      return createElement(MoveableGroup, __assign$2({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, X, {\n        target: null,\n        targets: $,\n        targetGroups: W\n      }));\n    } else\n      return createElement(MoveableManager$1, __assign$2({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, X, {\n        target: $[0]\n      }));\n  }, e.componentDidMount = function() {\n    this._updateRefs();\n  }, e.componentDidUpdate = function() {\n    var o = this._differ.update(this._elementTargets), T = o.added, S = o.removed, N = T.length || S.length;\n    N && this._onChangetarget && this._onChangetarget(), this._updateRefs();\n  }, e.componentWillUnmount = function() {\n    this.selectorMap = {}, this.refTargets = [];\n  }, e.updateSelectors = function() {\n    this.selectorMap = {}, this._updateRefs();\n  }, e.waitToChangeTarget = function() {\n    var o = this, T;\n    return this._onChangetarget = function() {\n      o._onChangetarget = null, T();\n    }, new Promise(function(S) {\n      T = S;\n    });\n  }, e.getManager = function() {\n    return this.moveable;\n  }, e._updateRefs = function(o) {\n    var T = this.refTargets, S = getRefTargets(this.props.target || this.props.targets), N = typeof document < \"u\", D = compareRefTargets(T, S), B = this.selectorMap, $ = {};\n    return this.refTargets.forEach(function U(z) {\n      if (isString$1(z)) {\n        var V = B[z];\n        V ? $[z] = B[z] : N && (D = !0, $[z] = [].slice.call(document.querySelectorAll(z)));\n      } else\n        isArray(z) && z.forEach(U);\n    }), this.refTargets = S, this.selectorMap = $, !o && D && this.forceUpdate(), S;\n  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, \"moveable\", void 0), t;\n}(PureComponent), Moveable$1 = /* @__PURE__ */ function(r) {\n  __extends$1(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  return t.defaultAbles = MOVEABLE_ABLES, t;\n}(InitialMoveable), Moveable$2 = Moveable$1;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(r, t) {\n  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {\n    e.__proto__ = o;\n  } || function(e, o) {\n    for (var T in o)\n      o.hasOwnProperty(T) && (e[T] = o[T]);\n  }, extendStatics(r, t);\n};\nfunction __extends(r, t) {\n  extendStatics(r, t);\n  function e() {\n    this.constructor = r;\n  }\n  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar __assign$1 = function() {\n  return __assign$1 = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign$1.apply(this, arguments);\n};\nfunction __decorate(r, t, e, o) {\n  var T = arguments.length, S = T < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, N;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    S = Reflect.decorate(r, t, e, o);\n  else\n    for (var D = r.length - 1; D >= 0; D--)\n      (N = r[D]) && (S = (T < 3 ? N(S) : T > 3 ? N(t, e, S) : N(t, e)) || S);\n  return T > 3 && S && Object.defineProperty(t, e, S), S;\n}\nvar InnerMoveable = /* @__PURE__ */ function(r) {\n  __extends(t, r);\n  function t(o) {\n    var T = r.call(this, o) || this;\n    return T.state = {}, T.state = T.props, T;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    return createPortal(createElement(Moveable$2, __assign$1({\n      ref: ref(this, \"moveable\")\n    }, this.state)), this.state.parentElement);\n  }, t;\n}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign = function() {\n  return __assign = Object.assign || function(t) {\n    for (var e, o = 1, T = arguments.length; o < T; o++) {\n      e = arguments[o];\n      for (var S in e)\n        Object.prototype.hasOwnProperty.call(e, S) && (t[S] = e[S]);\n    }\n    return t;\n  }, __assign.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var r = 0, t = 0, e = arguments.length; t < e; t++)\n    r += arguments[t].length;\n  for (var o = Array(r), T = 0, t = 0; t < e; t++)\n    for (var S = arguments[t], N = 0, D = S.length; N < D; N++, T++)\n      o[T] = S[N];\n  return o;\n}\nvar EventEmitter = /* @__PURE__ */ function() {\n  function r() {\n    this._events = {};\n  }\n  var t = r.prototype;\n  return t.on = function(e, o) {\n    if (isObject$2(e))\n      for (var T in e)\n        this.on(T, e[T]);\n    else\n      this._addEvent(e, o, {});\n    return this;\n  }, t.off = function(e, o) {\n    if (!e)\n      this._events = {};\n    else if (isObject$2(e))\n      for (var T in e)\n        this.off(T);\n    else if (!o)\n      this._events[e] = [];\n    else {\n      var S = this._events[e];\n      if (S) {\n        var N = findIndex(S, function(D) {\n          return D.listener === o;\n        });\n        N > -1 && S.splice(N, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, o) {\n    var T = this;\n    return o && this._addEvent(e, o, {\n      once: !0\n    }), new Promise(function(S) {\n      T._addEvent(e, S, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, o) {\n    var T = this;\n    o === void 0 && (o = {});\n    var S = this._events[e];\n    if (!e || !S)\n      return !0;\n    var N = !1;\n    return o.eventType = e, o.stop = function() {\n      N = !0;\n    }, o.currentTarget = this, __spreadArrays(S).forEach(function(D) {\n      D.listener(o), D.once && T.off(e, D.listener);\n    }), !N;\n  }, t.trigger = function(e, o) {\n    return o === void 0 && (o = {}), this.emit(e, o);\n  }, t._addEvent = function(e, o, T) {\n    var S = this._events;\n    S[e] = S[e] || [];\n    var N = S[e];\n    N.push(__assign({\n      listener: o\n    }, T));\n  }, r;\n}(), EventEmitter$1 = EventEmitter, MoveableManager = /* @__PURE__ */ function(r) {\n  __extends(t, r);\n  function t(o, T) {\n    T === void 0 && (T = {});\n    var S = r.call(this) || this;\n    S.tempElement = document.createElement(\"div\");\n    var N = __assign$1({}, T), D = {};\n    EVENTS.forEach(function($) {\n      D[camelize(\"on \".concat($))] = function(U) {\n        return S.trigger($, U);\n      };\n    }), render(createElement(InnerMoveable, __assign$1({\n      ref: ref(S, \"innerMoveable\"),\n      parentElement: o\n    }, N, D)), S.tempElement);\n    var B = N.target;\n    return isArray(B) && B.length > 1 && S.updateRect(), S;\n  }\n  var e = t.prototype;\n  return e.setState = function(o, T) {\n    this.innerMoveable.setState(o, T);\n  }, e.forceUpdate = function(o) {\n    this.innerMoveable.forceUpdate(o);\n  }, e.dragStart = function(o) {\n    var T = this.innerMoveable;\n    T.$_timer && this.forceUpdate(), this.getMoveable().dragStart(o);\n  }, e.destroy = function() {\n    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;\n  }, e.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  }, t = __decorate([Properties(METHODS, function(o, T) {\n    o[T] || (o[T] = function() {\n      for (var S = [], N = 0; N < arguments.length; N++)\n        S[N] = arguments[N];\n      var D = this.getMoveable();\n      if (!(!D || !D[T]))\n        return D[T].apply(D, S);\n    });\n  }), Properties(PROPERTIES, function(o, T) {\n    Object.defineProperty(o, T, {\n      get: function() {\n        return this.getMoveable().props[T];\n      },\n      set: function(S) {\n        var N;\n        this.setState((N = {}, N[T] = S, N));\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  })], t), t;\n}(EventEmitter$1), Moveable = /* @__PURE__ */ function(r) {\n  __extends(t, r);\n  function t() {\n    return r !== null && r.apply(this, arguments) || this;\n  }\n  return t;\n}(MoveableManager), Hr, ks, $s, Us, Gs, bo, En, xn, Eo, Xc;\nconst jt = class {\n  constructor(t, e = !1) {\n    rt(this, Eo);\n    Pt(this, \"hArg\", {});\n    Pt(this, \"id_tag\", \"\");\n    Pt(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0\n    });\n    Pt(this, \"child\");\n    Pt(this, \"parent\");\n    Pt(this, \"fncLay\", () => {\n    });\n    Pt(this, \"mov\");\n    Pt(this, \"div\");\n    Pt(this, \"lx\", 0);\n    Pt(this, \"ly\", 0);\n    Pt(this, \"rect\", Rectangle.EMPTY);\n    Pt(this, \"pivot\", new Point(0, 0));\n    Pt(this, \"scale\", new Point(1, 1));\n    Pt(this, \"rotation\", 0);\n    Pt(this, \"oldFn\", () => \"\");\n    Pt(this, \"rotatable\", !0);\n    this.bg_col = t, this.isLay = e;\n  }\n  static init(t, e, o, T, S, N, D) {\n    t.view.insertAdjacentHTML(\"beforebegin\", `<div id=\"${H(jt, Gs)}\" style=\"width: ${CmnLib.stageW * jt.sys.cvsScale}px; height: ${CmnLib.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`), nt(jt, Hr, document.getElementById(H(jt, Gs))), jt.divHint.classList.add(\"sn_design_hint\"), t.view.parentElement.appendChild(jt.divHint), jt.sys = e, nt(jt, ks, o), jt.prpPrs = T, nt(jt, $s, S), nt(jt, Us, N), jt.hPages = D, addStyle(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(t, e, o, T) {\n    jt.divHint.innerHTML = t;\n    const S = window.getComputedStyle(jt.divHint), N = parseFloat(S.width), D = parseFloat(S.height);\n    jt.divHint.style.cssText = `display: block; left: ${Math.max(10, T.lx + e - N)}px;\n\t\ttop: ${Math.max(10, T.ly + o - D - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const t = H(jt, Hr).style;\n    t.width = `${CmnLib.stageW * jt.sys.cvsScale}px`, t.height = `${CmnLib.stageH * jt.sys.cvsScale}px`;\n  }\n  destroy() {\n    var t;\n    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(t) {\n    var o, T;\n    if (!this.includeDesignArg(t))\n      return;\n    this.id_tag || (this.id_tag = (o = t[\":id_tag\"]) != null ? o : \"\"), this.hArg = t;\n    const e = (T = t[\":id_dc\"]) != null ? T : this.id_tag;\n    H(jt, En)[e] = this;\n  }\n  includeDesignArg(t) {\n    return Object.keys(t).some((e) => e in this.hDesignArg);\n  }\n  getRect() {\n    return Rectangle.EMPTY;\n  }\n  cnvPosArg(t, e) {\n    return {};\n  }\n  cnvSizeArg(t, e) {\n    return {};\n  }\n  setPos(t, e) {\n  }\n  setSize(t, e) {\n  }\n  setOther(t) {\n  }\n  adopt(t) {\n    this.child = t, t.parent = this;\n  }\n  static enterMode() {\n    jt.leaveMode(), H(jt, Hr).style.display = \"inline\", nt(jt, bo, 0), nt(jt, En, {});\n  }\n  static allHide() {\n    H(jt, xn).forEach((t) => t.visible = !1);\n  }\n  set visible(t) {\n    !this.div || !this.mov || (this.div.style.display = t ? \"inline\" : \"none\", this.mov.updateTarget());\n  }\n  static leaveMode() {\n    H(jt, Hr).textContent = \"\", H(jt, Hr).style.display = \"none\", H(jt, xn).forEach((t) => t.destroy()), nt(jt, xn, []);\n  }\n  cvsResize() {\n    var t;\n    ot(this, Eo, Xc).call(this), (t = this.mov) == null || t.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    var B, $;\n    const t = (B = this.hArg[\":id_dc\"]) != null ? B : this.id_tag;\n    H(jt, En)[t] = this;\n    const e = this.div = document.createElement(\"div\");\n    e.id = H(jt, Gs) + \"_\" + ++Pe(jt, bo)._, e.classList.add(\"sn_design_cast\"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = \"none\", this.rect = this.getRect(), ot(this, Eo, Xc).call(this), (this.parent && ($ = document.querySelector(\n      `[data-id_dc=\"${this.parent.id_tag}\"]`\n    )) != null ? $ : H(jt, Hr)).appendChild(e);\n    const o = {\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    }, T = () => {\n      o.aPos = [NaN, NaN], o.roDeg = this.rotation;\n      const U = this.pivot.x * jt.sys.cvsScale, z = this.pivot.y * jt.sys.cvsScale;\n      o.trOrg = `${U}px ${z}px`, o.origin = [U, z], Object.assign(this.mov, {\n        verticalGuidelines: [],\n        horizontalGuidelines: []\n      });\n    }, S = (U) => {\n      jt.sys.send2Dbg(\"_changeCast\", {\n        ...U,\n        \":id_tag\": this.id_tag\n      }), jt.divHint.style.display = \"none\";\n    }, N = () => {\n      const [U, z] = o.aPos;\n      if (isNaN(U)) {\n        jt.divHint.style.display = \"none\";\n        return;\n      }\n      const V = int(this.rect.x += U / jt.sys.cvsScale + this.pivot.x), X = int(this.rect.y += z / jt.sys.cvsScale + this.pivot.y);\n      this.setPos(V, X);\n      const W = uint(this.rect.width), Y = uint(this.rect.height);\n      this.setSize(W, Y), S({\n        ...this.cnvPosArg(V, X),\n        ...this.cnvSizeArg(W, Y)\n      });\n    };\n    let D;\n    this.mov = new Moveable(document.body, {\n      target: e,\n      draggable: !0,\n      resizable: !0,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: !0\n    }).on(\"dragStart\", (U) => {\n      var V;\n      T(), this.onDragStart();\n      const z = (V = this.child) == null ? void 0 : V.mov;\n      z && (D = z.target, z.isInside(U.clientX, U.clientY) && (z.target = void 0));\n    }).on(\"drag\", (U) => {\n      o.aPos = U.beforeTranslate, this.procDragHint(U, U.left, U.top);\n    }).on(\"dragEnd\", () => {\n      var U, z;\n      N(), (U = this.child) != null && U.mov && (this.child.mov.target = D), (z = this.parent) != null && z.mov && (this.parent.mov.target = this.parent.div);\n    }).on(\"resizeStart\", T).on(\"resize\", (U) => {\n      e.style.width = `${U.width}px`, e.style.height = `${U.height}px`, o.aPos = U.drag.beforeTranslate, this.rect.width = U.width / jt.sys.cvsScale, this.rect.height = U.height / jt.sys.cvsScale, this.procResizeHint(U, U.drag.left, U.drag.top);\n    }).on(\"resizeEnd\", N).on(\"rotateStart\", (U) => {\n      T(), U.set(o.roDeg);\n    }).on(\"rotate\", (U) => {\n      o.roDeg = U.beforeRotate, jt.setHint(int(o.roDeg) + \"\\u5EA6\", U.drag.left, U.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = o.roDeg, this.setOther({}), S({ rotation: int(o.roDeg) });\n    }).on(\"dragOriginStart\", () => T).on(\"dragOrigin\", (U) => {\n      o.trOrg = U.transformOrigin, o.origin = U.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [U, z] = o.origin;\n      o.trOrg = `${U}px ${z}px`;\n      const V = this.pivot.x = U / jt.sys.cvsScale, X = this.pivot.y = z / jt.sys.cvsScale;\n      this.setOther({});\n      const W = int(this.rect.x + V), Y = int(this.rect.y + X);\n      this.setPos(W, Y), S({\n        ...this.cnvPosArg(W, Y),\n        pivot_x: int(V),\n        pivot_y: int(X)\n      });\n    }).on(\"render\", () => {\n      const { aPos: U, roDeg: z, trOrg: V } = o;\n      e.style.transformOrigin = V, e.style.transform = `translate(${U[0]}px, ${U[1]}px) rotate(${z}deg)`;\n    }), H(jt, xn).push(this), e.addEventListener(\"dragenter\", () => e.classList.add(\"drag_border\")), e.addEventListener(\"dragover\", (U) => {\n      U.stopPropagation(), U.preventDefault(), U.dataTransfer && (U.dataTransfer.dropEffect = \"copy\");\n    }), e.addEventListener(\"dragleave\", () => e.classList.remove(\"drag_border\")), e.addEventListener(\"drop\", (U) => {\n      U.stopPropagation(), U.preventDefault(), e.classList.remove(\"drag_border\");\n      const z = U.dataTransfer;\n      if (!z || z.files.length === 0)\n        return;\n      const V = z.files[0], X = {\n        \":id_tag\": this.id_tag,\n        fn: getFn(V.name),\n        ext: getExt(V.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: H(jt, Us).searchPath(this.oldFn(), SEARCH_PATH_ARG_EXT.SPRITE)\n      };\n      V.arrayBuffer().then((W) => {\n        X.buf = W;\n        try {\n          X.url = H(jt, ks).cnvPath4Dbg(\n            H(jt, Us).searchPath(V.name, SEARCH_PATH_ARG_EXT.SPRITE)\n          );\n        } catch {\n        }\n        jt.sys.send2Dbg(\"_dropFile\", X);\n      }).catch((W) => console.error(\"drop2dc %o\", W));\n    }), e.addEventListener(\"dblclick\", (U) => {\n      U.preventDefault(), jt.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(t, e, o) {\n    const [T, S] = t.beforeTranslate;\n    jt.setHint(\n      `(${int(this.rect.x + T / jt.sys.cvsScale)}, ${int(this.rect.y + S / jt.sys.cvsScale)})`,\n      e,\n      o,\n      this\n    );\n  }\n  procResizeHint(t, e, o) {\n    jt.setHint(\n      `(${int(t.drag.left)}, ${int(t.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,\n      e,\n      o,\n      this\n    );\n  }\n  static replaceToken(t) {\n    var U, z, V, X, W, Y, q, Z, K, J, tt, et, Q, at, it, st;\n    const o = t[\":id_tag\"], T = H(jt, En)[o];\n    if (!document.querySelector(`div[data-id_dc='${o}']`) || !T)\n      return;\n    const N = t[\":token\"];\n    H(jt, ks).replace(t[\":idx_tkn\"], N);\n    const [D, B] = tagToken2Name_Args(N);\n    T.child && (T.child.hArg[\":token\"] = T.hArg[\":token\"]), H(jt, $s).go(B);\n    const $ = H(jt, $s).hPrm;\n    if (\"pivot_x\" in $ || \"pivot_y\" in $) {\n      const ut = Number(jt.prpPrs.getValAmpersand($.pivot_x.val)), ft = Number(jt.prpPrs.getValAmpersand($.pivot_y.val));\n      (isNaN(ut) || isNaN(ft)) && DebugMng.myTrace(`pivot_x\\u304Bpivot_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${N}`, \"F\"), T.pivot.set(ut, ft);\n    }\n    if (\"left\" in $ || \"top\" in $ || \"x\" in $ || \"y\" in $) {\n      const ut = int(jt.prpPrs.getValAmpersand((X = (V = (U = $.left) == null ? void 0 : U.val) != null ? V : (z = $.x) == null ? void 0 : z.val) != null ? X : \"0\")), ft = int(jt.prpPrs.getValAmpersand((Z = (q = (W = $.top) == null ? void 0 : W.val) != null ? q : (Y = $.y) == null ? void 0 : Y.val) != null ? Z : \"0\"));\n      (isNaN(ut) || isNaN(ft)) && DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${N}`, \"F\"), T.rect.x = ut - T.pivot.x, T.rect.y = ft - T.pivot.y, T.setPos(ut, ft);\n    }\n    if (\"width\" in $ || \"height\" in $) {\n      const ut = int(jt.prpPrs.getValAmpersand((J = (K = $.width) == null ? void 0 : K.val) != null ? J : \"0\")), ft = int(jt.prpPrs.getValAmpersand((et = (tt = $.height) == null ? void 0 : tt.val) != null ? et : \"0\"));\n      (isNaN(ut) || isNaN(ft)) && DebugMng.myTrace(`width\\u304Bheight\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${N}`, \"F\"), T.rect.width = ut, T.rect.height = ft, T.setSize(ut, ft);\n    }\n    if (\"scale_x\" in $ || \"scale_y\" in $) {\n      const ut = Number(jt.prpPrs.getValAmpersand((at = (Q = $.scale_x) == null ? void 0 : Q.val) != null ? at : \"0\")), ft = Number(jt.prpPrs.getValAmpersand((st = (it = $.scale_y) == null ? void 0 : it.val) != null ? st : \"0\"));\n      (isNaN(ut) || isNaN(ft)) && DebugMng.myTrace(`scale_x\\u304Bscale_y\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${N}`, \"F\"), T.scale.set(ut, ft);\n    }\n    if (\"rotation\" in $) {\n      const ut = Number(jt.prpPrs.getValAmpersand($.rotation.val));\n      isNaN(ut) && DebugMng.myTrace(`rotation\\u304C\\u6570\\u5024\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${N}`, \"F\"), T.rotation = ut;\n    }\n    T.setOther($), T.cvsResize();\n  }\n};\nlet DesignCast = jt;\nHr = new WeakMap(), ks = new WeakMap(), $s = new WeakMap(), Us = new WeakMap(), Gs = new WeakMap(), bo = new WeakMap(), En = new WeakMap(), xn = new WeakMap(), Eo = new WeakSet(), Xc = function() {\n  this.fncLay(), this.div && Object.assign(this.div.style, {\n    left: `${this.lx + this.rect.x * jt.sys.cvsScale}px`,\n    top: `${this.ly + this.rect.y * jt.sys.cvsScale}px`,\n    width: `${this.rect.width * jt.sys.cvsScale}px`,\n    height: `${this.rect.height * jt.sys.cvsScale}px`,\n    transformOrigin: `${this.pivot.x * jt.sys.cvsScale}px ${this.pivot.y * jt.sys.cvsScale}px`,\n    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n  });\n}, rt(DesignCast, Hr, void 0), Pt(DesignCast, \"sys\"), rt(DesignCast, ks, void 0), Pt(DesignCast, \"prpPrs\"), rt(DesignCast, $s, void 0), rt(DesignCast, Us, void 0), Pt(DesignCast, \"hPages\"), Pt(DesignCast, \"divHint\", document.createElement(\"div\")), rt(DesignCast, Gs, \"DesignMode\"), rt(DesignCast, bo, 0), rt(DesignCast, En, {}), rt(DesignCast, xn, []);\nvar $i;\nclass GrpLayDesignCast extends DesignCast {\n  constructor(e, o) {\n    super(\"#29e\", !0);\n    rt(this, $i, void 0);\n    Pt(this, \"oldFn\", () => {\n      var e;\n      return (e = this.hArg.fn) != null ? e : \"\";\n    });\n    this.spLay = e, this.gl = o;\n  }\n  setSp(e) {\n    nt(this, $i, e);\n  }\n  getRect() {\n    var e, o, T, S;\n    return new Rectangle(this.spLay.x, this.spLay.y, (o = (e = H(this, $i)) == null ? void 0 : e.width) != null ? o : 0, (S = (T = H(this, $i)) == null ? void 0 : T.height) != null ? S : 0);\n  }\n  cnvPosArg(e, o) {\n    return { left: e, top: o };\n  }\n  cnvSizeArg(e, o) {\n    return { width: e, height: o };\n  }\n  setPos(e, o) {\n    this.spLay.x = e, this.spLay.y = o;\n  }\n  setSize(e, o) {\n    H(this, $i).width = e, H(this, $i).height = o;\n  }\n  setOther(e) {\n    if (\"fn\" in e) {\n      const o = DesignCast.prpPrs.getValAmpersand(e.fn.val);\n      this.gl.lay({ fn: o });\n    }\n    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\n$i = new WeakMap();\nclass TxtLayDesignCast extends DesignCast {\n  constructor(e, o) {\n    super(\"#29e\", !0);\n    Pt(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0,\n      pl: 0,\n      pr: 0,\n      pt: 0,\n      pb: 0\n    });\n    this.spLay = e, this.ts = o;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(this.spLay.x, this.spLay.y, e.$width, e.$height);\n  }\n  cnvPosArg(e, o) {\n    return { left: e, top: o };\n  }\n  cnvSizeArg(e, o) {\n    return { width: e, height: o };\n  }\n  setPos(e, o) {\n    this.spLay.position.set(e, o), this.ts.lay(this.cnvPosArg(e, o));\n  }\n  setSize(e, o) {\n    this.ts.lay(this.cnvSizeArg(e, o));\n  }\n  setOther(e) {\n    var o;\n    (o = this.child) == null || o.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nvar xo, Wc;\nclass TxtLayPadDesignCast extends DesignCast {\n  constructor(e) {\n    super(\"#9e2\");\n    rt(this, xo);\n    Pt(this, \"rotatable\", !1);\n    this.ts = e;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Rectangle(\n      e.pad_left,\n      e.pad_top,\n      e.$width - e.pad_left - e.pad_right,\n      e.$height - e.pad_top - e.pad_bottom\n    );\n  }\n  cnvPosArg(e, o) {\n    return { pl: e, pt: o };\n  }\n  cnvSizeArg(e, o) {\n    const T = this.ts.infTL;\n    return {\n      pr: T.$width - T.pad_left - e,\n      pb: T.$height - T.pad_top - o\n    };\n  }\n  setPos(e, o) {\n    this.ts.lay(this.cnvPosArg(e, o));\n  }\n  setSize(e, o) {\n    this.ts.lay({ ...this.cnvSizeArg(e, o), \":redraw\": !0 });\n  }\n  setOther(e) {\n    var T, S, N, D, B, $, U, z;\n    const o = this.ts.infTL;\n    if ((\"pl\" in e || \"pt\" in e) && (this.setPos(\n      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        (S = (T = e.pl) == null ? void 0 : T.val) != null ? S : `${o.pad_left}`\n      )),\n      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(\n        (D = (N = e.pt) == null ? void 0 : N.val) != null ? D : `${o.pad_top}`\n      ))\n    ), this.cvsResize()), \"pr\" in e || \"pb\" in e) {\n      this.ts.lay({\n        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          ($ = (B = e.pr) == null ? void 0 : B.val) != null ? $ : `${o.pad_right}`\n        )),\n        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(\n          (z = (U = e.pb) == null ? void 0 : U.val) != null ? z : `${o.pad_bottom}`\n        ))\n      });\n      const V = this.getRect();\n      this.setSize(\n        this.rect.width = V.width,\n        this.rect.height = V.height\n      ), this.cvsResize();\n    }\n  }\n  procDragHint(e, o, T) {\n    const [S, N] = e.beforeTranslate;\n    ot(this, xo, Wc).call(this, o, T, S, N);\n  }\n  procResizeHint(e, o, T) {\n    const [S, N] = e.drag.beforeTranslate;\n    ot(this, xo, Wc).call(this, o, T, S, N);\n  }\n}\nxo = new WeakSet(), Wc = function(e, o, T, S) {\n  const N = this.rect.x, D = this.rect.y, B = this.rect.width, $ = this.rect.height, U = this.ts.infTL, z = int(N + T / DesignCast.sys.cvsScale), V = int(D + S / DesignCast.sys.cvsScale), X = int(U.$width - z - B), W = int(U.$height - V - $), Y = (q) => \"&nbsp;\".repeat(q);\n  DesignCast.setHint(\n    Y(5 + 5 + 1) + `\\u4E0A\\u5E45=${V}<br/>\n\t\t\t\\u5DE6\\u5E45=${z + Y(1 + 3 + 5 + 1)}\\u53F3\\u5E45=${X}<br/>` + Y(5) + `\\u5185\\u5074 ${int(B)} x ${int($)}<br/>` + Y(5 + 5) + `\\u4E0B\\u5E45=${W}`,\n    e,\n    o,\n    this\n  );\n};\nclass BtnDesignCast extends DesignCast {\n  constructor(t, e) {\n    super(\"#e92\"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x), this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y), this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x), this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y), this.rotation = argChk_Num(e, \"rotation\", this.rotation), this.sethArg(e);\n  }\n  sethArg(t) {\n    var o;\n    super.sethArg(t);\n    const e = (o = this.hArg.layer) != null ? o : \"\";\n    this.fncLay = !this.parent && !this.child && e ? () => {\n      const T = DesignCast.hPages[e].fore;\n      this.lx = T.x * DesignCast.sys.cvsScale, this.ly = T.y * DesignCast.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.btn.x = t, this.btn.y = e;\n  }\n  setOther(t) {\n    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n    const t = this.btn.parent.children.filter((e) => e !== this.btn);\n    Object.assign(this.mov, {\n      verticalGuidelines: t.map((e) => this.lx + e.x * DesignCast.sys.cvsScale),\n      horizontalGuidelines: t.map((e) => this.ly + e.y * DesignCast.sys.cvsScale)\n    });\n  }\n}\nclass TxtBtnDesignCast extends BtnDesignCast {\n  constructor(e, o, T) {\n    super(e, o);\n    Pt(this, \"oldFn\", () => {\n      var e;\n      return (e = this.hArg.b_pic) != null ? e : \"\";\n    });\n    this.txt = T, argChk_Boolean(o, \"design\", !0) || (this.setPos = () => {\n    }, this.setSize = () => {\n    });\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(e, o) {\n    this.txt.width = e, this.txt.height = o;\n  }\n  setOther(e) {\n    var o;\n    if (super.setOther(e), \"b_pic\" in e) {\n      const T = DesignCast.prpPrs.getValAmpersand((o = e.b_pic.val) != null ? o : \"\");\n      this.btn.update_b_pic(T, this.txt);\n    }\n  }\n}\nvar ii;\nclass PicBtnDesignCast extends BtnDesignCast {\n  constructor(e, o) {\n    super(e, o);\n    rt(this, ii, void 0);\n    Pt(this, \"oldFn\", () => {\n      var e;\n      return (e = this.hArg.pic) != null ? e : \"\";\n    });\n  }\n  setSp(e) {\n    nt(this, ii, e);\n  }\n  getRect() {\n    return new Rectangle(this.btn.x, this.btn.y, H(this, ii).width, H(this, ii).height);\n  }\n  setSize(e, o) {\n    H(this, ii).width = e, H(this, ii).height = o;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"pic\" in e) {\n      const o = DesignCast.prpPrs.getValAmpersand(e.pic.val);\n      this.btn.update_pic(o, H(this, ii));\n    }\n  }\n}\nii = new WeakMap();\nvar eh, Ui, ni, Tn, Sn, jr, To, Cn, So, Co, zr, si, Gi, Hi, Ro, Io, wo, rh, nd, ih, sd, Po, Yc, nh, ad, Hs, Cr, js, Rn, Ao;\nconst Wt = class extends Layer {\n  constructor() {\n    super();\n    rt(this, zr, new GrpLayDesignCast(this.spLay, this));\n    rt(this, si, \"\");\n    rt(this, Gi, \"\");\n    rt(this, Hi, \"\");\n    Pt(this, \"lay\", (e) => this.laySub(e, (o) => {\n      o && H(Wt, ni).resume();\n    }));\n    rt(this, Ro, 0);\n    rt(this, Io, 0);\n    rt(this, Hs, void 0);\n    rt(this, Cr, void 0);\n    rt(this, js, () => {\n    });\n    Pt(this, \"record\", () => ({\n      ...super.record(),\n      sBkFn: H(this, Gi),\n      sBkFace: H(this, Hi),\n      idc_hArg: H(this, zr).gethArg()\n    }));\n    Pt(this, \"dump\", () => super.dump() + `, \"pic\":\"${H(this, si)}\"`);\n    CmnLib.isDbg && (this.setSp = (e) => H(this, zr).setSp(e), this.cvsResize = () => {\n      super.cvsResize(), H(this, zr).cvsResize();\n    });\n  }\n  static init(e, o, T, S, N, D) {\n    nt(Wt, ni, e), nt(Wt, Tn, o), nt(Wt, Sn, T), nt(Wt, jr, S), nt(Wt, To, D);\n    const B = () => {\n      const $ = H(Wt, Cn) * H(Wt, So);\n      for (const U of Object.values(Wt.hFn2VElm))\n        U.volume = $;\n    };\n    N.setNoticeChgVolume(\n      ($) => {\n        nt(Wt, Cn, $), B();\n      },\n      ($) => {\n        nt(Wt, So, $), B();\n      }\n    ), H(Wt, jr).crypto && nt(Wt, wo, ot(Wt, ih, sd));\n  }\n  static setEvtMng(e) {\n    nt(Wt, Co, e);\n  }\n  static destroy() {\n    H(Wt, eh).clear(), nt(Wt, Ui, {}), Wt.hFn2ResAniSpr = {}, Wt.hFn2VElm = {};\n  }\n  setSp(e) {\n  }\n  laySub(e, o) {\n    const { fn: T, face: S = \"\" } = e;\n    if (H(this, zr).sethArg(e), !T)\n      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), nt(this, Gi, \"\"), nt(this, si, nt(this, Hi, S)), o(!1), !1;\n    const N = \"fn\" in e, D = \"face\" in e;\n    return this.clearLay({ filter: \"true\" }), N && nt(this, Gi, T), D && nt(this, Hi, S), super.lay(e), e.dx = 0, e.dy = 0, Wt.csv2Sprites(\n      nt(this, si, T + (S ? \",\" + S : \"\")),\n      this.spLay,\n      (B) => {\n        (\"width\" in e || \"height\" in e) && (B.width = argChk_Num(e, \"width\", 0), B.height = argChk_Num(e, \"height\", 0)), nt(this, Ro, B.width), nt(this, Io, B.height), Layer.setXY(B, e, this.spLay, !0), this.setSp(B);\n      },\n      (B) => {\n        Layer.setBlendmode(this.spLay, e), o(B);\n      }\n    );\n  }\n  get width() {\n    return H(this, Ro);\n  }\n  get height() {\n    return H(this, Io);\n  }\n  static csv2Sprites(e, o, T, S = () => {\n  }) {\n    let N = !1;\n    if (e.slice(0, 5) === \"data:\") {\n      const U = () => {\n        const z = Sprite.from(e);\n        o == null || o.addChild(z), T(z), S(N);\n      };\n      return e in TextureCache ? U() : (N = !0, new Loader().add(e, e).load(U)), N;\n    }\n    const D = [], B = new Loader();\n    e.split(\",\").forEach((U, z) => {\n      if (!U)\n        throw \"face\\u5C5E\\u6027\\u306B\\u7A7A\\u8981\\u7D20\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059\";\n      const V = H(Wt, Ui)[U] || {\n        fn: U,\n        dx: 0,\n        dy: 0,\n        blendmode: BLEND_MODES$5.NORMAL\n      }, X = z === 0 ? T : (q) => {\n        q.x = V.dx, q.y = V.dy, q.blendMode = V.blendmode;\n      };\n      if (D.push({ fn: V.fn, fnc: X }), V.fn in Wt.hFn2ResAniSpr || V.fn in TextureCache || V.fn in Loader.shared.resources)\n        return;\n      N = !0;\n      const W = H(Wt, Tn).searchPath(V.fn, SEARCH_PATH_ARG_EXT.SPRITE), Y = H(this, jr).crypto ? { xhrType: W.slice(-5) === \".json\" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};\n      B.add({ ...Y, name: V.fn, url: W });\n    });\n    const $ = (U) => {\n      var z;\n      for (const { fn: V, fnc: X } of D) {\n        const W = ot(z = Wt, nh, ad).call(z, V, U);\n        W.name = V, o == null || o.addChild(W), X(W);\n      }\n      S(N);\n    };\n    return N ? B.use((U, z) => {\n      H(this, jr).dec(U.extension, U.data).then((V) => {\n        var X;\n        return H(X = Wt, wo).call(X, V, U, () => z == null ? void 0 : z());\n      }).catch((V) => H(this, ni).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${U.name} ${V}`, !1));\n    }).load((U, z) => $(z)) : $({}), N;\n  }\n  static wv(e) {\n    const { fn: o } = e;\n    if (!o)\n      throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const T = Wt.hFn2VElm[o];\n    if (!T || T.loop)\n      return !1;\n    if (T.ended)\n      return delete Wt.hFn2VElm[o], !1;\n    const S = () => {\n      T.removeEventListener(\"ended\", S), delete Wt.hFn2VElm[o], H(this, ni).resume();\n    };\n    return T.addEventListener(\"ended\", S, { once: !0, passive: !0 }), H(Wt, Co).waitEvent(\n      () => {\n        T.pause(), S();\n      },\n      argChk_Boolean(e, \"canskip\", !0),\n      argChk_Boolean(e, \"global\", !1)\n    );\n  }\n  renderStart() {\n    nt(this, Hs, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    })), nt(this, Cr, new Sprite(H(this, Hs))), H(this, Cr).visible = !1, this.spLay.addChildAt(H(this, Cr), 0), H(this, Cr).position.set(-this.spLay.x, -this.spLay.y);\n    let e = () => {\n      const o = this.spLay.alpha;\n      this.spLay.alpha = 1;\n      for (const T of this.spLay.children)\n        T.visible = !0;\n      H(this, Cr).visible = !1, H(Wt, Sn).renderer.render(this.spLay, { renderTexture: H(this, Hs) }), this.spLay.alpha = o;\n      for (const T of this.spLay.children)\n        T.visible = !1;\n    };\n    if (!this.containMovement) {\n      let o = e;\n      e = () => {\n        e = () => {\n        }, o();\n      };\n    }\n    nt(this, js, () => {\n      e(), H(this, Cr).visible = !0;\n    }), H(Wt, Sn).ticker.add(H(this, js));\n  }\n  renderEnd() {\n    H(Wt, Sn).ticker.remove(H(this, js)), this.spLay.removeChild(H(this, Cr));\n    for (const e of this.spLay.children)\n      e.visible = !0;\n    H(this, Cr).destroy(!0);\n  }\n  static loadPic2Img(e, o, T) {\n    const S = H(this, Ao)[e];\n    if (S) {\n      o.src = S;\n      return;\n    }\n    const N = H(this, Rn)[e];\n    if (N) {\n      N.push(o);\n      return;\n    }\n    H(this, Rn)[e] = [o];\n    const D = H(Wt, Tn).searchPath(e, SEARCH_PATH_ARG_EXT.SPRITE), B = new Loader().add({ name: e, url: D, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });\n    H(Wt, jr).crypto && B.use(($, U) => {\n      H(Wt, jr).dec($.extension, $.data).then((z) => {\n        if ($.extension !== \"bin\") {\n          U == null || U();\n          return;\n        }\n        $.data = z, z instanceof HTMLImageElement && ($.type = LoaderResource.TYPE.IMAGE), U == null || U();\n      }).catch((z) => H(Wt, ni).errScript(`GrpLayer loadPic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${$.name} ${z}`, !1));\n    }), B.load(($, U) => {\n      for (const [z, { data: { src: V } }] of Object.entries(U)) {\n        const X = H(this, Ao)[z] = V;\n        for (const W of H(this, Rn)[z])\n          W.src = X, T && (W.onload = () => T(W));\n        delete H(this, Rn)[z];\n      }\n    });\n  }\n  setPos(e) {\n    Layer.setXY(\n      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],\n      e,\n      this.spLay,\n      !0\n    );\n  }\n  static add_face(e) {\n    const { name: o } = e;\n    if (!o)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (o in H(Wt, Ui))\n      throw \"\\u4E00\\u3064\\u306Ename\\uFF08\" + o + \"\\uFF09\\u306B\\u5BFE\\u3057\\u3066\\u540C\\u3058\\u753B\\u50CF\\u3092\\u8907\\u6570\\u5272\\u308A\\u5F53\\u3066\\u3089\\u308C\\u307E\\u305B\\u3093\";\n    const { fn: T = o } = e;\n    return H(Wt, Ui)[o] = {\n      fn: T,\n      dx: argChk_Num(e, \"dx\", 0),\n      dy: argChk_Num(e, \"dy\", 0),\n      blendmode: Layer.getBlendmodeNum(e.blendmode || \"\")\n    }, !1;\n  }\n  static clearFace2Name() {\n    nt(Wt, Ui, {});\n  }\n  get containMovement() {\n    if (H(this, si) === \"\")\n      return !1;\n    const e = this.spLay.children;\n    return H(this, si).split(\",\").some(\n      (o, T) => e[T] instanceof AnimatedSprite || Wt.hFn2VElm[o]\n    );\n  }\n  clearLay(e) {\n    super.clearLay(e);\n    for (const o of this.spLay.removeChildren())\n      o.destroy();\n    nt(this, Gi, \"\"), nt(this, Hi, \"\"), nt(this, si, \"\");\n  }\n  playback(e, o) {\n    if (super.playback(e, o), e.sBkFn === \"\" && e.sBkFace === \"\") {\n      nt(this, Gi, e.sBkFn), nt(this, Hi, e.sBkFace), H(this, zr).sethArg(e.idc_hArg);\n      return;\n    }\n    o.push(new Promise((T) => this.laySub(\n      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: Layer.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },\n      (S) => {\n        this.spLay.position.set(e.x, e.y), T();\n      }\n    )));\n  }\n  makeDesignCast(e) {\n    !this.spLay.visible || e(H(this, zr));\n  }\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    H(this, zr).visible = !0;\n  }\n};\nlet GrpLayer = Wt;\neh = new WeakMap(), Ui = new WeakMap(), ni = new WeakMap(), Tn = new WeakMap(), Sn = new WeakMap(), jr = new WeakMap(), To = new WeakMap(), Cn = new WeakMap(), So = new WeakMap(), Co = new WeakMap(), zr = new WeakMap(), si = new WeakMap(), Gi = new WeakMap(), Hi = new WeakMap(), Ro = new WeakMap(), Io = new WeakMap(), wo = new WeakMap(), rh = new WeakSet(), nd = function(e) {\n  const o = /([^\\d]+)\\d+\\.(\\w+)/.exec(e[0]);\n  if (!o)\n    return [];\n  const T = o[1].length, S = -o[2].length - 1;\n  return e.sort(\n    (N, D) => int(N.slice(T, S)) > int(D.slice(T, S)) ? 1 : -1\n  );\n}, ih = new WeakSet(), sd = function(e, o, T) {\n  var $;\n  if (o.data = e, o.extension === \"bin\" && (e instanceof HTMLImageElement ? (o.texture = Texture.fromLoader(e, o.url, o.name), o.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(e.src)) : e instanceof HTMLVideoElement && (e.volume = H(Wt, Cn), Wt.hFn2VElm[o.name] = ot($ = Wt, Po, Yc).call($, e), o.type = LoaderResource.TYPE.VIDEO, URL.revokeObjectURL(e.src))), o.extension !== \"json\") {\n    T();\n    return;\n  }\n  if (typeof e != \"string\") {\n    T();\n    return;\n  }\n  const { meta: S, frames: N } = o.data = JSON.parse(e);\n  if (o.type = LoaderResource.TYPE.JSON, !(S != null && S.image)) {\n    T();\n    return;\n  }\n  const D = getFn(S.image), B = H(Wt, Tn).searchPath(D, SEARCH_PATH_ARG_EXT.SPRITE);\n  new Loader().use((U, z) => {\n    H(this, jr).dec(U.extension, U.data).then((V) => {\n      U.data = V, V instanceof HTMLImageElement && (U.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(V.src)), z == null || z();\n    }).catch((V) => H(this, ni).errScript(`Graphic \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 dec2res4Cripto fn:${U.name} ${V}`, !1));\n  }).add({ name: D, url: B, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((U, z) => {\n    for (const { data: V } of Object.values(U.resources)) {\n      const { baseTexture: X } = Texture.from(V), W = Object.values(N);\n      Wt.hFn2ResAniSpr[o.name] = {\n        aTex: W.map(({ frame: { x: Y, y: q, w: Z, h: K } }) => new Texture(\n          X,\n          new Rectangle(Y, q, Z, K)\n        )),\n        meta: S\n      };\n    }\n    T();\n  });\n}, Po = new WeakSet(), Yc = function(e) {\n  return H(Wt, To).getVal(\"const.sn.needClick2Play\") && (DebugMng.trace_beforeNew(`[lay\\u7CFB] ${DebugMng.strPos()}\\u672A\\u30AF\\u30EA\\u30C3\\u30AF\\u72B6\\u614B\\u3067\\u52D5\\u753B\\u3092\\u81EA\\u52D5\\u518D\\u751F\\u3057\\u307E\\u3059\\u3002\\u97F3\\u58F0\\u306F\\u30DF\\u30E5\\u30FC\\u30C8\\u3055\\u308C\\u307E\\u3059`, \"W\"), e.muted = !0), e.setAttribute(\"playsinline\", \"\"), e;\n}, nh = new WeakSet(), ad = function(e, o) {\n  var S;\n  const T = Wt.hFn2ResAniSpr[e];\n  if (T) {\n    const N = new AnimatedSprite(T.aTex);\n    return N.animationSpeed = (S = T.meta.animationSpeed) != null ? S : 1, N.play(), N;\n  }\n  return e in TextureCache ? Sprite.from(e) : e in Wt.hFn2VElm ? Sprite.from(Wt.hFn2VElm[e]) : e in o ? new Sprite(o[e].texture) : new Sprite();\n}, Hs = new WeakMap(), Cr = new WeakMap(), js = new WeakMap(), Rn = new WeakMap(), Ao = new WeakMap(), rt(GrpLayer, rh), rt(GrpLayer, ih), rt(GrpLayer, Po), rt(GrpLayer, nh), rt(GrpLayer, eh, new EventListenerCtn()), rt(GrpLayer, Ui, {}), rt(GrpLayer, ni, void 0), rt(GrpLayer, Tn, void 0), rt(GrpLayer, Sn, void 0), rt(GrpLayer, jr, void 0), rt(GrpLayer, To, void 0), rt(GrpLayer, Cn, 1), rt(GrpLayer, So, 1), rt(GrpLayer, Co, void 0), Pt(GrpLayer, \"hFn2ResAniSpr\", {}), rt(GrpLayer, wo, (e, o, T) => {\n  var S, N;\n  switch (o.type) {\n    case LoaderResource.TYPE.JSON:\n      const D = o.spritesheet._frameKeys;\n      ot(S = Wt, rh, nd).call(S, D), Wt.hFn2ResAniSpr[o.name] = {\n        aTex: D.map(($) => Texture.from($)),\n        meta: o.data.meta\n      };\n      break;\n    case LoaderResource.TYPE.VIDEO:\n      const B = o.data;\n      B.volume = H(Wt, Cn), Wt.hFn2VElm[o.name] = ot(N = Wt, Po, Yc).call(N, B);\n  }\n  T();\n}), Pt(GrpLayer, \"hFn2VElm\", {}), rt(GrpLayer, Rn, {}), rt(GrpLayer, Ao, {});\nvar zs, Oo, In, le, Vr, ai, sh, ur, ji, Xt, oi, Xe, We, Vs, nl, Rr, Ir, No, Xs, ah, od, wn, Ws, ui, Pn, An, On, Ys, li, Mo, qc, hi, Do, ci, Xr, qs, Lo, Zc, zi, Nn, Fo, Kc, vr;\nconst Zt = class extends Container {\n  constructor(e, o, T) {\n    super();\n    rt(this, Vs);\n    rt(this, ah);\n    rt(this, Mo);\n    rt(this, Lo);\n    rt(this, Fo);\n    rt(this, le, document.createElement(\"span\"));\n    rt(this, Vr, new Container());\n    rt(this, ai, new Graphics());\n    rt(this, ur, new TxtLayDesignCast(this.spLay, this));\n    rt(this, ji, new TxtLayPadDesignCast(this));\n    rt(this, Xt, {\n      fontsize: 24,\n      $width: 0,\n      $height: 0,\n      pad_left: 0,\n      pad_right: 0,\n      pad_top: 0,\n      pad_bottom: 0\n    });\n    rt(this, oi, !1);\n    rt(this, Xe, 0);\n    rt(this, We, 0);\n    rt(this, Rr, 0);\n    rt(this, Ir, !1);\n    rt(this, No, 0);\n    rt(this, Xs, 0);\n    rt(this, wn, void 0);\n    rt(this, Ws, []);\n    rt(this, ui, []);\n    rt(this, Pn, 0);\n    rt(this, li, () => !1);\n    rt(this, qs, 0);\n    rt(this, zi, \"Quadratic.Out\");\n    rt(this, Nn, \"Quadratic.Out\");\n    rt(this, vr, void 0);\n    this.spLay = e, this.canFocus = o, this.sys = T, H(this, le).classList.add(\"sn_tx\"), H(this, le).style.position = \"absolute\", H(Zt, Oo).view.parentElement.appendChild(H(this, le)), this.addChild(H(this, Vr)), this.addChild(H(this, ai)), H(this, ai).name = \"grpDbgMasume\", H(this, ur).adopt(H(this, ji));\n  }\n  static init(e, o) {\n    nt(Zt, zs, e), nt(Zt, Oo, o), nt(Zt, An, /[!?]/), nt(Zt, On, /[]/), nt(Zt, Ys, /[]/);\n  }\n  static setEvtMng(e) {\n    nt(Zt, In, e);\n  }\n  static destroy() {\n    nt(Zt, hi, /* @__PURE__ */ Object.create(null)), nt(Zt, ci, /* @__PURE__ */ Object.create(null)), nt(Zt, Xr, new Container());\n  }\n  lay(e) {\n    var T, S, N, D, B, $, U, z;\n    const o = H(this, le).style;\n    if (\"style\" in e)\n      if (e.style) {\n        const V = document.createElement(\"span\");\n        V.style.cssText = e.style;\n        const X = V.style.length;\n        for (let W = 0; W < X; ++W) {\n          const Y = V.style[W];\n          if (Y in H(Zt, sh)) {\n            DebugMng.myTrace(`${Y}\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093`, \"W\");\n            continue;\n          }\n          o[Y] = V.style[Y];\n        }\n        !V.style.opacity && \"alpha\" in e && (o.opacity = String(this.spLay.alpha));\n      } else\n        H(this, le).style.cssText = \"\";\n    else\n      \"alpha\" in e && (o.opacity = String(this.spLay.alpha));\n    if (\"width\" in e && (o.width = ((T = e.width) != null ? T : \"0\") + \"px\"), \"height\" in e && (o.height = ((S = e.height) != null ? S : \"0\") + \"px\"), \"pl\" in e && (o.paddingLeft = ((N = e.pl) != null ? N : \"0\") + \"px\"), \"pr\" in e && (o.paddingRight = ((D = e.pr) != null ? D : \"0\") + \"px\"), \"pt\" in e && (o.paddingTop = ((B = e.pt) != null ? B : \"0\") + \"px\"), \"pb\" in e && (o.paddingBottom = (($ = e.pb) != null ? $ : \"0\") + \"px\"), \"kinsoku_sol\" in e && nt(Zt, An, new RegExp(`[${e.kinsoku_sol}]`)), \"kinsoku_eol\" in e && nt(Zt, On, new RegExp(`[${e.kinsoku_eol}]`)), \"kinsoku_dns\" in e && nt(Zt, Ys, new RegExp(`[${e.kinsoku_dns}]`)), ot(this, Vs, nl).call(this), H(this, ur).sethArg(e), nt(this, Rr, this.spLay.position.x), o.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), o.display = this.spLay.visible ? \"inline\" : \"none\", o.textShadow = (z = (U = e.filter) != null ? U : o.textShadow) != null ? z : \"\", nt(this, oi, argChk_Boolean(e, \"break_fixed\", H(this, oi))), nt(this, Xe, argChk_Num(e, \"break_fixed_left\", H(this, Xe))), nt(this, We, argChk_Num(e, \"break_fixed_top\", H(this, We))), \":redraw\" in e && H(this, Pn) > 0) {\n      const V = [\n        H(this, le).innerHTML.replaceAll(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>\\u3000</span>`\n      ];\n      ot(this, Fo, Kc).call(this), this.goTxt(V);\n    }\n  }\n  cvsResize() {\n    const e = H(this, le).style, o = this.sys.cvsScale;\n    e.left = `${this.sys.ofsLeft4elm + H(this, Rr) * o}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * o}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * o}, ${this.spLay.scale.y * o})`, H(this, ur).cvsResize(), H(this, ji).cvsResize();\n  }\n  get tategaki() {\n    return H(this, Ir);\n  }\n  get infTL() {\n    return H(this, Xt);\n  }\n  get getWidth() {\n    return H(this, Xt).$width;\n  }\n  get getHeight() {\n    return H(this, Xt).$height;\n  }\n  setSize(e, o) {\n    H(this, Xt).$width = e, H(this, Xt).$height = o, H(this, le).style.width = H(this, Xt).$width + \"px\", H(this, le).style.height = H(this, Xt).$height + \"px\";\n  }\n  goTxt(e) {\n    var K, J, tt, et, Q, at, it, st, ut, ft, ct;\n    H(Zt, Xr).visible = !1;\n    const o = H(this, ui).length;\n    o === 0 ? (H(Zt, zs).oCfg.debug.masume && (CmnLib.debugLog && console.log(`\\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${H(this, Xt).pad_left} pr:${H(this, Xt).pad_right} pt:${H(this, Xt).pad_top} pb:${H(this, Xt).pad_bottom} w:${H(this, Xt).$width} h:${H(this, Xt).$height}`), H(this, ai).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-H(this, Xt).pad_left, -H(this, Xt).pad_top, H(this, Xt).$width, H(this, Xt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(\n      0,\n      0,\n      H(this, Xt).$width - H(this, Xt).pad_left - H(this, Xt).pad_right,\n      H(this, Xt).$height - H(this, Xt).pad_top - H(this, Xt).pad_bottom\n    ).endFill()), H(this, le).innerHTML = [...e].join(\"\").replaceAll(/[\\n\\t]/g, \"\")) : H(this, le).insertAdjacentHTML(\"beforeend\", e.slice(H(this, Pn)).join(\"\").replaceAll(/[\\n\\t]/g, \"\")), nt(this, Pn, e.length);\n    const T = this.sys.cvsScale, S = H(this, le).getBoundingClientRect(), N = S.left + H(this, Xt).pad_left, D = S.top + H(this, Xt).pad_top;\n    let B;\n    if (T === 1)\n      B = (pt, mt) => new Rectangle(\n        pt.left - N,\n        pt.top - D,\n        pt.width,\n        pt.height + (\"gjqy\".includes(mt) ? H(this, qs) : 0)\n      );\n    else {\n      const pt = this.sys.ofsPadLeft_Dom2PIXI + S.left * (1 - T), mt = this.sys.ofsPadTop_Dom2PIXI + S.top * (1 - T);\n      B = (vt, _t) => new Rectangle(\n        (vt.left - pt) / T - N,\n        (vt.top - mt) / T - D,\n        vt.width / T,\n        (vt.height + (\"gjqy\".includes(_t) ? H(this, qs) : 0)) / T\n      );\n    }\n    let $ = 0, U = 2, z = !1;\n    do {\n      const pt = nt(this, ui, ot(this, Lo, Zc).call(this, H(this, le), B));\n      if ($ = pt.length, !z && ($ < 2 || o === $))\n        break;\n      z = !0;\n      let mt = -1 / 0;\n      for (; U < $; ++U) {\n        const vt = pt[U];\n        if (vt.elm.tagName === \"RT\")\n          continue;\n        const _t = this.tategaki ? vt.rect.y : vt.rect.x;\n        if (mt <= _t || ((J = (K = vt.elm.previousElementSibling) == null ? void 0 : K.children[0]) == null ? void 0 : J.tagName) === \"BR\") {\n          mt = _t;\n          continue;\n        }\n        let xt = U - 1;\n        for (; pt[xt].elm.tagName === \"RT\"; )\n          --xt;\n        const Rt = pt[xt].ch;\n        mt = -1 / 0;\n        const yt = U;\n        if (H(Zt, Ys).test(Rt) && Rt === vt.ch)\n          U = xt;\n        else {\n          if (H(Zt, On).test(Rt))\n            U = xt;\n          else if (H(Zt, An).test(vt.ch))\n            for (U = xt + 1; U > 0 && H(Zt, An).test(pt[--U].ch); )\n              ;\n          else {\n            ++U;\n            continue;\n          }\n          for (U = xt + 1; U > 0 && H(Zt, On).test(pt[--U].ch); )\n            ;\n        }\n        const ht = pt[U].elm.parentElement, bt = document.createElement(\"br\");\n        if (ht.classList.contains(\"sn_tx\"))\n          ht.insertBefore(bt, pt[U].elm);\n        else {\n          const St = ht.parentElement;\n          St.classList.contains(\"sn_ch\") ? St.parentElement.insertBefore(bt, St) : St.insertBefore(bt, ht);\n        }\n        U += 2, U < yt && (U = yt), $ = -1;\n        break;\n      }\n    } while ($ < 0);\n    const V = CmnLib.debugLog ? (pt, mt) => console.log(`\\u{1F34C} masume ch:${pt.ch} x:${mt.x} y:${mt.y} w:${mt.width} h:${mt.height}`) : () => {\n    }, X = H(Zt, zs).oCfg.debug.masume ? (pt, mt) => {\n      V(pt, mt), H(this, ai).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(mt.x, mt.y, mt.width, mt.height).endFill();\n    } : () => {\n    }, W = CmnTween.ease(H(this, zi));\n    for (let pt = o; pt < $; ++pt) {\n      const mt = H(this, ui)[pt], vt = mt.rect, _t = JSON.parse((tt = mt.elm.dataset.arg) != null ? tt : '{\"delay\": 0}'), xt = JSON.parse((et = mt.elm.dataset.add) != null ? et : \"{}\"), Rt = H(Zt, hi)[xt.ch_in_style];\n      if (X(mt, vt), mt.elm.dataset.cmd === \"grp\") {\n        const yt = new Container();\n        H(this, Vr).addChild(yt), GrpLayer.csv2Sprites(_t.pic, yt, (ht) => {\n          ot(this, Mo, qc).call(this, yt, _t, xt, vt, W, Rt != null ? Rt : {}), yt.parent || yt.removeChild(ht);\n        });\n      }\n      if (mt.elm.dataset.lnk) {\n        const yt = mt.elm.parentElement.closest(\"[data-arg]\"), ht = JSON.parse((Q = yt.dataset.arg) != null ? Q : \"{}\");\n        ht.key = `lnk=[${pt}] ` + this.name;\n        const bt = new Sprite();\n        ot(this, Mo, qc).call(this, bt, ht, xt, vt, W, Rt != null ? Rt : {});\n        const St = (at = ht.style) != null ? at : \"\", Ot = St + ((it = ht.style_hover) != null ? it : \"\"), wt = St + ((st = ht.style_clicked) != null ? st : \"\"), Ft = (ut = ht.r_style) != null ? ut : \"\", dt = Ft + ((ft = ht.r_style_hover) != null ? ft : \"\"), Gt = Ft + ((ct = ht.r_style_clicked) != null ? ct : \"\"), Mt = yt.querySelectorAll(\"rt\");\n        Mt.forEach((Et) => Et.dataset.st_r_bk = Et.style.cssText);\n        const Bt = yt.style.cssText, Dt = (Et, zt) => {\n          yt.style.cssText = Bt + Et, Mt.forEach((It) => It.style.cssText = It.dataset.st_r_bk + zt);\n        };\n        H(Zt, In).button(\n          ht,\n          bt,\n          () => Dt(St, Ft),\n          () => this.canFocus() ? (Dt(Ot, dt), !0) : !1,\n          () => Dt(wt, Gt)\n        ), H(this, Vr).addChild(bt);\n      }\n    }\n    const Y = H(this, le).querySelectorAll(\"span.sn_ch\");\n    if (nt(this, li, () => (nt(this, li, () => !1), Y.forEach((pt) => pt.className = pt.className.replaceAll(/ go_ch_in_[^\\s\"]+/g, \"\")), H(Zt, Xr).position.set(\n      H(this, Xe),\n      H(this, We)\n    ), H(Zt, Xr).visible = !0, H(Zt, In).noticeCompTxt(), !0)), Y.length === 0) {\n      const pt = globalThis.getComputedStyle(H(this, le)), mt = parseFloat(pt.fontSize);\n      H(this, Ir) ? (nt(this, Xe, (H(this, Xt).$width - H(this, Xt).pad_left - H(this, Xt).pad_right - mt * 1.5) * this.sys.cvsScale), nt(this, We, 0)) : (nt(this, Xe, 0), nt(this, We, mt / 2 * this.sys.cvsScale)), H(this, li).call(this);\n      return;\n    }\n    Y.forEach((pt) => pt.className = pt.className.replaceAll(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\"));\n    let Z;\n    for (let pt = $ - 1; pt >= 0; --pt) {\n      const mt = H(this, ui)[pt];\n      if (mt.elm.tagName !== \"SPAN\")\n        continue;\n      const vt = mt.rect;\n      if (nt(this, Xe, vt.x + (H(this, Ir) ? 0 : vt.width)), nt(this, We, vt.y + (H(this, Ir) ? vt.height : 0)), pt !== $) {\n        const _t = H(this, ui)[$ - 1].rect;\n        H(this, Ir) ? H(this, We) < _t.y + _t.height && nt(this, We, _t.y + _t.height) : H(this, Xe) < _t.x + _t.width && nt(this, Xe, _t.x + _t.width);\n      }\n      Z = mt.elm;\n      break;\n    }\n    if (!Z || o === $) {\n      H(this, li).call(this);\n      return;\n    }\n    Z.addEventListener(\"animationend\", H(this, li), { once: !0, passive: !0 });\n  }\n  skipChIn() {\n    let e = H(this, li).call(this);\n    for (const o of H(this, Ws))\n      o.tw && (o.tw.stop().end(), e = !0);\n    return nt(this, Ws, []), e;\n  }\n  static initChStyle() {\n    nt(Zt, hi, /* @__PURE__ */ Object.create(null)), nt(Zt, ci, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(e) {\n    return H(Zt, hi)[e];\n  }\n  static ch_in_style(e) {\n    var N, D, B;\n    const { name: o } = e;\n    if (!o)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (H(Zt, Do).test(o))\n      throw `name\\u3010${o}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (o in H(Zt, hi))\n      throw `name\\u3010${o}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const T = String((N = e.x) != null ? N : \"=0\"), S = String((D = e.y) != null ? D : \"=0\");\n    return H(Zt, hi)[o] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: T,\n      y: S,\n      nx: parseFloat(T.charAt(0) === \"=\" ? T.slice(1) : T),\n      ny: parseFloat(S.charAt(0) === \"=\" ? S.slice(1) : S),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !0),\n      ease: (B = e.ease) != null ? B : \"ease-out\"\n    };\n  }\n  static getChOutStyle(e) {\n    return H(Zt, ci)[e];\n  }\n  static ch_out_style(e) {\n    var N, D, B;\n    const { name: o } = e;\n    if (!o)\n      throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    if (H(Zt, Do).test(o))\n      throw `name\\u3010${o}\\u3011\\u306B\\u4F7F\\u3048\\u306A\\u3044\\u6587\\u5B57\\u304C\\u542B\\u307E\\u308C\\u307E\\u3059`;\n    if (o in H(Zt, ci))\n      throw `name\\u3010${o}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n    const T = String((N = e.x) != null ? N : \"=0\"), S = String((D = e.y) != null ? D : \"=0\");\n    return H(Zt, ci)[o] = {\n      wait: argChk_Num(e, \"wait\", 500),\n      alpha: argChk_Num(e, \"alpha\", 0),\n      x: T,\n      y: S,\n      nx: parseFloat(T.charAt(0) === \"=\" ? T.slice(1) : T),\n      ny: parseFloat(S.charAt(0) === \"=\" ? S.slice(1) : S),\n      scale_x: argChk_Num(e, \"scale_x\", 1),\n      scale_y: argChk_Num(e, \"scale_y\", 1),\n      rotate: argChk_Num(e, \"rotate\", 0),\n      join: argChk_Boolean(e, \"join\", !1),\n      ease: (B = e.ease) != null ? B : \"ease-out\"\n    };\n  }\n  dispBreak(e) {\n    const o = H(Zt, Xr);\n    o.visible = !1, this.addChild(o), GrpLayer.csv2Sprites(e, o, (T) => {\n      o.parent || o.removeChild(T);\n    });\n  }\n  static delBreak() {\n    const e = H(Zt, Xr);\n    e.parent && (e.parent.removeChild(e), e.removeChildren()), nt(Zt, Xr, new Container());\n  }\n  reNew() {\n    var o;\n    ot(this, Fo, Kc).call(this);\n    const e = new Zt(this.spLay, () => this.canFocus(), this.sys);\n    return nt(e, Xt, H(this, Xt)), H(e, le).style.cssText = H(this, le).style.cssText, nt(e, Rr, H(this, Rr)), e.name = this.name, ot(o = e, Vs, nl).call(o), H(e, ur).sethArg(H(this, ur).gethArg()), nt(e, wn, H(this, wn)), nt(e, zi, H(this, zi)), nt(e, Nn, H(this, Nn)), nt(e, oi, H(this, oi)), nt(e, Xe, H(this, Xe)), nt(e, We, H(this, We)), this.destroy(), e;\n  }\n  record() {\n    return {\n      infTL: H(this, Xt),\n      cssText: H(this, le).style.cssText,\n      left: H(this, Rr),\n      idc_hArg: H(this, ur).gethArg(),\n      ch_filter: H(this, wn),\n      fi_easing: H(this, zi),\n      fo_easing: H(this, Nn),\n      break_fixed: H(this, oi),\n      break_fixed_left: H(this, Xe),\n      break_fixed_top: H(this, We)\n    };\n  }\n  playback(e) {\n    var o, T, S;\n    nt(this, Xt, e.infTL), this.position.set(H(this, Xt).pad_left, H(this, Xt).pad_top), H(this, le).style.cssText = e.cssText, nt(this, Rr, e.left), ot(this, Vs, nl).call(this), H(this, ur).sethArg(e.idc_hArg), nt(this, wn, e.ch_filter), nt(this, zi, e.fi_easing), nt(this, Nn, e.fo_easing), nt(this, oi, (o = e.break_fixed) != null ? o : !1), nt(this, Xe, (T = e.break_fixed_left) != null ? T : 0), nt(this, We, (S = e.break_fixed_top) != null ? S : 0);\n  }\n  snapshot(e, o) {\n    ot(this, ah, od).call(this, (T) => {\n      nt(this, vr, new Sprite(T)), H(this, Ir) && (H(this, vr).x += CmnLib.stageW - (H(this, Rr) + H(this, Xt).$width)), H(this, vr).y -= H(this, Xs), H(this, vr).texture.frame = new Rectangle(0, 0, H(this, Xt).$width - H(this, Rr), H(this, Xt).$height), H(this, Vr).addChild(H(this, vr)), e.render(H(this, vr), void 0, !1), o();\n    }, !1);\n  }\n  snapshot_end() {\n    H(this, vr) && (H(this, Vr).removeChild(H(this, vr)), nt(this, vr, void 0));\n  }\n  makeDesignCast(e) {\n    e(H(this, ur));\n    const o = H(this, ur).gethArg();\n    H(this, ji).sethArg({ ...o, \":id_dc\": o[\":id_tag\"] + \"_pad\" }), e(H(this, ji));\n  }\n  showDesignCast() {\n    H(this, ur).visible = !0, H(this, ji).visible = !0;\n  }\n  dump() {\n    const e = [], o = H(this, le).style, T = o.length;\n    for (let S = 0; S < T; ++S) {\n      const N = o[S];\n      e.push(`\"${N}\":\"${o[N].replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${H(this, le).textContent.replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${e.join(\",\")}}`;\n  }\n  destroy() {\n    Zt.delBreak(), H(this, le).parentElement.removeChild(H(this, le)), this.removeChild(H(this, Vr)), this.removeChild(H(this, ai)), super.destroy();\n  }\n};\nlet TxtStage = Zt;\nzs = new WeakMap(), Oo = new WeakMap(), In = new WeakMap(), le = new WeakMap(), Vr = new WeakMap(), ai = new WeakMap(), sh = new WeakMap(), ur = new WeakMap(), ji = new WeakMap(), Xt = new WeakMap(), oi = new WeakMap(), Xe = new WeakMap(), We = new WeakMap(), Vs = new WeakSet(), nl = function() {\n  var S;\n  const e = H(this, le).style, o = parseFloat(e.fontSize || \"0\");\n  H(this, Xt).fontsize = o, H(this, Xt).pad_left = parseFloat(e.paddingLeft || \"0\"), H(this, Xt).pad_right = parseFloat(e.paddingRight || \"0\"), H(this, Xt).pad_top = parseFloat(e.paddingTop || \"0\"), H(this, Xt).pad_bottom = parseFloat(e.paddingBottom || \"0\"), H(this, Xt).$width = parseFloat(e.width || \"0\"), H(this, Xt).$height = parseFloat(e.height || \"0\"), this.position.set(H(this, Xt).pad_left, H(this, Xt).pad_top), nt(this, Ir, e.writingMode === \"vertical-rl\"), nt(this, No, 0), nt(this, Xs, 0);\n  const T = (S = e.lineHeight) != null ? S : \"0\";\n  nt(this, qs, H(this, Ir) ? 0 : (T.slice(-2) === \"px\" ? parseFloat(T) : o * parseFloat(T) - o) / 2);\n}, Rr = new WeakMap(), Ir = new WeakMap(), No = new WeakMap(), Xs = new WeakMap(), ah = new WeakSet(), od = function(e, o = !0) {\n  const T = {\n    escape: (q) => q.replaceAll(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (q) => {\n      const Z = $(q).toLowerCase();\n      return S()[Z] || \"\";\n    },\n    dataAsUrl: X,\n    isDataUrl: U,\n    resolveUrl: z,\n    getAndEncode: V,\n    asArray: (q) => {\n      const Z = [], K = q.length;\n      for (let J = 0; J < K; ++J)\n        Z.push(q[J]);\n      return Z;\n    }\n  };\n  function S() {\n    const q = \"application/font-woff\", Z = \"image/jpeg\";\n    return {\n      woff: q,\n      woff2: q,\n      ttf: \"application/font-truetype\",\n      eot: \"application/vnd.ms-fontobject\",\n      png: \"image/png\",\n      jpg: Z,\n      jpeg: Z,\n      gif: \"image/gif\",\n      tiff: \"image/tiff\",\n      svg: \"image/svg+xml\"\n    };\n  }\n  const N = W(), D = Y();\n  function B(q) {\n    return D.resolveAll().then((Z) => {\n      const K = document.createElement(\"style\");\n      return q.appendChild(K), K.appendChild(document.createTextNode(Z)), q;\n    });\n  }\n  function $(q) {\n    var K;\n    const Z = /\\.([^\\.\\/]*?)$/g.exec(q);\n    return (K = Z == null ? void 0 : Z[1]) != null ? K : \"\";\n  }\n  function U(q) {\n    return q.search(/^(data:)/) !== -1;\n  }\n  function z(q, Z) {\n    const K = document.implementation.createHTMLDocument(), J = K.createElement(\"base\");\n    K.head.appendChild(J);\n    const tt = K.createElement(\"a\");\n    return K.body.appendChild(tt), J.href = Z, tt.href = q, tt.href;\n  }\n  function V(q) {\n    let Z = 3e4;\n    return new Promise(function(K) {\n      const J = new XMLHttpRequest();\n      J.onreadystatechange = tt, J.ontimeout = et, J.responseType = \"blob\", J.timeout = Z, J.open(\"GET\", q, !0), J.send();\n      function tt() {\n        if (J.readyState !== 4)\n          return;\n        if (J.status !== 200) {\n          Q(\"cannot fetch resource: \" + q + \", status: \" + J.status);\n          return;\n        }\n        const at = new FileReader();\n        at.onloadend = function() {\n          const it = at.result.toString().split(/,/)[1];\n          K(it);\n        }, at.readAsDataURL(J.response);\n      }\n      function et() {\n        Q(\"timeout of \" + Z + \"ms occured while fetching resource: \" + q);\n      }\n      function Q(at) {\n        console.error(at), K(\"\");\n      }\n    });\n  }\n  function X(q, Z) {\n    return \"data:\" + Z + \";base64,\" + q;\n  }\n  function W() {\n    const q = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll: tt,\n      shouldProcess: Z\n    };\n    function Z(et) {\n      return et.search(q) !== -1;\n    }\n    function K(et) {\n      const Q = [];\n      let at;\n      for (; at = q.exec(et); )\n        Q.push(at[1]);\n      return Q.filter(function(it) {\n        return !T.isDataUrl(it);\n      });\n    }\n    function J(et, Q, at, it) {\n      return Promise.resolve(Q).then((ut) => at ? T.resolveUrl(ut, at) : ut).then(it || T.getAndEncode).then((ut) => T.dataAsUrl(ut, T.mimeType(Q))).then((ut) => et.replace(st(Q), \"$1\" + ut + \"$3\"));\n      function st(ut) {\n        return new RegExp(`(url\\\\(['\"]?)(` + T.escape(ut) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function tt(et, Q, at) {\n      if (it())\n        return Promise.resolve(et);\n      return Promise.resolve(et).then(K).then((st) => {\n        let ut = Promise.resolve(et);\n        for (const ft of st)\n          ut = ut.then((ct) => J(ct, ft, Q, at));\n        return ut;\n      });\n      function it() {\n        return !Z(et);\n      }\n    }\n  }\n  function Y() {\n    return {\n      resolveAll: q,\n      impl: { readAll: Z }\n    };\n    function q() {\n      return Z().then((K) => Promise.allSettled(\n        K.map((J) => J.resolve())\n      )).then((K) => K.join(`\n`));\n    }\n    function Z() {\n      return Promise.resolve(T.asArray(document.styleSheets)).then(J).then(K).then((et) => et.map(tt));\n      function K(et) {\n        return et.filter((Q) => Q.type === CSSRule.FONT_FACE_RULE).filter((Q) => N.shouldProcess(Q.style.getPropertyValue(\"src\")));\n      }\n      function J(et) {\n        const Q = [];\n        for (const at of et)\n          try {\n            if (at.href)\n              continue;\n            T.asArray(at.cssRules || []).forEach(Q.push.bind(Q));\n          } catch (it) {\n            console.error(\"Error while reading CSS rules from \" + at.href, it.toString());\n          }\n        return Q;\n      }\n      function tt(et) {\n        return {\n          resolve: function() {\n            const at = (et.parentStyleSheet || {}).href;\n            return N.inlineAll(et.cssText, at);\n          },\n          src: function() {\n            return et.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(H(this, le)).then((q) => {\n    const Z = q.cloneNode(!0);\n    return Z.style.padding = \"0px\", Z.style.paddingRight = H(this, No) + \"px\", Z.style.paddingTop = H(this, Xs) + \"px\", Z.style.left = \"0px\", Z.style.top = \"0px\", Z.style.width = H(this, Xt).$width - H(this, Xt).pad_left - H(this, Xt).pad_right + \"px\", Z.style.height = H(this, Xt).$height - H(this, Xt).pad_top - H(this, Xt).pad_bottom + \"px\", H(this, le).hidden = o, Z;\n  }).then(B).then((q) => {\n    q.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const Z = new Image();\n    return Z.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${H(this, Xt).$width}px\" height=\"${H(this, Xt).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(q).replaceAll(\"#\", \"%23\").replaceAll(`\n`, \"%0A\")}</foreignObject></svg>`, new Promise((K) => Z.onload = () => K(Z));\n  }).then((q) => new Promise((Z) => setTimeout(() => Z(q), 100))).then((q) => {\n    const Z = document.createElement(\"canvas\");\n    Z.width = H(this, Xt).$width, Z.height = H(this, Xt).$height, Z.getContext(\"2d\").drawImage(q, 0, 0), Z.toBlob((K) => {\n      if (!K)\n        return;\n      const J = URL.createObjectURL(K);\n      Texture.from(J).once(\"update\", (tt) => {\n        e(tt), URL.revokeObjectURL(J);\n      });\n    });\n  }).catch((q) => DebugMng.myTrace(`goTxt() = ${q}`));\n}, wn = new WeakMap(), Ws = new WeakMap(), ui = new WeakMap(), Pn = new WeakMap(), An = new WeakMap(), On = new WeakMap(), Ys = new WeakMap(), li = new WeakMap(), Mo = new WeakSet(), qc = function(e, o, T, S, N, D) {\n  var $, U, z;\n  e.alpha = 0, o.x && (S.x = o.x.charAt(0) === \"=\" ? S.x + parseInt(o.x.slice(1)) : parseInt(o.x)), o.y && (S.y = o.y.charAt(0) === \"=\" ? S.y + parseInt(o.y.slice(1)) : parseInt(o.y)), o.width && (S.width = parseInt(o.width)), o.height && (S.height = parseInt(o.height)), o.wait && (D.wait = parseInt(o.wait)), e.width = S.width, e.height = S.height, D.x ? e.position.set(\n    D.x.charAt(0) === \"=\" ? S.x + e.width * D.nx : D.nx,\n    D.y.charAt(0) === \"=\" ? S.y + e.height * D.ny : D.ny\n  ) : e.position.set(S.x, S.y);\n  const B = {\n    sp: e,\n    tw: new Tween(e).to({ alpha: 1, x: S.x, y: S.y, width: S.width, height: S.height, angle: 0 }, ($ = D.wait) != null ? $ : 0).easing(N).delay(((U = T.wait) != null ? U : 0) + ((z = o.delay) != null ? z : 0)).onComplete(() => {\n      B.tw = void 0;\n    }).start()\n  };\n  H(this, Ws).push(B);\n}, hi = new WeakMap(), Do = new WeakMap(), ci = new WeakMap(), Xr = new WeakMap(), qs = new WeakMap(), Lo = new WeakSet(), Zc = function(e, o) {\n  const T = [];\n  if (e.nodeType !== e.TEXT_NODE)\n    return Array.from(e.childNodes).map((B) => ot(this, Lo, Zc).call(this, B, o)).flat();\n  const S = e.ownerDocument.createRange();\n  S.selectNodeContents(e);\n  let N = 0;\n  const D = S.endOffset;\n  for (; N < D; ) {\n    S.setStart(e, N), S.setEnd(e, ++N);\n    const B = S.toString();\n    T.push({\n      ch: B,\n      rect: o(S.getBoundingClientRect(), B),\n      elm: S.startContainer.parentElement\n    });\n  }\n  return S.detach(), T;\n}, zi = new WeakMap(), Nn = new WeakMap(), Fo = new WeakSet(), Kc = function() {\n  var N;\n  H(this, ai).clear(), nt(this, ui, []), nt(this, Pn, 0), this.skipChIn();\n  const e = H(this, le).cloneNode(!0);\n  e.textContent = \"\";\n  const o = H(this, le);\n  o.parentElement.insertBefore(e, o);\n  let T = 0;\n  o.querySelectorAll(\"span.sn_ch\").forEach((D) => {\n    var U, z, V, X, W, Y;\n    const B = JSON.parse(\n      (Y = (W = (z = D == null ? void 0 : D.dataset.add) != null ? z : (U = D == null ? void 0 : D.children[0]) == null ? void 0 : U.getAttribute(\"data-add\")) != null ? W : (X = (V = D == null ? void 0 : D.children[0]) == null ? void 0 : V.children[0]) == null ? void 0 : X.getAttribute(\"data-add\")) != null ? Y : \"{}\"\n    );\n    if (!B.ch_out_style)\n      return;\n    const $ = H(Zt, ci)[B.ch_out_style];\n    if (!!$) {\n      if ($.wait === 0) {\n        D.style.display = \"none\";\n        return;\n      }\n      T += $.wait, $.join || (D.style.animationDelay = \"0ms\"), D.classList.add(`go_ch_out_${B.ch_out_style}`);\n    }\n  });\n  const S = () => {\n    o.parentElement.removeChild(o);\n    for (const D of H(this, Vr).removeChildren())\n      D instanceof Container && H(Zt, In).unButton(D), D.destroy();\n  };\n  T === 0 ? (H(this, le).textContent = \"\", S()) : (N = o.lastElementChild) == null || N.addEventListener(\"animationend\", S, { once: !0, passive: !0 }), nt(this, le, e);\n}, vr = new WeakMap(), rt(TxtStage, zs, void 0), rt(TxtStage, Oo, void 0), rt(TxtStage, In, void 0), rt(TxtStage, sh, {\n  \"background-color\": 0,\n  \"border-bottom-width\": 0,\n  \"border-left-width\": 0,\n  \"border-right-width\": 0,\n  \"border-top-width\": 0,\n  \"margin-bottom\": 0,\n  \"margin-left\": 0,\n  \"margin-right\": 0,\n  \"margin-top\": 0\n}), rt(TxtStage, An, void 0), rt(TxtStage, On, void 0), rt(TxtStage, Ys, void 0), rt(TxtStage, hi, /* @__PURE__ */ Object.create(null)), rt(TxtStage, Do, /[\\s\\.,]/), rt(TxtStage, ci, /* @__PURE__ */ Object.create(null)), rt(TxtStage, Xr, new Container());\nvar Bo, ko, wr, fi, Zs, Ks, $o, Jc, Js, Qs, Uo, Qc;\nconst an = class extends Container {\n  constructor(e, o, T, S) {\n    var W, Y, q, Z;\n    super();\n    rt(this, $o);\n    rt(this, Uo);\n    Pt(this, \"getBtnBounds\", () => H(this, wr));\n    rt(this, wr, new Rectangle());\n    rt(this, fi, void 0);\n    rt(this, Zs, void 0);\n    rt(this, Ks, void 0);\n    Pt(this, \"normal\", () => {\n    });\n    rt(this, Js, () => !1);\n    rt(this, Qs, () => {\n    });\n    this.hArg = e, this.evtMng = o, this.resolve = T, this.canFocus = S, CmnLib.isDbg && (this.makeDesignCast = (K) => K(H(this, fi)), this.cvsResize = () => H(this, fi).cvsResize());\n    let N = {\n      x: this.x = uint((W = e.left) != null ? W : 0),\n      y: this.y = uint((Y = e.top) != null ? Y : 0),\n      rotation: this.angle = argChk_Num(e, \"rotation\", this.angle),\n      pivot_x: this.pivot.x = argChk_Num(e, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = argChk_Num(e, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = argChk_Num(e, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = argChk_Num(e, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    this.getBtnBounds = () => (H(this, wr).x = N.x, H(this, wr).y = N.y, H(this, wr));\n    const D = N.enabled = argChk_Boolean(e, \"enabled\", !0);\n    if (D && o.button(this.hArg, this, () => this.normal(), () => H(this, Js).call(this), () => H(this, Qs).call(this)), e.pic) {\n      N.type = \"pic\", nt(this, fi, new PicBtnDesignCast(this, e)), GrpLayer.csv2Sprites(\n        e.pic,\n        this,\n        (K) => {\n          ot(this, Uo, Qc).call(this, K, N), H(this, wr).width = K.width * N.scale_x, H(this, wr).height = K.height * N.scale_y;\n        },\n        (K) => T\n      );\n      return;\n    }\n    if (!e.text)\n      throw \"text\\u307E\\u305F\\u306Fpic\\u5C5E\\u6027\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n    const B = argChk_Num(e, \"height\", 30), $ = new TextStyle({\n      align: \"center\",\n      dropShadow: !0,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: \"black\",\n      fontFamily: an.fontFamily,\n      fontSize: B,\n      padding: 5\n    });\n    if (e.style)\n      try {\n        const K = JSON.parse(e.style);\n        for (const [J, tt] of Object.entries(K))\n          $[J] = tt;\n      } catch (K) {\n        throw new Error(mesErrJSON(e, \"style\", K.message));\n      }\n    const U = new Text((q = e.text) != null ? q : \"\", $);\n    U.alpha = argChk_Num(e, \"alpha\", U.alpha), U.width = argChk_Num(e, \"width\", 100), U.height = e.height = B, this.setText = (K) => U.text = K, N.type = \"text\", N = { ...N, ...$ }, N.alpha = U.alpha, N.text = U.text, N.width = U.width, N.height = U.height, nt(this, fi, new TxtBtnDesignCast(this, e, U));\n    let z = !1;\n    if (e.b_pic && (N.b_pic = e.b_pic, z = GrpLayer.csv2Sprites(\n      e.b_pic,\n      this,\n      (K) => {\n        ot(this, $o, Jc).call(this, K, U), N.width = this.width, N.height = this.height;\n      },\n      (K) => {\n        Layer.setBlendmode(this, e), K && T();\n      }\n    )), U.name = JSON.stringify(N), this.addChild(U), H(this, wr).width = U.width, H(this, wr).height = U.height, N.width = this.width, N.height = this.height, e.b_pic || Layer.setBlendmode(this, e), H(Z = an, Bo).call(Z, this, U), !D) {\n      z || T();\n      return;\n    }\n    const V = $.clone();\n    if (e.style_hover)\n      try {\n        const K = JSON.parse(e.style_hover);\n        for (const [J, tt] of Object.entries(K))\n          V[J] = tt;\n      } catch (K) {\n        throw new Error(mesErrJSON(e, \"style_hover\", K.message));\n      }\n    else\n      V.fill = \"white\";\n    const X = V.clone();\n    if (e.style_clicked)\n      try {\n        const K = JSON.parse(e.style_clicked);\n        for (const [J, tt] of Object.entries(K))\n          X[J] = tt;\n      } catch (K) {\n        throw new Error(mesErrJSON(e, \"style_clicked\", K.message));\n      }\n    else\n      X.dropShadow = !1;\n    this.normal = () => U.style = $, nt(this, Js, () => S() ? (U.style = V, !0) : !1), nt(this, Qs, () => U.style = X), z || T();\n  }\n  static init(e) {\n    !e.oCfg.debug.masume || (nt(an, Bo, (o, T) => o.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(T.x, T.y, T.width, T.height).endFill()\n    )), nt(an, ko, (o, T, S, N) => o.addChild(\n      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(T.x, T.y, S, N).endFill()\n    )));\n  }\n  setText(e) {\n  }\n  destroy(e) {\n    this.evtMng.unButton(this), super.destroy();\n  }\n  makeDesignCast(e) {\n  }\n  showDesignCast() {\n    H(this, fi).visible = !0;\n  }\n  cvsResize() {\n  }\n  update_b_pic(e, o) {\n    var S;\n    const T = JSON.parse((S = o.name) != null ? S : \"{}\");\n    H(this, Zs) && this.removeChild(H(this, Zs)), this.hArg.b_pic = T.b_pic = e, o.name = JSON.stringify(T), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (N) => ot(this, $o, Jc).call(this, N, o),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n  update_pic(e, o) {\n    var S;\n    const T = JSON.parse((S = o.name) != null ? S : \"{}\");\n    H(this, Ks) && this.removeChild(H(this, Ks)), this.hArg.pic = T.pic = e, o.name = JSON.stringify(T), e && GrpLayer.csv2Sprites(\n      e,\n      this,\n      (N) => ot(this, Uo, Qc).call(this, N, T),\n      () => Layer.setBlendmode(this, this.hArg)\n    );\n  }\n};\nlet Button = an;\nBo = new WeakMap(), ko = new WeakMap(), wr = new WeakMap(), fi = new WeakMap(), Zs = new WeakMap(), Ks = new WeakMap(), $o = new WeakSet(), Jc = function(e, o) {\n  nt(this, Zs, e), this.setChildIndex(e, 0), e.alpha = o.alpha, e.setTransform(\n    o.x,\n    o.y,\n    1,\n    1,\n    o.rotation,\n    0,\n    0,\n    (e.width - o.width) / 2,\n    (e.height - o.height) / 2\n  ), e.name = o.name;\n}, Js = new WeakMap(), Qs = new WeakMap(), Uo = new WeakSet(), Qc = function(e, o) {\n  var z;\n  nt(this, Ks, e), o.alpha = e.alpha = argChk_Num(this.hArg, \"alpha\", e.alpha), H(this, fi).setSp(e);\n  const T = e.width / 3, S = e.height, N = e.texture.baseTexture, D = new Texture(N, new Rectangle(0, 0, T, S)), B = new Texture(N, new Rectangle(T, 0, T, S)), $ = new Texture(N, new Rectangle(T * 2, 0, T, S)), U = () => e.texture = D;\n  U(), this.normal = U, nt(this, Js, () => this.canFocus() ? (e.texture = $, !0) : !1), nt(this, Qs, () => e.texture = B), \"width\" in this.hArg ? (o.width = uint(this.hArg.width), this.scale.x *= o.width / T) : o.width = T, \"height\" in this.hArg ? (o.height = uint(this.hArg.height), this.scale.y *= o.height / T) : o.height = T, e.name = JSON.stringify(o), H(z = an, ko).call(z, this, e, T, S);\n}, Pt(Button, \"fontFamily\", \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif\"), rt(Button, Bo, (e, o) => {\n}), rt(Button, ko, (e, o, T, S) => {\n});\nvar ta, Pr, Go, ea, Ho, tf, jo, ef, zo, Mn, Vo, di, Dn, oh, ud, pi, gr, Ar, ve, Wr, oe, Xo, Yr, uh, Ke, Ln, ka, Fn, ra, Bn, $a, ia, Wo, rf, Yo, nf, kn, $n, na, qo, sa, Vi, Je, lh, ld, lr, Zo, aa, sl, vi, rn, gi, Or, _r, mr, Ko, sf, oa, al, Jo, af, Un;\nconst Jt = class extends Layer {\n  constructor() {\n    super();\n    rt(this, Ln);\n    rt(this, Bn);\n    rt(this, Wo);\n    rt(this, Yo);\n    rt(this, lh);\n    rt(this, aa);\n    rt(this, vi);\n    rt(this, Ko);\n    rt(this, oa);\n    rt(this, Jo);\n    rt(this, pi, 0);\n    rt(this, gr, 0);\n    rt(this, Ar, !1);\n    rt(this, ve, void 0);\n    rt(this, Wr, \"\");\n    rt(this, oe, new TxtStage(this.spLay, () => this.canFocus(), H(Jt, Vo)));\n    rt(this, Xo, new RubySpliter());\n    rt(this, Yr, document.createElement(\"span\"));\n    rt(this, Ke, new Container());\n    rt(this, Fn, \"\");\n    rt(this, ra, !0);\n    rt(this, ia, \"\");\n    rt(this, kn, \"\");\n    rt(this, $n, (e) => \"\");\n    rt(this, na, \"\");\n    rt(this, qo, new RegExp(\"[\\u3000]\"));\n    Pt(this, \"isCur\", !1);\n    rt(this, Vi, () => \"\");\n    rt(this, Je, \"\");\n    rt(this, lr, !1);\n    rt(this, Zo, (e, o) => {\n      var $, U, z, V, X, W, Y, q, Z, K;\n      H(Jt, ta).oCfg.debug.putCh && console.log(`\\u{1F58A} \\u6587\\u5B57\\u8868\\u793A text:\\`${e}\\` ruby:\\`${o}\\` name:\\`${this.name_}\\``);\n      const T = o.split(\"\\uFF5C\");\n      let S = \"\";\n      const [N, ...D] = T, B = D.join(\"\\uFF5C\");\n      switch (T.length) {\n        case 1:\n          if (nt(this, lr, !0), e === `\n`) {\n            H(this, Or) ? (nt(this, Or, !1), S = \"<ruby>\\u3000<rt>\\u3000</rt></ruby><br/>\") : S = \"<br/>\";\n            break;\n          }\n          H(this, Or) && (nt(this, Or, !1), o === \"\" && (o = \"\\u3000\")), S = ot(this, aa, sl).call(this, e, o, H(this, Je));\n          break;\n        default:\n          switch (N) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              nt(this, Or, !1), nt(this, lr, !0), S = ot(this, aa, sl).call(this, e, B, N);\n              break;\n            case \"gotxt\":\n              ot(this, oa, al).call(this), H(this, lr) ? (this.isCur && H(Jt, ea).recText(\n                H(this, _r).join(\"\").replace(/^<ruby><rt><\\/rt><\\/ruby>(<br\\/>)+/, \"\").replaceAll(/style='(anim\\S+ \\S+?;\\s*)+/g, \"style='\").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replaceAll(/class='sn_ch .+?'/g, \"class='sn_ch'\").replaceAll(\"display: none;\", \"\").replaceAll(\"class='offrec'\", \"style='display: none;'\")\n              ), H(this, oe).goTxt(H(this, _r)), nt(this, lr, !1), nt(this, gi, 0)) : this.isCur && H(Jt, Mn).noticeCompTxt();\n              return;\n            case \"add\":\n              {\n                const J = JSON.parse(B), { style: tt = \"\", wait: et = null } = J, { cl: Q, sty: at } = ot(this, vi, rn).call(this, !0, et);\n                H(this, _r).push(`<span${Q} style='${at} display: inline; ${tt}'>`), delete J.style, ot(this, Ko, sf).call(this, J);\n              }\n              return;\n            case \"add_close\":\n              H(this, _r).push(\"</span>\"), ot(this, oa, al).call(this);\n              return;\n            case \"grp\":\n              nt(this, lr, !0);\n              {\n                const J = JSON.parse(B);\n                if (($ = J.id) != null || (J.id = H(this, _r).length), J.id === \"break\") {\n                  H(this, oe).dispBreak(J.pic);\n                  return;\n                }\n                nt(this, Or, !1), J.delay = H(this, gi), (U = J.r) != null || (J.r = \"\"), (z = J.style) != null || (J.style = \"\"), (V = J.r_style) != null || (J.r_style = \"\");\n                const { cl: tt, sty: et, lnk: Q } = ot(this, vi, rn).call(this, !0, J.wait);\n                S = `<span${tt} style='${et} ${J.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(J)}'${Q} style='${et} display: inline;'>\\u3000</span><rt${Q}${this.mkStyle_r_align(\n                  \"\\u3000\",\n                  J.r,\n                  H(this, Je),\n                  H(this, Yr).style.cssText + ((W = (X = H(this, mr).at(-1)) == null ? void 0 : X.o.r_style) != null ? W : \"\") + J.r_style\n                )}>${J.r}</rt></ruby></span>`;\n              }\n              break;\n            case \"tcy\":\n              nt(this, Or, !1), nt(this, lr, !0);\n              {\n                H(Jt, Pr).doRecLog() && nt(this, Un, H(this, Un) + (e + (o ? `\\u300A${o}\\u300B` : \"\")));\n                const { t: J, r: tt = \"\", wait: et = null, style: Q = \"\", r_style: at = \"\" } = JSON.parse(B), it = CmnLib.isSafari ? tt.replaceAll(/[A-Za-z0-9]/g, (ct) => String.fromCharCode(ct.charCodeAt(0) + 65248)) : tt, { cl: st, sty: ut, lnk: ft } = ot(this, vi, rn).call(this, !0, et);\n                S = `<span${st} style='${ut}${H(this, $n).call(this, J)} ${Q}'><ruby><span${ft} style='${ut} display: inline;\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;'>${J}</span><rt${ft}${this.mkStyle_r_align(\n                  J,\n                  it,\n                  H(this, Je),\n                  H(this, Yr).style.cssText + ((q = (Y = H(this, mr).at(-1)) == null ? void 0 : Y.o.r_style) != null ? q : \"\") + at\n                )}>${it}</rt></ruby></span>`;\n              }\n              break;\n            case \"del\":\n              TxtStage.delBreak();\n              return;\n            case \"span\":\n              nt(this, lr, !0), ot(this, Jo, af).call(this, JSON.parse(B));\n              return;\n            case \"link\":\n              nt(this, lr, !0);\n              {\n                const J = JSON.parse(B);\n                J[\":link\"] = \" data-lnk='@'\";\n                const { cl: tt, sty: et, curpos: Q } = ot(this, vi, rn).call(this, !1, J.wait);\n                H(this, _r).push(`<span${tt} style='${et} display: inline; ${(Z = J.style) != null ? Z : \"\"}' ${Q} data-arg='${B}'>`), delete J.style, ot(this, Jo, af).call(this, J);\n              }\n              return;\n            case \"endlink\":\n              nt(this, lr, !0), H(this, _r).push(\"</span>\"), ot(this, oa, al).call(this);\n              return;\n            default:\n              nt(this, lr, !0), S = ot(this, aa, sl).call(this, e, o, H(this, Je));\n          }\n          break;\n      }\n      H(this, _r).push(H(K = Jt, sa).call(K, S));\n    });\n    rt(this, gi, 0);\n    rt(this, Or, !0);\n    rt(this, _r, []);\n    rt(this, mr, []);\n    Pt(this, \"click\", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : H(this, oe).skipChIn());\n    rt(this, Un, \"\");\n    Pt(this, \"addButton\", (e) => new Promise((o) => {\n      e.key = `btn=[${H(this, Ke).children.length}] ` + this.name_, e[\":id_tag\"] = e.key.slice(0, -7), argChk_Boolean(e, \"hint_tate\", H(this, oe).tategaki);\n      const T = new Button(e, H(Jt, Mn), () => o(), () => this.canFocus());\n      T.name = JSON.stringify(e).replaceAll('\"', \"'\"), H(this, Ke).addChild(T);\n    }));\n    Pt(this, \"record\", () => ({\n      ...super.record(),\n      enabled: this.enabled,\n      r_cssText: H(this, Yr).style.cssText,\n      r_align: H(this, Je),\n      b_do: H(this, ve) === void 0 ? void 0 : H(this, ve) instanceof Sprite ? \"Sprite\" : \"Graphics\",\n      b_pic: H(this, Wr),\n      b_color: H(this, pi),\n      b_alpha: H(this, gr),\n      b_alpha_isfixed: H(this, Ar),\n      ffs: H(this, kn),\n      txs: H(this, oe).record(),\n      strNoFFS: H(this, na),\n      btns: H(this, Ke).children.map((e) => e.name)\n    }));\n    this.spLay.addChild(H(this, oe)), H(this, Xo).init(H(this, Zo)), this.spLay.addChild(H(this, Ke)), H(this, Ke).name = \"cntBtn\";\n    const e = 16;\n    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(e, o, T, S, N, D) {\n    var B, $;\n    nt(Jt, ta, e), TxtStage.init(e, D), nt(Jt, Pr, T), nt(Jt, ea, S), nt(Jt, Go, N), T.setDoRecProc(Jt.chgDoRec), o.autowc = (U) => {\n      var z;\n      return ot(z = Jt, oh, ud).call(z, U);\n    }, o.autowc({ enabled: !1, text: \"\", time: 0 }), o.ch_in_style = (U) => {\n      var z;\n      return ot(z = Jt, Ho, tf).call(z, U);\n    }, o.ch_out_style = (U) => {\n      var z;\n      return ot(z = Jt, jo, ef).call(z, U);\n    }, TxtStage.initChStyle(), initStyle(), addStyle(\n      e.matchPath(\".+\", SEARCH_PATH_ARG_EXT.FONT).flatMap((U) => Object.values(U).map((z) => `\n@font-face {\n\tfont-family: '${z}';\n\tsrc: url('${H(this, ta).searchPath(z, SEARCH_PATH_ARG_EXT.FONT)}');\n}\n`)).join(\"\") + `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`\n    ), ot(B = Jt, Ho, tf).call(B, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !0,\n      ease: \"ease-out\"\n    }), ot($ = Jt, jo, ef).call($, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !1,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(e, o, T) {\n    nt(Jt, zo, e), nt(Jt, Mn, o), nt(Jt, Vo, T), TxtStage.setEvtMng(o);\n  }\n  destroy() {\n    H(this, ve) && (this.spLay.removeChild(H(this, ve)).destroy(), nt(this, ve, void 0)), this.clearText(), H(this, oe).destroy();\n  }\n  static destroy() {\n    nt(Jt, di, !1), nt(Jt, Dn, {}), nt(Jt, sa, (e) => e);\n  }\n  set name(e) {\n    this.name_ = e, H(this, oe).name = e;\n  }\n  get name() {\n    return this.name_;\n  }\n  cvsResize() {\n    H(this, oe).cvsResize();\n  }\n  cvsResizeChildren() {\n    for (const e of H(this, Ke).children)\n      e.cvsResize();\n  }\n  lay(e) {\n    var o;\n    if (super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[\":id_tag\"] = this.name_.slice(0, -7), RubySpliter.setting(e), ot(this, Yo, nf).call(this, e), H(this, oe).lay(e), \"r_align\" in e && nt(this, Je, (o = e.r_align) != null ? o : \"\"), nt(this, Vi, CmnLib.isSafari ? H(this, oe).tategaki ? (T, S) => `text-align: start; height: ${S}em; padding-top: ${T}; padding-bottom: ${T};` : (T, S) => `text-align: start; width: ${S}em; padding-left: ${T}; padding-right: ${T};` : H(this, oe).tategaki ? (T) => `text-align: justify; text-align-last: justify; padding-top: ${T}; padding-bottom: ${T};` : (T) => `text-align: justify; text-align-last: justify; padding-left: ${T}; padding-right: ${T};`), CmnLib.isFirefox && (this.mkStyle_r_align = ot(this, lh, ld)), \"r_style\" in e)\n      if (e.r_style) {\n        const T = document.createElement(\"span\");\n        T.style.cssText = e.r_style;\n        const S = T.style.length, N = H(this, Yr).style;\n        for (let D = 0; D < S; ++D) {\n          const B = T.style[D];\n          if (B in H(Jt, uh)) {\n            DebugMng.myTrace(`${B}\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093`, \"W\");\n            continue;\n          }\n          N[B] = T.style[B];\n        }\n      } else\n        H(this, Yr).style.cssText = \"\";\n    if (\"alpha\" in e)\n      for (const T of H(this, Ke).children)\n        T.alpha = this.spLay.alpha;\n    return ot(this, Ln, ka).call(this, e), ot(this, Bn, $a).call(this, e), ot(this, Wo, rf).call(this, e, (T) => {\n      T && H(Jt, zo).resume();\n    });\n  }\n  get width() {\n    return H(this, oe).getWidth;\n  }\n  get height() {\n    return H(this, oe).getHeight;\n  }\n  chgBackAlpha(e) {\n    const o = H(this, Ar) ? H(this, gr) : e * H(this, gr);\n    H(this, ve) instanceof Graphics && (H(this, ve) && (this.spLay.removeChild(H(this, ve)), H(this, ve).destroy()), this.spLay.addChildAt(\n      nt(this, ve, new Graphics()).beginFill(H(this, pi)).lineStyle(void 0).drawRect(0, 0, H(this, oe).getWidth, H(this, oe).getHeight).endFill(),\n      0\n    ), H(this, ve).name = \"back(color)\"), H(this, ve) && (H(this, ve).visible = o > 0, H(this, ve).alpha = o);\n  }\n  static chgDoRec(e) {\n    nt(Jt, sa, e ? (o) => o : (o) => `<span class='offrec'>${o}</span>`);\n  }\n  mkStyle_r_align(e, o, T, S = \"\") {\n    if (!T)\n      return ` style='${S}'`;\n    const N = e.length * 2;\n    if (N - o.length < 0)\n      return ` style='text-align: ${T}; ${S}'`;\n    let D = \"\";\n    switch (T) {\n      case \"justify\":\n        D = H(this, Vi).call(this, \"0\", N);\n        break;\n      case \"121\":\n        D = H(this, Vi).call(this, `calc(${(N - o.length) / (o.length * 2)}em)`, N);\n        break;\n      case \"even\":\n        D = H(this, Vi).call(this, `calc(${(N - o.length) / (o.length + 1)}em)`, N);\n        break;\n      case \"1ruby\":\n        D = H(this, Vi).call(this, \"1em\", N);\n        break;\n      default:\n        D = `text-align: ${T};`;\n    }\n    return ` style='${D} ${S}'`;\n  }\n  tagCh(e) {\n    H(this, Xo).putTxt(e);\n  }\n  clearText() {\n    this.spLay.addChild(nt(this, oe, H(this, oe).reNew())), nt(this, gi, 0), nt(this, Or, !0), nt(this, _r, []), nt(this, Un, \"\"), H(Jt, ea).recPagebreak();\n  }\n  get pageText() {\n    return H(this, Un).replace(\"\\u300A\\u3000\\u300B\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var e, o;\n    return ((e = this.spLay.interactiveChildren) != null ? e : !1) && this.spLay.visible && H(o = Jt, Go).call(o, this);\n  }\n  clearLay(e) {\n    super.clearLay(e), this.clearText();\n    for (const o of H(this, Ke).removeChildren())\n      o.destroy();\n  }\n  playback(e, o) {\n    super.playback(e, o), this.enabled = e.enabled, H(this, Yr).style.cssText = e.r_cssText, nt(this, Je, e.r_align), this.cvsResize(), ot(this, Yo, nf).call(this, e), H(this, oe).playback(e.txs), nt(this, gr, e.b_alpha), nt(this, Ar, e.b_alpha_isfixed), o.push(new Promise((S) => {\n      const N = e.b_do ? e.b_do === \"Sprite\" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: \"\" };\n      N.b_alpha = e.b_alpha, N.b_alpha_isfixed = e.b_alpha_isfixed, ot(this, Wo, rf).call(this, N, (D) => {\n        D && S();\n      }) || S();\n    }));\n    const T = e.btns;\n    o = o.concat(T.map((S) => this.addButton(JSON.parse(S.replaceAll(\"'\", '\"')))));\n  }\n  snapshot(e, o) {\n    e.render(this.spLay, { clear: !1 }), H(this, oe).snapshot(e, o);\n  }\n  snapshot_end() {\n    H(this, oe).snapshot_end();\n  }\n  makeDesignCast(e) {\n    !this.spLay.visible || H(this, oe).makeDesignCast(e);\n  }\n  makeDesignCastChildren(e) {\n    if (!!this.spLay.visible)\n      for (const o of H(this, Ke).children)\n        o.makeDesignCast(e);\n  }\n  showDesignCast() {\n    H(this, oe).showDesignCast();\n  }\n  showDesignCastChildren() {\n    for (const e of H(this, Ke).children)\n      e.showDesignCast();\n  }\n  dump() {\n    return H(this, Zo).call(this, \"\", \"gotxt\\uFF5C\"), super.dump() + `, \"enabled\":\"${this.enabled}\", ${H(this, oe).dump()}, \"b_pic\":\"${H(this, Wr)}\", \"b_color\":\"${H(this, pi)}\", \"b_alpha\":${H(this, gr)}, \"b_alpha_isfixed\":\"${H(this, Ar)}\", \"width\":${H(this, oe).getWidth}, \"height\":${H(this, oe).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Sprite ? \"Sprite\" : e instanceof Graphics ? \"Graphics\" : e instanceof Container ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${H(this, Ke).children.map((e) => {\n      var o;\n      return (o = e.children[0].name) != null ? o : \"{}\";\n    }).join(\",\")}]`;\n  }\n};\nlet TxtLayer = Jt;\nta = new WeakMap(), Pr = new WeakMap(), Go = new WeakMap(), ea = new WeakMap(), Ho = new WeakSet(), tf = function(e) {\n  const o = TxtStage.ch_in_style(e), T = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`, S = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`, { name: N } = e;\n  return addStyle(`\n.sn_ch_in_${N} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${N} {\n\topacity: ${o.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${N} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes sn_ch_in_${N} {\n\tfrom {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${T}, ${S});}\n\tto {opacity: 1; transform: none;}\n}\n`), !1;\n}, jo = new WeakSet(), ef = function(e) {\n  const o = TxtStage.ch_out_style(e), T = o.x.charAt(0) === \"=\" ? `${o.nx * 100}%` : `${o.nx}px`, S = o.y.charAt(0) === \"=\" ? `${o.ny * 100}%` : `${o.ny}px`, { name: N } = e;\n  return addStyle(`\n.go_ch_out_${N} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${N} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes go_ch_out_${N} {\n\tto {\n\t\topacity: ${o.alpha};\n\t\ttransform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${T}, ${S});\n\t}\n`), !1;\n}, zo = new WeakMap(), Mn = new WeakMap(), Vo = new WeakMap(), di = new WeakMap(), Dn = new WeakMap(), oh = new WeakSet(), ud = function(e) {\n  nt(Jt, di, argChk_Boolean(e, \"enabled\", H(Jt, di))), H(Jt, Pr).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", H(Jt, di));\n  const { text: o } = e;\n  if (\"text\" in e != \"time\" in e)\n    throw \"[autowc] text\\u3068time\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u5FC5\\u9808\\u3067\\u3059\";\n  if (H(Jt, Pr).setVal_Nochk(\"save\", \"const.sn.autowc.text\", o), !o)\n    return H(Jt, Pr).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\"), !1;\n  const T = o.length;\n  if (H(Jt, di) && T === 0)\n    throw '[autowc] enabled === false \\u304B\\u3064 text === \"\" \\u306F\\u8A31\\u3055\\u308C\\u307E\\u305B\\u3093';\n  const S = String(e.time).split(\",\");\n  if (S.length !== T)\n    throw \"[autowc] text\\u6587\\u5B57\\u6570\\u3068time\\u306B\\u8A18\\u8FF0\\u3055\\u308C\\u305F\\u5F85\\u3061\\u6642\\u9593\\uFF08\\u30B3\\u30F3\\u30DE\\u533A\\u5207\\u308A\\uFF09\\u306F\\u540C\\u6570\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  return nt(Jt, Dn, {}), S.forEach((N, D) => H(Jt, Dn)[o[D]] = uint(N)), H(Jt, Pr).setVal_Nochk(\"save\", \"const.sn.autowc.time\", e.time), !1;\n}, pi = new WeakMap(), gr = new WeakMap(), Ar = new WeakMap(), ve = new WeakMap(), Wr = new WeakMap(), oe = new WeakMap(), Xo = new WeakMap(), Yr = new WeakMap(), uh = new WeakMap(), Ke = new WeakMap(), Ln = new WeakSet(), ka = function(e) {\n  const { in_style: o } = e;\n  if (!o)\n    return;\n  const T = TxtStage.getChInStyle(o);\n  if (!T)\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044in_style\\u3010${o}\\u3011\\u3067\\u3059`;\n  nt(this, Fn, o), nt(this, ra, T.join);\n}, Fn = new WeakMap(), ra = new WeakMap(), Bn = new WeakSet(), $a = function(e) {\n  const { out_style: o } = e;\n  if (!o)\n    return;\n  if (!TxtStage.getChOutStyle(o))\n    throw `\\u5B58\\u5728\\u3057\\u306A\\u3044out_style\\u3010${o}\\u3011\\u3067\\u3059`;\n  nt(this, ia, o);\n}, ia = new WeakMap(), Wo = new WeakSet(), rf = function(e, o) {\n  if (\"back_clear\" in e)\n    return argChk_Boolean(e, \"back_clear\", !1) && (nt(this, pi, 0), nt(this, gr, 0), nt(this, Ar, !1), nt(this, Wr, \"\")), o(!1), !1;\n  nt(this, gr, argChk_Num(e, \"b_alpha\", H(this, gr))), nt(this, Ar, argChk_Boolean(e, \"b_alpha_isfixed\", H(this, Ar)));\n  const T = (H(this, Ar) ? 1 : Number(H(Jt, Pr).getVal(\"sys:TextLayer.Back.Alpha\"))) * H(this, gr);\n  if (e.b_pic) {\n    if (H(this, Wr) !== e.b_pic)\n      return nt(this, Wr, e.b_pic), H(this, ve) && (this.spLay.removeChild(H(this, ve)), H(this, ve).destroy()), GrpLayer.csv2Sprites(H(this, Wr), this.spLay, (S) => {\n        nt(this, ve, S), S.name = \"back(pic)\", S.visible = T > 0, S.alpha = T, H(this, oe).setSize(S.width, S.height), this.spLay.setChildIndex(S, 0), o(!0);\n      });\n  } else\n    \"b_color\" in e && (nt(this, pi, argChk_Color(e, \"b_color\", 0)), H(this, ve) && (this.spLay.removeChild(H(this, ve)), H(this, ve).destroy()), nt(this, Wr, \"\"), this.spLay.addChildAt(\n      nt(this, ve, new Graphics()).beginFill(H(this, pi)).lineStyle(void 0).drawRect(0, 0, H(this, oe).getWidth, H(this, oe).getHeight).endFill(),\n      0\n    ), H(this, ve).name = \"back(color)\");\n  return H(this, ve) && (H(this, ve).visible = T > 0, H(this, ve).alpha = T), o(!1), !1;\n}, Yo = new WeakSet(), nf = function(e) {\n  var o, T;\n  \"noffs\" in e && (nt(this, na, (o = e.noffs) != null ? o : \"\"), nt(this, qo, new RegExp(`[\\u3000${H(this, na)}]`))), \"ffs\" in e && ((T = H(this, kn)) != null || nt(this, kn, \"\"), nt(this, $n, H(this, kn) === \"\" ? () => \"\" : (S) => H(this, qo).test(S) ? \"\" : ` font-feature-settings: ${H(this, kn)};`));\n}, kn = new WeakMap(), $n = new WeakMap(), na = new WeakMap(), qo = new WeakMap(), sa = new WeakMap(), Vi = new WeakMap(), Je = new WeakMap(), lh = new WeakSet(), ld = function(e, o, T, S = \"\") {\n  if (!T)\n    return ` style='${S}'`;\n  const N = e.length * 2;\n  if (N - o.length < 0)\n    return ` style='text-align: ${T}; ${S}'`;\n  let D = \"\";\n  switch (T) {\n    case \"left\":\n      D = \"ruby-align: start;\";\n      break;\n    case \"center\":\n      D = \"ruby-align: center;\";\n      break;\n    case \"right\":\n      D = \"ruby-align: start;\";\n      break;\n    case \"justify\":\n      D = \"ruby-align: space-between;\";\n      break;\n    case \"121\":\n      D = \"ruby-align: space-around;\";\n      break;\n    case \"even\":\n      const B = (N - o.length) / (o.length + 1);\n      D = \"ruby-align: space-between; \" + (H(this, oe).tategaki ? `padding-top: ${B}em; padding-bottom: ${B}em;` : `padding-left: ${B}em; padding-right: ${B}em;`);\n      break;\n    case \"1ruby\":\n      D = \"ruby-align: space-between; \" + (H(this, oe).tategaki ? \"padding-top: 1em; padding-bottom: 1em;\" : \"padding-left: 1em; padding-right: 1em;\");\n      break;\n    default:\n      D = `text-align: ${T};`;\n  }\n  return ` style='${D} ${S}'`;\n}, lr = new WeakMap(), Zo = new WeakMap(), aa = new WeakSet(), sl = function(e, o, T) {\n  var $, U;\n  const S = e === \" \" ? \"&nbsp;\" : e;\n  H(Jt, Pr).doRecLog() && nt(this, Un, H(this, Un) + (S + (o ? `\\u300A${o}\\u300B` : \"\")));\n  const { cl: N, sty: D, lnk: B } = ot(this, vi, rn).call(this, !0, null, e);\n  return o ? `<span${N} style='${D} ${H(this, $n).call(this, e)}'><ruby>${Array.from(e).map((z, V) => `<span${N}${B} style='${V > 0 ? ot(this, vi, rn).call(this, !0, null, e).sty : D} display: inline;'>${z === \" \" ? \"&nbsp;\" : z}</span>`).join(\"\")}<rt${B}${this.mkStyle_r_align(\n    e,\n    o,\n    T,\n    H(this, Yr).style.cssText + ((U = ($ = H(this, mr).at(-1)) == null ? void 0 : $.o.r_style) != null ? U : \"\")\n  )}>${o}</rt></ruby></span>` : `<span${N} style='${D} ${H(this, $n).call(this, e)}'${B}>${S}</span>`;\n}, vi = new WeakSet(), rn = function(e, o, T = `\n`) {\n  var D, B, $, U, z, V, X;\n  const S = H(this, ra) ? ($ = o != null ? o : (D = H(this, mr).at(0)) == null ? void 0 : D.o.wait) != null ? $ : H(Jt, di) ? (B = H(Jt, Dn)[T.charAt(0)]) != null ? B : 0 : LayerMng.msecChWait : 0;\n  H(Jt, Mn).isSkippingByKeyDown() ? nt(this, gi, 0) : e && H(this, ra) && nt(this, gi, H(this, gi) + Number(S));\n  const N = `data-add='{\"ch_in_style\":\"${H(this, Fn)}\", \"ch_out_style\":\"${H(this, ia)}\"}'`;\n  return {\n    cl: ` class='sn_ch${S > 0 ? ` sn_ch_in_${H(this, Fn)}` : \"\"}'`,\n    sty: `animation-delay: ${H(this, gi)}ms;${(z = (U = H(this, mr).at(-1)) == null ? void 0 : U.o.style) != null ? z : \"\"}`,\n    lnk: ((X = (V = H(this, mr).at(0)) == null ? void 0 : V.o[\":link\"]) != null ? X : \"\") + \" \" + N,\n    curpos: N\n  };\n}, gi = new WeakMap(), Or = new WeakMap(), _r = new WeakMap(), mr = new WeakMap(), Ko = new WeakSet(), sf = function(e) {\n  H(this, mr).push({\n    o: e,\n    r_align: H(this, Je),\n    ch_in_style: H(this, Fn),\n    ch_out_style: H(this, ia)\n  }), \"r_align\" in e && nt(this, Je, e.r_align), ot(this, Ln, ka).call(this, e), ot(this, Bn, $a).call(this, e);\n}, oa = new WeakSet(), al = function() {\n  const e = H(this, mr).pop();\n  !e || (nt(this, Je, e.r_align), ot(this, Ln, ka).call(this, { in_style: e.ch_in_style }), ot(this, Bn, $a).call(this, { out_style: e.ch_out_style }));\n}, Jo = new WeakSet(), af = function(e) {\n  const o = H(this, mr).at(-1);\n  if (!o) {\n    ot(this, Ko, sf).call(this, e);\n    return;\n  }\n  o.o = { ...o.o, ...e }, !e.style && !e.r_style && (o.o.style = \"\", o.o.r_style = \"\"), \"r_align\" in e && nt(this, Je, e.r_align), ot(this, Ln, ka).call(this, e), ot(this, Bn, $a).call(this, e);\n}, Un = new WeakMap(), rt(TxtLayer, Ho), rt(TxtLayer, jo), rt(TxtLayer, oh), rt(TxtLayer, ta, void 0), rt(TxtLayer, Pr, void 0), rt(TxtLayer, Go, void 0), rt(TxtLayer, ea, void 0), rt(TxtLayer, zo, void 0), rt(TxtLayer, Mn, void 0), rt(TxtLayer, Vo, void 0), rt(TxtLayer, di, !1), rt(TxtLayer, Dn, {}), rt(TxtLayer, uh, {\n  \"text-align\": 0,\n  \"text-align-last\": 0,\n  height: 0,\n  width: 0,\n  \"padding-left\": 0,\n  \"padding-right\": 0,\n  \"padding-top\": 0,\n  \"padding-bottom\": 0\n}), rt(TxtLayer, sa, (e) => e);\nvar ua, Gn, hh, hd, la, ha, ol, ch, cd, fh, fd, Qo, dh, dd, ph, pd;\nclass FrameMng {\n  constructor(t, e, o, T, S, N, D) {\n    rt(this, hh);\n    rt(this, ha);\n    rt(this, ch);\n    rt(this, fh);\n    rt(this, dh);\n    rt(this, ph);\n    rt(this, ua, void 0);\n    rt(this, Gn, /* @__PURE__ */ Object.create(null));\n    rt(this, la, {});\n    rt(this, Qo, 1);\n    this.cfg = t, this.appPixi = o, this.val = T, this.main = S, this.sys = N, this.hTwInf = D, e.add_frame = (B) => ot(this, hh, hd).call(this, B), e.let_frame = (B) => ot(this, ch, cd).call(this, B), e.set_frame = (B) => ot(this, fh, fd).call(this, B), e.frame = (B) => ot(this, dh, dd).call(this, B), e.tsy_frame = (B) => ot(this, ph, pd).call(this, B);\n  }\n  setEvtMng(t) {\n    nt(this, ua, t);\n  }\n  destroy() {\n    for (const t of Object.values(H(this, Gn)))\n      t.parentElement.removeChild(t);\n    nt(this, Gn, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(t) {\n    return H(this, la)[t];\n  }\n  cvsResize() {\n    for (const [t, e] of Object.entries(H(this, Gn))) {\n      const o = \"const.sn.frm.\" + t, T = Number(this.val.getVal(o + \".x\")), S = Number(this.val.getVal(o + \".y\")), N = Number(this.val.getVal(o + \".width\")), D = Number(this.val.getVal(o + \".height\"));\n      e.style.left = `${this.sys.ofsLeft4elm + T * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + S * this.sys.cvsScale}px`, e.width = String(N * this.sys.cvsScale), e.height = String(D * this.sys.cvsScale);\n    }\n  }\n}\nua = new WeakMap(), Gn = new WeakMap(), hh = new WeakSet(), hd = function(t) {\n  const { id: e, src: o, alpha: T = 1, scale_x: S = 1, scale_y: N = 1, rotate: D = 0 } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!o)\n    throw \"src\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const B = \"const.sn.frm.\" + e;\n  if (this.val.getVal(`tmp:${B}`))\n    throw `frame\\u3010${e}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  const $ = argChk_Boolean(t, \"visible\", !0), U = t.b_color ? ` background-color: ${t.b_color};` : \"\", z = ot(this, ha, ol).call(this, t);\n  this.appPixi.view.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${e}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${T}; position: absolute; left:${this.sys.ofsLeft4elm + z.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + z.y * this.sys.cvsScale}px; z-index: 1; ${U} border: 0px; overflow: hidden; display: ${$ ? \"inline\" : \"none\"}; transform: scale(${S}, ${N}) rotate(${D}deg);\" width=\"${z.width * this.sys.cvsScale}\" height=\"${z.height * this.sys.cvsScale}\"></iframe>`);\n  const V = this.cfg.searchPath(o, SEARCH_PATH_ARG_EXT.HTML), X = new Loader().add({ name: o, url: V, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });\n  return this.sys.crypto && X.use((W, Y) => {\n    try {\n      W.data = this.sys.decStr(W.extension, W.data);\n    } catch (q) {\n      this.main.errScript(`[add_frame]Html \\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 src:${W.name} ${q}`, !1);\n    }\n    Y == null || Y();\n  }), X.load((W, Y) => {\n    var Z;\n    const q = document.getElementById(e);\n    H(this, Gn)[e] = q, H(this, la)[e] = !1, q.srcdoc = String((Z = Y[o]) == null ? void 0 : Z.data).replace(\"sn_repRes();\", \"\").replaceAll(\n      /\\s(?:src|href)=([\"'])(\\S+)\\1/g,\n      (K, J, tt) => tt.slice(0, 3) === \"../\" ? this.sys.cur + tt.slice(4) : K.replace(J, J + V.slice(0, V.lastIndexOf(\"/\") + 1))\n    ), q.onload = () => {\n      var J;\n      this.val.setVal_Nochk(\"tmp\", B, !0), this.val.setVal_Nochk(\"tmp\", B + \".alpha\", T), this.val.setVal_Nochk(\"tmp\", B + \".x\", z.x), this.val.setVal_Nochk(\"tmp\", B + \".y\", z.y), this.val.setVal_Nochk(\"tmp\", B + \".scale_x\", S), this.val.setVal_Nochk(\"tmp\", B + \".scale_y\", N), this.val.setVal_Nochk(\"tmp\", B + \".rotate\", D), this.val.setVal_Nochk(\"tmp\", B + \".width\", z.width), this.val.setVal_Nochk(\"tmp\", B + \".height\", z.height), this.val.setVal_Nochk(\"tmp\", B + \".visible\", $);\n      const K = q.contentWindow;\n      H(this, ua).resvFlameEvent(K), (J = K.sn_repRes) == null || J.call(K, (tt) => {\n        var et;\n        return GrpLayer.loadPic2Img((et = tt.dataset.src) != null ? et : \"\", tt);\n      }), this.main.resume();\n    };\n  }), !0;\n}, la = new WeakMap(), ha = new WeakSet(), ol = function(t) {\n  const e = { ...t }, o = this.sys.resolution;\n  return new DOMRect(\n    argChk_Num(e, \"x\", 0) * o,\n    argChk_Num(e, \"y\", 0) * o,\n    argChk_Num(e, \"width\", CmnLib.stageW) * o,\n    argChk_Num(e, \"height\", CmnLib.stageH) * o\n  );\n}, ch = new WeakSet(), cd = function(t) {\n  const { id: e, var_name: o } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const T = document.getElementById(e);\n  if (!T)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const S = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${S}`))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!o)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const N = T.contentWindow;\n  if (!N.hasOwnProperty(o))\n    throw `frame\\u3010${e}\\u3011\\u306B\\u5909\\u6570/\\u95A2\\u6570\\u3010${o}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u5909\\u6570\\u306F var\\u4ED8\\u304D\\u306B\\u3057\\u3066\\u4E0B\\u3055\\u3044`;\n  const D = N[o];\n  return this.val.setVal_Nochk(\n    \"tmp\",\n    S + \".\" + o,\n    argChk_Boolean(t, \"function\", !1) ? D() : D\n  ), !1;\n}, fh = new WeakSet(), fd = function(t) {\n  const { id: e, var_name: o, text: T } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const S = document.getElementById(e);\n  if (!S)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const N = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${N}`))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  if (!o)\n    throw \"var_name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!T)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  this.val.setVal_Nochk(\"tmp\", N + \".\" + o, T);\n  const D = S.contentWindow;\n  return D[o] = T, !1;\n}, Qo = new WeakMap(), dh = new WeakSet(), dd = function(t) {\n  const { id: e } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = document.getElementById(e);\n  if (!o)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const T = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(\"tmp:\" + T))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const S = o.style;\n  if (argChk_Boolean(t, \"float\", !1) ? S.zIndex = `${++Pe(this, Qo)._}` : \"index\" in t ? S.zIndex = `${argChk_Num(t, \"index\", 0)}` : t.dive && (S.zIndex = `-${++Pe(this, Qo)._}`), \"alpha\" in t) {\n    const D = S.opacity = String(t.alpha);\n    this.val.setVal_Nochk(\"tmp\", T + \".alpha\", D);\n  }\n  const N = ot(this, ha, ol).call(this, t);\n  if ((\"x\" in t || \"y\" in t) && (S.left = `${this.sys.ofsLeft4elm + N.x * this.sys.cvsScale}px`, S.top = `${this.sys.ofsTop4elm + N.y * this.sys.cvsScale}px`, this.val.setVal_Nochk(\"tmp\", T + \".x\", N.x), this.val.setVal_Nochk(\"tmp\", T + \".y\", N.y)), \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) {\n    const D = argChk_Num(t, \"scale_x\", 1), B = argChk_Num(t, \"scale_y\", 1), $ = argChk_Num(t, \"rotate\", 0);\n    S.transform = `scale(${D}, ${B}) rotate(${$}deg)`, this.val.setVal_Nochk(\"tmp\", T + \".scale_x\", D), this.val.setVal_Nochk(\"tmp\", T + \".scale_y\", B), this.val.setVal_Nochk(\"tmp\", T + \".rotate\", $);\n  }\n  if (\"width\" in t && (o.width = String(N.width * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", T + \".width\", N.width)), \"height\" in t && (o.height = String(N.height * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", T + \".height\", N.height)), \"visible\" in t) {\n    const D = argChk_Boolean(t, \"visible\", !0);\n    S.display = D ? \"inline\" : \"none\", this.val.setVal_Nochk(\"tmp\", T + \".visible\", D);\n  }\n  if (\"b_color\" in t && (S.backgroundColor = t.b_color), \"disabled\" in t) {\n    const D = H(this, la)[e] = argChk_Boolean(t, \"disabled\", !0);\n    o.contentDocument.body.querySelectorAll(\"input,select\").forEach(($) => $.disabled = D);\n  }\n  return !1;\n}, ph = new WeakSet(), pd = function(t) {\n  const { id: e, alpha: o, x: T, y: S, scale_x: N, scale_y: D, rotate: B, width: $, height: U, ease: z, path: V, chain: X } = t;\n  if (!e)\n    throw \"id\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const W = document.getElementById(e);\n  if (!W)\n    throw `id\\u3010${e}\\u3011\\u306F\\u30D5\\u30EC\\u30FC\\u30E0\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  const Y = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${Y}`, 0))\n    throw `frame\\u3010${e}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n  const q = {};\n  o && (q.a = W.style.opacity), (T || S || N || D || B) && (q.x = Number(this.val.getVal(`tmp:${Y}.x`)), q.y = Number(this.val.getVal(`tmp:${Y}.y`)), q.sx = Number(this.val.getVal(`tmp:${Y}.scale_x`)), q.sy = Number(this.val.getVal(`tmp:${Y}.scale_y`)), q.r = Number(this.val.getVal(`tmp:${Y}.rotate`))), $ && (q.w = this.val.getVal(`tmp:${Y}.width`)), U && (q.h = this.val.getVal(`tmp:${Y}.height`));\n  const Z = cnvTweenArg(t, q), K = {};\n  let J = () => {\n  };\n  o && (K.a = argChk_Num(Z, \"alpha\", 0), J = () => {\n    W.style.opacity = q.a, this.val.setVal_Nochk(\"tmp\", \"alpha\", q.a);\n  });\n  let tt = () => {\n  };\n  const et = ot(this, ha, ol).call(this, Z);\n  (T || S || N || D || B) && (K.x = et.x, K.y = et.y, K.sx = argChk_Num(Z, \"scale_x\", 1), K.sy = argChk_Num(Z, \"scale_y\", 1), K.r = argChk_Num(Z, \"rotate\", 0), tt = () => {\n    W.style.left = this.sys.ofsLeft4elm + q.x * this.sys.cvsScale + \"px\", W.style.top = this.sys.ofsTop4elm + q.y * this.sys.cvsScale + \"px\", W.style.transform = `scale(${q.sx}, ${q.sy}) rotate(${q.r}deg)`, this.val.setVal_Nochk(\"tmp\", Y + \".x\", q.x), this.val.setVal_Nochk(\"tmp\", Y + \".y\", q.y), this.val.setVal_Nochk(\"tmp\", Y + \".scale_x\", q.sx), this.val.setVal_Nochk(\"tmp\", Y + \".scale_y\", q.sy), this.val.setVal_Nochk(\"tmp\", Y + \".rotate\", q.r);\n  });\n  let Q = () => {\n  };\n  $ && (K.w = et.width, Q = () => {\n    W.width = q.w * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", Y + \".width\", q.w);\n  });\n  let at = () => {\n  };\n  U && (K.h = et.height, at = () => {\n    W.height = q.h * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", Y + \".height\", q.h);\n  }), this.appPixi.stage.interactive = !1;\n  const it = `frm\n${e}`, st = () => {\n    var yt, ht;\n    this.appPixi.stage.interactive = !0;\n    const Rt = this.hTwInf[it];\n    !Rt || (delete this.hTwInf[it], (yt = Rt.tw) == null || yt.stop(), Rt.resume && this.main.resume(), (ht = Rt.onEnd) == null || ht.call(Rt));\n  }, ut = argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, ua).isSkippingByKeyDown()) ? 0 : 1), ft = CmnTween.ease(z), ct = argChk_Num(t, \"repeat\", 1), pt = ct === 0 ? 1 / 0 : ct - 1, mt = argChk_Boolean(t, \"yoyo\", !1), vt = argChk_Num(t, \"delay\", 0), _t = new Tween(q).to(K, ut).easing(ft).repeat(pt).yoyo(mt).delay(vt).onUpdate(() => {\n    J(), tt(), Q(), at();\n  });\n  let xt = _t;\n  if (V) {\n    CmnLib.debugLog && console.group(`\\u{1F35D} [tsy_frame] path=${V}= start(${q.x},${q.y},${q.alpha})`);\n    for (const { groups: Rt } of V.matchAll(LayerMng.REG_TSY_PATH)) {\n      const { x: yt, x2: ht, y: bt, y2: St, o: Ot, o2: wt, json: Ft } = Rt;\n      let dt = {};\n      if (Ft)\n        try {\n          dt = JSON.parse(Ft);\n        } catch (Bt) {\n          console.error(`\\u{1F35D} json=${Ft} ` + Bt);\n          continue;\n        }\n      else\n        (yt != null ? yt : ht) && (dt.x = yt != null ? yt : ht), (bt != null ? bt : St) && (dt.y = bt != null ? bt : St), (Ot != null ? Ot : wt) && (dt.alpha = Ot != null ? Ot : wt);\n      const Gt = cnvTweenArg(dt, q);\n      CmnLib.debugLog && console.info(`\\u{1F35D} {x:${yt} y:${bt} o:${Ot}} => hTo:${JSON.stringify(Gt)}`);\n      const Mt = new Tween(q).to(Gt, ut).easing(ft).repeat(pt).yoyo(mt);\n      xt.chain(Mt), xt = Mt;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (xt.onComplete(st), X) {\n    const Rt = this.hTwInf[X != null ? X : \"\"];\n    if (!Rt || !Rt.tw)\n      throw `${X}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete Rt.onEnd, Rt.tw.chain(_t);\n  } else\n    _t.start();\n  return this.hTwInf[it] = { tw: xt, resume: !1 }, !1;\n};\nvar Nr, ue, xe, Xi, Hn, ca, tu, eu, ru, fa, iu, of, Wi, qr, vh, vd, Qe, gh, gd, _h, _d, mh, md, se, Zr, Kr, nu, yh, yd, da, ul, bh, bd, Eh, su, xh, jn, zn, _i, Oe, Vn, Th, Ed, Ne, Ye, sr, Sh, xd, Ch, Td, Rh, Sd, Xn, Ua, Ih, Cd, hr, wh, Rd, Ph, Id, Ah, wd, Oh, Pd, Nh, Ad, Yi, Wn, Ga, cr, Mh, Od, au, Dh, Nd, Jr, Yn, qi, bs, Mr, Qr, Lh, Md, Fh, Dd, Bh, Ld, kh, Fd, $h, Bd, Uh, kd, Gh, $d, ou, uf, Hh, Ud, jh, Gd, zh, Hd, Vh, jd, Xh, zd, Wh, Vd, Yh, Xd;\nconst Oi = class {\n  constructor(t, e, o, T, S, N, D, B, $, U) {\n    rt(this, iu);\n    rt(this, vh);\n    rt(this, gh);\n    rt(this, _h);\n    rt(this, mh);\n    rt(this, yh);\n    rt(this, da);\n    rt(this, bh);\n    rt(this, Th);\n    rt(this, Ye);\n    rt(this, Sh);\n    rt(this, Ch);\n    rt(this, Rh);\n    rt(this, Xn);\n    rt(this, Ih);\n    rt(this, wh);\n    rt(this, Ph);\n    rt(this, Ah);\n    rt(this, Oh);\n    rt(this, Nh);\n    rt(this, Wn);\n    rt(this, Mh);\n    rt(this, Dh);\n    rt(this, qi);\n    rt(this, Lh);\n    rt(this, Fh);\n    rt(this, Bh);\n    rt(this, kh);\n    rt(this, $h);\n    rt(this, Uh);\n    rt(this, Gh);\n    rt(this, ou);\n    rt(this, Hh);\n    rt(this, jh);\n    rt(this, zh);\n    rt(this, Vh);\n    rt(this, Xh);\n    rt(this, Wh);\n    rt(this, Yh);\n    rt(this, Nr, void 0);\n    rt(this, ue, new Container());\n    rt(this, xe, new Container());\n    rt(this, Xi, void 0);\n    rt(this, Hn, void 0);\n    rt(this, ca, new EventListenerCtn());\n    rt(this, tu, () => update());\n    rt(this, eu, {\n      attach: (t) => (DesignCast.leaveMode(), !1),\n      continue: (t) => (DesignCast.leaveMode(), !1),\n      disconnect: (t) => (DesignCast.leaveMode(), !1),\n      _enterDesign: (t) => {\n        DesignCast.enterMode();\n        for (const e of H(this, Zr)) {\n          const o = H(this, se)[e].fore;\n          o.makeDesignCastChildren((T) => T.make()), o.makeDesignCast((T) => T.make());\n        }\n        return ot(this, iu, of).call(this, H(this, Kr)), !1;\n      },\n      _replaceToken: (t, e) => (DesignCast.replaceToken(e), !1),\n      _selectNode: (t, e) => (ot(this, iu, of).call(this, e.node), !1)\n    });\n    rt(this, ru, \"\");\n    rt(this, fa, \"\");\n    Pt(this, \"getFrmDisabled\", (t) => H(this, Xi).getFrmDisabled(t));\n    rt(this, Wi, void 0);\n    rt(this, qr, void 0);\n    rt(this, Qe, (t, e = this.currentTxtlayForeNeedErr, o = !0) => e.tagCh(\"\\uFF5C\\u3000\\u300A\" + t + \"\\u300B\"));\n    Pt(this, \"goTxt\", () => {\n    });\n    Pt(this, \"breakLine\", () => {\n    });\n    Pt(this, \"breakPage\", () => {\n    });\n    rt(this, se, {});\n    rt(this, Zr, []);\n    rt(this, Kr, \"\");\n    rt(this, nu, \"\");\n    rt(this, Eh, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`);\n    rt(this, su, {\n      rule: Texture.EMPTY,\n      vague: 0,\n      tick: 0\n    });\n    rt(this, xh, new Filter(void 0, H(this, Eh), H(this, su)));\n    rt(this, jn, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    rt(this, zn, new Sprite(H(this, jn)));\n    rt(this, _i, RenderTexture.create({\n      width: CmnLib.stageW,\n      height: CmnLib.stageH\n    }));\n    rt(this, Oe, new Sprite(H(this, _i)));\n    rt(this, Vn, []);\n    rt(this, Ne, { tw: void 0, resume: !1 });\n    rt(this, hr, {});\n    rt(this, cr, (t) => {\n      throw H(this, Yn).call(this), 0;\n    });\n    rt(this, au, (t) => {\n      throw H(this, Yn).call(this), 0;\n    });\n    rt(this, Jr, void 0);\n    rt(this, Yn, () => {\n      throw \"\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\\u3002\\u6587\\u5B57\\u8868\\u793A\\u3084\\u64CD\\u4F5C\\u3059\\u308B\\u524D\\u306B\\u3001[add_lay layer=\\uFF08\\u30EC\\u30A4\\u30E4\\u540D\\uFF09 class=txt]\\u3067\\u6587\\u5B57\\u30EC\\u30A4\\u30E4\\u3092\\u8FFD\\u52A0\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n    });\n    rt(this, Mr, \"\");\n    rt(this, Qr, []);\n    this.cfg = t, this.hTag = e, this.appPixi = o, this.val = T, this.main = S, this.scrItr = N, this.sys = D, this.sndMng = B, this.alzTagArg = $, this.prpPrs = U;\n    const z = () => {\n      if (D.cvsResize(), this.cvsResizeDesign(), H(this, fa))\n        for (const Y of H(this, Zr))\n          H(this, se)[Y].fore.cvsResizeChildren();\n      else\n        for (const Y of H(this, Zr))\n          H(this, se)[Y].fore.cvsResize();\n      H(this, Xi).cvsResize(), H(this, qr).cvsResize();\n    };\n    if (CmnLib.isMobile)\n      H(this, ca).add(globalThis, \"orientationchange\", z, { passive: !0 });\n    else {\n      let Y;\n      H(this, ca).add(globalThis, \"resize\", () => {\n        Y || (Y = setTimeout(() => {\n          Y = void 0, z();\n        }, 1e3 / 60 * 10));\n      }, { passive: !0 });\n    }\n    D.cvsResize(), TxtLayer.init(t, e, T, this, (Y) => H(this, se)[Y.layname].fore === Y, o), GrpLayer.init(S, t, o, D, B, T), Button.init(t), nt(this, Xi, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, S, this.sys, H(this, hr))), D.hFactoryCls.grp = () => new GrpLayer(), D.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (Y) => ot(this, _h, _d).call(this, Y), e.snapshot = (Y) => ot(this, gh, gd).call(this, Y), e.add_lay = (Y) => ot(this, mh, md).call(this, Y), e.clear_lay = (Y) => ot(this, bh, bd).call(this, Y), e.finish_trans = () => ot(this, Xn, Ua).call(this), e.lay = (Y) => ot(this, yh, yd).call(this, Y), e.trans = (Y) => ot(this, Th, Ed).call(this, Y), e.wt = (Y) => ot(this, Rh, Sd).call(this, Y), e.quake = (Y) => ot(this, Ih, Cd).call(this, Y), e.stop_quake = (Y) => e.finish_trans(Y), e.wq = (Y) => e.wt(Y), e.pause_tsy = (Y) => ot(this, Oh, Pd).call(this, Y), e.resume_tsy = (Y) => ot(this, Nh, Ad).call(this, Y), e.stop_tsy = (Y) => ot(this, Ah, wd).call(this, Y), e.tsy = (Y) => ot(this, wh, Rd).call(this, Y), e.wait_tsy = (Y) => ot(this, Ph, Id).call(this, Y), e.ch = (Y) => ot(this, Wn, Ga).call(this, Y), e.clear_text = (Y) => ot(this, Lh, Md).call(this, Y), e.current = (Y) => H(this, au).call(this, Y), e.endlink = (Y) => ot(this, Fh, Dd).call(this, Y), e.er = (Y) => ot(this, Bh, Ld).call(this, Y), e.graph = (Y) => ot(this, kh, Fd).call(this, Y), e.link = (Y) => ot(this, $h, Bd).call(this, Y), e.r = (Y) => ot(this, Uh, kd).call(this, Y), e.rec_ch = (Y) => ot(this, ou, uf).call(this, Y), e.rec_r = (Y) => ot(this, Gh, $d).call(this, Y), e.reset_rec = (Y) => ot(this, Hh, Ud).call(this, Y), e.ruby2 = (Y) => ot(this, jh, Gd).call(this, Y), e.span = (Y) => ot(this, zh, Hd).call(this, Y), e.tcy = (Y) => ot(this, Vh, jd).call(this, Y), e.add_face = (Y) => GrpLayer.add_face(Y), e.wv = (Y) => GrpLayer.wv(Y), e.dump_lay = (Y) => ot(this, Xh, zd).call(this, Y), e.enable_event = (Y) => ot(this, Wh, Vd).call(this, Y), e.button = (Y) => ot(this, Yh, Xd).call(this, Y), t.existsBreakline && (this.breakLine = () => H(this, Qe).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakline\"}')), t.existsBreakpage && (this.breakPage = () => H(this, Qe).call(this, 'grp\\uFF5C{\"id\":\"break\",\"pic\":\"breakpage\"}')), nt(this, Hn, parseColor(String(t.oCfg.init.bg_color)));\n    const V = new Graphics();\n    V.beginFill(H(this, Hn), 1).lineStyle(0, H(this, Hn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), H(this, ue).addChild(V.clone()), H(this, xe).addChild(V), H(this, xe).visible = !1, nt(this, Nr, this.appPixi.stage), H(this, Nr).addChild(H(this, xe)), H(this, Nr).addChild(H(this, ue)), H(this, Nr).addChild(H(this, zn)), H(this, Nr).addChild(H(this, Oe)), this.appPixi.ticker.add(H(this, tu));\n    const X = (Y, q) => {\n      ot(this, vh, vd).call(this, Number(q));\n    };\n    X(\"\", T.getVal(\"sys:TextLayer.Back.Alpha\", 1)), T.defValTrg(\"sys:TextLayer.Back.Alpha\", X);\n    const W = (Y, q) => Button.fontFamily = q;\n    W(\"\", T.getVal(\"tmp:sn.button.fontFamily\", Button.fontFamily)), T.defValTrg(\"tmp:sn.button.fontFamily\", W), T.defTmp(\"const.sn.log.json\", () => JSON.stringify(\n      H(this, Mr) ? [...H(this, Qr), { text: H(this, Mr).replaceAll(\"</span><span class='sn_ch'>\", \"\") }] : H(this, Qr)\n    )), T.defTmp(\"const.sn.last_page_text\", () => {\n      var Y, q;\n      return (q = (Y = this.currentTxtlayFore) == null ? void 0 : Y.pageText) != null ? q : \"\";\n    }), CmnLib.isDbg && (DesignCast.init(this.appPixi, D, N, U, $, this.cfg, H(this, se)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), D.addHook((Y, q) => {\n      var Z, K;\n      !((K = (Z = H(this, eu))[Y]) != null && K.call(Z, Y, q)) || delete H(this, eu)[Y];\n    }));\n  }\n  cvsResizeDesign() {\n  }\n  cover(t, e = 0) {\n    H(this, Wi) && (H(this, Nr).removeChild(H(this, Wi)), H(this, Wi).destroy(), nt(this, Wi, void 0)), t && H(this, Nr).addChild(\n      nt(this, Wi, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()\n    );\n  }\n  setEvtMng(t) {\n    nt(this, qr, t), H(this, Xi).setEvtMng(t), GrpLayer.setEvtMng(t);\n  }\n  before_destroy() {\n    for (const t of Object.values(H(this, se)))\n      t.destroy();\n  }\n  destroy() {\n    H(this, ca).clear(), GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), H(this, Xi).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(H(this, tu)), nt(Oi, Yi, 10);\n  }\n  stopAllTw() {\n    nt(this, hr, {}), removeAll();\n  }\n  clearBreak() {\n    !this.currentTxtlayFore || (this.clearBreak = () => H(this, Qe).call(this, \"del\\uFF5Cbreak\"), this.clearBreak());\n  }\n  clickTxtLay() {\n    return this.currentTxtlayFore ? ot(this, Ye, sr).call(this).some((t) => {\n      const e = H(this, se)[t].fore;\n      return e instanceof TxtLayer && e.click();\n    }) : !1;\n  }\n  static get msecChWait() {\n    return H(Oi, Yi);\n  }\n  static set msecChWait(t) {\n    nt(Oi, Yi, t);\n  }\n  setNormalChWait() {\n    nt(Oi, Yi, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    return H(this, Yn).call(this), this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    if (!!H(this, Jr))\n      return H(this, Jr).fore;\n  }\n  recText(t) {\n    nt(this, Mr, t), this.val.setVal_Nochk(\n      \"save\",\n      \"const.sn.sLog\",\n      String(this.val.getVal(\"const.sn.log.json\"))\n    );\n  }\n  recPagebreak() {\n    if (!H(this, Mr))\n      return;\n    const t = H(this, Mr).replaceAll(\"</span><span class='sn_ch'>\", \"\");\n    H(this, Qr).push({ text: t }) > this.cfg.oCfg.log.max_len && nt(this, Qr, H(this, Qr).slice(-this.cfg.oCfg.log.max_len)), nt(this, Mr, \"\");\n  }\n  record() {\n    const t = {};\n    for (const e of H(this, Zr)) {\n      const o = H(this, se)[e];\n      t[e] = {\n        cls: o.cls,\n        fore: o.fore.record(),\n        back: o.back.record()\n      };\n    }\n    return t;\n  }\n  playback(t, e) {\n    var N, D;\n    nt(this, Qr, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\")))), nt(this, Mr, \"\");\n    const o = [], T = [];\n    for (const [B, { fore: $, fore: { idx: U }, back: z, cls: V }] of Object.entries(t)) {\n      T.push({ layer: B, idx: U });\n      const X = (D = (N = H(this, se))[B]) != null ? D : N[B] = new Pages(B, V, H(this, ue), H(this, xe), {}, this.sys, this.val, { isWait: !1 });\n      X.fore.playback($, o), X.back.playback(z, o);\n    }\n    const S = H(this, ue).children.length;\n    Promise.allSettled(o).then(() => {\n      for (const { layer: B, idx: $ } of T.sort(({ idx: U }, { idx: z }) => U === z ? 0 : U < z ? -1 : 1)) {\n        const { fore: U, back: z } = H(this, se)[B];\n        if (!U)\n          return;\n        const V = S > $ ? $ : S - 1;\n        H(this, ue).setChildIndex(U.spLay, V), H(this, xe).setChildIndex(z.spLay, V);\n      }\n      e();\n    }).catch((B) => console.error(\"fn:LayerMng.ts playback e:%o\", B));\n  }\n};\nlet LayerMng = Oi;\nNr = new WeakMap(), ue = new WeakMap(), xe = new WeakMap(), Xi = new WeakMap(), Hn = new WeakMap(), ca = new WeakMap(), tu = new WeakMap(), eu = new WeakMap(), ru = new WeakMap(), fa = new WeakMap(), iu = new WeakSet(), of = function(t) {\n  [Pe(this, ru)._, this.fa = \"\"] = t.split(\"/\");\n  const e = H(this, se)[H(this, ru)];\n  !e || (DesignCast.allHide(), H(this, fa) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());\n}, Wi = new WeakMap(), qr = new WeakMap(), vh = new WeakSet(), vd = function(t) {\n  for (const e of ot(this, Ye, sr).call(this)) {\n    const o = H(this, se)[e];\n    o.fore instanceof TxtLayer && (o.fore.chgBackAlpha(t), o.back.chgBackAlpha(t));\n  }\n}, Qe = new WeakMap(), gh = new WeakSet(), gd = function(t) {\n  const e = t.fn ? t.fn.slice(0, 10) === \"userdata:/\" ? t.fn : `downloads:/${t.fn + getDateStr(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${getDateStr(\"-\", \"_\", \"\", \"_\")}.png`, o = this.cfg.searchPath(e);\n  if (this.sys.canCapturePage(o))\n    return !1;\n  const T = getExt(o), S = argChk_Color(t, \"b_color\", H(this, Hn)), N = autoDetectRenderer({\n    width: argChk_Num(t, \"width\", CmnLib.stageW),\n    height: argChk_Num(t, \"height\", CmnLib.stageH),\n    backgroundAlpha: S > 16777216 && T === \"png\" ? 0 : 1,\n    antialias: argChk_Boolean(t, \"smoothing\", !1),\n    preserveDrawingBuffer: !0,\n    backgroundColor: S & 16777215,\n    autoDensity: !0\n  }), D = [], B = t.page !== \"back\" ? \"fore\" : \"back\";\n  if (H(this, Ne).tw)\n    D.push(new Promise(($) => {\n      H(this, xe).visible = !0;\n      for (const U of H(this, Vn))\n        N.render(U, { clear: !1 });\n      H(this, xe).visible = !1, H(this, zn).visible = !0, H(this, ue).filters = H(this, Oe).filters, H(this, ue).visible = !0, N.render(H(this, ue), { clear: !1 }), H(this, ue).visible = !1, H(this, ue).filters = [], $();\n    }));\n  else\n    for (const $ of ot(this, Ye, sr).call(this, t.layer))\n      D.push(\n        new Promise((U) => H(this, se)[$][B].snapshot(N, () => U()))\n      );\n  return Promise.allSettled(D).then(async () => {\n    const $ = RenderTexture.create({ width: N.width, height: N.height, transform: !0 });\n    if (N.render(H(this, Nr), { renderTexture: $ }), await this.sys.savePic(\n      o,\n      N.plugins.extract.base64(Sprite.from($))\n    ), !H(this, Ne).tw)\n      for (const U of ot(this, Ye, sr).call(this, t.layer))\n        H(this, se)[U][B].snapshot_end();\n    N.destroy(!0);\n  }), !1;\n}, _h = new WeakSet(), _d = function(t) {\n  const { fn: e } = t;\n  if (!e)\n    throw \"fn\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = argChk_Boolean(t, \"join\", !0);\n  switch (getExt(e)) {\n    case \"css\":\n      (async () => {\n        const T = await fetch(e);\n        if (!T.ok)\n          throw new Error(\"Network response was not ok.\");\n        addStyle(await T.text()), o && this.main.resume();\n      })();\n      break;\n    default:\n      throw \"\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u306A\\u3044\\u62E1\\u5F35\\u5B50\\u3067\\u3059\";\n  }\n  return o;\n}, mh = new WeakSet(), md = function(t) {\n  const { layer: e, class: o } = t;\n  if (!e)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (e in H(this, se))\n    throw `layer\\u3010${e}\\u3011\\u306F\\u3059\\u3067\\u306B\\u3042\\u308A\\u307E\\u3059`;\n  if (!o)\n    throw \"cls\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const T = { isWait: !1 };\n  switch (H(this, se)[e] = new Pages(e, o, H(this, ue), H(this, xe), t, this.sys, this.val, T), H(this, Zr).push(e), o) {\n    case \"txt\":\n      H(this, Kr) || (nt(this, Yn, () => {\n      }), nt(this, cr, ot(this, Mh, Od)), nt(this, au, ot(this, Dh, Nd)), this.hTag.current({ layer: e }), this.goTxt = () => {\n        this.val.getVal(\"sn.skip.enabled\") ? nt(Oi, Yi, 0) : this.setNormalChWait();\n        for (const S of ot(this, Ye, sr).call(this)) {\n          const N = H(this, se)[S].fore;\n          N instanceof TxtLayer && H(this, Qe).call(this, \"gotxt\\uFF5C\", N, !1);\n        }\n      }), this.val.setVal_Nochk(\n        \"save\",\n        \"const.sn.layer.\" + (e != null ? e : H(this, Kr)) + \".enabled\",\n        !0\n      );\n      break;\n    case \"grp\":\n      if (H(this, nu))\n        break;\n      nt(this, nu, e);\n      break;\n  }\n  return this.scrItr.recodeDesign(t), T.isWait;\n}, se = new WeakMap(), Zr = new WeakMap(), Kr = new WeakMap(), nu = new WeakMap(), yh = new WeakSet(), yd = function(t) {\n  const e = ot(this, qi, bs).call(this, t), o = H(this, se)[e], T = o.back.spLay, S = o.fore.spLay;\n  if (argChk_Boolean(t, \"float\", !1))\n    H(this, xe).setChildIndex(T, H(this, xe).children.length - 1), H(this, ue).setChildIndex(S, H(this, ue).children.length - 1), ot(this, da, ul).call(this);\n  else if (t.index)\n    argChk_Num(t, \"index\", 0) && (H(this, xe).setChildIndex(T, t.index), H(this, ue).setChildIndex(S, t.index), ot(this, da, ul).call(this));\n  else if (t.dive) {\n    const { dive: N } = t;\n    let D = 0;\n    if (e === N)\n      throw \"[lay] \\u5C5E\\u6027 layer\\u3068dive\\u304C\\u540C\\u3058\\u3010\" + N + \"\\u3011\\u3067\\u3059\";\n    const B = H(this, se)[N];\n    if (!B)\n      throw \"[lay] \\u5C5E\\u6027 dive\\u3010\" + N + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n    const $ = B.back, U = B.fore, z = H(this, xe).getChildIndex($.spLay), V = H(this, ue).getChildIndex(U.spLay);\n    D = z < V ? z : V, D > H(this, xe).getChildIndex(T) && --D, H(this, ue).setChildIndex(S, D), H(this, xe).setChildIndex(T, D), ot(this, da, ul).call(this);\n  }\n  return t[\":id_tag\"] = o.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), o.lay(t);\n}, da = new WeakSet(), ul = function() {\n  nt(this, Zr, ot(this, Ch, Td).call(this));\n}, bh = new WeakSet(), bd = function(t) {\n  return ot(this, Sh, xd).call(this, t, (e) => {\n    const o = H(this, se)[ot(this, qi, bs).call(this, { layer: e })];\n    t.page === \"both\" ? (o.fore.clearLay(t), o.back.clearLay(t)) : o.getPage(t).clearLay(t);\n  }), !1;\n}, Eh = new WeakMap(), su = new WeakMap(), xh = new WeakMap(), jn = new WeakMap(), zn = new WeakMap(), _i = new WeakMap(), Oe = new WeakMap(), Vn = new WeakMap(), Th = new WeakSet(), Ed = function(t) {\n  ot(this, Xn, Ua).call(this);\n  const { layer: e } = t;\n  nt(this, Vn, []);\n  const o = {}, T = [];\n  for (const q of ot(this, Ye, sr).call(this, e))\n    o[q] = !0, T.push(H(this, se)[q].fore);\n  const S = [];\n  for (const q of ot(this, Ye, sr).call(this)) {\n    const Z = H(this, se)[q][o[q] ? \"back\" : \"fore\"];\n    H(this, Vn).push(Z.spLay), S.push(Z);\n  }\n  H(this, jn).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, xe), { renderTexture: H(this, jn) });\n  let N = () => {\n    H(this, xe).visible = !0;\n    for (const q of H(this, Vn))\n      this.appPixi.renderer.render(q, { renderTexture: H(this, jn), clear: !1 });\n    H(this, xe).visible = !1;\n  };\n  if (!S.some((q) => q.containMovement)) {\n    let q = N;\n    N = () => {\n      N = () => {\n      }, q();\n    };\n  }\n  H(this, _i).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ue), { renderTexture: H(this, _i) });\n  let D = () => {\n    H(this, ue).visible = !0, this.appPixi.renderer.render(H(this, ue), { renderTexture: H(this, _i) }), H(this, ue).visible = !1;\n  };\n  if (!T.some((q) => q.containMovement)) {\n    let q = D;\n    D = () => {\n      D = () => {\n      }, q();\n    };\n  }\n  const B = () => {\n    N(), H(this, zn).visible = !0, D(), H(this, Oe).visible = !0;\n  };\n  H(this, Oe).alpha = 1;\n  const $ = () => {\n    var Z;\n    this.appPixi.ticker && this.appPixi.ticker.remove(B), [Pe(this, ue)._, Pe(this, xe)._] = [H(this, xe), H(this, ue)];\n    const q = [];\n    for (const [K, J] of Object.entries(H(this, se))) {\n      if (o[K]) {\n        J.transPage(q);\n        continue;\n      }\n      const { fore: { spLay: tt }, back: { spLay: et } } = J, Q = H(this, ue).getChildIndex(et);\n      H(this, ue).removeChild(et), H(this, xe).removeChild(tt), H(this, ue).addChildAt(tt, Q), H(this, xe).addChildAt(et, Q);\n    }\n    Promise.allSettled(q), H(this, ue).visible = !0, H(this, xe).visible = !1, H(this, zn).visible = !1, H(this, Oe).visible = !1, (Z = H(this, Ne).tw) == null || Z.stop(), H(this, Ne).resume && this.main.resume(), nt(this, Ne, { tw: void 0, resume: !1 });\n  };\n  nt(this, Ne, { tw: void 0, resume: !1 });\n  const U = argChk_Num(t, \"time\", 0);\n  if (U === 0 || H(this, qr).isSkippingByKeyDown())\n    return $(), !1;\n  const { ease: z, glsl: V, rule: X } = t, W = CmnTween.ease(z);\n  if (!V && !X)\n    return H(this, Oe).filters = [], H(this, Ne).tw = new Tween(H(this, Oe)).to({ alpha: 0 }, U).delay(argChk_Num(t, \"delay\", 0)).easing(W).onComplete($).start(), this.appPixi.ticker.add(B), !1;\n  const Y = V ? new Filter(void 0, V, H(this, su)) : H(this, xh);\n  if (Y.uniforms.vague = argChk_Num(t, \"vague\", 0.04), Y.uniforms.tick = 0, H(this, Ne).tw = new Tween(Y.uniforms).to({ tick: 1 }, U).delay(argChk_Num(t, \"delay\", 0)).easing(W).onComplete($), H(this, Oe).filters = [Y], V)\n    return H(this, Ne).tw.start(), this.appPixi.ticker.add(B), !1;\n  if (!X)\n    throw \"rule\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return GrpLayer.csv2Sprites(X, void 0, (q) => {\n    var Z;\n    Y.uniforms.rule = q.texture, q.destroy(), (Z = H(this, Ne).tw) == null || Z.start(), this.appPixi.ticker.add(B);\n  }), !1;\n}, Ne = new WeakMap(), Ye = new WeakSet(), sr = function(t = \"\") {\n  return t ? t.split(\",\") : H(this, Zr);\n}, Sh = new WeakSet(), xd = function(t, e) {\n  const o = ot(this, Ye, sr).call(this, t.layer);\n  for (const T of o) {\n    if (!T)\n      continue;\n    const S = H(this, se)[T];\n    if (!S)\n      throw \"\\u5B58\\u5728\\u3057\\u306A\\u3044layer\\u3010\" + T + \"\\u3011\\u3067\\u3059\";\n    e(T, S);\n  }\n  return o;\n}, Ch = new WeakSet(), Td = function(t = \"\") {\n  return ot(this, Ye, sr).call(this, t).sort((e, o) => {\n    const T = H(this, ue).getChildIndex(H(this, se)[e].fore.spLay), S = H(this, ue).getChildIndex(H(this, se)[o].fore.spLay);\n    return T < S ? -1 : T > S ? 1 : 0;\n  });\n}, Rh = new WeakSet(), Sd = function(t) {\n  return H(this, Ne).tw ? (H(this, Ne).resume = !0, H(this, qr).waitLimitedEvent(t, () => ot(this, Xn, Ua).call(this))) : !1;\n}, Xn = new WeakSet(), Ua = function() {\n  var t;\n  return (t = H(this, Ne).tw) == null || t.end(), !1;\n}, Ih = new WeakSet(), Cd = function(t) {\n  ot(this, Xn, Ua).call(this);\n  const e = argChk_Num(t, \"time\", NaN);\n  if (e === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || H(this, qr).isSkippingByKeyDown())\n    return !1;\n  const { layer: o, ease: T } = t, S = [];\n  for (const X of ot(this, Ye, sr).call(this, o))\n    S.push(H(this, se)[X].fore.spLay);\n  H(this, _i).resize(CmnLib.stageW, CmnLib.stageH);\n  const N = () => {\n    H(this, ue).visible = !0;\n    for (const X of S)\n      this.appPixi.renderer.render(\n        X,\n        { renderTexture: H(this, _i), clear: !1 }\n      );\n    H(this, ue).visible = !1;\n  };\n  H(this, Oe).visible = !0, H(this, Oe).alpha = 1;\n  const D = uint(argChk_Num(t, \"hmax\", 10)), B = uint(argChk_Num(t, \"vmax\", 10)), $ = D === 0 ? () => {\n  } : () => H(this, Oe).x = Math.round(Math.random() * D * 2) - D, U = B === 0 ? () => {\n  } : () => H(this, Oe).y = Math.round(Math.random() * B * 2) - B;\n  H(this, Oe).filters = [];\n  const z = argChk_Num(t, \"repeat\", 1), V = new Tween(H(this, Oe)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, \"delay\", 0)).easing(CmnTween.ease(T)).onUpdate(() => {\n    $(), U();\n  }).repeat(z === 0 ? 1 / 0 : z - 1).yoyo(argChk_Boolean(t, \"yoyo\", !1)).onComplete(() => {\n    var X, W;\n    (X = this.appPixi.ticker) == null || X.remove(N), H(this, ue).visible = !0, H(this, Oe).visible = !1, H(this, Oe).x = 0, H(this, Oe).y = 0, (W = H(this, Ne).tw) == null || W.stop(), H(this, Ne).resume && this.main.resume(), nt(this, Ne, { tw: void 0, resume: !1 });\n  }).start();\n  return nt(this, Ne, { tw: V, resume: !1 }), this.appPixi.ticker.add(N), !1;\n}, hr = new WeakMap(), wh = new WeakSet(), Rd = function(t) {\n  const { layer: e, render: o, path: T, name: S, ease: N, chain: D } = t;\n  if (!e)\n    throw \"layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const B = ot(this, qi, bs).call(this, t);\n  let $ = H(this, se)[B].fore, U = () => {\n  };\n  const z = H(this, qr).isSkippingByKeyDown();\n  !z && o && ($.renderStart(), U = () => $.renderEnd());\n  const V = S != null ? S : e, X = () => {\n    var ut, ft;\n    const st = H(this, hr)[V];\n    !st || (U(), delete H(this, hr)[V], (ut = st.tw) == null || ut.stop(), st.resume && this.main.resume(), (ft = st.onEnd) == null || ft.call(st));\n  }, W = cnvTweenArg(t, $), Y = argChk_Num(t, \"time\", NaN) * (Boolean(this.val.getVal(\"tmp:sn.skip.enabled\") || z) ? 0 : 1), q = CmnTween.ease(N), Z = argChk_Num(t, \"repeat\", 1), K = Z === 0 ? 1 / 0 : Z - 1, J = argChk_Boolean(t, \"yoyo\", !1), tt = argChk_Num(t, \"delay\", 0), et = new Tween($).to(W, Y).easing(q).repeat(K).yoyo(J).delay(tt);\n  let Q = et;\n  if (T) {\n    CmnLib.debugLog && console.group(`\\u{1F35D} [tsy] path=${T}= start(${$.x},${$.y},${$.alpha})`);\n    for (const { groups: st } of T.matchAll(Oi.REG_TSY_PATH)) {\n      const { x: ut, x2: ft, y: ct, y2: pt, o: mt, o2: vt, json: _t } = st;\n      let xt = {};\n      if (_t)\n        try {\n          xt = JSON.parse(_t);\n        } catch (ht) {\n          console.error(`\\u{1F35D} json=${_t} ` + ht);\n          continue;\n        }\n      else\n        (ut != null ? ut : ft) && (xt.x = ut != null ? ut : ft), (ct != null ? ct : pt) && (xt.y = ct != null ? ct : pt), (mt != null ? mt : vt) && (xt.alpha = mt != null ? mt : vt);\n      const Rt = cnvTweenArg(xt, $);\n      CmnLib.debugLog && console.info(`\\u{1F35D} ${_t != null ? _t : `{x:${ut} y:${ct} o:${mt}}`} => hTo:${JSON.stringify(Rt)}`);\n      const yt = new Tween($).to(Rt, Y).easing(q).repeat(K).yoyo(J);\n      Q.chain(yt), Q = yt;\n    }\n    CmnLib.debugLog && console.groupEnd();\n  }\n  if (Q.onComplete(X), D) {\n    const st = H(this, hr)[D != null ? D : \"\"];\n    if (!(st != null && st.tw))\n      throw `${D}\\u306F\\u5B58\\u5728\\u3057\\u306A\\u3044\\u30FB\\u307E\\u305F\\u306F\\u7D42\\u4E86\\u3057\\u305F\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u3067\\u3059`;\n    delete st.onEnd, st.tw.chain(et);\n  } else\n    et.start();\n  const at = argChk_Boolean(t, \"arrive\", !1), it = argChk_Boolean(t, \"backlay\", !1);\n  return H(this, hr)[V] = { tw: Q, resume: !1, onEnd: () => {\n    if (at && Object.assign($, W), it) {\n      const st = H(this, se)[B].back.spLay;\n      for (const ut of Object.keys(hMemberCnt))\n        st[ut] = $[ut];\n    }\n  } }, !1;\n}, Ph = new WeakSet(), Id = function(t) {\n  const { layer: e = \"\", id: o, name: T } = t, S = o ? `frm\n${o}` : T != null ? T : e;\n  if (!S)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  const N = H(this, hr)[S];\n  return N != null && N.tw ? N.resume = H(this, qr).waitEvent(\n    () => {\n      var D;\n      return (D = N.tw) == null ? void 0 : D.end();\n    },\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ) : !1;\n}, Ah = new WeakSet(), wd = function(t) {\n  var N, D;\n  const { layer: e = \"\", id: o, name: T } = t, S = o ? `frm\n${o}` : T != null ? T : e;\n  if (!S)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (D = (N = H(this, hr)[S]) == null ? void 0 : N.tw) == null || D.end(), !1;\n}, Oh = new WeakSet(), Pd = function(t) {\n  var N, D;\n  const { layer: e = \"\", id: o, name: T } = t, S = o ? `frm\n${o}` : T != null ? T : e;\n  if (!S)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (D = (N = H(this, hr)[S]) == null ? void 0 : N.tw) == null || D.pause(), !1;\n}, Nh = new WeakSet(), Ad = function(t) {\n  var N, D;\n  const { layer: e = \"\", id: o, name: T } = t, S = o ? `frm\n${o}` : T != null ? T : e;\n  if (!S)\n    throw \"\\u30C8\\u30A5\\u30A4\\u30FC\\u30F3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\";\n  return (D = (N = H(this, hr)[S]) == null ? void 0 : N.tw) == null || D.resume(), !1;\n}, Yi = new WeakMap(), Wn = new WeakSet(), Ga = function(t) {\n  const { text: e } = t;\n  if (!e)\n    throw \"text\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = H(this, cr).call(this, t);\n  delete t.text, this.val.getVal(\"tmp:sn.skip.enabled\") ? t.wait = 0 : \"wait\" in t && argChk_Num(t, \"wait\", NaN);\n  const T = encodeURIComponent(JSON.stringify(t));\n  H(this, Qe).call(this, \"add\\uFF5C\" + T, o);\n  const S = argChk_Boolean(t, \"record\", !0), N = this.val.doRecLog();\n  return S || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", S), o.tagCh(e.replaceAll(\"[r]\", `\n`)), this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", N), H(this, Qe).call(this, \"add_close\\uFF5C\", o), !1;\n}, cr = new WeakMap(), Mh = new WeakSet(), Od = function(t) {\n  const e = ot(this, qi, bs).call(this, t, H(this, Kr)), T = H(this, se)[e].getPage(t);\n  if (!(T instanceof TxtLayer))\n    throw e + \"\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return T;\n}, au = new WeakMap(), Dh = new WeakSet(), Nd = function(t) {\n  const { layer: e } = t;\n  if (!e)\n    throw \"[current] layer\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (nt(this, Jr, H(this, se)[e]), !(H(this, Jr).getPage(t) instanceof TxtLayer))\n    throw `${e}\\u306FTxtLayer\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093`;\n  this.recPagebreak(), nt(this, Kr, e), this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", e);\n  for (const o of ot(this, Ye, sr).call(this)) {\n    const T = H(this, se)[o];\n    T.fore instanceof TxtLayer && (T.fore.isCur = T.back.isCur = o === e);\n  }\n  return !1;\n}, Jr = new WeakMap(), Yn = new WeakMap(), qi = new WeakSet(), bs = function(t, e = \"\") {\n  var T;\n  const o = (T = t.layer) != null ? T : e;\n  if (o.includes(\",\"))\n    throw \"layer\\u540D\\u306B\\u300C,\\u300D\\u306F\\u4F7F\\u3048\\u307E\\u305B\\u3093\";\n  if (!(o in H(this, se)))\n    throw \"\\u5C5E\\u6027 layer\\u3010\" + o + \"\\u3011\\u304C\\u4E0D\\u6B63\\u3067\\u3059\\u3002\\u30EC\\u30A4\\u30E4\\u30FC\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return t.layer = o;\n}, Mr = new WeakMap(), Qr = new WeakMap(), Lh = new WeakSet(), Md = function(t) {\n  const e = H(this, cr).call(this, t);\n  return t.layer === H(this, Kr) && t.page === \"fore\" && this.recPagebreak(), e.clearText(), !1;\n}, Fh = new WeakSet(), Dd = function(t) {\n  return H(this, Qe).call(this, \"endlink\\uFF5C\", H(this, cr).call(this, t)), !1;\n}, Bh = new WeakSet(), Ld = function(t) {\n  return argChk_Boolean(t, \"rec_page_break\", !0) && this.recPagebreak(), H(this, Jr) && (H(this, Jr).fore.clearLay(t), H(this, Jr).back.clearLay(t)), !1;\n}, kh = new WeakSet(), Fd = function(t) {\n  if (!t.pic)\n    throw \"[graph] pic\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, Qe).call(this, \"grp\\uFF5C\" + e, H(this, cr).call(this, t)), !1;\n}, $h = new WeakSet(), Bd = function(t) {\n  var o, T, S;\n  (o = t.style) != null || (t.style = \"background-color: rgba(255,0,0,0.5);\"), (T = t.style_hover) != null || (t.style_hover = \"background-color: rgba(255,0,0,0.9);\"), (S = t.style_clicked) != null || (t.style_clicked = t.style);\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, Qe).call(this, \"link\\uFF5C\" + e, H(this, cr).call(this, t)), !1;\n}, Uh = new WeakSet(), kd = function(t) {\n  return t.text = `\n`, ot(this, Wn, Ga).call(this, t);\n}, Gh = new WeakSet(), $d = function(t) {\n  return ot(this, ou, uf).call(this, { ...t, text: \"[r]\" });\n}, ou = new WeakSet(), uf = function(t) {\n  var e;\n  return t.text ? (t.record = !0, (e = t.style) != null || (t.style = \"\"), t.style += \"display: none;\", t.wait = 0, ot(this, Wn, Ga).call(this, t)) : !1;\n}, Hh = new WeakSet(), Ud = function(t) {\n  var e;\n  return nt(this, Qr, []), nt(this, Mr, (e = t.text) != null ? e : \"\"), this.val.setVal_Nochk(\n    \"save\",\n    \"const.sn.sLog\",\n    t.text ? `[{text:\"${t.text}\"}]` : \"[]\"\n  ), !1;\n}, jh = new WeakSet(), Gd = function(t) {\n  const { t: e, r: o } = t;\n  if (!e)\n    throw \"[ruby2] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (!o)\n    throw \"[ruby2] r\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  return t.text = \"\\uFF5C\" + encodeURIComponent(e) + \"\\u300A\" + encodeURIComponent(o) + \"\\u300B\", delete t.t, delete t.r, ot(this, Wn, Ga).call(this, t);\n}, zh = new WeakSet(), Hd = function(t) {\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, Qe).call(this, \"span\\uFF5C\" + e, H(this, cr).call(this, t)), !1;\n}, Vh = new WeakSet(), jd = function(t) {\n  if (!t.t)\n    throw \"[tcy] t\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return H(this, Qe).call(this, \"tcy\\uFF5C\" + e, H(this, cr).call(this, t)), !1;\n}, Xh = new WeakSet(), zd = function(t) {\n  console.group(\"\\u{1F95F} [dump_lay]\");\n  for (const e of ot(this, Ye, sr).call(this, t.layer)) {\n    const o = H(this, se)[e];\n    try {\n      console.info(\n        `%c${o.fore.name.slice(0, -7)} %o`,\n        `color:#${CmnLib.isDarkMode ? \"49F\" : \"05A\"};`,\n        JSON.parse(`{\"back\":{${o.back.dump()}}, \"fore\":{${o.fore.dump()}}}`)\n      );\n    } catch (T) {\n      console.error(\"dump_lay err:%o\", T), console.error(`   back:${o.back.dump()}`), console.error(`   fore:${o.fore.dump()}`);\n    }\n  }\n  return console.groupEnd(), !1;\n}, Wh = new WeakSet(), Vd = function(t) {\n  const e = ot(this, qi, bs).call(this, t, H(this, Kr)), o = argChk_Boolean(t, \"enabled\", !0);\n  return H(this, cr).call(this, t).enabled = o, this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + e + \".enabled\", o), !1;\n}, Yh = new WeakSet(), Xd = function(t) {\n  var e, o, T;\n  return Pages.argChk_page(t, \"back\"), (e = t.clicksebuf) != null || (t.clicksebuf = \"SYS\"), (o = t.entersebuf) != null || (t.entersebuf = \"SYS\"), (T = t.leavesebuf) != null || (t.leavesebuf = \"SYS\"), t.fn || (t.fn = this.scrItr.scriptFn), H(this, cr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;\n}, Pt(LayerMng, \"REG_TSY_PATH\", /\\(\\s*(?:(?<x>[-=\\d\\.]+)|(['\"])(?<x2>.*?)\\2)?(?:\\s*,\\s*(?:(?<y>[-=\\d\\.]+)|(['\"])(?<y2>.*?)\\5)?(?:\\s*,\\s*(?:(?<o>[-=\\d\\.]+)|(['\"])(?<o2>.*?)\\8))?)?|(?<json>\\{[^{}]*})/g), rt(LayerMng, Yi, 10);\nvar Te, _e, pa, qh, Wd, uu, qn, Ha;\nclass FocusMng {\n  constructor() {\n    rt(this, qh);\n    rt(this, qn);\n    rt(this, Te, []);\n    rt(this, _e, -1);\n    rt(this, pa, new EventListenerCtn());\n    rt(this, uu, CmnLib.debugLog ? (t) => console.log(`\\u{1F47E} <FocusMng idx:${t} btn:%o`, H(this, Te)[t].btn) : () => {\n    });\n  }\n  destroy() {\n    nt(this, Te, []), nt(this, _e, -1), H(this, pa).clear();\n  }\n  add(t, e, o) {\n    var D;\n    if (H(this, Te).findIndex((B) => B.btn === t) >= 0)\n      return;\n    if (t instanceof Container) {\n      t.on(\"pointerdown\", () => {\n        for (let B = H(this, Te).length - 1; B >= 0; --B)\n          if (H(this, Te)[B].btn === t) {\n            nt(this, _e, B);\n            return;\n          }\n        nt(this, _e, -1);\n      }), H(this, Te).push({ btn: t, on: e, off: o });\n      return;\n    }\n    H(this, pa).add(t, \"focus\", () => {\n      for (let B = H(this, Te).length - 1; B >= 0; --B)\n        if (H(this, Te)[B].btn === t) {\n          nt(this, _e, B);\n          return;\n        }\n      nt(this, _e, -1);\n    });\n    let T = (B) => {\n    }, S = t.localName === \"button\" || t.localName === \"a\" ? (B) => !B.isTrusted && B.key === \"Enter\" : (B) => B.key === \"Enter\";\n    const N = t;\n    switch ((D = N.type) != null ? D : \"\") {\n      case \"checkbox\":\n        T = () => N.checked = !N.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (T = (B) => ot(this, qh, Wd).call(this, t, B.key), S = () => !1);\n        break;\n      case \"range\":\n        T = (B) => {\n          B.isTrusted || (B.key === \"ArrowUp\" ? N.stepUp() : N.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        T = (B) => {\n          var U;\n          if (B.isTrusted)\n            return;\n          let $ = ((U = N.selectionStart) != null ? U : 0) + (B.key === \"ArrowUp\" ? -1 : 1);\n          $ < 0 && ($ = 0), N.setSelectionRange($, $);\n        };\n        break;\n    }\n    H(this, pa).add(t, \"keydown\", (B) => {\n      if (!(B.key !== \"ArrowUp\" && B.key !== \"ArrowDown\" && B.key !== \"Enter\")) {\n        if (B.stopPropagation(), B.stopImmediatePropagation(), S(B)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        T(B);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), H(this, Te).push({ btn: t, on: e, off: o });\n  }\n  remove(t) {\n    const e = H(this, Te).findIndex((o) => o.btn === t);\n    e < 0 || (H(this, Te).splice(e, 1), H(this, Te).length === 0 ? nt(this, _e, -1) : e <= H(this, _e) && --Pe(this, _e)._);\n  }\n  isFocus(t) {\n    return H(this, _e) < 0 ? !1 : H(this, Te)[H(this, _e)].btn === t;\n  }\n  prev() {\n    ot(this, qn, Ha).call(this);\n    const t = H(this, Te).length;\n    if (t !== 0) {\n      --Pe(this, _e)._ < 0 && nt(this, _e, t - 1);\n      for (let e = t; e >= 1; --e) {\n        const o = (H(this, _e) + e) % t;\n        if (H(this, Te)[o].on()) {\n          nt(this, _e, o), H(this, uu).call(this, o);\n          return;\n        }\n      }\n      nt(this, _e, -1);\n    }\n  }\n  next() {\n    ot(this, qn, Ha).call(this);\n    const t = H(this, Te).length;\n    if (t !== 0) {\n      ++Pe(this, _e)._ >= t && nt(this, _e, 0);\n      for (let e = 0; e < t; ++e) {\n        const o = (H(this, _e) + e) % t;\n        if (H(this, Te)[o].on()) {\n          nt(this, _e, o), H(this, uu).call(this, o);\n          return;\n        }\n      }\n      nt(this, _e, -1);\n    }\n  }\n  getFocus() {\n    if (H(this, _e) < 0)\n      return;\n    ot(this, qn, Ha).call(this), H(this, _e) >= H(this, Te).length && nt(this, _e, 0);\n    const t = H(this, Te)[H(this, _e)];\n    return t.on() ? t.btn : void 0;\n  }\n  blur() {\n    ot(this, qn, Ha).call(this), nt(this, _e, -1), globalThis.focus();\n  }\n}\nTe = new WeakMap(), _e = new WeakMap(), pa = new WeakMap(), qh = new WeakSet(), Wd = function(t, e) {\n  const o = t.querySelectorAll(\"input[type]\"), T = o.length;\n  for (let S = 0; S < T; ++S)\n    if (!!o[S].checked) {\n      o[(S + T + (e === \"ArrowUp\" ? -1 : 1)) % T].checked = !0;\n      break;\n    }\n}, uu = new WeakMap(), qn = new WeakSet(), Ha = function() {\n  for (let t = H(this, Te).length - 1; t >= 0; --t) {\n    const e = H(this, Te)[t];\n    !(e.btn instanceof Container) || e.btn.parent ? e.off() : H(this, Te).splice(t, 1);\n  }\n};\nvar top = \"top\", bottom = \"bottom\", right = \"right\", left = \"left\", auto = \"auto\", basePlacements = [top, bottom, right, left], start = \"start\", end = \"end\", clippingParents = \"clippingParents\", viewport = \"viewport\", popper = \"popper\", reference = \"reference\", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(r, t) {\n  return r.concat([t + \"-\" + start, t + \"-\" + end]);\n}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(r, t) {\n  return r.concat([t, t + \"-\" + start, t + \"-\" + end]);\n}, []), beforeRead = \"beforeRead\", read$6 = \"read\", afterRead = \"afterRead\", beforeMain = \"beforeMain\", main$1 = \"main\", afterMain = \"afterMain\", beforeWrite = \"beforeWrite\", write$6 = \"write\", afterWrite = \"afterWrite\", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];\nfunction getNodeName(r) {\n  return r ? (r.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(r) {\n  if (r == null)\n    return window;\n  if (r.toString() !== \"[object Window]\") {\n    var t = r.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return r;\n}\nfunction isElement(r) {\n  var t = getWindow(r).Element;\n  return r instanceof t || r instanceof Element;\n}\nfunction isHTMLElement(r) {\n  var t = getWindow(r).HTMLElement;\n  return r instanceof t || r instanceof HTMLElement;\n}\nfunction isShadowRoot(r) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = getWindow(r).ShadowRoot;\n  return r instanceof t || r instanceof ShadowRoot;\n}\nfunction applyStyles(r) {\n  var t = r.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var o = t.styles[e] || {}, T = t.attributes[e] || {}, S = t.elements[e];\n    !isHTMLElement(S) || !getNodeName(S) || (Object.assign(S.style, o), Object.keys(T).forEach(function(N) {\n      var D = T[N];\n      D === !1 ? S.removeAttribute(N) : S.setAttribute(N, D === !0 ? \"\" : D);\n    }));\n  });\n}\nfunction effect$2(r) {\n  var t = r.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(o) {\n      var T = t.elements[o], S = t.attributes[o] || {}, N = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : e[o]), D = N.reduce(function(B, $) {\n        return B[$] = \"\", B;\n      }, {});\n      !isHTMLElement(T) || !getNodeName(T) || (Object.assign(T.style, D), Object.keys(S).forEach(function(B) {\n        T.removeAttribute(B);\n      }));\n    });\n  };\n}\nconst applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(r) {\n  return r.split(\"-\")[0];\n}\nvar max = Math.max, min = Math.min, round = Math.round;\nfunction getUAString() {\n  var r = navigator.userAgentData;\n  return r != null && r.brands ? r.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(r, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var o = r.getBoundingClientRect(), T = 1, S = 1;\n  t && isHTMLElement(r) && (T = r.offsetWidth > 0 && round(o.width) / r.offsetWidth || 1, S = r.offsetHeight > 0 && round(o.height) / r.offsetHeight || 1);\n  var N = isElement(r) ? getWindow(r) : window, D = N.visualViewport, B = !isLayoutViewport() && e, $ = (o.left + (B && D ? D.offsetLeft : 0)) / T, U = (o.top + (B && D ? D.offsetTop : 0)) / S, z = o.width / T, V = o.height / S;\n  return {\n    width: z,\n    height: V,\n    top: U,\n    right: $ + z,\n    bottom: U + V,\n    left: $,\n    x: $,\n    y: U\n  };\n}\nfunction getLayoutRect(r) {\n  var t = getBoundingClientRect(r), e = r.offsetWidth, o = r.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {\n    x: r.offsetLeft,\n    y: r.offsetTop,\n    width: e,\n    height: o\n  };\n}\nfunction contains(r, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (r.contains(t))\n    return !0;\n  if (e && isShadowRoot(e)) {\n    var o = t;\n    do {\n      if (o && r.isSameNode(o))\n        return !0;\n      o = o.parentNode || o.host;\n    } while (o);\n  }\n  return !1;\n}\nfunction getComputedStyle$1(r) {\n  return getWindow(r).getComputedStyle(r);\n}\nfunction isTableElement(r) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(r)) >= 0;\n}\nfunction getDocumentElement(r) {\n  return ((isElement(r) ? r.ownerDocument : r.document) || window.document).documentElement;\n}\nfunction getParentNode(r) {\n  return getNodeName(r) === \"html\" ? r : r.assignedSlot || r.parentNode || (isShadowRoot(r) ? r.host : null) || getDocumentElement(r);\n}\nfunction getTrueOffsetParent(r) {\n  return !isHTMLElement(r) || getComputedStyle$1(r).position === \"fixed\" ? null : r.offsetParent;\n}\nfunction getContainingBlock(r) {\n  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());\n  if (e && isHTMLElement(r)) {\n    var o = getComputedStyle$1(r);\n    if (o.position === \"fixed\")\n      return null;\n  }\n  var T = getParentNode(r);\n  for (isShadowRoot(T) && (T = T.host); isHTMLElement(T) && [\"html\", \"body\"].indexOf(getNodeName(T)) < 0; ) {\n    var S = getComputedStyle$1(T);\n    if (S.transform !== \"none\" || S.perspective !== \"none\" || S.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(S.willChange) !== -1 || t && S.willChange === \"filter\" || t && S.filter && S.filter !== \"none\")\n      return T;\n    T = T.parentNode;\n  }\n  return null;\n}\nfunction getOffsetParent(r) {\n  for (var t = getWindow(r), e = getTrueOffsetParent(r); e && isTableElement(e) && getComputedStyle$1(e).position === \"static\"; )\n    e = getTrueOffsetParent(e);\n  return e && (getNodeName(e) === \"html\" || getNodeName(e) === \"body\" && getComputedStyle$1(e).position === \"static\") ? t : e || getContainingBlock(r) || t;\n}\nfunction getMainAxisFromPlacement(r) {\n  return [\"top\", \"bottom\"].indexOf(r) >= 0 ? \"x\" : \"y\";\n}\nfunction within(r, t, e) {\n  return max(r, min(t, e));\n}\nfunction withinMaxClamp(r, t, e) {\n  var o = within(r, t, e);\n  return o > e ? e : o;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(r) {\n  return Object.assign({}, getFreshSideObject(), r);\n}\nfunction expandToHashMap(r, t) {\n  return t.reduce(function(e, o) {\n    return e[o] = r, e;\n  }, {});\n}\nvar toPaddingObject = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, mergePaddingObject(typeof t != \"number\" ? t : expandToHashMap(t, basePlacements));\n};\nfunction arrow(r) {\n  var t, e = r.state, o = r.name, T = r.options, S = e.elements.arrow, N = e.modifiersData.popperOffsets, D = getBasePlacement(e.placement), B = getMainAxisFromPlacement(D), $ = [left, right].indexOf(D) >= 0, U = $ ? \"height\" : \"width\";\n  if (!(!S || !N)) {\n    var z = toPaddingObject(T.padding, e), V = getLayoutRect(S), X = B === \"y\" ? top : left, W = B === \"y\" ? bottom : right, Y = e.rects.reference[U] + e.rects.reference[B] - N[B] - e.rects.popper[U], q = N[B] - e.rects.reference[B], Z = getOffsetParent(S), K = Z ? B === \"y\" ? Z.clientHeight || 0 : Z.clientWidth || 0 : 0, J = Y / 2 - q / 2, tt = z[X], et = K - V[U] - z[W], Q = K / 2 - V[U] / 2 + J, at = within(tt, Q, et), it = B;\n    e.modifiersData[o] = (t = {}, t[it] = at, t.centerOffset = at - Q, t);\n  }\n}\nfunction effect$1(r) {\n  var t = r.state, e = r.options, o = e.element, T = o === void 0 ? \"[data-popper-arrow]\" : o;\n  if (T != null && !(typeof T == \"string\" && (T = t.elements.popper.querySelector(T), !T))) {\n    if ( true && (isHTMLElement(T) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !contains(t.elements.popper, T)) {\n       true && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = T;\n  }\n}\nconst arrow$1 = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(r) {\n  return r.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(r) {\n  var t = r.x, e = r.y, o = window, T = o.devicePixelRatio || 1;\n  return {\n    x: round(t * T) / T || 0,\n    y: round(e * T) / T || 0\n  };\n}\nfunction mapToStyles(r) {\n  var t, e = r.popper, o = r.popperRect, T = r.placement, S = r.variation, N = r.offsets, D = r.position, B = r.gpuAcceleration, $ = r.adaptive, U = r.roundOffsets, z = r.isFixed, V = N.x, X = V === void 0 ? 0 : V, W = N.y, Y = W === void 0 ? 0 : W, q = typeof U == \"function\" ? U({\n    x: X,\n    y: Y\n  }) : {\n    x: X,\n    y: Y\n  };\n  X = q.x, Y = q.y;\n  var Z = N.hasOwnProperty(\"x\"), K = N.hasOwnProperty(\"y\"), J = left, tt = top, et = window;\n  if ($) {\n    var Q = getOffsetParent(e), at = \"clientHeight\", it = \"clientWidth\";\n    if (Q === getWindow(e) && (Q = getDocumentElement(e), getComputedStyle$1(Q).position !== \"static\" && D === \"absolute\" && (at = \"scrollHeight\", it = \"scrollWidth\")), Q = Q, T === top || (T === left || T === right) && S === end) {\n      tt = bottom;\n      var st = z && Q === et && et.visualViewport ? et.visualViewport.height : Q[at];\n      Y -= st - o.height, Y *= B ? 1 : -1;\n    }\n    if (T === left || (T === top || T === bottom) && S === end) {\n      J = right;\n      var ut = z && Q === et && et.visualViewport ? et.visualViewport.width : Q[it];\n      X -= ut - o.width, X *= B ? 1 : -1;\n    }\n  }\n  var ft = Object.assign({\n    position: D\n  }, $ && unsetSides), ct = U === !0 ? roundOffsetsByDPR({\n    x: X,\n    y: Y\n  }) : {\n    x: X,\n    y: Y\n  };\n  if (X = ct.x, Y = ct.y, B) {\n    var pt;\n    return Object.assign({}, ft, (pt = {}, pt[tt] = K ? \"0\" : \"\", pt[J] = Z ? \"0\" : \"\", pt.transform = (et.devicePixelRatio || 1) <= 1 ? \"translate(\" + X + \"px, \" + Y + \"px)\" : \"translate3d(\" + X + \"px, \" + Y + \"px, 0)\", pt));\n  }\n  return Object.assign({}, ft, (t = {}, t[tt] = K ? Y + \"px\" : \"\", t[J] = Z ? X + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction computeStyles(r) {\n  var t = r.state, e = r.options, o = e.gpuAcceleration, T = o === void 0 ? !0 : o, S = e.adaptive, N = S === void 0 ? !0 : S, D = e.roundOffsets, B = D === void 0 ? !0 : D;\n  if (true) {\n    var $ = getComputedStyle$1(t.elements.popper).transitionProperty || \"\";\n    N && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(z) {\n      return $.indexOf(z) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var U = {\n    placement: getBasePlacement(t.placement),\n    variation: getVariation(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: T,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, U, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: N,\n    roundOffsets: B\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, U, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: B\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: !0\n};\nfunction effect(r) {\n  var t = r.state, e = r.instance, o = r.options, T = o.scroll, S = T === void 0 ? !0 : T, N = o.resize, D = N === void 0 ? !0 : N, B = getWindow(t.elements.popper), $ = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return S && $.forEach(function(U) {\n    U.addEventListener(\"scroll\", e.update, passive);\n  }), D && B.addEventListener(\"resize\", e.update, passive), function() {\n    S && $.forEach(function(U) {\n      U.removeEventListener(\"scroll\", e.update, passive);\n    }), D && B.removeEventListener(\"resize\", e.update, passive);\n  };\n}\nconst eventListeners = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(r) {\n  return r.replace(/left|right|bottom|top/g, function(t) {\n    return hash$1[t];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(r) {\n  return r.replace(/start|end/g, function(t) {\n    return hash[t];\n  });\n}\nfunction getWindowScroll(r) {\n  var t = getWindow(r), e = t.pageXOffset, o = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: o\n  };\n}\nfunction getWindowScrollBarX(r) {\n  return getBoundingClientRect(getDocumentElement(r)).left + getWindowScroll(r).scrollLeft;\n}\nfunction getViewportRect(r, t) {\n  var e = getWindow(r), o = getDocumentElement(r), T = e.visualViewport, S = o.clientWidth, N = o.clientHeight, D = 0, B = 0;\n  if (T) {\n    S = T.width, N = T.height;\n    var $ = isLayoutViewport();\n    ($ || !$ && t === \"fixed\") && (D = T.offsetLeft, B = T.offsetTop);\n  }\n  return {\n    width: S,\n    height: N,\n    x: D + getWindowScrollBarX(r),\n    y: B\n  };\n}\nfunction getDocumentRect(r) {\n  var t, e = getDocumentElement(r), o = getWindowScroll(r), T = (t = r.ownerDocument) == null ? void 0 : t.body, S = max(e.scrollWidth, e.clientWidth, T ? T.scrollWidth : 0, T ? T.clientWidth : 0), N = max(e.scrollHeight, e.clientHeight, T ? T.scrollHeight : 0, T ? T.clientHeight : 0), D = -o.scrollLeft + getWindowScrollBarX(r), B = -o.scrollTop;\n  return getComputedStyle$1(T || e).direction === \"rtl\" && (D += max(e.clientWidth, T ? T.clientWidth : 0) - S), {\n    width: S,\n    height: N,\n    x: D,\n    y: B\n  };\n}\nfunction isScrollParent(r) {\n  var t = getComputedStyle$1(r), e = t.overflow, o = t.overflowX, T = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + T + o);\n}\nfunction getScrollParent(r) {\n  return [\"html\", \"body\", \"#document\"].indexOf(getNodeName(r)) >= 0 ? r.ownerDocument.body : isHTMLElement(r) && isScrollParent(r) ? r : getScrollParent(getParentNode(r));\n}\nfunction listScrollParents(r, t) {\n  var e;\n  t === void 0 && (t = []);\n  var o = getScrollParent(r), T = o === ((e = r.ownerDocument) == null ? void 0 : e.body), S = getWindow(o), N = T ? [S].concat(S.visualViewport || [], isScrollParent(o) ? o : []) : o, D = t.concat(N);\n  return T ? D : D.concat(listScrollParents(getParentNode(N)));\n}\nfunction rectToClientRect(r) {\n  return Object.assign({}, r, {\n    left: r.x,\n    top: r.y,\n    right: r.x + r.width,\n    bottom: r.y + r.height\n  });\n}\nfunction getInnerBoundingClientRect(r, t) {\n  var e = getBoundingClientRect(r, !1, t === \"fixed\");\n  return e.top = e.top + r.clientTop, e.left = e.left + r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction getClientRectFromMixedType(r, t, e) {\n  return t === viewport ? rectToClientRect(getViewportRect(r, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(r)));\n}\nfunction getClippingParents(r) {\n  var t = listScrollParents(getParentNode(r)), e = [\"absolute\", \"fixed\"].indexOf(getComputedStyle$1(r).position) >= 0, o = e && isHTMLElement(r) ? getOffsetParent(r) : r;\n  return isElement(o) ? t.filter(function(T) {\n    return isElement(T) && contains(T, o) && getNodeName(T) !== \"body\";\n  }) : [];\n}\nfunction getClippingRect(r, t, e, o) {\n  var T = t === \"clippingParents\" ? getClippingParents(r) : [].concat(t), S = [].concat(T, [e]), N = S[0], D = S.reduce(function(B, $) {\n    var U = getClientRectFromMixedType(r, $, o);\n    return B.top = max(U.top, B.top), B.right = min(U.right, B.right), B.bottom = min(U.bottom, B.bottom), B.left = max(U.left, B.left), B;\n  }, getClientRectFromMixedType(r, N, o));\n  return D.width = D.right - D.left, D.height = D.bottom - D.top, D.x = D.left, D.y = D.top, D;\n}\nfunction computeOffsets(r) {\n  var t = r.reference, e = r.element, o = r.placement, T = o ? getBasePlacement(o) : null, S = o ? getVariation(o) : null, N = t.x + t.width / 2 - e.width / 2, D = t.y + t.height / 2 - e.height / 2, B;\n  switch (T) {\n    case top:\n      B = {\n        x: N,\n        y: t.y - e.height\n      };\n      break;\n    case bottom:\n      B = {\n        x: N,\n        y: t.y + t.height\n      };\n      break;\n    case right:\n      B = {\n        x: t.x + t.width,\n        y: D\n      };\n      break;\n    case left:\n      B = {\n        x: t.x - e.width,\n        y: D\n      };\n      break;\n    default:\n      B = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var $ = T ? getMainAxisFromPlacement(T) : null;\n  if ($ != null) {\n    var U = $ === \"y\" ? \"height\" : \"width\";\n    switch (S) {\n      case start:\n        B[$] = B[$] - (t[U] / 2 - e[U] / 2);\n        break;\n      case end:\n        B[$] = B[$] + (t[U] / 2 - e[U] / 2);\n        break;\n    }\n  }\n  return B;\n}\nfunction detectOverflow(r, t) {\n  t === void 0 && (t = {});\n  var e = t, o = e.placement, T = o === void 0 ? r.placement : o, S = e.strategy, N = S === void 0 ? r.strategy : S, D = e.boundary, B = D === void 0 ? clippingParents : D, $ = e.rootBoundary, U = $ === void 0 ? viewport : $, z = e.elementContext, V = z === void 0 ? popper : z, X = e.altBoundary, W = X === void 0 ? !1 : X, Y = e.padding, q = Y === void 0 ? 0 : Y, Z = mergePaddingObject(typeof q != \"number\" ? q : expandToHashMap(q, basePlacements)), K = V === popper ? reference : popper, J = r.rects.popper, tt = r.elements[W ? K : V], et = getClippingRect(isElement(tt) ? tt : tt.contextElement || getDocumentElement(r.elements.popper), B, U, N), Q = getBoundingClientRect(r.elements.reference), at = computeOffsets({\n    reference: Q,\n    element: J,\n    strategy: \"absolute\",\n    placement: T\n  }), it = rectToClientRect(Object.assign({}, J, at)), st = V === popper ? it : Q, ut = {\n    top: et.top - st.top + Z.top,\n    bottom: st.bottom - et.bottom + Z.bottom,\n    left: et.left - st.left + Z.left,\n    right: st.right - et.right + Z.right\n  }, ft = r.modifiersData.offset;\n  if (V === popper && ft) {\n    var ct = ft[T];\n    Object.keys(ut).forEach(function(pt) {\n      var mt = [right, bottom].indexOf(pt) >= 0 ? 1 : -1, vt = [top, bottom].indexOf(pt) >= 0 ? \"y\" : \"x\";\n      ut[pt] += ct[vt] * mt;\n    });\n  }\n  return ut;\n}\nfunction computeAutoPlacement(r, t) {\n  t === void 0 && (t = {});\n  var e = t, o = e.placement, T = e.boundary, S = e.rootBoundary, N = e.padding, D = e.flipVariations, B = e.allowedAutoPlacements, $ = B === void 0 ? placements : B, U = getVariation(o), z = U ? D ? variationPlacements : variationPlacements.filter(function(W) {\n    return getVariation(W) === U;\n  }) : basePlacements, V = z.filter(function(W) {\n    return $.indexOf(W) >= 0;\n  });\n  V.length === 0 && (V = z,  true && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var X = V.reduce(function(W, Y) {\n    return W[Y] = detectOverflow(r, {\n      placement: Y,\n      boundary: T,\n      rootBoundary: S,\n      padding: N\n    })[getBasePlacement(Y)], W;\n  }, {});\n  return Object.keys(X).sort(function(W, Y) {\n    return X[W] - X[Y];\n  });\n}\nfunction getExpandedFallbackPlacements(r) {\n  if (getBasePlacement(r) === auto)\n    return [];\n  var t = getOppositePlacement(r);\n  return [getOppositeVariationPlacement(r), t, getOppositeVariationPlacement(t)];\n}\nfunction flip(r) {\n  var t = r.state, e = r.options, o = r.name;\n  if (!t.modifiersData[o]._skip) {\n    for (var T = e.mainAxis, S = T === void 0 ? !0 : T, N = e.altAxis, D = N === void 0 ? !0 : N, B = e.fallbackPlacements, $ = e.padding, U = e.boundary, z = e.rootBoundary, V = e.altBoundary, X = e.flipVariations, W = X === void 0 ? !0 : X, Y = e.allowedAutoPlacements, q = t.options.placement, Z = getBasePlacement(q), K = Z === q, J = B || (K || !W ? [getOppositePlacement(q)] : getExpandedFallbackPlacements(q)), tt = [q].concat(J).reduce(function(wt, Ft) {\n      return wt.concat(getBasePlacement(Ft) === auto ? computeAutoPlacement(t, {\n        placement: Ft,\n        boundary: U,\n        rootBoundary: z,\n        padding: $,\n        flipVariations: W,\n        allowedAutoPlacements: Y\n      }) : Ft);\n    }, []), et = t.rects.reference, Q = t.rects.popper, at = /* @__PURE__ */ new Map(), it = !0, st = tt[0], ut = 0; ut < tt.length; ut++) {\n      var ft = tt[ut], ct = getBasePlacement(ft), pt = getVariation(ft) === start, mt = [top, bottom].indexOf(ct) >= 0, vt = mt ? \"width\" : \"height\", _t = detectOverflow(t, {\n        placement: ft,\n        boundary: U,\n        rootBoundary: z,\n        altBoundary: V,\n        padding: $\n      }), xt = mt ? pt ? right : left : pt ? bottom : top;\n      et[vt] > Q[vt] && (xt = getOppositePlacement(xt));\n      var Rt = getOppositePlacement(xt), yt = [];\n      if (S && yt.push(_t[ct] <= 0), D && yt.push(_t[xt] <= 0, _t[Rt] <= 0), yt.every(function(wt) {\n        return wt;\n      })) {\n        st = ft, it = !1;\n        break;\n      }\n      at.set(ft, yt);\n    }\n    if (it)\n      for (var ht = W ? 3 : 1, bt = function(Ft) {\n        var dt = tt.find(function(Gt) {\n          var Mt = at.get(Gt);\n          if (Mt)\n            return Mt.slice(0, Ft).every(function(Bt) {\n              return Bt;\n            });\n        });\n        if (dt)\n          return st = dt, \"break\";\n      }, St = ht; St > 0; St--) {\n        var Ot = bt(St);\n        if (Ot === \"break\")\n          break;\n      }\n    t.placement !== st && (t.modifiersData[o]._skip = !0, t.placement = st, t.reset = !0);\n  }\n}\nconst flip$1 = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction getSideOffsets(r, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: r.top - t.height - e.y,\n    right: r.right - t.width + e.x,\n    bottom: r.bottom - t.height + e.y,\n    left: r.left - t.width - e.x\n  };\n}\nfunction isAnySideFullyClipped(r) {\n  return [top, right, bottom, left].some(function(t) {\n    return r[t] >= 0;\n  });\n}\nfunction hide(r) {\n  var t = r.state, e = r.name, o = t.rects.reference, T = t.rects.popper, S = t.modifiersData.preventOverflow, N = detectOverflow(t, {\n    elementContext: \"reference\"\n  }), D = detectOverflow(t, {\n    altBoundary: !0\n  }), B = getSideOffsets(N, o), $ = getSideOffsets(D, T, S), U = isAnySideFullyClipped(B), z = isAnySideFullyClipped($);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: B,\n    popperEscapeOffsets: $,\n    isReferenceHidden: U,\n    hasPopperEscaped: z\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": U,\n    \"data-popper-escaped\": z\n  });\n}\nconst hide$1 = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(r, t, e) {\n  var o = getBasePlacement(r), T = [left, top].indexOf(o) >= 0 ? -1 : 1, S = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: r\n  })) : e, N = S[0], D = S[1];\n  return N = N || 0, D = (D || 0) * T, [left, right].indexOf(o) >= 0 ? {\n    x: D,\n    y: N\n  } : {\n    x: N,\n    y: D\n  };\n}\nfunction offset(r) {\n  var t = r.state, e = r.options, o = r.name, T = e.offset, S = T === void 0 ? [0, 0] : T, N = placements.reduce(function(U, z) {\n    return U[z] = distanceAndSkiddingToXY(z, t.rects, S), U;\n  }, {}), D = N[t.placement], B = D.x, $ = D.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += B, t.modifiersData.popperOffsets.y += $), t.modifiersData[o] = N;\n}\nconst offset$1 = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(r) {\n  var t = r.state, e = r.name;\n  t.modifiersData[e] = computeOffsets({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(r) {\n  return r === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(r) {\n  var t = r.state, e = r.options, o = r.name, T = e.mainAxis, S = T === void 0 ? !0 : T, N = e.altAxis, D = N === void 0 ? !1 : N, B = e.boundary, $ = e.rootBoundary, U = e.altBoundary, z = e.padding, V = e.tether, X = V === void 0 ? !0 : V, W = e.tetherOffset, Y = W === void 0 ? 0 : W, q = detectOverflow(t, {\n    boundary: B,\n    rootBoundary: $,\n    padding: z,\n    altBoundary: U\n  }), Z = getBasePlacement(t.placement), K = getVariation(t.placement), J = !K, tt = getMainAxisFromPlacement(Z), et = getAltAxis(tt), Q = t.modifiersData.popperOffsets, at = t.rects.reference, it = t.rects.popper, st = typeof Y == \"function\" ? Y(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : Y, ut = typeof st == \"number\" ? {\n    mainAxis: st,\n    altAxis: st\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, st), ft = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ct = {\n    x: 0,\n    y: 0\n  };\n  if (!!Q) {\n    if (S) {\n      var pt, mt = tt === \"y\" ? top : left, vt = tt === \"y\" ? bottom : right, _t = tt === \"y\" ? \"height\" : \"width\", xt = Q[tt], Rt = xt + q[mt], yt = xt - q[vt], ht = X ? -it[_t] / 2 : 0, bt = K === start ? at[_t] : it[_t], St = K === start ? -it[_t] : -at[_t], Ot = t.elements.arrow, wt = X && Ot ? getLayoutRect(Ot) : {\n        width: 0,\n        height: 0\n      }, Ft = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject(), dt = Ft[mt], Gt = Ft[vt], Mt = within(0, at[_t], wt[_t]), Bt = J ? at[_t] / 2 - ht - Mt - dt - ut.mainAxis : bt - Mt - dt - ut.mainAxis, Dt = J ? -at[_t] / 2 + ht + Mt + Gt + ut.mainAxis : St + Mt + Gt + ut.mainAxis, Et = t.elements.arrow && getOffsetParent(t.elements.arrow), zt = Et ? tt === \"y\" ? Et.clientTop || 0 : Et.clientLeft || 0 : 0, It = (pt = ft == null ? void 0 : ft[tt]) != null ? pt : 0, Ct = xt + Bt - It - zt, Lt = xt + Dt - It, $t = within(X ? min(Rt, Ct) : Rt, xt, X ? max(yt, Lt) : yt);\n      Q[tt] = $t, ct[tt] = $t - xt;\n    }\n    if (D) {\n      var At, ee = tt === \"x\" ? top : left, te = tt === \"x\" ? bottom : right, he = Q[et], we = et === \"y\" ? \"height\" : \"width\", Be = he + q[ee], ne = he - q[te], Me = [top, left].indexOf(Z) !== -1, ye = (At = ft == null ? void 0 : ft[et]) != null ? At : 0, de = Me ? Be : he - at[we] - it[we] - ye + ut.altAxis, ce = Me ? he + at[we] + it[we] - ye - ut.altAxis : ne, ie = X && Me ? withinMaxClamp(de, he, ce) : within(X ? de : Be, he, X ? ce : ne);\n      Q[et] = ie, ct[et] = ie - he;\n    }\n    t.modifiersData[o] = ct;\n  }\n}\nconst preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(r) {\n  return {\n    scrollLeft: r.scrollLeft,\n    scrollTop: r.scrollTop\n  };\n}\nfunction getNodeScroll(r) {\n  return r === getWindow(r) || !isHTMLElement(r) ? getWindowScroll(r) : getHTMLElementScroll(r);\n}\nfunction isElementScaled(r) {\n  var t = r.getBoundingClientRect(), e = round(t.width) / r.offsetWidth || 1, o = round(t.height) / r.offsetHeight || 1;\n  return e !== 1 || o !== 1;\n}\nfunction getCompositeRect(r, t, e) {\n  e === void 0 && (e = !1);\n  var o = isHTMLElement(t), T = isHTMLElement(t) && isElementScaled(t), S = getDocumentElement(t), N = getBoundingClientRect(r, T, e), D = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, B = {\n    x: 0,\n    y: 0\n  };\n  return (o || !o && !e) && ((getNodeName(t) !== \"body\" || isScrollParent(S)) && (D = getNodeScroll(t)), isHTMLElement(t) ? (B = getBoundingClientRect(t, !0), B.x += t.clientLeft, B.y += t.clientTop) : S && (B.x = getWindowScrollBarX(S))), {\n    x: N.left + D.scrollLeft - B.x,\n    y: N.top + D.scrollTop - B.y,\n    width: N.width,\n    height: N.height\n  };\n}\nfunction order(r) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), o = [];\n  r.forEach(function(S) {\n    t.set(S.name, S);\n  });\n  function T(S) {\n    e.add(S.name);\n    var N = [].concat(S.requires || [], S.requiresIfExists || []);\n    N.forEach(function(D) {\n      if (!e.has(D)) {\n        var B = t.get(D);\n        B && T(B);\n      }\n    }), o.push(S);\n  }\n  return r.forEach(function(S) {\n    e.has(S.name) || T(S);\n  }), o;\n}\nfunction orderModifiers(r) {\n  var t = order(r);\n  return modifierPhases.reduce(function(e, o) {\n    return e.concat(t.filter(function(T) {\n      return T.phase === o;\n    }));\n  }, []);\n}\nfunction debounce(r) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(r());\n      });\n    })), t;\n  };\n}\nfunction format(r) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)\n    e[o - 1] = arguments[o];\n  return [].concat(e).reduce(function(T, S) {\n    return T.replace(/%s/, S);\n  }, r);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction validateModifiers(r) {\n  r.forEach(function(t) {\n    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, o, T) {\n      return T.indexOf(e) === o;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(o) {\n            return '\"' + o + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(o) {\n        r.find(function(T) {\n          return T.name === o;\n        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), o, o));\n      });\n    });\n  });\n}\nfunction uniqueBy(r, t) {\n  var e = /* @__PURE__ */ new Set();\n  return r.filter(function(o) {\n    var T = t(o);\n    if (!e.has(T))\n      return e.add(T), !0;\n  });\n}\nfunction mergeByName(r) {\n  var t = r.reduce(function(e, o) {\n    var T = e[o.name];\n    return e[o.name] = T ? Object.assign({}, T, o, {\n      options: Object.assign({}, T.options, o.options),\n      data: Object.assign({}, T.data, o.data)\n    }) : o, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var r = arguments.length, t = new Array(r), e = 0; e < r; e++)\n    t[e] = arguments[e];\n  return !t.some(function(o) {\n    return !(o && typeof o.getBoundingClientRect == \"function\");\n  });\n}\nfunction popperGenerator(r) {\n  r === void 0 && (r = {});\n  var t = r, e = t.defaultModifiers, o = e === void 0 ? [] : e, T = t.defaultOptions, S = T === void 0 ? DEFAULT_OPTIONS : T;\n  return function(D, B, $) {\n    $ === void 0 && ($ = S);\n    var U = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, S),\n      modifiersData: {},\n      elements: {\n        reference: D,\n        popper: B\n      },\n      attributes: {},\n      styles: {}\n    }, z = [], V = !1, X = {\n      state: U,\n      setOptions: function(Z) {\n        var K = typeof Z == \"function\" ? Z(U.options) : Z;\n        Y(), U.options = Object.assign({}, S, U.options, K), U.scrollParents = {\n          reference: isElement(D) ? listScrollParents(D) : D.contextElement ? listScrollParents(D.contextElement) : [],\n          popper: listScrollParents(B)\n        };\n        var J = orderModifiers(mergeByName([].concat(o, U.options.modifiers)));\n        if (U.orderedModifiers = J.filter(function(ft) {\n          return ft.enabled;\n        }), \"development\" !== \"production\") {\n          var tt = uniqueBy([].concat(J, U.options.modifiers), function(ft) {\n            var ct = ft.name;\n            return ct;\n          });\n          if (validateModifiers(tt), getBasePlacement(U.options.placement) === auto) {\n            var et = U.orderedModifiers.find(function(ft) {\n              var ct = ft.name;\n              return ct === \"flip\";\n            });\n            et || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var Q = getComputedStyle$1(B), at = Q.marginTop, it = Q.marginRight, st = Q.marginBottom, ut = Q.marginLeft;\n          [at, it, st, ut].some(function(ft) {\n            return parseFloat(ft);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return W(), X.update();\n      },\n      forceUpdate: function() {\n        if (!V) {\n          var Z = U.elements, K = Z.reference, J = Z.popper;\n          if (!areValidElements(K, J)) {\n             true && console.error(INVALID_ELEMENT_ERROR);\n            return;\n          }\n          U.rects = {\n            reference: getCompositeRect(K, getOffsetParent(J), U.options.strategy === \"fixed\"),\n            popper: getLayoutRect(J)\n          }, U.reset = !1, U.placement = U.options.placement, U.orderedModifiers.forEach(function(ft) {\n            return U.modifiersData[ft.name] = Object.assign({}, ft.data);\n          });\n          for (var tt = 0, et = 0; et < U.orderedModifiers.length; et++) {\n            if ( true && (tt += 1, tt > 100)) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n            if (U.reset === !0) {\n              U.reset = !1, et = -1;\n              continue;\n            }\n            var Q = U.orderedModifiers[et], at = Q.fn, it = Q.options, st = it === void 0 ? {} : it, ut = Q.name;\n            typeof at == \"function\" && (U = at({\n              state: U,\n              options: st,\n              name: ut,\n              instance: X\n            }) || U);\n          }\n        }\n      },\n      update: debounce(function() {\n        return new Promise(function(q) {\n          X.forceUpdate(), q(U);\n        });\n      }),\n      destroy: function() {\n        Y(), V = !0;\n      }\n    };\n    if (!areValidElements(D, B))\n      return  true && console.error(INVALID_ELEMENT_ERROR), X;\n    X.setOptions($).then(function(q) {\n      !V && $.onFirstUpdate && $.onFirstUpdate(q);\n    });\n    function W() {\n      U.orderedModifiers.forEach(function(q) {\n        var Z = q.name, K = q.options, J = K === void 0 ? {} : K, tt = q.effect;\n        if (typeof tt == \"function\") {\n          var et = tt({\n            state: U,\n            name: Z,\n            instance: X,\n            options: J\n          }), Q = function() {\n          };\n          z.push(et || Q);\n        }\n      });\n    }\n    function Y() {\n      z.forEach(function(q) {\n        return q();\n      }), z = [];\n    }\n    return X;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nconst { GamepadListener } = __webpack_require__(/*! gamepad.js */ \"../skynovel/node_modules/gamepad.js/gamepad.js\");\nvar tr, Zi, Fe, lu, hu, lf, cu, hf, fu, cf, va, ga, du, ff, Ce, yr, mi, yi, pu, Ki, Es, vu, gu, He, ma, ya, _u, Zh, Yd, mu, Zn, Kh, qd, yu, df, Jh, Zd, bu, pf, Kn, ja, Jn, Qh, Kd, tc, Jd, br, ec, Qd, rc, tp, ba, ll, bi, Qn, ts, ic, ep, qe;\nclass EventMng {\n  constructor(t, e, o, T, S, N, D, B, $) {\n    rt(this, hu);\n    rt(this, cu);\n    rt(this, fu);\n    rt(this, du);\n    rt(this, Ki);\n    rt(this, Zh);\n    rt(this, Kh);\n    rt(this, yu);\n    rt(this, Jh);\n    rt(this, bu);\n    rt(this, Kn);\n    rt(this, Qh);\n    rt(this, tc);\n    rt(this, ec);\n    rt(this, rc);\n    rt(this, ba);\n    rt(this, ic);\n    rt(this, tr, new EventListenerCtn());\n    rt(this, Zi, new GamepadListener({\n      analog: !1,\n      deadZone: 0.3\n    }));\n    rt(this, Fe, new FocusMng());\n    rt(this, lu, (t) => {\n    });\n    rt(this, va, !1);\n    rt(this, ga, !1);\n    rt(this, Ce, {});\n    rt(this, yr, {});\n    rt(this, mi, !1);\n    rt(this, yi, !1);\n    rt(this, pu, (t) => {\n      var e;\n      return (e = H(this, Ce)[t]) != null ? e : H(this, yr)[t];\n    });\n    rt(this, vu, () => {\n      nt(this, vu, () => {\n      }), this.scrItr.firstWait();\n    });\n    rt(this, gu, {\n      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n    });\n    rt(this, He, void 0);\n    rt(this, ma, void 0);\n    rt(this, ya, void 0);\n    rt(this, _u, {\n      placement: \"bottom\",\n      fallbackPlacements: [\"top\", \"bottom\"]\n    });\n    rt(this, mu, (t, e) => {\n    });\n    rt(this, Zn, new EventListenerCtn());\n    rt(this, Jn, () => this.layMng.goTxt());\n    rt(this, br, () => !1);\n    rt(this, bi, () => {\n    });\n    rt(this, Qn, new i$1());\n    rt(this, ts, \"sn:notice_comp_txt\");\n    rt(this, qe, {\n      Alt: 0,\n      Meta: 0,\n      Control: 0,\n      ArrowDown: 0,\n      End: 0,\n      Enter: 0,\n      Escape: 0,\n      \" \": 0,\n      GoBack: 0\n    });\n    var W, Y;\n    if (this.cfg = t, this.hTag = e, this.appPixi = o, this.main = T, this.layMng = S, this.val = N, this.sndMng = D, this.scrItr = B, this.sys = $, e.clear_event = (q) => ot(this, Kh, qd).call(this, q), e.event = (q) => ot(this, Jh, Zd).call(this, q), e.l = (q) => ot(this, Qh, Kd).call(this, q), e.p = (q) => ot(this, tc, Jd).call(this, q), e.s = () => (this.scrItr.recodePage(), ot(this, Ki, Es).call(this, () => {\n    }, !1, !0)), e.set_cancel_skip = () => ot(this, ec, Qd).call(this), e.set_focus = (q) => ot(this, rc, tp).call(this, q), e.wait = (q) => ot(this, ba, ll).call(this, q), e.waitclick = () => ot(this, ic, ep).call(this), D.setEvtMng(this), B.setOtherObj(this, S), TxtLayer.setEvtMng(T, this, $), S.setEvtMng(this), $.setFire((q, Z) => this.fire(q, Z)), CmnLib.isDbg) {\n      const q = {\n        pause: () => {\n          if (nt(this, mi, !0), !H(this, yi))\n            return;\n          const Z = {};\n          this.scrItr.recodeDesign(Z), this.sys.callHook(\"_enterDesign\", Z), this.sys.send2Dbg(\"_enterDesign\", Z);\n        },\n        stopOnBreakpoint: () => nt(this, mi, !0),\n        stopOnDataBreakpoint: () => nt(this, mi, !0),\n        continue: () => nt(this, mi, !1),\n        disconnect: () => nt(this, mi, !1)\n      };\n      q.attach = q.stopOnEntry = q.stopOnStep = q.stopOnStepIn = q.stopOnStepOut = q.stopOnBackstep = q.pause, $.addHook((Z) => {\n        var K;\n        return (K = q[Z]) == null ? void 0 : K.call(q);\n      });\n    }\n    addStyle(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`);\n    for (const q of Array.from(document.getElementsByClassName(\"sn_hint\")))\n      (W = q.parentElement) == null || W.removeChild(q);\n    (Y = o.view.parentElement) == null || Y.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), nt(this, He, document.querySelector(\".sn_hint\")), nt(this, ma, H(this, He).querySelector(\"span\")), nt(this, ya, createPopper(H(this, gu), H(this, He))), H(this, He).hidden = !0, o.stage.interactive = !0, CmnLib.isMobile ? o.stage.on(\"pointerdown\", (q) => this.fire(\"click\", q)) : H(this, tr).add(o.stage, \"pointerdown\", (q) => {\n      switch (q.data.button) {\n        case 0:\n          this.fire(\"click\", q);\n          break;\n        case 1:\n          this.fire(\"middleclick\", q);\n          break;\n      }\n    }), H(this, tr).add(window, \"keydown\", (q) => ot(this, hu, lf).call(this, q)), H(this, tr).add(o.view, \"contextmenu\", (q) => ot(this, cu, hf).call(this, q));\n    const U = (q) => {\n      CmnLib.isDarkMode = q.matches, N.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", CmnLib.isDarkMode);\n    }, z = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    U(z), H(this, tr).add(z, \"change\", (q) => {\n      U(q), this.fire(\"sn:chgDarkMode\", q);\n    }), \"WheelEvent\" in window && (H(this, tr).add(o.view, \"wheel\", (q) => ot(this, fu, cf).call(this, q), { passive: !0 }), nt(this, lu, (q) => H(this, tr).add(q, \"wheel\", (Z) => ot(this, fu, cf).call(this, Z), { passive: !0 })), nt(this, mu, (q, Z) => q.add(o.view, \"wheel\", (K) => {\n      K.isComposing || K.deltaY <= 0 || (K.stopPropagation(), Z());\n    }))), CmnLib.debugLog && (H(this, Zi).on(\"gamepad:connected\", (q) => console.log(`\\u{1F47A}<'gamepad:connected' index:${q.detail.index} id:${q.detail.gamepad.id}`)), H(this, Zi).on(\"gamepad:disconnected\", (q) => console.log(`\\u{1F47A}<'gamepad:disconnected' index:${q.detail.index} id:${q.detail.gamepad.id}`)));\n    const V = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      \"\",\n      \"ArrowDown\",\n      \"\"\n    ], X = [0, 0];\n    H(this, Zi).on(\"gamepad:axis\", (q) => {\n      if (!document.hasFocus() || q.detail.stick !== 0)\n        return;\n      X[q.detail.axis] = q.detail.value;\n      const Z = (X[1] + 1) * 3 + (X[0] + 1), K = V[Z];\n      if (!K)\n        return;\n      const J = H(this, Fe).getFocus();\n      (!J || J instanceof Container ? globalThis : J).dispatchEvent(new KeyboardEvent(\"keydown\", { key: K, bubbles: !0 })), !(!J || J instanceof Container) && J.getAttribute(\"type\") === \"range\" && J.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n    }), H(this, Zi).on(\"gamepad:button\", (q) => {\n      if (!(!document.hasFocus() || q.detail.value === 0))\n        if (q.detail.button % 2 === 0) {\n          const Z = H(this, Fe).getFocus();\n          (!Z || Z instanceof Container ? globalThis : Z).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n        } else\n          o.view.dispatchEvent(new Event(\"contextmenu\"));\n    }), H(this, Zi).start(), H(this, tr).add(window, \"keyup\", (q) => {\n      q.isComposing || q.key in H(this, qe) && (H(this, qe)[q.key] = 0);\n    }), N.defTmp(\"const.sn.key.alternate\", () => H(this, qe).Alt > 0), N.defTmp(\"const.sn.key.command\", () => H(this, qe).Meta > 0), N.defTmp(\"const.sn.key.control\", () => H(this, qe).Control > 0), N.defTmp(\"const.sn.key.end\", () => H(this, qe).End > 0), N.defTmp(\"const.sn.key.escape\", () => H(this, qe).Escape > 0), N.defTmp(\"const.sn.key.back\", () => H(this, qe).GoBack > 0);\n  }\n  resvFlameEvent(t) {\n    H(this, tr).add(t, \"keydown\", (e) => ot(this, hu, lf).call(this, e)), H(this, tr).add(t, \"contextmenu\", (e) => ot(this, cu, hf).call(this, e)), H(this, lu).call(this, t);\n  }\n  destroy() {\n    H(this, Fe).destroy(), H(this, tr).clear();\n  }\n  fire(t, e) {\n    var S;\n    if (H(this, br).call(this) || !H(this, yi) || H(this, mi))\n      return;\n    const o = t.toLowerCase();\n    if (CmnLib.debugLog && console.log(`\\u{1F47A} fire<(key:\\`${o}\\` type:${e.type} e:%o)`, { ...e }), o === \"enter\") {\n      const N = H(this, Fe).getFocus();\n      if (N instanceof Container) {\n        N.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const T = H(this, pu).call(this, o);\n    if (!T) {\n      o.slice(0, 5) === \"swipe\" && globalThis.scrollBy(\n        -e.deltaX,\n        -e.deltaY\n      );\n      return;\n    }\n    o.slice(-5) !== \"wheel\" && ((S = e.preventDefault) == null || S.call(e)), e.stopPropagation(), !(o.slice(0, 4) !== \"dom=\" && this.layMng.clickTxtLay()) && (nt(this, yi, !1), T(e), H(this, He).hidden = !0);\n  }\n  popLocalEvts() {\n    const t = H(this, Ce);\n    return nt(this, Ce, {}), t;\n  }\n  pushLocalEvts(t) {\n    nt(this, Ce, t);\n  }\n  waitEvent(t, e = !0, o = !1) {\n    if (e && o)\n      throw \"canskip\\u3068global\\u3092\\u540C\\u6642\\u306Btrue\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\";\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku)\n        return t(), !1;\n      H(this, br).call(this);\n    }\n    return ot(this, Ki, Es).call(this, t, e, o);\n  }\n  unButton(t) {\n    H(this, Fe).remove(t);\n  }\n  button(t, e, o, T, S) {\n    var z, V;\n    !t.fn && !t.label && this.main.errScript(\"fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\"), e.interactive = e.buttonMode = !0;\n    const N = (V = (z = t.key) == null ? void 0 : z.toLowerCase()) != null ? V : \" \";\n    t.fn || (t.fn = this.scrItr.scriptFn);\n    const D = argChk_Boolean(t, \"global\", !1);\n    D ? H(this, yr)[N] = () => this.main.resumeByJumpOrCall(t) : H(this, Ce)[N] = () => this.main.resumeByJumpOrCall(t), e.on(\"pointerdown\", (X) => this.fire(N, X));\n    const B = t.hint ? () => ot(this, Zh, Yd).call(this, t, e) : () => {\n    }, $ = () => {\n      o(), H(this, He).hidden = !0;\n    }, U = () => (B(), T());\n    if (e.on(\"pointerover\", U), e.on(\"pointerout\", () => {\n      H(this, Fe).isFocus(e) ? U() : $();\n    }), e.on(\"pointerdown\", () => {\n      H(this, He).hidden = !0;\n      const X = H(this, Fe).getFocus();\n      S(), X instanceof Button && X.normal();\n    }), e.on(\n      \"pointerup\",\n      CmnLib.isMobile ? $ : () => {\n        H(this, Fe).isFocus(e) ? U() : $();\n      }\n    ), H(this, Fe).add(e, U, $), t.clickse && (this.cfg.searchPath(t.clickse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerdown\", () => {\n      const X = { fn: t.clickse, join: !1 };\n      t.clicksebuf && (X.buf = t.clicksebuf), this.hTag.playse(X);\n    })), t.enterse && (this.cfg.searchPath(t.enterse, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerover\", () => {\n      const X = { fn: t.enterse, join: !1 };\n      t.entersebuf && (X.buf = t.entersebuf), this.hTag.playse(X);\n    })), t.leavese && (this.cfg.searchPath(t.leavese, SEARCH_PATH_ARG_EXT.SOUND), e.on(\"pointerout\", () => {\n      const X = { fn: t.leavese, join: !1 };\n      t.leavesebuf && (X.buf = t.leavesebuf), this.hTag.playse(X);\n    })), t.onenter) {\n      const X = N + t.onenter.toLowerCase(), W = { fn: t.fn, label: t.onenter, call: !0, key: X };\n      D ? H(this, yr)[X] = () => this.main.resumeByJumpOrCall(W) : H(this, Ce)[X] = () => this.main.resumeByJumpOrCall(W), e.on(\"pointerover\", (Y) => this.fire(X, Y));\n    }\n    if (t.onleave) {\n      const X = N + t.onleave.toLowerCase(), W = { fn: t.fn, label: t.onleave, call: !0, key: X };\n      D ? H(this, yr)[X] = () => this.main.resumeByJumpOrCall(W) : H(this, Ce)[X] = () => this.main.resumeByJumpOrCall(W), e.on(\"pointerout\", (Y) => this.fire(X, Y));\n    }\n    this.sndMng.loadAheadSnd(t);\n  }\n  cvsResize() {\n    H(this, He).hidden = !0;\n  }\n  waitLimitedEvent(t, e) {\n    H(this, Jn).call(this), this.val.saveKidoku();\n    const o = () => {\n      H(this, Zn).clear(), e();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n        H(this, br).call(this);\n      else\n        return o(), !1;\n    return argChk_Boolean(t, \"canskip\", !0) && (H(this, Zn).add(window, \"pointerdown\", (T) => {\n      T.stopPropagation(), o();\n    }), H(this, Zn).add(window, \"keydown\", (T) => {\n      T.isComposing || (T.stopPropagation(), o());\n    }), H(this, mu).call(this, H(this, Zn), o)), !0;\n  }\n  noticeCompTxt() {\n    H(this, Qn).emit(H(this, ts));\n  }\n  isSkippingByKeyDown() {\n    return this.scrItr.skip4page ? !0 : Object.keys(H(this, qe)).some((t) => H(this, qe)[t] === 2);\n  }\n}\ntr = new WeakMap(), Zi = new WeakMap(), Fe = new WeakMap(), lu = new WeakMap(), hu = new WeakSet(), lf = function(t) {\n  if (t.isComposing)\n    return;\n  t.key in H(this, qe) && (H(this, qe)[t.key] = t.repeat ? 2 : 1);\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + t.key;\n  this.fire(e, t);\n}, cu = new WeakSet(), hf = function(t) {\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(e, t), t.preventDefault();\n}, fu = new WeakSet(), cf = function(t) {\n  if (t.isComposing)\n    return;\n  if (H(this, va)) {\n    nt(this, ga, !0);\n    return;\n  }\n  nt(this, va, !0), ot(this, du, ff).call(this);\n  const e = (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\") + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(e, t);\n}, va = new WeakMap(), ga = new WeakMap(), du = new WeakSet(), ff = function() {\n  setTimeout(() => {\n    if (H(this, ga)) {\n      nt(this, ga, !1), ot(this, du, ff).call(this);\n      return;\n    }\n    nt(this, va, !1);\n  }, 250);\n}, Ce = new WeakMap(), yr = new WeakMap(), mi = new WeakMap(), yi = new WeakMap(), pu = new WeakMap(), Ki = new WeakSet(), Es = function(t, e = !0, o = !0) {\n  if (H(this, Jn).call(this), this.val.saveKidoku(), e ? H(this, Ce).click = H(this, Ce).enter = H(this, Ce).arrowdown = H(this, Ce)[\"wheel.y>0\"] = t : (delete H(this, Ce).click, delete H(this, Ce).enter, delete H(this, Ce).arrowdown, delete H(this, Ce)[\"wheel.y>0\"]), nt(this, pu, o ? (T) => {\n    var S;\n    return (S = H(this, Ce)[T]) != null ? S : H(this, yr)[T];\n  } : (T) => H(this, Ce)[T]), nt(this, yi, !0), H(this, vu).call(this), CmnLib.debugLog) {\n    const T = /* @__PURE__ */ Object.create(null);\n    T.local = Object.keys(H(this, Ce)), T.global = Object.keys(H(this, yr)), console.log(\"\\u{1F38D} wait event... %o\", T);\n  }\n  return !0;\n}, vu = new WeakMap(), gu = new WeakMap(), He = new WeakMap(), ma = new WeakMap(), ya = new WeakMap(), _u = new WeakMap(), Zh = new WeakSet(), Yd = function(t, e) {\n  var S, N;\n  const o = e instanceof Button ? e.getBtnBounds() : e.getBounds();\n  if (!(t[\":\\u30BF\\u30B0\\u540D\"] === \"link\")) {\n    const D = e.parent.parent;\n    o.x += D.x, o.y += D.y;\n  }\n  if (!t.hint) {\n    H(this, He).hidden = !0;\n    return;\n  }\n  H(this, He).style.cssText = `position:${H(this, He).style.position}; transform:${H(this, He).style.transform};` + ((S = t.hint_style) != null ? S : \"\"), H(this, ma).style.cssText = \"\", H(this, ma).textContent = (N = t.hint) != null ? N : \"\";\n  try {\n    const D = t.hint_opt ? { ...H(this, _u), ...JSON.parse(t.hint_opt) } : H(this, _u);\n    H(this, ya).setOptions(D);\n  } catch (D) {\n    console.error(mesErrJSON(t, \"hint_opt\", D.message));\n  }\n  H(this, gu).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + o.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + o.y * this.sys.cvsScale,\n    width: o.width,\n    height: o.height\n  }), H(this, ya).update(), H(this, He).hidden = !1;\n}, mu = new WeakMap(), Zn = new WeakMap(), Kh = new WeakSet(), qd = function(t) {\n  const e = argChk_Boolean(t, \"global\", !1), o = e ? H(this, yr) : H(this, Ce);\n  for (const [T, S] of Object.entries(o))\n    ot(this, yu, df).call(this, T, S);\n  return e ? nt(this, yr, {}) : nt(this, Ce, {}), nt(this, yi, !1), !1;\n}, yu = new WeakSet(), df = function(t, e) {\n  t.slice(0, 4) === \"dom=\" && ot(this, Kn, ja).call(this, t).el.forEach((o) => o.removeEventListener(\"click\", e));\n}, Jh = new WeakSet(), Zd = function(t) {\n  var N, D;\n  const e = t.key;\n  if (!e)\n    throw \"key\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = e.toLowerCase(), T = argChk_Boolean(t, \"call\", !1), S = argChk_Boolean(t, \"global\", !1) ? H(this, yr) : H(this, Ce);\n  if (argChk_Boolean(t, \"del\", !1)) {\n    if (t.fn || t.label || T)\n      throw \"fn/label/call\\u3068del\\u306F\\u540C\\u6642\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\";\n    return ot(this, yu, df).call(this, e, S[o]), delete S[o], !1;\n  }\n  if ((N = t.fn) != null || (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === \"dom=\") {\n    const B = ot(this, Kn, ja).call(this, e);\n    if (B.el.length === 0) {\n      if (argChk_Boolean(t, \"need_err\", !0))\n        throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${B.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n      return !1;\n    }\n    let $ = [\"click\", \"keydown\"];\n    switch ((D = B.el[0].type) != null ? D : \"\") {\n      case \"checkbox\":\n        $ = [\"input\"];\n        break;\n      case \"range\":\n        $ = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        $ = [\"input\", \"change\"];\n        break;\n    }\n    $.forEach((z, V) => B.el.forEach((X) => {\n      H(this, tr).add(X, z, (W) => {\n        if (!H(this, yi) || this.layMng.getFrmDisabled(B.id) || z === \"keydown\" && W.key !== \"Enter\")\n          return;\n        const Y = X.dataset;\n        for (const [q, Z] of Object.entries(Y))\n          this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${q}`, Z);\n        this.fire(e, W);\n      }), V === 0 && H(this, Fe).add(\n        X,\n        () => ot(this, bu, pf).call(this, X) ? (X.focus(), !0) : !1,\n        () => {\n        }\n      );\n    }));\n  }\n  return S[o] = () => this.main.resumeByJumpOrCall(t), !1;\n}, bu = new WeakSet(), pf = function(t) {\n  if (t.offsetParent === null)\n    return !1;\n  let e = t;\n  do {\n    if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || (e == null ? void 0 : e.disabled))\n      return !1;\n    e = e.parentElement;\n  } while (e !== null);\n  return !0;\n}, Kn = new WeakSet(), ja = function(t) {\n  const e = t.indexOf(\":\");\n  let o = \"\";\n  if (e >= 0) {\n    const T = t.slice(4, e), S = `const.sn.frm.${T}`;\n    if (!this.val.getVal(`tmp:${S}`, 0))\n      throw `HTML\\u3010${T}\\u3011\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093`;\n    const D = document.getElementById(T).contentWindow;\n    return o = t.slice(e + 1), { el: D.document.querySelectorAll(o), id: T, sel: o };\n  }\n  return o = t.slice(4), { el: document.querySelectorAll(o), id: \"\", sel: o };\n}, Jn = new WeakMap(), Qh = new WeakSet(), Kd = function(t) {\n  if (this.scrItr.skip4page)\n    return !1;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\"))\n    return H(this, Jn).call(this), !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      H(this, br).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return !1;\n  }\n  return this.val.getVal(\"tmp:sn.auto.enabled\") ? ot(this, ba, ll).call(this, {\n    time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n  }) : (argChk_Boolean(t, \"visible\", !0) && this.layMng.breakLine(), ot(this, Ki, Es).call(this, () => this.main.resume()));\n}, tc = new WeakSet(), Jd = function(t) {\n  if (this.scrItr.recodePage(), this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku)\n      H(this, br).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\")\n      return H(this, Jn).call(this), !1;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return ot(this, ba, ll).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  argChk_Boolean(t, \"visible\", !0) && this.layMng.breakPage();\n  const e = () => {\n    this.sndMng.clearCache(), this.main.resume();\n  };\n  return ot(this, Ki, Es).call(this, argChk_Boolean(t, \"er\", !1) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(t), e();\n  } : e);\n}, br = new WeakMap(), ec = new WeakSet(), Qd = function() {\n  return nt(this, br, () => (nt(this, br, () => !1), this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", !0), this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", !1), this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", !1), this.layMng.setNormalChWait(), H(this, bi).call(this), !0)), !1;\n}, rc = new WeakSet(), tp = function(t) {\n  const { add: e, del: o, to: T } = t;\n  if ((e == null ? void 0 : e.slice(0, 4)) === \"dom=\") {\n    const S = ot(this, Kn, ja).call(this, e);\n    if (S.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${S.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    return S.el.forEach((N) => H(this, Fe).add(\n      N,\n      () => ot(this, bu, pf).call(this, N) ? (N.focus(), !0) : !1,\n      () => {\n      }\n    )), !1;\n  }\n  if ((o == null ? void 0 : o.slice(0, 4)) === \"dom=\") {\n    const S = ot(this, Kn, ja).call(this, o);\n    if (S.el.length === 0 && argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u30BB\\u30EC\\u30AF\\u30BF\\uFF08${S.sel}\\uFF09\\u306B\\u5BFE\\u5FDC\\u3059\\u308B\\u8981\\u7D20\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093\\u3002\\u5B58\\u5728\\u3057\\u306A\\u3044\\u5834\\u5408\\u3092\\u8A31\\u5BB9\\u3059\\u308B\\u306A\\u3089\\u3001need_err=false \\u3068\\u6307\\u5B9A\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044`;\n    return S.el.forEach((N) => H(this, Fe).remove(N)), !1;\n  }\n  if (!T)\n    throw \"[set_focus] add \\u304B to \\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  switch (T) {\n    case \"null\":\n      H(this, Fe).blur();\n      break;\n    case \"next\":\n      H(this, Fe).next();\n      break;\n    case \"prev\":\n      H(this, Fe).prev();\n      break;\n  }\n  return !1;\n}, ba = new WeakSet(), ll = function(t) {\n  const e = argChk_Num(t, \"time\", NaN);\n  return this.scrItr.skip4page ? !1 : this.val.getVal(\"tmp:sn.skip.enabled\") ? (!this.val.getVal(\"tmp:sn.skip.all\") && !this.scrItr.isNextKidoku && H(this, br).call(this), !1) : (H(this, Qn).once(H(this, ts), () => {\n    H(this, Qn).off(H(this, ts));\n    const o = new Tween({}).to({}, e).onComplete(() => {\n      nt(this, bi, () => {\n      }), o.stop(), this.main.resume();\n    }).start();\n    nt(this, bi, () => o.end());\n  }), nt(this, bi, () => {\n    nt(this, bi, () => {\n    }), H(this, Qn).off(H(this, ts));\n  }), this.waitEvent(\n    () => H(this, bi).call(this),\n    argChk_Boolean(t, \"canskip\", !0),\n    argChk_Boolean(t, \"global\", !1)\n  ));\n}, bi = new WeakMap(), Qn = new WeakMap(), ts = new WeakMap(), ic = new WeakSet(), ep = function() {\n  return this.scrItr.skip4page ? !1 : ((this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\")) && H(this, br).call(this), ot(this, Ki, Es).call(this, () => this.main.resume()));\n}, qe = new WeakMap();\nclass CallStack {\n  constructor(t = \"\", e = 0, o = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    Pt(this, \"toString\", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);\n    this.fn = t, this.idx = e, this.csArg = o;\n  }\n}\nvar Qt, ae, Vt, me, ge, Ji, Eu, vf, es, Ea, nc, Qi, xu, gf, Tu, _f, Su, tn, xs, rs, za, is, Ei, Re, sc, rp, ns, Va, ac, ip, Cu, xa, fr, oc, np, uc, sp, xi, nn, lc, ap, ss, as, Ru, Iu, wu, dr, hc, op, cc, up, fc, lp, Pu, mf, dc, hp, pc, cp, vc, fp, Au, yf, Ou, os, Xa, us, Ti, sn, Nu, bf, Mu, Du, Ef, gc, mc, Lu, ls, Fu, yc, dp, er, bc, pp, Bu, xf, Ec, xc, Tc, Sc, vp, Si, ku, Tf, Cc, gp, Rc, _p, Ic, wc, mp, $u, Ta, Pc, yp, Sa, hl, Ca, Ac, bp, Dr, Oc, Ep, Ra, cl, Nc, xp, Lr, Ue;\nconst ar = class {\n  constructor(t, e, o, T, S, N, D, B, $) {\n    rt(this, Eu);\n    rt(this, xu);\n    rt(this, Tu);\n    rt(this, tn);\n    rt(this, rs);\n    rt(this, sc);\n    rt(this, ns);\n    rt(this, ac);\n    rt(this, oc);\n    rt(this, uc);\n    rt(this, xi);\n    rt(this, lc);\n    rt(this, hc);\n    rt(this, cc);\n    rt(this, fc);\n    rt(this, Pu);\n    rt(this, dc);\n    rt(this, pc);\n    rt(this, vc);\n    rt(this, Au);\n    rt(this, os);\n    rt(this, Ti);\n    rt(this, Nu);\n    rt(this, Du);\n    rt(this, yc);\n    rt(this, bc);\n    rt(this, Bu);\n    rt(this, Sc);\n    rt(this, ku);\n    rt(this, Cc);\n    rt(this, Rc);\n    rt(this, wc);\n    rt(this, Pc);\n    rt(this, Sa);\n    rt(this, Ac);\n    rt(this, Oc);\n    rt(this, Ra);\n    rt(this, Nc);\n    rt(this, Qt, { aToken: [\"\"], len: 1, aLNum: [1] });\n    rt(this, ae, \"\");\n    rt(this, Vt, 0);\n    rt(this, me, 0);\n    Pt(this, \"addLineNum\", (t) => nt(this, me, H(this, me) + t));\n    rt(this, ge, []);\n    rt(this, Ji, new Grammar());\n    Pt(this, \"firstWait\", () => {\n    });\n    rt(this, es, {\n      disconnect: () => {\n        nt(ar, is, {}), nt(ar, Ei, {}), this.isBreak = () => !1, H(this, es).continue({}), nt(this, Re, 0);\n      },\n      restart: () => this.isBreak = () => !1,\n      add_break: (t) => ot(this, Eu, vf).call(this, t.fn, t.o),\n      data_break: (t) => {\n        H(this, Re) === 0 && (nt(this, Re, 1), this.main.setLoop(!1, `\\u5909\\u6570 ${t.dataId}\\u3010${t.old_v}\\u3011\\u2192\\u3010${t.new_v}\\u3011\\u30C7\\u30FC\\u30BF\\u30D6\\u30EC\\u30FC\\u30AF`), this.sys.callHook(\"stopOnDataBreakpoint\", {}), this.sys.send2Dbg(\"stopOnDataBreakpoint\", {}));\n      },\n      set_func_break: (t) => {\n        nt(ar, Ei, {});\n        for (const e of t.a)\n          H(ar, Ei)[e.name] = 1;\n        this.sys.send2Dbg(t.ri, {});\n      },\n      stack: (t) => this.sys.send2Dbg(t.ri, { a: ot(this, ac, ip).call(this) }),\n      eval: (t) => {\n        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });\n      },\n      continue: () => {\n        ot(this, rs, za).call(this) || (nt(this, Vt, H(this, Vt) - H(this, tn, xs)), nt(this, Re, 3), this.main.setLoop(!0), this.main.resume());\n      },\n      stepover: (t) => ot(this, xu, gf).call(this, t),\n      stepin: () => {\n        if (ot(this, rs, za).call(this))\n          return;\n        const t = H(this, Qt).aToken[H(this, Vt) - H(this, tn, xs)];\n        this.sys.callHook(`stopOnStep${H(this, Ta).test(t) ? \"In\" : \"\"}`, {}), nt(this, Vt, H(this, Vt) - H(this, tn, xs)), nt(this, Re, H(this, Re) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();\n      },\n      stepout: (t) => {\n        ot(this, rs, za).call(this) || (H(this, ge).length > 0 ? ot(this, Tu, _f).call(this, !0) : ot(this, xu, gf).call(this, t));\n      },\n      pause: () => {\n        nt(this, Re, 4), this.main.setLoop(!1, \"\\u4E00\\u6642\\u505C\\u6B62\"), this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        nt(this, Re, 4), this.main.setLoop(!1, \"\\u4E00\\u6642\\u505C\\u6B62\"), this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    });\n    rt(this, Ea, (t) => this.cfg.searchPath(t, SEARCH_PATH_ARG_EXT.SCRIPT));\n    rt(this, Qi, (t) => (this.sys.pathBaseCnvSnPath4Dbg + H(this, Ea).call(this, t)).replace(H(ar, nc), `$1/prj/$2/${H(this, ae)}$3`));\n    Pt(this, \"cnvPath4Dbg\", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace(\"/crypto_prj/\", \"/prj/\"));\n    rt(this, Su, 0);\n    rt(this, Re, 0);\n    Pt(this, \"isBreak\", (t) => !1);\n    rt(this, Cu, (t) => {\n    });\n    rt(this, xa, void 0);\n    rt(this, fr, void 0);\n    rt(this, ss, () => {\n    });\n    rt(this, as, () => {\n    });\n    rt(this, Ru, \"\");\n    rt(this, Iu, {});\n    Pt(this, \"noticeBreak\", (t) => {\n    });\n    rt(this, wu, 5);\n    rt(this, dr, [-1]);\n    rt(this, Ou, \"\");\n    rt(this, us, \"\");\n    Pt(this, \"nextToken\", () => \"\");\n    rt(this, Mu, (t) => {\n    });\n    rt(this, gc, /(\\*{2,})([^\\|]*)/);\n    rt(this, mc, /\\[macro\\s/);\n    rt(this, Lu, /\\[endmacro[\\s\\]]/);\n    rt(this, ls, /^\\[let_ml\\s/g);\n    rt(this, Fu, /^\\[endlet_ml\\s*]/g);\n    rt(this, er, /* @__PURE__ */ Object.create(null));\n    rt(this, Ec, /^\\[(call|loadplugin)\\s/);\n    rt(this, xc, /\\bfn\\s*=\\s*[^\\s\\]]+/);\n    rt(this, Tc, () => {\n      for (let t = H(this, Qt).len - 1; t >= 0; --t) {\n        const e = H(this, Qt).aToken[t];\n        if (!H(this, Ec).test(e))\n          continue;\n        const [o, T] = tagToken2Name_Args(e);\n        this.alzTagArg.go(T);\n        const S = this.alzTagArg.hPrm.fn;\n        if (!S)\n          continue;\n        const { val: N } = S;\n        if (!N || N.slice(-1) !== \"*\")\n          continue;\n        H(this, Qt).aToken.splice(t, 1, \"\t\", \"; \" + e), H(this, Qt).aLNum.splice(t, 1, NaN, NaN);\n        const D = o === \"loadplugin\" ? SEARCH_PATH_ARG_EXT.CSS : SEARCH_PATH_ARG_EXT.SN, B = this.cfg.matchPath(\"^\" + N.slice(0, -1) + \".*\", D);\n        for (const $ of B) {\n          const U = e.replace(\n            H(this, xc),\n            \"fn=\" + decodeURIComponent(getFn($[D]))\n          );\n          H(this, Qt).aToken.splice(t, 0, U), H(this, Qt).aLNum.splice(t, 0, NaN);\n        }\n      }\n      H(this, Qt).len = H(this, Qt).aToken.length;\n    });\n    rt(this, Si, !1);\n    rt(this, Ic, new RegExp(`[\"'#;\\\\]\\u3000]+`));\n    rt(this, $u, \"call\");\n    rt(this, Ta, /\\[(call)\\b/);\n    rt(this, Ca, !1);\n    rt(this, Dr, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    });\n    rt(this, Lr, []);\n    rt(this, Ue, -1);\n    if (this.cfg = t, this.hTag = e, this.main = o, this.val = T, this.alzTagArg = S, this.runAnalyze = N, this.prpPrs = D, this.sndMng = B, this.sys = $, e.let_ml = (U) => ot(this, oc, np).call(this, U), e.dump_stack = () => ot(this, uc, sp).call(this), e.dump_script = (U) => ot(this, lc, ap).call(this, U), e.else = e.elsif = e.endif = () => ot(this, hc, op).call(this), e.if = (U) => ot(this, cc, up).call(this, U), e.call = (U) => ot(this, fc, lp).call(this, U), e.jump = (U) => ot(this, dc, hp).call(this, U), e.page = (U) => ot(this, pc, cp).call(this, U), e.pop_stack = (U) => ot(this, vc, fp).call(this, U), e.return = (U) => ot(this, Au, yf).call(this, U), e.bracket2macro = (U) => ot(this, Cc, gp).call(this, U), e.char2macro = (U) => ot(this, Rc, _p).call(this, U), e.endmacro = (U) => ot(this, Au, yf).call(this, U), e.macro = (U) => ot(this, wc, mp).call(this, U), e.load = (U) => ot(this, Pc, yp).call(this, U), e.reload_script = (U) => ot(this, Ac, bp).call(this, U), e.record_place = () => ot(this, Oc, Ep).call(this), e.save = (U) => ot(this, Nc, xp).call(this, U), t.oCfg.debug.token && nt(this, Mu, (U) => console.log(`\\u{1F331} \\u30C8\\u30FC\\u30AF\\u30F3 fn:${H(this, ae)} idx:${H(this, Vt)} ln:${H(this, me)} token\\u3010${U}\\u3011`)), T.defTmp(\"const.sn.vctCallStk.length\", () => H(this, ge).length), H(this, Ji).setEscape(t.oCfg.init.escape), CmnLib.isDbg) {\n      $.addHook((z, V) => {\n        var X, W;\n        return (W = (X = H(this, es))[z]) == null ? void 0 : W.call(X, V);\n      }), this.isBreak = ot(this, sc, rp);\n      const U = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        }, this.sys.send2Dbg(\"hi\", {});\n      }, H(this, es).auth = (z) => {\n        const V = z.hBreakpoint.hFn2hLineBP;\n        for (const [X, W] of Object.entries(V))\n          ot(this, Eu, vf).call(this, X, W);\n        nt(ar, Ei, {});\n        for (const X of z.hBreakpoint.aFunc)\n          H(ar, Ei)[X.name] = 1;\n        if (z.stopOnEntry) {\n          for (; ; ) {\n            let X = this.nextToken();\n            if (!X)\n              break;\n            const W = X.charCodeAt(0);\n            if (W === 91 || W === 38 || W === 42 && X.length === 1)\n              break;\n            W === 10 && nt(this, me, H(this, me) + X.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {}), this.analyzeInit = U, this.analyzeInit();\n        } else\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          }, this.analyzeInit = U, this.analyzeInit();\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    t.oCfg.debug.tag && nt(this, Cu, (U) => console.log(`\\u{1F332} \\u30BF\\u30B0\\u89E3\\u6790 fn:${H(this, ae)} idx:${H(this, Vt)} ln:${H(this, me)} [${U} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return H(this, ae);\n  }\n  subIdxToken() {\n    --Pe(this, Vt)._;\n  }\n  get lineNum() {\n    return H(this, me);\n  }\n  destroy() {\n    this.isBreak = () => !1;\n  }\n  \\u30BF\\u30B0\\u89E3\\u6790(t) {\n    const [e, o] = tagToken2Name_Args(t), T = this.hTag[e];\n    if (!T)\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0\\u3010${e}\\u3011\\u3067\\u3059`;\n    this.alzTagArg.go(o), H(this, Cu).call(this, e);\n    const S = this.alzTagArg.hPrm;\n    if (S.cond) {\n      const B = S.cond.val;\n      if (!B || B.charAt(0) === \"&\")\n        throw \"\\u5C5E\\u6027cond\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n      const $ = this.prpPrs.parse(B), U = String($);\n      if (U === \"null\" || U === \"undefined\" || !$)\n        return !1;\n    }\n    let N = {};\n    const D = H(this, ge).length;\n    if (this.alzTagArg.isKomeParam) {\n      if (D === 0)\n        throw \"\\u5C5E\\u6027\\u300C*\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u306E\\u307F\\u6709\\u52B9\\u3067\\u3059\";\n      N = { ...H(this, ge)[H(this, ge).length - 1].csArg };\n    }\n    N[\":\\u30BF\\u30B0\\u540D\"] = e;\n    for (const [B, { val: $, def: U }] of Object.entries(S)) {\n      let z = $;\n      if ((z == null ? void 0 : z.charAt(0)) === \"%\") {\n        if (D === 0)\n          throw \"\\u5C5E\\u6027\\u300C%\\u300D\\u306F\\u30DE\\u30AF\\u30ED\\u5B9A\\u7FA9\\u5185\\u3067\\u306E\\u307F\\u4F7F\\u7528\\u3067\\u304D\\u307E\\u3059\\uFF08\\u305D\\u306E\\u30DE\\u30AF\\u30ED\\u306E\\u5F15\\u6570\\u3092\\u793A\\u3059\\u7C21\\u7565\\u6587\\u6CD5\\u3067\\u3042\\u308B\\u305F\\u3081\\uFF09\";\n        const V = H(this, ge)[H(this, ge).length - 1].csArg[z.slice(1)];\n        if (V) {\n          N[B] = V;\n          continue;\n        }\n        if (U === void 0 || U === \"null\")\n          continue;\n        z = U;\n      }\n      if (z = this.prpPrs.getValAmpersand(z != null ? z : \"\"), z !== \"undefined\") {\n        N[B] = z;\n        continue;\n      }\n      U !== void 0 && (z = this.prpPrs.getValAmpersand(U), z !== \"undefined\" && (N[B] = z));\n    }\n    return T(N);\n  }\n  setOtherObj(t, e) {\n    nt(this, xa, t), nt(this, fr, e);\n  }\n  dumpErrForeLine() {\n    var N;\n    if (H(this, Vt) === 0) {\n      console.group(`\\u{1F95F} Error line (from 0 rows before) fn:${H(this, ae)}`), console.groupEnd();\n      return;\n    }\n    let t = \"\";\n    for (let D = H(this, Vt) - 1; D >= 0 && (t = H(this, Qt).aToken[D] + t, !(((N = t.match(/\\n/g)) != null ? N : []).length >= H(this, wu))); --D)\n      ;\n    const e = t.split(`\n`).slice(-H(this, wu)), o = e.length;\n    console.group(`\\u{1F95F} Error line (from ${o} rows before) fn:${H(this, ae)}`);\n    const T = String(H(this, me)).length, S = ot(this, xi, nn).call(this, H(this, Qt), H(this, Vt));\n    for (let D = 0; D < o; ++D) {\n      const B = H(this, me) - o + D + 1, $ = `${String(B).padStart(T, \" \")}: %c`, U = e[D], z = U.length > 75 ? U.slice(0, 75) + \"\\u2026\" : U;\n      D === o - 1 ? console.info(\n        $ + z.slice(0, S.col_s) + \"%c\" + z.slice(S.col_s),\n        \"color: black; background-color: skyblue;\",\n        \"color: black; background-color: pink;\"\n      ) : console.info($ + z, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const t = ot(this, yc, dp).call(this, H(this, Qt), Boolean(this.val.getVal(\"mp:const.sn.macro.name\")), H(this, me), H(this, us), H(this, Vt));\n    nt(this, Vt, t.idx), nt(this, me, t.ln), this.runAnalyze();\n  }\n  get isKidoku() {\n    return H(this, Si);\n  }\n  get isNextKidoku() {\n    let t = H(this, ae), e = H(this, Vt), o = H(this, Qt).len;\n    if (H(this, ge).length > 0) {\n      const S = H(this, ge)[0];\n      t = S.fn, e = S.idx;\n      const N = H(this, er)[t];\n      N && (o = N.len);\n    }\n    const T = this.val.getAreaKidoku(t);\n    return !T || e === o ? !1 : T.search(e);\n  }\n  get normalWait() {\n    return H(this, Si) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? uint(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return H(this, Ca);\n  }\n  recodePage() {\n    if (nt(this, Ca, !1), !this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: t, idx: e } = ot(this, Ra, cl).call(this), o = e - 1, T = o + \":\" + t, S = H(this, Lr).findIndex((D) => D.key === T);\n    if (S > -1) {\n      nt(this, Ue, S);\n      return;\n    }\n    const N = {\n      key: T,\n      fn: t,\n      idx: o,\n      retFn: t,\n      retIdx: 0,\n      retMark: { ...H(this, Dr) }\n    };\n    if (H(this, Ue) >= 0) {\n      const D = H(this, Lr)[H(this, Ue)];\n      N.retFn = D.fn, N.retIdx = D.idx + 1;\n    }\n    ++Pe(this, Ue)._ === H(this, Lr).length ? H(this, Lr).push(N) : H(this, Lr)[H(this, Ue)] = N;\n  }\n  recodeDesign(t) {\n    let e = \"\", o = 0;\n    const T = H(this, ge).length;\n    if (t.design_unit && T > 0) {\n      const D = H(this, ge)[0];\n      e = D.fn, o = D.idx;\n    } else\n      e = H(this, ae), o = H(this, Vt);\n    t[\":path\"] = H(this, Qi).call(this, e);\n    const S = ot(this, xi, nn).call(this, H(this, er)[e], o);\n    t[\":ln\"] = S.ln, t[\":col_s\"] = S.col_s, t[\":col_e\"] = S.col_e;\n    const N = o - 1;\n    t[\":idx_tkn\"] = N, t[\":token\"] = H(this, er)[e].aToken[N], this.sys.send2Dbg(\"_recodeDesign\", t);\n  }\n  replace(t, e) {\n    H(this, Qt).aToken[t] = e;\n  }\n};\nlet ScriptIterator = ar;\nQt = new WeakMap(), ae = new WeakMap(), Vt = new WeakMap(), me = new WeakMap(), ge = new WeakMap(), Ji = new WeakMap(), Eu = new WeakSet(), vf = function(t, e) {\n  H(ar, is)[H(this, Qi).call(this, t)] = e;\n}, es = new WeakMap(), Ea = new WeakMap(), nc = new WeakMap(), Qi = new WeakMap(), xu = new WeakSet(), gf = function(t) {\n  if (ot(this, rs, za).call(this))\n    return;\n  const e = H(this, Qt).aToken[H(this, Vt) - H(this, tn, xs)];\n  H(this, Ta).test(e) ? ot(this, Tu, _f).call(this, !1) : (this.sys.callHook(\"stopOnStep\", {}), H(this, es).stepin(t));\n}, Tu = new WeakSet(), _f = function(t) {\n  this.sys.callHook(`stopOnStep${t ? \"Out\" : \"\"}`, {}), nt(this, Su, H(this, ge).length - (t ? 1 : 0)), nt(this, Vt, H(this, Vt) - H(this, tn, xs)), nt(this, Re, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();\n}, Su = new WeakMap(), tn = new WeakSet(), xs = function() {\n  return H(this, Re) === 2 || H(this, Re) === 4 ? 1 : 0;\n}, rs = new WeakSet(), za = function() {\n  return H(this, Vt) < H(this, Qt).len ? !1 : (this.sys.callHook(\"stopOnEntry\", {}), this.main.setLoop(!1, \"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\"), !0);\n}, is = new WeakMap(), Ei = new WeakMap(), Re = new WeakMap(), sc = new WeakSet(), rp = function(t) {\n  switch (H(this, Re)) {\n    case 6:\n      ot(this, ns, Va).call(this), nt(this, Re, 7);\n      break;\n    case 7:\n      if (H(this, ge).length !== H(this, Su))\n        break;\n      return nt(this, Re, 4), this.main.setLoop(!1, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 5:\n      ot(this, ns, Va).call(this), nt(this, Re, 4);\n      break;\n    case 4:\n      return ot(this, ns, Va).call(this), this.main.setLoop(!1, \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 3:\n      ot(this, ns, Va).call(this), nt(this, Re, 0);\n      break;\n    default:\n      if (tagToken2Name(t) in H(ar, Ei))\n        return nt(this, Re, 2), this.main.setLoop(!1, `\\u95A2\\u6570 ${t} \\u30D6\\u30EC\\u30FC\\u30AF`), this.sys.callHook(\"stopOnBreakpoint\", {}), this.sys.send2Dbg(\"stopOnBreakpoint\", {}), !0;\n      {\n        const e = H(ar, is)[H(this, Qi).call(this, H(this, ae))];\n        if (!e)\n          break;\n        const o = e[H(this, me)];\n        if (!o)\n          break;\n        if (o.condition) {\n          if (!this.prpPrs.parse(o.condition))\n            break;\n        } else if (\"hitCondition\" in o && --o.hitCondition > 0)\n          break;\n        const T = H(this, Re) === 0;\n        nt(this, Re, 2), this.main.setLoop(!1, T ? (o.condition ? \"\\u6761\\u4EF6\" : \"\\u30D2\\u30C3\\u30C8\\u30AB\\u30A6\\u30F3\\u30C8\") + \"\\u30D6\\u30EC\\u30FC\\u30AF\" : \"\\u30B9\\u30C6\\u30C3\\u30D7\\u5B9F\\u884C\");\n        const S = T ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(S, {}), this.sys.send2Dbg(S, {});\n      }\n      return !0;\n  }\n  return !1;\n}, ns = new WeakSet(), Va = function() {\n  var e;\n  const t = (e = H(ar, is)[getFn(H(this, ae))]) == null ? void 0 : e[H(this, me)];\n  t != null && t.hitCondition && --t.hitCondition;\n}, ac = new WeakSet(), ip = function() {\n  var U, z;\n  const t = H(this, Re) === 3 ? 1 : 0, e = H(this, Qt).aToken[H(this, Vt) - 1 + t], o = H(this, Qi).call(this, H(this, ae)), T = tagToken2Name(e), S = T ? `[${T}]` : e, N = (U = this.val.getVal(\"mp:const.sn.macro\")) != null ? U : \"{}\";\n  if (H(this, Vt) === 0)\n    return [{ fn: o, ln: 1, col: 1, nm: S, ma: N }];\n  const D = ot(this, xi, nn).call(this, H(this, Qt), H(this, Vt)), B = [{ fn: o, ln: D.ln, col: D.col_s + 1, nm: S, ma: N }], $ = H(this, ge).length;\n  if ($ === 0)\n    return B;\n  for (let V = $ - 1; V >= 0; --V) {\n    const X = H(this, ge)[V], W = H(this, er)[X.fn], Y = W.aToken[X.idx - 1], q = ot(this, xi, nn).call(this, W, X.idx), Z = tagToken2Name(Y);\n    B.push({\n      fn: H(this, Qi).call(this, X.fn),\n      ln: q.ln,\n      col: q.col_s + 1,\n      nm: Z ? `[${Z}]` : Y,\n      ma: (z = X.csArg[\":hMp\"][\"const.sn.macro\"]) != null ? z : \"{}\"\n    });\n  }\n  return B;\n}, Cu = new WeakMap(), xa = new WeakMap(), fr = new WeakMap(), oc = new WeakSet(), np = function(t) {\n  var S;\n  const { name: e } = t;\n  if (!e)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  let o = \"\";\n  const T = H(this, Qt).len;\n  for (; H(this, Vt) < T && (o = H(this, Qt).aToken[H(this, Vt)], o === \"\"); ++Pe(this, Vt)._)\n    ;\n  return t.text = o, t.cast = \"str\", this.hTag.let(t), nt(this, Vt, H(this, Vt) + 2), nt(this, me, H(this, me) + ((S = o.match(/\\n/g)) != null ? S : []).length), !1;\n}, uc = new WeakSet(), sp = function() {\n  var T;\n  if (H(this, Vt) === 0)\n    return console.group(`\\u{1F95F} [dump_stack] \\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${H(this, ae)} line:${1} col:${0}`), console.groupEnd(), !1;\n  const t = ot(this, xi, nn).call(this, H(this, Qt), H(this, Vt)), e = `\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u73FE\\u5728\\u5730 fn:${H(this, ae)} line:${t.ln} col:${t.col_s + 1}`;\n  console.group(`\\u{1F95F} [dump_stack] ${e}`);\n  const o = H(this, ge).length;\n  if (o > 0) {\n    console.info(e);\n    for (let S = o - 1; S >= 0; --S) {\n      const N = H(this, ge)[S], D = N.csArg[\":hMp\"], B = D ? D[\":\\u30BF\\u30B0\\u540D\"] : void 0, $ = (T = N.csArg[\":\\u30BF\\u30B0\\u540D\"]) != null ? T : \"\", U = ot(this, xi, nn).call(this, H(this, er)[N.fn], N.idx);\n      console.info(\n        `${o - S}\\u3064\\u524D\\u306E\\u30B3\\u30FC\\u30EB\\u5143 fn:${N.fn} line:${U.ln} col:${U.col_s + 1}` + (B ? \"\\uFF08[\" + B + \"]\\u30DE\\u30AF\\u30ED\\u5185\\uFF09\" : \" \") + `\\u3067 [${$} ...]\\u3092\\u30B3\\u30FC\\u30EB`\n      );\n    }\n  }\n  return console.groupEnd(), !1;\n}, xi = new WeakSet(), nn = function(t, e) {\n  const o = { ln: 1, col_s: 0, col_e: 0 };\n  if (!t)\n    return o;\n  let T = e - 1;\n  const S = o.ln = t.aLNum[T];\n  for (; t.aLNum[T] === S; ) {\n    if (t.aToken[T].charAt(0) !== `\n`) {\n      const N = t.aToken[T].length;\n      o.col_e > 0 && (o.col_s += N), o.col_e += N;\n    }\n    if (--T < 0)\n      break;\n  }\n  return o;\n}, lc = new WeakSet(), ap = function(t) {\n  const { set_fnc: e, break_fnc: o } = t;\n  if (!e)\n    throw \"set_fnc\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (nt(this, ss, globalThis[e]), !H(this, ss)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${e}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    return nt(this, ss, () => {\n    }), !1;\n  }\n  if (this.noticeBreak = (T) => {\n    var S;\n    H(this, Ru) !== H(this, ae) && (nt(this, Ru, H(this, ae)), H(this, ss).call(this, H(this, Iu)[H(this, ae)] = (S = H(this, Iu)[H(this, ae)]) != null ? S : H(this, Qt).aToken.join(\"\"))), H(this, as).call(this, H(this, me), T);\n  }, this.noticeBreak(!0), !o)\n    return !1;\n  if (nt(this, as, globalThis[o]), !H(this, as)) {\n    if (argChk_Boolean(t, \"need_err\", !0))\n      throw `HTML\\u5185\\u306B\\u95A2\\u6570${o}\\u304C\\u898B\\u3064\\u304B\\u308A\\u307E\\u305B\\u3093`;\n    nt(this, as, () => {\n    });\n  }\n  return !1;\n}, ss = new WeakMap(), as = new WeakMap(), Ru = new WeakMap(), Iu = new WeakMap(), wu = new WeakMap(), dr = new WeakMap(), hc = new WeakSet(), op = function() {\n  if (H(this, dr)[0] === -1)\n    throw \"if\\u30D6\\u30ED\\u30C3\\u30AF\\u5185\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\";\n  return nt(this, Vt, H(this, dr)[0]), H(this, dr).shift(), !1;\n}, cc = new WeakSet(), up = function(t) {\n  const { exp: e } = t;\n  if (!e)\n    throw \"exp\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e.charAt(0) === \"&\")\n    throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n  let o = 0, T = this.prpPrs.parse(e) ? H(this, Vt) : -1;\n  const S = H(this, Qt).aLNum[H(this, Vt)];\n  let N = H(this, me) - (S || 0);\n  const D = H(this, Qt).len;\n  for (; H(this, Vt) < D; ++Pe(this, Vt)._) {\n    const B = H(this, Qt).aLNum[H(this, Vt)];\n    H(this, Qt).aLNum[H(this, Vt)] = (B || 0) + N;\n    const $ = H(this, Qt).aToken[H(this, Vt)];\n    if (!$)\n      continue;\n    const U = $.charCodeAt(0);\n    if (U === 10) {\n      nt(this, me, H(this, me) + $.length);\n      continue;\n    }\n    if (U !== 91)\n      continue;\n    const [z, V] = tagToken2Name_Args($);\n    if (!(z in this.hTag))\n      throw `\\u672A\\u5B9A\\u7FA9\\u306E\\u30BF\\u30B0[${z}]\\u3067\\u3059`;\n    switch (this.alzTagArg.go(V), z) {\n      case \"if\":\n        ++o;\n        break;\n      case \"elsif\":\n        if (o > 0 || T > -1)\n          break;\n        const X = this.alzTagArg.hPrm.exp.val;\n        if (X.charAt(0) === \"&\")\n          throw \"\\u5C5E\\u6027exp\\u306F\\u300C&\\u300D\\u304C\\u4E0D\\u8981\\u3067\\u3059\";\n        this.prpPrs.parse(X) && (T = H(this, Vt) + 1);\n        break;\n      case \"else\":\n        if (o > 0)\n          break;\n        T === -1 && (T = H(this, Vt) + 1);\n        break;\n      case \"endif\":\n        if (o > 0) {\n          --o;\n          break;\n        }\n        return T === -1 ? (++Pe(this, Vt)._, H(this, Qt).aLNum[H(this, Vt)] += N) : (H(this, dr).unshift(H(this, Vt) + 1), nt(this, Vt, T), nt(this, me, H(this, Qt).aLNum[H(this, Vt)])), !1;\n    }\n  }\n  throw \"[endif]\\u304C\\u306A\\u3044\\u307E\\u307E\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\";\n}, fc = new WeakSet(), lp = function(t) {\n  argChk_Boolean(t, \"count\", !1) || ot(this, ku, Tf).call(this);\n  const { fn: e } = t;\n  return e && H(this, Ea).call(this, e), ot(this, Pu, mf).call(this, { \":hEvt1Time\": H(this, xa).popLocalEvts(), \":hMp\": this.val.cloneMp() }), argChk_Boolean(t, \"clear_local_event\", !1) && this.hTag.clear_event({}), ot(this, Ti, sn).call(this, e, t.label), !0;\n}, Pu = new WeakSet(), mf = function(t) {\n  H(this, Qt).aLNum[H(this, Vt)] = H(this, me), H(this, Ou) || (t[\":resvToken\"] = \"\", ot(this, os, Xa).call(this)), H(this, ge).push(new CallStack(H(this, ae), H(this, Vt), t)), H(this, dr).unshift(-1);\n}, dc = new WeakSet(), hp = function(t) {\n  return argChk_Boolean(t, \"count\", !0) || ot(this, ku, Tf).call(this), H(this, dr)[0] = -1, ot(this, Ti, sn).call(this, t.fn, t.label), !0;\n}, pc = new WeakSet(), cp = function(t) {\n  if (H(this, Ue) === -1)\n    return !1;\n  if (argChk_Boolean(t, \"clear\", !1))\n    return nt(this, Lr, []), nt(this, Ue, -1), !1;\n  const { to: e } = t;\n  if (!e)\n    throw \"clear\\u304Bto\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const o = H(this, Ue);\n  switch (e) {\n    case \"prev\":\n      H(this, Ue) > 0 && --Pe(this, Ue)._;\n      break;\n    case \"next\":\n      const D = H(this, Lr).length;\n      H(this, Ue) < D - 1 && ++Pe(this, Ue)._;\n      break;\n    default:\n      throw `\\u5C5E\\u6027to\\u300C${e}\\u300D\\u306F\\u7570\\u5E38\\u3067\\u3059`;\n  }\n  if (o === H(this, Ue))\n    return !1;\n  const T = H(this, Lr)[H(this, Ue)], { fn: S, idx: N } = ot(this, Ra, cl).call(this);\n  return T.key === N + \":\" + S ? !1 : ot(this, Sa, hl).call(this, { fn: T.retFn, index: T.retIdx }, T.retMark);\n}, vc = new WeakSet(), fp = function(t) {\n  if (argChk_Boolean(t, \"clear\", !1))\n    nt(this, ge, []);\n  else if (!H(this, ge).pop())\n    throw \"[pop_stack] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  return ot(this, os, Xa).call(this), nt(this, dr, [-1]), this.val.setMp({}), !1;\n}, Au = new WeakSet(), yf = function(t) {\n  const e = H(this, ge).pop();\n  if (!e)\n    throw \"[return] \\u30B9\\u30BF\\u30C3\\u30AF\\u304C\\u7A7A\\u3067\\u3059\";\n  const o = e.csArg;\n  H(this, dr).shift();\n  const T = o[\":hMp\"];\n  T && this.val.setMp(T);\n  const S = o[\":resvToken\"];\n  S ? this.nextToken = () => (ot(this, os, Xa).call(this), S) : ot(this, os, Xa).call(this), o[\":hEvt1Time\"] && H(this, xa).pushLocalEvts(o[\":hEvt1Time\"]);\n  const { fn: N, label: D } = t;\n  return N || D ? (ot(this, Ti, sn).call(this, N, D), !0) : e.fn in H(this, er) ? (ot(this, Bu, xf).call(this, e), !1) : (ot(this, Ti, sn).call(this, e.fn, \"\", e.idx), !0);\n}, Ou = new WeakMap(), os = new WeakSet(), Xa = function() {\n  nt(this, Ou, \"\"), this.nextToken = ot(this, Nu, bf);\n}, us = new WeakMap(), Ti = new WeakSet(), sn = function(t = \"\", e = \"\", o = 0) {\n  if (!t && !e && this.main.errScript(\"[jump\\u7CFB] fn\\u307E\\u305F\\u306Flabel\\u306F\\u5FC5\\u9808\\u3067\\u3059\"), e ? (e.charAt(0) !== \"*\" && this.main.errScript(\"[jump\\u7CFB] label\\u306F*\\u3067\\u59CB\\u307E\\u308A\\u307E\\u3059\"), nt(this, us, e), H(this, us).slice(0, 2) !== \"**\" && nt(this, Vt, o)) : (nt(this, us, \"\"), nt(this, Vt, o)), !t) {\n    this.analyzeInit();\n    return;\n  }\n  const T = H(this, Ea).call(this, t);\n  if (t === H(this, ae)) {\n    this.analyzeInit();\n    return;\n  }\n  nt(this, ae, t);\n  const S = H(this, er)[H(this, ae)];\n  if (S) {\n    nt(this, Qt, S), this.analyzeInit();\n    return;\n  }\n  new Loader().add({ name: H(this, ae), url: T }).use((N, D) => {\n    try {\n      N.data = this.sys.decStr(N.extension, N.data);\n    } catch (B) {\n      this.main.errScript(`[jump\\u7CFB]sn\\u30ED\\u30FC\\u30C9\\u5931\\u6557\\u3067\\u3059 fn:${N.name} ${B}`, !1);\n    }\n    D == null || D();\n  }).load((N, D) => {\n    this.nextToken = ot(this, Nu, bf), nt(this, me, 1), ot(this, bc, pp).call(this, D[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());\n  }), this.main.stop();\n}, Nu = new WeakSet(), bf = function() {\n  var e, o;\n  if (ot(this, Du, Ef).call(this))\n    return \"\";\n  ot(this, Sc, vp).call(this), (e = H(this, Qt).aLNum)[o = H(this, Vt)] || (e[o] = H(this, me));\n  const t = H(this, Qt).aToken[H(this, Vt)];\n  return H(this, Mu).call(this, t), ++Pe(this, Vt)._, t;\n}, Mu = new WeakMap(), Du = new WeakSet(), Ef = function() {\n  return H(this, Vt) < H(this, Qt).len ? !1 : (this.main.errScript(\"\\u30B9\\u30AF\\u30EA\\u30D7\\u30C8\\u7D42\\u7AEF\\u3067\\u3059\"), !0);\n}, gc = new WeakMap(), mc = new WeakMap(), Lu = new WeakMap(), ls = new WeakMap(), Fu = new WeakMap(), yc = new WeakSet(), dp = function(t, e, o, T, S) {\n  var U, z, V, X, W;\n  const N = t.aToken.length;\n  if (!T) {\n    if (ot(this, Du, Ef).call(this))\n      return { idx: S, ln: o };\n    if (t.aLNum[S])\n      o = t.aLNum[S];\n    else {\n      o = 1;\n      for (let Y = 0; Y < S; ++Y) {\n        (U = t.aLNum)[Y] || (U[Y] = o);\n        const q = t.aToken[Y];\n        q.charCodeAt(0) === 10 ? o += q.length : o += ((z = q.match(/\\n/g)) != null ? z : []).length;\n      }\n      t.aLNum[S] = o;\n    }\n    return { idx: S, ln: o };\n  }\n  t.aLNum[0] = 1;\n  const D = T.match(H(this, gc));\n  if (D) {\n    T = D[1];\n    let Y = S;\n    switch (D[2]) {\n      case \"before\":\n        for (; t.aToken[--Y] !== T; )\n          Y === 0 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \" + o + \"\\u884C\\u76EE\\u4EE5\\u524D\\u3067\" + (e ? \"\\u30DE\\u30AF\\u30ED\\u5185\\u306B\" : \"\") + \"\\u30E9\\u30D9\\u30EB\\u3010\" + T + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\"), e && t.aToken[Y].search(H(this, mc)) > -1 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBbefore] \\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + T + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        return { idx: Y + 1, ln: t.aLNum[Y] };\n      case \"after\":\n        for (; t.aToken[++Y] !== T; )\n          Y === N && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + o + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + T + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\"), t.aToken[Y].search(H(this, Lu)) > -1 && DebugMng.myTrace(\"[jump\\u7CFB \\u7121\\u540D\\u30E9\\u30D9\\u30EBafter] \" + o + \"\\u884C\\u76EE\\u4EE5\\u5F8C\\u3067\\u30DE\\u30AF\\u30ED\\u5185\\u306B\\u30E9\\u30D9\\u30EB\\u3010\" + T + \"\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\", \"ET\");\n        return { idx: Y + 1, ln: t.aLNum[Y] };\n      default:\n        DebugMng.myTrace(\"[jump\\u7CFB] \\u7121\\u540D\\u30E9\\u30D9\\u30EB\\u6307\\u5B9A\\u3010label=\" + T + \"\\u3011\\u304C\\u9593\\u9055\\u3063\\u3066\\u3044\\u307E\\u3059\", \"ET\");\n    }\n  }\n  o = 1;\n  const B = new RegExp(\n    \"^\" + T.replaceAll(\"*\", \"\\\\*\") + \"(?=\\\\s|;|\\\\[|\\\\||$)\"\n  );\n  let $ = !1;\n  for (let Y = 0; Y < N; ++Y) {\n    (V = t.aLNum)[Y] || (V[Y] = o);\n    const q = t.aToken[Y];\n    if ($) {\n      H(this, Fu).lastIndex = 0, H(this, Fu).test(q) ? $ = !1 : o += ((X = q.match(/\\n/g)) != null ? X : []).length;\n      continue;\n    }\n    const Z = q.charCodeAt(0);\n    if (Z === 10) {\n      o += q.length;\n      continue;\n    }\n    if (Z === 42) {\n      if (q.search(B) > -1)\n        return { idx: Y + 1, ln: o };\n      continue;\n    }\n    Z === 91 && (o += ((W = q.match(/\\n/g)) != null ? W : []).length, H(this, ls).lastIndex = 0, H(this, ls).test(q) && ($ = !0));\n  }\n  throw $ ? \"[let_ml]\\u306E\\u7D42\\u7AEF\\u30FB[endlet_ml]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\" : (DebugMng.myTrace(`[jump\\u7CFB] \\u30E9\\u30D9\\u30EB\\u3010${T}\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`, \"ET\"), \"Dummy\");\n}, er = new WeakMap(), bc = new WeakSet(), pp = function(t) {\n  const e = H(this, Ji).matchToken(t.replaceAll(/(\\r\\n|\\r)/g, `\n`));\n  for (let S = e.length - 1; S >= 0; --S) {\n    const N = e[S];\n    if (H(this, ls).lastIndex = 0, H(this, ls).test(N)) {\n      const D = N.indexOf(\"]\") + 1;\n      if (D === 0)\n        throw \"[let_ml]\\u3067\\u9589\\u3058\\u308B\\u3010]\\u3011\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\";\n      const B = N.slice(0, D), $ = N.slice(D);\n      e.splice(S, 1, B, $);\n    }\n  }\n  const o = nt(this, Qt, { aToken: e, len: e.length, aLNum: [] });\n  let T = \"\";\n  try {\n    T = \"ScriptIterator.replaceScriptChar2macro\", H(this, Ji).replaceScr_C2M_And_let_ml(o), T = \"ScriptIterator.replaceScript_Wildcard\", H(this, Tc).call(this);\n  } catch (S) {\n    S instanceof Error ? T += `\\u4F8B\\u5916 mes=${S.message}(${S.name})` : T = S, this.main.errScript(T, !1);\n  }\n  H(this, er)[H(this, ae)] = o, this.val.loadScrWork(H(this, ae));\n}, Bu = new WeakSet(), xf = function(t) {\n  nt(this, ae, t.fn), nt(this, Vt, t.idx);\n  const e = H(this, er)[H(this, ae)];\n  e && nt(this, Qt, e), nt(this, me, H(this, Qt).aLNum[t.idx]);\n}, Ec = new WeakMap(), xc = new WeakMap(), Tc = new WeakMap(), Sc = new WeakSet(), vp = function() {\n  const t = this.val.getAreaKidoku(H(this, ae));\n  if (!t)\n    throw `recordKidoku fn:'${H(this, ae)}' (areas === null)`;\n  if (H(this, ge).length > 0) {\n    t.record(H(this, Vt));\n    return;\n  }\n  nt(this, Si, t.search(H(this, Vt))), this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", H(this, Si)), !H(this, Si) && t.record(H(this, Vt));\n}, Si = new WeakMap(), ku = new WeakSet(), Tf = function() {\n  var t;\n  (t = this.val.getAreaKidoku(H(this, ae))) == null || t.erase(H(this, Vt)), nt(this, Si, !1);\n}, Cc = new WeakSet(), gp = function(t) {\n  return H(this, Ji).bracket2macro(t, H(this, Qt), H(this, Vt)), !1;\n}, Rc = new WeakSet(), _p = function(t) {\n  return H(this, Ji).char2macro(t, this.hTag, H(this, Qt), H(this, Vt)), !1;\n}, Ic = new WeakMap(), wc = new WeakSet(), mp = function(t) {\n  var S, N, D;\n  const { name: e } = t;\n  if (!e)\n    throw \"name\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  if (e in this.hTag)\n    throw `[${e}]\\u306F\\u30BF\\u30B0\\u304B\\u3059\\u3067\\u306B\\u5B9A\\u7FA9\\u6E08\\u307F\\u306E\\u30DE\\u30AF\\u30ED\\u3067\\u3059`;\n  if (H(this, Ic).test(e))\n    throw `[${e}]\\u306F\\u30DE\\u30AF\\u30ED\\u540D\\u3068\\u3057\\u3066\\u7570\\u5E38\\u3067\\u3059`;\n  const o = H(this, me), T = new CallStack(H(this, ae), H(this, Vt));\n  for (nt(this, $u, H(this, $u) + (\"|\" + e)), nt(this, Ta, new RegExp(`\\\\[(${H(this, $u)})\\\\b`)), this.hTag[e] = (B) => (B.design_unit = t.design_unit, ot(this, Pu, mf).call(this, { ...B, \":hMp\": this.val.cloneMp() }), this.val.setMp(B), this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(t)), this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", H(this, ae)), nt(this, me, o), ot(this, Bu, xf).call(this, T), !1); H(this, Vt) < H(this, Qt).len; ++Pe(this, Vt)._) {\n    (S = H(this, Qt).aLNum)[N = H(this, Vt)] || (S[N] = H(this, me));\n    const B = H(this, Qt).aToken[H(this, Vt)];\n    if (B.search(H(this, Lu)) > -1)\n      return ++Pe(this, Vt)._, !1;\n    const $ = B.charCodeAt(0);\n    $ === 10 ? nt(this, me, H(this, me) + B.length) : $ === 91 && nt(this, me, H(this, me) + ((D = B.match(/\\n/g)) != null ? D : []).length);\n  }\n  throw `\\u30DE\\u30AF\\u30ED[${e}]\\u5B9A\\u7FA9\\u306E\\u7D42\\u7AEF\\u30FB[endmacro]\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093`;\n}, $u = new WeakMap(), Ta = new WeakMap(), Pc = new WeakSet(), yp = function(t) {\n  if (!(\"place\" in t))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.place);\n  if (\"fn\" in t != \"label\" in t)\n    throw \"fn\\u3068label\\u306F\\u30BB\\u30C3\\u30C8\\u3067\\u6307\\u5B9A\\u3057\\u3066\\u4E0B\\u3055\\u3044\";\n  const o = this.val.getMark(e);\n  if (!o)\n    throw `place\\u3010${e}\\u3011\\u306F\\u5B58\\u5728\\u3057\\u307E\\u305B\\u3093`;\n  return ot(this, Sa, hl).call(this, t, o);\n}, Sa = new WeakSet(), hl = function(t, e, o = !0) {\n  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), H(this, fr).recPagebreak(), o && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, \"do_rec\", !0) && nt(this, Dr, {\n    hSave: this.val.cloneSave(),\n    hPages: { ...e.hPages },\n    aIfStk: [...e.aIfStk]\n  });\n  const T = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(T);\n  const S = String(this.val.getVal(\"save:const.sn.scriptFn\")), N = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  return nt(this, dr, [...H(this, Dr).aIfStk]), nt(this, ge, []), H(this, fr).cover(!0), H(this, fr).stopAllTw(), \"index\" in t ? (H(this, fr).playback(H(this, Dr).hPages, () => {\n    var D, B;\n    H(this, fr).cover(!1), nt(this, Ca, !0), ot(this, Ti, sn).call(this, (D = t.fn) != null ? D : S, \"\", (B = t.index) != null ? B : N);\n  }), !0) : (delete H(this, er)[S], H(this, fr).playback(\n    H(this, Dr).hPages,\n    \"label\" in t ? () => {\n      H(this, fr).cover(!1), nt(this, ae, S), nt(this, Vt, N), this.hTag.call({ fn: t.fn, label: t.label });\n    } : () => {\n      H(this, fr).cover(!1), ot(this, Ti, sn).call(this, S, \"\", N);\n    }\n  ), !0);\n}, Ca = new WeakMap(), Ac = new WeakSet(), bp = function(t) {\n  const e = this.val.getMark(0);\n  return delete H(this, er)[getFn(e.hSave[\"const.sn.scriptFn\"])], t.do_rec = !1, ot(this, Sa, hl).call(this, t, e, !1);\n}, Dr = new WeakMap(), Oc = new WeakSet(), Ep = function() {\n  if (this.main.isDestroyed())\n    return !1;\n  const { fn: t, idx: e } = ot(this, Ra, cl).call(this);\n  return this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", t), this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", e), nt(this, Dr, {\n    hSave: this.val.cloneSave(),\n    hPages: H(this, fr).record(),\n    aIfStk: H(this, dr).slice(H(this, ge).length)\n  }), !1;\n}, Ra = new WeakSet(), cl = function() {\n  if (H(this, ge).length === 0)\n    return {\n      fn: H(this, ae),\n      idx: H(this, Vt)\n    };\n  const e = H(this, ge)[0];\n  return {\n    fn: e.fn,\n    idx: e.idx\n  };\n}, Nc = new WeakSet(), xp = function(t) {\n  var T;\n  if (!(\"place\" in t))\n    throw \"place\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n  const e = Number(t.place);\n  delete t[\":\\u30BF\\u30B0\\u540D\"], delete t.place, t.text = ((T = t.text) != null ? T : \"\").replace(/^(<br\\/>)+/, \"\"), H(this, Dr).json = t, this.val.setMark(e, H(this, Dr));\n  const o = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  return e === o && this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", o + 1), !1;\n}, Lr = new WeakMap(), Ue = new WeakMap(), rt(ScriptIterator, nc, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/), rt(ScriptIterator, is, {}), rt(ScriptIterator, Ei, {});\nvar rr, ir, je, Er, Ci, hs, Ge, Uu, Ri, Ia, cs, Gu, Hu, wa, Mc, Tp, ju, zu, Pa, Aa, fl, fs, ds;\nclass Main {\n  constructor(t) {\n    rt(this, Mc);\n    rt(this, Aa);\n    rt(this, rr, void 0);\n    rt(this, ir, void 0);\n    rt(this, je, /* @__PURE__ */ Object.create(null));\n    rt(this, Er, void 0);\n    rt(this, Ci, void 0);\n    rt(this, hs, void 0);\n    rt(this, Ge, void 0);\n    rt(this, Uu, void 0);\n    rt(this, Ri, void 0);\n    rt(this, Ia, void 0);\n    rt(this, cs, () => {\n    });\n    rt(this, Gu, new AnalyzeTagArg());\n    rt(this, Hu, !1);\n    rt(this, wa, \"skynovel\");\n    rt(this, ju, () => H(this, cs).call(this));\n    rt(this, zu, (t = ot(this, Aa, fl)) => {\n      H(this, fs) || (H(this, Ri).clearBreak(), nt(this, cs, t), this.resume = (e = ot(this, Aa, fl)) => {\n        nt(this, cs, e);\n      }, H(this, Ge).noticeBreak(!1));\n    });\n    Pt(this, \"resume\", H(this, zu));\n    Pt(this, \"stop\", () => {\n      nt(this, cs, () => {\n      }), this.resume = H(this, zu), H(this, Ge).noticeBreak(!0);\n    });\n    rt(this, Pa, !0);\n    rt(this, fs, !1);\n    Pt(this, \"isDestroyed\", () => H(this, fs));\n    rt(this, ds, void 0);\n    this.sys = t, skipHello(), Config.generate(t).then((e) => nt(this, rr, e)).then(() => ot(this, Mc, Tp).call(this)).catch((e) => console.error(\"load err fn:prj.json e:%o\", e));\n  }\n  errScript(t, e = !0) {\n    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log(\"\\u{1F35C} SKYNovel err!\"), e)\n      throw t;\n  }\n  resumeByJumpOrCall(t) {\n    var e, o;\n    if (t.url) {\n      globalThis.open(t.url);\n      return;\n    }\n    H(this, Er).setVal_Nochk(\"tmp\", \"sn.eventArg\", (e = t.arg) != null ? e : \"\"), H(this, Er).setVal_Nochk(\"tmp\", \"sn.eventLabel\", (o = t.label) != null ? o : \"\"), argChk_Boolean(t, \"call\", !1) ? (H(this, Ge).subIdxToken(), this.resume(() => H(this, je).call(t))) : (H(this, je).clear_event({}), this.resume(() => H(this, je).jump(t)));\n  }\n  setLoop(t, e = \"\") {\n    nt(this, Pa, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}\\u4E2D` : \"\");\n  }\n  fire(t, e) {\n    H(this, Ia).fire(t, e);\n  }\n  async destroy(t = 0) {\n    H(this, fs) || (nt(this, fs, !0), H(this, Hu) && (this.stop(), nt(this, Pa, !1), H(this, Ri).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), nt(this, je, {}), H(this, Ia).destroy(), H(this, Ge).destroy(), H(this, Ri).destroy(), H(this, Uu).destroy(), H(this, ir).ticker.remove(H(this, ju)), H(this, ds) && H(this, ir) && H(this, ir).view.parentNode.appendChild(H(this, ds)), clearTextureCache(), H(this, ir).destroy(!0), this.sys.destroy()));\n  }\n}\nrr = new WeakMap(), ir = new WeakMap(), je = new WeakMap(), Er = new WeakMap(), Ci = new WeakMap(), hs = new WeakMap(), Ge = new WeakMap(), Uu = new WeakMap(), Ri = new WeakMap(), Ia = new WeakMap(), cs = new WeakMap(), Gu = new WeakMap(), Hu = new WeakMap(), wa = new WeakMap(), Mc = new WeakSet(), Tp = async function() {\n  var T, S, N;\n  const t = (T = document.createElement(\"canvas\")) == null ? void 0 : T.getContext(\"2d\");\n  if (!t)\n    throw \"argChk_Color err\";\n  CmnLib.cc4ColorName = t;\n  const e = {\n    width: H(this, rr).oCfg.window.width,\n    height: H(this, rr).oCfg.window.height,\n    backgroundColor: parseColor(String(H(this, rr).oCfg.init.bg_color)),\n    resolution: (S = globalThis.devicePixelRatio) != null ? S : 1,\n    autoResize: !0\n  }, o = document.getElementById(H(this, wa));\n  o && (nt(this, ds, o.cloneNode(!0)), H(this, ds).id = H(this, wa), e.view = o), nt(this, ir, new Application(e)), o || (document.body.appendChild(H(this, ir).view), H(this, ir).view.id = H(this, wa)), nt(this, Er, new Variable(H(this, rr), H(this, je))), nt(this, Ci, new PropParser(H(this, Er), (N = H(this, rr).oCfg.init.escape) != null ? N : \"\\\\\")), await Promise.allSettled(this.sys.init(H(this, je), H(this, ir), H(this, Er), this)), H(this, je).title({ text: H(this, rr).oCfg.book.title || \"SKYNovel\" }), nt(this, hs, new SoundMng(H(this, rr), H(this, je), H(this, Er), this, this.sys)), nt(this, Ge, new ScriptIterator(H(this, rr), H(this, je), this, H(this, Er), H(this, Gu), () => ot(this, Aa, fl).call(this), H(this, Ci), H(this, hs), this.sys)), nt(this, Uu, new DebugMng(this.sys, H(this, je), H(this, Ge))), nt(this, Ri, new LayerMng(H(this, rr), H(this, je), H(this, ir), H(this, Er), this, H(this, Ge), this.sys, H(this, hs), H(this, Gu), H(this, Ci))), nt(this, Ia, new EventMng(H(this, rr), H(this, je), H(this, ir), this, H(this, Ri), H(this, Er), H(this, hs), H(this, Ge), this.sys)), H(this, ir).ticker.add(H(this, ju)), this.resumeByJumpOrCall({ fn: \"main\" }), nt(this, Hu, !0);\n}, ju = new WeakMap(), zu = new WeakMap(), Pa = new WeakMap(), Aa = new WeakSet(), fl = function() {\n  var t;\n  for (; H(this, Pa); ) {\n    let e = H(this, Ge).nextToken();\n    if (!e)\n      break;\n    const o = e.charCodeAt(0);\n    if (o !== 9) {\n      if (o === 10) {\n        H(this, Ge).addLineNum(e.length);\n        continue;\n      }\n      if (o === 91) {\n        if (H(this, Ge).isBreak(e))\n          return;\n        try {\n          const T = ((t = e.match(/\\n/g)) != null ? t : []).length;\n          if (T > 0 && H(this, Ge).addLineNum(T), H(this, Ge).\\u30BF\\u30B0\\u89E3\\u6790(e)) {\n            this.stop();\n            break;\n          }\n          continue;\n        } catch (T) {\n          T instanceof Error ? this.errScript(`[${tagToken2Name(e)}]\\u30BF\\u30B0\\u89E3\\u6790\\u4E2D\\u4F8B\\u5916 mes=${T.message}(${T.name})`, !1) : this.errScript(String(T), !1);\n          return;\n        }\n      }\n      if (o === 38)\n        try {\n          if (e.slice(-1) !== \"&\") {\n            if (H(this, Ge).isBreak(e))\n              return;\n            const T = splitAmpersand(e.slice(1));\n            T.name = H(this, Ci).getValAmpersand(T.name), T.text = String(H(this, Ci).parse(T.text)), H(this, je).let(T);\n            continue;\n          }\n          if (e.charAt(1) === \"&\")\n            throw new Error(\"\\u300C&\\u8868\\u793A&\\u300D\\u66F8\\u5F0F\\u3067\\u306F\\u300C&\\u300D\\u6307\\u5B9A\\u304C\\u4E0D\\u8981\\u3067\\u3059\");\n          e = String(H(this, Ci).parse(e.slice(1, -1)));\n        } catch (T) {\n          this.errScript(\n            T instanceof Error ? `& \\u5909\\u6570\\u64CD\\u4F5C\\u30FB\\u8868\\u793A mes=${T.message}(${T.name})` : T,\n            !1\n          );\n          return;\n        }\n      else {\n        if (o === 59)\n          continue;\n        if (o === 42 && e.length > 1)\n          continue;\n      }\n      try {\n        H(this, Ri).currentTxtlayForeNeedErr.tagCh(e);\n      } catch (T) {\n        this.errScript(\n          T instanceof Error ? `\\u6587\\u5B57\\u8868\\u793A mes=${T.message}(${T.name})` : T,\n          !1\n        );\n        return;\n      }\n    }\n  }\n}, fs = new WeakMap(), ds = new WeakMap();\nvar assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < \"u\" ? window : commonjsGlobal$1, util$6 = {\n  assign,\n  create: create$1,\n  trim: trim$1,\n  bind: bind$1,\n  slice: slice$1,\n  each: each$7,\n  map,\n  pluck: pluck$1,\n  isList: isList$1,\n  isFunction: isFunction$1,\n  isObject: isObject$1,\n  Global: Global$5\n};\nfunction make_assign() {\n  return Object.assign ? Object.assign : function(t, e, o, T) {\n    for (var S = 1; S < arguments.length; S++)\n      each$7(Object(arguments[S]), function(N, D) {\n        t[D] = N;\n      });\n    return t;\n  };\n}\nfunction make_create() {\n  if (Object.create)\n    return function(t, e, o, T) {\n      var S = slice$1(arguments, 1);\n      return assign.apply(this, [Object.create(t)].concat(S));\n    };\n  {\n    let r = function() {\n    };\n    return function(e, o, T, S) {\n      var N = slice$1(arguments, 1);\n      return r.prototype = e, assign.apply(this, [new r()].concat(N));\n    };\n  }\n}\nfunction make_trim() {\n  return String.prototype.trim ? function(t) {\n    return String.prototype.trim.call(t);\n  } : function(t) {\n    return t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n}\nfunction bind$1(r, t) {\n  return function() {\n    return t.apply(r, Array.prototype.slice.call(arguments, 0));\n  };\n}\nfunction slice$1(r, t) {\n  return Array.prototype.slice.call(r, t || 0);\n}\nfunction each$7(r, t) {\n  pluck$1(r, function(e, o) {\n    return t(e, o), !1;\n  });\n}\nfunction map(r, t) {\n  var e = isList$1(r) ? [] : {};\n  return pluck$1(r, function(o, T) {\n    return e[T] = t(o, T), !1;\n  }), e;\n}\nfunction pluck$1(r, t) {\n  if (isList$1(r)) {\n    for (var e = 0; e < r.length; e++)\n      if (t(r[e], e))\n        return r[e];\n  } else\n    for (var o in r)\n      if (r.hasOwnProperty(o) && t(r[o], o))\n        return r[o];\n}\nfunction isList$1(r) {\n  return r != null && typeof r != \"function\" && typeof r.length == \"number\";\n}\nfunction isFunction$1(r) {\n  return r && {}.toString.call(r) === \"[object Function]\";\n}\nfunction isObject$1(r) {\n  return r && {}.toString.call(r) === \"[object Object]\";\n}\nvar util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {\n  createStore\n}, storeAPI = {\n  version: \"2.0.12\",\n  enabled: !1,\n  get: function(r, t) {\n    var e = this.storage.read(this._namespacePrefix + r);\n    return this._deserialize(e, t);\n  },\n  set: function(r, t) {\n    return t === void 0 ? this.remove(r) : (this.storage.write(this._namespacePrefix + r, this._serialize(t)), t);\n  },\n  remove: function(r) {\n    this.storage.remove(this._namespacePrefix + r);\n  },\n  each: function(r) {\n    var t = this;\n    this.storage.each(function(e, o) {\n      r.call(t, t._deserialize(e), (o || \"\").replace(t._namespaceRegexp, \"\"));\n    });\n  },\n  clearAll: function() {\n    this.storage.clearAll();\n  },\n  hasNamespace: function(r) {\n    return this._namespacePrefix == \"__storejs_\" + r + \"_\";\n  },\n  createStore: function() {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function(r) {\n    this._addPlugin(r);\n  },\n  namespace: function(r) {\n    return createStore(this.storage, this.plugins, r);\n  }\n};\nfunction _warn() {\n  var r = typeof console > \"u\" ? null : console;\n  if (!!r) {\n    var t = r.warn ? r.warn : r.log;\n    t.apply(r, arguments);\n  }\n}\nfunction createStore(r, t, e) {\n  e || (e = \"\"), r && !isList(r) && (r = [r]), t && !isList(t) && (t = [t]);\n  var o = e ? \"__storejs_\" + e + \"_\" : \"\", T = e ? new RegExp(\"^\" + o) : null, S = /^[a-zA-Z0-9_\\-]*$/;\n  if (!S.test(e))\n    throw new Error(\"store.js namespaces can only have alphanumerics + underscores and dashes\");\n  var N = {\n    _namespacePrefix: o,\n    _namespaceRegexp: T,\n    _testStorage: function(B) {\n      try {\n        var $ = \"__storejs__test__\";\n        B.write($, $);\n        var U = B.read($) === $;\n        return B.remove($), U;\n      } catch {\n        return !1;\n      }\n    },\n    _assignPluginFnProp: function(B, $) {\n      var U = this[$];\n      this[$] = function() {\n        var V = slice(arguments, 0), X = this;\n        function W() {\n          if (!!U)\n            return each$6(arguments, function(q, Z) {\n              V[Z] = q;\n            }), U.apply(X, V);\n        }\n        var Y = [W].concat(V);\n        return B.apply(X, Y);\n      };\n    },\n    _serialize: function(B) {\n      return JSON.stringify(B);\n    },\n    _deserialize: function(B, $) {\n      if (!B)\n        return $;\n      var U = \"\";\n      try {\n        U = JSON.parse(B);\n      } catch {\n        U = B;\n      }\n      return U !== void 0 ? U : $;\n    },\n    _addStorage: function(B) {\n      this.enabled || this._testStorage(B) && (this.storage = B, this.enabled = !0);\n    },\n    _addPlugin: function(B) {\n      var $ = this;\n      if (isList(B)) {\n        each$6(B, function(V) {\n          $._addPlugin(V);\n        });\n        return;\n      }\n      var U = pluck(this.plugins, function(V) {\n        return B === V;\n      });\n      if (!U) {\n        if (this.plugins.push(B), !isFunction(B))\n          throw new Error(\"Plugins must be function values that return objects\");\n        var z = B.call(this);\n        if (!isObject(z))\n          throw new Error(\"Plugins must return an object of function properties\");\n        each$6(z, function(V, X) {\n          if (!isFunction(V))\n            throw new Error(\"Bad plugin property: \" + X + \" from plugin \" + B.name + \". Plugins should only return functions.\");\n          $._assignPluginFnProp(V, X);\n        });\n      }\n    },\n    addStorage: function(B) {\n      _warn(\"store.addStorage(storage) is deprecated. Use createStore([storages])\"), this._addStorage(B);\n    }\n  }, D = create(N, storeAPI, {\n    plugins: []\n  });\n  return D.raw = {}, each$6(D, function(B, $) {\n    isFunction(B) && (D.raw[$] = bind(D, B));\n  }), each$6(r, function(B) {\n    D._addStorage(B);\n  }), each$6(t, function(B) {\n    D._addPlugin(B);\n  }), D;\n}\nvar util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {\n  name: \"localStorage\",\n  read: read$5,\n  write: write$5,\n  each: each$5,\n  remove: remove$5,\n  clearAll: clearAll$5\n};\nfunction localStorage() {\n  return Global$4.localStorage;\n}\nfunction read$5(r) {\n  return localStorage().getItem(r);\n}\nfunction write$5(r, t) {\n  return localStorage().setItem(r, t);\n}\nfunction each$5(r) {\n  for (var t = localStorage().length - 1; t >= 0; t--) {\n    var e = localStorage().key(t);\n    r(read$5(e), e);\n  }\n}\nfunction remove$5(r) {\n  return localStorage().removeItem(r);\n}\nfunction clearAll$5() {\n  return localStorage().clear();\n}\nvar util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {\n  name: \"oldFF-globalStorage\",\n  read: read$4,\n  write: write$4,\n  each: each$4,\n  remove: remove$4,\n  clearAll: clearAll$4\n}, globalStorage = Global$3.globalStorage;\nfunction read$4(r) {\n  return globalStorage[r];\n}\nfunction write$4(r, t) {\n  globalStorage[r] = t;\n}\nfunction each$4(r) {\n  for (var t = globalStorage.length - 1; t >= 0; t--) {\n    var e = globalStorage.key(t);\n    r(globalStorage[e], e);\n  }\n}\nfunction remove$4(r) {\n  return globalStorage.removeItem(r);\n}\nfunction clearAll$4() {\n  each$4(function(r, t) {\n    delete globalStorage[r];\n  });\n}\nvar util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {\n  name: \"oldIE-userDataStorage\",\n  write: write$3,\n  read: read$3,\n  each: each$3,\n  remove: remove$3,\n  clearAll: clearAll$3\n}, storageName = \"storejs\", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : \"\").match(/ (MSIE 8|MSIE 9|MSIE 10)\\./);\nfunction write$3(r, t) {\n  if (!disable) {\n    var e = fixKey(r);\n    _withStorageEl(function(o) {\n      o.setAttribute(e, t), o.save(storageName);\n    });\n  }\n}\nfunction read$3(r) {\n  if (!disable) {\n    var t = fixKey(r), e = null;\n    return _withStorageEl(function(o) {\n      e = o.getAttribute(t);\n    }), e;\n  }\n}\nfunction each$3(r) {\n  _withStorageEl(function(t) {\n    for (var e = t.XMLDocument.documentElement.attributes, o = e.length - 1; o >= 0; o--) {\n      var T = e[o];\n      r(t.getAttribute(T.name), T.name);\n    }\n  });\n}\nfunction remove$3(r) {\n  var t = fixKey(r);\n  _withStorageEl(function(e) {\n    e.removeAttribute(t), e.save(storageName);\n  });\n}\nfunction clearAll$3() {\n  _withStorageEl(function(r) {\n    var t = r.XMLDocument.documentElement.attributes;\n    r.load(storageName);\n    for (var e = t.length - 1; e >= 0; e--)\n      r.removeAttribute(t[e].name);\n    r.save(storageName);\n  });\n}\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\");\nfunction fixKey(r) {\n  return r.replace(/^\\d/, \"___$&\").replace(forbiddenCharsRegex, \"___\");\n}\nfunction _makeIEStorageElFunction() {\n  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)\n    return null;\n  var r = \"script\", t, e, o;\n  try {\n    e = new ActiveXObject(\"htmlfile\"), e.open(), e.write(\"<\" + r + \">document.w=window</\" + r + '><iframe src=\"/favicon.ico\"></iframe>'), e.close(), t = e.w.frames[0].document, o = t.createElement(\"div\");\n  } catch {\n    o = doc$1.createElement(\"div\"), t = doc$1.body;\n  }\n  return function(T) {\n    var S = [].slice.call(arguments, 0);\n    S.unshift(o), t.appendChild(o), o.addBehavior(\"#default#userData\"), o.load(storageName), T.apply(this, S), t.removeChild(o);\n  };\n}\nvar util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {\n  name: \"cookieStorage\",\n  read: read$2,\n  write: write$2,\n  each: each$2,\n  remove: remove$2,\n  clearAll: clearAll$2\n}, doc = Global$1.document;\nfunction read$2(r) {\n  if (!r || !_has(r))\n    return null;\n  var t = \"(?:^|.*;\\\\s*)\" + escape(r).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\";\n  return unescape(doc.cookie.replace(new RegExp(t), \"$1\"));\n}\nfunction each$2(r) {\n  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)\n    if (!!trim(t[e])) {\n      var o = t[e].split(\"=\"), T = unescape(o[0]), S = unescape(o[1]);\n      r(S, T);\n    }\n}\nfunction write$2(r, t) {\n  !r || (doc.cookie = escape(r) + \"=\" + escape(t) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\");\n}\nfunction remove$2(r) {\n  !r || !_has(r) || (doc.cookie = escape(r) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\");\n}\nfunction clearAll$2() {\n  each$2(function(r, t) {\n    remove$2(t);\n  });\n}\nfunction _has(r) {\n  return new RegExp(\"(?:^|;\\\\s*)\" + escape(r).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\").test(doc.cookie);\n}\nvar util = util$6, Global = util.Global, sessionStorage_1 = {\n  name: \"sessionStorage\",\n  read: read$1,\n  write: write$1,\n  each: each$1,\n  remove: remove$1,\n  clearAll: clearAll$1\n};\nfunction sessionStorage$1() {\n  return Global.sessionStorage;\n}\nfunction read$1(r) {\n  return sessionStorage$1().getItem(r);\n}\nfunction write$1(r, t) {\n  return sessionStorage$1().setItem(r, t);\n}\nfunction each$1(r) {\n  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {\n    var e = sessionStorage$1().key(t);\n    r(read$1(e), e);\n  }\n}\nfunction remove$1(r) {\n  return sessionStorage$1().removeItem(r);\n}\nfunction clearAll$1() {\n  return sessionStorage$1().clear();\n}\nvar memoryStorage_1 = {\n  name: \"memoryStorage\",\n  read,\n  write,\n  each,\n  remove,\n  clearAll\n}, memoryStorage = {};\nfunction read(r) {\n  return memoryStorage[r];\n}\nfunction write(r, t) {\n  memoryStorage[r] = t;\n}\nfunction each(r) {\n  for (var t in memoryStorage)\n    memoryStorage.hasOwnProperty(t) && r(memoryStorage[t], t);\n}\nfunction remove(r) {\n  delete memoryStorage[r];\n}\nfunction clearAll(r) {\n  memoryStorage = {};\n}\nvar all = [\n  localStorage_1,\n  oldFFGlobalStorage,\n  oldIEUserDataStorage,\n  cookieStorage,\n  sessionStorage_1,\n  memoryStorage_1\n], json2$1 = {}, hasRequiredJson2;\nfunction requireJson2() {\n  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != \"object\" && (JSON = {}), function() {\n    var rx_one = /^[\\],:{}\\s]*$/, rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, rx_four = /(?:^|:|,)(?:\\s*\\[)+/g, rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g, rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    function f(r) {\n      return r < 10 ? \"0\" + r : r;\n    }\n    function this_value() {\n      return this.valueOf();\n    }\n    typeof Date.prototype.toJSON != \"function\" && (Date.prototype.toJSON = function() {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + \"-\" + f(this.getUTCMonth() + 1) + \"-\" + f(this.getUTCDate()) + \"T\" + f(this.getUTCHours()) + \":\" + f(this.getUTCMinutes()) + \":\" + f(this.getUTCSeconds()) + \"Z\" : null;\n    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);\n    var gap, indent, meta, rep;\n    function quote(r) {\n      return rx_escapable.lastIndex = 0, rx_escapable.test(r) ? '\"' + r.replace(rx_escapable, function(t) {\n        var e = meta[t];\n        return typeof e == \"string\" ? e : \"\\\\u\" + (\"0000\" + t.charCodeAt(0).toString(16)).slice(-4);\n      }) + '\"' : '\"' + r + '\"';\n    }\n    function str(r, t) {\n      var e, o, T, S, N = gap, D, B = t[r];\n      switch (B && typeof B == \"object\" && typeof B.toJSON == \"function\" && (B = B.toJSON(r)), typeof rep == \"function\" && (B = rep.call(t, r, B)), typeof B) {\n        case \"string\":\n          return quote(B);\n        case \"number\":\n          return isFinite(B) ? String(B) : \"null\";\n        case \"boolean\":\n        case \"null\":\n          return String(B);\n        case \"object\":\n          if (!B)\n            return \"null\";\n          if (gap += indent, D = [], Object.prototype.toString.apply(B) === \"[object Array]\") {\n            for (S = B.length, e = 0; e < S; e += 1)\n              D[e] = str(e, B) || \"null\";\n            return T = D.length === 0 ? \"[]\" : gap ? `[\n` + gap + D.join(`,\n` + gap) + `\n` + N + \"]\" : \"[\" + D.join(\",\") + \"]\", gap = N, T;\n          }\n          if (rep && typeof rep == \"object\")\n            for (S = rep.length, e = 0; e < S; e += 1)\n              typeof rep[e] == \"string\" && (o = rep[e], T = str(o, B), T && D.push(quote(o) + (gap ? \": \" : \":\") + T));\n          else\n            for (o in B)\n              Object.prototype.hasOwnProperty.call(B, o) && (T = str(o, B), T && D.push(quote(o) + (gap ? \": \" : \":\") + T));\n          return T = D.length === 0 ? \"{}\" : gap ? `{\n` + gap + D.join(`,\n` + gap) + `\n` + N + \"}\" : \"{\" + D.join(\",\") + \"}\", gap = N, T;\n      }\n    }\n    typeof JSON.stringify != \"function\" && (meta = {\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    }, JSON.stringify = function(r, t, e) {\n      var o;\n      if (gap = \"\", indent = \"\", typeof e == \"number\")\n        for (o = 0; o < e; o += 1)\n          indent += \" \";\n      else\n        typeof e == \"string\" && (indent = e);\n      if (rep = t, t && typeof t != \"function\" && (typeof t != \"object\" || typeof t.length != \"number\"))\n        throw new Error(\"JSON.stringify\");\n      return str(\"\", { \"\": r });\n    }), typeof JSON.parse != \"function\" && (JSON.parse = function(text, reviver) {\n      var j;\n      function walk(r, t) {\n        var e, o, T = r[t];\n        if (T && typeof T == \"object\")\n          for (e in T)\n            Object.prototype.hasOwnProperty.call(T, e) && (o = walk(T, e), o !== void 0 ? T[e] = o : delete T[e]);\n        return reviver.call(r, t, T);\n      }\n      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(r) {\n        return \"\\\\u\" + (\"0000\" + r.charCodeAt(0).toString(16)).slice(-4);\n      })), rx_one.test(\n        text.replace(rx_two, \"@\").replace(rx_three, \"]\").replace(rx_four, \"\")\n      ))\n        return j = eval(\"(\" + text + \")\"), typeof reviver == \"function\" ? walk({ \"\": j }, \"\") : j;\n      throw new SyntaxError(\"JSON.parse\");\n    });\n  }()), json2$1;\n}\nvar json2 = json2Plugin;\nfunction json2Plugin() {\n  return requireJson2(), {};\n}\nvar engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);\n/*!\ndevtools-detect\nhttps://github.com/sindresorhus/devtools-detect\nBy Sindre Sorhus\nMIT License\n*/\nconst devtools = {\n  isOpen: !1,\n  orientation: void 0\n}, threshold = 160, emitEvent = (r, t) => {\n  globalThis.dispatchEvent(new globalThis.CustomEvent(\"devtoolschange\", {\n    detail: {\n      isOpen: r,\n      orientation: t\n    }\n  }));\n}, main = ({ emitEvents: r = !0 } = {}) => {\n  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, o = t ? \"vertical\" : \"horizontal\";\n  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== o) && r && emitEvent(!0, o), devtools.isOpen = !0, devtools.orientation = o) : (devtools.isOpen && r && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);\n};\nmain({ emitEvents: !1 });\nsetInterval(main, 500);\nvar Oa, Vu, Ii, Xu;\nclass SysWeb extends SysBase {\n  constructor(e = {}, o = { cur: \"prj/\", crypto: !1, dip: \"\" }) {\n    super(e, o);\n    rt(this, Oa, \"\");\n    rt(this, Vu, \":\");\n    Pt(this, \"run\", async () => {\n      H(this, Ii) && (H(this, Ii).destroy(10), await new Promise((o) => setTimeout(o, 10))), nt(this, Ii, new Main(this));\n    });\n    rt(this, Ii, void 0);\n    Pt(this, \"pathBaseCnvSnPath4Dbg\", \"${pathbase}/\");\n    Pt(this, \"_export\", () => ((async () => {\n      const e = JSON.stringify({\n        sys: this.data.sys,\n        mark: this.data.mark,\n        kidoku: this.data.kidoku\n      }), o = this.crypto ? await this.enc(e) : e, T = new Blob([o], { type: \"text/json\" }), S = document.createElement(\"a\");\n      S.href = URL.createObjectURL(T), S.download = (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + getDateStr(\"-\", \"_\", \"\") + \".swpd\", S.click(), CmnLib.debugLog && console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A8\\u30AF\\u30B9\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\"), setTimeout(() => this.fire(\"sn:exported\", new Event(\"click\")), 10);\n    })(), !1));\n    Pt(this, \"_import\", () => (new Promise((e, o) => {\n      const T = document.createElement(\"input\");\n      T.type = \"file\", T.accept = \".swpd, text/plain\", T.onchange = () => {\n        T.files ? e(T.files[0].path) : o();\n      }, T.click();\n    }).then((e) => new Promise((o) => {\n      const T = new FileReader();\n      T.readAsText(e), T.onload = () => o(T.result);\n    })).then(async (e) => {\n      const o = JSON.parse(this.crypto ? this.decStr(\"json\", e) : e);\n      if (!o.sys || !o.mark || !o.kidoku)\n        throw new Error(\"\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059\");\n      if (o.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {\n        console.error(`\\u5225\\u306E\\u30B2\\u30FC\\u30E0\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u540D=${o.sys[SysBase.VALNM_CFG_NS]}\\u3011\\u306E\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059`);\n        return;\n      }\n      this.data.sys = o.sys, this.data.mark = o.mark, this.data.kidoku = o.kidoku, this.flush(), this.val.updateData(o), CmnLib.debugLog && console.log(\"\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3092\\u30A4\\u30F3\\u30DD\\u30FC\\u30C8\\u3057\\u307E\\u3057\\u305F\"), this.fire(\"sn:imported\", new Event(\"click\"));\n    }).catch((e) => console.error(`\\u7570\\u5E38\\u306A\\u30D7\\u30EC\\u30A4\\u30C7\\u30FC\\u30BF\\u3067\\u3059 ${e.message}`)), !1));\n    Pt(this, \"navigate_to\", (e) => {\n      const { url: o } = e;\n      if (!o)\n        throw \"[navigate_to] url\\u306F\\u5FC5\\u9808\\u3067\\u3059\";\n      return globalThis.open(o, \"_blank\"), !1;\n    });\n    rt(this, Xu, {});\n    const T = o.cur.split(\"/\");\n    nt(this, Oa, T.length > 2 ? T.slice(0, -2).join(\"/\") + \"/\" : \"\"), globalThis.onload = async () => this.loaded(e, o);\n  }\n  async loaded(e, o) {\n    await super.loaded(e, o), document.querySelectorAll(\"[data-prj]\").forEach((D) => {\n      const B = D.attributes.getNamedItem(\"data-prj\");\n      B && this.elc.add(D, \"click\", () => this.runSN(B.value), { passive: !0 });\n    }), document.querySelectorAll(\"[data-reload]\").forEach(\n      (D) => this.elc.add(D, \"click\", () => this.run(), { passive: !0 })\n    ), o.dip && (CmnLib.hDip = JSON.parse(o.dip));\n    const T = new URLSearchParams(location.search), S = T.get(\"dip\");\n    if (S && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(S.replaceAll(\"%2C\", \",\")) }), !argChk_Boolean(CmnLib.hDip, \"oninit_run\", !0))\n      return;\n    argChk_Boolean(CmnLib.hDip, \"dbg\", !1) && (CmnLib.isDbg = !0, this.fetch = (D) => fetch(D, { mode: \"cors\" })), this.extPort = argChk_Num(CmnLib.hDip, \"port\", this.extPort);\n    const N = T.get(\"cur\");\n    N && (o.cur = H(this, Oa) + N + \"/\"), this.run();\n  }\n  runSN(e) {\n    this.arg.cur = H(this, Oa) + e + \"/\", H(this, Vu) !== this.arg.cur && (nt(this, Vu, this.arg.cur), this.run());\n  }\n  stop() {\n    !H(this, Ii) || (H(this, Ii).destroy(), nt(this, Ii, void 0));\n  }\n  async loadPath(e, o) {\n    await super.loadPath(e, o);\n    const T = this.arg.cur + \"path.json\", S = await fetch(T);\n    if (!S.ok)\n      throw Error(S.statusText);\n    const N = await S.text(), D = JSON.parse(this.decStr(T, N));\n    for (const [B, $] of Object.entries(D)) {\n      const U = e[B] = $;\n      for (const [z, V] of Object.entries(U))\n        z !== \":cnt\" && (U[z] = this.arg.cur + V);\n    }\n  }\n  initVal(e, o, T) {\n    const S = encodeURIComponent(document.location.hostname);\n    o[\"const.sn.isDebugger\"] = S === \"localhost\" || S === \"127.0.0.1\";\n    const N = this.cfg.getNs();\n    this.flush = this.crypto ? async () => {\n      store_legacy.set(N + \"sys_\", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(N + \"mark_\", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(N + \"kidoku_\", this.enc(JSON.stringify(this.data.kidoku)));\n    } : () => {\n      store_legacy.set(N + \"sys\", this.data.sys), store_legacy.set(N + \"mark\", this.data.mark), store_legacy.set(N + \"kidoku\", this.data.kidoku);\n    };\n    const D = N + (this.arg.crypto ? \"sys_\" : \"sys\");\n    if (o[\"const.sn.isFirstBoot\"] = store_legacy.get(D) === void 0) {\n      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), T(this.data);\n      return;\n    }\n    if (!this.crypto) {\n      this.data.sys = store_legacy.get(N + \"sys\"), this.data.mark = store_legacy.get(N + \"mark\"), this.data.kidoku = store_legacy.get(N + \"kidoku\"), T(this.data);\n      return;\n    }\n    let B = \"\";\n    try {\n      B = \"sys\", this.data.sys = JSON.parse(this.decStr(\"json\", store_legacy.get(N + \"sys_\"))), B += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), B = \"mark\", this.data.mark = JSON.parse(this.decStr(\"json\", store_legacy.get(N + \"mark_\"))), B = \"kidoku\", this.data.kidoku = JSON.parse(this.decStr(\"json\", store_legacy.get(N + \"kidoku_\")));\n    } catch ($) {\n      console.error(`\\u30BB\\u30FC\\u30D6\\u30C7\\u30FC\\u30BF\\uFF08${B}\\uFF09\\u304C\\u58CA\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u4E00\\u5EA6\\u30AF\\u30EA\\u30A2\\u3059\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059 %o`, $);\n    }\n    T(this.data);\n  }\n  init(e, o, T, S) {\n    super.init(e, o, T, S);\n    const N = o.view.parentElement;\n    if (\"requestFullscreen\" in document.body)\n      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : N.requestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = Boolean(document.fullscreenElement));\n    else {\n      const D = document;\n      this.tglFlscr_sub = () => this.isFullScr ? D.webkitCancelFullScreen() : N.webkitRequestFullscreen(), this.elc.add(document, \"fullscreenchange\", () => this.isFullScr = Boolean(D.webkitFullscreenElement));\n    }\n    return this.cfg.oCfg.debug.devtool || this.elc.add(window, \"devtoolschange\", (D) => {\n      !D.detail.isOpen || (console.error(\"DevTool\\u306F\\u7981\\u6B62\\u3055\\u308C\\u3066\\u3044\\u307E\\u3059\\u3002\\u8A31\\u53EF\\u3059\\u308B\\u5834\\u5408\\u306F\\u3010\\u30D7\\u30ED\\u30B8\\u30A7\\u30AF\\u30C8\\u8A2D\\u5B9A\\u3011\\u306E\\u3010devtool\\u3011\\u3092ON\\u306B\\u3002\"), S.destroy());\n    }, { once: !0, passive: !0 }), [];\n  }\n  cvsResize() {\n    if (super.cvsResize(), this.isFullScr) {\n      const e = this.appPixi.view.style;\n      e.width = e.height = \"\";\n    }\n  }\n  titleSub(e) {\n    document.title = e, document.querySelectorAll(\"[data-title]\").forEach((o) => o.textContent = e);\n  }\n  async savePic(e, o) {\n    const T = document.createElement(\"a\");\n    T.href = o, T.download = e, T.click(), CmnLib.debugLog && console.log(\"\\u753B\\u50CF\\u30D5\\u30A1\\u30A4\\u30EB\\u3092\\u30C0\\u30A6\\u30F3\\u30ED\\u30FC\\u30C9\\u3057\\u307E\\u3059\");\n  }\n  async appendFile(e, o, T) {\n    var B;\n    const S = ((B = H(this, Xu)[e]) != null ? B : \"\") + o;\n    H(this, Xu)[e] = S;\n    const N = new Blob([S], { type: \"text/json\" }), D = document.createElement(\"a\");\n    D.href = URL.createObjectURL(N), D.download = e, D.click();\n  }\n}\nOa = new WeakMap(), Vu = new WeakMap(), Ii = new WeakMap(), Xu = new WeakMap();\n\n//# sourceMappingURL=web.js.map\n\n\n//# sourceURL=webpack://gallery/../skynovel/dist/web.js?");

/***/ }),

/***/ "./core/plugin.js":
/*!************************!*\
  !*** ./core/plugin.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"3d_layer\":0,\"cubism3_layer\":0,\"emote_layer\":0});\n\n//# sourceURL=webpack://gallery/./core/plugin.js?");

/***/ }),

/***/ "./core/plugin/3d_layer/ThreeDLayer.js":
/*!*********************************************!*\
  !*** ./core/plugin/3d_layer/ThreeDLayer.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThreeDLayer = void 0;\nconst { Layer, CmnLib, argChk_Num, argChk_Boolean } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"./node_modules/three/build/three.cjs\");\nconst OrbitControls_1 = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\nconst GLTFLoader_1 = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nconst EXT_STILL_IMG = 'png_|jpg_|jpeg_|svg_|png|jpg|jpeg|svg';\nclass ThreeDLayer extends Layer {\n    constructor(pia) {\n        super();\n        this.pia = pia;\n        this.tick = () => {\n            if (!this.running)\n                return;\n            this.canvas_3D.render(this.scene_3D, this.camera);\n            this.sprite_3D.texture.update();\n            this.tickUpdEff();\n            this.fncCtrl();\n            this.fncMixerUpd();\n            requestAnimationFrame(this.tick);\n        };\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.clock = new three_1.Clock();\n        this.hEff = {};\n        this.tickUpdEff = () => { };\n        this.hInf = {};\n        this.record = () => Object.assign(super.record(), {\n            hInf: this.hInf,\n        });\n        if (ThreeDLayer.uniq_num++ % 2 == 1)\n            return;\n        this.scene_3D = new three_1.Scene();\n        this.canvas_3D = new three_1.WebGLRenderer({ antialias: true, alpha: true });\n        this.canvas_3D.setSize(CmnLib.stageW, CmnLib.stageH);\n        this.canvas_3D.setPixelRatio(window.devicePixelRatio);\n        const texture_3D = pixi_js_1.Texture.from(this.canvas_3D.domElement);\n        this.sprite_3D = new pixi_js_1.Sprite(texture_3D);\n        this.spLay.addChild(this.sprite_3D);\n        this.sprite_3D.x = (CmnLib.stageW - this.sprite_3D.width) / 2;\n        this.sprite_3D.y = (CmnLib.stageH - this.sprite_3D.height) / 2;\n    }\n    static async init() { globalThis.THREE ??= await Promise.resolve().then(() => __importStar(__webpack_require__(/*! three */ \"./node_modules/three/build/three.cjs\"))); }\n    lay(hArg) {\n        if (!this.scene_3D)\n            return false;\n        if ('grid' in hArg) {\n            const grid = new three_1.GridHelper(argChk_Num(hArg, 'grid_size', 10), argChk_Num(hArg, 'grid_step', 5));\n            this.csv2pos(hArg, 'grid', grid);\n            grid.name = '_grid';\n            this.scene_3D.add(grid);\n        }\n        if ('camera' in hArg) {\n            if (!this.camera) {\n                this.camera = new three_1.PerspectiveCamera(argChk_Num(hArg, 'camera_fov', 50), CmnLib.stageW / CmnLib.stageH, argChk_Num(hArg, 'camera_near', 0.1), argChk_Num(hArg, 'camera_far', 2000));\n            }\n            this.csv2pos(hArg, 'camera', this.camera);\n            if ('camera_target' in hArg) {\n                const [x, y, z] = String(hArg['camera_target']).split(',').map(v => Number(v));\n                this.camera.lookAt(new three_1.Vector3(x, y, z));\n            }\n        }\n        if ('directional_light' in hArg) {\n            const light = new three_1.DirectionalLight(0xFFFFFF);\n            light.intensity = argChk_Num(hArg, 'intensity', 1);\n            this.csv2pos(hArg, 'directional_light', light);\n            light.name = '_light';\n            this.scene_3D.add(light);\n        }\n        if ('controls' in hArg) {\n            const elm = document.getElementById('skynovel');\n            if (!elm)\n                return false;\n            const controls = new OrbitControls_1.OrbitControls(this.camera, elm);\n            controls.target.set(this.camera.position.x + 0.15, this.camera.position.y, this.camera.position.z);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.2;\n            controls.rotateSpeed = 0.1;\n            controls.zoomSpeed = 2;\n            this.fncCtrl = () => controls.update();\n        }\n        const type = hArg.type;\n        const name = hArg.name || '';\n        let mdl = new three_1.Mesh();\n        if (type) {\n            if (name in this.hInf)\n                throw `name=${name}`;\n            if (!this.running) {\n                this.running = true;\n                this.tick();\n            }\n            if (type == 'box') {\n                const size = argChk_Num(hArg, 'size', 100);\n                const geometry = new three_1.BoxGeometry(size, size, size);\n                const material = new three_1.MeshNormalMaterial();\n                mdl = new three_1.Mesh(geometry, material);\n                mdl.rotation.z = -45;\n                this.fncCtrl = () => this.scene_3D.children.forEach(o => {\n                    const m = o;\n                    if (!m)\n                        return;\n                    m.rotation.x += 0.01;\n                    m.rotation.y += 0.01;\n                    m.rotation.z += 0.01;\n                });\n                this.hInf[name] = { type: type, fn: '' };\n            }\n            else {\n                const fn = hArg.fn;\n                if (!fn)\n                    throw 'fn';\n                switch (type) {\n                    case 'eff':\n                        {\n                            const fncEff = () => {\n                                this.hEff[fn] = this.ctxEff.loadEffect(this.pia.searchPath(fn, 'efk'), argChk_Num(hArg, 'scale', 1), () => {\n                                    const [x, y, z] = String(hArg.pos || '0,0,0').split(',');\n                                    const h = this.ctxEff.play(this.hEff[fn], parseInt(x), parseInt(y), parseInt(z));\n                                    this.hInf[name] = { type: type, fn: fn, effhdl: h };\n                                }, (m, url) => console.error(m + ' url=' + url));\n                            };\n                            if (this.ctxEff) {\n                                fncEff();\n                                break;\n                            }\n                            effekseer.initRuntime('./effekseer.wasm', () => {\n                                this.ctxEff = effekseer.createContext();\n                                this.ctxEff.init(this.canvas_3D.getContext());\n                                const clock = new three_1.Clock();\n                                this.tickUpdEff = () => {\n                                    this.ctxEff.update(clock.getDelta() * 60.0);\n                                    this.ctxEff.setProjectionMatrix(Float32Array.from(this.camera.projectionMatrix.elements));\n                                    this.ctxEff.setCameraMatrix(Float32Array.from(this.camera.matrixWorldInverse.elements));\n                                    this.ctxEff.draw();\n                                };\n                            }, () => { });\n                        }\n                        break;\n                    case 'celestial_sphere':\n                        {\n                            const geometry = new three_1.SphereGeometry(5, 60, 40);\n                            geometry.scale(-1, 1, 1);\n                            const ldr = new three_1.TextureLoader();\n                            if (!fn)\n                                throw 'fn';\n                            const tx = ldr.load(this.pia.searchPath(fn, EXT_STILL_IMG));\n                            tx.minFilter = three_1.LinearFilter;\n                            const material = new three_1.MeshBasicMaterial({ map: tx });\n                            mdl = new three_1.Mesh(geometry, material);\n                            this.camera.lookAt(mdl.position);\n                            this.fncCtrl = () => { mdl.rotation.y += 0.001; };\n                        }\n                        break;\n                    case 'gltf':\n                        {\n                            const onProgress = ('debug' in hArg)\n                                ? (xhr) => console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`)\n                                : () => { };\n                            (new GLTFLoader_1.GLTFLoader()).load(this.pia.searchPath(fn, 'gltf|glb'), (gltf) => {\n                                const mdl = gltf.scene;\n                                mdl.name = name;\n                                this.scene_3D.add(mdl);\n                                this.hInf[name] = { type: type, fn: fn, gltf: gltf };\n                                this.arg2mdl(hArg, mdl);\n                            }, onProgress, (e) => console.error('An error happened', e));\n                        }\n                        return false;\n                    default:\n                        throw ` type=${type} `;\n                }\n                this.hInf[name] = { type: type, fn: fn };\n            }\n            mdl.name = name;\n            this.scene_3D.add(mdl);\n        }\n        else if ('del' in hArg) {\n            const del = hArg['del'];\n            if (!del)\n                return false;\n            const mdl2 = this.scene_3D.children.find(e => e.name === del);\n            if (!mdl2)\n                return false;\n            this.clearObject3D(mdl2);\n            delete this.hInf[del];\n            return false;\n        }\n        else if ('name' in hArg) {\n            const mdl2 = this.scene_3D.children.find(e => e.name === name);\n            if (!mdl2)\n                throw ` name=${name} `;\n            mdl = mdl2;\n        }\n        else\n            return false;\n        this.arg2mdl(hArg, mdl);\n        return false;\n    }\n    arg2mdl(hArg, o) {\n        this.csv2pos(hArg, 'pos', o);\n        this.csv2scale(hArg, 'scale', o);\n        const inf = this.hInf[o.name];\n        if (!inf)\n            return;\n        if ('label' in hArg) {\n            inf.label = hArg['label'];\n            if (inf.gltf) {\n                const ac = three_1.AnimationClip.findByName(inf.gltf.animations, inf.label || '');\n                if (!ac) {\n                    console.info(` ${inf.fn}(glTF)`);\n                    const a = inf.gltf.animations;\n                    a.map(v => console.info(`  label=${v.name}`));\n                    throw `${inf.fn}(glTF)label=${inf.label}`;\n                }\n                if (inf.mixer) {\n                    const t = argChk_Num(hArg, 'time', 1000) / 1000;\n                    const aa = inf.mixer.clipAction(ac);\n                    aa.crossFadeFrom(inf.aa, t, true);\n                    inf.aa = aa;\n                }\n                else {\n                    inf.mixer = new three_1.AnimationMixer(o);\n                    inf.aa = inf.mixer.clipAction(ac);\n                    this.fncMixerUpd = () => {\n                        this.scene_3D.children.map(v => {\n                            const inf2 = this.hInf[v.name];\n                            if (inf2)\n                                inf2.mixer.update(this.clock.getDelta());\n                        });\n                    };\n                }\n                inf.aa.enabled = true;\n                inf.aa.clampWhenFinished = true;\n                inf.aa.loop = argChk_Boolean(hArg, 'loop', true)\n                    ? three_1.LoopRepeat\n                    : three_1.LoopOnce;\n                inf.aa.play();\n            }\n        }\n    }\n    csv2pos(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const [x, y, z] = String(hArg[name]).split(',').map(v => Number(v));\n        o.position.set(x, y, z);\n    }\n    csv2scale(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const [x, y, z] = String(hArg[name]).split(',').map(v => Number(v));\n        o.scale.set(x, y, z);\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (!this.scene_3D)\n            return;\n        if (!this.running)\n            return;\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.hInf = {};\n        this.clearScene(this.scene_3D);\n        this.canvas_3D.clear();\n        this.sprite_3D.texture.update();\n    }\n    clearScene(sc) {\n        sc.children.slice().map(o => this.clearObject3D(o));\n    }\n    clearObject3D(o) {\n        o.parent.remove(o);\n        const s = o;\n        if (s) {\n            const inf = this.hInf[s.name];\n            if (inf && inf.mixer)\n                inf.mixer.stopAllAction();\n            this.clearScene(s);\n            return;\n        }\n        const m = o;\n        if (!m)\n            return;\n        m.geometry.dispose();\n        if (m.material instanceof three_1.Material) {\n            m.material.dispose();\n            if (m.material)\n                m.material = [];\n        }\n        else {\n            m.material.map(v => v.dispose());\n        }\n    }\n    playback(hLay, aPrm) {\n        super.playback(hLay, aPrm);\n        this.hInf = hLay.hInf;\n        if (!this.scene_3D)\n            return;\n    }\n    dump() {\n        if (!this.scene_3D)\n            return `\"is\":\"nothing\"`;\n        const aChi = [];\n        this.scene_3D.children.map(o => {\n            let s = `\"${o.name}\": {\"type\":\"${o.type}\"`;\n            const inf = this.hInf[o.name];\n            if (inf && inf.mixer)\n                s += `, \"label\":\"${inf.label}\"`;\n            aChi.push(s + `}`);\n        });\n        return super.dump() + `, \"mdl\":{${aChi.join(',')}}`;\n    }\n}\nexports.ThreeDLayer = ThreeDLayer;\nThreeDLayer.uniq_num = 0;\n//# sourceMappingURL=ThreeDLayer.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/ThreeDLayer.js?");

/***/ }),

/***/ "./core/plugin/3d_layer/index.js":
/*!***************************************!*\
  !*** ./core/plugin/3d_layer/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst ThreeDLayer_1 = __webpack_require__(/*! ./ThreeDLayer */ \"./core/plugin/3d_layer/ThreeDLayer.ts\");\nasync function init(pia) {\n    pia.addLayCls('3d', () => new ThreeDLayer_1.ThreeDLayer(pia));\n    return ThreeDLayer_1.ThreeDLayer.init();\n}\nexports.init = init;\n;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/index.js?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/Cubism3Layer.js":
/*!***************************************************!*\
  !*** ./core/plugin/cubism3_layer/Cubism3Layer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cubism3Layer = void 0;\nconst { Layer, argChk_Num } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nclass Cubism3Layer extends Layer {\n    constructor() {\n        super(...arguments);\n        this.ldr = new pixi_js_1.Loader;\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n        this.hdl_tick = 0;\n        this.record = () => Object.assign(super.record(), this.state);\n    }\n    lay(hArg, fncComp) {\n        super.lay(hArg);\n        const id = hArg.id || '0';\n        const fn = hArg.fn;\n        if (fn) {\n            const label = hArg.label;\n            if (!label)\n                throw `labeljson${fn}_(label).json`;\n            let needLoad = false;\n            ['moc', 'tex', 'mot'].map((type, i) => {\n                const rn = `l2d:${fn}_${type}`;\n                if (rn in this.ldr.resources)\n                    return;\n                if (rn in pixi_js_1.utils.TextureCache)\n                    pixi_js_1.utils.TextureCache[rn].destroy(true);\n                needLoad = true;\n                if (this.ldr.loading)\n                    this.ldr = new pixi_js_1.Loader();\n                switch (i) {\n                    case 0:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn, 'moc3_|moc3'),\n                            xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n                        });\n                        break;\n                    case 1:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn, 'png_|png|jpg_|jpg|jpeg_|jpeg'),\n                        });\n                        break;\n                    case 2:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn + '_' + label, 'json_|json'),\n                            xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.JSON,\n                        });\n                        break;\n                }\n            });\n            const fncLoaded = (res) => {\n                const moc = Live2DCubismCore.Moc.fromArrayBuffer(res['l2d:' + fn + '_moc'].data);\n                this.model = new LIVE2DCUBISMPIXI.ModelBuilder()\n                    .setMoc(moc)\n                    .setTimeScale(1)\n                    .addTexture(0, (res['l2d:' + fn + '_tex'] || pixi_js_1.utils.TextureCache['l2d:' + fn + '_tex']).texture)\n                    .addAnimatorLayer(id, LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE, 1)\n                    .build();\n                this.spLay.addChild(this.model);\n                const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                this.model.animator\n                    .getLayer(id)\n                    .play(ani);\n                const tick = () => {\n                    this.hdl_tick = requestAnimationFrame(tick);\n                    if (this.model)\n                        this.model.update(1);\n                };\n                this.hdl_tick = requestAnimationFrame(tick);\n                const a = { ...hArg };\n                delete a.fn;\n                delete a.label;\n                this.state.fn = fn;\n                this.state.label = label;\n                this.lay(a, fncComp);\n                Cubism3Layer.pia.resume(fncComp);\n            };\n            if (needLoad)\n                this.ldr.load((_loader, res) => fncLoaded(res));\n            else\n                fncLoaded(this.ldr.resources);\n            return true;\n        }\n        if (!this.state.fn)\n            return false;\n        if ('label' in hArg) {\n            const label = hArg.label || '';\n            if (this.state.label != label) {\n                this.state.label = label;\n                const fn = this.state.fn;\n                const fn_mot = Cubism3Layer.pia.searchPath(fn + '_' + label, 'json_|json');\n                new pixi_js_1.Loader()\n                    .add({ name: 'l2d:' + fn + '_mot', url: fn_mot, xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.JSON })\n                    .load((_loader, res) => {\n                    const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                    this.model.animator\n                        .getLayer(id)\n                        .play(ani);\n                });\n            }\n        }\n        if ('scale' in hArg) {\n            this.state.scale = argChk_Num(hArg, 'scale', 1);\n            this.model.scale = new pixi_js_1.Point(this.state.scale, this.state.scale);\n            this.model.x = this.model.width / 2;\n            this.model.y = this.model.height / 2;\n        }\n        Layer.setXY(this.model, hArg, this.spLay, true);\n        return false;\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (this.model) {\n            cancelAnimationFrame(this.hdl_tick);\n            this.spLay.removeChild(this.model);\n            this.model = null;\n        }\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        return this.lay(hLay, fncComp);\n    }\n    destroy() { this.clearLay({}); }\n}\nexports.Cubism3Layer = Cubism3Layer;\n//# sourceMappingURL=Cubism3Layer.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/Cubism3Layer.js?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/index.js":
/*!********************************************!*\
  !*** ./core/plugin/cubism3_layer/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst Cubism3Layer_1 = __webpack_require__(/*! ./Cubism3Layer */ \"./core/plugin/cubism3_layer/Cubism3Layer.ts\");\nasync function init(pia) {\n    pia.addLayCls('cubism3', () => new Cubism3Layer_1.Cubism3Layer);\n}\nexports.init = init;\n;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/index.js?");

/***/ }),

/***/ "./core/plugin/emote_layer/EmoteLayer.js":
/*!***********************************************!*\
  !*** ./core/plugin/emote_layer/EmoteLayer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmoteLayer = void 0;\nconst { Layer, CmnLib, argChk_Num } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nclass EmoteLayer extends Layer {\n    constructor(pia) {\n        super();\n        this.pia = pia;\n        this.sp = new pixi_js_1.Sprite;\n        this.record = () => Object.assign(super.record(), (this.inf)\n            ? {\n                fn: this.inf.fn,\n                label: this.inf.player.mainTimelineLabel,\n                scale: this.inf.player.scale,\n                grayscale: this.inf.player.grayscale,\n                windSpeed: this.inf.player.windSpeed,\n                windPowerMin: this.inf.player.windPowerMin,\n                windPowerMax: this.inf.player.windPowerMax,\n            }\n            : { fn: '' });\n        if (EmoteLayer.uniq_num++ % 2 === 1)\n            return;\n        if (EmoteLayer.uniq_num === 1) {\n            switch (String(this.pia.getVal('const.sn.platform.os.family'))) {\n                case 'Android':\n                case 'iOS':\n                    EmotePlayer.maskMode = EmotePlayer.MaskMode.STENCIL;\n                    break;\n            }\n            EmotePlayer.createRenderCanvas(CmnLib.stageW, CmnLib.stageH);\n        }\n        this.rt = pixi_js_1.RenderTexture.create({ width: CmnLib.stageW, height: CmnLib.stageH });\n        this.spLay.addChild(new pixi_js_1.Sprite(this.rt));\n        this.cvs = document.createElement('canvas');\n        this.cvs.id = `emote:${EmoteLayer.uniq_num}`;\n        this.cvs.width = CmnLib.stageW;\n        this.cvs.height = CmnLib.stageH;\n        this.cvs.hidden = true;\n        const cvsSN = document.getElementById('skynovel');\n        cvsSN.parentElement.appendChild(this.cvs);\n        this.sp.width = CmnLib.stageW;\n        this.sp.height = CmnLib.stageH;\n    }\n    lay(hArg, fncComp) {\n        if (!this.rt)\n            return false;\n        const layer = hArg.layer;\n        if (!layer) {\n            if (hArg[':'] === 'add_lay')\n                return false;\n            throw `layer`;\n        }\n        super.lay(hArg);\n        if (hArg.fn) {\n            const fn = hArg.fn;\n            const player = new EmotePlayer(this.cvs);\n            this.inf = {\n                fn: fn,\n                player: player,\n            };\n            const a = { ...hArg };\n            delete a.fn;\n            a[':'] = 'lay';\n            player.onUpdate = () => {\n                if (!player)\n                    return;\n                this.sp.texture.destroy();\n                this.sp.texture = new pixi_js_1.Texture(new pixi_js_1.BaseTexture(this.cvs));\n                this.pia.render(this.sp, this.rt, true);\n            };\n            player.promiseLoadDataFromURL(this.pia.searchPath(fn, 'emtbytes_|emtbytes'))\n                .then(() => {\n                this.lay(a, fncComp);\n                this.pia.resume(fncComp);\n            });\n            return true;\n        }\n        else if (hArg[':'] === 'add_lay')\n            return false;\n        if (!this.inf)\n            return false;\n        Layer.setXY(this.sp, hArg, this.spLay, true);\n        const player = this.inf.player;\n        if (hArg.label) {\n            const a = [...player.mainTimelineLabels, ...player.diffTimelineLabels];\n            if (!a.includes(hArg.label)) {\n                console.error(` ${this.inf.fn}.emtbytes `);\n                a.forEach(v => console.info(`  label=${v}`));\n                throw `${this.inf.fn}.emtbytes label=${hArg.label}`;\n            }\n            player.mainTimelineLabel = hArg.label;\n        }\n        if ('scale' in hArg)\n            player.scale = argChk_Num(hArg, 'scale', 1);\n        if ('grayscale' in hArg)\n            player.grayscale = argChk_Num(hArg, 'grayscale', 1);\n        if ('windSpeed' in hArg)\n            player.windSpeed = argChk_Num(hArg, 'windSpeed', 0);\n        if ('windPowerMin' in hArg)\n            player.windPowerMin = argChk_Num(hArg, 'windPowerMin', 0);\n        if ('windPowerMax' in hArg)\n            player.windPowerMax = argChk_Num(hArg, 'windPowerMax', 0);\n        return false;\n    }\n    clearLay(hArg) {\n        if (!this.rt)\n            return;\n        super.clearLay(hArg);\n        if (!this.inf)\n            return;\n        this.inf.player.onUpdate = () => { };\n        this.inf.player.unloadData();\n        this.inf = null;\n        this.sp.visible = false;\n        this.pia.render(this.sp, this.rt, true);\n        this.sp.visible = true;\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        if (hLay.fn)\n            return this.lay(hLay, fncComp);\n        this.clearLay(hLay);\n        return false;\n    }\n    dump() {\n        if (!this.rt)\n            return `\"is\":\"nothing\"`;\n        return super.dump() + ((this.inf)\n            ? `, \"mdl\":{\"fn\":\"${this.inf.fn}\",\"label\":\"${this.inf.player.mainTimelineLabel}\",\"scale\":\"${this.inf.player.scale}\"}`\n            : `, \"mdl\":{\"fn\":\"\"}`);\n    }\n    ;\n    destroy() {\n        if (!this.rt)\n            return;\n        this.clearLay({});\n        this.cvs.parentElement.removeChild(this.cvs);\n        this.spLay.removeChildren().forEach((v) => v.destroy());\n    }\n}\nexports.EmoteLayer = EmoteLayer;\nEmoteLayer.uniq_num = 0;\n//# sourceMappingURL=EmoteLayer.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/EmoteLayer.js?");

/***/ }),

/***/ "./core/plugin/emote_layer/index.js":
/*!******************************************!*\
  !*** ./core/plugin/emote_layer/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst EmoteLayer_1 = __webpack_require__(/*! ./EmoteLayer */ \"./core/plugin/emote_layer/EmoteLayer.ts\");\nasync function init(pia) {\n    pia.addLayCls('emote', () => new EmoteLayer_1.EmoteLayer(pia));\n}\nexports.init = init;\n;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/index.js?");

/***/ }),

/***/ "./core/plugin sync recursive ^\\.\\/.*$":
/*!************************************!*\
  !*** ./core/plugin/ sync ^\.\/.*$ ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./3d_layer\": \"./core/plugin/3d_layer/index.ts\",\n\t\"./3d_layer/\": \"./core/plugin/3d_layer/index.ts\",\n\t\"./3d_layer/ThreeDLayer\": \"./core/plugin/3d_layer/ThreeDLayer.ts\",\n\t\"./3d_layer/ThreeDLayer.js\": \"./core/plugin/3d_layer/ThreeDLayer.js\",\n\t\"./3d_layer/ThreeDLayer.js.map\": \"./core/plugin/3d_layer/ThreeDLayer.js.map\",\n\t\"./3d_layer/ThreeDLayer.ts\": \"./core/plugin/3d_layer/ThreeDLayer.ts\",\n\t\"./3d_layer/effekseer.d\": \"./core/plugin/3d_layer/effekseer.d.ts\",\n\t\"./3d_layer/effekseer.d.ts\": \"./core/plugin/3d_layer/effekseer.d.ts\",\n\t\"./3d_layer/index\": \"./core/plugin/3d_layer/index.ts\",\n\t\"./3d_layer/index.d\": \"./core/plugin/3d_layer/index.d.ts\",\n\t\"./3d_layer/index.d.ts\": \"./core/plugin/3d_layer/index.d.ts\",\n\t\"./3d_layer/index.d.ts.map\": \"./core/plugin/3d_layer/index.d.ts.map\",\n\t\"./3d_layer/index.js\": \"./core/plugin/3d_layer/index.js\",\n\t\"./3d_layer/index.js.map\": \"./core/plugin/3d_layer/index.js.map\",\n\t\"./3d_layer/index.ts\": \"./core/plugin/3d_layer/index.ts\",\n\t\"./cubism3_layer\": \"./core/plugin/cubism3_layer/index.ts\",\n\t\"./cubism3_layer/\": \"./core/plugin/cubism3_layer/index.ts\",\n\t\"./cubism3_layer/Cubism3Layer\": \"./core/plugin/cubism3_layer/Cubism3Layer.ts\",\n\t\"./cubism3_layer/Cubism3Layer.js\": \"./core/plugin/cubism3_layer/Cubism3Layer.js\",\n\t\"./cubism3_layer/Cubism3Layer.js.map\": \"./core/plugin/cubism3_layer/Cubism3Layer.js.map\",\n\t\"./cubism3_layer/Cubism3Layer.ts\": \"./core/plugin/cubism3_layer/Cubism3Layer.ts\",\n\t\"./cubism3_layer/index\": \"./core/plugin/cubism3_layer/index.ts\",\n\t\"./cubism3_layer/index.d\": \"./core/plugin/cubism3_layer/index.d.ts\",\n\t\"./cubism3_layer/index.d.ts\": \"./core/plugin/cubism3_layer/index.d.ts\",\n\t\"./cubism3_layer/index.d.ts.map\": \"./core/plugin/cubism3_layer/index.d.ts.map\",\n\t\"./cubism3_layer/index.js\": \"./core/plugin/cubism3_layer/index.js\",\n\t\"./cubism3_layer/index.js.map\": \"./core/plugin/cubism3_layer/index.js.map\",\n\t\"./cubism3_layer/index.ts\": \"./core/plugin/cubism3_layer/index.ts\",\n\t\"./emote_layer\": \"./core/plugin/emote_layer/index.ts\",\n\t\"./emote_layer/\": \"./core/plugin/emote_layer/index.ts\",\n\t\"./emote_layer/EmoteLayer\": \"./core/plugin/emote_layer/EmoteLayer.ts\",\n\t\"./emote_layer/EmoteLayer.js\": \"./core/plugin/emote_layer/EmoteLayer.js\",\n\t\"./emote_layer/EmoteLayer.js.map\": \"./core/plugin/emote_layer/EmoteLayer.js.map\",\n\t\"./emote_layer/EmoteLayer.ts\": \"./core/plugin/emote_layer/EmoteLayer.ts\",\n\t\"./emote_layer/index\": \"./core/plugin/emote_layer/index.ts\",\n\t\"./emote_layer/index.d\": \"./core/plugin/emote_layer/index.d.ts\",\n\t\"./emote_layer/index.d.ts\": \"./core/plugin/emote_layer/index.d.ts\",\n\t\"./emote_layer/index.d.ts.map\": \"./core/plugin/emote_layer/index.d.ts.map\",\n\t\"./emote_layer/index.js\": \"./core/plugin/emote_layer/index.js\",\n\t\"./emote_layer/index.js.map\": \"./core/plugin/emote_layer/index.js.map\",\n\t\"./emote_layer/index.ts\": \"./core/plugin/emote_layer/index.ts\",\n\t\"./emote_layer/.txt\": \"./core/plugin/emote_layer/.txt\",\n\t\"./pass\": \"./core/plugin/pass.json\",\n\t\"./pass.json\": \"./core/plugin/pass.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./core/plugin sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://gallery/./core/plugin/_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./core/web4webpack.js":
/*!*****************************!*\
  !*** ./core/web4webpack.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.js */ \"./core/plugin.js\");\n/* harmony import */ var _famibee_skynovel_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\n\nObject.defineProperty(__webpack_exports__, \"__esModule\", ({ value: true }));\n// npm run webpack:dev\n\nconst hPlg = {};\n\nfor (const nm in _plugin_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) hPlg[nm] = __webpack_require__(\"./core/plugin sync recursive ^\\\\.\\\\/.*$\")(`./${nm}`);\n\nconst dip = {'expanding': false};\nlet pcur = 'prj/';\nif (location.pathname.slice(-15) == '/index_app.html') {\n\tpcur = '';\n\tdip['oninit_run'] = false;\n}\n\nconst sys = new _famibee_skynovel_web__WEBPACK_IMPORTED_MODULE_1__.SysWeb(hPlg, {cur: pcur +'top/', dip: JSON.stringify(dip)});\nglobalThis.runSN = (cur = pcur +'top')=> sys.runSN(cur);\nglobalThis.stopSN = ()=> sys.stop();\n\n\n//# sourceURL=webpack://gallery/./core/web4webpack.js?");

/***/ }),

/***/ "./core/plugin/3d_layer/ThreeDLayer.js.map":
/*!*************************************************!*\
  !*** ./core/plugin/3d_layer/ThreeDLayer.js.map ***!
  \*************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/ThreeDLayer.js.map?");

/***/ }),

/***/ "./core/plugin/3d_layer/effekseer.d.ts":
/*!*********************************************!*\
  !*** ./core/plugin/3d_layer/effekseer.d.ts ***!
  \*********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/effekseer.d.ts?");

/***/ }),

/***/ "./core/plugin/3d_layer/index.d.ts":
/*!*****************************************!*\
  !*** ./core/plugin/3d_layer/index.d.ts ***!
  \*****************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/index.d.ts?");

/***/ }),

/***/ "./core/plugin/3d_layer/index.d.ts.map":
/*!*********************************************!*\
  !*** ./core/plugin/3d_layer/index.d.ts.map ***!
  \*********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/index.d.ts.map?");

/***/ }),

/***/ "./core/plugin/3d_layer/index.js.map":
/*!*******************************************!*\
  !*** ./core/plugin/3d_layer/index.js.map ***!
  \*******************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/index.js.map?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/Cubism3Layer.js.map":
/*!*******************************************************!*\
  !*** ./core/plugin/cubism3_layer/Cubism3Layer.js.map ***!
  \*******************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/Cubism3Layer.js.map?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/index.d.ts":
/*!**********************************************!*\
  !*** ./core/plugin/cubism3_layer/index.d.ts ***!
  \**********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/index.d.ts?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/index.d.ts.map":
/*!**************************************************!*\
  !*** ./core/plugin/cubism3_layer/index.d.ts.map ***!
  \**************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/index.d.ts.map?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/index.js.map":
/*!************************************************!*\
  !*** ./core/plugin/cubism3_layer/index.js.map ***!
  \************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/index.js.map?");

/***/ }),

/***/ "./core/plugin/emote_layer/EmoteLayer.js.map":
/*!***************************************************!*\
  !*** ./core/plugin/emote_layer/EmoteLayer.js.map ***!
  \***************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/EmoteLayer.js.map?");

/***/ }),

/***/ "./core/plugin/emote_layer/index.d.ts":
/*!********************************************!*\
  !*** ./core/plugin/emote_layer/index.d.ts ***!
  \********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/index.d.ts?");

/***/ }),

/***/ "./core/plugin/emote_layer/index.d.ts.map":
/*!************************************************!*\
  !*** ./core/plugin/emote_layer/index.d.ts.map ***!
  \************************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/index.d.ts.map?");

/***/ }),

/***/ "./core/plugin/emote_layer/index.js.map":
/*!**********************************************!*\
  !*** ./core/plugin/emote_layer/index.js.map ***!
  \**********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/index.js.map?");

/***/ }),

/***/ "./core/plugin/emote_layer/.txt":
/*!***********************************************!*\
  !*** ./core/plugin/emote_layer/.txt ***!
  \***********************************************/
/***/ (() => {

eval("\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/%E6%9C%80%E5%88%9D%E3%81%AB%E3%81%8A%E8%AA%AD%E3%81%BF%E4%B8%8B%E3%81%95%E3%81%84.txt?");

/***/ }),

/***/ "./core/plugin/3d_layer/ThreeDLayer.ts":
/*!*********************************************!*\
  !*** ./core/plugin/3d_layer/ThreeDLayer.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThreeDLayer = void 0;\nconst { Layer, CmnLib, argChk_Num, argChk_Boolean } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst three_1 = __webpack_require__(/*! three */ \"./node_modules/three/build/three.cjs\");\nconst OrbitControls_1 = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\nconst GLTFLoader_1 = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nconst EXT_STILL_IMG = 'png_|jpg_|jpeg_|svg_|png|jpg|jpeg|svg';\nclass ThreeDLayer extends Layer {\n    constructor(pia) {\n        super();\n        this.pia = pia;\n        this.tick = () => {\n            if (!this.running)\n                return;\n            this.canvas_3D.render(this.scene_3D, this.camera);\n            this.sprite_3D.texture.update();\n            this.tickUpdEff();\n            this.fncCtrl();\n            this.fncMixerUpd();\n            requestAnimationFrame(this.tick);\n        };\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.clock = new three_1.Clock();\n        this.hEff = {};\n        this.tickUpdEff = () => { };\n        this.hInf = {};\n        this.record = () => Object.assign(super.record(), {\n            hInf: this.hInf,\n        });\n        if (ThreeDLayer.uniq_num++ % 2 == 1)\n            return;\n        this.scene_3D = new three_1.Scene();\n        this.canvas_3D = new three_1.WebGLRenderer({ antialias: true, alpha: true });\n        this.canvas_3D.setSize(CmnLib.stageW, CmnLib.stageH);\n        this.canvas_3D.setPixelRatio(window.devicePixelRatio);\n        const texture_3D = pixi_js_1.Texture.from(this.canvas_3D.domElement);\n        this.sprite_3D = new pixi_js_1.Sprite(texture_3D);\n        this.spLay.addChild(this.sprite_3D);\n        this.sprite_3D.x = (CmnLib.stageW - this.sprite_3D.width) / 2;\n        this.sprite_3D.y = (CmnLib.stageH - this.sprite_3D.height) / 2;\n    }\n    static async init() { globalThis.THREE ??= await Promise.resolve().then(() => __importStar(__webpack_require__(/*! three */ \"./node_modules/three/build/three.cjs\"))); }\n    lay(hArg) {\n        if (!this.scene_3D)\n            return false;\n        if ('grid' in hArg) {\n            const grid = new three_1.GridHelper(argChk_Num(hArg, 'grid_size', 10), argChk_Num(hArg, 'grid_step', 5));\n            this.csv2pos(hArg, 'grid', grid);\n            grid.name = '_grid';\n            this.scene_3D.add(grid);\n        }\n        if ('camera' in hArg) {\n            if (!this.camera) {\n                this.camera = new three_1.PerspectiveCamera(argChk_Num(hArg, 'camera_fov', 50), CmnLib.stageW / CmnLib.stageH, argChk_Num(hArg, 'camera_near', 0.1), argChk_Num(hArg, 'camera_far', 2000));\n            }\n            this.csv2pos(hArg, 'camera', this.camera);\n            if ('camera_target' in hArg) {\n                const [x, y, z] = String(hArg['camera_target']).split(',').map(v => Number(v));\n                this.camera.lookAt(new three_1.Vector3(x, y, z));\n            }\n        }\n        if ('directional_light' in hArg) {\n            const light = new three_1.DirectionalLight(0xFFFFFF);\n            light.intensity = argChk_Num(hArg, 'intensity', 1);\n            this.csv2pos(hArg, 'directional_light', light);\n            light.name = '_light';\n            this.scene_3D.add(light);\n        }\n        if ('controls' in hArg) {\n            const elm = document.getElementById('skynovel');\n            if (!elm)\n                return false;\n            const controls = new OrbitControls_1.OrbitControls(this.camera, elm);\n            controls.target.set(this.camera.position.x + 0.15, this.camera.position.y, this.camera.position.z);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.2;\n            controls.rotateSpeed = 0.1;\n            controls.zoomSpeed = 2;\n            this.fncCtrl = () => controls.update();\n        }\n        const type = hArg.type;\n        const name = hArg.name || '';\n        let mdl = new three_1.Mesh();\n        if (type) {\n            if (name in this.hInf)\n                throw `name=${name}`;\n            if (!this.running) {\n                this.running = true;\n                this.tick();\n            }\n            if (type == 'box') {\n                const size = argChk_Num(hArg, 'size', 100);\n                const geometry = new three_1.BoxGeometry(size, size, size);\n                const material = new three_1.MeshNormalMaterial();\n                mdl = new three_1.Mesh(geometry, material);\n                mdl.rotation.z = -45;\n                this.fncCtrl = () => this.scene_3D.children.forEach(o => {\n                    const m = o;\n                    if (!m)\n                        return;\n                    m.rotation.x += 0.01;\n                    m.rotation.y += 0.01;\n                    m.rotation.z += 0.01;\n                });\n                this.hInf[name] = { type: type, fn: '' };\n            }\n            else {\n                const fn = hArg.fn;\n                if (!fn)\n                    throw 'fn';\n                switch (type) {\n                    case 'eff':\n                        {\n                            const fncEff = () => {\n                                this.hEff[fn] = this.ctxEff.loadEffect(this.pia.searchPath(fn, 'efk'), argChk_Num(hArg, 'scale', 1), () => {\n                                    const [x, y, z] = String(hArg.pos || '0,0,0').split(',');\n                                    const h = this.ctxEff.play(this.hEff[fn], parseInt(x), parseInt(y), parseInt(z));\n                                    this.hInf[name] = { type: type, fn: fn, effhdl: h };\n                                }, (m, url) => console.error(m + ' url=' + url));\n                            };\n                            if (this.ctxEff) {\n                                fncEff();\n                                break;\n                            }\n                            effekseer.initRuntime('./effekseer.wasm', () => {\n                                this.ctxEff = effekseer.createContext();\n                                this.ctxEff.init(this.canvas_3D.getContext());\n                                const clock = new three_1.Clock();\n                                this.tickUpdEff = () => {\n                                    this.ctxEff.update(clock.getDelta() * 60.0);\n                                    this.ctxEff.setProjectionMatrix(Float32Array.from(this.camera.projectionMatrix.elements));\n                                    this.ctxEff.setCameraMatrix(Float32Array.from(this.camera.matrixWorldInverse.elements));\n                                    this.ctxEff.draw();\n                                };\n                            }, () => { });\n                        }\n                        break;\n                    case 'celestial_sphere':\n                        {\n                            const geometry = new three_1.SphereGeometry(5, 60, 40);\n                            geometry.scale(-1, 1, 1);\n                            const ldr = new three_1.TextureLoader();\n                            if (!fn)\n                                throw 'fn';\n                            const tx = ldr.load(this.pia.searchPath(fn, EXT_STILL_IMG));\n                            tx.minFilter = three_1.LinearFilter;\n                            const material = new three_1.MeshBasicMaterial({ map: tx });\n                            mdl = new three_1.Mesh(geometry, material);\n                            this.camera.lookAt(mdl.position);\n                            this.fncCtrl = () => { mdl.rotation.y += 0.001; };\n                        }\n                        break;\n                    case 'gltf':\n                        {\n                            const onProgress = ('debug' in hArg)\n                                ? (xhr) => console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`)\n                                : () => { };\n                            (new GLTFLoader_1.GLTFLoader()).load(this.pia.searchPath(fn, 'gltf|glb'), (gltf) => {\n                                const mdl = gltf.scene;\n                                mdl.name = name;\n                                this.scene_3D.add(mdl);\n                                this.hInf[name] = { type: type, fn: fn, gltf: gltf };\n                                this.arg2mdl(hArg, mdl);\n                            }, onProgress, (e) => console.error('An error happened', e));\n                        }\n                        return false;\n                    default:\n                        throw ` type=${type} `;\n                }\n                this.hInf[name] = { type: type, fn: fn };\n            }\n            mdl.name = name;\n            this.scene_3D.add(mdl);\n        }\n        else if ('del' in hArg) {\n            const del = hArg['del'];\n            if (!del)\n                return false;\n            const mdl2 = this.scene_3D.children.find(e => e.name === del);\n            if (!mdl2)\n                return false;\n            this.clearObject3D(mdl2);\n            delete this.hInf[del];\n            return false;\n        }\n        else if ('name' in hArg) {\n            const mdl2 = this.scene_3D.children.find(e => e.name === name);\n            if (!mdl2)\n                throw ` name=${name} `;\n            mdl = mdl2;\n        }\n        else\n            return false;\n        this.arg2mdl(hArg, mdl);\n        return false;\n    }\n    arg2mdl(hArg, o) {\n        this.csv2pos(hArg, 'pos', o);\n        this.csv2scale(hArg, 'scale', o);\n        const inf = this.hInf[o.name];\n        if (!inf)\n            return;\n        if ('label' in hArg) {\n            inf.label = hArg['label'];\n            if (inf.gltf) {\n                const ac = three_1.AnimationClip.findByName(inf.gltf.animations, inf.label || '');\n                if (!ac) {\n                    console.info(` ${inf.fn}(glTF)`);\n                    const a = inf.gltf.animations;\n                    a.map(v => console.info(`  label=${v.name}`));\n                    throw `${inf.fn}(glTF)label=${inf.label}`;\n                }\n                if (inf.mixer) {\n                    const t = argChk_Num(hArg, 'time', 1000) / 1000;\n                    const aa = inf.mixer.clipAction(ac);\n                    aa.crossFadeFrom(inf.aa, t, true);\n                    inf.aa = aa;\n                }\n                else {\n                    inf.mixer = new three_1.AnimationMixer(o);\n                    inf.aa = inf.mixer.clipAction(ac);\n                    this.fncMixerUpd = () => {\n                        this.scene_3D.children.map(v => {\n                            const inf2 = this.hInf[v.name];\n                            if (inf2)\n                                inf2.mixer.update(this.clock.getDelta());\n                        });\n                    };\n                }\n                inf.aa.enabled = true;\n                inf.aa.clampWhenFinished = true;\n                inf.aa.loop = argChk_Boolean(hArg, 'loop', true)\n                    ? three_1.LoopRepeat\n                    : three_1.LoopOnce;\n                inf.aa.play();\n            }\n        }\n    }\n    csv2pos(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const [x, y, z] = String(hArg[name]).split(',').map(v => Number(v));\n        o.position.set(x, y, z);\n    }\n    csv2scale(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const [x, y, z] = String(hArg[name]).split(',').map(v => Number(v));\n        o.scale.set(x, y, z);\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (!this.scene_3D)\n            return;\n        if (!this.running)\n            return;\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.hInf = {};\n        this.clearScene(this.scene_3D);\n        this.canvas_3D.clear();\n        this.sprite_3D.texture.update();\n    }\n    clearScene(sc) {\n        sc.children.slice().map(o => this.clearObject3D(o));\n    }\n    clearObject3D(o) {\n        o.parent.remove(o);\n        const s = o;\n        if (s) {\n            const inf = this.hInf[s.name];\n            if (inf && inf.mixer)\n                inf.mixer.stopAllAction();\n            this.clearScene(s);\n            return;\n        }\n        const m = o;\n        if (!m)\n            return;\n        m.geometry.dispose();\n        if (m.material instanceof three_1.Material) {\n            m.material.dispose();\n            if (m.material)\n                m.material = [];\n        }\n        else {\n            m.material.map(v => v.dispose());\n        }\n    }\n    playback(hLay, aPrm) {\n        super.playback(hLay, aPrm);\n        this.hInf = hLay.hInf;\n        if (!this.scene_3D)\n            return;\n    }\n    dump() {\n        if (!this.scene_3D)\n            return `\"is\":\"nothing\"`;\n        const aChi = [];\n        this.scene_3D.children.map(o => {\n            let s = `\"${o.name}\": {\"type\":\"${o.type}\"`;\n            const inf = this.hInf[o.name];\n            if (inf && inf.mixer)\n                s += `, \"label\":\"${inf.label}\"`;\n            aChi.push(s + `}`);\n        });\n        return super.dump() + `, \"mdl\":{${aChi.join(',')}}`;\n    }\n}\nexports.ThreeDLayer = ThreeDLayer;\nThreeDLayer.uniq_num = 0;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/ThreeDLayer.ts?");

/***/ }),

/***/ "./core/plugin/3d_layer/index.ts":
/*!***************************************!*\
  !*** ./core/plugin/3d_layer/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst ThreeDLayer_1 = __webpack_require__(/*! ./ThreeDLayer */ \"./core/plugin/3d_layer/ThreeDLayer.ts\");\nasync function init(pia) {\n    pia.addLayCls('3d', () => new ThreeDLayer_1.ThreeDLayer(pia));\n    return ThreeDLayer_1.ThreeDLayer.init();\n}\nexports.init = init;\n;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/3d_layer/index.ts?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/Cubism3Layer.ts":
/*!***************************************************!*\
  !*** ./core/plugin/cubism3_layer/Cubism3Layer.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cubism3Layer = void 0;\nconst { Layer, argChk_Num } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nclass Cubism3Layer extends Layer {\n    constructor() {\n        super(...arguments);\n        this.ldr = new pixi_js_1.Loader;\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n        this.hdl_tick = 0;\n        this.record = () => Object.assign(super.record(), this.state);\n    }\n    lay(hArg, fncComp) {\n        super.lay(hArg);\n        const id = hArg.id || '0';\n        const fn = hArg.fn;\n        if (fn) {\n            const label = hArg.label;\n            if (!label)\n                throw `labeljson${fn}_(label).json`;\n            let needLoad = false;\n            ['moc', 'tex', 'mot'].map((type, i) => {\n                const rn = `l2d:${fn}_${type}`;\n                if (rn in this.ldr.resources)\n                    return;\n                if (rn in pixi_js_1.utils.TextureCache)\n                    pixi_js_1.utils.TextureCache[rn].destroy(true);\n                needLoad = true;\n                if (this.ldr.loading)\n                    this.ldr = new pixi_js_1.Loader();\n                switch (i) {\n                    case 0:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn, 'moc3_|moc3'),\n                            xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.BUFFER,\n                        });\n                        break;\n                    case 1:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn, 'png_|png|jpg_|jpg|jpeg_|jpeg'),\n                        });\n                        break;\n                    case 2:\n                        this.ldr.add({\n                            name: rn,\n                            url: Cubism3Layer.pia.searchPath(fn + '_' + label, 'json_|json'),\n                            xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.JSON,\n                        });\n                        break;\n                }\n            });\n            const fncLoaded = (res) => {\n                const moc = Live2DCubismCore.Moc.fromArrayBuffer(res['l2d:' + fn + '_moc'].data);\n                this.model = new LIVE2DCUBISMPIXI.ModelBuilder()\n                    .setMoc(moc)\n                    .setTimeScale(1)\n                    .addTexture(0, (res['l2d:' + fn + '_tex'] || pixi_js_1.utils.TextureCache['l2d:' + fn + '_tex']).texture)\n                    .addAnimatorLayer(id, LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE, 1)\n                    .build();\n                this.spLay.addChild(this.model);\n                const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                this.model.animator\n                    .getLayer(id)\n                    .play(ani);\n                const tick = () => {\n                    this.hdl_tick = requestAnimationFrame(tick);\n                    if (this.model)\n                        this.model.update(1);\n                };\n                this.hdl_tick = requestAnimationFrame(tick);\n                const a = { ...hArg };\n                delete a.fn;\n                delete a.label;\n                this.state.fn = fn;\n                this.state.label = label;\n                this.lay(a, fncComp);\n                Cubism3Layer.pia.resume(fncComp);\n            };\n            if (needLoad)\n                this.ldr.load((_loader, res) => fncLoaded(res));\n            else\n                fncLoaded(this.ldr.resources);\n            return true;\n        }\n        if (!this.state.fn)\n            return false;\n        if ('label' in hArg) {\n            const label = hArg.label || '';\n            if (this.state.label != label) {\n                this.state.label = label;\n                const fn = this.state.fn;\n                const fn_mot = Cubism3Layer.pia.searchPath(fn + '_' + label, 'json_|json');\n                new pixi_js_1.Loader()\n                    .add({ name: 'l2d:' + fn + '_mot', url: fn_mot, xhrType: pixi_js_1.LoaderResource.XHR_RESPONSE_TYPE.JSON })\n                    .load((_loader, res) => {\n                    const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                    this.model.animator\n                        .getLayer(id)\n                        .play(ani);\n                });\n            }\n        }\n        if ('scale' in hArg) {\n            this.state.scale = argChk_Num(hArg, 'scale', 1);\n            this.model.scale = new pixi_js_1.Point(this.state.scale, this.state.scale);\n            this.model.x = this.model.width / 2;\n            this.model.y = this.model.height / 2;\n        }\n        Layer.setXY(this.model, hArg, this.spLay, true);\n        return false;\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (this.model) {\n            cancelAnimationFrame(this.hdl_tick);\n            this.spLay.removeChild(this.model);\n            this.model = null;\n        }\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        return this.lay(hLay, fncComp);\n    }\n    destroy() { this.clearLay({}); }\n}\nexports.Cubism3Layer = Cubism3Layer;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/Cubism3Layer.ts?");

/***/ }),

/***/ "./core/plugin/cubism3_layer/index.ts":
/*!********************************************!*\
  !*** ./core/plugin/cubism3_layer/index.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst Cubism3Layer_1 = __webpack_require__(/*! ./Cubism3Layer */ \"./core/plugin/cubism3_layer/Cubism3Layer.ts\");\nasync function init(pia) {\n    pia.addLayCls('cubism3', () => new Cubism3Layer_1.Cubism3Layer);\n}\nexports.init = init;\n;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/cubism3_layer/index.ts?");

/***/ }),

/***/ "./core/plugin/emote_layer/EmoteLayer.ts":
/*!***********************************************!*\
  !*** ./core/plugin/emote_layer/EmoteLayer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmoteLayer = void 0;\nconst { Layer, CmnLib, argChk_Num } = __webpack_require__(/*! @famibee/skynovel/web */ \"../skynovel/dist/web.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/dist/cjs/pixi.js\");\nclass EmoteLayer extends Layer {\n    constructor(pia) {\n        super();\n        this.pia = pia;\n        this.sp = new pixi_js_1.Sprite;\n        this.record = () => Object.assign(super.record(), (this.inf)\n            ? {\n                fn: this.inf.fn,\n                label: this.inf.player.mainTimelineLabel,\n                scale: this.inf.player.scale,\n                grayscale: this.inf.player.grayscale,\n                windSpeed: this.inf.player.windSpeed,\n                windPowerMin: this.inf.player.windPowerMin,\n                windPowerMax: this.inf.player.windPowerMax,\n            }\n            : { fn: '' });\n        if (EmoteLayer.uniq_num++ % 2 === 1)\n            return;\n        if (EmoteLayer.uniq_num === 1) {\n            switch (String(this.pia.getVal('const.sn.platform.os.family'))) {\n                case 'Android':\n                case 'iOS':\n                    EmotePlayer.maskMode = EmotePlayer.MaskMode.STENCIL;\n                    break;\n            }\n            EmotePlayer.createRenderCanvas(CmnLib.stageW, CmnLib.stageH);\n        }\n        this.rt = pixi_js_1.RenderTexture.create({ width: CmnLib.stageW, height: CmnLib.stageH });\n        this.spLay.addChild(new pixi_js_1.Sprite(this.rt));\n        this.cvs = document.createElement('canvas');\n        this.cvs.id = `emote:${EmoteLayer.uniq_num}`;\n        this.cvs.width = CmnLib.stageW;\n        this.cvs.height = CmnLib.stageH;\n        this.cvs.hidden = true;\n        const cvsSN = document.getElementById('skynovel');\n        cvsSN.parentElement.appendChild(this.cvs);\n        this.sp.width = CmnLib.stageW;\n        this.sp.height = CmnLib.stageH;\n    }\n    lay(hArg, fncComp) {\n        if (!this.rt)\n            return false;\n        const layer = hArg.layer;\n        if (!layer) {\n            if (hArg[':'] === 'add_lay')\n                return false;\n            throw `layer`;\n        }\n        super.lay(hArg);\n        if (hArg.fn) {\n            const fn = hArg.fn;\n            const player = new EmotePlayer(this.cvs);\n            this.inf = {\n                fn: fn,\n                player: player,\n            };\n            const a = { ...hArg };\n            delete a.fn;\n            a[':'] = 'lay';\n            player.onUpdate = () => {\n                if (!player)\n                    return;\n                this.sp.texture.destroy();\n                this.sp.texture = new pixi_js_1.Texture(new pixi_js_1.BaseTexture(this.cvs));\n                this.pia.render(this.sp, this.rt, true);\n            };\n            player.promiseLoadDataFromURL(this.pia.searchPath(fn, 'emtbytes_|emtbytes'))\n                .then(() => {\n                this.lay(a, fncComp);\n                this.pia.resume(fncComp);\n            });\n            return true;\n        }\n        else if (hArg[':'] === 'add_lay')\n            return false;\n        if (!this.inf)\n            return false;\n        Layer.setXY(this.sp, hArg, this.spLay, true);\n        const player = this.inf.player;\n        if (hArg.label) {\n            const a = [...player.mainTimelineLabels, ...player.diffTimelineLabels];\n            if (!a.includes(hArg.label)) {\n                console.error(` ${this.inf.fn}.emtbytes `);\n                a.forEach(v => console.info(`  label=${v}`));\n                throw `${this.inf.fn}.emtbytes label=${hArg.label}`;\n            }\n            player.mainTimelineLabel = hArg.label;\n        }\n        if ('scale' in hArg)\n            player.scale = argChk_Num(hArg, 'scale', 1);\n        if ('grayscale' in hArg)\n            player.grayscale = argChk_Num(hArg, 'grayscale', 1);\n        if ('windSpeed' in hArg)\n            player.windSpeed = argChk_Num(hArg, 'windSpeed', 0);\n        if ('windPowerMin' in hArg)\n            player.windPowerMin = argChk_Num(hArg, 'windPowerMin', 0);\n        if ('windPowerMax' in hArg)\n            player.windPowerMax = argChk_Num(hArg, 'windPowerMax', 0);\n        return false;\n    }\n    clearLay(hArg) {\n        if (!this.rt)\n            return;\n        super.clearLay(hArg);\n        if (!this.inf)\n            return;\n        this.inf.player.onUpdate = () => { };\n        this.inf.player.unloadData();\n        this.inf = null;\n        this.sp.visible = false;\n        this.pia.render(this.sp, this.rt, true);\n        this.sp.visible = true;\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        if (hLay.fn)\n            return this.lay(hLay, fncComp);\n        this.clearLay(hLay);\n        return false;\n    }\n    dump() {\n        if (!this.rt)\n            return `\"is\":\"nothing\"`;\n        return super.dump() + ((this.inf)\n            ? `, \"mdl\":{\"fn\":\"${this.inf.fn}\",\"label\":\"${this.inf.player.mainTimelineLabel}\",\"scale\":\"${this.inf.player.scale}\"}`\n            : `, \"mdl\":{\"fn\":\"\"}`);\n    }\n    ;\n    destroy() {\n        if (!this.rt)\n            return;\n        this.clearLay({});\n        this.cvs.parentElement.removeChild(this.cvs);\n        this.spLay.removeChildren().forEach((v) => v.destroy());\n    }\n}\nexports.EmoteLayer = EmoteLayer;\nEmoteLayer.uniq_num = 0;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/EmoteLayer.ts?");

/***/ }),

/***/ "./core/plugin/emote_layer/index.ts":
/*!******************************************!*\
  !*** ./core/plugin/emote_layer/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nconst EmoteLayer_1 = __webpack_require__(/*! ./EmoteLayer */ \"./core/plugin/emote_layer/EmoteLayer.ts\");\nasync function init(pia) {\n    pia.addLayCls('emote', () => new EmoteLayer_1.EmoteLayer(pia));\n}\nexports.init = init;\n;\n\n\n//# sourceURL=webpack://gallery/./core/plugin/emote_layer/index.ts?");

/***/ }),

/***/ "./core/plugin/pass.json":
/*!*******************************!*\
  !*** ./core/plugin/pass.json ***!
  \*******************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"pass\":\"8c1ae1c9-bbf6-40fe-bc12-7c5890e7895c\",\"salt\":\"90434bb510043673f677ef42ed0b4e76\",\"iv\":\"5a8aec26a5f1e38a372a180460f26c2a\",\"ite\":524,\"stk\":\"7edc2b487aa65fdff5ff4d0034825da9\"}');\n\n//# sourceURL=webpack://gallery/./core/plugin/pass.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkgallery"] = self["webpackChunkgallery"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor","three"], () => (__webpack_require__("./core/web4webpack.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;