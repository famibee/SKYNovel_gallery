!function(n){function e(e){for(var s,a,o=e[0],h=e[1],l=e[2],_=0,g=[];_<o.length;_++)a=o[_],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&g.push(i[a][0]),i[a]=0;for(s in h)Object.prototype.hasOwnProperty.call(h,s)&&(n[s]=h[s]);for(c&&c(e);g.length;)g.shift()();return r.push.apply(r,l||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],s=!0,o=1;o<t.length;o++){var h=t[o];0!==i[h]&&(s=!1)}s&&(r.splice(e--,1),n=a(a.s=t[0]))}return n}var s={},i={main:0},r=[];function a(e){if(s[e])return s[e].exports;var t=s[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.m=n,a.c=s,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)a.d(t,s,function(e){return n[e]}.bind(null,s));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="";var o=window.webpackJsonp=window.webpackJsonp||[],h=o.push.bind(o);o.push=e,o=o.slice();for(var l=0;l<o.length;l++)e(o[l]);var c=h;r.push(["./core/web4webpack.js","vendor","three"]),t()}({"../npm_core/core/lib/sn/AnalyzeTagArg.js":
/*!************************************************!*\
  !*** ../npm_core/core/lib/sn/AnalyzeTagArg.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nclass AnalyzeTagArg {\n    constructor() {\n        this.REG_TAGARG = m_xregexp(`(?: (?<key>[^\\\\s=]+) \\\\s* = \\\\s* (?: (?: ([\\\\\"\\\\'\\\\#]) (?<val>.*?) \\\\2 )\n| (?<val2> [^\\\\s\\\\\"\\\\'\\\\#\\\\|]+) ) (?: \\\\| (?: (?: ([\\\\\"\\\\'\\\\#]) (?<def>.*?) \\\\5 )\n| (?<def2> [^\\\\s\\\\\"\\\\'\\\\#\\\\|]+) ) )? )\n| (?<literal>\\\\S+)`, 'gx');\n        this.REG_TAGARG_VAL = m_xregexp(`(?: \\\\s* (?: (?: ([\\\\\"\\\\'\\\\#]) (?<val>.*?) \\\\1 )\n| (?<val2> [^\\\\\"\\\\'\\\\#\\\\|]+) ) (?: \\\\| (?: (?: ([\\\\\"\\\\'\\\\#]) (?<def>.*?) \\\\4 )\n| (?<def2> [^\\\\\"\\\\'\\\\#\\\\|]+) ) )? )`, 'x');\n        this.$hPrm = {};\n        this.$isKomeParam = false;\n        this.$literal = '';\n    }\n    go(args) {\n        this.$hPrm = {};\n        this.$isKomeParam = false;\n        if (args == null)\n            return true;\n        let elm = null, pos = 0;\n        while (elm = m_xregexp.exec(args, this.REG_TAGARG, pos)) {\n            pos = elm['index'] + elm[0].length;\n            this.$literal = elm['literal'];\n            if (this.$literal == undefined) {\n                this.$hPrm[elm['key']] = {\n                    val: (elm['val'] == undefined) ? elm['val2'] : elm['val'],\n                    def: (elm['def'] == undefined) ? elm['def2'] : elm['def']\n                };\n                continue;\n            }\n            if (this.$literal != '*')\n                return false;\n            this.$isKomeParam = true;\n        }\n        return true;\n    }\n    goVal(args) {\n        const elm = m_xregexp.exec(args, this.REG_TAGARG_VAL);\n        this.$hPrm = {\n            val: (elm['val'] == undefined) ? elm['val2'] : elm['val'],\n            def: (elm['def'] == undefined) ? elm['def2'] : elm['def']\n        };\n    }\n    get hPrm() { return this.$hPrm; }\n    get isKomeParam() { return this.$isKomeParam; }\n    get literal() { return this.$literal; }\n}\nexports.AnalyzeTagArg = AnalyzeTagArg;\n//# sourceMappingURL=AnalyzeTagArg.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/AnalyzeTagArg.js?")},"../npm_core/core/lib/sn/Areas.js":
/*!****************************************!*\
  !*** ../npm_core/core/lib/sn/Areas.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Areas {\n    constructor() {\n        this.hAreas = {};\n    }\n    search(idx) {\n        for (const begin in this.hAreas) {\n            if (idx < parseInt(begin))\n                continue;\n            if (idx <= this.hAreas[begin])\n                return true;\n        }\n        return false;\n    }\n    record(idx) {\n        if (this.search(idx))\n            return;\n        for (const begin in this.hAreas) {\n            if (this.hAreas[begin] + 1 == idx) {\n                if ((idx + 1) in this.hAreas) {\n                    this.hAreas[begin] = this.hAreas[idx + 1];\n                    delete this.hAreas[idx + 1];\n                }\n                else {\n                    this.hAreas[begin] = idx;\n                }\n                return;\n            }\n        }\n        if ((idx + 1) in this.hAreas) {\n            this.hAreas[idx] = this.hAreas[idx + 1];\n            delete this.hAreas[idx + 1];\n            return;\n        }\n        this.hAreas[idx] = idx;\n    }\n    erase(idx) {\n        if (!this.search(idx))\n            return;\n        if (idx in this.hAreas) {\n            if (this.hAreas[idx] > idx)\n                this.hAreas[idx + 1] = this.hAreas[idx];\n            delete this.hAreas[idx];\n            return;\n        }\n        for (const begin in this.hAreas) {\n            if (idx < parseInt(begin))\n                continue;\n            if (this.hAreas[begin] < idx)\n                continue;\n            if (this.hAreas[begin] == idx) {\n                this.hAreas[begin] = idx - 1;\n                return;\n            }\n            this.hAreas[idx + 1] = this.hAreas[begin];\n            this.hAreas[begin] = idx - 1;\n            return;\n        }\n    }\n    get count() { return Object.keys(this.hAreas).length; }\n    toString() {\n        let ret = '';\n        const aBegin = [];\n        for (const begin in this.hAreas)\n            aBegin.push(parseInt(begin));\n        aBegin.sort(function (x, y) { return x - y; });\n        for (const v of aBegin) {\n            ret +=  true\n                ? ''\n                : undefined;\n        }\n        if (ret != '')\n            ret = ret.substr(1);\n        return ret;\n    }\n}\nexports.Areas = Areas;\n//# sourceMappingURL=Areas.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Areas.js?")},"../npm_core/core/lib/sn/Button.js":
/*!*****************************************!*\
  !*** ../npm_core/core/lib/sn/Button.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst GrpLayer_1 = __webpack_require__(/*! ./GrpLayer */ \"../npm_core/core/lib/sn/GrpLayer.js\");\nclass Button extends pixi_js_1.Container {\n    constructor(main, evtMng, hArg) {\n        var _a;\n        super();\n        this.main = main;\n        this.evtMng = evtMng;\n        this.isStop = false;\n        const enabled = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'enabled', true);\n        if (enabled)\n            this.evtMng.button(hArg, this);\n        if ('text' in hArg) {\n            const fontSize = CmnLib_1.uint(hArg.height || 30);\n            const style = {\n                fill: 'black',\n                align: 'center',\n                fontFamily: Button.fontFamily,\n                fontSize: fontSize,\n                padding: 5,\n                dropShadow: true,\n                dropShadowAlpha: 0.7,\n                dropShadowColor: '#ffffff',\n                dropShadowBlur: 7,\n                dropShadowDistance: 0,\n            };\n            if (hArg.style)\n                Button.s2hStyle(style, hArg.style);\n            const txt = new pixi_js_1.Text((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')), style);\n            txt.alpha = CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', txt.alpha);\n            txt.pivot.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_x', txt.pivot.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_y', txt.pivot.y));\n            txt.rotation = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotation', txt.rotation);\n            txt.scale.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', txt.scale.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', txt.scale.y));\n            txt.width = CmnLib_1.uint(hArg.width || 100);\n            txt.height = fontSize;\n            txt.x = CmnLib_1.uint(hArg.left || 0);\n            txt.y = CmnLib_1.uint(hArg.top || 0);\n            if (hArg.b_pic) {\n                const cnt = new pixi_js_1.Container();\n                this.addChild(cnt);\n                this.isStop = GrpLayer_1.GrpLayer.csv2Sprites(hArg.b_pic, cnt, sp => {\n                    sp.alpha = txt.alpha;\n                    sp.rotation = txt.rotation;\n                    sp.x = txt.x;\n                    sp.y = txt.y;\n                    sp.pivot.set((sp.width - txt.width) / 2, (sp.height - txt.height) / 2);\n                }, isStop => { if (isStop)\n                    this.main.resume(); });\n            }\n            this.addChild(txt);\n            if (!enabled)\n                return;\n            const normal = () => Object.assign(txt.style, style);\n            const style_hover = Object.assign({}, style);\n            if (hArg.style_hover)\n                Button.s2hStyle(style_hover, hArg.style_hover);\n            else\n                style_hover.fill = 'white';\n            const hover = () => Object.assign(txt.style, style_hover);\n            const style_clicked = Object.assign({}, style_hover);\n            if (hArg.style_clicked)\n                Button.s2hStyle(style_clicked, hArg.style_clicked);\n            else\n                style_clicked.dropShadow = false;\n            const clicked = () => Object.assign(txt.style, style_clicked);\n            this.on('pointerover', hover);\n            this.on('pointerout', normal);\n            this.on('pointerdown', clicked);\n            this.on('pointerup', CmnLib_1.CmnLib.isMobile ? normal : hover);\n            return;\n        }\n        if (!hArg.pic)\n            throw 'textまたはpic属性は必須です';\n        this.isStop = GrpLayer_1.GrpLayer.csv2Sprites(hArg.pic, this, sp => {\n            sp.alpha = CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', sp.alpha);\n            sp.pivot.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_x', sp.pivot.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_y', sp.pivot.y));\n            sp.rotation = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotation', sp.rotation);\n            sp.scale.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', sp.scale.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', sp.scale.y));\n            sp.x = CmnLib_1.uint(hArg.left || 0);\n            sp.y = CmnLib_1.uint(hArg.top || 0);\n            const w3 = sp.width / 3;\n            const h = sp.height;\n            const tx = sp.texture.baseTexture;\n            const txNormal = new pixi_js_1.Texture(tx, new pixi_js_1.Rectangle(0, 0, w3, h));\n            const txClicked = new pixi_js_1.Texture(tx, new pixi_js_1.Rectangle(w3, 0, w3, h));\n            const txHover = new pixi_js_1.Texture(tx, new pixi_js_1.Rectangle(w3 * 2, 0, w3, h));\n            const normal = () => sp.texture = txNormal;\n            const hover = () => sp.texture = txHover;\n            const clicked = () => sp.texture = txClicked;\n            this.on('pointerover', hover);\n            this.on('pointerout', normal);\n            this.on('pointerdown', clicked);\n            this.on('pointerup', CmnLib_1.CmnLib.isMobile ? normal : hover);\n            normal();\n        }, isStop => { if (isStop)\n            this.main.resume(); });\n    }\n    static s2hStyle(hStyle, style) {\n        Button.cln = document.createElement('span');\n        const s = Button.cln.style;\n        s.cssText = style;\n        const len = s.length;\n        for (let i = 0; i < len; ++i) {\n            const nm = s[i];\n            hStyle[nm] = s[nm];\n        }\n    }\n}\nexports.Button = Button;\nButton.fontFamily = \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif\";\n//# sourceMappingURL=Button.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Button.js?")},"../npm_core/core/lib/sn/CallStack.js":
/*!********************************************!*\
  !*** ../npm_core/core/lib/sn/CallStack.js ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass CallStack {\n    constructor($fn = '', $idx = 0, $hArg = null) {\n        this.$fn = $fn;\n        this.$idx = $idx;\n        this.$hArg = $hArg;\n        this.toString = () => `[fn:${this.$fn}, idx:${this.$idx}, hArg:${this.$hArg}]`;\n    }\n    get fn() { return this.$fn; }\n    get idx() { return this.$idx; }\n    get hArg() { return this.$hArg; }\n}\nexports.CallStack = CallStack;\n//# sourceMappingURL=CallStack.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/CallStack.js?")},"../npm_core/core/lib/sn/CmnLib.js":
/*!*****************************************!*\
  !*** ../npm_core/core/lib/sn/CmnLib.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction int(o) { return parseInt(String(o), 10); }\nexports.int = int;\nfunction uint(o) {\n    const v = parseInt(String(o), 10);\n    return v < 0 ? -v : v;\n}\nexports.uint = uint;\nfunction trim(s) { return s.replace(/^\\s+|\\s+$/g, ''); }\nexports.trim = trim;\nif (!('toInt' in String.prototype)) {\n    String.prototype['toInt'] = function () { return int(this); };\n}\nif (!('toUint' in String.prototype)) {\n    String.prototype['toUint'] = function () {\n        const v = int(this);\n        return v < 0 ? -v : v;\n    };\n}\nif (!String.prototype.trim) {\n    String.prototype.trim = function () { return this.replace(/^\\s+|\\s+$/g, ''); };\n}\nfunction getDateStr(spl_dd = '/', spl_dt = ' ', spl_tt = ':', spl_ms = '') {\n    const now = new Date();\n    return now.getFullYear()\n        + spl_dd + String(100 + now.getMonth() + 1).substr(1, 2)\n        + spl_dd + String(100 + now.getDate()).substr(1, 2)\n        + spl_dt + String(100 + now.getHours()).substr(1, 2)\n        + spl_tt + String(100 + now.getMinutes()).substr(1, 2)\n        + (spl_ms == '' ? '' : spl_ms + String(now.getMilliseconds()));\n}\nexports.getDateStr = getDateStr;\n;\n;\nconst m_path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\nconst platform = __webpack_require__(/*! platform */ \"../npm_core/node_modules/platform/platform.js\");\nclass CmnLib {\n    static argChk_Num(hash, name, def) {\n        const v = hash[name];\n        if (!(name in hash)) {\n            if (isNaN(def))\n                throw '[' + hash['タグ名'] + ']属性 ' + name + ' は必須です';\n            hash[name] = def;\n            return def;\n        }\n        const n = (String(v).substr(0, 2) == '0x')\n            ? parseInt(v)\n            : parseFloat(v);\n        if (isNaN(n))\n            throw '[' + hash['タグ名'] + ']属性 ' + name + ' の値【' + v + '】が数値ではありません';\n        return hash[name] = n;\n    }\n    static argChk_Boolean(hash, name, def) {\n        if (!(name in hash))\n            return hash[name] = def;\n        const v = hash[name];\n        if (v == null)\n            return false;\n        const v2 = String(v);\n        return hash[name] = (v2 == \"false\") ? false : Boolean(v2);\n    }\n    static cvsResize(cvs) {\n        var _a;\n        const bk_cw = CmnLib.cvsWidth;\n        const bk_ch = CmnLib.cvsHeight;\n        let wiw = window.innerWidth;\n        let wih = window.innerHeight;\n        const wi = window;\n        const lp = screen.orientation\n            ? screen.orientation.type.charAt(0)\n            : ((_a = wi.orientation, (_a !== null && _a !== void 0 ? _a : 90)) % 180 == 0) ? 'p' : 'l';\n        if (CmnLib.isMobile &&\n            ((lp == 'p' && wiw > wih) || (lp == 'l' && wiw < wih)))\n            [wiw, wih] = [wih, wiw];\n        if (CmnLib.argChk_Boolean(CmnLib.hDip, 'expanding', true) ||\n            CmnLib.stageW > wiw ||\n            CmnLib.stageH > wih) {\n            if (CmnLib.stageW / CmnLib.stageH <= wiw / wih) {\n                CmnLib.cvsHeight = wih;\n                CmnLib.cvsWidth = CmnLib.stageW / CmnLib.stageH * wih;\n            }\n            else {\n                CmnLib.cvsWidth = wiw;\n                CmnLib.cvsHeight = CmnLib.stageH / CmnLib.stageW * wiw;\n            }\n            CmnLib.cvsScale = CmnLib.cvsWidth / CmnLib.stageW;\n            const cr = cvs.getBoundingClientRect();\n            CmnLib.ofsPadLeft_Dom2PIXI = cr.left * (1 - CmnLib.cvsScale);\n            CmnLib.ofsPadTop_Dom2PIXI = cr.top * (1 - CmnLib.cvsScale);\n        }\n        else {\n            CmnLib.cvsWidth = CmnLib.stageW;\n            CmnLib.cvsHeight = CmnLib.stageH;\n            CmnLib.cvsScale = 1;\n            CmnLib.ofsPadLeft_Dom2PIXI = 0;\n            CmnLib.ofsPadTop_Dom2PIXI = 0;\n        }\n        const ps = cvs.parentElement.style;\n        ps.position = 'relative';\n        const s = cvs.style;\n        ps.width = s.width = `${CmnLib.cvsWidth}px`;\n        ps.height = s.height = `${CmnLib.cvsHeight}px`;\n        return bk_cw != CmnLib.cvsWidth || bk_ch != CmnLib.cvsHeight;\n    }\n}\nexports.CmnLib = CmnLib;\nCmnLib.stageW = 0;\nCmnLib.stageH = 0;\nCmnLib.ofsPadLeft_Dom2PIXI = 0;\nCmnLib.ofsPadTop_Dom2PIXI = 0;\nCmnLib.cvsWidth = 0;\nCmnLib.cvsHeight = 0;\nCmnLib.cvsScale = 1;\nCmnLib.devtool = false;\nCmnLib.platform = Object.assign({}, platform);\nCmnLib.isSafari = platform.name == 'Safari';\nCmnLib.isFirefox = platform.name == 'Firefox';\nCmnLib.isMac = new RegExp('OS X').test(CmnLib.platform.os.family);\nCmnLib.isMobile = !new RegExp('(Windows|OS X)').test(CmnLib.platform.os.family);\nCmnLib.hDip = {};\nCmnLib.isRetina = false;\nCmnLib.isDarkMode = false;\nCmnLib.retinaRate = 1;\nCmnLib.sn_id = 'skynovel';\nCmnLib.getFn = (path) => m_path.basename(path, m_path.extname(path));\nCmnLib.getExt = (path) => m_path.extname(path).slice(1);\n//# sourceMappingURL=CmnLib.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/CmnLib.js?")},"../npm_core/core/lib/sn/CmnTween.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/CmnTween.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\nclass CmnTween {\n    static ease(nm) {\n        if (!nm)\n            return k => TWEEN.default.Easing.Linear.None(k);\n        if (!(nm in CmnTween.hEase))\n            throw '異常なease指定です';\n        return CmnTween.hEase[nm];\n    }\n}\nexports.CmnTween = CmnTween;\nCmnTween.hEase = {\n    'Back.In': k => TWEEN.default.Easing.Back.In(k),\n    'Back.InOut': k => TWEEN.default.Easing.Back.InOut(k),\n    'Back.Out': k => TWEEN.default.Easing.Back.Out(k),\n    'Bounce.In': k => TWEEN.default.Easing.Bounce.In(k),\n    'Bounce.InOut': k => TWEEN.default.Easing.Bounce.InOut(k),\n    'Bounce.Out': k => TWEEN.default.Easing.Bounce.Out(k),\n    'Circular.In': k => TWEEN.default.Easing.Circular.In(k),\n    'Circular.InOut': k => TWEEN.default.Easing.Circular.InOut(k),\n    'Circular.Out': k => TWEEN.default.Easing.Circular.Out(k),\n    'Cubic.In': k => TWEEN.default.Easing.Cubic.In(k),\n    'Cubic.InOut': k => TWEEN.default.Easing.Cubic.InOut(k),\n    'Cubic.Out': k => TWEEN.default.Easing.Cubic.Out(k),\n    'Elastic.In': k => TWEEN.default.Easing.Elastic.In(k),\n    'Elastic.InOut': k => TWEEN.default.Easing.Elastic.InOut(k),\n    'Elastic.Out': k => TWEEN.default.Easing.Elastic.Out(k),\n    'Exponential.In': k => TWEEN.default.Easing.Exponential.In(k),\n    'Exponential.InOut': k => TWEEN.default.Easing.Exponential.InOut(k),\n    'Exponential.Out': k => TWEEN.default.Easing.Exponential.Out(k),\n    'Linear.None': k => TWEEN.default.Easing.Linear.None(k),\n    'Quadratic.In': k => TWEEN.default.Easing.Quadratic.In(k),\n    'Quadratic.InOut': k => TWEEN.default.Easing.Quadratic.InOut(k),\n    'Quadratic.Out': k => TWEEN.default.Easing.Quadratic.Out(k),\n    'Quartic.In': k => TWEEN.default.Easing.Quartic.In(k),\n    'Quartic.InOut': k => TWEEN.default.Easing.Quartic.InOut(k),\n    'Quartic.Out': k => TWEEN.default.Easing.Quartic.Out(k),\n    'Quintic.In': k => TWEEN.default.Easing.Quintic.In(k),\n    'Quintic.InOut': k => TWEEN.default.Easing.Quintic.InOut(k),\n    'Quintic.Out': k => TWEEN.default.Easing.Quintic.Out(k),\n    'Sinusoidal.In': k => TWEEN.default.Easing.Sinusoidal.In(k),\n    'Sinusoidal.InOut': k => TWEEN.default.Easing.Sinusoidal.InOut(k),\n    'Sinusoidal.Out': k => TWEEN.default.Easing.Sinusoidal.Out(k),\n};\n//# sourceMappingURL=CmnTween.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/CmnTween.js?")},"../npm_core/core/lib/sn/Config.js":
/*!*****************************************!*\
  !*** ../npm_core/core/lib/sn/Config.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nclass Config {\n    constructor(sys, fncLoaded, oCfg4tst) {\n        this.sys = sys;\n        this.oCfg = {\n            first_script: 'main',\n            save_ns: '',\n            coder: { len: 0x360 },\n            window: {\n                width: 300,\n                height: 300,\n            },\n            book: {\n                title: '',\n                creator: '',\n                cre_url: '',\n                publisher: '',\n                pub_url: '',\n                detail: '',\n                version: '1.0',\n                nocode_reg: 'system/.+.mp3|m4a|config/.+',\n                nocode: '',\n                pack_exc: '',\n            },\n            log: { max_len: 1024 },\n            init: {\n                bg_color: 0x000000,\n                tagch_msecwait: 10,\n                auto_msecpagewait: 3500,\n                escape: '',\n            },\n            debug: {\n                devtool: false,\n                token: false,\n                tag: false,\n                putCh: false,\n                slideBaseSpan: false,\n                baseTx: false,\n                masume: false,\n                variable: false,\n            },\n        };\n        this.userFnTail = '';\n        this.hPathFn2Exts = {};\n        this.getJsonSearchPath = () => JSON.stringify(this.hPathFn2Exts);\n        this.$existsBreakline = false;\n        this.$existsBreakpage = false;\n        const load = (oCfg) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n            this.oCfg.first_script = (_b = (_a = oCfg) === null || _a === void 0 ? void 0 : _a.first_script, (_b !== null && _b !== void 0 ? _b : this.oCfg.first_script));\n            this.oCfg.coder = (_d = (_c = oCfg) === null || _c === void 0 ? void 0 : _c.coder, (_d !== null && _d !== void 0 ? _d : this.oCfg.coder));\n            CmnLib_1.CmnLib.stageW = this.oCfg.window.width = Number((_g = (_f = (_e = oCfg) === null || _e === void 0 ? void 0 : _e.window) === null || _f === void 0 ? void 0 : _f.width, (_g !== null && _g !== void 0 ? _g : this.oCfg.window.width)));\n            CmnLib_1.CmnLib.stageH = this.oCfg.window.height = Number((_k = (_j = (_h = oCfg) === null || _h === void 0 ? void 0 : _h.window) === null || _j === void 0 ? void 0 : _j.height, (_k !== null && _k !== void 0 ? _k : this.oCfg.window.height)));\n            if ('book' in oCfg) {\n                const b = this.oCfg.book;\n                for (const nm in b) {\n                    if (nm in oCfg.book)\n                        b[nm] = oCfg.book[nm];\n                }\n            }\n            this.oCfg.log.max_len = (_o = (_m = (_l = oCfg.log) === null || _l === void 0 ? void 0 : _l.max_len) === null || _m === void 0 ? void 0 : _m.max_len, (_o !== null && _o !== void 0 ? _o : this.oCfg.log.max_len));\n            if ('init' in oCfg) {\n                const i = this.oCfg.init;\n                for (const nm in i) {\n                    if (!(nm in oCfg.init))\n                        continue;\n                    const v = String(oCfg.init[nm]);\n                    i[nm] = (v.charAt(0) == '#')\n                        ? parseInt(v.slice(1), 16)\n                        : v;\n                }\n            }\n            if ('debug' in oCfg) {\n                const d = this.oCfg.debug;\n                for (const nm in d) {\n                    if (!(nm in oCfg.debug))\n                        continue;\n                    d[nm] = CmnLib_1.CmnLib.argChk_Boolean(oCfg.debug, nm, d[nm]);\n                }\n            }\n            CmnLib_1.CmnLib.devtool = this.oCfg.debug.devtool;\n            sys.loadPathAndVal(this.hPathFn2Exts, () => {\n                this.$existsBreakline = this.matchPath('^breakline$', Config.EXT_SPRITE).length > 0;\n                this.$existsBreakpage = this.matchPath('^breakpage$', Config.EXT_SPRITE).length > 0;\n                fncLoaded();\n            }, this);\n        };\n        if (oCfg4tst) {\n            load(oCfg4tst);\n            return;\n        }\n        const fn = sys.cur + 'prj.json' + sys.crypt_;\n        sys.fetch(fn)\n            .then(res => res.text())\n            .then(d => JSON.parse(sys.pre(fn, d)))\n            .then(load);\n    }\n    get existsBreakline() { return this.$existsBreakline; }\n    get existsBreakpage() { return this.$existsBreakpage; }\n    getNs() { return `skynovel.${this.oCfg.save_ns} - `; }\n    searchPath(fn, extptn = '') {\n        if (!fn)\n            throw '[searchPath] fnが空です';\n        if (fn.substr(0, 7) == 'http://')\n            return fn;\n        if (fn.substr(0, 9) == 'desktop:/') {\n            return this.sys.path_desktop + fn.slice(9);\n        }\n        if (fn.substr(0, 10) == 'userdata:/') {\n            return this.sys.path_userdata + fn.slice(10);\n        }\n        const a = {\n            fn: CmnLib_1.CmnLib.getFn(fn),\n            ext: CmnLib_1.CmnLib.getExt(fn)\n        };\n        if (this.userFnTail) {\n            const utn = a.fn + '@@' + this.userFnTail;\n            if (utn in this.hPathFn2Exts) {\n                if (extptn == '')\n                    a.fn = utn;\n                else\n                    for (let e3 in this.hPathFn2Exts[utn]) {\n                        if (`|${extptn}|`.indexOf(`|${e3}|`) == -1)\n                            continue;\n                        a.fn = utn;\n                        break;\n                    }\n            }\n        }\n        const h_exts = this.hPathFn2Exts[a.fn];\n        if (!h_exts)\n            throw `サーチパスに存在しないファイル【${fn}】です`;\n        let ret = '';\n        if (!a.ext) {\n            const hcnt = CmnLib_1.int(h_exts[':cnt']);\n            if (extptn == '') {\n                if (hcnt > 1)\n                    throw `指定ファイル【${fn}】が複数マッチします。サーチ対象拡張子群【${extptn}】で絞り込むか、ファイル名を個別にして下さい。`;\n                return fn;\n            }\n            const search_exts = `|${extptn}|`;\n            if (hcnt > 1) {\n                let cnt = 0;\n                for (const e2 in h_exts) {\n                    if (search_exts.indexOf(`|${e2}|`) == -1)\n                        continue;\n                    if (++cnt > 1)\n                        throw `指定ファイル【${fn}】が複数マッチします。サーチ対象拡張子群【${extptn}】で絞り込むか、ファイル名を個別にして下さい。`;\n                }\n            }\n            for (let e in h_exts) {\n                if (search_exts.indexOf(`|${e}|`) == -1)\n                    continue;\n                return h_exts[e];\n            }\n            throw `サーチ対象拡張子群【${extptn}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${fn}】`;\n        }\n        if (extptn != '') {\n            const search_exts2 = `|${extptn}|`;\n            if (search_exts2.indexOf(`|${a.ext}|`) == -1) {\n                throw `指定ファイルの拡張子【${a.ext}】は、サーチ対象拡張子群【${extptn}】にマッチしません。探索ファイル名=【${fn}】`;\n            }\n        }\n        ret = h_exts[a.ext];\n        if (!ret)\n            throw `サーチパスに存在しない拡張子【${a.ext}】です。探索ファイル名=【${fn}】、サーチ対象拡張子群【${extptn}】`;\n        return ret;\n    }\n    matchPath(fnptn, extptn = '') {\n        const aRet = [];\n        const regPtn = new RegExp(fnptn);\n        const regExt = new RegExp(extptn);\n        for (let fn in this.hPathFn2Exts) {\n            if (fn.search(regPtn) == -1)\n                continue;\n            const h_exts = this.hPathFn2Exts[fn];\n            if (extptn == '') {\n                aRet.push(h_exts);\n                continue;\n            }\n            const o = {};\n            let isa = false;\n            for (const ext in h_exts) {\n                if (ext.search(regExt) == -1)\n                    continue;\n                o[ext] = h_exts[ext];\n                isa = true;\n            }\n            if (isa)\n                aRet.push(o);\n        }\n        return aRet;\n    }\n}\nexports.Config = Config;\nConfig.EXT_SPRITE = 'png_|jpg_|jpeg_|json_|svg_|mp4_|png|jpg|jpeg|svg|json|mp4';\nConfig.EXT_SCRIPT = 'sn_|sn';\nConfig.EXT_FONT = 'woff2|otf|ttf';\nConfig.EXT_SOUND = 'mp3_|mp3|m4a_|m4a|ogg_|ogg|aac_|aac|webm_|webm|flac_|flac|wav';\n//# sourceMappingURL=Config.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Config.js?")},"../npm_core/core/lib/sn/DebugMng.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/DebugMng.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Stats = __webpack_require__(/*! stats.js */ \"../npm_core/node_modules/stats.js/src/Stats.js\");\nclass DebugMng {\n    constructor(sys, hTag, scrItr) {\n        this.sys = sys;\n        this.fncUpd = () => { };\n        this.first = true;\n        DebugMng.scrItr = scrItr;\n        DebugMng.hTag = hTag;\n        DebugMng.title = hTag.title;\n        DebugMng.myTrace = DebugMng.fncMyTrace;\n        hTag.log = o => this.log(o);\n        hTag.stats = o => this.stats(o);\n        hTag.trace = o => this.trace(o);\n        DebugMng.spnDbg = document.createElement('span');\n        DebugMng.spnDbg.hidden = true;\n        DebugMng.spnDbg.textContent = '';\n        DebugMng.spnDbg.style.cssText =\n            `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`;\n        document.body.appendChild(DebugMng.spnDbg);\n    }\n    destroy() {\n        DebugMng.title = () => false;\n        document.body.removeChild(DebugMng.spnDbg);\n    }\n    update() { this.fncUpd(); }\n    log(hArg) {\n        if (this.first) {\n            this.first = false;\n            this.sys.appendFile(this.sys.path_desktop + 'log.txt', `== ${CmnLib_1.CmnLib.platform.description} ==`, err => { if (err)\n                console.log(err); });\n        }\n        this.sys.appendFile(this.sys.path_desktop + 'log.txt', `--- ${CmnLib_1.getDateStr('-', '_', '')} [fn:${DebugMng.scrItr.scriptFn} line:${DebugMng.scrItr.lineNum}] prj:${this.sys.cur}\\n${hArg.text || `(text is ${hArg.text})`}\\n`, err => { if (err)\n            console.log(err); });\n        return false;\n    }\n    stats(hArg) {\n        if (this._stats) {\n            this._stats.dom.style.right = '0px';\n            this._stats.dom.style.top = '0px';\n            return false;\n        }\n        this._stats = new Stats();\n        this._stats.showPanel(0);\n        this._stats.dom.style.position = 'fixed';\n        this._stats.dom.style.right = '0px';\n        this._stats.dom.style.top = '0px';\n        this._stats.dom.style.right = CmnLib_1.CmnLib.argChk_Num(hArg, 'left', CmnLib_1.int(this._stats.dom.style.right)) + 'px';\n        this._stats.dom.style.top = CmnLib_1.CmnLib.argChk_Num(hArg, 'top', CmnLib_1.int(this._stats.dom.style.top)) + 'px';\n        document.body.appendChild(this._stats.dom);\n        this.fncUpd = () => { this._stats.update(); };\n        return false;\n    }\n    trace(hArg) {\n        DebugMng.myTrace(hArg.text || `(text is ${hArg.text})`, 'I');\n        return false;\n    }\n    static fncMyTrace(txt, lvl = 'E') {\n        let mes = `{${lvl}} `;\n        if (DebugMng.scrItr)\n            mes += `(fn:${DebugMng.scrItr.scriptFn} line:${DebugMng.scrItr.lineNum}) `;\n        mes += txt;\n        DebugMng.dspDbg(mes, lvl);\n        let sty = '';\n        switch (lvl) {\n            case 'D':\n                sty = `color:#${CmnLib_1.CmnLib.isDarkMode ? '49F' : '05A'};`;\n                break;\n            case 'W':\n                sty = 'color:#F80;';\n                break;\n            case 'F':\n                sty = 'color:#B00;';\n                break;\n            case 'ET':\n            case 'E':\n                DebugMng.title({ text: txt });\n                this.hTag.dump_lay({});\n                this.hTag.dump_val({});\n                DebugMng.scrItr.dumpErrForeLine();\n                this.hTag.dump_stack({});\n                if (lvl == 'ET')\n                    throw mes;\n                console.error('%c' + mes, 'color:#F30;');\n                return;\n            default:\n                sty = '';\n                mes = ' ' + mes;\n        }\n        console.info('%c' + mes, sty);\n    }\n    static dspDbg(mes, lvl) {\n        let sty = '';\n        switch (lvl) {\n            case 'D':\n                sty = 'color:#05A;';\n                break;\n            case 'W':\n                sty = 'color:#F80;';\n                break;\n            case 'F':\n                sty = 'color:#B00;';\n                break;\n            case 'ET':\n            case 'E':\n                sty = 'color:#F30;';\n                break;\n            default: sty = '';\n        }\n        DebugMng.spnDbg.innerHTML += `<span style='${sty}'>${mes}</span><br/>`;\n        DebugMng.spnDbg.hidden = false;\n    }\n    ;\n}\nexports.DebugMng = DebugMng;\nDebugMng.myTrace = (txt, lvl = 'E') => {\n    let mes = `{${lvl}} ` + txt;\n    let sty = '';\n    switch (lvl) {\n        case 'D':\n            sty = `color:#${CmnLib_1.CmnLib.isDarkMode ? '49F' : '05A'};`;\n            break;\n        case 'W':\n            sty = 'color:#FF8800;';\n            break;\n        case 'F':\n            sty = 'color:#BB0000;';\n            break;\n        case 'ET': throw mes;\n        case 'E':\n            console.error('%c' + mes, 'color:#FF3300;');\n            return;\n        default:\n            sty = 'color:black;';\n            mes = ' ' + mes;\n    }\n    console.info('%c' + mes, sty);\n};\n//# sourceMappingURL=DebugMng.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/DebugMng.js?")},"../npm_core/core/lib/sn/EventListenerCtn.js":
/*!***************************************************!*\
  !*** ../npm_core/core/lib/sn/EventListenerCtn.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nclass EventListenerCtn {\n    constructor() {\n        this.vctEvt = [];\n    }\n    add(ed, type, fnc, ctx = {}) {\n        if (ed instanceof pixi_js_1.BaseTexture) {\n            switch (type) {\n                case 'loaded':\n                case 'update':\n                case 'error':\n                case 'dispose':\n                    ed.on(type, fnc, ctx);\n                    this.vctEvt.push(() => ed.off(type, fnc, ctx));\n                    break;\n            }\n            return;\n        }\n        if (ed instanceof pixi_js_1.utils.EventEmitter) {\n            ed.on(type, fnc, ctx);\n            this.vctEvt.push(() => ed.off(type, fnc, ctx));\n            return;\n        }\n        ed.addEventListener(type, fnc, ctx);\n        this.vctEvt.push(() => { var _a; return ed.removeEventListener(type, fnc, { capture: (_a = ctx.capture, (_a !== null && _a !== void 0 ? _a : false)) }); });\n    }\n    clear() {\n        for (const fnc of this.vctEvt)\n            fnc();\n        this.vctEvt = [];\n    }\n}\nexports.EventListenerCtn = EventListenerCtn;\n//# sourceMappingURL=EventListenerCtn.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/EventListenerCtn.js?")},"../npm_core/core/lib/sn/EventMng.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/EventMng.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst TxtLayer_1 = __webpack_require__(/*! ./TxtLayer */ \"../npm_core/core/lib/sn/TxtLayer.js\");\nconst EventListenerCtn_1 = __webpack_require__(/*! ./EventListenerCtn */ \"../npm_core/core/lib/sn/EventListenerCtn.js\");\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst Hammer = __webpack_require__(/*! hammerjs */ \"../npm_core/node_modules/hammerjs/hammer.js\");\nclass EventMng {\n    constructor(cfg, hTag, appPixi, main, layMng, val, sndMng, scrItr) {\n        this.cfg = cfg;\n        this.hTag = hTag;\n        this.appPixi = appPixi;\n        this.main = main;\n        this.layMng = layMng;\n        this.val = val;\n        this.scrItr = scrItr;\n        this.elc = new EventListenerCtn_1.EventListenerCtn;\n        this.hHamEv = {\n            tap2: null,\n            press: null,\n            swipeleft: null,\n            swiperight: null,\n            swipeup: null,\n            swipedown: null,\n        };\n        this.resvFlameEvent4Wheel = (_win) => { };\n        this.wheeling = false;\n        this.extend_wheel = false;\n        this.hLocalEvt2Fnc = {};\n        this.hGlobalEvt2Fnc = {};\n        this.isStop = false;\n        this.waitCustomEvent4Wheel = (_elc, _fnc) => { };\n        this.goTxt = () => this.layMng.goTxt();\n        this.fncCancelSkip = () => { };\n        this.cr = (len) => this.scrItr.addLineNum(len);\n        this.hDownKeys = {\n            'Alt': 0,\n            'Meta': 0,\n            'Control': 0,\n            'ArrowDown': 0,\n            'End': 0,\n            'Enter': 0,\n            'Escape': 0,\n            ' ': 0,\n            'GoBack': 0,\n        };\n        sndMng.setEvtMng(this);\n        scrItr.setOtherObj(this, layMng);\n        TxtLayer_1.TxtLayer.setEvtMng(main, this);\n        layMng.setEvtMng(this);\n        hTag.clear_event = o => this.clear_event(o);\n        hTag.event = o => this.event(o);\n        hTag.l = o => this.l(o);\n        hTag.p = o => this.p(o);\n        hTag.s = () => { this.stdWait(() => { }, false); return true; };\n        hTag.set_cancel_skip = () => this.set_cancel_skip();\n        hTag.wait = o => this.wait(o);\n        hTag.waitclick = () => { this.stdWait(() => main.resume()); return true; };\n        this.ham = new Hammer(appPixi.view, { recognizers: [\n                [Hammer.Press],\n                [Hammer.Swipe, { direction: Hammer.DIRECTION_ALL }],\n            ] });\n        this.hHamEv.tap2 = null;\n        for (const key in this.hHamEv) {\n            const fnc = this.hHamEv[key] = (e) => {\n                val.defTmp('sn.eventArg.type', e.type);\n                val.defTmp('sn.eventArg.pointers', e.pointers);\n                this.defEvt2Fnc(e, e.type);\n            };\n            this.ham.on(key, fnc);\n        }\n        appPixi.stage.interactive = true;\n        if (CmnLib_1.CmnLib.isMobile)\n            appPixi.stage.on('pointerdown', (e) => this.defEvt2Fnc(e, 'click'));\n        else\n            this.elc.add(appPixi.stage, 'pointerdown', e => {\n                switch (e.data.button) {\n                    case 0:\n                        this.defEvt2Fnc(e, 'click');\n                        break;\n                    case 1:\n                        this.defEvt2Fnc(e, 'middleclick');\n                        break;\n                }\n            });\n        this.elc.add(window, 'keydown', e => this.ev_keydown(e));\n        this.elc.add(appPixi.view, 'contextmenu', e => this.ev_contextmenu(e));\n        if ('WheelEvent' in window) {\n            this.elc.add(appPixi.view, 'wheel', e => this.ev_wheel(e), { passive: true });\n            this.resvFlameEvent4Wheel = (win) => win.addEventListener('wheel', e => this.ev_wheel(e), { passive: true });\n            this.waitCustomEvent4Wheel = (elc, fnc) => elc.add(this.appPixi.view, 'wheel', (e) => {\n                if (e['isComposing'])\n                    return;\n                if (e.deltaY <= 0)\n                    return;\n                e.stopPropagation();\n                fnc();\n            });\n        }\n        this.elc.add(window, 'gamepadconnected', (e) => {\n            if (CmnLib_1.CmnLib.devtool)\n                console.log('👺 Gamepad connected at index %d: %s. %d buttons, %d axes.', e['gamepad'].index, e['gamepad'].id, e['gamepad'].buttons.length, e['gamepad'].axes.length);\n            const key = e.type;\n            this.defEvt2Fnc(e, key);\n        });\n        this.elc.add(window, 'gamepaddisconnected', (e) => {\n            if (CmnLib_1.CmnLib.devtool)\n                console.log('👺 Gamepad disconnected from index %d: %s', e['gamepad'].index, e['gamepad'].id);\n            const key = e.type;\n            this.defEvt2Fnc(e, key);\n        });\n        this.elc.add(window, 'keyup', (e) => {\n            if (e['isComposing'])\n                return;\n            if (e.key in this.hDownKeys)\n                this.hDownKeys[e.key] = 0;\n        });\n        val.defTmp('const.sn.key.alternate', () => (this.hDownKeys['Alt'] > 0));\n        val.defTmp('const.sn.key.command', () => (this.hDownKeys['Meta'] > 0));\n        val.defTmp('const.sn.key.control', () => (this.hDownKeys['Control'] > 0));\n        val.defTmp('const.sn.key.end', () => (this.hDownKeys['End'] > 0));\n        val.defTmp('const.sn.key.escape', () => (this.hDownKeys['Escape'] > 0));\n        val.defTmp('const.sn.key.back', () => (this.hDownKeys['GoBack'] > 0));\n    }\n    resvFlameEvent(win) {\n        win.addEventListener('keydown', e => this.ev_keydown(e));\n        win.addEventListener('contextmenu', e => this.ev_contextmenu(e));\n        this.resvFlameEvent4Wheel(win);\n    }\n    ev_keydown(e) {\n        if (e['isComposing'])\n            return;\n        if (e.key in this.hDownKeys)\n            this.hDownKeys[e.key] = e.repeat ? 2 : 1;\n        const key = (e.altKey ? (e.key == 'Alt' ? '' : 'alt+') : '')\n            + (e.ctrlKey ? (e.key == 'Control' ? '' : 'ctrl+') : '')\n            + (e.shiftKey ? (e.key == 'Shift' ? '' : 'shift+') : '')\n            + e.key;\n        this.defEvt2Fnc(e, key);\n    }\n    ev_contextmenu(e) {\n        const key = (e.altKey ? (e.key == 'Alt' ? '' : 'alt+') : '')\n            + (e.ctrlKey ? (e.key == 'Control' ? '' : 'ctrl+') : '')\n            + (e.shiftKey ? (e.key == 'Shift' ? '' : 'shift+') : '')\n            + 'rightclick';\n        this.defEvt2Fnc(e, key);\n        e.preventDefault();\n    }\n    ev_wheel(e) {\n        if (e['isComposing'])\n            return;\n        if (this.wheeling) {\n            this.extend_wheel = true;\n            return;\n        }\n        this.wheeling = true;\n        this.ev_wheel_waitstop();\n        const key = (e.altKey ? 'alt+' : '')\n            + (e.ctrlKey ? 'ctrl+' : '')\n            + (e.shiftKey ? 'shift+' : '')\n            + (e.deltaY > 0 ? 'downwheel' : 'upwheel');\n        this.defEvt2Fnc(e, key);\n    }\n    ev_wheel_waitstop() {\n        setTimeout(() => {\n            if (this.extend_wheel) {\n                this.extend_wheel = false;\n                this.ev_wheel_waitstop();\n                return;\n            }\n            this.wheeling = false;\n        }, 250);\n    }\n    destroy() {\n        this.elc.clear();\n        for (const key in this.hHamEv) {\n            this.ham.off(key);\n        }\n        this.ham.destroy();\n    }\n    defEvt2Fnc(e, KEY) {\n        var _a, _b;\n        const key = KEY.toLowerCase();\n        const ke = this.hLocalEvt2Fnc[key]\n            || this.hGlobalEvt2Fnc[key];\n        if (!ke) {\n            if (key.slice(0, 5) == 'swipe') {\n                const esw = e;\n                window.scrollBy(-(_a = esw.deltaX, (_a !== null && _a !== void 0 ? _a : 0)), -(_b = esw.deltaY, (_b !== null && _b !== void 0 ? _b : 0)));\n            }\n            return;\n        }\n        if ((key.slice(-5) != 'wheel') && ('preventDefault' in e))\n            e.preventDefault();\n        e.stopPropagation();\n        if (key.slice(0, 4) != 'dom=' && this.layMng.clickTxtLay())\n            return;\n        if (!this.isStop)\n            return;\n        this.isStop = false;\n        ke(e);\n    }\n    popLocalEvts() {\n        if (this.isStop)\n            return {};\n        const ret = this.hLocalEvt2Fnc;\n        this.hLocalEvt2Fnc = {};\n        return ret;\n    }\n    pushLocalEvts(h) { this.hLocalEvt2Fnc = h; }\n    stdWait(fnc, canskip = true) {\n        this.goTxt();\n        if (canskip) {\n            const fncKey = () => fnc();\n            this.hLocalEvt2Fnc['click'] = fncKey;\n            this.hLocalEvt2Fnc['enter'] = fncKey;\n            this.hLocalEvt2Fnc['arrowdown'] = fncKey;\n            this.hLocalEvt2Fnc['wheel.y>0'] = fncKey;\n        }\n        else {\n            delete this.hLocalEvt2Fnc['click'];\n            delete this.hLocalEvt2Fnc['enter'];\n            delete this.hLocalEvt2Fnc['arrowdown'];\n            delete this.hLocalEvt2Fnc['wheel.y>0'];\n        }\n        this.val.saveKidoku();\n        this.fncCancelSkip();\n        this.isStop = true;\n    }\n    button(hArg, em) {\n        var _a;\n        if (!hArg.fn && !hArg.label)\n            this.main.errScript('fnまたはlabelは必須です');\n        em.interactive = em.buttonMode = true;\n        const key = (_a = hArg.key, (_a !== null && _a !== void 0 ? _a : ' ')).toLowerCase();\n        if (!hArg.fn)\n            hArg.fn = this.scrItr.scriptFn;\n        const glb = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'global', false);\n        if (glb)\n            this.hGlobalEvt2Fnc[key] = () => this.main.resumeByJumpOrCall(hArg);\n        else\n            this.hLocalEvt2Fnc[key] = () => this.main.resumeByJumpOrCall(hArg);\n        em.on('pointerdown', (e) => this.defEvt2Fnc(e, key));\n        if (hArg.clickse) {\n            this.cfg.searchPath(hArg.clickse, Config_1.Config.EXT_SOUND);\n            em.on('pointerdown', () => {\n                const o = { fn: hArg.clickse, join: false };\n                if (hArg.clicksebuf)\n                    o.buf = hArg.clicksebuf;\n                this.hTag.playse(o);\n            });\n        }\n        if (hArg.enterse) {\n            this.cfg.searchPath(hArg.enterse, Config_1.Config.EXT_SOUND);\n            em.on('pointerover', () => {\n                const o = { fn: hArg.enterse, join: false };\n                if (hArg.entersebuf)\n                    o.buf = hArg.entersebuf;\n                this.hTag.playse(o);\n            });\n        }\n        if (hArg.leavese) {\n            this.cfg.searchPath(hArg.leavese, Config_1.Config.EXT_SOUND);\n            em.on('pointerout', () => {\n                const o = { fn: hArg.leavese, join: false };\n                if (hArg.leavesebuf)\n                    o.buf = hArg.leavesebuf;\n                this.hTag.playse(o);\n            });\n        }\n        if (hArg.onenter) {\n            const key2 = key + hArg.onenter.toLowerCase();\n            const o = { fn: hArg.fn, label: hArg.onenter, call: true, key: key2 };\n            if (glb)\n                this.hGlobalEvt2Fnc[key2] = () => this.main.resumeByJumpOrCall(o);\n            else\n                this.hLocalEvt2Fnc[key2] = () => this.main.resumeByJumpOrCall(o);\n            em.on('pointerover', (e) => this.defEvt2Fnc(e, key2));\n        }\n        if (hArg.onleave) {\n            const key2 = key + hArg.onleave.toLowerCase();\n            const o = { fn: hArg.fn, label: hArg.onleave, call: true, key: key2 };\n            if (glb)\n                this.hGlobalEvt2Fnc[key2] = () => this.main.resumeByJumpOrCall(o);\n            else\n                this.hLocalEvt2Fnc[key2] = () => this.main.resumeByJumpOrCall(o);\n            em.on('pointerout', (e) => this.defEvt2Fnc(e, key2));\n        }\n    }\n    waitCustomEvent(hArg, elc, fnc) {\n        this.goTxt();\n        if (!CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true))\n            return;\n        elc.add(window, 'pointerdown', (e) => {\n            e.stopPropagation();\n            this.fncCancelSkip();\n            fnc();\n        });\n        elc.add(window, 'keydown', (e) => {\n            if (e['isComposing'])\n                return;\n            e.stopPropagation();\n            this.fncCancelSkip();\n            fnc();\n        });\n        this.waitCustomEvent4Wheel(elc, fnc);\n    }\n    clear_event(hArg) {\n        const glb = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'global', false);\n        const h = glb ? this.hGlobalEvt2Fnc : this.hLocalEvt2Fnc;\n        for (const nm in h)\n            this.clear_eventer(nm, h[nm]);\n        if (glb)\n            this.hGlobalEvt2Fnc = {};\n        else\n            this.hLocalEvt2Fnc = {};\n        return false;\n    }\n    clear_eventer(key, e2f) {\n        if (key.slice(0, 4) != 'dom=')\n            return;\n        for (const v of document.querySelectorAll(key.slice(4))) {\n            v.removeEventListener('click', e2f);\n        }\n    }\n    event(hArg) {\n        const KEY = hArg.key;\n        if (!KEY)\n            throw 'keyは必須です';\n        const key = KEY.toLowerCase();\n        const call = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'call', false);\n        const h = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'global', false)\n            ? this.hGlobalEvt2Fnc\n            : this.hLocalEvt2Fnc;\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'del', false)) {\n            if (hArg.fn || hArg.label || call)\n                throw 'fn/label/callとdelは同時指定できません';\n            this.clear_eventer(KEY, h[key]);\n            delete h[key];\n            return false;\n        }\n        hArg.fn = hArg.fn || this.scrItr.scriptFn;\n        if (KEY.slice(0, 4) == 'dom=') {\n            let elmlist;\n            const idx = KEY.indexOf(':');\n            let sel = '';\n            if (idx >= 0) {\n                const name = KEY.slice(4, idx);\n                const frmnm = `const.sn.frm.${name}`;\n                if (!this.val.getVal(`tmp:${frmnm}`, 0))\n                    throw `HTML【${name}】が読み込まれていません`;\n                const ifrm = document.getElementById(name);\n                const win = ifrm.contentWindow;\n                sel = KEY.slice(idx + 1);\n                elmlist = win.document.querySelectorAll(sel);\n            }\n            else {\n                sel = KEY.slice(4);\n                elmlist = document.querySelectorAll(sel);\n            }\n            const need_err = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'need_err', true);\n            if (elmlist.length == 0 && need_err)\n                throw `HTML内にセレクタ（${sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n            const ie = elmlist[0];\n            const type = (ie) ? ie.type : '';\n            ((type == 'range' || type == 'checkbox' || type == 'text' || type == 'textarea')\n                ? ['input', 'change']\n                : ['click'])\n                .forEach(v => {\n                for (const elm of elmlist)\n                    this.elc.add(elm, v, e => {\n                        const e2 = elm.dataset;\n                        for (const key in e2) {\n                            if (e2.hasOwnProperty(key))\n                                this.val.setVal_Nochk('tmp', `sn.event.domdata.${key}`, e2[key]);\n                        }\n                        this.defEvt2Fnc(e, KEY);\n                    });\n            });\n            for (const elm of elmlist)\n                this.elc.add(elm, 'mouseleave', e => {\n                    if (e.which != 1)\n                        return;\n                    this.defEvt2Fnc(e, KEY);\n                });\n        }\n        h[key] = () => this.main.resumeByJumpOrCall(hArg);\n        return false;\n    }\n    l(hArg) {\n        if (!this.val.getVal('tmp:sn.tagL.enabled')) {\n            this.goTxt();\n            return false;\n        }\n        if (this.val.getVal('tmp:sn.skip.enabled') && !this.val.getVal('tmp:sn.skip.all')\n            && !this.scrItr.isNextKidoku) {\n            this.fncCancelSkip();\n            this.val.setVal_Nochk('tmp', 'sn.skip.enabled', false);\n        }\n        if (this.val.getVal('tmp:sn.skip.enabled') && ('ps'.includes(String(this.val.getVal('sys:sn.skip.mode')))))\n            return false;\n        if (this.val.getVal('tmp:sn.auto.enabled')) {\n            return this.wait({\n                time: Number(this.scrItr.isKidoku\n                    ? this.val.getVal('sys:sn.auto.msecLineWait_Kidoku')\n                    : this.val.getVal('sys:sn.auto.msecLineWait'))\n            });\n        }\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'visible', true))\n            this.layMng.breakLine();\n        this.stdWait(() => this.main.resume());\n        return true;\n    }\n    p(hArg) {\n        if (this.val.getVal('tmp:sn.skip.enabled') && !this.val.getVal('tmp:sn.skip.all')\n            && !this.scrItr.isNextKidoku) {\n            this.fncCancelSkip();\n            this.val.setVal_Nochk('tmp', 'sn.skip.enabled', false);\n        }\n        if (this.val.getVal('tmp:sn.skip.enabled') && ('s' == String(this.val.getVal('sys:sn.skip.mode')))) {\n            this.goTxt();\n            return false;\n        }\n        if (this.val.getVal('tmp:sn.auto.enabled')) {\n            return this.wait({\n                time: Number(this.scrItr.isKidoku\n                    ? this.val.getVal('sys:sn.auto.msecPageWait_Kidoku')\n                    : this.val.getVal('sys:sn.auto.msecPageWait'))\n            });\n        }\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'visible', true))\n            this.layMng.breakPage();\n        this.stdWait(this.layMng.getCurrentTxtlayFore()\n            && CmnLib_1.CmnLib.argChk_Boolean(hArg, 'er', false)\n            ? () => { this.hTag.er(hArg); this.main.resume(); }\n            : () => this.main.resume());\n        return true;\n    }\n    set_cancel_skip() {\n        this.fncCancelSkip = () => {\n            this.fncCancelSkip = () => { };\n            this.val.setVal_Nochk('tmp', 'sn.tagL.enabled', true);\n            this.val.setVal_Nochk('tmp', 'sn.skip.enabled', false);\n            this.val.setVal_Nochk('tmp', 'sn.auto.enabled', false);\n            this.layMng.setNormalWaitTxtLayer();\n        };\n        this.unregisterClickEvts();\n        return false;\n    }\n    unregisterClickEvts() {\n        const len = this.scrItr.lenCallStk;\n        for (let i = 0; i < len; ++i) {\n            const cs = this.scrItr.getCallStk(i);\n            if (!cs)\n                continue;\n            const hE1T = cs.hEvt1Time;\n            if (!hE1T)\n                continue;\n            delete hE1T['Click'];\n            delete hE1T['Enter'];\n            delete hE1T['ArrowDown'];\n            delete hE1T['wheel.y>0'];\n        }\n    }\n    wait(hArg) {\n        this.val.saveKidoku();\n        const twSleep = new TWEEN.default.Tween(this)\n            .to({}, CmnLib_1.uint(CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN)))\n            .onComplete(() => this.main.resume())\n            .start();\n        this.stdWait(() => twSleep.stop().end(), CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true));\n        return true;\n    }\n    isSkipKeyDown() {\n        for (const v in this.hDownKeys)\n            if (this.hDownKeys[v] == 2)\n                return true;\n        return false;\n    }\n}\nexports.EventMng = EventMng;\n//# sourceMappingURL=EventMng.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/EventMng.js?")},"../npm_core/core/lib/sn/FrameMng.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/FrameMng.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnTween_1 = __webpack_require__(/*! ./CmnTween */ \"../npm_core/core/lib/sn/CmnTween.js\");\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\nclass FrameMng {\n    constructor(hTag, appPixi, val, main, sys, hTwInf) {\n        this.appPixi = appPixi;\n        this.val = val;\n        this.main = main;\n        this.sys = sys;\n        this.hTwInf = hTwInf;\n        this.hIfrm = Object.create(null);\n        hTag.add_frame = o => this.add_frame(o);\n        hTag.let_frame = o => this.let_frame(o);\n        hTag.set_frame = o => this.set_frame(o);\n        hTag.frame = o => this.frame(o);\n        hTag.tsy_frame = o => this.tsy_frame(o);\n    }\n    setEvtMng(evtMng) { this.evtMng = evtMng; }\n    destroy() {\n        for (const k in this.hIfrm) {\n            const v = this.hIfrm[k];\n            v.parentElement.removeChild(v);\n        }\n    }\n    add_frame(hArg) {\n        const id = hArg.id;\n        if (!id)\n            throw 'idは必須です';\n        const src = hArg.src;\n        if (!src)\n            throw 'srcは必須です';\n        const frmnm = `const.sn.frm.${id}`;\n        if (this.val.getVal(`tmp:${frmnm}`))\n            throw `frame【${id}】はすでにあります`;\n        const a = CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', 1);\n        const sx = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', 1);\n        const sy = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', 1);\n        const r = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotate', 0);\n        const v = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'visible', true);\n        const b_color = hArg.b_color ? ` background-color: ${hArg.b_color};` : '';\n        const rct = this.rect(hArg);\n        const scale = this.sys.reso4frame * CmnLib_1.CmnLib.cvsScale;\n        this.appPixi.view.insertAdjacentHTML('beforebegin', `<iframe id=\"${id}\" sandbox=\"allow-scripts allow-same-origin\" src=\"${this.sys.cur + src}\" style=\"z-index: 1; opacity: ${a}; position: absolute; left:${this.sys.ofsLeft4frm + rct.x * scale}px; top: ${this.sys.ofsTop4frm + rct.y * scale}px; border: 0px; overflow: hidden; display: ${v ? 'inline' : 'none'};${b_color}\" width=\"${rct.width * scale}\" height=\"${rct.height * scale}\" transform: scale(${sx}, ${sy}) rotate(${r}deg);></iframe>`);\n        const ifrm = document.getElementById(id);\n        this.hIfrm[id] = ifrm;\n        const win = ifrm.contentWindow;\n        win.addEventListener('load', () => {\n            this.val.setVal_Nochk('tmp', frmnm, true);\n            this.val.setVal_Nochk('tmp', frmnm + '.alpha', a);\n            this.val.setVal_Nochk('tmp', frmnm + '.x', rct.x);\n            this.val.setVal_Nochk('tmp', frmnm + '.y', rct.y);\n            this.val.setVal_Nochk('tmp', frmnm + '.scale_x', sx);\n            this.val.setVal_Nochk('tmp', frmnm + '.scale_y', sy);\n            this.val.setVal_Nochk('tmp', frmnm + '.rotate', r);\n            this.val.setVal_Nochk('tmp', frmnm + '.width', rct.width);\n            this.val.setVal_Nochk('tmp', frmnm + '.height', rct.height);\n            this.val.setVal_Nochk('tmp', frmnm + '.visible', v);\n            this.evtMng.resvFlameEvent(win);\n            this.main.resume();\n        }, { once: true, passive: true });\n        return true;\n    }\n    rect(hArg) {\n        const a = Object.assign({}, hArg);\n        const re = this.sys.resolution;\n        return new DOMRect(CmnLib_1.CmnLib.argChk_Num(a, 'x', 0) * re, CmnLib_1.CmnLib.argChk_Num(a, 'y', 0) * re, CmnLib_1.CmnLib.argChk_Num(a, 'width', CmnLib_1.CmnLib.stageW) * re, CmnLib_1.CmnLib.argChk_Num(a, 'height', CmnLib_1.CmnLib.stageH) * re);\n    }\n    let_frame(hArg) {\n        const id = hArg.id;\n        if (!id)\n            throw 'idは必須です';\n        const frmnm = `const.sn.frm.${id}`;\n        if (!this.val.getVal(`tmp:${frmnm}`))\n            throw `frame【${id}】が読み込まれていません`;\n        const var_name = hArg.var_name;\n        if (!var_name)\n            throw 'var_nameは必須です';\n        const ifrm = document.getElementById(id);\n        const win = ifrm.contentWindow;\n        if (!win.hasOwnProperty(var_name))\n            throw `frame【${id}】に変数/関数【${var_name}】がありません。変数は var付きにして下さい`;\n        const v = win[var_name];\n        this.val.setVal_Nochk('tmp', frmnm + '.' + var_name, CmnLib_1.CmnLib.argChk_Boolean(hArg, 'function', false) ? v() : v);\n        return false;\n    }\n    set_frame(hArg) {\n        const id = hArg.id;\n        if (!id)\n            throw 'idは必須です';\n        const frmnm = `const.sn.frm.${id}`;\n        if (!this.val.getVal(`tmp:${frmnm}`))\n            throw `frame【${id}】が読み込まれていません`;\n        const var_name = hArg.var_name;\n        if (!var_name)\n            throw 'var_nameは必須です';\n        const text = hArg.text;\n        if (!text)\n            throw 'textは必須です';\n        this.val.setVal_Nochk('tmp', frmnm + '.' + var_name, text);\n        const ifrm = document.getElementById(id);\n        const win = ifrm.contentWindow;\n        win[var_name] = text;\n        return false;\n    }\n    frame(hArg) {\n        const id = hArg.id;\n        if (!id)\n            throw 'idは必須です';\n        const frmnm = `const.sn.frm.${id}`;\n        if (!this.val.getVal(`tmp:${frmnm}`))\n            throw `frame【${id}】が読み込まれていません`;\n        const ifrm = document.getElementById(id);\n        if ('alpha' in hArg) {\n            const a = String(hArg.alpha);\n            ifrm.style.opacity = a;\n            this.val.setVal_Nochk('tmp', frmnm + '.alpha', a);\n        }\n        const rct = this.rect(hArg);\n        const scale = this.sys.reso4frame * CmnLib_1.CmnLib.cvsScale;\n        if ('x' in hArg || 'y' in hArg) {\n            ifrm.style.left = this.sys.ofsLeft4frm + rct.x * scale + 'px';\n            ifrm.style.top = this.sys.ofsTop4frm + rct.y * scale + 'px';\n            this.val.setVal_Nochk('tmp', frmnm + '.x', rct.x);\n            this.val.setVal_Nochk('tmp', frmnm + '.y', rct.y);\n        }\n        if ('scale_x' in hArg || 'scale_y' in hArg || 'rotate' in hArg) {\n            const sx = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', 1);\n            const sy = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', 1);\n            const r = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotate', 0);\n            ifrm.style.transform = `scale(${sx}, ${sy}) rotate(${r}deg)`;\n            this.val.setVal_Nochk('tmp', frmnm + '.scale_x', sx);\n            this.val.setVal_Nochk('tmp', frmnm + '.scale_y', sy);\n            this.val.setVal_Nochk('tmp', frmnm + '.rotate', r);\n        }\n        if ('width' in hArg) {\n            ifrm.style.width = String(rct.width * scale);\n            this.val.setVal_Nochk('tmp', frmnm + '.width', rct.width);\n        }\n        if ('height' in hArg) {\n            ifrm.style.height = String(rct.height * scale);\n            this.val.setVal_Nochk('tmp', frmnm + '.height', rct.height);\n        }\n        if ('visible' in hArg) {\n            const v = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'visible', true);\n            ifrm.style.display = v ? 'inline' : 'none';\n            this.val.setVal_Nochk('tmp', frmnm + '.visible', v);\n        }\n        if ('b_color' in hArg) {\n            ifrm.style.backgroundColor = hArg.b_color;\n        }\n        return false;\n    }\n    tsy_frame(hArg) {\n        const id = hArg.id;\n        if (!id)\n            throw 'idは必須です';\n        const frmnm = `const.sn.frm.${id}`;\n        if (!this.val.getVal(`tmp:${frmnm}`, 0))\n            throw `frame【${id}】が読み込まれていません`;\n        const ease = CmnTween_1.CmnTween.ease(hArg.ease);\n        const ifrm = document.getElementById(id);\n        const hNow = {};\n        const hTo = {};\n        const repeat = CmnLib_1.CmnLib.argChk_Num(hArg, 'repeat', 1);\n        let fncA = () => { };\n        if ('alpha' in hArg) {\n            hNow.a = ifrm.style.opacity;\n            hTo.a = CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', 0);\n            fncA = () => {\n                ifrm.style.opacity = hNow.a;\n                this.val.setVal_Nochk('tmp', 'alpha', hNow.a);\n            };\n        }\n        let fncXYSR = () => { };\n        const rct = this.rect(hArg);\n        const scale = this.sys.reso4frame * CmnLib_1.CmnLib.cvsScale;\n        if ('x' in hArg || 'y' in hArg\n            || 'scale_x' in hArg || 'scale_y' in hArg || 'rotate' in hArg) {\n            hNow.x = Number(this.val.getVal(`tmp:${frmnm}.x`));\n            hNow.y = Number(this.val.getVal(`tmp:${frmnm}.y`));\n            hNow.sx = Number(this.val.getVal(`tmp:${frmnm}.scale_x`));\n            hNow.sy = Number(this.val.getVal(`tmp:${frmnm}.scale_y`));\n            hNow.r = Number(this.val.getVal(`tmp:${frmnm}.rotate`));\n            hTo.x = rct.x;\n            hTo.y = rct.y;\n            hTo.sx = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', 1);\n            hTo.sy = CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', 1);\n            hTo.r = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotate', 0);\n            fncXYSR = () => {\n                ifrm.style.left = this.sys.ofsLeft4frm + hNow.x * scale + 'px';\n                ifrm.style.top = this.sys.ofsTop4frm + hNow.y * scale + 'px';\n                ifrm.style.transform = `scale(${hNow.sx}, ${hNow.sy}) rotate(${hNow.r}deg)`;\n                this.val.setVal_Nochk('tmp', frmnm + '.x', hNow.x);\n                this.val.setVal_Nochk('tmp', frmnm + '.y', hNow.y);\n                this.val.setVal_Nochk('tmp', frmnm + '.scale_x', hNow.sx);\n                this.val.setVal_Nochk('tmp', frmnm + '.scale_y', hNow.sy);\n                this.val.setVal_Nochk('tmp', frmnm + '.rotate', hNow.r);\n            };\n        }\n        let fncW = () => { };\n        if ('width' in hArg) {\n            hNow.w = this.val.getVal(`tmp:${frmnm}.width`);\n            hTo.w = rct.width;\n            fncW = () => {\n                ifrm.style.width = hNow.w * scale + 'px';\n                this.val.setVal_Nochk('tmp', frmnm + '.width', hNow.w);\n            };\n        }\n        let fncH = () => { };\n        if ('height' in hArg) {\n            hNow.h = this.val.getVal(`tmp:${frmnm}.height`);\n            hTo.h = rct.height;\n            fncH = () => {\n                ifrm.style.height = hNow.h * scale + 'px';\n                this.val.setVal_Nochk('tmp', frmnm + '.height', hNow.h);\n            };\n        }\n        this.appPixi.stage.interactive = false;\n        const tw_nm = `frm\\n${hArg.id}`;\n        const tw = new TWEEN.default.Tween(hNow)\n            .to(hTo, CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN)\n            * (Boolean(this.val.getVal('tmp:sn.skip.enabled')) ? 0 : 1))\n            .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n            .easing(ease)\n            .repeat(repeat == 0 ? Infinity : (repeat - 1))\n            .yoyo(CmnLib_1.CmnLib.argChk_Boolean(hArg, 'yoyo', false))\n            .onUpdate(() => { fncA(); fncXYSR(); fncW(); fncH(); })\n            .onComplete(() => {\n            this.appPixi.stage.interactive = true;\n            const twInf = this.hTwInf[tw_nm];\n            if (!twInf)\n                return;\n            delete this.hTwInf[tw_nm];\n            this.evtMng.popLocalEvts();\n            if (twInf.resume)\n                this.main.resume();\n            if (twInf.onComplete)\n                twInf.onComplete();\n        })\n            .start();\n        this.hTwInf[tw_nm] = { tw: tw, resume: false, onComplete: () => { } };\n        return false;\n    }\n}\nexports.FrameMng = FrameMng;\n//# sourceMappingURL=FrameMng.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/FrameMng.js?")},"../npm_core/core/lib/sn/Grammar.js":
/*!******************************************!*\
  !*** ../npm_core/core/lib/sn/Grammar.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst RubySpliter_1 = __webpack_require__(/*! ./RubySpliter */ \"../npm_core/core/lib/sn/RubySpliter.js\");\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nclass Grammar {\n    constructor() {\n        this.regC2M = new RegExp('');\n        this.regStrC2M = '';\n        this.regStrC2M4not = '';\n        this.replaceScr_C2M_And_let_ml = (scr, start_idx = 0) => {\n            if (!this.hC2M)\n                return;\n            for (let i = scr.len - 1; i >= start_idx; --i) {\n                const token = scr.aToken[i];\n                this.REG_TOKEN_NOTXT.lastIndex = 0;\n                if (this.REG_TOKEN_NOTXT.test(token.charAt(0)))\n                    continue;\n                const lnum = scr.aLNum[i];\n                const a = token.match(this.regC2M);\n                if (!a)\n                    continue;\n                let del = 1;\n                for (let j = a.length - 1; j >= 0; --j) {\n                    let ch = a[j];\n                    const macro = this.hC2M[ch.charAt(0)];\n                    if (macro) {\n                        ch = macro + ((macro.substr(-1) == ']')\n                            ? ''\n                            : (`'${ch.slice(1, -1)}']`));\n                    }\n                    scr.aToken.splice(i, del, ch);\n                    scr.aLNum.splice(i, del, lnum);\n                    del = 0;\n                }\n            }\n            scr.len = scr.aToken.length;\n        };\n        this.REG_MULTILINE_TAG = m_xregexp(`\\\\[\n\t\t([^\\\\n\\\\]]+ \\\\n\n\t\t\t(?:\n\t\t\t\t([\"'#]) .*? \\\\2\n\t\t\t|\t[^\\\\[\\\\]]\n\t\t\t)*\n\t\t)\n\t\\\\]\n|\t;[^\\\\n]+`, 'gx');\n        this.setEscape('');\n    }\n    mkEscape(ce) {\n        return m_xregexp((ce ? `(?: \\\\${ce}\\\\S) |` : '') +\n            `(?: \\\\[let_ml \\\\s+ [^\\\\[\\\\]]+ \\\\])` +\n            `(?: . | \\\\s)+?` +\n            `(?=\\\\[endlet_ml \\\\s* \\\\])` +\n            `| \\\\[ (?: ([\\\\\"\\\\'\\\\#]) .*? \\\\1 | . ) *? \\\\]` +\n            '| \\\\n+' +\n            '| \\\\t+' +\n            '| &[^&\\\\n]+&' +\n            '| &&?[^;\\\\n\\\\t&]+' +\n            '| ;[^\\\\n]+' +\n            '| ^\\\\*\\\\w+' +\n            `| [^\\\\n\\\\t\\\\[;${ce ? `\\\\${ce}` : ''}]+`, 'gx');\n    }\n    setEscape(ce) {\n        if (this.hC2M && (ce in this.hC2M))\n            throw '[エスケープ文字] char【' + ce + '】が登録済みの括弧マクロまたは一文字マクロです';\n        this.REG_TOKEN = this.mkEscape(ce);\n        RubySpliter_1.RubySpliter.setEscape(ce);\n        this.REG_CANTC2M = new RegExp(`[\\w\\s;[\\]*=&｜《》${ce}]`);\n        this.REG_TOKEN_NOTXT = new RegExp(`[\\n\\t;\\[*&${ce ? `\\\\${ce}` : ''}]`);\n    }\n    bracket2macro(hArg, script, idxToken) {\n        var _a;\n        const name = hArg.name;\n        if (!name)\n            throw '[bracket2macro] nameは必須です';\n        const text = hArg.text;\n        if (!text)\n            throw '[bracket2macro] textは必須です';\n        if (text.length != 2)\n            throw '[bracket2macro] textは括弧の前後を示す二文字を指定してください';\n        this.hC2M = (_a = this.hC2M, (_a !== null && _a !== void 0 ? _a : {}));\n        const op = text.charAt(0);\n        const cl = text.charAt(1);\n        if (op in this.hC2M)\n            throw '[bracket2macro] text【' + op + '】が登録済みの括弧マクロまたは一文字マクロです';\n        if (cl in this.hC2M)\n            throw '[bracket2macro] text【' + cl + '】が登録済みの括弧マクロまたは一文字マクロです';\n        this.REG_CANTC2M.lastIndex = 0;\n        if (this.REG_CANTC2M.test(op))\n            throw '[bracket2macro] text【' + op + '】は括弧マクロに使用できない文字です';\n        this.REG_CANTC2M.lastIndex = 0;\n        if (this.REG_CANTC2M.test(cl))\n            throw '[bracket2macro] text【' + cl + '】は括弧マクロに使用できない文字です';\n        this.hC2M[cl] = '0';\n        this.hC2M[op] = '[' + name + ' text=';\n        this.addC2M(`\\\\${op}[^\\\\${cl}]*\\\\${cl}`, `\\\\${op}\\\\${cl}`);\n        this.replaceScr_C2M_And_let_ml(script, idxToken);\n    }\n    char2macro(hArg, hTag, script, idxToken) {\n        var _a;\n        const char = hArg.char;\n        if (!char)\n            throw '[char2macro] charは必須です';\n        this.hC2M = (_a = this.hC2M, (_a !== null && _a !== void 0 ? _a : {}));\n        if (char in this.hC2M)\n            throw '[char2macro] char【' + char + '】が登録済みの括弧マクロまたは一文字マクロです';\n        this.REG_CANTC2M.lastIndex = 0;\n        if (this.REG_CANTC2M.test(char))\n            throw '[char2macro] char【' + char + '】は一文字マクロに使用できない文字です';\n        const name = hArg.name;\n        if (!name)\n            throw '[char2macro] nameは必須です';\n        if (!(name in hTag))\n            throw '[char2macro] 未定義のタグ又はマクロ[' + name + ']です';\n        this.hC2M[char] = '[' + name + ']';\n        this.addC2M(`\\\\${char}`, `\\\\${char}`);\n        this.replaceScr_C2M_And_let_ml(script, idxToken);\n    }\n    addC2M(a, b) {\n        this.regStrC2M += `${a}|`;\n        this.regStrC2M4not += `${b}`;\n        this.regC2M = new RegExp(`(${this.regStrC2M}[^${this.regStrC2M4not}]+)`, 'g');\n    }\n    cnvMultilineTag(txt) {\n        return txt.replace(this.REG_MULTILINE_TAG, function () {\n            if (arguments[0].charAt(0) == ';')\n                return arguments[0];\n            let fore = '';\n            let back = '';\n            for (const v of arguments[1].match(Grammar.REG_MULTILINE_TAG_SPLIT)) {\n                switch (v.substr(-1)) {\n                    case '\\n':\n                        back += v;\n                        break;\n                    case `\"`:\n                    case `'`:\n                    case `#`:\n                        fore += v;\n                        break;\n                    default:\n                        fore += ' ' + CmnLib_1.trim(v);\n                        break;\n                }\n            }\n            return '[' + CmnLib_1.trim(fore.slice(1)) + ']' + back;\n        });\n    }\n    static splitAmpersand(token) {\n        const equa = token.replace(/==/g, '＝').replace(/!=/g, '≠').split('=');\n        const cnt_equa = equa.length;\n        if (cnt_equa < 2 || cnt_equa > 3)\n            throw '「&計算」書式では「=」指定が一つか二つ必要です';\n        if (equa[1].charAt(0) == '&')\n            throw '「&計算」書式では「&」指定が不要です';\n        return {\n            name: equa[0].replace(/＝/g, '==').replace(/≠/g, '!='),\n            text: equa[1].replace(/＝/g, '==').replace(/≠/g, '!='),\n            cast: ((cnt_equa == 3) ? CmnLib_1.trim(equa[2]) : null)\n        };\n    }\n}\nexports.Grammar = Grammar;\nGrammar.REG_MULTILINE_TAG_SPLIT = m_xregexp(`(([\"'#]).*?\\\\2|;.*\\\\n|\\\\n+|[^\\\\n\"'#;]+)`, 'g');\nGrammar.REG_TAG = m_xregexp(`^\\\\[ (?<name>\\\\S*) (\\\\s+ (?<args>.+) )? ]$`, 'x');\n//# sourceMappingURL=Grammar.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Grammar.js?")},"../npm_core/core/lib/sn/GrpLayer.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/GrpLayer.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Layer_1 = __webpack_require__(/*! ./Layer */ \"../npm_core/core/lib/sn/Layer.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst EventListenerCtn_1 = __webpack_require__(/*! ./EventListenerCtn */ \"../npm_core/core/lib/sn/EventListenerCtn.js\");\n;\n;\n;\nclass GrpLayer extends Layer_1.Layer {\n    constructor() {\n        super(...arguments);\n        this.csvFn = '';\n        this.sBkFn = '';\n        this.sBkFace = '';\n        this.record = () => Object.assign(super.record(), {\n            sBkFn: this.sBkFn,\n            sBkFace: this.sBkFace,\n        });\n        this.dump = () => super.dump() + `, \"pic\":\"${this.csvFn}\"`;\n    }\n    static init(main, cfg, sys) {\n        GrpLayer.main = main;\n        GrpLayer.cfg = cfg;\n        GrpLayer.sys = sys;\n    }\n    static setEvtMng(evtMng) { GrpLayer.evtMng = evtMng; }\n    static destroy() {\n        GrpLayer.elc.clear();\n        GrpLayer.hFace = {};\n        GrpLayer.hFn2ResAniSpr = {};\n    }\n    lay(hArg) {\n        var _a;\n        const fn = hArg.fn;\n        const face = (_a = hArg.face, (_a !== null && _a !== void 0 ? _a : ''));\n        if (!fn) {\n            super.lay(hArg);\n            if (this.cnt.children.length > 0)\n                this.setPos(hArg);\n            this.sBkFn = '';\n            this.csvFn = this.sBkFace = face;\n            return false;\n        }\n        const inFn = 'fn' in hArg;\n        const inFace = 'face' in hArg;\n        this.clearLay({ filter: 'true' });\n        if (inFn)\n            this.sBkFn = fn;\n        if (inFace)\n            this.sBkFace = face;\n        super.lay(hArg);\n        hArg.dx = 0;\n        hArg.dy = 0;\n        return GrpLayer.csv2Sprites(this.csvFn = fn + (face ? ',' + face : ''), this.cnt, sp => {\n            Layer_1.Layer.setXY(sp, hArg, this.cnt, true);\n        }, GrpLayer.fncAllComp);\n    }\n    static csv2Sprites(csv, parent, fncFirstComp, fncAllComp = () => { }) {\n        const aComp = [];\n        let needLoad = false;\n        const ldr = new pixi_js_1.Loader();\n        csv.split(',').forEach((fn, i) => {\n            if (!fn)\n                throw 'face属性に空要素が含まれます';\n            const f = GrpLayer.hFace[fn] || {\n                fn: fn,\n                dx: 0,\n                dy: 0,\n                blendmode: pixi_js_1.BLEND_MODES.NORMAL\n            };\n            const fnc = (i == 0) ? fncFirstComp : (sp) => {\n                sp.x = f.dx;\n                sp.y = f.dy;\n                sp.blendMode = f.blendmode;\n            };\n            aComp.push({ fn: f.fn, fnc: fnc });\n            if (f.fn in GrpLayer.hFn2ResAniSpr)\n                return;\n            if (f.fn in pixi_js_1.utils.TextureCache)\n                return;\n            if (f.fn in pixi_js_1.Loader.shared.resources)\n                return;\n            needLoad = true;\n            ldr.add(f.fn, GrpLayer.cfg.searchPath(f.fn, Config_1.Config.EXT_SPRITE));\n        });\n        const fncLoaded = (res) => {\n            for (const v of aComp) {\n                const sp = GrpLayer.mkSprite(v.fn, res);\n                parent.addChild(sp);\n                v.fnc(sp);\n            }\n            fncAllComp(needLoad);\n        };\n        if (needLoad) {\n            ldr.pre((res, next) => res.load(() => {\n                const d = GrpLayer.sys.pre(res.extension, res.data);\n                if (res.extension == 'json_') {\n                    res.type = 1;\n                    res.data = JSON.parse(d);\n                }\n                else\n                    res.data = d;\n                next();\n            }))\n                .load((_loader, res) => fncLoaded(res));\n        }\n        else\n            fncLoaded(pixi_js_1.utils.TextureCache);\n        return needLoad;\n    }\n    static mkSprite(fn, res) {\n        var _a;\n        if (fn in pixi_js_1.utils.TextureCache)\n            return new pixi_js_1.Sprite(pixi_js_1.Texture.from(fn));\n        const ras = GrpLayer.hFn2ResAniSpr[fn];\n        if (ras) {\n            const asp = new pixi_js_1.AnimatedSprite(ras.aTex);\n            asp.animationSpeed = (_a = ras.meta['animationSpeed'], (_a !== null && _a !== void 0 ? _a : 1.0));\n            asp.play();\n            return asp;\n        }\n        const r = res[fn];\n        if (!r)\n            return new pixi_js_1.Sprite;\n        switch (r.type) {\n            case 1:\n                const aFK = r.spritesheet._frameKeys;\n                const a_base_name = /([^\\d]+)\\d+\\.(\\w+)/.exec(aFK[0]);\n                if (a_base_name) {\n                    const is = a_base_name[1].length;\n                    const ie = -a_base_name[2].length - 1;\n                    aFK.sort((a, b) => (CmnLib_1.int(a.slice(is, ie)) > CmnLib_1.int(b.slice(is, ie))) ? 1 : -1);\n                }\n                const aTex = [];\n                for (const v of aFK)\n                    aTex.push(pixi_js_1.Texture.from(v));\n                GrpLayer.hFn2ResAniSpr[r.name] = { aTex: aTex, meta: r.data.meta };\n                return GrpLayer.mkSprite(fn, res);\n            case 5:\n                const hve = r.data;\n                GrpLayer.fn2Video[fn] = hve;\n                return new pixi_js_1.Sprite(pixi_js_1.Texture.from(r.data));\n            default: return new pixi_js_1.Sprite(r.texture);\n        }\n    }\n    static wv(hArg) {\n        const fn = hArg.fn;\n        if (!fn)\n            throw 'fnは必須です';\n        const hve = GrpLayer.fn2Video[fn];\n        if (!hve)\n            return false;\n        if (hve.ended) {\n            delete GrpLayer.fn2Video[fn];\n            return false;\n        }\n        const fnc = () => {\n            hve.removeEventListener('ended', fnc);\n            delete GrpLayer.fn2Video[fn];\n            this.main.resume();\n        };\n        hve.addEventListener('ended', fnc, { once: true, passive: true });\n        GrpLayer.evtMng.stdWait(() => { hve.pause(); fnc(); }, CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true));\n        return true;\n    }\n    static ldPic(fn, fnc) {\n        const url = GrpLayer.cfg.searchPath(fn, Config_1.Config.EXT_SPRITE);\n        const tx = pixi_js_1.utils.TextureCache[url];\n        if (tx) {\n            fnc(tx);\n            return;\n        }\n        const tx2 = pixi_js_1.Texture.from(url);\n        GrpLayer.elc.add(tx2.baseTexture, 'loaded', () => fnc(tx2));\n    }\n    setPos(hArg) {\n        Layer_1.Layer.setXY((this.cnt.children.length == 0) ? this.cnt : this.cnt.children[0], hArg, this.cnt, true);\n    }\n    static add_face(hArg) {\n        var _a;\n        const name = hArg.name;\n        if (!name)\n            throw 'nameは必須です';\n        if (name in GrpLayer.hFace)\n            throw '一つのname（' + name + '）に対して同じ画像を複数割り当てられません';\n        const fn = (_a = hArg.fn, (_a !== null && _a !== void 0 ? _a : name));\n        GrpLayer.hFace[name] = {\n            fn: fn,\n            dx: CmnLib_1.CmnLib.argChk_Num(hArg, 'dx', 0) * CmnLib_1.CmnLib.retinaRate,\n            dy: CmnLib_1.CmnLib.argChk_Num(hArg, 'dy', 0) * CmnLib_1.CmnLib.retinaRate,\n            blendmode: Layer_1.Layer.cnvBlendmode(hArg.blendmode || '')\n        };\n        return false;\n    }\n    static clearFace2Name() { GrpLayer.hFace = {}; }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        for (const c of this.cnt.removeChildren())\n            c.destroy();\n        this.sBkFn = '';\n        this.sBkFace = '';\n        this.csvFn = '';\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        if (hLay.sBkFn == '' && hLay.sBkFace == '') {\n            this.sBkFn = hLay.sBkFn;\n            this.sBkFace = hLay.sBkFace;\n            if (fncComp != undefined)\n                fncComp();\n            return false;\n        }\n        if (fncComp != undefined)\n            GrpLayer.fncAllComp = () => {\n                GrpLayer.fncAllComp = GrpLayer.fncDefAllComp;\n                fncComp();\n            };\n        return this.lay({ fn: hLay.sBkFn, face: hLay.sBkFace, left: hLay.x, top: hLay.y });\n    }\n}\nexports.GrpLayer = GrpLayer;\nGrpLayer.elc = new EventListenerCtn_1.EventListenerCtn;\nGrpLayer.hFace = {};\nGrpLayer.hFn2ResAniSpr = {};\nGrpLayer.fncDefAllComp = (isStop) => { if (isStop)\n    GrpLayer.main.resume(); };\nGrpLayer.fncAllComp = GrpLayer.fncDefAllComp;\nGrpLayer.fn2Video = {};\n//# sourceMappingURL=GrpLayer.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/GrpLayer.js?")},"../npm_core/core/lib/sn/Layer.js":
/*!****************************************!*\
  !*** ../npm_core/core/lib/sn/Layer.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nclass Layer {\n    constructor() {\n        this.name = '';\n        this.cnt = new pixi_js_1.Sprite(pixi_js_1.Texture.EMPTY);\n    }\n    get alpha() { return this.cnt.alpha; }\n    set alpha(v) { this.cnt.alpha = v; }\n    get height() { return this.cnt.getBounds().height; }\n    get rotation() { return this.cnt.rotation; }\n    set rotation(v) { this.cnt.rotation = v; }\n    get scale_x() { return this.cnt.scale.x; }\n    set scale_x(v) { this.cnt.scale.x = v; }\n    get scale_y() { return this.cnt.scale.y; }\n    set scale_y(v) { this.cnt.scale.y = v; }\n    get width() { return this.cnt.getBounds().width; }\n    get x() { return this.cnt.x; }\n    set x(v) { this.cnt.x = v; }\n    get y() { return this.cnt.y; }\n    set y(v) { this.cnt.y = v; }\n    destroy() { }\n    lay(hArg) {\n        if ('alpha' in hArg)\n            this.cnt.alpha = CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', this.cnt.alpha);\n        if ('pivot_x' in hArg || 'pivot_y' in hArg)\n            this.cnt.pivot.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_x', this.cnt.pivot.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'pivot_y', this.cnt.pivot.y));\n        if ('rotation' in hArg)\n            this.cnt.angle = CmnLib_1.CmnLib.argChk_Num(hArg, 'rotation', this.cnt.angle);\n        if ('scale_x' in hArg || 'scale_y' in hArg)\n            this.cnt.scale.set(CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', this.cnt.scale.x), CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', this.cnt.scale.y));\n        if ('visible' in hArg)\n            this.cnt.visible = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'visible', this.cnt.visible);\n        return false;\n    }\n    clearLay(hArg) {\n        this.cnt.alpha = 1;\n        this.cnt.blendMode = pixi_js_1.BLEND_MODES.NORMAL;\n        this.cnt.pivot.set(0, 0);\n        this.cnt.rotation = 0;\n        this.cnt.scale.set(1, 1);\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'filter', false))\n            this.cnt.filters = [];\n    }\n    copy(fromLayer) {\n        const org_name = this.name;\n        this.playback(fromLayer.record());\n        this.name = org_name;\n    }\n    record() {\n        return {\n            name: this.name,\n            idx: this.cnt.parent.getChildIndex(this.cnt),\n            alpha: this.cnt.alpha,\n            blendMode: this.cnt.blendMode,\n            rotation: this.cnt.rotation,\n            scale_x: this.cnt.scale.x,\n            scale_y: this.cnt.scale.y,\n            pivot_x: this.cnt.pivot.x,\n            pivot_y: this.cnt.pivot.y,\n            x: this.cnt.x,\n            y: this.cnt.y,\n            visible: this.cnt.visible,\n        };\n    }\n    playback(hLay, _fncComp = undefined) {\n        this.name = hLay.name;\n        this.clearLay({ filter: 'true' });\n        this.cnt.alpha = hLay.alpha;\n        this.cnt.blendMode = hLay.blendMode;\n        this.cnt.rotation = hLay.rotation;\n        this.cnt.scale.set(hLay.scale_x, hLay.scale_y);\n        this.cnt.pivot.set(hLay.pivot_x, hLay.pivot_y);\n        this.cnt.position.set(hLay.x, hLay.y);\n        this.cnt.visible = hLay.visible;\n        return false;\n    }\n    snapshot(rnd, re) {\n        rnd.render(this.cnt, undefined, false);\n        re();\n    }\n    snapshot_end() { }\n    cvsResize() { }\n    dump() {\n        return ` \"idx\":${this.cnt.parent.getChildIndex(this.cnt)}, \"visible\":\"${this.cnt.visible}\", \"left\":${this.cnt.x}, \"top\":${this.cnt.y}, \"alpha\":${this.cnt.alpha}, \"rotation\":${this.cnt.rotation}, \"name\":\"${this.name}\", \"scale_x\":${this.cnt.scale.x}, \"scale_y\":${this.cnt.scale.y}`;\n    }\n    static argChk_BlendmodeAndSet(hash, $do) {\n        const v = hash['blendmode'];\n        if (!v)\n            return;\n        if (!($do instanceof pixi_js_1.Sprite))\n            return;\n        const sp = $do;\n        if (!(v in Layer.hBlendmode))\n            throw 'blendmode=' + v + ' は異常な値です';\n        if (!Layer.hBlendmode[v])\n            throw '（' + name + '）はサポートされない blendmode です';\n        sp.blendMode = v;\n    }\n    static cnvBlendmode(name) {\n        if (!name)\n            return pixi_js_1.BLEND_MODES.NORMAL;\n        const bm = Layer.hBlendmode[name];\n        if (bm)\n            return bm;\n        throw '（' + name + '）はサポートされない blendmode です';\n    }\n    static setXY(base, hArg, ret, isGrp = false, isButton = false) {\n        if (hArg.pos) {\n            Layer.setXYByPos(base, hArg.pos, ret);\n            return;\n        }\n        const rct_base = base.getBounds();\n        const r_absclX = (ret.scale.x < 0) ? -ret.scale.x : ret.scale.x;\n        const b_width = (r_absclX == 1)\n            ? rct_base.width : rct_base.width * r_absclX;\n        const r_absclY = (ret.scale.y < 0) ? -ret.scale.y : ret.scale.y;\n        const b_height = (r_absclY == 1)\n            ? rct_base.height : rct_base.height * r_absclY;\n        let x = ret.x;\n        if ('left' in hArg) {\n            x = CmnLib_1.CmnLib.argChk_Num(hArg, 'left', 0);\n            if ((x > -1) && (x < 1))\n                x *= CmnLib_1.CmnLib.stageW;\n        }\n        else if ('center' in hArg) {\n            x = CmnLib_1.CmnLib.argChk_Num(hArg, 'center', 0);\n            if ((x > -1) && (x < 1))\n                x *= CmnLib_1.CmnLib.stageW;\n            x = x - (isButton ? b_width / 3 : b_width) / 2;\n        }\n        else if ('right' in hArg) {\n            x = CmnLib_1.CmnLib.argChk_Num(hArg, 'right', 0);\n            if ((x > -1) && (x < 1))\n                x *= CmnLib_1.CmnLib.stageW;\n            x = x - (isButton ? b_width / 3 : b_width);\n        }\n        else if ('s_right' in hArg) {\n            x = CmnLib_1.CmnLib.argChk_Num(hArg, 's_right', 0);\n            if ((x > -1) && (x < 1))\n                x *= CmnLib_1.CmnLib.stageW;\n            x = CmnLib_1.CmnLib.stageW - x\n                - (isButton ? b_width / 3 : b_width);\n        }\n        ret.x = CmnLib_1.int(((ret.scale.x < 0)\n            ? x + (isButton ? b_width / 3 : b_width)\n            : x) * CmnLib_1.CmnLib.retinaRate);\n        let y = ret.y;\n        if ('top' in hArg) {\n            y = CmnLib_1.CmnLib.argChk_Num(hArg, 'top', 0);\n            if ((y > -1) && (y < 1))\n                y *= CmnLib_1.CmnLib.stageH;\n        }\n        else if ('middle' in hArg) {\n            y = CmnLib_1.CmnLib.argChk_Num(hArg, 'middle', 0);\n            if ((y > -1) && (y < 1))\n                y *= CmnLib_1.CmnLib.stageH;\n            y = y - b_height / 2;\n        }\n        else if ('bottom' in hArg) {\n            y = CmnLib_1.CmnLib.argChk_Num(hArg, 'bottom', 0);\n            if ((y > -1) && (y < 1))\n                y *= CmnLib_1.CmnLib.stageH;\n            y = y - b_height;\n        }\n        else if ('s_bottom' in hArg) {\n            y = CmnLib_1.CmnLib.argChk_Num(hArg, 's_bottom', 0);\n            if ((y > -1) && (y < 1))\n                y *= CmnLib_1.CmnLib.stageH;\n            y = CmnLib_1.CmnLib.stageH - y - b_height;\n        }\n        ret.y = CmnLib_1.int(((ret.scale.y < 0) ? y + b_height : y)\n            * CmnLib_1.CmnLib.retinaRate);\n        if (isGrp) {\n            if (!('left' in hArg)\n                && !('center' in hArg)\n                && !('right' in hArg)\n                && !('s_right' in hArg)\n                && !('top' in hArg)\n                && !('middle' in hArg)\n                && !('bottom' in hArg)\n                && !('s_bottom' in hArg)) {\n                Layer.setXYByPos(base, 'c', ret);\n            }\n        }\n    }\n    static setXYByPos(base, pos, ret) {\n        if (pos == 'stay')\n            return;\n        if (base == null)\n            throw 'setXYByPos base == null';\n        if (ret == null)\n            throw 'setXYByPos result == null';\n        const rct_base = base.getBounds();\n        const r_absclX = (ret.scale.x < 0) ? -ret.scale.x : ret.scale.x;\n        const b_width = (r_absclX == 1) ? rct_base.width : rct_base.width * r_absclX;\n        const r_absclY = (ret.scale.y < 0) ? -ret.scale.y : ret.scale.y;\n        const b_height = (r_absclY == 1) ? rct_base.height : rct_base.height * r_absclY;\n        let c = 0;\n        if (!pos || pos == 'c') {\n            c = CmnLib_1.CmnLib.stageW * 0.5;\n        }\n        else if (pos == 'r') {\n            c = CmnLib_1.CmnLib.stageW - b_width * 0.5;\n        }\n        else if (pos == 'l') {\n            c = b_width * 0.5;\n        }\n        else {\n            c = CmnLib_1.int(pos) * CmnLib_1.CmnLib.retinaRate;\n        }\n        ret.x = CmnLib_1.int(c - b_width * 0.5);\n        ret.y = CmnLib_1.CmnLib.stageH - b_height;\n        if (ret.scale.x < 0)\n            ret.x += b_width;\n        if (ret.scale.y < 0)\n            ret.y += b_height;\n    }\n    static setXYCenter(dsp) {\n        const rct = dsp.getBounds();\n        dsp.x = (CmnLib_1.CmnLib.stageW - rct.width) * 0.5;\n        dsp.y = (CmnLib_1.CmnLib.stageH - rct.height) * 0.5;\n    }\n}\nexports.Layer = Layer;\nLayer.hBlendmode = {\n    'normal': pixi_js_1.BLEND_MODES.NORMAL,\n    'add': pixi_js_1.BLEND_MODES.ADD,\n    'multiply': pixi_js_1.BLEND_MODES.MULTIPLY,\n    'screen': pixi_js_1.BLEND_MODES.SCREEN,\n    'overlay': pixi_js_1.BLEND_MODES.OVERLAY,\n    'darken': pixi_js_1.BLEND_MODES.DARKEN,\n    'lighten': pixi_js_1.BLEND_MODES.LIGHTEN,\n    'color_dodge': pixi_js_1.BLEND_MODES.COLOR_DODGE,\n    'color_burn': pixi_js_1.BLEND_MODES.COLOR_BURN,\n    'hard_light': pixi_js_1.BLEND_MODES.HARD_LIGHT,\n    'soft_light': pixi_js_1.BLEND_MODES.SOFT_LIGHT,\n    'difference': pixi_js_1.BLEND_MODES.DIFFERENCE,\n    'exclusion': pixi_js_1.BLEND_MODES.EXCLUSION,\n    'hue': pixi_js_1.BLEND_MODES.HUE,\n    'saturation': pixi_js_1.BLEND_MODES.SATURATION,\n    'color': pixi_js_1.BLEND_MODES.COLOR,\n    'luminosity': pixi_js_1.BLEND_MODES.LUMINOSITY,\n};\n//# sourceMappingURL=Layer.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Layer.js?")},"../npm_core/core/lib/sn/LayerMng.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/LayerMng.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnTween_1 = __webpack_require__(/*! ./CmnTween */ \"../npm_core/core/lib/sn/CmnTween.js\");\nconst Pages_1 = __webpack_require__(/*! ./Pages */ \"../npm_core/core/lib/sn/Pages.js\");\nconst GrpLayer_1 = __webpack_require__(/*! ./GrpLayer */ \"../npm_core/core/lib/sn/GrpLayer.js\");\nconst TxtLayer_1 = __webpack_require__(/*! ./TxtLayer */ \"../npm_core/core/lib/sn/TxtLayer.js\");\nconst RubySpliter_1 = __webpack_require__(/*! ./RubySpliter */ \"../npm_core/core/lib/sn/RubySpliter.js\");\nconst FrameMng_1 = __webpack_require__(/*! ./FrameMng */ \"../npm_core/core/lib/sn/FrameMng.js\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"../npm_core/core/lib/sn/Button.js\");\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst EventListenerCtn_1 = __webpack_require__(/*! ./EventListenerCtn */ \"../npm_core/core/lib/sn/EventListenerCtn.js\");\nclass LayerMng {\n    constructor(cfg, hTag, appPixi, val, main, scrItr, sys) {\n        this.cfg = cfg;\n        this.hTag = hTag;\n        this.appPixi = appPixi;\n        this.val = val;\n        this.main = main;\n        this.scrItr = scrItr;\n        this.sys = sys;\n        this.fore = new pixi_js_1.Container;\n        this.back = new pixi_js_1.Container;\n        this.fncTicker = () => TWEEN.default.update();\n        this.grpCover = null;\n        this.cmdTxt = (cmd, tl = this.getCurrentTxtlayForeNeedErr(), _record = true) => tl.tagCh('｜　《' + cmd + '》');\n        this.goTxt = () => { };\n        this.breakLine = () => { };\n        this.breakPage = () => { };\n        this.hPages = {};\n        this.aLayName = [];\n        this.curTxtlay = '';\n        this.srcRuleTransFragment = `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, vTextureCoord);\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat grd = 0.5 -v /vague *0.5;\n\t\tfloat f_a = fg.a *(1.0 -grd);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`;\n        this.ufRuleTrans = {\n            rule: { type: 'sampler2D', value: pixi_js_1.Texture.EMPTY },\n            vague: { type: '1f', value: 0.0 },\n            tick: { type: '1f', value: 0.0 },\n        };\n        this.fltRule = new pixi_js_1.Filter(undefined, this.srcRuleTransFragment, this.ufRuleTrans);\n        this.rtTransBack = pixi_js_1.RenderTexture.create({\n            width: CmnLib_1.CmnLib.stageW,\n            height: CmnLib_1.CmnLib.stageH,\n        });\n        this.spTransBack = new pixi_js_1.Sprite(this.rtTransBack);\n        this.rtTransFore = pixi_js_1.RenderTexture.create({\n            width: CmnLib_1.CmnLib.stageW,\n            height: CmnLib_1.CmnLib.stageH,\n        });\n        this.spTransFore = new pixi_js_1.Sprite(this.rtTransFore);\n        this.aBackTransAfter = [];\n        this.twInfTrans = { tw: null, resume: false };\n        this.elcTrans = new EventListenerCtn_1.EventListenerCtn;\n        this.hMemberCnt = {\n            alpha: 0,\n            height: 0,\n            rotation: 0,\n            scale_x: 0,\n            scale_y: 0,\n            width: 0,\n            x: 0,\n            y: 0,\n        };\n        this.hTwInf = {};\n        this.getTxtLayer = (_hArg) => { this.fncChkTxtLay(); throw 0; };\n        this.current = (_hArg) => { this.fncChkTxtLay(); throw 0; };\n        this.fncChkTxtLay = () => { throw '文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい'; };\n        this.oLastPage = { text: '' };\n        this.aPageLog = [];\n        const fncResizeLay = () => {\n            if (!CmnLib_1.CmnLib.cvsResize(appPixi.view))\n                return;\n            this.aLayName.forEach(layer => {\n                const pg = this.hPages[layer];\n                pg.fore.cvsResize();\n                pg.back.cvsResize();\n            });\n        };\n        if (CmnLib_1.CmnLib.isMobile) {\n            window.addEventListener('orientationchange', fncResizeLay);\n        }\n        else {\n            let tid = 0;\n            window.addEventListener('resize', () => {\n                if (tid)\n                    return;\n                tid = setTimeout(() => { tid = 0; fncResizeLay(); }, 500);\n            });\n        }\n        CmnLib_1.CmnLib.cvsResize(appPixi.view);\n        TxtLayer_1.TxtLayer.init(cfg, hTag, val, (txt) => this.recText(txt));\n        GrpLayer_1.GrpLayer.init(main, cfg, sys);\n        this.frmMng = new FrameMng_1.FrameMng(this.hTag, this.appPixi, this.val, main, this.sys, this.hTwInf);\n        sys.hFactoryCls['grp'] = () => new GrpLayer_1.GrpLayer;\n        sys.hFactoryCls['txt'] = () => new TxtLayer_1.TxtLayer;\n        hTag.snapshot = o => this.snapshot(o);\n        hTag.loadplugin = o => this.loadplugin(o);\n        hTag.set_focus = o => this.set_focus(o);\n        hTag.add_lay = o => this.add_lay(o);\n        hTag.lay = o => this.lay(o);\n        hTag.clear_lay = o => this.clear_lay(o);\n        hTag.trans = o => this.trans(o);\n        hTag.wt = o => this.wt(o);\n        hTag.finish_trans = () => this.finish_trans();\n        hTag.quake = o => this.quake(o);\n        hTag.wq = o => hTag.wt(o);\n        hTag.stop_quake = o => hTag.finish_trans(o);\n        hTag.tsy = o => this.tsy(o);\n        hTag.wait_tsy = o => this.wait_tsy(o);\n        hTag.stop_tsy = o => this.stop_tsy(o);\n        hTag.pause_tsy = o => this.pause_tsy(o);\n        hTag.resume_tsy = o => this.resume_tsy(o);\n        hTag.ch = o => this.ch(o);\n        hTag.clear_text = o => this.clear_text(o);\n        hTag.current = o => this.current(o);\n        hTag.endlink = () => this.endlink();\n        hTag.er = o => this.er(o);\n        hTag.graph = o => this.graph(o);\n        hTag.link = o => this.link(o);\n        hTag.r = o => this.r(o);\n        hTag.rec_r = () => this.rec_r();\n        hTag.rec_ch = o => this.rec_ch(o);\n        hTag.reset_rec = o => this.reset_rec(o);\n        hTag.ruby2 = o => this.ruby2(o);\n        hTag.span = o => this.span(o);\n        hTag.tcy = o => this.tcy(o);\n        hTag.add_face = o => GrpLayer_1.GrpLayer.add_face(o);\n        hTag.wv = o => GrpLayer_1.GrpLayer.wv(o);\n        hTag.dump_lay = o => this.dump_lay(o);\n        hTag.enable_event = o => this.enable_event(o);\n        hTag.button = o => this.button(o);\n        if (cfg.existsBreakline)\n            this.breakLine = () => this.cmdTxt('grp｜{\"id\":\"break\",\"pic\":\"breakline\"}');\n        if (cfg.existsBreakpage)\n            this.breakPage = () => this.cmdTxt('grp｜{\"id\":\"break\",\"pic\":\"breakpage\"}');\n        const grp = new pixi_js_1.Graphics;\n        grp.beginFill(cfg.oCfg.init.bg_color, 1);\n        grp.lineStyle(0, cfg.oCfg.init.bg_color);\n        grp.drawRect(0, 0, CmnLib_1.CmnLib.stageW, CmnLib_1.CmnLib.stageH);\n        grp.endFill();\n        this.fore.addChild(grp.clone());\n        this.back.addChild(grp);\n        this.back.visible = false;\n        this.stage = this.appPixi.stage;\n        this.stage.addChild(this.back);\n        this.stage.addChild(this.fore);\n        this.stage.addChild(this.spTransBack);\n        this.stage.addChild(this.spTransFore);\n        this.appPixi.ticker.add(this.fncTicker);\n        const fncTxt_b_alpha = (_name, val) => {\n            this.foreachRedrawTxtLayBack(Number(val));\n        };\n        fncTxt_b_alpha('', val.getVal('sys:TextLayer.Back.Alpha', 1));\n        val.defValTrg('sys:TextLayer.Back.Alpha', fncTxt_b_alpha);\n        const fncBtnFont = (_name, val) => {\n            Button_1.Button.fontFamily = val;\n        };\n        fncBtnFont('', val.getVal('tmp:sn.button.fontFamily', Button_1.Button.fontFamily));\n        val.defValTrg('tmp:sn.button.fontFamily', fncBtnFont);\n        val.defTmp('const.sn.log.json', () => JSON.stringify([...this.aPageLog, this.oLastPage]));\n        val.defTmp('const.sn.last_page_text', () => {\n            const tl = this.getCurrentTxtlayFore();\n            return tl ? tl.pageText : '';\n        });\n    }\n    cover(visible, bg_color = 0x0) {\n        if (this.grpCover) {\n            this.stage.removeChild(this.grpCover);\n            this.grpCover.destroy();\n            this.grpCover = null;\n        }\n        if (visible) {\n            this.grpCover = new pixi_js_1.Graphics;\n            this.grpCover.beginFill(bg_color);\n            this.grpCover.lineStyle(0, bg_color);\n            this.grpCover.drawRect(0, 0, CmnLib_1.CmnLib.stageW, CmnLib_1.CmnLib.stageH);\n            this.grpCover.endFill();\n            this.stage.addChild(this.grpCover);\n        }\n    }\n    setEvtMng(evtMng) {\n        this.evtMng = evtMng;\n        this.frmMng.setEvtMng(evtMng);\n        GrpLayer_1.GrpLayer.setEvtMng(evtMng);\n    }\n    before_destroy() { for (const pg in this.hPages)\n        this.hPages[pg].destroy(); }\n    destroy() {\n        GrpLayer_1.GrpLayer.destroy();\n        RubySpliter_1.RubySpliter.destroy();\n        this.frmMng.destroy();\n        TWEEN.default.removeAll();\n        this.appPixi.ticker.remove(this.fncTicker);\n        LayerMng.$msecChWait = 10;\n    }\n    foreachRedrawTxtLayBack(g_alpha) {\n        const vct = this.getLayers();\n        const len = vct.length;\n        for (let i = 0; i < len; ++i) {\n            const name = vct[i];\n            const pg = this.hPages[name];\n            if (!(pg.fore instanceof TxtLayer_1.TxtLayer))\n                continue;\n            const pTxt = pg.fore;\n            pTxt.chgBackAlpha(g_alpha);\n            pg.back.chgBackAlpha(g_alpha);\n        }\n    }\n    clearBreak() {\n        if (!this.getCurrentTxtlayFore())\n            return;\n        this.clearBreak = () => this.cmdTxt('del｜break');\n        this.clearBreak();\n    }\n    clickTxtLay() {\n        const tl = this.getCurrentTxtlayFore();\n        if (!tl)\n            return true;\n        const vct = this.getLayers();\n        const len = vct.length;\n        for (let i = 0; i < len; ++i) {\n            const name = vct[i];\n            const pg = this.hPages[name];\n            if (!(pg.fore instanceof TxtLayer_1.TxtLayer))\n                continue;\n            const pTxt = pg.fore;\n            if (!pTxt.click())\n                return false;\n        }\n        return true;\n    }\n    snapshot(hArg) {\n        var _a;\n        const fn = (hArg.fn)\n            ? ((hArg.fn.substr(0, 10) == 'userdata:/')\n                ? hArg.fn\n                : ('desktop:/' + hArg.fn + CmnLib_1.getDateStr('-', '_', '', '_') + '.png'))\n            : ('desktop:/snapshot' + CmnLib_1.getDateStr('-', '_', '', '_') + '.png');\n        const ext = CmnLib_1.CmnLib.getExt(fn);\n        const b_color = (_a = hArg.b_color, (_a !== null && _a !== void 0 ? _a : this.cfg.oCfg.init.bg_color));\n        const renderer = pixi_js_1.autoDetectRenderer({\n            width: CmnLib_1.CmnLib.argChk_Num(hArg, 'width', CmnLib_1.CmnLib.stageW),\n            height: CmnLib_1.CmnLib.argChk_Num(hArg, 'height', CmnLib_1.CmnLib.stageH),\n            transparent: (b_color > 0x1000000) && (ext == 'png'),\n            antialias: CmnLib_1.CmnLib.argChk_Boolean(hArg, 'smoothing', false),\n            preserveDrawingBuffer: true,\n            backgroundColor: CmnLib_1.uint(b_color) & 0xFFFFFF,\n            autoDensity: true,\n        });\n        const a = [];\n        if (this.twInfTrans.tw) {\n            a.push(new Promise(re => {\n                this.back.visible = true;\n                for (const lay of this.aBackTransAfter) {\n                    renderer.render(lay, undefined, false);\n                }\n                this.back.visible = false;\n                this.spTransBack.visible = true;\n                this.fore.filters = this.spTransFore.filters;\n                this.fore.visible = true;\n                renderer.render(this.fore, undefined, false);\n                this.fore.visible = false;\n                this.fore.filters = [];\n                re();\n            }));\n        }\n        else {\n            const pg = (hArg.page != 'back') ? 'fore' : 'back';\n            for (const v of this.getLayers(hArg.layer))\n                a.push(new Promise(re => this.hPages[v][pg].snapshot(renderer, re)));\n        }\n        Promise.all(a).then(() => {\n            this.sys.savePic(this.cfg.searchPath(fn), this.appPixi.renderer.extract.base64(this.stage));\n            if (!this.twInfTrans.tw) {\n                const pg = (hArg.page != 'back') ? 'fore' : 'back';\n                for (const v of this.getLayers(hArg.layer))\n                    this.hPages[v][pg].snapshot_end();\n            }\n            renderer.destroy(true);\n        });\n        return false;\n    }\n    loadplugin(hArg) {\n        const fn = hArg.fn;\n        if (!fn)\n            throw 'fnは必須です';\n        const join = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'join', true);\n        switch (CmnLib_1.CmnLib.getExt(fn)) {\n            case 'css':\n                (async () => {\n                    const res = await fetch(fn);\n                    if (!res.ok)\n                        throw new Error('Network response was not ok.');\n                    TxtLayer_1.TxtLayer.addStyle(await res.text());\n                    if (join)\n                        this.main.resume();\n                })();\n                break;\n            default: throw 'サポートされない拡張子です';\n        }\n        return join;\n    }\n    set_focus(hArg) {\n        const to = hArg.to;\n        if (!to)\n            throw '[set_focus] toは必須です';\n        return false;\n    }\n    add_lay(hArg) {\n        const layer = hArg.layer;\n        if (!layer)\n            throw 'layerは必須です';\n        if (layer.includes(','))\n            throw 'layer名に「,」は使えません';\n        if (layer in this.hPages)\n            throw `layer【${layer}】はすでにあります`;\n        const cls = hArg.class;\n        if (!cls)\n            throw 'clsは必須です';\n        this.hPages[layer] = new Pages_1.Pages(layer, cls, this.fore, hArg, this.back, hArg, this.sys, this.val);\n        this.aLayName.push(layer);\n        switch (cls) {\n            case 'txt':\n                if (!this.curTxtlay) {\n                    this.fncChkTxtLay = () => { };\n                    this.getTxtLayer = this.$getTxtLayer;\n                    this.current = this.$current;\n                    this.hTag.current({ layer: layer });\n                    this.goTxt = () => {\n                        if (this.val.getVal('sn.skip.enabled')) {\n                            LayerMng.$msecChWait = 0;\n                        }\n                        else {\n                            this.setNormalWaitTxtLayer();\n                        }\n                        for (const name of this.getLayers()) {\n                            const pg = this.hPages[name];\n                            if (!(pg.fore instanceof TxtLayer_1.TxtLayer))\n                                continue;\n                            this.cmdTxt('gotxt｜', pg.fore, false);\n                        }\n                    };\n                }\n                this.val.setVal_Nochk('save', 'const.sn.layer.' + ((layer !== null && layer !== void 0 ? layer : this.curTxtlay)) + '.enabled', true);\n                break;\n        }\n        return false;\n    }\n    lay(hArg) {\n        const layer = this.argChk_layer(hArg);\n        const pg = this.hPages[layer];\n        const back = pg.back.cnt;\n        const fore = pg.fore.cnt;\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'float', false)) {\n            this.back.setChildIndex(back, this.back.children.length - 1);\n            this.fore.setChildIndex(fore, this.fore.children.length - 1);\n            this.rebuildLayerRankInfo();\n        }\n        else if (hArg.index) {\n            if (CmnLib_1.CmnLib.argChk_Num(hArg, 'index', 0)) {\n                this.back.setChildIndex(back, CmnLib_1.uint(hArg.index));\n                this.fore.setChildIndex(fore, CmnLib_1.uint(hArg.index));\n                this.rebuildLayerRankInfo();\n            }\n        }\n        else if (hArg.dive) {\n            const dive = hArg.dive;\n            let idx_dive = 0;\n            if (layer == dive)\n                throw '[lay] 属性 layerとdiveが同じ【' + dive + '】です';\n            const pg_dive = this.hPages[dive];\n            if (!pg_dive)\n                throw '[lay] 属性 dive【' + dive + '】が不正です。レイヤーがありません';\n            const back_dive = pg_dive.back;\n            const fore_dive = pg_dive.fore;\n            const idx_back_dive = this.back.getChildIndex(back_dive.cnt);\n            const idx_fore_dive = this.fore.getChildIndex(fore_dive.cnt);\n            idx_dive = (idx_back_dive < idx_fore_dive) ? idx_back_dive : idx_fore_dive;\n            if (idx_dive > this.back.getChildIndex(back))\n                --idx_dive;\n            this.fore.setChildIndex(fore, idx_dive);\n            this.back.setChildIndex(back, idx_dive);\n            this.rebuildLayerRankInfo();\n        }\n        return pg.lay(hArg);\n    }\n    rebuildLayerRankInfo() { this.aLayName = this.sortLayers(); }\n    clear_lay(hArg) {\n        this.foreachLayers(hArg, name => {\n            const pg = this.hPages[this.argChk_layer({ layer: name })];\n            if (hArg.page == 'both') {\n                pg.fore.clearLay(hArg);\n                pg.back.clearLay(hArg);\n            }\n            else {\n                pg.getPage(hArg).clearLay(hArg);\n            }\n        });\n        return false;\n    }\n    trans(hArg) {\n        this.finish_trans();\n        const ease = CmnTween_1.CmnTween.ease(hArg.ease);\n        this.aBackTransAfter = [];\n        const hTarget = {};\n        for (const v of this.getLayers(hArg.layer))\n            hTarget[v] = true;\n        for (const lay_nm of this.getLayers())\n            this.aBackTransAfter.push(this.hPages[lay_nm][hTarget[lay_nm] ? 'back' : 'fore'].cnt);\n        this.rtTransBack.resize(CmnLib_1.CmnLib.stageW, CmnLib_1.CmnLib.stageH);\n        this.appPixi.renderer.render(this.back, this.rtTransBack);\n        this.rtTransFore.resize(CmnLib_1.CmnLib.stageW, CmnLib_1.CmnLib.stageH);\n        this.appPixi.renderer.render(this.fore, this.rtTransFore);\n        const fncRender = () => {\n            this.back.visible = true;\n            for (const lay of this.aBackTransAfter) {\n                this.appPixi.renderer.render(lay, this.rtTransBack, false);\n            }\n            this.back.visible = false;\n            this.spTransBack.visible = true;\n            this.fore.visible = true;\n            this.appPixi.renderer.render(this.fore, this.rtTransFore);\n            this.fore.visible = false;\n            this.spTransFore.visible = true;\n        };\n        this.spTransFore.alpha = 1;\n        const closeTrans = () => {\n            if (this.appPixi.ticker)\n                this.appPixi.ticker.remove(fncRender);\n            this.elcTrans.clear();\n            [this.fore, this.back] = [this.back, this.fore];\n            for (const lay_name in this.hPages) {\n                const pg = this.hPages[lay_name];\n                if (hTarget[lay_name]) {\n                    pg.transPage();\n                    continue;\n                }\n                const idx = this.fore.getChildIndex(pg.back.cnt);\n                this.fore.removeChild(pg.back.cnt);\n                this.back.removeChild(pg.fore.cnt);\n                this.fore.addChildAt(pg.fore.cnt, idx);\n                this.back.addChildAt(pg.back.cnt, idx);\n            }\n            this.fore.visible = true;\n            this.back.visible = false;\n            this.spTransBack.visible = false;\n            this.spTransFore.visible = false;\n            if (this.twInfTrans.resume)\n                this.main.resume();\n            this.twInfTrans = { tw: null, resume: false };\n        };\n        const time = CmnLib_1.CmnLib.argChk_Num(hArg, 'time', 0);\n        if (time == 0 || this.evtMng.isSkipKeyDown()) {\n            closeTrans();\n            return false;\n        }\n        this.twInfTrans = { tw: null, resume: false };\n        const is_glsl = 'glsl' in hArg;\n        if ((!is_glsl) && !('rule' in hArg)) {\n            this.spTransFore.filters = [];\n            this.twInfTrans.tw = new TWEEN.default.Tween(this.spTransFore)\n                .to({ alpha: 0 }, time)\n                .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n                .easing(ease)\n                .onComplete(closeTrans)\n                .start();\n            this.appPixi.ticker.add(fncRender);\n            return false;\n        }\n        const flt = is_glsl\n            ? new pixi_js_1.Filter(undefined, hArg.glsl, this.ufRuleTrans)\n            : this.fltRule;\n        flt.uniforms.vague = CmnLib_1.CmnLib.argChk_Num(hArg, 'vague', 0.04);\n        flt.uniforms.tick = 0;\n        this.twInfTrans.tw = new TWEEN.default.Tween(flt.uniforms)\n            .to({ tick: 1 }, time)\n            .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n            .easing(ease)\n            .onComplete(closeTrans);\n        this.spTransFore.filters = [flt];\n        if (is_glsl) {\n            this.twInfTrans.tw.start();\n            this.appPixi.ticker.add(fncRender);\n            return false;\n        }\n        if (!hArg.rule)\n            throw 'ruleが指定されていません';\n        GrpLayer_1.GrpLayer.ldPic(hArg.rule, tx => {\n            flt.uniforms.rule = tx;\n            if (this.twInfTrans.tw)\n                this.twInfTrans.tw.start();\n            this.appPixi.ticker.add(fncRender);\n        });\n        return false;\n    }\n    getLayers(layer = '') {\n        return (layer) ? layer.split(',') : this.aLayName;\n    }\n    foreachLayers(hArg, fnc) {\n        const vct = this.getLayers(hArg['layer']);\n        for (const name of vct) {\n            if (!name)\n                continue;\n            const pg = this.hPages[name];\n            if (pg == null)\n                throw '存在しないlayer【' + name + '】です';\n            fnc(name, pg);\n        }\n        return vct;\n    }\n    sortLayers(layers = '') {\n        const a = this.getLayers(layers);\n        a.sort((a, b) => {\n            const ai = this.fore.getChildIndex(this.hPages[a].fore.cnt);\n            const bi = this.fore.getChildIndex(this.hPages[b].fore.cnt);\n            if (ai < bi)\n                return -1;\n            if (ai > bi)\n                return 1;\n            return 0;\n        });\n        return a;\n    }\n    wt(hArg) {\n        if (!this.twInfTrans.tw)\n            return false;\n        this.twInfTrans.resume = true;\n        this.evtMng.waitCustomEvent(hArg, this.elcTrans, () => this.finish_trans());\n        return true;\n    }\n    finish_trans() {\n        if (this.twInfTrans.tw)\n            this.twInfTrans.tw.stop().end();\n        return false;\n    }\n    quake(hArg) {\n        this.finish_trans();\n        if (this.val.getVal('tmp:sn.skip.enabled'))\n            return false;\n        if (this.evtMng.isSkipKeyDown())\n            return false;\n        const aDo = [];\n        for (const lay_nm of this.getLayers(hArg.layer)) {\n            aDo.push(this.hPages[lay_nm].fore.cnt);\n        }\n        this.rtTransFore.resize(CmnLib_1.CmnLib.stageW, CmnLib_1.CmnLib.stageH);\n        const fncRender = () => {\n            this.fore.visible = true;\n            for (const lay of aDo) {\n                this.appPixi.renderer.render(lay, this.rtTransFore, false);\n            }\n            this.fore.visible = false;\n        };\n        this.spTransFore.visible = true;\n        this.spTransFore.alpha = 1;\n        const closeTrans = () => {\n            if (this.appPixi.ticker)\n                this.appPixi.ticker.remove(fncRender);\n            this.fore.visible = true;\n            this.spTransFore.visible = false;\n            this.spTransFore.x = 0;\n            this.spTransFore.y = 0;\n            if (this.twInfTrans.resume)\n                this.main.resume();\n            this.twInfTrans = { tw: null, resume: false };\n        };\n        const ease = CmnTween_1.CmnTween.ease(hArg.ease);\n        const h = CmnLib_1.uint(CmnLib_1.CmnLib.argChk_Num(hArg, 'hmax', 10));\n        const v = CmnLib_1.uint(CmnLib_1.CmnLib.argChk_Num(hArg, 'vmax', 10));\n        const fncH = (h == 0)\n            ? () => { }\n            : () => this.spTransFore.x = Math.round(Math.random() * h * 2) - h;\n        const fncV = (v == 0)\n            ? () => { }\n            : () => this.spTransFore.y = Math.round(Math.random() * v * 2) - v;\n        this.spTransFore.filters = [];\n        const repeat = CmnLib_1.CmnLib.argChk_Num(hArg, 'repeat', 1);\n        this.twInfTrans = { tw: null, resume: false };\n        this.twInfTrans.tw = new TWEEN.default.Tween(this.spTransFore)\n            .to({ x: 0, y: 0 }, CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN))\n            .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n            .easing(ease)\n            .onUpdate(() => { fncH(); fncV(); })\n            .repeat(repeat == 0 ? Infinity : (repeat - 1))\n            .yoyo(CmnLib_1.CmnLib.argChk_Boolean(hArg, 'yoyo', false))\n            .onComplete(closeTrans)\n            .start();\n        this.appPixi.ticker.add(fncRender);\n        return false;\n    }\n    tsy(hArg) {\n        var _a, _b;\n        if (!hArg.layer)\n            throw 'layerは必須です';\n        const layer = this.argChk_layer(hArg);\n        const foreLay = this.hPages[layer].fore;\n        const ease = CmnTween_1.CmnTween.ease(hArg.ease);\n        const hTo = {};\n        for (const nm in this.hMemberCnt) {\n            if (!(nm in hArg))\n                continue;\n            const v = String(hArg[nm]);\n            const a = ((v.charAt(0) == '=') ? v.slice(1) : v).split(',');\n            const a0 = hTo[nm] = parseFloat(a[0]);\n            if (a.length > 1)\n                hTo[nm] += Math.round(Math.random()\n                    * (parseFloat(a[1]) - a0 + 1));\n            if (v.charAt(0) == '=')\n                hTo[nm] += parseFloat(foreLay[nm]);\n        }\n        const repeat = CmnLib_1.CmnLib.argChk_Num(hArg, 'repeat', 1);\n        const tw_nm = (_a = hArg.name, (_a !== null && _a !== void 0 ? _a : hArg.layer));\n        const tw = new TWEEN.default.Tween(foreLay)\n            .to(hTo, CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN)\n            * (Boolean(this.val.getVal('tmp:sn.skip.enabled')) ? 0 : 1))\n            .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n            .easing(ease)\n            .repeat(repeat == 0 ? Infinity : (repeat - 1))\n            .yoyo(CmnLib_1.CmnLib.argChk_Boolean(hArg, 'yoyo', false))\n            .onComplete(() => {\n            const twInf = this.hTwInf[tw_nm];\n            if (!twInf)\n                return;\n            delete this.hTwInf[tw_nm];\n            this.evtMng.popLocalEvts();\n            if (twInf.resume)\n                this.main.resume();\n            if (twInf.onComplete)\n                twInf.onComplete();\n        });\n        if ('chain' in hArg) {\n            const twFrom = this.hTwInf[_b = hArg.chain, (_b !== null && _b !== void 0 ? _b : '')];\n            if (!twFrom || !twFrom.tw)\n                throw `${hArg.chain}は存在しない・または終了したトゥイーンです`;\n            twFrom.onComplete = () => { };\n            twFrom.tw.chain(tw);\n        }\n        else\n            tw.start();\n        const arrive = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'arrive', false);\n        const backlay = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'backlay', false);\n        this.hTwInf[tw_nm] = { tw: tw, resume: false, onComplete: () => {\n                if (arrive)\n                    Object.assign(foreLay, hTo);\n                if (backlay) {\n                    const backCnt = this.hPages[layer].back.cnt;\n                    for (const nm in this.hMemberCnt)\n                        backCnt[nm] = foreLay[nm];\n                }\n            } };\n        return false;\n    }\n    wait_tsy(hArg) {\n        var _a;\n        const tw_nm = ('id' in hArg) ? `frm\\n${hArg.id}` : (_a = hArg.name, (_a !== null && _a !== void 0 ? _a : hArg.layer));\n        if (!tw_nm)\n            throw 'トゥイーンが指定されていません';\n        const twInf = this.hTwInf[tw_nm];\n        if (!twInf || !twInf.tw)\n            return false;\n        twInf.resume = true;\n        this.evtMng.stdWait(() => { if (twInf.tw)\n            twInf.tw.stop().end(); }, CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true));\n        return true;\n    }\n    stop_tsy(hArg) {\n        var _a;\n        const tw_nm = ('id' in hArg) ? `frm\\n${hArg.id}` : (_a = hArg.name, (_a !== null && _a !== void 0 ? _a : hArg.layer));\n        if (!tw_nm)\n            throw 'トゥイーンが指定されていません';\n        const twInf = this.hTwInf[tw_nm];\n        if (!twInf || !twInf.tw)\n            return false;\n        twInf.tw.stop().end();\n        return false;\n    }\n    pause_tsy(hArg) {\n        var _a;\n        const tw_nm = ('id' in hArg) ? `frm\\n${hArg.id}` : (_a = hArg.name, (_a !== null && _a !== void 0 ? _a : hArg.layer));\n        if (!tw_nm)\n            throw 'トゥイーンが指定されていません';\n        const twInf = this.hTwInf[tw_nm];\n        if (!twInf || !twInf.tw)\n            return false;\n        twInf.tw.stop();\n        return false;\n    }\n    resume_tsy(hArg) {\n        var _a;\n        const tw_nm = ('id' in hArg) ? `frm\\n${hArg.id}` : (_a = hArg.name, (_a !== null && _a !== void 0 ? _a : hArg.layer));\n        if (!tw_nm)\n            throw 'トゥイーンが指定されていません';\n        const twInf = this.hTwInf[tw_nm];\n        if (!twInf || !twInf.tw)\n            return false;\n        twInf.tw.start();\n        return false;\n    }\n    static get msecChWait() { return LayerMng.$msecChWait; }\n    static set msecChWait(v) { LayerMng.$msecChWait = v; }\n    ch(hArg) {\n        if (!hArg.text)\n            throw 'textは必須です';\n        let wait = CmnLib_1.CmnLib.argChk_Num(hArg, 'wait', -1);\n        if (wait > 0 && this.val.getVal('tmp:sn.skip.enabled'))\n            wait = 0;\n        hArg.wait = wait;\n        const tl = this.getTxtLayer(hArg);\n        if (wait >= 0)\n            this.cmdTxt('add｜' + JSON.stringify(hArg), tl);\n        const record = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'record', true);\n        const doRecLog = this.val.doRecLog();\n        if (!record)\n            this.val.setVal_Nochk('save', 'sn.doRecLog', record);\n        tl.tagCh(hArg.text.replace(/\\[r]/g, '\\n'));\n        if (!record)\n            this.val.setVal_Nochk('save', 'sn.doRecLog', doRecLog);\n        if (wait >= 0)\n            this.cmdTxt(`add_close｜`, tl);\n        return false;\n    }\n    $getTxtLayer(hArg) {\n        const layer = this.argChk_layer(hArg, this.curTxtlay);\n        const pg = this.hPages[layer];\n        const lay = pg.getPage(hArg);\n        if (!(lay instanceof TxtLayer_1.TxtLayer))\n            throw layer + 'はTxtLayerではありません';\n        const tf = lay;\n        return tf;\n    }\n    setNormalWaitTxtLayer() { LayerMng.$msecChWait = this.scrItr.normalWait; }\n    $current(hArg) {\n        const layer = hArg.layer;\n        if (!layer)\n            throw '[current] layerは必須です';\n        this.pgTxtlay = this.hPages[layer];\n        if (!(this.pgTxtlay.getPage(hArg) instanceof TxtLayer_1.TxtLayer))\n            throw `${layer}はTxtLayerではありません`;\n        this.recText('', true);\n        this.curTxtlay = layer;\n        this.val.setVal_Nochk('save', 'const.sn.mesLayer', layer);\n        const vct = this.getLayers();\n        const len = vct.length;\n        for (let i = 0; i < len; ++i) {\n            const name = vct[i];\n            const pg = this.hPages[name];\n            if (!(pg.fore instanceof TxtLayer_1.TxtLayer))\n                continue;\n            pg.fore.isCur =\n                pg.back.isCur = (name == layer);\n        }\n        return false;\n    }\n    getCurrentTxtlayForeNeedErr() {\n        this.fncChkTxtLay();\n        return this.getCurrentTxtlayFore();\n    }\n    getCurrentTxtlayFore() {\n        if (!this.pgTxtlay)\n            return undefined;\n        return this.pgTxtlay.fore;\n    }\n    argChk_layer(hash, def = '') {\n        var _a;\n        const v = (_a = hash.layer, (_a !== null && _a !== void 0 ? _a : def));\n        if (v.includes(','))\n            throw 'layer名に「,」は使えません';\n        if (!(v in this.hPages))\n            throw '属性 layer【' + v + '】が不正です。レイヤーがありません';\n        return hash.layer = v;\n    }\n    recText(txt, pagebreak = false) {\n        if (pagebreak) {\n            if (this.oLastPage.text) {\n                this.aPageLog.push(this.oLastPage);\n                this.aPageLog = this.aPageLog.slice(-this.cfg.oCfg.log.max_len);\n            }\n            this.oLastPage = { text: '' };\n            return;\n        }\n        this.oLastPage.text = txt.replace(/\\\\`/, '`');\n        this.val.setVal_Nochk('save', 'const.sn.sLog', String(this.val.getVal('const.sn.log.json')));\n    }\n    clear_text(hArg) {\n        const tf = this.getTxtLayer(hArg);\n        if (hArg.layer == this.curTxtlay && hArg.page == 'fore')\n            this.recText('', true);\n        tf.clearText();\n        return false;\n    }\n    endlink() { this.cmdTxt('endlink｜'); return false; }\n    er(hArg) {\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'rec_page_break', true))\n            this.recText('', true);\n        if (this.pgTxtlay) {\n            this.pgTxtlay.fore.clearLay(hArg);\n            this.pgTxtlay.back.clearLay(hArg);\n        }\n        return false;\n    }\n    graph(hArg) {\n        if (!('pic' in hArg))\n            throw '[graph] picは必須です';\n        hArg.text = '｜　《grp｜' + JSON.stringify(hArg) + '》';\n        return this.ch(hArg);\n    }\n    link(hArg) {\n        if (!hArg.style)\n            hArg.style = 'background-color: rgba(255,0,0,0.5);';\n        this.cmdTxt('link｜' + JSON.stringify(hArg));\n        return false;\n    }\n    r(hArg) { hArg.text = '\\n'; return this.ch(hArg); }\n    rec_r() { this.recText('\\n'); return false; }\n    ;\n    rec_ch(hArg) {\n        var _a;\n        this.oLastPage = hArg;\n        this.recText((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')));\n        return false;\n    }\n    ;\n    reset_rec(hArg) {\n        var _a, _b;\n        this.val.setVal_Nochk('save', 'const.sn.sLog', (_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')));\n        this.aPageLog = [];\n        this.oLastPage = { text: (_b = hArg.text, (_b !== null && _b !== void 0 ? _b : '')) };\n        return false;\n    }\n    ruby2(hArg) {\n        const t = hArg.t;\n        if (!t)\n            throw '[ruby2] tは必須です';\n        const r = hArg.r;\n        if (!r)\n            throw '[ruby2] rは必須です';\n        hArg.text = '｜' + t + '《' + r + '》';\n        return this.ch(hArg);\n    }\n    span(hArg) {\n        this.cmdTxt('span｜' + JSON.stringify(hArg));\n        return false;\n    }\n    tcy(hArg) {\n        var _a;\n        if (!hArg.t)\n            throw '[tcy] tは必須です';\n        hArg.text = '｜　｜《tcy｜' + hArg.t + '｜' + (_a = hArg.r, (_a !== null && _a !== void 0 ? _a : '')) + '》';\n        return this.ch(hArg);\n    }\n    dump_lay(hArg) {\n        console.group('🥟 [dump_lay]');\n        for (const name of this.getLayers(hArg.layer)) {\n            const pg = this.hPages[name];\n            try {\n                console.info(`%c${pg.fore.name.slice(0, -7)} %o`, `color:#${CmnLib_1.CmnLib.isDarkMode ? '49F' : '05A'};`, JSON.parse(`{\"back\":{${pg.back.dump()}}, \"fore\":{${pg.fore.dump()}}}`));\n            }\n            catch (error) {\n                console.error(`dump_lay err:%o`, error);\n                console.error(`   back:${pg.back.dump()}`);\n                console.error(`   fore:${pg.fore.dump()}`);\n            }\n        }\n        console.groupEnd();\n        return false;\n    }\n    enable_event(hArg) {\n        const layer = this.argChk_layer(hArg, this.curTxtlay);\n        const enb = this.getTxtLayer(hArg).enabled\n            = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'enabled', true);\n        this.val.setVal_Nochk('save', 'const.sn.layer.' + layer + '.enabled', enb);\n        return false;\n    }\n    button(hArg) {\n        var _a, _b, _c;\n        Pages_1.Pages.argChk_page(hArg, 'back');\n        hArg.clicksebuf = (_a = hArg.clicksebuf, (_a !== null && _a !== void 0 ? _a : 'SYS'));\n        hArg.entersebuf = (_b = hArg.entersebuf, (_b !== null && _b !== void 0 ? _b : 'SYS'));\n        hArg.leavesebuf = (_c = hArg.leavesebuf, (_c !== null && _c !== void 0 ? _c : 'SYS'));\n        return this.getTxtLayer(hArg).addButton(hArg);\n    }\n    record() {\n        const o = {};\n        this.aLayName.forEach(layer => {\n            const pg = this.hPages[layer];\n            o[layer] = {\n                cls: pg.cls,\n                fore: pg.fore.record(),\n                back: pg.back.record(),\n            };\n        });\n        return o;\n    }\n    playback($hPages, fncComp) {\n        const aPromise = [];\n        const aSort = [];\n        for (const layer in $hPages) {\n            const $pg = $hPages[layer];\n            aSort.push({ layer: layer, idx: $pg.fore.idx });\n            const pg = this.hPages[layer] || new Pages_1.Pages(layer, $pg.cls, this.fore, {}, this.back, {}, this.sys, this.val);\n            this.hPages[layer] = pg;\n            aPromise.push(new Promise(re => pg.fore.playback($pg.fore, re)));\n            aPromise.push(new Promise(re => pg.back.playback($pg.back, re)));\n        }\n        const len = this.fore.children.length;\n        Promise.all(aPromise).then(() => {\n            aSort.sort(function (a, b) {\n                if (a.idx < b.idx)\n                    return -1;\n                if (a.idx > b.idx)\n                    return 1;\n                return 0;\n            });\n            aSort.forEach(o => {\n                const pg = this.hPages[o.layer];\n                if (!pg)\n                    return;\n                const idx = len > o.idx ? o.idx : len - 1;\n                this.fore.setChildIndex(pg.fore.cnt, idx);\n                this.back.setChildIndex(pg.back.cnt, idx);\n            });\n            fncComp();\n        })\n            .catch(e => console.error(`fn:LayerMng.ts playback e:%o`, e));\n        this.aPageLog = JSON.parse(String(this.val.getVal('save:const.sn.sLog')));\n        this.oLastPage = { text: '' };\n    }\n}\nexports.LayerMng = LayerMng;\nLayerMng.$msecChWait = 10;\n//# sourceMappingURL=LayerMng.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/LayerMng.js?")},"../npm_core/core/lib/sn/Main.js":
/*!***************************************!*\
  !*** ../npm_core/core/lib/sn/Main.js ***!
  \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst Grammar_1 = __webpack_require__(/*! ./Grammar */ \"../npm_core/core/lib/sn/Grammar.js\");\nconst AnalyzeTagArg_1 = __webpack_require__(/*! ./AnalyzeTagArg */ \"../npm_core/core/lib/sn/AnalyzeTagArg.js\");\nconst PropParser_1 = __webpack_require__(/*! ./PropParser */ \"../npm_core/core/lib/sn/PropParser.js\");\nconst DebugMng_1 = __webpack_require__(/*! ./DebugMng */ \"../npm_core/core/lib/sn/DebugMng.js\");\nconst Variable_1 = __webpack_require__(/*! ./Variable */ \"../npm_core/core/lib/sn/Variable.js\");\nconst SoundMng_1 = __webpack_require__(/*! ./SoundMng */ \"../npm_core/core/lib/sn/SoundMng.js\");\nconst LayerMng_1 = __webpack_require__(/*! ./LayerMng */ \"../npm_core/core/lib/sn/LayerMng.js\");\nconst EventMng_1 = __webpack_require__(/*! ./EventMng */ \"../npm_core/core/lib/sn/EventMng.js\");\nconst ScriptIterator_1 = __webpack_require__(/*! ./ScriptIterator */ \"../npm_core/core/lib/sn/ScriptIterator.js\");\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nclass Main {\n    constructor(sys) {\n        this.sys = sys;\n        this.hTag = Object.create(null);\n        this.fncNext = () => { };\n        this.alzTagArg = new AnalyzeTagArg_1.AnalyzeTagArg;\n        this.inited = false;\n        this.fncTicker = () => {\n            this.fncNext();\n            this.dbgMng.update();\n        };\n        this.fncresume = (fnc = this.runAnalyze) => {\n            if (this.destroyed)\n                return;\n            this.layMng.clearBreak();\n            this.fncNext = fnc;\n            this.resume = (fnc = this.runAnalyze) => {\n                this.fncNext = fnc;\n            };\n            this.scrItr.noticeBreak(false);\n        };\n        this.resume = this.fncresume;\n        this.stop = () => {\n            this.fncNext = () => { };\n            this.resume = this.fncresume;\n            this.scrItr.noticeBreak(true);\n        };\n        this.getValAmpersand = (val) => (val.charAt(0) == '&')\n            ? String(this.prpPrs.parse(val.substr(1)))\n            : val;\n        this.pauseDev = () => this.appPixi.stop();\n        this.resumeDev = () => this.appPixi.start();\n        this.destroyed = false;\n        this.isDestroyed = () => this.destroyed;\n        pixi_js_1.utils.skipHello();\n        this.cfg = new Config_1.Config(sys, () => {\n            var _a;\n            const hApp = {\n                width: this.cfg.oCfg.window.width,\n                height: this.cfg.oCfg.window.height,\n                backgroundColor: this.cfg.oCfg.init.bg_color,\n                resolution: (_a = window.devicePixelRatio, (_a !== null && _a !== void 0 ? _a : 1)),\n                autoResize: true,\n            };\n            const cvs = document.getElementById(CmnLib_1.CmnLib.sn_id);\n            if (cvs) {\n                this.clone_cvs = cvs.cloneNode(true);\n                this.clone_cvs.id = CmnLib_1.CmnLib.sn_id;\n                hApp.view = cvs;\n            }\n            this.appPixi = new pixi_js_1.Application(hApp);\n            if (!cvs) {\n                document.body.appendChild(this.appPixi.view);\n                this.appPixi.view.id = CmnLib_1.CmnLib.sn_id;\n            }\n            this.val = new Variable_1.Variable(this.cfg, this.hTag);\n            this.prpPrs = new PropParser_1.PropParser(this.val);\n            this.sys.init(this.cfg, this.hTag, this.appPixi, this.val, this);\n            this.hTag['title']({ text: this.cfg.oCfg.book.title || 'SKYNovel' });\n            this.sndMng = new SoundMng_1.SoundMng(this.cfg, this.hTag, this.val, this);\n            this.scrItr = new ScriptIterator_1.ScriptIterator(this.cfg, this.hTag, this, this.val, this.alzTagArg, () => this.runAnalyze(), this.prpPrs.parse, this.sndMng, this.sys);\n            this.dbgMng = new DebugMng_1.DebugMng(this.sys, this.hTag, this.scrItr);\n            this.layMng = new LayerMng_1.LayerMng(this.cfg, this.hTag, this.appPixi, this.val, this, this.scrItr, this.sys);\n            this.evtMng = new EventMng_1.EventMng(this.cfg, this.hTag, this.appPixi, this, this.layMng, this.val, this.sndMng, this.scrItr);\n            this.appPixi.ticker.add(this.fncTicker);\n            this.resumeByJumpOrCall({ fn: this.cfg.oCfg.first_script });\n            this.inited = true;\n        });\n    }\n    errScript(mes, isThrow = true) {\n        this.stop();\n        DebugMng_1.DebugMng.myTrace(mes);\n        if (CmnLib_1.CmnLib.devtool)\n            console.log('🍜 SKYNovel err!');\n        if (isThrow)\n            throw mes;\n    }\n    resumeByJumpOrCall(hArg) {\n        var _a, _b;\n        if (hArg.url) {\n            window.open(hArg.url);\n            return;\n        }\n        this.val.setVal_Nochk('tmp', 'sn.eventArg', (_a = hArg.arg, (_a !== null && _a !== void 0 ? _a : '')));\n        this.val.setVal_Nochk('tmp', 'sn.eventLabel', (_b = hArg.label, (_b !== null && _b !== void 0 ? _b : '')));\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'call', false)) {\n            this.scrItr.subIdxToken();\n            this.resume(() => this.hTag.call(hArg));\n        }\n        else {\n            this.hTag.clear_event({});\n            this.resume(() => this.hTag.jump(hArg));\n        }\n    }\n    runAnalyze() {\n        while (true) {\n            let token = this.scrItr.nextToken();\n            if (!token)\n                break;\n            const uc = token.charCodeAt(0);\n            if (this.cfg.oCfg.debug.token)\n                console.log(`🌱 トークン fn:${this.scrItr.scriptFn} lnum:${this.scrItr.lineNum} uc:${uc} token<${token}>`);\n            if (uc == 9)\n                continue;\n            if (uc == 10) {\n                this.evtMng.cr(token.length);\n                continue;\n            }\n            if (uc == 91) {\n                try {\n                    if (this.タグ解析(token)) {\n                        this.stop();\n                        break;\n                    }\n                    else\n                        continue;\n                }\n                catch (err) {\n                    let mes = '';\n                    if (err instanceof Error) {\n                        const e = err;\n                        mes = 'タグ解析中例外 mes=' + e.message + '(' + e.name + ')';\n                        const a_tag = Grammar_1.Grammar.REG_TAG.exec(token);\n                        if (a_tag != null)\n                            mes = '[' + a_tag.name + ']' + mes;\n                    }\n                    else {\n                        mes = err;\n                    }\n                    this.errScript(mes, false);\n                    return;\n                }\n            }\n            if (uc == 38) {\n                try {\n                    if (token.substr(-1) != '&') {\n                        const o = Grammar_1.Grammar.splitAmpersand(token.slice(1));\n                        o.name = this.getValAmpersand(o.name);\n                        o.text = String(this.prpPrs.parse(o.text));\n                        this.hTag.let(o);\n                        continue;\n                    }\n                    if (token.charAt(1) == '&')\n                        throw new Error('「&表示&」書式では「&」指定が不要です');\n                    token = String(this.prpPrs.parse(token.slice(1, -1)));\n                }\n                catch (err) {\n                    let mes = '';\n                    if (err instanceof Error) {\n                        const e = err;\n                        mes = '& 変数操作・変数表示 mes=' + e.message + '(' + e.name + ')';\n                    }\n                    else {\n                        mes = err;\n                    }\n                    this.errScript(mes, false);\n                    return;\n                }\n            }\n            else if (uc == 59)\n                continue;\n            else if ((uc == 42) && (token.length > 1))\n                continue;\n            try {\n                const tl = this.layMng.getCurrentTxtlayForeNeedErr();\n                tl.tagCh(token);\n            }\n            catch (err) {\n                let mes = '';\n                if (err instanceof Error) {\n                    const e = err;\n                    mes = '文字表示 mes=' + e.message + '(' + e.name + ')';\n                }\n                else {\n                    mes = err;\n                }\n                this.errScript(mes, false);\n                return;\n            }\n        }\n    }\n    タグ解析(tagToken) {\n        const a_tag = m_xregexp.exec(tagToken, Grammar_1.Grammar.REG_TAG);\n        if (a_tag == null)\n            throw 'タグ記述[' + tagToken + ']異常です(タグ解析)';\n        const tag_name = a_tag['name'];\n        const tag_fnc = this.hTag[tag_name];\n        if (tag_fnc == null)\n            throw '未定義のタグ[' + tag_name + ']です';\n        if (!this.alzTagArg.go(a_tag['args']))\n            throw '属性「' + this.alzTagArg.literal + '」は異常です';\n        if (this.cfg.oCfg.debug.tag)\n            console.log(`🌲 タグ解析 fn:${this.scrItr.scriptFn} lnum:${this.scrItr.lineNum} [${tag_name} %o]`, this.alzTagArg.hPrm);\n        if (this.alzTagArg.hPrm['cond']) {\n            const cond = this.alzTagArg.hPrm['cond'].val;\n            if (cond.charAt(0) == '&')\n                throw '属性condは「&」が不要です';\n            const p = this.prpPrs.parse(cond);\n            const ps = String(p);\n            if (ps == 'null' || ps == 'undefined')\n                return false;\n            if (!p)\n                return false;\n        }\n        const hArg = { タグ名: tag_name };\n        if (this.alzTagArg.isKomeParam) {\n            if (this.scrItr.isEmptyCallStk)\n                throw '属性「*」はマクロのみ有効です';\n            const hArgDef = this.scrItr.lastHArg;\n            if (!hArgDef)\n                throw '属性「*」はマクロのみ有効です';\n            for (const k in hArgDef)\n                hArg[k] = hArgDef[k];\n        }\n        for (const k in this.alzTagArg.hPrm) {\n            let val = this.alzTagArg.hPrm[k].val;\n            if (val.charAt(0) == '%') {\n                if (this.scrItr.isEmptyCallStk)\n                    throw '属性「%」はマクロのみ有効です';\n                const mac = this.scrItr.lastHArg[val.substr(1)];\n                if (mac) {\n                    hArg[k] = mac;\n                    continue;\n                }\n                val = this.alzTagArg.hPrm[k].def;\n                if (!val || val == 'null')\n                    continue;\n            }\n            const v = this.getValAmpersand(val);\n            if (v != 'undefined')\n                hArg[k] = v;\n        }\n        return tag_fnc(hArg);\n    }\n    async destroy(ms_late = 0) {\n        if (this.destroyed)\n            return;\n        this.destroyed = true;\n        if (!this.inited)\n            return;\n        await this.layMng.before_destroy();\n        if (ms_late > 0)\n            await new Promise(r => setTimeout(r, ms_late));\n        this.stop();\n        this.hTag = {};\n        this.evtMng.destroy();\n        this.layMng.destroy();\n        this.dbgMng.destroy();\n        this.appPixi.ticker.remove(this.fncTicker);\n        if (this.clone_cvs && this.appPixi) {\n            this.appPixi.view.parentElement.insertBefore(this.clone_cvs, this.appPixi.view);\n        }\n        pixi_js_1.utils.clearTextureCache();\n        this.appPixi.destroy(true);\n    }\n}\nexports.Main = Main;\n//# sourceMappingURL=Main.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Main.js?")},"../npm_core/core/lib/sn/Pages.js":
/*!****************************************!*\
  !*** ../npm_core/core/lib/sn/Pages.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nclass Pages {\n    constructor(layer, cls_, fore, hArgFore, back, hArgBack, sys, val) {\n        this.cls_ = cls_;\n        this.lay = (hArg) => this.getPage(hArg).lay(hArg);\n        this.getPage = (hArg) => (Pages.argChk_page(hArg, 'fore') != 'back')\n            ? this.pg.fore\n            : this.pg.back;\n        const fncF = sys.hFactoryCls[cls_];\n        if (!fncF)\n            throw `属性 class【${cls_}】が不正です`;\n        this.pg = { fore: fncF(), back: fncF() };\n        this.pg.fore.name = `layer:${layer} cls:${cls_} page:A`;\n        this.pg.back.name = `layer:${layer} cls:${cls_} page:B`;\n        fore.addChild(this.fore.cnt);\n        back.addChild(this.back.cnt);\n        CmnLib_1.CmnLib.argChk_Boolean(hArgFore, 'visible', true);\n        CmnLib_1.CmnLib.argChk_Boolean(hArgBack, 'visible', true);\n        this.fore.lay(hArgFore);\n        this.back.lay(hArgBack);\n        const valnm = `const.sn.lay.${layer}`;\n        val.setVal_Nochk('tmp', valnm, true);\n        val.defTmp(valnm + '.fore.alpha', () => this.pg.fore.alpha);\n        val.defTmp(valnm + '.back.alpha', () => this.pg.back.alpha);\n        val.defTmp(valnm + '.fore.height', () => this.pg.fore.height);\n        val.defTmp(valnm + '.back.height', () => this.pg.back.height);\n        val.defTmp(valnm + '.fore.visible', () => this.pg.fore.cnt.visible);\n        val.defTmp(valnm + '.back.visible', () => this.pg.back.cnt.visible);\n        val.defTmp(valnm + '.fore.width', () => this.pg.fore.width);\n        val.defTmp(valnm + '.back.width', () => this.pg.back.width);\n        val.defTmp(valnm + '.fore.x', () => this.pg.fore.x);\n        val.defTmp(valnm + '.back.x', () => this.pg.back.x);\n        val.defTmp(valnm + '.fore.y', () => this.pg.fore.y);\n        val.defTmp(valnm + '.back.y', () => this.pg.back.y);\n    }\n    destroy() {\n        this.pg.fore.destroy();\n        this.pg.back.destroy();\n    }\n    static argChk_page(hash, def) {\n        var _a;\n        const v = (_a = hash.page, (_a !== null && _a !== void 0 ? _a : def));\n        if (v == 'fore')\n            return hash.page = v;\n        if (v == 'back')\n            return hash.page = v;\n        throw Error('属性 page【' + v + '】が不正です');\n    }\n    get cls() { return this.cls_; }\n    get fore() { return this.pg.fore; }\n    get back() { return this.pg.back; }\n    transPage() {\n        [this.pg.back, this.pg.fore] = [this.pg.fore, this.pg.back];\n        this.pg.back.copy(this.pg.fore);\n    }\n}\nexports.Pages = Pages;\n//# sourceMappingURL=Pages.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Pages.js?")},"../npm_core/core/lib/sn/PropParser.js":
/*!*********************************************!*\
  !*** ../npm_core/core/lib/sn/PropParser.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst P = __webpack_require__(/*! parsimmon */ \"../npm_core/node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nclass PropParser {\n    constructor(val) {\n        this.val = val;\n        this.parser = null;\n        this.parse = s => {\n            const p = this.parser.parse(s);\n            if (!p.status)\n                throw Error('(PropParser)文法エラー【' + s + '】');\n            const a = p.value;\n            if (a[0] == '!str!')\n                return this.procEmbedVar(a[1]);\n            return this.calc(a);\n        };\n        this.hFnc = {\n            '!num!': a => a.shift(),\n            '!str!': a => this.procEmbedVar(a.shift()),\n            '!bool!': a => a.shift(),\n            '!': a => {\n                const b = a.shift();\n                return (b[0] == '!bool!')\n                    ? !Boolean(b[1])\n                    : !(String(this.calc(b)) == 'true');\n            },\n            '~': a => ~Number(this.calc(a.shift())),\n            '**': a => Number(this.calc(a.shift())) **\n                Number(this.calc(a.shift())),\n            '*': a => Number(this.calc(a.shift())) *\n                Number(this.calc(a.shift())),\n            '/': a => Number(this.calc(a.shift())) /\n                Number(this.calc(a.shift())),\n            '¥': a => Math.floor(this.hFnc['/'](a)),\n            '%': a => Number(this.calc(a.shift())) %\n                Number(this.calc(a.shift())),\n            '+': a => {\n                const b = this.calc(a.shift());\n                const c = this.calc(a.shift());\n                if (Object.prototype.toString.call(b) == '[object String]'\n                    || Object.prototype.toString.call(c) == '[object String]') {\n                    return String(b) + String(c);\n                }\n                return Number(b) + Number(c);\n            },\n            '-': a => Number(this.calc(a.shift())) -\n                Number(this.calc(a.shift())),\n            'int': a => CmnLib_1.int(this.fncSub_ChkNum(a.shift())),\n            'parseInt': a => CmnLib_1.int(this.hFnc['Number'](a)),\n            'Number': a => {\n                const b = this.calc(a.shift());\n                if (Object.prototype.toString.call(b) != '[object String]')\n                    return Number(b);\n                return this.fncSub_ChkNum(this.parser.parse(String(b)).value);\n            },\n            'ceil': a => Math.ceil(this.fncSub_ChkNum(a.shift())),\n            'floor': a => Math.floor(this.fncSub_ChkNum(a.shift())),\n            'round': a => Math.round(this.fncSub_ChkNum(a.shift())),\n            '<<': a => Number(this.calc(a.shift())) <<\n                Number(this.calc(a.shift())),\n            '>>': a => Number(this.calc(a.shift())) >>\n                Number(this.calc(a.shift())),\n            '>>>': a => Number(this.calc(a.shift())) >>>\n                Number(this.calc(a.shift())),\n            '<': a => Number(this.calc(a.shift())) <\n                Number(this.calc(a.shift())),\n            '<=': a => Number(this.calc(a.shift())) <=\n                Number(this.calc(a.shift())),\n            '>': a => Number(this.calc(a.shift())) >\n                Number(this.calc(a.shift())),\n            '>=': a => Number(this.calc(a.shift())) >=\n                Number(this.calc(a.shift())),\n            '==': a => {\n                const b = this.calc(a.shift());\n                const c = this.calc(a.shift());\n                if ((b == null) && (c == null) && (!b || !c))\n                    return (b == c);\n                return String(b) == String(c);\n            },\n            '!=': a => !this.hFnc['=='](a),\n            '===': a => {\n                const b = this.calc(a.shift());\n                const c = this.calc(a.shift());\n                if (Object.prototype.toString.call(b) !=\n                    Object.prototype.toString.call(c))\n                    return false;\n                return String(b) == String(c);\n            },\n            '!==': a => !this.hFnc['==='](a),\n            '&': a => Number(this.calc(a.shift())) &\n                Number(this.calc(a.shift())),\n            '^': a => Number(this.calc(a.shift())) ^\n                Number(this.calc(a.shift())),\n            '|': a => Number(this.calc(a.shift())) |\n                Number(this.calc(a.shift())),\n            '&&': a => (String(this.calc(a.shift())) == 'true') &&\n                (String(this.calc(a.shift())) == 'true'),\n            '||': a => (String(this.calc(a.shift())) == 'true') ||\n                (String(this.calc(a.shift())) == 'true'),\n            '?': a => {\n                const b = a.shift();\n                let cond = false;\n                if (b[0] == '!bool!') {\n                    cond = Boolean(b[1]);\n                }\n                else {\n                    const cond2 = String(this.calc(b));\n                    cond = (cond2 != 'true' && cond2 != 'false')\n                        ? (CmnLib_1.int(cond2) != 0)\n                        : (cond2 == 'true');\n                }\n                const elm2 = a.shift();\n                if (elm2[0] != ':')\n                    throw Error('(PropParser)三項演算子の文法エラーです。: が見つかりません');\n                return this.calc(elm2[cond ? 1 : 2]);\n            },\n            ':': () => { throw Error('(PropParser)三項演算子の文法エラーです。? が見つかりません'); },\n        };\n        this.REG_EMBEDVAR = /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g;\n        function ope(a) {\n            const ps = [];\n            for (const v of a)\n                ps.push(((v instanceof RegExp)\n                    ? P.regex(v)\n                    : P.string(v))\n                    .trim(P.optWhitespace));\n            return P.alt.apply(null, ps);\n        }\n        function PREFIX(operatorsParser, nextParser) {\n            const parser = P.lazy(() => {\n                return P.seq(operatorsParser, parser).or(nextParser);\n            });\n            return parser;\n        }\n        function BINARY_RIGHT(operatorsParser, nextParser) {\n            let parser = P.lazy(() => nextParser.chain((next) => P.seq(operatorsParser, P.of(next), parser).or(P.of(next))));\n            return parser;\n        }\n        function BINARY_LEFT(operatorsParser, nextParser) {\n            return P.seqMap(nextParser, P.seq(operatorsParser, nextParser).many(), (first, rest) => {\n                return rest.reduce((acc, ch) => {\n                    return [ch[0], acc, ch[1]];\n                }, first);\n            });\n        }\n        const Num = P.alt(P.alt(P.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/), P.regex(/0x[0-9a-fA-F]+/)).map(Number), P.alt(P.regex(/-?(0|[1-9][0-9]*)/)).map(n => CmnLib_1.int(n)))\n            .map(str => ['!num!', str])\n            .desc('number');\n        const NullLiteral = P.string('null')\n            .map(() => ['!str!', null]);\n        const BooleanLiteral = P.regex(/(true|false)/)\n            .map(b => ['!bool!', b == 'true'])\n            .desc('boolean');\n        const StringLiteral = P\n            .regex(/(\"|'|#).*?\\1/)\n            .map(b => ['!str!', b.slice(1, -1)])\n            .desc('string');\n        const REG_BRACKETS = /\\[[^\\]]+\\]/g;\n        const VarLiteral = P\n            .regex(/\\-?((tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(@str)?/)\n            .map(b => {\n            const s = String(b).replace(REG_BRACKETS, v => '.' + this.parse(v.slice(1, -1)));\n            if (s.charAt(0) == '-') {\n                const val = this.val.getVal(s.slice(1));\n                if (val == null || String(val) == 'null')\n                    throw Error('(PropParser)数値以外に-符号がついています');\n                return ['!num!', -Number(val)];\n            }\n            const val = this.val.getVal(s);\n            if (val == null)\n                return ['!str!', val];\n            if (typeof val == 'boolean')\n                return ['!bool!', val];\n            return (Object.prototype.toString.call(val) == '[object String]')\n                ? ['!str!', String(val)]\n                : ['!num!', Number(val)];\n        })\n            .desc('string');\n        const Basic = P.lazy(() => P\n            .string('(').then(this.parser).skip(P.string(')'))\n            .or(Num)\n            .or(NullLiteral)\n            .or(BooleanLiteral)\n            .or(StringLiteral)\n            .or(VarLiteral));\n        const table = [\n            { type: PREFIX, ops: ope([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n            { type: PREFIX, ops: ope([/(!(?!=)|~)/]) },\n            { type: BINARY_RIGHT, ops: ope(['**']) },\n            { type: BINARY_LEFT, ops: ope(['*', '/', '¥', '%']) },\n            { type: BINARY_LEFT, ops: ope(['+', '-']) },\n            { type: BINARY_LEFT, ops: ope([/(>>>|<<|>>)/]) },\n            { type: BINARY_LEFT, ops: ope([/(<=|<|>=|>)/]) },\n            { type: BINARY_LEFT, ops: ope([/(===|!==|==|!=)/]) },\n            { type: BINARY_LEFT, ops: ope([/&(?!&)/]) },\n            { type: BINARY_LEFT, ops: ope(['^']) },\n            { type: BINARY_LEFT, ops: ope([/\\|(?!\\|)/]) },\n            { type: BINARY_LEFT, ops: ope(['&&']) },\n            { type: BINARY_LEFT, ops: ope(['||']) },\n            { type: BINARY_RIGHT, ops: ope([':']) },\n            { type: BINARY_RIGHT, ops: ope(['?']) },\n        ];\n        const tableParser = table.reduce((acc, level) => level.type(level.ops, acc), Basic);\n        this.parser = tableParser.trim(P.optWhitespace);\n    }\n    calc(a) {\n        const elm = a.shift();\n        if (elm instanceof Array)\n            return this.calc(elm);\n        const fnc = this.hFnc[elm];\n        return (fnc) ? fnc(a) : Object(null);\n    }\n    fncSub_ChkNum(v) {\n        const b = this.calc(v);\n        if (Object.prototype.toString.call(b) != '[object Number]')\n            throw Error('(PropParser)引数【' + b + '】が数値ではありません');\n        return Number(b);\n    }\n    procEmbedVar(b) {\n        if (b == null)\n            return b;\n        return Object(String(b).replace(this.REG_EMBEDVAR, ($0) => {\n            return Object(($0.charAt(0) == '$')\n                ? this.val.getVal($0.slice(1))\n                : this.parse($0.slice(2, -1)));\n        }));\n    }\n    static getValName(arg_name) {\n        var _a;\n        const a = m_xregexp.exec(CmnLib_1.trim(arg_name), this.REG_VAL);\n        if (!a)\n            return undefined;\n        return {\n            scope: a.scope || 'tmp',\n            name: PropParser.getValName_B2D(a.name),\n            at: (_a = a.at, (_a !== null && _a !== void 0 ? _a : '')),\n        };\n    }\n    static getValName_B2D(str) {\n        let i = 0, e = 0;\n        while (true) {\n            i = str.indexOf('[\"');\n            if (i < 0) {\n                i = str.indexOf(\"['\");\n                if (i < 0)\n                    break;\n                e = str.indexOf(\"']\", i + 2);\n            }\n            else {\n                e = str.indexOf('\"]', i + 2);\n            }\n            if (e < 0)\n                break;\n            str = str.slice(0, i) + '.' + str.slice(i + 2, e)\n                + str.slice(e + 2);\n            i = e - 2;\n        }\n        return str;\n    }\n}\nexports.PropParser = PropParser;\nPropParser.REG_VAL = m_xregexp('^((?<scope>\\\\w+?):)?(?<name>[^\\\\s :@]+)(?<at>\\\\@str)?$');\n//# sourceMappingURL=PropParser.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/PropParser.js?")},"../npm_core/core/lib/sn/RubySpliter.js":
/*!**********************************************!*\
  !*** ../npm_core/core/lib/sn/RubySpliter.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nclass RubySpliter {\n    constructor() {\n        this.putCh = () => { };\n    }\n    setting(hArg) { if (hArg.sesame)\n        RubySpliter.sesame = hArg.sesame; }\n    getSesame() { return RubySpliter.sesame; }\n    init(putCh) { this.putCh = putCh; }\n    static setEscape(ce) {\n        RubySpliter.REG_RUBY = m_xregexp(RubySpliter.mkEscReg(ce), 'gsx');\n    }\n    putTxt(text) {\n        var _a, _b, _c;\n        let elm = null, pos = 0;\n        while (elm = m_xregexp.exec(text, RubySpliter.REG_RUBY, pos)) {\n            pos = elm['index'] + elm[0].length;\n            const ruby = elm['ruby'];\n            if (ruby) {\n                this.putTxtRb(elm['str'], ruby);\n                continue;\n            }\n            const kan_ruby = elm['kan_ruby'];\n            if (kan_ruby) {\n                this.putTxtRb(elm['kan'], kan_ruby);\n                continue;\n            }\n            if (elm['txt4']) {\n                this.putCh(elm['txt4'].slice(1), '');\n                continue;\n            }\n            const txt = (_c = (_b = (_a = elm['txt'], (_a !== null && _a !== void 0 ? _a : elm['txt2'])), (_b !== null && _b !== void 0 ? _b : elm['txt3'])), (_c !== null && _c !== void 0 ? _c : ''));\n            const a = Array.from(txt);\n            const len = a.length;\n            for (let i = 0; i < len; ++i)\n                this.putCh(a[i], '');\n        }\n    }\n    putTxtRb(text, ruby) {\n        const a = Array.from(text);\n        const len = a.length;\n        if (ruby.charAt(0) == '*' && ruby.length <= 2) {\n            const rb_ses = 'center｜'\n                + ((ruby == '*') ? RubySpliter.sesame : ruby.charAt(1));\n            for (let i = 0; i < len; ++i)\n                this.putCh(a[i], rb_ses);\n            return;\n        }\n        if (len == 1 || ruby.indexOf(' ') == -1) {\n            this.putCh(text, ruby.replace(RubySpliter.REG_TAB_G, ' '));\n            return;\n        }\n        const aR = ruby.split(' ');\n        const lenR = aR.length;\n        const len_max = (lenR > len) ? lenR : len;\n        for (let i = 0; i < len_max; ++i) {\n            this.putCh((i < len) ? a[i] : '', (i < lenR) ? aR[i].replace(RubySpliter.REG_TAB_G, ' ') : '');\n        }\n    }\n    static destroy() { RubySpliter.sesame = 'ヽ'; }\n}\nexports.RubySpliter = RubySpliter;\nRubySpliter.sesame = 'ヽ';\nRubySpliter.mkEscReg = (ce) => `(?: ${ce ? `(?<txt4>\\\\${ce}\\\\S) |` : ''}\n\t(?: ｜(?<str>[^《\\\\n]+)《(?<ruby>[^》\\\\n]+)》)\n|\t(?: (?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*\n\t|\t[^　｜》\\\\n⺀-⿟々〇〻㐀-鿿豈-﫿])《(?<kan_ruby>[^》\\\\n]+)》)\n|\t(?: (?<txt>[^　｜《》]*[ぁ-ヿ])(?=[⺀-⿟々〇〻㐀-鿿豈-﫿]+《))\n|\t(?<txt2>[^｜《》]+(?=｜\\\\|　))\n|\t(?<txt3>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|.)\n)`;\nRubySpliter.REG_TAB_G = /\\t/g;\n//# sourceMappingURL=RubySpliter.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/RubySpliter.js?")},"../npm_core/core/lib/sn/ScriptIterator.js":
/*!*************************************************!*\
  !*** ../npm_core/core/lib/sn/ScriptIterator.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst CallStack_1 = __webpack_require__(/*! ./CallStack */ \"../npm_core/core/lib/sn/CallStack.js\");\nconst Grammar_1 = __webpack_require__(/*! ./Grammar */ \"../npm_core/core/lib/sn/Grammar.js\");\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst DebugMng_1 = __webpack_require__(/*! ./DebugMng */ \"../npm_core/core/lib/sn/DebugMng.js\");\n;\n;\nclass ScriptIterator {\n    constructor(cfg, hTag, main, val, alzTagArg, runAnalyze, parse, sndMng, sys) {\n        this.cfg = cfg;\n        this.hTag = hTag;\n        this.main = main;\n        this.val = val;\n        this.alzTagArg = alzTagArg;\n        this.runAnalyze = runAnalyze;\n        this.parse = parse;\n        this.sndMng = sndMng;\n        this.sys = sys;\n        this.script = { aToken: [''], len: 1, aLNum: [1] };\n        this.scriptFn_ = '';\n        this.idxToken_ = 0;\n        this.lineNum_ = 0;\n        this.addLineNum = (len) => { this.lineNum_ += len; };\n        this.aCallStk = [];\n        this.getCallStk = (idx) => this.aCallStk[idx].hArg;\n        this.grm = new Grammar_1.Grammar;\n        this.fncSet = () => { };\n        this.fncBreak = () => { };\n        this.fnLastBreak = '';\n        this.hScrCache4Dump = {};\n        this.noticeBreak = (_set) => { };\n        this.dumpErrLine = 5;\n        this.aIfStk = [-1];\n        this.resvToken = '';\n        this.skipLabel = '';\n        this.onlyCodeScript = (full_path) => {\n            const is_cry = full_path.substr(-1) == '_';\n            if (is_cry)\n                this.replaceScript_Wildcard_Sub_ext = (nm) => nm == 'loadplugin' ? 'css' : 'sn_';\n            this.onlyCodeScript = is_cry\n                ? (fp) => (fp.substr(-1) != '_')\n                : (_) => false;\n            return false;\n        };\n        this.REG_NONAME_LABEL = /(\\*{2,})(.*)/;\n        this.REG_LABEL_ESC = /\\*/g;\n        this.REG_TOKEN_MACRO_BEGIN = /\\[macro\\s/;\n        this.REG_TOKEN_MACRO_END = /\\[endmacro[\\s\\]]/;\n        this.REG_TAG_LET_ML = m_xregexp(`^\\\\[let_ml\\\\s`, 'g');\n        this.REG_TAG_ENDLET_ML = m_xregexp(`^\\\\[endlet_ml\\\\s*]`, 'g');\n        this.hScript = Object.create(null);\n        this.REG_WILDCARD = /^\\[(call|loadplugin)\\s/;\n        this.REG_WILDCARD2 = /\\bfn\\s*=\\s*[^\\s\\]]+/;\n        this.replaceScript_Wildcard = () => {\n            for (let i = this.script.len - 1; i >= 0; --i) {\n                const token = this.script.aToken[i];\n                this.REG_WILDCARD.lastIndex = 0;\n                if (!this.REG_WILDCARD.test(token))\n                    continue;\n                const a_tag = m_xregexp.exec(token, Grammar_1.Grammar.REG_TAG);\n                if (!this.alzTagArg.go(a_tag['args']))\n                    continue;\n                const p_fn = this.alzTagArg.hPrm['fn'];\n                if (!p_fn)\n                    continue;\n                const fn = p_fn.val;\n                if (!fn || fn.slice(-1) != '*')\n                    continue;\n                const ext = this.replaceScript_Wildcard_Sub_ext(a_tag['name']);\n                const a = this.cfg.matchPath('^' + fn.slice(0, -1) + '.*', ext);\n                this.script.aToken.splice(i, 1, '\\t', '; ' + token);\n                this.script.aLNum.splice(i, 1, NaN, NaN);\n                for (const v of a) {\n                    const nt = token.replace(this.REG_WILDCARD2, 'fn=' + decodeURIComponent(CmnLib_1.CmnLib.getFn(v[ext])));\n                    this.script.aToken.splice(i, 0, nt);\n                    this.script.aLNum.splice(i, 0, NaN);\n                }\n            }\n            this.script.len = this.script.aToken.length;\n        };\n        this.replaceScript_Wildcard_Sub_ext = (nm) => nm == 'loadplugin' ? 'css' : 'sn';\n        this.nextToken = () => '';\n        this.isKidoku_ = false;\n        this.hTagInf = {};\n        this.mark = {\n            hSave: {},\n            hPages: {},\n            aIfStk: [-1],\n        };\n        hTag.let_ml = o => this.let_ml(o);\n        hTag.dump_stack = () => this.dump_stack();\n        hTag.dump_script = o => this.dump_script(o);\n        hTag['else'] =\n            hTag.elsif =\n                hTag.endif = () => this.endif();\n        hTag['if'] = o => this.if(o);\n        hTag.call = o => this.call(o);\n        hTag.jump = o => this.jump(o);\n        hTag.pop_stack = o => this.pop_stack(o);\n        hTag.return = () => this.return();\n        hTag.bracket2macro = o => this.bracket2macro(o);\n        hTag.break_macro = o => this.break_macro(o);\n        hTag.char2macro = o => this.char2macro(o);\n        hTag.endmacro = o => this.break_macro(o);\n        hTag.macro = o => this.macro(o);\n        hTag.load = o => this.load(o);\n        hTag.reload_script = o => this.reload_script(o);\n        hTag.record_place = () => this.record_place();\n        hTag.save = o => this.save(o);\n        val.defTmp('const.sn.vctCallStk.length', () => this.aCallStk.length);\n        this.grm.setEscape(cfg.oCfg.init.escape);\n    }\n    get scriptFn() { return this.scriptFn_; }\n    ;\n    get idxToken() { return this.idxToken_; }\n    ;\n    subIdxToken() { --this.idxToken_; }\n    ;\n    get lineNum() { return this.lineNum_; }\n    get now_token() { return this.script.aToken[this.idxToken_ - 1]; }\n    ;\n    get isEmptyCallStk() { return this.aCallStk.length == 0; }\n    ;\n    get lenCallStk() { return this.aCallStk.length; }\n    ;\n    get lastHArg() { return this.aCallStk[this.lenCallStk - 1].hArg; }\n    ;\n    setOtherObj(evtMng, layMng) {\n        this.evtMng = evtMng;\n        this.layMng = layMng;\n    }\n    let_ml(hArg) {\n        var _a;\n        const name = hArg.name;\n        if (!name)\n            throw 'nameは必須です';\n        let ml = '';\n        const len = this.script.len;\n        for (; this.idxToken_ < len; ++this.idxToken_) {\n            ml = this.script.aToken[this.idxToken_];\n            if (ml != '')\n                break;\n        }\n        hArg.text = ml;\n        hArg.cast = 'str';\n        this.hTag['let'](hArg);\n        this.idxToken_ += 2;\n        this.lineNum_ += (_a = ml.match(/\\n/g), (_a !== null && _a !== void 0 ? _a : [])).length;\n        return false;\n    }\n    dump_stack() {\n        if (this.idxToken_ == 0) {\n            console.group(`🥟 [dump_stack] スクリプト現在地 fn:${this.scriptFn_} line:${1} col:${0}`);\n            console.groupEnd();\n            return false;\n        }\n        const lc0 = this.getScr2lineCol(this.script, this.idxToken_);\n        const now = `スクリプト現在地 fn:${this.scriptFn_} line:${lc0.line} col:${lc0.col_s + 1}`;\n        console.group(`🥟 [dump_stack] ${now}`);\n        const len = this.aCallStk.length;\n        if (len > 0) {\n            console.info(now);\n            for (let i = len - 1; i >= 0; --i) {\n                const cs = this.aCallStk[i];\n                const lc = this.getScr2lineCol(this.hScript[cs.fn], cs.idx);\n                if (!cs.hArg)\n                    continue;\n                const csa = cs.hArg.hMpVal;\n                const from_macro_nm = csa ? csa['タグ名'] : null;\n                const call_nm = cs.hArg.タグ名;\n                console.info(`${len - i}つ前のコール元 fn:${cs.fn} line:${lc.line} col:${lc.col_s + 1}` + (from_macro_nm ? '（[' + from_macro_nm + ']マクロ内）' : ' ') +\n                    `で [${call_nm} ...]をコール`);\n            }\n        }\n        console.groupEnd();\n        return false;\n    }\n    getScr2lineCol(st, idx) {\n        const ret = { line: 0, col_s: 0, col_e: 0 };\n        if (st == null)\n            return ret;\n        const lN = ret.line = st.aLNum[idx - 1];\n        let col_e = 0;\n        let i = idx - 1;\n        while (st.aLNum[i] == lN) {\n            col_e += st.aToken[i].length;\n            if (--i < 0)\n                break;\n        }\n        ret.col_e = col_e;\n        ret.col_s = col_e - st.aToken[idx - 1].length;\n        return ret;\n    }\n    dump_script(hArg) {\n        const set_fnc = hArg.set_fnc;\n        if (!set_fnc)\n            throw 'set_fncは必須です';\n        this.fncSet = window[set_fnc];\n        if (!this.fncSet) {\n            if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'need_err', true))\n                throw `HTML内に関数${set_fnc}が見つかりません`;\n            this.fncSet = () => { };\n            return false;\n        }\n        this.noticeBreak = (set) => {\n            if (this.fnLastBreak != this.scriptFn_) {\n                this.fnLastBreak = this.scriptFn_;\n                this.fncSet(this.hScrCache4Dump[this.scriptFn_]\n                    = this.hScrCache4Dump[this.scriptFn_]\n                        || this.script.aToken.join(''));\n            }\n            this.fncBreak(this.lineNum_, set);\n        };\n        this.noticeBreak(true);\n        const break_fnc = hArg.break_fnc;\n        if (!break_fnc)\n            return false;\n        this.fncBreak = window[break_fnc];\n        if (!this.fncBreak) {\n            if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'need_err', true))\n                throw `HTML内に関数${break_fnc}が見つかりません`;\n            this.fncBreak = () => { };\n        }\n        return false;\n    }\n    dumpErrForeLine() {\n        var _a;\n        if (this.idxToken_ == 0) {\n            console.group(`🥟 Error line (from 0 rows before) fn:${this.scriptFn_}`);\n            console.groupEnd();\n            return;\n        }\n        let s = '';\n        for (let i = this.idxToken_ - 1; i >= 0; --i) {\n            s = this.script.aToken[i] + s;\n            if ((_a = s.match(/\\n/g), (_a !== null && _a !== void 0 ? _a : [])).length >= this.dumpErrLine)\n                break;\n        }\n        const a = s.split('\\n').slice(-this.dumpErrLine);\n        const len = a.length;\n        console.group(`🥟 Error line (from ${len} rows before) fn:${this.scriptFn_}`);\n        const ln_txt_width = String(this.lineNum_).length;\n        const lc = this.getScr2lineCol(this.script, this.idxToken_);\n        for (let i = 0; i < len; ++i) {\n            const ln = this.lineNum_ - len + i + 1;\n            const mes = `${String(ln).padStart(ln_txt_width, ' ')}: %c`;\n            const e = a[i];\n            const line = (e.length > 75) ? e.substr(0, 75) + '…' : e;\n            if (i == len - 1)\n                console.info(mes + line.slice(0, lc.col_s) + '%c' + line.slice(lc.col_s), 'color: black; background-color: skyblue;', 'color: black; background-color: pink;');\n            else\n                console.info(mes + line, 'color: black; background-color: skyblue;');\n        }\n        console.groupEnd();\n    }\n    endif() {\n        if (this.aIfStk[0] == -1)\n            throw 'ifブロック内ではありません';\n        this.idxToken_ = this.aIfStk[0];\n        this.lineNum_ = this.script.aLNum[this.idxToken_ - 1];\n        this.aIfStk.shift();\n        return false;\n    }\n    if(hArg) {\n        const exp = hArg.exp;\n        if (!exp)\n            throw 'expは必須です';\n        if (exp.charAt(0) == '&')\n            throw '属性expは「&」が不要です';\n        let cntDepth = 0;\n        let idxGo = this.parse(exp) ? this.idxToken_ : -1;\n        for (; this.idxToken_ < this.script.len; ++this.idxToken_) {\n            if (!this.script.aLNum[this.idxToken_])\n                this.script.aLNum[this.idxToken_] = this.lineNum_;\n            const t = this.script.aToken[this.idxToken_];\n            if (!t)\n                continue;\n            const uc = t.charCodeAt(0);\n            if (uc == 10) {\n                this.addLineNum(t.length);\n                continue;\n            }\n            if (uc != 91)\n                continue;\n            const a_tag = m_xregexp.exec(t, Grammar_1.Grammar.REG_TAG);\n            if (a_tag == null)\n                throw 'タグ記述[' + t + ']異常です(if文)';\n            const tag_name = a_tag['name'];\n            if (!(tag_name in this.hTag))\n                throw '未定義のタグ[' + tag_name + ']です';\n            if (!this.alzTagArg.go(a_tag['args']))\n                throw '属性「' + this.alzTagArg.literal + '」は異常です';\n            switch (tag_name) {\n                case 'if':\n                    ++cntDepth;\n                    break;\n                case 'elsif':\n                    if (cntDepth > 0)\n                        break;\n                    if (idxGo > -1)\n                        break;\n                    const e = this.alzTagArg.hPrm['exp'].val;\n                    if (e.charAt() == '&')\n                        throw '属性expは「&」が不要です';\n                    if (this.parse(e))\n                        idxGo = this.idxToken_ + 1;\n                    break;\n                case 'else':\n                    if (cntDepth > 0)\n                        break;\n                    if (idxGo == -1)\n                        idxGo = this.idxToken_ + 1;\n                    break;\n                case 'endif':\n                    if (cntDepth > 0) {\n                        --cntDepth;\n                        break;\n                    }\n                    if (idxGo == -1) {\n                        ++this.idxToken_;\n                        this.script.aLNum[this.idxToken_] = this.lineNum_;\n                    }\n                    else {\n                        this.aIfStk.unshift(this.idxToken_ + 1);\n                        this.idxToken_ = idxGo;\n                        this.lineNum_ = this.script.aLNum[this.idxToken_];\n                    }\n                    return false;\n            }\n        }\n        throw '[endif]がないままスクリプト終端です';\n    }\n    call(hArg) {\n        if (!CmnLib_1.CmnLib.argChk_Boolean(hArg, 'count', false))\n            this.eraseKidoku();\n        const fn = hArg.fn;\n        if (fn)\n            this.cfg.searchPath(fn, Config_1.Config.EXT_SCRIPT);\n        this.script.aLNum[this.idxToken_] = this.lineNum_;\n        const hPushArg = {\n            csAnalyBf: new CallStack_1.CallStack(this.scriptFn_, this.idxToken_),\n            hEvt1Time: this.evtMng.popLocalEvts()\n        };\n        this.callSub(hPushArg);\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'clear_local_event', false))\n            this.hTag.clear_event({});\n        this.jumpWork(fn, hArg.label);\n        return true;\n    }\n    callSub(hPushArg) {\n        if (!this.resvToken) {\n            hPushArg.resvToken = this.resvToken;\n            this.clearResvToken();\n        }\n        this.pushCallStack(hPushArg);\n        this.aIfStk.unshift(-1);\n    }\n    jump(hArg) {\n        if (!CmnLib_1.CmnLib.argChk_Boolean(hArg, 'count', true))\n            this.eraseKidoku();\n        this.aIfStk[0] = -1;\n        this.jumpWork(hArg.fn, hArg.label);\n        return true;\n    }\n    pop_stack(hArg) {\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'clear', false)) {\n            while (this.aCallStk.length > 0)\n                this.aCallStk.pop();\n        }\n        else {\n            if (this.aCallStk.length == 0)\n                throw '[pop_stack] スタックが空です';\n            this.aCallStk.pop();\n        }\n        this.clearResvToken();\n        this.aIfStk = [-1];\n        return false;\n    }\n    return() {\n        if (this.aCallStk.length == 0)\n            throw '[return] スタックが空です';\n        const cs = this.aCallStk.pop();\n        if (!cs || !cs.hArg)\n            return false;\n        this.aIfStk.shift();\n        const after_token = cs.hArg.resvToken;\n        if (after_token)\n            this.nextToken = () => {\n                this.clearResvToken();\n                return after_token;\n            };\n        else\n            this.clearResvToken();\n        if (cs.hArg.hEvt1Time)\n            this.evtMng.pushLocalEvts(cs.hArg.hEvt1Time);\n        const oscr = this.hScript[cs.fn];\n        if (!oscr) {\n            this.jumpWork(cs.fn, '', cs.idx);\n            return true;\n        }\n        this.jump_light(cs.fn, cs.idx);\n        return false;\n    }\n    clearResvToken() {\n        this.resvToken = '';\n        this.nextToken = this.nextToken_Proc;\n    }\n    jumpWork(fn = '', label = '', idx = 0) {\n        if (!fn && !label)\n            this.main.errScript('[jump系] fnまたはlabelは必須です');\n        if (label) {\n            if (label.charAt(0) != '*')\n                this.main.errScript('[jump系] labelは*で始まります');\n            this.skipLabel = label;\n            if (this.skipLabel.slice(0, 2) != '**')\n                this.idxToken_ = idx;\n        }\n        else {\n            this.skipLabel = '';\n            this.idxToken_ = idx;\n        }\n        if (!fn) {\n            this.analyzeInit();\n            return;\n        }\n        const full_path = this.cfg.searchPath(fn, Config_1.Config.EXT_SCRIPT);\n        if (fn == this.scriptFn_) {\n            this.analyzeInit();\n            return;\n        }\n        this.scriptFn_ = fn;\n        const st = this.hScript[this.scriptFn_];\n        if (st) {\n            this.script = st;\n            this.analyzeInit();\n            return;\n        }\n        if (this.onlyCodeScript(full_path))\n            this.main.errScript('[セキュリティ] 最初のスクリプトが暗号化だったため、以降は暗号化スクリプト以外許されません');\n        (new pixi_js_1.Loader()).add(this.scriptFn_, full_path)\n            .pre((res, next) => res.load(() => {\n            res.data = this.sys.pre(res.extension, res.data);\n            next();\n        }))\n            .load((_loader, res) => {\n            const err = res[this.scriptFn_].error;\n            if (err) {\n                this.main.errScript(`[jump系]スクリプトロード失敗です ${err}`, false);\n                return;\n            }\n            this.nextToken = this.nextToken_Proc;\n            this.resolveScript(res[this.scriptFn_].data);\n            this.hTag.record_place({});\n            this.main.resume(() => this.analyzeInit());\n        });\n        this.main.stop();\n    }\n    analyzeInit() {\n        const o = this.seekScript(this.script, Boolean(this.val.getVal('mp:const.sn.macro_name')), this.lineNum_, this.skipLabel, this.idxToken_);\n        this.idxToken_ = o.idx;\n        this.lineNum_ = o.lineNum;\n        this.runAnalyze();\n    }\n    seekScript(st, inMacro, ln, skipLabel, idxToken) {\n        var _a;\n        const len = st.aToken.length;\n        if (!skipLabel) {\n            if (idxToken >= len)\n                DebugMng_1.DebugMng.myTrace('[jump系] 内部エラー idxToken:' + idxToken + ' は、最大トークン数:' + len + 'を越えます', 'ET');\n            if (!st.aLNum[idxToken]) {\n                ln = 1;\n                for (let j = 0; j < idxToken; ++j) {\n                    if (!st.aLNum[j])\n                        st.aLNum[j] = ln;\n                    const token_j = st.aToken[j];\n                    if (token_j.charCodeAt(0) == 10) {\n                        ln += token_j.length;\n                    }\n                }\n                st.aLNum[idxToken] = ln;\n            }\n            else {\n                ln = st.aLNum[idxToken];\n            }\n            return {\n                idx: idxToken,\n                lineNum: ln\n            };\n        }\n        st.aLNum[0] = 1;\n        const a_skipLabel = skipLabel.match(this.REG_NONAME_LABEL);\n        if (a_skipLabel) {\n            skipLabel = a_skipLabel[1];\n            let i = idxToken;\n            switch (a_skipLabel[2]) {\n                case 'before':\n                    while (st.aToken[--i] != skipLabel) {\n                        if (i == 0)\n                            DebugMng_1.DebugMng.myTrace('[jump系 無名ラベルbefore] '\n                                + ln + '行目以前で' + (inMacro ? 'マクロ内に' : '')\n                                + 'ラベル【' + skipLabel + '】がありません', 'ET');\n                        if (inMacro && st.aToken[i].search(this.REG_TOKEN_MACRO_BEGIN) > -1)\n                            DebugMng_1.DebugMng.myTrace('[jump系 無名ラベルbefore] マクロ内にラベル【' + skipLabel + '】がありません', 'ET');\n                    }\n                    return {\n                        idx: i + 1,\n                        lineNum: st.aLNum[i]\n                    };\n                case 'after':\n                    while (st.aToken[++i] != skipLabel) {\n                        if (i == len)\n                            DebugMng_1.DebugMng.myTrace('[jump系 無名ラベルafter] '\n                                + ln + '行目以後でマクロ内にラベル【' + skipLabel + '】がありません', 'ET');\n                        if (st.aToken[i].search(this.REG_TOKEN_MACRO_END) > -1)\n                            DebugMng_1.DebugMng.myTrace('[jump系 無名ラベルafter] '\n                                + ln + '行目以後でマクロ内にラベル【' + skipLabel + '】がありません', 'ET');\n                    }\n                    return {\n                        idx: i + 1,\n                        lineNum: st.aLNum[i]\n                    };\n                default:\n                    DebugMng_1.DebugMng.myTrace('[jump系] 無名ラベル指定【label=' + skipLabel + '】が間違っています', 'ET');\n            }\n        }\n        ln = 1;\n        const reLabel = new RegExp('^' + skipLabel.replace(this.REG_LABEL_ESC, '\\\\*')\n            + '(?:\\\\s|;|\\\\[|$)');\n        let in_let_ml = false;\n        for (let i = 0; i < len; ++i) {\n            if (!st.aLNum[i])\n                st.aLNum[i] = ln;\n            const token = st.aToken[i];\n            const uc = token.charCodeAt(0);\n            if (uc != 42) {\n                if (in_let_ml) {\n                    this.REG_TAG_ENDLET_ML.lastIndex = 0;\n                    if (this.REG_TAG_ENDLET_ML.test(token)) {\n                        in_let_ml = false;\n                        continue;\n                    }\n                    ln += (_a = token.match(/\\n/g), (_a !== null && _a !== void 0 ? _a : [])).length;\n                }\n                else {\n                    this.REG_TAG_LET_ML.lastIndex = 0;\n                    if (this.REG_TAG_LET_ML.test(token)) {\n                        in_let_ml = true;\n                        continue;\n                    }\n                    if (uc == 10)\n                        ln += token.length;\n                }\n                continue;\n            }\n            if (token.search(reLabel) > -1)\n                return {\n                    idx: i + 1,\n                    lineNum: ln\n                };\n        }\n        if (in_let_ml)\n            throw '[let_ml]の終端・[endlet_ml]がありません';\n        DebugMng_1.DebugMng.myTrace(`[jump系] ラベル【` + skipLabel + `】がありません`, 'ET');\n        throw 'Dummy';\n    }\n    resolveScript(txt) {\n        txt = txt.replace(/(\\r\\n|\\r)/g, '\\n');\n        const v = this.grm.cnvMultilineTag(txt).match(this.grm.REG_TOKEN);\n        if (!v)\n            throw 'CmnLib.cnvMultilineTag fail';\n        for (let i = v.length - 1; i >= 0; --i) {\n            const e = v[i];\n            this.REG_TAG_LET_ML.lastIndex = 0;\n            if (this.REG_TAG_LET_ML.test(e)) {\n                const idx = e.indexOf(']') + 1;\n                if (idx == 0)\n                    throw '[let_ml]で閉じる【]】がありません';\n                const a = e.slice(0, idx);\n                const b = e.slice(idx);\n                v.splice(i, 1, a, b);\n            }\n        }\n        this.script = { aToken: v, len: v.length, aLNum: [] };\n        let mes = '';\n        try {\n            mes = 'ScriptIterator.replaceScriptChar2macro';\n            this.grm.replaceScr_C2M_And_let_ml(this.script);\n            mes = 'ScriptIterator.replaceScript_Wildcard';\n            this.replaceScript_Wildcard();\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                const e = err;\n                mes += '例外 mes=' + e.message + '(' + e.name + ')';\n            }\n            else {\n                mes = err;\n            }\n            this.main.errScript(mes, false);\n        }\n        this.hScript[this.scriptFn_] = this.script;\n        this.val.loadScrWork(this.scriptFn_);\n    }\n    jump_light(fn, idx) {\n        this.scriptFn_ = fn;\n        this.idxToken_ = idx;\n        const st = this.hScript[this.scriptFn_];\n        if (st != null)\n            this.script = st;\n        this.lineNum_ = this.script.aLNum[idx];\n    }\n    nextToken_Proc() {\n        if (this.idxToken_ == this.script.len)\n            this.main.errScript('スクリプト終端です  idxToken:' + this.idxToken_ + ' this.tokens.aToken.length:' + this.script.aToken.length);\n        this.recordKidoku();\n        if (!this.script.aLNum[this.idxToken_])\n            this.script.aLNum[this.idxToken_] = this.lineNum_;\n        const token = this.script.aToken[this.idxToken_];\n        this.main.stop();\n        ++this.idxToken_;\n        return token;\n    }\n    recordKidoku() {\n        const areas = this.val.getAreaKidoku(this.scriptFn_);\n        if (!areas)\n            throw `recordKidoku fn:'${this.scriptFn_}' (areas == null)`;\n        if (this.aCallStk.length > 0) {\n            areas.record(this.idxToken_);\n            return;\n        }\n        this.isKidoku_ = areas.search(this.idxToken_);\n        this.val.setVal_Nochk('tmp', 'const.sn.isKidoku', this.isKidoku_);\n        if (this.isKidoku_)\n            return;\n        areas.record(this.idxToken_);\n    }\n    get isKidoku() { return this.isKidoku_; }\n    ;\n    eraseKidoku() {\n        const areas = this.val.getAreaKidoku(this.scriptFn_);\n        if (areas)\n            areas.erase(this.idxToken_);\n        this.isKidoku_ = false;\n    }\n    get isNextKidoku() {\n        let fn = this.scriptFn;\n        let idx = this.idxToken;\n        let len = this.script.len;\n        if (this.aCallStk.length > 0) {\n            const cs = this.aCallStk[0];\n            fn = cs.fn;\n            idx = cs.idx;\n            const st = this.hScript[fn];\n            if (st != null)\n                len = st.len;\n        }\n        const areas = this.val.getAreaKidoku(fn);\n        if (!areas)\n            return false;\n        if (idx == len)\n            return false;\n        return areas.search(idx);\n    }\n    pushCallStack(hArg) {\n        this.aCallStk.push(new CallStack_1.CallStack(this.scriptFn_, this.idxToken_, hArg));\n    }\n    get normalWait() {\n        return this.isKidoku_\n            ? (this.val.getVal('sys:sn.tagCh.doWait_Kidoku')\n                ? CmnLib_1.uint(this.val.getVal('sys:sn.tagCh.msecWait_Kidoku'))\n                : 0)\n            : (this.val.getVal('sys:sn.tagCh.doWait')\n                ? CmnLib_1.uint(this.val.getVal('sys:sn.tagCh.msecWait'))\n                : 0);\n    }\n    bracket2macro(hArg) {\n        this.grm.bracket2macro(hArg, this.script, this.idxToken_);\n        return false;\n    }\n    break_macro(hArg) {\n        const len = this.aCallStk.length;\n        if (len == 0)\n            throw '[endmacro] マクロ外で呼ばれました';\n        const hPopArg = this.aCallStk[len - 1].hArg.hMpVal;\n        if (hPopArg)\n            this.val.setMp(hPopArg);\n        return this.hTag['return'](hArg);\n    }\n    char2macro(hArg) {\n        this.grm.char2macro(hArg, this.hTag, this.script, this.idxToken_);\n        return false;\n    }\n    macro(hArg) {\n        var _a;\n        const name = hArg.name;\n        if (!name)\n            throw 'nameは必須です';\n        if (name in this.hTag) {\n            const o = this.hTagInf[name];\n            if (!o)\n                throw 'すでに定義済みのタグ[' + name + ']です';\n            throw 'すでに ' + o.fn + '.sn にて定義済みのマクロ[' + name + ']です';\n        }\n        const cs = new CallStack_1.CallStack(this.scriptFn_, this.idxToken_);\n        const ln = this.lineNum_;\n        this.hTag[name] = hArg => {\n            const hPushArg = Object.assign({}, hArg);\n            hPushArg.hMpVal = this.val.cloneMp();\n            this.callSub(hPushArg);\n            this.val.setMp(hArg);\n            this.val.setVal_Nochk('mp', 'const.sn.macro_name', name);\n            this.val.setVal_Nochk('mp', 'const.sn.me_call_scriptFn', this.scriptFn_);\n            this.lineNum_ = ln;\n            const keep_cs = cs;\n            this.jump_light(keep_cs.fn, keep_cs.idx);\n            return false;\n        };\n        this.hTagInf[name] = { by: 'macro', fn: this.scriptFn_ };\n        for (; this.idxToken_ < this.script.len; ++this.idxToken_) {\n            if (!this.script.aLNum[this.idxToken_])\n                this.script.aLNum[this.idxToken_] = this.lineNum_;\n            const token = this.script.aToken[this.idxToken_];\n            if (token.search(this.REG_TOKEN_MACRO_END) > -1) {\n                ++this.idxToken_;\n                return false;\n            }\n            if (token.charCodeAt(0) == 10)\n                this.lineNum_ += (_a = token.match(/\\n/g), (_a !== null && _a !== void 0 ? _a : [])).length;\n        }\n        throw 'マクロ' + name + '定義の終端・[endmacro]がありません';\n    }\n    load(hArg) {\n        const place = hArg.place;\n        if (!place)\n            throw 'placeは必須です';\n        if (('fn' in hArg) != ('label' in hArg))\n            throw 'fnとlabelはセットで指定して下さい';\n        const mark = this.val.getMark(place);\n        if (!mark)\n            throw `place【${place}】は存在しません`;\n        return this.loadFromMark(hArg, mark);\n    }\n    loadFromMark(hArg, mark, reload_sound = true) {\n        this.layMng.cover(true);\n        this.hTag.clear_event({});\n        this.val.mark2save(mark);\n        this.layMng.recText('', true);\n        if (reload_sound)\n            this.sndMng.playLoopFromSaveObj();\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'do_rec', true))\n            this.mark = {\n                hSave: this.val.cloneSave(),\n                hPages: Object.assign({}, mark.hPages),\n                aIfStk: [...mark.aIfStk],\n            };\n        const o = {\n            enabled: this.val.getVal('save:const.sn.autowc.enabled'),\n            text: String(this.val.getVal('save:const.sn.autowc.text')),\n            time: String(this.val.getVal('save:const.sn.autowc.time')),\n        };\n        this.hTag.autowc(o);\n        const fn = String(this.val.getVal('save:const.sn.scriptFn'));\n        const idx = Number(this.val.getVal('save:const.sn.scriptIdx'));\n        delete this.hScript[fn];\n        this.aIfStk = [...this.mark.aIfStk];\n        this.aCallStk = [];\n        this.layMng.playback(this.mark.hPages, 'label' in hArg\n            ? () => {\n                this.layMng.cover(false);\n                this.scriptFn_ = fn;\n                this.idxToken_ = idx;\n                this.hTag.call({ fn: hArg.fn, label: hArg.label });\n            }\n            : () => {\n                this.layMng.cover(false);\n                this.jumpWork(fn, '', idx);\n            });\n        return true;\n    }\n    reload_script(hArg) {\n        const mark = this.val.getMark(0);\n        delete this.hScript[CmnLib_1.CmnLib.getFn(mark.hSave['const.sn.scriptFn'])];\n        hArg.do_rec = false;\n        return this.loadFromMark(hArg, mark, false);\n    }\n    record_place() {\n        if (this.main.isDestroyed())\n            return false;\n        if (this.aCallStk.length == 0) {\n            this.val.setVal_Nochk('save', 'const.sn.scriptFn', this.scriptFn);\n            this.val.setVal_Nochk('save', 'const.sn.scriptIdx', this.idxToken);\n        }\n        else {\n            this.val.setVal_Nochk('save', 'const.sn.scriptFn', this.aCallStk[0].fn);\n            this.val.setVal_Nochk('save', 'const.sn.scriptIdx', this.aCallStk[0].idx);\n        }\n        this.mark = {\n            hSave: this.val.cloneSave(),\n            hPages: this.layMng.record(),\n            aIfStk: this.aIfStk.slice(this.aCallStk.length),\n        };\n        return false;\n    }\n    save(hArg) {\n        var _a;\n        const place = hArg.place;\n        if (!place)\n            throw 'placeは必須です';\n        delete hArg.タグ名;\n        delete hArg.place;\n        hArg.text = (_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).replace(/^(<br\\/>)+/, '');\n        this.mark.json = hArg;\n        this.val.setMark(place, this.mark);\n        const now_sp = Number(this.val.getVal('sys:const.sn.save.place'));\n        if (place == now_sp)\n            this.val.setVal_Nochk('sys', 'const.sn.save.place', now_sp + 1);\n        return false;\n    }\n}\nexports.ScriptIterator = ScriptIterator;\n//# sourceMappingURL=ScriptIterator.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/ScriptIterator.js?")},"../npm_core/core/lib/sn/SoundMng.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/SoundMng.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnTween_1 = __webpack_require__(/*! ./CmnTween */ \"../npm_core/core/lib/sn/CmnTween.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst howler_1 = __webpack_require__(/*! howler */ \"../npm_core/node_modules/howler/dist/howler.js\");\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\n;\nclass SoundMng {\n    constructor(cfg, hTag, val, main) {\n        this.cfg = cfg;\n        this.val = val;\n        this.main = main;\n        this.hSndBuf = {};\n        this.initVol = () => {\n            Howler.volume(Number(this.val.getVal('sys:sn.sound.global_volume', 1)));\n            this.initVol = () => { };\n        };\n        hTag.volume = o => this.volume(o);\n        hTag.fadebgm = o => this.fadebgm(o);\n        hTag.fadeoutbgm = o => this.fadeoutbgm(o);\n        hTag.fadeoutse = o => this.fadeoutse(o);\n        hTag.fadese = o => this.fadese(o);\n        hTag.playbgm = o => this.playbgm(o);\n        hTag.playse = o => this.playse(o);\n        hTag.stop_allse = () => this.stop_allse();\n        hTag.stopbgm = o => this.stopbgm(o);\n        hTag.stopse = o => this.stopse(o);\n        hTag.wb = o => this.wb(o);\n        hTag.wf = o => this.wf(o);\n        hTag.stopfadese = o => this.stopfadese(o);\n        hTag.wl = o => this.wl(o);\n        hTag.ws = o => this.ws(o);\n        hTag.xchgbuf = o => this.xchgbuf(o);\n        val.defValTrg('sys:sn.sound.global_volume', (_name, val) => Howler.volume(Number(val)));\n        this.val.setVal_Nochk('save', 'const.sn.loopPlaying', '{}');\n        const codecs = {};\n        ['mp3', 'm4a', 'ogg', 'aac', 'webm', 'flac', 'wav'].forEach(v => { codecs[v] = Howler.codecs(v); });\n        val.setVal_Nochk('tmp', 'const.sn.sound.codecs', JSON.stringify(codecs));\n    }\n    setEvtMng(evtMng) { this.evtMng = evtMng; }\n    volume(hArg) {\n        var _a;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const bvn = 'const.sn.sound.' + buf + '.volume';\n        const arg_vol = this.getVol(hArg, 1);\n        if (Number(this.val.getVal('sys:' + bvn)) == arg_vol)\n            return false;\n        this.val.setVal_Nochk('sys', bvn, arg_vol);\n        this.val.flush();\n        hArg.time = 0;\n        hArg.volume = Number(this.val.getVal('save:' + bvn));\n        return this.fadese(hArg);\n    }\n    getVol(hArg, def) {\n        const vol = CmnLib_1.CmnLib.argChk_Num(hArg, 'volume', def);\n        if (vol < 0)\n            return 0;\n        if (vol > 1)\n            return 1;\n        return vol;\n    }\n    fadeoutbgm(hArg) { hArg.volume = 0; return this.fadebgm(hArg); }\n    fadeoutse(hArg) { hArg.volume = 0; return this.fadese(hArg); }\n    fadebgm(hArg) { hArg.buf = 'BGM'; return this.fadese(hArg); }\n    fadese(hArg) {\n        var _a;\n        this.stopfadese(hArg);\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const oSb = this.hSndBuf[buf];\n        if (!oSb || !oSb.playing())\n            return false;\n        const bvn = 'const.sn.sound.' + buf + '.volume';\n        const savevol = this.getVol(hArg, NaN);\n        this.val.setVal_Nochk('save', bvn, savevol);\n        const vol = savevol * Number(this.val.getVal('sys:' + bvn, 1));\n        const stop = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'stop', (hArg.volume == 0));\n        if (stop) {\n            this.delLoopPlay(buf);\n            this.val.setVal_Nochk('save', 'const.sn.sound.' + buf + '.fn', '');\n        }\n        this.val.flush();\n        if (CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN) == 0) {\n            oSb.snd.volume(vol);\n            if (stop) {\n                if (buf == 'BGM')\n                    this.stopbgm(hArg);\n                else\n                    this.stopse(hArg);\n            }\n            return false;\n        }\n        const ease = CmnTween_1.CmnTween.ease(hArg.ease);\n        const repeat = CmnLib_1.CmnLib.argChk_Num(hArg, 'repeat', 1);\n        oSb.twFade = new TWEEN.default.Tween({ v: oSb.snd.volume() })\n            .to({ v: vol }, CmnLib_1.CmnLib.argChk_Num(hArg, 'time', NaN))\n            .delay(CmnLib_1.CmnLib.argChk_Num(hArg, 'delay', 0))\n            .easing(ease)\n            .repeat(repeat == 0 ? Infinity : (repeat - 1))\n            .yoyo(CmnLib_1.CmnLib.argChk_Boolean(hArg, 'yoyo', false))\n            .onUpdate((o) => { if (oSb.playing())\n            oSb.snd.volume(o.v); })\n            .onComplete(() => {\n            const oSb = this.hSndBuf[buf];\n            if (!oSb || !oSb.twFade)\n                return;\n            delete oSb.twFade;\n            if (stop) {\n                if (buf == 'BGM')\n                    this.stopbgm(hArg);\n                else\n                    this.stopse(hArg);\n            }\n            if (oSb.resumeFade) {\n                this.evtMng.popLocalEvts();\n                this.main.resume();\n            }\n            if (oSb.onCompleteFade)\n                oSb.onCompleteFade();\n        });\n        oSb.twFade.start();\n        return false;\n    }\n    playbgm(hArg) {\n        hArg.buf = 'BGM';\n        hArg.canskip = false;\n        CmnLib_1.CmnLib.argChk_Boolean(hArg, 'loop', true);\n        return this.playse(hArg);\n    }\n    playse(hArg) {\n        var _a;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        this.stopse({ buf: buf });\n        const fn = hArg.fn;\n        if (!fn)\n            throw '[playse] fnは必須です(buf=' + buf + ')';\n        if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true)\n            && this.evtMng.isSkipKeyDown())\n            return false;\n        const loop = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'loop', false);\n        this.addLoopPlay(buf, loop);\n        const nm = 'const.sn.sound.' + buf + '.';\n        this.val.setVal_Nochk('save', nm + 'fn', fn);\n        const savevol = this.getVol(hArg, 1);\n        this.val.setVal_Nochk('save', nm + 'volume', savevol);\n        const vol = savevol * Number(this.val.getVal('sys:' + nm + 'volume', 1));\n        const ret_ms = CmnLib_1.CmnLib.argChk_Num(hArg, 'ret_ms', 0);\n        this.val.setVal_Nochk('save', nm + 'ret_ms', ret_ms);\n        const end_ms = CmnLib_1.CmnLib.argChk_Num(hArg, 'end_ms', 0);\n        this.val.setVal_Nochk('save', nm + 'end_ms', end_ms);\n        this.val.flush();\n        const o = {\n            src: this.cfg.searchPath(fn, Config_1.Config.EXT_SOUND),\n            autoplay: true,\n            loop: loop,\n            volume: vol,\n        };\n        if (!loop)\n            o.onend = () => {\n                const oSb = this.hSndBuf[buf];\n                if (!oSb)\n                    return;\n                oSb.onend();\n            };\n        const join = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'join', true);\n        if (join)\n            o.onload = () => this.main.resume();\n        const snd = new howler_1.Howl(o);\n        this.hSndBuf[buf] = {\n            snd: snd,\n            loop: loop,\n            ret_ms: ret_ms,\n            end_ms: end_ms,\n            resume: false,\n            playing: CmnLib_1.CmnLib.isFirefox\n                ? () => true\n                : () => snd.playing(),\n            onend: () => {\n                const oSb = this.hSndBuf[buf];\n                if (!oSb)\n                    return;\n                if (CmnLib_1.CmnLib.isFirefox)\n                    oSb.playing = () => false;\n                this.stopfadese(hArg);\n                if (oSb.resume) {\n                    this.evtMng.popLocalEvts();\n                    this.main.resume();\n                }\n            },\n        };\n        this.initVol();\n        return join;\n    }\n    stop_allse() {\n        for (const buf in this.hSndBuf)\n            this.stopse({ buf: buf });\n        this.hSndBuf = {};\n        return false;\n    }\n    stopbgm(hArg) { hArg.buf = 'BGM'; return this.stopse(hArg); }\n    stopse(hArg) {\n        var _a;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        this.stopfadese(hArg);\n        this.delLoopPlay(buf);\n        const oSb = this.hSndBuf[buf];\n        if (oSb)\n            oSb.snd.stop();\n        return false;\n    }\n    wb(hArg) { hArg.buf = 'BGM'; return this.wf(hArg); }\n    wf(hArg) {\n        var _a;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const oSb = this.hSndBuf[buf];\n        if (!oSb || !oSb.twFade)\n            return false;\n        if (!oSb.playing())\n            return false;\n        oSb.resumeFade = true;\n        this.evtMng.stdWait(() => { this.stopfadese(hArg); }, CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', true));\n        return true;\n    }\n    stopfadese(hArg) {\n        var _a;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const oSb = this.hSndBuf[buf];\n        if (!oSb || !oSb.twFade)\n            return false;\n        oSb.twFade.stop().end();\n        return false;\n    }\n    wl(hArg) { hArg.buf = 'BGM'; return this.ws(hArg); }\n    ws(hArg) {\n        var _a;\n        console.log(`fn:SoundMng.ts line:279 `);\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const oSb = this.hSndBuf[buf];\n        console.log(`fn:SoundMng.ts line:282 A:${!oSb} B:${!oSb.playing()} C:${oSb.loop}`);\n        if (!oSb || !oSb.playing() || oSb.loop)\n            return false;\n        console.log(`fn:SoundMng.ts line:283 `);\n        oSb.resume = true;\n        this.evtMng.stdWait(() => {\n            console.log(`fn:SoundMng.ts line:286 FIN`);\n            this.stopse(hArg);\n            const oSb = this.hSndBuf[buf];\n            if (!oSb || !oSb.playing() || oSb.loop)\n                return;\n            oSb.onend();\n        }, CmnLib_1.CmnLib.argChk_Boolean(hArg, 'canskip', false));\n        console.log(`fn:SoundMng.ts line:296 `);\n        return true;\n    }\n    xchgbuf(hArg) {\n        var _a, _b;\n        const buf = (_a = hArg.buf, (_a !== null && _a !== void 0 ? _a : 'SE'));\n        const buf2 = (_b = hArg.buf2, (_b !== null && _b !== void 0 ? _b : 'SE'));\n        [this.hSndBuf[buf], this.hSndBuf[buf2]] = [this.hSndBuf[buf2], this.hSndBuf[buf]];\n        return false;\n    }\n    playLoopFromSaveObj() {\n        const loopPlaying = String(this.val.getVal('save:const.sn.loopPlaying', '{}'));\n        this.val.flush();\n        if (loopPlaying == '{}') {\n            this.stop_allse();\n            return;\n        }\n        const aFnc = [];\n        const hBuf = JSON.parse(loopPlaying);\n        for (const buf in hBuf) {\n            const nm = 'save:const.sn.sound.' + buf + '.';\n            const hArg = {\n                fn: String(this.val.getVal(nm + 'fn')),\n                buf: buf,\n                join: false,\n                loop: true,\n                volume: Number(this.val.getVal(nm + 'volume')),\n                ret_ms: Number(this.val.getVal(nm + 'ret_ms')),\n                end_ms: Number(this.val.getVal(nm + 'end_ms')),\n            };\n            aFnc.push(() => {\n                if (hArg.buf == 'BGM')\n                    this.playbgm(hArg);\n                else\n                    this.playse(hArg);\n            });\n        }\n        this.stop_allse();\n        aFnc.forEach(f => f());\n    }\n    addLoopPlay(buf, is_loop) {\n        if (!is_loop) {\n            this.delLoopPlay(buf);\n            return;\n        }\n        const hBuf = JSON.parse(String(this.val.getVal('save:const.sn.loopPlaying', '{}')));\n        hBuf[buf] = 0;\n        this.val.setVal_Nochk('save', 'const.sn.loopPlaying', JSON.stringify(hBuf));\n        this.val.flush();\n    }\n    delLoopPlay(buf) {\n        const hBuf = JSON.parse(String(this.val.getVal('save:const.sn.loopPlaying', '{}')));\n        delete hBuf[buf];\n        this.val.setVal_Nochk('save', 'const.sn.loopPlaying', JSON.stringify(hBuf));\n        this.val.flush();\n    }\n}\nexports.SoundMng = SoundMng;\n//# sourceMappingURL=SoundMng.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/SoundMng.js?")},"../npm_core/core/lib/sn/SysBase.js":
/*!******************************************!*\
  !*** ../npm_core/core/lib/sn/SysBase.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SysBase {\n    constructor(hPlg = {}, arg) {\n        this.hPlg = hPlg;\n        this.arg = arg;\n        this.hFactoryCls = {};\n        this.fetch = (url) => fetch(url);\n        this.resolution = 1;\n        this.reso4frame = 1;\n        this.data = { sys: {}, mark: {}, kidoku: {} };\n        this.close = () => false;\n        this.navigate_to = () => false;\n        this.title = () => false;\n        this.tgl_full_scr = () => false;\n        this.update_check = () => false;\n        this.window = () => false;\n        this.pre = (_ext, data) => data;\n        this.enc = (data) => data;\n        this.stk = () => '';\n        this.isApp = () => false;\n        this.$path_desktop = '';\n        this.$path_userdata = '';\n        this.existsSync = (_path) => true;\n        this.writeFile = (_file, _data, _callback) => { };\n        this.savePic = (_fn, _data_url) => { };\n        this.appendFile = (_path, _data, _callback) => { };\n        this.ofsLeft4frm = 0;\n        this.ofsTop4frm = 0;\n        const fncPre = hPlg['snsys_pre'];\n        if (fncPre)\n            fncPre.init({\n                addTag: () => { },\n                addLayCls: () => { },\n                searchPath: () => '',\n                getVal: () => { return {}; },\n                resume: () => { },\n                render: () => { },\n                setPre: fnc => this.pre = fnc,\n                setEnc: fnc => this.enc = fnc,\n                getStK: fnc => this.stk = fnc,\n            });\n    }\n    get cur() { return this.arg.cur; }\n    get crypt() { return this.arg.crypt; }\n    get crypt_() { return this.arg.crypt ? '_' : ''; }\n    loadPathAndVal(_hPathFn2Exts, _fncLoaded, _cfg) { }\n    initVal(_data, _hTmp, _comp) { }\n    flush() { }\n    init(cfg, hTag, appPixi, val, main) {\n        this.val = val;\n        this.appPixi = appPixi;\n        this.val.setSys(this);\n        this.hFactoryCls = {};\n        for (const nm in this.hPlg) {\n            this.hPlg[nm].init({\n                addTag: (name, tag_fnc) => {\n                    if (hTag[name])\n                        throw `すでに定義済みのタグ[${name}]です`;\n                    hTag[name] = tag_fnc;\n                },\n                addLayCls: (cls, fnc) => {\n                    if (this.hFactoryCls[cls])\n                        throw `すでに定義済みのレイヤcls【${cls}】です`;\n                    this.hFactoryCls[cls] = fnc;\n                },\n                searchPath: (fn, extptn = '') => cfg.searchPath(fn, extptn),\n                getVal: val.getVal,\n                resume: () => main.resume(),\n                render: (dsp, renTx, clear = false) => this.appPixi.renderer.render(dsp, renTx, clear),\n                setPre: fnc => this.pre = fnc,\n                setEnc: fnc => this.enc = fnc,\n                getStK: fnc => this.stk = fnc,\n            });\n        }\n        hTag.close = o => this.close(o);\n        hTag.navigate_to = o => this.navigate_to(o);\n        hTag.title = o => this.title(o);\n        hTag.toggle_full_screen = o => this.tgl_full_scr(o);\n        hTag.update_check = o => this.update_check(o);\n        hTag.window = o => this.window(o);\n        val.setVal_Nochk('tmp', 'const.sn.isApp', this.isApp());\n    }\n    get path_desktop() { return this.$path_desktop; }\n    get path_userdata() { return this.$path_userdata; }\n    resizeFrames() {\n        const cr = this.appPixi.view.getBoundingClientRect();\n        Array.prototype.slice.call(document.getElementsByTagName('iframe'))\n            .forEach((it) => {\n            const frmnm = `const.sn.frm.${it.id}`;\n            it.style.left = this.ofsLeft4frm + cr.left\n                + Number(this.val.getVal(`tmp:${frmnm}.x`)) * this.reso4frame\n                + 'px';\n            it.style.top = this.ofsTop4frm + cr.top\n                + Number(this.val.getVal(`tmp:${frmnm}.y`)) * this.reso4frame\n                + 'px';\n            it.width = String(Number(this.val.getVal(`tmp:${frmnm}.width`))\n                * this.reso4frame);\n            it.height = String(Number(this.val.getVal(`tmp:${frmnm}.height`))\n                * this.reso4frame);\n        });\n    }\n}\nexports.SysBase = SysBase;\n//# sourceMappingURL=SysBase.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/SysBase.js?")},"../npm_core/core/lib/sn/SysWeb.js":
/*!*****************************************!*\
  !*** ../npm_core/core/lib/sn/SysWeb.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SysBase_1 = __webpack_require__(/*! ./SysBase */ \"../npm_core/core/lib/sn/SysBase.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Main_1 = __webpack_require__(/*! ./Main */ \"../npm_core/core/lib/sn/Main.js\");\nconst strLocal = __webpack_require__(/*! store */ \"../npm_core/node_modules/store/dist/store.legacy.js\");\nclass SysWeb extends SysBase_1.SysBase {\n    constructor(hPlg = {}, arg = { cur: 'prj/', crypt: false, dip: '' }) {\n        super(hPlg, arg);\n        this.def_prj = 'prj';\n        this.run = async (prj) => {\n            if (this.main) {\n                const ms_late = 10;\n                this.main.destroy(ms_late);\n                await new Promise(r => setTimeout(r, ms_late));\n            }\n            this.now_prj = prj || this.def_prj;\n            const idxEnd = this.arg.cur.lastIndexOf('/', this.arg.cur.length - 2) + 1;\n            const idxStart = this.arg.cur.lastIndexOf('/', idxEnd - 2) + 1;\n            this.arg.cur = location.href.slice(0, location.href.lastIndexOf('/') + 1)\n                + (idxEnd == 0 ? '' : this.arg.cur.slice(idxStart, idxEnd))\n                + this.now_prj + '/';\n            this.main = new Main_1.Main(this);\n        };\n        this.now_prj = ':';\n        this.ns = '';\n        this.flushSub = () => { };\n        this.navigate_to = hArg => {\n            const url = hArg.url;\n            if (!url)\n                throw '[navigate_to] urlは必須です';\n            window.open(url, '_blank');\n            return false;\n        };\n        this.title = hArg => {\n            const text = hArg.text;\n            if (!text)\n                throw '[title] textは必須です';\n            document.title = text;\n            for (const v of document.querySelectorAll('[data-title]'))\n                v.textContent = text;\n            return false;\n        };\n        this.isFullScr = () => ('mozFullScreen' in document)\n            ? document['mozFullScreen']\n            : document.fullscreen;\n        this.readFile = (path, callback) => {\n            try {\n                (async () => {\n                    const res = await fetch(path);\n                    if (!res.ok)\n                        throw Error(res.statusText);\n                    callback(null, new Buffer(await res.text()));\n                })();\n            }\n            catch (e) {\n                console.error('Error:', e);\n            }\n        };\n        this.savePic = (fn, data_url) => {\n            const anchor = document.createElement('a');\n            anchor.href = data_url;\n            anchor.download = fn;\n            const e = document.createEvent('MouseEvent');\n            e.initEvent('click');\n            anchor.dispatchEvent(e);\n            if (CmnLib_1.CmnLib.devtool)\n                console.log('画像ファイルをダウンロードします');\n        };\n        const idxCur = arg.cur.lastIndexOf('/', arg.cur.length - 2);\n        this.def_prj = arg.cur.slice(idxCur + 1, -1);\n        window.onload = () => {\n            var _a;\n            for (const v of document.querySelectorAll('[data-prj]')) {\n                v.addEventListener('click', () => {\n                    const elm = v.attributes.getNamedItem('data-prj');\n                    if (!elm)\n                        return;\n                    const prj = elm.value;\n                    if (this.now_prj != prj)\n                        this.run(prj);\n                });\n            }\n            for (const v of document.querySelectorAll('[data-reload]')) {\n                v.addEventListener('click', () => this.run(this.now_prj));\n            }\n            if (arg.dip)\n                CmnLib_1.CmnLib.hDip = JSON.parse(arg.dip);\n            const sp = new URLSearchParams(location.search);\n            const dip = sp.get('dip');\n            if (dip)\n                CmnLib_1.CmnLib.hDip = Object.assign(Object.assign({}, CmnLib_1.CmnLib.hDip), JSON.parse(dip));\n            if (!CmnLib_1.CmnLib.argChk_Boolean(CmnLib_1.CmnLib.hDip, 'oninit_run', true))\n                return;\n            this.run((_a = sp.get('cur'), (_a !== null && _a !== void 0 ? _a : '')));\n        };\n        if ('webkitFullscreenEnabled' in document)\n            this.tgl_full_scr = o => this.regEvt_FullScr(o, 'webkitRequestFullscreen', 'webkitCancelFullScreen', 'webkitFullscreenElement');\n        else if ('mozFullScreenEnabled' in document)\n            this.tgl_full_scr = o => this.regEvt_FullScr(o, 'mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement');\n        else if ('msFullscreenEnabled' in document)\n            this.tgl_full_scr = o => this.regEvt_FullScr(o, 'msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement');\n        else if (document['fullscreenEnabled'])\n            this.tgl_full_scr = o => this.regEvt_FullScr(o, 'requestFullscreen', 'exitFullscreen', 'fullscreenElement');\n    }\n    stop() {\n        if (!this.main)\n            return;\n        this.main.destroy();\n        this.main = null;\n    }\n    loadPathAndVal(hPathFn2Exts, fncLoaded, cfg) {\n        (async () => {\n            const fn = this.arg.cur + 'path.json' + this.crypt_;\n            const res = await fetch(fn);\n            if (!res.ok)\n                throw Error(res.statusText);\n            const mes = await res.text();\n            const json = JSON.parse(this.pre(fn, mes));\n            for (const nm in json) {\n                const h = hPathFn2Exts[nm] = json[nm];\n                for (const ext in h)\n                    if (ext != ':cnt')\n                        h[ext] = this.arg.cur + h[ext];\n            }\n            this.ns = cfg.getNs();\n            fncLoaded();\n        })();\n    }\n    initVal(data, hTmp, comp) {\n        this.flushSub = this.crypt\n            ? () => {\n                strLocal.set(this.ns + 'sys_', String(this.enc(JSON.stringify(this.data.sys))));\n                strLocal.set(this.ns + 'mark_', String(this.enc(JSON.stringify(this.data.mark))));\n                strLocal.set(this.ns + 'kidoku_', String(this.enc(JSON.stringify(this.data.kidoku))));\n            }\n            : () => {\n                strLocal.set(this.ns + 'sys', this.data.sys);\n                strLocal.set(this.ns + 'mark', this.data.mark);\n                strLocal.set(this.ns + 'kidoku', this.data.kidoku);\n            };\n        if (strLocal.get(this.ns + 'sys' + this.crypt_) == undefined) {\n            hTmp['const.sn.isFirstBoot'] = true;\n            this.data.sys = data['sys'];\n            this.data.mark = data['mark'];\n            this.data.kidoku = data['kidoku'];\n            this.flush();\n        }\n        else {\n            hTmp['const.sn.isFirstBoot'] = false;\n            if (this.crypt) {\n                this.data.sys = JSON.parse(this.pre('_', strLocal.get(this.ns + 'sys_')));\n                this.data.mark = JSON.parse(this.pre('_', strLocal.get(this.ns + 'mark_')));\n                this.data.kidoku = JSON.parse(this.pre('_', strLocal.get(this.ns + 'kidoku_')));\n            }\n            else {\n                this.data.sys = strLocal.get(this.ns + 'sys');\n                this.data.mark = strLocal.get(this.ns + 'mark');\n                this.data.kidoku = strLocal.get(this.ns + 'kidoku');\n            }\n        }\n        comp(this.data);\n        const hn = document.location.hostname;\n        hTmp['const.sn.isDebugger'] = (hn == 'localhost' || hn == '127.0.0.1');\n        this.val.defTmp('const.sn.displayState', () => this.isFullScr());\n    }\n    flush() { this.flushSub(); }\n    regEvt_FullScr(hArg, go_fnc_name, exit_fnc_name, get_fnc_name) {\n        const elm = document.body;\n        const doc = document;\n        if (!hArg.key) {\n            if (doc[get_fnc_name] != null)\n                doc[exit_fnc_name]();\n            else\n                elm[go_fnc_name]();\n            this.resizeFramesWork();\n            return false;\n        }\n        const key = hArg.key.toLowerCase();\n        doc.addEventListener('keydown', (e) => {\n            const key2 = (e.altKey ? (e.key == 'Alt' ? '' : 'alt+') : '')\n                + (e.ctrlKey ? (e.key == 'Control' ? '' : 'ctrl+') : '')\n                + (e.shiftKey ? (e.key == 'Shift' ? '' : 'shift+') : '')\n                + e.key.toLowerCase();\n            if (key2 != key)\n                return;\n            e.stopPropagation();\n            if (doc[get_fnc_name] != null)\n                doc[exit_fnc_name]();\n            else\n                elm[go_fnc_name]();\n            this.resizeFramesWork();\n        });\n        return false;\n    }\n    resizeFramesWork() {\n        const is_fs = this.isFullScr();\n        const ratioWidth = screen.width / CmnLib_1.CmnLib.stageW;\n        const ratioHeight = screen.height / CmnLib_1.CmnLib.stageH;\n        const ratio = (ratioWidth < ratioHeight) ? ratioWidth : ratioHeight;\n        this.reso4frame = is_fs ? 1 : ratio;\n        this.ofsLeft4frm = is_fs ? 0 : (screen.width - CmnLib_1.CmnLib.stageW * this.reso4frame * CmnLib_1.CmnLib.cvsScale) / 2;\n        this.ofsTop4frm = is_fs ? 0 : (screen.height - CmnLib_1.CmnLib.stageH * this.reso4frame * CmnLib_1.CmnLib.cvsScale) / 2;\n        this.resizeFrames();\n    }\n}\nexports.SysWeb = SysWeb;\n//# sourceMappingURL=SysWeb.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../sn_gallery/node_modules/node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/SysWeb.js?")},"../npm_core/core/lib/sn/TxtLayer.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/TxtLayer.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Layer_1 = __webpack_require__(/*! ./Layer */ \"../npm_core/core/lib/sn/Layer.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst TxtStage_1 = __webpack_require__(/*! ./TxtStage */ \"../npm_core/core/lib/sn/TxtStage.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../npm_core/core/lib/sn/Config.js\");\nconst RubySpliter_1 = __webpack_require__(/*! ./RubySpliter */ \"../npm_core/core/lib/sn/RubySpliter.js\");\nconst GrpLayer_1 = __webpack_require__(/*! ./GrpLayer */ \"../npm_core/core/lib/sn/GrpLayer.js\");\nconst Button_1 = __webpack_require__(/*! ./Button */ \"../npm_core/core/lib/sn/Button.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst LayerMng_1 = __webpack_require__(/*! ./LayerMng */ \"../npm_core/core/lib/sn/LayerMng.js\");\nclass TxtLayer extends Layer_1.Layer {\n    constructor() {\n        super();\n        this.infTL = {\n            fontsize: 24,\n            $width: 0,\n            $height: 0,\n            pad_left: 0,\n            pad_right: 0,\n            pad_top: 0,\n            pad_bottom: 0,\n        };\n        this.b_color = 0x000000;\n        this.b_alpha = 0;\n        this.b_alpha_isfixed = false;\n        this.b_do = null;\n        this.b_pic = '';\n        this.cntInsidePadding = new pixi_js_1.Container;\n        this.txs = new TxtStage_1.TxtStage(this.infTL, this.cntInsidePadding, this.cnt);\n        this.rbSpl = new RubySpliter_1.RubySpliter;\n        this.cntBtn = new pixi_js_1.Container;\n        this.ch_in_style = '';\n        this.ch_in_join = true;\n        this.ch_out_style = '';\n        this.ffs = '';\n        this.fncFFSStyle = (_ch) => '';\n        this.fncFFSSpan = (ch) => ch;\n        this.strNoFFS = '';\n        this.regNoFFS = new RegExp('[　]');\n        this.isCur = false;\n        this.ruby_pd = () => '';\n        this.r_align = '';\n        this.needGoTxt = false;\n        this.putCh = (ch, ruby) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            if (TxtLayer.cfg.oCfg.debug.putCh)\n                console.log(`🖊 文字表示 text:\\`${ch}\\` ruby:\\`${ruby}\\` name:\\`${this.name}\\``);\n            const a_ruby = ruby.split('｜');\n            let add_htm = '';\n            const isSkip = TxtLayer.evtMng.isSkipKeyDown();\n            switch (a_ruby.length) {\n                case 1:\n                    this.needGoTxt = true;\n                    if (ch == '\\n') {\n                        if (this.aSpan_bk) {\n                            add_htm = this.aSpan_bk.slice(-1)[0];\n                            this.autoCloseSpan();\n                            this.aSpan.push(TxtLayer.rec('<br/>'));\n                            this.aSpan.push(add_htm);\n                            this.aSpan_bk = this.aSpan;\n                            this.aSpan = [];\n                            return;\n                        }\n                        if (this.firstCh) {\n                            this.firstCh = false;\n                            add_htm = '<ruby>　<rt>　</rt></ruby><br/>';\n                        }\n                        else {\n                            add_htm = '<br/>';\n                        }\n                        break;\n                    }\n                    if (this.firstCh) {\n                        this.firstCh = false;\n                        if (ruby == '')\n                            ruby = '　';\n                    }\n                    add_htm = this.tagCh_sub(ch, ruby, isSkip, this.r_align);\n                    break;\n                case 2:\n                    switch (a_ruby[0]) {\n                        case 'start':\n                        case 'left':\n                        case 'center':\n                        case 'right':\n                        case 'justify':\n                        case '121':\n                        case 'even':\n                        case '1ruby':\n                            this.firstCh = false;\n                            this.needGoTxt = true;\n                            add_htm = this.tagCh_sub(ch, a_ruby[1], isSkip, a_ruby[0]);\n                            break;\n                        case 'gotxt':\n                            {\n                                this.autoCloseSpan();\n                                if (this.isCur)\n                                    TxtLayer.recText(this.aSpan.join('')\n                                        .replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, '')\n                                        .replace(/style='(anim\\S+ \\S+?;\\s*)+/g, `style='`)\n                                        .replace(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, '')\n                                        .replace(/class='sn_ch .+?'/g, `class='sn_ch'`)\n                                        .replace(/class='offrec'/g, `style='display: none;'`)\n                                        .replace(/`/g, '\\\\`'));\n                                if (!this.needGoTxt)\n                                    return;\n                                this.txs.goTxt([...this.aSpan, this.tagCh_sub('　', '', false, '')]);\n                                this.needGoTxt = false;\n                                this.cumDelay = 0;\n                                return;\n                            }\n                        case 'add':\n                            {\n                                const o = JSON.parse(a_ruby[1]);\n                                o.style = (_a = o.style, (_a !== null && _a !== void 0 ? _a : ''));\n                                this.beginSpan(o);\n                                if (this.aSpan_bk)\n                                    this.autoCloseSpan();\n                                else {\n                                    if (isSkip)\n                                        this.cumDelay = 0;\n                                    const wait = (_b = o.wait, (_b !== null && _b !== void 0 ? _b : -1));\n                                    const sn_ch = (wait == 0)\n                                        ? ''\n                                        : ` sn_ch_in_${this.ch_in_style}`;\n                                    const ad = (wait < 0)\n                                        ? ''\n                                        : ` animation-duration: ${wait}ms;`;\n                                    this.aSpan.push(`<span class='sn_ch${sn_ch}' style='animation-delay: ${this.cumDelay}ms;${ad} ${o.style}' data-add='${JSON.stringify(o)}'>`);\n                                }\n                                this.aSpan_bk = this.aSpan;\n                                this.aSpan = [];\n                            }\n                            return;\n                        case 'add_close':\n                            this.autoCloseSpan();\n                            return;\n                        case 'grp':\n                            this.needGoTxt = true;\n                            {\n                                if (isSkip)\n                                    this.cumDelay = 0;\n                                const arg = (a_ruby[1] ? a_ruby[1].slice(0, -1) + ',' : `{`) + `\"delay\": ${this.cumDelay}}`;\n                                if (this.ch_in_join)\n                                    this.cumDelay += (TxtLayer.doAutoWc) ? 0 : LayerMng_1.LayerMng.msecChWait;\n                                const o = JSON.parse(arg);\n                                o.style = (_c = o.style, (_c !== null && _c !== void 0 ? _c : ''));\n                                if (!('id' in o))\n                                    o.id = this.aSpan.length;\n                                if (o.id == 'break') {\n                                    this.txs.dispBreak(o.pic);\n                                    return;\n                                }\n                                add_htm = `<span data-cmd='grp' data-id='${o.id}' data-arg='${arg}'`;\n                                const wait = (_d = o.wait, (_d !== null && _d !== void 0 ? _d : -1));\n                                const sn_ch = (wait == 0)\n                                    ? ''\n                                    : ` sn_ch_in_${this.ch_in_style}`;\n                                const ad = (wait < 0)\n                                    ? ''\n                                    : ` animation-duration: ${wait}ms;`;\n                                add_htm += ` class='sn_ch${sn_ch}' style='animation-delay: ${this.cumDelay}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>　</span>`;\n                                if (this.firstCh) {\n                                    this.firstCh = false;\n                                    add_htm = `<ruby>${add_htm}<rt>　</rt></ruby>`;\n                                }\n                                if (this.aSpan.slice(-1)[0] == add_htm)\n                                    return;\n                            }\n                            break;\n                        case 'del':\n                            const id_del = a_ruby[1];\n                            if (id_del != 'break')\n                                throw '文字レイヤdelコマンドは、現在id=breakのみサポートします';\n                            TxtStage_1.TxtStage.delBreak();\n                            return;\n                        case 'span':\n                            this.autoCloseSpan();\n                            this.needGoTxt = true;\n                            {\n                                const o = JSON.parse(a_ruby[1]);\n                                this.beginSpan(o);\n                                if (!o.style)\n                                    return;\n                                if (isSkip)\n                                    this.cumDelay = 0;\n                                const wait = (_e = o.wait, (_e !== null && _e !== void 0 ? _e : -1));\n                                const sn_ch = (wait == 0)\n                                    ? ''\n                                    : ` sn_ch_in_${this.ch_in_style}`;\n                                const ad = (wait < 0)\n                                    ? ''\n                                    : ` animation-duration: ${wait}ms;`;\n                                this.aSpan.push(`<span class='sn_ch${sn_ch}' style='animation-delay: ${this.cumDelay}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>`);\n                                this.aSpan_bk = this.aSpan;\n                                this.aSpan = [];\n                            }\n                            return;\n                        case 'link':\n                            this.autoCloseSpan();\n                            this.needGoTxt = true;\n                            {\n                                const o = JSON.parse(a_ruby[1]);\n                                o.style = (_f = o.style, (_f !== null && _f !== void 0 ? _f : ''));\n                                this.beginSpan(o);\n                                if (isSkip)\n                                    this.cumDelay = 0;\n                                const wait = (_g = o.wait, (_g !== null && _g !== void 0 ? _g : -1));\n                                const sn_ch = (wait == 0)\n                                    ? ''\n                                    : ` sn_ch_in_${this.ch_in_style}`;\n                                const ad = (wait < 0)\n                                    ? ''\n                                    : ` animation-duration: ${wait}ms;`;\n                                this.aSpan_link = ` data-cmd='link' data-arg='${a_ruby[1]}'`;\n                                this.aSpan.push(`<span${this.aSpan_link} class='sn_ch${sn_ch}' style='animation-delay: ${this.cumDelay}ms;${ad} ${o.style}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>`);\n                                this.aSpan_bk = this.aSpan;\n                                this.aSpan = [];\n                            }\n                            return;\n                        case 'endlink':\n                            this.needGoTxt = true;\n                            if (this.aSpan_bk) {\n                                const len = this.aSpan.length;\n                                for (let i = 0; i < len; ++i)\n                                    this.aSpan[i] = this.aSpan[i].replace(/ data-cmd='linkrsv'/, this.aSpan_link);\n                            }\n                            this.autoCloseSpan();\n                            return;\n                        default:\n                            this.needGoTxt = true;\n                            add_htm = this.tagCh_sub(ch, ruby, isSkip, this.r_align);\n                    }\n                    break;\n                case 3:\n                    this.firstCh = false;\n                    this.needGoTxt = true;\n                    switch (a_ruby[0]) {\n                        case 'tcy':\n                            {\n                                if (TxtLayer.val.doRecLog())\n                                    this.page_text += ch\n                                        + (ruby ? `《${ruby}》` : '');\n                                const tx = a_ruby[1];\n                                const id_tcy = (tx.length > 1)\n                                    ? (this.aSpan.length + 1)\n                                    : '';\n                                const rb = CmnLib_1.CmnLib.isSafari\n                                    ? a_ruby[2].replace(/[A-Za-z0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 65248))\n                                    : a_ruby[2];\n                                if (isSkip)\n                                    this.cumDelay = 0;\n                                const rs = this.mkStyle_r_align(tx, rb, this.r_align);\n                                add_htm = rb\n                                    ? (this.aSpan_bk\n                                        ? (`<ruby><span data-tcy='${id_tcy}' style='\n\t\t\t\t\t\t\t\ttext-combine-upright: all;\n\t\t\t\t\t\t\t\t-webkit-text-combine: horizontal;\n\t\t\t\t\t\t\t\t${this.fncFFSStyle(tx)}\n\t\t\t\t\t\t\t' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}' data-cmd='linkrsv'>${tx}</span>`\n                                            + `<rt${rs}>${rb}</rt></ruby>`)\n                                        : (`<span class='sn_ch sn_ch_in_${this.ch_in_style}' style='animation-delay: ${this.cumDelay}ms;'>`\n                                            + `<ruby><span data-tcy='${id_tcy}' style='\n\t\t\t\t\t\t\t\t\ttext-combine-upright: all;\n\t\t\t\t\t\t\t\t\t-webkit-text-combine: horizontal;\n\t\t\t\t\t\t\t\t\t${this.fncFFSStyle(tx)}\n\t\t\t\t\t\t\t\t' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>${tx}</span>`\n                                            + `<rt${rs}>${rb}</rt></ruby>`\n                                            + `</span>`))\n                                    : (this.aSpan_bk\n                                        ? (`<span data-tcy='${id_tcy}' style='\n\t\t\t\t\t\t\ttext-combine-upright: all;\n\t\t\t\t\t\t\t-webkit-text-combine: horizontal;\n\t\t\t\t\t\t\t${this.fncFFSStyle(tx)}\n\t\t\t\t\t\t' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}' data-cmd='linkrsv'>${tx}</span>`)\n                                        : `<span data-tcy='${id_tcy}' style='\n\t\t\t\t\t\t\ttext-combine-upright: all;\n\t\t\t\t\t\t\t-webkit-text-combine: horizontal;\n\t\t\t\t\t\t\tanimation-delay: ${this.cumDelay}ms;\n\t\t\t\t\t\t\theight: 1em;\n\t\t\t\t\t\t\t${this.fncFFSStyle(tx)}\n\t\t\t\t\t\t' class='sn_ch sn_ch_in_${this.ch_in_style}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>${tx}</span>`);\n                                if (this.ch_in_join)\n                                    this.cumDelay += (TxtLayer.doAutoWc)\n                                        ? (_h = TxtLayer.hAutoWc[ch.charAt(0)], (_h !== null && _h !== void 0 ? _h : 0)) : LayerMng_1.LayerMng.msecChWait;\n                            }\n                            break;\n                        default:\n                            throw `異常な値です putCh(text: ${ch}, ruby: ${ruby})`;\n                    }\n                    break;\n            }\n            this.aSpan.push(TxtLayer.rec(add_htm));\n        };\n        this.cumDelay = 0;\n        this.firstCh = true;\n        this.aSpan = [];\n        this.aSpan_bk = null;\n        this.aSpan_link = '';\n        this.hSpanBk = {\n            ch_in_style: '',\n            ch_out_style: '',\n            r_align: '',\n        };\n        this.click = () => {\n            if (!this.cnt.interactiveChildren || !this.cnt.visible)\n                return true;\n            return this.txs.skipChIn();\n        };\n        this.page_text = '';\n        this.record = () => Object.assign(super.record(), {\n            enabled: this.enabled,\n            r_align: this.r_align,\n            b_do: (this.b_do == null)\n                ? null\n                : (this.b_do instanceof pixi_js_1.Sprite ? 'Sprite' : 'Graphics'),\n            b_pic: this.b_pic,\n            b_color: this.b_color,\n            b_alpha: this.b_alpha,\n            b_alpha_isfixed: this.b_alpha_isfixed,\n            txs: this.txs.record(),\n            ffs: this.ffs,\n            strNoFFS: this.strNoFFS,\n            btns: this.cntBtn.children.map(btn => btn.name),\n        });\n        const padding = 16 * CmnLib_1.CmnLib.retinaRate;\n        this.cnt.addChild(this.cntInsidePadding);\n        this.cntInsidePadding.name = 'cntInsidePadding';\n        this.cntInsidePadding.position.set(padding, padding);\n        this.rbSpl.init(this.putCh);\n        this.cnt.addChild(this.cntBtn);\n        this.cntBtn.name = 'cntBtn';\n        this.lay({ style: `width: ${CmnLib_1.CmnLib.stageW}px; height: ${CmnLib_1.CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${padding}px;`, in_style: 'default', out_style: 'default', back_clear: 'true' });\n    }\n    static init(cfg, hTag, val, recText) {\n        TxtLayer.cfg = cfg;\n        TxtStage_1.TxtStage.init(cfg);\n        TxtLayer.val = val;\n        TxtLayer.recText = recText;\n        val.setDoRecProc(TxtLayer.chgDoRec);\n        hTag.autowc = o => TxtLayer.autowc(o);\n        const o = { enabled: 'false', text: '', time: '' };\n        hTag.autowc(o);\n        hTag.ch_in_style = o => TxtLayer.ch_in_style(o);\n        hTag.ch_out_style = o => TxtLayer.ch_out_style(o);\n        TxtStage_1.TxtStage.initChStyle();\n        const he = document.getElementsByTagName('head')[0];\n        const len = he.children.length;\n        for (let i = len - 1; i >= 0; --i) {\n            const v = he.children[i];\n            if (!(v instanceof HTMLStyleElement))\n                continue;\n            if (v.innerText.slice(0, 14) != TxtLayer.css_key4del)\n                continue;\n            he.removeChild(v);\n        }\n        let font = '';\n        for (const o of cfg.matchPath('.+', Config_1.Config.EXT_FONT)) {\n            for (const key in o)\n                font += `\n@font-face {\n\tfont-family: '${CmnLib_1.CmnLib.getFn(o[key])}';\n\tsrc: url('${o[key]}');\n}\n`;\n        }\n        font += `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`;\n        TxtLayer.addStyle(font);\n        TxtLayer.ch_in_style({\n            name: 'default',\n            wait: 500,\n            alpha: 0,\n            x: '=0.3',\n            y: '=0',\n            scale_x: 1,\n            scale_y: 1,\n            rotate: 0,\n            join: true,\n            ease: 'ease-out',\n        });\n        TxtLayer.ch_out_style({\n            name: 'default',\n            wait: 0,\n            alpha: 0,\n            x: '=0',\n            y: '=0',\n            scale_x: 1,\n            scale_y: 1,\n            rotate: 0,\n            join: false,\n            ease: 'ease-out',\n        });\n    }\n    static addStyle(style) {\n        const gs = document.createElement('style');\n        gs.type = 'text/css';\n        gs.innerHTML = TxtLayer.css_key4del + style;\n        document.getElementsByTagName('head')[0].appendChild(gs);\n    }\n    static ch_in_style(hArg) {\n        const o = TxtStage_1.TxtStage.ch_in_style(hArg);\n        const x = (o.x.charAt(0) == '=') ? `${o.nx * 100}%` : `${o.nx}px`;\n        const y = (o.y.charAt(0) == '=') ? `${o.ny * 100}%` : `${o.ny}px`;\n        const name = hArg.name;\n        TxtLayer.addStyle(`\n.sn_ch_in_${name} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${name} {\n\topacity: ${o.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${name} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes sn_ch_in_${name} {\n\tfrom {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x}, ${y});}\n\tto {opacity: 1; transform: none;}\n}\n`);\n        return false;\n    }\n    static ch_out_style(hArg) {\n        const o = TxtStage_1.TxtStage.ch_out_style(hArg);\n        const x = (o.x.charAt(0) == '=') ? `${o.nx * 100}%` : `${o.nx}px`;\n        const y = (o.y.charAt(0) == '=') ? `${o.ny * 100}%` : `${o.ny}px`;\n        const name = hArg.name;\n        TxtLayer.addStyle(`\n.go_ch_out_${name} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${name} ${o.wait}ms ${o.ease} 0s both;\n}\n@keyframes go_ch_out_${name} {\n\tto {\n\t\topacity: ${o.alpha};\n\t\ttransform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x}, ${y});\n\t}\n`);\n        return false;\n    }\n    static setEvtMng(main, evtMng) {\n        TxtLayer.main = main;\n        TxtLayer.evtMng = evtMng;\n        TxtStage_1.TxtStage.setEvtMng(evtMng);\n    }\n    static autowc(hArg) {\n        TxtLayer.doAutoWc = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'enabled', TxtLayer.doAutoWc);\n        TxtLayer.val.setVal_Nochk('save', 'const.sn.autowc.enabled', TxtLayer.doAutoWc);\n        const ch = hArg.text;\n        if (('text' in hArg) != ('time' in hArg))\n            throw '[autowc] textとtimeは同時指定必須です';\n        TxtLayer.val.setVal_Nochk('save', 'const.sn.autowc.text', ch);\n        if (!ch) {\n            TxtLayer.val.setVal_Nochk('save', 'const.sn.autowc.time', '');\n            return false;\n        }\n        const len = ch.length;\n        if (TxtLayer.doAutoWc && len == 0)\n            throw '[autowc] enabled == false かつ text == \"\" は許されません';\n        const a = String(hArg.time).split(',');\n        if (a.length != len)\n            throw '[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい';\n        TxtLayer.hAutoWc = Object.create(null);\n        a.forEach((v, i) => TxtLayer.hAutoWc[ch[i]] = CmnLib_1.uint(v));\n        TxtLayer.val.setVal_Nochk('save', 'const.sn.autowc.time', hArg.time);\n        return false;\n    }\n    destroy() {\n        if (this.b_do) {\n            this.cnt.removeChild(this.b_do).destroy();\n            this.b_do = null;\n        }\n        this.clearText();\n        this.txs.destroy();\n    }\n    set name(nm) { if (this.txs)\n        this.txs.name = nm; }\n    get name() { return this.txs ? this.txs.name : ''; }\n    cvsResize() { this.txs.cvsResize(); }\n    lay(hArg) {\n        var _a;\n        super.lay(hArg);\n        Layer_1.Layer.setXY(this.cnt, hArg, this.cnt);\n        this.rbSpl.setting(hArg);\n        this.setFfs(hArg);\n        this.txs.lay(hArg);\n        if ('r_align' in hArg)\n            this.r_align = (_a = hArg.r_align, (_a !== null && _a !== void 0 ? _a : ''));\n        this.ruby_pd = CmnLib_1.CmnLib.isSafari\n            ? this.txs.tategaki\n                ? (v, l) => `text-align: start; height: ${l}em; padding-top: ${v}; padding-bottom: ${v};`\n                : (v, l) => `text-align: start; width: ${l}em; padding-left: ${v}; padding-right: ${v};`\n            : this.txs.tategaki\n                ? v => `text-align: justify; text-align-last: justify; padding-top: ${v}; padding-bottom: ${v};`\n                : v => `text-align: justify; text-align-last: justify; padding-left: ${v}; padding-right: ${v};`;\n        if (CmnLib_1.CmnLib.isFirefox)\n            this.mkStyle_r_align = this.mkStyle_r_align4ff;\n        if ('alpha' in hArg)\n            this.cntBtn.children.forEach(e => e.alpha = this.cnt.alpha);\n        this.set_ch_in(hArg);\n        this.set_ch_out(hArg);\n        return this.drawBack(hArg);\n    }\n    set_ch_in(hArg) {\n        const ins = hArg.in_style;\n        if (!ins)\n            return;\n        const cis = TxtStage_1.TxtStage.getChInStyle(ins);\n        if (!cis)\n            throw `存在しないin_style【${ins}】です`;\n        this.ch_in_style = ins;\n        this.ch_in_join = cis.join;\n    }\n    set_ch_out(hArg) {\n        const outs = hArg.out_style;\n        if (!outs)\n            return;\n        const cos = TxtStage_1.TxtStage.getChOutStyle(outs);\n        if (!cos)\n            throw `存在しないout_style【${outs}】です`;\n        this.ch_out_style = outs;\n    }\n    drawBack(hArg) {\n        if ('back_clear' in hArg) {\n            if (CmnLib_1.CmnLib.argChk_Boolean(hArg, 'back_clear', false)) {\n                this.b_color = 0x000000;\n                this.b_alpha = 0;\n                this.b_alpha_isfixed = false;\n                this.b_pic = '';\n            }\n            return false;\n        }\n        this.b_alpha = CmnLib_1.CmnLib.argChk_Num(hArg, 'b_alpha', this.b_alpha);\n        this.b_alpha_isfixed = CmnLib_1.CmnLib.argChk_Boolean(hArg, 'b_alpha_isfixed', this.b_alpha_isfixed);\n        const alpha = (this.b_alpha_isfixed\n            ? 1\n            : Number(TxtLayer.val.getVal('sys:TextLayer.Back.Alpha'))) * this.b_alpha;\n        if (hArg.b_pic) {\n            if (this.b_pic != hArg.b_pic) {\n                this.b_pic = hArg.b_pic;\n                if (this.b_do) {\n                    this.cnt.removeChild(this.b_do);\n                    this.b_do.destroy();\n                }\n                return GrpLayer_1.GrpLayer.csv2Sprites(this.b_pic, this.cnt, sp => {\n                    this.b_do = sp;\n                    sp.name = 'back(pic)';\n                    sp.visible = (alpha > 0);\n                    sp.alpha = alpha;\n                    this.txs.setSize(sp.width, sp.height);\n                    this.cnt.setChildIndex(sp, 0);\n                    TxtLayer.main.resume();\n                });\n            }\n        }\n        else if ('b_color' in hArg) {\n            this.b_color = parseInt(hArg.b_color || '0');\n            if (this.b_do) {\n                this.cnt.removeChild(this.b_do);\n                this.b_do.destroy();\n            }\n            this.b_pic = '';\n            const grp = this.b_do = new pixi_js_1.Graphics;\n            grp.name = 'back(color)';\n            grp.beginFill(this.b_color);\n            grp.lineStyle(undefined);\n            grp.drawRect(0, 0, this.infTL.$width, this.infTL.$height);\n            grp.endFill();\n            this.cnt.addChildAt(grp, 0);\n        }\n        if (this.b_do) {\n            this.b_do.visible = (alpha > 0);\n            this.b_do.alpha = alpha;\n        }\n        return false;\n    }\n    chgBackAlpha(g_alpha) {\n        const alpha = this.b_alpha_isfixed\n            ? this.b_alpha\n            : g_alpha * this.b_alpha;\n        if (this.b_do instanceof pixi_js_1.Graphics) {\n            if (this.b_do) {\n                this.cnt.removeChild(this.b_do);\n                this.b_do.destroy();\n            }\n            const grp = this.b_do = new pixi_js_1.Graphics;\n            grp.name = 'back(color)';\n            grp.beginFill(this.b_color);\n            grp.lineStyle(undefined);\n            grp.drawRect(0, 0, this.infTL.$width, this.infTL.$height);\n            grp.endFill();\n            this.cnt.addChildAt(grp, 0);\n        }\n        if (this.b_do) {\n            this.b_do.visible = (alpha > 0);\n            this.b_do.alpha = alpha;\n        }\n    }\n    setFfs(hArg) {\n        var _a, _b;\n        if ('noffs' in hArg) {\n            this.strNoFFS = (_a = hArg.noffs, (_a !== null && _a !== void 0 ? _a : ''));\n            this.regNoFFS = new RegExp(`[　${this.strNoFFS}]`);\n        }\n        if (!('ffs' in hArg))\n            return;\n        this.ffs = (_b = hArg.ffs, (_b !== null && _b !== void 0 ? _b : ''));\n        if (this.ffs == '') {\n            this.fncFFSStyle = () => '';\n            this.fncFFSSpan = ch => ch;\n        }\n        else {\n            this.fncFFSStyle = ch => this.regNoFFS.test(ch)\n                ? ''\n                : ` font-feature-settings: ${this.ffs};`;\n            this.fncFFSSpan = ch => this.regNoFFS.test(ch)\n                ? ch\n                : `<span style='font-feature-settings: ${this.ffs};'>${ch}</span>`;\n        }\n    }\n    static chgDoRec(doRec) {\n        TxtLayer.rec = doRec\n            ? (tx) => tx\n            : (tx) => `<span class='offrec'>${tx}</span>`;\n    }\n    mkStyle_r_align(ch, rb, r_align) {\n        if (!r_align)\n            return '';\n        const len = ch.length * 2;\n        if (len - rb.length < 0)\n            return ` style='text-align: ${r_align};'`;\n        let st = '';\n        switch (r_align) {\n            case 'justify':\n                st = this.ruby_pd('0', len);\n                break;\n            case '121':\n                st = this.ruby_pd(`calc(${(len - rb.length) / (rb.length * 2)}em)`, len);\n                break;\n            case 'even':\n                st = this.ruby_pd(`calc(${(len - rb.length) / (rb.length + 1)}em)`, len);\n                break;\n            case '1ruby':\n                st = this.ruby_pd('1em', len);\n                break;\n            default:\n                st = `text-align: ${r_align};`;\n        }\n        return ` style='${st}'`;\n    }\n    ;\n    mkStyle_r_align4ff(ch, rb, r_align) {\n        if (!r_align)\n            return '';\n        const len = ch.length * 2;\n        if (len - rb.length < 0)\n            return ` style='text-align: ${r_align};'`;\n        let st = '';\n        switch (r_align) {\n            case 'left':\n                st = `ruby-align: start;`;\n                break;\n            case 'center':\n                st = `ruby-align: center;`;\n                break;\n            case 'right':\n                st = `ruby-align: start;`;\n                break;\n            case 'justify':\n                st = `ruby-align: space-between;`;\n                break;\n            case '121':\n                st = `ruby-align: space-around;`;\n                break;\n            case 'even':\n                const ev = (len - rb.length) / (rb.length + 1);\n                st = `ruby-align: space-between; ` +\n                    (this.txs.tategaki\n                        ? `padding-top: ${ev}em; padding-bottom: ${ev}em;`\n                        : `padding-left: ${ev}em; padding-right: ${ev}em;`);\n                break;\n            case '1ruby':\n                st = `ruby-align: space-between; ` +\n                    (this.txs.tategaki\n                        ? `padding-top: 1em; padding-bottom: 1em;`\n                        : `padding-left: 1em; padding-right: 1em;`);\n                break;\n            default: st = `text-align: ${r_align};`;\n        }\n        return ` style='${st}'`;\n    }\n    tagCh(text) { this.rbSpl.putTxt(text); }\n    tagCh_sub(ch, ruby, isSkip, r_align) {\n        var _a;\n        if (TxtLayer.val.doRecLog())\n            this.page_text += ch\n                + (ruby ? `《${ruby}》` : '');\n        let add_htm = '';\n        const rs = this.mkStyle_r_align(ch, ruby, r_align);\n        if (isSkip)\n            this.cumDelay = 0;\n        add_htm = ruby\n            ? (this.aSpan_bk\n                ? `<ruby style='${this.fncFFSStyle(ch)}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}' data-cmd='linkrsv'>${ch}<rt${rs}>${ruby}</rt></ruby>`\n                : (`<span class='sn_ch sn_ch_in_${this.ch_in_style}' style='animation-delay: ${this.cumDelay}ms;${this.fncFFSStyle(ch)}'>`\n                    + `<ruby data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>${ch}<rt${rs}>${ruby}</rt></ruby>`\n                    + `</span>`))\n            : (this.aSpan_bk\n                ? this.fncFFSSpan(ch)\n                : `<span class='sn_ch sn_ch_in_${this.ch_in_style}' style='animation-delay: ${this.cumDelay}ms;${this.fncFFSStyle(ch)}' data-add='{\"ch_in_style\":\"${this.ch_in_style}\", \"ch_out_style\":\"${this.ch_out_style}\"}'>${ch}</span>`);\n        if (this.ch_in_join)\n            this.cumDelay += TxtLayer.doAutoWc\n                ? (_a = TxtLayer.hAutoWc[ch.charAt(0)], (_a !== null && _a !== void 0 ? _a : 0)) : LayerMng_1.LayerMng.msecChWait;\n        return add_htm;\n    }\n    beginSpan(o) {\n        this.hSpanBk.ch_in_style = this.ch_in_style;\n        this.set_ch_in(o);\n        this.hSpanBk.ch_out_style = this.ch_out_style;\n        this.set_ch_out(o);\n        this.hSpanBk.r_align = this.r_align;\n        if ('r_align' in o)\n            this.r_align = o.r_align;\n    }\n    autoCloseSpan() {\n        if (!this.aSpan_bk)\n            return;\n        this.aSpan_bk.push(this.aSpan, '</span>');\n        this.aSpan = Array.prototype.concat.apply([], this.aSpan_bk);\n        this.aSpan_bk = null;\n        this.set_ch_in({ in_style: this.hSpanBk.ch_in_style });\n        this.set_ch_out({ out_style: this.hSpanBk.ch_out_style });\n        this.r_align = this.hSpanBk.r_align;\n    }\n    clearText() {\n        const txs = this.txs;\n        this.txs = this.txs.passBaton();\n        txs.destroy();\n        this.cumDelay = 0;\n        this.firstCh = true;\n        this.aSpan = [];\n        this.aSpan_bk = null;\n        this.page_text = '';\n        TxtLayer.recText('', true);\n    }\n    get pageText() { return this.page_text; }\n    get enabled() { return this.cnt.interactiveChildren; }\n    set enabled(e) { this.cnt.interactiveChildren = e; }\n    addButton(hArg) {\n        hArg.key = `btn=[${this.cntBtn.children.length}] ` + this.name;\n        const btn = new Button_1.Button(TxtLayer.main, TxtLayer.evtMng, hArg);\n        btn.name = JSON.stringify(hArg);\n        this.cntBtn.addChild(btn);\n        return btn.isStop;\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        this.clearText();\n        for (const c of this.cntBtn.removeChildren())\n            c.removeAllListeners().destroy();\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        this.enabled = hLay.enabled;\n        this.r_align = hLay.r_align;\n        this.cvsResize();\n        this.b_alpha = hLay.b_alpha;\n        this.b_alpha_isfixed = hLay.b_alpha_isfixed;\n        let ret = this.drawBack((hLay.b_do)\n            ? (hLay.b_do == 'Sprite' ? { b_pic: hLay.b_pic } : { b_color: hLay.b_color })\n            : { b_pic: '' });\n        this.setFfs(hLay);\n        this.txs.playback(hLay.txs);\n        const aBtn = hLay.btns;\n        aBtn.forEach(v => ret = ret || this.addButton(JSON.parse(v)));\n        if (fncComp != undefined)\n            fncComp();\n        return ret;\n    }\n    snapshot(rnd, re) {\n        rnd.render(this.cnt, undefined, false);\n        this.txs.snapshot(rnd, re);\n    }\n    snapshot_end() { this.txs.snapshot_end(); }\n    dump() {\n        let aPixiObj = [];\n        const len = this.cnt.children.length;\n        for (let i = 0; i < len; ++i) {\n            const e = this.cnt.children[i];\n            const cls = (e instanceof pixi_js_1.Sprite) ? \"Sprite\" : ((e instanceof pixi_js_1.Graphics) ? \"Graphics\" : ((e instanceof pixi_js_1.Container) ? \"Container\" : \"?\"));\n            aPixiObj.push(`{\"class\":\"${cls}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha || 1}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`);\n        }\n        return super.dump() + `, \"enabled\":\"${this.enabled}\", ${this.txs.dump()}, \"b_pic\":\"${this.b_pic}\", \"b_color\":\"${this.b_color}\", \"b_alpha\":${this.b_alpha}, \"b_alpha_isfixed\":\"${this.b_alpha_isfixed}\", \"b_width\":${this.infTL.$width}, \"b_height\":${this.infTL.$height}, \"pixi_obj\":[${aPixiObj.join(',')}]`;\n    }\n}\nexports.TxtLayer = TxtLayer;\nTxtLayer.css_key4del = '/* SKYNovel */';\nTxtLayer.doAutoWc = false;\nTxtLayer.hAutoWc = Object.create(null);\nTxtLayer.rec = (tx) => tx;\n//# sourceMappingURL=TxtLayer.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/TxtLayer.js?")},"../npm_core/core/lib/sn/TxtStage.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/TxtStage.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"../npm_core/node_modules/pixi.js/lib/pixi.es.js\");\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnTween_1 = __webpack_require__(/*! ./CmnTween */ \"../npm_core/core/lib/sn/CmnTween.js\");\nconst GrpLayer_1 = __webpack_require__(/*! ./GrpLayer */ \"../npm_core/core/lib/sn/GrpLayer.js\");\nconst DebugMng_1 = __webpack_require__(/*! ./DebugMng */ \"../npm_core/core/lib/sn/DebugMng.js\");\nconst TW = __webpack_require__(/*! @tweenjs/tween.js */ \"../npm_core/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\nconst TWEEN = TW;\nconst m_xregexp = __webpack_require__(/*! xregexp */ \"../npm_core/node_modules/xregexp/lib/index.js\");\n;\n;\nclass TxtStage extends pixi_js_1.Container {\n    constructor(infTL, cntInsidePadding, cnt) {\n        super();\n        this.infTL = infTL;\n        this.cnt = cnt;\n        this.htmTxt = document.createElement('span');\n        this.cntTxt = new pixi_js_1.Container;\n        this.grpDbgMasume = new pixi_js_1.Graphics;\n        this.left = 0;\n        this.isTategaki = false;\n        this.padTx4x = 0;\n        this.padTx4y = 0;\n        this.aSpTw = [];\n        this.aRect = [];\n        this.lenHtmTxt = 0;\n        this.rctm = new pixi_js_1.Rectangle;\n        this.regDs = m_xregexp('animation\\\\-duration: (?<ms>\\\\d+)ms;');\n        this.fncEndChIn = () => { };\n        this.isChInIng = false;\n        this.lh_half = 0;\n        this.fi_easing = 'Quadratic.Out';\n        this.fo_easing = 'Quadratic.Out';\n        this.sss = null;\n        this.htmTxt.classList.add('sn_tx');\n        this.htmTxt.style.position = 'absolute';\n        TxtStage.cvs.parentElement.appendChild(this.htmTxt);\n        cntInsidePadding.addChild(this);\n        cntInsidePadding.addChild(this.cntTxt);\n        cntInsidePadding.addChild(this.grpDbgMasume);\n        this.grpDbgMasume.name = 'grpDbgMasume';\n    }\n    static init(cfg) {\n        TxtStage.cfg = cfg;\n        TxtStage.cvs = document.getElementById(CmnLib_1.CmnLib.sn_id);\n    }\n    static setEvtMng(evtMng) { TxtStage.evtMng = evtMng; }\n    lay(hArg) {\n        var _a, _b;\n        const s = this.htmTxt.style;\n        if (hArg.style) {\n            const cln = document.createElement('span');\n            cln.style.cssText = hArg.style;\n            const len = cln.style.length;\n            for (let i = 0; i < len; ++i) {\n                const key = cln.style[i];\n                if (key in TxtStage.hWarning) {\n                    DebugMng_1.DebugMng.myTrace(`${key}は指定できません`, 'W');\n                    continue;\n                }\n                s[key] = cln.style[key];\n            }\n            if ((!cln.style.opacity) && ('alpha' in hArg))\n                s.opacity = String(this.cnt.alpha);\n        }\n        else if ('alpha' in hArg)\n            s.opacity = String(this.cnt.alpha);\n        this.lay_sub();\n        this.left = this.cnt.position.x\n            - (CmnLib_1.CmnLib.isSafari && !CmnLib_1.CmnLib.isMobile && this.isTategaki\n                ? this.infTL.pad_left + this.infTL.pad_right\n                : 0);\n        s.left = this.left + 'px';\n        s.top = this.cnt.position.y + 'px';\n        s.transformOrigin = `${this.cnt.pivot.x}px ${this.cnt.pivot.y}px`;\n        this.cvsResize();\n        s.display = this.cnt.visible ? 'inline' : 'none';\n        s.textShadow = (_b = (_a = hArg.filter, (_a !== null && _a !== void 0 ? _a : s.textShadow)), (_b !== null && _b !== void 0 ? _b : ''));\n    }\n    lay_sub() {\n        var _a;\n        const s = this.htmTxt.style;\n        const fs = parseFloat(s.fontSize || '0');\n        this.infTL.fontsize = fs;\n        this.infTL.pad_left = parseFloat(s.paddingLeft || '0');\n        this.infTL.pad_right = parseFloat(s.paddingRight || '0');\n        this.infTL.pad_top = parseFloat(s.paddingTop || '0');\n        this.infTL.pad_bottom = parseFloat(s.paddingBottom || '0');\n        this.infTL.$width = parseFloat(s.width || '0');\n        this.infTL.$height = parseFloat(s.height || '0');\n        this.parent.position.set(this.infTL.pad_left, this.infTL.pad_top);\n        this.isTategaki = (s.writingMode == 'vertical-rl');\n        this.padTx4x = 0;\n        this.padTx4y = 0;\n        const lh = (_a = s.lineHeight, (_a !== null && _a !== void 0 ? _a : '0'));\n        this.lh_half = this.isTategaki\n            ? 0\n            : ((lh.slice(-2) == 'px')\n                ? parseFloat(lh)\n                : (fs * parseFloat(lh) - fs)) / 2;\n    }\n    cvsResize() {\n        this.htmTxt.style.transform = `rotate(${this.cnt.rotation}deg) scale(${this.cnt.scale.x * CmnLib_1.CmnLib.cvsScale}, ${this.cnt.scale.y * CmnLib_1.CmnLib.cvsScale}`;\n    }\n    get tategaki() { return this.isTategaki; }\n    setSize(width, height) {\n        this.infTL.$width = width;\n        this.infTL.$height = height;\n        this.htmTxt.style.width = this.infTL.$width + 'px';\n        this.htmTxt.style.height = this.infTL.$height + 'px';\n    }\n    htm2tx(fnc, hidden = true) {\n        const util = {\n            escape: (str) => str.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1'),\n            mimeType: (url) => {\n                const extension = parseExtension(url).toLowerCase();\n                return mimes()[extension] || '';\n            },\n            dataAsUrl: dataAsUrl,\n            isDataUrl: isDataUrl,\n            resolveUrl: resolveUrl,\n            getAndEncode: getAndEncode,\n            asArray: (arrayLike) => {\n                const array = [];\n                const length = arrayLike.length;\n                for (let i = 0; i < length; ++i)\n                    array.push(arrayLike[i]);\n                return array;\n            },\n        };\n        function mimes() {\n            const WOFF = 'application/font-woff';\n            const JPEG = 'image/jpeg';\n            return {\n                'woff': WOFF,\n                'woff2': WOFF,\n                'ttf': 'application/font-truetype',\n                'eot': 'application/vnd.ms-fontobject',\n                'png': 'image/png',\n                'jpg': JPEG,\n                'jpeg': JPEG,\n                'gif': 'image/gif',\n                'tiff': 'image/tiff',\n                'svg': 'image/svg+xml'\n            };\n        }\n        const inliner = newInliner();\n        const fontFaces = newFontFaces();\n        function embedFonts(node) {\n            return fontFaces.resolveAll()\n                .then(cssText => {\n                const styleNode = document.createElement('style');\n                node.appendChild(styleNode);\n                styleNode.appendChild(document.createTextNode(cssText));\n                return node;\n            });\n        }\n        function parseExtension(url) {\n            const match = /\\.([^\\.\\/]*?)$/g.exec(url);\n            if (match)\n                return match[1];\n            else\n                return '';\n        }\n        function isDataUrl(url) {\n            return url.search(/^(data:)/) !== -1;\n        }\n        function resolveUrl(url, baseUrl) {\n            const doc = document.implementation.createHTMLDocument();\n            const base = doc.createElement('base');\n            doc.head.appendChild(base);\n            const a = doc.createElement('a');\n            doc.body.appendChild(a);\n            base.href = baseUrl;\n            a.href = url;\n            return a.href;\n        }\n        function getAndEncode(url) {\n            let TIMEOUT = 30000;\n            return new Promise(function (resolve) {\n                const request = new XMLHttpRequest();\n                request.onreadystatechange = done;\n                request.ontimeout = timeout;\n                request.responseType = 'blob';\n                request.timeout = TIMEOUT;\n                request.open('GET', url, true);\n                request.send();\n                function done() {\n                    if (request.readyState !== 4)\n                        return;\n                    if (request.status !== 200) {\n                        fail('cannot fetch resource: ' + url + ', status: ' + request.status);\n                        return;\n                    }\n                    const encoder = new FileReader();\n                    encoder.onloadend = function () {\n                        const content = encoder.result.toString().split(/,/)[1];\n                        resolve(content);\n                    };\n                    encoder.readAsDataURL(request.response);\n                }\n                function timeout() {\n                    fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url);\n                }\n                function fail(message) {\n                    console.error(message);\n                    resolve('');\n                }\n            });\n        }\n        function dataAsUrl(content, type) {\n            return 'data:' + type + ';base64,' + content;\n        }\n        function newInliner() {\n            const URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n            return {\n                inlineAll: inlineAll,\n                shouldProcess: shouldProcess,\n            };\n            function shouldProcess(str) {\n                return str.search(URL_REGEX) !== -1;\n            }\n            function readUrls(str) {\n                const result = [];\n                let match;\n                while ((match = URL_REGEX.exec(str))) {\n                    result.push(match[1]);\n                }\n                return result.filter(function (url) {\n                    return !util.isDataUrl(url);\n                });\n            }\n            function inline(str, url, baseUrl, get) {\n                return Promise.resolve(url)\n                    .then(url => baseUrl ? util.resolveUrl(url, baseUrl) : url)\n                    .then(get || util.getAndEncode)\n                    .then(data => util.dataAsUrl(data, util.mimeType(url)))\n                    .then(dataUrl => str.replace(urlAsRegex(url), '$1' + dataUrl + '$3'));\n                function urlAsRegex(url) {\n                    return new RegExp('(url\\\\([\\'\"]?)(' + util.escape(url) + ')([\\'\"]?\\\\))', 'g');\n                }\n            }\n            function inlineAll(str, baseUrl, get) {\n                if (nothingToInline())\n                    return Promise.resolve(str);\n                return Promise.resolve(str)\n                    .then(readUrls)\n                    .then(urls => {\n                    let done = Promise.resolve(str);\n                    for (const url of urls) {\n                        done = done.then(string => {\n                            return inline(string, url, baseUrl, get);\n                        });\n                    }\n                    return done;\n                });\n                function nothingToInline() {\n                    return !shouldProcess(str);\n                }\n            }\n        }\n        function newFontFaces() {\n            return {\n                resolveAll: resolveAll,\n                impl: { readAll: readAll }\n            };\n            function resolveAll() {\n                return readAll()\n                    .then(webFonts => Promise.all(webFonts.map((webFont) => webFont.resolve())))\n                    .then(cssStrings => cssStrings.join('\\n'));\n            }\n            function readAll() {\n                return Promise.resolve(util.asArray(document.styleSheets))\n                    .then(getCssRules)\n                    .then(selectWebFontRules)\n                    .then(rules => rules.map(newWebFont));\n                function selectWebFontRules(cssRules) {\n                    return cssRules\n                        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n                        .filter((rule) => inliner.shouldProcess(rule.style.getPropertyValue('src')));\n                }\n                function getCssRules(styleSheets) {\n                    const cssRules = [];\n                    for (const sheet of styleSheets) {\n                        try {\n                            if (sheet.href)\n                                continue;\n                            util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));\n                        }\n                        catch (e) {\n                            console.error('Error while reading CSS rules from ' + sheet.href, e.toString());\n                        }\n                    }\n                    return cssRules;\n                }\n                function newWebFont(webFontRule) {\n                    return {\n                        resolve: function resolve() {\n                            const baseUrl = (webFontRule.parentStyleSheet || {}).href;\n                            return inliner.inlineAll(webFontRule.cssText, baseUrl);\n                        },\n                        src: function () {\n                            return webFontRule.style.getPropertyValue('src');\n                        }\n                    };\n                }\n            }\n        }\n        Promise.resolve(this.htmTxt)\n            .then(node => {\n            const cln = node.cloneNode(true);\n            cln.style.padding = '0px';\n            cln.style.paddingRight = this.padTx4x + 'px';\n            cln.style.paddingTop = this.padTx4y + 'px';\n            cln.style.left = '0px';\n            cln.style.top = '0px';\n            cln.style.width = (this.infTL.$width - this.infTL.pad_left - this.infTL.pad_right) + 'px';\n            cln.style.height = (this.infTL.$height - this.infTL.pad_top - this.infTL.pad_bottom) + 'px';\n            this.htmTxt.hidden = hidden;\n            return cln;\n        })\n            .then(embedFonts)\n            .then(node => {\n            node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n            const img = new Image;\n            img.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${this.infTL.$width}px\" height=\"${this.infTL.$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(node)\n                .replace(/#/g, '%23').replace(/\\n/g, '%0A')}</foreignObject></svg>`;\n            return new Promise(resolve => img.onload = () => resolve(img));\n        })\n            .then(img => new Promise(resolve => setTimeout(() => resolve(img), 100)))\n            .then((img) => {\n            const canvas = document.createElement('canvas');\n            canvas.width = this.infTL.$width;\n            canvas.height = this.infTL.$height;\n            canvas.getContext('2d').drawImage(img, 0, 0);\n            canvas.toBlob(blob => {\n                const url = URL.createObjectURL(blob);\n                pixi_js_1.Texture.from(url).once('update', (tx2) => {\n                    fnc(tx2);\n                    URL.revokeObjectURL(url);\n                });\n            });\n        })\n            .catch(err => DebugMng_1.DebugMng.myTrace(`goTxt() = ${err}`));\n    }\n    goTxt(aSpan) {\n        var _a, _b;\n        TxtStage.cntBreak.visible = false;\n        const begin = this.aRect.length;\n        if (TxtStage.cfg.oCfg.debug.masume && begin == 0) {\n            if (TxtStage.cfg.oCfg.debug.devtool)\n                console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${this.infTL.pad_left} pr:${this.infTL.pad_right} pt:${this.infTL.pad_top} pb:${this.infTL.pad_bottom} w:${this.infTL.$width} h:${this.infTL.$height}`);\n            this.grpDbgMasume.clear();\n            this.grpDbgMasume.beginFill(0x33FF00, 0.2);\n            this.grpDbgMasume.lineStyle(1, 0x33FF00, 1);\n            this.grpDbgMasume.drawRect(-this.infTL.pad_left, -this.infTL.pad_top, this.infTL.$width, this.infTL.$height);\n            this.grpDbgMasume.endFill();\n            this.grpDbgMasume.beginFill(0x0033FF, 0.2);\n            this.grpDbgMasume.lineStyle(2, 0x0033FF, 1);\n            this.grpDbgMasume.drawRect(0, 0, this.infTL.$width - this.infTL.pad_left - this.infTL.pad_right, this.infTL.$height - this.infTL.pad_top - this.infTL.pad_bottom);\n            this.grpDbgMasume.endFill();\n        }\n        if (begin == 0)\n            this.htmTxt.innerHTML = [...aSpan].join('');\n        else\n            this.htmTxt.insertAdjacentHTML('beforeend', aSpan.slice(this.lenHtmTxt).join(''));\n        this.lenHtmTxt = aSpan.length;\n        let len = 0;\n        let j = 2;\n        do {\n            const e = this.aRect = this.getChRects(this.htmTxt);\n            len = e.length;\n            if (CmnLib_1.CmnLib.cvsScale != 1) {\n                for (let i = 0; i < len; ++i) {\n                    const r = e[i].rect;\n                    r.x -= CmnLib_1.CmnLib.ofsPadLeft_Dom2PIXI;\n                    r.y -= CmnLib_1.CmnLib.ofsPadTop_Dom2PIXI;\n                    r.x /= CmnLib_1.CmnLib.cvsScale;\n                    r.y /= CmnLib_1.CmnLib.cvsScale;\n                    r.width /= CmnLib_1.CmnLib.cvsScale;\n                    r.height /= CmnLib_1.CmnLib.cvsScale;\n                }\n            }\n            if (len < 2)\n                break;\n            let sl_xy = -Infinity;\n            for (; j < len; ++j) {\n                const he = e[j];\n                if (he.elm.outerHTML.slice(0, 3) == '<rt')\n                    continue;\n                const xy = this.tategaki ? he.rect.y : he.rect.x;\n                if (sl_xy < xy) {\n                    sl_xy = xy;\n                    continue;\n                }\n                sl_xy = -Infinity;\n                if (TxtStage.reg分割禁止.test(e[j - 1].ch)\n                    && e[j - 1].ch == he.ch)\n                    --j;\n                else {\n                    if (TxtStage.reg行末禁則.test(e[j - 1].ch))\n                        --j;\n                    else if (TxtStage.reg行頭禁則.test(he.ch)) {\n                        while (j > 0 && TxtStage.reg行頭禁則.test(e[--j].ch))\n                            ;\n                    }\n                    else\n                        continue;\n                    while (j > 0 && TxtStage.reg行末禁則.test(e[j - 1].ch))\n                        --j;\n                }\n                const pal = e[j].elm.parentElement;\n                if (pal.classList.contains('sn_tx'))\n                    pal.insertBefore(document.createElement('br'), e[j].elm);\n                else\n                    pal.parentElement.insertBefore(document.createElement('br'), pal);\n                j += 2;\n                len = -1;\n                break;\n            }\n        } while (len < 0);\n        const fncMasumeLog = (TxtStage.cfg.oCfg.debug.devtool)\n            ? (v, rct) => console.log(`🍌 masume ch:${v.ch} x:${rct.x} y:${rct.y} w:${rct.width} h:${rct.height}`)\n            : () => { };\n        const fncMasume = (TxtStage.cfg.oCfg.debug.masume)\n            ? (v, rct) => {\n                fncMasumeLog(v, rct);\n                this.grpDbgMasume.beginFill(0x66CCFF, 0.5);\n                this.grpDbgMasume.lineStyle(2, 0xFF3300, 1);\n                this.grpDbgMasume.drawRect(rct.x, rct.y, rct.width, rct.height);\n                this.grpDbgMasume.endFill();\n            }\n            : () => { };\n        const ease = CmnTween_1.CmnTween.ease(this.fi_easing);\n        const bcr = this.htmTxt.getBoundingClientRect();\n        const sx = bcr.left + window.pageXOffset + this.infTL.pad_left;\n        const sy = bcr.top + window.pageYOffset + this.infTL.pad_top;\n        for (let i = begin; i < len; ++i) {\n            const v = this.aRect[i];\n            const rct = v.rect;\n            const arg = JSON.parse((_a = v.arg, (_a !== null && _a !== void 0 ? _a : '{\"delay\": 0}')));\n            const add = JSON.parse((_b = v.add, (_b !== null && _b !== void 0 ? _b : '{}')));\n            const cis = TxtStage.hChInStyle[add.ch_in_style];\n            rct.x -= sx;\n            rct.y -= sy;\n            fncMasume(v, rct);\n            if (cis) {\n                if (this.isTategaki) {\n                    rct.x += (rct.width - rct.height) / 2;\n                    rct.width = rct.height;\n                }\n                else {\n                    rct.y += (rct.height - rct.width) / 2;\n                    rct.height = rct.width;\n                }\n                this.rctm = rct;\n            }\n            switch (v.cmd) {\n                case 'grp':\n                    const cnt = new pixi_js_1.Container;\n                    this.spWork(cnt, arg, add, rct, ease, (cis !== null && cis !== void 0 ? cis : {}));\n                    this.cntTxt.addChild(cnt);\n                    GrpLayer_1.GrpLayer.csv2Sprites(arg.pic, cnt, sp => {\n                        if (!cnt.parent)\n                            cnt.removeChild(sp);\n                    });\n                    break;\n                case 'link':\n                    const sp = new pixi_js_1.Sprite;\n                    sp.width = rct.width;\n                    sp.height = rct.height;\n                    arg.key = `lnk=[${i}] ` + this.name;\n                    this.spWork(sp, arg, add, rct, ease, (cis !== null && cis !== void 0 ? cis : {}));\n                    TxtStage.evtMng.button(arg, sp);\n                    this.cntTxt.addChild(sp);\n                    break;\n            }\n        }\n        this.aRect.slice(0, -1);\n        --this.lenHtmTxt;\n        this.htmTxt.innerHTML = this.htmTxt.innerHTML.replace(/<span [^>]+>　<\\/span>$/, '');\n        const chs = this.htmTxt.querySelectorAll('span.sn_ch');\n        const len_chs = chs.length;\n        for (let i = 0; i < len_chs; ++i) {\n            const v = chs[i];\n            v.className = v.className.replace(/sn_ch_in_([^\\s\"]+)/g, 'go_ch_in_$1');\n        }\n        this.isChInIng = true;\n        this.fncEndChIn = () => {\n            this.isChInIng = false;\n            for (let i = 0; i < len_chs; ++i) {\n                const v = chs[i];\n                v.className = v.className.replace(/ go_ch_in_[^\\s\"]+/g, '');\n            }\n            TxtStage.cntBreak.position.set(this.rctm.x, this.rctm.y);\n            TxtStage.cntBreak.visible = true;\n            this.fncEndChIn = () => { };\n        };\n        if (len_chs == 0) {\n            this.fncEndChIn();\n            return;\n        }\n        let le = null;\n        for (let i = len_chs - 1; i >= 0; --i) {\n            const v = chs[i];\n            if (v.className == 'sn_ch')\n                break;\n            const st = v.getAttribute('style');\n            if (!st) {\n                le = v;\n                break;\n            }\n            const m = m_xregexp.exec(st, this.regDs);\n            if (!m || Number(m['ms']) > 0) {\n                le = v;\n                break;\n            }\n        }\n        if (!le) {\n            this.fncEndChIn();\n            return;\n        }\n        le.addEventListener('animationend', this.fncEndChIn, { once: true, passive: true });\n    }\n    spWork(sp, arg, add, rct, ease, cis) {\n        var _a, _b, _c;\n        sp.alpha = 0;\n        if (arg.width)\n            sp.width = arg.width;\n        if (arg.height)\n            sp.height = arg.height;\n        sp.position.set((cis.x.charAt(0) == '=') ? rct.x + sp.width * cis.nx : cis.nx, (cis.y.charAt(0) == '=') ? rct.y + sp.height * cis.ny : cis.ny);\n        const st = {\n            sp: sp,\n            tw: new TWEEN.default.Tween(sp)\n                .to({ alpha: 1, x: rct.x, y: rct.y, width: rct.width, height: rct.height, rotation: 0 }, (_a = cis.wait, (_a !== null && _a !== void 0 ? _a : 0)))\n                .easing(ease)\n                .delay((_b = add.wait, (_b !== null && _b !== void 0 ? _b : 0)) + (_c = arg.delay, (_c !== null && _c !== void 0 ? _c : 0)))\n                .onComplete(() => {\n                st.tw = null;\n            })\n                .start(),\n        };\n        this.aSpTw.push(st);\n    }\n    skipChIn() {\n        let isLiveTw = this.isChInIng;\n        this.fncEndChIn();\n        this.aSpTw.forEach(st => { if (st.tw) {\n            st.tw.stop().end();\n            isLiveTw = true;\n        } });\n        this.aSpTw = [];\n        return isLiveTw;\n    }\n    static initChStyle() {\n        TxtStage.hChInStyle = Object.create(null);\n        TxtStage.hChOutStyle = Object.create(null);\n    }\n    static getChInStyle(name) { return TxtStage.hChInStyle[name]; }\n    static ch_in_style(hArg) {\n        var _a, _b, _c;\n        const name = hArg.name;\n        if (!name)\n            throw 'nameは必須です';\n        TxtStage.REG_NG_CHSTYLE_NAME_CHR.lastIndex = 0;\n        if (TxtStage.REG_NG_CHSTYLE_NAME_CHR.test(name))\n            throw `name【${name}】に使えない文字が含まれます`;\n        if (name in TxtStage.hChInStyle)\n            throw `name【${name}】はすでにあります`;\n        const x = String((_a = hArg.x, (_a !== null && _a !== void 0 ? _a : '=0')));\n        const y = String((_b = hArg.y, (_b !== null && _b !== void 0 ? _b : '=0')));\n        return TxtStage.hChInStyle[name] = {\n            wait: CmnLib_1.CmnLib.argChk_Num(hArg, 'wait', 500),\n            alpha: CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', 0),\n            x: x,\n            y: y,\n            nx: parseFloat((x.charAt(0) == '=') ? x.slice(1) : x),\n            ny: parseFloat((y.charAt(0) == '=') ? y.slice(1) : y),\n            scale_x: CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', 1),\n            scale_y: CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', 1),\n            rotate: CmnLib_1.CmnLib.argChk_Num(hArg, 'rotate', 0),\n            join: CmnLib_1.CmnLib.argChk_Boolean(hArg, 'join', true),\n            ease: (_c = hArg.ease, (_c !== null && _c !== void 0 ? _c : 'ease-out')),\n        };\n    }\n    static getChOutStyle(name) { return TxtStage.hChOutStyle[name]; }\n    static ch_out_style(hArg) {\n        var _a, _b, _c;\n        const name = hArg.name;\n        if (!name)\n            throw 'nameは必須です';\n        TxtStage.REG_NG_CHSTYLE_NAME_CHR.lastIndex = 0;\n        if (TxtStage.REG_NG_CHSTYLE_NAME_CHR.test(name))\n            throw `name【${name}】に使えない文字が含まれます`;\n        if (name in TxtStage.hChOutStyle)\n            throw `name【${name}】はすでにあります`;\n        const x = String((_a = hArg.x, (_a !== null && _a !== void 0 ? _a : '=0')));\n        const y = String((_b = hArg.y, (_b !== null && _b !== void 0 ? _b : '=0')));\n        return TxtStage.hChOutStyle[name] = {\n            wait: CmnLib_1.CmnLib.argChk_Num(hArg, 'wait', 500),\n            alpha: CmnLib_1.CmnLib.argChk_Num(hArg, 'alpha', 0),\n            x: x,\n            y: y,\n            nx: parseFloat((x.charAt(0) == '=') ? x.slice(1) : x),\n            ny: parseFloat((y.charAt(0) == '=') ? y.slice(1) : y),\n            scale_x: CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_x', 1),\n            scale_y: CmnLib_1.CmnLib.argChk_Num(hArg, 'scale_y', 1),\n            rotate: CmnLib_1.CmnLib.argChk_Num(hArg, 'rotate', 0),\n            join: CmnLib_1.CmnLib.argChk_Boolean(hArg, 'join', false),\n            ease: (_c = hArg.ease, (_c !== null && _c !== void 0 ? _c : 'ease-out')),\n        };\n    }\n    dispBreak(pic) {\n        const cnt = TxtStage.cntBreak;\n        cnt.visible = false;\n        this.addChild(cnt);\n        GrpLayer_1.GrpLayer.csv2Sprites(pic, cnt, sp => {\n            if (!cnt.parent)\n                cnt.removeChild(sp);\n        });\n    }\n    static delBreak() {\n        const cnt = TxtStage.cntBreak;\n        if (cnt.parent) {\n            cnt.parent.removeChild(cnt);\n            cnt.removeChildren();\n        }\n        TxtStage.cntBreak = new pixi_js_1.Container;\n    }\n    getChRects(elm) {\n        var _a, _b, _c, _d;\n        const ret = [];\n        if (elm.nodeType != elm.TEXT_NODE) {\n            for (const v of elm.childNodes)\n                ret.push(this.getChRects(v));\n            return Array.prototype.concat.apply([], ret);\n        }\n        const range = elm.ownerDocument.createRange();\n        range.selectNodeContents(elm);\n        let pos = 0;\n        const end = range.endOffset;\n        while (pos < end) {\n            range.setStart(elm, pos);\n            range.setEnd(elm, ++pos);\n            const r = range.getBoundingClientRect();\n            const pe = range.startContainer.parentElement;\n            if (!pe)\n                throw `fn:TxtStage.ts pe null`;\n            const ch = range.toString();\n            const cr = {\n                ch: ch,\n                rect: new pixi_js_1.Rectangle(r.left + window.pageXOffset, r.top + window.pageYOffset, r.width, r.height + ('gjqy'.includes(ch) ? this.lh_half : 0)),\n                elm: pe,\n                cmd: (_a = pe.getAttribute('data-cmd'), (_a !== null && _a !== void 0 ? _a : undefined)),\n                arg: (_b = pe.getAttribute('data-arg'), (_b !== null && _b !== void 0 ? _b : undefined)),\n                add: (_c = pe.getAttribute('data-add'), (_c !== null && _c !== void 0 ? _c : undefined)),\n                tcy: (_d = pe.getAttribute('data-tcy'), (_d !== null && _d !== void 0 ? _d : undefined)),\n            };\n            ret.push(cr);\n        }\n        range.detach();\n        return ret;\n    }\n    clearText() {\n        var _a, _b, _c, _d;\n        this.grpDbgMasume.clear();\n        this.aRect = [];\n        this.lenHtmTxt = 0;\n        this.skipChIn();\n        const n = this.htmTxt.cloneNode(true);\n        n.textContent = '';\n        const old = this.htmTxt;\n        old.parentElement.insertBefore(n, old);\n        const chs = old.querySelectorAll('span.sn_ch');\n        const len_chs = chs.length;\n        let sum_wait = 0;\n        for (let i = 0; i < len_chs; ++i) {\n            const elm = chs[i];\n            const add = JSON.parse((_c = (_b = (_a = elm.getAttribute('data-add'), (_a !== null && _a !== void 0 ? _a : elm.children[0].getAttribute('data-add'))), (_b !== null && _b !== void 0 ? _b : elm.children[0].children[0]\n                .getAttribute('data-add'))), (_c !== null && _c !== void 0 ? _c : '{}')));\n            if (!add.ch_out_style)\n                continue;\n            const cos = TxtStage.hChOutStyle[add.ch_out_style];\n            if (!cos)\n                continue;\n            if (cos.wait == 0) {\n                elm.style.display = 'none';\n                continue;\n            }\n            sum_wait += cos.wait;\n            if (!cos.join)\n                elm.style.animationDelay = '0ms';\n            elm.classList.add(`go_ch_out_${add.ch_out_style}`);\n        }\n        const end = () => {\n            old.parentElement.removeChild(old);\n            for (const c of this.cntTxt.removeChildren())\n                c.removeAllListeners().destroy();\n        };\n        if (sum_wait == 0) {\n            this.htmTxt.textContent = '';\n            end();\n        }\n        else\n            (_d = old.lastElementChild) === null || _d === void 0 ? void 0 : _d.addEventListener('animationend', end, { once: true, passive: true });\n        this.htmTxt = n;\n    }\n    passBaton() {\n        this.clearText();\n        const to = new TxtStage(this.infTL, this.parent, this.cnt);\n        to.htmTxt.style.cssText = this.htmTxt.style.cssText;\n        to.left = this.left;\n        to.name = this.name;\n        to.lay_sub();\n        to.ch_filter = this.ch_filter;\n        to.fi_easing = this.fi_easing;\n        to.fo_easing = this.fo_easing;\n        return to;\n    }\n    record() {\n        return {\n            infTL: this.infTL,\n            cssText: this.htmTxt.style.cssText,\n            left: this.left,\n            ch_filter: this.ch_filter,\n            fi_easing: this.fi_easing,\n            fo_easing: this.fo_easing,\n        };\n    }\n    ;\n    playback(hLay) {\n        this.infTL = hLay.infTL;\n        this.parent.position.set(this.infTL.pad_left, this.infTL.pad_top);\n        this.htmTxt.style.cssText = hLay.cssText;\n        this.left = hLay.left;\n        this.lay_sub();\n        this.ch_filter = hLay.ch_filter;\n        this.fi_easing = hLay.fi_easing;\n        this.fo_easing = hLay.fo_easing;\n    }\n    snapshot(rnd, re) {\n        this.htm2tx(tx => {\n            this.sss = new pixi_js_1.Sprite(tx);\n            if (this.isTategaki) {\n                this.sss.x += CmnLib_1.CmnLib.stageW - (this.left + this.infTL.$width)\n                    - ((CmnLib_1.CmnLib.isSafari && !CmnLib_1.CmnLib.isMobile)\n                        ? 0\n                        : this.infTL.pad_left + this.infTL.pad_right);\n            }\n            this.sss.y -= this.padTx4y;\n            this.sss.texture.frame = new pixi_js_1.Rectangle(0, 0, this.infTL.$width - this.left, this.infTL.$height);\n            this.cntTxt.addChild(this.sss);\n            rnd.render(this.sss, undefined, false);\n            re();\n        }, false);\n    }\n    snapshot_end() {\n        if (this.sss) {\n            this.cntTxt.removeChild(this.sss);\n            this.sss = null;\n        }\n    }\n    dump() {\n        const aStyle = [];\n        const s = this.htmTxt.style;\n        const lenStyle = s.length;\n        for (let i = 0; i < lenStyle; ++i) {\n            const key = s[i];\n            aStyle.push(`\"${key}\":\"${s[key].replace(/(\")/g, '\\\\$1')}\"`);\n        }\n        return `\"txt\":\"${this.htmTxt.textContent.replace(/(\")/g, '\\\\$1')}\", \"style\":{${aStyle.join(',')}}`;\n    }\n    destroy() {\n        TxtStage.delBreak();\n        this.htmTxt.parentElement.removeChild(this.htmTxt);\n        this.parent.removeChild(this.cntTxt);\n        this.parent.removeChild(this.grpDbgMasume);\n        this.parent.removeChild(this);\n        super.destroy();\n    }\n}\nexports.TxtStage = TxtStage;\nTxtStage.hWarning = {\n    backgroundColor: 0,\n    borderBottomWidth: 0,\n    borderLeftWidth: 0,\n    borderRightWidth: 0,\n    borderTopWidth: 0,\n    marginBottom: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n};\nTxtStage.reg行頭禁則 = new RegExp('[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]');\nTxtStage.reg行末禁則 = new RegExp('[［（｛〈「『【〔“〝]');\nTxtStage.reg分割禁止 = new RegExp('[─‥…]');\nTxtStage.hChInStyle = Object.create(null);\nTxtStage.REG_NG_CHSTYLE_NAME_CHR = /[\\s\\.,]/;\nTxtStage.hChOutStyle = Object.create(null);\nTxtStage.cntBreak = new pixi_js_1.Container;\n//# sourceMappingURL=TxtStage.js.map\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/TxtStage.js?")},"../npm_core/core/lib/sn/Variable.js":
/*!*******************************************!*\
  !*** ../npm_core/core/lib/sn/Variable.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CmnLib_1 = __webpack_require__(/*! ./CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst Areas_1 = __webpack_require__(/*! ./Areas */ \"../npm_core/core/lib/sn/Areas.js\");\nconst PropParser_1 = __webpack_require__(/*! ./PropParser */ \"../npm_core/core/lib/sn/PropParser.js\");\nclass Variable {\n    constructor(cfg, hTag) {\n        var _a;\n        this.cfg = cfg;\n        this.hScope = { sys: {}, save: {}, tmp: {}, mp: {} };\n        this.hSave = this.hScope.save;\n        this.hTmp = this.hScope.tmp;\n        this.data = { sys: {}, mark: {}, kidoku: {} };\n        this.hAreaKidoku = {};\n        this.flush_ = () => { };\n        this.doRecProc = (_doRec) => { };\n        this.getMark = (place) => this.data.mark[place];\n        this.getAreaKidoku = (fn) => this.hAreaKidoku[fn];\n        this.setVal = (arg_name, val, autocast = true) => {\n            if (!arg_name)\n                throw '[変数に値セット] nameは必須です';\n            if (val == null)\n                throw '[変数に値セット] textは必須です（空文字はOK）';\n            const o = PropParser_1.PropParser.getValName(arg_name);\n            if (o == undefined)\n                throw '[変数参照] name(' + arg_name + ')が変数名として異常です';\n            const hScope = this.hScope[o.scope];\n            if (!hScope)\n                throw '[変数に値セット] scopeが異常【' + o.scope + '】です';\n            const nm = o['name'];\n            if (nm.slice(0, 6) == 'const.' && (nm in hScope)) {\n                throw '[変数に値セット] 変数【' + nm + '】は書き換え不可です';\n            }\n            this.setVal_Nochk(o.scope, nm, val, autocast);\n        };\n        this.getVal = (arg_name, def) => {\n            if (!arg_name)\n                throw '[変数参照] nameは必須です';\n            const o = PropParser_1.PropParser.getValName(arg_name);\n            if (o == undefined)\n                throw '[変数参照] name(' + arg_name + ')が変数名として異常です';\n            const hScope = this.hScope[o['scope']];\n            if (!hScope)\n                throw '[変数参照] scopeが異常【' + o['scope'] + '】です';\n            const name = o['name'];\n            let val = hScope[name];\n            if (!(name in hScope)) {\n                val = def;\n                const aNm = name.split('.');\n                const len = aNm.length;\n                let nm = '';\n                for (let i = 0; i < len; ++i) {\n                    nm += '.' + aNm[i];\n                    const bn = nm.slice(1);\n                    if (!(bn in hScope))\n                        continue;\n                    val = JSON.parse(hScope[bn]);\n                    while (++i < len) {\n                        if (!(aNm[i] in val)) {\n                            val = def;\n                            break;\n                        }\n                        val = val[aNm[i]];\n                    }\n                    if (val instanceof Object)\n                        val = JSON.stringify(val);\n                    break;\n                }\n            }\n            if (val instanceof Function)\n                val = val();\n            if (o['at'] == '@str')\n                return val;\n            return this.castAuto(val);\n        };\n        this.REG_NUMERICLITERAL = /^-?[\\d\\.]+$/;\n        this.dump_val = () => {\n            const val = { tmp: {}, sys: {}, save: {}, mp: {} };\n            for (let scope in val) {\n                const hVal = this.hScope[scope];\n                const hRet = val[scope];\n                for (let key in hVal) {\n                    const v = hVal[key];\n                    if (Object.prototype.toString.call(v) == '[object Function]') {\n                        hRet[key] = v();\n                    }\n                    else\n                        hRet[key] = v;\n                }\n            }\n            console.info('🥟 [dump_val]', val);\n            return false;\n        };\n        this.$doRecLog = false;\n        this.hValTrg = {\n            'sys:sn.tagCh.doWait': name => this.runFirst_Bool_hSysVal_true(name),\n            'sys:sn.tagCh.doWait_Kidoku': name => this.runFirst_Bool_hSysVal_true(name),\n            'sys:sn.tagCh.msecWait': name => this.runFirst_sys_an_tagCh_msecWait(name),\n            'sys:sn.tagCh.msecWait_Kidoku': name => this.runFirst_sys_an_tagCh_msecWait_Kidoku(name),\n            'sys:sn.tagCh.canskip': name => this.runFirst_Bool_hSysVal_true(name),\n            'sys:sn.auto.msecPageWait': name => this.runFirst_sys_an_auto_msecPageWait(name),\n            'sys:sn.auto.msecPageWait_Kidoku': name => this.runFirst_sys_an_auto_msecPageWait(name),\n            'sys:sn.auto.msecLineWait': name => this.runFirst_sys_an_auto_msecLineWait(name),\n            'sys:sn.auto.msecLineWait_Kidoku': name => this.runFirst_sys_an_auto_msecLineWait(name),\n            'save:sn.doRecLog': name => {\n                this.doRecProc(this.$doRecLog = this.runFirst_Bool_hSaveVal_true(name));\n            },\n            'save:sn.userFnTail': (_name, val) => this.cfg.userFnTail = val,\n            'tmp:sn.tagL.enabled': name => this.runFirst_Bool_hTmp_true(name),\n            'tmp:sn.skip.all': name => this.runFirst_Bool_hTmp_false(name),\n            'tmp:sn.skip.enabled': name => this.runFirst_Bool_hTmp_false(name),\n            'tmp:sn.auto.enabled': name => this.runFirst_Bool_hTmp_false(name),\n            'tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode': (() => {\n            }),\n            'tmp:sn.chkFontMode': () => {\n                if (this.hTmp['const.sn.onLauncher'])\n                    return;\n                if (!this.hTmp['const.sn.isDebugger'])\n                    return;\n            }\n        };\n        hTag.let = o => this.let(o);\n        hTag.let_abs = o => this.let_abs(o);\n        hTag.let_char_at = o => this.let_char_at(o);\n        hTag.let_index_of = o => this.let_index_of(o);\n        hTag.let_length = o => this.let_length(o);\n        hTag.let_replace = o => this.let_replace(o);\n        hTag.let_round = o => this.let_round(o);\n        hTag.let_search = o => this.let_search(o);\n        hTag.let_substr = o => this.let_substr(o);\n        hTag.clearsysvar = () => this.clearsysvar();\n        hTag.clearvar = () => this.clearvar();\n        hTag.dump_val = () => this.dump_val();\n        hTag.copybookmark = o => this.copybookmark(o);\n        hTag.erasebookmark = o => this.erasebookmark(o);\n        this.hSave['sn.userFnTail'] = '';\n        this.defTmp('const.sn.bookmark.json', () => {\n            const a = [];\n            Object.keys(this.data.mark).sort().forEach(k => {\n                const o = Object.assign({}, this.data.mark[k].json);\n                for (const key in o) {\n                    const v = o[key];\n                    if (typeof v != 'string')\n                        continue;\n                    if (v.substr(0, 10) != 'userdata:/')\n                        continue;\n                    o[key] = cfg.searchPath(v);\n                }\n                o.place = k;\n                a.push(o);\n            });\n            return JSON.stringify(a);\n        });\n        this.hTmp['const.sn.isFirstBoot'] = true;\n        this.hTmp['sn.tagL.enabled'] = true;\n        this.hTmp['sn.skip.all'] = false;\n        this.hTmp['sn.skip.enabled'] = false;\n        this.hTmp['sn.auto.enabled'] = false;\n        this.hTmp['const.sn.last_page_text'] = '';\n        this.hTmp['const.sn.displayState'] = false;\n        this.hTmp['const.Date.getTime'] = () => (new Date).getTime();\n        this.hTmp['const.Date.getDateStr'] = () => CmnLib_1.getDateStr();\n        this.hTmp['const.Stage.mouseX'] = () => {\n            return 0;\n        };\n        this.hTmp['const.Stage.mouseY'] = () => {\n            return 0;\n        };\n        this.hTmp['const.sn.platform'] = JSON.stringify(CmnLib_1.CmnLib.platform);\n        this.clearsysvar();\n        this.clearvar();\n        this.hTmp['const.sn.config.window.width'] = cfg.oCfg.window.width;\n        this.hTmp['const.sn.config.window.height'] = cfg.oCfg.window.height;\n        this.hTmp['const.sn.config.book.title'] = cfg.oCfg.book.title;\n        this.hTmp['const.sn.config.book.version'] = cfg.oCfg.book.version;\n        this.hTmp['const.sn.Math.PI'] = Math.PI;\n        if (typeof window == 'undefined')\n            return;\n        const win = window;\n        const ac = (_a = win['AudioContext'], (_a !== null && _a !== void 0 ? _a : win['webkitAudioContext']));\n        this.hTmp['const.sn.needClick2Play'] = () => new ac().state == 'suspended';\n        const dmmq = window.matchMedia('(prefers-color-scheme: dark)');\n        this.hTmp['const.sn.isDarkMode'] = CmnLib_1.CmnLib.isDarkMode = dmmq.matches;\n        dmmq.addListener(e => this.hTmp['const.sn.isDarkMode'] = CmnLib_1.CmnLib.isDarkMode = e.matches);\n    }\n    setSys(sys) {\n        sys.initVal(this.data, this.hTmp, data => {\n            this.data = data;\n            this.hSys = this.hScope.sys = this.data.sys;\n            for (const fn in this.data.kidoku) {\n                const areas = new Areas_1.Areas();\n                areas.hAreas = Object.assign({}, this.data.kidoku[fn]);\n                this.hAreaKidoku[fn] = areas;\n            }\n            sessionStorage.clear();\n            this.flush_ = (this.cfg.oCfg.debug.variable)\n                ? () => {\n                    const oSys = {};\n                    Object.keys(this.hSys).forEach(k => {\n                        const v = this.hSys[k];\n                        oSys['sys:' + k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'sys'] = JSON.stringify(oSys);\n                    const oSave = {};\n                    Object.keys(this.hSave).forEach(k => {\n                        const v = this.hSave[k];\n                        oSave['save:' + k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'save'] = JSON.stringify(oSave);\n                    const oTmp = {};\n                    Object.keys(this.hTmp).forEach(k => {\n                        const v = this.hTmp[k];\n                        oTmp[k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'tmp'] = JSON.stringify(oTmp);\n                    const oMp = {};\n                    Object.keys(this.hScope.mp).forEach(k => {\n                        const v = this.hScope.mp[k];\n                        oMp[k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'mp'] = JSON.stringify(oMp);\n                    const oMark = {};\n                    Object.keys(this.data.mark).forEach(k => {\n                        const v = this.data.mark[k];\n                        oMark[k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'mark'] = JSON.stringify(oMark);\n                    const oKidoku = {};\n                    Object.keys(this.data.kidoku).forEach(k => {\n                        const v = this.data.kidoku[k];\n                        oKidoku[k] = (v instanceof Function) ? v() : v;\n                    });\n                    sessionStorage[this.cfg.getNs() + 'kidoku'] = JSON.stringify(oKidoku);\n                    sys.flush();\n                }\n                : () => sys.flush();\n        });\n    }\n    flush() { this.flush_(); }\n    setDoRecProc(doRecProc) {\n        this.doRecProc = doRecProc;\n    }\n    defTmp(name, fnc) { this.hTmp[name] = fnc; }\n    ;\n    cloneMp() { return Object.assign({}, this.hScope.mp); }\n    setMp(mp) { this.hScope.mp = mp; }\n    setMark(place, mark) { this.data.mark[place] = mark; this.flush(); }\n    cloneSave() { return Object.assign({}, this.hScope.save); }\n    mark2save(mark) {\n        var _a;\n        this.hSave = this.hScope.save = Object.assign({}, mark.hSave);\n        this.$doRecLog = (_a = this.hSave['sn.doRecLog'], (_a !== null && _a !== void 0 ? _a : false));\n    }\n    loadScrWork(fn) {\n        if (!(fn in this.hAreaKidoku))\n            this.hAreaKidoku[fn] = new Areas_1.Areas;\n    }\n    saveKidoku() {\n        for (const fn in this.hAreaKidoku) {\n            this.data.kidoku[fn] = Object.assign({}, this.hAreaKidoku[fn].hAreas);\n        }\n        this.flush();\n    }\n    copybookmark(hArg) {\n        if (!('from' in hArg))\n            throw 'fromは必須です';\n        if (!('to' in hArg))\n            throw 'toは必須です';\n        const from = Number(hArg.from);\n        const to = Number(hArg.to);\n        if (from != to)\n            this.setMark(to, Object.assign({}, this.data.mark[from]));\n        return false;\n    }\n    erasebookmark(hArg) {\n        const place = hArg.place;\n        if (!place)\n            throw 'placeは必須です';\n        delete this.data.mark[place];\n        this.flush();\n        return false;\n    }\n    let(hArg) {\n        if (!hArg.name)\n            throw 'nameは必須です';\n        let autocast = true;\n        if (hArg.cast) {\n            switch (hArg.cast) {\n                case 'num':\n                    CmnLib_1.CmnLib.argChk_Num(hArg, 'text', NaN);\n                    break;\n                case 'int':\n                    hArg.text = String(CmnLib_1.int(CmnLib_1.CmnLib.argChk_Num(hArg, 'text', NaN)));\n                    break;\n                case 'uint':\n                    hArg.text = String(CmnLib_1.uint(CmnLib_1.CmnLib.argChk_Num(hArg, 'text', NaN)));\n                    break;\n                case 'bool':\n                    CmnLib_1.CmnLib.argChk_Boolean(hArg, 'text', false);\n                    break;\n                case 'str':\n                    autocast = false;\n                    break;\n                default:\n                    throw 'cast【' + hArg.cast + '】は未定義です';\n            }\n        }\n        this.setVal(hArg.name, hArg.text, autocast);\n        return false;\n    }\n    let_abs(hArg) {\n        const n = CmnLib_1.CmnLib.argChk_Num(hArg, 'text', 0);\n        hArg.text = String((n < 0) ? -n : n);\n        this.let(hArg);\n        return false;\n    }\n    let_char_at(hArg) {\n        var _a;\n        hArg.text = (_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).charAt(CmnLib_1.CmnLib.argChk_Num(hArg, 'pos', 0));\n        this.let(hArg);\n        return false;\n    }\n    let_index_of(hArg) {\n        var _a;\n        const val = hArg.val;\n        if (!val)\n            throw 'valは必須です';\n        const start = CmnLib_1.CmnLib.argChk_Num(hArg, 'start', 0);\n        hArg.text = String((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).indexOf(val, start));\n        this.let(hArg);\n        return false;\n    }\n    let_length(hArg) {\n        var _a;\n        hArg.text = String((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).length);\n        this.let(hArg);\n        return false;\n    }\n    let_replace(hArg) {\n        var _a;\n        if (!hArg.reg)\n            throw 'regは必須です';\n        const flags = hArg.flags;\n        const reg = (!flags)\n            ? new RegExp(hArg.reg)\n            : new RegExp(hArg.reg, flags);\n        hArg.text = String((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : ''))).replace(reg, String(hArg.val));\n        this.let(hArg);\n        return false;\n    }\n    let_round(hArg) {\n        const n = CmnLib_1.CmnLib.argChk_Num(hArg, 'text', 0);\n        hArg.text = String(Math.round(n));\n        this.let(hArg);\n        return false;\n    }\n    let_search(hArg) {\n        var _a;\n        if (!hArg.reg)\n            throw 'regは必須です';\n        const flags = hArg.flags;\n        const reg = (!flags)\n            ? new RegExp(hArg.reg)\n            : new RegExp(hArg.reg, flags);\n        hArg.text = String((_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).search(reg));\n        this.let(hArg);\n        return false;\n    }\n    let_substr(hArg) {\n        var _a, _b;\n        const i = CmnLib_1.CmnLib.argChk_Num(hArg, 'pos', 0);\n        hArg.text = (hArg.len != 'all')\n            ? (_a = hArg.text, (_a !== null && _a !== void 0 ? _a : '')).substr(i, CmnLib_1.int(CmnLib_1.CmnLib.argChk_Num(hArg, 'len', 1)))\n            : (_b = hArg.text, (_b !== null && _b !== void 0 ? _b : '')).substr(i);\n        this.let(hArg);\n        return false;\n    }\n    clearsysvar() {\n        var _a, _b;\n        const sys = this.hSys = this.hScope['sys'] = this.data.sys = {};\n        const is_nw = (typeof process !== 'undefined');\n        if (is_nw) {\n        }\n        else {\n            this.setVal_Nochk('sys', 'const.sn.window.x', 0);\n            this.setVal_Nochk('sys', 'const.sn.window.y', 0);\n        }\n        this.setVal_Nochk('sys', 'sn.tagCh.doWait', true);\n        this.setVal_Nochk('sys', 'sn.tagCh.doWait_Kidoku', true);\n        this.setVal_Nochk('sys', 'sn.tagCh.msecWait', this.cfg.oCfg.init.tagch_msecwait);\n        this.setVal_Nochk('sys', 'sn.tagCh.msecWait_Kidoku', this.cfg.oCfg.init.tagch_msecwait);\n        this.setVal_Nochk('sys', 'sn.tagCh.canskip', true);\n        this.setVal_Nochk('sys', 'sn.skip.mode', 's');\n        this.setVal_Nochk('sys', 'sn.auto.msecPageWait', CmnLib_1.CmnLib.argChk_Num(sys, 'sn.auto.msecPageWait', (_a = this.cfg.oCfg.init.auto_msecpagewait, (_a !== null && _a !== void 0 ? _a : 3500))));\n        this.setVal_Nochk('sys', 'sn.auto.msecPageWait_Kidoku', CmnLib_1.CmnLib.argChk_Num(sys, 'sn.auto.msecPageWait', (_b = this.cfg.oCfg.init.auto_msecpagewait, (_b !== null && _b !== void 0 ? _b : 3500))));\n        this.setVal_Nochk('sys', 'sn.auto.msecLineWait', 500);\n        this.setVal_Nochk('sys', 'sn.auto.msecLineWait_Kidoku', 500);\n        this.setVal_Nochk('sys', 'const.sn.sound.BGM.volume', 1);\n        this.setVal_Nochk('sys', 'const.sn.sound.SE.volume', 1);\n        this.setVal_Nochk('sys', 'const.sn.sound.SYS.volume', 1);\n        for (const fn in this.data.kidoku)\n            this.data.kidoku[fn].hAreas = {};\n        this.setVal_Nochk('sys', 'TextLayer.Back.Alpha', 0.5);\n        this.hScope['mark'] = this.data.mark = {};\n        this.setVal_Nochk('sys', 'const.sn.save.place', 1);\n        this.flush();\n        return false;\n    }\n    clearvar() {\n        var _a, _b, _c;\n        const mesLayer = (_a = this.hSave['const.sn.mesLayer'], (_a !== null && _a !== void 0 ? _a : ''));\n        const doRecLog = (_b = this.hSave['sn.doRecLog'], (_b !== null && _b !== void 0 ? _b : false));\n        const sLog = (_c = this.hSave['const.sn.sLog'], (_c !== null && _c !== void 0 ? _c : ''));\n        this.hSave = this.hScope.save = {};\n        this.setVal_Nochk('save', 'const.sn.mesLayer', mesLayer);\n        this.setVal_Nochk('save', 'sn.doRecLog', doRecLog);\n        this.setVal_Nochk('save', 'const.sn.sLog', sLog);\n        return false;\n    }\n    setVal_Nochk(scope, nm, val, autocast = false) {\n        const hScope = this.hScope[scope];\n        if (autocast)\n            val = this.castAuto(val);\n        hScope[nm] = val;\n        const trg = this.hValTrg[scope + ':' + nm];\n        if (trg != null)\n            trg(nm, val);\n    }\n    castAuto(val) {\n        const s_val = val;\n        if (s_val == 'true')\n            return true;\n        if (s_val == 'false')\n            return false;\n        if (s_val == 'null')\n            return null;\n        if (s_val == 'undefined')\n            return undefined;\n        this.REG_NUMERICLITERAL.lastIndex = 0;\n        if (this.REG_NUMERICLITERAL.test(s_val))\n            return parseFloat(s_val);\n        return val;\n    }\n    doRecLog() { return this.$doRecLog; }\n    defValTrg(name, fnc) { this.hValTrg[name] = fnc; }\n    runFirst_Bool_hSysVal_true(name) {\n        CmnLib_1.CmnLib.argChk_Boolean(this.hSys, name, true);\n    }\n    runFirst_sys_an_tagCh_msecWait(name) {\n        CmnLib_1.CmnLib.argChk_Num(this.hSys, name, 10);\n        if (this.hSys['sn.tagCh.doWait']) {\n        }\n    }\n    runFirst_sys_an_tagCh_msecWait_Kidoku(name) {\n        CmnLib_1.CmnLib.argChk_Num(this.hSys, name, (this.cfg.oCfg.init.tagch_msecwait == undefined)\n            ? 10\n            : this.cfg.oCfg.init.tagch_msecwait);\n        if (this.hSys['sn.tagCh.doWait_Kidoku']) {\n        }\n    }\n    runFirst_sys_an_auto_msecPageWait(name) {\n        CmnLib_1.CmnLib.argChk_Num(this.hSys, name, (this.cfg.oCfg.init.auto_msecpagewait == undefined)\n            ? 3500\n            : this.cfg.oCfg.init.auto_msecpagewait);\n    }\n    runFirst_sys_an_auto_msecLineWait(name) {\n        CmnLib_1.CmnLib.argChk_Num(this.hSys, name, 500);\n    }\n    runFirst_Bool_hSaveVal_true(name) {\n        return CmnLib_1.CmnLib.argChk_Boolean(this.hSave, name, true);\n    }\n    runFirst_Bool_hTmp_true(name) {\n        CmnLib_1.CmnLib.argChk_Boolean(this.hTmp, name, true);\n    }\n    runFirst_Bool_hTmp_false(name) {\n        CmnLib_1.CmnLib.argChk_Boolean(this.hTmp, name, false);\n    }\n}\nexports.Variable = Variable;\n;\n//# sourceMappingURL=Variable.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../sn_gallery/node_modules/process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../npm_core/core/lib/sn/Variable.js?")},"./core/plugin sync recursive ^\\.\\/.*\\/index\\.js$":
/*!**********************************************!*\
  !*** ./core/plugin sync ^\.\/.*\/index\.js$ ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('var map = {\n\t"./3d_layer/index.js": "./core/plugin/3d_layer/index.js",\n\t"./cubism3_layer/index.js": "./core/plugin/cubism3_layer/index.js",\n\t"./emote_layer/index.js": "./core/plugin/emote_layer/index.js"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = "./core/plugin sync recursive ^\\\\.\\\\/.*\\\\/index\\\\.js$";\n\n//# sourceURL=webpack:///./core/plugin_sync_^\\.\\/.*\\/index\\.js$?')},"./core/plugin.js":
/*!************************!*\
  !*** ./core/plugin.js ***!
  \************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ({"3d_layer":0,"cubism3_layer":0,"emote_layer":0});\n\n//# sourceURL=webpack:///./core/plugin.js?')},"./core/plugin/3d_layer/ThreeDLayer.js":
/*!*********************************************!*\
  !*** ./core/plugin/3d_layer/ThreeDLayer.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Layer_1 = __webpack_require__(/*! skynovel/core/lib/sn/Layer */ \"../npm_core/core/lib/sn/Layer.js\");\nconst Layer = Layer_1.Layer;\nconst CmnLib_1 = __webpack_require__(/*! skynovel/core/lib/sn/CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnLib = CmnLib_1.CmnLib;\nconst three_1 = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\nconst EXT_STILL_IMG = 'png_|jpg_|jpeg_|svg_|png|jpg|jpeg|svg';\nclass ThreeDLayer extends Layer {\n    constructor() {\n        super();\n        this.tick = () => {\n            if (!this.running)\n                return;\n            this.canvas_3D.render(this.scene_3D, this.camera);\n            this.sprite_3D.texture.update();\n            this.fncCtrl();\n            this.fncMixerUpd();\n            requestAnimationFrame(this.tick);\n        };\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.clock = new three_1.Clock();\n        this.hInf = {};\n        this.record = () => Object.assign(super.record(), {\n            type: this.type,\n        });\n        if (ThreeDLayer.uniq_num++ % 2 == 1)\n            return;\n        this.scene_3D = new three_1.Scene();\n        const log = console.log;\n        console.log = () => { };\n        this.canvas_3D = new three_1.WebGLRenderer({ antialias: true, alpha: true });\n        console.log = log;\n        this.canvas_3D.setSize(CmnLib.stageW, CmnLib.stageH);\n        this.canvas_3D.setPixelRatio(window.devicePixelRatio);\n        const texture_3D = pixi_js_1.Texture.from(this.canvas_3D.domElement);\n        this.sprite_3D = new pixi_js_1.Sprite(texture_3D);\n        this.cnt.addChild(this.sprite_3D);\n        this.sprite_3D.x = (CmnLib.stageW - this.sprite_3D.width) / 2;\n        this.sprite_3D.y = (CmnLib.stageH - this.sprite_3D.height) / 2;\n    }\n    lay(hArg) {\n        if (!this.scene_3D)\n            return false;\n        if ('grid' in hArg) {\n            const grid = new three_1.GridHelper(CmnLib.argChk_Num(hArg, 'grid_size', 10), CmnLib.argChk_Num(hArg, 'grid_step', 5));\n            this.csv2pos(hArg, 'grid', grid);\n            grid.name = '_grid';\n            this.scene_3D.add(grid);\n        }\n        if ('camera' in hArg) {\n            if (!this.camera) {\n                this.camera = new three_1.PerspectiveCamera(CmnLib.argChk_Num(hArg, 'camera_fov', 50), CmnLib.stageW / CmnLib.stageH, CmnLib.argChk_Num(hArg, 'camera_near', 0.1), CmnLib.argChk_Num(hArg, 'camera_far', 2000));\n            }\n            this.csv2pos(hArg, 'camera', this.camera);\n        }\n        if ('directional_light' in hArg) {\n            const light = new three_1.DirectionalLight(0xFFFFFF);\n            light.intensity = CmnLib.argChk_Num(hArg, 'intensity', 1);\n            this.csv2pos(hArg, 'directional_light', light);\n            light.name = '_light';\n            this.scene_3D.add(light);\n        }\n        if ('controls' in hArg) {\n            const elm = document.getElementById('skynovel');\n            __webpack_require__(/*! three/examples/js/controls/OrbitControls */ \"./node_modules/three/examples/js/controls/OrbitControls.js\");\n            const controls = new ThreeDLayer.THREE.OrbitControls(this.camera, elm);\n            controls.target.set(this.camera.position.x + 0.15, this.camera.position.y, this.camera.position.z);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.2;\n            controls.rotateSpeed = 0.1;\n            controls.zoomSpeed = 2;\n            this.fncCtrl = () => controls.update();\n        }\n        const type = hArg.type;\n        const name = hArg.name || '';\n        let mdl = new three_1.Mesh();\n        if (type) {\n            if (name in this.hInf)\n                throw `name（=${name}）が重複しています`;\n            if (!this.running) {\n                this.running = true;\n                this.tick();\n            }\n            if (type == 'box') {\n                const size = CmnLib.argChk_Num(hArg, 'size', 100);\n                const geometry = new three_1.BoxGeometry(size, size, size);\n                const material = new three_1.MeshNormalMaterial();\n                mdl = new three_1.Mesh(geometry, material);\n                mdl.rotation.z = -45;\n                this.fncCtrl = () => {\n                    this.scene_3D.children.map(o => {\n                        const m = o;\n                        if (!m)\n                            return;\n                        m.rotation.x += 0.01;\n                        m.rotation.y += 0.01;\n                        m.rotation.z += 0.01;\n                    });\n                };\n                this.hInf[name] = { type: type, fn: '' };\n                mdl.name = name;\n                this.scene_3D.add(mdl);\n                return false;\n            }\n            const fn = hArg.fn;\n            if (!fn)\n                throw 'fnは必須です';\n            switch (type) {\n                case 'celestial_sphere':\n                    {\n                        const geometry = new three_1.SphereGeometry(5, 60, 40);\n                        geometry.scale(-1, 1, 1);\n                        const ldr = new three_1.TextureLoader();\n                        if (!fn)\n                            throw 'fnがありません';\n                        const tx = ldr.load(ThreeDLayer.plgArg.searchPath(fn, EXT_STILL_IMG));\n                        tx.minFilter = three_1.LinearFilter;\n                        const material = new three_1.MeshBasicMaterial({ map: tx });\n                        mdl = new three_1.Mesh(geometry, material);\n                        this.camera.lookAt(mdl.position);\n                        this.fncCtrl = () => { mdl.rotation.y += 0.001; };\n                    }\n                    break;\n                case 'gltf':\n                    {\n                        if (!fn)\n                            throw 'fnがありません';\n                        const onProgress = ('debug' in hArg)\n                            ? (xhr) => console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`)\n                            : () => { };\n                        __webpack_require__(/*! three/examples/js/loaders/GLTFLoader */ \"./node_modules/three/examples/js/loaders/GLTFLoader.js\");\n                        (new ThreeDLayer.THREE.GLTFLoader()).load(ThreeDLayer.plgArg.searchPath(fn, 'gltf|glb'), (gltf) => {\n                            const mdl = gltf.scene;\n                            mdl.name = name;\n                            this.scene_3D.add(mdl);\n                            this.hInf[name] = { type: type, fn: fn, gltf: gltf };\n                            this.arg2mdl(hArg, mdl);\n                        }, onProgress, (err) => console.error('An error happened', err));\n                    }\n                    return false;\n                case 'fbx':\n                    {\n                    }\n                    break;\n                case 'dae':\n                    {\n                    }\n                    break;\n                default:\n                    throw `サポートしない type=${type} です`;\n            }\n            this.hInf[name] = { type: type, fn: fn };\n            mdl.name = name;\n            this.scene_3D.add(mdl);\n        }\n        else if ('del' in hArg) {\n            const del = hArg['del'];\n            const mdl2 = this.scene_3D.children.find(e => e.name === del);\n            if (!mdl2)\n                throw `３Ｄレイヤに存在しないモデル name=${del} です`;\n            this.clearObject3D(mdl2);\n            delete this.hInf[del];\n            return false;\n        }\n        else if ('name' in hArg) {\n            const mdl2 = this.scene_3D.children.find(e => e.name === name);\n            if (!mdl2)\n                throw `３Ｄレイヤに存在しないモデル name=${name} です`;\n            mdl = mdl2;\n        }\n        else\n            return false;\n        this.arg2mdl(hArg, mdl);\n        return false;\n    }\n    arg2mdl(hArg, o) {\n        var _a;\n        this.csv2pos(hArg, 'pos', o);\n        this.csv2scale(hArg, 'scale', o);\n        const inf = this.hInf[o.name];\n        if (!inf)\n            return;\n        if ('label' in hArg) {\n            inf.label = hArg['label'];\n            if (inf.gltf) {\n                const ac = three_1.AnimationClip.findByName(inf.gltf.animations, (_a = inf.label, (_a !== null && _a !== void 0 ? _a : '')));\n                if (!ac) {\n                    console.info(`エラーが発生しました。参考までに ${inf.fn}(glTF)内に存在するアニメ名を列挙します`);\n                    const a = inf.gltf.animations;\n                    a.map(v => console.info(`  label=${v.name}`));\n                    throw `${inf.fn}(glTF)内に存在しないアニメ（label=${inf.label}）です`;\n                }\n                if (inf.mixer) {\n                    const t = CmnLib.argChk_Num(hArg, 'time', 1000) / 1000;\n                    const aa = inf.mixer.clipAction(ac);\n                    aa.crossFadeFrom(inf.aa, t, true);\n                    inf.aa = aa;\n                }\n                else {\n                    inf.mixer = new three_1.AnimationMixer(o);\n                    inf.aa = inf.mixer.clipAction(ac);\n                    this.fncMixerUpd = () => {\n                        this.scene_3D.children.map(v => {\n                            const inf2 = this.hInf[v.name];\n                            if (inf2)\n                                inf2.mixer.update(this.clock.getDelta());\n                        });\n                    };\n                }\n                inf.aa.enabled = true;\n                inf.aa.clampWhenFinished = true;\n                inf.aa.loop = CmnLib.argChk_Boolean(hArg, 'loop', true)\n                    ? three_1.LoopRepeat\n                    : three_1.LoopOnce;\n                inf.aa.play();\n            }\n        }\n    }\n    csv2pos(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const p = String(hArg[name]).split(',').map(v => Number(v));\n        o.position.set(p[0], p[1], p[2]);\n    }\n    csv2scale(hArg, name, o) {\n        if (!(name in hArg))\n            return;\n        const p = String(hArg[name]).split(',').map(v => Number(v));\n        o.scale.set(p[0], p[1], p[2]);\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (!this.scene_3D)\n            return;\n        if (!this.running)\n            return;\n        this.running = false;\n        this.fncCtrl = () => { };\n        this.fncMixerUpd = () => { };\n        this.hInf = {};\n        this.clearScene(this.scene_3D);\n        this.canvas_3D.clear();\n        this.sprite_3D.texture.update();\n        delete this.camera;\n    }\n    clearScene(sc) {\n        sc.children.slice().map(o => this.clearObject3D(o));\n    }\n    clearObject3D(o) {\n        o.parent.remove(o);\n        const s = o;\n        if (s) {\n            const inf = this.hInf[s.name];\n            if (inf && inf.mixer)\n                inf.mixer.stopAllAction();\n            this.clearScene(s);\n            return;\n        }\n        const m = o;\n        if (!m)\n            return;\n        m.geometry.dispose();\n        if (m.material instanceof three_1.Material) {\n            m.material.dispose();\n            if (m.material)\n                delete m.material;\n        }\n        else {\n            m.material.map(v => v.dispose());\n        }\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        if (fncComp != undefined)\n            fncComp();\n        if (!this.scene_3D)\n            return false;\n        return false;\n    }\n    dump() {\n        if (!this.scene_3D)\n            return `\"is\":\"nothing\"`;\n        const aChi = [];\n        this.scene_3D.children.map(o => {\n            let s = `\"${o.name}\": {\"type\":\"${o.type}\"`;\n            const inf = this.hInf[o.name];\n            if (inf && inf.mixer)\n                s += `, \"label\":\"${inf.label}\"`;\n            aChi.push(s + `}`);\n        });\n        return super.dump() + `, \"mdl\":{${aChi.join(',')}}`;\n    }\n    ;\n}\nexports.ThreeDLayer = ThreeDLayer;\nThreeDLayer.uniq_num = 0;\n//# sourceMappingURL=ThreeDLayer.js.map\n\n//# sourceURL=webpack:///./core/plugin/3d_layer/ThreeDLayer.js?")},"./core/plugin/3d_layer/index.js":
/*!***************************************!*\
  !*** ./core/plugin/3d_layer/index.js ***!
  \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst ThreeDLayer_1 = __webpack_require__(/*! ./ThreeDLayer */ "./core/plugin/3d_layer/ThreeDLayer.js");\nexports.init = (plgArg) => {\n    ThreeDLayer_1.ThreeDLayer.plgArg = plgArg;\n    (async () => {\n        ThreeDLayer_1.ThreeDLayer.THREE = await Promise.resolve().then(() => __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js"));\n        window.THREE = ThreeDLayer_1.ThreeDLayer.THREE;\n        plgArg.addLayCls(\'3d\', () => { const l = new ThreeDLayer_1.ThreeDLayer; return l; });\n    })();\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./core/plugin/3d_layer/index.js?')},"./core/plugin/cubism3_layer/Cubism3Layer.js":
/*!***************************************************!*\
  !*** ./core/plugin/cubism3_layer/Cubism3Layer.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Layer_1 = __webpack_require__(/*! skynovel/core/lib/sn/Layer */ \"../npm_core/core/lib/sn/Layer.js\");\nconst Layer = Layer_1.Layer;\nconst CmnLib_1 = __webpack_require__(/*! skynovel/core/lib/sn/CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnLib = CmnLib_1.CmnLib;\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\nclass Cubism3Layer extends Layer {\n    constructor() {\n        super(...arguments);\n        this.ldr = new pixi_js_1.Loader;\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n        this.hdl_tick = 0;\n        this.record = () => Object.assign(super.record(), this.state);\n    }\n    lay(hArg, fncComp) {\n        super.lay(hArg);\n        const id = hArg.id || '0';\n        const fn = hArg.fn;\n        if (fn) {\n            const label = hArg.label;\n            if (!label)\n                throw `label属性でモーションjsonファイル（${fn}_(label).json）を指定して下さい`;\n            let needLoad = false;\n            ['moc', 'tex', 'mot'].map((type, i) => {\n                const rn = `l2d:${fn}_${type}`;\n                if (rn in this.ldr.resources)\n                    return;\n                if (rn in pixi_js_1.utils.TextureCache)\n                    pixi_js_1.utils.TextureCache[rn].destroy(true);\n                needLoad = true;\n                if (this.ldr.loading)\n                    this.ldr = new pixi_js_1.Loader();\n                switch (i) {\n                    case 0:\n                        this.ldr.add(rn, Cubism3Layer.plgArg.searchPath(fn, 'moc3_|moc3'), { xhrType: 'arraybuffer' });\n                        break;\n                    case 1:\n                        this.ldr.add(rn, Cubism3Layer.plgArg.searchPath(fn, 'png_|png|jpg_|jpg|jpeg_|jpeg'));\n                        break;\n                    case 2:\n                        this.ldr.add(rn, Cubism3Layer.plgArg.searchPath(fn + '_' + label, 'json_|json'), { xhrType: 'json' });\n                        break;\n                }\n            });\n            const fncLoaded = (res) => {\n                const moc = Live2DCubismCore.Moc.fromArrayBuffer(res['l2d:' + fn + '_moc'].data);\n                this.model = new LIVE2DCUBISMPIXI.ModelBuilder()\n                    .setMoc(moc)\n                    .setTimeScale(1)\n                    .addTexture(0, (res['l2d:' + fn + '_tex'] || pixi_js_1.utils.TextureCache['l2d:' + fn + '_tex']).texture)\n                    .addAnimatorLayer(id, LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE, 1)\n                    .build();\n                this.cnt.addChild(this.model);\n                const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                this.model.animator\n                    .getLayer(id)\n                    .play(ani);\n                const tick = () => {\n                    this.hdl_tick = requestAnimationFrame(tick);\n                    if (this.model)\n                        this.model.update(1);\n                };\n                this.hdl_tick = requestAnimationFrame(tick);\n                const a = Object.assign({}, hArg);\n                delete a.fn;\n                delete a.label;\n                this.state.fn = fn;\n                this.state.label = label;\n                this.lay(a, fncComp);\n                Cubism3Layer.plgArg.resume(fncComp);\n            };\n            if (needLoad)\n                this.ldr.load((_loader, res) => fncLoaded(res));\n            else\n                fncLoaded(this.ldr.resources);\n            return true;\n        }\n        if (!this.state.fn)\n            return false;\n        if ('label' in hArg) {\n            const label = hArg.label || '';\n            if (this.state.label != label) {\n                this.state.label = label;\n                const fn = this.state.fn;\n                const fn_mot = Cubism3Layer.plgArg.searchPath(fn + '_' + label, 'json_|json');\n                new pixi_js_1.Loader()\n                    .add('l2d:' + fn + '_mot', fn_mot, { xhrType: 1 })\n                    .load((_loader, res) => {\n                    const ani = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(res['l2d:' + fn + '_mot'].data);\n                    this.model.animator\n                        .getLayer(id)\n                        .play(ani);\n                });\n            }\n        }\n        if ('scale' in hArg) {\n            this.state.scale = CmnLib.argChk_Num(hArg, 'scale', 1);\n            this.model.scale = new pixi_js_1.Point(this.state.scale, this.state.scale);\n            this.model.x = this.model.width / 2;\n            this.model.y = this.model.height / 2;\n        }\n        Layer.setXY(this.model, hArg, this.cnt, true);\n        return false;\n    }\n    clearLay(hArg) {\n        super.clearLay(hArg);\n        if (this.model) {\n            cancelAnimationFrame(this.hdl_tick);\n            this.cnt.removeChild(this.model);\n            this.model = null;\n        }\n        this.state = {\n            fn: '',\n            label: '',\n            scale: 1,\n        };\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        return this.lay(hLay, fncComp);\n    }\n    destroy() { this.clearLay({}); }\n}\nexports.Cubism3Layer = Cubism3Layer;\n//# sourceMappingURL=Cubism3Layer.js.map\n\n//# sourceURL=webpack:///./core/plugin/cubism3_layer/Cubism3Layer.js?")},"./core/plugin/cubism3_layer/index.js":
/*!********************************************!*\
  !*** ./core/plugin/cubism3_layer/index.js ***!
  \********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst Cubism3Layer_1 = __webpack_require__(/*! ./Cubism3Layer */ "./core/plugin/cubism3_layer/Cubism3Layer.js");\nexports.init = (plgArg) => {\n    Cubism3Layer_1.Cubism3Layer.plgArg = plgArg;\n    (async () => {\n        plgArg.addLayCls(\'cubism3\', () => { const l = new Cubism3Layer_1.Cubism3Layer; return l; });\n    })();\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./core/plugin/cubism3_layer/index.js?')},"./core/plugin/emote_layer/EmoteLayer.js":
/*!***********************************************!*\
  !*** ./core/plugin/emote_layer/EmoteLayer.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Layer_1 = __webpack_require__(/*! skynovel/core/lib/sn/Layer */ \"../npm_core/core/lib/sn/Layer.js\");\nconst Layer = Layer_1.Layer;\nconst CmnLib_1 = __webpack_require__(/*! skynovel/core/lib/sn/CmnLib */ \"../npm_core/core/lib/sn/CmnLib.js\");\nconst CmnLib = CmnLib_1.CmnLib;\nconst pixi_js_1 = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\nclass EmoteLayer extends Layer {\n    constructor() {\n        super();\n        this.sp = new pixi_js_1.Sprite;\n        this.record = () => Object.assign(super.record(), (this.inf)\n            ? {\n                fn: this.inf.fn,\n                label: this.inf.player.mainTimelineLabel,\n                scale: this.inf.player.scale,\n                grayscale: this.inf.player.grayscale,\n                windSpeed: this.inf.player.windSpeed,\n                windPowerMin: this.inf.player.windPowerMin,\n                windPowerMax: this.inf.player.windPowerMax,\n            }\n            : { fn: '' });\n        if (EmoteLayer.uniq_num++ % 2 == 1)\n            return;\n        if (EmoteLayer.uniq_num == 1) {\n            switch (String(EmoteLayer.plgArg.getVal('const.sn.platform.os.family'))) {\n                case 'Android':\n                case 'iOS':\n                    EmotePlayer.maskMode = EmotePlayer.MaskMode.STENCIL;\n                    break;\n            }\n            EmotePlayer.createRenderCanvas(CmnLib.stageW, CmnLib.stageH);\n        }\n        this.rt = pixi_js_1.RenderTexture.create({ width: CmnLib.stageW, height: CmnLib.stageH });\n        this.cnt.addChild(new pixi_js_1.Sprite(this.rt));\n        this.cvs = document.createElement('canvas');\n        this.cvs.id = `emote:${EmoteLayer.uniq_num}`;\n        this.cvs.width = CmnLib.stageW;\n        this.cvs.height = CmnLib.stageH;\n        this.cvs.hidden = true;\n        const cvsSN = document.getElementById('skynovel');\n        cvsSN.parentElement.appendChild(this.cvs);\n        this.sp.width = CmnLib.stageW;\n        this.sp.height = CmnLib.stageH;\n    }\n    lay(hArg, fncComp) {\n        if (!this.rt)\n            return false;\n        const layer = hArg.layer;\n        if (!layer) {\n            if (hArg['タグ名'] == 'add_lay')\n                return false;\n            throw `layerは必須です`;\n        }\n        super.lay(hArg);\n        if (hArg.fn) {\n            const fn = hArg.fn;\n            const player = new EmotePlayer(this.cvs);\n            this.inf = {\n                fn: fn,\n                player: player,\n            };\n            const a = Object.assign({}, hArg);\n            delete a.fn;\n            a['タグ名'] = 'lay';\n            player.onUpdate = () => {\n                if (!player)\n                    return;\n                this.sp.texture.destroy();\n                this.sp.texture = new pixi_js_1.Texture(new pixi_js_1.BaseTexture(this.cvs));\n                EmoteLayer.plgArg.render(this.sp, this.rt, true);\n            };\n            player.promiseLoadDataFromURL(EmoteLayer.plgArg.searchPath(fn, 'emtbytes_|emtbytes'))\n                .then(() => {\n                this.lay(a, fncComp);\n                EmoteLayer.plgArg.resume(fncComp);\n            });\n            return true;\n        }\n        else if (hArg['タグ名'] == 'add_lay')\n            return false;\n        if (!this.inf)\n            return false;\n        Layer.setXY(this.sp, hArg, this.cnt, true);\n        const player = this.inf.player;\n        if (hArg.label) {\n            const a = player.mainTimelineLabels;\n            if (!a.includes(hArg.label)) {\n                console.info(`エラーが発生しました。参考までに ${this.inf.fn}.emtbytes 内に存在するアニメ名を列挙します`);\n                a.map(v => console.info(`  label=${v}`));\n                throw `${this.inf.fn}.emtbytes 内に存在しないアニメ（label=${hArg.label}）です`;\n            }\n            player.mainTimelineLabel = hArg.label;\n        }\n        if ('scale' in hArg)\n            player.scale = CmnLib.argChk_Num(hArg, 'scale', 1);\n        if ('grayscale' in hArg)\n            player.grayscale = CmnLib.argChk_Num(hArg, 'grayscale', 1);\n        if ('windSpeed' in hArg)\n            player.windSpeed = CmnLib.argChk_Num(hArg, 'windSpeed', 0);\n        if ('windPowerMin' in hArg)\n            player.windPowerMin = CmnLib.argChk_Num(hArg, 'windPowerMin', 0);\n        if ('windPowerMax' in hArg)\n            player.windPowerMax = CmnLib.argChk_Num(hArg, 'windPowerMax', 0);\n        return false;\n    }\n    clearLay(hArg) {\n        if (!this.rt)\n            return;\n        super.clearLay(hArg);\n        if (!this.inf)\n            return;\n        this.inf.player.onUpdate = () => { };\n        this.inf.player.unloadData();\n        this.inf = null;\n        this.sp.visible = false;\n        EmoteLayer.plgArg.render(this.sp, this.rt, true);\n        this.sp.visible = true;\n    }\n    playback(hLay, fncComp = undefined) {\n        super.playback(hLay);\n        if (hLay.fn)\n            return this.lay(hLay, fncComp);\n        this.clearLay(hLay);\n        return false;\n    }\n    dump() {\n        if (!this.rt)\n            return `\"is\":\"nothing\"`;\n        return super.dump() + ((this.inf)\n            ? `, \"mdl\":{\"fn\":\"${this.inf.fn}\",\"label\":\"${this.inf.player.mainTimelineLabel}\",\"scale\":\"${this.inf.player.scale}\"}`\n            : `, \"mdl\":{\"fn\":\"\"}`);\n    }\n    ;\n    destroy() {\n        if (!this.rt)\n            return;\n        this.clearLay({});\n        this.cvs.parentElement.removeChild(this.cvs);\n        this.cnt.removeChildren().map((v) => v.destroy());\n    }\n}\nexports.EmoteLayer = EmoteLayer;\nEmoteLayer.uniq_num = 0;\n//# sourceMappingURL=EmoteLayer.js.map\n\n//# sourceURL=webpack:///./core/plugin/emote_layer/EmoteLayer.js?")},"./core/plugin/emote_layer/index.js":
/*!******************************************!*\
  !*** ./core/plugin/emote_layer/index.js ***!
  \******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst EmoteLayer_1 = __webpack_require__(/*! ./EmoteLayer */ "./core/plugin/emote_layer/EmoteLayer.js");\nexports.init = (plgArg) => {\n    EmoteLayer_1.EmoteLayer.plgArg = plgArg;\n    (async () => {\n        plgArg.addLayCls(\'emote\', () => { const l = new EmoteLayer_1.EmoteLayer; return l; });\n    })();\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./core/plugin/emote_layer/index.js?')},"./core/web4webpack.js":
/*!*****************************!*\
  !*** ./core/web4webpack.js ***!
  \*****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("//@ts-check\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst hPlg = {};\nconst h = __webpack_require__(/*! ./plugin.js */ \"./core/plugin.js\").default;\nfor (const nm in h) hPlg[nm] = __webpack_require__(\"./core/plugin sync recursive ^\\\\.\\\\/.*\\\\/index\\\\.js$\")(`./${nm}/index.js`);\n\nconst {SysWeb} = __webpack_require__(/*! skynovel/core/lib/sn/SysWeb */ \"../npm_core/core/lib/sn/SysWeb.js\");\n//@ts-ignore\nconst sys = new SysWeb(hPlg, {cur: 'prj/top/', dip: '{\"expanding\": false}'});\n//const sys = new SysWeb(hPlg, {cur: 'prj/top/'});\nglobalThis.runSN = (cur = 'top')=> sys.run(cur);\nglobalThis.stopSN = ()=> sys.stop();\n\n\n/*\nconst init = async ()=> {\n\tconst hPlg = {};\n//\tconst h = require('./plugin.js').default;\n\tconst {default: h} = await import('./plugin.js');\n//\tfor (const nm in h) hPlg[nm] = require(`./plugin/${nm}/index.js`);\n\tfor (const nm in h) {\n//\t\thPlg[nm] = require(`./plugin/${nm}/index.js`);\n\t\thPlg[nm] = await import(`./plugin/${nm}/index.js`);\n\t}\n\n\tconst {SysWeb} = require('skynovel/core/lib/sn/SysWeb');\n//\tconst {SysWeb} = await import('skynovel/core/lib/sn/SysWeb');\n\tconst sys = new SysWeb(hPlg, {cur: 'prj/top/', dip: '{\"expanding\": false}'});\n\t//const sys = new SysWeb_1.SysWeb(hPlg, {cur: 'prj/top/'});\n\twindow.runSN = (cur = 'top')=> sys.run(cur);\n\twindow.stopSN = ()=> sys.stop();\n\nconsole.log(`fn:web4webpack.js line:32 Ok.`);\n};\ninit();\n*/\n\n\n//# sourceURL=webpack:///./core/web4webpack.js?")}});